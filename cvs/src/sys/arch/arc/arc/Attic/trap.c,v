head	1.26;
access;
symbols
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	UBC_SYNC_A:1.26
	UBC_SYNC_B:1.26
	NIKLAS_UNDEAD:1.25.0.2
	OPENBSD_2_8:1.24.0.2
	OPENBSD_2_8_BASE:1.24
	OPENBSD_2_7:1.23.0.4
	OPENBSD_2_7_BASE:1.23
	SMP:1.23.0.2
	SMP_BASE:1.23
	kame_19991208:1.23
	OPENBSD_2_6:1.22.0.2
	OPENBSD_2_6_BASE:1.22
	OPENBSD_2_5:1.21.0.2
	OPENBSD_2_5_BASE:1.21
	OPENBSD_2_4:1.20.0.2
	OPENBSD_2_4_BASE:1.20
	OPENBSD_2_3:1.17.0.2
	OPENBSD_2_3_BASE:1.17
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	PEFO_960624:1.1.1.1
	PEFO:1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2001.02.07.07.45.00;	author art;	state dead;
branches;
next	1.25;

1.25
date	2000.11.10.18.15.36;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.08.10.31.15;	author art;	state Exp;
branches;
next	1.23;

1.23
date	99.12.08.06.50.15;	author itojun;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	99.05.24.23.08.59;	author jason;	state Exp;
branches;
next	1.21;

1.21
date	99.01.07.23.15.55;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	98.10.15.21.30.00;	author imp;	state Exp;
branches;
next	1.19;

1.19
date	98.09.30.12.40.41;	author pefo;	state Exp;
branches;
next	1.18;

1.18
date	98.09.15.10.58.54;	author pefo;	state Exp;
branches;
next	1.17;

1.17
date	98.03.25.11.51.36;	author pefo;	state Exp;
branches;
next	1.16;

1.16
date	98.03.16.09.38.33;	author pefo;	state Exp;
branches;
next	1.15;

1.15
date	98.03.01.18.58.30;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	98.03.01.16.55.00;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	98.01.28.13.46.00;	author pefo;	state Exp;
branches;
next	1.12;

1.12
date	97.07.23.07.00.39;	author denny;	state Exp;
branches;
next	1.11;

1.11
date	97.04.19.17.19.48;	author pefo;	state Exp;
branches;
next	1.10;

1.10
date	97.03.12.19.16.47;	author pefo;	state Exp;
branches;
next	1.9;

1.9
date	97.02.04.17.26.14;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.02.02.00.47.43;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.01.28.03.54.53;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.09.14.15.58.18;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	96.09.02.11.33.24;	author pefo;	state Exp;
branches;
next	1.4;

1.4
date	96.08.26.11.11.56;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	96.07.30.20.24.18;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	96.07.16.07.46.14;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	96.06.24.09.07.21;	author pefo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.06.24.09.07.21;	author pefo;	state Exp;
branches;
next	;

1.23.2.1
date	2001.04.18.16.02.31;	author niklas;	state dead;
branches;
next	;


desc
@@


1.26
log
@We need to loose some weight.
If someone feels very opposed to this, the code is left in the Attic.
Just revive and _make_it_work_.
@
text
@/*	$OpenBSD: trap.c,v 1.25 2000/11/10 18:15:36 art Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department and Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah Hdr: trap.c 1.32 91/04/06
 *
 *	from: @@(#)trap.c	8.5 (Berkeley) 1/11/94
 */

#include "ppp.h"
#include "bridge.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/kernel.h>
#include <sys/signalvar.h>
#include <sys/syscall.h>
#include <sys/user.h>
#include <sys/buf.h>
#include <sys/device.h>
#ifdef KTRACE
#include <sys/ktrace.h>
#endif
#include <net/netisr.h>
#include <miscfs/procfs/procfs.h>

#include <machine/trap.h>
#include <machine/psl.h>
#include <machine/reg.h>
#include <machine/cpu.h>
#include <machine/pio.h>
#include <machine/intr.h>
#include <machine/autoconf.h>
#include <machine/pte.h>
#include <machine/pmap.h>
#include <machine/mips_opcode.h>
#include <machine/frame.h>

#include <vm/vm.h>
#include <vm/vm_kern.h>
#include <vm/vm_page.h>

#include <arc/pica/pica.h>
#include <mips/archtype.h>

#ifdef DDB
#include <mips/db_machdep.h>
#include <ddb/db_sym.h>
#endif

#include <sys/cdefs.h>
#include <sys/syslog.h>

struct	proc *machFPCurProcPtr;		/* pointer to last proc to use FP */

extern void MipsKernGenException __P((void));
extern void MipsUserGenException __P((void));
extern void MipsKernIntr __P((void));
extern void MipsUserIntr __P((void));
extern void MipsTLBModException __P((void));
extern void MipsTLBInvalidException __P((void));

void (*machExceptionTable[])(void) = {
/*
 * The kernel exception handlers.
 */
	MipsKernIntr,			/* external interrupt */
	MipsKernGenException,		/* TLB modification */
	MipsTLBInvalidException,	/* TLB miss (load or instr. fetch) */
	MipsTLBInvalidException,	/* TLB miss (store) */
	MipsKernGenException,		/* address error (load or I-fetch) */
	MipsKernGenException,		/* address error (store) */
	MipsKernGenException,		/* bus error (I-fetch) */
	MipsKernGenException,		/* bus error (load or store) */
	MipsKernGenException,		/* system call */
	MipsKernGenException,		/* breakpoint */
	MipsKernGenException,		/* reserved instruction */
	MipsKernGenException,		/* coprocessor unusable */
	MipsKernGenException,		/* arithmetic overflow */
	MipsKernGenException,		/* trap exception */
	MipsKernGenException,		/* viritual coherence exception inst */
	MipsKernGenException,		/* floating point exception */
	MipsKernGenException,		/* reserved */
	MipsKernGenException,		/* reserved */
	MipsKernGenException,		/* reserved */
	MipsKernGenException,		/* reserved */
	MipsKernGenException,		/* reserved */
	MipsKernGenException,		/* reserved */
	MipsKernGenException,		/* reserved */
	MipsKernGenException,		/* watch exception */
	MipsKernGenException,		/* reserved */
	MipsKernGenException,		/* reserved */
	MipsKernGenException,		/* reserved */
	MipsKernGenException,		/* reserved */
	MipsKernGenException,		/* reserved */
	MipsKernGenException,		/* reserved */
	MipsKernGenException,		/* reserved */
	MipsKernGenException,		/* viritual coherence exception data */
/*
 * The user exception handlers.
 */
	MipsUserIntr,			/*  0 */
	MipsUserGenException,		/*  1 */
	MipsUserGenException,		/*  2 */
	MipsUserGenException,		/*  3 */
	MipsUserGenException,		/*  4 */
	MipsUserGenException,		/*  5 */
	MipsUserGenException,		/*  6 */
	MipsUserGenException,		/*  7 */
	MipsUserGenException,		/*  8 */
	MipsUserGenException,		/*  9 */
	MipsUserGenException,		/* 10 */
	MipsUserGenException,		/* 11 */
	MipsUserGenException,		/* 12 */
	MipsUserGenException,		/* 13 */
	MipsUserGenException,		/* 14 */
	MipsUserGenException,		/* 15 */
	MipsUserGenException,		/* 16 */
	MipsUserGenException,		/* 17 */
	MipsUserGenException,		/* 18 */
	MipsUserGenException,		/* 19 */
	MipsUserGenException,		/* 20 */
	MipsUserGenException,		/* 21 */
	MipsUserGenException,		/* 22 */
	MipsUserGenException,		/* 23 */
	MipsUserGenException,		/* 24 */
	MipsUserGenException,		/* 25 */
	MipsUserGenException,		/* 26 */
	MipsUserGenException,		/* 27 */
	MipsUserGenException,		/* 28 */
	MipsUserGenException,		/* 29 */
	MipsUserGenException,		/* 20 */
	MipsUserGenException,		/* 31 */
};

char	*trap_type[] = {
	"external interrupt",
	"TLB modification",
	"TLB miss (load or instr. fetch)",
	"TLB miss (store)",
	"address error (load or I-fetch)",
	"address error (store)",
	"bus error (I-fetch)",
	"bus error (load or store)",
	"system call",
	"breakpoint",
	"reserved instruction",
	"coprocessor unusable",
	"arithmetic overflow",
	"trap",
	"viritual coherency instruction",
	"floating point",
	"reserved 16",
	"reserved 17",
	"reserved 18",
	"reserved 19",
	"reserved 20",
	"reserved 21",
	"reserved 22",
	"watch",
	"reserved 24",
	"reserved 25",
	"reserved 26",
	"reserved 27",
	"reserved 28",
	"reserved 29",
	"reserved 30",
	"viritual coherency data",
};

struct {
	int	int_mask;
	int	(*int_hand)(u_int, struct clockframe *);
} cpu_int_tab[8];

int cpu_int_mask;	/* External cpu interrupt mask */

#if defined(DDB) || defined(DEBUG)
#define TRAPSIZE	10
struct trapdebug {		/* trap history buffer for debugging */
	u_int	status;
	u_int	cause;
	u_int	vadr;
	u_int	pc;
	u_int	ra;
	u_int	sp;
	u_int	code;
} trapdebug[TRAPSIZE], *trp = trapdebug;

void trapDump __P((char *));

void stacktrace __P((int *));
void logstacktrace __P((int *));
int  kdbpeek __P((int *));
#if defined(DDB)
int  kdb_trap __P((int, db_regs_t *));
#endif

/* extern functions printed by name in stack backtraces */
extern void idle __P((void));
extern void MipsTLBMiss __P((void));
#endif	/* DDB || DEBUG */

extern const struct callback *callv;
extern u_long intrcnt[];
extern void MipsSwitchFPState __P((struct proc *, int *));
extern void MipsFPTrap __P((u_int, u_int, u_int));

u_int trap __P((u_int, u_int, u_int, u_int, struct trap_frame));
void interrupt __P((u_int, u_int, u_int, u_int, u_int));
void softintr __P((u_int, u_int));
int cpu_singlestep __P((struct proc *));
u_int MipsEmulateBranch __P((int *, int, int, u_int));

/*
 * Handle an exception.
 * Called from MipsKernGenException() or MipsUserGenException()
 * when a processor trap occurs.
 * In the case of a kernel trap, we return the pc where to resume if
 * ((struct pcb *)UADDR)->pcb_onfault is set, otherwise, return old pc.
 */
u_int
trap(statusReg, causeReg, vadr, pc, f)
	u_int statusReg;	/* status register at time of the exception */
	u_int causeReg;		/* cause register at time of exception */
	u_int vadr;		/* address (if any) the fault occured on */
	u_int pc;		/* program counter where to continue */
	struct trap_frame f;
{
	int type, i;
	unsigned ucode = 0;
	struct proc *p = curproc;
	u_quad_t sticks;
	vm_prot_t ftype;
	extern unsigned onfault_table[];
	int typ = 0;
	union sigval sv;

#if defined(DDB) || defined(DEBUG)
	trp->status = statusReg;
	trp->cause = causeReg;
	trp->vadr = vadr;
	trp->pc = pc;
	trp->ra = !USERMODE(statusReg) ? f.reg[PC] :
		p->p_md.md_regs[RA];
	trp->sp = (int)&f;
	trp->code = 0;
	if (++trp == &trapdebug[TRAPSIZE])
		trp = trapdebug;
#endif

	type = (causeReg & CR_EXC_CODE) >> CR_EXC_CODE_SHIFT;
	if (USERMODE(statusReg)) {
		type |= T_USER;
		sticks = p->p_sticks;
	}

	/*
	 * Enable hardware interrupts if they were on before.
	 * We only respond to software interrupts when returning to user mode.
	 */
	if (statusReg & SR_INT_ENAB)
		splx((statusReg & HARD_INT_MASK) | SR_INT_ENAB);

	switch (type) {
	case T_TLB_MOD:
		/* check for kernel address */
		if ((int)vadr < 0) {
			pt_entry_t *pte;
			unsigned int entry;
			vm_offset_t pa;

			pte = kvtopte(vadr);
			entry = pte->pt_entry;
#ifdef DIAGNOSTIC
			if (!(entry & PG_V) || (entry & PG_M))
				panic("trap: ktlbmod: invalid pte");
#endif
			if (pmap_is_page_ro(pmap_kernel(), mips_trunc_page(vadr), entry)) {
				/* write to read only page in the kernel */
				ftype = VM_PROT_WRITE;
				goto kernel_fault;
			}
			entry |= PG_M;
			pte->pt_entry = entry;
			vadr &= ~PGOFSET;
			R4K_TLBUpdate(vadr, entry);
			pa = pfn_to_vad(entry);
#ifdef ATTR
			pmap_attributes[atop(pa)] |= PMAP_ATTR_MOD;
#else
			if (!IS_VM_PHYSADDR(pa))
				panic("trap: ktlbmod: unmanaged page");
			PHYS_TO_VM_PAGE(pa)->flags &= ~PG_CLEAN;
#endif
			return (pc);
		}
		/* FALLTHROUGH */

	case T_TLB_MOD+T_USER:
	    {
		pt_entry_t *pte;
		unsigned int entry;
		vm_offset_t pa;
		pmap_t pmap = p->p_vmspace->vm_map.pmap;

		if (!(pte = pmap_segmap(pmap, vadr)))
			panic("trap: utlbmod: invalid segmap");
		pte += (vadr >> PGSHIFT) & (NPTEPG - 1);
		entry = pte->pt_entry;
#ifdef DIAGNOSTIC
		if (!(entry & PG_V) || (entry & PG_M)) {
			panic("trap: utlbmod: invalid pte");
		}
#endif
		if (pmap_is_page_ro(pmap, (vm_offset_t)mips_trunc_page(vadr), entry)) {
			/* write to read only page */
			ftype = VM_PROT_WRITE;
			goto dofault;
		}
		entry |= PG_M;
		pte->pt_entry = entry;
		vadr = (vadr & ~PGOFSET) | (pmap->pm_tlbpid << VMTLB_PID_SHIFT);
		R4K_TLBUpdate(vadr, entry);
		pa = pfn_to_vad(entry);
#ifdef ATTR
		pmap_attributes[atop(pa)] |= PMAP_ATTR_MOD;
#else
		if (!IS_VM_PHYSADDR(pa)) {
			panic("trap: utlbmod: unmanaged page");
		}
		PHYS_TO_VM_PAGE(pa)->flags &= ~PG_CLEAN;
#endif
		if (!USERMODE(statusReg))
			return (pc);
		goto out;
	    }

	case T_TLB_LD_MISS:
	case T_TLB_ST_MISS:
		ftype = (type == T_TLB_ST_MISS) ? VM_PROT_WRITE : VM_PROT_READ;
		/* check for kernel address */
		if ((int)vadr < 0) {
			vm_offset_t va;
			int rv;

		kernel_fault:
			va = trunc_page((vm_offset_t)vadr);
			rv = vm_fault(kernel_map, va, ftype, FALSE);
			if (rv == KERN_SUCCESS)
				return (pc);
			if ((i = ((struct pcb *)UADDR)->pcb_onfault) != 0) {
				((struct pcb *)UADDR)->pcb_onfault = 0;
				return (onfault_table[i]);
			}
			goto err;
		}
		/*
		 * It is an error for the kernel to access user space except
		 * through the copyin/copyout routines.
		 */
		if ((i = ((struct pcb *)UADDR)->pcb_onfault) == 0)
			goto err;
		/* check for fuswintr() or suswintr() getting a page fault */
		if (i == 4)
			return (onfault_table[i]);
		goto dofault;

	case T_TLB_LD_MISS+T_USER:
		ftype = VM_PROT_READ;
		goto dofault;

	case T_TLB_ST_MISS+T_USER:
		ftype = VM_PROT_WRITE;
	dofault:
	    {
		vm_offset_t va;
		struct vmspace *vm;
		vm_map_t map;
		int rv;

		vm = p->p_vmspace;
		map = &vm->vm_map;
		va = trunc_page((vm_offset_t)vadr);
		rv = vm_fault(map, va, ftype, FALSE);
#ifdef VMFAULT_TRACE
		printf("vm_fault(%x (pmap %x), %x (%x), %x, %d) -> %x at pc %x\n",
		       map, &vm->vm_pmap, va, vadr, ftype, FALSE, rv, pc);
#endif
		/*
		 * If this was a stack access we keep track of the maximum
		 * accessed stack size.  Also, if vm_fault gets a protection
		 * failure it is due to accessing the stack region outside
		 * the current limit and we need to reflect that as an access
		 * error.
		 */
		if ((caddr_t)va >= vm->vm_maxsaddr) {
			if (rv == KERN_SUCCESS) {
				unsigned nss;

				nss = clrnd(btoc(USRSTACK-(unsigned)va));
				if (nss > vm->vm_ssize)
					vm->vm_ssize = nss;
			} else if (rv == KERN_PROTECTION_FAILURE)
				rv = KERN_INVALID_ADDRESS;
		}
		if (rv == KERN_SUCCESS) {
			if (!USERMODE(statusReg))
				return (pc);
			goto out;
		}
		if (!USERMODE(statusReg)) {
			if ((i = ((struct pcb *)UADDR)->pcb_onfault) != 0) {
				((struct pcb *)UADDR)->pcb_onfault = 0;
				return (onfault_table[i]);
			}
			goto err;
		}
		ucode = ftype;
		i = SIGSEGV;
		typ = SEGV_MAPERR;
		break;
	    }

	case T_ADDR_ERR_LD+T_USER:	/* misaligned or kseg access */
	case T_ADDR_ERR_ST+T_USER:	/* misaligned or kseg access */
		ucode = 0;		/* XXX should be VM_PROT_something */
		i = SIGBUS;
		typ = BUS_ADRALN;
		break;
	case T_BUS_ERR_IFETCH+T_USER:	/* BERR asserted to cpu */
	case T_BUS_ERR_LD_ST+T_USER:	/* BERR asserted to cpu */
		ucode = 0;		/* XXX should be VM_PROT_something */
		i = SIGBUS;
		typ = BUS_OBJERR;
		break;

	case T_SYSCALL+T_USER:
	    {
		int *locr0 = p->p_md.md_regs;
		struct sysent *callp;
		unsigned int code;
		int numsys;
		struct args {
			int i[8];
		} args;
		int rval[2];

		cnt.v_syscall++;
		/* compute next PC after syscall instruction */
		if ((int)causeReg < 0) {	/* Check BD bit */
			locr0[PC] = MipsEmulateBranch(locr0, pc, 0, 0);
		}
		else {
			locr0[PC] += 4;
		}
		callp = p->p_emul->e_sysent;
		numsys = p->p_emul->e_nsysent;
		code = locr0[V0];
		switch (code) {
		case SYS_syscall:
			/*
			 * Code is first argument, followed by actual args.
			 */
			code = locr0[A0];
			if (code >= numsys)
				callp += p->p_emul->e_nosys; /* (illegal) */
			else
				callp += code;
			i = callp->sy_argsize / sizeof(int);
			args.i[0] = locr0[A1];
			args.i[1] = locr0[A2];
			args.i[2] = locr0[A3];
			if (i > 3) {
				i = copyin((caddr_t)(locr0[SP] +
						4 * sizeof(int)),
					(caddr_t)&args.i[3],
					(u_int)(i - 3) * sizeof(int));
				if (i) {
					locr0[V0] = i;
					locr0[A3] = 1;
#ifdef SYSCALL_DEBUG
					scdebug_call(p, code, args.i);
#endif
#ifdef KTRACE
					if (KTRPOINT(p, KTR_SYSCALL))
						ktrsyscall(p, code,
							callp->sy_argsize,
							args.i);
#endif
					goto done;
				}
			}
			break;

		case SYS___syscall:
			/*
			 * Like syscall, but code is a quad, so as to maintain
			 * quad alignment for the rest of the arguments.
			 */
			code = locr0[A0 + _QUAD_LOWWORD];
			if (code >= numsys)
				callp += p->p_emul->e_nosys; /* (illegal) */
			else
				callp += code; 
			i = callp->sy_argsize / sizeof(int);
			args.i[0] = locr0[A2];
			args.i[1] = locr0[A3];
			if (i > 2) {
				i = copyin((caddr_t)(locr0[SP] +
						4 * sizeof(int)),
					(caddr_t)&args.i[2],
					(u_int)(i - 2) * sizeof(int));
				if (i) {
					locr0[V0] = i;
					locr0[A3] = 1;
#ifdef SYSCALL_DEBUG
					scdebug_call(p, code, args.i);
#endif
#ifdef KTRACE
					if (KTRPOINT(p, KTR_SYSCALL))
						ktrsyscall(p, code,
							callp->sy_argsize,
							args.i);
#endif
					goto done;
				}
			}
			break;

		default:
			if (code >= numsys)
				callp += p->p_emul->e_nosys; /* (illegal) */
			else
				callp += code;
			i = callp->sy_narg;
			args.i[0] = locr0[A0];
			args.i[1] = locr0[A1];
			args.i[2] = locr0[A2];
			args.i[3] = locr0[A3];
			if (i > 4) {
				i = copyin((caddr_t)(locr0[SP] +
						4 * sizeof(int)),
					(caddr_t)&args.i[4],
					(u_int)(i - 4) * sizeof(int));
				if (i) {
					locr0[V0] = i;
					locr0[A3] = 1;
#ifdef SYSCALL_DEBUG
					scdebug_call(p, code, args.i);
#endif
#ifdef KTRACE
					if (KTRPOINT(p, KTR_SYSCALL))
						ktrsyscall(p, code,
							callp->sy_argsize,
							args.i);
#endif
					goto done;
				}
			}
		}
#ifdef SYSCALL_DEBUG
		scdebug_call(p, code, args.i);
#endif
#ifdef KTRACE
		if (KTRPOINT(p, KTR_SYSCALL))
			ktrsyscall(p, code, callp->sy_argsize, args.i);
#endif
		rval[0] = 0;
		rval[1] = locr0[V1];
#if defined(DDB) || defined(DEBUG)
		if (trp == trapdebug)
			trapdebug[TRAPSIZE - 1].code = code;
		else
			trp[-1].code = code;
#endif
		i = (*callp->sy_call)(p, &args, rval);
		/*
		 * Reinitialize proc pointer `p' as it may be different
		 * if this is a child returning from fork syscall.
		 */
		p = curproc;
		locr0 = p->p_md.md_regs;
#if defined(DDB) || defined(DEBUG)
		{ int s;
		s = splhigh();
		trp->status = statusReg;
		trp->cause = causeReg;
		trp->vadr = locr0[SP];
		trp->pc = locr0[PC];
		trp->ra = locr0[RA];
		trp->code = -code;
		if (++trp == &trapdebug[TRAPSIZE])
			trp = trapdebug;
		splx(s);
		}
#endif
		switch (i) {
		case 0:
			locr0[V0] = rval[0];
			locr0[V1] = rval[1];
			locr0[A3] = 0;
			break;

		case ERESTART:
			locr0[PC] = pc;
			break;

		case EJUSTRETURN:
			break;	/* nothing to do */

		default:
			locr0[V0] = i;
			locr0[A3] = 1;
		}
		if(code == SYS_ptrace)
			R4K_FlushCache();
	done:
#ifdef SYSCALL_DEBUG
		scdebug_ret(p, code, i, rval);
#endif
#ifdef KTRACE
		if (KTRPOINT(p, KTR_SYSRET))
			ktrsysret(p, code, i, rval[0]);
#endif
		goto out;
	    }

#ifdef DDB
	case T_BREAK:
		kdb_trap(type, &f);
		return(f.reg[PC]);
#endif

	case T_BREAK+T_USER:
	    {
		unsigned int va, instr;
		struct uio uio;
		struct iovec iov;

		/* compute address of break instruction */
		va = pc;
		if ((int)causeReg < 0)
			va += 4;

		/* read break instruction */
		instr = fuiword((caddr_t)va);
#if 0
		printf("trap: %s (%d) breakpoint %x at %x: (adr %x ins %x)\n",
			p->p_comm, p->p_pid, instr, pc,
			p->p_md.md_ss_addr, p->p_md.md_ss_instr); /* XXX */
#endif
		if (p->p_md.md_ss_addr != va || instr != BREAK_SSTEP) {
			i = SIGTRAP;
			typ = TRAP_TRACE;
			break;
		}

		/*
		 * Restore original instruction and clear BP
		 */
		iov.iov_base = (caddr_t)&p->p_md.md_ss_instr;
		iov.iov_len = sizeof(int); 
		uio.uio_iov = &iov;
		uio.uio_iovcnt = 1; 
		uio.uio_offset = (off_t)va;
		uio.uio_resid = sizeof(int);
		uio.uio_segflg = UIO_SYSSPACE;
		uio.uio_rw = UIO_WRITE;
		uio.uio_procp = curproc;
		i = procfs_domem(p, p, NULL, &uio);
		R4K_FlushCache();

		if (i < 0)
			printf("Warning: can't restore instruction at %x: %x\n",
				p->p_md.md_ss_addr, p->p_md.md_ss_instr);

		p->p_md.md_ss_addr = 0;
		i = SIGTRAP;
		typ = TRAP_BRKPT;
		break;
	    }

	case T_RES_INST+T_USER:
		i = SIGILL;
		typ = ILL_ILLOPC;
		break;

	case T_COP_UNUSABLE+T_USER:
		if ((causeReg & CR_COP_ERR) != 0x10000000) {
			i = SIGILL;	/* only FPU instructions allowed */
			typ = ILL_ILLOPC;
			break;
		}
		MipsSwitchFPState(machFPCurProcPtr, p->p_md.md_regs);
		machFPCurProcPtr = p;
		p->p_md.md_regs[PS] |= SR_COP_1_BIT;
		p->p_md.md_flags |= MDP_FPUSED;
		goto out;

	case T_FPE:
#if defined(DDB) || defined(DEBUG)
		trapDump("fpintr");
#else
		printf("FPU Trap: PC %x CR %x SR %x\n",
			pc, causeReg, statusReg);
		goto err;
#endif

	case T_FPE+T_USER:
		MipsFPTrap(statusReg, causeReg, pc);
		goto out;

	case T_OVFLOW+T_USER:
		i = SIGFPE;
		typ = FPE_FLTOVF;
		break;

	case T_ADDR_ERR_LD:	/* misaligned access */
	case T_ADDR_ERR_ST:	/* misaligned access */
	case T_BUS_ERR_LD_ST:	/* BERR asserted to cpu */
		if ((i = ((struct pcb *)UADDR)->pcb_onfault) != 0) {
			((struct pcb *)UADDR)->pcb_onfault = 0;
			return (onfault_table[i]);
		}
		/* FALLTHROUGH */

	default:
	err:
#ifdef DEBUG
		stacktrace(!USERMODE(statusReg) ? f.reg : p->p_md.md_regs);
		trapDump("trap");
#endif
		panic("trap");
	}
	p->p_md.md_regs[PC] = pc;
	p->p_md.md_regs[CAUSE] = causeReg;
	p->p_md.md_regs[BADVADDR] = vadr;
	sv.sival_int = vadr;
	trapsignal(p, i, ucode, typ, sv);
out:
	/*
	 * Note: we should only get here if returning to user mode.
	 */
	/* take pending signals */
	while ((i = CURSIG(p)) != 0)
		postsig(i);
	p->p_priority = p->p_usrpri;
	astpending = 0;
	if (want_resched) {
		int s;

		/*
		 * Since we are curproc, clock will normally just change
		 * our priority without moving us from one queue to another
		 * (since the running process is not on a queue.)
		 * If that happened after we put ourselves on the run queue
		 * but before we switched, we might not be on the queue
		 * indicated by our priority.
		 */
		s = splstatclock();
		setrunqueue(p);
		p->p_stats->p_ru.ru_nivcsw++;
		mi_switch();
		splx(s);
		while ((i = CURSIG(p)) != 0)
			postsig(i);
	}

	/*
	 * If profiling, charge system time to the trapped pc.
	 */
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, pc, (int)(p->p_sticks - sticks) * psratio);
	}

	curpriority = p->p_priority;
	return (pc);
}

/*
 * Handle an interrupt.
 * Called from MipsKernIntr() or MipsUserIntr()
 * Note: curproc might be NULL.
 */
void
interrupt(statusReg, causeReg, what, pc, args)
	u_int statusReg;	/* status register at time of the exception */
	u_int causeReg;		/* cause register at time of exception */
	u_int what;
	u_int pc;		/* program counter where to continue */
	u_int args;
{
	unsigned mask;
	int i;
	struct clockframe cf;

	cnt.v_trap++;
#if defined(DDB) || defined(DEBUG)
	trp->status = statusReg;
	trp->cause = causeReg;
	trp->vadr = 0;
	trp->pc = pc;
	trp->ra = 0;
	trp->sp = (int)&args;
	trp->code = 0;
	if (++trp == &trapdebug[TRAPSIZE])
		trp = trapdebug;
#endif

	cnt.v_intr++;
	mask = causeReg & statusReg;	/* pending interrupts & enable mask */
	cf.pc = pc;
	cf.sr = statusReg;
	cf.cr = causeReg;

	/*
	 *  Check off all enabled interrupts. Called interrupt routine
	 *  returns mask of interrupts to reenable.
	 */
	for(i = 0; i < 8; i++) {
		if(cpu_int_tab[i].int_mask & mask) {
			causeReg &= (*cpu_int_tab[i].int_hand)(mask, &cf);
		}
	}
	/*
	 *  Reenable all non served hardware levels.
	 */
	splx((statusReg & ~causeReg & HARD_INT_MASK) | SR_INT_ENAB);


	if (mask & SOFT_INT_MASK_0) {
		clearsoftclock();
		cnt.v_soft++;
		softclock();
	}
	/*
	 *  Process network interrupt if we trapped or will very soon
	 */
	if ((mask & SOFT_INT_MASK_1) ||
	    (netisr && (statusReg & SOFT_INT_MASK_1))) {
		clearsoftnet();
		cnt.v_soft++;
		intrcnt[1]++;
#ifdef INET
		if (netisr & (1 << NETISR_ARP)) {
			netisr &= ~(1 << NETISR_ARP);
			arpintr();
		}
		if (netisr & (1 << NETISR_IP)) {
			netisr &= ~(1 << NETISR_IP);
			ipintr();
		}
#endif
#ifdef INET6
		if (netisr & (1 << NETISR_IPV6)) {
			netisr &= ~(1 << NETISR_IPV6);
			ip6intr();
		}
#endif
#ifdef NETATALK
		if (netisr & (1 << NETISR_ATALK)) {
			netisr &= ~(1 << NETISR_ATALK);
			atintr();
		}
#endif
#ifdef NS
		if (netisr & (1 << NETISR_NS)) {
			netisr &= ~(1 << NETISR_NS);
			nsintr();
		}
#endif
#ifdef ISO
		if (netisr & (1 << NETISR_ISO)) {
			netisr &= ~(1 << NETISR_ISO);
			clnlintr();
		}
#endif
#if NPPP > 0
		if(netisr & (1 << NETISR_PPP)) {
			netisr &= ~(1 << NETISR_PPP);
			pppintr();
		}
#endif
#if NBRIDGE > 0
		if(netisr & (1 << NETISR_BRIDGE)) {
			netisr &= ~(1 << NETISR_BRIDGE);
			bridgeintr();
		}
#endif
	}
	if (mask & SOFT_INT_MASK_0) {
		clearsoftclock();
		intrcnt[0]++;
		cnt.v_soft++;
		softclock();
	}
}

/*
 *	Set up handler for external interrupt events.
 *	Events are checked in priority order.
 */
void
set_intr(mask, int_hand, prio)
	int	mask;
	int	(*int_hand)(u_int, struct clockframe *);
	int	prio;
{
	if(prio >= 8)
		panic("set_intr: to high priority");

	if(cpu_int_tab[prio].int_mask != 0 &&
	   (cpu_int_tab[prio].int_mask != mask ||
	    cpu_int_tab[prio].int_hand != int_hand)) {
		panic("set_intr: int already set %x", prio);
	}

	cpu_int_tab[prio].int_hand = int_hand;
	cpu_int_tab[prio].int_mask = mask;
	cpu_int_mask |= mask >> 10;

	/*
	 *  Update external interrupt mask but don't enable clock.
	 */
	switch(system_type) {
	case ACER_PICA_61:
	case MAGNUM:
		out32(R4030_SYS_EXT_IMASK, cpu_int_mask & (~INT_MASK_4 >> 10));
		break;

	case DESKSTATION_TYNE:
		break;
	case DESKSTATION_RPC44:
		break;
	case ALGOR_P4032:
	case ALGOR_P5064:
		break;
	}
}

/*
 * This is called from MipsUserIntr() if astpending is set.
 * This is very similar to the tail of trap().
 */
void
softintr(statusReg, pc)
	unsigned statusReg;	/* status register at time of the exception */
	unsigned pc;		/* program counter where to continue */
{
	struct proc *p = curproc;
	int sig;

	cnt.v_soft++;
	/* take pending signals */
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);
	p->p_priority = p->p_usrpri;
	astpending = 0;
	if (p->p_flag & P_OWEUPC) {
		p->p_flag &= ~P_OWEUPC;
		ADDUPROF(p);
	}
	if (want_resched) {
		int s;

		/*
		 * Since we are curproc, clock will normally just change
		 * our priority without moving us from one queue to another
		 * (since the running process is not on a queue.)
		 * If that happened after we put ourselves on the run queue
		 * but before we switched, we might not be on the queue
		 * indicated by our priority.
		 */
		s = splstatclock();
		setrunqueue(p);
		p->p_stats->p_ru.ru_nivcsw++;
		mi_switch();
		splx(s);
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
	}
	curpriority = p->p_priority;
}

#if defined(DDB) || defined(DEBUG)
void
trapDump(msg)
	char *msg;
{
	int i;
	int s;

	s = splhigh();
	printf("trapDump(%s)\n", msg);
	for (i = 0; i < TRAPSIZE; i++) {
		if (trp == trapdebug)
			trp = &trapdebug[TRAPSIZE - 1];
		else
			trp--;
		if (trp->cause == 0)
			break;
		printf("%s: ADR %x PC %x CR %x SR %x\n",
			trap_type[(trp->cause & CR_EXC_CODE) >>
				CR_EXC_CODE_SHIFT],
			trp->vadr, trp->pc, trp->cause, trp->status);
		printf("   RA %x SP %x code %d\n", trp->ra, trp->sp, trp->code);
	}
	splx(s);
}
#endif

#if 0
/*
 *----------------------------------------------------------------------
 *
 * MemErrorInterrupts --
 *   arc_errintr - for the ACER PICA_61
 *
 *	Handler an interrupt for the control register.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
static void
arc_errintr()
{
	volatile u_short *sysCSRPtr =
		(u_short *)PHYS_TO_UNCACHED(KN01_SYS_CSR);
	u_short csr;

	csr = *sysCSRPtr;

	if (csr & KN01_CSR_MERR) {
		printf("Memory error at 0x%x\n",
			*(unsigned *)PHYS_TO_UNCACHED(KN01_SYS_ERRADR));
		panic("Mem error interrupt");
	}
	*sysCSRPtr = (csr & ~KN01_CSR_MBZ) | 0xff;
}
#endif


/*
 * Return the resulting PC as if the branch was executed.
 */
unsigned
MipsEmulateBranch(regsPtr, instPC, fpcCSR, instptr)
	int *regsPtr;
	int instPC;
	int fpcCSR;
	u_int instptr;
{
	InstFmt inst;
	unsigned retAddr;
	int condition;

#define GetBranchDest(InstPtr, inst) \
	((unsigned)InstPtr + 4 + ((short)inst.IType.imm << 2))


	if(instptr) {
		inst = *(InstFmt *)&instptr;
	}
	else {
		inst = *(InstFmt *)instPC;
	}
#if 0
	printf("regsPtr=%x PC=%x Inst=%x fpcCsr=%x\n", regsPtr, instPC,
		inst.word, fpcCSR); /* XXX */
#endif
	switch ((int)inst.JType.op) {
	case OP_SPECIAL:
		switch ((int)inst.RType.func) {
		case OP_JR:
		case OP_JALR:
			retAddr = regsPtr[inst.RType.rs];
			break;

		default:
			retAddr = instPC + 4;
			break;
		}
		break;

	case OP_BCOND:
		switch ((int)inst.IType.rt) {
		case OP_BLTZ:
		case OP_BLTZL:
		case OP_BLTZAL:
		case OP_BLTZALL:
			if ((int)(regsPtr[inst.RType.rs]) < 0)
				retAddr = GetBranchDest(instPC, inst);
			else
				retAddr = instPC + 8;
			break;

		case OP_BGEZ:
		case OP_BGEZL:
		case OP_BGEZAL:
		case OP_BGEZALL:
			if ((int)(regsPtr[inst.RType.rs]) >= 0)
				retAddr = GetBranchDest(instPC, inst);
			else
				retAddr = instPC + 8;
			break;

		default:
			panic("MipsEmulateBranch: Bad branch cond");
		}
		break;

	case OP_J:
	case OP_JAL:
		retAddr = (inst.JType.target << 2) | 
			((unsigned)instPC & 0xF0000000);
		break;

	case OP_BEQ:
	case OP_BEQL:
		if (regsPtr[inst.RType.rs] == regsPtr[inst.RType.rt])
			retAddr = GetBranchDest(instPC, inst);
		else
			retAddr = instPC + 8;
		break;

	case OP_BNE:
	case OP_BNEL:
		if (regsPtr[inst.RType.rs] != regsPtr[inst.RType.rt])
			retAddr = GetBranchDest(instPC, inst);
		else
			retAddr = instPC + 8;
		break;

	case OP_BLEZ:
	case OP_BLEZL:
		if ((int)(regsPtr[inst.RType.rs]) <= 0)
			retAddr = GetBranchDest(instPC, inst);
		else
			retAddr = instPC + 8;
		break;

	case OP_BGTZ:
	case OP_BGTZL:
		if ((int)(regsPtr[inst.RType.rs]) > 0)
			retAddr = GetBranchDest(instPC, inst);
		else
			retAddr = instPC + 8;
		break;

	case OP_COP1:
		switch (inst.RType.rs) {
		case OP_BCx:
		case OP_BCy:
			if ((inst.RType.rt & COPz_BC_TF_MASK) == COPz_BC_TRUE)
				condition = fpcCSR & FPC_COND_BIT;
			else
				condition = !(fpcCSR & FPC_COND_BIT);
			if (condition)
				retAddr = GetBranchDest(instPC, inst);
			else
				retAddr = instPC + 8;
			break;

		default:
			retAddr = instPC + 4;
		}
		break;

	default:
		retAddr = instPC + 4;
	}
	return (retAddr);
}

/*
 * This routine is called by procxmt() to single step one instruction.
 * We do this by storing a break instruction after the current instruction,
 * resuming execution, and then restoring the old instruction.
 */
int
cpu_singlestep(p)
	struct proc *p;
{
	unsigned va;
	int *locr0 = p->p_md.md_regs;
	int i;
	int bpinstr = BREAK_SSTEP;
	int curinstr;
	struct uio uio;
	struct iovec iov;

	/*
	 * Fetch what's at the current location.
	 */
	iov.iov_base = (caddr_t)&curinstr;
	iov.iov_len = sizeof(int); 
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1; 
	uio.uio_offset = (off_t)locr0[PC];
	uio.uio_resid = sizeof(int);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = curproc;
	procfs_domem(curproc, p, NULL, &uio);

	/* compute next address after current location */
	if(curinstr != 0) {
		va = MipsEmulateBranch(locr0, locr0[PC], locr0[FSR], curinstr);
	}
	else {
		va = locr0[PC] + 4;
	}
	if (p->p_md.md_ss_addr) {
		printf("SS %s (%d): breakpoint already set at %x (va %x)\n",
			p->p_comm, p->p_pid, p->p_md.md_ss_addr, va); /* XXX */
		return (EFAULT);
	}
	p->p_md.md_ss_addr = va;
	/*
	 * Fetch what's at the current location.
	 */
	iov.iov_base = (caddr_t)&p->p_md.md_ss_instr;
	iov.iov_len = sizeof(int); 
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1; 
	uio.uio_offset = (off_t)va;
	uio.uio_resid = sizeof(int);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = curproc;
	procfs_domem(curproc, p, NULL, &uio);

	/*
	 * Store breakpoint instruction at the "next" location now.
	 */
	iov.iov_base = (caddr_t)&bpinstr;
	iov.iov_len = sizeof(int); 
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1; 
	uio.uio_offset = (off_t)va;
	uio.uio_resid = sizeof(int);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_WRITE;
	uio.uio_procp = curproc;
	i = procfs_domem(curproc, p, NULL, &uio);
	R4K_FlushCache();

	if (i < 0)
		return (EFAULT);
#if 0
	printf("SS %s (%d): breakpoint set at %x: %x (pc %x) br %x\n",
		p->p_comm, p->p_pid, p->p_md.md_ss_addr,
		p->p_md.md_ss_instr, locr0[PC], curinstr); /* XXX */
#endif
	return (0);
}

#if defined(DDB) || defined(DEBUG)
#define MIPS_JR_RA	0x03e00008	/* instruction code for jr ra */

/* forward */
char *fn_name(unsigned addr);
void stacktrace_subr __P((int *, int (*)(const char*, ...)));

/*
 * Print a stack backtrace.
 */
void
stacktrace(regs)
	int *regs;
{
	stacktrace_subr(regs, printf);
}

void
logstacktrace(regs)
	int *regs;
{
	stacktrace_subr(regs, addlog);
}

void
stacktrace_subr(regs, printfn)
	int *regs;
	int (*printfn) __P((const char*, ...));
{
	unsigned pc, sp, fp, ra, va, subr;
	unsigned a0, a1, a2, a3;
	unsigned instr, mask;
	InstFmt i;
	int more, stksize;
	extern char edata[];
	unsigned int frames =  0;

	/* get initial values from the exception frame */
	sp = regs[SP];
	pc = regs[PC];
	fp = regs[S8];
	ra = regs[RA];		/* May be a 'leaf' function */
	a0 = regs[A0];
	a1 = regs[A1];
	a2 = regs[A2];
	a3 = regs[A3];

/* Jump here when done with a frame, to start a new one */
loop:

/* Jump here after a nonstandard (interrupt handler) frame */
specialframe:
	stksize = 0;
	subr = 0;
	if	(frames++ > 100) {
		(*printfn)("\nstackframe count exceeded\n");
		/* return breaks stackframe-size heuristics with gcc -O2 */
		goto finish;	/*XXX*/
	}

	/* check for bad SP: could foul up next frame */
	if (sp & 3 || sp < 0x80000000) {
		(*printfn)("SP 0x%x: not in kernel\n", sp);
		ra = 0;
		subr = 0;
		goto done;
	}

	/* Backtraces should contine through interrupts from kernel mode */
	if (pc >= (unsigned)MipsKernIntr && pc < (unsigned)MipsUserIntr) {
		(*printfn)("MipsKernIntr+%x: (%x, %x ,%x) -------\n",
		       pc-(unsigned)MipsKernIntr, a0, a1, a2);
		regs = (int *)(sp + STAND_ARG_SIZE);
		a0 = kdbpeek(&regs[A0]);
		a1 = kdbpeek(&regs[A1]);
		a2 = kdbpeek(&regs[A2]);
		a3 = kdbpeek(&regs[A3]);

		pc = kdbpeek(&regs[PC]); /* exc_pc - pc at time of exception */
		ra = kdbpeek(&regs[RA]); /* ra at time of exception */
		sp = kdbpeek(&regs[SP]);
		goto specialframe;
	}


# define Between(x, y, z) \
		( ((x) <= (y)) && ((y) < (z)) )
# define pcBetween(a,b) \
		Between((unsigned)a, pc, (unsigned)b)

	/*
	 * Check for current PC in  exception handler code that don't
	 * have a preceding "j ra" at the tail of the preceding function. 
	 * Depends on relative ordering of functions in locore.
	 */
	if (pcBetween(MipsKernGenException, MipsUserGenException))
		subr = (unsigned) MipsKernGenException;
	else if (pcBetween(MipsUserGenException,MipsKernIntr))
		subr = (unsigned) MipsUserGenException;
	else if (pcBetween(MipsKernIntr, MipsUserIntr))
		subr = (unsigned) MipsKernIntr;
	else if (pcBetween(MipsUserIntr, MipsTLBInvalidException))
		subr = (unsigned) MipsUserIntr;
	else if (pcBetween(splx, wbflush))
		subr = (unsigned) splx;
	else if (pcBetween(cpu_switch, fuword))
		subr = (unsigned) cpu_switch;
	else if (pcBetween(idle, cpu_switch))	{
		subr = (unsigned) idle;
		ra = 0;
		goto done;
	}
	else if (pc >= (unsigned)MipsTLBMiss && pc < (unsigned)setsoftclock) {
		(*printfn)("<<locore>>");
		goto done;
	}

	/* check for bad PC */
	if (pc & 3 || pc < 0x80000000 || pc >= (unsigned)edata) {
		(*printfn)("PC 0x%x: not in kernel\n", pc);
		ra = 0;
		goto done;
	}

	/*
	 * Find the beginning of the current subroutine by scanning backwards
	 * from the current PC for the end of the previous subroutine.
	 */
	if (!subr) {
		va = pc - sizeof(int);
		while ((instr = kdbpeek((int *)va)) != MIPS_JR_RA)
		va -= sizeof(int);
		va += 2 * sizeof(int);	/* skip back over branch & delay slot */
		/* skip over nulls which might separate .o files */
		while ((instr = kdbpeek((int *)va)) == 0)
			va += sizeof(int);
		subr = va;
	}

	/*
	 * Jump here for locore entry points for which the preceding
	 * function doesn't end in "j ra"
	 */
	/* scan forwards to find stack size and any saved registers */
	stksize = 0;
	more = 3;
	mask = 0;
	for (va = subr; more; va += sizeof(int),
	     		      more = (more == 3) ? 3 : more - 1) {
		/* stop if hit our current position */
		if (va >= pc)
			break;
		instr = kdbpeek((int *)va);
		i.word = instr;
		switch (i.JType.op) {
		case OP_SPECIAL:
			switch (i.RType.func) {
			case OP_JR:
			case OP_JALR:
				more = 2; /* stop after next instruction */
				break;

			case OP_SYSCALL:
			case OP_BREAK:
				more = 1; /* stop now */
			};
			break;

		case OP_BCOND:
		case OP_J:
		case OP_JAL:
		case OP_BEQ:
		case OP_BNE:
		case OP_BLEZ:
		case OP_BGTZ:
			more = 2; /* stop after next instruction */
			break;

		case OP_COP0:
		case OP_COP1:
		case OP_COP2:
		case OP_COP3:
			switch (i.RType.rs) {
			case OP_BCx:
			case OP_BCy:
				more = 2; /* stop after next instruction */
			};
			break;

		case OP_SW:
			/* look for saved registers on the stack */
			if (i.IType.rs != 29)
				break;
			/* only restore the first one */
			if (mask & (1 << i.IType.rt))
				break;
			mask |= (1 << i.IType.rt);
			switch (i.IType.rt) {
			case 4: /* a0 */
				a0 = kdbpeek((int *)(sp + (short)i.IType.imm));
				break;

			case 5: /* a1 */
				a1 = kdbpeek((int *)(sp + (short)i.IType.imm));
				break;

			case 6: /* a2 */
				a2 = kdbpeek((int *)(sp + (short)i.IType.imm));
				break;

			case 7: /* a3 */
				a3 = kdbpeek((int *)(sp + (short)i.IType.imm));
				break;

			case 30: /* fp */
				fp = kdbpeek((int *)(sp + (short)i.IType.imm));
				break;

			case 31: /* ra */
				ra = kdbpeek((int *)(sp + (short)i.IType.imm));
			}
			break;

		case OP_ADDI:
		case OP_ADDIU:
			/* look for stack pointer adjustment */
			if (i.IType.rs != 29 || i.IType.rt != 29)
				break;
			stksize = - ((short)i.IType.imm);
		}
	}

done:
	(*printfn)("%s+%x (%x,%x,%x,%x) ra %x sz %d\n",
		fn_name(subr), pc - subr, a0, a1, a2, a3, ra, stksize);

	if (ra) {
		if (pc == ra && stksize == 0)
			(*printfn)("stacktrace: loop!\n");
		else {
			pc = ra;
			sp += stksize;
			ra = 0;
			goto loop;
		}
	} else {
finish:
		if (curproc)
			(*printfn)("User-level: pid %d\n", curproc->p_pid);
		else
			(*printfn)("User-level: curproc NULL\n");
	}
}

/*
 * Functions ``special'' enough to print by name
 */
#ifdef __STDC__
#define Name(_fn)  { (void*)_fn, # _fn }
#else
#define Name(_fn) { _fn, "_fn"}
#endif
static struct { void *addr; char *name;} names[] = {
	Name(interrupt),
	Name(trap),
	Name(MipsKernGenException),
	Name(MipsUserGenException),
	Name(MipsKernIntr),
	Name(MipsUserIntr),
	Name(splx),
	Name(idle),
	Name(cpu_switch),
	{0, 0}
};

/*
 * Map a function address to a string name, if known; or a hex string.
 */
char *
fn_name(unsigned addr)
{
	static char buf[17];
	int i = 0;

	for (i = 0; names[i].name; i++)
		if (names[i].addr == (void*)addr)
			return (names[i].name);
	sprintf(buf, "%x", addr);
	return (buf);
}

#endif /* DDB */
@


1.25
log
@Change the ktrace interface functions from taking the trace vnode to taking the
traced proc. The vnode is in the proc and all functions need the proc.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.24 2000/06/08 10:31:15 art Exp $	*/
@


1.24
log
@&vm_pmap -> vm_map.pmap
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23 1999/12/08 06:50:15 itojun Exp $	*/
d523 1
a523 1
						ktrsyscall(p->p_tracep, code,
d558 1
a558 1
						ktrsyscall(p->p_tracep, code,
d590 1
a590 1
						ktrsyscall(p->p_tracep, code,
d603 1
a603 1
			ktrsyscall(p->p_tracep, code, callp->sy_argsize, args.i);
d660 1
a660 1
			ktrsysret(p->p_tracep, code, i, rval[0]);
@


1.23
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.22 1999/05/24 23:08:59 jason Exp $	*/
d341 1
a341 1
		pmap_t pmap = &p->p_vmspace->vm_pmap;
@


1.23.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23 1999/12/08 06:50:15 itojun Exp $	*/
@


1.22
log
@Only do basic work in the ethernet interrupt context, and queue packets to
be bridged.  Do the real work in a scheduled netisr.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.21 1999/01/07 23:15:55 deraadt Exp $	*/
d896 1
a896 1
			ipv6intr();
@


1.21
log
@global decl for *intr() routines, plus add INET6
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20 1998/10/15 21:30:00 imp Exp $	*/
d46 1
d921 6
@


1.20
log
@
Back out PEFO's trap change.  It breaks everybody, it seems.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17 1998/03/25 11:51:36 pefo Exp $	*/
a242 3
extern void arpintr __P((void));
extern void ipintr __P((void));
extern void pppintr __P((void));
d890 6
@


1.19
log
@Fix ERESTART bug introduced with trapframes
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.18 1998/09/15 10:58:54 pefo Exp $	*/
d64 1
a72 1
#include <machine/regnum.h>
d227 2
a228 2
void stacktrace __P((struct trap_frame *));
void logstacktrace __P((struct trap_frame *));
d241 1
a241 1
extern void MipsSwitchFPState __P((struct proc *, struct trap_frame *));
d247 3
a249 4
u_int trap __P((struct trap_frame *));
void child_return __P((struct proc *p));
void interrupt __P((struct trap_frame *));
void softintr __P((u_int));
d251 1
a251 1
u_int MipsEmulateBranch __P((struct trap_frame *, int, int, u_int));
d261 6
a266 2
trap(trapframe)
	struct trap_frame *trapframe;
d278 7
a284 7
	trp->status = trapframe->sr;
	trp->cause = trapframe->cause;
	trp->vadr = trapframe->badvaddr;
	trp->pc = trapframe->pc;
	trp->ra = !USERMODE(trapframe->sr) ? trapframe->pc :
		p->p_md.md_regs->ra;
	trp->sp = (u_int)trapframe;
d290 2
a291 2
	type = (trapframe->cause & CR_EXC_CODE) >> CR_EXC_CODE_SHIFT;
	if (USERMODE(trapframe->sr)) {
d300 2
a301 2
	if (trapframe->sr & SR_INT_ENAB)
		splx((trapframe->sr & HARD_INT_MASK) | SR_INT_ENAB);
d306 1
a306 1
		if ((int)trapframe->badvaddr < 0) {
d311 1
a311 1
			pte = kvtopte(trapframe->badvaddr);
d317 1
a317 1
			if (pmap_is_page_ro(pmap_kernel(), mips_trunc_page(trapframe->badvaddr), entry)) {
d324 2
a325 2
			trapframe->badvaddr &= ~PGOFSET;
			R4K_TLBUpdate(trapframe->badvaddr, entry);
d334 1
a334 1
			return (trapframe->pc);
d345 1
a345 1
		if (!(pte = pmap_segmap(pmap, trapframe->badvaddr)))
d347 1
a347 1
		pte += (trapframe->badvaddr >> PGSHIFT) & (NPTEPG - 1);
d354 1
a354 1
		if (pmap_is_page_ro(pmap, (vm_offset_t)mips_trunc_page(trapframe->badvaddr), entry)) {
d361 2
a362 2
		trapframe->badvaddr = (trapframe->badvaddr & ~PGOFSET) | (pmap->pm_tlbpid << VMTLB_PID_SHIFT);
		R4K_TLBUpdate(trapframe->badvaddr, entry);
d372 2
a373 2
		if (!USERMODE(trapframe->sr))
			return (trapframe->pc);
d381 1
a381 1
		if ((int)trapframe->badvaddr < 0) {
d386 1
a386 1
			va = trunc_page((vm_offset_t)trapframe->badvaddr);
d389 1
a389 1
				return (trapframe->pc);
d422 1
a422 1
		va = trunc_page((vm_offset_t)trapframe->badvaddr);
d426 1
a426 1
		    map, &vm->vm_pmap, va, trapframe->badvaddr, ftype, FALSE, rv, trapframe->pc);
d446 2
a447 2
			if (!USERMODE(trapframe->sr))
				return (trapframe->pc);
d450 1
a450 1
		if (!USERMODE(trapframe->sr)) {
d478 1
a478 1
		struct trap_frame *locr0 = p->p_md.md_regs;
a480 1
		unsigned int tpc;
d489 2
a490 3
		tpc = trapframe->pc; /* Remember if restart */
		if ((int)trapframe->cause < 0) {	/* Check BD bit */
			locr0->pc = MipsEmulateBranch(locr0, trapframe->pc, 0, 0);
d493 1
a493 1
			locr0->pc += 4;
d497 1
a497 1
		code = locr0->v0;
d503 1
a503 1
			code = locr0->a0;
d509 3
a511 3
			args.i[0] = locr0->a1;
			args.i[1] = locr0->a2;
			args.i[2] = locr0->a3;
d513 1
a513 1
				i = copyin((caddr_t)(locr0->sp +
d518 2
a519 2
					locr0->v0 = i;
					locr0->a3 = 1;
d539 1
a539 6
			if(_QUAD_LOWWORD == 0) {
				code = locr0->a0;
			}
			else {
				code = locr0->a1;
			}
d545 2
a546 2
			args.i[0] = locr0->a2;
			args.i[1] = locr0->a3;
d548 1
a548 1
				i = copyin((caddr_t)(locr0->sp +
d553 2
a554 2
					locr0->v0 = i;
					locr0->a3 = 1;
d575 4
a578 4
			args.i[0] = locr0->a0;
			args.i[1] = locr0->a1;
			args.i[2] = locr0->a2;
			args.i[3] = locr0->a3;
d580 1
a580 1
				i = copyin((caddr_t)(locr0->sp +
d585 2
a586 2
					locr0->v0 = i;
					locr0->a3 = 1;
d608 1
a608 1
		rval[1] = locr0->v1;
d625 5
a629 5
		trp->status = trapframe->sr;
		trp->cause = trapframe->cause;
		trp->vadr = locr0->sp;
		trp->pc = locr0->pc;
		trp->ra = locr0->ra;
d638 3
a640 3
			locr0->v0 = rval[0];
			locr0->v1 = rval[1];
			locr0->a3 = 0;
d644 1
a644 1
			locr0->pc = tpc;
d651 2
a652 2
			locr0->v0 = i;
			locr0->a3 = 1;
d669 2
a670 2
		kdb_trap(type, trapframe);
		return(trapframe->pc);
d680 2
a681 2
		va = trapframe->pc;
		if ((int)trapframe->cause < 0)
d688 1
a688 1
			p->p_comm, p->p_pid, instr, trapframe->pc,
d728 1
a728 1
		if ((trapframe->cause & CR_COP_ERR) != 0x10000000) {
d735 1
a735 1
		p->p_md.md_regs->sr |= SR_COP_1_BIT;
d744 1
a744 1
			trapframe->pc, trapframe->cause, trapframe->sr);
d749 1
a749 1
		MipsFPTrap(trapframe->sr, trapframe->cause, trapframe->pc);
d769 1
a769 1
		stacktrace(!USERMODE(trapframe->sr) ? &f : p->p_md.md_regs);
d774 4
a777 4
	p->p_md.md_regs->pc = trapframe->pc;
	p->p_md.md_regs->cause = trapframe->cause;
	p->p_md.md_regs->badvaddr = trapframe->badvaddr;
	sv.sival_int = trapframe->badvaddr;
d814 1
a814 1
		addupc_task(p, trapframe->pc, (int)(p->p_sticks - sticks) * psratio);
d818 1
a818 54
	return (trapframe->pc);
}

void
child_return(p)
	struct proc *p;
{
	struct trap_frame *trapframe;
	int i;

	trapframe = p->p_md.md_regs;
	trapframe->v0 = 0;
	trapframe->v1 = 1;
	trapframe->a3 = 0;

	/* take pending signals */
	while ((i = CURSIG(p)) != 0)
		postsig(i);
	p->p_priority = p->p_usrpri;
	astpending = 0;
	if (want_resched) {
		int s;

		/*
		 * Since we are curproc, clock will normally just change
		 * our priority without moving us from one queue to another
		 * (since the running process is not on a queue.)
		 * If that happened after we put ourselves on the run queue
		 * but before we switched, we might not be on the queue
		 * indicated by our priority.
		 */
		s = splstatclock();
		setrunqueue(p);
		p->p_stats->p_ru.ru_nivcsw++;
		mi_switch();
		splx(s);
		while ((i = CURSIG(p)) != 0)
			postsig(i);
	}

#if 0 /* Need sticks */
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, trapframe->pc, (int)(p->p_sticks - sticks) * psratio);
	}
#endif

	curpriority = p->p_priority;

#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p->p_tracep, SYS_fork, 0, 0);
#endif 
a825 2
int iofvcount = 0;

d827 6
a832 2
interrupt(trapframe)
	struct trap_frame *trapframe;
a834 1
	unsigned cause;
d840 2
a841 2
	trp->status = trapframe->sr;
	trp->cause = trapframe->cause;
d843 1
a843 1
	trp->pc = trapframe->pc;
d845 1
a845 1
	trp->sp = (int)trapframe;
d852 5
a856 9
	mask = trapframe->cause & trapframe->sr;	/* pending interrupts & enable mask */
	cf.pc = trapframe->pc;
	cf.sr = trapframe->sr;
	cf.cr = trapframe->cause;

if(iofvcount++ > 100) {
trapDump("int overflow");
Debugger();
}
a860 1
	cause = trapframe->cause;
d863 1
a863 1
			cause &= (*cpu_int_tab[i].int_hand)(mask, &cf);
d869 1
a869 1
	splx((trapframe->sr & ~cause & HARD_INT_MASK) | SR_INT_ENAB);
d881 1
a881 1
	    (netisr && (trapframe->sr & SOFT_INT_MASK_1))) {
d975 1
a975 1
softintr(statusReg)
d977 1
d1081 2
a1082 2
MipsEmulateBranch(framePtr, instPC, fpcCSR, instptr)
	struct trap_frame *framePtr;
a1089 1
	register_t *regsPtr = (register_t *)framePtr;
d1219 1
a1219 1
	struct trap_frame *locr0 = p->p_md.md_regs;
d1233 1
a1233 1
	uio.uio_offset = (off_t)locr0->pc;
d1242 1
a1242 1
		va = MipsEmulateBranch(locr0, locr0->pc, locr0->fsr, curinstr);
d1245 1
a1245 1
		va = locr0->pc + 4;
d1297 1
a1297 1
void stacktrace_subr __P((struct trap_frame *, int (*)(const char*, ...)));
d1304 1
a1304 1
	struct trap_frame *regs;
d1311 1
a1311 1
	struct trap_frame *regs;
d1318 1
a1318 1
	struct trap_frame *regs;
d1330 8
a1337 8
	sp = regs->sp;
	pc = regs->pc;
	fp = regs->s8;
	ra = regs->ra;		/* May be a 'leaf' function */
	a0 = regs->a0;
	a1 = regs->a1;
	a2 = regs->a2;
	a3 = regs->a3;
d1364 9
a1372 9
		regs = (struct trap_frame *)(sp + STAND_ARG_SIZE);
		a0 = kdbpeek(&regs->a0);
		a1 = kdbpeek(&regs->a1);
		a2 = kdbpeek(&regs->a2);
		a3 = kdbpeek(&regs->a3);

		pc = kdbpeek(&regs->pc); /* exc_pc - pc at time of exception */
		ra = kdbpeek(&regs->ra); /* ra at time of exception */
		sp = kdbpeek(&regs->sp);
@


1.18
log
@Real trapframe and no more __FORK_BRAINDAMAGE
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17 1998/03/25 11:51:36 pefo Exp $	*/
d478 1
d487 1
d648 1
a648 1
			locr0->pc = trapframe->pc;
@


1.17
log
@DDB vs DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16 1998/03/16 09:38:33 pefo Exp $	*/
a63 1
#include <machine/reg.h>
d72 1
d227 2
a228 2
void stacktrace __P((int *));
void logstacktrace __P((int *));
d241 1
a241 1
extern void MipsSwitchFPState __P((struct proc *, int *));
d247 4
a250 3
u_int trap __P((u_int, u_int, u_int, u_int, struct trap_frame));
void interrupt __P((u_int, u_int, u_int, u_int, u_int));
void softintr __P((u_int, u_int));
d252 1
a252 1
u_int MipsEmulateBranch __P((int *, int, int, u_int));
d262 2
a263 6
trap(statusReg, causeReg, vadr, pc, f)
	u_int statusReg;	/* status register at time of the exception */
	u_int causeReg;		/* cause register at time of exception */
	u_int vadr;		/* address (if any) the fault occured on */
	u_int pc;		/* program counter where to continue */
	struct trap_frame f;
d275 7
a281 7
	trp->status = statusReg;
	trp->cause = causeReg;
	trp->vadr = vadr;
	trp->pc = pc;
	trp->ra = !USERMODE(statusReg) ? f.reg[PC] :
		p->p_md.md_regs[RA];
	trp->sp = (int)&f;
d287 2
a288 2
	type = (causeReg & CR_EXC_CODE) >> CR_EXC_CODE_SHIFT;
	if (USERMODE(statusReg)) {
d297 2
a298 2
	if (statusReg & SR_INT_ENAB)
		splx((statusReg & HARD_INT_MASK) | SR_INT_ENAB);
d303 1
a303 1
		if ((int)vadr < 0) {
d308 1
a308 1
			pte = kvtopte(vadr);
d314 1
a314 1
			if (pmap_is_page_ro(pmap_kernel(), mips_trunc_page(vadr), entry)) {
d321 2
a322 2
			vadr &= ~PGOFSET;
			R4K_TLBUpdate(vadr, entry);
d331 1
a331 1
			return (pc);
d342 1
a342 1
		if (!(pte = pmap_segmap(pmap, vadr)))
d344 1
a344 1
		pte += (vadr >> PGSHIFT) & (NPTEPG - 1);
d351 1
a351 1
		if (pmap_is_page_ro(pmap, (vm_offset_t)mips_trunc_page(vadr), entry)) {
d358 2
a359 2
		vadr = (vadr & ~PGOFSET) | (pmap->pm_tlbpid << VMTLB_PID_SHIFT);
		R4K_TLBUpdate(vadr, entry);
d369 2
a370 2
		if (!USERMODE(statusReg))
			return (pc);
d378 1
a378 1
		if ((int)vadr < 0) {
d383 1
a383 1
			va = trunc_page((vm_offset_t)vadr);
d386 1
a386 1
				return (pc);
d419 1
a419 1
		va = trunc_page((vm_offset_t)vadr);
d423 1
a423 1
		       map, &vm->vm_pmap, va, vadr, ftype, FALSE, rv, pc);
d443 2
a444 2
			if (!USERMODE(statusReg))
				return (pc);
d447 1
a447 1
		if (!USERMODE(statusReg)) {
d475 1
a475 1
		int *locr0 = p->p_md.md_regs;
d486 2
a487 2
		if ((int)causeReg < 0) {	/* Check BD bit */
			locr0[PC] = MipsEmulateBranch(locr0, pc, 0, 0);
d490 1
a490 1
			locr0[PC] += 4;
d494 1
a494 1
		code = locr0[V0];
d500 1
a500 1
			code = locr0[A0];
d506 3
a508 3
			args.i[0] = locr0[A1];
			args.i[1] = locr0[A2];
			args.i[2] = locr0[A3];
d510 1
a510 1
				i = copyin((caddr_t)(locr0[SP] +
d515 2
a516 2
					locr0[V0] = i;
					locr0[A3] = 1;
d536 6
a541 1
			code = locr0[A0 + _QUAD_LOWWORD];
d547 2
a548 2
			args.i[0] = locr0[A2];
			args.i[1] = locr0[A3];
d550 1
a550 1
				i = copyin((caddr_t)(locr0[SP] +
d555 2
a556 2
					locr0[V0] = i;
					locr0[A3] = 1;
d577 4
a580 4
			args.i[0] = locr0[A0];
			args.i[1] = locr0[A1];
			args.i[2] = locr0[A2];
			args.i[3] = locr0[A3];
d582 1
a582 1
				i = copyin((caddr_t)(locr0[SP] +
d587 2
a588 2
					locr0[V0] = i;
					locr0[A3] = 1;
d610 1
a610 1
		rval[1] = locr0[V1];
d627 5
a631 5
		trp->status = statusReg;
		trp->cause = causeReg;
		trp->vadr = locr0[SP];
		trp->pc = locr0[PC];
		trp->ra = locr0[RA];
d640 3
a642 3
			locr0[V0] = rval[0];
			locr0[V1] = rval[1];
			locr0[A3] = 0;
d646 1
a646 1
			locr0[PC] = pc;
d653 2
a654 2
			locr0[V0] = i;
			locr0[A3] = 1;
d671 2
a672 2
		kdb_trap(type, &f);
		return(f.reg[PC]);
d682 2
a683 2
		va = pc;
		if ((int)causeReg < 0)
d690 1
a690 1
			p->p_comm, p->p_pid, instr, pc,
d730 1
a730 1
		if ((causeReg & CR_COP_ERR) != 0x10000000) {
d737 1
a737 1
		p->p_md.md_regs[PS] |= SR_COP_1_BIT;
d746 1
a746 1
			pc, causeReg, statusReg);
d751 1
a751 1
		MipsFPTrap(statusReg, causeReg, pc);
d771 1
a771 1
		stacktrace(!USERMODE(statusReg) ? f.reg : p->p_md.md_regs);
d776 4
a779 4
	p->p_md.md_regs[PC] = pc;
	p->p_md.md_regs[CAUSE] = causeReg;
	p->p_md.md_regs[BADVADDR] = vadr;
	sv.sival_int = vadr;
d816 1
a816 1
		addupc_task(p, pc, (int)(p->p_sticks - sticks) * psratio);
d820 54
a873 1
	return (pc);
d881 2
d884 2
a885 6
interrupt(statusReg, causeReg, what, pc, args)
	u_int statusReg;	/* status register at time of the exception */
	u_int causeReg;		/* cause register at time of exception */
	u_int what;
	u_int pc;		/* program counter where to continue */
	u_int args;
d888 1
d894 2
a895 2
	trp->status = statusReg;
	trp->cause = causeReg;
d897 1
a897 1
	trp->pc = pc;
d899 1
a899 1
	trp->sp = (int)&args;
d906 9
a914 5
	mask = causeReg & statusReg;	/* pending interrupts & enable mask */
	cf.pc = pc;
	cf.sr = statusReg;
	cf.cr = causeReg;

d919 1
d922 1
a922 1
			causeReg &= (*cpu_int_tab[i].int_hand)(mask, &cf);
d928 1
a928 1
	splx((statusReg & ~causeReg & HARD_INT_MASK) | SR_INT_ENAB);
d940 1
a940 1
	    (netisr && (statusReg & SOFT_INT_MASK_1))) {
d1034 1
a1034 1
softintr(statusReg, pc)
a1035 1
	unsigned pc;		/* program counter where to continue */
d1139 2
a1140 2
MipsEmulateBranch(regsPtr, instPC, fpcCSR, instptr)
	int *regsPtr;
d1148 1
d1278 1
a1278 1
	int *locr0 = p->p_md.md_regs;
d1292 1
a1292 1
	uio.uio_offset = (off_t)locr0[PC];
d1301 1
a1301 1
		va = MipsEmulateBranch(locr0, locr0[PC], locr0[FSR], curinstr);
d1304 1
a1304 1
		va = locr0[PC] + 4;
d1356 1
a1356 1
void stacktrace_subr __P((int *, int (*)(const char*, ...)));
d1363 1
a1363 1
	int *regs;
d1370 1
a1370 1
	int *regs;
d1377 1
a1377 1
	int *regs;
d1389 8
a1396 8
	sp = regs[SP];
	pc = regs[PC];
	fp = regs[S8];
	ra = regs[RA];		/* May be a 'leaf' function */
	a0 = regs[A0];
	a1 = regs[A1];
	a2 = regs[A2];
	a3 = regs[A3];
d1423 9
a1431 9
		regs = (int *)(sp + STAND_ARG_SIZE);
		a0 = kdbpeek(&regs[A0]);
		a1 = kdbpeek(&regs[A1]);
		a2 = kdbpeek(&regs[A2]);
		a3 = kdbpeek(&regs[A3]);

		pc = kdbpeek(&regs[PC]); /* exc_pc - pc at time of exception */
		ra = kdbpeek(&regs[RA]); /* ra at time of exception */
		sp = kdbpeek(&regs[SP]);
@


1.16
log
@DDB.

Support for Algorithmics R5000/R10000 evaluation board. So far only the
RM5260 is supported. RM5270 - RM7000 later. R5000 and R10000 depending
on access to cpu modules.

vm_machdep.c moved to arch/mips/mips.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.15 1998/03/01 18:58:30 niklas Exp $	*/
d213 1
a213 1
#ifdef DDB
a225 1
#endif	/* DDB */
a226 1
#ifdef DEBUG	/* stack trace code, also useful for DDB one day */
d230 1
d232 1
d237 1
a237 1
#endif	/* DEBUG */
d277 1
a277 1
#ifdef DDB
d609 1
a609 1
#ifdef DDB
d622 1
a622 1
#ifdef DDB
d740 1
a740 1
#ifdef DDB
d839 1
a839 1
#ifdef DDB
d1014 1
a1014 1
#ifdef DDB
d1292 1
a1292 1
#ifdef DDB
@


1.15
log
@Use MDB instead of DEBUG to enable minidebug
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.13 1998/01/28 13:46:00 pefo Exp $	*/
d72 1
d81 5
d213 1
a213 1
#ifdef MDB
d226 1
a226 1
#endif	/* MDB */
d228 5
a232 3
#ifdef MDB	/* stack trace code, also useful for DDB one day */
void stacktrace __P((int, int, int, int));
void logstacktrace __P((int, int, int, int));
d237 1
a237 3
extern u_int mdbpeek __P((int));
extern int mdb __P((u_int, u_int, struct proc *, int));
#endif	/* MDB */
d247 1
a247 1
u_int trap __P((u_int, u_int, u_int, u_int, u_int));
d261 1
a261 1
trap(statusReg, causeReg, vadr, pc, args)
d266 1
a266 1
	u_int args;
d277 1
a277 1
#ifdef MDB
d282 1
a282 1
	trp->ra = !USERMODE(statusReg) ? ((int *)&args)[19] :
d284 1
a284 1
	trp->sp = (int)&args;
d307 3
a309 3
			register pt_entry_t *pte;
			register unsigned entry;
			register vm_offset_t pa;
d340 3
a342 3
		register pt_entry_t *pte;
		register unsigned entry;
		register vm_offset_t pa;
d382 1
a382 1
			register vm_offset_t va;
d415 3
a417 3
		register vm_offset_t va;
		register struct vmspace *vm;
		register vm_map_t map;
d478 2
a479 2
		register int *locr0 = p->p_md.md_regs;
		register struct sysent *callp;
d489 1
a489 1
		if ((int)causeReg < 0)
d491 2
a492 1
		else
d494 1
d609 1
a609 1
#ifdef MDB
d622 1
a622 1
#ifdef MDB
d667 6
d675 1
a675 1
		register unsigned va, instr;
d740 1
a740 1
#ifdef MDB
d768 2
a769 38
#ifdef MDB
	    {
		extern struct pcb mdbpcb;

		if (USERMODE(statusReg))
			mdbpcb = p->p_addr->u_pcb;
		else {
			mdbpcb.pcb_regs[ZERO] = 0;
			mdbpcb.pcb_regs[AST] = ((int *)&args)[2];
			mdbpcb.pcb_regs[V0] = ((int *)&args)[3];
			mdbpcb.pcb_regs[V1] = ((int *)&args)[4];
			mdbpcb.pcb_regs[A0] = ((int *)&args)[5];
			mdbpcb.pcb_regs[A1] = ((int *)&args)[6];
			mdbpcb.pcb_regs[A2] = ((int *)&args)[7];
			mdbpcb.pcb_regs[A3] = ((int *)&args)[8];
			mdbpcb.pcb_regs[T0] = ((int *)&args)[9];
			mdbpcb.pcb_regs[T1] = ((int *)&args)[10];
			mdbpcb.pcb_regs[T2] = ((int *)&args)[11];
			mdbpcb.pcb_regs[T3] = ((int *)&args)[12];
			mdbpcb.pcb_regs[T4] = ((int *)&args)[13];
			mdbpcb.pcb_regs[T5] = ((int *)&args)[14];
			mdbpcb.pcb_regs[T6] = ((int *)&args)[15];
			mdbpcb.pcb_regs[T7] = ((int *)&args)[16];
			mdbpcb.pcb_regs[T8] = ((int *)&args)[17];
			mdbpcb.pcb_regs[T9] = ((int *)&args)[18];
			mdbpcb.pcb_regs[RA] = ((int *)&args)[19];
			mdbpcb.pcb_regs[MULLO] = ((int *)&args)[21];
			mdbpcb.pcb_regs[MULHI] = ((int *)&args)[22];
			mdbpcb.pcb_regs[PC] = pc;
			mdbpcb.pcb_regs[SR] = statusReg;
			bzero((caddr_t)&mdbpcb.pcb_regs[F0], 33 * sizeof(int));
		}
		if (mdb(causeReg, vadr, p, !USERMODE(statusReg)))
			return (mdbpcb.pcb_regs[PC]);
	    }
#else
#ifdef MDB
		stacktrace();
a771 1
#endif
d827 1
a827 1
interrupt(statusReg, causeReg, pc, what, args)
d830 1
a831 1
	u_int what;
d834 2
a835 2
	register unsigned mask;
	register int i;
d839 1
a839 1
#ifdef MDB
d861 1
a861 1
	for(i = 0; i < 5; i++) {
d938 1
a938 1
	if(prio > 5)
d943 3
a945 2
	    cpu_int_tab[prio].int_hand != int_hand))
		panic("set_intr: int already set");
d965 1
d979 1
a979 1
	register struct proc *p = curproc;
d1014 1
a1014 1
#ifdef MDB
d1019 1
a1019 1
	register int i;
d1216 1
a1216 1
	register struct proc *p;
d1218 2
a1219 2
	register unsigned va;
	register int *locr0 = p->p_md.md_regs;
d1292 1
a1292 1
#ifdef MDB
d1297 1
a1297 1
void stacktrace_subr __P((int, int, int, int, int (*)(const char*, ...)));
d1303 2
a1304 2
stacktrace(a0, a1, a2, a3)
	int a0, a1, a2, a3;
d1306 1
a1306 1
	stacktrace_subr(a0, a1, a2, a3, printf);
d1310 2
a1311 2
logstacktrace(a0, a1, a2, a3)
	int a0, a1, a2, a3;
d1313 1
a1313 1
	stacktrace_subr(a0, a1, a2, a3, addlog);
d1317 2
a1318 2
stacktrace_subr(a0, a1, a2, a3, printfn)
	int a0, a1, a2, a3;
d1322 1
a1325 1
	int regs[3];
a1326 1
	extern void cpu_getregs __P((int *));
a1328 2
	cpu_getregs(regs);

d1330 8
a1337 4
	sp = regs[0];
	pc = regs[1];
	ra = 0;
	fp = regs[2];
a1340 1
	ra = 0;
a1361 1
		/* NOTE: the offsets depend on the code in locore.s */
d1364 9
a1372 8
		a0 = mdbpeek(sp + 36);
		a1 = mdbpeek(sp + 40);
		a2 = mdbpeek(sp + 44);
		a3 = mdbpeek(sp + 48);

		pc = mdbpeek(sp + 20);	/* exc_pc - pc at time of exception */
		ra = mdbpeek(sp + 92);	/* ra at time of exception */
		sp = sp + 108;
d1422 1
a1422 1
		while ((instr = mdbpeek(va)) != MIPS_JR_RA)
d1426 1
a1426 1
		while ((instr = mdbpeek(va)) == 0)
d1432 1
a1432 1
	 * Jump here for locore entry pointsn for which the preceding
d1444 1
a1444 1
		instr = mdbpeek(va);
d1491 1
a1491 1
				a0 = mdbpeek(sp + (short)i.IType.imm);
d1495 1
a1495 1
				a1 = mdbpeek(sp + (short)i.IType.imm);
d1499 1
a1499 1
				a2 = mdbpeek(sp + (short)i.IType.imm);
d1503 1
a1503 1
				a3 = mdbpeek(sp + (short)i.IType.imm);
d1507 1
a1507 1
				fp = mdbpeek(sp + (short)i.IType.imm);
d1511 1
a1511 1
				ra = mdbpeek(sp + (short)i.IType.imm);
d1583 1
a1583 1
#endif /* MDB */
@


1.14
log
@GCC 2.8 type safety + explicit typing
@
text
@d2 1
a42 1
 *      $Id: trap.c,v 1.13 1998/01/28 13:46:00 pefo Exp $
d207 1
a207 1
#ifdef DEBUG
d220 1
a220 1
#endif	/* DEBUG */
d222 1
a222 1
#ifdef DEBUG	/* stack trace code, also useful for DDB one day */
d231 1
a231 1
#endif	/* DEBUG */
d271 1
a271 1
#ifdef DEBUG
d601 1
a601 1
#ifdef DEBUG
d614 1
a614 1
#ifdef DEBUG
d726 1
a726 1
#ifdef DEBUG
d754 1
a754 1
#ifdef DEBUG
d790 1
a790 1
#ifdef DEBUG
d862 1
a862 1
#ifdef DEBUG
d1035 1
a1035 1
#ifdef DEBUG
d1313 1
a1313 1
#ifdef DEBUG
d1604 1
a1604 1
#endif /* DEBUG */
@


1.13
log
@Moving around files for new mips arch layout
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.12 1997/07/23 07:00:39 denny Exp $	*/
d42 1
a42 1
 *      $Id: trap.c,v 1.12 1997/07/23 07:00:39 denny Exp $
d262 1
a262 1
	register int type, i;
d264 1
a264 1
	register struct proc *p = curproc;
d269 1
d800 2
a801 1
	trapsignal(p, i, ucode, typ, (caddr_t)vadr);
d1348 1
a1348 1
	extern cpu_getregs __P((int *));
@


1.12
log
@Add AppleTalk netisr. Only tested (indeed, only compiled) on mac68k port.
Add options NETATALK to your config to try it out.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11 1997/04/19 17:19:48 pefo Exp $	*/
d42 1
a42 1
 *      $Id: trap.c,v 1.11 1997/04/19 17:19:48 pefo Exp $
d78 1
a78 1
#include <arc/arc/arctype.h>
d85 6
a90 6
extern void MachKernGenException __P((void));
extern void MachUserGenException __P((void));
extern void MachKernIntr __P((void));
extern void MachUserIntr __P((void));
extern void MachTLBModException __P((void));
extern void MachTLBInvalidException __P((void));
d96 32
a127 32
	MachKernIntr,			/* external interrupt */
	MachKernGenException,		/* TLB modification */
	MachTLBInvalidException,	/* TLB miss (load or instr. fetch) */
	MachTLBInvalidException,	/* TLB miss (store) */
	MachKernGenException,		/* address error (load or I-fetch) */
	MachKernGenException,		/* address error (store) */
	MachKernGenException,		/* bus error (I-fetch) */
	MachKernGenException,		/* bus error (load or store) */
	MachKernGenException,		/* system call */
	MachKernGenException,		/* breakpoint */
	MachKernGenException,		/* reserved instruction */
	MachKernGenException,		/* coprocessor unusable */
	MachKernGenException,		/* arithmetic overflow */
	MachKernGenException,		/* trap exception */
	MachKernGenException,		/* viritual coherence exception inst */
	MachKernGenException,		/* floating point exception */
	MachKernGenException,		/* reserved */
	MachKernGenException,		/* reserved */
	MachKernGenException,		/* reserved */
	MachKernGenException,		/* reserved */
	MachKernGenException,		/* reserved */
	MachKernGenException,		/* reserved */
	MachKernGenException,		/* reserved */
	MachKernGenException,		/* watch exception */
	MachKernGenException,		/* reserved */
	MachKernGenException,		/* reserved */
	MachKernGenException,		/* reserved */
	MachKernGenException,		/* reserved */
	MachKernGenException,		/* reserved */
	MachKernGenException,		/* reserved */
	MachKernGenException,		/* reserved */
	MachKernGenException,		/* viritual coherence exception data */
d131 32
a162 32
	MachUserIntr,			/*  0 */
	MachUserGenException,		/*  1 */
	MachUserGenException,		/*  2 */
	MachUserGenException,		/*  3 */
	MachUserGenException,		/*  4 */
	MachUserGenException,		/*  5 */
	MachUserGenException,		/*  6 */
	MachUserGenException,		/*  7 */
	MachUserGenException,		/*  8 */
	MachUserGenException,		/*  9 */
	MachUserGenException,		/* 10 */
	MachUserGenException,		/* 11 */
	MachUserGenException,		/* 12 */
	MachUserGenException,		/* 13 */
	MachUserGenException,		/* 14 */
	MachUserGenException,		/* 15 */
	MachUserGenException,		/* 16 */
	MachUserGenException,		/* 17 */
	MachUserGenException,		/* 18 */
	MachUserGenException,		/* 19 */
	MachUserGenException,		/* 20 */
	MachUserGenException,		/* 21 */
	MachUserGenException,		/* 22 */
	MachUserGenException,		/* 23 */
	MachUserGenException,		/* 24 */
	MachUserGenException,		/* 25 */
	MachUserGenException,		/* 26 */
	MachUserGenException,		/* 27 */
	MachUserGenException,		/* 28 */
	MachUserGenException,		/* 29 */
	MachUserGenException,		/* 20 */
	MachUserGenException,		/* 31 */
d228 1
a228 1
extern void MachTLBMiss __P((void));
d235 2
a236 3
extern u_int cputype;
extern void MachSwitchFPState __P((struct proc *, int *));
extern void MachFPTrap __P((u_int, u_int, u_int));
d245 1
a245 1
u_int MachEmulateBranch __P((int *, int, int, u_int));
d249 1
a249 1
 * Called from MachKernGenException() or MachUserGenException()
d483 1
a483 1
			locr0[PC] = MachEmulateBranch(locr0, pc, 0, 0);
d718 1
a718 1
		MachSwitchFPState(machFPCurProcPtr, p->p_md.md_regs);
d734 1
a734 1
		MachFPTrap(statusReg, causeReg, pc);
d844 1
a844 1
 * Called from MachKernIntr() or MachUserIntr()
d974 1
a974 1
	switch(cputype) {
d990 1
a990 1
 * This is called from MachUserIntr() if astpending is set.
d1100 1
a1100 1
MachEmulateBranch(regsPtr, instPC, fpcCSR, instptr)
d1161 1
a1161 1
			panic("MachEmulateBranch: Bad branch cond");
d1261 1
a1261 1
		va = MachEmulateBranch(locr0, locr0[PC], locr0[FSR], curinstr);
d1380 1
a1380 1
	if (pc >= (unsigned)MachKernIntr && pc < (unsigned)MachUserIntr) {
d1382 2
a1383 2
		(*printfn)("MachKernIntr+%x: (%x, %x ,%x) -------\n",
		       pc-(unsigned)MachKernIntr, a0, a1, a2);
d1406 8
a1413 8
	if (pcBetween(MachKernGenException, MachUserGenException))
		subr = (unsigned) MachKernGenException;
	else if (pcBetween(MachUserGenException,MachKernIntr))
		subr = (unsigned) MachUserGenException;
	else if (pcBetween(MachKernIntr, MachUserIntr))
		subr = (unsigned) MachKernIntr;
	else if (pcBetween(MachUserIntr, MachTLBInvalidException))
		subr = (unsigned) MachUserIntr;
d1423 1
a1423 1
	else if (pc >= (unsigned)MachTLBMiss && pc < (unsigned)setsoftclock) {
d1576 4
a1579 4
	Name(MachKernGenException),
	Name(MachUserGenException),
	Name(MachKernIntr),
	Name(MachUserIntr),
@


1.11
log
@-Wall cleanup.
Change to new MI assym.h file generation. (genassym.cf)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.10 1997/03/12 19:16:47 pefo Exp $	*/
d42 1
a42 1
 *      $Id: trap.c,v 1.10 1997/03/12 19:16:47 pefo Exp $
d915 6
@


1.10
log
@Addition of support for a PCI based Vr4300 board from Algorithmics, the P-4032.
Changes to io macros were done to handle sparse bus addressing dynamically.
This is a first cut (rough).
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.9 1997/02/04 17:26:14 deraadt Exp $	*/
d42 1
a42 1
 *      $Id: trap.c,v 1.9 1997/02/04 17:26:14 deraadt Exp $
d45 2
d60 1
d67 1
d85 6
a90 7
extern void MachKernGenException();
extern void MachUserGenException();
extern void MachKernIntr();
extern void MachUserIntr();
extern void MachTLBModException();
extern void MachTLBInvalidException();
extern unsigned MachEmulateBranch();
d92 1
a92 1
void (*machExceptionTable[])() = {
d202 1
a202 1
	int	(*int_hand)();
d218 2
d223 2
a224 2
extern void stacktrace();
extern void logstacktrace();
d227 4
a230 2
extern void idle(), cpu_switch(), splx(), wbflush();
extern void MachTLBMiss();
a232 1
static void arc_errintr();
a233 1
extern volatile struct chiptime *Mach_clock_addr;
d236 11
d255 1
a255 1
unsigned
d257 5
a261 4
	unsigned statusReg;	/* status register at time of the exception */
	unsigned causeReg;	/* cause register at time of exception */
	unsigned vadr;		/* address (if any) the fault occured on */
	unsigned pc;		/* program counter where to continue */
d348 1
a348 1
		if (pmap_is_page_ro(pmap, mips_trunc_page(vadr), entry)) {
d384 1
a384 1
			if (i = ((struct pcb *)UADDR)->pcb_onfault) {
d445 1
a445 1
			if (i = ((struct pcb *)UADDR)->pcb_onfault) {
d746 1
a746 1
		if (i = ((struct pcb *)UADDR)->pcb_onfault) {
d848 1
d850 5
a854 3
	unsigned statusReg;	/* status register at time of the exception */
	unsigned causeReg;	/* cause register at time of exception */
	unsigned pc;		/* program counter where to continue */
d903 1
a903 1
	    netisr && (statusReg & SOFT_INT_MASK_1)) {
a928 1
#include "ppp.h"
d951 1
a951 1
	int	(*int_hand)();
d988 1
d1029 1
d1055 1
a1074 1
#if 0
d1087 1
a1088 1
}
d1095 5
a1099 5
MachEmulateBranch(regsPtr, instPC, fpcCSR, allowNonBranch)
	unsigned *regsPtr;
	unsigned instPC;
	unsigned fpcCSR;
	int allowNonBranch;
d1109 2
a1110 2
	if(allowNonBranch == 0) {
		inst = *(InstFmt *)instPC;
d1113 1
a1113 1
		inst = *(InstFmt *)&allowNonBranch;
a1127 2
			if (!allowNonBranch)
				panic("MachEmulateBranch: Non-branch");
a1212 2
			if (!allowNonBranch)
				panic("MachEmulateBranch: Bad coproc branch instruction");
a1217 2
		if (!allowNonBranch)
			panic("MachEmulateBranch: Non-branch instruction");
a1219 3
#if 0
	printf("Target addr=%x\n", retAddr); /* XXX */
#endif
d1228 1
a1306 11
kdbpeek(addr)
{
	if (addr & 3) {
		printf("kdbpeek: unaligned address %x\n", addr);
		return (-1);
	}
	return (*(int *)addr);
}
#endif

#ifdef DEBUG
d1340 2
a1341 2
	extern setsoftclock();
	extern char start[], edata[];
d1379 4
a1382 4
		a0 = kdbpeek(sp + 36);
		a1 = kdbpeek(sp + 40);
		a2 = kdbpeek(sp + 44);
		a3 = kdbpeek(sp + 48);
d1384 2
a1385 2
		pc = kdbpeek(sp + 20);	/* exc_pc - pc at time of exception */
		ra = kdbpeek(sp + 92);	/* ra at time of exception */
d1436 1
a1436 1
		while ((instr = kdbpeek(va)) != MIPS_JR_RA)
d1440 1
a1440 1
		while ((instr = kdbpeek(va)) == 0)
a1448 1
stackscan:
d1458 1
a1458 1
		instr = kdbpeek(va);
d1505 1
a1505 1
				a0 = kdbpeek(sp + (short)i.IType.imm);
d1509 1
a1509 1
				a1 = kdbpeek(sp + (short)i.IType.imm);
d1513 1
a1513 1
				a2 = kdbpeek(sp + (short)i.IType.imm);
d1517 1
a1517 1
				a3 = kdbpeek(sp + (short)i.IType.imm);
d1521 1
a1521 1
				fp = kdbpeek(sp + (short)i.IType.imm);
d1525 1
a1525 1
				ra = kdbpeek(sp + (short)i.IType.imm);
@


1.9
log
@send VM_PROT_* code for si_trapno
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.8 1997/02/02 00:47:43 deraadt Exp $	*/
d42 1
a42 1
 *      $Id: trap.c,v 1.8 1997/02/02 00:47:43 deraadt Exp $
a266 1
	cnt.v_trap++;
d840 1
d938 3
a940 1
	if(cpu_int_tab[prio].int_mask != 0)
d959 2
@


1.8
log
@attempt at siginfo.. Per must look this over
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.7 1997/01/28 03:54:53 deraadt Exp $	*/
d42 1
a42 1
 *      $Id: trap.c,v 1.7 1997/01/28 03:54:53 deraadt Exp $
d435 1
a435 1
		ucode = vadr;
d443 1
d449 1
@


1.7
log
@add addr arg to sendsig/trapsignal; no siginfo_t support yet
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.6 1996/09/14 15:58:18 pefo Exp $	*/
d42 1
a42 1
 *      $Id: trap.c,v 1.6 1996/09/14 15:58:18 pefo Exp $
d252 1
d437 1
d443 3
d449 1
d661 1
d686 1
d692 1
d698 1
d722 1
d782 1
a782 1
	trapsignal(p, i, ucode, (caddr_t)vadr);
@


1.6
log
@First shot at a multivendor kernel. This version handles pica's and desk-
station tyne's. Auto detection still needs to be compleeted.
Checked in version is hardwired for pica's. Use the PICA config file.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.5 1996/09/02 11:33:24 pefo Exp $	*/
d42 1
a42 1
 *      $Id: trap.c,v 1.5 1996/09/02 11:33:24 pefo Exp $
d771 1
a771 1
	trapsignal(p, i, ucode);
@


1.5
log
@ZAP GENERIC!
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.4 1996/08/26 11:11:56 pefo Exp $	*/
d42 1
a42 1
 *      $Id: trap.c,v 1.4 1996/08/26 11:11:56 pefo Exp $
d338 1
a338 2
		vadr = (vadr & ~PGOFSET) |
			(pmap->pm_tlbpid << VMTLB_PID_SHIFT);
d842 3
d852 1
a852 1
			causeReg &= (*cpu_int_tab[i].int_hand)(mask, pc, statusReg, causeReg);
@


1.4
log
@Changes and bugfixes in memory handling system.
Sysmap too small.
Alloc map page failure.
Support for discontigous memory. Needs testing.
Name changes. "Mach" removal.
Kernel memory size increased.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.3 1996/07/30 20:24:18 pefo Exp $	*/
d42 1
a42 1
 *      $Id: trap.c,v 1.3 1996/07/30 20:24:18 pefo Exp $
d939 3
a941 1
	case DESKSTATION:
@


1.3
log
@Cleanup, endian and abi stuff fixies. Some stuff added for MIPS Magnum.
(PICA and Magnum uses very similar core chipsets).
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.2 1996/07/16 07:46:14 pefo Exp $	*/
d42 1
a42 1
 *      $Id: trap.c,v 1.2 1996/07/16 07:46:14 pefo Exp $
d302 1
a302 1
			MachTLBUpdate(vadr, entry);
d340 1
a340 1
		MachTLBUpdate(vadr, entry);
d624 1
a624 1
			MachFlushCache();
d672 1
a672 1
		MachFlushCache();
d1260 1
a1260 1
	MachFlushCache();
@


1.2
log
@Rename some 'pica' names to 'mips'.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.1.1.1 1996/06/24 09:07:21 pefo Exp $	*/
d42 1
a42 1
 *      $Id: trap.c,v 1.1.1.1 1996/06/24 09:07:21 pefo Exp $
d74 1
d230 1
d910 5
a914 1

d920 1
a920 1
	if(prio > 4)
d933 9
a941 1
	out32(PICA_SYS_EXT_IMASK, cpu_int_mask & (~INT_MASK_4 >> 10));
d1288 1
a1288 1
void stacktrace_subr __P((int, int, int, int, void (*)(const char*, ...)));
d1310 1
a1310 1
	void (*printfn) __P((const char*, ...));
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
 *      $Id: trap.c,v 1.7 1996/06/06 23:07:46 deraadt Exp $
d292 1
a292 1
			if (pmap_is_page_ro(pmap_kernel(), pica_trunc_page(vadr), entry)) {
d329 1
a329 1
		if (pmap_is_page_ro(pmap, pica_trunc_page(vadr), entry)) {
@


1.1.1.1
log
@Next try. ARC tree import. "New" Mips (spim) ARC compliant systems tree.
This tree will eventually suport viritualy all ARC compliant Mips systems,
that is all we can lay our hands on for porting/testing. It will supersede
the pica tree which will be removed shortly when this tree is functioning.
@
text
@@

