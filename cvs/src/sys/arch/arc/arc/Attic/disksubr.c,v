head	1.21;
access;
symbols
	SMP_SYNC_A:1.21
	SMP_SYNC_B:1.21
	UBC_SYNC_A:1.21
	UBC_SYNC_B:1.21
	SMP:1.21.0.2
	OPENBSD_2_2:1.19.0.2
	OPENBSD_2_2_BASE:1.19
	OPENBSD_2_1:1.14.0.2
	OPENBSD_2_1_BASE:1.14
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	PEFO_960624:1.1.1.1
	PEFO:1.1.1;
locks; strict;
comment	@ * @;


1.21
date	98.01.28.13.45.52;	author pefo;	state dead;
branches;
next	1.20;

1.20
date	98.01.11.20.42.04;	author provos;	state Exp;
branches;
next	1.19;

1.19
date	97.10.18.10.35.02;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.10.02.00.50.53;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.09.29.01.12.20;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.09.23.12.46.38;	author pefo;	state Exp;
branches;
next	1.15;

1.15
date	97.08.08.21.46.36;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	97.05.08.00.14.29;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.04.30.08.40.15;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	97.04.18.20.15.47;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.04.18.14.27.23;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	97.04.06.06.04.29;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.04.05.21.56.04;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.01.24.11.17.12;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.01.14.00.46.42;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.12.09.15.54.58;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.09.27.19.14.08;	author pefo;	state Exp;
branches;
next	1.4;

1.4
date	96.09.22.11.26.09;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	96.09.21.10.15.06;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	96.08.26.11.01.34;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	96.06.24.09.07.20;	author pefo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.06.24.09.07.20;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Moving around files for new mips arch layout
@
text
@/*	$OpenBSD: disksubr.c,v 1.20 1998/01/11 20:42:04 provos Exp $	*/
/*	$NetBSD: disksubr.c,v 1.21 1996/05/03 19:42:03 christos Exp $	*/

/*
 * Copyright (c) 1996 Theo de Raadt
 * Copyright (c) 1982, 1986, 1988 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ufs_disksubr.c	7.16 (Berkeley) 5/4/91
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/syslog.h>
#include <sys/disk.h>

#define	b_cylin	b_resid

#define BOOT_MAGIC 0xAA55
#define BOOT_MAGIC_OFF (DOSPARTOFF+NDOSPART*sizeof(struct dos_partition))

void
dk_establish(dk, dev)
	struct disk *dk;
	struct device *dev;
{
}

/*
 * Attempt to read a disk label from a device
 * using the indicated stategy routine.
 * The label must be partly set up before this:
 * secpercyl, secsize and anything required for a block i/o read
 * operation in the driver's strategy/start routines
 * must be filled in before calling us.
 *
 * If dos partition table requested, attempt to load it and
 * find disklabel inside a DOS partition. Also, if bad block
 * table needed, attempt to extract it as well. Return buffer
 * for use in signalling errors if requested.
 *
 * We would like to check if each MBR has a valid BOOT_MAGIC, but
 * we cannot because it doesn't always exist. So.. we assume the
 * MBR is valid.
 *
 * Returns null on success and an error string on failure.
 */
char *
readdisklabel(dev, strat, lp, osdep)
	dev_t dev;
	void (*strat) __P((struct buf *));
	register struct disklabel *lp;
	struct cpu_disklabel *osdep;
{
	struct dos_partition *dp = osdep->dosparts, *dp2;
	struct dkbad *bdp = &DKBAD(osdep);
	struct buf *bp;
	struct disklabel *dlp;
	char *msg = NULL, *cp;
	int dospartoff, cyl, i, ourpart = -1;

	/* minimal requirements for archtypal disk label */
	if (lp->d_secsize == 0)
		lp->d_secsize = DEV_BSIZE;
	if (lp->d_secperunit == 0)
		lp->d_secperunit = 0x1fffffff;
	lp->d_npartitions = RAW_PART + 1;
	for (i = 0; i < RAW_PART; i++) {
		lp->d_partitions[i].p_size = 0;
		lp->d_partitions[i].p_offset = 0;
	}
	if (lp->d_partitions[i].p_size == 0)
		lp->d_partitions[i].p_size = 0x1fffffff;
	lp->d_partitions[i].p_offset = 0;

	/* get a buffer and initialize it */
	bp = geteblk((int)lp->d_secsize);
	bp->b_dev = dev;

	/* do dos partitions in the process of getting disklabel? */
	dospartoff = 0;
	cyl = LABELSECTOR / lp->d_secpercyl;
	if (dp) {
	        daddr_t part_blkno = DOSBBSECTOR;
		unsigned long extoff = 0;
		int wander = 1, n = 0, loop = 0;

		/*
		 * Read dos partition table, follow extended partitions.
		 * Map the partitions to disklabel entries i-p
		 */
		while (wander && n < 8 && loop < 8) {
		        loop++;
			wander = 0;

			/* read boot record */
			bp->b_blkno = part_blkno;
			bp->b_bcount = lp->d_secsize;
			bp->b_flags = B_BUSY | B_READ;
			bp->b_cylin = part_blkno / lp->d_secpercyl;
			(*strat)(bp);
		     
			/* if successful, wander through dos partition table */
			if (biowait(bp)) {
				msg = "dos partition I/O error";
				goto done;
			}
			bcopy(bp->b_data + DOSPARTOFF, dp, NDOSPART * sizeof(*dp));

			if (ourpart == -1) {
				/* Search for our MBR partition */
				for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
				    i++, dp2++)
					if (get_le(&dp2->dp_size) &&
					    dp2->dp_typ == DOSPTYP_OPENBSD)
						ourpart = i;
				for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
				    i++, dp2++)
					if (get_le(&dp2->dp_size) &&
					    dp2->dp_typ == DOSPTYP_386BSD)
						ourpart = i;
				if (ourpart == -1)
					goto donot;
				/*
				 * This is our MBR partition. need sector address
				 * for SCSI/IDE, cylinder for ESDI/ST506/RLL
				 */
				dp2 = &dp[ourpart];
				dospartoff = get_le(&dp2->dp_start) + part_blkno;
				cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);

				/* XXX build a temporary disklabel */
				lp->d_partitions[0].p_size = get_le(&dp2->dp_size);
				lp->d_partitions[0].p_offset =
					get_le(&dp2->dp_start) + part_blkno;
				if (lp->d_ntracks == 0)
					lp->d_ntracks = dp2->dp_ehd + 1;
				if (lp->d_nsectors == 0)
					lp->d_nsectors = DPSECT(dp2->dp_esect);
				if (lp->d_secpercyl == 0)
					lp->d_secpercyl = lp->d_ntracks *
					    lp->d_nsectors;
			}
donot:
			/*
			 * In case the disklabel read below fails, we want to
			 * provide a fake label in i-p.
			 */
			for (dp2=dp, i=0; i < NDOSPART && n < 8; i++, dp2++) {
				struct partition *pp = &lp->d_partitions[8+n];

				if (dp2->dp_typ == DOSPTYP_OPENBSD)
					continue;
				if (get_le(&dp2->dp_size) > lp->d_secperunit)
					continue;
				if (get_le(&dp2->dp_size))
					pp->p_size = get_le(&dp2->dp_size);
				if (get_le(&dp2->dp_start))
					pp->p_offset =
					    get_le(&dp2->dp_start) + part_blkno;

				switch (dp2->dp_typ) {
				case DOSPTYP_UNUSED:
					for (cp = (char *)dp2;
					    cp < (char *)(dp2 + 1); cp++)
						if (*cp)
							break;
					/*
					 * Was it all zeroes?  If so, it is
					 * an unused entry that we don't
					 * want to show.
					 */
					if (cp == (char *)(dp2 + 1))
					    continue;
					lp->d_partitions[8 + n++].p_fstype =
					    FS_UNUSED;
					break;

				case DOSPTYP_LINUX:
					pp->p_fstype = FS_EXT2FS;
					n++;
					break;

				case DOSPTYP_FAT12:
				case DOSPTYP_FAT16S:
				case DOSPTYP_FAT16B:
				case DOSPTYP_FAT16C:
				case DOSPTYP_FAT32:
					pp->p_fstype = FS_MSDOS;
					n++;
					break;
				case DOSPTYP_EXTEND:
					part_blkno = get_le(&dp2->dp_start) + extoff;
					if (!extoff)
						extoff = get_le(&dp2->dp_start);
					wander = 1;
					break;
				default:
					pp->p_fstype = FS_OTHER;
					n++;
					break;
				}
			}
		}
		lp->d_bbsize = 8192;
		lp->d_sbsize = 64*1024;		/* XXX ? */
		lp->d_npartitions = MAXPARTITIONS;
	}

	/* next, dig out disk label */
	bp->b_blkno = dospartoff + LABELSECTOR;
	bp->b_cylin = cyl;
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_BUSY | B_READ;
	(*strat)(bp);

	/* if successful, locate disk label within block and validate */
	if (biowait(bp)) {
		/* XXX we return the faked label built so far */
		msg = "disk label I/O error";
		goto done;
	}
	for (dlp = (struct disklabel *)bp->b_data;
	    dlp <= (struct disklabel *)(bp->b_data + lp->d_secsize - sizeof(*dlp));
	    dlp = (struct disklabel *)((char *)dlp + sizeof(long))) {
		if (dlp->d_magic != DISKMAGIC || dlp->d_magic2 != DISKMAGIC) {
			if (msg == NULL)
				msg = "no disk label";
		} else if (dlp->d_npartitions > MAXPARTITIONS ||
			   dkcksum(dlp) != 0)
			msg = "disk label corrupted";
		else {
			*lp = *dlp;
			msg = NULL;
			break;
		}
	}

	if (msg) {
#if defined(CD9660)
		if (iso_disklabelspoof(dev, strat, lp) == 0)
			msg = NULL;
#endif
		goto done;
	}

	/* obtain bad sector table if requested and present */
	if (bdp && (lp->d_flags & D_BADSECT)) {
		struct dkbad *db;

		i = 0;
		do {
			/* read a bad sector table */
			bp->b_flags = B_BUSY | B_READ;
			bp->b_blkno = lp->d_secperunit - lp->d_nsectors + i;
			if (lp->d_secsize > DEV_BSIZE)
				bp->b_blkno *= lp->d_secsize / DEV_BSIZE;
			else
				bp->b_blkno /= DEV_BSIZE / lp->d_secsize;
			bp->b_bcount = lp->d_secsize;
			bp->b_cylin = lp->d_ncylinders - 1;
			(*strat)(bp);

			/* if successful, validate, otherwise try another */
			if (biowait(bp)) {
				msg = "bad sector table I/O error";
			} else {
				db = (struct dkbad *)(bp->b_data);
#define DKBAD_MAGIC 0x4321
				if (db->bt_mbz == 0
					&& db->bt_flag == DKBAD_MAGIC) {
					msg = NULL;
					*bdp = *db;
					break;
				} else
					msg = "bad sector table corrupted";
			}
		} while ((bp->b_flags & B_ERROR) && (i += 2) < 10 &&
			i < lp->d_nsectors);
	}

done:
	bp->b_flags |= B_INVAL;
	brelse(bp);
	return (msg);
}

/*
 * Check new disk label for sensibility
 * before setting it.
 */
int
setdisklabel(olp, nlp, openmask, osdep)
	register struct disklabel *olp, *nlp;
	u_long openmask;
	struct cpu_disklabel *osdep;
{
	register i;
	register struct partition *opp, *npp;

	/* sanity clause */
	if (nlp->d_secpercyl == 0 || nlp->d_secsize == 0 ||
	    (nlp->d_secsize % DEV_BSIZE) != 0)
		return(EINVAL);

	/* special case to allow disklabel to be invalidated */
	if (nlp->d_magic == 0xffffffff) {
		*olp = *nlp;
		return (0);
	}

	if (nlp->d_magic != DISKMAGIC || nlp->d_magic2 != DISKMAGIC ||
	    dkcksum(nlp) != 0)
		return (EINVAL);

	/* XXX missing check if other dos partitions will be overwritten */

	while (openmask != 0) {
		i = ffs(openmask) - 1;
		openmask &= ~(1 << i);
		if (nlp->d_npartitions <= i)
			return (EBUSY);
		opp = &olp->d_partitions[i];
		npp = &nlp->d_partitions[i];
		if (npp->p_offset != opp->p_offset || npp->p_size < opp->p_size)
			return (EBUSY);
		/*
		 * Copy internally-set partition information
		 * if new label doesn't include it.		XXX
		 */
		if (npp->p_fstype == FS_UNUSED && opp->p_fstype != FS_UNUSED) {
			npp->p_fstype = opp->p_fstype;
			npp->p_fsize = opp->p_fsize;
			npp->p_frag = opp->p_frag;
			npp->p_cpg = opp->p_cpg;
		}
	}
	nlp->d_checksum = 0;
	nlp->d_checksum = dkcksum(nlp);
	*olp = *nlp;
	return (0);
}


/*
 * Write disk label back to device after modification.
 * XXX cannot handle OpenBSD partitions in extended partitions!
 */
int
writedisklabel(dev, strat, lp, osdep)
	dev_t dev;
	void (*strat) __P((struct buf *));
	register struct disklabel *lp;
	struct cpu_disklabel *osdep;
{
	struct dos_partition *dp = osdep->dosparts, *dp2;
	struct buf *bp;
	struct disklabel *dlp;
	int error, dospartoff, cyl, i;
	int ourpart = -1;

	/* get a buffer and initialize it */
	bp = geteblk((int)lp->d_secsize);
	bp->b_dev = dev;

	/* do dos partitions in the process of getting disklabel? */
	dospartoff = 0;
	cyl = LABELSECTOR / lp->d_secpercyl;
	if (dp) {
		/* read master boot record */
		bp->b_blkno = DOSBBSECTOR;
		bp->b_bcount = lp->d_secsize;
		bp->b_flags = B_BUSY | B_READ;
		bp->b_cylin = DOSBBSECTOR / lp->d_secpercyl;
		(*strat)(bp);

		if ((error = biowait(bp)) != 0)
			goto done;

		/* XXX how do we check veracity/bounds of this? */
		bcopy(bp->b_data + DOSPARTOFF, dp,
		    NDOSPART * sizeof(*dp));

		for (dp2=dp, i=0; i < NDOSPART && ourpart == -1; i++, dp2++)
			if (get_le(&dp2->dp_size) && dp2->dp_typ == DOSPTYP_OPENBSD)
				ourpart = i;
		for (dp2=dp, i=0; i < NDOSPART && ourpart == -1; i++, dp2++)
			if (get_le(&dp2->dp_size) && dp2->dp_typ == DOSPTYP_386BSD)
				ourpart = i;

		if (ourpart != -1) {
			dp2 = &dp[ourpart];

			/*
			 * need sector address for SCSI/IDE,
			 * cylinder for ESDI/ST506/RLL
			 */
			dospartoff = get_le(&dp2->dp_start);
			cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);
		}
	}

	/* next, dig out disk label */
	bp->b_blkno = dospartoff + LABELSECTOR;
	bp->b_cylin = cyl;
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_BUSY | B_READ;
	(*strat)(bp);

	/* if successful, locate disk label within block and validate */
	if ((error = biowait(bp)) != 0)
		goto done;
	for (dlp = (struct disklabel *)bp->b_data;
	    dlp <= (struct disklabel *)(bp->b_data + lp->d_secsize - sizeof(*dlp));
	    dlp = (struct disklabel *)((char *)dlp + sizeof(long))) {
		if (dlp->d_magic == DISKMAGIC && dlp->d_magic2 == DISKMAGIC &&
		    dkcksum(dlp) == 0) {
			*dlp = *lp;
			bp->b_flags = B_BUSY | B_WRITE;
			(*strat)(bp);
			error = biowait(bp);
			goto done;
		}
	}

	/* Write it in the regular place. */
	*(struct disklabel *)bp->b_data = *lp;
	bp->b_flags = B_BUSY | B_WRITE;
	(*strat)(bp);
	error = biowait(bp);
	goto done;

done:
	bp->b_flags |= B_INVAL;
	brelse(bp);
	return (error);
}

/*
 * Determine the size of the transfer, and make sure it is
 * within the boundaries of the partition. Adjust transfer
 * if needed, and signal errors or early completion.
 */
int
bounds_check_with_label(bp, lp, osdep, wlabel)
	struct buf *bp;
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
	int wlabel;
{
#define blockpersec(count, lp) ((count) * (((lp)->d_secsize) / DEV_BSIZE))
	struct partition *p = lp->d_partitions + DISKPART(bp->b_dev);
	int labelsector = blockpersec(lp->d_partitions[RAW_PART].p_offset, lp) +
	    LABELSECTOR;
	int sz = howmany(bp->b_bcount, DEV_BSIZE);

	if (bp->b_blkno + sz > blockpersec(p->p_size, lp)) {
		sz = blockpersec(p->p_size, lp) - bp->b_blkno;
		if (sz == 0) {
			/* If exactly at end of disk, return EOF. */
			bp->b_resid = bp->b_bcount;
			goto done;
		}
		if (sz < 0) {
			/* If past end of disk, return EINVAL. */
			bp->b_error = EINVAL;
			goto bad;
		}
		/* Otherwise, truncate request. */
		bp->b_bcount = sz << DEV_BSHIFT;
	}

	/* Overwriting disk label? */
	if (bp->b_blkno + blockpersec(p->p_offset, lp) <= labelsector &&
#if LABELSECTOR != 0
	    bp->b_blkno + blockpersec(p->p_offset, lp) + sz > labelsector &&
#endif
	    (bp->b_flags & B_READ) == 0 && !wlabel) {
		bp->b_error = EROFS;
		goto bad;
	}

	/* calculate cylinder for disksort to order transfers with */
	bp->b_cylin = (bp->b_blkno + blockpersec(p->p_offset, lp)) /
	    lp->d_secpercyl;
	return (1);

bad:
	bp->b_flags |= B_ERROR;
done:
	return (0);
}
@


1.20
log
@disklabel spoofing for FAT32.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.19 1997/10/18 10:35:02 deraadt Exp $	*/
@


1.19
log
@do not create spoofed partition for DOSTYP_OPENBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.27 1997/10/02 00:50:51 deraadt Exp $	*/
d219 1
@


1.18
log
@no more ESRCH from writedisklabel()
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.26 1997/09/29 01:12:21 deraadt Exp $	*/
d183 2
@


1.17
log
@ignore partitions larger than device, as an attempt to ignore floppies without MBR
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.16 1997/09/23 12:46:38 pefo Exp $	*/
d453 7
a459 1
	error = ESRCH;
@


1.16
log
@Make disksubr byte order independent. This code is now so generic that it
should be able to use it for i386, arc, powerpc, sgi, and more....
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.15 1997/08/08 21:46:36 niklas Exp $	*/
d183 2
@


1.15
log
@Change the bounds_check_with_label API to also take a cpu_disklabel
reference for making transferral of meta-information possible from
readdisklabel to bounds_check_with_label.  The first (and maybe only)
thing that will use this is the multi-disklabel-format code on the
alpha where the labelsector is passed via cpu_disklabel so the label
write-protection can work correctly no matter what label was found.

Also use a new macro DKBAD to get at the dkbad field of the cpu_disklabel
implementations that contain it.  This too is for multi-disklabel
architectures where the "bad" field can be inside a union.  Use this
macro as a means for a driver to check if an architecture supports
dkbad constructs.

Remove proto of bounds_check_with_label from all MD disklabel.h as it
is in sys/disklabel.h.

I have not been able to test the changes everywhere, if I break anything
I apologize, and promise to fix it as soon as I become aware of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.14 1997/05/08 00:14:29 deraadt Exp $	*/
d145 1
a145 1
					if (dp2->dp_size &&
d150 1
a150 1
					if (dp2->dp_size &&
d160 1
a160 1
				dospartoff = dp2->dp_start + part_blkno;
d164 3
a166 3
				lp->d_partitions[0].p_size = dp2->dp_size;
				lp->d_partitions[0].p_offset = dp2->dp_start +
				    part_blkno;
d183 3
a185 3
				if (dp2->dp_size)
					pp->p_size = dp2->dp_size;
				if (dp2->dp_start)
d187 1
a187 1
					    dp2->dp_start + part_blkno;
d219 1
a219 1
					part_blkno = dp2->dp_start + extoff;
d221 1
a221 1
						extoff = dp2->dp_start;
d411 1
a411 1
			if (dp2->dp_size && dp2->dp_typ == DOSPTYP_OPENBSD)
d414 1
a414 1
			if (dp2->dp_size && dp2->dp_typ == DOSPTYP_386BSD)
d424 1
a424 1
			dospartoff = dp2->dp_start;
@


1.14
log
@sync to i386
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.24 1997/05/08 00:05:51 deraadt Exp $	*/
d87 1
a87 1
	struct dkbad *bdp = &osdep->bad;
d465 1
a465 1
bounds_check_with_label(bp, lp, wlabel)
d468 1
@


1.13
log
@guarantee termination for faked disklabels, no endless loops
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.12 1997/04/18 20:15:47 deraadt Exp $	*/
d73 4
d117 1
a117 3
		int wander = 1;
		int n = 0;
		int loop = 0;
a124 2

			/* on finding a extended partition wander further */
a138 7
		     
                	/* 
			 * We would like to check if each MBR has a valid
			 * BOOT_MAGIC, but we cannot because it doesn't
			 * always exist. So.. we assume the MBR is valid.
			 */
		     
a140 3
			/*
			 * Search for our MBR partition
			 */
d142 1
d153 2
a154 5
			}

			if (ourpart != -1) {
				dp2 = &dp[ourpart];

d159 1
d175 1
a175 1

d178 1
a178 2
			 * provide a fake label in which m/n/o/p are MBR 
			 * partitions 0/1/2/3
d180 1
a180 1
			for (dp2=dp, i=0; i < NDOSPART && !wander; i++, dp2++) {
a182 5
/*		       		if (dp2->dp_start + dp2->dp_size > 
				    lp->d_ncylinders * lp->d_secpercyl)
					continue;
*/

d235 1
a235 1
	
d364 2
a365 2
 	nlp->d_checksum = 0;
 	nlp->d_checksum = dkcksum(nlp);
d373 1
d428 1
a428 1
	
@


1.12
log
@do not check BOOT_MAGIC!
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.20 1997/04/18 14:27:22 provos Exp $	*/
d115 1
d121 3
a123 1
		while (wander && n < 8) {
@


1.11
log
@faked disklabel for extended partition +
fixes by Niklas to faciliate use of other partition types (ext2fs) +
Indentation by Theo ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.10 1997/04/06 06:04:29 deraadt Exp $	*/
a114 1
		unsigned char *p;
d137 5
a141 6
                	/* XXX - how do we check veracity/bounds of this? */
			p = (unsigned char *)bp->b_data + BOOT_MAGIC_OFF;
			if ((p[0] | (p[1] << 8)) != BOOT_MAGIC) {
				msg = "dos partition corrupt";
				goto done;
			}
@


1.10
log
@correct labelsector confusion
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.18 1997/04/05 21:56:02 deraadt Exp $	*/
d50 2
a51 2
int fat_types[] = { DOSPTYP_FAT12, DOSPTYP_FAT16S,
		    DOSPTYP_FAT16B, DOSPTYP_FAT16C, -1 };
d86 2
a87 2
	char *msg = NULL;
	int dospartoff, cyl, i, *ip, ourpart = -1;
d111 5
a115 15
		/* read master boot record */
		bp->b_blkno = DOSBBSECTOR;
		bp->b_bcount = lp->d_secsize;
		bp->b_flags = B_BUSY | B_READ;
		bp->b_cylin = DOSBBSECTOR / lp->d_secpercyl;
		(*strat)(bp);

		/* if successful, wander through dos partition table */
		if (biowait(bp)) {
			msg = "dos partition I/O error";
			goto done;
		}

		/* XXX how do we check veracity/bounds of this? */
		bcopy(bp->b_data + DOSPARTOFF, dp, NDOSPART * sizeof(*dp));
d118 2
a119 1
		 * Search for our MBR partition
d121 25
a145 6
		for (dp2=dp, i=0; i < NDOSPART && ourpart == -1; i++, dp2++)
			if (dp2->dp_size && dp2->dp_typ == DOSPTYP_OPENBSD)
				ourpart = i;
		for (dp2=dp, i=0; i < NDOSPART && ourpart == -1; i++, dp2++)
			if (dp2->dp_size && dp2->dp_typ == DOSPTYP_386BSD)
				ourpart = i;
d147 38
a184 2
		if (ourpart != -1) {
			dp2 = &dp[ourpart];
d187 3
a189 2
			 * This is our MBR partition. need sector address
			 * for SCSI/IDE, cylinder for ESDI/ST506/RLL
d191 2
a192 2
			dospartoff = dp2->dp_start;
			cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);
d194 4
a197 11
			/* XXX build a temporary disklabel */
			lp->d_partitions[0].p_size = dp2->dp_size;
			lp->d_partitions[0].p_offset = dp2->dp_start;
			if (lp->d_ntracks == 0)
				lp->d_ntracks = dp2->dp_ehd + 1;
			if (lp->d_nsectors == 0)
				lp->d_nsectors = DPSECT(dp2->dp_esect);
			if (lp->d_secpercyl == 0)
				lp->d_secpercyl = lp->d_ntracks *
				    lp->d_nsectors;
		}
d199 46
a244 14
		/*
		 * In case the disklabel read below fails, we want to provide
		 * a fake label in which m/n/o/p are MBR partitions 0/1/2/3
		 */
		for (dp2=dp, i=0; i < NDOSPART; i++, dp2++) {
			if (dp2->dp_start + dp2->dp_size > lp->d_nsectors)
				continue;
			lp->d_partitions[12+i].p_size = dp2->dp_size;
			lp->d_partitions[12+i].p_offset = dp2->dp_start;
			for (ip = fat_types; *ip != -1; ip++) {
				if (dp2->dp_typ != *ip)
					continue;
				lp->d_partitions[12+i].p_fstype =
				    FS_MSDOS;
@


1.9
log
@correct DEV_BSIZE vs lp->d_secsize confusion; spotted by hte late night icb gang. Other ports need fixing still
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.17 1997/01/24 11:17:09 deraadt Exp $	*/
d413 1
d415 2
a416 1
	int labelsector = lp->d_partitions[RAW_PART].p_offset + LABELSECTOR;
a417 2

#define blockpersec(count, lp) ((count) * (((lp)->d_secsize) / DEV_BSIZE))
@


1.8
log
@do not build fake disklabel partitions for MBR partitions that have out-of-range start/size fields
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.16 1997/01/14 00:46:45 deraadt Exp $	*/
d415 1
a415 1
	int sz;
d417 1
a417 1
	sz = howmany(bp->b_bcount, lp->d_secsize);
d419 2
a420 2
	if (bp->b_blkno + sz > p->p_size) {
		sz = p->p_size - bp->b_blkno;
d436 1
a436 1
	if (bp->b_blkno + p->p_offset <= labelsector &&
d438 1
a438 1
	    bp->b_blkno + p->p_offset + sz > labelsector &&
d446 2
a447 2
	bp->b_cylin = (bp->b_blkno + p->p_offset) /
	    (lp->d_secsize / DEV_BSIZE) / lp->d_secpercyl;
@


1.7
log
@RAW_PART
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.6 1996/12/09 15:54:58 deraadt Exp $	*/
d164 2
@


1.6
log
@arc port can use the same disksubr code, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.14 1996/12/09 07:19:22 deraadt Exp $	*/
d412 1
a412 1
	int labelsector = lp->d_partitions[2].p_offset + LABELSECTOR;
@


1.5
log
@OpenBSD changes
@
text
@d1 2
a2 1
/*	$OpenBSD: disksubr.c,v 1.4 1996/09/22 11:26:09 pefo Exp $	*/
d5 2
a6 1
 * Copyright (c) 1994, 1995 Carnegie-Mellon University.
d9 15
a23 13
 * Authors: Keith Bostic, Chris G. Demetriou, Per Fogelstrom (R4000)
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
d25 11
a35 4
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
d37 1
a37 2
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
d41 1
a42 1
#include <sys/ioccom.h>
d45 1
d48 1
a48 2
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
d50 2
a51 2
#include <machine/cpu.h>
#include <machine/autoconf.h>
a52 3
extern struct device *bootdv;

/* was this the boot device ? */
d61 2
a62 1
 * Attempt to read a disk label from a device * using the indicated stategy routine.
d64 9
a72 2
 *     secpercyl and anything required in the strategy routine
 *     (e.g., sector size) must be filled in before calling us.
d76 1
a76 1
readdisklabel(dev, strat, lp, clp)
d78 3
a80 3
	void (*strat)();
	struct disklabel *lp;
	struct cpu_disklabel *clp;
d82 2
a85 1
	struct dos_partition *dp = clp->dosparts;
d87 1
a87 1
	int dospart, dospartoff, i;
d90 2
d93 1
a93 1
		lp->d_secperunit = 0x1fffffff; 
d95 1
a95 1
	for(i = 0; i < RAW_PART; i++) {
d99 3
a101 3
	if (lp->d_partitions[RAW_PART].p_size == 0)
		lp->d_partitions[RAW_PART].p_size = 0x1fffffff;
	lp->d_partitions[RAW_PART].p_offset = 0;
d103 1
a103 1
	/* obtain buffer to probe drive with */
a105 2
	dospartoff = 0;
	dospart = -1;
d108 2
d115 1
a115 1
		bp->b_resid = 0;
d123 48
a170 28
		if (*(unsigned int *)(bp->b_data) == 0x8efac033) {
			/* XXX how do we check veracity/bounds of this? */
			bcopy(bp->b_data + DOSPARTOFF, dp, NDOSPART * sizeof(*dp));

			for (i = 0, dp = clp->dosparts; i < NDOSPART; i++, dp++) {
				if (dp->dp_size && dp->dp_typ == DOSPTYP_OPENBSD
				    && dospart < 0)
					dospart = i;
			}
			for (i = 0, dp = clp->dosparts; i < NDOSPART; i++, dp++) {
				if (dp->dp_size && dp->dp_typ == DOSPTYP_386BSD
				    && dospart < 0)
					dospart = i;
			}
			if(dospart >= 0) {
				/*
				 * set part a to show OpenBSD part
				 */
				dp = clp->dosparts+dospart;
				dospartoff = dp->dp_start;

				lp->d_partitions[0].p_size = dp->dp_size;
				lp->d_partitions[0].p_offset = dp->dp_start;
				lp->d_partitions[RAW_PART].p_size = dp->dp_size;
				lp->d_partitions[RAW_PART].p_offset = dp->dp_start;
				lp->d_ntracks = dp->dp_ehd + 1;
				lp->d_nsectors = DPSECT(dp->dp_esect);
				lp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;
d173 3
a175 1
			
d177 1
d180 1
a180 1
	bp->b_resid = 0;
d183 1
a183 1
	(*strat)(bp);  
d187 2
a188 1
		msg = "disk label read error";
d191 15
d207 5
a211 7
	dlp = (struct disklabel *)(bp->b_un.b_addr + LABELOFFSET);
	if (dlp->d_magic == DISKMAGIC) {
		if (dkcksum(dlp)) {
			msg = "OpenBSD disk label corrupted";
			goto done;
		}
		*lp = *dlp;
d214 36
a249 1
	msg = "no disk label";
d251 1
a251 1
	bp->b_flags = B_INVAL | B_AGE | B_READ;
d257 2
a258 1
 * Check new disk label for sensibility before setting it.
d261 1
a261 1
setdisklabel(olp, nlp, openmask, clp)
d264 1
a264 1
	struct cpu_disklabel *clp;
d274 6
d281 1
a281 1
		dkcksum(nlp) != 0)
d284 4
a287 2
	while ((i = ffs((long)openmask)) != 0) {
		i--;
d296 3
a298 3
		* Copy internally-set partition information
		* if new label doesn't include it.             XXX
		*/
d306 2
a307 2
	nlp->d_checksum = 0;
	nlp->d_checksum = dkcksum(nlp);
d309 1
a309 1
	return (0);     
d312 1
a314 2
 * this means write out the Rigid disk blocks to represent the 
 * label.  Hope the user was carefull.
d317 1
a317 1
writedisklabel(dev, strat, lp, clp)
d319 1
a319 1
	void (*strat)();
d321 1
a321 1
	struct cpu_disklabel *clp;
d323 2
a324 1
	struct buf *bp; 
d326 2
a327 3
	struct dos_partition *dp = clp->dosparts;
	int error = 0, i;
	int dospart, dospartoff;
d329 1
a331 2
	dospart = -1;
	dospartoff = 0;
d334 2
d341 1
a341 1
		bp->b_resid = 0;
d344 23
a366 19
		if (((error = biowait(bp)) == 0) 
		   && *(unsigned int *)(bp->b_data) == 0x8efac033) {
			/* XXX how do we check veracity/bounds of this? */
			bcopy(bp->b_data + DOSPARTOFF, dp, NDOSPART * sizeof(*dp));

			for (i = 0, dp = clp->dosparts; i < NDOSPART; i++, dp++) {
				if (dp->dp_size && dp->dp_typ == DOSPTYP_OPENBSD
				    && dospart < 0) {
					dospart = i;
					dospartoff = dp->dp_start;
				}
			}
			for (i = 0, dp = clp->dosparts; i < NDOSPART; i++, dp++) {
				if (dp->dp_size && dp->dp_typ == DOSPTYP_386BSD
				    && dospart < 0) {
					dospart = i;
					dospartoff = dp->dp_start;
				}
			}
a367 1
			
d369 2
d372 1
a372 1
	bp->b_resid = 0;
d374 1
a374 1
	bp->b_flags = B_READ;           /* get current label */
d376 3
a378 1
	if (error = biowait(bp))
d380 13
a392 7

	dlp = (struct disklabel *)(bp->b_un.b_addr + LABELOFFSET);
	*dlp = *lp;     /* struct assignment */

	bp->b_flags = B_WRITE;
	(*strat)(bp);
	error = biowait(bp);
d395 1
d397 1
a397 1
	return (error); 
d400 1
a400 2

/* 
d411 10
a420 19
#define dkpart(dev) (minor(dev) % MAXPARTITIONS )

	struct partition *p = lp->d_partitions + dkpart(bp->b_dev);
	int labelsect = lp->d_partitions[RAW_PART].p_offset;
	int maxsz = p->p_size;
	int sz = (bp->b_bcount + DEV_BSIZE - 1) >> DEV_BSHIFT;

	/* overwriting disk label ? */
	/* XXX should also protect bootstrap in first 8K */ 
	if (bp->b_blkno + p->p_offset == LABELSECTOR + labelsect &&
	    (bp->b_flags & B_READ) == 0 && wlabel == 0) {
		bp->b_error = EROFS;
		goto bad;
	}

	/* beyond partition? */ 
	if (bp->b_blkno < 0 || bp->b_blkno + sz > maxsz) {
		/* if exactly at end of disk, return an EOF */
		if (bp->b_blkno == maxsz) {
d422 1
a422 1
			return(0);
d424 2
a425 3
		/* or truncate if part of it fits */
		sz = maxsz - bp->b_blkno;
		if (sz <= 0) {
d429 1
d431 11
a441 1
	}               
d444 4
a447 2
	bp->b_resid = (bp->b_blkno + p->p_offset) / lp->d_secpercyl;
	return(1);
d450 2
a451 1
	return(-1);
@


1.4
log
@We run OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.3 1996/09/21 10:15:06 pefo Exp $	*/
d54 1
a54 2
 * Attempt to read a disk label from a device
 * using the indicated stategy routine.
d56 2
a57 2
 * secpercyl and anything required in the strategy routine
 * (e.g., sector size) must be filled in before calling us.
d71 1
a71 2
	int dospartoff = 0;
	int i;
d88 2
d104 2
a105 1
		} else if (*(unsigned int *)(bp->b_data) == 0x8efac033) {
d108 7
a114 2
			for (i = 0; i < NDOSPART; i++, dp++) {
				/* is this ours? */
d116 17
a132 10
				    && dospartoff == 0) {
					dospartoff = dp->dp_start;

					/* set part a to show OpenBSD part */
					lp->d_partitions[0].p_size = dp->dp_size;
					lp->d_partitions[0].p_offset = dp->dp_start;
					lp->d_ntracks = dp->dp_ehd + 1;
					lp->d_nsectors = DPSECT(dp->dp_esect);
					lp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;
				}
d229 1
a229 1
	int dospartoff = 0;
d233 2
d249 9
a257 2
			for (i = 0; i < NDOSPART; i++, dp++) {
				/* is this ours? */
d259 2
a260 1
				    && dospartoff == 0) {
@


1.3
log
@pefo you're a clown!!
@
text
@d1 1
a1 2
/*	$OpenBSD: disksubr.c,v 1.2 1996/08/26 11:01:34 pefo Exp $	*/
/*	$NetBSD: disksubr.c,v 1.3 1995/04/22 12:43:22 cgd Exp $	*/
d113 1
a113 1
					/* set part a to show NetBSD part */
d140 1
a140 1
			msg = "NetBSD disk label corrupted";
@


1.2
log
@Allow for 16 partition disklabels, hepp!
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.1.1.1 1996/06/24 09:07:20 pefo Exp $	*/
d105 1
a105 1
		} else if (*(unsigned int *)(bp->b_data) == 0x8ec033fa) {
d232 1
a232 1
		   && *(unsigned int *)(bp->b_data) == 0x8ec033fa) {
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a170 9
#ifdef notdef
	/* XXX WHY WAS THIS HERE?! */
	/* special case to allow disklabel to be invalidated */
	if (nlp->d_magic == 0xffffffff) { 
		*olp = *nlp;
		return (0);
	}
#endif

d277 1
a277 1
#define dkpart(dev) (minor(dev) & 7)
@


1.1.1.1
log
@Next try. ARC tree import. "New" Mips (spim) ARC compliant systems tree.
This tree will eventually suport viritualy all ARC compliant Mips systems,
that is all we can lay our hands on for porting/testing. It will supersede
the pica tree which will be removed shortly when this tree is functioning.
@
text
@@
