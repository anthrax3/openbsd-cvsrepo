head	1.52;
access;
symbols
	OPENBSD_6_0:1.52.0.4
	OPENBSD_6_0_BASE:1.52
	OPENBSD_5_9:1.52.0.2
	OPENBSD_5_9_BASE:1.52
	OPENBSD_5_8:1.51.0.4
	OPENBSD_5_8_BASE:1.51
	OPENBSD_5_7:1.49.0.4
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.49.0.8
	OPENBSD_5_6_BASE:1.49
	OPENBSD_5_5:1.49.0.6
	OPENBSD_5_5_BASE:1.49
	OPENBSD_5_4:1.49.0.2
	OPENBSD_5_4_BASE:1.49
	OPENBSD_5_3:1.46.0.6
	OPENBSD_5_3_BASE:1.46
	OPENBSD_5_2:1.46.0.4
	OPENBSD_5_2_BASE:1.46
	OPENBSD_5_1_BASE:1.46
	OPENBSD_5_1:1.46.0.2
	OPENBSD_5_0:1.45.0.2
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.43.0.4
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.43.0.2
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.40.0.8
	OPENBSD_4_7_BASE:1.40
	OPENBSD_4_6:1.40.0.10
	OPENBSD_4_6_BASE:1.40
	OPENBSD_4_5:1.40.0.6
	OPENBSD_4_5_BASE:1.40
	OPENBSD_4_4:1.40.0.4
	OPENBSD_4_4_BASE:1.40
	OPENBSD_4_3:1.40.0.2
	OPENBSD_4_3_BASE:1.40
	OPENBSD_4_2:1.39.0.2
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.37.0.4
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.37.0.2
	OPENBSD_4_0_BASE:1.37
	OPENBSD_3_9:1.35.0.2
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.30.0.2
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.29.0.4
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.29.0.2
	OPENBSD_3_6_BASE:1.29
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.27.0.4
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	UBC_SYNC_A:1.26
	OPENBSD_3_3:1.26.0.6
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.26.0.4
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	UBC_SYNC_B:1.26
	UBC:1.22.0.2
	UBC_BASE:1.22
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.15.0.4
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	SMP:1.12.0.2
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.10.0.4
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.52
date	2015.11.05.22.41.32;	author miod;	state Exp;
branches;
next	1.51;
commitid	QjA1fBoOLxnsf5lX;

1.51
date	2015.03.30.20.30.22;	author miod;	state Exp;
branches;
next	1.50;
commitid	f66FukLLgPJs9j5H;

1.50
date	2015.03.18.20.56.40;	author miod;	state Exp;
branches;
next	1.49;
commitid	1t8JWNihm6Vc4kyS;

1.49
date	2013.03.26.05.04.10;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2013.03.25.17.46.24;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2013.03.23.16.12.27;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2011.09.08.03.40.32;	author guenther;	state Exp;
branches;
next	1.45;

1.45
date	2011.04.07.15.45.18;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2011.03.23.16.54.37;	author pirofti;	state Exp;
branches;
next	1.43;

1.43
date	2010.07.11.14.09.10;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2010.07.10.19.32.24;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2010.06.29.21.26.09;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2007.11.28.16.33.20;	author martin;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.28.21.02.49;	author thib;	state Exp;
branches;
next	1.38;

1.38
date	2007.04.10.16.43.37;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2006.08.12.17.54.38;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.19.01.47.24;	author martin;	state Exp;
branches;
next	1.35;

1.35
date	2006.02.28.18.24.18;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2005.11.01.21.37.09;	author martin;	state Exp;
branches;
next	1.33;

1.33
date	2005.09.25.20.05.35;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2005.09.21.20.58.24;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2005.09.12.23.05.05;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2005.07.31.15.31.17;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2004.08.06.22.31.31;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.19.22.55.50;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.02.23.27.54;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.15.00.06.08;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.14.01.26.43;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.13.00.24.21;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.19.21.56.28;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.10.01.05.27;	author miod;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2001.12.05.01.57.15;	author provos;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.18.10.47.05;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.07.06.02.07.43;	author provos;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.10.09.23.11;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.05.20.56.52;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.15.23.23.58;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2000.03.08.22.13.23;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.22.19.27.59;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.15.16.32.41;	author art;	state Exp;
branches;
next	1.12;

1.12
date	99.11.25.08.46.44;	author art;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	99.07.09.21.33.37;	author art;	state Exp;
branches;
next	1.10;

1.10
date	98.08.18.05.08.50;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.12.25.00.00.45;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.12.21.21.19.49;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	97.09.17.17.44.06;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.08.08.08.26.36;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.12.11.11.13.00;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.08.11.05.34.53;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.15.13.56.42;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.22.06.25.53;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.43;	author deraadt;	state Exp;
branches;
next	;

1.12.2.1
date	2000.02.20.11.56.50;	author niklas;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2000.03.02.07.04.33;	author niklas;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2000.03.24.09.08.48;	author niklas;	state Exp;
branches;
next	1.12.2.4;

1.12.2.4
date	2001.05.14.21.37.13;	author niklas;	state Exp;
branches;
next	1.12.2.5;

1.12.2.5
date	2001.07.04.10.23.31;	author niklas;	state Exp;
branches;
next	1.12.2.6;

1.12.2.6
date	2001.10.31.03.07.57;	author nate;	state Exp;
branches;
next	1.12.2.7;

1.12.2.7
date	2002.03.06.02.04.46;	author niklas;	state Exp;
branches;
next	1.12.2.8;

1.12.2.8
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.12.2.9;

1.12.2.9
date	2003.06.07.11.14.43;	author ho;	state Exp;
branches;
next	1.12.2.10;

1.12.2.10
date	2004.06.05.23.10.58;	author niklas;	state Exp;
branches;
next	;

1.22.2.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	;


desc
@@


1.52
log
@Now that the kernel virtual address space has been made larger, even on
sun4/4c/4e, increase NKMEMPAGES_MAX_DEFAULT to the same value as platforms
with limited, but not horribly limited, kva size.
@
text
@/*	$OpenBSD: param.h,v 1.51 2015/03/30 20:30:22 miod Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef	_MACHINE_PARAM_H_
#define	_MACHINE_PARAM_H_

#ifdef _KERNEL				/* XXX */
#ifndef _LOCORE				/* XXX */
#include <machine/cpu.h>		/* XXX */
#endif					/* XXX */
#endif					/* XXX */

/*
 * Sun4M support by Aaron Brown, Harvard University.
 * Changes Copyright (c) 1995 The President and Fellows of Harvard College.
 * All rights reserved.
 */
#define	_MACHINE	sparc
#define	MACHINE		"sparc"
#define	_MACHINE_ARCH	sparc
#define	MACHINE_ARCH	"sparc"
#define	MID_MACHINE	MID_SPARC

/*
 * The original SUN4 machines have 8K page size while the newer ones have a
 * 4K page size.  It is possible to build a kernel for either architecture,
 * or have the page size be dynamically handled (via uvmexp variables) at
 * run time.
 */
#define	SUN4_PGSHIFT	13			/* for a sun4 machine */
#define	SUN4CM_PGSHIFT	12			/* for a sun4c or sun4m machine */
#if (defined(SUN4) || defined(SUN4E)) && \
    !(defined(SUN4C) || defined(SUN4D) || defined(SUN4M))
# define PAGE_SHIFT	SUN4_PGSHIFT
# define PAGE_SIZE	(1 << PAGE_SHIFT)
# define PAGE_MASK	(PAGE_SIZE - 1)
#elif (defined(SUN4C) || defined(SUN4D) || defined(SUN4M)) && \
    !(defined(SUN4) || defined(SUN4E))
# define PAGE_SHIFT	SUN4CM_PGSHIFT
# define PAGE_SIZE	(1 << PAGE_SHIFT)
# define PAGE_MASK	(PAGE_SIZE - 1)
#elif defined(STANDALONE)	/* boot blocks */
# define PAGE_SHIFT	pgshift
# define PAGE_SIZE	nbpg
# define PAGE_MASK	pgofset
#else
# define PAGE_SHIFT	uvmexp.pageshift
# define PAGE_SIZE	uvmexp.pagesize
# define PAGE_MASK	uvmexp.pagemask
#endif

#define	KERNBASE	0xf8000000

#ifdef _KERNEL

#define	NBPG		PAGE_SIZE		/* bytes/page */
#define	PGSHIFT		PAGE_SHIFT		/* LOG2(PAGE_SIZE) */
#define	PGOFSET		PAGE_MASK		/* byte offset into page */

/*#define UPAGES	depends on machine model */
#define	USPACE		8192			/* total size of u-area */
#define	USPACE_ALIGN	0			/* u-area alignment 0-none */

#define	NMBCLUSTERS	2048			/* map size, max cluster allocation */

/* cannot be changed without great pain */
#ifndef	MSGBUFSIZE
#define	MSGBUFSIZE	4096			/* default message buffer size */
#endif

/*
 * Maximum size of the kernel malloc arena in PAGE_SIZE-sized
 * logical pages.
 */
#define	NKMEMPAGES_MAX_DEFAULT		((64 * 1024 * 1024) >> PAGE_SHIFT)

#ifndef _LOCORE
extern struct extent	*dvmamap_extent;

extern void	dvma_init(void);
extern caddr_t	kdvma_mapin(caddr_t, int, int);
extern caddr_t	dvma_malloc_space(size_t, void *, int, int);
extern void	dvma_free(caddr_t, size_t, void *);
#define		dvma_malloc(len,kaddr,flags)	dvma_malloc_space(len,kaddr,flags,0)

extern void	delay(unsigned int);
#define	DELAY(n)	delay(n)

extern int cputyp;

#endif /* _LOCORE */

#endif /* _KERNEL */

/*
 * Values for the cputyp variable. Order is important!
 * needed by locore, and libkvm
 */
#define	CPU_SUN4	0
#define	CPU_SUN4E	1
#define	CPU_SUN4C	2
#define	CPU_SUN4M	3
#define	CPU_SUN4D	4

/*
 * Shorthand CPU-type macros. Enumerate all eight cases.
 * Let compiler optimize away code conditional on constants.
 *
 * On sun4 and sun4e machines, the page size is 8192, while on sun4c, sun4d
 * and sun4m machines, it is 4096. Therefore, in the common case below, the
 * various pagesize-related defines are defined as variables which are
 * initialized early in locore.s after the machine type has been detected.
 *
 * Note that whenever the macros defined below evaluate to expressions
 * involving variables, the kernel will perform slightly worse due to the
 * extra memory references they'll generate.
 */
#if defined(SUN4) && !(defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M))
#	define	CPU_ISSUN4	(1)
#elif defined(SUN4C) && !(defined(SUN4) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M))
#	define	CPU_ISSUN4C	(1)
#elif defined(SUN4D) && !(defined(SUN4) || defined(SUN4C) || defined(SUN4E) || defined(SUN4M))
#	define	CPU_ISSUN4D	(1)
#elif defined(SUN4E) && !(defined(SUN4) || defined(SUN4C) || defined(SUN4D) || defined(SUN4M))
#	define	CPU_ISSUN4E	(1)
#elif defined(SUN4M) && !(defined(SUN4) || defined(SUN4C) || defined(SUN4D) || defined(SUN4E))
#	define	CPU_ISSUN4M	(1)
#elif (defined(SUN4) || defined(SUN4C)) && !(defined(SUN4D) || defined(SUN4E) || defined(SUN4M))
#	define	CPU_ISSUN4OR4C	(1)
#elif (defined(SUN4) || defined(SUN4C) || defined(SUN4E)) && !(defined(SUN4D) || defined(SUN4M))
#	define	CPU_ISSUN4OR4COR4E	(1)
#elif (defined(SUN4) || defined(SUN4E)) && !(defined(SUN4C) || defined(SUN4D) || defined(SUN4M))
#	define	CPU_ISSUN4OR4E	(1)
#elif (defined(SUN4C) || defined(SUN4M)) && !(defined(SUN4) || defined(SUN4D) || defined(SUN4E))
#	define	CPU_ISSUN4COR4M	(1)
#elif (defined(SUN4D) || defined(SUN4M)) && !(defined(SUN4) || defined(SUN4C) || defined(SUN4E))
#	define	CPU_ISSUN4DOR4M	(1)
#endif

#if !defined(CPU_ISSUN4)
#if defined(SUN4)
# define CPU_ISSUN4	(cputyp == CPU_SUN4)
#else
# define CPU_ISSUN4	(0)
#endif
#endif
#if !defined(CPU_ISSUN4C)
#if defined(SUN4C)
# define CPU_ISSUN4C	(cputyp == CPU_SUN4C)
#else
# define CPU_ISSUN4C	(0)
#endif
#endif
#if !defined(CPU_ISSUN4D)
#if defined(SUN4D)
# define CPU_ISSUN4D	(cputyp == CPU_SUN4D)
#else
# define CPU_ISSUN4D	(0)
#endif
#endif
#if !defined(CPU_ISSUN4E)
#if defined(SUN4E)
# define CPU_ISSUN4E	(cputyp == CPU_SUN4E)
#else
# define CPU_ISSUN4E	(0)
#endif
#endif
#if !defined(CPU_ISSUN4M)
#if defined(SUN4M)
# define CPU_ISSUN4M	(cputyp == CPU_SUN4M)
#else
# define CPU_ISSUN4M	(0)
#endif
#endif

#if !defined(CPU_ISSUN4OR4C)
# define CPU_ISSUN4OR4C	(CPU_ISSUN4 || CPU_ISSUN4C)
#endif
#if !defined(CPU_ISSUN4OR4E)
# define CPU_ISSUN4OR4E	(cputyp <= CPU_SUN4E)
				/* (CPU_ISSUN4 || CPU_ISSUN4E) */
#endif
#if !defined(CPU_ISSUN4OR4COR4E)
# define CPU_ISSUN4OR4COR4E	(cputyp <= CPU_SUN4C)
				/* (CPU_ISSUN4 || CPU_ISSUN4C || CPU_ISSUN4E) */
#endif
#if !defined(CPU_ISSUN4COR4M)
# define CPU_ISSUN4COR4M	(CPU_ISSUN4C || CPU_ISSUN4M)
#endif
#if !defined(CPU_ISSUN4DOR4M)
# define CPU_ISSUN4DOR4M	(cputyp >= CPU_SUN4M)
				/* (CPU_ISSUN4D || CPU_ISSUN4M) */
#endif

#endif /* _MACHINE_PARAM_H_ */
@


1.51
log
@Add a bus_dma_tag_t for DVMA usage, suitable for use for devices not sitting
behind a sun4m iommu.

Move the existing dvma routines from vm_machdep.c to this new dvma.c; this
allows for a few declarations to be removed from public headers.

Extend the device attachment arguments (struct confargs) to pass a
bus_dma_tag_t. mainbus receives the dvma bus_dma_tag_t, and devices pass the
tag unchanged to their children, except for iommu(4) which replaces it with
its own.

Change the few sun4m-only drivers to pick the bus_dma_tag_t from confargs
rather than assume iommu; this allows qlw(4) to attach and work on sun4c.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.50 2015/03/18 20:56:40 miod Exp $	*/
d112 1
a112 1
#define	NKMEMPAGES_MAX_DEFAULT		((4 * 1024 * 1024) >> PAGE_SHIFT)
@


1.50
log
@Rework the virtual memory layout on SRMMU systems (sun4d/sun4m) to use a much
lower VM_MIN_KERNEL_ADDRESS, since these systems are not crippled by the
Sun-4 MMU hole and have the real 4GB of address space.

Kernels running on Sun-4 MMU are not affected and will still be restricted
to the existing 128MB of kernel space, with 1GB - 128MB of user space.

Kernels running on SRMMU will now provide the low 3GB of address space to
userland, and use the top 1GB for the kernel, except when compiled with
option SMALL_KERNEL, in which case they will keep Sun-4 style the layout
(this is temporary to allow for people to boot bsd.rd to upgrade even when
not running 2.10 boot blocks, and will be removed eventually)

A consequence of this is that the top of the userland stack is no longer at
0xf0000000. But since nothing in userland uses USRSTACK anymore, this should
not be an issue.

Tested on sun4c and various sun4m, with physical memory sizes ranging from 32
to 448MB.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.49 2013/03/26 05:04:10 deraadt Exp $	*/
a114 2
extern vaddr_t		dvma_base;
extern vaddr_t		dvma_end;
d117 1
@


1.49
log
@PGSHIFT and PGOFSET are now contained inside the kernel namespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.48 2013/03/25 17:46:24 deraadt Exp $	*/
a91 2

#define	KERNTEXTOFF	0xf8004000		/* start of kernel text */
@


1.48
log
@ALIGNBYTES/ALIGN/ALIGNED_POINTER can move to the MI file.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.47 2013/03/23 16:12:27 deraadt Exp $	*/
a87 2
#define	PGSHIFT		PAGE_SHIFT		/* LOG2(PAGE_SIZE) */
#define	PGOFSET		PAGE_MASK		/* byte offset into page */
d96 2
@


1.47
log
@refactor sys/param.h and machine/param.h.  A lot of #ifdef _KERNEL is added
to keep definitions our of user space.  The MD files now follow a consistant
order -- all namespace intrusion is at the tail can be cleaned up
independently.  locore, bootblocks, and libkvm still see enough visibility to
build.  Checked on 90% of platforms...
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.46 2011/09/08 03:40:32 guenther Exp $	*/
a59 4

#define	ALIGNBYTES		_ALIGNBYTES
#define	ALIGN(p)		_ALIGN(p)
#define	ALIGNED_POINTER(p,t)	_ALIGNED_POINTER(p,t)
@


1.46
log
@Provide namespace-safe alignment macros in <machine/_types.h>, with
compat names kept in <machine/param.h>.  In <sys/socket.h>, pull
in <sys/_types.h> instead of the namespace polluting <machine/param.h>
and completely eliminate __CMSG_ALIGN, replaced by _ALIGN

ok deraadt@@
@
text
@d1 1
a1 2
/*	$OpenBSD: param.h,v 1.45 2011/04/07 15:45:18 miod Exp $	*/
/*	$NetBSD: param.h,v 1.29 1997/03/10 22:50:37 pk Exp $ */
a38 2
 *
 *	@@(#)param.h	8.1 (Berkeley) 6/11/93
d41 8
a48 2
#ifndef _MACHINE_PARAM_H_
#define _MACHINE_PARAM_H_
a60 6
#ifdef _KERNEL				/* XXX */
#ifndef _LOCORE				/* XXX */
#include <machine/cpu.h>		/* XXX */
#endif					/* XXX */
#endif					/* XXX */

d65 29
a93 2
#define SUN4_PGSHIFT	13	/* for a sun4 machine */
#define SUN4CM_PGSHIFT	12	/* for a sun4c or sun4m machine */
d95 3
a97 2
#define	KERNBASE	0xf8000000	/* start of kernel virtual space */
#define	KERNTEXTOFF	0xf8004000	/* start of kernel text */
d99 1
a99 4
#define	DEV_BSHIFT	9		/* log2(DEV_BSIZE) */
#define	DEV_BSIZE	(1 << DEV_BSHIFT)
#define	BLKDEV_IOSIZE	2048
#define	MAXPHYS		(64 * 1024)
d101 1
a101 2
#define	USPACE		8192
#define	USPACE_ALIGN	(0)		/* u-area alignment 0-none */
d103 3
a105 4
/*
 * Constants related to network buffer management.
 */
#define	NMBCLUSTERS	2048		/* map size, max cluster allocation */
d107 6
a112 1
#define MSGBUFSIZE	4096		/* cannot be changed without great pain */
d115 1
a115 1
 * Minimum and maximum sizes of the kernel malloc arena in PAGE_SIZE-sized
a117 1
#define	NKMEMPAGES_MIN_DEFAULT		((4 * 1024 * 1024) >> PAGE_SHIFT)
a119 9
/* pages ("clicks") to disk blocks */
#define	ctod(x)		((x) << (PGSHIFT - DEV_BSHIFT))
#define	dtoc(x)		((x) >> (PGSHIFT - DEV_BSHIFT))

/* bytes to disk blocks */
#define	btodb(x)	((x) >> DEV_BSHIFT)
#define	dbtob(x)	((x) << DEV_BSHIFT)

#ifdef _KERNEL
a133 4
#if 0
extern int cpumod;
extern int mmumod;
#endif
d136 1
d141 1
d143 1
a143 1
#define CPU_SUN4	0
d145 3
a147 3
#define CPU_SUN4C	2
#define CPU_SUN4M	3
#define CPU_SUN4D	4
a161 23
#if (defined(SUN4) || defined(SUN4E)) && !(defined(SUN4C) || defined(SUN4D) || defined(SUN4M))
#	define PAGE_SIZE	8192
#	define PAGE_MASK	(PAGE_SIZE - 1)
#	define PAGE_SHIFT	SUN4_PGSHIFT
#elif (defined(SUN4C) || defined(SUN4D) || defined(SUN4M)) && !(defined(SUN4) || defined(SUN4E))
#	define PAGE_SIZE	4096
#	define PAGE_MASK	(PAGE_SIZE - 1)
#	define PAGE_SHIFT	SUN4CM_PGSHIFT
#else
#ifdef	STANDALONE	/* boot blocks */
#	define PAGE_SIZE	nbpg
#	define PAGE_MASK	pgofset
#	define PAGE_SHIFT	pgshift
#else
#	define PAGE_SIZE	uvmexp.pagesize
#	define PAGE_MASK	uvmexp.pagemask
#	define PAGE_SHIFT	uvmexp.pageshift
#endif
#endif
#	define NBPG		PAGE_SIZE
#	define PGOFSET		PAGE_MASK
#	define PGSHIFT		PAGE_SHIFT

d163 1
a163 1
#	define CPU_ISSUN4	(1)
d165 1
a165 1
#	define CPU_ISSUN4C	(1)
d167 1
a167 1
#	define CPU_ISSUN4D	(1)
d169 1
a169 1
#	define CPU_ISSUN4E	(1)
d171 1
a171 1
#	define CPU_ISSUN4M	(1)
d173 1
a173 1
#	define CPU_ISSUN4OR4C	(1)
d175 1
a175 1
#	define CPU_ISSUN4OR4COR4E	(1)
d177 1
a177 1
#	define CPU_ISSUN4OR4E	(1)
d179 1
a179 1
#	define CPU_ISSUN4COR4M	(1)
d181 1
a181 1
#	define CPU_ISSUN4DOR4M	(1)
d186 1
a186 1
#	define CPU_ISSUN4	(cputyp == CPU_SUN4)
d188 1
a188 1
#	define CPU_ISSUN4	(0)
d193 1
a193 1
#	define CPU_ISSUN4C	(cputyp == CPU_SUN4C)
d195 1
a195 1
#	define CPU_ISSUN4C	(0)
d200 1
a200 1
#	define CPU_ISSUN4D	(cputyp == CPU_SUN4D)
d202 1
a202 1
#	define CPU_ISSUN4D	(0)
d207 1
a207 1
#	define CPU_ISSUN4E	(cputyp == CPU_SUN4E)
d209 1
a209 1
#	define CPU_ISSUN4E	(0)
d214 1
a214 1
#	define CPU_ISSUN4M	(cputyp == CPU_SUN4M)
d216 1
a216 1
#	define CPU_ISSUN4M	(0)
d221 1
a221 1
#	define CPU_ISSUN4OR4C	(CPU_ISSUN4 || CPU_ISSUN4C)
d224 1
a224 1
#	define CPU_ISSUN4OR4E	(cputyp <= CPU_SUN4E)
d228 1
a228 1
#	define CPU_ISSUN4OR4COR4E	(cputyp <= CPU_SUN4C)
d232 1
a232 1
#	define CPU_ISSUN4COR4M	(CPU_ISSUN4C || CPU_ISSUN4M)
d235 1
a235 1
#	define CPU_ISSUN4DOR4M	(cputyp >= CPU_SUN4M)
@


1.45
log
@Make sure the ALIGN() macro uses u_long on all platforms for consistency, and
update the comment block accordingly.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.44 2011/03/23 16:54:37 pirofti Exp $	*/
d64 3
a66 14
/*
 * Round p (pointer or byte index) up to a correctly-aligned value for
 * the machine's strictest data type.  The result is u_long and must be
 * cast to any desired pointer type.
 *
 * ALIGNED_POINTER is a boolean macro that checks whether an address
 * is valid to fetch data elements of type t from on this architecture.
 * This does not reflect the optimal alignment, just the possibility
 * (within reasonable limits). 
 *
 */
#define	ALIGNBYTES		7
#define	ALIGN(p)		(((u_long)(p) + ALIGNBYTES) & ~ALIGNBYTES)
#define ALIGNED_POINTER(p,t)	((((u_long)(p)) & (sizeof(t)-1)) == 0)
@


1.44
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.43 2010/07/11 14:09:10 miod Exp $	*/
d66 1
a66 1
 * the machine's strictest data type.  The result is u_int and must be
d76 1
a76 1
#define	ALIGN(p)		(((u_int)(p) + ALIGNBYTES) & ~ALIGNBYTES)
@


1.43
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.42 2010/07/10 19:32:24 miod Exp $	*/
d44 2
a45 2
#ifndef _SPARC_PARAM_H_
#define _SPARC_PARAM_H_
d260 1
a260 1
#endif /* _SPARC_PARAM_H_ */
@


1.42
log
@sun4e (i.e. SPARCengine 1e) support. This platform is a mix between sun4 and
sun4c, as it has a sun4c OpenPROM but a sun4 8KB pagesize. VME devices are
not supported yet.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.41 2010/06/29 21:26:09 miod Exp $	*/
d256 1
a256 1
#	define CPU_ISSUN4DOR4M	(cputyp >= CPU_SUN4D)
@


1.41
log
@There is absolutely no need to double map DVMA addresses into the kernel address
space on SRMMU systems (i.e. sun4m), so don't do it anymore and update
misleading comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.40 2007/11/28 16:33:20 martin Exp $	*/
d139 1
a139 1
 * Values for the cputyp variable.
d142 4
a145 2
#define CPU_SUN4C	1
#define CPU_SUN4M	2
d151 4
a154 4
 * On a sun4 machine, the page size is 8192, while on a sun4c and sun4m
 * it is 4096. Therefore, in the (SUN4 && (SUN4C || SUN4M)) cases below,
 * NBPG, PGOFSET and PGSHIFT are defined as variables which are initialized
 * early in locore.s after the machine type has been detected.
d160 2
a161 16
#if   defined(SUN4M) && defined(SUN4C) && defined(SUN4)
#	define CPU_ISSUN4M	(cputyp == CPU_SUN4M)
#	define CPU_ISSUN4C	(cputyp == CPU_SUN4C)
#	define CPU_ISSUN4	(cputyp == CPU_SUN4)
#	define CPU_ISSUN4OR4C	(cputyp == CPU_SUN4 || cputyp == CPU_SUN4C)
#	define CPU_ISSUN4COR4M	(cputyp == CPU_SUN4C || cputyp == CPU_SUN4M)
#elif defined(SUN4M) && defined(SUN4C) && !defined(SUN4)
#	define CPU_ISSUN4M	(cputyp == CPU_SUN4M)
#	define CPU_ISSUN4C	(cputyp == CPU_SUN4C)
#	define CPU_ISSUN4	(0)
#	define CPU_ISSUN4OR4C	(cputyp == CPU_SUN4C)
#	define CPU_ISSUN4COR4M	(cputyp == CPU_SUN4C || cputyp == CPU_SUN4M)
#	define NBPG		4096
#	define PGOFSET		(NBPG-1)
#	define PGSHIFT		SUN4CM_PGSHIFT
#	define PAGE_SIZE	4096
d163 2
a164 16
#	define PAGE_SHIFT	SUN4CM_PGSHIFT
#elif defined(SUN4M) && !defined(SUN4C) && defined(SUN4)
#	define CPU_ISSUN4M	(cputyp == CPU_SUN4M)
#	define CPU_ISSUN4C	(0)
#	define CPU_ISSUN4	(cputyp == CPU_SUN4)
#	define CPU_ISSUN4OR4C	(cputyp == CPU_SUN4)
#	define CPU_ISSUN4COR4M	(cputyp == CPU_SUN4M)
#elif defined(SUN4M) && !defined(SUN4C) && !defined(SUN4)
#	define CPU_ISSUN4M	(1)
#	define CPU_ISSUN4C	(0)
#	define CPU_ISSUN4	(0)
#	define CPU_ISSUN4OR4C	(0)
#	define CPU_ISSUN4COR4M	(1)
#	define NBPG		4096
#	define PGOFSET		(NBPG-1)
#	define PGSHIFT		SUN4CM_PGSHIFT
d168 1
a168 39
#elif !defined(SUN4M) && defined(SUN4C) && defined(SUN4)
#	define CPU_ISSUN4M	(0)
#	define CPU_ISSUN4C	(cputyp == CPU_SUN4C)
#	define CPU_ISSUN4	(cputyp == CPU_SUN4)
#	define CPU_ISSUN4OR4C	(1)
#	define CPU_ISSUN4COR4M	(cputyp == CPU_SUN4C)
#elif !defined(SUN4M) && defined(SUN4C) && !defined(SUN4)
#	define CPU_ISSUN4M	(0)
#	define CPU_ISSUN4C	(1)
#	define CPU_ISSUN4	(0)
#	define CPU_ISSUN4OR4C	(1)
#	define CPU_ISSUN4COR4M	(1)
#	define NBPG		4096
#	define PGOFSET		(NBPG-1)
#	define PGSHIFT		SUN4CM_PGSHIFT
#	define PAGE_SIZE	4096
#	define PAGE_MASK	(PAGE_SIZE - 1)
#	define PAGE_SHIFT	SUN4CM_PGSHIFT
#elif !defined(SUN4M) && !defined(SUN4C) && defined(SUN4)
#	define CPU_ISSUN4M	(0)
#	define CPU_ISSUN4C	(0)
#	define CPU_ISSUN4	(1)
#	define CPU_ISSUN4OR4C	(1)
#	define CPU_ISSUN4COR4M	(0)
#	define NBPG		8192
#	define PGOFSET		(NBPG-1)
#	define PGSHIFT		SUN4_PGSHIFT
#	define PAGE_SIZE	8192
#	define PAGE_MASK	(PAGE_SIZE - 1)
#	define PAGE_SHIFT	SUN4_PGSHIFT
#elif !defined(SUN4M) && !defined(SUN4C) && !defined(SUN4)
#	define CPU_ISSUN4M	(cputyp == CPU_SUN4M)
#	define CPU_ISSUN4C	(cputyp == CPU_SUN4C)
#	define CPU_ISSUN4	(cputyp == CPU_SUN4)
#	define CPU_ISSUN4OR4C	(cputyp == CPU_SUN4 || cputyp == CPU_SUN4C)
#	define CPU_ISSUN4COR4M	(cputyp == CPU_SUN4C || cputyp == CPU_SUN4M)
#endif

#ifndef	NBPG
a169 3
#	define NBPG		nbpg
#	define PGOFSET		pgofset
#	define PGSHIFT		pgshift
a173 3
#	define NBPG		uvmexp.pagesize
#	define PGOFSET		uvmexp.pagemask
#	define PGSHIFT		uvmexp.pageshift
d178 80
@


1.40
log
@ctob/btoc -> ptoa/atop

from Rodolfo Gouveia
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.39 2007/05/28 21:02:49 thib Exp $	*/
a114 10
/*
 * dvmamap manages a range of DVMA addresses intended to create double
 * mappings of physical memory. In a way, `dvmamap' is a submap of the
 * VM map `phys_map'. The difference is the use of the `resource map'
 * routines to manage page allocation, allowing DVMA addresses to be
 * allocated and freed from within interrupt routines.
 *
 * Note that `phys_map' can still be used to allocate memory-backed pages
 * in DVMA space.
 */
@


1.39
log
@Move the MSIZE, MCLSHIFT, MCLBYTES and the MCLOFSET
mbuf constants from MD param.h to MI param.h.
Besides being the same on every arch, things will
most probly break if any arch has different values
then the others.

The NMBCLUSTERS constants needs to be MD though;

ok miod@@,krw@@,claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.38 2007/04/10 16:43:37 miod Exp $	*/
a109 4

/* pages to bytes */
#define	ctob(x)		((x) << PGSHIFT)
#define	btoc(x)		(((x) + PGOFSET) >> PGSHIFT)
@


1.38
log
@slighly -> slightly
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.37 2006/08/12 17:54:38 krw Exp $	*/
a94 4
 * MCLBYTES must be no larger than the software page size, and,
 * on machines that exchange pages of input or output buffers with mbuf
 * clusters (MAPPED_MBUFS), MCLBYTES must also be an integral multiple
 * of the hardware page size.
a95 4
#define	MSIZE		256		/* size of an mbuf */
#define	MCLSHIFT	11		/* log2(MCLBYTES) */
#define	MCLBYTES	(1 << MCLSHIFT)	/* enough for whole Ethernet packet */
#define	MCLOFSET	(MCLBYTES - 1)
@


1.37
log
@Make all DEV_BSIZE definitions consistant by using (1 << DEV_BSHIFT)
in the six cases using "512".

As DEV_BSHIFT is always 9, this should be a no-op.

"no objections" miod@@ "I can't see any problem doing this." pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.36 2006/03/19 01:47:24 martin Exp $	*/
d177 1
a177 1
 * involving variables, the kernel will perform slighly worse due to the
@


1.36
log
@remove unused bdbtofsb(bn) macro

found by drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.35 2006/02/28 18:24:18 miod Exp $	*/
a84 1
#define	DEV_BSIZE	512
d86 1
@


1.35
log
@Shrink NKMEMPAGES_MAX back to 4MB for 3.9, as this still has issues on >= 512MB
machines; this will be fixed post release. Reported by Serge Basterot.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.34 2005/11/01 21:37:09 martin Exp $	*/
a125 8

/*
 * Map a ``block device block'' to a file system block.
 * This should be device dependent, and should use the bsize
 * field from the disk label.
 * For now though just use DEV_BSIZE.
 */
#define	bdbtofsb(bn)	((bn) / (BLKDEV_IOSIZE / DEV_BSIZE))
@


1.34
log
@remove Mach macros, they were unused anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.33 2005/09/25 20:05:35 miod Exp $	*/
d113 1
a113 1
#define	NKMEMPAGES_MAX_DEFAULT		((8 * 1024 * 1024) >> PAGE_SHIFT)
@


1.33
log
@Do not try increasing NKMEMPAGE_MAX on sun4m at all, until we make
kernel_map larger.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.32 2005/09/21 20:58:24 miod Exp $	*/
a133 6

/*
 * Mach derived conversion macros
 */
#define sparc_btop(x)	((unsigned)(x) >> PGSHIFT)
#define sparc_ptob(x)	((unsigned)(x) << PGSHIFT)
@


1.32
log
@Reduce NKMEMPAGES_MAX_DEFAULT_SUN4M, or we may allocate too much of kernel_map
on large memory sun4m machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.31 2005/09/12 23:05:05 miod Exp $	*/
a113 1
#define	NKMEMPAGES_MAX_DEFAULT_SUN4M	((24 * 1024 * 1024) >> PAGE_SHIFT)
@


1.31
log
@Change the NKMEMPAGES range to 4-64MB for 32bit arches, and 8-128MB for 64bit
arches; except on sparc where the range is 4-8 for !sun4m and 4-64 for sun4m,
selected at runtime.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.30 2005/07/31 15:31:17 miod Exp $	*/
d114 1
a114 1
#define	NKMEMPAGES_MAX_DEFAULT_SUN4M	((64 * 1024 * 1024) >> PAGE_SHIFT)
@


1.30
log
@Get rid of unused SINCR and SSIZE constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.29 2004/08/06 22:31:31 mickey Exp $	*/
d112 3
a114 2
#define	NKMEMPAGES_MIN_DEFAULT	((6 * 1024 * 1024) >> PAGE_SHIFT)
#define	NKMEMPAGES_MAX_DEFAULT	((6 * 1024 * 1024) >> PAGE_SHIFT)
@


1.29
log
@provide md USPACE_ALIGN zero on all but mips; deradat@@ pefo@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.28 2004/04/19 22:55:50 deraadt Exp $	*/
a89 1
#define	SSIZE		1		/* initial stack size in pages */
@


1.28
log
@remove the GATEWAY junk thingy; at the same time, select a new fat
cluster value that noone will really need to crank.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.27 2003/06/02 23:27:54 millert Exp $	*/
d92 1
@


1.27
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.26 2002/03/15 00:06:08 miod Exp $	*/
d104 1
a104 8

#ifndef NMBCLUSTERS
#ifdef GATEWAY
#define	NMBCLUSTERS	1024		/* map size, max cluster allocation */
#else
#define	NMBCLUSTERS	512		/* map size, max cluster allocation */
#endif
#endif
@


1.26
log
@The previous commit broke the bootblocks, since uvmexp is not available
there.
Win some uglyness points in fixing this.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.25 2002/03/14 01:26:43 millert Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.25
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.24 2002/03/13 00:24:21 miod Exp $	*/
a210 6
#	define NBPG		uvmexp.pagesize
#	define PGOFSET		uvmexp.pagemask
#	define PGSHIFT		uvmexp.pageshift
#	define PAGE_SIZE	uvmexp.pagesize
#	define PAGE_MASK	uvmexp.pagemask
#	define PAGE_SHIFT	uvmexp.pageshift
a228 6
#	define NBPG		uvmexp.pagesize
#	define PGOFSET		uvmexp.pagemask
#	define PGSHIFT		uvmexp.pageshift
#	define PAGE_SIZE	uvmexp.pagesize
#	define PAGE_MASK	uvmexp.pagemask
#	define PAGE_SHIFT	uvmexp.pageshift
a246 6
#	define NBPG		uvmexp.pagesize
#	define PGOFSET		uvmexp.pagemask
#	define PGSHIFT		uvmexp.pageshift
#	define PAGE_SIZE	uvmexp.pagesize
#	define PAGE_MASK	uvmexp.pagemask
#	define PAGE_SHIFT	uvmexp.pageshift
d277 11
d294 1
@


1.24
log
@On sparc, PAGE_SIZE and friends might not be a compile-time constant.
Instead of using a homegrown set of variables in this case, rely on uvmexp
fields once uvm has been initialized.

This requires a few #include <uvm/uvm_extern.h> here and there in the kernel
as well.

Idea from art@@, changes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.23 2002/02/19 21:56:28 miod Exp $	*/
d168 3
a170 3
extern caddr_t	kdvma_mapin __P((caddr_t, int, int));
extern caddr_t	dvma_malloc_space  __P((size_t, void *, int, int));
extern void	dvma_free __P((caddr_t, size_t, void *));
d173 1
a173 1
extern void	delay __P((unsigned int));
@


1.23
log
@Provide PAGE_{MASK,SHIFT,SIZE} ``constants'' for every cpu combination.
Fixes PR #2219
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.22 2001/12/10 01:05:27 miod Exp $	*/
a85 10
/*
 * The following variables are always defined and initialized (in locore)
 * so independently compiled modules (e.g. LKMs) can be used irrespective
 * of the `options SUN4?' combination a particular kernel was configured with.
 * See also the definitions of NBPG, PGOFSET and PGSHIFT below.
 */
#if defined(_KERNEL) && !defined(_LOCORE)
extern int nbpg, pgofset, pgshift;
#endif

d211 6
a216 6
#	define NBPG		nbpg
#	define PGOFSET		pgofset
#	define PGSHIFT		pgshift
#	define PAGE_SIZE	nbpg
#	define PAGE_MASK	pgofset
#	define PAGE_SHIFT	pgshift
d235 6
a240 6
#	define NBPG		nbpg
#	define PGOFSET		pgofset
#	define PGSHIFT		pgshift
#	define PAGE_SIZE	nbpg
#	define PAGE_MASK	pgofset
#	define PAGE_SHIFT	pgshift
d259 6
a264 6
#	define NBPG		nbpg
#	define PGOFSET		pgofset
#	define PGSHIFT		pgshift
#	define PAGE_SIZE	nbpg
#	define PAGE_MASK	pgofset
#	define PAGE_SHIFT	pgshift
d295 6
a300 6
#	define NBPG		nbpg
#	define PGOFSET		pgofset
#	define PGSHIFT		pgshift
#	define PAGE_SIZE	nbpg
#	define PAGE_MASK	pgofset
#	define PAGE_SHIFT	pgshift
@


1.22
log
@Define MCLBYTES from MCLSHIFT, rather than providing the final value.
(sync with other arches)
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.21 2001/12/05 01:57:15 provos Exp $	*/
d224 3
d248 3
d272 3
d308 3
@


1.22.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.22 2001/12/10 01:05:27 miod Exp $	*/
d86 10
d178 3
a180 3
extern caddr_t	kdvma_mapin(caddr_t, int, int);
extern caddr_t	dvma_malloc_space(size_t, void *, int, int);
extern void	dvma_free(caddr_t, size_t, void *);
d183 1
a183 1
extern void	delay(unsigned int);
d221 3
d242 3
d263 3
a295 4
#endif

#ifndef	NBPG
#ifdef	STANDALONE	/* boot blocks */
a298 11
#	define PAGE_SIZE	nbpg
#	define PAGE_MASK	pgofset
#	define PAGE_SHIFT	pgshift
#else
#	define NBPG		uvmexp.pagesize
#	define PGOFSET		uvmexp.pagemask
#	define PGSHIFT		uvmexp.pageshift
#	define PAGE_SIZE	uvmexp.pagesize
#	define PAGE_MASK	uvmexp.pagemask
#	define PAGE_SHIFT	uvmexp.pageshift
#endif
@


1.21
log
@make nkmempages dynamic based on memory. okay art@@ from netbsd:
date: 2000/02/11 19:22:52;  author: thorpej;
Add some very simple code to auto-size the kmem_map.  We take the
amount of physical memory, divide it by 4, and then allow machine
dependent code to place upper and lower bounds on the size.  Export
the computed value to userspace via the new "vm.nkmempages" sysctl.

NKMEMCLUSTERS is now deprecated and will generate an error if you
attempt to use it.  The new option, should you choose to use it,
is called NKMEMPAGES, and two new options NKMEMPAGES_MIN and
NKMEMPAGES_MAX allow the user to configure the bounds in the kernel
config file.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.19 2001/07/06 02:07:43 provos Exp $	*/
a114 1
#define	MCLBYTES	2048		/* enough for whole Ethernet packet */
d116 1
@


1.20
log
@Get rid of the PMAP_NEW option by making it mandatory for all archs.
The archs that didn't have a proper PMAP_NEW now have a dummy implementation
with wrappers around the old functions.
@
text
@d130 2
a131 1
 * Size of kernel malloc arena in logical pages.
d133 2
a134 3
#ifndef	NKMEMCLUSTERS
#define	NKMEMCLUSTERS	(6 * 1024 * 1024 / PAGE_SIZE)
#endif
@


1.19
log
@change MSIZE to 256, okay @@deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.18 2001/05/10 09:23:11 art Exp $	*/
a134 2

#define PMAP_NEW
@


1.18
log
@Switch sparc to PMAP_NEW. I've been running with that code for ages.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.17 2001/05/05 20:56:52 art Exp $	*/
d114 1
a114 1
#define	MSIZE		128		/* size of an mbuf */
@


1.17
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.16 2001/01/15 23:23:58 jason Exp $	*/
d135 2
@


1.16
log
@- increase the amount of space mapped for dvma on sun4m
- use a flag to specify allocations for 24 bit devices
- compatibility macros to deal with the 32 bit devices

This fixes the 'le at sbus' on sun4m problem (with the extent fixes
earlier), and allows the Artecon ethernet cards to work in sun4m machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.15 2000/03/08 22:13:23 deraadt Exp $	*/
a103 4
#define	CLSIZE		1
#define	CLSIZELOG2	0

/* NOTE: SSIZE must be multiple of CLSIZE */
d109 1
a109 1
 * MCLBYTES must be no larger than CLBYTES (the software page size), and,
d130 1
a130 1
 * Size of kernel malloc arena in CLBYTES-sized logical pages.
d133 1
a133 1
#define	NKMEMCLUSTERS	(6 * 1024 * 1024 / CLBYTES)
@


1.15
log
@multiple inclusion protect because of pstat and socket.h needing ALIGNBYTES
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.14 2000/02/22 19:27:59 deraadt Exp $	*/
d183 1
a183 1
extern caddr_t	dvma_malloc __P((size_t, void *, int));
d185 1
@


1.14
log
@enlarge msgbuf, somewhat line netbsd did
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.13 2000/02/15 16:32:41 art Exp $	*/
d47 4
d303 2
@


1.13
log
@Use extents instead of rmaps to handle dvma space.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.12 1999/11/25 08:46:44 art Exp $	*/
d126 2
@


1.12
log
@In the cases where we are sure what page size we have, define PAGE_SIZE
(and friends).
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.11 1999/07/09 21:33:37 art Exp $	*/
d174 1
a174 7
extern struct map	*dvmamap;
/*
 * The dvma resource map is defined in page units, which are numbered 1 to N.
 * Use these macros to convert to/from virtual addresses.
 */
#define rctov(n)		(ctob(((n)-1))+dvma_base)
#define vtorc(v)		((btoc((v)-dvma_base))+1)
@


1.12.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.13 2000/02/15 16:32:41 art Exp $	*/
d174 7
a180 1
extern struct extent	*dvmamap_extent;
@


1.12.2.2
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a125 2

#define MSGBUFSIZE	4096		/* cannot be changed without great pain */
@


1.12.2.3
log
@Sync with -current
@
text
@a46 4

#ifndef _SPARC_PARAM_H_
#define _SPARC_PARAM_H_

a298 2

#endif /* _SPARC_PARAM_H_ */
@


1.12.2.4
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.16 2001/01/15 23:23:58 jason Exp $	*/
d183 1
a183 1
extern caddr_t	dvma_malloc_space  __P((size_t, void *, int, int));
a184 1
#define		dvma_malloc(len,kaddr,flags)	dvma_malloc_space(len,kaddr,flags,0)
@


1.12.2.5
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.12.2.4 2001/05/14 21:37:13 niklas Exp $	*/
d104 4
d113 1
a113 1
 * MCLBYTES must be no larger than the software page size, and,
d134 1
a134 1
 * Size of kernel malloc arena in logical pages.
d137 1
a137 1
#define	NKMEMCLUSTERS	(6 * 1024 * 1024 / PAGE_SIZE)
a138 2

#define PMAP_NEW
@


1.12.2.6
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.12.2.5 2001/07/04 10:23:31 niklas Exp $	*/
d114 1
a114 1
#define	MSIZE		256		/* size of an mbuf */
d135 2
@


1.12.2.7
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d115 1
a116 1
#define	MCLBYTES	(1 << MCLSHIFT)	/* enough for whole Ethernet packet */
d130 1
a130 2
 * Minimum and maximum sizes of the kernel malloc arena in PAGE_SIZE-sized
 * logical pages.
d132 3
a134 2
#define	NKMEMPAGES_MIN_DEFAULT	((6 * 1024 * 1024) >> PAGE_SHIFT)
#define	NKMEMPAGES_MAX_DEFAULT	((6 * 1024 * 1024) >> PAGE_SHIFT)
a223 3
#	define PAGE_SIZE	nbpg
#	define PAGE_MASK	pgofset
#	define PAGE_SHIFT	pgshift
a244 3
#	define PAGE_SIZE	nbpg
#	define PAGE_MASK	pgofset
#	define PAGE_SHIFT	pgshift
a265 3
#	define PAGE_SIZE	nbpg
#	define PAGE_MASK	pgofset
#	define PAGE_SHIFT	pgshift
a298 3
#	define PAGE_SIZE	nbpg
#	define PAGE_MASK	pgofset
#	define PAGE_SHIFT	pgshift
@


1.12.2.8
log
@Merge in -current from about a week ago
@
text
@d86 10
d178 3
a180 3
extern caddr_t	kdvma_mapin(caddr_t, int, int);
extern caddr_t	dvma_malloc_space(size_t, void *, int, int);
extern void	dvma_free(caddr_t, size_t, void *);
d183 1
a183 1
extern void	delay(unsigned int);
d221 6
d245 6
d269 6
a304 4
#endif

#ifndef	NBPG
#ifdef	STANDALONE	/* boot blocks */
a310 8
#else
#	define NBPG		uvmexp.pagesize
#	define PGOFSET		uvmexp.pagemask
#	define PGSHIFT		uvmexp.pageshift
#	define PAGE_SIZE	uvmexp.pagesize
#	define PAGE_MASK	uvmexp.pagemask
#	define PAGE_SHIFT	uvmexp.pageshift
#endif
@


1.12.2.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.12.2.8 2002/03/28 10:57:10 niklas Exp $	*/
d25 5
a29 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.12.2.10
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d104 8
a111 1
#define	NMBCLUSTERS	2048		/* map size, max cluster allocation */
@


1.11
log
@vm_offset_t -> {v,p}addr_t and vm_size_t -> {v,p}size_t
remove "register" keywords
Various cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.10 1998/08/18 05:08:50 millert Exp $	*/
d236 3
d257 3
d278 3
d290 3
@


1.10
log
@Add sparc_btop and sparc_ptob for consistency with other ports
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.9 1997/12/25 00:00:45 deraadt Exp $	*/
d172 2
a173 2
extern vm_offset_t	dvma_base;
extern vm_offset_t	dvma_end;
@


1.9
log
@do not break the bootblocks
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.7 1997/09/17 17:44:06 downsj Exp $	*/
d153 6
@


1.8
log
@ifdef some definitions of NBPG that use kernel variables, when the
file is included from userland programs (such as lsof)
@
text
@a217 1
#if defined(_KERNEL) && !defined(_LOCORE)
a220 1
#endif
a235 1
#if defined(_KERNEL) && !defined(_LOCORE)
a238 1
#endif
a253 1
#if defined(_KERNEL) && !defined(_LOCORE)
a256 1
#endif
a280 1
#if defined(_KERNEL) && !defined(_LOCORE)
a283 1
#endif
@


1.7
log
@Double default NMBCLUSTERS settings.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.6 1997/08/08 08:26:36 downsj Exp $	*/
d218 1
d222 1
d238 1
d242 1
d258 1
d262 1
d287 1
d291 1
@


1.6
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d121 2
a123 2
#else
#define	NMBCLUSTERS	256		/* map size, max cluster allocation */
@


1.5
log
@MCLSHIFT=11, and calc MCLBYTES in such terms. found by pefo
@
text
@d1 2
a2 1
/*	$NetBSD: param.h,v 1.24 1996/05/15 02:13:48 mrg Exp $ */
d68 6
d75 3
a77 2
#define	ALIGNBYTES	7
#define	ALIGN(p)	(((u_int)(p) + ALIGNBYTES) & ~ALIGNBYTES)
d83 5
a87 20
 * Three possible cases:
 * 	sun4 only		8192 bytes/page
 *	sun4c/sun4m only	4096 bytes/page
 *	sun4/sun4c/sun4m	either of the above
 *
 * In the later case NBPG, PGOFSET, and PGSHIFT are encoded in variables
 * initialized early in locore.s.  Since they are variables, rather than
 * simple constants, the kernel will not perform slighly worse.
 */
#if defined(SUN4) && !defined(SUN4C) && !defined(SUN4M)
#define	NBPG		8192		/* bytes/page */
#define	PGOFSET		(NBPG-1)	/* byte offset into page */
#define	PGSHIFT		SUN4_PGSHIFT	/* log2(NBPG) */
#endif
#if !defined(SUN4) && (defined(SUN4C) || defined(SUN4M))
#define	NBPG		4096		/* bytes/page */
#define	PGOFSET		(NBPG-1)	/* byte offset into page */
#define	PGSHIFT		SUN4CM_PGSHIFT	/* log2(NBPG) */
#endif
#if defined(SUN4) && (defined(SUN4C) || defined(SUN4M))
a90 4
#define	NBPG		nbpg		/* bytes/page */
#define	PGOFSET		pgofset		/* byte offset into page */
#define	PGSHIFT		pgshift		/* log2(NBPG) */
#endif
d115 1
a116 1
#define	MCLBYTES	(1 << MCLSHIFT)	/* enough for whole Ethernet packet */
d184 1
d187 1
a197 21
/*
 * Values for cpumod (cpu model) variable.  XXX currently valid only for sun4
 * or Sun4M
 */
#define SUN4_100	0x22
#define SUN4_200	0x21
#define SUN4_300	0x23
#define SUN4_400	0x24
#define SUN4M_MS	0x04	/* MicroSPARC-II */
#define SUN4M_SS	0x40	/* Generic SuperSPARC */
#define SUN4M_HS	0x10	/* Generic ROSS sparc product (HyperSPARC) */
#define SUN4M_RT620	0x1f	/* Ross HyperSPARC RT620 */
#define SUN4M_STP1020N	0x41	/* TI SuperSPARC STP1020N */
#define SUN4M_STP1020P	0x40	/* TI SuperSPARC STP1020P */
#define SUN4M_STP1020A	0x40	/* TI SuperSPARC STP1020A */

/* Values for mmumod (mmu model) variable. Valid only for Sun4M */
#define	SUN4M_MMU_HS	0x1	/* ROSS HyperSparc */
#define SUN4M_MMU_SS	0x0	/* TI SuperSPARC */
#define SUN4M_MMU_MS1	0x4	/* MicroSPARC-I (??? XXX) */
#define SUN4M_MMU_MS	0x0	/* MicroSPARC-II (ugh, conflicts w/SS) */
d202 9
d218 3
d227 3
d236 3
d245 3
d254 3
d263 3
d272 3
d276 8
a283 5
#	define CPU_ISSUN4M	(0)
#	define CPU_ISSUN4C	(0)
#	define CPU_ISSUN4	(0)
#	define CPU_ISSUN4OR4C	(0)
#	define CPU_ISSUN4COR4M	(0)
@


1.4
log
@netbsd port, now we merge our changes back in
@
text
@a125 1
#define	MCLBYTES	2048		/* enough for whole Ethernet packet */
d127 1
@


1.3
log
@new mapdev/()/mapiodev() calling convention uses "struct rom_reg *" to supply
base plus an offset
new dvma routines
@
text
@d1 1
a1 1
/*	$NetBSD: param.h,v 1.16 1995/06/28 02:43:50 cgd Exp $ */
a45 1

d47 3
a49 1
 * Machine dependent constants for Sun-4c (SPARCstation)
d51 1
d53 1
d58 1
d61 1
d79 1
a79 1
 * 
d95 1
a95 1
#if defined(_KERNEL) && !defined(LOCORE)
d132 1
a132 1
#define	NMBCLUSTERS	2048		/* map size, max cluster allocation */
d134 1
a134 1
#define	NMBCLUSTERS	1024		/* map size, max cluster allocation */
d176 1
a176 1
#ifndef LOCORE
a179 1
#endif
a189 2
#endif

d191 1
a191 2
#ifdef _KERNEL
#ifndef LOCORE
a192 2
#endif
#endif
a193 2
#ifdef _KERNEL
#ifndef LOCORE
d196 5
a200 2
#endif
#endif
d209 1
d215 67
@


1.2
log
@crank NMBCLUSTERS
@
text
@d172 2
a173 1
extern vm_offset_t	dvmabase;
a175 1
#endif
d180 7
a186 2
#define rctov(n)		(ctob(((n)-1))+dvmabase)
#define vtorc(v)		((btoc((v)-dvmabase))+1)
d196 1
d199 1
@


1.1
log
@Initial revision
@
text
@d127 1
a127 1
#define	NMBCLUSTERS	512		/* map size, max cluster allocation */
d129 1
a129 1
#define	NMBCLUSTERS	256		/* map size, max cluster allocation */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
