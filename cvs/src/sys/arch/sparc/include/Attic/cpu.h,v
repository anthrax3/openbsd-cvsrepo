head	1.36;
access;
symbols
	OPENBSD_6_0:1.35.0.16
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.35.0.12
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.35.0.14
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.6
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.35.0.10
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.35.0.8
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.35.0.4
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.35.0.2
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.34.0.6
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.4
	OPENBSD_5_0:1.34.0.2
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.33.0.2
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.32.0.6
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.4
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.30.0.4
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.30.0.2
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.29.0.4
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.29.0.2
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.25.0.6
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.25.0.4
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.23.0.2
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.19.0.2
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.18
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.10.0.6
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.4
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.36
date	2016.09.01.09.23.42;	author tedu;	state dead;
branches;
next	1.35;
commitid	Q2PxaFNhqAe0Wmla;

1.35
date	2012.12.02.07.03.31;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2011.03.23.16.54.37;	author pirofti;	state Exp;
branches;
next	1.33;

1.33
date	2010.11.27.19.41.45;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2009.04.10.20.53.54;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2009.03.26.17.24.33;	author oga;	state Exp;
branches;
next	1.30;

1.30
date	2008.07.18.23.43.31;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.08.07.23.18;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2007.03.15.10.22.29;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2006.12.24.20.30.35;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2006.11.29.12.26.14;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2005.08.14.10.58.36;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2005.03.23.17.14.45;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2004.09.29.07.35.13;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2004.08.06.22.39.14;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2004.06.13.21.49.19;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.02.23.27.54;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.11.22.23.08.46;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.12.16.35.38;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.12.10.44.04;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.14.04.16.06;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.07.21.33.43;	author nordin;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.30.01.12.28;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.03.16.00;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.26.43;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.06.18.41.10;	author art;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2000.06.05.11.02.52;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.18.13.31.12;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.21.21.05.58;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.27.20.14.12;	author art;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	99.07.23.19.11.27;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	99.01.10.13.34.20;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	97.08.25.08.38.45;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	97.08.08.08.26.11;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.08.11.05.34.46;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.42;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.42;	author deraadt;	state Exp;
branches;
next	;

1.7.2.1
date	2000.02.21.22.29.02;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.05.14.21.37.12;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2003.06.07.11.14.43;	author ho;	state Exp;
branches;
next	1.7.2.7;

1.7.2.7
date	2004.06.06.05.23.39;	author tedu;	state Exp;
branches;
next	;

1.11.2.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.10.29.00.28.10;	author art;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: cpu.h,v 1.35 2012/12/02 07:03:31 guenther Exp $	*/
/*	$NetBSD: cpu.h,v 1.24 1997/03/15 22:25:15 pk Exp $ */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)cpu.h	8.4 (Berkeley) 1/5/94
 */

#ifndef _MACHINE_CPU_H_
#define _MACHINE_CPU_H_

/*
 * CTL_MACHDEP definitions.
 */
#define CPU_LED_BLINK	1	/* int: twiddle the power LED */
 		/*	2	   formerly int: vsyncblank */
#define CPU_CPUTYPE	3	/* int: cpu type */
#define CPU_V8MUL	4
#define CPU_MAXID	5	/* 4 valid machdep IDs */

#define	CTL_MACHDEP_NAMES { \
	{ 0, 0 }, \
	{ "led_blink", CTLTYPE_INT }, \
	{ 0, 0 }, \
	{ "cputype", CTLTYPE_INT }, \
	{ "v8mul", CTLTYPE_INT }, \
}

#ifdef _KERNEL
/*
 * Exported definitions unique to SPARC cpu support.
 */

#include <machine/psl.h>
#include <machine/reg.h>
#include <machine/intr.h>
#include <sparc/sparc/intreg.h>
#include <sparc/sparc/cpuvar.h>

/*
 * Arguments to hardclock, softclock and gatherstats encapsulate the
 * previous machine state in an opaque clockframe.  The ipl is here
 * as well for strayintr (see locore.s:interrupt and intr.c:strayintr).
 * Note that CLKF_INTR is valid only if CLKF_USERMODE is false.
 */
struct clockframe {
	u_int	psr;		/* psr before interrupt, excluding PSR_ET */
	u_int	pc;		/* pc at interrupt */
	u_int	npc;		/* npc at interrupt */
	u_int	ipl;		/* actual interrupt priority level */
	u_int	fp;		/* %fp at interrupt */
};
typedef struct clockframe clockframe;

extern int eintstack[];

#define	CLKF_USERMODE(framep)	(((framep)->psr & PSR_PS) == 0)
#define	CLKF_PC(framep)		((framep)->pc)
#define	CLKF_INTR(framep)	((framep)->fp < (u_int)eintstack)

/*
 * Preempt the current process if in interrupt from user mode,
 * or after the current trap/syscall if in system mode.
 */
extern int	want_resched;		/* resched() was called */
#define	need_resched(ci)		(want_resched = 1, want_ast = 1)
#define clear_resched(ci) 	want_resched = 0
extern int	want_ast;

/*
 * This is used during profiling to integrate system time.
 */
#define	PROC_PC(p)		((p)->p_md.md_tf->tf_pc)
#define	PROC_STACK(p)		((p)->p_md.md_tf->tf_out[6])

/*
 * Give a profiling tick to the current process when the user profiling
 * buffer pages are invalid.  On the sparc, request an ast to send us
 * through trap(), marking the proc as needing a profiling tick.
 */
#define	need_proftick(p)	do { want_ast = 1; } while (0)

/*
 * Notify the current process (p) that it has a signal pending,
 * process as soon as possible.
 */
#define	signotify(p)		(want_ast = 1)

extern int	foundfpu;		/* true => we have an FPU */

/* auxreg.c */
void led_blink(void *);
/* scf.c */
void scfblink(void *);
/* disksubr.c */
struct dkbad;
int isbad(struct dkbad *bt, int, int, int);
/* machdep.c */
int	ldcontrolb(caddr_t);
void	dumpconf(void);
caddr_t	reserve_dumppages(caddr_t);
/* clock.c */
struct timeval;
void	lo_microtime(struct timeval *);
int	statintr(void *);
int	clockintr(void *);/* level 10 (clock) interrupt code */
int	statintr(void *);	/* level 14 (statclock) interrupt code */
/* locore.s */
struct fpstate;
void	savefpstate(struct fpstate *);
void	loadfpstate(struct fpstate *);
int	probeget(caddr_t, int);
void	write_all_windows(void);
void	write_user_windows(void);
void 	proc_trampoline(void);
struct pcb;
void	snapshot(struct pcb *);
struct frame *getfp(void);
int	xldcontrolb(caddr_t, struct pcb *);
void	copywords(const void *, void *, size_t);
void	qcopy(const void *, void *, size_t);
void	qzero(void *, size_t);
/* locore2.c */
void	remrunqueue(struct proc *);
/* trap.c */
void	pmap_unuse_final(struct proc *);
int	rwindow_save(struct proc *);
/* amd7930intr.s */
void	amd7930_trap(void);
#ifdef KGDB
/* zs_kgdb.c */
void zs_kgdb_init(void);
#endif
/* fb.c */
void	fb_unblank(void);
/* cache.c */
void cache_flush(caddr_t, u_int);
/* kgdb_stub.c */
#ifdef KGDB
void kgdb_attach(int (*)(void *), void (*)(void *, int), void *);
void kgdb_connect(int);
void kgdb_panic(void);
#endif
/* iommu.c */
void	iommu_enter(u_int, u_int);
void	iommu_remove(u_int, u_int);
/* emul.c */
struct trapframe;
int emulinstr(int, struct trapframe *);

/*
 *
 * The SPARC has a Trap Base Register (TBR) which holds the upper 20 bits
 * of the trap vector table.  The next eight bits are supplied by the
 * hardware when the trap occurs, and the bottom four bits are always
 * zero (so that we can shove up to 16 bytes of executable code---exactly
 * four instructions---into each trap vector).
 *
 * The hardware allocates half the trap vectors to hardware and half to
 * software.
 *
 * Traps have priorities assigned (lower number => higher priority).
 */

struct trapvec {
	int	tv_instr[4];		/* the four instructions */
};
extern struct trapvec *trapbase;	/* the 256 vectors */

#endif /* _KERNEL */
#endif /* _MACHINE_CPU_H_ */
@


1.35
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.34 2011/03/23 16:54:37 pirofti Exp $	*/
@


1.34
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.33 2010/11/27 19:41:45 miod Exp $	*/
d109 1
@


1.33
log
@Misaligned load/store recovery code in the kernel, enabled by T_FIXALIGN
userland traps on a per-process basis, were necessary for *some* SunOS
binaries on sparc, which had to compiled with explicit misaligned access code
generation (i.e. for vendors to release a working SunOS/sparc version of their
code until they could fix their bogus code).

There is no reason to keep this code on sparc64, and now that we don't provide
COMPAT_SUNOS anymore, there is no reason to keep this code on sparc.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.32 2009/04/10 20:53:54 miod Exp $	*/
d44 2
a45 2
#ifndef _SPARC_CPU_H_
#define _SPARC_CPU_H_
d205 1
a205 1
#endif /* _SPARC_CPU_H_ */
@


1.32
log
@generic soft interrupts support for sparc. Soft interrupt handlers are now
kept in a separate intrhand array, with their own enable bits so that
soft interrupts sharing the same level only get invoked if really triggered.
Inspired by NetBSD with significant changes.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.31 2009/03/26 17:24:33 oga Exp $	*/
a182 1
int fixalign(struct proc *, struct trapframe *);
@


1.31
log
@Remove cpu_wait(). It's original use was to be called from the reaper so
MD code would free resources that couldn't be freed until we were no
longer running in that processor. However, it's is unused on all
architectures since mikeb@@'s tss changes on x86 earlier in the year.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.30 2008/07/18 23:43:31 art Exp $	*/
a68 1
#include <sys/evcount.h>
d71 1
a96 26
 * Software interrupt request `register'.
 */
union sir {
	int	sir_any;
	char	sir_which[4];
};
extern union sir sir;

#define SIR_NET		0
#define SIR_CLOCK	1

#if defined(SUN4M)
extern void	raise(int, int);
#if !(defined(SUN4) || defined(SUN4C))
#define setsoftint()	raise(0,1)
#else /* both defined */
#define setsoftint()	(cputyp == CPU_SUN4M ? raise(0,1) : ienab_bis(IE_L1))
#endif /* !4,!4c */
#else	/* 4m not defined */
#define setsoftint()	ienab_bis(IE_L1)
#endif /* SUN4M */

#define setsoftnet()	(sir.sir_which[SIR_NET] = 1, setsoftint())
#define setsoftclock()	(sir.sir_which[SIR_CLOCK] = 1, setsoftint())

/*
a124 28
/*
 * Interrupt handler chains.  Interrupt handlers should return 0 for
 * ``not me'' or 1 (``I took care of it'').  intr_establish() inserts a
 * handler into the list.  The handler is called with its (single)
 * argument, or with a pointer to a clockframe if ih_arg is NULL.
 * ih_ipl specifies the interrupt level that should be blocked when
 * executing this handler.
 */
struct intrhand {
	int	(*ih_fun)(void *);
	void	*ih_arg;
	int	ih_ipl;
	int	ih_vec;			/* human readable ipl for vmstat */
	struct	evcount ih_count;
	struct	intrhand *ih_next;
};
extern struct intrhand *intrhand[15];
void	intr_establish(int level, struct intrhand *, int, const char *);
void	vmeintr_establish(int vec, int level, struct intrhand *, int, const char *);

/*
 * intr_fasttrap() is a lot like intr_establish, but is used for ``fast''
 * interrupt vectors (vectors that are not shared and are handled in the
 * trap window).  Such functions must be written in assembly.
 */
int	intr_fasttrap(int, void (*)(void), int (*)(void *), void *);
void	intr_fastuntrap(int);

a134 1
void	intr_init(void);
@


1.30
log
@Add a macro that clears the want_resched flag that need_resched sets.
Right now when mi_switch picks up the same proc, we didn't clear the
flag which would mean that every time we service an AST we would attempt
a context switch. For some architectures, amd64 being probably the
most extreme, that meant attempting to context switch for every
trap and interrupt.

Now we clear_resched explicitly after every context switch, even if it
didn't do anything. Which also allows us to remove some more code
in cpu_switchto (not done yet).

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29 2007/05/08 07:23:18 art Exp $	*/
a73 6

/*
 * definitions of cpu-dependent requirements
 * referenced in generic code
 */
#define cpu_wait(p)	/* nothing */
@


1.29
log
@Switch sparc to __HAVE_CPUINFO.

miod@@ tested (since I hacked it up blindly) and ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.28 2007/03/15 10:22:29 art Exp $	*/
d134 1
@


1.28
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.27 2006/12/24 20:30:35 miod Exp $	*/
d71 1
d73 1
@


1.27
log
@Define PROC_PC. Then, since profiling information is being reported in
statclock(), do not bother doing this in userret() anymore. As a result,
userret() does not need its pc and ticks arguments, simplify.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.26 2006/11/29 12:26:14 miod Exp $	*/
d144 1
a144 1
#define	need_proftick(p)	((p)->p_flag |= P_OWEUPC, want_ast = 1)
@


1.26
log
@Remove cpu_swapin() and cpu_swapout(), they are no longer necessary (except
for cpu_swapin() on hppa* which is kept).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.25 2005/08/14 10:58:36 miod Exp $	*/
d133 5
@


1.25
log
@Add more flexibility to the fast trap handlers mechanism:
- add the ability to deregister a fast trap handler.
- when registering a fast trap, provide an optional callback which will be
  invoked if we try to register a regular trap handler later; the callback
  will be responsible to replace the fast trap handler with a regular trap
  handler (and is allowed to fail).

Alter audioamd(4) to take advantage of this, so that it can share its
interrupt with stp(4) on SPARCclassic machines.

Problem found the hard way and fix tested by Jason George; discussed and
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.24 2005/03/23 17:14:45 miod Exp $	*/
a76 2
#define	cpu_swapin(p)	/* nothing */
#define	cpu_swapout(p)	/* nothing */
@


1.24
log
@Move wzero() and wcopy() from machdep.c to where they are really used.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.23 2004/09/29 07:35:13 miod Exp $	*/
d176 2
a177 1
void	intr_fasttrap(int level, void (*vec)(void));
@


1.23
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.22 2004/08/06 22:39:14 deraadt Exp $	*/
a257 3

extern void wzero(void *, u_int);
extern void wcopy(const void *, void *, u_int);
@


1.22
log
@rename sparc kill_user_windows() to pmap_unuse_final().  provide empty stubs
on all other architectures.  remove last architecture dependent #ifdef from
uvm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.21 2004/06/13 21:49:19 niklas Exp $	*/
d69 1
d163 2
d168 2
a169 2
void	intr_establish(int level, struct intrhand *, int);
void	vmeintr_establish(int vec, int level, struct intrhand *, int);
d188 1
@


1.21
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d210 1
a210 1
void	kill_user_windows(struct proc *);
@


1.20
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.19 2002/11/22 23:08:46 deraadt Exp $	*/
d132 1
a132 1
#define	need_resched()		(want_resched = 1, want_ast = 1)
@


1.19
log
@new sysctl: machdep.v8mul says whether the kernel replaced the mul/div/rem
stubs, so that userland can do the same.  we cannot just determine based
on sun4m, because cypress (at least) is a sun4m cpu without the instructions
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.18 2002/08/12 16:35:38 miod Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.18
log
@Neuter the machdep.vsyncblank sysctl, as this setting is now controlled
by wsconsctl.
ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.17 2002/08/12 10:44:04 miod Exp $	*/
d57 2
a58 1
#define CPU_MAXID	4	/* 3 valid machdep IDs */
d65 1
@


1.17
log
@Convert sparc console code from rcons and pseudo-devices to rasops and wscons.
For most framebuffers it is faster.

Other changes include:
o 24 bit support in tcx(4) for the S24 framebuffer
o accelerated cgsix(4) text console
o new cgtwelve(4) driver for the GS framebuffer
o improved serial driver code
o better keyboard support

The following framebuffers have not been tested but should work: cgfour,
cgeight and cgfourteen

These changes will require XF4 changes, to use Xwsfb instead of Xsun*, to be
commited later today.

Most of the work by me during the LSM and the week after, with code borrowed
from jason@@, NetBSD (new serial code), and feedback from mickey@@. Work on
pnozz(4) done by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.16 2002/06/14 04:16:06 art Exp $	*/
d55 1
a55 1
#define CPU_VSYNCBLANK	2	/* int: turn off monitors in *blank */
d62 1
a62 1
	{ "vsyncblank", CTLTYPE_INT }, \
@


1.16
log
@sysctl for getting the cputype.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.15 2002/06/07 21:33:43 nordin Exp $	*/
a215 4
/* cons.c */
int	cnrom(void);
/* zs.c */
void zsconsole(struct tty *, int, int, int (**)(struct tty *, int));
d217 1
@


1.15
log
@Remove obsolete CLKF_BASEPRI(). ok niklas@@, miod@@ and art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.14 2002/04/30 01:12:28 art Exp $	*/
d56 2
a57 1
#define CPU_MAXID	3	/* 2 valid machdep IDs */
d63 1
@


1.14
log
@Fix an ancient problem in how sparc interrupts are handled.

There are many interrupt handlers that assume that they don't need to do
any spl protection in their code because the interrupt of some level can't
be interrupted by an interrupt of the same level. The problem is that some
interrupt handlers have hardware levels that are lower then their "software"
levels.

Fix this by adding an additional field to struct intrhand that specifies which
"software" level an interrupt handler has and blocks that level while handling
the interrupt. This new field is initialized in intr_establish which gets
an additional argument (which can be -1 meaning that the interrupt handler
doesn't need to block any additional level).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.13 2002/03/14 03:16:00 millert Exp $	*/
a97 1
#define	CLKF_BASEPRI(framep)	(((framep)->psr & PSR_PIL) == 0)
@


1.13
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.12 2002/03/14 01:26:43 millert Exp $	*/
d156 2
d162 1
d166 2
a167 2
void	intr_establish(int level, struct intrhand *);
void	vmeintr_establish(int vec, int level, struct intrhand *);
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.11 2001/11/06 18:41:10 art Exp $	*/
d171 1
a171 1
void	intr_fasttrap __P((int level, void (*vec)(void)));
d215 1
a215 1
void zsconsole __P((struct tty *, int, int, int (**)(struct tty *, int)));
d225 1
a225 1
void kgdb_attach __P((int (*)(void *), void (*)(void *, int), void *));
@


1.11
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.10 2000/06/05 11:02:52 art Exp $	*/
d115 1
a115 1
extern void	raise __P((int, int));
d158 1
a158 1
	int	(*ih_fun) __P((void *));
d163 2
a164 2
void	intr_establish __P((int level, struct intrhand *));
void	vmeintr_establish __P((int vec, int level, struct intrhand *));
d174 1
a174 1
void led_blink __P((void *));
d176 1
a176 1
void scfblink __P((void *));
d179 1
a179 1
int isbad __P((struct dkbad *bt, int, int, int));
d181 3
a183 3
int	ldcontrolb __P((caddr_t));
void	dumpconf __P((void));
caddr_t	reserve_dumppages __P((caddr_t));
d186 4
a189 4
void	lo_microtime __P((struct timeval *));
int	statintr __P((void *));
int	clockintr __P((void *));/* level 10 (clock) interrupt code */
int	statintr __P((void *));	/* level 14 (statclock) interrupt code */
d192 6
a197 6
void	savefpstate __P((struct fpstate *));
void	loadfpstate __P((struct fpstate *));
int	probeget __P((caddr_t, int));
void	write_all_windows __P((void));
void	write_user_windows __P((void));
void 	proc_trampoline __P((void));
d199 6
a204 6
void	snapshot __P((struct pcb *));
struct frame *getfp __P((void));
int	xldcontrolb __P((caddr_t, struct pcb *));
void	copywords __P((const void *, void *, size_t));
void	qcopy __P((const void *, void *, size_t));
void	qzero __P((void *, size_t));
d206 1
a206 1
void	remrunqueue __P((struct proc *));
d208 2
a209 2
void	kill_user_windows __P((struct proc *));
int	rwindow_save __P((struct proc *));
d211 1
a211 1
void	amd7930_trap __P((void));
d213 1
a213 1
int	cnrom __P((void));
d217 1
a217 1
void zs_kgdb_init __P((void));
d220 1
a220 1
void	fb_unblank __P((void));
d222 1
a222 1
void cache_flush __P((caddr_t, u_int));
d226 2
a227 2
void kgdb_connect __P((int));
void kgdb_panic __P((void));
d230 2
a231 2
void	iommu_enter __P((u_int, u_int));
void	iommu_remove __P((u_int, u_int));
d234 2
a235 2
int fixalign __P((struct proc *, struct trapframe *));
int emulinstr __P((int, struct trapframe *));
d256 2
a257 2
extern void wzero __P((void *, u_int));
extern void wcopy __P((const void *, void *, u_int));
@


1.11.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.11 2001/11/06 18:41:10 art Exp $	*/
d98 1
d115 1
a115 1
extern void	raise(int, int);
a155 2
 * ih_ipl specifies the interrupt level that should be blocked when
 * executing this handler.
d158 1
a158 1
	int	(*ih_fun)(void *);
a159 1
	int	ih_ipl;
d163 2
a164 2
void	intr_establish(int level, struct intrhand *, int);
void	vmeintr_establish(int vec, int level, struct intrhand *, int);
d171 1
a171 1
void	intr_fasttrap(int level, void (*vec)(void));
d174 1
a174 1
void led_blink(void *);
d176 1
a176 1
void scfblink(void *);
d179 1
a179 1
int isbad(struct dkbad *bt, int, int, int);
d181 3
a183 3
int	ldcontrolb(caddr_t);
void	dumpconf(void);
caddr_t	reserve_dumppages(caddr_t);
d186 4
a189 4
void	lo_microtime(struct timeval *);
int	statintr(void *);
int	clockintr(void *);/* level 10 (clock) interrupt code */
int	statintr(void *);	/* level 14 (statclock) interrupt code */
d192 6
a197 6
void	savefpstate(struct fpstate *);
void	loadfpstate(struct fpstate *);
int	probeget(caddr_t, int);
void	write_all_windows(void);
void	write_user_windows(void);
void 	proc_trampoline(void);
d199 6
a204 6
void	snapshot(struct pcb *);
struct frame *getfp(void);
int	xldcontrolb(caddr_t, struct pcb *);
void	copywords(const void *, void *, size_t);
void	qcopy(const void *, void *, size_t);
void	qzero(void *, size_t);
d206 1
a206 1
void	remrunqueue(struct proc *);
d208 2
a209 2
void	kill_user_windows(struct proc *);
int	rwindow_save(struct proc *);
d211 1
a211 1
void	amd7930_trap(void);
d213 1
a213 1
int	cnrom(void);
d215 1
a215 1
void zsconsole(struct tty *, int, int, int (**)(struct tty *, int));
d217 1
a217 1
void zs_kgdb_init(void);
d220 1
a220 1
void	fb_unblank(void);
d222 1
a222 1
void cache_flush(caddr_t, u_int);
d225 3
a227 3
void kgdb_attach(int (*)(void *), void (*)(void *, int), void *);
void kgdb_connect(int);
void kgdb_panic(void);
d230 2
a231 2
void	iommu_enter(u_int, u_int);
void	iommu_remove(u_int, u_int);
d234 2
a235 2
int fixalign(struct proc *, struct trapframe *);
int emulinstr(int, struct trapframe *);
d256 2
a257 2
extern void wzero(void *, u_int);
extern void wcopy(const void *, void *, u_int);
@


1.11.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.11.2.1 2002/06/11 03:38:16 art Exp $	*/
d55 2
a56 3
 		/*	2	   formerly int: vsyncblank */
#define CPU_CPUTYPE	3	/* int: cpu type */
#define CPU_MAXID	4	/* 3 valid machdep IDs */
d61 1
a61 2
	{ 0, 0 }, \
	{ "cputype", CTLTYPE_INT }, \
d214 4
a218 1
/* zs_kgdb.c */
@


1.11.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 1
a57 2
#define CPU_V8MUL	4
#define CPU_MAXID	5	/* 4 valid machdep IDs */
a63 1
	{ "v8mul", CTLTYPE_INT }, \
@


1.10
log
@Changes to exit handling.

cpu_exit no longer frees the vmspace and u-area. This is now handled by a
separate kernel thread "reaper". This is to avoid sleeping locks in the
critical path of cpu_exit where we're not allowed to sleep.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.9 2000/05/18 13:31:12 jason Exp $	*/
a209 1
void	child_return __P((struct proc *));
@


1.9
log
@add machdep.vsyncblank sysctl for controlling whether vsync is disabled
when the monitor is blanked.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.8 2000/02/21 21:05:58 art Exp $	*/
d78 1
a78 1
#define	cpu_wait(p)	/* nothing */
@


1.8
log
@move fpproc into the cpuinfo structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.7 2000/01/27 20:14:12 art Exp $	*/
d55 2
a56 1
#define	CPU_MAXID	2	/* 1 valid machdep ID */
d61 1
@


1.7
log
@reduce global symbol pollution
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.6 1999/07/23 19:11:27 jason Exp $	*/
a146 6
/*
 * Only one process may own the FPU state.
 *
 * XXX this must be per-cpu (eventually)
 */
extern struct	proc *fpproc;		/* FPU owner */
@


1.7.2.1
log
@sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.8 2000/02/21 21:05:58 art Exp $	*/
d147 6
@


1.7.2.2
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.10 2000/06/05 11:02:52 art Exp $	*/
d55 1
a55 2
#define CPU_VSYNCBLANK	2	/* int: turn off monitors in *blank */
#define CPU_MAXID	3	/* 2 valid machdep IDs */
a59 1
	{ "vsyncblank", CTLTYPE_INT }, \
d76 1
a76 1
#define cpu_wait(p)	/* nothing */
@


1.7.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d210 1
@


1.7.2.4
log
@Merge in -current from about a week ago
@
text
@d115 1
a115 1
extern void	raise(int, int);
d158 1
a158 1
	int	(*ih_fun)(void *);
d163 2
a164 2
void	intr_establish(int level, struct intrhand *);
void	vmeintr_establish(int vec, int level, struct intrhand *);
d171 1
a171 1
void	intr_fasttrap(int level, void (*vec)(void));
d174 1
a174 1
void led_blink(void *);
d176 1
a176 1
void scfblink(void *);
d179 1
a179 1
int isbad(struct dkbad *bt, int, int, int);
d181 3
a183 3
int	ldcontrolb(caddr_t);
void	dumpconf(void);
caddr_t	reserve_dumppages(caddr_t);
d186 4
a189 4
void	lo_microtime(struct timeval *);
int	statintr(void *);
int	clockintr(void *);/* level 10 (clock) interrupt code */
int	statintr(void *);	/* level 14 (statclock) interrupt code */
d192 6
a197 6
void	savefpstate(struct fpstate *);
void	loadfpstate(struct fpstate *);
int	probeget(caddr_t, int);
void	write_all_windows(void);
void	write_user_windows(void);
void 	proc_trampoline(void);
d199 6
a204 6
void	snapshot(struct pcb *);
struct frame *getfp(void);
int	xldcontrolb(caddr_t, struct pcb *);
void	copywords(const void *, void *, size_t);
void	qcopy(const void *, void *, size_t);
void	qzero(void *, size_t);
d206 1
a206 1
void	remrunqueue(struct proc *);
d208 2
a209 2
void	kill_user_windows(struct proc *);
int	rwindow_save(struct proc *);
d211 1
a211 1
void	amd7930_trap(void);
d213 1
a213 1
int	cnrom(void);
d215 1
a215 1
void zsconsole(struct tty *, int, int, int (**)(struct tty *, int));
d217 1
a217 1
void zs_kgdb_init(void);
d220 1
a220 1
void	fb_unblank(void);
d222 1
a222 1
void cache_flush(caddr_t, u_int);
d225 3
a227 3
void kgdb_attach(int (*)(void *), void (*)(void *, int), void *);
void kgdb_connect(int);
void kgdb_panic(void);
d230 2
a231 2
void	iommu_enter(u_int, u_int);
void	iommu_remove(u_int, u_int);
d234 2
a235 2
int fixalign(struct proc *, struct trapframe *);
int emulinstr(int, struct trapframe *);
d256 2
a257 2
extern void wzero(void *, u_int);
extern void wcopy(const void *, void *, u_int);
@


1.7.2.5
log
@Sync the SMP branch with 3.3
@
text
@d55 2
a56 4
 		/*	2	   formerly int: vsyncblank */
#define CPU_CPUTYPE	3	/* int: cpu type */
#define CPU_V8MUL	4
#define CPU_MAXID	5	/* 4 valid machdep IDs */
d61 1
a61 3
	{ 0, 0 }, \
	{ "cputype", CTLTYPE_INT }, \
	{ "v8mul", CTLTYPE_INT }, \
d98 1
a155 2
 * ih_ipl specifies the interrupt level that should be blocked when
 * executing this handler.
a159 1
	int	ih_ipl;
d163 2
a164 2
void	intr_establish(int level, struct intrhand *, int);
void	vmeintr_establish(int vec, int level, struct intrhand *, int);
d212 4
a216 1
/* zs_kgdb.c */
@


1.7.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.7.2.5 2003/03/27 23:49:25 niklas Exp $	*/
d25 5
a29 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.2.7
log
@need_resched macro needs to take ci arg to be compat with MP function
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.7.2.6 2003/06/07 11:14:43 ho Exp $	*/
d132 1
a132 1
#define	need_resched(ci)		(want_resched = 1, want_ast = 1)
@


1.6
log
@Drivers for the FORCE CPU-5V:
o fga5000 vme-sbus bridge
o system config registers
o flash memory
and daadio VME board driver
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.5 1999/01/10 13:34:20 niklas Exp $	*/
d106 2
a107 1
} sir;
a125 2
int	want_ast;

d130 1
a130 1
int	want_resched;		/* resched() was called */
d132 1
d152 2
a153 2
struct	proc *fpproc;		/* FPU owner */
int	foundfpu;		/* true => we have an FPU */
d165 2
a166 2
} *intrhand[15];

@


1.5
log
@Generalize cpu_set_kpc to take any kind of arg; mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.4 1997/08/25 08:38:45 downsj Exp $	*/
d179 2
@


1.4
log
@Implement LED blinking as a run-time configurable option via the sysctl
machdep.led_blink.

Rename auxreg.h because we need config to generate one now.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.3 1997/08/08 08:26:11 downsj Exp $	*/
a231 2
/* vm_machdep.c */
void cpu_set_kpc __P((struct proc *, void (*)(struct proc *)));
@


1.3
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d54 2
a55 1
#define	CPU_MAXID	1	/* no valid machdep ids */
d59 1
d177 2
@


1.2
log
@netbsd port, now we merge our changes back in
@
text
@d1 2
a2 1
/*	$NetBSD: cpu.h,v 1.21 1996/03/31 22:17:14 pk Exp $ */
d48 2
a49 2
#ifndef _CPU_H_
#define _CPU_H_
d204 1
a204 1
void	remrq __P((struct proc *));
d233 4
d261 1
a261 1
#endif /* _CPU_H_ */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: cpu.h,v 1.17 1995/06/28 02:56:05 cgd Exp $ */
d51 1
a51 1
 * CTL_MACHDEP definitinos.
a75 9
 * See syscall() for an explanation of the following.  Note that the
 * locore bootstrap code follows the syscall stack protocol.  The
 * framep argument is unused.
 */
#define cpu_set_init_frame(p, fp) \
	(p)->p_md.md_tf = (struct trapframe *) \
	    ((caddr_t)(p)->p_addr + USPACE - sizeof(struct trapframe))

/*
d108 11
a118 1
#define	setsoftint()	ienab_bis(IE_L1)
d133 1
a133 1
 * buffer pages are invalid.  On the sparc, request an ast to send us 
d174 59
d250 1
a250 1
extern struct trapvec trapbase[256];	/* the 256 vectors */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
