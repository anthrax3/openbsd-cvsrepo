head	1.20;
access;
symbols
	OPENBSD_6_0:1.19.0.6
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.4
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.18.0.16
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.20
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.18
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.14
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.12
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.10
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.8
	OPENBSD_5_0:1.18.0.6
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.4
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.12
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.8
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.6
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.15.0.8
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.6
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.4
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.8.0.4
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.10
	OPENBSD_2_8:1.7.0.8
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.6
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.4
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2016.09.01.09.23.42;	author tedu;	state dead;
branches;
next	1.19;
commitid	Q2PxaFNhqAe0Wmla;

1.19
date	2015.03.30.20.30.22;	author miod;	state Exp;
branches;
next	1.18;
commitid	f66FukLLgPJs9j5H;

1.18
date	2010.06.29.21.28.08;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.12.20.07.53;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.04.03.44.44;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.08.12.42.57;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.23.17.10.24;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.15.18.46.30;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.23.27.54;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.15.01.20.04;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.03.16.00;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.43;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.05.22.34.17;	author art;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	99.07.23.19.11.27;	author jason;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	99.04.18.03.24.27;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	97.08.08.08.26.03;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.08.11.05.34.43;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.15.13.56.42;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.18.18.06.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.42;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.42;	author deraadt;	state Exp;
branches;
next	;

1.7.4.1
date	2001.07.04.10.23.28;	author niklas;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.7.4.3;

1.7.4.3
date	2003.06.07.11.14.43;	author ho;	state Exp;
branches;
next	;

1.8.4.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: autoconf.h,v 1.19 2015/03/30 20:30:22 miod Exp $	*/
/*	$NetBSD: autoconf.h,v 1.20 1997/05/24 20:03:03 pk Exp $ */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)autoconf.h	8.2 (Berkeley) 9/30/93
 */

/*
 * Autoconfiguration information.
 */

#ifndef _MACHINE_AUTOCONF_H_
#define _MACHINE_AUTOCONF_H_

/*
 * Most devices are configured according to information kept in
 * the FORTH PROMs.  In particular, we extract the `name', `reg',
 * and `address' properties of each device attached to the mainbus;
 * other drives may also use this information.  The mainbus itself
 * (which `is' the CPU, in some sense) gets just the node, with a
 * fake name ("mainbus").
 */

#define	RA_MAXVADDR	8		/* max (virtual) addresses per device */
#define	RA_MAXREG	16		/* max # of register banks per device */
#define	RA_MAXINTR	8		/* max interrupts per device */

struct romaux {
	const char *ra_name;		/* name from FORTH PROM */
	int	ra_node;		/* FORTH PROM node ID */
	void	*ra_vaddrs[RA_MAXVADDR];/* ROM mapped virtual addresses */
	int	ra_nvaddrs;		/* # of ra_vaddrs[]s, may be 0 */
#define ra_vaddr	ra_vaddrs[0]	/* compatibility */

	struct rom_reg {
		int	rr_iospace;	/* register space (obio, etc) */
		void	*rr_paddr;	/* register physical address */
		int	rr_len;		/* register length */
	} ra_reg[RA_MAXREG];
	int	ra_nreg;		/* # of ra_reg[]s */
#define ra_iospace	ra_reg[0].rr_iospace
#define ra_paddr	ra_reg[0].rr_paddr
#define ra_len		ra_reg[0].rr_len

	struct rom_intr {		/* interrupt information: */
		int	int_pri;		/* priority (IPL) */
		int	int_vec;		/* vector (always 0?) */
	} ra_intr[RA_MAXINTR];
	int	ra_nintr;		/* number of interrupt info elements */

	struct	bootpath *ra_bp;	/* used for locating boot device */
};

struct rom_range {		/* Only used on v3 PROMs */
	u_int32_t	cspace;		/* Client space */
	u_int32_t	coffset;	/* Client offset */
	u_int32_t	pspace;		/* Parent space */
	u_int32_t	poffset;	/* Parent offset */
	u_int32_t	size;		/* Size in bytes of this range */
};

/*
 * mapiodev maps an I/O device to a virtual address, returning the address.
 * mapdev does the real work: you can supply a special virtual address and
 * it will use that instead of creating one, but you must only do this if
 * you get it from ../sparc/vaddrs.h.
 */
void	*mapdev(struct rom_reg *pa, int va, int offset, int size);
#define	mapiodev(pa, offset, size) \
	mapdev(pa, 0, offset, size)

#include <machine/bus.h>

struct confargs {
	int		ca_bustype;
	struct	romaux	ca_ra;
	int		ca_slot;
	int		ca_offset;

	bus_dma_tag_t	ca_dmat;
};
#define BUS_MAIN	0
#define BUS_OBIO	1
#define BUS_VME16	2
#define BUS_VME32	3
#define BUS_SBUS	4
#define BUS_XBOX	5
#define BUS_FGA		6
#define BUS_FGA_A16D8	7
#define BUS_FGA_A16D16	8
#define BUS_FGA_A16D32	9
#define BUS_FGA_A24D8	10
#define BUS_FGA_A24D16	11
#define BUS_FGA_A24D32	12
#define BUS_FGA_A32D8	13
#define BUS_FGA_A32D16	14
#define BUS_FGA_A32D32	15

/*
 * REG2PHYS is provided for drivers with a `d_mmap' function.
 */
#define REG2PHYS(rr, offset) \
	(((u_int)(rr)->rr_paddr + (offset)) | PMAP_IOENC((rr)->rr_iospace) )

/* For VME and sun4/obio busses */
void	*bus_map(struct rom_reg *, int);
void	bus_untmp(void);

/*
 * The various getprop* functions obtain `properties' from the ROMs.
 * getprop() obtains a property as a byte-sequence, and returns its
 * length; the others convert or make some other guarantee.
 */
int	getproplen(int node, char *name);
int	getprop(int node, char *name, void *buf, int bufsiz);
char	*getpropstring(int node, char *name);
int	getpropint(int node, char *name, int deflt);

/* Frequently used options node */
extern int optionsnode;
/* Machine type */
extern char mainbus_model[30];

/*
 * The romprop function gets physical and virtual addresses from the PROM
 * and fills in a romaux.  It returns 1 on success, 0 if the physical
 * address is not available as a "reg" property.
 */
int	romprop(struct romaux *ra, const char *name, int node);

/*
 * `clockfreq' produces a printable representation of a clock frequency
 * (this is just a frill).
 */
char	*clockfreq(int freq);

/* Pass a string to the FORTH interpreter.  May fail silently. */
void	rominterpret(char *);

/* Openprom V2 style boot path */
struct device;
struct bootpath {
	char	name[16];	/* name of this node */
	int	val[3];		/* up to three optional values */
	struct device *dev;	/* device that recognised this component */
};

struct bootpath	*bootpath_store(int, struct bootpath *);
int		sd_crazymap(int);

void	bootstrap(void);
int	firstchild(int);
int	nextsibling(int);
void	callrom(void);
struct device *getdevunit(char *, int);
void	*findzs(int);
int	romgetcursoraddr(int **, int **);
int	findroot(void);
int	findnode(int, const char *);
int	opennode(char *);
int	node_has_property(int, const char *);

#endif /* _MACHINE_AUTOCONF_H_ */
@


1.19
log
@Add a bus_dma_tag_t for DVMA usage, suitable for use for devices not sitting
behind a sun4m iommu.

Move the existing dvma routines from vm_machdep.c to this new dvma.c; this
allows for a few declarations to be removed from public headers.

Extend the device attachment arguments (struct confargs) to pass a
bus_dma_tag_t. mainbus receives the dvma bus_dma_tag_t, and devices pass the
tag unchanged to their children, except for iommu(4) which replaces it with
its own.

Change the few sun4m-only drivers to pick the bus_dma_tag_t from confargs
rather than assume iommu; this allows qlw(4) to attach and work on sun4c.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.h,v 1.18 2010/06/29 21:28:08 miod Exp $	*/
@


1.18
log
@During kernel bootstrap, stop assuming the kernel image has been loaded in
low physical memory, but instead figure out where it has been loaded from
the current MMU setup.

From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.h,v 1.17 2009/07/12 20:07:53 kettenis Exp $	*/
d98 11
d111 6
a116 4
	int	ca_bustype;
	struct	romaux ca_ra;
	int	ca_slot;
	int	ca_offset;
a134 9
/*
 * mapiodev maps an I/O device to a virtual address, returning the address.
 * mapdev does the real work: you can supply a special virtual address and
 * it will use that instead of creating one, but you must only do this if
 * you get it from ../sparc/vaddrs.h.
 */
void	*mapdev(struct rom_reg *pa, int va, int offset, int size);
#define	mapiodev(pa, offset, size) \
	mapdev(pa, 0, offset, size)
@


1.17
log
@Add protection against multiple inclusion.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.h,v 1.16 2007/05/04 03:44:44 deraadt Exp $	*/
a167 13

/*
 * Memory description arrays.  Shared between pmap.c and autoconf.c; no
 * one else should use this (except maybe mem.c, e.g., if we fix the VM to
 * handle discontiguous physical memory).
 */
struct memarr {
	u_int	addr;
	u_int	len;
};
int	makememarr(struct memarr *, int max, int which);
#define	MEMARR_AVAILPHYS	0
#define	MEMARR_TOTALPHYS	1
@


1.16
log
@setroot() was a ugly mix of MI and MD code, with different bugs on different
machines.  Instead -- build one solid clean MI version, and thenchange all
the architectures to use it.  ok various people, tested on almost all cases.
(it is a 10094 line diff..)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.h,v 1.15 2005/07/08 12:42:57 miod Exp $	*/
d48 3
d207 2
@


1.15
log
@Declare mainbus_model as extern here so that code outside of autoconf.c can
look at it (forgotten as part of the auxio commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.h,v 1.14 2005/03/23 17:10:24 miod Exp $	*/
a191 3

/* Parse a disk string into a dev_t, return device struct pointer */
struct	device *parsedisk(char *, int, int, dev_t *);
@


1.14
log
@Kill the sparc-specific mountroot hooks (which are run before the root
filesystem is mounted, unlike the MI mountroot hooks). They were only
used to allow root on floppy in the long dead two-floppies installation
method.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.h,v 1.13 2005/03/15 18:46:30 miod Exp $	*/
d150 2
@


1.13
log
@Nuke matchbyname(), which isn't used anymore.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.h,v 1.12 2003/06/02 23:27:54 millert Exp $	*/
a192 3

/* Establish a mountroot_hook, for benefit of floppy drive, mostly. */
void	mountroot_hook_establish(void (*)(struct device *), struct device *);
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.h,v 1.11 2002/03/15 01:20:04 millert Exp $	*/
a158 10
 * The matchbyname function is useful in drivers that are matched
 * by romaux name, i.e., all `mainbus attached' devices.  It expects
 * its aux pointer to point to a pointer to the name (the address of
 * a romaux structure suffices, for instance).
 */
struct device;
struct cfdata;
int	matchbyname(struct device *, void *cf, void *aux);

/*
d181 1
@


1.11
log
@Cosmetic changes only, primarily making comments line up nicely after the
__P removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.h,v 1.10 2002/03/14 03:16:00 millert Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.10
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.h,v 1.9 2002/03/14 01:26:43 millert Exp $	*/
d129 1
a129 2
void	*mapdev(struct rom_reg *pa, int va,
		     int offset, int size);
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.h,v 1.8 2001/05/05 22:34:17 art Exp $	*/
d209 1
a209 2
void	mountroot_hook_establish __P((void (*)(struct device *),
				      struct device *));
@


1.8
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.h,v 1.7 1999/07/23 19:11:27 jason Exp $	*/
d129 2
a130 2
void	*mapdev __P((struct rom_reg *pa, int va,
		     int offset, int size));
d140 2
a141 2
void	*bus_map __P((struct rom_reg *, int));
void	bus_untmp __P((void));
d148 4
a151 4
int	getproplen __P((int node, char *name));
int	getprop __P((int node, char *name, void *buf, int bufsiz));
char	*getpropstring __P((int node, char *name));
int	getpropint __P((int node, char *name, int deflt));
d161 1
a161 1
int	romprop __P((struct romaux *ra, const char *name, int node));
d171 1
a171 1
int	matchbyname __P((struct device *, void *cf, void *aux));
d177 1
a177 1
char	*clockfreq __P((int freq));
d193 1
a193 1
void	rominterpret __P((char *));
d202 2
a203 2
struct bootpath	*bootpath_store __P((int, struct bootpath *));
int		sd_crazymap __P((int));
d206 1
a206 1
struct	device *parsedisk __P((char *, int, int, dev_t *));
d209 1
a209 1
void	mountroot_hook_establish __P((void (*) __P((struct device *)),
d212 11
a222 11
void	bootstrap __P((void));
int	firstchild __P((int));
int	nextsibling __P((int));
void	callrom __P((void));
struct device *getdevunit __P((char *, int));
void	*findzs __P((int));
int	romgetcursoraddr __P((int **, int **));
int	findroot __P((void));
int	findnode __P((int, const char *));
int	opennode __P((char *));
int	node_has_property __P((int, const char *));
@


1.8.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.h,v 1.8 2001/05/05 22:34:17 art Exp $	*/
d129 2
a130 1
void	*mapdev(struct rom_reg *pa, int va, int offset, int size);
d140 2
a141 2
void	*bus_map(struct rom_reg *, int);
void	bus_untmp(void);
d148 4
a151 4
int	getproplen(int node, char *name);
int	getprop(int node, char *name, void *buf, int bufsiz);
char	*getpropstring(int node, char *name);
int	getpropint(int node, char *name, int deflt);
d161 1
a161 1
int	romprop(struct romaux *ra, const char *name, int node);
d171 1
a171 1
int	matchbyname(struct device *, void *cf, void *aux);
d177 1
a177 1
char	*clockfreq(int freq);
d193 1
a193 1
void	rominterpret(char *);
d202 2
a203 2
struct bootpath	*bootpath_store(int, struct bootpath *);
int		sd_crazymap(int);
d206 1
a206 1
struct	device *parsedisk(char *, int, int, dev_t *);
d209 2
a210 1
void	mountroot_hook_establish(void (*)(struct device *), struct device *);
d212 11
a222 11
void	bootstrap(void);
int	firstchild(int);
int	nextsibling(int);
void	callrom(void);
struct device *getdevunit(char *, int);
void	*findzs(int);
int	romgetcursoraddr(int **, int **);
int	findroot(void);
int	findnode(int, const char *);
int	opennode(char *);
int	node_has_property(int, const char *);
@


1.7
log
@Drivers for the FORCE CPU-5V:
o fga5000 vme-sbus bridge
o system config registers
o flash memory
and daadio VME board driver
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.h,v 1.6 1999/04/18 03:24:27 jason Exp $	*/
a211 1
void	configure __P((void));
@


1.7.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.h,v 1.7 1999/07/23 19:11:27 jason Exp $	*/
d212 1
@


1.7.4.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d129 2
a130 1
void	*mapdev(struct rom_reg *pa, int va, int offset, int size);
d140 2
a141 2
void	*bus_map(struct rom_reg *, int);
void	bus_untmp(void);
d148 4
a151 4
int	getproplen(int node, char *name);
int	getprop(int node, char *name, void *buf, int bufsiz);
char	*getpropstring(int node, char *name);
int	getpropint(int node, char *name, int deflt);
d161 1
a161 1
int	romprop(struct romaux *ra, const char *name, int node);
d171 1
a171 1
int	matchbyname(struct device *, void *cf, void *aux);
d177 1
a177 1
char	*clockfreq(int freq);
d193 1
a193 1
void	rominterpret(char *);
d202 2
a203 2
struct bootpath	*bootpath_store(int, struct bootpath *);
int		sd_crazymap(int);
d206 1
a206 1
struct	device *parsedisk(char *, int, int, dev_t *);
d209 2
a210 1
void	mountroot_hook_establish(void (*)(struct device *), struct device *);
d212 11
a222 11
void	bootstrap(void);
int	firstchild(int);
int	nextsibling(int);
void	callrom(void);
struct device *getdevunit(char *, int);
void	*findzs(int);
int	romgetcursoraddr(int **, int **);
int	findroot(void);
int	findnode(int, const char *);
int	opennode(char *);
int	node_has_property(int, const char *);
@


1.7.4.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.h,v 1.7.4.2 2002/03/28 10:57:10 niklas Exp $	*/
d25 5
a29 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6
log
@Support for the Sun SBus Expansion Subsystem (SUNW,xbox)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.h,v 1.5 1997/08/08 08:26:03 downsj Exp $	*/
d112 10
@


1.5
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d111 1
@


1.4
log
@netbsd port, now we merge our changes back in
@
text
@d1 2
a2 1
/*	$NetBSD: autoconf.h,v 1.16 1996/04/10 20:33:38 pk Exp $ */
a63 1
#define RA_MAXRANGE	10		/* max # of bus translations */
d88 2
a89 8
	struct rom_range {		/* Only used on v3 PROMs */
		u_int32_t	cspace;		/* Client space */
		u_int32_t	coffset;	/* Client offset */
		u_int32_t	pspace;		/* Parent space */
		u_int32_t	poffset;	/* Parent offset */
		u_int32_t	size;		/* Size in bytes of this range */
	} ra_range[RA_MAXRANGE];
	int	ra_nrange;
d91 6
a96 1
	struct	bootpath *ra_bp;	/* used for locating boot device */
a111 2
extern int bt2pmt[];

d119 3
a121 3
		     int offset, int size, int bustype));
#define	mapiodev(pa, offset, size, bustype) \
	mapdev(pa, 0, offset, size, bustype)
d125 2
a126 6
#define REG2PHYS(rr, offset, bt)				\
	(((u_int)(rr)->rr_paddr + (offset)) |			\
		((CPU_ISSUN4M)					\
			? ((rr)->rr_iospace << PMAP_SHFT4M)	\
			: bt2pmt[bt])				\
	)
d129 1
a129 2
void	*bus_map __P((struct rom_reg *, int, int));
void	*bus_tmp __P((void *, int));
d137 1
d159 1
@


1.3
log
@new mapdev/()/mapiodev() calling convention uses "struct rom_reg *" to supply
base plus an offset
new dvma routines
@
text
@d1 1
a1 1
/*	$NetBSD: autoconf.h,v 1.9 1995/03/08 15:51:03 pk Exp $ */
d59 3
a61 2
#define	RA_MAXVADDR	4		/* max (virtual) addresses per device */
#define	RA_MAXREG	2		/* max # of register banks per device */
d63 2
d71 1
d81 1
d87 10
a97 1
	int	ra_pfour;		/* p4 register, for BUS_PFOUR devices */
a111 1
#define BUS_PFOUR	5
d116 25
d165 1
a174 30
 * mapiodev maps an I/O device to a virtual address, returning the address.
 * mapdev does the real work: you can supply a special virtual address and
 * it will use that instead of creating one, but you must only do this if
 * you get it from ../sparc/vaddrs.h.
 */
void	*mapdev __P((struct rom_reg *rr, int va, int offset,
	    int size, int bustype));
#define	mapiodev(rr, offset, size, bustype)	mapdev(rr, 0, offset, size, bustype)

void 	*bus_map __P((void *pa, int len, int bustype));
void 	*bus_tmp __P((void *pa, int bustype));
void	bus_untmp __P((void));

#ifdef notyet
/*
 * REG2PHYS is provided for drivers with a `d_mmap' function.
 */
#define REG2PHYS(rr, offset, bt)				\
	(((u_int)(rr)->rr_paddr + (offset)) |			\
		((cputyp == CPU_SUN4M)				\
			? ((rr)->rr_iospace << PMAP_SHFT4M)	\
			: bt2pmt[bt])				\
	)
#else
#define REG2PHYS(rr, offset, bt)				\
	(((u_int)(rr)->rr_paddr + (offset)) | (bt2pmt[bt])	\
	)
#endif

/*
d192 3
a194 2
	char	name[8];		/* name of this node */
	int	val[2];			/* up to two optional values */
d197 2
a198 4
struct device *bootdv;			/* found during autoconfiguration */

struct bootpath *bootpath_store __P((int, struct bootpath *));
int sd_crazymap __P((int));
d202 17
@


1.2
log
@put bus_*() protos here; pfour support
@
text
@d141 3
a143 2
void	*mapdev __P((void *pa, int va, int size, int bustype));
#define	mapiodev(pa, size, bustype)	mapdev(pa, 0, size, bustype)
d148 16
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: autoconf.h,v 1.10 1995/08/18 10:47:46 pk Exp $ */
d83 1
d98 1
d144 4
d172 2
a173 2
struct bootpath	*bootpath_store __P((int, struct bootpath *));
int		sd_crazymap __P((int));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
