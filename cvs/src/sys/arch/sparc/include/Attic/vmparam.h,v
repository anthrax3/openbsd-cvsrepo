head	1.49;
access;
symbols
	OPENBSD_6_0:1.48.0.4
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.48.0.2
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.46.0.4
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.41.0.4
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.39.0.6
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.39.0.4
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.2
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.4
	OPENBSD_5_0:1.38.0.2
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.36.0.2
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.35.0.2
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.33.0.6
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.33.0.8
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.4
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.33.0.2
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.31.0.12
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.31.0.10
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.31.0.8
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.31.0.6
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.31.0.4
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.31.0.2
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.28.0.6
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.28.0.4
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	UBC_SYNC_A:1.27
	OPENBSD_3_3:1.27.0.2
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.26.0.2
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.24.0.2
	OPENBSD_3_1_BASE:1.24
	UBC_SYNC_B:1.27
	UBC:1.21.0.2
	UBC_BASE:1.21
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.14.0.6
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.4
	OPENBSD_2_7_BASE:1.14
	SMP:1.14.0.2
	SMP_BASE:1.14
	kame_19991208:1.14
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.6.0.4
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.49
date	2016.09.01.09.23.42;	author tedu;	state dead;
branches;
next	1.48;
commitid	Q2PxaFNhqAe0Wmla;

1.48
date	2015.09.21.00.24.21;	author tobiasu;	state Exp;
branches;
next	1.47;
commitid	OvFoJaQtZ4Ic29uA;

1.47
date	2015.09.18.12.50.27;	author miod;	state Exp;
branches;
next	1.46;
commitid	aBaVLnMs8wxyaAGJ;

1.46
date	2015.06.02.04.31.53;	author miod;	state Exp;
branches;
next	1.45;
commitid	PhNpsU2zqVxSFdZa;

1.45
date	2015.03.30.20.30.22;	author miod;	state Exp;
branches;
next	1.44;
commitid	f66FukLLgPJs9j5H;

1.44
date	2015.03.27.20.25.39;	author miod;	state Exp;
branches;
next	1.43;
commitid	DNjbblqLgBZmk6yi;

1.43
date	2015.03.18.20.56.40;	author miod;	state Exp;
branches;
next	1.42;
commitid	1t8JWNihm6Vc4kyS;

1.42
date	2014.05.31.20.11.11;	author miod;	state Exp;
branches;
next	1.41;
commitid	0tTWseP2VVvnz1EB;

1.41
date	2014.01.30.18.16.41;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2014.01.23.22.06.29;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2012.07.01.15.31.35;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2011.05.30.22.25.22;	author oga;	state Exp;
branches;
next	1.37;

1.37
date	2011.03.23.16.54.37;	author pirofti;	state Exp;
branches;
next	1.36;

1.36
date	2010.12.15.05.30.19;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2010.06.27.03.03.48;	author thib;	state Exp;
branches;
next	1.34;

1.34
date	2010.04.22.19.02.47;	author oga;	state Exp;
branches;
next	1.33;

1.33
date	2008.07.22.18.15.48;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2008.06.24.21.24.03;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2005.04.17.18.47.48;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2005.04.11.15.13.01;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2004.11.28.01.36.39;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.02.23.27.55;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2002.10.28.19.30.21;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2002.07.26.18.36.33;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2002.07.20.21.38.21;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.17.22.59.53;	author maja;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.19.08.58.05;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.05.16.25.44;	author art;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2001.11.30.17.37.43;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.09.22.18.00.10;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.27.06.19.55;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.06.00.45.55;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.05.20.56.52;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.15.23.23.58;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	99.12.01.22.49.10;	author deraadt;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	99.11.11.12.30.36;	author art;	state Exp;
branches;
next	1.12;

1.12
date	99.11.05.21.19.23;	author art;	state Exp;
branches;
next	1.11;

1.11
date	99.07.09.21.33.37;	author art;	state Exp;
branches;
next	1.10;

1.10
date	99.06.06.20.32.26;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	99.05.29.14.53.27;	author art;	state Exp;
branches;
next	1.8;

1.8
date	99.05.27.23.56.39;	author art;	state Exp;
branches;
next	1.7;

1.7
date	99.04.22.20.36.21;	author art;	state Exp;
branches;
next	1.6;

1.6
date	98.08.23.23.07.04;	author marc;	state Exp;
branches;
next	1.5;

1.5
date	97.08.08.08.26.54;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	97.06.04.23.18.58;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.08.11.05.34.59;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.15.13.56.43;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.45;	author deraadt;	state Exp;
branches;
next	;

1.14.2.1
date	2001.05.14.21.37.13;	author niklas;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2001.07.04.10.23.33;	author niklas;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2001.10.31.03.07.57;	author nate;	state Exp;
branches;
next	1.14.2.4;

1.14.2.4
date	2001.12.05.00.39.13;	author niklas;	state Exp;
branches;
next	1.14.2.5;

1.14.2.5
date	2002.03.06.02.04.46;	author niklas;	state Exp;
branches;
next	1.14.2.6;

1.14.2.6
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.14.2.7;

1.14.2.7
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.14.2.8;

1.14.2.8
date	2003.06.07.11.14.43;	author ho;	state Exp;
branches;
next	;

1.21.2.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2002.10.29.00.28.10;	author art;	state Exp;
branches;
next	1.21.2.3;

1.21.2.3
date	2002.10.29.01.11.09;	author art;	state Exp;
branches;
next	;


desc
@@


1.49
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: vmparam.h,v 1.48 2015/09/21 00:24:21 tobiasu Exp $	*/
/*	$NetBSD: vmparam.h,v 1.13 1997/07/12 16:20:03 perry Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)vmparam.h	8.1 (Berkeley) 6/11/93
 */

#ifndef _MACHINE_VMPARAM_H_
#define _MACHINE_VMPARAM_H_

/*
 * Machine dependent constants for SPARC
 */

/*
 * Virtual memory related constants, all in bytes
 */
#ifndef MAXTSIZ
#define	MAXTSIZ		(64*1024*1024)		/* max text size */
#endif
#ifndef DFLDSIZ
#define	DFLDSIZ		(64*1024*1024)		/* initial data size limit */
#endif
#ifndef MAXDSIZ
#define	MAXDSIZ		(256*1024*1024)		/* max data size */
#endif
#ifndef BRKSIZ
#define	BRKSIZ		MAXDSIZ			/* heap gap size */
#endif
#ifndef	DFLSSIZ
#define	DFLSSIZ		(2*1024*1024)		/* initial stack size limit */
#endif
#ifndef	MAXSSIZ
#define	MAXSSIZ		(32*1024*1024)		/* max stack size */
#endif

#define STACKGAP_RANDOM	64*1024
#define STACKGAP_RANDOM_SUN4M 256*1024

/*
 * Size of shared memory map
 */
#ifndef SHMMAXPGS
#define SHMMAXPGS	1024
#endif

/*
 * User/kernel map constants.  Note that sparc/vaddrs.h defines the
 * IO space virtual base, which must be the same as VM_MAX_KERNEL_ADDRESS:
 * tread with care.
 */

#define	VM_MIN_KERNEL_ADDRESS_OLD	((vaddr_t)KERNBASE)
#define	VM_MIN_KERNEL_ADDRESS_SUN4	((vaddr_t)0xf0000000)
#define	VM_MIN_KERNEL_ADDRESS_SRMMU	((vaddr_t)0xc0000000)

#if (defined(SUN4) || defined(SUN4C) || defined(SUN4E)) && \
      (defined(SUN4D) || defined(SUN4M))
/* user/kernel bound will de determined at run time */
extern vsize_t vm_kernel_space_size;
#define	VM_KERNEL_SPACE_SIZE	vm_kernel_space_size
#define VM_MAXUSER_ADDRESS	vm_min_kernel_address
#define VM_MAX_ADDRESS		vm_min_kernel_address
#define	USRSTACK		vm_min_kernel_address
#elif (defined(SUN4) || defined(SUN4C) || defined(SUN4E))
/* old Sun MMU with address hole */
#define	VM_MIN_KERNEL_ADDRESS	VM_MIN_KERNEL_ADDRESS_SUN4
#define VM_MAXUSER_ADDRESS	VM_MIN_KERNEL_ADDRESS
#define VM_MAX_ADDRESS		VM_MIN_KERNEL_ADDRESS
#define	USRSTACK		VM_MIN_KERNEL_ADDRESS
#else
/* SRMMU without address hole */
#define	VM_MIN_KERNEL_ADDRESS	VM_MIN_KERNEL_ADDRESS_SRMMU
#define VM_MAXUSER_ADDRESS	VM_MIN_KERNEL_ADDRESS
#define VM_MAX_ADDRESS		VM_MIN_KERNEL_ADDRESS
#define	USRSTACK		VM_MIN_KERNEL_ADDRESS
#endif

#define VM_MIN_ADDRESS		((vaddr_t)0x2000)
#define VM_MAX_KERNEL_ADDRESS	((vaddr_t)0xfe000000)

extern vaddr_t vm_pie_max_addr;
#define	VM_PIE_MAX_ADDR vm_pie_max_addr

#define	IOSPACE_BASE		VM_MAX_KERNEL_ADDRESS
#define	IOSPACE_LEN		0x01000000		/* 16 MB of iospace */

#define VM_PHYSSEG_MAX		32	/* we only have one "hole" */
#define VM_PHYSSEG_STRAT	VM_PSTRAT_BSEARCH
#define VM_PHYSSEG_NOADD		/* can't add RAM after vm_mem_init */

#if defined (_KERNEL)
void		dvma_mapout(vaddr_t, vaddr_t, int);
#endif

#endif /* _MACHINE_VMPARAM_H_ */
@


1.48
log
@Increase MAXTSIZ to 64MB, required for gcc/gnat

ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.47 2015/09/18 12:50:27 miod Exp $	*/
@


1.47
log
@Drop the workarounds allowing SMALL_KERNEL (i.e. installation media) to be
booted from old (< 2.10) bootblocks.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.46 2015/06/02 04:31:53 miod Exp $	*/
d55 1
a55 1
#define	MAXTSIZ		(32*1024*1024)		/* max text size */
@


1.46
log
@Override pie range constants (well, only VM_PIE_MAX_ADDR) with a variable
which value is decided at runtime, in order to only enable PIE on sun4m
which has a large enough address space.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.45 2015/03/30 20:30:22 miod Exp $	*/
d93 1
a93 7
#if defined(SMALL_KERNEL)
/* limit to small KVA regardless of the cpu type */
#define	VM_MIN_KERNEL_ADDRESS	VM_MIN_KERNEL_ADDRESS_OLD
#define VM_MAXUSER_ADDRESS	VM_MIN_KERNEL_ADDRESS
#define VM_MAX_ADDRESS		VM_MIN_KERNEL_ADDRESS
#define	USRSTACK		VM_MIN_KERNEL_ADDRESS
#elif (defined(SUN4) || defined(SUN4C) || defined(SUN4E)) && \
@


1.45
log
@Add a bus_dma_tag_t for DVMA usage, suitable for use for devices not sitting
behind a sun4m iommu.

Move the existing dvma routines from vm_machdep.c to this new dvma.c; this
allows for a few declarations to be removed from public headers.

Extend the device attachment arguments (struct confargs) to pass a
bus_dma_tag_t. mainbus receives the dvma bus_dma_tag_t, and devices pass the
tag unchanged to their children, except for iommu(4) which replaces it with
its own.

Change the few sun4m-only drivers to pick the bus_dma_tag_t from confargs
rather than assume iommu; this allows qlw(4) to attach and work on sun4c.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.44 2015/03/27 20:25:39 miod Exp $	*/
d123 3
@


1.44
log
@Lower VM_MIN_KERNEL_ADDRESS by 128MB on non-SRMMU systems (sun4/4c/4e) as well,
in order to give these systems a more reasonable amount of kva, yet still
providing .75GB to userland processes.

Although there is no dependency upon a recent boot loader on non-SRMMU systems,
SMALL_KERNEL will nevertheless stick to the legacy kvm layout, for the time
being.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.43 2015/03/18 20:56:40 miod Exp $	*/
a131 3
struct vm_map;
#define		dvma_mapin(map,va,len,canwait)	dvma_mapin_space(map,va,len,canwait,0)
vaddr_t		dvma_mapin_space(struct vm_map *, vaddr_t, int, int, int);
a132 1

@


1.43
log
@Rework the virtual memory layout on SRMMU systems (sun4d/sun4m) to use a much
lower VM_MIN_KERNEL_ADDRESS, since these systems are not crippled by the
Sun-4 MMU hole and have the real 4GB of address space.

Kernels running on Sun-4 MMU are not affected and will still be restricted
to the existing 128MB of kernel space, with 1GB - 128MB of user space.

Kernels running on SRMMU will now provide the low 3GB of address space to
userland, and use the top 1GB for the kernel, except when compiled with
option SMALL_KERNEL, in which case they will keep Sun-4 style the layout
(this is temporary to allow for people to boot bsd.rd to upgrade even when
not running 2.10 boot blocks, and will be removed eventually)

A consequence of this is that the top of the userland stack is no longer at
0xf0000000. But since nothing in userland uses USRSTACK anymore, this should
not be an issue.

Tested on sun4c and various sun4m, with physical memory sizes ranging from 32
to 448MB.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.42 2014/05/31 20:11:11 miod Exp $	*/
d90 1
d109 1
a109 1
#define	VM_MIN_KERNEL_ADDRESS	VM_MIN_KERNEL_ADDRESS_OLD
@


1.42
log
@Reduce MAXSSIZ to 32MB to match all other platforms; noticed by tobiasu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.41 2014/01/30 18:16:41 miod Exp $	*/
d48 1
a48 1
 * Machine dependent constants for Sun-4c SPARC
a51 7
 * USRTEXT is the start of the user text/data space, while USRSTACK
 * is the top (end) of the user stack.
 */
#define	USRTEXT		0x2000			/* Start of user text */
#define	USRSTACK	VM_MIN_KERNEL_ADDRESS	/* Start of user stack */

/*
d88 32
a120 3
#define VM_MAX_ADDRESS		((vaddr_t)VM_MIN_KERNEL_ADDRESS)
#define VM_MAXUSER_ADDRESS	((vaddr_t)VM_MIN_KERNEL_ADDRESS)
#define VM_MIN_KERNEL_ADDRESS	((vaddr_t)KERNBASE)
d130 1
a130 1
#if defined (_KERNEL) && !defined(_LOCORE)
d135 1
@


1.41
log
@Move declaration of struct vm_page_md from <machine/vmparam.h> to
<machine/pmap.h> where it belongs, and compensate in <uvm/uvm_extern.h>
by including <uvm/uvm_pmap.h> before <uvm/uvm_page.h>. Tested on all
MACHINE_ARCH but amd64 and i386 (and hppa64).
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.40 2014/01/23 22:06:29 miod Exp $	*/
d77 1
a77 1
#define	MAXSSIZ		(128*1024*1024)		/* max stack size */
@


1.40
log
@unifdef -D__HAVE_VM_PAGE_MD - no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.39 2012/07/01 15:31:35 miod Exp $	*/
a106 24

/*
 * pmap specific data stored in the vm_physmem[] array
 */


/* XXX - belongs in pmap.h, but put here because of ordering issues */
struct pvlist {
	struct		pvlist *pv_next;	/* next pvlist, if any */
	struct		pmap *pv_pmap;		/* pmap of this va */
	vaddr_t		pv_va;			/* virtual address */
	int		pv_flags;		/* flags (below) */
};

struct vm_page_md {
	struct pvlist pv_head;
};

#define VM_MDPAGE_INIT(pg) do {			\
	(pg)->mdpage.pv_head.pv_next = NULL;	\
	(pg)->mdpage.pv_head.pv_pmap = NULL;	\
	(pg)->mdpage.pv_head.pv_va = 0;		\
	(pg)->mdpage.pv_head.pv_flags = 0;	\
} while (0)
@


1.39
log
@Increase default and maximum text, data and stack size limits; this is required
to build X at -O2 nowadays, as well as an increasing number of ports.
Based upon a diff from Brad, with a few values stripped down to fit within
the sun4/4c virtual address space limitation. Discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.38 2011/05/30 22:25:22 oga Exp $	*/
a120 1
#define __HAVE_VM_PAGE_MD
@


1.38
log
@Remove the freelist member from vm_physseg

The new world order of pmemrange makes this data completely redundant
(being dealt with by the pmemrange constraints instead). Remove all code
that messes with the freelist.

While touching every caller of uvm_page_physload() anyway, add the flags
argument to all callers (all but one is 0 and that one already used
PHYSLOAD_DEVICE) and remove the macro magic to allow callers to continue
without it.

Should shrink the code a bit, as well.

matthew@@ pointed out some mistakes i'd made.
``freelist death, I like. Ok.' ariane@@
`I agree with the general direction, go ahead and i'll fix any fallout
shortly'' miod@@ (68k 88k and vax i could not check would build)
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.37 2011/03/23 16:54:37 pirofti Exp $	*/
d62 1
a62 1
#define	MAXTSIZ		(16*1024*1024)		/* max text size */
d65 1
a65 1
#define	DFLDSIZ		(32*1024*1024)		/* initial data size limit */
d68 1
a68 1
#define	MAXDSIZ		(128*1024*1024)		/* max data size */
d74 1
a74 1
#define	DFLSSIZ		(512*1024)		/* initial stack size limit */
d77 1
a77 1
#define	MAXSSIZ		MAXDSIZ			/* max stack size */
@


1.37
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.36 2010/12/15 05:30:19 tedu Exp $	*/
a131 3

#define VM_NFREELIST		1
#define VM_FREELIST_DEFAULT	0
@


1.36
log
@oops, i forgot to check in the BRKSIZ define in uvm, but deraadt thinks
its better as a per arch MD define anyway.  all default to MAXDSIZ as before.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.35 2010/06/27 03:03:48 thib Exp $	*/
d44 2
a45 2
#ifndef _SPARC_VMPARAM_H_
#define _SPARC_VMPARAM_H_
d143 1
a143 1
#endif /* _SPARC_VMPARAM_H_ */
@


1.35
log
@uvm constraints. Add two mandatory MD symbols, uvm_md_constraints
which contains the constraints for DMA/memory allocation for each
architecture, and dma_constraints which contains the range of addresses
that are dma accessable by the system.

This is based on ariane@@'s physcontig diff, with lots of bugfixes and
additions the following additions by my self:

Introduce a new function pool_set_constraints() which sets the address
range for which we allocate pages for the pool from, this is now used
for the mbuf/mbuf cluster pools to keep them dma accessible.

The !direct archs no longer stuff pages into the kernel object in
uvm_km_getpage_pla but rather do a pmap_extract() in uvm_km_putpages.

Tested heavily by my self on i386, amd64 and sparc64. Some tests on
alpha and SGI.

"commit it" beck, art, oga, deraadt
"i like the diff" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.33 2008/07/22 18:15:48 miod Exp $	*/
d69 3
@


1.34
log
@Committing on behalf or ariane@@.

recommit pmemrange:
        physmem allocator: change the view of free memory from single
        free pages to free ranges.  Classify memory based on region with
        associated use-counter (which is used to construct a priority
        list of where to allocate memory).

	Based on code from tedu@@, help from many.

Useable now that bugs have been found and fixed in most architecture's
pmap.c

ok by everyone who has done a pmap or uvm commit in the last year.
@
text
@a132 3
/* No UVM_IO_RANGES required: IOMMU takes care of this. */
#define UVM_IO_RANGES {}

@


1.33
log
@Do not define VM_MIN_ADDRESS as __LDPGSZ, but provide its value, to prevent
uvm_map.c from requiring <machine/exec.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.32 2008/06/24 21:24:03 deraadt Exp $	*/
d132 3
@


1.32
log
@On user/kernel shared page table machines, do not let processes map their
own page 0, as discussed with miod (and many others previously, including
art and toby).  On sparc, make this __LDPGSZ because PAGE_SIZE is non-constant
ok miod tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.31 2005/04/17 18:47:48 miod Exp $	*/
d92 1
a92 1
#define VM_MIN_ADDRESS		((vaddr_t)__LDPGSZ)
@


1.31
log
@Do not use KERNBASE when VM_MIN_KERNEL_ADDRESS or VM_MAXUSER_ADDRESS are
implied; this currently does not change anything (yet).

Also, define the I/O space range in <machine/vmparam.h> rather than in
<sparc/sparc/vaddrs.h>.

ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.30 2005/04/11 15:13:01 deraadt Exp $	*/
d92 1
a92 1
#define VM_MIN_ADDRESS		((vaddr_t)0)
@


1.30
log
@use MD #define to choose stackgap size per-architecture.  on sparc, special
case sun4c/sun4 -- because address space is more constrained
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.29 2004/11/28 01:36:39 mickey Exp $	*/
d56 1
a56 1
#define	USRSTACK	KERNBASE		/* Start of user stack */
d93 2
a94 2
#define VM_MAX_ADDRESS		((vaddr_t)KERNBASE)
#define VM_MAXUSER_ADDRESS	((vaddr_t)KERNBASE)
d97 3
@


1.29
log
@MAXSLP is not really an MD-configurable define so move it to param.h; miod@@ testing
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.28 2003/06/02 23:27:55 millert Exp $	*/
d76 3
@


1.28
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.27 2002/10/28 19:30:21 art Exp $	*/
a82 11

/*
 * The time for a process to be blocked before being very swappable.
 * This is a number of seconds which the system takes as being a non-trivial
 * amount of real time.  You probably shouldn't change this;
 * it is used in subtle ways (fractions and multiples of it are, that is, like
 * half of a ``long time'', almost a long time, etc.)
 * It is related to human patience and other factors which don't really
 * change over time.
 */
#define	MAXSLP 		20
@


1.27
log
@Convert sparc pmap from physseg to VM_PAGE_MD.
This allows us to remove some ambiguities on how some functions are called,
remove some diagnostic checks for conditions that can never happen and
remove the ugly hack with "pmap_initialized". It also removes some unnecessary
overhead in time-critical functions like pmap_{zero,copy}_page and
pmap_{is,clear}_{mod*,ref*}.

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.26 2002/07/26 18:36:33 art Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.26
log
@Zap VM_KMEM_SIZE, not used anymore.
Pointed out by francisco <frisco@@blackant.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.25 2002/07/20 21:38:21 art Exp $	*/
d117 8
a124 3
#define __HAVE_PMAP_PHYSSEG
struct pmap_physseg {
	struct pvlist *pv_head;
d126 12
@


1.25
log
@define __HAVE_PMAP_PHYSSEG
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.24 2002/03/14 01:26:44 millert Exp $	*/
a108 3

/* virtual sizes (bytes) for various kernel submaps */
#define VM_KMEM_SIZE		(NKMEMCLUSTERS*PAGE_SIZE)
@


1.24
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.23 2002/02/17 22:59:53 maja Exp $	*/
d120 1
@


1.23
log
@Patch from Daniel Lucq <daniel@@lucq.org>

The patch allows you to change the value of NMBCLUSTERS, BUFCACHEPERCENT
and NKMEMPAGES using the config command, instead of recompiling the kernel.

This is the kernel part of the patch. I have compiled it on i386, sparc64,
alpha and macppc. -moj ok art@@ maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.22 2001/12/19 08:58:05 art Exp $	*/
d130 2
a131 2
vaddr_t		dvma_mapin_space __P((struct vm_map *, vaddr_t, int, int, int));
void		dvma_mapout __P((vaddr_t, vaddr_t, int));
@


1.22
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.19 2001/09/22 18:00:10 miod Exp $	*/
a110 1
#define VM_MBUF_SIZE		(NMBCLUSTERS*MCLBYTES)
@


1.21
log
@VM_KMEM_SIZE no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.20 2001/11/30 17:37:43 art Exp $	*/
d112 1
a120 1
#define __HAVE_PMAP_PHYSSEG
@


1.21.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.21 2001/12/05 16:25:44 art Exp $	*/
d111 1
a111 1
#define VM_KMEM_SIZE		(NKMEMCLUSTERS*PAGE_SIZE)
d131 2
a132 2
vaddr_t		dvma_mapin_space(struct vm_map *, vaddr_t, int, int, int);
void		dvma_mapout(vaddr_t, vaddr_t, int);
@


1.21.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.21.2.1 2002/06/11 03:38:16 art Exp $	*/
d110 3
d120 3
a122 11
/* XXX - belongs in pmap.h, but put here because of ordering issues */
struct pvlist {
	struct		pvlist *pv_next;	/* next pvlist, if any */
	struct		pmap *pv_pmap;		/* pmap of this va */
	vaddr_t		pv_va;			/* virtual address */
	int		pv_flags;		/* flags (below) */
};

#define __HAVE_VM_PAGE_MD
struct vm_page_md {
	struct pvlist pv_head;
a123 7

#define VM_MDPAGE_INIT(pg) do {			\
	(pg)->mdpage.pv_head.pv_next = NULL;	\
	(pg)->mdpage.pv_head.pv_pmap = NULL;	\
	(pg)->mdpage.pv_head.pv_va = 0;		\
	(pg)->mdpage.pv_head.pv_flags = 0;	\
} while (0)
@


1.21.2.3
log
@misc minor cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.21.2.2 2002/10/29 00:28:10 art Exp $	*/
a116 2


@


1.20
log
@Now that pmaps can have vm_page_md, make pmap_physseg optional.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.19 2001/09/22 18:00:10 miod Exp $	*/
a111 1
#define VM_KMEM_SIZE		(NKMEMCLUSTERS*PAGE_SIZE)
@


1.19
log
@Remove more old, dusty, unused defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.18 2001/06/27 06:19:55 art Exp $	*/
d121 1
@


1.18
log
@MNN is no longer an option.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.17 2001/05/06 00:45:55 art Exp $	*/
a81 11
 * Default sizes of swap allocation chunks (see dmap.h).
 * The actual values may be changed in vminit() based on MAXDSIZ.
 * With MAXDSIZ of 16Mb and NDMAP of 38, dmmax will be 1024.
 * DMMIN should be at least ctod(1) so that vtod() works.
 * vminit() insures this.
 */
#define	DMMIN	32			/* smallest swap allocation */
#define	DMMAX	NBPG			/* largest potential swap allocation */
#define	DMTEXT	1024			/* swap allocation for text */

/*
a97 13

/*
 * A swapped in process is given a small amount of core without being bothered
 * by the page replacement algorithm.  Basically this says that if you are
 * swapped in you deserve some resources.  We protect the last SAFERSS
 * pages against paging and will just swap you out rather than paging you.
 */
#define	SAFERSS		4		/* nominal ``small'' resident set size
					   protected against replacement */

/*
 * Mach derived constants
 */
@


1.17
log
@Update some comments wrt. the CLSIZE changes.
And remove that memory price comment from 1981. It is amusing, but also
confusing because the math in there is only correct on vax.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.16 2001/05/05 20:56:52 art Exp $	*/
a136 2

#define MACHINE_NEW_NONCONTIG
@


1.16
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.15 2001/01/15 23:23:58 jason Exp $	*/
a114 11
 * Note that each process has at least UPAGES+CLSIZE pages which are not
 * paged anyways (this is currently 8+2=10 pages or 5k bytes), so this
 * number just means a swapped in process is given around 25k bytes.
 * Just for fun: current memory prices are 4600$ a megabyte on VAX (4/22/81),
 * so we loan each swapped in process memory worth 100$, or just admit
 * that we don't consider it worthwhile and swap it out to disk which costs
 * $30/mb or about $0.75.
 * Update: memory prices have changed recently (9/96). At the current    
 * value of $6 per megabyte, we lend each swapped in process memory worth
 * $0.15, or just admit that we don't consider it worthwhile and swap it out
 * to disk which costs $0.20/MB, or just under half a cent. 
@


1.15
log
@- increase the amount of space mapped for dvma on sun4m
- use a flag to specify allocations for 24 bit devices
- compatibility macros to deal with the 32 bit devices

This fixes the 'le at sbus' on sun4m problem (with the extent fixes
earlier), and allows the Artecon ethernet cards to work in sun4m machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.14 1999/12/01 22:49:10 deraadt Exp $	*/
d147 1
a147 1
#define VM_KMEM_SIZE		(NKMEMCLUSTERS*CLBYTES)
@


1.14
log
@crank DFLDSIZ to 32MB
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.13 1999/11/11 12:30:36 art Exp $	*/
d167 2
a168 1
vaddr_t		dvma_mapin __P((struct vm_map *, vaddr_t, int, int));
@


1.14.2.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.15 2001/01/15 23:23:58 jason Exp $	*/
d167 1
a167 2
#define		dvma_mapin(map,va,len,canwait)	dvma_mapin_space(map,va,len,canwait,0)
vaddr_t		dvma_mapin_space __P((struct vm_map *, vaddr_t, int, int, int));
@


1.14.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.14.2.1 2001/05/14 21:37:13 niklas Exp $	*/
d115 11
d147 3
a149 1
#define VM_KMEM_SIZE		(NKMEMCLUSTERS*PAGE_SIZE)
@


1.14.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.14.2.2 2001/07/04 10:23:33 niklas Exp $	*/
d82 11
d109 13
@


1.14.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.14.2.3 2001/10/31 03:07:57 nate Exp $	*/
a120 1
#define __HAVE_PMAP_PHYSSEG
@


1.14.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d111 1
d121 1
@


1.14.2.6
log
@Merge in -current from about a week ago
@
text
@d130 2
a131 2
vaddr_t		dvma_mapin_space(struct vm_map *, vaddr_t, int, int, int);
void		dvma_mapout(vaddr_t, vaddr_t, int);
@


1.14.2.7
log
@Sync the SMP branch with 3.3
@
text
@d110 3
d120 2
a121 8


/* XXX - belongs in pmap.h, but put here because of ordering issues */
struct pvlist {
	struct		pvlist *pv_next;	/* next pvlist, if any */
	struct		pmap *pv_pmap;		/* pmap of this va */
	vaddr_t		pv_va;			/* virtual address */
	int		pv_flags;		/* flags (below) */
a122 12

#define __HAVE_VM_PAGE_MD
struct vm_page_md {
	struct pvlist pv_head;
};

#define VM_MDPAGE_INIT(pg) do {			\
	(pg)->mdpage.pv_head.pv_next = NULL;	\
	(pg)->mdpage.pv_head.pv_pmap = NULL;	\
	(pg)->mdpage.pv_head.pv_va = 0;		\
	(pg)->mdpage.pv_head.pv_flags = 0;	\
} while (0)
@


1.14.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.14.2.7 2003/03/27 23:49:25 niklas Exp $	*/
d25 5
a29 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.13
log
@General cleanup of pmap.

- MACHINE_NONCONTIG will no longer work and all code that is not
  MACHINE_NEW_NONCONTIG is removed.
- Kill the pv_table hack which adds complexity to the code and wastes some
  memory, let the vm "handle" the pv lists through the vm_physmem array,
  this makes allocation a lot easier.
- kill the managed() macro, since it was only used to see if pvhead would
  end up in a "hole" in pv_table.
- pvhead() is now a function that returns NULL if the page is unmanaged. It
  also takes a page number as an argument instead of the physical address,
  since in most cases pvhead was called as pvhead(ptoa(pa)) anyway and it
  did an atop internally.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.12 1999/11/05 21:19:23 art Exp $	*/
d69 1
a69 1
#define	DFLDSIZ		(24*1024*1024)		/* initial data size limit */
@


1.12
log
@MACHINE_NEW_NONCONTIG is now default even without uvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.11 1999/07/09 21:33:37 art Exp $	*/
d48 3
a150 2
#ifdef MACHINE_NEW_NONCONTIG

d159 1
a159 1
	/* NULL */
a164 2
#endif

d170 2
@


1.11
log
@vm_offset_t -> {v,p}addr_t and vm_size_t -> {v,p}size_t
remove "register" keywords
Various cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.10 1999/06/06 20:32:26 deraadt Exp $	*/
a145 1
#if defined(UVM)
a146 5
#endif

#ifndef MACHINE_NEW_NONCONTIG
#define MACHINE_NONCONTIG	/* VM <=> pmap interface modifier */
#endif
@


1.10
log
@set DFLDSIZ to 24MB
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.9 1999/05/29 14:53:27 art Exp $	*/
d136 5
a140 5
#define VM_MIN_ADDRESS		((vm_offset_t)0)
#define VM_MAX_ADDRESS		((vm_offset_t)KERNBASE)
#define VM_MAXUSER_ADDRESS	((vm_offset_t)KERNBASE)
#define VM_MIN_KERNEL_ADDRESS	((vm_offset_t)KERNBASE)
#define VM_MAX_KERNEL_ADDRESS	((vm_offset_t)0xfe000000)
d174 2
a175 2
vm_offset_t	dvma_mapin __P((struct vm_map *, vm_offset_t, int, int));
void		dvma_mapout __P((vm_offset_t, vm_offset_t, int));
@


1.9
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.8 1999/05/27 23:56:39 art Exp $	*/
d66 1
a66 1
#define	DFLDSIZ		(16*1024*1024)		/* initial data size limit */
@


1.8
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.7 1999/04/22 20:36:21 art Exp $	*/
d150 1
a150 1
#ifndef MACHINE_NEW_NONCONTG
@


1.7
log
@MACHINE_NEW_NONCONTIG code. From NetBSD. Needed by UVM
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.6 1998/08/23 23:07:04 marc Exp $	*/
d147 1
a147 1
#defined MACHINE_NEW_NONCONTIG
@


1.6
log
@crank max data size from 64 to 128 meg
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.5 1997/08/08 08:26:54 downsj Exp $	*/
d146 5
d152 19
@


1.5
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d69 1
a69 1
#define	MAXDSIZ		(64*1024*1024)		/* max data size */
@


1.4
log
@Bump MAXTSIZ to 16MB (makes latest netscape communicator work)
@
text
@d1 2
a2 1
/*	$NetBSD: vmparam.h,v 1.10 1996/03/14 19:49:20 christos Exp $ */
d119 4
@


1.3
log
@netbsd port, now we merge our changes back in
@
text
@d62 1
a62 1
#define	MAXTSIZ		(8*1024*1024)		/* max text size */
@


1.2
log
@new mapdev/()/mapiodev() calling convention uses "struct rom_reg *" to supply
base plus an offset
new dvma routines
@
text
@d1 1
a1 1
/*	$NetBSD: vmparam.h,v 1.6 1995/07/05 18:04:48 pk Exp $ */
d143 1
a143 1
#if defined (_KERNEL) && !defined(LOCORE)
d146 1
a146 1
int		dvma_mapout __P((vm_offset_t, vm_offset_t, int));
@


1.1
log
@Initial revision
@
text
@d142 6
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
