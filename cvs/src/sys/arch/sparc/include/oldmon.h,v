head	1.9;
access;
symbols
	OPENBSD_6_0:1.9.0.60
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.56
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.58
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.50
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.54
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.52
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.48
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.46
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.44
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.42
	OPENBSD_5_0:1.9.0.40
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.38
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.36
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.32
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.34
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.30
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.28
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.26
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.24
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.22
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.20
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.18
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.16
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.14
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.12
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.10
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.8
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.7.0.4
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.16
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.14
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.12
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2002.03.15.01.20.04;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.43;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.08.13.48.21;	author art;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2001.08.08.02.26.35;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.06.17.19.00;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.08.08.08.26.32;	author downsj;	state Exp;
branches
	1.4.12.1;
next	1.3;

1.3
date	96.08.11.05.34.52;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.25.10.06.47;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.43;	author deraadt;	state Exp;
branches;
next	;

1.4.12.1
date	2001.05.14.21.37.12;	author niklas;	state Exp;
branches;
next	1.4.12.2;

1.4.12.2
date	2001.10.31.03.07.57;	author nate;	state Exp;
branches;
next	1.4.12.3;

1.4.12.3
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	;

1.7.4.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Cosmetic changes only, primarily making comments line up nicely after the
__P removal.
@
text
@/*	$OpenBSD: oldmon.h,v 1.8 2002/03/14 01:26:43 millert Exp $	*/
/*	$NetBSD: oldmon.h,v 1.11 1996/03/31 22:21:38 pk Exp $ */

/*
 * Copyright (C) 1985 Regents of the University of California
 * Copyright (c) 1993 Adam Glass
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Adam Glass.
 * 4. The name of the Author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Adam Glass ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: Sprite /cdrom/src/kernel/Cvsroot/kernel/mach/sun3.md/machMon.h,v
 *	    9.1 90/10/03 13:52:34 mgbaker Exp SPRITE (Berkeley)
 */
#ifndef _MACHINE_OLDMON_H
#define _MACHINE_OLDMON_H

/*
 *     Structures, constants and defines for access to the sun monitor.
 *     These are translated from the sun monitor header file "sunromvec.h".
 *
 * The memory addresses for the PROM, and the EEPROM.
 * On the sun2 these addresses are actually 0x00EF??00
 * but only the bottom 24 bits are looked at so these still
 * work ok.
 */
#define PROM_BASE       0xffe81000

enum maptypes { /* Page map entry types. */
	MAP_MAINMEM,
	MAP_OBIO,
	MAP_MBMEM,
	MAP_MBIO,
	MAP_VME16A16D,
	MAP_VME16A32D,
	MAP_VME24A16D,
	MAP_VME24A32D,
	MAP_VME32A16D,
	MAP_VME32A32D
};
/*
 * This table gives information about the resources needed by a device.
 */
struct devinfo {
	unsigned int	d_devbytes;  /* Bytes occupied by device in IO space.*/
	unsigned int	d_dmabytes;  /* Bytes needed by device in DMA memory.*/
	unsigned int	d_localbytes;/* Bytes needed by device for local info.*/
	unsigned int	d_stdcount;  /* How many standard addresses. */
	unsigned long	*d_stdaddrs; /* The vector of standard addresses. */
	enum maptypes	d_devtype;   /* What map space device is in. */
	unsigned int	d_maxiobytes;/* Size to break big I/O's into. */
};

/*
 * A "stand alone I/O request".
 * This is passed as the main argument to the PROM I/O routines
 * in the `om_boottable' structure.
 */
struct saioreq {
	char	si_flgs;
	struct om_boottable *si_boottab;/* Points to boottab entry if any */
	char	*si_devdata;		/* Device-specific data pointer */
	int	si_ctlr;		/* Controller number or address */
	int	si_unit;		/* Unit number within controller */
	long	si_boff;		/* Partition number within unit */
	long	si_cyloff;
	long	si_offset;
	long	si_bn;			/* Block number to R/W */
	char	*si_ma;			/* Memory address to R/W */
	int	si_cc;			/* Character count to R/W */
	struct	saif *si_sif;		/* net if. pointer (set by b_open) */
	char 	*si_devaddr;		/* Points to mapped in device */
	char	*si_dmaaddr;		/* Points to allocated DMA space */
};
#define SAIO_F_READ	0x01
#define SAIO_F_WRITE	0x02
#define SAIO_F_ALLOC	0x04
#define SAIO_F_FILE	0x08
#define	SAIO_F_EOF	0x10	/* EOF on device */
#define SAIO_F_AJAR	0x20	/* Descriptor "ajar" (stopped but not closed) */


/*
 * The table entry that describes a device.  It exists in the PROM; a
 * pointer to it is passed in MachMonBootParam.  It can be used to locate
 * PROM subroutines for opening, reading, and writing the device.
 *
 * When using this interface, only one device can be open at once.
 *
 * NOTE: I am not sure what arguments boot, open, close, and strategy take.
 * What is here is just translated verbatim from the sun monitor code.  We
 * should figure this out eventually if we need it.
 */
struct om_boottable {
	char	b_devname[2];		/* The name of the device */
	int	(*b_probe)(void);	/* probe() --> -1 or found controller
					   number */
	int	(*b_boot)(void);	/* boot(bp) --> -1 or start address */
	int	(*b_open)(struct saioreq *);/* open(iobp) --> -1 or 0 */
	int	(*b_close)(struct saioreq *);/* close(iobp) --> -1 or 0 */
	int	(*b_strategy)(struct saioreq *, int);/* strategy(iobp,rw) --> -1 or 0 */
	char	*b_desc;		/* Printable string describing dev */
	struct devinfo *b_devinfo;      /* info to configure device. */
};

/*
 * Structure set up by the boot command to pass arguments to the program that
 * is booted.
 */
struct om_bootparam {
	char	*argPtr[8];		/* String arguments */
	char	strings[100];		/* String table for string arguments */
	char	devName[2];		/* Device name */
	int	ctlrNum;		/* Controller number */
	int	unitNum;		/* Unit number */
	int	partNum;		/* Partition/file number */
	char	*fileName;		/* File name, points into strings */
	struct om_boottable *bootTable;	/* Points to table entry for device */
};

/*
 * Here is the structure of the vector table which is at the front of the boot
 * rom.  The functions defined in here are explained below.
 *
 * NOTE: This struct has references to the structures keybuf and globram which
 *       I have not translated.  If anyone needs to use these they should
 *       translate these structs into Sprite format.
 */
struct om_vector {
	char	*initSp;		/* Initial system stack ptr for hardware */
	int	(*startMon)(void);/* Initial PC for hardware */
	int	*diagberr;		/* Bus err handler for diags */

	/* Monitor and hardware revision and identification */
	struct om_bootparam **bootParam;/* Info for bootstrapped pgm */
 	u_long	*memorySize;		/* Usable memory in bytes */

	/* Single-character input and output */
	int	(*getChar)(void);	/* Get char from input source */
	void	(*putChar)(int);	/* Put char to output sink */
	int	(*mayGet)(void);	/* Maybe get char, or -1 */
	int	(*mayPut)(int);		/* Maybe put char, or -1 */
	u_char	*echo;			/* Should getchar echo? */
	u_char	*inSource;		/* Input source selector */
	u_char	*outSink;		/* Output sink selector */
#define	PROMDEV_KBD	0		/* input from keyboard */
#define	PROMDEV_SCREEN	0		/* output to screen */
#define	PROMDEV_TTYA	1		/* in/out to ttya */
#define	PROMDEV_TTYB	2		/* in/out to ttyb */

	/* Keyboard input (scanned by monitor nmi routine) */
	int	(*getKey)(void);	/* Get next key if one exists */
	int	(*initGetKey)(void);	/* Initialize get key */
	u_int	*translation;		/* Kbd translation selector */
	u_char	*keyBid;		/* Keyboard ID byte */
	int	*screen_x;		/* V2: Screen x pos (R/O) */
	int	*screen_y;		/* V2: Screen y pos (R/O) */
	struct keybuf	*keyBuf;	/* Up/down keycode buffer */

	/* Monitor revision level. */
	char	*monId;

	/* Frame buffer output and terminal emulation */
	int	(*fbWriteChar)(void);	/* Write a character to FB */
	int	*fbAddr;		/* Address of frame buffer */
	char	**font;			/* Font table for FB */
	void	(*fbWriteStr)(char *, int);
					/* Quickly write string to FB */

	/* Reboot interface routine -- resets and reboots system. */
	void	(*reBoot)(char *);	/* e.g. reBoot("xy()vmunix") */

	/* Line input and parsing */
	u_char	*lineBuf;		/* The line input buffer */
	u_char	**linePtr;		/* Cur pointer into linebuf */
	int	*lineSize;		/* length of line in linebuf */
	int	(*getLine)(void);	/* Get line from user */
	u_char	(*getNextChar)(void);	/* Get next char from linebuf */
	u_char	(*peekNextChar)(void);	/* Peek at next char */
	int	*fbThere;		/* =1 if frame buffer there */
	int	(*getNum)(void);	/* Grab hex num from line */

	/* Print formatted output to current output sink */
	int	(*printf)(void);	/* Similar to "Kernel printf" */
	int	(*printHex)(void);	/* Format N digits in hex */

	/* Led stuff */
	u_char	*leds;			/* RAM copy of LED register */
	int	(*setLeds)(void);	/* Sets LED's and RAM copy */

	/* Non-maskable interrupt  (nmi) information */
	int	(*nmiAddr)(void);	/* Addr for level 7 vector */
	void	(*abortEntry)(void);	/* Entry for keyboard abort */
	int	*nmiClock;		/* Counts up in msec */

	/* Frame buffer type: see <machine/fbio.h> */
	int	*fbType;

	/* Assorted other things */
	u_long	romvecVersion;		/* Version # of Romvec */
	struct globram *globRam;	/* monitor global variables */
	caddr_t	kbdZscc;		/* Addr of keyboard in use */

	int	*keyrInit;		/* ms before kbd repeat */
	u_char	*keyrTick; 		/* ms between repetitions */
	u_long	*memoryAvail;		/* V1: Main mem usable size */
	long	*resetAddr;		/* where to jump on a reset */
	long	*resetMap;		/* pgmap entry for resetaddr */
					/* Really struct pgmapent *  */

					/* Exit from user program */
	void	(*exitToMon)(void) __attribute__((__noreturn__));
	u_char	**memorybitmap;		/* V1: &{0 or &bits} */
					/* Set seg in any context */
	void	(*setcxsegmap)(int, caddr_t, int);
	void	(**vector_cmd)(u_long, char *);/* V2: Handler for 'v' cmd */
  	u_long	*ExpectedTrapSig;
  	u_long	*TrapVectorTable;
	int	dummy1z;
	int	dummy2z;
	int	dummy3z;
	int	dummy4z;
};

#define	romVectorPtr	((struct om_vector *)PROM_BASE)

#define mon_printf (romVectorPtr->printf)
#define mon_putchar (romVectorPtr->putChar)
#define mon_may_getchar (romVectorPtr->mayGet)
#define mon_exit_to_mon (romVectorPtr->exitToMon)
#define mon_reboot (romVectorPtr->exitToMon)
#define mon_panic(x) { mon_printf(x); mon_exit_to_mon();}

#define mon_setcxsegmap(context, va, sme) \
    romVectorPtr->setcxsegmap(context, va, sme)
#define romp (romVectorPtr)

/*
 * OLDMON_STARTVADDR and OLDMON_ENDVADDR denote the range of the damn monitor.
 *
 * supposedly you can steal pmegs within this range that do not contain
 * valid pages.
 */
#define OLDMON_STARTVADDR	0xFFD00000
#define OLDMON_ENDVADDR		0xFFF00000

/*
 * These describe the monitor's short segment which it basically uses to map
 * one stupid page that it uses for storage.  MONSHORTPAGE is the page,
 * and MONSHORTSEG is the segment that it is in.  If this sounds dumb to
 * you, it is.  I can change the pmeg, but not the virtual address.
 * Sun defines these with the high nibble set to 0xF.  I believe this was
 * for the monitor source which accesses this piece of memory with addressing
 * limitations or some such crud.  I haven't replicated this here, because
 * it is confusing, and serves no obvious purpose if you aren't the monitor.
 *
 */
#define MONSHORTPAGE	0x0FFFE000
#define MONSHORTSEG	0x0FFE0000



/*
 * Ethernet interface descriptor
 * First, set: saiop->si_devaddr, saiop->si_dmaaddr, etc.
 * Then:  saiop->si_boottab->b_open()  will set:
 *   saiop->si_sif;
 *   saiop->si_devdata;
 * The latter is the first arg to the following functions.
 * Note that the buffer must be in DVMA space...
 */
struct saif {
	/* transmit packet, returns zero on success. */
	int	(*sif_xmit)(void *devdata, char *buf, int len);
	/* wait for packet, zero if none arrived */
	int	(*sif_poll)(void *devdata, char *buf);
	/* reset interface, set addresses, etc. */
	int	(*sif_reset)(void *devdata, struct saioreq *sip);
	/* Later (sun4 only) proms have more stuff here. */
};


#if defined(SUN4)
void	oldmon_w_trace(u_long);
void	oldmon_w_cmd(u_long, char *);
#endif

#endif /* _MACHINE_OLDMON_H */
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: oldmon.h,v 1.7 2001/08/08 13:48:21 art Exp $	*/
d158 1
a158 1
	struct om_bootparam **bootParam;	/* Info for bootstrapped pgm */
d165 1
a165 1
	int	(*mayPut)(int);	/* Maybe put char, or -1 */
d176 1
a176 1
	int	(*initGetKey)(void);/* Initialize get key */
d187 1
a187 1
	int	(*fbWriteChar)(void);/* Write a character to FB */
d201 2
a202 2
	u_char	(*getNextChar)(void);/* Get next char from linebuf */
	u_char	(*peekNextChar)(void);/* Peek at next char */
d208 1
a208 1
	int	(*printHex)(void);/* Format N digits in hex */
d216 1
a216 1
	void	(*abortEntry)(void);/* Entry for keyboard abort */
d234 2
a235 1
	void	(*exitToMon)(void) __attribute__((__noreturn__));/* Exit from user program */
d237 2
a238 1
	void	(*setcxsegmap)		/* Set seg in any context */(int, caddr_t, int);
@


1.7
log
@__dead doesn't work on function pointers.
@
text
@d1 1
a1 1
/*	$OpenBSD: oldmon.h,v 1.6 2001/08/08 02:26:35 millert Exp $	*/
d119 1
a119 1
	int	(*b_probe) __P((void));	/* probe() --> -1 or found controller
d121 4
a124 7
	int	(*b_boot) __P((void));	/* boot(bp) --> -1 or start address */
	int	(*b_open)
		__P((struct saioreq *));/* open(iobp) --> -1 or 0 */
	int	(*b_close)
		__P((struct saioreq *));/* close(iobp) --> -1 or 0 */
	int	(*b_strategy)
		__P((struct saioreq *, int));/* strategy(iobp,rw) --> -1 or 0 */
d154 1
a154 1
	int	(*startMon) __P((void));/* Initial PC for hardware */
d162 4
a165 4
	int	(*getChar) __P((void));	/* Get char from input source */
	void	(*putChar) __P((int));	/* Put char to output sink */
	int	(*mayGet) __P((void));	/* Maybe get char, or -1 */
	int	(*mayPut) __P((int));	/* Maybe put char, or -1 */
d175 2
a176 2
	int	(*getKey) __P((void));	/* Get next key if one exists */
	int	(*initGetKey) __P((void));/* Initialize get key */
d187 1
a187 1
	int	(*fbWriteChar) __P((void));/* Write a character to FB */
d190 1
a190 1
	void	(*fbWriteStr) __P((char *, int));
d194 1
a194 1
	void	(*reBoot) __P((char *));	/* e.g. reBoot("xy()vmunix") */
d200 3
a202 3
	int	(*getLine) __P((void));	/* Get line from user */
	u_char	(*getNextChar) __P((void));/* Get next char from linebuf */
	u_char	(*peekNextChar) __P((void));/* Peek at next char */
d204 1
a204 1
	int	(*getNum) __P((void));	/* Grab hex num from line */
d207 2
a208 2
	int	(*printf) __P((void));	/* Similar to "Kernel printf" */
	int	(*printHex) __P((void));/* Format N digits in hex */
d212 1
a212 1
	int	(*setLeds) __P((void));	/* Sets LED's and RAM copy */
d215 2
a216 2
	int	(*nmiAddr) __P((void));	/* Addr for level 7 vector */
	void	(*abortEntry) __P((void));/* Entry for keyboard abort */
d234 1
a234 1
	void	(*exitToMon) __P((void)) __attribute__((__noreturn__));/* Exit from user program */
d236 2
a237 3
	void	(*setcxsegmap)		/* Set seg in any context */
		    __P((int, caddr_t, int));
	void	(**vector_cmd) __P((u_long, char *));/* V2: Handler for 'v' cmd */
d305 2
a306 2
void	oldmon_w_trace __P((u_long));
void	oldmon_w_cmd __P((u_long, char *));
@


1.7.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: oldmon.h,v 1.7 2001/08/08 13:48:21 art Exp $	*/
d119 1
a119 1
	int	(*b_probe)(void);	/* probe() --> -1 or found controller
d121 7
a127 4
	int	(*b_boot)(void);	/* boot(bp) --> -1 or start address */
	int	(*b_open)(struct saioreq *);/* open(iobp) --> -1 or 0 */
	int	(*b_close)(struct saioreq *);/* close(iobp) --> -1 or 0 */
	int	(*b_strategy)(struct saioreq *, int);/* strategy(iobp,rw) --> -1 or 0 */
d157 1
a157 1
	int	(*startMon)(void);/* Initial PC for hardware */
d161 1
a161 1
	struct om_bootparam **bootParam;/* Info for bootstrapped pgm */
d165 4
a168 4
	int	(*getChar)(void);	/* Get char from input source */
	void	(*putChar)(int);	/* Put char to output sink */
	int	(*mayGet)(void);	/* Maybe get char, or -1 */
	int	(*mayPut)(int);		/* Maybe put char, or -1 */
d178 2
a179 2
	int	(*getKey)(void);	/* Get next key if one exists */
	int	(*initGetKey)(void);	/* Initialize get key */
d190 1
a190 1
	int	(*fbWriteChar)(void);	/* Write a character to FB */
d193 1
a193 1
	void	(*fbWriteStr)(char *, int);
d197 1
a197 1
	void	(*reBoot)(char *);	/* e.g. reBoot("xy()vmunix") */
d203 3
a205 3
	int	(*getLine)(void);	/* Get line from user */
	u_char	(*getNextChar)(void);	/* Get next char from linebuf */
	u_char	(*peekNextChar)(void);	/* Peek at next char */
d207 1
a207 1
	int	(*getNum)(void);	/* Grab hex num from line */
d210 2
a211 2
	int	(*printf)(void);	/* Similar to "Kernel printf" */
	int	(*printHex)(void);	/* Format N digits in hex */
d215 1
a215 1
	int	(*setLeds)(void);	/* Sets LED's and RAM copy */
d218 2
a219 2
	int	(*nmiAddr)(void);	/* Addr for level 7 vector */
	void	(*abortEntry)(void);	/* Entry for keyboard abort */
d237 1
a237 2
					/* Exit from user program */
	void	(*exitToMon)(void) __attribute__((__noreturn__));
d239 3
a241 3
					/* Set seg in any context */
	void	(*setcxsegmap)(int, caddr_t, int);
	void	(**vector_cmd)(u_long, char *);/* V2: Handler for 'v' cmd */
d309 2
a310 2
void	oldmon_w_trace(u_long);
void	oldmon_w_cmd(u_long, char *);
@


1.6
log
@nuke __attribute__((__noreturn__)) when used in conjunction with __dead
@
text
@d1 1
a1 1
/*	$OpenBSD: oldmon.h,v 1.5 2000/12/06 17:19:00 deraadt Exp $	*/
d237 1
a237 1
	__dead void (*exitToMon) __P((void)); /* Exit from user program */
@


1.5
log
@use __x__ formats for __attribute__ arguments; guenther@@gac.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: oldmon.h,v 1.4 1997/08/08 08:26:32 downsj Exp $	*/
d237 1
a237 2
	__dead void (*exitToMon)
	    __P((void)) __attribute__((__noreturn__));/* Exit from user program */
@


1.4
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d238 1
a238 1
	    __P((void)) __attribute__((noreturn));/* Exit from user program */
@


1.4.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: oldmon.h,v 1.5 2000/12/06 17:19:00 deraadt Exp $	*/
d238 1
a238 1
	    __P((void)) __attribute__((__noreturn__));/* Exit from user program */
@


1.4.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: oldmon.h,v 1.4.12.1 2001/05/14 21:37:12 niklas Exp $	*/
d237 2
a238 1
	void	(*exitToMon) __P((void)) __attribute__((__noreturn__));/* Exit from user program */
@


1.4.12.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d119 1
a119 1
	int	(*b_probe)(void);	/* probe() --> -1 or found controller
d121 7
a127 4
	int	(*b_boot)(void);	/* boot(bp) --> -1 or start address */
	int	(*b_open)(struct saioreq *);/* open(iobp) --> -1 or 0 */
	int	(*b_close)(struct saioreq *);/* close(iobp) --> -1 or 0 */
	int	(*b_strategy)(struct saioreq *, int);/* strategy(iobp,rw) --> -1 or 0 */
d157 1
a157 1
	int	(*startMon)(void);/* Initial PC for hardware */
d161 1
a161 1
	struct om_bootparam **bootParam;/* Info for bootstrapped pgm */
d165 4
a168 4
	int	(*getChar)(void);	/* Get char from input source */
	void	(*putChar)(int);	/* Put char to output sink */
	int	(*mayGet)(void);	/* Maybe get char, or -1 */
	int	(*mayPut)(int);		/* Maybe put char, or -1 */
d178 2
a179 2
	int	(*getKey)(void);	/* Get next key if one exists */
	int	(*initGetKey)(void);	/* Initialize get key */
d190 1
a190 1
	int	(*fbWriteChar)(void);	/* Write a character to FB */
d193 1
a193 1
	void	(*fbWriteStr)(char *, int);
d197 1
a197 1
	void	(*reBoot)(char *);	/* e.g. reBoot("xy()vmunix") */
d203 3
a205 3
	int	(*getLine)(void);	/* Get line from user */
	u_char	(*getNextChar)(void);	/* Get next char from linebuf */
	u_char	(*peekNextChar)(void);	/* Peek at next char */
d207 1
a207 1
	int	(*getNum)(void);	/* Grab hex num from line */
d210 2
a211 2
	int	(*printf)(void);	/* Similar to "Kernel printf" */
	int	(*printHex)(void);	/* Format N digits in hex */
d215 1
a215 1
	int	(*setLeds)(void);	/* Sets LED's and RAM copy */
d218 2
a219 2
	int	(*nmiAddr)(void);	/* Addr for level 7 vector */
	void	(*abortEntry)(void);	/* Entry for keyboard abort */
d237 1
a237 2
					/* Exit from user program */
	void	(*exitToMon)(void) __attribute__((__noreturn__));
d239 3
a241 3
					/* Set seg in any context */
	void	(*setcxsegmap)(int, caddr_t, int);
	void	(**vector_cmd)(u_long, char *);/* V2: Handler for 'v' cmd */
d309 2
a310 2
void	oldmon_w_trace(u_long);
void	oldmon_w_cmd(u_long, char *);
@


1.3
log
@netbsd port, now we merge our changes back in
@
text
@d1 1
@


1.2
log
@wrap function protos in __P()
@
text
@d1 1
a1 1
/*	$NetBSD: oldmon.h,v 1.5 1995/09/03 21:36:06 pk Exp $ */
d77 29
d112 2
a113 2
 * NOTE: I am not sure what arguments boot, open, close, and strategy take.  
 * What is here is just translated verbatim from the sun monitor code.  We 
d118 1
a118 1
	int	(*b_probe)();		/* probe() --> -1 or found controller 
d120 7
a126 4
	int	(*b_boot)();		/* boot(bp) --> -1 or start address */
	int	(*b_open)();		/* open(iobp) --> -1 or 0 */
	int	(*b_close)();		/* close(iobp) --> -1 or 0 */
	int	(*b_strategy)();	/* strategy(iobp,rw) --> -1 or 0 */
d156 1
a156 1
	int	(*startMon)();		/* Initial PC for hardware */
d177 2
a178 2
	int	(*getKey)();		/* Get next key if one exists */
	int	(*initGetKey)();	/* Initialize get key */
d189 1
a189 1
	int	(*fbWriteChar)();	/* Write a character to FB */
d192 2
a193 1
	void	(*fbWriteStr) __P((char *, int)); /* Quickly write string to FB */
d202 3
a204 3
	int	(*getLine)();		/* Get line from user */
	u_char	(*getNextChar)();	/* Get next char from linebuf */
	u_char	(*peekNextChar)();	/* Peek at next char */
d206 1
a206 1
	int	(*getNum)();		/* Grab hex num from line */
d209 2
a210 2
	int	(*printf)();		/* Similar to "Kernel printf" */
	int	(*printHex)();		/* Format N digits in hex */
d214 1
a214 1
	int	(*setLeds)();		/* Sets LED's and RAM copy */
d216 3
a218 3
	/* Non-maskable interrupt  (nmi) information */ 
	int	(*nmiAddr)();		/* Addr for level 7 vector */
	void	(*abortEntry) __P((void));	/* Entry for keyboard abort */
d225 1
a225 1
	u_long	romvecVersion;		/* Version # of Romvec */ 
d236 2
a237 1
	__dead void (*exitToMon) __P((void));	/* Exit from user program */
d239 3
a241 2
	void	(*setcxsegmap)();	/* Set seg in any context */
	void	(**vector_cmd)();	/* V2: Handler for 'v' cmd */
d265 1
a265 1
 * 
d267 1
a267 1
 * valid pages. 
a285 27
/*
 * A "stand alone I/O request".
 * This is passed as the main argument to the PROM I/O routines
 * in the `om_boottable' structure.
 */
struct saioreq {
	char	si_flgs;
	struct om_boottable *si_boottab;/* Points to boottab entry if any */
	char	*si_devdata;		/* Device-specific data pointer */
	int	si_ctlr;		/* Controller number or address */
	int	si_unit;		/* Unit number within controller */
	long	si_boff;		/* Partition number within unit */
	long	si_cyloff;
	long	si_offset;
	long	si_bn;			/* Block number to R/W */
	char	*si_ma;			/* Memory address to R/W */
	int	si_cc;			/* Character count to R/W */
	struct	saif *si_sif;		/* net if. pointer (set by b_open) */
	char 	*si_devaddr;		/* Points to mapped in device */
	char	*si_dmaaddr;		/* Points to allocated DMA space */
};
#define SAIO_F_READ	0x01
#define SAIO_F_WRITE	0x02
#define SAIO_F_ALLOC	0x04
#define SAIO_F_FILE	0x08
#define	SAIO_F_EOF	0x10	/* EOF on device */
#define SAIO_F_AJAR	0x20	/* Descriptor "ajar" (stopped but not closed) */
d299 1
a299 1
	int	(*sif_xmit) __P((void *devdata, char *buf, int len));
d301 1
a301 1
	int	(*sif_poll) __P((void *devdata, char *buf));
d303 1
a303 1
	int	(*sif_reset) __P((void *devdata, struct saioreq *sip));
d306 8
a313 1
#endif /* MACHINE_OLDMON_H */
@


1.1
log
@Initial revision
@
text
@d132 4
a135 4
	int	(*getChar)(void);	/* Get char from input source */
	void	(*putChar)(int);	/* Put char to output sink */
	int	(*mayGet)(void);	/* Maybe get char, or -1 */
	int	(*mayPut)(int);		/* Maybe put char, or -1 */
d160 1
a160 1
	void	(*fbWriteStr)(char *, int); /* Quickly write string to FB */
d163 1
a163 1
	void	(*reBoot)(char *);	/* e.g. reBoot("xy()vmunix") */
d185 1
a185 1
	void	(*abortEntry)(void);	/* Entry for keyboard abort */
d203 1
a203 1
	__dead void (*exitToMon)(void);	/* Exit from user program */
d291 1
a291 1
	int	(*sif_xmit)(void *devdata, char *buf, int len);
d293 1
a293 1
	int	(*sif_poll)(void *devdata, char *buf);
d295 1
a295 1
	int	(*sif_reset)(void *devdata, struct saioreq *sip);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
