head	1.29;
access;
symbols
	OPENBSD_6_0:1.29.0.2
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.28.0.6
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.8
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.27.0.6
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.25.0.16
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.14
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.12
	OPENBSD_5_0:1.25.0.10
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.8
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.6
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.4
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.23.0.8
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.6
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.4
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.2
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.21.0.4
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.20.0.4
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.15
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.3.0.14
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.12
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.10
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2016.06.20.11.02.33;	author dlg;	state Exp;
branches;
next	1.28;
commitid	9ZcVv11nnmonpmTs;

1.28
date	2014.03.29.18.09.30;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2013.05.17.19.38.52;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2013.05.16.06.38.13;	author ratchov;	state Exp;
branches;
next	1.25;

1.25
date	2009.04.10.20.53.54;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2009.03.15.19.40.40;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.16.19.37.06;	author thib;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.08.07.23.18;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.12.03.14.37;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.19.15.29.48;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.13.21.49.20;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.02.23.27.54;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.12.11.06.56.21;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2002.11.11.05.04.44;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.12.10.44.04;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.23.14.00.38;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.15.23.17.54;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2002.04.30.01.03.04;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.29.07.35.22;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.28.03.51.19;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.43;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.19.08.58.05;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.12.07.10.38.11;	author art;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.06.24.17.05.42;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.07.11.49.39;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.06.15.25.04;	author ho;	state Exp;
branches;
next	1.3;

1.3
date	97.08.08.08.26.41;	author downsj;	state Exp;
branches
	1.3.12.1;
next	1.2;

1.2
date	96.08.11.05.34.55;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.44;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.44;	author deraadt;	state Exp;
branches;
next	;

1.3.12.1
date	2001.05.14.21.37.13;	author niklas;	state Exp;
branches;
next	1.3.12.2;

1.3.12.2
date	2001.07.04.10.23.33;	author niklas;	state Exp;
branches;
next	1.3.12.3;

1.3.12.3
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.3.12.4;

1.3.12.4
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.3.12.5;

1.3.12.5
date	2003.06.07.11.14.43;	author ho;	state Exp;
branches;
next	1.3.12.6;

1.3.12.6
date	2004.06.07.18.46.20;	author deraadt;	state Exp;
branches;
next	;

1.7.2.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.10.29.00.28.10;	author art;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.29
log
@rework the splfoo implementation so it can provide splraise.

sparc was like sparc64 (or more likely sparc64 was like sparc) in
that the spl api was build with macros that created inline functions
that the spl were implemented as. this rework provides an splraise
that the splfoo macros are defined to.

because the code sequences for spl0, splraise, and splx are relatively
long, ive turned them into functions.

tested by (and thanks go to) miod@@ tobiasu@@
@
text
@/*	$OpenBSD: psl.h,v 1.28 2014/03/29 18:09:30 guenther Exp $	*/
/*	$NetBSD: psl.h,v 1.12 1997/03/10 21:49:11 pk Exp $ */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)psl.h	8.1 (Berkeley) 6/11/93
 */

#ifndef PSR_IMPL

/*
 * SPARC Process Status Register (in psl.h for hysterical raisins).
 *
 * The picture in the Sun manuals looks like this:
 *	                                     1 1
 *	 31   28 27   24 23   20 19       14 3 2 11    8 7 6 5 4       0
 *	+-------+-------+-------+-----------+-+-+-------+-+-+-+---------+
 *	|  impl |  ver  |  icc  |  reserved |E|E|  pil  |S|P|E|   CWP   |
 *	|       |       |n z v c|           |C|F|       | |S|T|         |
 *	+-------+-------+-------+-----------+-+-+-------+-+-+-+---------+
 */

#define	PSR_IMPL	0xf0000000	/* implementation */
#define	PSR_VER		0x0f000000	/* version */
#define	PSR_ICC		0x00f00000	/* integer condition codes */
#define	PSR_N		0x00800000	/* negative */
#define	PSR_Z		0x00400000	/* zero */
#define	PSR_O		0x00200000	/* overflow */
#define	PSR_C		0x00100000	/* carry */
#define	PSR_EC		0x00002000	/* coprocessor enable */
#define	PSR_EF		0x00001000	/* FP enable */
#define	PSR_PIL		0x00000f00	/* interrupt level */
#define	PSR_S		0x00000080	/* supervisor (kernel) mode */
#define	PSR_PS		0x00000040	/* previous supervisor mode (traps) */
#define	PSR_ET		0x00000020	/* trap enable */
#define	PSR_CWP		0x0000001f	/* current window pointer */

#define	PSR_BITS "\20\16EC\15EF\10S\7PS\6ET"

/*
 * Various interrupt levels.
 */
#define IPL_NONE	0
#define IPL_SOFTINT	1
#define IPL_SOFTCLOCK	1		/* softclock() interrupts */
#define IPL_SOFTNET	1		/* soft network interrupts */
#define IPL_AUSOFT	4		/* audio soft interrupts */
#define IPL_FDSOFT	4		/* floppy soft interrupts */
#define IPL_BIO		5		/* block devices are at 5 and below */
#define IPL_TTY		6		/* MD tty soft interrupts */
#define	IPL_SOFTTTY	IPL_TTY
#define IPL_NET		7		/* network hardware at 7 or below */
#define IPL_VM		7		/* max(BIO, NET, TTY) */
#define	IPL_FB		9		/* framebuffer interrupts */
#define	IPL_CLOCK	10		/* hardclock() */
#define IPL_FD		11		/* hard floppy interrupts. */
#define IPL_ZS		12		/* zs interrupts */
/*
 * XXX - this is called AUHARD instead of AUDIO because of some confusion
 * with how MI audio code handles this. Stay tuned for a change in the future
 */
#define IPL_AUHARD	13		/* hard audio interrupts */
#define IPL_AUDIO	IPL_AUHARD
#define IPL_STATCLOCK	14		/* statclock() */
#define IPL_SCHED	IPL_STATCLOCK
#define IPL_HIGH	15		/* splhigh() */

#define	IPL_MPSAFE	0	/* no "mpsafe" interrupts */

#if defined(_KERNEL) && !defined(_LOCORE)

static __inline int getpsr(void);
static __inline void setpsr(int);
static __inline int getmid(void);

/*
 * GCC pseudo-functions for manipulating PSR (primarily PIL field).
 */
static __inline int
getpsr()
{
	int psr;

	__asm volatile("rd %%psr,%0" : "=r" (psr));
	return (psr);
}

static __inline int
getmid()
{
	int mid;

	__asm volatile("rd %%tbr,%0" : "=r" (mid));
	return ((mid >> 20) & 0x3);
}

static __inline void
setpsr(newpsr)
	int newpsr;
{
	__asm volatile("wr %0,0,%%psr" : : "r" (newpsr));
	__asm volatile("nop");
	__asm volatile("nop");
	__asm volatile("nop");
}

#ifdef DIAGNOSTIC
/*
 * Although this function is implemented in MI code, it must be in this MD
 * header because we don't want this header to include MI includes.
 */
void splassert_fail(int, int, const char *);
extern int splassert_ctl;
void splassert_check(int, const char *);
#define splassert(__wantipl) do {			\
	if (splassert_ctl > 0) {			\
		splassert_check(__wantipl, __func__);	\
	}						\
} while (0)
#define splsoftassert(wantipl) splassert(wantipl)
#else
#define splassert(wantipl)	do { /* nada */ } while (0)
#define splsoftassert(wantipl)	do { /* nada */ } while (0)
#endif

int	spl0(void);
int	splraise(int);
int	splhigh(void);
void	splx(int);

#define splsoftint()	splraise(IPL_SOFTINT)
#define splsoftclock()	splraise(IPL_SOFTCLOCK)
#define splsoftnet()	splraise(IPL_SOFTNET)
#define splausoft()	splraise(IPL_AUSOFT)
#define splfdsoft()	splraise(IPL_FDSOFT)
#define splbio()	splraise(IPL_BIO)
#define splnet()	splraise(IPL_NET)
#define spltty()	splraise(IPL_TTY)
#define splvm()		splraise(IPL_VM)
#define splclock()	splraise(IPL_CLOCK)
#define splfd()		splraise(IPL_FD)
#define splzs()		splraise(IPL_ZS)
#define splaudio()	splraise(IPL_AUDIO)
#define splsched()	splraise(IPL_SCHED)
#define splstatclock()	splraise(IPL_STATCLOCK)

#endif /* KERNEL && !_LOCORE */

#endif /* PSR_IMPL */
@


1.28
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.27 2013/05/17 19:38:52 kettenis Exp $	*/
a108 3
static __inline int spl0(void);
static __inline int splhigh(void);
static __inline void splx(int);
a141 22
static __inline int
spl0()
{
	int psr, oldipl;

	/*
	 * wrpsr xors two values: we choose old psr and old ipl here,
	 * which gives us the same value as the old psr but with all
	 * the old PIL bits turned off.
	 */
	__asm volatile("rd %%psr,%0" : "=r" (psr));
	oldipl = psr & PSR_PIL;
	__asm volatile("wr %0,%1,%%psr" : : "r" (psr), "r" (oldipl));

	/*
	 * Three instructions must execute before we can depend
	 * on the bits to be changed.
	 */
	__asm volatile("nop; nop; nop");
	return (oldipl);
}

d161 20
a180 64
/*
 * PIL 1 through 14 can use this macro.
 * (spl0 and splhigh are special since they put all 0s or all 1s
 * into the ipl field.)
 */
#define	SPL(name, newipl) \
static __inline int name(void); \
static __inline int name() \
{ \
	int psr, oldipl; \
	__asm volatile("rd %%psr,%0" : "=r" (psr)); \
	oldipl = psr & PSR_PIL; \
	psr &= ~oldipl; \
	__asm volatile("wr %0,%1,%%psr" : : \
	    "r" (psr), "n" ((newipl) << 8)); \
	__asm volatile("nop; nop; nop"); \
	__asm volatile("":::"memory");	/* protect from reordering */ \
	return (oldipl); \
}
/* A non-priority-decreasing version of SPL */
#define	SPLHOLD(name, newipl) \
static __inline int name(void); \
static __inline int name() \
{ \
	int psr, oldipl; \
	__asm volatile("rd %%psr,%0" : "=r" (psr)); \
	oldipl = psr & PSR_PIL; \
	if ((newipl << 8) <= oldipl) \
		return oldipl; \
	psr &= ~oldipl; \
	__asm volatile("wr %0,%1,%%psr" : : \
	    "r" (psr), "n" ((newipl) << 8)); \
	__asm volatile("nop; nop; nop"); \
	__asm volatile("":::"memory");	/* protect from reordering */ \
	return (oldipl); \
}

SPLHOLD(splsoftint, IPL_SOFTINT)
#define	splsoftclock		splsoftint
#define	splsoftnet		splsoftint
SPLHOLD(splausoft, IPL_AUSOFT)
SPLHOLD(splfdsoft, IPL_FDSOFT)
SPLHOLD(splbio, IPL_BIO)
SPLHOLD(splnet, IPL_NET)
SPLHOLD(spltty, IPL_TTY)
SPLHOLD(splvm, IPL_VM)
SPLHOLD(splclock, IPL_CLOCK)
SPLHOLD(splfd, IPL_FD)
SPLHOLD(splzs, IPL_ZS)
SPLHOLD(splaudio, IPL_AUHARD)
SPLHOLD(splsched, IPL_SCHED)
SPLHOLD(splstatclock, IPL_STATCLOCK)

static __inline int splhigh()
{
	int psr, oldipl;

	__asm volatile("rd %%psr,%0" : "=r" (psr));
	__asm volatile("wr %0,0,%%psr" : : "r" (psr | PSR_PIL));
	__asm volatile("and %1,%2,%0; nop; nop" : "=r" (oldipl) : \
	    "r" (psr), "n" (PSR_PIL));
	__asm volatile("":::"memory");	/* protect from reordering */
	return (oldipl);
}
a181 12
/* splx does not have a return value */
static __inline void splx(newipl)
	int newipl;
{
	int psr;

	__asm volatile("":::"memory");	/* protect from reordering */
	__asm volatile("rd %%psr,%0" : "=r" (psr));
	__asm volatile("wr %0,%1,%%psr" : : \
	    "r" (psr & ~PSR_PIL), "rn" (newipl));
	__asm volatile("nop; nop; nop");
}
@


1.27
log
@Add a dummy IPL_MPSAFE definition.

ok miod@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.26 2013/05/16 06:38:13 ratchov Exp $	*/
d122 1
a122 1
	__asm __volatile("rd %%psr,%0" : "=r" (psr));
d131 1
a131 1
	__asm __volatile("rd %%tbr,%0" : "=r" (mid));
d139 4
a142 4
	__asm __volatile("wr %0,0,%%psr" : : "r" (newpsr));
	__asm __volatile("nop");
	__asm __volatile("nop");
	__asm __volatile("nop");
d155 1
a155 1
	__asm __volatile("rd %%psr,%0" : "=r" (psr));
d157 1
a157 1
	__asm __volatile("wr %0,%1,%%psr" : : "r" (psr), "r" (oldipl));
d163 1
a163 1
	__asm __volatile("nop; nop; nop");
d196 1
a196 1
	__asm __volatile("rd %%psr,%0" : "=r" (psr)); \
d199 1
a199 1
	__asm __volatile("wr %0,%1,%%psr" : : \
d201 2
a202 2
	__asm __volatile("nop; nop; nop"); \
	__asm __volatile("":::"memory");	/* protect from reordering */ \
d211 1
a211 1
	__asm __volatile("rd %%psr,%0" : "=r" (psr)); \
d216 1
a216 1
	__asm __volatile("wr %0,%1,%%psr" : : \
d218 2
a219 2
	__asm __volatile("nop; nop; nop"); \
	__asm __volatile("":::"memory");	/* protect from reordering */ \
d243 3
a245 3
	__asm __volatile("rd %%psr,%0" : "=r" (psr));
	__asm __volatile("wr %0,0,%%psr" : : "r" (psr | PSR_PIL));
	__asm __volatile("and %1,%2,%0; nop; nop" : "=r" (oldipl) : \
d247 1
a247 1
	__asm __volatile("":::"memory");	/* protect from reordering */
d257 3
a259 3
	__asm __volatile("":::"memory");	/* protect from reordering */
	__asm __volatile("rd %%psr,%0" : "=r" (psr));
	__asm __volatile("wr %0,%1,%%psr" : : \
d261 1
a261 1
	__asm __volatile("nop; nop; nop");
@


1.26
log
@Add missing IPL_AUDIO macro, needed by dev/audio.c

ok miod and kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.25 2009/04/10 20:53:54 miod Exp $	*/
d102 2
@


1.25
log
@generic soft interrupts support for sparc. Soft interrupt handlers are now
kept in a separate intrhand array, with their own enable bits so that
soft interrupts sharing the same level only get invoked if really triggered.
Inspired by NetBSD with significant changes.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.24 2009/03/15 19:40:40 miod Exp $	*/
d98 1
@


1.24
log
@Introduce splsoftassert(), similar to splassert() but for soft interrupt
levels. This will allow for platforms where soft interrupt levels do not
map to real hardware interrupt levels to have soft ipl values overlapping
hard ipl values without breaking spl asserts.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.23 2007/05/16 19:37:06 thib Exp $	*/
d80 2
a81 2
#define IPL_SOFTCLOCK	IPL_SOFTINT	/* softclock() interrupts */
#define IPL_SOFTNET	IPL_SOFTINT	/* soft network interrupts */
d85 2
a86 1
#define IPL_TTY		6		/* tty soft interrupts */
@


1.23
log
@splassert_ctl defaults to 1 now, so dont wrap the checks for
splassert_ctl > 0 in __predict_false().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.22 2007/05/08 07:23:18 art Exp $	*/
d176 1
d178 2
a179 1
#define splassert(wantipl) do { /* nada */ } while (0)
@


1.22
log
@Switch sparc to __HAVE_CPUINFO.

miod@@ tested (since I hacked it up blindly) and ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.21 2006/03/12 03:14:37 brad Exp $	*/
d172 1
a172 1
	if (__predict_false(splassert_ctl > 0)) {	\
@


1.21
log
@remove splimp.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.20 2005/04/19 15:29:48 mickey Exp $	*/
d98 1
d230 1
@


1.20
log
@nothing uses spllowersoftclock() anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.19 2004/06/13 21:49:20 niklas Exp $	*/
a224 2
/* XXX - the following two should die. */
#define splimp splvm
@


1.19
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a218 1
SPL(spllowersoftclock, IPL_SOFTCLOCK)
@


1.18
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.17 2002/12/11 06:56:21 art Exp $	*/
d98 1
@


1.17
log
@Added paranoia to make sure that gcc doesn't reorder spl* inlines.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.16 2002/11/11 05:04:44 miod Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.16
log
@Various little pmap changes:
- get rid of splpmap, use splvm everywhere
- harmonize some 4_4c routines to wake them easier to diff against 4m
- fix an spl botch in can't happen situations on 4_4c
- fix pmap_stas.ps_npg_prot_all on 4m in case someone cares
- slightly better pmap_kenter_pa and pmap_kremove on 4_4c

art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.15 2002/08/12 10:44:04 miod Exp $	*/
d198 1
d215 1
d245 1
d255 1
@


1.15
log
@Convert sparc console code from rcons and pseudo-devices to rasops and wscons.
For most framebuffers it is faster.

Other changes include:
o 24 bit support in tcx(4) for the S24 framebuffer
o accelerated cgsix(4) text console
o new cgtwelve(4) driver for the GS framebuffer
o improved serial driver code
o better keyboard support

The following framebuffers have not been tested but should work: cgfour,
cgeight and cgfourteen

These changes will require XF4 changes, to use Xwsfb instead of Xsun*, to be
commited later today.

Most of the work by me during the LSM and the week after, with code borrowed
from jason@@, NetBSD (new serial code), and feedback from mickey@@. Work on
pnozz(4) done by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.14 2002/07/23 14:00:38 art Exp $	*/
a228 1
#define splpmap splvm
@


1.14
log
@Define IPL_NONE
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.13 2002/05/15 23:17:54 art Exp $	*/
d92 1
@


1.13
log
@Implement splassert() for sparc - a tool for finding problems related to
spl handling (already found 3 problems).

Man page in a few seconds.
deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.12 2002/04/30 01:03:04 art Exp $	*/
d82 1
@


1.12
log
@dmesg logs show that many NICs run at prio 7. Bump IPL_NET to 7.
deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.11 2002/04/29 07:35:22 miod Exp $	*/
a109 3
/* SPL asserts */
#define	splassert(wantipl)	/* nothing */

d113 2
a114 1
static __inline int getpsr()
d122 2
a123 1
static __inline int getmid()
d131 2
a132 1
static __inline void setpsr(newpsr)
d141 2
a142 1
static __inline int spl0()
d163 17
d187 1
a187 1
 static __inline int name() \
@


1.11
log
@Define placeholders for art's splassert() debugging stuff on all arches.
Currently as no-ops everywhere.

ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.10 2002/04/28 03:51:19 art Exp $	*/
a87 1
#define IPL_NET		6		/* network hardware at 6 or below */
d89 1
@


1.10
log
@Rename all PIL_* constants to IPL_* to match other archs and make them
usable in MD code in the future.
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.9 2002/03/14 01:26:43 millert Exp $	*/
d109 3
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.8 2001/12/19 08:58:05 art Exp $	*/
d79 21
a99 1
#define	PIL_CLOCK	10
d166 1
a166 1
static __inline int name() \
d194 1
a194 1
SPLHOLD(splsoftint, 1)
d197 15
a211 47

SPL(spllowersoftclock, 1)

/* audio software interrupts are at software level 4 */
#define	PIL_AUSOFT	4
SPLHOLD(splausoft, PIL_AUSOFT)

/* floppy software interrupts are at software level 4 too */
#define PIL_FDSOFT	4
SPLHOLD(splfdsoft, PIL_FDSOFT)

/* Block devices */
#define PIL_BIO 5
SPLHOLD(splbio, PIL_BIO)

/* network hardware interrupts are at level 6 */
#define	PIL_NET	6
SPLHOLD(splnet, PIL_NET)

/* tty input runs at software level 6 */
#define	PIL_TTY	6
SPLHOLD(spltty, PIL_TTY)

/*
 * Memory allocation (must be as high as highest network, tty, or disk device)
 */
SPLHOLD(splimp, 7)
SPLHOLD(splvm, 7)

/*
 * remove.
 */
SPLHOLD(splpmap, 7)

SPLHOLD(splclock, PIL_CLOCK)

/* fd hardware interrupts are at level 11 */
SPLHOLD(splfd, 11)

/* zs hardware interrupts are at level 12 */
SPLHOLD(splzs, 12)

/* audio hardware interrupts are at level 13 */
SPLHOLD(splaudio, 13)

/* second sparc timer interrupts at level 14 */
SPLHOLD(splstatclock, 14)
@


1.8
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.6 2001/06/24 17:05:42 miod Exp $	*/
d83 6
a88 6
static __inline int getpsr __P((void));
static __inline void setpsr __P((int));
static __inline int spl0 __P((void));
static __inline int splhigh __P((void));
static __inline void splx __P((int));
static __inline int getmid __P((void));
d145 1
a145 1
static __inline int name __P((void)); \
d159 1
a159 1
static __inline int name __P((void)); \
@


1.7
log
@splpmap -> splvm
@
text
@d206 5
@


1.7.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.7 2001/12/07 10:38:11 art Exp $	*/
d79 1
a79 21
/*
 * Various interrupt levels.
 */
#define IPL_SOFTINT	1
#define IPL_SOFTCLOCK	IPL_SOFTINT	/* softclock() interrupts */
#define IPL_SOFTNET	IPL_SOFTINT	/* soft network interrupts */
#define IPL_AUSOFT	4		/* audio soft interrupts */
#define IPL_FDSOFT	4		/* floppy soft interrupts */
#define IPL_BIO		5		/* block devices are at 5 and below */
#define IPL_TTY		6		/* tty soft interrupts */
#define IPL_NET		7		/* network hardware at 7 or below */
#define IPL_VM		7		/* max(BIO, NET, TTY) */
#define	IPL_CLOCK	10		/* hardclock() */
#define IPL_FD		11		/* hard floppy interrupts. */
#define IPL_ZS		12		/* zs interrupts */
/*
 * XXX - this is called AUHARD instead of AUDIO because of some confusion
 * with how MI audio code handles this. Stay tuned for a change in the future
 */
#define IPL_AUHARD	13		/* hard audio interrupts */
#define IPL_STATCLOCK	14		/* statclock() */
d83 6
a88 6
static __inline int getpsr(void);
static __inline void setpsr(int);
static __inline int spl0(void);
static __inline int splhigh(void);
static __inline void splx(int);
static __inline int getmid(void);
d93 1
a93 2
static __inline int
getpsr()
d101 1
a101 2
static __inline int
getmid()
d109 1
a109 2
static __inline void
setpsr(newpsr)
d118 1
a118 2
static __inline int
spl0()
a138 17
#ifdef DIAGNOSTIC
/*
 * Although this function is implemented in MI code, it must be in this MD
 * header because we don't want this header to include MI includes.
 */
void splassert_fail(int, int, const char *);
extern int splassert_ctl;
void splassert_check(int, const char *);
#define splassert(__wantipl) do {			\
	if (__predict_false(splassert_ctl > 0)) {	\
		splassert_check(__wantipl, __func__);	\
	}						\
} while (0)
#else
#define splassert(wantipl) do { /* nada */ } while (0)
#endif

d145 1
a145 1
static __inline int name(void); \
d159 1
a159 1
static __inline int name(void); \
d174 1
a174 1
SPLHOLD(splsoftint, IPL_SOFTINT)
d177 42
a218 15
SPL(spllowersoftclock, IPL_SOFTCLOCK)
SPLHOLD(splausoft, IPL_AUSOFT)
SPLHOLD(splfdsoft, IPL_FDSOFT)
SPLHOLD(splbio, IPL_BIO)
SPLHOLD(splnet, IPL_NET)
SPLHOLD(spltty, IPL_TTY)
SPLHOLD(splvm, IPL_VM)
/* XXX - the following two should die. */
#define splimp splvm
#define splpmap splvm
SPLHOLD(splclock, IPL_CLOCK)
SPLHOLD(splfd, IPL_FD)
SPLHOLD(splzs, IPL_ZS)
SPLHOLD(splaudio, IPL_AUHARD)
SPLHOLD(splstatclock, IPL_STATCLOCK)
@


1.7.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.7.2.1 2002/06/11 03:38:16 art Exp $	*/
a81 1
#define IPL_NONE	0
a90 1
#define	IPL_FB		9		/* framebuffer interrupts */
@


1.7.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a197 1
	__asm __volatile("":::"memory");	/* protect from reordering */ \
a213 1
	__asm __volatile("":::"memory");	/* protect from reordering */ \
d229 1
a243 1
	__asm __volatile("":::"memory");	/* protect from reordering */
a252 1
	__asm __volatile("":::"memory");	/* protect from reordering */
@


1.6
log
@Define splvm() for arches who don't already provide it, with the same
definition as splimp().
art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.5 2000/07/07 11:49:39 art Exp $	*/
a204 5

/*
 * remove.
 */
SPLHOLD(splpmap, 7)
@


1.5
log
@Convert spl* on sparc to be raising-only.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.4 2000/07/06 15:25:04 ho Exp $	*/
d204 1
@


1.4
log
@Add spllowersoftclock(), same as splsoftclock(). (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.3 1997/08/08 08:26:41 downsj Exp $	*/
d174 1
a174 2
SPL(splsoftint, 1)
#define	spllowersoftclock	splsoftint
d178 2
d182 1
a182 1
SPL(splausoft, PIL_AUSOFT)
d186 1
a186 1
SPL(splfdsoft, PIL_FDSOFT)
d189 2
a190 1
SPL(splbio, 5)
d194 1
a194 1
SPL(splnet, PIL_NET)
d198 1
a198 1
SPL(spltty, PIL_TTY)
d203 5
a207 1
SPL(splimp, 7)
d210 1
a210 1
SPL(splclock, PIL_CLOCK)
d213 1
a213 1
SPL(splfd, 11)
d216 1
a216 1
SPL(splzs, 12)
d219 1
a219 1
SPL(splaudio, 13)
d222 1
a222 1
SPL(splstatclock, 14)
@


1.3
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d175 3
a177 2
#define	splsoftclock	splsoftint
#define	splsoftnet	splsoftint
@


1.3.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.5 2000/07/07 11:49:39 art Exp $	*/
d174 3
a176 5
SPLHOLD(splsoftint, 1)
#define	splsoftclock		splsoftint
#define	splsoftnet		splsoftint

SPL(spllowersoftclock, 1)
d180 1
a180 1
SPLHOLD(splausoft, PIL_AUSOFT)
d184 1
a184 1
SPLHOLD(splfdsoft, PIL_FDSOFT)
d187 1
a187 2
#define PIL_BIO 5
SPLHOLD(splbio, PIL_BIO)
d191 1
a191 1
SPLHOLD(splnet, PIL_NET)
d195 1
a195 1
SPLHOLD(spltty, PIL_TTY)
d200 1
a200 5
SPLHOLD(splimp, 7)

/*
 * remove.
 */
d203 1
a203 1
SPLHOLD(splclock, PIL_CLOCK)
d206 1
a206 1
SPLHOLD(splfd, 11)
d209 1
a209 1
SPLHOLD(splzs, 12)
d212 1
a212 1
SPLHOLD(splaudio, 13)
d215 1
a215 1
SPLHOLD(splstatclock, 14)
@


1.3.12.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.3.12.1 2001/05/14 21:37:13 niklas Exp $	*/
a203 1
SPLHOLD(splvm, 7)
@


1.3.12.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d83 6
a88 6
static __inline int getpsr(void);
static __inline void setpsr(int);
static __inline int spl0(void);
static __inline int splhigh(void);
static __inline void splx(int);
static __inline int getmid(void);
d145 1
a145 1
static __inline int name(void); \
d159 1
a159 1
static __inline int name(void); \
@


1.3.12.4
log
@Sync the SMP branch with 3.3
@
text
@d79 1
a79 23
/*
 * Various interrupt levels.
 */
#define IPL_NONE	0
#define IPL_SOFTINT	1
#define IPL_SOFTCLOCK	IPL_SOFTINT	/* softclock() interrupts */
#define IPL_SOFTNET	IPL_SOFTINT	/* soft network interrupts */
#define IPL_AUSOFT	4		/* audio soft interrupts */
#define IPL_FDSOFT	4		/* floppy soft interrupts */
#define IPL_BIO		5		/* block devices are at 5 and below */
#define IPL_TTY		6		/* tty soft interrupts */
#define IPL_NET		7		/* network hardware at 7 or below */
#define IPL_VM		7		/* max(BIO, NET, TTY) */
#define	IPL_FB		9		/* framebuffer interrupts */
#define	IPL_CLOCK	10		/* hardclock() */
#define IPL_FD		11		/* hard floppy interrupts. */
#define IPL_ZS		12		/* zs interrupts */
/*
 * XXX - this is called AUHARD instead of AUDIO because of some confusion
 * with how MI audio code handles this. Stay tuned for a change in the future
 */
#define IPL_AUHARD	13		/* hard audio interrupts */
#define IPL_STATCLOCK	14		/* statclock() */
d93 1
a93 2
static __inline int
getpsr()
d101 1
a101 2
static __inline int
getmid()
d109 1
a109 2
static __inline void
setpsr(newpsr)
d118 1
a118 2
static __inline int
spl0()
a138 17
#ifdef DIAGNOSTIC
/*
 * Although this function is implemented in MI code, it must be in this MD
 * header because we don't want this header to include MI includes.
 */
void splassert_fail(int, int, const char *);
extern int splassert_ctl;
void splassert_check(int, const char *);
#define splassert(__wantipl) do {			\
	if (__predict_false(splassert_ctl > 0)) {	\
		splassert_check(__wantipl, __func__);	\
	}						\
} while (0)
#else
#define splassert(wantipl) do { /* nada */ } while (0)
#endif

a154 1
	__asm __volatile("":::"memory");	/* protect from reordering */ \
a170 1
	__asm __volatile("":::"memory");	/* protect from reordering */ \
d174 1
a174 1
SPLHOLD(splsoftint, IPL_SOFTINT)
d177 47
a223 14
SPL(spllowersoftclock, IPL_SOFTCLOCK)
SPLHOLD(splausoft, IPL_AUSOFT)
SPLHOLD(splfdsoft, IPL_FDSOFT)
SPLHOLD(splbio, IPL_BIO)
SPLHOLD(splnet, IPL_NET)
SPLHOLD(spltty, IPL_TTY)
SPLHOLD(splvm, IPL_VM)
/* XXX - the following two should die. */
#define splimp splvm
SPLHOLD(splclock, IPL_CLOCK)
SPLHOLD(splfd, IPL_FD)
SPLHOLD(splzs, IPL_ZS)
SPLHOLD(splaudio, IPL_AUHARD)
SPLHOLD(splstatclock, IPL_STATCLOCK)
a232 1
	__asm __volatile("":::"memory");	/* protect from reordering */
a241 1
	__asm __volatile("":::"memory");	/* protect from reordering */
@


1.3.12.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.3.12.4 2003/03/27 23:49:25 niklas Exp $	*/
d25 5
a29 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.3.12.6
log
@IPL_HIGH 15 (for now)
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.3.12.5 2003/06/07 11:14:43 ho Exp $	*/
a97 1
#define IPL_HIGH	15		/* splhigh() */
@


1.2
log
@netbsd port, now we merge our changes back in
@
text
@d1 2
a2 1
/*	$NetBSD: psl.h,v 1.11 1996/03/31 22:20:14 pk Exp $ */
d88 1
d99 8
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: psl.h,v 1.7 1995/08/13 00:29:56 mycroft Exp $ */
d80 8
a87 1
#if defined(_KERNEL) && !defined(LOCORE)
d91 2
a92 1
static __inline int getpsr() {
d99 3
a101 1
static __inline void setpsr(int newpsr) {
d108 2
a109 1
static __inline int spl0() {
d135 17
a151 1
static __inline int name() { \
d155 2
d168 11
d187 3
a189 1
/* Memory allocation (must be as high as highest network or tty device) */
d191 1
a191 10

/* audio software interrupts are at software level 4 */
#define	PIL_AUSOFT	4
SPL(splausoft, PIL_AUSOFT)

/* floppy software interrupts are at software level 4 too */
#define PIL_FDSOFT	4
SPL(splfdsoft, PIL_FDSOFT)

SPL(splbio, 9)
d207 2
a208 1
static __inline int splhigh() {
d219 3
a221 1
static __inline void splx(int newipl) {
d229 1
a229 1
#endif /* KERNEL && !LOCORE */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
