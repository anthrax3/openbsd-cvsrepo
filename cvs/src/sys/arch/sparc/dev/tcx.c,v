head	1.47;
access;
symbols
	OPENBSD_6_0:1.47.0.12
	OPENBSD_6_0_BASE:1.47
	OPENBSD_5_9:1.47.0.8
	OPENBSD_5_9_BASE:1.47
	OPENBSD_5_8:1.47.0.10
	OPENBSD_5_8_BASE:1.47
	OPENBSD_5_7:1.47.0.2
	OPENBSD_5_7_BASE:1.47
	OPENBSD_5_6:1.47.0.6
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.47.0.4
	OPENBSD_5_5_BASE:1.47
	OPENBSD_5_4:1.46.0.2
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.45.0.12
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.45.0.10
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.8
	OPENBSD_5_0:1.45.0.6
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.45.0.4
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.45.0.2
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.44.0.2
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.43.0.6
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.43.0.2
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.31.0.2
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.30.0.4
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.29.0.2
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.26.0.2
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.24.0.2
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.19.0.6
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.13
	UBC:1.5.0.2
	UBC_BASE:1.5
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.12
	OPENBSD_2_8:1.2.0.10
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.8
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.6
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.0.6
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.4
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.2
	OPENBSD_2_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.47
date	2013.10.20.20.07.26;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2013.05.31.22.07.49;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2010.05.13.20.35.43;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2009.09.05.14.09.35;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2008.12.26.22.30.21;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2008.12.26.15.34.10;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2008.12.25.16.42.44;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2008.12.24.22.12.35;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2008.12.24.22.10.40;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2008.12.24.21.29.23;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2008.12.24.15.21.16;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2008.12.24.14.57.22;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2008.12.24.14.39.57;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2008.12.24.13.40.39;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2008.12.24.00.47.33;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2008.12.23.20.35.46;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2008.06.26.05.42.13;	author ray;	state Exp;
branches;
next	1.30;

1.30
date	2007.03.13.19.40.48;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2007.02.18.18.40.35;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2006.07.25.21.23.30;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2006.06.02.20.00.54;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.25.21.47.15;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2005.03.23.17.16.34;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2005.03.13.23.05.22;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.07.16.44.50;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2005.03.07.01.28.45;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2004.11.29.22.07.37;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2004.09.29.07.35.11;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.28.17.05.33;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.15.21.04.11;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.06.19.42.47;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.06.17.02.32;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2002.12.10.20.32.57;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.06.21.06.20;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2002.10.12.01.09.43;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2002.10.01.20.55.14;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.30.18.07.29;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.23.18.13.39;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.20.11.17.56;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.09.22.15.16;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2002.08.12.10.44.04;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.43;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.11.01.12.13.46;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.17.13.52.29;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	98.11.20.15.57.24;	author deraadt;	state Exp;
branches
	1.2.6.1;
next	1.1;

1.1
date	97.08.08.08.25.31;	author downsj;	state Exp;
branches;
next	;

1.2.6.1
date	2001.10.31.03.07.56;	author nate;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.2.6.3;

1.2.6.3
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.2.6.4;

1.2.6.4
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.2.6.5;

1.2.6.5
date	2003.05.13.19.41.08;	author ho;	state Exp;
branches;
next	1.2.6.6;

1.2.6.6
date	2003.06.07.11.14.43;	author ho;	state Exp;
branches;
next	1.2.6.7;

1.2.6.7
date	2004.02.19.10.49.58;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.10.29.00.28.09;	author art;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@/*	$OpenBSD: tcx.c,v 1.46 2013/05/31 22:07:49 deraadt Exp $	*/
/*	$NetBSD: tcx.c,v 1.8 1997/07/29 09:58:14 fair Exp $ */

/*
 * Copyright (c) 2002, 2003, 2008 Miodrag Vallat.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *
 *  Copyright (c) 1996 The NetBSD Foundation, Inc.
 *  All rights reserved.
 *
 *  This code is derived from software contributed to The NetBSD Foundation
 *  by Paul Kranenburg.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 *  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 *  PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Color display (TCX) driver.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/conf.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/pmap.h>
#include <machine/cpu.h>
#include <machine/conf.h>
#include <sparc/sparc/asm.h>
#include <machine/ctlreg.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

#include <sparc/dev/btreg.h>
#include <sparc/dev/btvar.h>
#include <sparc/dev/tcxreg.h>
#include <dev/ic/bt458reg.h>

#include <dev/cons.h>	/* for prom console hook */

/* per-display variables */
struct tcx_softc {
	struct	sunfb sc_sunfb;		/* common base part */
	struct	rom_reg sc_phys[2];	/* copy of prom ranges for mmap */
	volatile struct bt_regs *sc_bt;	/* Brooktree registers */
	volatile struct tcx_thc *sc_thc;/* THC registers */
	volatile u_int8_t *sc_dfb8;	/* 8 bit plane */
	paddr_t	sc_cplane;		/* S24 control plane PA */
	union	bt_cmap sc_cmap;	/* Brooktree color map */
	struct	intrhand sc_ih;
	int	sc_isconsole;

	/* acceleration parts */
	paddr_t	sc_stipple;		/* Stipple space PA */
	paddr_t	sc_blit;		/* Blitter space PA */
	int	sc_blit_width;		/* maximal blith width */
	int	(*sc_plain_copycols)(void *, int, int, int, int);
};

void	tcx_accel_init(struct tcx_softc *, struct confargs *);
void	tcx_accel_plug(struct tcx_softc *, struct confargs *);
void	tcx_blit(struct tcx_softc *, uint32_t, uint32_t, int);
void	tcx_burner(void *, u_int, u_int);
int	tcx_copyrows(void *, int, int, int);
int	tcx_copycols(void *, int, int, int, int);
int	tcx_do_cursor(struct rasops_info *);
int	tcx_erasecols(void *, int, int, int, long);
int	tcx_eraserows(void *, int, int, long);
int	tcx_intr(void *);
int	tcx_ioctl(void *, u_long, caddr_t, int, struct proc *);
static __inline__
void	tcx_loadcmap_deferred(struct tcx_softc *, u_int, u_int);
paddr_t	tcx_mmap(void *, off_t, int);
void	tcx_prom(struct tcx_softc *);
int	tcx_putchar(void *, int, int, u_int, long);
void	tcx_reset(struct tcx_softc *, int);
void	tcx_s24_reset(struct tcx_softc *, int);
void	tcx_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
void	tcx_stipple(struct tcx_softc *, int, int, int, int, int);

struct wsdisplay_accessops tcx_accessops = {
	.ioctl = tcx_ioctl,
	.mmap = tcx_mmap,
	.burn_screen = tcx_burner
};

int	tcxmatch(struct device *, void *, void *);
void	tcxattach(struct device *, struct device *, void *);
int	tcxactivate(struct device *, int);

const struct cfattach tcx_ca = {
	sizeof(struct tcx_softc), tcxmatch, tcxattach,
	NULL, tcxactivate
};

struct cfdriver tcx_cd = {
	NULL, "tcx", DV_DULL
};

/*
 * There are three ways to access the framebuffer memory of the S24:
 * - 26 bits per pixel, in 32-bit words; the low-order 24 bits are blue,
 *   green and red values, and the other two bits select the display modes,
 *   per pixel.
 *   This is the view we'll use to initialize the frame buffer.
 * - 24 bits per pixel, in 32-bit words; the high-order byte reads as zero,
 *   and is ignored on writes (so the mode bits can not be altered).
 *   This is the view available via mmap, for the X server.
 * - 8 bits per pixel, unpadded; writes to this space do not modify the
 *   other 18 bits, which are hidden.
 *   This is the view used for the console emulation mode, as well as for
 *   the X server on 8-bit only devices.
 *
 * The entry-level tcx found on the SPARCstation 4 can only provide the 8-bit
 * mode.
 *
 * Both flavours can be told out by the `tcx-8-bit' property; also, on
 * 8-bit tcx, the 24 bit color regions have a size of zero (or one with
 * the most recent PROM versions).
 */
#define	TCX_CTL_8_MAPPED	0x00000000	/* 8 bits, uses colormap */
#define	TCX_CTL_24_MAPPED	0x01000000	/* 24 bits, uses colormap */
#define	TCX_CTL_24_LEVEL	0x03000000	/* 24 bits, direct color */
#define	TCX_CTL_PIXELMASK	0x00ffffff	/* mask for index/level */

int
tcxmatch(struct device *parent, void *vcf, void *aux)
{
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

	if (strcmp(ra->ra_name, "SUNW,tcx") != 0)
		return (0);

	return (1);
}

void
tcxattach(struct device *parent, struct device *self, void *args)
{
	struct tcx_softc *sc = (struct tcx_softc *)self;
	struct confargs *ca = args;
	int node, pri;
	char *nam = NULL;
	vaddr_t thc_offset;

	pri = ca->ca_ra.ra_intr[0].int_pri;
	printf(" pri %d: ", pri);

	node = ca->ca_ra.ra_node;
	sc->sc_isconsole = node == fbnode;

	if (ca->ca_ra.ra_nreg < TCX_NREG) {
		printf("expected %d registers, got %d\n",
		    TCX_NREG, ca->ca_ra.ra_nreg);
		return;
	}

	nam = getpropstring(node, "model");
	if (*nam != '\0')
		printf("%s, ", nam);

	/*
	 * Copy the register address spaces needed for mmap operation.
	 */
	sc->sc_phys[0] = ca->ca_ra.ra_reg[TCX_REG_DFB8];
	sc->sc_phys[1] = ca->ca_ra.ra_reg[TCX_REG_DFB24];

	/*
	 * Can't trust the PROM range len here, it is only 4 bytes on the
	 * 8-bit model. Not that it matters much anyway since we map in
	 * pages.
	 */
	sc->sc_bt = (volatile struct bt_regs *)
	    mapiodev(&ca->ca_ra.ra_reg[TCX_REG_CMAP], 0, sizeof *sc->sc_bt);

	/*
	 * For some reason S24 PROM sets up TEC and THC ranges at the
	 * right addresses (701000 and 301000), while 8 bit TCX doesn't
	 * (and uses 70000 and 30000) - be sure to only compensate on 8 bit
	 * models.
	 */
	if (((vaddr_t)ca->ca_ra.ra_reg[TCX_REG_THC].rr_paddr & 0x1000) != 0)
		thc_offset = 0;
	else
		thc_offset = 0x1000;
	sc->sc_thc = (volatile struct tcx_thc *)
	    mapiodev(&ca->ca_ra.ra_reg[TCX_REG_THC],
	        thc_offset, sizeof *sc->sc_thc);

	/*
	 * Find out frame buffer geometry, so that we know how much
	 * memory to map.
	 */
	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, ca->ca_bustype);

	sc->sc_dfb8 = mapiodev(&ca->ca_ra.ra_reg[TCX_REG_DFB8], 0,
	    round_page(sc->sc_sunfb.sf_fbsize));

	/*
	 * If the frame buffer advertizes itself as the 8 bit model, or
	 * if the PROM ranges are too small, limit ourselves to 8 bit
	 * operations.
	 *
	 * Further code needing to know which capabilities the frame buffer
	 * has will rely on sc_cplane being non-zero if 24 bit operation
	 * is possible.
	 */
	if (!node_has_property(node, "tcx-8-bit") &&
	    ca->ca_ra.ra_reg[TCX_REG_RDFB32].rr_len >=
	      sc->sc_sunfb.sf_fbsize * 4) {
		sc->sc_cplane =
		    (paddr_t)ca->ca_ra.ra_reg[TCX_REG_RDFB32].rr_paddr;
	}

	printf("%dx%dx%d\n",
	    sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height,
	    sc->sc_cplane == 0 ? 8 : 24);

	/*
	 * Set up mappings for the acceleration code. This may fail.
	 */
	tcx_accel_init(sc, ca);

	/* reset cursor & frame buffer controls */
	tcx_reset(sc, 8);

	/* enable video */
	tcx_burner(sc, 1, 0);

	sc->sc_sunfb.sf_ro.ri_hw = sc;
	sc->sc_sunfb.sf_ro.ri_bits = (void *)sc->sc_dfb8;

	fbwscons_init(&sc->sc_sunfb, sc->sc_isconsole);
	fbwscons_setcolormap(&sc->sc_sunfb, tcx_setcolor);

	/*
	 * Now plug accelerated console routines, if possible.
	 */
	tcx_accel_plug(sc, ca);

	sc->sc_ih.ih_fun = tcx_intr;
	sc->sc_ih.ih_arg = sc;
	intr_establish(pri, &sc->sc_ih, IPL_FB, self->dv_xname);

	if (sc->sc_isconsole)
		fbwscons_console_init(&sc->sc_sunfb, -1);

	fbwscons_attach(&sc->sc_sunfb, &tcx_accessops, sc->sc_isconsole);
}

int
tcxactivate(struct device *self, int act)
{
	struct tcx_softc *sc = (struct tcx_softc *)self;
	int ret = 0;

	switch (act) {
	case DVACT_POWERDOWN:
		if (sc->sc_isconsole)
			tcx_prom(sc);
		break;
	}

	return (ret);
}

int
tcx_ioctl(void *dev, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct tcx_softc *sc = dev;
	struct wsdisplay_cmap *cm;
	struct wsdisplay_fbinfo *wdf;
	int error;

	/*
	 * Note that, although the emulation (text) mode is running in 8-bit
	 * mode, if the frame buffer is able to run in 24-bit mode, it will
	 * be advertized as such.
	 */
	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_SUNTCX;
		break;
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width = sc->sc_sunfb.sf_width;
		wdf->depth = sc->sc_sunfb.sf_depth;
		wdf->cmsize = sc->sc_cplane == 0 ? 256 : 0;
		break;
	case WSDISPLAYIO_GETSUPPORTEDDEPTH:
		if (sc->sc_cplane != 0)
			*(u_int *)data = WSDISPLAYIO_DEPTH_24_32;
		else
			return (-1);
		break;
	case WSDISPLAYIO_LINEBYTES:
		if (sc->sc_cplane == 0)
			*(u_int *)data = sc->sc_sunfb.sf_linebytes;
		else
			*(u_int *)data = sc->sc_sunfb.sf_linebytes * 4;
		break;

	case WSDISPLAYIO_GETCMAP:
		if (sc->sc_cplane == 0) {
			cm = (struct wsdisplay_cmap *)data;
			error = bt_getcmap(&sc->sc_cmap, cm);
			if (error)
				return (error);
		}
		break;
	case WSDISPLAYIO_PUTCMAP:
		if (sc->sc_cplane == 0) {
			cm = (struct wsdisplay_cmap *)data;
			error = bt_putcmap(&sc->sc_cmap, cm);
			if (error)
				return (error);
			tcx_loadcmap_deferred(sc, cm->index, cm->count);
		}
		break;

	case WSDISPLAYIO_SMODE:
		if (*(int *)data == WSDISPLAYIO_MODE_EMUL) {
			/* Back from X11 to text mode */
			tcx_reset(sc, 8);
		} else {
			/* Starting X11, try to switch to 24 bit mode */
			if (sc->sc_cplane != 0)
				tcx_reset(sc, 32);
		}
		break;

	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
		break;

	default:
		return (-1);	/* not supported yet */
	}

	return (0);
}

void
tcx_reset(struct tcx_softc *sc, int depth)
{
	volatile struct bt_regs *bt;

	/* Hide the cursor, just in case */
	sc->sc_thc->thc_cursoraddr = THC_CURSOFF;

	/* Enable cursor in Brooktree DAC. */
	bt = sc->sc_bt;
	bt->bt_addr = BT_CR << 24;
	bt->bt_ctrl |= (BTCR_DISPENA_OV1 | BTCR_DISPENA_OV0) << 24;

	/*
	 * Change mode if appropriate
	 */
	if (sc->sc_sunfb.sf_depth != depth) {
		if (sc->sc_cplane != 0) {
			tcx_s24_reset(sc, depth);
		}

		if (depth == 8)
			fbwscons_setcolormap(&sc->sc_sunfb, tcx_setcolor);
	}

	sc->sc_sunfb.sf_depth = depth;
}

void
tcx_prom(struct tcx_softc *sc)
{
	extern struct consdev consdev_prom;

	if (sc->sc_sunfb.sf_depth != 8) {
		/*
	 	 * Select 8-bit mode.
	 	 */
		tcx_reset(sc, 8);

		/*
	 	 * Go back to prom output for the last few messages, so they
	 	 * will be displayed correctly.
	 	 */
		cn_tab = &consdev_prom;
	}
}

void
tcx_burner(void *v, u_int on, u_int flags)
{
	struct tcx_softc *sc = v;
	int s;
	u_int32_t thcm;

	s = splhigh();
	thcm = sc->sc_thc->thc_hcmisc;
	if (on) {
		thcm |= THC_MISC_VIDEN;
		thcm &= ~(THC_MISC_VSYNC_DISABLE | THC_MISC_HSYNC_DISABLE);
	} else {
		thcm &= ~THC_MISC_VIDEN;
		if (flags & WSDISPLAY_BURN_VBLANK)
			thcm |= THC_MISC_VSYNC_DISABLE | THC_MISC_HSYNC_DISABLE;
	}
	sc->sc_thc->thc_hcmisc = thcm;
	splx(s);
}

paddr_t
tcx_mmap(void *v, off_t offset, int prot)
{
	struct tcx_softc *sc = v;
	int regno;

	if (offset & PGOFSET || offset < 0)
		return (-1);

	/* Allow mapping as a dumb framebuffer from offset 0 */
	if (sc->sc_sunfb.sf_depth == 8 && offset < sc->sc_sunfb.sf_fbsize)
		regno = 0;	/* copy of TCX_REG_DFB8 */
	else if (sc->sc_sunfb.sf_depth != 8 &&
	    offset < sc->sc_sunfb.sf_fbsize * 4)
		regno = 1;	/* copy of TCX_REG_RDFB32 */
	else
		return (-1);

	return (REG2PHYS(&sc->sc_phys[regno], offset) | PMAP_NC);
}

void
tcx_setcolor(void *v, u_int index, u_int8_t r, u_int8_t g, u_int8_t b)
{
	struct tcx_softc *sc = v;

	bt_setcolor(&sc->sc_cmap, sc->sc_bt, index, r, g, b, 1);
}

static __inline__ void
tcx_loadcmap_deferred(struct tcx_softc *sc, u_int start, u_int ncolors)
{
	u_int32_t thcm;

	thcm = sc->sc_thc->thc_hcmisc;
	thcm |= THC_MISC_INTEN;
	sc->sc_thc->thc_hcmisc = thcm;
}

int
tcx_intr(void *v)
{
	struct tcx_softc *sc = v;
	u_int32_t thcm;

	thcm = sc->sc_thc->thc_hcmisc;
	if (thcm & THC_MISC_INTEN) {
		thcm &= ~(THC_MISC_INTR | THC_MISC_INTEN);

		/* Acknowledge the interrupt */
		sc->sc_thc->thc_hcmisc = thcm | THC_MISC_INTR;

		bt_loadcmap(&sc->sc_cmap, sc->sc_bt, 0, 256, 1);

		/* Disable further interrupts now */
		sc->sc_thc->thc_hcmisc = thcm;

		return (1);
	}

	return (0);
}

/*
 * Switch video mode and clear screen
 */
void
tcx_s24_reset(struct tcx_softc *sc, int depth)
{
	struct rasops_info *ri = &sc->sc_sunfb.sf_ro;
	uint32_t pixel;
	paddr_t dst;
	int n;

	if (depth == 8)
		pixel = TCX_CTL_8_MAPPED | (ri->ri_devcmap[WSCOL_WHITE] & 0xff);
	else
		pixel = TCX_CTL_24_LEVEL | 0xffffff;

	/*
	 * Set the first 32 pixels as white in the intended mode, using the
	 * control plane.
	 */
	dst = sc->sc_cplane;
	for (n = 32; n != 0; n--) {
		sta(dst, ASI_BYPASS, pixel);
		dst += 4;
	}

	/*
	 * Do the remaining pixels: either with the blitter if we can use it,
	 * or continuing manual writes if we can't.
	 */
	if (sc->sc_blit != 0) {
		dst = sc->sc_blit + (32 << 3);
		pixel = ((sc->sc_blit_width - 1) << 24) | 0;
		for (n = sc->sc_sunfb.sf_fbsize - 32; n != 0;
		    n -= sc->sc_blit_width) {
			stda(dst, ASI_BYPASS, pixel);
			dst += sc->sc_blit_width << 3;
		}
	} else {
		/* this relies on video memory being contiguous */
		for (n = sc->sc_sunfb.sf_fbsize - 32; n != 0; n--) {
			sta(dst, ASI_BYPASS, pixel);
			dst += 4;
		}
	}
}

/*
 * Accelerated console operations
 *
 * Most of the TCX and S24 frame buffers can not perform simple ROPs
 * besides GXcopy. Those which can, have a ``stip-rop'' property,
 * and appear to support at least copy and invert rops.
 *
 * We use the blitter for block moves: copycols, copyrows; and the
 * stipple for solid fills: erasecols, eraserows, putchar.
 *
 * This work has been made possible thanks to the information collected in
 *   http://ftp.rodents-montreal.org/mouse/docs/Sun/S24/memory-map
 * and experiments.
 *
 * It turns out that frame buffer memory is contiguous, so addressing
 * of a given (x,y) pixel is always (y * width + x), regardless of the
 * actual frame buffer resolution.
 */

void
tcx_accel_init(struct tcx_softc *sc, struct confargs *ca)
{
	int stipple_align, regno;

	/*
	 * On S24, try and map raw blit and raw stipple spaces.
	 * We prefer the raw spaces so that we can eventually switch
	 * between 8 bit and 24 bit modes with blitter operations.
	 *
	 * However, on 8-bit TCX, these spaces are missing (and empty!),
	 * so we should fallback to non-raw spaces in this case.
	 *
	 * Since this frame buffer can only exist on SS4 and SS5,
	 * we can rely upon the fact this code will only run on sun4m,
	 * and use stda() bypassing the MMU to access these spaces,
	 * instead of mapping them (8MB KVA each, after all, even more
	 * on an SS4 with the resolution extender VSIMM).
	 */

	sc->sc_blit_width = getpropint(ca->ca_ra.ra_node, "blit-width", 0);
	if (sc->sc_blit_width > 5)
		sc->sc_blit_width = 5;	/* paranoia */
	if (sc->sc_blit_width <= 3)	/* not worth until more than 8 pixels */
		sc->sc_blit_width = 0;
	else {
		sc->sc_blit_width = 1 << sc->sc_blit_width;

		regno = sc->sc_cplane == 0 ? TCX_REG_BLIT : TCX_REG_RBLIT;
		if (ca->ca_ra.ra_reg[regno].rr_len >=
		    sc->sc_sunfb.sf_fbsize * 8)
			sc->sc_blit = (paddr_t)ca->ca_ra.ra_reg[regno].rr_paddr;
	}

	/*
	 * Do not assume the stipple space is usable unless there is a
	 * `stipple-align' property.  Also, don't try to use it if the
	 * alignment is not 32 - our code may not behave correctly.
	 */

	stipple_align = getpropint(ca->ca_ra.ra_node, "stipple-align", 0);
	if (stipple_align == 5) {
		regno = sc->sc_cplane == 0 ? TCX_REG_STIP : TCX_REG_RSTIP;
		if (ca->ca_ra.ra_reg[regno].rr_len >=
		    sc->sc_sunfb.sf_fbsize * 8)
			sc->sc_stipple =
			    (paddr_t)ca->ca_ra.ra_reg[regno].rr_paddr;
	}
}

/*
 * After rasops has initialized, override its basic operations with
 * accelerated routines whenever possible (this will depend on the
 * frame buffer capabilities and our success at using blit and
 * stipple spaces).
 */
void
tcx_accel_plug(struct tcx_softc *sc, struct confargs *ca)
{
	struct rasops_info *ri = &sc->sc_sunfb.sf_ro;

	if (sc->sc_stipple != 0) {
		sc->sc_sunfb.sf_ro.ri_ops.eraserows = tcx_eraserows;
		sc->sc_sunfb.sf_ro.ri_ops.erasecols = tcx_erasecols;
		if (node_has_property(ca->ca_ra.ra_node, "stip-rop")) {
			/* needs GXinvert support */
			sc->sc_sunfb.sf_ro.ri_do_cursor = tcx_do_cursor;
		}
		if (ri->ri_font->fontwidth <= 16) {
			/*
			 * The code in tcx_putchar really can handle up
			 * to 32 bit font width if one extends the font
			 * bits loading part to support more than 16 bits,
			 * but then there is no such font in wsfont at the
			 * moment, so why bother.
			 */
			sc->sc_sunfb.sf_ro.ri_ops.putchar = tcx_putchar;
		}
	}

	if (sc->sc_blit != 0) {
		sc->sc_sunfb.sf_ro.ri_ops.copyrows = tcx_copyrows;
		sc->sc_plain_copycols = sc->sc_sunfb.sf_ro.ri_ops.copycols;
		sc->sc_sunfb.sf_ro.ri_ops.copycols = tcx_copycols;
	}
}

/*
 * Blitter operations
 *
 * Since the blitter only operates on 1 pixel height areas, we need
 * to invoke it many times, and handle overlapping regions ourselves.
 */

int
tcx_copycols(void *cookie, int row, int src, int dst, int n)
{
	struct rasops_info *ri = cookie;
	struct tcx_softc *sc = ri->ri_hw;
	int h;
	uint32_t dstaddr, srcaddr;

	if (dst > src && dst < src + n) {
		/* Areas overlap, do it the slow but safe way */
		return (*sc->sc_plain_copycols)(cookie, row, src, dst, n);
	}

	/* Areas do not overlap dangerously, copy forwards */

	/* actual columns */
	n *= ri->ri_font->fontwidth;
	src *= ri->ri_font->fontwidth;
	dst *= ri->ri_font->fontwidth;

	row *= ri->ri_font->fontheight;
	srcaddr = dstaddr = ri->ri_xorigin +
	    (ri->ri_yorigin + row) * sc->sc_sunfb.sf_width;
	srcaddr += src;
	dstaddr += dst;

	for (h = ri->ri_font->fontheight; h != 0; h--) {
		tcx_blit(sc, dstaddr, srcaddr, n);
		srcaddr += sc->sc_sunfb.sf_width;
		dstaddr += sc->sc_sunfb.sf_width;
	}

	return 0;
}

int
tcx_copyrows(void *cookie, int src, int dst, int n)
{
	struct rasops_info *ri = cookie;
	struct tcx_softc *sc = ri->ri_hw;
	int reverse;
	uint32_t dstaddr, srcaddr;

	/* actual lines */
	src *= ri->ri_font->fontheight;
	dst *= ri->ri_font->fontheight;
	n *= ri->ri_font->fontheight;

	if (dst > src && dst < src + n) {
		/* Areas overlap, copy backwards */
		dst += n - 1;
		src += n - 1;
		reverse = 1;
	} else {
		/* Areas do not overlap dangerously, copy forwards */
		reverse = 0;
	}

	dstaddr = (ri->ri_yorigin + dst) * sc->sc_sunfb.sf_width;
	srcaddr = (ri->ri_yorigin + src) * sc->sc_sunfb.sf_width;

	dstaddr += ri->ri_xorigin;
	srcaddr += ri->ri_xorigin;

	for (; n != 0; n--) {
		tcx_blit(sc, dstaddr, srcaddr, ri->ri_emuwidth);
		if (reverse) {
			dstaddr -= sc->sc_sunfb.sf_width;
			srcaddr -= sc->sc_sunfb.sf_width;
		} else {
			dstaddr += sc->sc_sunfb.sf_width;
			srcaddr += sc->sc_sunfb.sf_width;
		}
	}

	return 0;
}

/*
 * Perform a blit operation, copying the line starting at computed
 * position src to computed position dst, for a length of len pixels.
 */
void
tcx_blit(struct tcx_softc *sc, uint32_t dst, uint32_t src, int len)
{
	int cx;
	uint32_t addr;

	addr = sc->sc_blit + (dst << 3);

	/* do the incomplete chunk first if needed */
	cx = len & (sc->sc_blit_width - 1);
	if (cx == 0)
		cx = sc->sc_blit_width;

	while (len != 0) {
		stda(addr, ASI_BYPASS, ((cx - 1) << 24) | src);
		src += cx;
		addr += cx << 3;
		len -= cx;
		/* and then full steam ahead for the others */
		cx = sc->sc_blit_width;
	}	
}

/*
 * Stipple operations
 */

/* canonical rop values */
#define	GXcopy		0x03
#define	GXinvert	0x0a

#define	STIPPLE_ROP_SHIFT	28

/*
 * Perform a stipple operation rop from (x, y) to (x + cnt - 1, y).
 *
 * We probably should honour the stipple alignment property (stipple-align),
 * in case it is different than 32 (1 << 5). However, due to the way
 * the stipple space is accessed, it is not possible to have a stricter
 * alignment requirement, so let's settle for 32. There probably haven't
 * been TCX boards with relaxed alignment rules anyway.
 */
void
tcx_stipple(struct tcx_softc *sc, int x, int y, int cnt, int rop, int bg)
{
	int rx;		/* aligned x */
	int lbcnt;	/* count of untouched pixels on the left */
	int rbcnt;	/* count of untouched pixels on the right */
	uint32_t wmask;	/* write mask */
	uint32_t soffs;	/* stipple offset */
	uint64_t scmd;

	scmd = rop << STIPPLE_ROP_SHIFT;
	scmd |= TCX_CTL_8_MAPPED | bg;	/* pixel bits, here in 8-bit mode */
	scmd <<= 32;

	/*
	 * The first pass needs to align the position to a 32 pixel
	 * boundary, which explains why the loop is a bit unnatural
	 * at first glance.
	 */
	rx = x & ~(32 - 1);
	soffs = sc->sc_stipple + ((y * sc->sc_sunfb.sf_width + rx) << 3);
	lbcnt = x - rx;
	wmask = 0xffffffff >> lbcnt;

	while (cnt != 0) {
		rbcnt = (32 - lbcnt) - cnt;
		if (rbcnt < 0)
			rbcnt = 0;
		if (rbcnt != 0)
			wmask &= ~((1 << rbcnt) - 1);

		stda(soffs, ASI_BYPASS, scmd | wmask);

		cnt -= (32 - lbcnt) - rbcnt;
		soffs += 32 << 3;

		/* further loops are aligned */
		lbcnt = 0;
		wmask = 0xffffffff;
	}
}

int
tcx_erasecols(void *cookie, int row, int col, int n, long attr)
{
	struct rasops_info *ri = cookie;
	struct tcx_softc *sc = ri->ri_hw;
	int fg, bg, h, cury, sx;

	ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);
	bg = ri->ri_devcmap[bg] & 0xff;	/* 8 bit palette index */

	n *= ri->ri_font->fontwidth;
	sx = ri->ri_xorigin + col * ri->ri_font->fontwidth;

	cury = ri->ri_yorigin + row * ri->ri_font->fontheight;
	for (h = ri->ri_font->fontheight; h != 0; cury++, h--)
		tcx_stipple(sc, sx, cury, n, GXcopy, bg);

	return 0;
}

int
tcx_eraserows(void *cookie, int row, int n, long attr)
{
	struct rasops_info *ri = cookie;
	struct tcx_softc *sc = ri->ri_hw;
	int fg, bg, x, y, w;

	ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);
	bg = ri->ri_devcmap[bg] & 0xff;	/* 8 bit palette index */

	if ((n == ri->ri_rows) && ISSET(ri->ri_flg, RI_FULLCLEAR)) {
		n = ri->ri_height;
		x = y = 0;
		w = ri->ri_width;
	} else {
		n *= ri->ri_font->fontheight;
		x = ri->ri_xorigin;
		y = ri->ri_yorigin + row * ri->ri_font->fontheight;
		w = ri->ri_emuwidth;
	}

	for (; n != 0; y++, n--)
		tcx_stipple(sc, x, y, w, GXcopy, bg);

	return 0;
}

int
tcx_do_cursor(struct rasops_info *ri)
{
	struct tcx_softc *sc = ri->ri_hw;
	int x, y, n;

	x = ri->ri_ccol * ri->ri_font->fontwidth + ri->ri_xorigin;
	y = ri->ri_crow * ri->ri_font->fontheight + ri->ri_yorigin;

	for (n = ri->ri_font->fontheight; n != 0; y++, n--)
		tcx_stipple(sc, x, y, ri->ri_font->fontwidth, GXinvert, 0xff);

	return 0;
}

int
tcx_putchar(void *cookie, int row, int col, u_int uc, long attr)
{
	struct rasops_info *ri = cookie;
	struct tcx_softc *sc = ri->ri_hw;
	struct wsdisplay_font *font = ri->ri_font;
	int fg, bg, ul;
	int h, x, y;
	uint8_t *fontbits;
	uint32_t fgpattern, bgpattern;

	ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, &ul);
	fg = ri->ri_devcmap[fg] & 0xff;	/* 8 bit palette index */
	bg = ri->ri_devcmap[bg] & 0xff;	/* 8 bit palette index */

	x = ri->ri_xorigin + col * font->fontwidth;
	y = ri->ri_yorigin + row * font->fontheight;

	if (uc == ' ') {
		/* inline tcx_erasecols(cookie, row, col, 1, attr) */
		for (h = font->fontheight; h != 0; y++, h--)
			tcx_stipple(sc, x, y, font->fontwidth, GXcopy,
			    h == 2 && ul != 0 ? fg : bg);
	} else {
		int rx;
		int lbcnt, rbcnt;
		uint32_t soffs;
		uint64_t stmpl, scmd;

		stmpl = (GXcopy << STIPPLE_ROP_SHIFT) | TCX_CTL_8_MAPPED;

		fontbits = (uint8_t *)font->data +
		    (uc - font->firstchar) * ri->ri_fontscale;

		rx = x & ~(32 - 1);
		lbcnt = x - rx;
		rbcnt = (32 - lbcnt) - font->fontwidth; /* may be negative */
		soffs = sc->sc_stipple +
		    ((y * sc->sc_sunfb.sf_width + rx) << 3);

		for (h = font->fontheight; h != 0; y++, h--) {
			if (font->fontwidth <= 8)
				fgpattern = *(uint8_t *)fontbits >>
				    (8 - font->fontwidth);
			else /* if (font->fontwidth <= 16) */
				fgpattern = *(uint16_t *)fontbits >>
				    (16 - font->fontwidth);
			/* see tcx_accel_plug() for the reason why
			   larger font sizes are not supported, yet */
			fontbits += font->stride;

			/* underline */
			if (ul && h == 2)
				fgpattern = 0xffffffff &
				    ((1 << font->fontwidth) - 1);

			bgpattern = ~fgpattern &
			    ((1 << font->fontwidth) - 1);

			/*
			 * We have a pattern of font->fontwidth bits in
			 * the low bits of `fgpattern' and its one-complement
			 * in `bgpattern'. The bgpattern bits need to be
			 * painted with the background colour, while the
			 * fgpattern bits need to be painted with the
			 * foreground colour.
			 *
			 * The particular character cell position might
			 * span two stipple cells, so we have to account
			 * for this.
			 */

			if (rbcnt >= 0) {
				/* everything fits in one stipple cell. */

				/* foreground */
				scmd = (stmpl | fg) << 32;
				stda(soffs, ASI_BYPASS,
				    scmd | (fgpattern << rbcnt));

				/* background */
				scmd = (stmpl | bg) << 32;
				stda(soffs, ASI_BYPASS,
				    scmd | (bgpattern << rbcnt));
			} else {
				/* needs two stipple cells. */

				/* foreground, first stipple cell */
				scmd = (stmpl | fg) << 32;
				stda(soffs, ASI_BYPASS,
				    scmd | (fgpattern >> -rbcnt));

				/* background, first stipple cell */
				scmd = (stmpl | bg) << 32;
				stda(soffs, ASI_BYPASS,
				    scmd | (bgpattern >> -rbcnt));

				/* rotate patterns, relying on 32 bit size */
				fgpattern <<= (32 + rbcnt);
				bgpattern <<= (32 + rbcnt);

				/* foreground, second stipple cell */
				scmd = (stmpl | fg) << 32;
				stda(soffs + (32 << 3), ASI_BYPASS,
				    scmd | fgpattern);

				/* background, second stipple cell */
				scmd = (stmpl | bg) << 32;
				stda(soffs + (32 << 3), ASI_BYPASS,
				    scmd | bgpattern);
			}

			soffs += sc->sc_sunfb.sf_width << 3;
		}
	}

	return 0;
}
@


1.46
log
@Replace shutdownhooks with activate functions, properly doing those
operations only if device is console
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.45 2010/05/13 20:35:43 miod Exp $	*/
d128 3
a130 10
	tcx_ioctl,
	tcx_mmap,
	NULL,	/* alloc_screen */
	NULL,	/* free_screen */
	NULL,	/* show_screen */
	NULL,   /* load_font */
	NULL,   /* scrollback */
	NULL,   /* getchar */
	tcx_burner,
	NULL	/* pollc */
@


1.45
log
@Only enable acceleration code if specific device properties exist; this should
fix OpenBSD/sparc operation in QEMU, which only provides the frame buffer
memory and none of the accelerated stipple and blit spaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.44 2009/09/05 14:09:35 miod Exp $	*/
d97 1
d120 1
a120 1
void	tcx_prom(void *);
d142 1
d145 2
a146 1
	sizeof(struct tcx_softc), tcxmatch, tcxattach
a196 1
	int isconsole = 0;
d204 1
a204 1
	isconsole = node == fbnode;
d287 1
a287 1
	fbwscons_init(&sc->sc_sunfb, isconsole);
d299 1
a299 1
	if (isconsole) {
d301 15
a315 1
		shutdownhook_establish(tcx_prom, sc);
d318 1
a318 1
	fbwscons_attach(&sc->sc_sunfb, &tcx_accessops, isconsole);
d427 1
a427 1
tcx_prom(void *v)
a428 1
	struct tcx_softc *sc = v;
@


1.44
log
@Change the wsdisplay_emulops return types from void to int; emulops will now
return zero on success and nonzero on failure.
This commit only performs mechanical changes for the existing emulops to
always return zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.43 2008/12/26 22:30:21 miod Exp $	*/
d583 1
a583 1
	int regno;
d600 1
a600 1
	sc->sc_blit_width = getpropint(ca->ca_ra.ra_node, "blit-width", 5);
d614 14
a627 3
	regno = sc->sc_cplane == 0 ? TCX_REG_STIP : TCX_REG_RSTIP;
	if (ca->ca_ra.ra_reg[regno].rr_len >= sc->sc_sunfb.sf_fbsize * 8)
		sc->sc_stipple = (paddr_t)ca->ca_ra.ra_reg[regno].rr_paddr;
@


1.43
log
@Move the logic responsible from deciding whether a frame buffer needs to be
cleared on attach, from the individual drivers to the common frame buffer code;
the latter will decide based on the prom font metrics and the prom console
window position, whenever possible.

This removes the need for the console window position to be hardcoded in
the p9100 driver, and will no longer require a screen clear on a vigra
VS-12 in high resolution mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.42 2008/12/26 15:34:10 miod Exp $	*/
d102 1
a102 1
	void	(*sc_plain_copycols)(void *, int, int, int, int);
d109 5
a113 5
void	tcx_copyrows(void *, int, int, int);
void	tcx_copycols(void *, int, int, int, int);
void	tcx_do_cursor(struct rasops_info *);
void	tcx_erasecols(void *, int, int, int, long);
void	tcx_eraserows(void *, int, int, long);
d120 1
a120 1
void	tcx_putchar(void *, int, int, u_int, long);
d663 1
a663 1
void
d673 1
a673 2
		(*sc->sc_plain_copycols)(cookie, row, src, dst, n);
		return;
d694 2
d698 1
a698 1
void
d737 2
d829 1
a829 1
void
d845 2
d849 1
a849 1
void
d872 2
d876 1
a876 1
void
d887 2
d891 1
a891 1
void
d1006 2
@


1.42
log
@Use constants from bt458reg.h when frobbing ramdac registers.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.41 2008/12/25 16:42:44 miod Exp $	*/
d285 1
a285 13
	/*
	 * If the framebuffer width is under 960 pixels, we will switch
	 * from the PROM font to the more adequate 8x16 font here.
	 * However, we need to adjust two things in this case:
	 * - the display row should be overrided from the current PROM metrics,
	 *   to prevent us from overwriting the last few lines of text.
	 * - if the 80x34 screen would make a large margin appear around it,
	 *   choose to clear the screen rather than keeping old prom output in
	 *   the margins.
	 */
	fbwscons_init(&sc->sc_sunfb,
	    isconsole && sc->sc_sunfb.sf_width >= 12 * 80 ? 0 : RI_CLEAR);

d298 1
a298 2
		fbwscons_console_init(&sc->sc_sunfb,
		    sc->sc_sunfb.sf_width >= 12 * 80 ? -1 : 0);
@


1.41
log
@Correctly display underlined spaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.40 2008/12/24 22:12:35 miod Exp $	*/
d83 1
a83 1
#include <sparc/dev/sbusvar.h>
d168 2
a169 1
 * 8-bit tcx, the 24 bit color regions have a size of zero.
d405 2
a406 2
	bt->bt_addr = 0x06 << 24;
	bt->bt_ctrl |= 0x03 << 24;
d964 1
a964 1
			 * for this unconditionnaly.
@


1.40
log
@No need to invoke fbwscons_setcolormap() twice.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.39 2008/12/24 22:10:40 miod Exp $	*/
d915 2
a916 1
			tcx_stipple(sc, x, y, font->fontwidth, GXcopy, bg);
@


1.39
log
@Get rid of all remaining magic numbers but 32. If you need to know why 32
is magic on a 32-bit platform, maybe you shouldn't do kernel programming.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.38 2008/12/24 21:29:23 miod Exp $	*/
a276 1
	fbwscons_setcolormap(&sc->sc_sunfb, tcx_setcolor);
@


1.38
log
@Provide an accelerated putchar routine for fonts 16 bits wide or less (and
the code can do up to 32 bit without serious changes, but I'm lazy).
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.37 2008/12/24 15:21:16 miod Exp $	*/
d256 1
a256 1
	 * has will rely on sc_cplane being non NULL if 24 bit operation
d786 2
d807 1
a807 1
	scmd = rop << 28;
d816 1
a816 1
	rx = x & ~31;
d923 1
a923 1
		stmpl = (GXcopy << 28) | TCX_CTL_8_MAPPED;
d928 1
a928 1
		rx = x & ~31;
@


1.37
log
@Oops, logic botch in 1.34 would disable 24 bit mode on S24.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.36 2008/12/24 14:57:22 miod Exp $	*/
d106 1
d120 1
d303 1
a303 11
	if (sc->sc_stipple != 0) {
		sc->sc_sunfb.sf_ro.ri_ops.eraserows = tcx_eraserows;
		sc->sc_sunfb.sf_ro.ri_ops.erasecols = tcx_erasecols;
		if (node_has_property(node, "stip-rop"))
			sc->sc_sunfb.sf_ro.ri_do_cursor = tcx_do_cursor;
	}
	if (sc->sc_blit != 0) {
		sc->sc_sunfb.sf_ro.ri_ops.copyrows = tcx_copyrows;
		sc->sc_plain_copycols = sc->sc_sunfb.sf_ro.ri_ops.copycols;
		sc->sc_sunfb.sf_ro.ri_ops.copycols = tcx_copycols;
	}
d541 1
a541 1
		pixel = TCX_CTL_24_LEVEL | 0x000000;
d579 1
a579 1
 * but I have no idea which ROPs are supported anyway.
d582 1
a582 7
 * stipple for solid fills: erasecols, eraserows.
 *
 * Eventually putchar could be done as two stipple operations, one for the
 * foreground color, and one for the background color; however, due to
 * stipple alignment restrictions, this will likely need four operations
 * per character cell (and let's not talk about fonts larger than 32
 * pixels please).
d586 5
d633 37
d673 1
a673 1
 * to invoke it many times, and handle overlaps ourselves.
d891 116
@


1.36
log
@On cards which advertize complete rop support, use the stipple engine to
draw the inverted cursor.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.33 2008/12/24 00:47:33 miod Exp $	*/
d257 1
a257 1
	if (node_has_property(node, "tcx-8-bit") &&
@


1.35
log
@It turns out the 8-bit tcx flavour has undocumented low-res video modes (soon
to be in tcx.4), which require a font swap and thus clearing the screen at
attach time if console. Add the necessary code for this.
@
text
@d110 1
d122 1
a122 1
void	tcx_stipple(struct tcx_softc *, int, int, int, int);
d304 2
d594 1
a594 1
 * stipple alignment restrictions, this will likely need four operation
d596 1
a596 1
 * pixels).
d754 55
d824 1
a824 1
		tcx_stipple(sc, sx, cury, n, bg);
d849 1
a849 1
		tcx_stipple(sc, x, y, w, bg);
a851 9
/*
 * Perform a stipple operation from srop from (x, y) to (x + cnt - 1, y).
 *
 * We probably should honour the stipple alignment property (stipple-align),
 * in case it is different than 32 (1 << 5). However, due to the way
 * the stipple space is accessed, it is not possible to have a stricter
 * alignment requirement, so let's settle for 32. There probably haven't
 * been TCX boards with relaxed alignment rules anyway.
 */
d853 1
a853 1
tcx_stipple(struct tcx_softc *sc, int x, int y, int cnt, int bg)
d855 2
a856 20
	int rx;		/* aligned x */
	int lbcnt;	/* count of untouched pixels on the left */
	int rbcnt;	/* count of untouched pixels on the right */
	uint32_t wmask;	/* write mask */
	uint32_t soffs;	/* stipple offset */
	uint64_t rop;

	rop = 0x3 /* GXcopy */ << 28;
	rop |= TCX_CTL_8_MAPPED | bg;	/* pixel bits, here in 8-bit mode */
	rop <<= 32;

	/*
	 * The first pass needs to align the position to a 32 pixel
	 * boundary, which explains why the loop is a bit unnatural
	 * at first glance.
	 */
	rx = x & ~31;
	soffs = sc->sc_stipple + ((y * sc->sc_sunfb.sf_width + rx) << 3);
	lbcnt = x - rx;
	wmask = 0xffffffff >> lbcnt;
d858 2
a859 11
	while (cnt != 0) {
		rbcnt = (32 - lbcnt) - cnt;
		if (rbcnt < 0)
			rbcnt = 0;
		if (rbcnt != 0)
			wmask &= ~((1 << rbcnt) - 1);

		stda(soffs, ASI_BYPASS, rop | wmask);

		cnt -= (32 - lbcnt) - rbcnt;
		soffs += 32 << 3;
d861 2
a862 4
		/* further loops are aligned */
		lbcnt = 0;
		wmask = 0xffffffff;
	}
@


1.34
log
@When switching between 8 bit and 24 bit modes on S24, use the blitter
whenever possible to speed things up. Also, do not map the control space
anymore and access in through physical addresses, as done for the
blitter and stipple spaces; saves another 4MB of KVM on S24.
@
text
@d195 1
a195 1
	printf(" pri %d", pri);
d201 1
a201 1
		printf(": expected %d registers, got %d\n",
d206 4
d263 4
d281 14
a294 1
	fbwscons_init(&sc->sc_sunfb, isconsole ? 0 : RI_CLEAR);
d315 2
a316 1
		fbwscons_console_init(&sc->sc_sunfb, -1);
a318 10

	nam = getpropstring(node, "model");
	if (*nam != '\0')
		printf(": %s\n%s", nam, self->dv_xname);
	printf(": %dx%d, id %d, rev %d, sense %d\n",
	    sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height,
	    (sc->sc_thc->thc_config & THC_CFG_FBID) >> THC_CFG_FBID_SHIFT,
	    (sc->sc_thc->thc_config & THC_CFG_REV) >> THC_CFG_REV_SHIFT,
	    (sc->sc_thc->thc_config & THC_CFG_SENSE) >> THC_CFG_SENSE_SHIFT
	);
@


1.33
log
@Basic acceleration code for tcx: solid fills and some simple block copy cases.
Makes it noticeably faster, especially when scrolling on console.

Tested on SS4 (tcx) and SS5 (S24) in 1152x900 and 1024x768 modes.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.31 2008/06/26 05:42:13 ray Exp $	*/
d94 1
a94 1
	volatile u_int32_t *sc_cplane;	/* S24 control plane */
d119 1
d252 2
a253 2
	if (node_has_property(node, "tcx-8-bit") ||
	    ca->ca_ra.ra_reg[TCX_REG_RDFB32].rr_len <
d255 2
a256 4
		sc->sc_cplane = NULL;
	} else {
		sc->sc_cplane = mapiodev(&ca->ca_ra.ra_reg[TCX_REG_RDFB32], 0,
		    round_page(sc->sc_sunfb.sf_fbsize * 4));
d333 1
a333 1
		wdf->cmsize = sc->sc_cplane == NULL ? 256 : 0;
d336 1
a336 1
		if (sc->sc_cplane != NULL)
d342 1
a342 1
		if (sc->sc_cplane == NULL)
d349 1
a349 1
		if (sc->sc_cplane == NULL) {
d357 1
a357 1
		if (sc->sc_cplane == NULL) {
d372 1
a372 1
			if (sc->sc_cplane != NULL)
d405 2
a406 18
		if (sc->sc_cplane != NULL) {
			volatile u_int32_t *cptr;
			u_int32_t pixel;
			int ramsize;

			cptr = sc->sc_cplane;
			ramsize = sc->sc_sunfb.sf_fbsize;

			if (depth == 8) {
				while (ramsize-- != 0) {
					pixel = (*cptr & TCX_CTL_PIXELMASK);
					*cptr++ = pixel | TCX_CTL_8_MAPPED;
				}
			} else {
				while (ramsize-- != 0) {
					*cptr++ = TCX_CTL_24_LEVEL;
				}
			}
d521 47
d615 1
a615 1
		regno = sc->sc_cplane == NULL ? TCX_REG_BLIT : TCX_REG_RBLIT;
d621 1
a621 1
	regno = sc->sc_cplane == NULL ? TCX_REG_STIP : TCX_REG_RSTIP;
@


1.32
log
@No need to keep the 32 bit space mapped, since it is only used by userland
and through mmap; also shrink the softc of about 120 bytes by not keeping a
copy of all prom regions when only two of them are needed.

While there, map THC at the preferred address on S24 flavours, and do not
reprogram the control bits on S24 at attach time (since the prom has already
done this for us).

Tested on ss4 and ss5+S24.
@
text
@d5 1
a5 1
 * Copyright (c) 2002, 2003 Miodrag Vallat.  All rights reserved.
d72 2
d97 6
d105 2
d108 4
d117 1
d120 1
a120 1
void	tcx_prom(void *);
d168 1
a168 1
#define	TCX_CTL_24_LEVEL	0x03000000	/* 24 bits, true color */
d260 5
d277 13
d535 266
@


1.31
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.30 2007/03/13 19:40:48 miod Exp $	*/
d58 1
a58 1
 * color display (TCX) driver.
a62 1
#include <sys/buf.h>
a63 4
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/mman.h>
#include <sys/tty.h>
d87 7
a93 8
	struct	sunfb sc_sunfb;			/* common base part */
	struct	rom_reg sc_phys[TCX_NREG];	/* phys addr of h/w */
	volatile struct bt_regs *sc_bt;		/* Brooktree registers */
	volatile struct tcx_thc *sc_thc;	/* THC registers */
	volatile u_int8_t *sc_dfb8;		/* 8 bit plane */
	volatile u_int32_t *sc_dfb24;		/* S24 24 bit plane */
	volatile u_int32_t *sc_cplane;		/* S24 control plane */
	union	bt_cmap sc_cmap;		/* Brooktree color map */
d123 1
a123 1
struct cfattach tcx_ca = {
d136 1
d139 1
d142 2
d147 3
d173 1
a173 1
	int node, pri, i;
d176 1
d182 1
d190 5
a194 3
	/* Copy register address spaces */
	for (i = 0; i < TCX_NREG; i++)
		sc->sc_phys[i] = ca->ca_ra.ra_reg[i];
d196 5
d203 11
d216 1
a216 1
	        0x1000, sizeof *sc->sc_thc);
d218 8
a225 1
	isconsole = node == fbnode;
d227 12
a238 5
	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, ca->ca_bustype);
	if (node_has_property(node, "tcx-8-bit")) {
		sc->sc_dfb8 = mapiodev(&ca->ca_ra.ra_reg[TCX_REG_DFB8], 0,
		    round_page(sc->sc_sunfb.sf_fbsize));
		sc->sc_dfb24 = NULL;
a240 6
		sc->sc_dfb8 = mapiodev(&ca->ca_ra.ra_reg[TCX_REG_DFB8], 0,
		    round_page(sc->sc_sunfb.sf_fbsize));

		/* map the 24 bit and control planes for S24 framebuffers */
		sc->sc_dfb24 = mapiodev(&ca->ca_ra.ra_reg[TCX_REG_DFB24], 0,
		    round_page(sc->sc_sunfb.sf_fbsize * 4));
a245 1
	sc->sc_sunfb.sf_depth = 0;	/* force action */
d247 1
d445 1
d452 1
a452 1
		return (REG2PHYS(&sc->sc_phys[TCX_REG_DFB8], offset) | PMAP_NC);
d455 3
a457 2
		return (REG2PHYS(&sc->sc_phys[TCX_REG_DFB24], offset) |
		    PMAP_NC);
d459 1
a459 1
	return (-1);
@


1.30
log
@When about to run X11 in 32 bpp mode, advertize correctly that we are
really using 24 bpp pixels on 32 bit boundaries.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.29 2007/02/18 18:40:35 miod Exp $	*/
a42 7
 *  3. All advertising materials mentioning features or use of this software
 *     must display the following acknowledgement:
 *         This product includes software developed by the NetBSD
 *         Foundation, Inc. and its contributors.
 *  4. Neither the name of The NetBSD Foundation nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
@


1.29
log
@Display the interrupt priority in dmesg, for frame buffers which register
interrupt handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.28 2006/07/25 21:23:30 miod Exp $	*/
d280 6
@


1.28
log
@Do not bother reading the existing colormap on attach, since we will
override it with the rasops one.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.27 2006/06/02 20:00:54 miod Exp $	*/
d179 1
a179 1
	int node = 0, i;
d183 3
d237 1
a237 2
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih, IPL_FB,
	    self->dv_xname);
@


1.27
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.26 2005/12/25 21:47:15 miod Exp $	*/
a179 1
	volatile struct bt_regs *bt;
d195 1
a195 1
	sc->sc_bt = bt = (volatile struct bt_regs *)
a222 5

	/* grab initial (current) color map */
	bt->bt_addr = 0;
	for (i = 0; i < 256 * 3; i++)
		((char *)&sc->sc_cmap)[i] = bt->bt_cmap >> 24;
@


1.26
log
@Return proper frame buffer type rather than generic SUN24 id, Xwsfb has known
the proper id for a long time already...
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.25 2005/03/23 17:16:34 miod Exp $	*/
a99 1
	struct	sbusdev sc_sd;			/* sbus device */
a246 2

	sbus_establish(&sc->sc_sd, &sc->sc_sunfb.sf_dev);
@


1.25
log
@Move the alloc_screen, free_screen and show_screen wsdisplay accessops to
the common frame buffer code, rather than duplicating it in every driver.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.24 2005/03/13 23:05:22 miod Exp $	*/
d279 1
a279 4
		if (sc->sc_cplane == NULL)
			*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
		else
			*(u_int *)data = WSDISPLAY_TYPE_SUN24;
@


1.24
log
@Add missed WSDISPLAYIO_[GS]VIDEO ioctl handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.23 2005/03/07 16:44:50 miod Exp $	*/
a86 1
#include <dev/wscons/wscons_raster.h>
a108 1
	int	sc_nscreens;
d111 9
a119 13
int tcx_ioctl(void *, u_long, caddr_t, int, struct proc *);
int tcx_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void tcx_free_screen(void *, void *);
int tcx_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t tcx_mmap(void *, off_t, int);
void tcx_reset(struct tcx_softc *, int);
void tcx_burner(void *, u_int, u_int);
void tcx_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
static __inline__ void tcx_loadcmap_deferred(struct tcx_softc *, u_int, u_int);
int tcx_intr(void *);
void tcx_prom(void *);
d124 3
a126 3
	tcx_alloc_screen,
	tcx_free_screen,
	tcx_show_screen,
d131 1
d134 2
a135 2
int tcxmatch(struct device *, void *, void *);
void tcxattach(struct device *, struct device *, void *);
a162 3
/*
 * Match a tcx.
 */
d164 1
a164 3
tcxmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
a174 3
/*
 * Attach a display.
 */
d176 1
a176 3
tcxattach(parent, self, args)
	struct device *parent, *self;
	void *args;
d265 1
a265 6
tcx_ioctl(dev, cmd, data, flags, p)
	void *dev;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
a337 3
/*
 * Clean up hardware state (e.g., after bootup or after X crashes).
 */
d339 1
a339 3
tcx_reset(sc, depth)
	struct tcx_softc *sc;
	int depth;
d383 1
a383 2
tcx_prom(v)
	void *v;
d390 2
a391 2
	 	* Select 8-bit mode.
	 	*/
d395 3
a397 3
	 	* Go back to prom output for the last few messages, so they
	 	* will be displayed correctly.
	 	*/
d403 1
a403 3
tcx_burner(v, on, flags)
	void *v;
	u_int on, flags;
a422 4
/*
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
 */
d424 1
a424 4
tcx_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
d439 1
a439 1
	return (-1);	/* not a user-map offset */
d443 1
a443 4
tcx_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
	u_int8_t r, g, b;
a449 43
int
tcx_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
{
	struct tcx_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	sc->sc_nscreens++;
	return (0);
}

void
tcx_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct tcx_softc *sc = v;

	sc->sc_nscreens--;
}

int
tcx_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
	return (0);
}

d461 1
a461 2
tcx_intr(v)
	void *v;
@


1.23
log
@Do not bother passing the blanking routine to fbwscons_console_init(),
as fbwscons_attach() can find it on its own.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.22 2005/03/07 01:28:45 miod Exp $	*/
d345 4
@


1.22
log
@Shorten dmesg on ss4.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.21 2004/11/29 22:07:37 miod Exp $	*/
d260 1
a260 1
		fbwscons_console_init(&sc->sc_sunfb, -1, tcx_burner);
@


1.21
log
@Move the struct wsscreen_descr from a per-driver global to a per-instance
field of the sunfb structure. This allows multiple instances of the same driver,
but with different resolutions (such as a couple of vigra or a TGX cgsix and
a TGX+ cgsix) to use distinct wsscreen_descr structures featuring different
resolution information.

Doing this allows more wsscreen_descr fiddling inside the sparc* fb api,
and results in some code shrinkage (about 4KB on sparc GENERIC).
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.20 2004/09/29 07:35:11 miod Exp $	*/
a200 2
	nam = getpropstring(node, "model");
	printf(": %s\n", nam);
d203 2
a204 2
		printf("\n%s: expected %d registers, got %d\n",
		    self->dv_xname, TCX_NREG, ca->ca_ra.ra_nreg);
d266 5
a270 2
	printf("%s: %dx%d, id %d, rev %d, sense %d\n",
	    self->dv_xname, sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height,
@


1.20
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.19 2003/06/28 17:05:33 miod Exp $	*/
a112 12
struct wsscreen_descr tcx_stdscreen = {
	"std",
};

const struct wsscreen_descr *tcx_scrlist[] = {
	&tcx_stdscreen,
};

struct wsscreen_list tcx_screenlist = {
	sizeof(tcx_scrlist) / sizeof(struct wsscreen_descr *), tcx_scrlist
};

a194 1
	struct wsemuldisplaydev_attach_args waa;
a255 5
	tcx_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	tcx_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	tcx_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	tcx_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

d262 1
a262 2
		fbwscons_console_init(&sc->sc_sunfb, &tcx_stdscreen, -1,
		    tcx_burner);
d275 1
a275 5
	waa.console = isconsole;
	waa.scrdata = &tcx_screenlist;
	waa.accessops = &tcx_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
@


1.19
log
@Sync sparc fb API with the sparc64 changes (fbwscons_init takes flags, and
the sunfb structure keeps pointer to the prom cursor coordinates).
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.18 2003/06/15 21:04:11 miod Exp $	*/
d276 2
a277 1
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih, IPL_FB);
@


1.18
log
@Fix the logic in the interrupt handler, and reenable colormap updates
triggered by the vertical retrace interrupt.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.17 2003/06/06 19:42:47 miod Exp $	*/
d266 1
a266 1
	fbwscons_init(&sc->sc_sunfb, isconsole);
@


1.17
log
@Do not bother taking care of the frame buffer flags in the softc, if the
driver does not use any. Basically this changes all drivers but those that
can handle a P4 card.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.16 2003/04/06 17:02:32 miod Exp $	*/
a65 3
 *
 * XXX Use of the vertical retrace interrupt to update the colormap is not
 * enabled by default, as it hangs the system on some machines.
a273 1
#if 0
a276 1
#endif
d340 6
a345 4
		cm = (struct wsdisplay_cmap *)data;
		error = bt_getcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
d348 7
a354 9
		cm = (struct wsdisplay_cmap *)data;
		error = bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
#if 0
		tcx_loadcmap_deferred(sc, cm->index, cm->count);
#else
		bt_loadcmap(&sc->sc_cmap, sc->sc_bt, cm->index, cm->count, 1);
#endif
a553 1
	thcm &= ~THC_MISC_RESET;
d566 7
a572 5
	if ((thcm & (THC_MISC_INTEN | THC_MISC_INTR)) !=
	    (THC_MISC_INTEN | THC_MISC_INTR)) {
		/* Not expecting an interrupt, it's not for us. */
		return (0);
	}
d574 2
a575 4
	/* Acknowledge the interrupt and disable it. */
	thcm &= ~(THC_MISC_RESET | THC_MISC_INTEN);
	thcm |= THC_MISC_INTR;
	sc->sc_thc->thc_hcmisc = thcm;
d577 2
a578 1
	bt_loadcmap(&sc->sc_cmap, sc->sc_bt, 0, 256, 1);
d580 1
a580 1
	return (1);
@


1.16
log
@Run the console in the overlay plane, or in low-depth mode, as appropriate,
and do not switch to high-depth mode until the appropriate ioctls are
issued. This lets us benefit from true color X11, with a faster text console.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.15 2002/12/10 20:32:57 miod Exp $	*/
a215 2
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags & FB_USERMASK;

d277 5
a281 6
	if (ISSET(sc->sc_sunfb.sf_flags, TCX_INTR)) {
		sc->sc_ih.ih_fun = tcx_intr;
		sc->sc_ih.ih_arg = sc;
		intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih,
		    IPL_FB);
	}
d355 5
a359 6
		if (ISSET(sc->sc_sunfb.sf_flags, TCX_INTR)) {
			tcx_loadcmap_deferred(sc, cm->index, cm->count);
		} else {
			bt_loadcmap(&sc->sc_cmap, sc->sc_bt,
			    cm->index, cm->count, 1);
		}
@


1.15
log
@The introduction of fbwscons_setcolormap() left out 24 bit frame buffers
operating in 8 bit mode, such as on the installation media...
Installing with a pale grey on white is not what I would call a friendly
display, ouch.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.14 2002/11/06 21:06:20 miod Exp $	*/
d5 1
a5 1
 * Copyright (c) 2002 Miodrag Vallat.  All rights reserved.
d108 2
a121 1
	/* XXX other formats? */
d135 1
a135 1
void tcx_reset(struct tcx_softc *);
d194 1
a194 1
	if (strcmp(ra->ra_name, "SUNW,tcx"))
d197 1
a197 4
	if (ca->ca_bustype == BUS_SBUS)
		return (1);

	return (0);
d211 1
a211 1
	int fb_depth, node = 0, i;
d218 9
a226 3
	if (ca->ca_ra.ra_nreg < TCX_NREG)
		panic("tcx: expected %d registers, got %d", TCX_NREG,
		    ca->ca_ra.ra_nreg);
d238 1
a238 5
	switch (ca->ca_bustype) {
	case BUS_SBUS:
		node = ca->ca_ra.ra_node;
		nam = getpropstring(node, "model");
		break;
d240 9
a248 4
	default:
		printf("TCX on bus 0x%x?\n", ca->ca_bustype);
		return;
	}
d250 5
a254 19
	printf(": %s\n", nam);

	isconsole = node == fbnode;

	if (ISSET(sc->sc_sunfb.sf_flags, FB_FORCELOW))
		fb_depth = 8;
	else
		fb_depth = node_has_property(node, "tcx-8-bit") ?  8 : 32;

	fb_setsize(&sc->sc_sunfb, fb_depth, 1152, 900, node, ca->ca_bustype);

	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(&ca->ca_ra.ra_reg[
	    sc->sc_sunfb.sf_depth == 8 ? TCX_REG_DFB8 : TCX_REG_DFB24],
	    0, round_page(sc->sc_sunfb.sf_fbsize));
	
	/* map the control plane for S24 framebuffers */
	if (sc->sc_sunfb.sf_depth != 8) {
		sc->sc_cplane = mapiodev(&ca->ca_ra.ra_reg[TCX_REG_RDFB32],
		    0, round_page(sc->sc_sunfb.sf_fbsize));
d258 2
a259 1
	tcx_reset(sc);
d270 1
d321 5
d328 4
a331 1
		*(u_int *)data = WSDISPLAY_TYPE_SUN24;
d338 1
a338 1
		wdf->cmsize = (sc->sc_sunfb.sf_depth == 8) ? 256 : 0;
d341 4
a344 1
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
d348 15
a362 5
		if (sc->sc_sunfb.sf_depth == 8) {
			cm = (struct wsdisplay_cmap *)data;
			error = bt_getcmap(&sc->sc_cmap, cm);
			if (error)
				return (error);
d365 9
a373 12
	case WSDISPLAYIO_PUTCMAP:
		if (sc->sc_sunfb.sf_depth == 8) {
			cm = (struct wsdisplay_cmap *)data;
			error = bt_putcmap(&sc->sc_cmap, cm);
			if (error)
				return (error);
			if (ISSET(sc->sc_sunfb.sf_flags, TCX_INTR)) {
				tcx_loadcmap_deferred(sc, cm->index, cm->count);
			} else {
				bt_loadcmap(&sc->sc_cmap, sc->sc_bt,
				    cm->index, cm->count, 1);
			}
a376 7
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
d388 1
a388 1
tcx_reset(sc)
d390 1
d403 1
a403 1
	 * Select 24-bit mode if appropriate.
d405 19
a423 19
	if (sc->sc_sunfb.sf_depth != 8) {
		volatile u_int32_t *cptr;
		u_int32_t pixel;
		int ramsize;

		ramsize = sc->sc_sunfb.sf_fbsize / sizeof(u_int32_t);
		cptr = sc->sc_cplane;

		/*
		 * Since the prom output so far has only been white (0)
		 * or black (255), we can promote the 8 bit plane contents
		 * to full color.
		 * Of course, the 24 bit plane uses 0 for black, so a
		 * reversal is necessary. Blame Sun.
		 */
		while (ramsize-- != 0) {
			pixel = 255 - ((*cptr & TCX_CTL_PIXELMASK) & 0xff);
			pixel = (pixel << 16) | (pixel << 8) | pixel;
			*cptr++ = pixel | TCX_CTL_24_LEVEL;
d426 2
a427 1
		shutdownhook_establish(tcx_prom, sc);
d429 2
a439 3
	/*
	 * Select 8-bit mode.
	 */
d441 10
a450 11
		volatile u_int32_t *cptr;
		u_int32_t pixel;
		int ramsize;

		ramsize = sc->sc_sunfb.sf_fbsize / sizeof(u_int32_t);
		cptr = sc->sc_cplane;

		while (ramsize-- != 0) {
			pixel = (*cptr & TCX_CTL_PIXELMASK);
			*cptr++ = pixel | TCX_CTL_8_MAPPED;
		}
a451 6

	/*
	 * Go back to prom output for the last few messages, so they
	 * will be displayed correctly.
	 */
	cn_tab = &consdev_prom;
a487 1
	int reg;
d489 1
a489 1
	if (offset & PGOFSET)
d493 6
a498 5
	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		reg = (sc->sc_sunfb.sf_depth == 8) ?
		    TCX_REG_DFB8 : TCX_REG_DFB24;
		return (REG2PHYS(&sc->sc_phys[reg], offset) | PMAP_NC);
	}
d530 2
a531 7
	if (sc->sc_sunfb.sf_depth == 8) {
		sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
		    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	} else {
		sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
		    0, 0, 0, attrp);
	}
@


1.14
log
@- always initialize colormaps, even if the frame buffer is non console; this
  helps if the ramdac does not get initialized (idea from jason@@)
- only register a shutdown hook for the frame buffers which need it, if this
  is the console frame buffer. Otherwise this is just a waste of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.13 2002/10/12 01:09:43 krw Exp $	*/
d279 1
@


1.13
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.12 2002/10/01 20:55:14 miod Exp $	*/
d294 2
a295 1
		    tcx_setcolor, tcx_burner);
d300 1
a300 1
	printf("%s: %dx%d, depth %d, id %d, rev %d, sense %d\n",
a301 1
	    sc->sc_sunfb.sf_depth,
@


1.12
log
@Do not enable the code that makes use of the vertical retrace interrupt
to update the colormap, as it causes _some_ machines to freeze solid;
could not be reproduced here, thanks to Thomas Koellmann (koellmann
at gmx dot net) for reporting this problem and testing this change.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.11 2002/09/30 18:07:29 miod Exp $	*/
d221 1
a221 1
		panic("\ntcx: expected %d registers, got %d", TCX_NREG,
@


1.11
log
@Evil, evil, evil typo broke innocent ramdisks. Die!
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.10 2002/09/23 18:13:39 miod Exp $	*/
d66 3
d285 6
a290 3
	sc->sc_ih.ih_fun = tcx_intr;
	sc->sc_ih.ih_arg = sc;
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih, IPL_FB);
d356 6
a361 1
			tcx_loadcmap_deferred(sc, cm->index, cm->count);
@


1.10
log
@Get the wsdisplay capabilities from rasops, rather than attempting to
guess them at compile-time. Plus this makes cgtwelve a bit more clean.

ok fgs@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.9 2002/09/20 11:17:56 fgsch Exp $	*/
d249 1
a249 1
		fb_depth = node_has_property(node, "tcx-8-bit") ?  8 : 32,
@


1.9
log
@Support to run the 24 bit fb in 8 bit mode or cg12 in 1 bit mode
via flags, using 0x0001.
miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.7 2002/08/12 10:44:04 miod Exp $	*/
a112 5
	0, 0,	/* will be filled in */
	0,
	0, 0,
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
	WSSCREEN_REVERSE | WSSCREEN_WSCOLORS
d277 1
@


1.8
log
@Register more screen capabilities to work with the recent wsemul_sun changes.
@
text
@a97 8
/*
 * Define TCX_LOWDEPTH to only use the 8 bit color mode of the S24, for faster
 * console output.
 */
#ifdef	SMALL_KERNEL
#define	TCX_LOWDEPTH
#endif

a191 1
	struct cfdata *cf = vcf;
a194 5
	/*
	 * Mask out invalid flags from the user.
	 */
	cf->cf_flags &= FB_USERMASK;

d215 1
a215 1
	int node = 0, i;
d220 1
a220 1
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;
d251 6
a256 6
#ifdef TCX_LOWDEPTH
	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, ca->ca_bustype);
#else
	fb_setsize(&sc->sc_sunfb, node_has_property(node, "tcx-8-bit") ?
	    8 : 32, 1152, 900, node, ca->ca_bustype);
#endif
@


1.7
log
@Convert sparc console code from rcons and pseudo-devices to rasops and wscons.
For most framebuffers it is faster.

Other changes include:
o 24 bit support in tcx(4) for the S24 framebuffer
o accelerated cgsix(4) text console
o new cgtwelve(4) driver for the GS framebuffer
o improved serial driver code
o better keyboard support

The following framebuffers have not been tested but should work: cgfour,
cgeight and cgfourteen

These changes will require XF4 changes, to use Xwsfb instead of Xsun*, to be
commited later today.

Most of the work by me during the LSM and the week after, with code borrowed
from jason@@, NetBSD (new serial code), and feedback from mickey@@. Work on
pnozz(4) done by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.6 2002/03/14 01:26:43 millert Exp $	*/
d124 1
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.5 2001/11/06 19:53:16 miod Exp $	*/
d4 25
a28 1
/* 
d31 1
a31 1
 * 
d34 1
a34 1
 * 
d50 1
a50 1
 * 
d62 1
a62 1
 */ 
a65 4
 *
 * Does not handle interrupts, even though they can occur.
 *
 * XXX should defer colormap updates to vertical retrace interrupts
a71 1
#include <machine/fbio.h>
a77 5
#ifdef DEBUG
#include <sys/proc.h>
#include <sys/syslog.h>
#endif

a81 1
#include <machine/fbvar.h>
d85 6
d96 1
a96 5
#if 0
union cursor_cmap {		/* colormap, like bt_cmap, but tiny */
	u_char	cm_map[2][3];	/* 2 R/G/B entries */
	u_int	cm_chip[2];	/* 2 chip equivalents */
};
d98 6
a103 8
struct tcx_cursor {		/* tcx hardware cursor status */
	short	cc_enable;		/* cursor is enabled */
	struct	fbcurpos cc_pos;	/* position */
	struct	fbcurpos cc_hot;	/* hot-spot */
	struct	fbcurpos cc_size;	/* size of mask & image fields */
	u_int	cc_bits[2][32];		/* space for mask & image bits */
	union	cursor_cmap cc_color;	/* cursor colormap */
};
d108 3
a110 5
	struct	device sc_dev;		/* base device */
	struct	sbusdev sc_sd;		/* sbus device */
	struct	fbdevice sc_fb;		/* frame buffer device */
	struct	rom_reg sc_physadr[TCX_NREG];	/* phys addr of h/w */
	int	sc_bustype;		/* type of bus we live on */
d113 47
a159 2
	short	sc_blanked;		/* true if blanked */
	union	bt_cmap sc_cmap;	/* Brooktree color map */
d162 2
a163 4
/* autoconfiguration driver */
static void	tcxattach(struct device *, struct device *, void *);
static int	tcxmatch(struct device *, void *, void *);
static void	tcx_unblank(struct device *);
d173 17
a189 4
/* frame buffer generic driver */
static struct fbdriver tcx_fbdriver = {
	tcx_unblank, tcxopen, tcxclose, tcxioctl, tcxmmap
};
a190 6
extern int fbnode;

static void tcx_reset(struct tcx_softc *);
static void tcx_loadcmap(struct tcx_softc *, int, int);

#define OBPNAME	"SUNW,tcx"
a202 3
	if (strcmp(ra->ra_name, OBPNAME))
		return (0);

d208 3
d225 13
a237 21
	register struct tcx_softc *sc = (struct tcx_softc *)self;
	register struct confargs *ca = args;
	register int node = 0, ramsize, i;
	register volatile struct bt_regs *bt;
	struct fbdevice *fb = &sc->sc_fb;
	int isconsole = 0, sbus = 1;
	extern struct tty *fbconstty;

	fb->fb_driver = &tcx_fbdriver;
	fb->fb_device = &sc->sc_dev;
	fb->fb_flags = sc->sc_dev.dv_cfdata->cf_flags;

	/*
	 * XXX - should be set to FBTYPE_TCX.
	 * XXX For CG3 emulation to work in current (96/6) X11 servers,
	 * XXX `fbtype' must point to an "unregocnised" entry.
	 */
	fb->fb_type.fb_type = FBTYPE_RESERVED3;

	if (ca->ca_ra.ra_nreg != TCX_NREG)
		panic("tcx: oops");
d241 1
a241 5
		sc->sc_physadr[i] = ca->ca_ra.ra_reg[i];

	/* XXX - fix THC and TEC offsets */
	sc->sc_physadr[TCX_REG_TEC].rr_paddr += 0x1000;
	sc->sc_physadr[TCX_REG_THC].rr_paddr += 0x1000;
d244 1
a244 1
		mapiodev(&ca->ca_ra.ra_reg[TCX_REG_CMAP], 0, sizeof *sc->sc_bt);
d246 2
a247 1
		mapiodev(&ca->ca_ra.ra_reg[TCX_REG_THC], 0, sizeof *sc->sc_thc);
d252 1
a254 1
	case BUS_OBIO:
d260 20
a279 23
	fb->fb_type.fb_depth = node_has_property(node, "tcx-24-bit")
		? 24
		: (node_has_property(node, "tcx-8-bit")
			? 8
			: 8);

	fb_setsize(fb, fb->fb_type.fb_depth, 1152, 900,
		   node, ca->ca_bustype);

	ramsize = fb->fb_type.fb_height * fb->fb_linebytes;
	fb->fb_type.fb_cmsize = 256;
	fb->fb_type.fb_size = ramsize;
	printf(": %s, %d x %d", OBPNAME,
		fb->fb_type.fb_width,
		fb->fb_type.fb_height);

	isconsole = node == fbnode && fbconstty != NULL;

	printf(", id %d, rev %d, sense %d",
		(sc->sc_thc->thc_config & THC_CFG_FBID) >> THC_CFG_FBID_SHIFT,
		(sc->sc_thc->thc_config & THC_CFG_REV) >> THC_CFG_REV_SHIFT,
		(sc->sc_thc->thc_config & THC_CFG_SENSE) >> THC_CFG_SENSE_SHIFT
	);
d284 1
a284 1
	/* grab initial (current) color map (DOES THIS WORK?) */
d290 12
a301 1
	sc->sc_thc->thc_hcmisc |= THC_MISC_VIDEN;
d304 3
a306 9
		printf(" (console)\n");
	} else
		printf("\n");

	if (sbus)
		sbus_establish(&sc->sc_sd, &sc->sc_dev);
	if (node == fbnode)
		fb_attach(&sc->sc_fb, isconsole);
}
d308 1
a308 7
int
tcxopen(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	int unit = minor(dev);
d310 7
a316 12
	if (unit >= tcx_cd.cd_ndevs || tcx_cd.cd_devs[unit] == NULL)
		return (ENXIO);
	return (0);
}

int
tcxclose(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	struct tcx_softc *sc = tcx_cd.cd_devs[minor(dev)];
d318 5
a322 2
	tcx_reset(sc);
	return (0);
d326 2
a327 2
tcxioctl(dev, cmd, data, flags, p)
	dev_t dev;
d329 1
a329 1
	register caddr_t data;
d333 3
a335 1
	register struct tcx_softc *sc = tcx_cd.cd_devs[minor(dev)];
d339 2
a340 3

	case FBIOGTYPE:
		*(struct fbtype *)data = sc->sc_fb.fb_type;
d342 6
a347 13

	case FBIOGATTR:
#define fba ((struct fbgattr *)data)
		fba->real_type = sc->sc_fb.fb_type.fb_type;
		fba->owner = 0;		/* XXX ??? */
		fba->fbtype = sc->sc_fb.fb_type;
		fba->sattr.flags = 0;
		fba->sattr.emu_type = sc->sc_fb.fb_type.fb_type;
		fba->sattr.dev_specific[0] = -1;
		fba->emu_types[0] = sc->sc_fb.fb_type.fb_type;
		fba->emu_types[1] = FBTYPE_SUN3COLOR;
		fba->emu_types[2] = -1;
#undef fba
d349 2
a350 14

	case FBIOGETCMAP:
		return (bt_getcmap((struct fbcmap *)data, &sc->sc_cmap, 256));

	case FBIOPUTCMAP:
		/* copy to software map */
#define	p ((struct fbcmap *)data)
		error = bt_putcmap(p, &sc->sc_cmap, 256);
		if (error)
			return (error);
		/* now blast them into the chip */
		/* XXX should use retrace interrupt */
		tcx_loadcmap(sc, p->index, p->count);
#undef p
d353 7
a359 2
	case FBIOGVIDEO:
		*(int *)data = sc->sc_blanked;
d361 7
a367 10

	case FBIOSVIDEO:
		if (*(int *)data)
			tcx_unblank(&sc->sc_dev);
		else if (!sc->sc_blanked) {
			sc->sc_blanked = 1;
			sc->sc_thc->thc_hcmisc &= ~THC_MISC_VIDEN;
			/* Put monitor in `power-saving mode' */
			sc->sc_thc->thc_hcmisc |= THC_MISC_VSYNC_DISABLE;
			sc->sc_thc->thc_hcmisc |= THC_MISC_HSYNC_DISABLE;
d371 7
d379 1
a379 5
#ifdef DEBUG
		log(LOG_NOTICE, "tcxioctl(0x%lx) (%s[%d])\n", cmd,
		    p->p_comm, p->p_pid);
#endif
		return (ENOTTY);
d381 1
d388 1
a388 1
static void
d390 1
a390 1
	register struct tcx_softc *sc;
d392 4
a395 1
	register volatile struct bt_regs *bt;
d401 27
d430 6
a435 11
/*
 * Load a subset of the current (new) colormap into the color DAC.
 */
static void
tcx_loadcmap(sc, start, ncolors)
	register struct tcx_softc *sc;
	register int start, ncolors;
{
	register volatile struct bt_regs *bt;
	register u_int *ip, i;
	register int count;
d437 15
a451 11
	ip = &sc->sc_cmap.cm_chip[BT_D4M3(start)];	/* start/4 * 3 */
	count = BT_D4M3(start + ncolors - 1) - BT_D4M3(start) + 3;
	bt = sc->sc_bt;
	bt->bt_addr = BT_D4M4(start) << 24;
	while (--count >= 0) {
		i = *ip++;
		/* hardware that makes one want to pound boards with hammers */
		bt->bt_cmap = i;
		bt->bt_cmap = i << 8;
		bt->bt_cmap = i << 16;
		bt->bt_cmap = i << 24;
d453 6
d461 18
a478 11
static void
tcx_unblank(dev)
	struct device *dev;
{
	struct tcx_softc *sc = (struct tcx_softc *)dev;

	if (sc->sc_blanked) {
		sc->sc_blanked = 0;
		sc->sc_thc->thc_hcmisc &= ~THC_MISC_VSYNC_DISABLE;
		sc->sc_thc->thc_hcmisc &= ~THC_MISC_HSYNC_DISABLE;
		sc->sc_thc->thc_hcmisc |= THC_MISC_VIDEN;
d480 2
a484 26
 * Base addresses at which users can mmap() the various pieces of a tcx.
 */
#define	TCX_USER_RAM	0x00000000
#define	TCX_USER_RAM24	0x01000000
#define	TCX_USER_RAM_COMPAT	0x04000000	/* cg3 emulation */
#define	TCX_USER_STIP	0x10000000
#define	TCX_USER_BLIT	0x20000000
#define	TCX_USER_RDFB32	0x28000000
#define	TCX_USER_RSTIP	0x30000000
#define	TCX_USER_RBLIT	0x38000000
#define	TCX_USER_TEC	0x70001000
#define	TCX_USER_BTREGS	0x70002000
#define	TCX_USER_THC	0x70004000
#define	TCX_USER_DHC	0x70008000
#define	TCX_USER_ALT	0x7000a000
#define	TCX_USER_UART	0x7000c000
#define	TCX_USER_VRT	0x7000e000
#define	TCX_USER_ROM	0x70010000

struct mmo {
	u_int	mo_uaddr;	/* user (virtual) address */
	u_int	mo_size;	/* size, or 0 for video ram size */
	u_int	mo_bank;	/* register bank number */
};

/*
a486 2
 *
 * XXX	needs testing against `demanding' applications (e.g., aviator)
d489 3
a491 3
tcxmmap(dev, off, prot)
	dev_t dev;
	off_t off;
d494 2
a495 21
	register struct tcx_softc *sc = tcx_cd.cd_devs[minor(dev)];
	register struct mmo *mo;
	register u_int u, sz;
	static struct mmo mmo[] = {
		{ TCX_USER_RAM, 0, TCX_REG_DFB8 },
		{ TCX_USER_RAM24, 0, TCX_REG_DFB24 },
		{ TCX_USER_RAM_COMPAT, 0, TCX_REG_DFB8 },

		{ TCX_USER_STIP, 1, TCX_REG_STIP },
		{ TCX_USER_BLIT, 1, TCX_REG_BLIT },
		{ TCX_USER_RDFB32, 1, TCX_REG_RDFB32 },
		{ TCX_USER_RSTIP, 1, TCX_REG_RSTIP },
		{ TCX_USER_RBLIT, 1, TCX_REG_RBLIT },
		{ TCX_USER_TEC, 1, TCX_REG_TEC },
		{ TCX_USER_BTREGS, 8192 /* XXX */, TCX_REG_CMAP },
		{ TCX_USER_THC, sizeof(struct tcx_thc), TCX_REG_THC },
		{ TCX_USER_DHC, 1, TCX_REG_DHC },
		{ TCX_USER_ALT, 1, TCX_REG_ALT },
		{ TCX_USER_ROM, 65536, TCX_REG_ROM },
	};
#define NMMO (sizeof mmo / sizeof *mmo)
d497 2
a498 2
	if (off & PGOFSET)
		panic("tcxmmap");
d500 33
a532 2
	if (off < 0)
		return (-1);
d534 9
a542 15
	/*
	 * Entries with size 0 map video RAM (i.e., the size in fb data).
	 *
	 * Since we work in pages, the fact that the map offset table's
	 * sizes are sometimes bizarre (e.g., 1) is effectively ignored:
	 * one byte is as good as one page.
	 */
	for (mo = mmo; mo < &mmo[NMMO]; mo++) {
		if ((u_int)off < mo->mo_uaddr)
			continue;
		u = off - mo->mo_uaddr;
		sz = mo->mo_size ? mo->mo_size : sc->sc_fb.fb_type.fb_size;
		if (u < sz)
			return (REG2PHYS(&sc->sc_physadr[mo->mo_bank], u) |
				PMAP_NC);
d544 48
a591 4
#ifdef DEBUG
	{
	  register struct proc *p = curproc;	/* XXX */
	  log(LOG_NOTICE, "tcxmmap(0x%x) (%s[%d])\n", off, p->p_comm, p->p_pid);
d593 9
a601 2
#endif
	return (-1);	/* not a user-map offset */
@


1.5
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.4 2001/11/01 12:13:46 art Exp $	*/
d107 3
a109 3
static void	tcxattach __P((struct device *, struct device *, void *));
static int	tcxmatch __P((struct device *, void *, void *));
static void	tcx_unblank __P((struct device *));
d126 2
a127 2
static void tcx_reset __P((struct tcx_softc *));
static void tcx_loadcmap __P((struct tcx_softc *, int, int));
@


1.5.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.5 2001/11/06 19:53:16 miod Exp $	*/
d107 3
a109 3
static void	tcxattach(struct device *, struct device *, void *);
static int	tcxmatch(struct device *, void *, void *);
static void	tcx_unblank(struct device *);
d126 2
a127 2
static void tcx_reset(struct tcx_softc *);
static void tcx_loadcmap(struct tcx_softc *, int, int);
@


1.5.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.5.2.1 2002/06/11 03:38:16 art Exp $	*/
d4 1
a4 25
/*
 * Copyright (c) 2002 Miodrag Vallat.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *
d7 1
a7 1
 *
d10 1
a10 1
 *
d26 1
a26 1
 *
d38 1
a38 1
 */
d43 3
a45 2
 * XXX Use of the vertical retrace interrupt to update the colormap is not
 * enabled by default, as it hangs the system on some machines.
d52 1
d59 5
d68 1
a71 6
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

d77 15
a91 1
#include <dev/cons.h>	/* for prom console hook */
d95 5
a99 3
	struct	sunfb sc_sunfb;			/* common base part */
	struct	sbusdev sc_sd;			/* sbus device */
	struct	rom_reg sc_phys[TCX_NREG];	/* phys addr of h/w */
d102 2
a103 4
	volatile u_int32_t *sc_cplane;		/* S24 control plane */
	union	bt_cmap sc_cmap;		/* Brooktree color map */
	struct	intrhand sc_ih;
	int	sc_nscreens;
d106 4
a109 41
struct wsscreen_descr tcx_stdscreen = {
	"std",
};

const struct wsscreen_descr *tcx_scrlist[] = {
	&tcx_stdscreen,
	/* XXX other formats? */
};

struct wsscreen_list tcx_screenlist = {
	sizeof(tcx_scrlist) / sizeof(struct wsscreen_descr *), tcx_scrlist
};

int tcx_ioctl(void *, u_long, caddr_t, int, struct proc *);
int tcx_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void tcx_free_screen(void *, void *);
int tcx_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t tcx_mmap(void *, off_t, int);
void tcx_reset(struct tcx_softc *);
void tcx_burner(void *, u_int, u_int);
void tcx_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
static __inline__ void tcx_loadcmap_deferred(struct tcx_softc *, u_int, u_int);
int tcx_intr(void *);
void tcx_prom(void *);

struct wsdisplay_accessops tcx_accessops = {
	tcx_ioctl,
	tcx_mmap,
	tcx_alloc_screen,
	tcx_free_screen,
	tcx_show_screen,
	NULL,   /* load_font */
	NULL,   /* scrollback */
	NULL,   /* getchar */
	tcx_burner,
};

int tcxmatch(struct device *, void *, void *);
void tcxattach(struct device *, struct device *, void *);
d119 9
a127 17
/*
 * There are three ways to access the framebuffer memory of the S24:
 * - 26 bits per pixel, in 32-bit words; the low-order 24 bits are blue,
 *   green and red values, and the other two bits select the display modes,
 *   per pixel.
 * - 24 bits per pixel, in 32-bit words; the high-order byte reads as zero,
 *   and is ignored on writes (so the mode bits can not be altered).
 * - 8 bits per pixel, unpadded; writes to this space do not modify the
 *   other 18 bits, which are hidden.
 *
 * The entry-level tcx found on the SPARCstation 4 can only provide the 8-bit
 * mode.
 */
#define	TCX_CTL_8_MAPPED	0x00000000	/* 8 bits, uses colormap */
#define	TCX_CTL_24_MAPPED	0x01000000	/* 24 bits, uses colormap */
#define	TCX_CTL_24_LEVEL	0x03000000	/* 24 bits, true color */
#define	TCX_CTL_PIXELMASK	0x00ffffff	/* mask for index/level */
d129 1
d138 1
d142 1
a142 1
	if (strcmp(ra->ra_name, "SUNW,tcx"))
d145 5
d164 21
a184 13
	struct tcx_softc *sc = (struct tcx_softc *)self;
	struct confargs *ca = args;
	struct wsemuldisplaydev_attach_args waa;
	int fb_depth, node = 0, i;
	volatile struct bt_regs *bt;
	int isconsole = 0;
	char *nam = NULL;

	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags & FB_USERMASK;

	if (ca->ca_ra.ra_nreg < TCX_NREG)
		panic("tcx: expected %d registers, got %d", TCX_NREG,
		    ca->ca_ra.ra_nreg);
d188 5
a192 1
		sc->sc_phys[i] = ca->ca_ra.ra_reg[i];
d195 1
a195 1
	    mapiodev(&ca->ca_ra.ra_reg[TCX_REG_CMAP], 0, sizeof *sc->sc_bt);
d197 1
a197 2
	    mapiodev(&ca->ca_ra.ra_reg[TCX_REG_THC],
	        0x1000, sizeof *sc->sc_thc);
a201 1
		nam = getpropstring(node, "model");
d204 1
d210 23
a232 20
	printf(": %s\n", nam);

	isconsole = node == fbnode;

	if (ISSET(sc->sc_sunfb.sf_flags, FB_FORCELOW))
		fb_depth = 8;
	else
		fb_depth = node_has_property(node, "tcx-8-bit") ?  8 : 32;

	fb_setsize(&sc->sc_sunfb, fb_depth, 1152, 900, node, ca->ca_bustype);

	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(&ca->ca_ra.ra_reg[
	    sc->sc_sunfb.sf_depth == 8 ? TCX_REG_DFB8 : TCX_REG_DFB24],
	    0, round_page(sc->sc_sunfb.sf_fbsize));
	
	/* map the control plane for S24 framebuffers */
	if (sc->sc_sunfb.sf_depth != 8) {
		sc->sc_cplane = mapiodev(&ca->ca_ra.ra_reg[TCX_REG_RDFB32],
		    0, round_page(sc->sc_sunfb.sf_fbsize));
	}
d237 1
a237 1
	/* grab initial (current) color map */
d243 1
a243 1
	tcx_burner(sc, 1, 0);
d245 10
a254 2
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, isconsole);
d256 7
a262 11
	tcx_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	tcx_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	tcx_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	tcx_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

	if (ISSET(sc->sc_sunfb.sf_flags, TCX_INTR)) {
		sc->sc_ih.ih_fun = tcx_intr;
		sc->sc_ih.ih_arg = sc;
		intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih,
		    IPL_FB);
	}
d264 4
a267 4
	if (isconsole) {
		fbwscons_console_init(&sc->sc_sunfb, &tcx_stdscreen, -1,
		    tcx_setcolor, tcx_burner);
	}
d269 7
a275 1
	sbus_establish(&sc->sc_sd, &sc->sc_sunfb.sf_dev);
d277 2
a278 13
	printf("%s: %dx%d, depth %d, id %d, rev %d, sense %d\n",
	    self->dv_xname, sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height,
	    sc->sc_sunfb.sf_depth,
	    (sc->sc_thc->thc_config & THC_CFG_FBID) >> THC_CFG_FBID_SHIFT,
	    (sc->sc_thc->thc_config & THC_CFG_REV) >> THC_CFG_REV_SHIFT,
	    (sc->sc_thc->thc_config & THC_CFG_SENSE) >> THC_CFG_SENSE_SHIFT
	);

	waa.console = isconsole;
	waa.scrdata = &tcx_screenlist;
	waa.accessops = &tcx_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
d282 2
a283 2
tcx_ioctl(dev, cmd, data, flags, p)
	void *dev;
d285 1
a285 1
	caddr_t data;
d289 1
a289 3
	struct tcx_softc *sc = dev;
	struct wsdisplay_cmap *cm;
	struct wsdisplay_fbinfo *wdf;
d293 3
a295 2
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_SUN24;
d297 13
a309 6
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width = sc->sc_sunfb.sf_width;
		wdf->depth = sc->sc_sunfb.sf_depth;
		wdf->cmsize = (sc->sc_sunfb.sf_depth == 8) ? 256 : 0;
d311 14
a324 2
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
d327 2
a328 7
	case WSDISPLAYIO_GETCMAP:
		if (sc->sc_sunfb.sf_depth == 8) {
			cm = (struct wsdisplay_cmap *)data;
			error = bt_getcmap(&sc->sc_cmap, cm);
			if (error)
				return (error);
		}
d330 10
a339 12
	case WSDISPLAYIO_PUTCMAP:
		if (sc->sc_sunfb.sf_depth == 8) {
			cm = (struct wsdisplay_cmap *)data;
			error = bt_putcmap(&sc->sc_cmap, cm);
			if (error)
				return (error);
			if (ISSET(sc->sc_sunfb.sf_flags, TCX_INTR)) {
				tcx_loadcmap_deferred(sc, cm->index, cm->count);
			} else {
				bt_loadcmap(&sc->sc_cmap, sc->sc_bt,
				    cm->index, cm->count, 1);
			}
a342 7
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
d344 5
a348 1
		return (-1);	/* not supported yet */
a349 1

d356 1
a356 1
void
d358 1
a358 1
	struct tcx_softc *sc;
d360 1
a360 4
	volatile struct bt_regs *bt;

	/* Hide the cursor, just in case */
	sc->sc_thc->thc_cursoraddr = THC_CURSOFF;
d366 1
d368 11
a378 23
	/*
	 * Select 24-bit mode if appropriate.
	 */
	if (sc->sc_sunfb.sf_depth != 8) {
		volatile u_int32_t *cptr;
		u_int32_t pixel;
		int ramsize;

		ramsize = sc->sc_sunfb.sf_fbsize / sizeof(u_int32_t);
		cptr = sc->sc_cplane;

		/*
		 * Since the prom output so far has only been white (0)
		 * or black (255), we can promote the 8 bit plane contents
		 * to full color.
		 * Of course, the 24 bit plane uses 0 for black, so a
		 * reversal is necessary. Blame Sun.
		 */
		while (ramsize-- != 0) {
			pixel = 255 - ((*cptr & TCX_CTL_PIXELMASK) & 0xff);
			pixel = (pixel << 16) | (pixel << 8) | pixel;
			*cptr++ = pixel | TCX_CTL_24_LEVEL;
		}
d380 11
a390 1
		shutdownhook_establish(tcx_prom, sc);
d394 11
a404 22
void
tcx_prom(v)
	void *v;
{
	struct tcx_softc *sc = v;
	extern struct consdev consdev_prom;

	/*
	 * Select 8-bit mode.
	 */
	if (sc->sc_sunfb.sf_depth != 8) {
		volatile u_int32_t *cptr;
		u_int32_t pixel;
		int ramsize;

		ramsize = sc->sc_sunfb.sf_fbsize / sizeof(u_int32_t);
		cptr = sc->sc_cplane;

		while (ramsize-- != 0) {
			pixel = (*cptr & TCX_CTL_PIXELMASK);
			*cptr++ = pixel | TCX_CTL_8_MAPPED;
		}
a405 6

	/*
	 * Go back to prom output for the last few messages, so they
	 * will be displayed correctly.
	 */
	cn_tab = &consdev_prom;
d408 25
a432 22
void
tcx_burner(v, on, flags)
	void *v;
	u_int on, flags;
{
	struct tcx_softc *sc = v;
	int s;
	u_int32_t thcm;

	s = splhigh();
	thcm = sc->sc_thc->thc_hcmisc;
	if (on) {
		thcm |= THC_MISC_VIDEN;
		thcm &= ~(THC_MISC_VSYNC_DISABLE | THC_MISC_HSYNC_DISABLE);
	} else {
		thcm &= ~THC_MISC_VIDEN;
		if (flags & WSDISPLAY_BURN_VBLANK)
			thcm |= THC_MISC_VSYNC_DISABLE | THC_MISC_HSYNC_DISABLE;
	}
	sc->sc_thc->thc_hcmisc = thcm;
	splx(s);
}
d437 2
d441 3
a443 3
tcx_mmap(v, offset, prot)
	void *v;
	off_t offset;
d446 21
a466 2
	struct tcx_softc *sc = v;
	int reg;
d468 4
a471 1
	if (offset & PGOFSET)
d474 20
a493 5
	/* Allow mapping as a dumb framebuffer from offset 0 */
	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		reg = (sc->sc_sunfb.sf_depth == 8) ?
		    TCX_REG_DFB8 : TCX_REG_DFB24;
		return (REG2PHYS(&sc->sc_phys[reg], offset) | PMAP_NC);
d495 1
a495 1

a496 94
}

void
tcx_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
	u_int8_t r, g, b;
{
	struct tcx_softc *sc = v;

	bt_setcolor(&sc->sc_cmap, sc->sc_bt, index, r, g, b, 1);
}

int
tcx_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
{
	struct tcx_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	if (sc->sc_sunfb.sf_depth == 8) {
		sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
		    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	} else {
		sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
		    0, 0, 0, attrp);
	}
	sc->sc_nscreens++;
	return (0);
}

void
tcx_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct tcx_softc *sc = v;

	sc->sc_nscreens--;
}

int
tcx_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
	return (0);
}

static __inline__ void
tcx_loadcmap_deferred(struct tcx_softc *sc, u_int start, u_int ncolors)
{
	u_int32_t thcm;

	thcm = sc->sc_thc->thc_hcmisc;
	thcm &= ~THC_MISC_RESET;
	thcm |= THC_MISC_INTEN;
	sc->sc_thc->thc_hcmisc = thcm;
}

int
tcx_intr(v)
	void *v;
{
	struct tcx_softc *sc = v;
	u_int32_t thcm;

	thcm = sc->sc_thc->thc_hcmisc;
	if ((thcm & (THC_MISC_INTEN | THC_MISC_INTR)) !=
	    (THC_MISC_INTEN | THC_MISC_INTR)) {
		/* Not expecting an interrupt, it's not for us. */
		return (0);
	}

	/* Acknowledge the interrupt and disable it. */
	thcm &= ~(THC_MISC_RESET | THC_MISC_INTEN);
	thcm |= THC_MISC_INTR;
	sc->sc_thc->thc_hcmisc = thcm;

	bt_loadcmap(&sc->sc_cmap, sc->sc_bt, 0, 256, 1);

	return (1);
@


1.5.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d5 1
a5 1
 * Copyright (c) 2002, 2003 Miodrag Vallat.  All rights reserved.
a107 2
	volatile u_int8_t *sc_dfb8;		/* 8 bit plane */
	volatile u_int32_t *sc_dfb24;		/* S24 24 bit plane */
d120 1
d134 1
a134 1
void tcx_reset(struct tcx_softc *, int);
d193 1
a193 1
	if (strcmp(ra->ra_name, "SUNW,tcx") != 0)
d196 4
a199 1
	return (1);
d213 1
a213 1
	int node = 0, i;
d220 3
a222 9
	node = ca->ca_ra.ra_node;
	nam = getpropstring(node, "model");
	printf(": %s\n", nam);

	if (ca->ca_ra.ra_nreg < TCX_NREG) {
		printf("\n%s: expected %d registers, got %d\n",
		    self->dv_xname, TCX_NREG, ca->ca_ra.ra_nreg);
		return;
	}
d234 13
d249 15
a263 15
	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, ca->ca_bustype);
	if (node_has_property(node, "tcx-8-bit")) {
		sc->sc_dfb8 = mapiodev(&ca->ca_ra.ra_reg[TCX_REG_DFB8], 0,
		    round_page(sc->sc_sunfb.sf_fbsize));
		sc->sc_dfb24 = NULL;
		sc->sc_cplane = NULL;
	} else {
		sc->sc_dfb8 = mapiodev(&ca->ca_ra.ra_reg[TCX_REG_DFB8], 0,
		    round_page(sc->sc_sunfb.sf_fbsize));

		/* map the 24 bit and control planes for S24 framebuffers */
		sc->sc_dfb24 = mapiodev(&ca->ca_ra.ra_reg[TCX_REG_DFB24], 0,
		    round_page(sc->sc_sunfb.sf_fbsize * 4));
		sc->sc_cplane = mapiodev(&ca->ca_ra.ra_reg[TCX_REG_RDFB32], 0,
		    round_page(sc->sc_sunfb.sf_fbsize * 4));
d267 1
a267 2
	sc->sc_sunfb.sf_depth = 0;	/* force action */
	tcx_reset(sc, 8);
a277 1
	sc->sc_sunfb.sf_ro.ri_bits = (void *)sc->sc_dfb8;
a278 1
	fbwscons_setcolormap(&sc->sc_sunfb, tcx_setcolor);
d294 1
a294 2
		    tcx_burner);
		shutdownhook_establish(tcx_prom, sc);
d299 1
a299 1
	printf("%s: %dx%d, id %d, rev %d, sense %d\n",
d301 1
a326 5
	/*
	 * Note that, although the emulation (text) mode is running in 8-bit
	 * mode, if the frame buffer is able to run in 24-bit mode, it will
	 * be advertized as such.
	 */
d329 1
a329 4
		if (sc->sc_cplane == NULL)
			*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
		else
			*(u_int *)data = WSDISPLAY_TYPE_SUN24;
d336 1
a336 1
		wdf->cmsize = sc->sc_cplane == NULL ? 256 : 0;
d339 1
a339 4
		if (sc->sc_cplane == NULL)
			*(u_int *)data = sc->sc_sunfb.sf_linebytes;
		else
			*(u_int *)data = sc->sc_sunfb.sf_linebytes * 4;
d343 6
a348 4
		cm = (struct wsdisplay_cmap *)data;
		error = bt_getcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
d351 11
a361 20
		cm = (struct wsdisplay_cmap *)data;
		error = bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		if (ISSET(sc->sc_sunfb.sf_flags, TCX_INTR)) {
			tcx_loadcmap_deferred(sc, cm->index, cm->count);
		} else {
			bt_loadcmap(&sc->sc_cmap, sc->sc_bt,
			    cm->index, cm->count, 1);
		}
		break;

	case WSDISPLAYIO_SMODE:
		if (*(int *)data == WSDISPLAYIO_MODE_EMUL) {
			/* Back from X11 to text mode */
			tcx_reset(sc, 8);
		} else {
			/* Starting X11, try to switch to 24 bit mode */
			if (sc->sc_cplane != NULL)
				tcx_reset(sc, 32);
d365 7
d383 1
a383 1
tcx_reset(sc, depth)
a384 1
	int depth;
d397 1
a397 1
	 * Change mode if appropriate
d399 19
a417 19
	if (sc->sc_sunfb.sf_depth != depth) {
		if (sc->sc_cplane != NULL) {
			volatile u_int32_t *cptr;
			u_int32_t pixel;
			int ramsize;

			cptr = sc->sc_cplane;
			ramsize = sc->sc_sunfb.sf_fbsize;

			if (depth == 8) {
				while (ramsize-- != 0) {
					pixel = (*cptr & TCX_CTL_PIXELMASK);
					*cptr++ = pixel | TCX_CTL_8_MAPPED;
				}
			} else {
				while (ramsize-- != 0) {
					*cptr++ = TCX_CTL_24_LEVEL;
				}
			}
d420 1
a420 2
		if (depth == 8)
			fbwscons_setcolormap(&sc->sc_sunfb, tcx_setcolor);
a421 2

	sc->sc_sunfb.sf_depth = depth;
d431 3
d435 12
a446 4
		/*
	 	* Select 8-bit mode.
	 	*/
		tcx_reset(sc, 8);
d448 5
a452 6
		/*
	 	* Go back to prom output for the last few messages, so they
	 	* will be displayed correctly.
	 	*/
		cn_tab = &consdev_prom;
	}
d489 1
d491 1
a491 1
	if (offset & PGOFSET || offset < 0)
d495 5
a499 6
	if (sc->sc_sunfb.sf_depth == 8 && offset < sc->sc_sunfb.sf_fbsize)
		return (REG2PHYS(&sc->sc_phys[TCX_REG_DFB8], offset) | PMAP_NC);
	else if (sc->sc_sunfb.sf_depth != 8 &&
	    offset < sc->sc_sunfb.sf_fbsize * 4)
		return (REG2PHYS(&sc->sc_phys[TCX_REG_DFB24], offset) |
		    PMAP_NC);
d531 7
a537 2
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
@


1.4
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.3 2001/08/17 13:52:29 mickey Exp $	*/
d64 1
a64 1
#include <vm/vm.h>
@


1.3
log
@cdev_decl cleanup; jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.2 1998/11/20 15:57:24 deraadt Exp $	*/
d440 1
a440 1
int
d443 2
a444 1
	int off, prot;
@


1.2
log
@careful off handling in mmap routines
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.1 1997/08/08 08:25:31 downsj Exp $	*/
a109 3

/* cdevsw prototypes */
cdev_decl(tcx);
@


1.2.6.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.2 1998/11/20 15:57:24 deraadt Exp $	*/
d110 3
@


1.2.6.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d64 1
a64 1
#include <uvm/uvm_extern.h>
d440 1
a440 1
paddr_t
d443 1
a443 2
	off_t off;
	int prot;
@


1.2.6.3
log
@Merge in -current from about a week ago
@
text
@d107 3
a109 3
static void	tcxattach(struct device *, struct device *, void *);
static int	tcxmatch(struct device *, void *, void *);
static void	tcx_unblank(struct device *);
d126 2
a127 2
static void tcx_reset(struct tcx_softc *);
static void tcx_loadcmap(struct tcx_softc *, int, int);
@


1.2.6.4
log
@Sync the SMP branch with 3.3
@
text
@d4 1
a4 25
/*
 * Copyright (c) 2002 Miodrag Vallat.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *
d7 1
a7 1
 *
d10 1
a10 1
 *
d26 1
a26 1
 *
d38 1
a38 1
 */
d43 3
a45 2
 * XXX Use of the vertical retrace interrupt to update the colormap is not
 * enabled by default, as it hangs the system on some machines.
d52 1
d59 5
d68 1
a71 6
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

d77 15
a91 1
#include <dev/cons.h>	/* for prom console hook */
d95 5
a99 3
	struct	sunfb sc_sunfb;			/* common base part */
	struct	sbusdev sc_sd;			/* sbus device */
	struct	rom_reg sc_phys[TCX_NREG];	/* phys addr of h/w */
d102 2
a103 4
	volatile u_int32_t *sc_cplane;		/* S24 control plane */
	union	bt_cmap sc_cmap;		/* Brooktree color map */
	struct	intrhand sc_ih;
	int	sc_nscreens;
d106 4
a109 41
struct wsscreen_descr tcx_stdscreen = {
	"std",
};

const struct wsscreen_descr *tcx_scrlist[] = {
	&tcx_stdscreen,
	/* XXX other formats? */
};

struct wsscreen_list tcx_screenlist = {
	sizeof(tcx_scrlist) / sizeof(struct wsscreen_descr *), tcx_scrlist
};

int tcx_ioctl(void *, u_long, caddr_t, int, struct proc *);
int tcx_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void tcx_free_screen(void *, void *);
int tcx_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t tcx_mmap(void *, off_t, int);
void tcx_reset(struct tcx_softc *);
void tcx_burner(void *, u_int, u_int);
void tcx_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
static __inline__ void tcx_loadcmap_deferred(struct tcx_softc *, u_int, u_int);
int tcx_intr(void *);
void tcx_prom(void *);

struct wsdisplay_accessops tcx_accessops = {
	tcx_ioctl,
	tcx_mmap,
	tcx_alloc_screen,
	tcx_free_screen,
	tcx_show_screen,
	NULL,   /* load_font */
	NULL,   /* scrollback */
	NULL,   /* getchar */
	tcx_burner,
};

int tcxmatch(struct device *, void *, void *);
void tcxattach(struct device *, struct device *, void *);
d119 9
a127 17
/*
 * There are three ways to access the framebuffer memory of the S24:
 * - 26 bits per pixel, in 32-bit words; the low-order 24 bits are blue,
 *   green and red values, and the other two bits select the display modes,
 *   per pixel.
 * - 24 bits per pixel, in 32-bit words; the high-order byte reads as zero,
 *   and is ignored on writes (so the mode bits can not be altered).
 * - 8 bits per pixel, unpadded; writes to this space do not modify the
 *   other 18 bits, which are hidden.
 *
 * The entry-level tcx found on the SPARCstation 4 can only provide the 8-bit
 * mode.
 */
#define	TCX_CTL_8_MAPPED	0x00000000	/* 8 bits, uses colormap */
#define	TCX_CTL_24_MAPPED	0x01000000	/* 24 bits, uses colormap */
#define	TCX_CTL_24_LEVEL	0x03000000	/* 24 bits, true color */
#define	TCX_CTL_PIXELMASK	0x00ffffff	/* mask for index/level */
d129 1
d138 1
d142 1
a142 1
	if (strcmp(ra->ra_name, "SUNW,tcx"))
d145 5
d164 21
a184 13
	struct tcx_softc *sc = (struct tcx_softc *)self;
	struct confargs *ca = args;
	struct wsemuldisplaydev_attach_args waa;
	int fb_depth, node = 0, i;
	volatile struct bt_regs *bt;
	int isconsole = 0;
	char *nam = NULL;

	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags & FB_USERMASK;

	if (ca->ca_ra.ra_nreg < TCX_NREG)
		panic("tcx: expected %d registers, got %d", TCX_NREG,
		    ca->ca_ra.ra_nreg);
d188 5
a192 1
		sc->sc_phys[i] = ca->ca_ra.ra_reg[i];
d195 1
a195 1
	    mapiodev(&ca->ca_ra.ra_reg[TCX_REG_CMAP], 0, sizeof *sc->sc_bt);
d197 1
a197 2
	    mapiodev(&ca->ca_ra.ra_reg[TCX_REG_THC],
	        0x1000, sizeof *sc->sc_thc);
a201 1
		nam = getpropstring(node, "model");
d204 1
d210 23
a232 20
	printf(": %s\n", nam);

	isconsole = node == fbnode;

	if (ISSET(sc->sc_sunfb.sf_flags, FB_FORCELOW))
		fb_depth = 8;
	else
		fb_depth = node_has_property(node, "tcx-8-bit") ?  8 : 32;

	fb_setsize(&sc->sc_sunfb, fb_depth, 1152, 900, node, ca->ca_bustype);

	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(&ca->ca_ra.ra_reg[
	    sc->sc_sunfb.sf_depth == 8 ? TCX_REG_DFB8 : TCX_REG_DFB24],
	    0, round_page(sc->sc_sunfb.sf_fbsize));
	
	/* map the control plane for S24 framebuffers */
	if (sc->sc_sunfb.sf_depth != 8) {
		sc->sc_cplane = mapiodev(&ca->ca_ra.ra_reg[TCX_REG_RDFB32],
		    0, round_page(sc->sc_sunfb.sf_fbsize));
	}
d237 1
a237 1
	/* grab initial (current) color map */
d243 1
a243 17
	tcx_burner(sc, 1, 0);

	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, isconsole);
	fbwscons_setcolormap(&sc->sc_sunfb, tcx_setcolor);

	tcx_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	tcx_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	tcx_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	tcx_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

	if (ISSET(sc->sc_sunfb.sf_flags, TCX_INTR)) {
		sc->sc_ih.ih_fun = tcx_intr;
		sc->sc_ih.ih_arg = sc;
		intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih,
		    IPL_FB);
	}
d246 9
a254 4
		fbwscons_console_init(&sc->sc_sunfb, &tcx_stdscreen, -1,
		    tcx_burner);
		shutdownhook_establish(tcx_prom, sc);
	}
d256 7
a262 1
	sbus_establish(&sc->sc_sd, &sc->sc_sunfb.sf_dev);
d264 12
a275 6
	printf("%s: %dx%d, id %d, rev %d, sense %d\n",
	    self->dv_xname, sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height,
	    (sc->sc_thc->thc_config & THC_CFG_FBID) >> THC_CFG_FBID_SHIFT,
	    (sc->sc_thc->thc_config & THC_CFG_REV) >> THC_CFG_REV_SHIFT,
	    (sc->sc_thc->thc_config & THC_CFG_SENSE) >> THC_CFG_SENSE_SHIFT
	);
d277 2
a278 5
	waa.console = isconsole;
	waa.scrdata = &tcx_screenlist;
	waa.accessops = &tcx_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
d282 2
a283 2
tcx_ioctl(dev, cmd, data, flags, p)
	void *dev;
d285 1
a285 1
	caddr_t data;
d289 1
a289 3
	struct tcx_softc *sc = dev;
	struct wsdisplay_cmap *cm;
	struct wsdisplay_fbinfo *wdf;
d293 3
a295 2
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_SUN24;
d297 13
a309 6
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width = sc->sc_sunfb.sf_width;
		wdf->depth = sc->sc_sunfb.sf_depth;
		wdf->cmsize = (sc->sc_sunfb.sf_depth == 8) ? 256 : 0;
d311 14
a324 2
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
d327 2
a328 7
	case WSDISPLAYIO_GETCMAP:
		if (sc->sc_sunfb.sf_depth == 8) {
			cm = (struct wsdisplay_cmap *)data;
			error = bt_getcmap(&sc->sc_cmap, cm);
			if (error)
				return (error);
		}
d330 10
a339 12
	case WSDISPLAYIO_PUTCMAP:
		if (sc->sc_sunfb.sf_depth == 8) {
			cm = (struct wsdisplay_cmap *)data;
			error = bt_putcmap(&sc->sc_cmap, cm);
			if (error)
				return (error);
			if (ISSET(sc->sc_sunfb.sf_flags, TCX_INTR)) {
				tcx_loadcmap_deferred(sc, cm->index, cm->count);
			} else {
				bt_loadcmap(&sc->sc_cmap, sc->sc_bt,
				    cm->index, cm->count, 1);
			}
a342 7
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
d344 5
a348 1
		return (-1);	/* not supported yet */
a349 1

d356 1
a356 1
void
d358 1
a358 1
	struct tcx_softc *sc;
d360 1
a360 4
	volatile struct bt_regs *bt;

	/* Hide the cursor, just in case */
	sc->sc_thc->thc_cursoraddr = THC_CURSOFF;
d366 1
d368 11
a378 23
	/*
	 * Select 24-bit mode if appropriate.
	 */
	if (sc->sc_sunfb.sf_depth != 8) {
		volatile u_int32_t *cptr;
		u_int32_t pixel;
		int ramsize;

		ramsize = sc->sc_sunfb.sf_fbsize / sizeof(u_int32_t);
		cptr = sc->sc_cplane;

		/*
		 * Since the prom output so far has only been white (0)
		 * or black (255), we can promote the 8 bit plane contents
		 * to full color.
		 * Of course, the 24 bit plane uses 0 for black, so a
		 * reversal is necessary. Blame Sun.
		 */
		while (ramsize-- != 0) {
			pixel = 255 - ((*cptr & TCX_CTL_PIXELMASK) & 0xff);
			pixel = (pixel << 16) | (pixel << 8) | pixel;
			*cptr++ = pixel | TCX_CTL_24_LEVEL;
		}
d380 11
a390 1
		shutdownhook_establish(tcx_prom, sc);
d394 11
a404 22
void
tcx_prom(v)
	void *v;
{
	struct tcx_softc *sc = v;
	extern struct consdev consdev_prom;

	/*
	 * Select 8-bit mode.
	 */
	if (sc->sc_sunfb.sf_depth != 8) {
		volatile u_int32_t *cptr;
		u_int32_t pixel;
		int ramsize;

		ramsize = sc->sc_sunfb.sf_fbsize / sizeof(u_int32_t);
		cptr = sc->sc_cplane;

		while (ramsize-- != 0) {
			pixel = (*cptr & TCX_CTL_PIXELMASK);
			*cptr++ = pixel | TCX_CTL_8_MAPPED;
		}
a405 6

	/*
	 * Go back to prom output for the last few messages, so they
	 * will be displayed correctly.
	 */
	cn_tab = &consdev_prom;
d408 25
a432 22
void
tcx_burner(v, on, flags)
	void *v;
	u_int on, flags;
{
	struct tcx_softc *sc = v;
	int s;
	u_int32_t thcm;

	s = splhigh();
	thcm = sc->sc_thc->thc_hcmisc;
	if (on) {
		thcm |= THC_MISC_VIDEN;
		thcm &= ~(THC_MISC_VSYNC_DISABLE | THC_MISC_HSYNC_DISABLE);
	} else {
		thcm &= ~THC_MISC_VIDEN;
		if (flags & WSDISPLAY_BURN_VBLANK)
			thcm |= THC_MISC_VSYNC_DISABLE | THC_MISC_HSYNC_DISABLE;
	}
	sc->sc_thc->thc_hcmisc = thcm;
	splx(s);
}
d437 2
d441 3
a443 3
tcx_mmap(v, offset, prot)
	void *v;
	off_t offset;
d446 21
a466 2
	struct tcx_softc *sc = v;
	int reg;
d468 4
a471 1
	if (offset & PGOFSET)
d474 20
a493 5
	/* Allow mapping as a dumb framebuffer from offset 0 */
	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		reg = (sc->sc_sunfb.sf_depth == 8) ?
		    TCX_REG_DFB8 : TCX_REG_DFB24;
		return (REG2PHYS(&sc->sc_phys[reg], offset) | PMAP_NC);
d495 1
a495 1

a496 94
}

void
tcx_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
	u_int8_t r, g, b;
{
	struct tcx_softc *sc = v;

	bt_setcolor(&sc->sc_cmap, sc->sc_bt, index, r, g, b, 1);
}

int
tcx_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
{
	struct tcx_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	if (sc->sc_sunfb.sf_depth == 8) {
		sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
		    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	} else {
		sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
		    0, 0, 0, attrp);
	}
	sc->sc_nscreens++;
	return (0);
}

void
tcx_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct tcx_softc *sc = v;

	sc->sc_nscreens--;
}

int
tcx_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
	return (0);
}

static __inline__ void
tcx_loadcmap_deferred(struct tcx_softc *sc, u_int start, u_int ncolors)
{
	u_int32_t thcm;

	thcm = sc->sc_thc->thc_hcmisc;
	thcm &= ~THC_MISC_RESET;
	thcm |= THC_MISC_INTEN;
	sc->sc_thc->thc_hcmisc = thcm;
}

int
tcx_intr(v)
	void *v;
{
	struct tcx_softc *sc = v;
	u_int32_t thcm;

	thcm = sc->sc_thc->thc_hcmisc;
	if ((thcm & (THC_MISC_INTEN | THC_MISC_INTR)) !=
	    (THC_MISC_INTEN | THC_MISC_INTR)) {
		/* Not expecting an interrupt, it's not for us. */
		return (0);
	}

	/* Acknowledge the interrupt and disable it. */
	thcm &= ~(THC_MISC_RESET | THC_MISC_INTEN);
	thcm |= THC_MISC_INTR;
	sc->sc_thc->thc_hcmisc = thcm;

	bt_loadcmap(&sc->sc_cmap, sc->sc_bt, 0, 256, 1);

	return (1);
@


1.2.6.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.2.6.4 2003/03/27 23:49:25 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 2002, 2003 Miodrag Vallat.  All rights reserved.
a107 2
	volatile u_int8_t *sc_dfb8;		/* 8 bit plane */
	volatile u_int32_t *sc_dfb24;		/* S24 24 bit plane */
d120 1
d134 1
a134 1
void tcx_reset(struct tcx_softc *, int);
d193 1
a193 1
	if (strcmp(ra->ra_name, "SUNW,tcx") != 0)
d196 4
a199 1
	return (1);
d213 1
a213 1
	int node = 0, i;
d220 3
a222 9
	node = ca->ca_ra.ra_node;
	nam = getpropstring(node, "model");
	printf(": %s\n", nam);

	if (ca->ca_ra.ra_nreg < TCX_NREG) {
		printf("\n%s: expected %d registers, got %d\n",
		    self->dv_xname, TCX_NREG, ca->ca_ra.ra_nreg);
		return;
	}
d234 13
d249 15
a263 15
	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, ca->ca_bustype);
	if (node_has_property(node, "tcx-8-bit")) {
		sc->sc_dfb8 = mapiodev(&ca->ca_ra.ra_reg[TCX_REG_DFB8], 0,
		    round_page(sc->sc_sunfb.sf_fbsize));
		sc->sc_dfb24 = NULL;
		sc->sc_cplane = NULL;
	} else {
		sc->sc_dfb8 = mapiodev(&ca->ca_ra.ra_reg[TCX_REG_DFB8], 0,
		    round_page(sc->sc_sunfb.sf_fbsize));

		/* map the 24 bit and control planes for S24 framebuffers */
		sc->sc_dfb24 = mapiodev(&ca->ca_ra.ra_reg[TCX_REG_DFB24], 0,
		    round_page(sc->sc_sunfb.sf_fbsize * 4));
		sc->sc_cplane = mapiodev(&ca->ca_ra.ra_reg[TCX_REG_RDFB32], 0,
		    round_page(sc->sc_sunfb.sf_fbsize * 4));
d267 1
a267 2
	sc->sc_sunfb.sf_depth = 0;	/* force action */
	tcx_reset(sc, 8);
a277 1
	sc->sc_sunfb.sf_ro.ri_bits = (void *)sc->sc_dfb8;
a327 5
	/*
	 * Note that, although the emulation (text) mode is running in 8-bit
	 * mode, if the frame buffer is able to run in 24-bit mode, it will
	 * be advertized as such.
	 */
d330 1
a330 4
		if (sc->sc_cplane == NULL)
			*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
		else
			*(u_int *)data = WSDISPLAY_TYPE_SUN24;
d337 1
a337 1
		wdf->cmsize = sc->sc_cplane == NULL ? 256 : 0;
d340 1
a340 4
		if (sc->sc_cplane == NULL)
			*(u_int *)data = sc->sc_sunfb.sf_linebytes;
		else
			*(u_int *)data = sc->sc_sunfb.sf_linebytes * 4;
d344 6
a349 4
		cm = (struct wsdisplay_cmap *)data;
		error = bt_getcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
d352 11
a362 20
		cm = (struct wsdisplay_cmap *)data;
		error = bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		if (ISSET(sc->sc_sunfb.sf_flags, TCX_INTR)) {
			tcx_loadcmap_deferred(sc, cm->index, cm->count);
		} else {
			bt_loadcmap(&sc->sc_cmap, sc->sc_bt,
			    cm->index, cm->count, 1);
		}
		break;

	case WSDISPLAYIO_SMODE:
		if (*(int *)data == WSDISPLAYIO_MODE_EMUL) {
			/* Back from X11 to text mode */
			tcx_reset(sc, 8);
		} else {
			/* Starting X11, try to switch to 24 bit mode */
			if (sc->sc_cplane != NULL)
				tcx_reset(sc, 32);
d366 7
d384 1
a384 1
tcx_reset(sc, depth)
a385 1
	int depth;
d398 1
a398 1
	 * Change mode if appropriate
d400 19
a418 19
	if (sc->sc_sunfb.sf_depth != depth) {
		if (sc->sc_cplane != NULL) {
			volatile u_int32_t *cptr;
			u_int32_t pixel;
			int ramsize;

			cptr = sc->sc_cplane;
			ramsize = sc->sc_sunfb.sf_fbsize;

			if (depth == 8) {
				while (ramsize-- != 0) {
					pixel = (*cptr & TCX_CTL_PIXELMASK);
					*cptr++ = pixel | TCX_CTL_8_MAPPED;
				}
			} else {
				while (ramsize-- != 0) {
					*cptr++ = TCX_CTL_24_LEVEL;
				}
			}
d421 1
a421 2
		if (depth == 8)
			fbwscons_setcolormap(&sc->sc_sunfb, tcx_setcolor);
a422 2

	sc->sc_sunfb.sf_depth = depth;
d432 3
d436 12
a447 4
		/*
	 	* Select 8-bit mode.
	 	*/
		tcx_reset(sc, 8);
d449 5
a453 6
		/*
	 	* Go back to prom output for the last few messages, so they
	 	* will be displayed correctly.
	 	*/
		cn_tab = &consdev_prom;
	}
d490 1
d492 1
a492 1
	if (offset & PGOFSET || offset < 0)
d496 5
a500 6
	if (sc->sc_sunfb.sf_depth == 8 && offset < sc->sc_sunfb.sf_fbsize)
		return (REG2PHYS(&sc->sc_phys[TCX_REG_DFB8], offset) | PMAP_NC);
	else if (sc->sc_sunfb.sf_depth != 8 &&
	    offset < sc->sc_sunfb.sf_fbsize * 4)
		return (REG2PHYS(&sc->sc_phys[TCX_REG_DFB24], offset) |
		    PMAP_NC);
d532 7
a538 2
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
@


1.2.6.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tcx.c,v 1.2.6.5 2003/05/13 19:41:08 ho Exp $	*/
d216 2
d279 6
a284 5
#if 0
	sc->sc_ih.ih_fun = tcx_intr;
	sc->sc_ih.ih_arg = sc;
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih, IPL_FB);
#endif
d358 6
a363 5
#if 0
		tcx_loadcmap_deferred(sc, cm->index, cm->count);
#else
		bt_loadcmap(&sc->sc_cmap, sc->sc_bt, cm->index, cm->count, 1);
#endif
@


1.2.6.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d66 3
d269 1
a269 1
	fbwscons_init(&sc->sc_sunfb, isconsole ? 0 : RI_CLEAR);
d277 1
d281 1
d345 4
a348 6
		if (sc->sc_cplane == NULL) {
			cm = (struct wsdisplay_cmap *)data;
			error = bt_getcmap(&sc->sc_cmap, cm);
			if (error)
				return (error);
		}
d351 9
a359 7
		if (sc->sc_cplane == NULL) {
			cm = (struct wsdisplay_cmap *)data;
			error = bt_putcmap(&sc->sc_cmap, cm);
			if (error)
				return (error);
			tcx_loadcmap_deferred(sc, cm->index, cm->count);
		}
d559 1
d572 5
a576 2
	if (thcm & THC_MISC_INTEN) {
		thcm &= ~(THC_MISC_INTR | THC_MISC_INTEN);
d578 4
a581 2
		/* Acknowledge the interrupt */
		sc->sc_thc->thc_hcmisc = thcm | THC_MISC_INTR;
d583 1
a583 1
		bt_loadcmap(&sc->sc_cmap, sc->sc_bt, 0, 256, 1);
d585 1
a585 7
		/* Disable further interrupts now */
		sc->sc_thc->thc_hcmisc = thcm;

		return (1);
	}

	return (0);
@


1.1
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d472 3
@

