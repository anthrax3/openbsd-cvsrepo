head	1.91;
access;
symbols
	OPENBSD_6_0:1.91.0.4
	OPENBSD_6_0_BASE:1.91
	OPENBSD_5_9:1.91.0.2
	OPENBSD_5_9_BASE:1.91
	OPENBSD_5_8:1.90.0.8
	OPENBSD_5_8_BASE:1.90
	OPENBSD_5_7:1.90.0.2
	OPENBSD_5_7_BASE:1.90
	OPENBSD_5_6:1.90.0.4
	OPENBSD_5_6_BASE:1.90
	OPENBSD_5_5:1.89.0.4
	OPENBSD_5_5_BASE:1.89
	OPENBSD_5_4:1.84.0.2
	OPENBSD_5_4_BASE:1.84
	OPENBSD_5_3:1.82.0.2
	OPENBSD_5_3_BASE:1.82
	OPENBSD_5_2:1.81.0.6
	OPENBSD_5_2_BASE:1.81
	OPENBSD_5_1_BASE:1.81
	OPENBSD_5_1:1.81.0.4
	OPENBSD_5_0:1.81.0.2
	OPENBSD_5_0_BASE:1.81
	OPENBSD_4_9:1.80.0.2
	OPENBSD_4_9_BASE:1.80
	OPENBSD_4_8:1.72.0.2
	OPENBSD_4_8_BASE:1.72
	OPENBSD_4_7:1.68.0.2
	OPENBSD_4_7_BASE:1.68
	OPENBSD_4_6:1.64.0.4
	OPENBSD_4_6_BASE:1.64
	OPENBSD_4_5:1.63.0.2
	OPENBSD_4_5_BASE:1.63
	OPENBSD_4_4:1.62.0.2
	OPENBSD_4_4_BASE:1.62
	OPENBSD_4_3:1.56.0.2
	OPENBSD_4_3_BASE:1.56
	OPENBSD_4_2:1.54.0.2
	OPENBSD_4_2_BASE:1.54
	OPENBSD_4_1:1.47.0.2
	OPENBSD_4_1_BASE:1.47
	OPENBSD_4_0:1.44.0.2
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.43.0.2
	OPENBSD_3_9_BASE:1.43
	OPENBSD_3_8:1.42.0.2
	OPENBSD_3_8_BASE:1.42
	OPENBSD_3_7:1.40.0.2
	OPENBSD_3_7_BASE:1.40
	OPENBSD_3_6:1.36.0.2
	OPENBSD_3_6_BASE:1.36
	SMP_SYNC_A:1.36
	SMP_SYNC_B:1.36
	OPENBSD_3_5:1.35.0.2
	OPENBSD_3_5_BASE:1.35
	OPENBSD_3_4:1.33.0.2
	OPENBSD_3_4_BASE:1.33
	UBC_SYNC_A:1.32
	OPENBSD_3_3:1.32.0.2
	OPENBSD_3_3_BASE:1.32
	OPENBSD_3_2:1.29.0.2
	OPENBSD_3_2_BASE:1.29
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	UBC_SYNC_B:1.29
	UBC:1.24.0.6
	UBC_BASE:1.24
	OPENBSD_3_0:1.24.0.4
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9_BASE:1.24
	OPENBSD_2_9:1.24.0.2
	OPENBSD_2_8:1.23.0.12
	OPENBSD_2_8_BASE:1.23
	OPENBSD_2_7:1.23.0.10
	OPENBSD_2_7_BASE:1.23
	SMP:1.23.0.8
	SMP_BASE:1.23
	kame_19991208:1.23
	OPENBSD_2_6:1.23.0.6
	OPENBSD_2_6_BASE:1.23
	OPENBSD_2_5:1.23.0.4
	OPENBSD_2_5_BASE:1.23
	OPENBSD_2_4:1.23.0.2
	OPENBSD_2_4_BASE:1.23
	OPENBSD_2_3:1.22.0.4
	OPENBSD_2_3_BASE:1.22
	OPENBSD_2_2:1.22.0.2
	OPENBSD_2_2_BASE:1.22
	OPENBSD_2_1:1.16.0.2
	OPENBSD_2_1_BASE:1.16
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.91
date	2015.09.08.10.21.16;	author deraadt;	state Exp;
branches;
next	1.90;
commitid	DGOx6p2gOlciIkZ2;

1.90
date	2014.07.12.18.44.43;	author tedu;	state Exp;
branches;
next	1.89;
commitid	uKVPYMN2MLxdZxzH;

1.89
date	2013.11.26.15.42.43;	author martin;	state Exp;
branches;
next	1.88;

1.88
date	2013.11.21.00.13.33;	author dlg;	state Exp;
branches;
next	1.87;

1.87
date	2013.11.18.01.56.35;	author dlg;	state Exp;
branches;
next	1.86;

1.86
date	2013.11.12.16.04.09;	author krw;	state Exp;
branches;
next	1.85;

1.85
date	2013.11.01.17.36.19;	author krw;	state Exp;
branches;
next	1.84;

1.84
date	2013.06.11.16.42.11;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	2013.05.30.16.15.01;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2013.01.01.01.00.14;	author miod;	state Exp;
branches;
next	1.81;

1.81
date	2011.06.05.18.40.33;	author matthew;	state Exp;
branches;
next	1.80;

1.80
date	2010.11.18.21.13.19;	author miod;	state Exp;
branches;
next	1.79;

1.79
date	2010.09.28.12.39.17;	author miod;	state Exp;
branches;
next	1.78;

1.78
date	2010.09.23.13.11.38;	author jsing;	state Exp;
branches;
next	1.77;

1.77
date	2010.09.22.01.18.57;	author matthew;	state Exp;
branches;
next	1.76;

1.76
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.75;

1.75
date	2010.09.08.14.47.10;	author jsing;	state Exp;
branches;
next	1.74;

1.74
date	2010.08.28.20.23.22;	author matthew;	state Exp;
branches;
next	1.73;

1.73
date	2010.08.17.20.05.06;	author miod;	state Exp;
branches;
next	1.72;

1.72
date	2010.07.10.19.32.24;	author miod;	state Exp;
branches;
next	1.71;

1.71
date	2010.07.02.19.57.15;	author tedu;	state Exp;
branches;
next	1.70;

1.70
date	2010.05.23.10.49.19;	author dlg;	state Exp;
branches;
next	1.69;

1.69
date	2010.04.23.15.25.21;	author jsing;	state Exp;
branches;
next	1.68;

1.68
date	2009.09.12.01.23.30;	author krw;	state Exp;
branches;
next	1.67;

1.67
date	2009.08.24.08.52.13;	author jasper;	state Exp;
branches;
next	1.66;

1.66
date	2009.08.13.15.23.12;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2009.07.24.08.07.39;	author blambert;	state Exp;
branches;
next	1.64;

1.64
date	2009.04.10.20.53.51;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2008.10.15.19.12.19;	author blambert;	state Exp;
branches;
next	1.62;

1.62
date	2008.06.26.05.42.13;	author ray;	state Exp;
branches;
next	1.61;

1.61
date	2008.06.12.06.58.37;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2008.06.11.12.35.43;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2008.06.10.20.50.23;	author beck;	state Exp;
branches;
next	1.58;

1.58
date	2008.03.22.22.54.43;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2008.03.20.00.59.37;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2007.11.27.16.22.13;	author martynas;	state Exp;
branches;
next	1.55;

1.55
date	2007.10.01.16.11.19;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2007.06.20.18.15.47;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2007.06.08.05.27.58;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2007.06.07.00.14.20;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2007.06.06.17.15.12;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2007.06.05.00.38.18;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.01.00.07.48;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2007.04.27.22.20.01;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2007.02.15.00.53.26;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2006.11.29.12.24.17;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2006.09.26.23.33.04;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2006.03.15.20.20.41;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2006.01.22.00.40.02;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2005.08.14.10.58.33;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2005.03.23.17.10.22;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2005.03.12.00.09.01;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2004.12.25.23.02.25;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2004.09.29.07.35.11;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2004.09.22.22.12.57;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2004.04.02.04.31.21;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2004.02.15.02.45.46;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2004.01.12.11.35.08;	author jmc;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.02.23.27.54;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2002.11.24.18.17.58;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2002.11.24.15.05.03;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2002.11.24.02.00.36;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2002.05.29.08.28.36;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2002.04.30.01.12.29;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2002.04.28.03.51.19;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.14.01.26.42;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.13.00.24.21;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2001.03.24.01.37.28;	author ho;	state Exp;
branches
	1.24.6.1;
next	1.23;

1.23
date	98.10.03.21.18.58;	author millert;	state Exp;
branches
	1.23.8.1;
next	1.22;

1.22
date	97.09.20.12.24.17;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	97.08.25.08.38.44;	author downsj;	state Exp;
branches;
next	1.20;

1.20
date	97.08.08.08.25.06;	author downsj;	state Exp;
branches;
next	1.19;

1.19
date	97.06.25.13.04.20;	author downsj;	state Exp;
branches;
next	1.18;

1.18
date	97.06.24.09.50.56;	author downsj;	state Exp;
branches;
next	1.17;

1.17
date	97.05.30.08.27.49;	author grr;	state Exp;
branches;
next	1.16;

1.16
date	97.05.11.22.37.34;	author grr;	state Exp;
branches;
next	1.15;

1.15
date	97.04.02.18.28.48;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.04.02.01.33.15;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.12.06.11.23.02;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.12.05.17.16.59;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.11.23.21.46.16;	author kstailey;	state Exp;
branches;
next	1.10;

1.10
date	96.11.06.01.33.58;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.08.11.23.11.35;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	96.08.11.05.34.18;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.01.15.00.16.32;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.01.12.20.20.48;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	95.12.15.13.56.23;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.10.24.14.36.36;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.10.21.20.06.35;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.19.11.23.13;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.39;	author deraadt;	state Exp;
branches;
next	;

1.23.8.1
date	2001.05.14.21.37.05;	author niklas;	state Exp;
branches;
next	1.23.8.2;

1.23.8.2
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.23.8.3;

1.23.8.3
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.23.8.4;

1.23.8.4
date	2003.06.07.11.14.42;	author ho;	state Exp;
branches;
next	1.23.8.5;

1.23.8.5
date	2004.02.19.10.49.57;	author niklas;	state Exp;
branches;
next	1.23.8.6;

1.23.8.6
date	2004.06.05.23.10.57;	author niklas;	state Exp;
branches;
next	;

1.24.6.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	1.24.6.2;

1.24.6.2
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.91
log
@sizes for free(); ok semarie
@
text
@/*	$OpenBSD: fd.c,v 1.90 2014/07/12 18:44:43 tedu Exp $	*/
/*	$NetBSD: fd.c,v 1.51 1997/05/24 20:16:19 pk Exp $	*/

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Paul Kranenburg.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*-
 * Copyright (c) 1993, 1994, 1995 Charles Hannum.
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Don Ahn.
 *
 * Portions Copyright (c) 1993, 1994 by
 *  jc@@irbs.UUCP (John Capo)
 *  vak@@zebub.msk.su (Serge Vakulenko)
 *  ache@@astral.msk.su (Andrew A. Chernov)
 *  joerg_wunsch@@uriah.sax.de (Joerg Wunsch)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)fd.c	7.4 (Berkeley) 5/25/91
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/disk.h>
#include <sys/buf.h>
#include <sys/malloc.h>
#include <sys/proc.h>
#include <sys/uio.h>
#include <sys/mtio.h>
#include <sys/stat.h>
#include <sys/syslog.h>
#include <sys/queue.h>
#include <sys/conf.h>
#include <sys/timeout.h>
#include <sys/dkio.h>

#include <dev/cons.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/autoconf.h>
#include <machine/conf.h>
#include <machine/ioctl_fd.h>

#include <sparc/sparc/auxioreg.h>
#include <sparc/dev/fdreg.h>
#include <sparc/dev/fdvar.h>

#define FDUNIT(dev)	((dev & 0x80) >> 7)
#define FDTYPE(dev)	((minor(dev) & 0x70) >> 4)
#define FDPART(dev)	(minor(dev) & 0x0f)

/* XXX misuse a flag to identify format operation */
#define B_FORMAT B_XXX

#ifdef FD_DEBUG
int	fdc_debug = 0;
#endif

enum fdc_state {
	DEVIDLE = 0,
	MOTORWAIT,	/*  1 */
	DOSEEK,		/*  2 */
	SEEKWAIT,	/*  3 */
	SEEKTIMEDOUT,	/*  4 */
	SEEKCOMPLETE,	/*  5 */
	DOIO,		/*  6 */
	IOCOMPLETE,	/*  7 */
	IOTIMEDOUT,	/*  8 */
	IOCLEANUPWAIT,	/*  9 */
	IOCLEANUPTIMEDOUT,/*10 */
	DORESET,	/* 11 */
	RESETCOMPLETE,	/* 12 */
	RESETTIMEDOUT,	/* 13 */
	DORECAL,	/* 14 */
	RECALWAIT,	/* 15 */
	RECALTIMEDOUT,	/* 16 */
	RECALCOMPLETE,	/* 17 */
};

/* software state, per controller */
struct fdc_softc {
	struct device	sc_dev;		/* boilerplate */
	caddr_t		sc_reg;
	struct fd_softc *sc_fd[4];	/* pointers to children */
	TAILQ_HEAD(drivehead, fd_softc) sc_drives;
	enum fdc_state	sc_state;
	int		sc_flags;
#define FDC_82077		0x01
#define FDC_NEEDHEADSETTLE	0x02
#define FDC_EIS			0x04
#define FDC_NEEDMOTORWAIT	0x08
	int		sc_errors;		/* number of retries so far */
	int		sc_overruns;		/* number of DMA overruns */
	int		sc_cfg;			/* current configuration */
	struct fdcio	sc_io;
#define sc_reg_msr	sc_io.fdcio_reg_msr
#define sc_reg_fifo	sc_io.fdcio_reg_fifo
#define sc_reg_dor	sc_io.fdcio_reg_dor
#define sc_reg_drs	sc_io.fdcio_reg_msr
#define sc_itask	sc_io.fdcio_itask
#define sc_istatus	sc_io.fdcio_istatus
#define sc_data		sc_io.fdcio_data
#define sc_tc		sc_io.fdcio_tc
#define sc_nstat	sc_io.fdcio_nstat
#define sc_status	sc_io.fdcio_status
#define	sc_hih		sc_io.fdcio_ih
#define	sc_sih		sc_io.fdcio_sih
	struct timeout	fdctimeout_to;
	struct timeout	fdcpseudointr_to;
};

#ifndef FDC_C_HANDLER
extern	struct fdcio *fdciop;
#endif

/* controller driver configuration */
int	fdcmatch(struct device *, void *, void *);
void	fdcattach(struct device *, struct device *, void *);

struct cfattach fdc_ca = {
	sizeof(struct fdc_softc), fdcmatch, fdcattach
};

struct cfdriver fdc_cd = {
	NULL, "fdc", DV_DULL
};

__inline struct fd_type *fd_dev_to_type(struct fd_softc *, dev_t);

/* The order of entries in the following table is important -- BEWARE! */
struct fd_type fd_types[] = {
	{ 18,2,36,2,0xff,0xcf,0x1b,0x6c,80,2880,1,FDC_500KBPS, "1.44MB"    }, /* 1.44MB diskette */
	{  9,2,18,2,0xff,0xdf,0x2a,0x50,80,1440,1,FDC_250KBPS, "720KB"    }, /* 3.5" 720kB diskette */
	{  9,2,18,2,0xff,0xdf,0x2a,0x50,40, 720,2,FDC_250KBPS, "360KB/x"  }, /* 360kB in 720kB drive */
	{  8,2,16,3,0xff,0xdf,0x35,0x74,77,1232,1,FDC_500KBPS, "1.2MB/NEC" } /* 1.2 MB japanese format */
};

/* software state, per disk (with up to 4 disks per ctlr) */
struct fd_softc {
	struct device	sc_dv;		/* generic device info */
	struct disk	sc_dk;		/* generic disk info */

	struct fd_type *sc_deftype;	/* default type descriptor */
	struct fd_type *sc_type;	/* current type descriptor */

	daddr_t sc_blkno;	/* starting block number */
	int sc_bcount;		/* byte count left */
	int sc_skip;		/* bytes already transferred */
	int sc_nblks;		/* number of blocks currently transferring */
	int sc_nbytes;		/* number of bytes currently transferring */

	int sc_drive;		/* physical unit number */
	int sc_flags;
#define	FD_OPEN		0x01		/* it's open */
#define	FD_MOTOR	0x02		/* motor should be on */
#define	FD_MOTOR_WAIT	0x04		/* motor coming up */
	int sc_cylin;		/* where we think the head is */
	int sc_opts;		/* user-set options */

	TAILQ_ENTRY(fd_softc) sc_drivechain;
	int sc_ops;		/* I/O ops since last switch */
	struct bufq sc_bufq;	/* pending I/O requests */
	struct buf *sc_bp;	/* current I/O */

	struct timeout fd_motor_on_to;
	struct timeout fd_motor_off_to;
};

/* floppy driver configuration */
int	fdmatch(struct device *, void *, void *);
void	fdattach(struct device *, struct device *, void *);
int	fdactivate(struct device *, int);

struct cfattach fd_ca = {
	sizeof(struct fd_softc), fdmatch, fdattach,
	NULL, fdactivate
};

struct cfdriver fd_cd = {
	NULL, "fd", DV_DISK
};

int fdgetdisklabel(dev_t, struct fd_softc *, struct disklabel *, int);
int fd_get_parms(struct fd_softc *);
void fdstrategy(struct buf *);
void fdstart(struct fd_softc *);
int fdprint(void *, const char *);

struct	fd_type *fd_nvtotype(char *, int, int);
void	fd_set_motor(struct fdc_softc *fdc);
void	fd_motor_off(void *arg);
void	fd_motor_on(void *arg);
int	fdcresult(struct fdc_softc *fdc);
int	fdc_wrfifo(struct fdc_softc *fdc, u_char x);
void	fdcstart(struct fdc_softc *fdc);
void	fdcstatus(struct fdc_softc *fdc, char *s);
void	fdc_reset(struct fdc_softc *fdc);
void	fdctimeout(void *arg);
void	fdcpseudointr(void *arg);
#ifdef FDC_C_HANDLER
int	fdc_c_hwintr(struct fdc_softc *);
#else
void	fdchwintr(void);
#endif
void	fdcswintr(void *);
int	fdcstate(struct fdc_softc *);
void	fdcretry(struct fdc_softc *fdc);
void	fdfinish(struct fd_softc *fd, struct buf *bp);
int	fdformat(dev_t, struct fd_formb *, struct proc *);
void	fd_do_eject(struct fd_softc *);
static int fdconf(struct fdc_softc *);

#define OBP_FDNAME	(CPU_ISSUN4M ? "SUNW,fdtwo" : "fd")

int
fdcmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	register struct confargs *ca = aux;
	register struct romaux *ra = &ca->ca_ra;

	/*
	 * Floppy doesn't exist on sun4 and sun4e.
	 */
	if (CPU_ISSUN4OR4E)
		return (0);

	/*
	 * Floppy controller is on mainbus on sun4c.
	 */
	if ((CPU_ISSUN4C) && (ca->ca_bustype != BUS_MAIN))
		return (0);

	/*
	 * Floppy controller is on obio on sun4m.
	 */
	if ((CPU_ISSUN4M) && (ca->ca_bustype != BUS_OBIO))
		return (0);

	/* Sun PROMs call the controller an "fd" or "SUNW,fdtwo" */
	if (strcmp(OBP_FDNAME, ra->ra_name))
		return (0);

	if (ca->ca_ra.ra_vaddr &&
	    probeget(ca->ca_ra.ra_vaddr, 1) == -1) {
		return (0);
	}

	return (1);
}

/*
 * Arguments passed between fdcattach and fdprobe.
 */
struct fdc_attach_args {
	int fa_drive;
	struct bootpath *fa_bootpath;
	struct fd_type *fa_deftype;
};

/*
 * Print the location of a disk drive (called just before attaching the
 * the drive).  If `fdc' is not NULL, the drive was found but was not
 * in the system config file; print the drive name as well.
 * Return QUIET (config_find ignores this if the device was configured) to
 * avoid printing `fdN not configured' messages.
 */
int
fdprint(aux, fdc)
	void *aux;
	const char *fdc;
{
	register struct fdc_attach_args *fa = aux;

	if (!fdc)
		printf(" drive %d", fa->fa_drive);
	return (QUIET);
}

/*
 * Configure several parameters and features on the FDC.
 * Return 0 on success.
 */
static int
fdconf(fdc)
	struct fdc_softc *fdc;
{
	int	vroom;

	if (fdc_wrfifo(fdc, NE7CMD_DUMPREG) || fdcresult(fdc) != 10)
		return (-1);

	/*
	 * dumpreg[7] seems to be a motor-off timeout; set it to whatever
	 * the PROM thinks is appropriate.
	 */
	if ((vroom = fdc->sc_status[7]) == 0)
		vroom = 0x64;

	/* Configure controller to use FIFO and Implied Seek */
	if (fdc_wrfifo(fdc, NE7CMD_CFG) != 0)
		return (-1);
	if (fdc_wrfifo(fdc, vroom) != 0)
		return (-1);
	if (fdc_wrfifo(fdc, fdc->sc_cfg) != 0)
		return (-1);
	if (fdc_wrfifo(fdc, 0) != 0)	/* PRETRK */
		return (-1);
	/* No result phase for the NE7CMD_CFG command */

	if ((fdc->sc_flags & FDC_82077) != 0) {
		/* Lock configuration across soft resets. */
		if (fdc_wrfifo(fdc, NE7CMD_LOCK | CFG_LOCK) != 0 ||
		    fdcresult(fdc) != 1) {
#ifdef FD_DEBUG
			printf("fdconf: CFGLOCK failed");
#endif
			return (-1);
		}
	}
	return (0);
#if 0
	if (fdc_wrfifo(fdc, NE7CMD_VERSION) == 0 &&
	    fdcresult(fdc) == 1 && fdc->sc_status[0] == 0x90) {
		if (fdc_debug)
			printf("[version cmd]");
	}
#endif

}

void
fdcattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	register struct confargs *ca = aux;
	struct fdc_softc *fdc = (void *)self;
	struct fdc_attach_args fa;
	struct bootpath *bp;
	int pri;
	char code;

	if (ca->ca_ra.ra_vaddr)
		fdc->sc_reg = (caddr_t)ca->ca_ra.ra_vaddr;
	else
		fdc->sc_reg = (caddr_t)mapiodev(ca->ca_ra.ra_reg, 0,
						ca->ca_ra.ra_len);

	fdc->sc_state = DEVIDLE;
	fdc->sc_itask = FDC_ITASK_NONE;
	fdc->sc_istatus = FDC_ISTATUS_NONE;
	fdc->sc_flags |= FDC_EIS;
	TAILQ_INIT(&fdc->sc_drives);

	pri = ca->ca_ra.ra_intr[0].int_pri;
	printf(" pri %d, softpri %d: ", pri, IPL_FDSOFT);
#ifdef FDC_C_HANDLER
	fdc->sc_hih.ih_fun = (void *)fdc_c_hwintr;
	fdc->sc_hih.ih_arg = fdc;
	intr_establish(pri, &fdc->sc_hih, IPL_FD, self->dv_xname);
#else
	fdciop = &fdc->sc_io;
	fdc->sc_hih.ih_vec = pri;
	if (intr_fasttrap(pri, fdchwintr, NULL, NULL) != 0) {
		printf("unable to register fast trap handler\n");
		return;
	}
	evcount_attach(&fdc->sc_hih.ih_count, self->dv_xname,
	    &fdc->sc_hih.ih_vec);
#endif
	fdc->sc_sih = softintr_establish(IPL_FDSOFT, fdcswintr, fdc);

	/* Assume a 82077 */
	fdc->sc_reg_msr = &((struct fdreg_77 *)fdc->sc_reg)->fd_msr;
	fdc->sc_reg_fifo = &((struct fdreg_77 *)fdc->sc_reg)->fd_fifo;
	fdc->sc_reg_dor = &((struct fdreg_77 *)fdc->sc_reg)->fd_dor;

	code = '7';
	if (*fdc->sc_reg_dor == NE7_RQM) {
		/*
		 * This hack from Chris Torek: apparently DOR really
		 * addresses MSR/DRS on a 82072.
		 * We used to rely on the VERSION command to tell the
		 * difference (which did not work).
		 */
		*fdc->sc_reg_dor = FDC_250KBPS;
		if (*fdc->sc_reg_dor == NE7_RQM)
			code = '2';
	}
	if (code == '7') {
		fdc->sc_flags |= FDC_82077;
		fdc->sc_flags |= FDC_NEEDMOTORWAIT;
	} else {
		fdc->sc_reg_msr = &((struct fdreg_72 *)fdc->sc_reg)->fd_msr;
		fdc->sc_reg_fifo = &((struct fdreg_72 *)fdc->sc_reg)->fd_fifo;
		fdc->sc_reg_dor = 0;
	}

	/*
	 * Configure controller; enable FIFO, Implied seek, no POLL mode?.
	 * Note: CFG_EFIFO is active-low, initial threshold value: 8
	 */
	fdc->sc_cfg = CFG_EIS|/*CFG_EFIFO|*/CFG_POLL|(8 & CFG_THRHLD_MASK);
	if (fdconf(fdc) != 0) {
		printf("%s: no drives attached\n", fdc->sc_dev.dv_xname);
		return;
	}

	if ((fdc->sc_flags & FDC_82077) != 0) {
		/* Lock configuration across soft resets. */
		fdc_wrfifo(fdc, NE7CMD_LOCK | CFG_LOCK);
		if (fdcresult(fdc) != 1)
			printf(" CFGLOCK: unexpected response");
	}

	printf("chip 8207%c\n", code);

	/*
	 * Controller and drives are represented by one and the same
	 * Openprom node, so we can as well check for the floppy boots here.
	 */
	fa.fa_bootpath = 0;
	if ((bp = ca->ca_ra.ra_bp) && strcmp(bp->name, OBP_FDNAME) == 0) {

		switch (ca->ca_bustype) {
		case BUS_MAIN:
			/*
			 * We can get the bootpath in several different
			 * formats! The faked v1 bootpath looks like /fd@@0,0.
			 * The v2 bootpath is either just /fd0, in which case
			 * `bp->val[0]' will have been set to -1, or /fd@@x,y
			 * where <x,y> is the prom address specifier.
			 */
			if (((bp->val[0] == ca->ca_ra.ra_iospace) &&
			     (bp->val[1] == (int)ca->ca_ra.ra_paddr)) ||

			    ((bp->val[0] == -1) &&	/* v2: /fd0 */
			     (bp->val[1] == 0)) ||

			    ((bp->val[0] == 0) &&	/* v1: /fd@@0,0 */
			     (bp->val[1] == 0))
			   )
				fa.fa_bootpath = bp;
			break;

		case BUS_OBIO:
			/*
			 * floppy controller on obio (such as on the sun4m),
			 * e.g.: `/obio0/SUNW,fdtwo@@0,700000'.
			 * We use "slot, offset" to determine if this is the
			 * right one.
			 */
			if ((bp->val[0] == ca->ca_slot) &&
			    (bp->val[1] == ca->ca_offset))
				fa.fa_bootpath = bp;
			break;
		}

	}

	timeout_set(&fdc->fdctimeout_to, fdctimeout, fdc);
	timeout_set(&fdc->fdcpseudointr_to, fdcpseudointr, fdc);

	/*
	 * physical limit: four drives per controller, but the dev_t
	 * only has room for 2
	 */
	for (fa.fa_drive = 0; fa.fa_drive < 2; fa.fa_drive++) {
		fa.fa_deftype = NULL;		/* unknown */
		fa.fa_deftype = &fd_types[0];	/* XXX */
		(void)config_found(self, (void *)&fa, fdprint);
	}

	bootpath_store(1, NULL);
}

int
fdmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct fdc_softc *fdc = (void *)parent;
	struct fdc_attach_args *fa = aux;
	int drive = fa->fa_drive;
	int n, ok;

	if (drive > 0)
		/* XXX - for now, punt on more than one drive */
		return (0);

	if ((fdc->sc_flags & FDC_82077) != 0) {
		/* select drive and turn on motor */
		*fdc->sc_reg_dor = drive | FDO_FRST | FDO_MOEN(drive);
		/* wait for motor to spin up */
		delay(250000);
	} else {
		auxregbisc(AUXIO4C_FDS, 0);
	}

	fdc->sc_nstat = 0;
	fdc_wrfifo(fdc, NE7CMD_RECAL);
	fdc_wrfifo(fdc, drive);

	/* wait for recalibrate */
	for (n = 0; n < 10000; n++) {
		delay(1000);
		if ((*fdc->sc_reg_msr & (NE7_RQM|NE7_DIO|NE7_CB)) == NE7_RQM) {
			/* wait a bit longer till device *really* is ready */
			delay(100000);
			if (fdc_wrfifo(fdc, NE7CMD_SENSEI))
				break;
			if (fdcresult(fdc) == 1 && fdc->sc_status[0] == 0x80)
				/*
				 * Got `invalid command'; we interpret it
				 * to mean that the re-calibrate hasn't in
				 * fact finished yet
				 */
				continue;
			break;
		}
	}
	n = fdc->sc_nstat;
#ifdef FD_DEBUG
	if (fdc_debug) {
		int i;
		printf("fdprobe: %d stati:", n);
		for (i = 0; i < n; i++)
			printf(" 0x%x", fdc->sc_status[i]);
		printf("\n");
	}
#endif
	ok = (n == 2 && (fdc->sc_status[0] & 0xf8) == 0x20) ? 1 : 0;

	/* turn off motor */
	if ((fdc->sc_flags & FDC_82077) != 0) {
		/* deselect drive and turn motor off */
		*fdc->sc_reg_dor = FDO_FRST | FDO_DS;
	} else {
		auxregbisc(0, AUXIO4C_FDS);
	}

	return (ok);
}

/*
 * Controller is working, and drive responded.  Attach it.
 */
void
fdattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct fdc_softc *fdc = (void *)parent;
	struct fd_softc *fd = (void *)self;
	struct fdc_attach_args *fa = aux;
	struct fd_type *type = fa->fa_deftype;
	int drive = fa->fa_drive;

	/* Setup timeouts */
	timeout_set(&fd->fd_motor_on_to, fd_motor_on, fd);
	timeout_set(&fd->fd_motor_off_to, fd_motor_off, fd);

	/* XXX Allow `flags' to override device type? */

	if (type)
		printf(": %s %d cyl, %d head, %d sec\n", type->name,
		    type->tracks, type->heads, type->sectrac);
	else
		printf(": density unknown\n");

	fd->sc_cylin = -1;
	fd->sc_drive = drive;
	fd->sc_deftype = type;
	fdc->sc_fd[drive] = fd;

	fdc_wrfifo(fdc, NE7CMD_SPECIFY);
	fdc_wrfifo(fdc, type->steprate);
	/* XXX head load time == 6ms */
	fdc_wrfifo(fdc, 6 | NE7_SPECIFY_NODMA);

	/*
	 * Initialize and attach the disk structure.
	 */
	fd->sc_dk.dk_flags = DKF_NOLABELREAD;
	fd->sc_dk.dk_name = fd->sc_dv.dv_xname;
	bufq_init(&fd->sc_bufq, BUFQ_DEFAULT);
	disk_attach(&fd->sc_dv, &fd->sc_dk);

	/*
	 * We're told if we're the boot device in fdcattach().
	 */
	if (fa->fa_bootpath)
		fa->fa_bootpath->dev = &fd->sc_dv;
}

int
fdactivate(struct device *self, int act)
{
	struct fd_softc *sc = (struct fd_softc *)self;
	int ret = 0;

	switch (act) {
	case DVACT_POWERDOWN:
		/* Make sure the drive motor gets turned off at shutdown time. */
		fd_motor_off(sc);
		break;
	}

	return (ret);
}

__inline struct fd_type *
fd_dev_to_type(fd, dev)
	struct fd_softc *fd;
	dev_t dev;
{
	int type = FDTYPE(dev);

	if (type > (sizeof(fd_types) / sizeof(fd_types[0])))
		return (NULL);
	return (type ? &fd_types[type - 1] : fd->sc_deftype);
}

void
fdstrategy(bp)
	register struct buf *bp;	/* IO operation to perform */
{
	struct fd_softc *fd;
	int unit = FDUNIT(bp->b_dev);
	int sz;
 	int s;

	/* Valid unit, controller, and request? */
	if (unit >= fd_cd.cd_ndevs ||
	    (fd = fd_cd.cd_devs[unit]) == 0 ||
	    bp->b_blkno < 0 ||
	    (((bp->b_bcount % FD_BSIZE(fd)) != 0 ||
	      (bp->b_blkno * DEV_BSIZE) % FD_BSIZE(fd) != 0) &&
	     (bp->b_flags & B_FORMAT) == 0)) {
		bp->b_error = EINVAL;
		goto bad;
	}

	/* If it's a null transfer, return immediately. */
	if (bp->b_bcount == 0)
		goto done;

	bp->b_resid = bp->b_bcount;
	sz = howmany(bp->b_bcount, DEV_BSIZE);

	if (bp->b_blkno + sz > (fd->sc_type->size * DEV_BSIZE) / FD_BSIZE(fd)) {
		sz = (fd->sc_type->size * DEV_BSIZE) / FD_BSIZE(fd)
		    - bp->b_blkno;
		if (sz == 0) {
			/* If exactly at end of disk, return EOF. */
			goto done;
		}
		if (sz < 0) {
			/* If past end of disk, return EINVAL. */
			bp->b_error = EINVAL;
			goto bad;
		}
		/* Otherwise, truncate request. */
		bp->b_bcount = sz << DEV_BSHIFT;
	}

#ifdef FD_DEBUG
	if (fdc_debug > 1)
	    printf("fdstrategy: b_blkno %lld b_bcount %ld blkno %lld\n",
		(long long)bp->b_blkno, bp->b_bcount,
		(long long)fd->sc_blkno);
#endif

	/* Queue transfer */
	bufq_queue(&fd->sc_bufq, bp);

	/* Queue transfer on drive, activate drive and controller if idle. */
	s = splbio();
	timeout_del(&fd->fd_motor_off_to); /* a good idea */
	if (fd->sc_bp == NULL)
		fdstart(fd);
#ifdef DIAGNOSTIC
	else {
		struct fdc_softc *fdc = (void *)fd->sc_dv.dv_parent;
		if (fdc->sc_state == DEVIDLE) {
			printf("fdstrategy: controller inactive\n");
			fdcstart(fdc);
		}
	}
#endif
	splx(s);
	return;

bad:
	bp->b_flags |= B_ERROR;
done:
	/* Toss transfer; we're done early. */
	s = splbio();
	biodone(bp);
	splx(s);
}

void
fdstart(fd)
	struct fd_softc *fd;
{
	struct fdc_softc *fdc = (void *)fd->sc_dv.dv_parent;
	int active = !TAILQ_EMPTY(&fdc->sc_drives);

	/* Link into controller queue. */
	fd->sc_bp = bufq_dequeue(&fd->sc_bufq);
	TAILQ_INSERT_TAIL(&fdc->sc_drives, fd, sc_drivechain);

	/* If controller not already active, start it. */
	if (!active)
		fdcstart(fdc);
}

void
fdfinish(fd, bp)
	struct fd_softc *fd;
	struct buf *bp;
{
	struct fdc_softc *fdc = (void *)fd->sc_dv.dv_parent;

	fd->sc_skip = 0;
	fd->sc_bp = bufq_dequeue(&fd->sc_bufq);

	/*
	 * Move this drive to the end of the queue to give others a `fair'
	 * chance.  We only force a switch if N operations are completed while
	 * another drive is waiting to be serviced, since there is a long motor
	 * startup delay whenever we switch.
	 */
	if (TAILQ_NEXT(fd, sc_drivechain) != NULL && ++fd->sc_ops >= 8) {
		fd->sc_ops = 0;
		TAILQ_REMOVE(&fdc->sc_drives, fd, sc_drivechain);
		if (fd->sc_bp != NULL)
			TAILQ_INSERT_TAIL(&fdc->sc_drives, fd, sc_drivechain);
	}

	biodone(bp);
	/* turn off motor 5s from now */
	timeout_add_sec(&fd->fd_motor_off_to, 5);
	fdc->sc_state = DEVIDLE;
}

void
fdc_reset(fdc)
	struct fdc_softc *fdc;
{
	if (fdc->sc_flags & FDC_82077) {
		*fdc->sc_reg_dor = FDO_FDMAEN | FDO_MOEN(0);
	}

	*fdc->sc_reg_drs = DRS_RESET;
	delay(10);
	*fdc->sc_reg_drs = 0;

	if (fdc->sc_flags & FDC_82077) {
		*fdc->sc_reg_dor = FDO_FRST | FDO_FDMAEN | FDO_DS;
	}
#ifdef FD_DEBUG
	if (fdc_debug)
		printf("fdc reset\n");
#endif
}

void
fd_set_motor(fdc)
	struct fdc_softc *fdc;
{
	struct fd_softc *fd;
	u_char status;
	int n;

	if (fdc->sc_flags & FDC_82077) {
		status = FDO_FRST | FDO_FDMAEN;
		if ((fd = TAILQ_FIRST(&fdc->sc_drives)) != NULL)
			status |= fd->sc_drive;

		for (n = 0; n < 4; n++)
			if ((fd = fdc->sc_fd[n]) && (fd->sc_flags & FD_MOTOR))
				status |= FDO_MOEN(n);
		*fdc->sc_reg_dor = status;
	} else {
		for (n = 0; n < 4; n++) {
			if ((fd = fdc->sc_fd[n]) != NULL &&
			    (fd->sc_flags & FD_MOTOR) != 0) {
				auxregbisc(AUXIO4C_FDS, 0);
				return;
			}
		}
		auxregbisc(0, AUXIO4C_FDS);
	}
}

void
fd_motor_off(arg)
	void *arg;
{
	struct fd_softc *fd = arg;
	int s;

	s = splbio();
	fd->sc_flags &= ~(FD_MOTOR | FD_MOTOR_WAIT);
	fd_set_motor((struct fdc_softc *)fd->sc_dv.dv_parent);
	splx(s);
}

void
fd_motor_on(arg)
	void *arg;
{
	struct fd_softc *fd = arg;
	struct fdc_softc *fdc = (void *)fd->sc_dv.dv_parent;
	int s;

	s = splbio();
	fd->sc_flags &= ~FD_MOTOR_WAIT;
	if (fd == TAILQ_FIRST(&fdc->sc_drives) && fdc->sc_state == MOTORWAIT)
		(void) fdcstate(fdc);
	splx(s);
}

/*
 * Get status bytes off the FDC after a command has finished
 * Returns the number of status bytes read; -1 on error.
 * The return value is also stored in `sc_nstat'.
 */
int
fdcresult(fdc)
	struct fdc_softc *fdc;
{
	u_char i;
	int j, n = 0;

	for (j = 100000; j; j--) {
		i = *fdc->sc_reg_msr & (NE7_DIO | NE7_RQM | NE7_CB);
		if (i == NE7_RQM)
			return (fdc->sc_nstat = n);
		if (i == (NE7_DIO | NE7_RQM | NE7_CB)) {
			if (n >= sizeof(fdc->sc_status)) {
				log(LOG_ERR, "fdcresult: overrun\n");
				return (-1);
			}
			fdc->sc_status[n++] = *fdc->sc_reg_fifo;
		} else
			delay(1);
	}

	log(LOG_ERR, "fdcresult: timeout\n");
	return (fdc->sc_nstat = -1);
}

/*
 * Write a command byte to the FDC.
 * Returns 0 on success; -1 on failure (i.e. timeout)
 */
int
fdc_wrfifo(fdc, x)
	struct fdc_softc *fdc;
	u_char x;
{
	int i;

	for (i = 100000; i-- > 0;) {
		if ((*fdc->sc_reg_msr & (NE7_DIO|NE7_RQM)) == NE7_RQM) {
			/* The chip is ready */
			*fdc->sc_reg_fifo = x;
			return (0);
		}
		delay(1);
	}
	return (-1);
}

int
fdopen(dev, flags, fmt, p)
	dev_t dev;
	int flags, fmt;
	struct proc *p;
{
 	int unit, pmask;
	struct fd_softc *fd;
	struct fd_type *type;

	unit = FDUNIT(dev);
	if (unit >= fd_cd.cd_ndevs)
		return (ENXIO);
	fd = fd_cd.cd_devs[unit];
	if (fd == NULL)
		return (ENXIO);
	type = fd_dev_to_type(fd, dev);
	if (type == NULL)
		return (ENXIO);

	if ((fd->sc_flags & FD_OPEN) != 0 &&
	    fd->sc_type != type)
		return (EBUSY);

	fd->sc_type = type;
	fd->sc_cylin = -1;
	fd->sc_flags |= FD_OPEN;

	/*
	 * Only update the disklabel if we're not open anywhere else.
	 */
	if (fd->sc_dk.dk_openmask == 0)
		fdgetdisklabel(dev, fd, fd->sc_dk.dk_label, 0);

	pmask = (1 << FDPART(dev));

	switch (fmt) {
	case S_IFCHR:
		fd->sc_dk.dk_copenmask |= pmask;
		break;

	case S_IFBLK:
		fd->sc_dk.dk_bopenmask |= pmask;
		break;
	}
	fd->sc_dk.dk_openmask =
	    fd->sc_dk.dk_copenmask | fd->sc_dk.dk_bopenmask;

	return (0);
}

int
fdclose(dev, flags, fmt, p)
	dev_t dev;
	int flags, fmt;
	struct proc *p;
{
	struct fd_softc *fd = fd_cd.cd_devs[FDUNIT(dev)];
	int pmask = (1 << FDPART(dev));

	fd->sc_flags &= ~FD_OPEN;
	fd->sc_opts &= ~(FDOPT_NORETRY|FDOPT_SILENT);

	switch (fmt) {
	case S_IFCHR:
		fd->sc_dk.dk_copenmask &= ~pmask;
		break;

	case S_IFBLK:
		fd->sc_dk.dk_bopenmask &= ~pmask;
		break;
	}
	fd->sc_dk.dk_openmask =
	    fd->sc_dk.dk_copenmask | fd->sc_dk.dk_bopenmask;

	return (0);
}

int
fdread(dev, uio, flag)
        dev_t dev;
        struct uio *uio;
	int flag;
{

        return (physio(fdstrategy, dev, B_READ, minphys, uio));
}

int
fdwrite(dev, uio, flag)
        dev_t dev;
        struct uio *uio;
	int flag;
{

        return (physio(fdstrategy, dev, B_WRITE, minphys, uio));
}

void
fdcstart(fdc)
	struct fdc_softc *fdc;
{

#ifdef DIAGNOSTIC
	/* only got here if controller's drive queue was inactive; should
	   be in idle state */
	if (fdc->sc_state != DEVIDLE) {
		printf("fdcstart: not idle\n");
		return;
	}
#endif
	(void) fdcstate(fdc);
}

void
fdcstatus(fdc, s)
	struct fdc_softc *fdc;
	char *s;
{
	struct fd_softc *fd = TAILQ_FIRST(&fdc->sc_drives);
	int n;

	/* Just print last status */
	n = fdc->sc_nstat;

#if 0
	/*
	 * A 82072 seems to return <invalid command> on
	 * gratuitous Sense Interrupt commands.
	 */
	if (n == 0 && (fdc->sc_flags & FDC_82077) != 0) {
		fdc_wrfifo(fdc, NE7CMD_SENSEI);
		(void) fdcresult(fdc);
		n = 2;
	}
#endif

	printf("%s: %s: state %d",
	    fd ? fd->sc_dv.dv_xname : "fdc", s, fdc->sc_state);

	switch (n) {
	case 0:
		printf("\n");
		break;
	case 2:
		printf(" (st0 %b cyl %d)\n",
		    fdc->sc_status[0], NE7_ST0BITS,
		    fdc->sc_status[1]);
		break;
	case 7:
		printf(" (st0 %b st1 %b st2 %b cyl %d head %d sec %d)\n",
		    fdc->sc_status[0], NE7_ST0BITS,
		    fdc->sc_status[1], NE7_ST1BITS,
		    fdc->sc_status[2], NE7_ST2BITS,
		    fdc->sc_status[3], fdc->sc_status[4], fdc->sc_status[5]);
		break;
#ifdef DIAGNOSTIC
	default:
		printf(" fdcstatus: weird size: %d\n", n);
		break;
#endif
	}
}

void
fdctimeout(arg)
	void *arg;
{
	struct fdc_softc *fdc = arg;
	struct fd_softc *fd;
	int s;

	s = splbio();
	fd = TAILQ_FIRST(&fdc->sc_drives);
	if (fd == NULL) {
		printf("%s: timeout but no I/O pending: statu %d, istatus=%d\n",
		    fdc->sc_dev.dv_xname, fdc->sc_state, fdc->sc_istatus);
		fdc->sc_state = DEVIDLE;
		goto out;
	}

	if (fd->sc_bp != NULL)
		fdc->sc_state++;
	else
		fdc->sc_state = DEVIDLE;

	(void) fdcstate(fdc);
out:
	splx(s);
}

void
fdcpseudointr(arg)
	void *arg;
{
	struct fdc_softc *fdc = arg;
	int s;

	/* Just ensure it has the right spl. */
	s = splbio();
	(void) fdcstate(fdc);
	splx(s);
}


#ifdef FDC_C_HANDLER
/*
 * hardware interrupt entry point: must be converted to `fast'
 * (in-window) handler.
 */
int
fdc_c_hwintr(fdc)
	struct fdc_softc *fdc;
{

	switch (fdc->sc_itask) {
	case FDC_ITASK_NONE:
		return (0);
	case FDC_ITASK_SENSEI:
		if (fdc_wrfifo(fdc, NE7CMD_SENSEI) != 0 || fdcresult(fdc) == -1)
			fdc->sc_istatus = FDC_ISTATUS_ERROR;
		else
			fdc->sc_istatus = FDC_ISTATUS_DONE;
		softintr_schedule(fdc->sc_sih);
		goto done;
	case FDC_ITASK_RESULT:
		if (fdcresult(fdc) == -1)
			fdc->sc_istatus = FDC_ISTATUS_ERROR;
		else
			fdc->sc_istatus = FDC_ISTATUS_DONE;
		softintr_schedule(fdc->sc_sih);
		goto done;
	case FDC_ITASK_DMA:
		/* Proceed with pseudo-DMA below */
		break;
	default:
		printf("fdc: stray hard interrupt: itask=%d\n", fdc->sc_itask);
		fdc->sc_istatus = FDC_ISTATUS_SPURIOUS;
		softintr_schedule(fdc->sc_sih);
		goto done;
	}

	/*
	 * Pseudo DMA in progress
	 */
	for (;;) {
		register int msr;

		msr = *fdc->sc_reg_msr;

		if ((msr & NE7_RQM) == 0)
			/* That's all this round */
			break;

		if ((msr & NE7_NDM) == 0) {
			fdcresult(fdc);
			fdc->sc_istatus = FDC_ISTATUS_DONE;
			softintr_schedule(fdc->sc_sih);
#ifdef FD_DEBUG
			if (fdc_debug > 1)
				printf("fdc: overrun: tc = %d\n", fdc->sc_tc);
#endif
			break;
		}

		/* Another byte can be transferred */
		if ((msr & NE7_DIO) != 0)
			*fdc->sc_data++ = *fdc->sc_reg_fifo;
		else
			*fdc->sc_reg_fifo = *fdc->sc_data++;
		if (--fdc->sc_tc == 0) {
			fdc->sc_istatus = FDC_ISTATUS_DONE;
			FTC_FLIP;
			fdcresult(fdc);
			softintr_schedule(fdc->sc_sih);
			break;
		}
	}
done:
	return (1);
}
#endif

void
fdcswintr(void *arg)
{
	struct fdc_softc *fdc = (struct fdc_softc *)arg;
	int s;

	if (fdc->sc_istatus == FDC_ISTATUS_NONE)
		/* This (software) interrupt is not for us */
		return;

	switch (fdc->sc_istatus) {
	case FDC_ISTATUS_ERROR:
		printf("fdc: ierror status: state %d\n", fdc->sc_state);
		break;
	case FDC_ISTATUS_SPURIOUS:
		printf("fdc: spurious interrupt: state %d\n", fdc->sc_state);
		break;
	}

	s = splbio();
	fdcstate(fdc);
	splx(s);
}

int
fdcstate(fdc)
	struct fdc_softc *fdc;
{
#define	st0	fdc->sc_status[0]
#define	st1	fdc->sc_status[1]
#define	cyl	fdc->sc_status[1]
#define FDC_WRFIFO(fdc, c) \
	do { \
		if (fdc_wrfifo(fdc, (c))) { \
			goto xxx; \
		} \
	} while (0)

	struct fd_softc *fd;
	struct buf *bp;
	int read, head, sec, nblks, cylin;
	struct fd_type *type;
	struct fd_formb *finfo = NULL;

	if (fdc->sc_istatus == FDC_ISTATUS_ERROR) {
		/* Prevent loop if the reset sequence produces errors */
		if (fdc->sc_state != RESETCOMPLETE &&
		    fdc->sc_state != RECALWAIT &&
		    fdc->sc_state != RECALCOMPLETE)
			fdc->sc_state = DORESET;
	}

	/* Clear I task/status field */
	fdc->sc_istatus = FDC_ISTATUS_NONE;
	fdc->sc_itask = FDC_ITASK_NONE;

loop:
	/* Is there a drive for the controller to do a transfer with? */
	fd = TAILQ_FIRST(&fdc->sc_drives);
	if (fd == NULL) {
		fdc->sc_state = DEVIDLE;
 		return (0);
	}

	/* Is there a transfer to this drive?  If not, deactivate drive. */
	bp = fd->sc_bp;
	if (bp == NULL) {
		fd->sc_ops = 0;
		TAILQ_REMOVE(&fdc->sc_drives, fd, sc_drivechain);
		goto loop;
	}

	cylin = ((bp->b_blkno * DEV_BSIZE) + (bp->b_bcount - bp->b_resid)) /
	    (FD_BSIZE(fd) * fd->sc_type->seccyl);

	if (bp->b_flags & B_FORMAT)
		finfo = (struct fd_formb *)bp->b_data;

	switch (fdc->sc_state) {
	case DEVIDLE:
		fdc->sc_errors = 0;
		fd->sc_skip = 0;
		fd->sc_bcount = bp->b_bcount;
		fd->sc_blkno = (bp->b_blkno * DEV_BSIZE) / FD_BSIZE(fd);
		timeout_del(&fd->fd_motor_off_to);
		if ((fd->sc_flags & FD_MOTOR_WAIT) != 0) {
			fdc->sc_state = MOTORWAIT;
			return (1);
		}
		if ((fd->sc_flags & FD_MOTOR) == 0) {
			/* Turn on the motor, being careful about pairing. */
			struct fd_softc *ofd = fdc->sc_fd[fd->sc_drive ^ 1];
			if (ofd && ofd->sc_flags & FD_MOTOR) {
				timeout_del(&ofd->fd_motor_off_to);
				ofd->sc_flags &= ~(FD_MOTOR | FD_MOTOR_WAIT);
			}
			fd->sc_flags |= FD_MOTOR | FD_MOTOR_WAIT;
			fd_set_motor(fdc);
			fdc->sc_state = MOTORWAIT;
			if ((fdc->sc_flags & FDC_NEEDMOTORWAIT) != 0) { /* XXX */
				/* Allow .25s for motor to stabilize. */
				timeout_add_msec(&fd->fd_motor_on_to, 250);
			} else {
				fd->sc_flags &= ~FD_MOTOR_WAIT;
				goto loop;
			}
			return (1);
		}
		/* Make sure the right drive is selected. */
		fd_set_motor(fdc);

		/*FALLTHROUGH*/
	case DOSEEK:
	doseek:
		if ((fdc->sc_flags & FDC_EIS) &&
		    (bp->b_flags & B_FORMAT) == 0) {
			fd->sc_cylin = cylin;
			/* We use implied seek */
			goto doio;
		}

		if (fd->sc_cylin == cylin)
			goto doio;

		fd->sc_cylin = -1;
		fdc->sc_state = SEEKWAIT;
		fdc->sc_nstat = 0;

		fd->sc_dk.dk_seek++;

		disk_busy(&fd->sc_dk);
		timeout_add_sec(&fdc->fdctimeout_to, 4);

		/* specify command */
		FDC_WRFIFO(fdc, NE7CMD_SPECIFY);
		FDC_WRFIFO(fdc, fd->sc_type->steprate);
		/* XXX head load time == 6ms */
		FDC_WRFIFO(fdc, 6 | NE7_SPECIFY_NODMA);

		fdc->sc_itask = FDC_ITASK_SENSEI;
		/* seek function */
		FDC_WRFIFO(fdc, NE7CMD_SEEK);
		FDC_WRFIFO(fdc, fd->sc_drive); /* drive number */
		FDC_WRFIFO(fdc, cylin * fd->sc_type->step);

		return (1);

	case DOIO:
	doio:
		if (finfo != NULL)
			fd->sc_skip = (char *)&(finfo->fd_formb_cylno(0)) -
				      (char *)finfo;
		type = fd->sc_type;
		sec = fd->sc_blkno % type->seccyl;
		nblks = type->seccyl - sec;
		nblks = min(nblks, fd->sc_bcount / FD_BSIZE(fd));
		nblks = min(nblks, FDC_MAXIOSIZE / FD_BSIZE(fd));
		fd->sc_nblks = nblks;
		fd->sc_nbytes = finfo ? bp->b_bcount : nblks * FD_BSIZE(fd);
		head = sec / type->sectrac;
		sec -= head * type->sectrac;
#ifdef DIAGNOSTIC
		{
			daddr_t block;

			block = (fd->sc_cylin * type->heads + head) *
			    type->sectrac + sec;
			if (block != fd->sc_blkno) {
				printf("fdcintr: block %lld != blkno %lld\n",
				    (long long)block, (long long)fd->sc_blkno);
#if defined(FD_DEBUG) && defined(DDB)
				Debugger();
#endif
			}
		}
#endif
		read = bp->b_flags & B_READ;

		/* Setup for pseudo DMA */
		fdc->sc_data = bp->b_data + fd->sc_skip;
		fdc->sc_tc = fd->sc_nbytes;

		*fdc->sc_reg_drs = type->rate;
#ifdef FD_DEBUG
		if (fdc_debug > 1)
			printf("fdcstate: doio: %s drive %d "
			       "track %d head %d sec %d nblks %d\n",
				finfo ? "format" :
					(read ? "read" : "write"),
				fd->sc_drive, fd->sc_cylin, head, sec, nblks);
#endif
		fdc->sc_state = IOCOMPLETE;
		fdc->sc_itask = FDC_ITASK_DMA;
		fdc->sc_nstat = 0;

		disk_busy(&fd->sc_dk);

		/* allow 3 seconds for operation */
		timeout_add_sec(&fdc->fdctimeout_to, 3);

		if (finfo != NULL) {
			/* formatting */
			FDC_WRFIFO(fdc, NE7CMD_FORMAT);
			FDC_WRFIFO(fdc, (head << 2) | fd->sc_drive);
			FDC_WRFIFO(fdc, finfo->fd_formb_secshift);
			FDC_WRFIFO(fdc, finfo->fd_formb_nsecs);
			FDC_WRFIFO(fdc, finfo->fd_formb_gaplen);
			FDC_WRFIFO(fdc, finfo->fd_formb_fillbyte);
		} else {
			if (read)
				FDC_WRFIFO(fdc, NE7CMD_READ);
			else
				FDC_WRFIFO(fdc, NE7CMD_WRITE);
			FDC_WRFIFO(fdc, (head << 2) | fd->sc_drive);
			FDC_WRFIFO(fdc, fd->sc_cylin);	/*track*/
			FDC_WRFIFO(fdc, head);
			FDC_WRFIFO(fdc, sec + 1);	/*sector+1*/
			FDC_WRFIFO(fdc, type->secsize);	/*sector size*/
			FDC_WRFIFO(fdc, type->sectrac);	/*secs/track*/
			FDC_WRFIFO(fdc, type->gap1);	/*gap1 size*/
			FDC_WRFIFO(fdc, type->datalen);	/*data length*/
		}

		return (1);				/* will return later */

	case SEEKWAIT:
		timeout_del(&fdc->fdctimeout_to);
		fdc->sc_state = SEEKCOMPLETE;
		if (fdc->sc_flags & FDC_NEEDHEADSETTLE) {
			/* allow 1/50 second for heads to settle */
			timeout_add_msec(&fdc->fdcpseudointr_to, 20);
			return (1);		/* will return later */
		}
		/*FALLTHROUGH*/
	case SEEKCOMPLETE:
		disk_unbusy(&fd->sc_dk, 0, 0);	/* no data on seek */

		/* Make sure seek really happened. */
		if (fdc->sc_nstat != 2 || (st0 & 0xf8) != 0x20 ||
		    cyl != cylin * fd->sc_type->step) {
#ifdef FD_DEBUG
			if (fdc_debug)
				fdcstatus(fdc, "seek failed");
#endif
			fdcretry(fdc);
			goto loop;
		}
		fd->sc_cylin = cylin;
		goto doio;

	case IOTIMEDOUT:
		/*
		 * Try to abort the I/O operation without resetting
		 * the chip first.  Poke TC and arrange to pick up
		 * the timed out I/O command's status.
		 */
		fdc->sc_itask = FDC_ITASK_RESULT;
		fdc->sc_state = IOCLEANUPWAIT;
		fdc->sc_nstat = 0;
		/* 1/10 second should be enough */
		timeout_add_msec(&fdc->fdctimeout_to, 100);
		return (1);

	case IOCLEANUPTIMEDOUT:
	case SEEKTIMEDOUT:
	case RECALTIMEDOUT:
	case RESETTIMEDOUT:
		fdcstatus(fdc, "timeout");

		/* All other timeouts always roll through a chip reset */
		fdcretry(fdc);

		/* Force reset, no matter what fdcretry() says */
		fdc->sc_state = DORESET;
		goto loop;

	case IOCLEANUPWAIT: /* IO FAILED, cleanup succeeded */
		timeout_del(&fdc->fdctimeout_to);
		disk_unbusy(&fd->sc_dk, (bp->b_bcount - bp->b_resid),
		    (bp->b_flags & B_READ));
		fdcretry(fdc);
		goto loop;

	case IOCOMPLETE: /* IO DONE, post-analyze */
		timeout_del(&fdc->fdctimeout_to);

		disk_unbusy(&fd->sc_dk, (bp->b_bcount - bp->b_resid),
		    (bp->b_flags & B_READ));

		if (fdc->sc_nstat != 7 || st1 != 0 ||
		    ((st0 & 0xf8) != 0 &&
		     ((st0 & 0xf8) != 0x20 || (fdc->sc_cfg & CFG_EIS) == 0))) {
#ifdef FD_DEBUG
			if (fdc_debug) {
				fdcstatus(fdc,
					bp->b_flags & B_READ
					? "read failed" : "write failed");
				printf("blkno %lld nblks %d nstat %d tc %d\n",
				       (long long)fd->sc_blkno, fd->sc_nblks,
				       fdc->sc_nstat, fdc->sc_tc);
			}
#endif
			if (fdc->sc_nstat == 7 &&
			    (st1 & ST1_OVERRUN) == ST1_OVERRUN) {

				/*
				 * Silently retry overruns if no other
				 * error bit is set. Adjust threshold.
				 */
				int thr = fdc->sc_cfg & CFG_THRHLD_MASK;
				if (thr < 15) {
					thr++;
					fdc->sc_cfg &= ~CFG_THRHLD_MASK;
					fdc->sc_cfg |= (thr & CFG_THRHLD_MASK);
#ifdef FD_DEBUG
					if (fdc_debug)
						printf("fdc: %d -> threshold\n", thr);
#endif
					fdconf(fdc);
					fdc->sc_overruns = 0;
				}
				if (++fdc->sc_overruns < 3) {
					fdc->sc_state = DOIO;
					goto loop;
				}
			}
			fdcretry(fdc);
			goto loop;
		}
		if (fdc->sc_errors) {
			diskerr(bp, "fd", "soft error", LOG_PRINTF,
			    fd->sc_skip / FD_BSIZE(fd),
			    (struct disklabel *)NULL);
			printf("\n");
			fdc->sc_errors = 0;
		} else {
			if (--fdc->sc_overruns < -20) {
				int thr = fdc->sc_cfg & CFG_THRHLD_MASK;
				if (thr > 0) {
					thr--;
					fdc->sc_cfg &= ~CFG_THRHLD_MASK;
					fdc->sc_cfg |= (thr & CFG_THRHLD_MASK);
#ifdef FD_DEBUG
					if (fdc_debug)
						printf("fdc: %d -> threshold\n", thr);
#endif
					fdconf(fdc);
				}
				fdc->sc_overruns = 0;
			}
		}
		fd->sc_blkno += fd->sc_nblks;
		fd->sc_skip += fd->sc_nbytes;
		fd->sc_bcount -= fd->sc_nbytes;
		bp->b_resid -= fd->sc_nbytes;
		if (finfo == NULL && fd->sc_bcount > 0) {
			cylin = fd->sc_blkno / fd->sc_type->seccyl;
			goto doseek;
		}
		fdfinish(fd, bp);
		goto loop;

	case DORESET:
		/* try a reset, keep motor on */
		fd_set_motor(fdc);
		delay(100);
		fdc->sc_nstat = 0;
		fdc->sc_itask = FDC_ITASK_SENSEI;
		fdc->sc_state = RESETCOMPLETE;
		timeout_add_msec(&fdc->fdctimeout_to, 500);
		fdc_reset(fdc);
		return (1);			/* will return later */

	case RESETCOMPLETE:
		timeout_del(&fdc->fdctimeout_to);
		fdconf(fdc);

		/* FALLTHROUGH */
	case DORECAL:
		fdc->sc_state = RECALWAIT;
		fdc->sc_itask = FDC_ITASK_SENSEI;
		fdc->sc_nstat = 0;
		timeout_add_sec(&fdc->fdctimeout_to, 5);
		/* recalibrate function */
		FDC_WRFIFO(fdc, NE7CMD_RECAL);
		FDC_WRFIFO(fdc, fd->sc_drive);
		return (1);			/* will return later */

	case RECALWAIT:
		timeout_del(&fdc->fdctimeout_to);
		fdc->sc_state = RECALCOMPLETE;
		if (fdc->sc_flags & FDC_NEEDHEADSETTLE) {
			/* allow 1/30 second for heads to settle */
			timeout_add(&fdc->fdcpseudointr_to, hz / 30);
			return (1);		/* will return later */
		}

	case RECALCOMPLETE:
		if (fdc->sc_nstat != 2 || (st0 & 0xf8) != 0x20 || cyl != 0) {
#ifdef FD_DEBUG
			if (fdc_debug)
				fdcstatus(fdc, "recalibrate failed");
#endif
			fdcretry(fdc);
			goto loop;
		}
		fd->sc_cylin = 0;
		goto doseek;

	case MOTORWAIT:
		if (fd->sc_flags & FD_MOTOR_WAIT)
			return (1);		/* time's not up yet */
		goto doseek;

	default:
		fdcstatus(fdc, "stray interrupt");
		return (1);
	}
#ifdef DIAGNOSTIC
	panic("fdcintr: impossible");
#endif

xxx:
	/*
	 * We get here if the chip locks up in FDC_WRFIFO()
	 * Cancel any operation and schedule a reset.
	 */
	timeout_del(&fdc->fdctimeout_to);
	fdcretry(fdc);
	fdc->sc_state = DORESET;
	goto loop;

#undef	st0
#undef	st1
#undef	cyl
}

void
fdcretry(fdc)
	struct fdc_softc *fdc;
{
	struct fd_softc *fd;
	struct buf *bp;
	int error = EIO;

	fd = TAILQ_FIRST(&fdc->sc_drives);
	bp = fd->sc_bp;

	fdc->sc_overruns = 0;
	if (fd->sc_opts & FDOPT_NORETRY)
		goto fail;

	switch (fdc->sc_errors) {
	case 0:
		if (fdc->sc_nstat == 7 &&
		    (fdc->sc_status[0] & 0xd8) == 0x40 &&
		    (fdc->sc_status[1] & 0x2) == 0x2) {
			printf("%s: read-only medium\n", fd->sc_dv.dv_xname);
			error = EROFS;
			goto failsilent;
		}
		/* try again */
		fdc->sc_state =
			(fdc->sc_flags & FDC_EIS) ? DOIO : DOSEEK;
		break;

	case 1: case 2: case 3:
		/* didn't work; try recalibrating */
		fdc->sc_state = DORECAL;
		break;

	case 4:
		if (fdc->sc_nstat == 7 &&
		    fdc->sc_status[0] == 0 &&
		    fdc->sc_status[1] == 0 &&
		    fdc->sc_status[2] == 0) {
			/*
			 * We've retried a few times and we've got
			 * valid status and all three status bytes
			 * are zero.  Assume this condition is the
			 * result of no disk loaded into the drive.
			 */
			printf("%s: no medium?\n", fd->sc_dv.dv_xname);
			error = ENODEV;
			goto failsilent;
		}

		/* still no go; reset the bastard */
		fdc->sc_state = DORESET;
		break;

	default:
	fail:
		if ((fd->sc_opts & FDOPT_SILENT) == 0) {
			diskerr(bp, "fd", "hard error", LOG_PRINTF,
				fd->sc_skip / FD_BSIZE(fd),
				(struct disklabel *)NULL);
			printf("\n");
			fdcstatus(fdc, "controller status");
		}

	failsilent:
		bp->b_flags |= B_ERROR;
		bp->b_error = error;
		bp->b_resid = bp->b_bcount;
		fdfinish(fd, bp);
	}
	fdc->sc_errors++;
}

daddr_t
fdsize(dev)
	dev_t dev;
{

	/* Swapping to floppies would not make sense. */
	return (-1);
}

int
fddump(dev, blkno, va, size)
	dev_t dev;
	daddr_t blkno;
	caddr_t va;
	size_t size;
{

	/* Not implemented. */
	return (EINVAL);
}

int
fdioctl(dev, cmd, addr, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
{
	struct fd_softc *fd = fd_cd.cd_devs[FDUNIT(dev)];
	struct disklabel *lp;
	int error;

	switch (cmd) {
	case DIOCRLDINFO:
		lp = malloc(sizeof(*lp), M_TEMP, M_WAITOK);
		fdgetdisklabel(dev, fd, lp, 0);
		bcopy(lp, fd->sc_dk.dk_label, sizeof(*lp));
		free(lp, M_TEMP, sizeof *lp);
		return 0;

	case DIOCGPDINFO:
		fdgetdisklabel(dev, fd, (struct disklabel *)addr, 1);
		return 0;

	case DIOCGDINFO:
		*(struct disklabel *)addr = *(fd->sc_dk.dk_label);
		return 0;

	case DIOCGPART:
		((struct partinfo *)addr)->disklab = fd->sc_dk.dk_label;
		((struct partinfo *)addr)->part =
		    &fd->sc_dk.dk_label->d_partitions[FDPART(dev)];
		return 0;

	case DIOCWDINFO:
	case DIOCSDINFO:
		if ((flag & FWRITE) == 0)
			return (EBADF);

		error = setdisklabel(fd->sc_dk.dk_label,
		    (struct disklabel *)addr, 0);
		if (error == 0) {
			if (cmd == DIOCWDINFO)
				error = writedisklabel(DISKLABELDEV(dev),
				    fdstrategy, fd->sc_dk.dk_label);
		}
		return (error);

	case DIOCLOCK:
		/*
		 * Nothing to do here, really.
		 */
		return (0);

	case MTIOCTOP:
		if (((struct mtop *)addr)->mt_op != MTOFFL)
			return EIO;

	case DIOCEJECT:
		fd_do_eject(fd);
		return (0);

	case FD_FORM:
		if((flag & FWRITE) == 0)
			return EBADF;	/* must be opened for writing */
		else if(((struct fd_formb *)addr)->format_version !=
		    FD_FORMAT_VERSION)
			return EINVAL;	/* wrong version of formatting prog */
		else
			return fdformat(dev, (struct fd_formb *)addr, p);
		break;

	case FD_GTYPE:			/* get drive type */
		*(struct fd_type *)addr = *fd->sc_type;
		return (0);

	case FD_GOPTS:			/* get drive options */
		*(int *)addr = fd->sc_opts;
		return (0);

	case FD_SOPTS:			/* set drive options */
		fd->sc_opts = *(int *)addr;
		return (0);

#ifdef FD_DEBUG
	case _IO('f', 100):
		{
		int i;
		struct fdc_softc *fdc = (struct fdc_softc *)
					fd->sc_dv.dv_parent;

		fdc_wrfifo(fdc, NE7CMD_DUMPREG);
		fdcresult(fdc);
		printf("dumpreg(%d regs): <", fdc->sc_nstat);
		for (i = 0; i < fdc->sc_nstat; i++)
			printf(" 0x%x", fdc->sc_status[i]);
		printf(">\n");
		}

		return (0);
	case _IOW('f', 101, int):
		{
		struct fdc_softc *fdc = (struct fdc_softc *)
					fd->sc_dv.dv_parent;
		fdc->sc_cfg &= ~CFG_THRHLD_MASK;
		fdc->sc_cfg |= (*(int *)addr & CFG_THRHLD_MASK);
		fdconf(fdc);
		}
		return (0);
	case _IO('f', 102):
		{
		int i;
		struct fdc_softc *fdc = (struct fdc_softc *)
					fd->sc_dv.dv_parent;
		fdc_wrfifo(fdc, NE7CMD_SENSEI);
		fdcresult(fdc);
		printf("sensei(%d regs): <", fdc->sc_nstat);
		for (i = 0; i < fdc->sc_nstat; i++)
			printf(" 0x%x", fdc->sc_status[i]);
		}
		printf(">\n");
		return (0);
#endif
	default:
		return (ENOTTY);
	}
}

int
fdformat(dev, finfo, p)
	dev_t dev;
	struct fd_formb *finfo;
	struct proc *p;
{
	int rv = 0;
	struct fd_softc *fd = fd_cd.cd_devs[FDUNIT(dev)];
	struct fd_type *type = fd->sc_type;
	struct buf *bp;

	/* set up a buffer header for fdstrategy() */
	bp = malloc(sizeof(*bp), M_TEMP, M_NOWAIT | M_ZERO);
	if (bp == 0)
		return (ENOBUFS);

	bp->b_flags = B_BUSY | B_PHYS | B_FORMAT | B_RAW;
	bp->b_proc = p;
	bp->b_dev = dev;

	/*
	 * Calculate a fake blkno, so fdstrategy() would initiate a
	 * seek to the requested cylinder.
	 */
	bp->b_blkno = ((finfo->cyl * (type->sectrac * type->heads)
		       + finfo->head * type->sectrac) * FD_BSIZE(fd))
		       / DEV_BSIZE;

	bp->b_bcount = sizeof(struct fd_idfield_data) * finfo->fd_formb_nsecs;
	bp->b_data = (caddr_t)finfo;

#ifdef FD_DEBUG
	if (fdc_debug) {
		int i;

		printf("fdformat: blkno 0x%x count %ld\n",
			bp->b_blkno, bp->b_bcount);

		printf("\tcyl:\t%d\n", finfo->cyl);
		printf("\thead:\t%d\n", finfo->head);
		printf("\tnsecs:\t%d\n", finfo->fd_formb_nsecs);
		printf("\tsshft:\t%d\n", finfo->fd_formb_secshift);
		printf("\tgaplen:\t%d\n", finfo->fd_formb_gaplen);
		printf("\ttrack data:");
		for (i = 0; i < finfo->fd_formb_nsecs; i++) {
			printf(" [c%d h%d s%d]",
					finfo->fd_formb_cylno(i),
					finfo->fd_formb_headno(i),
					finfo->fd_formb_secno(i) );
			if (finfo->fd_formb_secsize(i) != 2)
				printf("<sz:%d>", finfo->fd_formb_secsize(i));
		}
		printf("\n");
	}
#endif

	/* now do the format */
	fdstrategy(bp);

	/* ...and wait for it to complete */
	rv = biowait(bp);
	free(bp, M_TEMP, sizeof *bp);
	return (rv);
}

int
fdgetdisklabel(dev_t dev, struct fd_softc *fd, struct disklabel *lp,
    int spoofonly)
{
	bzero(lp, sizeof(struct disklabel));

	lp->d_type = DTYPE_FLOPPY;
	lp->d_secsize = FD_BSIZE(fd);
	lp->d_secpercyl = fd->sc_type->seccyl;
	lp->d_nsectors = fd->sc_type->sectrac;
	lp->d_ncylinders = fd->sc_type->tracks;
	lp->d_ntracks = fd->sc_type->heads;	/* Go figure... */
	DL_SETDSIZE(lp, fd->sc_type->size);

	strncpy(lp->d_typename, "floppy disk", sizeof(lp->d_typename));
	strncpy(lp->d_packname, "fictitious", sizeof(lp->d_packname));
	lp->d_version = 1;

	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = dkcksum(lp);

	/*
	 * Call the generic disklabel extraction routine.
	 */
	return readdisklabel(DISKLABELDEV(dev), fdstrategy, lp, spoofonly);
}

void
fd_do_eject(fd)
	struct fd_softc *fd;
{
	struct fdc_softc *fdc = (void *)fd->sc_dv.dv_parent;

	if (CPU_ISSUN4C) {
		auxregbisc(AUXIO4C_FDS, AUXIO4C_FEJ);
		delay(10);
		auxregbisc(AUXIO4C_FEJ, AUXIO4C_FDS);
		return;
	}
	if (CPU_ISSUN4M && (fdc->sc_flags & FDC_82077) != 0) {
		int dor = FDO_FRST | FDO_FDMAEN | FDO_MOEN(0);
		*fdc->sc_reg_dor = dor | FDO_EJ;
		delay(10);
		*fdc->sc_reg_dor = FDO_FRST | FDO_DS;
		return;
	}
}
@


1.90
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.89 2013/11/26 15:42:43 martin Exp $	*/
d1769 1
a1769 1
		free(lp, M_TEMP, 0);
d1941 1
a1941 1
	free(bp, M_TEMP, 0);
@


1.89
log
@make this compile after dlg's recent change
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.88 2013/11/21 00:13:33 dlg Exp $	*/
d1769 1
a1769 1
		free(lp, M_TEMP);
d1941 1
a1941 1
	free(bp, M_TEMP);
@


1.88
log
@remove the #define b_cylinder b_resid from bufs. i hated the
overloading of that thing.

the only hardware that seems to care about cylinders in our tree
are floppy drives, and the drivers for those calculate their own
cylinders from logical block addresses and ignore whatever the rest
of the kernel thought b_cylinders should be.

most of this diff is moving the floppy drivers to using b_resid as
a resid and using that as part of the calculation for real cylinder
values.

the rest of the diff is getting rid of the useless assignments to
b_cylinder that dont get used by anything (now that disksort is
gone).

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.87 2013/11/18 01:56:35 dlg Exp $	*/
d708 1
a708 1
	bp->b_resid = bp->b_count;
@


1.87
log
@replace disksort with bufqs. basically a copy of the same change in sparc64
which was a copy of the change in isa/fd.c.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.86 2013/11/12 16:04:09 krw Exp $	*/
d708 1
a715 1
			bp->b_resid = bp->b_bcount;
a726 3
 	bp->b_cylinder = (bp->b_blkno * DEV_BSIZE) /
	    (FD_BSIZE(fd) * fd->sc_type->seccyl);

d729 3
a731 3
	    printf("fdstrategy: b_blkno %lld b_bcount %ld blkno %lld "
		"cylin %ld\n", (long long)bp->b_blkno, bp->b_bcount,
		(long long)fd->sc_blkno, bp->b_cylinder);
a801 1
	bp->b_resid = fd->sc_bcount;
d1261 1
a1261 1
	int read, head, sec, nblks;
a1264 1

d1293 3
d1337 1
a1337 1
			fd->sc_cylin = bp->b_cylinder;
d1342 1
a1342 1
		if (fd->sc_cylin == bp->b_cylinder)
d1364 1
a1364 1
		FDC_WRFIFO(fdc, bp->b_cylinder * fd->sc_type->step);
d1460 1
a1460 1
		    cyl != bp->b_cylinder * fd->sc_type->step) {
d1468 1
a1468 1
		fd->sc_cylin = bp->b_cylinder;
d1575 1
d1577 1
a1577 1
			bp->b_cylinder = fd->sc_blkno / fd->sc_type->seccyl;
d1725 1
@


1.86
log
@Use daddr_t to hold calculated disk sector address. %d -> %lld to
match. Whitespace tweaks. All bringing this chunk into identity
with same chunk in sparc64 fd.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.85 2013/11/01 17:36:19 krw Exp $	*/
d220 2
a221 1
	struct buf sc_q;	/* head of buf chain */
d646 1
d737 3
a741 1
	disksort(&fd->sc_q, bp);
d743 1
a743 1
	if (!fd->sc_q.b_active)
d774 1
a774 1
	fd->sc_q.b_active = 1;
d789 3
d801 1
a801 1
		if (bp->b_actf) {
a802 2
		} else
			fd->sc_q.b_active = 0;
d804 1
a805 3
	fd->sc_skip = 0;
	fd->sc_q.b_actf = bp->b_actf;

d1123 1
a1123 1
	if (fd->sc_q.b_actf)
d1291 1
a1291 1
	bp = fd->sc_q.b_actf;
a1294 1
		fd->sc_q.b_active = 0;
d1668 1
a1668 1
	bp = fd->sc_q.b_actf;
@


1.85
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.84 2013/06/11 16:42:11 deraadt Exp $	*/
d1383 8
a1390 6
		{int block;
		 block = (fd->sc_cylin * type->heads + head) * type->sectrac +
		     sec;
		 if (block != fd->sc_blkno) {
			 printf("fdcintr: block %d != blkno %lld\n", block,
			     (long long)fd->sc_blkno);
d1392 1
a1392 1
			 Debugger();
d1394 2
a1395 1
		 }}
@


1.84
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.83 2013/05/30 16:15:01 deraadt Exp $	*/
d730 3
a732 2
	    printf("fdstrategy: b_blkno %d b_bcount %ld blkno %lld cylin %ld\n",
		    bp->b_blkno, bp->b_bcount, fd->sc_blkno, bp->b_cylinder);
d1384 2
a1385 1
		 block = (fd->sc_cylin * type->heads + head) * type->sectrac + sec;
d1387 2
a1388 1
			 printf("fdcintr: block %d != blkno %lld\n", block, fd->sc_blkno);
d1516 1
a1516 1
				       fd->sc_blkno, fd->sc_nblks,
@


1.83
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.82 2013/01/01 01:00:14 miod Exp $	*/
d204 1
a204 1
	daddr64_t sc_blkno;	/* starting block number */
d1723 1
a1723 1
daddr64_t
d1735 1
a1735 1
	daddr64_t blkno;
@


1.82
log
@Fix gap value when formatting 1.44MB 3"1/2 floppy disks; from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.81 2011/06/05 18:40:33 matthew Exp $	*/
a217 2
	void	*sc_sdhook;	/* shutdownhook cookie */

d229 1
d232 2
a233 1
	sizeof(struct fd_softc), fdmatch, fdattach
d652 14
d667 1
a667 2
	/* Make sure the drive motor gets turned off at shutdown time. */
	fd->sc_sdhook = shutdownhook_establish(fd_motor_off, fd);
@


1.81
log
@Drop kernel support for the useless DIOCWLABEL ioctl and prune a lot
of silly flag twiddling code in various disk drivers.

ok deraadt@@, miod@@

N.B., users will need a -current disklabel(8) to be able to write new
disklabels to disk now.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.80 2010/11/18 21:13:19 miod Exp $	*/
d190 1
a190 1
	{ 18,2,36,2,0xff,0xcf,0x1b,0x54,80,2880,1,FDC_500KBPS, "1.44MB"    }, /* 1.44MB diskette */
@


1.80
log
@Do not #include <sys/dkstat.h> if you don't need anything from it.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.79 2010/09/28 12:39:17 miod Exp $	*/
a1763 6

	case DIOCWLABEL:
		if ((flag & FWRITE) == 0)
			return EBADF;
		/* XXX do something */
		return (0);
@


1.79
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.78 2010/09/23 13:11:38 jsing Exp $	*/
a79 1
#include <sys/dkstat.h>
@


1.78
log
@Introduce a DKF_NOLABELREAD flag, which is used by a device to prevent
automatic reading of disklabel on attach.

ok deraadt@@ miod@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.76 2010/09/20 06:33:47 matthew Exp $	*/
d646 1
a646 1
	disk_attach(&fd->sc_dev, &fd->sc_dk);
@


1.77
log
@All users of physio(9) now pass NULL as the buf pointer argument, so
no point in keeping it around.

"i like this" thib@@ (a while back); ok krw@@ and oga@@; reminder to
update the man page and tweaks jmc@@
@
text
@d644 1
@


1.76
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.75 2010/09/08 14:47:10 jsing Exp $	*/
d1010 1
a1010 1
        return (physio(fdstrategy, NULL, dev, B_READ, minphys, uio));
d1020 1
a1020 1
        return (physio(fdstrategy, NULL, dev, B_WRITE, minphys, uio));
@


1.75
log
@Store a struct device pointer within struct disk and populate this when
disk_attach() is called by the device driver. We will be building on
this shortly.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.73 2010/08/17 20:05:06 miod Exp $	*/
d429 1
a429 1
	    &fdc->sc_hih.ih_vec, &evcount_intr);
@


1.74
log
@Garbage collect struct dkdriver.

ok miod@@; "please go ahead" jsing@@
@
text
@d645 1
a645 1
	disk_attach(&fd->sc_dk);
@


1.73
log
@Make sure fast trap handlers correctly invoke soft interrupts by marking
them explicitely pending before triggering the softintr; I am ashamed I did
not notice this when changing the soft interrupt code 18 months ago.
Noticed by claudio@@ and beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.72 2010/07/10 19:32:24 miod Exp $	*/
a246 2
struct dkdriver fddkdriver = { fdstrategy };

a644 1
	fd->sc_dk.dk_driver = &fddkdriver;
@


1.72
log
@sun4e (i.e. SPARCengine 1e) support. This platform is a mix between sun4 and
sun4c, as it has a sun4c OpenPROM but a sun4 8KB pagesize. VME devices are
not supported yet.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.71 2010/07/02 19:57:15 tedu Exp $	*/
a141 1
	void		*sc_sih;	/* softintr cookie */
d166 1
@


1.71
log
@remove support for compat_sunos (and m68k4k).  ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.70 2010/05/23 10:49:19 dlg Exp $	*/
d284 1
a284 1
	 * Floppy doesn't exist on sun4.
d286 1
a286 1
	if (CPU_ISSUN4)
@


1.70
log
@add dkio.h to the last of the disk ioctl users i can find.

requested by deraadt@@ who was rightly disparaging of my grep skillz.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.69 2010/04/23 15:25:21 jsing Exp $	*/
a1797 3
#ifdef COMPAT_SUNOS
	case SUNOS_FDIOCEJECT:
#endif
@


1.69
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.67 2009/08/24 08:52:13 jasper Exp $	*/
d92 1
@


1.68
log
@Add DIOCSDINFO support to the three fd drivers. No change to existing
behaviour.
@
text
@a1947 1
	lp->d_rpm = 300;	/* XXX like it matters... */
a1950 1
	lp->d_interleave = 1;
@


1.67
log
@- fix format strings for values that are daddr64_t

ok otto@@, agreed by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.66 2009/08/13 15:23:12 deraadt Exp $	*/
d1774 1
d1780 5
a1784 5
		if (error)
			return (error);

		error = writedisklabel(DISKLABELDEV(dev), fdstrategy,
		    fd->sc_dk.dk_label);
@


1.66
log
@Replace the error strings that were being passed around with much simpler
errnos.  Note that the error strings are being ignored, since we long ago
decided to not spam the console, and there is no other nice way to use the
errors (without changing the ioctls to pass it back)
The errno is now useful, since we can pass b_error from failing IO up, and
the drive can decide how to use that
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.65 2009/07/24 08:07:39 blambert Exp $	*/
d719 1
a719 1
	    printf("fdstrategy: b_blkno %d b_bcount %ld blkno %d cylin %ld\n",
d1374 1
a1374 1
			 printf("fdcintr: block %d != blkno %d\n", block, fd->sc_blkno);
d1501 1
a1501 1
				printf("blkno %d nblks %d nstat %d tc %d\n",
@


1.65
log
@timeout_add -> timeout_add_msec

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.64 2009/04/10 20:53:51 miod Exp $	*/
d240 1
a240 1
void fdgetdisklabel(dev_t, struct fd_softc *, struct disklabel *, int);
d1934 1
a1934 1
void
a1937 2
	char *errstring;

d1961 1
a1961 4
	errstring = readdisklabel(DISKLABELDEV(dev), fdstrategy, lp, spoofonly);
	if (errstring) {
		/*printf("%s: %s\n", fd->sc_dv.dv_xname, errstring);*/
	}
@


1.64
log
@generic soft interrupts support for sparc. Soft interrupt handlers are now
kept in a separate intrhand array, with their own enable bits so that
soft interrupts sharing the same level only get invoked if really triggered.
Inspired by NetBSD with significant changes.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.63 2008/10/15 19:12:19 blambert Exp $	*/
d1310 1
a1310 1
				timeout_add(&fd->fd_motor_on_to, hz / 4);
d1434 1
a1434 1
			timeout_add(&fdc->fdcpseudointr_to, hz / 50);
d1464 1
a1464 1
		timeout_add(&fdc->fdctimeout_to, hz / 10);
d1572 1
a1572 1
		timeout_add(&fdc->fdctimeout_to, hz / 2);
@


1.63
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.62 2008/06/26 05:42:13 ray Exp $	*/
d141 1
a141 1
	struct intrhand sc_sih;
d264 1
a264 1
int	fdcswintr(struct fdc_softc *);
a271 19
#if IPL_FDSOFT == 4
#define IE_FDSOFT	IE_L4
#else
#error 4
#endif

#ifdef FDC_C_HANDLER
#if defined(SUN4M)
#define FD_SET_SWINTR do {		\
	if (CPU_ISSUN4M)		\
		raise(0, IPL_FDSOFT);	\
	else				\
		ienab_bis(IE_FDSOFT);	\
} while(0)
#else
#define FD_SET_SWINTR ienab_bis(IE_FDSOFT)
#endif /* defined(SUN4M) */
#endif /* FDC_C_HANDLER */

d432 1
a432 3
	fdc->sc_sih.ih_fun = (void *)fdcswintr;
	fdc->sc_sih.ih_arg = fdc;
	intr_establish(IPL_FDSOFT, &fdc->sc_sih, IPL_BIO, self->dv_xname);
d1150 1
a1150 1
		FD_SET_SWINTR;
d1157 1
a1157 1
		FD_SET_SWINTR;
d1165 1
a1165 1
		FD_SET_SWINTR;
d1184 1
a1184 1
			FD_SET_SWINTR;
d1201 1
a1201 1
			FD_SET_SWINTR;
d1210 2
a1211 3
int
fdcswintr(fdc)
	struct fdc_softc *fdc;
d1213 1
d1218 1
a1218 1
		return (0);
a1231 1
	return (1);
@


1.62
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.61 2008/06/12 06:58:37 deraadt Exp $	*/
d814 1
a814 1
	timeout_add(&fd->fd_motor_off_to, 5 * hz);
d1362 1
a1362 1
		timeout_add(&fdc->fdctimeout_to, 4 * hz);
d1424 1
a1424 1
		timeout_add(&fdc->fdctimeout_to, 3 * hz);
d1607 1
a1607 1
		timeout_add(&fdc->fdctimeout_to, 5 * hz);
@


1.61
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.59 2008/06/10 20:50:23 beck Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.60
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.58 2008/03/22 22:54:43 krw Exp $	*/
d1914 1
a1914 1
	bp->b_flags = B_BUSY | B_PHYS | B_FORMAT;
@


1.59
log
@Fix buffer cache pending read statistics by ensuring we can identify
biowait() reads that do *not* come from the buffer cache - we use the
B_RAW flag to identify these at art's suggestion - since it makes sense
and the flag was not being used. this just flags all these buffers with
B_RAW - biodone already ignores returned buffers marked B_RAW.
ok art@@
@
text
@d1914 1
a1914 1
	bp->b_flags = B_BUSY | B_PHYS | B_FORMAT | B_RAW;
@


1.58
log
@Add support for DIOCRLDINFO, DIOCGPDINFO, DIOCGPART to the fd
driver(s). Adapted from sd driver.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.57 2008/03/20 00:59:37 krw Exp $	*/
d1914 1
a1914 1
	bp->b_flags = B_BUSY | B_PHYS | B_FORMAT;
@


1.57
log
@Bring isa/fd.c into line with sparc/sparc64 fd code and prepare all
for the addition of missing disklabel related ioctl's.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.56 2007/11/27 16:22:13 martynas Exp $	*/
d1771 1
d1775 11
d1788 6
@


1.56
log
@typos;  ok jmc@@
sys/dev/pci/pciide.c from naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.55 2007/10/01 16:11:19 krw Exp $	*/
d247 1
a247 1
void fdgetdisklabel(dev_t);
d987 1
a987 1
		fdgetdisklabel(dev);
d1946 2
a1947 2
fdgetdisklabel(dev)
	dev_t dev;
a1948 3
	int unit = FDUNIT(dev);
	struct fd_softc *fd = fd_cd.cd_devs[unit];
	struct disklabel *lp = fd->sc_dk.dk_label;
d1974 1
a1974 1
	errstring = readdisklabel(DISKLABELDEV(dev), fdstrategy, lp, 0);
@


1.55
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...' where
obvious.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.54 2007/06/20 18:15:47 deraadt Exp $	*/
d398 1
a398 1
		/* Lock configuration accross soft resets. */
@


1.54
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.53 2007/06/08 05:27:58 deraadt Exp $	*/
d1892 1
a1892 1
	bp = (struct buf *)malloc(sizeof(struct buf), M_TEMP, M_NOWAIT);
a1895 1
	bzero((void *)bp, sizeof(struct buf));
@


1.53
log
@all drivers should spoof version 1 labels
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.52 2007/06/07 00:14:20 deraadt Exp $	*/
d1789 1
a1789 2
				    (struct disklabel *)addr, 0,
				    fd->sc_dk.dk_cpulabel);
d1794 1
a1794 2
				       fd->sc_dk.dk_label,
				       fd->sc_dk.dk_cpulabel);
a1952 1
	struct cpu_disklabel *clp = fd->sc_dk.dk_cpulabel;
a1955 1
	bzero(clp, sizeof(struct cpu_disklabel));
d1978 1
a1978 1
	errstring = readdisklabel(DISKLABELDEV(dev), fdstrategy, lp, clp, 0);
@


1.52
log
@another XXsize() function forgotten
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.51 2007/06/06 17:15:12 deraadt Exp $	*/
d1973 1
@


1.51
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.50 2007/06/05 00:38:18 deraadt Exp $	*/
d1741 1
a1741 1
int
@


1.50
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.49 2007/06/01 00:07:48 krw Exp $	*/
d211 1
a211 1
	daddr_t	sc_blkno;	/* starting block number */
d1753 1
a1753 1
	daddr_t blkno;
@


1.49
log
@Don't initialize d_partitions[RAW_DISK] just before calling
readdisklabel(), since all readdisklabel()'s do that already.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.48 2007/04/27 22:20:01 krw Exp $	*/
d1967 1
a1967 1
	lp->d_secperunit = fd->sc_type->size;
@


1.48
log
@Even floppies should use DISKLABELDEV() on the dev_t parameter to
readdisklabel/writedisklabel.

ok deraadt@@ weingart@@ conceptual ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.47 2007/02/15 00:53:26 krw Exp $	*/
a1972 5

	lp->d_partitions[RAW_PART].p_offset = 0;
	lp->d_partitions[RAW_PART].p_size = lp->d_secpercyl * lp->d_ncylinders;
	lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;
	lp->d_npartitions = RAW_PART + 1;
@


1.47
log
@Don't print the error strings returned by readdisklabel().  If you
need the debug info uncomment the printf's you need. Crude but
effective way to suppress 'no disklabel' errors that pop up at the
most innconvenient times to frighten users. More elegant method,
DPRINTF-like constructs or something, later.

"Yay!" marco@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.46 2006/11/29 12:24:17 miod Exp $	*/
d1794 1
a1794 1
		error = writedisklabel(dev, fdstrategy,
d1986 1
a1986 1
	errstring = readdisklabel(dev, fdstrategy, lp, clp, 0);
@


1.46
log
@Kernel stack can be swapped. This means that stuff that's on the stack
should never be referenced outside the context of the process to which
this stack belongs unless we do the PHOLD/PRELE dance. Loads of code
doesn't follow the rules here. Instead of trying to track down all
offenders and fix this hairy situation, it makes much more sense
to not swap kernel stacks.

From art@@, tested by many some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.45 2006/09/26 23:33:04 krw Exp $	*/
d1988 1
a1988 1
		printf("%s: %s\n", fd->sc_dv.dv_xname, errstring);
@


1.45
log
@Zap D_REMOVABLE flag from disklabel. If you didn't already know that
floppies and cd's were removable, displaying that fact in disklabel
output was unlikely to help. And the display in disklabel was the only
use of D_REMOVABLE in the tree.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.44 2006/03/15 20:20:41 miod Exp $	*/
a1897 1
	PHOLD(p);
a1943 1
	PRELE(p);
@


1.44
log
@Nuke dk_establish(), no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.43 2006/01/22 00:40:02 miod Exp $	*/
a1974 1
	lp->d_flags = D_REMOVABLE;
@


1.43
log
@b_cylin -> b_cylinder; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.42 2005/08/14 10:58:33 miod Exp $	*/
a684 3

	/* XXX Need to do some more fiddling with sc_dk. */
	dk_establish(&fd->sc_dk, &fd->sc_dv);
@


1.42
log
@Add more flexibility to the fast trap handlers mechanism:
- add the ability to deregister a fast trap handler.
- when registering a fast trap, provide an optional callback which will be
  invoked if we try to register a regular trap handler later; the callback
  will be responsible to replace the fast trap handler with a regular trap
  handler (and is allowed to fail).

Alter audioamd(4) to take advantage of this, so that it can share its
interrupt with stp(4) on SPARCclassic machines.

Problem found the hard way and fix tested by Jason George; discussed and
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.41 2005/03/23 17:10:22 miod Exp $	*/
a119 2
#define b_cylin b_resid

d745 1
a745 1
 	bp->b_cylin = (bp->b_blkno * DEV_BSIZE) /
d751 1
a751 1
		    bp->b_blkno, bp->b_bcount, fd->sc_blkno, bp->b_cylin);
d1357 1
a1357 1
			fd->sc_cylin = bp->b_cylin;
d1362 1
a1362 1
		if (fd->sc_cylin == bp->b_cylin)
d1384 1
a1384 1
		FDC_WRFIFO(fdc, bp->b_cylin * fd->sc_type->step);
d1475 1
a1475 1
		    cyl != bp->b_cylin * fd->sc_type->step) {
d1483 1
a1483 1
		fd->sc_cylin = bp->b_cylin;
d1591 1
a1591 1
			bp->b_cylin = fd->sc_blkno / fd->sc_type->seccyl;
@


1.41
log
@Kill the sparc-specific mountroot hooks (which are run before the root
filesystem is mounted, unlike the MI mountroot hooks). They were only
used to allow root on floppy in the long dead two-floppies installation
method.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.40 2005/03/12 00:09:01 miod Exp $	*/
d445 1
d453 4
a458 1
	intr_fasttrap(pri, fdchwintr);
d507 1
a507 1
	printf(" pri %d, softpri %d: chip 8207%c\n", pri, IPL_FDSOFT, code);
@


1.40
log
@Do not drop the user in ddb in DIAGNOSTIC checks unless option FD_DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.39 2004/12/25 23:02:25 miod Exp $	*/
a278 1
void	fd_mountroot_hook(struct device *);
a680 6
	/*
	 * Establish a mountroot_hook anyway in case we booted
	 * with RB_ASKNAME and get selected as the boot device.
	 */
	mountroot_hook_establish(fd_mountroot_hook, &fd->sc_dv);

a2013 27
	}
}

/*
 * The mountroot_hook is called once the root and swap device have been
 * established.  NULL implies that we may have been the boot device but
 * haven't been elected for the root device.
 */

/* ARGSUSED */
void
fd_mountroot_hook(dev)
	struct device *dev;
{
	int c;

	if (dev) {
		fd_do_eject((struct fd_softc *)dev);

		printf("Insert filesystem floppy and press return.");
		for (;;) {
			c = cngetc();
			if ((c == '\r') || (c == '\n')) {
				printf("\n");
				break;
			}
		}
@


1.39
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.38 2004/09/29 07:35:11 miod Exp $	*/
d1412 1
a1412 1
#ifdef DDB
@


1.38
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.37 2004/09/22 22:12:57 miod Exp $	*/
d791 1
a791 1
	int active = fdc->sc_drives.tqh_first != 0;
d815 1
a815 1
	if (fd->sc_drivechain.tqe_next && ++fd->sc_ops >= 8) {
d864 1
a864 1
		if ((fd = fdc->sc_drives.tqh_first) != NULL)
d906 1
a906 1
	if ((fdc->sc_drives.tqh_first == fd) && (fdc->sc_state == MOTORWAIT))
d1082 1
a1082 1
	struct fd_softc *fd = fdc->sc_drives.tqh_first;
d1136 1
a1136 1
	fd = fdc->sc_drives.tqh_first;
d1306 1
a1306 1
	fd = fdc->sc_drives.tqh_first;
d1685 1
a1685 1
	fd = fdc->sc_drives.tqh_first;
@


1.37
log
@Bring some enhancements and fixes to fdc(4) from NetBSD:
- better state machine, will prevent "eject fd0" with an empty drive to
  spin.
- will not attach fd children to fdc if no floppy drive is present (though
  the PROM usually finds this for us).
- use biowait() in fdformat() instead of rolling our own.
- drop 5"1/4 formats table.
- cope with non 512 bytes per sector formats.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.36 2004/04/02 04:31:21 deraadt Exp $	*/
a150 1
	struct intrhand sc_hih;
d174 1
a174 1
#define sc_intrcnt	sc_io.fdcio_intrcnt
d180 1
a180 1
extern	struct fdcio	*fdciop;
d449 1
a449 1
	intr_establish(pri, &fdc->sc_hih, IPL_FD);
d452 3
d459 1
a459 1
	intr_establish(IPL_FDSOFT, &fdc->sc_sih, IPL_BIO);
a503 2
	evcnt_attach(&fdc->sc_dev, "intr", &fdc->sc_intrcnt);

a1241 1
	fdc->sc_intrcnt.ev_count++;
@


1.36
log
@remove pk from copyright, seen in netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.35 2004/02/15 02:45:46 tedu Exp $	*/
d5 35
a121 1
#define FD_DEBUG
d128 17
a144 15
	MOTORWAIT,
	DOSEEK,
	SEEKWAIT,
	SEEKTIMEDOUT,
	SEEKCOMPLETE,
	DOIO,
	IOCOMPLETE,
	IOTIMEDOUT,
	DORESET,
	RESETCOMPLETE,
	RESETTIMEDOUT,
	DORECAL,
	RECALWAIT,
	RECALTIMEDOUT,
	RECALCOMPLETE,
d160 1
d169 2
a170 1
#define sc_istate	sc_io.fdcio_istate
d200 1
a200 4
	{ 18,2,36,2,0xff,0xcf,0x1b,0x6c,80,2880,1,FDC_500KBPS, "1.44MB"    }, /* 1.44MB diskette */
	{ 15,2,30,2,0xff,0xdf,0x1b,0x54,80,2400,1,FDC_500KBPS, "1.2MB"    }, /* 1.2 MB AT-diskettes */
	{  9,2,18,2,0xff,0xdf,0x23,0x50,40, 720,2,FDC_300KBPS, "360KB/AT" }, /* 360kB in 1.2MB drive */
	{  9,2,18,2,0xff,0xdf,0x2a,0x50,40, 720,1,FDC_250KBPS, "360KB/PC" }, /* 360kB PC diskettes */
a201 1
	{  9,2,18,2,0xff,0xdf,0x23,0x50,80,1440,1,FDC_300KBPS, "720KB/x"  }, /* 720kB in 1.2MB drive */
d203 1
d263 1
a263 1
int	out_fdc(struct fdc_softc *fdc, u_char x);
d265 1
a265 1
void	fdcstatus(struct device *dv, int n, char *s);
d270 1
a270 1
int	fdchwintr(struct fdc_softc *);
d281 1
a281 1
static void fdconf(struct fdc_softc *);
d370 5
a374 1
static void
d380 2
a381 2
	if (out_fdc(fdc, NE7CMD_DUMPREG) || fdcresult(fdc) != 10)
		return;
d391 29
a419 5
	out_fdc(fdc, NE7CMD_CFG);
	out_fdc(fdc, vroom);
	out_fdc(fdc, fdc->sc_cfg);
	out_fdc(fdc, 0); /* PRETRK */
	/* No result phase */
d441 2
a442 1
	fdc->sc_istate = ISTATE_IDLE;
d448 1
a448 1
	fdc->sc_hih.ih_fun = (void *)fdchwintr;
d478 1
a484 8
#ifdef FD_DEBUG
	if (out_fdc(fdc, NE7CMD_VERSION) == 0 &&
	    fdcresult(fdc) == 1 && fdc->sc_status[0] == 0x90) {
		if (fdc_debug)
			printf("[version cmd]");
	}
#endif

d490 4
a493 1
	fdconf(fdc);
d495 1
a495 1
	if (fdc->sc_flags & FDC_82077) {
d497 1
a497 1
		out_fdc(fdc, NE7CMD_LOCK | CFG_LOCK);
d579 1
a579 1
	if (fdc->sc_flags & FDC_82077) {
d582 2
a586 2
	/* wait for motor to spin up */
	delay(250000);
d589 3
a591 2
	out_fdc(fdc, NE7CMD_RECAL);
	out_fdc(fdc, drive);
d598 1
a598 1
			if (out_fdc(fdc, NE7CMD_SENSEI))
d616 1
a616 1
			printf(" %x", fdc->sc_status[i]);
d623 1
a623 1
	if (fdc->sc_flags & FDC_82077) {
d647 4
d664 4
a667 3
	out_fdc(fdc, NE7CMD_SPECIFY);
	out_fdc(fdc, type->steprate);
	out_fdc(fdc, 6 | NE7_SPECIFY_NODMA);
a692 4

	/* Setup timeouts */
	timeout_set(&fd->fd_motor_on_to, fd_motor_on, fd);
	timeout_set(&fd->fd_motor_off_to, fd_motor_off, fd);
d720 2
a721 1
	    ((bp->b_bcount % FDC_BSIZE) != 0 &&
d731 1
a731 1
	sz = howmany(bp->b_bcount, FDC_BSIZE);
d733 3
a735 2
	if (bp->b_blkno + sz > fd->sc_type->size) {
		sz = fd->sc_type->size - bp->b_blkno;
d750 2
a751 1
 	bp->b_cylin = bp->b_blkno / (FDC_BSIZE / DEV_BSIZE) / fd->sc_type->seccyl;
d872 6
a877 9
		int on = 0;

		for (n = 0; n < 4; n++)
			if ((fd = fdc->sc_fd[n]) && (fd->sc_flags & FD_MOTOR))
				on = 1;
		if (on) {
			auxregbisc(AUXIO4C_FDS, 0);
		} else {
			auxregbisc(0, AUXIO4C_FDS);
d879 1
d911 5
d921 1
a921 2
	int j = 100000,
	    n = 0;
d923 1
a923 1
	for (; j; j--) {
d934 1
a934 1
			delay(10);
d936 1
d941 4
d946 1
a946 1
out_fdc(fdc, x)
d950 1
a950 1
	int i = 100000;
d952 6
a957 1
	while (((*fdc->sc_reg_msr & (NE7_DIO|NE7_RQM)) != NE7_RQM) && i-- > 0)
d959 2
a960 5
	if (i <= 0)
		return (-1);

	*fdc->sc_reg_fifo = x;
	return (0);
d977 1
a977 1
	if (fd == 0)
d1078 2
a1079 3
fdcstatus(dv, n, s)
	struct device *dv;
	int n;
d1082 5
a1086 1
	struct fdc_softc *fdc = (void *)dv->dv_parent;
d1093 2
a1094 2
	if (n == 0 && (fdc->sc_flags & FDC_82077)) {
		out_fdc(fdc, NE7CMD_SENSEI);
d1100 2
a1101 4
	/* Just print last status */
	n = fdc->sc_nstat;

	printf("%s: %s: state %d", dv->dv_xname, s, fdc->sc_state);
d1132 1
a1132 1
	struct fd_softc *fd = fdc->sc_drives.tqh_first;
d1136 7
a1142 1
	fdcstatus(&fd->sc_dv, 0, "timeout");
d1150 1
d1174 1
a1174 1
fdchwintr(fdc)
d1178 2
a1179 2
	switch (fdc->sc_istate) {
	case ISTATE_IDLE:
d1181 5
a1185 4
	case ISTATE_SENSEI:
		out_fdc(fdc, NE7CMD_SENSEI);
		fdcresult(fdc);
		fdc->sc_istate = ISTATE_IDLE;
d1188 5
a1192 4
	case ISTATE_SPURIOUS:
		fdcresult(fdc);
		fdc->sc_istate = ISTATE_SPURIOUS;
		printf("fdc: stray hard interrupt... ");
d1195 2
a1196 1
	case ISTATE_DMA:
d1199 3
a1201 1
		printf("fdc: goofed ...\n");
d1205 3
d1214 1
d1219 1
a1219 1
			fdc->sc_istate = ISTATE_IDLE;
d1221 4
a1224 1
			printf("fdc: overrun: tc = %d\n", fdc->sc_tc);
d1228 2
a1229 1
		if (msr & NE7_DIO) {
d1231 1
a1231 1
		} else {
a1232 1
		}
d1234 1
a1234 1
			fdc->sc_istate = ISTATE_DONE;
d1253 2
a1254 1
	if (fdc->sc_istate != ISTATE_DONE)
d1257 9
a1265 1
	fdc->sc_istate = ISTATE_IDLE;
d1279 6
a1284 2
#define OUT_FDC(fdc, c, s) \
    do { if (out_fdc(fdc, (c))) { (fdc)->sc_state = (s); goto loop; } } while(0)
d1293 6
a1298 10
	if (fdc->sc_istate != ISTATE_IDLE) {
		/* Trouble... */
		printf("fdc: spurious interrupt: state %d, istate=%d\n",
			fdc->sc_state, fdc->sc_istate);
		fdc->sc_istate = ISTATE_IDLE;
		if (fdc->sc_state == RESETCOMPLETE ||
		    fdc->sc_state == RESETTIMEDOUT) {
			panic("fdcintr: spurious interrupt can't be cleared");
		}
		goto doreset;
d1301 4
d1330 1
a1330 1
		fd->sc_blkno = bp->b_blkno / (FDC_BSIZE / DEV_BSIZE);
d1346 1
a1346 1
			if (fdc->sc_flags & FDC_82077) { /* XXX */
a1370 12
		/* specify command */
		OUT_FDC(fdc, NE7CMD_SPECIFY, SEEKTIMEDOUT);
		OUT_FDC(fdc, fd->sc_type->steprate, SEEKTIMEDOUT);
		/* XXX head load time == 6ms */
		OUT_FDC(fdc, 6 | NE7_SPECIFY_NODMA, SEEKTIMEDOUT);

		fdc->sc_istate = ISTATE_SENSEI;
		/* seek function */
		OUT_FDC(fdc, NE7CMD_SEEK, SEEKTIMEDOUT);
		OUT_FDC(fdc, fd->sc_drive, SEEKTIMEDOUT); /* drive number */
		OUT_FDC(fdc, bp->b_cylin * fd->sc_type->step, SEEKTIMEDOUT);

d1376 1
d1378 13
a1391 1
		timeout_add(&fdc->fdctimeout_to, 4 * hz);
d1402 2
a1403 2
		nblks = min(nblks, fd->sc_bcount / FDC_BSIZE);
		nblks = min(nblks, FDC_MAXIOSIZE / FDC_BSIZE);
d1405 1
a1405 1
		fd->sc_nbytes = finfo ? bp->b_bcount : nblks * FDC_BSIZE;
d1427 5
a1431 3
			printf("fdcintr: %s drive %d track %d head %d sec %d nblks %d\n",
				read ? "read" : "write", fd->sc_drive,
				fd->sc_cylin, head, sec, nblks);
d1434 1
a1434 1
		fdc->sc_istate = ISTATE_DMA;
d1436 6
d1444 6
a1449 6
			OUT_FDC(fdc, NE7CMD_FORMAT, IOTIMEDOUT);
			OUT_FDC(fdc, (head << 2) | fd->sc_drive, IOTIMEDOUT);
			OUT_FDC(fdc, finfo->fd_formb_secshift, IOTIMEDOUT);
			OUT_FDC(fdc, finfo->fd_formb_nsecs, IOTIMEDOUT);
			OUT_FDC(fdc, finfo->fd_formb_gaplen, IOTIMEDOUT);
			OUT_FDC(fdc, finfo->fd_formb_fillbyte, IOTIMEDOUT);
d1452 1
a1452 1
				OUT_FDC(fdc, NE7CMD_READ, IOTIMEDOUT);
d1454 9
a1462 9
				OUT_FDC(fdc, NE7CMD_WRITE, IOTIMEDOUT);
			OUT_FDC(fdc, (head << 2) | fd->sc_drive, IOTIMEDOUT);
			OUT_FDC(fdc, fd->sc_cylin, IOTIMEDOUT);	/*track*/
			OUT_FDC(fdc, head, IOTIMEDOUT);
			OUT_FDC(fdc, sec + 1, IOTIMEDOUT);	/*sector+1*/
			OUT_FDC(fdc, type->secsize, IOTIMEDOUT);/*sector size*/
			OUT_FDC(fdc, type->sectrac, IOTIMEDOUT);/*secs/track*/
			OUT_FDC(fdc, type->gap1, IOTIMEDOUT);	/*gap1 size*/
			OUT_FDC(fdc, type->datalen, IOTIMEDOUT);/*data length*/
a1464 4
		disk_busy(&fd->sc_dk);

		/* allow 2 seconds for operation */
		timeout_add(&fdc->fdctimeout_to, 2 * hz);
d1484 1
a1484 1
				fdcstatus(&fd->sc_dv, 2, "seek failed");
d1493 13
a1505 3
		FTC_FLIP;
		(void)fdcresult(fdc);
		/*FALLTHROUGH*/
d1509 13
d1536 1
a1536 1
				fdcstatus(&fd->sc_dv, 7,
d1573 2
a1574 1
			    fd->sc_skip / FDC_BSIZE, (struct disklabel *)NULL);
a1603 1
	doreset:
a1606 1
		fdc_reset(fdc);
d1608 1
a1608 1
		fdc->sc_istate = ISTATE_SENSEI;
d1611 1
d1618 1
a1618 1
		/* fall through */
d1621 1
a1621 1
		fdc->sc_istate = ISTATE_SENSEI;
d1623 1
d1625 2
a1626 3
		OUT_FDC(fdc, NE7CMD_RECAL, RECALTIMEDOUT);
		OUT_FDC(fdc, fd->sc_drive, RECALTIMEDOUT);
		timeout_add(&fdc->fdctimeout_to, 5 * hz);
d1642 1
a1642 1
				fdcstatus(&fd->sc_dv, 2, "recalibrate failed");
d1656 1
a1656 1
		fdcstatus(&fd->sc_dv, 0, "stray interrupt");
d1662 11
d1684 1
d1695 7
d1713 15
d1736 1
a1736 1
				fd->sc_skip / FDC_BSIZE,
d1738 2
a1739 7

			printf(" (st0 %b st1 %b st2 %b cyl %d head %d sec %d)\n",
			    fdc->sc_status[0], NE7_ST0BITS,
			    fdc->sc_status[1], NE7_ST1BITS,
			    fdc->sc_status[2], NE7_ST2BITS,
			    fdc->sc_status[3], fdc->sc_status[4],
			    fdc->sc_status[5]);
d1742 1
d1744 1
a1744 1
		bp->b_error = EIO;
d1847 1
a1847 1
#ifdef DEBUG
d1854 1
a1854 1
		out_fdc(fdc, NE7CMD_DUMPREG);
d1858 1
a1858 1
			printf(" %x", fdc->sc_status[i]);
d1864 7
a1870 5
		((struct fdc_softc *)fd->sc_dv.dv_parent)->sc_cfg &=
			~CFG_THRHLD_MASK;
		((struct fdc_softc *)fd->sc_dv.dv_parent)->sc_cfg |=
			(*(int *)addr & CFG_THRHLD_MASK);
		fdconf((struct fdc_softc *) fd->sc_dv.dv_parent);
d1877 1
a1877 1
		out_fdc(fdc, NE7CMD_SENSEI);
d1880 1
a1880 1
		for (i=0; i< fdc->sc_nstat; i++)
a1888 4

#ifdef DIAGNOSTIC
	panic("fdioctl: impossible");
#endif
d1897 1
a1897 1
	int rv = 0, s;
d1917 3
a1919 2
	bp->b_blkno = (finfo->cyl * (type->sectrac * type->heads)
		       + finfo->head * type->sectrac) * FDC_BSIZE / DEV_BSIZE;
d1925 4
a1928 2
	if (fdc_debug)
		printf("fdformat: blkno %x count %ld\n",
d1930 17
d1953 1
a1953 18
	s = splbio();
	while (!(bp->b_flags & B_DONE)) {
		rv = tsleep((caddr_t)bp, PRIBIO, "fdform", 20 * hz);
		if (rv == EWOULDBLOCK)
			break;
	}
	splx(s);

	if (rv == EWOULDBLOCK) {
		/* timed out */
		rv = EIO;
		s = splbio();
		biodone(bp);
		splx(s);
	}
	if (bp->b_flags & B_ERROR) {
		rv = bp->b_error;
	}
d1972 2
a1973 1
	lp->d_secsize = FDC_BSIZE;
a1974 1
	lp->d_ntracks = fd->sc_type->heads;	/* Go figure... */
d1977 3
a1981 1
	lp->d_type = DTYPE_FLOPPY;
a1982 2
	lp->d_rpm = 300;	/* XXX like it matters... */
	lp->d_secperunit = fd->sc_type->size;
a2000 1
		return;
d2016 1
a2016 1
	if (CPU_ISSUN4M && (fdc->sc_flags & FDC_82077)) {
@


1.35
log
@new arg to disk_unbusy, to record separate read/write statistics.
looked at by various, testing henning@@ mcbride@@ dan weeks
mostly from netbsd via Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.34 2004/01/12 11:35:08 jmc Exp $	*/
a5 1
 * Copyright (c) 1995 Paul Kranenburg.
@


1.34
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.33 2003/06/02 23:27:54 millert Exp $	*/
d1366 1
a1366 1
		disk_unbusy(&fd->sc_dk, 0);	/* no data on seek */
d1394 2
a1395 1
		disk_unbusy(&fd->sc_dk, (bp->b_bcount - bp->b_resid));
@


1.33
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.32 2002/11/24 18:17:58 miod Exp $	*/
d183 2
a184 2
	int sc_nblks;		/* number of blocks currently tranferring */
	int sc_nbytes;		/* number of bytes currently tranferring */
@


1.32
log
@Be sun4m-friendly in FDC_C_HANDLER case.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.31 2002/11/24 15:05:03 miod Exp $	*/
d27 1
a27 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.31
log
@Fix a kernel fault in FDC_C_HANDLER code.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.30 2002/11/24 02:00:36 miod Exp $	*/
d1134 1
a1134 1
			ienab_bis(IE_FDSOFT);
@


1.30
log
@Make this compile again if FDC_C_HANDLER is defined.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.29 2002/05/29 08:28:36 art Exp $	*/
d1038 1
a1038 1
		printf(" (st0 %s cyl %d)\n",
d1153 1
a1153 1
	sc->sc_intrcnt.ev_count++;
@


1.29
log
@splbio around biodone.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.28 2002/04/30 01:12:29 art Exp $	*/
d265 1
a265 1
		ienab_bis(IE_L4);	\
d268 1
a268 1
#define AUDIO_SET_SWINTR ienab_bis(IE_FDSOFT)
@


1.28
log
@Fix an ancient problem in how sparc interrupts are handled.

There are many interrupt handlers that assume that they don't need to do
any spl protection in their code because the interrupt of some level can't
be interrupted by an interrupt of the same level. The problem is that some
interrupt handlers have hardware levels that are lower then their "software"
levels.

Fix this by adding an additional field to struct intrhand that specifies which
"software" level an interrupt handler has and blocks that level while handling
the interrupt. This new field is initialized in intr_establish which gets
an additional argument (which can be -1 meaning that the interrupt handler
doesn't need to block any additional level).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.27 2002/04/28 03:51:19 art Exp $	*/
d721 1
d723 1
d1785 1
d1787 1
@


1.27
log
@Rename all PIL_* constants to IPL_* to match other archs and make them
usable in MD code in the future.
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.26 2002/03/14 01:26:42 millert Exp $	*/
d391 1
a391 1
	intr_establish(pri, &fdc->sc_hih);
d398 1
a398 1
	intr_establish(IPL_FDSOFT, &fdc->sc_sih);
@


1.26
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.25 2002/03/13 00:24:21 miod Exp $	*/
d253 1
a253 1
#if PIL_FDSOFT == 4
d263 1
a263 1
		raise(0, PIL_FDSOFT);	\
d398 1
a398 1
	intr_establish(PIL_FDSOFT, &fdc->sc_sih);
d449 1
a449 1
	printf(" pri %d, softpri %d: chip 8207%c\n", pri, PIL_FDSOFT, code);
@


1.25
log
@On sparc, PAGE_SIZE and friends might not be a compile-time constant.
Instead of using a homegrown set of variables in this case, rely on uvmexp
fields once uvm has been initialized.

This requires a few #include <uvm/uvm_extern.h> here and there in the kernel
as well.

Idea from art@@, changes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.24 2001/03/24 01:37:28 ho Exp $	*/
d152 2
a153 2
int	fdcmatch __P((struct device *, void *, void *));
void	fdcattach __P((struct device *, struct device *, void *));
d163 1
a163 1
__inline struct fd_type *fd_dev_to_type __P((struct fd_softc *, dev_t));
d209 2
a210 2
int	fdmatch __P((struct device *, void *, void *));
void	fdattach __P((struct device *, struct device *, void *));
d220 5
a224 5
void fdgetdisklabel __P((dev_t));
int fd_get_parms __P((struct fd_softc *));
void fdstrategy __P((struct buf *));
void fdstart __P((struct fd_softc *));
int fdprint __P((void *, const char *));
d228 11
a238 11
struct	fd_type *fd_nvtotype __P((char *, int, int));
void	fd_set_motor __P((struct fdc_softc *fdc));
void	fd_motor_off __P((void *arg));
void	fd_motor_on __P((void *arg));
int	fdcresult __P((struct fdc_softc *fdc));
int	out_fdc __P((struct fdc_softc *fdc, u_char x));
void	fdcstart __P((struct fdc_softc *fdc));
void	fdcstatus __P((struct device *dv, int n, char *s));
void	fdc_reset __P((struct fdc_softc *fdc));
void	fdctimeout __P((void *arg));
void	fdcpseudointr __P((void *arg));
d240 1
a240 1
int	fdchwintr __P((struct fdc_softc *));
d242 1
a242 1
void	fdchwintr __P((void));
d244 8
a251 8
int	fdcswintr __P((struct fdc_softc *));
int	fdcstate __P((struct fdc_softc *));
void	fdcretry __P((struct fdc_softc *fdc));
void	fdfinish __P((struct fd_softc *fd, struct buf *bp));
int	fdformat __P((dev_t, struct fd_formb *, struct proc *));
void	fd_do_eject __P((struct fd_softc *));
void	fd_mountroot_hook __P((struct device *));
static void fdconf __P((struct fdc_softc *));
@


1.24
log
@Convert to new timeout API. mickey@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.23 1998/10/03 21:18:58 millert Exp $	*/
d71 2
@


1.24.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.24 2001/03/24 01:37:28 ho Exp $	*/
a71 2
#include <uvm/uvm_extern.h>

d150 2
a151 2
int	fdcmatch(struct device *, void *, void *);
void	fdcattach(struct device *, struct device *, void *);
d161 1
a161 1
__inline struct fd_type *fd_dev_to_type(struct fd_softc *, dev_t);
d207 2
a208 2
int	fdmatch(struct device *, void *, void *);
void	fdattach(struct device *, struct device *, void *);
d218 5
a222 5
void fdgetdisklabel(dev_t);
int fd_get_parms(struct fd_softc *);
void fdstrategy(struct buf *);
void fdstart(struct fd_softc *);
int fdprint(void *, const char *);
d226 11
a236 11
struct	fd_type *fd_nvtotype(char *, int, int);
void	fd_set_motor(struct fdc_softc *fdc);
void	fd_motor_off(void *arg);
void	fd_motor_on(void *arg);
int	fdcresult(struct fdc_softc *fdc);
int	out_fdc(struct fdc_softc *fdc, u_char x);
void	fdcstart(struct fdc_softc *fdc);
void	fdcstatus(struct device *dv, int n, char *s);
void	fdc_reset(struct fdc_softc *fdc);
void	fdctimeout(void *arg);
void	fdcpseudointr(void *arg);
d238 1
a238 1
int	fdchwintr(struct fdc_softc *);
d240 1
a240 1
void	fdchwintr(void);
d242 8
a249 8
int	fdcswintr(struct fdc_softc *);
int	fdcstate(struct fdc_softc *);
void	fdcretry(struct fdc_softc *fdc);
void	fdfinish(struct fd_softc *fd, struct buf *bp);
int	fdformat(dev_t, struct fd_formb *, struct proc *);
void	fd_do_eject(struct fd_softc *);
void	fd_mountroot_hook(struct device *);
static void fdconf(struct fdc_softc *);
d251 1
a251 1
#if IPL_FDSOFT == 4
d261 1
a261 1
		raise(0, IPL_FDSOFT);	\
d389 1
a389 1
	intr_establish(pri, &fdc->sc_hih, IPL_FD);
d396 1
a396 1
	intr_establish(IPL_FDSOFT, &fdc->sc_sih, IPL_BIO);
d447 1
a447 1
	printf(" pri %d, softpri %d: chip 8207%c\n", pri, IPL_FDSOFT, code);
a718 1
	s = splbio();
a719 1
	splx(s);
a1780 1
		s = splbio();
a1781 1
		splx(s);
@


1.24.6.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d265 1
a265 1
		ienab_bis(IE_FDSOFT);	\
d268 1
a268 1
#define FD_SET_SWINTR ienab_bis(IE_FDSOFT)
d1038 1
a1038 1
		printf(" (st0 %b cyl %d)\n",
d1134 1
a1134 1
			FD_SET_SWINTR;
d1153 1
a1153 1
	fdc->sc_intrcnt.ev_count++;
@


1.23
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.22 1997/09/20 12:24:17 deraadt Exp $	*/
d68 1
d141 2
d201 3
d492 3
d630 4
d700 1
a700 1
	untimeout(fd_motor_off, fd); /* a good idea */
d765 1
a765 1
	timeout(fd_motor_off, fd, 5 * hz);
d1225 1
a1225 1
		untimeout(fd_motor_off, fd);
d1234 1
a1234 1
				untimeout(fd_motor_off, ofd);
d1242 1
a1242 1
				timeout(fd_motor_on, fd, hz / 4);
d1284 1
a1284 1
		timeout(fdctimeout, fdc, 4 * hz);
d1353 1
a1353 1
		timeout(fdctimeout, fdc, 2 * hz);
d1357 1
a1357 1
		untimeout(fdctimeout, fdc);
d1361 1
a1361 1
			timeout(fdcpseudointr, fdc, hz / 50);
d1392 1
a1392 1
		untimeout(fdctimeout, fdc);
d1476 1
a1476 1
		timeout(fdctimeout, fdc, hz / 2);
d1480 1
a1480 1
		untimeout(fdctimeout, fdc);
d1491 1
a1491 1
		timeout(fdctimeout, fdc, 5 * hz);
d1495 1
a1495 1
		untimeout(fdctimeout, fdc);
d1499 1
a1499 1
			timeout(fdcpseudointr, fdc, hz / 30);
@


1.23.8.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.24 2001/03/24 01:37:28 ho Exp $	*/
a67 1
#include <sys/timeout.h>
a139 2
	struct timeout	fdctimeout_to;
	struct timeout	fdcpseudointr_to;
a197 3

	struct timeout fd_motor_on_to;
	struct timeout fd_motor_off_to;
a485 3
	timeout_set(&fdc->fdctimeout_to, fdctimeout, fdc);
	timeout_set(&fdc->fdcpseudointr_to, fdcpseudointr, fdc);

a620 4

	/* Setup timeouts */
	timeout_set(&fd->fd_motor_on_to, fd_motor_on, fd);
	timeout_set(&fd->fd_motor_off_to, fd_motor_off, fd);
d687 1
a687 1
	timeout_del(&fd->fd_motor_off_to); /* a good idea */
d752 1
a752 1
	timeout_add(&fd->fd_motor_off_to, 5 * hz);
d1212 1
a1212 1
		timeout_del(&fd->fd_motor_off_to);
d1221 1
a1221 1
				timeout_del(&ofd->fd_motor_off_to);
d1229 1
a1229 1
				timeout_add(&fd->fd_motor_on_to, hz / 4);
d1271 1
a1271 1
		timeout_add(&fdc->fdctimeout_to, 4 * hz);
d1340 1
a1340 1
		timeout_add(&fdc->fdctimeout_to, 2 * hz);
d1344 1
a1344 1
		timeout_del(&fdc->fdctimeout_to);
d1348 1
a1348 1
			timeout_add(&fdc->fdcpseudointr_to, hz / 50);
d1379 1
a1379 1
		timeout_del(&fdc->fdctimeout_to);
d1463 1
a1463 1
		timeout_add(&fdc->fdctimeout_to, hz / 2);
d1467 1
a1467 1
		timeout_del(&fdc->fdctimeout_to);
d1478 1
a1478 1
		timeout_add(&fdc->fdctimeout_to, 5 * hz);
d1482 1
a1482 1
		timeout_del(&fdc->fdctimeout_to);
d1486 1
a1486 1
			timeout_add(&fdc->fdcpseudointr_to, hz / 30);
@


1.23.8.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a71 2
#include <uvm/uvm_extern.h>

d150 2
a151 2
int	fdcmatch(struct device *, void *, void *);
void	fdcattach(struct device *, struct device *, void *);
d161 1
a161 1
__inline struct fd_type *fd_dev_to_type(struct fd_softc *, dev_t);
d207 2
a208 2
int	fdmatch(struct device *, void *, void *);
void	fdattach(struct device *, struct device *, void *);
d218 5
a222 5
void fdgetdisklabel(dev_t);
int fd_get_parms(struct fd_softc *);
void fdstrategy(struct buf *);
void fdstart(struct fd_softc *);
int fdprint(void *, const char *);
d226 11
a236 11
struct	fd_type *fd_nvtotype(char *, int, int);
void	fd_set_motor(struct fdc_softc *fdc);
void	fd_motor_off(void *arg);
void	fd_motor_on(void *arg);
int	fdcresult(struct fdc_softc *fdc);
int	out_fdc(struct fdc_softc *fdc, u_char x);
void	fdcstart(struct fdc_softc *fdc);
void	fdcstatus(struct device *dv, int n, char *s);
void	fdc_reset(struct fdc_softc *fdc);
void	fdctimeout(void *arg);
void	fdcpseudointr(void *arg);
d238 1
a238 1
int	fdchwintr(struct fdc_softc *);
d240 1
a240 1
void	fdchwintr(void);
d242 8
a249 8
int	fdcswintr(struct fdc_softc *);
int	fdcstate(struct fdc_softc *);
void	fdcretry(struct fdc_softc *fdc);
void	fdfinish(struct fd_softc *fd, struct buf *bp);
int	fdformat(dev_t, struct fd_formb *, struct proc *);
void	fd_do_eject(struct fd_softc *);
void	fd_mountroot_hook(struct device *);
static void fdconf(struct fdc_softc *);
@


1.23.8.3
log
@Sync the SMP branch with 3.3
@
text
@d253 1
a253 1
#if IPL_FDSOFT == 4
d263 1
a263 1
		raise(0, IPL_FDSOFT);	\
d265 1
a265 1
		ienab_bis(IE_FDSOFT);	\
d268 1
a268 1
#define FD_SET_SWINTR ienab_bis(IE_FDSOFT)
d391 1
a391 1
	intr_establish(pri, &fdc->sc_hih, IPL_FD);
d398 1
a398 1
	intr_establish(IPL_FDSOFT, &fdc->sc_sih, IPL_BIO);
d449 1
a449 1
	printf(" pri %d, softpri %d: chip 8207%c\n", pri, IPL_FDSOFT, code);
a720 1
	s = splbio();
a721 1
	splx(s);
d1036 1
a1036 1
		printf(" (st0 %b cyl %d)\n",
d1132 1
a1132 1
			FD_SET_SWINTR;
d1151 1
a1151 1
	fdc->sc_intrcnt.ev_count++;
a1782 1
		s = splbio();
a1783 1
		splx(s);
@


1.23.8.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.23.8.3 2003/03/27 23:49:25 niklas Exp $	*/
d27 5
a31 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.23.8.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d183 2
a184 2
	int sc_nblks;		/* number of blocks currently transferring */
	int sc_nbytes;		/* number of bytes currently transferring */
@


1.23.8.6
log
@Merge with the trunk
@
text
@d6 1
d1366 1
a1366 1
		disk_unbusy(&fd->sc_dk, 0, 0);	/* no data on seek */
d1394 1
a1394 2
		disk_unbusy(&fd->sc_dk, (bp->b_bcount - bp->b_resid),
		    (bp->b_flags & B_READ));
@


1.22
log
@only eject root floppies
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.21 1997/08/25 08:38:44 downsj Exp $	*/
d1817 1
a1817 1
	errstring = readdisklabel(dev, fdstrategy, lp, clp);
@


1.21
log
@Implement LED blinking as a run-time configurable option via the sysctl
machdep.led_blink.

Rename auxreg.h because we need config to generate one now.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.20 1997/08/08 08:25:06 downsj Exp $	*/
d1858 2
a1859 1
	fd_do_eject((struct fd_softc *)dev);
a1860 1
	if (dev) {
@


1.20
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.19 1997/06/25 13:04:20 downsj Exp $	*/
d76 1
a76 1
#include <sparc/sparc/auxreg.h>
@


1.19
log
@Kill unused variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.18 1997/06/24 09:50:56 downsj Exp $	*/
d372 1
a372 2
						ca->ca_ra.ra_len,
						ca->ca_bustype);
@


1.18
log
@New floppy and auxreg drivers, from NetBSD.  fd.c has many changes preserved,
and uses our fdformat interface (same code base as NetBSD, with differently
named ioctls, but we have always preserved the names of the original code's
authors, unlike NetBSD...)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d999 1
a999 1
	char bits[64];
a1523 1
	char bits[64];
a1602 5
	struct fdformat_parms *form_parms;
	struct fdformat_cmd *form_cmd;
	struct fd_formb fd_formbbuf;
	int il[FD_MAX_NSEC + 1];
	int i, j;
d1783 1
a1783 1
	int unit = FDUNIT(dev), i;
@


1.17
log
@Inhbit the silly "Insert fileystem floppy" message when booting from floppy
and root isn't really going to be mounted on the floppy, i.e. ramdisk...
@
text
@d1 2
a2 2
/*	$OpenBSD: fd.c,v 1.16 1997/05/11 22:37:34 grr Exp $	*/
/*	$NetBSD: fd.c,v 1.33.4.1 1996/06/12 20:52:25 pk Exp $	*/
d13 6
d60 2
d74 1
d84 3
a159 20
/*
 * Floppies come in various flavors, e.g., 1.2MB vs 1.44MB; here is how
 * we tell them apart.
 */
struct fd_type {
	int	sectrac;	/* sectors per track */
	int	heads;		/* number of heads */
	int	seccyl;		/* sectors per cylinder */
	int	secsize;	/* size code for sectors */
	int	datalen;	/* data len when secsize = 0 */
	int	steprate;	/* step rate and head unload time */
	int	gap1;		/* gap len between sectors */
	int	gap2;		/* formatting gap */
	int	tracks;		/* total num of tracks */
	int	size;		/* size of disk in sectors */
	int	step;		/* steps per cylinder */
	int	rate;		/* transfer speed code */
	char	*name;
};

d162 7
a168 7
	{ 18,2,36,2,0xff,0xcf,0x1b,0x6c,80,2880,1,FDC_500KBPS,"1.44MB"    }, /* 1.44MB diskette */
	{ 15,2,30,2,0xff,0xdf,0x1b,0x54,80,2400,1,FDC_500KBPS,"1.2MB"    }, /* 1.2 MB AT-diskettes */
	{  9,2,18,2,0xff,0xdf,0x23,0x50,40, 720,2,FDC_300KBPS,"360KB/AT" }, /* 360kB in 1.2MB drive */
	{  9,2,18,2,0xff,0xdf,0x2a,0x50,40, 720,1,FDC_250KBPS,"360KB/PC" }, /* 360kB PC diskettes */
	{  9,2,18,2,0xff,0xdf,0x2a,0x50,80,1440,1,FDC_250KBPS,"720KB"    }, /* 3.5" 720kB diskette */
	{  9,2,18,2,0xff,0xdf,0x23,0x50,80,1440,1,FDC_300KBPS,"720KB/x"  }, /* 720kB in 1.2MB drive */
	{  9,2,18,2,0xff,0xdf,0x2a,0x50,40, 720,2,FDC_250KBPS,"360KB/x"  }, /* 360kB in 720kB drive */
d191 1
d237 1
d240 2
a241 1
void	fd_do_eject __P((void));
d251 13
a291 8
#ifndef FDSUN4M
	/*
	 * XXX Floppy doesn't work yet sun4m, nasty things happen if you try
	 */
	if (CPU_ISSUN4M)
		return (0);
#endif

d329 1
a329 1
	return QUIET;
d450 1
a450 10
		/*
		 * WOAH THERE!  It looks like we can get the bootpath
		 * in several different formats!!  The faked
		 * bootpath (and some v2?) looks like /fd@@0,0
		 * but the real bootpath on some v2 OpenPROM
		 * systems looks like /fd0.  In the case of
		 * a floppy controller on obio (such as on the sun4m),
		 * we use "slot, offset" to determine if this is the
		 * right one.  --thorpej
		 */
d453 11
a463 1
			if (((bp->val[0] == 0) &&	/* /fd@@0,0 */
d465 4
a468 2
			    ((bp->val[0] == -1) &&	/* /fd0 */
			     (bp->val[1] == 0)))
d473 6
a478 1
			/* /obio0/SUNW,fdtwo@@0,700000 */
d511 2
a512 2
		/* XXX - for now, punt > 1 drives */
		return 0;
d518 1
a518 1
		auxregbisc(AUXIO_FDS, 0);
d557 6
a562 4
	if (fdc->sc_flags & FDC_82077)
		*fdc->sc_reg_dor = FDO_FRST;
	else
		auxregbisc(0, AUXIO_FDS);
d564 1
a564 1
	return ok;
d584 1
a584 1
		printf(": %s, %d cyl, %d head, %d sec\n", type->name,
d594 4
d632 2
a633 2
		return NULL;
	return type ? &fd_types[type - 1] : fd->sc_deftype;
d649 2
a650 1
	    (bp->b_bcount % FDC_BSIZE) != 0) {
d762 1
a762 1
		*fdc->sc_reg_dor = FDO_MOEN(0);
d768 4
d802 1
a802 1
			auxregbisc(AUXIO_FDS, 0);
d804 1
a804 1
			auxregbisc(0, AUXIO_FDS);
d833 1
a833 1
		(void) fdcswintr(fdc);
d852 1
a852 1
				return -1;
d855 2
a856 1
		}
d869 2
a870 1
	while (((*fdc->sc_reg_msr & (NE7_DIO|NE7_RQM)) != NE7_RQM) && i-- > 0);
d872 1
a872 1
		return -1;
d875 1
a875 1
	return 0;
d890 1
a890 1
		return ENXIO;
d893 1
a893 1
		return ENXIO;
d896 1
a896 1
		return ENXIO;
d900 1
a900 1
		return EBUSY;
d926 1
a926 1
	return 0;
d939 1
d953 1
a953 1
	return 0;
d989 1
a989 1
	(void) fdcswintr(fdc);
d999 1
d1022 1
a1022 1
		printf(" (st0 %b cyl %d)\n",
d1057 1
a1057 1
	(void) fdcswintr(fdc);
d1070 1
a1070 1
	(void) fdcswintr(fdc);
a1083 2
	struct buf *bp;
	int read;
d1086 2
d1092 1
a1092 1
		ienab_bis(IE_FDSOFT);
a1093 1
	case ISTATE_IDLE:
a1094 1
		auxregbisc(0, AUXIO_FDS);	/* Does this help? */
d1098 1
a1098 1
		ienab_bis(IE_FDSOFT);
a1106 1
	read = bp->b_flags & B_READ;
a1123 4
#ifdef DIAGNOSTIC
			if (!read)
				printf("fdxfer: false read\n");
#endif
a1125 4
#ifdef DIAGNOSTIC
			if (read)
				printf("fdxfer: false write\n");
#endif
d1129 2
a1130 4
			auxregbisc(AUXIO_FTC, 0);
			fdc->sc_istate = ISTATE_IDLE;
			delay(10);
			auxregbisc(0, AUXIO_FTC);
d1132 1
a1132 1
			ienab_bis(IE_FDSOFT);
d1146 16
d1172 1
d1192 1
a1192 1
 		return 0;
d1204 3
d1216 1
a1216 1
			return 1;
d1235 1
a1235 1
			return 1;
d1240 1
a1240 1
		/* fall through */
d1243 2
a1244 1
		if (fdc->sc_flags & FDC_EIS) {
d1256 2
a1257 1
		OUT_FDC(fdc, 6, SEEKTIMEDOUT);	/* XXX head load time == 6ms */
d1273 1
a1273 1
		return 1;
d1277 3
d1286 1
a1286 1
		fd->sc_nbytes = nblks * FDC_BSIZE;
d1315 22
a1336 12
		if (read)
			OUT_FDC(fdc, NE7CMD_READ, IOTIMEDOUT);	/* READ */
		else
			OUT_FDC(fdc, NE7CMD_WRITE, IOTIMEDOUT);	/* WRITE */
		OUT_FDC(fdc, (head << 2) | fd->sc_drive, IOTIMEDOUT);
		OUT_FDC(fdc, fd->sc_cylin, IOTIMEDOUT);	/* track */
		OUT_FDC(fdc, head, IOTIMEDOUT);
		OUT_FDC(fdc, sec + 1, IOTIMEDOUT);	/* sector +1 */
		OUT_FDC(fdc, type->secsize, IOTIMEDOUT);/* sector size */
		OUT_FDC(fdc, type->sectrac, IOTIMEDOUT);/* sectors/track */
		OUT_FDC(fdc, type->gap1, IOTIMEDOUT);	/* gap1 size */
		OUT_FDC(fdc, type->datalen, IOTIMEDOUT);/* data length */
d1342 1
a1342 1
		return 1;				/* will return later */
d1350 1
a1350 1
			return 1;		/* will return later */
d1352 1
a1352 1

d1370 1
a1370 3
		auxregbisc(AUXIO_FTC, 0);
		delay(10);
		auxregbisc(0, AUXIO_FTC);
d1372 1
d1384 3
a1386 1
		if (fdc->sc_nstat != 7 || (st0 & 0xf8) != 0 || st1 != 0) {
d1392 3
a1394 2
				printf("blkno %d nblks %d tc %d\n",
				       fd->sc_blkno, fd->sc_nblks, fdc->sc_tc);
d1448 1
a1448 1
		if (fd->sc_bcount > 0) {
d1465 1
a1465 1
		return 1;			/* will return later */
d1480 1
a1480 1
		return 1;			/* will return later */
d1488 1
a1488 1
			return 1;		/* will return later */
d1505 1
a1505 1
			return 1;		/* time's not up yet */
d1510 1
a1510 1
		return 1;
d1524 1
d1532 2
d1553 13
a1565 8
		diskerr(bp, "fd", "hard error", LOG_PRINTF,
		    fd->sc_skip / FDC_BSIZE, (struct disklabel *)NULL);

		printf(" (st0 %b st1 %b st2 %b cyl %d head %d sec %d)\n",
		    fdc->sc_status[0], NE7_ST0BITS,
		    fdc->sc_status[1], NE7_ST1BITS,
		    fdc->sc_status[2], NE7_ST2BITS,
		    fdc->sc_status[3], fdc->sc_status[4], fdc->sc_status[5]);
d1580 1
a1580 1
	return -1;
d1592 1
a1592 1
	return EINVAL;
d1604 5
d1620 1
a1620 1
		return 0;
d1624 1
a1624 1
			return EBADF;
d1630 1
a1630 1
			return error;
d1635 1
a1635 1
		return error;
d1641 1
a1641 1
		return 0;
d1651 24
a1674 2
		fd_do_eject();
		return 0;
d1691 1
a1691 1
		return 0;
d1698 1
a1698 1
		return 0;
d1711 1
a1711 1
		return 0;
d1714 1
a1714 1
		return ENOTTY;
d1722 63
d1832 2
a1833 1
fd_do_eject()
d1835 1
d1837 13
a1849 3
	auxregbisc(AUXIO_FDS, AUXIO_FEJ);
	delay(10);
	auxregbisc(AUXIO_FEJ, AUXIO_FDS);
d1865 1
a1865 1
	fd_do_eject();
d1873 1
a1873 1
				return;
@


1.16
log
@don't config the floppy on Sun4m's, since the the driver isn't right and doing anything near the floppy blows the system
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.15 1997/04/02 18:28:48 deraadt Exp $	*/
d1695 6
d1709 9
a1717 6
	printf("Insert filesystem floppy and press return.");
	for (;;) {
		c = cngetc();
		if ((c == '\r') || (c == '\n')) {
			printf("\n");
			return;
@


1.15
log
@use FDPART(), limit drives to 2 to avoid dev_t problems; grr@@shandakor.tharsis.com
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.14 1997/04/02 01:33:15 deraadt Exp $	*/
d283 8
@


1.14
log
@clear correct structure, PR#144, grr@@shandakor.tharsis.com
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.13 1996/12/06 11:23:02 deraadt Exp $	*/
d71 1
a71 1
#define FDUNIT(dev)	((dev & 0x180) >> 7)
d471 5
a475 2
	/* physical limit: four drives per controller. */
	for (fa.fa_drive = 0; fa.fa_drive < 4; fa.fa_drive++) {
d477 1
a477 1
	fa.fa_deftype = &fd_types[0];		/* XXX */
d883 1
a883 1
	pmask = (1 << DISKPART(dev));
d907 1
a907 1
	int pmask = (1 << DISKPART(dev));
@


1.13
log
@repair max sectors
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.12 1996/12/05 17:16:59 deraadt Exp $	*/
d1640 1
a1640 1
	bzero(lp, sizeof(struct cpu_disklabel));
@


1.12
log
@mirror isa fd driver in disklabel handling
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.11 1996/11/23 21:46:16 kstailey Exp $	*/
d1652 1
d1668 1
a1668 1
	(void) readdisklabel(dev, fdstrategy, lp, clp);
@


1.11
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.10 1996/11/06 01:33:58 deraadt Exp $	*/
d1637 1
a1641 1
	lp->d_type = DTYPE_FLOPPY;
d1644 1
a1646 2
	lp->d_ntracks = fd->sc_type->heads;	/* Go figure... */
	lp->d_rpm = 3600;	/* XXX like it matters... */
d1648 2
a1649 1
	strncpy(lp->d_typename, "floppy", sizeof(lp->d_typename));
d1651 1
d1653 1
d1665 1
a1665 2
	 * Call the generic disklabel extraction routine.  If there's
	 * not a label there, fake it.
d1667 4
a1670 22
	if (readdisklabel(dev, fdstrategy, lp, clp) != NULL) {
		strncpy(lp->d_packname, "default label",
		    sizeof(lp->d_packname));
		/*
		 * Reset the partition info; it might have gotten
		 * trashed in readdisklabel().
		 *
		 * XXX Why do we have to do this?  readdisklabel()
		 * should be safe...
		 */
		for (i = 0; i < MAXPARTITIONS; ++i) {
			lp->d_partitions[i].p_offset = 0;
			if (i == RAW_PART) {
				lp->d_partitions[i].p_size =
				    lp->d_secpercyl * lp->d_ncylinders;
				lp->d_partitions[i].p_fstype = FS_BSDFFS;
			} else {
				lp->d_partitions[i].p_size = 0;
				lp->d_partitions[i].p_fstype = FS_UNUSED;
			}
		}
		lp->d_npartitions = RAW_PART + 1;
@


1.10
log
@give floppies real partitions
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.9 1996/08/11 23:11:35 downsj Exp $	*/
d223 1
a223 1
int fdprint __P((void *, char *));
d315 1
a315 1
	char *fdc;
@


1.9
log
@Merge back revisions 1.2 through 1.4.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d71 3
a73 2
#define FDUNIT(dev)	(minor(dev) / 8)
#define FDTYPE(dev)	(minor(dev) % 8)
@


1.8
log
@netbsd port, now we merge our changes back in
@
text
@d1 1
d55 1
a496 2
		/* wait for motor to spin up */
		delay(250000);
d500 3
d537 1
a537 2
	if (fdc->sc_flags & FDC_82077) {
		/* select drive and turn on motor */
d539 1
a539 1
	} else {
a540 1
	}
d562 1
a562 1
		printf(": %s %d cyl, %d head, %d sec\n", type->name,
d1058 1
a1058 1
		return 1;
d1066 1
a1066 1
		return 1;
d1071 1
a1071 1
		return 1;
d1114 3
a1116 1
	return 1;
d1571 7
@


1.7
log
@sync with netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: fd.c,v 1.13 1995/10/09 22:33:07 pk Exp $	*/
a45 1
#include <sys/conf.h>
d54 1
a54 1
#include <sys/mtio.h>
d57 3
d63 2
d135 2
a136 2
struct cfdriver fdccd = {
	NULL, "fdc", fdcmatch, fdcattach, DV_DULL, sizeof(struct fdc_softc)
d139 6
d197 2
d208 2
a209 2
struct cfdriver fdcd = {
	NULL, "fd", fdmatch, fdattach, DV_DISK, sizeof(struct fd_softc)
d212 5
a216 1
void fdgetdisklabel __P((struct fd_softc *));
d220 1
d243 3
d253 1
a253 1
#define OBP_FDNAME	(cputyp == CPU_SUN4M ? "SUNW,fdtwo" : "fd")
a259 1
	struct cfdata *cf = match;
d263 18
d284 4
a287 6
	if (ca->ca_bustype == BUS_MAIN) {
		if (ca->ca_ra.ra_vaddr &&
		    probeget(ca->ca_ra.ra_vaddr, 1) == -1) {
			return (0);
		}
		return (1);
d290 1
a290 1
	return (0);
d298 1
a298 1
	int fa_bootdev;
d353 2
a354 1
	int n, pri;
d437 30
a466 7
	if (ca->ca_ra.ra_bp &&
	    strcmp(ca->ca_ra.ra_bp->name, OBP_FDNAME) == 0 &&
	    ca->ca_ra.ra_bp->val[0] == 0 && 
	    ca->ca_ra.ra_bp->val[1] == 0)
		fa.fa_bootdev = 1;
	else
		fa.fa_bootdev = 0;
a483 1
	struct cfdata *cf = match;
d486 1
a486 1
	int n;
a499 1

d504 2
a505 2
	for (n = 0; n < 100000; n++) {
		delay(10);
d531 2
a532 2
	if (n != 2 || (fdc->sc_status[0] & 0xf8) != 0x20)
		return 0;
d534 2
a535 1
	if (fdc->sc_flags & FDC_82077)
d537 1
a537 1
	else
d539 1
d541 1
a541 1
	return 1;
d561 1
a561 1
		printf(": %s, %d cyl, %d head, %d sec\n", type->name,
d581 11
a591 2
	if (fa->fa_bootdev)
		bootdv = &fd->sc_dv;
d597 1
a597 1
inline struct fd_type *
d619 2
a620 2
	if (unit >= fdcd.cd_ndevs ||
	    (fd = fdcd.cd_devs[unit]) == 0 ||
d653 1
a653 1
		printf("fdstrategy: b_blkno %d b_bcount %d blkno %d cylin %d\n",
d756 1
a756 1
		if (fd = fdc->sc_drives.tqh_first)
d845 1
a845 1
Fdopen(dev, flags)
d847 2
a848 1
	int flags;
d850 1
a850 1
 	int unit;
d855 1
a855 1
	if (unit >= fdcd.cd_ndevs)
d857 1
a857 1
	fd = fdcd.cd_devs[unit];
d872 20
d896 1
a896 1
fdclose(dev, flags)
d898 2
a899 1
	int flags;
d901 2
a902 1
	struct fd_softc *fd = fdcd.cd_devs[FDUNIT(dev)];
d905 13
d922 1
a922 1
fdread(dev, uio)
d925 1
d932 1
a932 1
fdwrite(dev, uio)
d935 1
a963 1

d1057 1
a1057 1
		goto done;
d1065 1
a1065 1
		goto done;
d1070 1
a1070 1
		goto done;
d1113 1
a1113 3
done:
	sc->sc_intrcnt.ev_count++;
	return (1);
d1129 1
a1129 1
	int read, head, trac, sec, i, s, nblks;
a1351 1
					fdc->sc_state = DOIO;
d1354 2
a1355 1
				if (++fdc->sc_overruns < 3)
d1357 1
d1474 1
a1474 1
			(fdc->sc_flags & FDC_EIS) ? DOIO : SEEKCOMPLETE;
d1490 1
d1514 5
a1518 1
fddump()
d1526 1
a1526 1
fdioctl(dev, cmd, addr, flag)
d1531 1
d1533 1
a1533 2
	struct fd_softc *fd = fdcd.cd_devs[FDUNIT(dev)];
	struct disklabel buffer;
a1537 11
		bzero(fd->sc_dk.dk_label, sizeof(struct disklabel));
		
		fd->sc_dk.dk_label->d_secpercyl = fd->sc_type->seccyl;
		fd->sc_dk.dk_label->d_type = DTYPE_FLOPPY;
		fd->sc_dk.dk_label->d_secsize = FDC_BSIZE;

		if (readdisklabel(dev, fdstrategy,
				  fd->sc_dk.dk_label,
				  fd->sc_dk.dk_cpulabel) != NULL)
			return EINVAL;

d1562 8
a1569 9
	case MTIOCTOP:
		if (((struct mtop *)addr)->mt_op != MTOFFL)
			return EIO;
#ifdef COMPAT_SUNOS
	case SUNOS_FDIOCEJECT:
#endif
		auxregbisc(AUXIO_FDS, AUXIO_FEJ);
		delay(10);
		auxregbisc(AUXIO_FEJ, AUXIO_FDS);
d1571 1
d1593 1
a1593 1
		fdconf(fd->sc_dv.dv_parent);
d1616 89
@


1.6
log
@from netbsd;
New generic disk framework.  Highlights:
New metrics handling.  Metrics are now kept in the new `struct disk'.
Busy time is now stored as a timeval, and transfer count in bytes.
Storage for disklabels is now dynamically allocated, so that the size
of the disk structure is not machine-dependent.
Several new functions for attaching and detaching disks, and handling
metrics calculation.
Old-style instrumentation is still supported in drivers that did it
before.  However, old-style instrumentation is being deprecated, and
will go away once the userland utilities are updated for the new
framework.
For usage and architectural details, see the forthcoming disk(9)
manual page.
@
text
@a624 3
	/* Instrumentation. */
	disk_busy(&fd->sc_dk);

a654 2
	disk_unbusy(&fd->sc_dk, (bp->b_bcount - bp->b_resid));

d1118 4
d1174 3
d1191 2
d1219 3
@


1.5
log
@new mapdev/()/mapiodev() calling convention uses "struct rom_reg *" to supply
base plus an offset
new dvma routines
@
text
@d168 2
a169 1
	struct dkdevice sc_dk;
d415 2
d511 5
d517 1
d523 1
a523 1
		bootdv = &fd->sc_dk.dk_dev;
d526 1
a526 1
	dk_establish(&fd->sc_dk, &fd->sc_dk.dk_dev);
d597 1
a597 1
		struct fdc_softc *fdc = (void *)fd->sc_dk.dk_dev.dv_parent;
d618 1
a618 1
	struct fdc_softc *fdc = (void *)fd->sc_dk.dk_dev.dv_parent;
d625 3
d638 1
a638 1
	struct fdc_softc *fdc = (void *)fd->sc_dk.dk_dev.dv_parent;
d657 3
d723 1
a723 1
	fd_set_motor((struct fdc_softc *)fd->sc_dk.dk_dev.dv_parent);
d732 1
a732 1
	struct fdc_softc *fdc = (void *)fd->sc_dk.dk_dev.dv_parent;
d914 1
a914 1
	fdcstatus(&fd->sc_dk.dk_dev, 0, "timeout");
d1194 1
a1194 1
				fdcstatus(&fd->sc_dk.dk_dev, 2, "seek failed");
d1218 1
a1218 1
				fdcstatus(&fd->sc_dk.dk_dev, 7,
d1322 1
a1322 1
				fdcstatus(&fd->sc_dk.dk_dev, 2, "recalibrate failed");
d1336 1
a1336 1
		fdcstatus(&fd->sc_dk.dk_dev, 0, "stray interrupt");
d1422 1
a1422 1
		bzero(&fd->sc_dk.dk_label, sizeof(struct disklabel));
d1424 3
a1426 3
		fd->sc_dk.dk_label.d_secpercyl = fd->sc_type->seccyl;
		fd->sc_dk.dk_label.d_type = DTYPE_FLOPPY;
		fd->sc_dk.dk_label.d_secsize = FDC_BSIZE;
d1429 2
a1430 2
				  &fd->sc_dk.dk_label,
				  &fd->sc_dk.dk_cpulabel) != NULL)
d1433 1
a1433 1
		*(struct disklabel *)addr = fd->sc_dk.dk_label;
d1446 1
a1446 1
		error = setdisklabel(&fd->sc_dk.dk_label,
d1448 1
a1448 1
				    &fd->sc_dk.dk_cpulabel);
d1453 2
a1454 2
				       &fd->sc_dk.dk_label,
				       &fd->sc_dk.dk_cpulabel);
d1472 1
a1472 1
					fd->sc_dk.dk_dev.dv_parent;
d1484 1
a1484 1
		((struct fdc_softc *)fd->sc_dk.dk_dev.dv_parent)->sc_cfg &=
d1486 1
a1486 1
		((struct fdc_softc *)fd->sc_dk.dk_dev.dv_parent)->sc_cfg |=
d1488 1
a1488 1
		fdconf(fd->sc_dk.dk_dev.dv_parent);
d1494 1
a1494 1
					fd->sc_dk.dk_dev.dv_parent;
@


1.4
log
@pretty; delay properly during drive probe
@
text
@d96 1
a96 1
	struct dkdevice sc_dk;		/* boilerplate */
d323 1
a323 1
		fdc->sc_reg = (caddr_t)mapiodev(ca->ca_ra.ra_paddr,
d392 1
a392 1
	evcnt_attach(&fdc->sc_dk.dk_dev, "intr", &fdc->sc_intrcnt);
d434 2
a438 2
	/* wait for motor to spin up */
	delay(250000);
@


1.3
log
@simplify
@
text
@a433 2
		/* wait for motor to spin up */
		delay(250000);
d437 3
d474 1
a474 2
	if (fdc->sc_flags & FDC_82077) {
		/* select drive and turn on motor */
d476 1
a476 1
	} else {
a477 1
	}
d499 1
a499 1
		printf(": %s %d cyl, %d head, %d sec\n", type->name,
@


1.2
log
@intr counter; mtio offline
@
text
@a1402 1
	struct mtop *mtop;
d1444 1
a1444 2
		mtop = (struct mtop *)addr;
		if (mtop->mt_op != MTOFFL)
@


1.1
log
@Initial revision
@
text
@d55 1
d943 1
a943 1
		return 1;
d951 1
a951 1
		return 1;
d956 1
a956 1
		return 1;
d999 3
a1001 1
	return 1;
d1403 1
d1444 7
a1450 1
	case DIOCEJECT:
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
