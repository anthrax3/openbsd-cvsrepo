head	1.25;
access;
symbols
	OPENBSD_6_0:1.25.0.6
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.24.0.6
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.23.0.16
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.14
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.12
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.10
	OPENBSD_5_0:1.23.0.8
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.6
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.20.0.8
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.6
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.4
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.15.0.4
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	SMP:1.4.0.2
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.25
date	2015.03.28.19.07.07;	author miod;	state Exp;
branches;
next	1.24;
commitid	nwbHy4sQv9NnJnmZ;

1.24
date	2013.10.20.20.07.26;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.05.14.09.35;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2008.12.26.22.30.21;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2008.12.26.00.43.03;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2007.02.25.18.14.48;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2007.02.18.18.40.35;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.12.02.11.24.02;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.11.29.19.08.22;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.06.02.20.00.54;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.09.22.22.12;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.23.17.16.34;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.23.17.15.44;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.07.16.44.50;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.05.23.04.25;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.29.22.07.37;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.29.07.35.11;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.12.16.26.11;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.10.09.05.52;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.03.09.22.59.09;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.27.22.32.20;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.07.10.16.45;	author jmc;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2003.06.28.17.05.33;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.18.17.40.32;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2003.06.17.21.21.32;	author miod;	state Exp;
branches;
next	;

1.4.2.1
date	2004.06.05.23.10.57;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Don't include sbusvar.h if you need neither sbus_translate() nor sbus_testdma().
@
text
@/*	$OpenBSD: p9000.c,v 1.24 2013/10/20 20:07:26 miod Exp $	*/

/*
 * Copyright (c) 2003, Miodrag Vallat.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Driver for the Tadpole SPARCbook 3 on-board display.
 * Heavily based on the p9100 driver.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/mman.h>
#include <sys/tty.h>
#include <sys/conf.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/pmap.h>
#include <machine/cpu.h>
#include <machine/conf.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

#include <sparc/dev/btreg.h>
#include <sparc/dev/btvar.h>
#include <sparc/dev/bt445reg.h>
#include <sparc/dev/bt445var.h>

#include <dev/ic/p9000.h>

#include "tctrl.h"
#if NTCTRL > 0
#include <sparc/dev/tctrlvar.h>
#endif

/* per-display variables */
struct p9000_softc {
	struct	sunfb sc_sunfb;		/* common base part */
	struct	rom_reg	sc_phys;	/* phys address description */
	volatile u_int8_t *sc_cmd;	/* command registers (dac, etc) */
	volatile u_int8_t *sc_ctl;	/* control registers (draw engine) */
	union	bt_cmap sc_cmap;	/* Brooktree color map */
	volatile u_int8_t *sc_ramdac;	/* BT445 registers */
	struct	intrhand sc_ih;
	u_int32_t	sc_junk;	/* throwaway value */
};

int	p9000_ioctl(void *, u_long, caddr_t, int, struct proc *);
static __inline__
void	p9000_loadcmap_deferred(struct p9000_softc *, u_int, u_int);
void	p9000_loadcmap_immediate(struct p9000_softc *, u_int, u_int);
paddr_t	p9000_mmap(void *, off_t, int);
void	p9000_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
void	p9000_burner(void *, u_int, u_int);
int	p9000_intr(void *);

struct wsdisplay_accessops p9000_accessops = {
	.ioctl = p9000_ioctl,
	.mmap = p9000_mmap,
	.burn_screen = p9000_burner
};

int	p9000_ras_copycols(void *, int, int, int, int);
int	p9000_ras_copyrows(void *, int, int, int);
int	p9000_ras_do_cursor(struct rasops_info *);
int	p9000_ras_erasecols(void *, int, int, int, long int);
int	p9000_ras_eraserows(void *, int, int, long int);
void	p9000_ras_init(struct p9000_softc *);

int	p9000match(struct device *, void *, void *);
void	p9000attach(struct device *, struct device *, void *);

struct cfattach pninek_ca = {
	sizeof (struct p9000_softc), p9000match, p9000attach
};

struct cfdriver pninek_cd = {
	NULL, "pninek", DV_DULL
};

/*
 * SBus registers mappings
 */
#define	P9000_NREG	5	/* actually, 7 total */
#define	P9000_REG_CTL	0
#define	P9000_REG_CMD	1
#define	P9000_REG_VRAM	4

/*
 * P9000 read/write macros
 */

#define	P9000_READ_CTL(sc,reg) \
	*(volatile u_int32_t *)((sc)->sc_ctl + (reg))
#define	P9000_READ_CMD(sc,reg) \
	*(volatile u_int32_t *)((sc)->sc_cmd + (reg))

#define	P9000_WRITE_CTL(sc,reg,value) \
	*(volatile u_int32_t *)((sc)->sc_ctl + (reg)) = (value)
#define	P9000_WRITE_CMD(sc,reg,value) \
	*(volatile u_int32_t *)((sc)->sc_cmd + (reg)) = (value)

/*
 * On the Tadpole, the first write to a register group is ignored until
 * the proper group address is latched, which can be done by reading from the
 * register group first.
 *
 * Register groups are 0x80 bytes long (i.e. it is necessary to force a read
 * when writing to an address which upper 25 bit differ from the previous
 * read or write operation).
 *
 * This is specific to the Tadpole design, and not a limitation of the
 * Power 9000 hardware.
 */
#define	P9000_SELECT_SCR(sc) \
	(sc)->sc_junk = P9000_READ_CTL(sc, P9000_SYSTEM_CONFIG)
#define	P9000_SELECT_VCR(sc) \
	(sc)->sc_junk = P9000_READ_CTL(sc, P9000_HCR)
#define	P9000_SELECT_VRAM(sc) \
	(sc)->sc_junk = P9000_READ_CTL(sc, P9000_MCR)
#define	P9000_SELECT_PE(sc) \
	(sc)->sc_junk = P9000_READ_CMD(sc, P9000_PE_STATUS)
#define	P9000_SELECT_DE_LOW(sc)	\
	(sc)->sc_junk = P9000_READ_CMD(sc, P9000_DE_FG_COLOR)
#define	P9000_SELECT_DE_HIGH(sc) \
	(sc)->sc_junk = P9000_READ_CMD(sc, P9000_DE_PATTERN(0))
#define	P9000_SELECT_COORD(sc,field) \
	(sc)->sc_junk = P9000_READ_CMD(sc, field)


int
p9000match(struct device *parent, void *vcf, void *aux)
{
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

	if (strcmp("p9000", ra->ra_name))
		return (0);

	/*
	 * If this is not the console device, chances are the
	 * frame buffer is not completely initialized, and access
	 * to some of its control registers could hang (this is
	 * the case on p9100). Until this can be verified, do
	 * not attach if console is on serial.
	 */
	if (ra->ra_node != fbnode)
		return (0);

	return (1);
}

void
p9000attach(struct device *parent, struct device *self, void *args)
{
	struct p9000_softc *sc = (struct p9000_softc *)self;
	struct confargs *ca = args;
	int node, pri, isconsole, scr;
	struct device *btdev;
	extern struct cfdriver btcham_cd;

	pri = ca->ca_ra.ra_intr[0].int_pri;
	printf(" pri %d", pri);

#ifdef DIAGNOSTIC
	if (ca->ca_ra.ra_nreg < P9000_NREG) {
		printf(": expected %d registers, got only %d\n",
		    P9000_NREG, ca->ca_ra.ra_nreg);
		return;
	}
#endif

	/*
	 * Find the RAMDAC device. It should have attached before, since it
	 * attaches at obio. If, for some reason, it did not, it's not worth
	 * going any further.
	 *
	 * We rely upon the PROM to properly initialize the RAMDAC in a safe
	 * mode.
	 */
	btdev = btcham_cd.cd_ndevs != 0 ? btcham_cd.cd_devs[0] : NULL;
	if (btdev != NULL)
		sc->sc_ramdac = ((struct bt445_softc *)btdev)->sc_regs;

	if (sc->sc_ramdac == NULL) {
		printf(": bt445 did not attach previously\n");
		return;
	}

	sc->sc_phys = ca->ca_ra.ra_reg[P9000_REG_VRAM];

	sc->sc_ctl = mapiodev(&(ca->ca_ra.ra_reg[P9000_REG_CTL]), 0,
	    ca->ca_ra.ra_reg[0].rr_len);
	sc->sc_cmd = mapiodev(&(ca->ca_ra.ra_reg[P9000_REG_CMD]), 0,
	    ca->ca_ra.ra_reg[1].rr_len);

	node = ca->ca_ra.ra_node;
	isconsole = node == fbnode;

	fb_setsize(&sc->sc_sunfb, 8, 640, 480, node, ca->ca_bustype);
	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(&sc->sc_phys, 0,
	    round_page(sc->sc_sunfb.sf_fbsize));
	sc->sc_sunfb.sf_ro.ri_hw = sc;

	P9000_SELECT_SCR(sc);
	scr = P9000_READ_CTL(sc, P9000_SYSTEM_CONFIG);

	printf(": rev %x, %dx%d\n", scr & SCR_ID_MASK,
	    sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);

	/* Disable frame buffer interrupts */
	P9000_SELECT_SCR(sc);
	P9000_WRITE_CTL(sc, P9000_INTERRUPT_ENABLE, IER_MASTER_ENABLE | 0);

	sc->sc_ih.ih_fun = p9000_intr;
	sc->sc_ih.ih_arg = sc;
	intr_establish(pri, &sc->sc_ih, IPL_FB, self->dv_xname);

	fbwscons_init(&sc->sc_sunfb, isconsole);
	fbwscons_setcolormap(&sc->sc_sunfb, p9000_setcolor);

	/*
	 * Plug-in accelerated console operations.
	 */
	if (sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags != 0)
		p9000_ras_init(sc);

	/* enable video */
	p9000_burner(sc, 1, 0);

	if (isconsole)
		fbwscons_console_init(&sc->sc_sunfb, -1);

	fbwscons_attach(&sc->sc_sunfb, &p9000_accessops, isconsole);
}

int
p9000_ioctl(void *v, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct p9000_softc *sc = v;
	struct wsdisplay_fbinfo *wdf;
	struct wsdisplay_cmap *cm;
#if NTCTRL > 0
	struct wsdisplay_param *dp;
#endif
	int error;

	switch (cmd) {

	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_SB_P9000;
		break;

	case WSDISPLAYIO_SMODE:
		/* Restore proper acceleration state upon leaving X11 */
		if (*(u_int *)data == WSDISPLAYIO_MODE_EMUL) {
			if (sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags != 0)
				p9000_ras_init(sc);
		}
		break;

	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
		wdf->cmsize = 256;
		break;

	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
		break;

	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_getcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		break;

	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		p9000_loadcmap_deferred(sc, cm->index, cm->count);
		break;

#if NTCTRL > 0
	case WSDISPLAYIO_GETPARAM:
		dp = (struct wsdisplay_param *)data;

		switch (dp->param) {
		case WSDISPLAYIO_PARAM_BRIGHTNESS:
			dp->min = 0;
			dp->max = 255;
			dp->curval = tadpole_get_brightness();
			break;
		case WSDISPLAYIO_PARAM_BACKLIGHT:
			dp->min = 0;
			dp->max = 1;
			dp->curval = tadpole_get_video() & TV_ON ? 1 : 0;
			break;
		default:
			return (-1);
		}
		break;

	case WSDISPLAYIO_SETPARAM:
		dp = (struct wsdisplay_param *)data;

		switch (dp->param) {
		case WSDISPLAYIO_PARAM_BRIGHTNESS:
			tadpole_set_brightness(dp->curval);
			break;
		case WSDISPLAYIO_PARAM_BACKLIGHT:
			tadpole_set_video(dp->curval);
			break;
		default:
			return (-1);
		}
		break;
#endif	/* NTCTRL > 0 */

	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
		break;

	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
	default:
		return (-1);	/* not supported yet */
	}

	return (0);
}

paddr_t
p9000_mmap(void *v, off_t offset, int prot)
{
	struct p9000_softc *sc = v;

	if (offset & PGOFSET)
		return (-1);

	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys, offset) | PMAP_NC);
	}

	return (-1);
}

void
p9000_setcolor(void *v, u_int index, u_int8_t r, u_int8_t g, u_int8_t b)
{
	struct p9000_softc *sc = v;
	union bt_cmap *bcm = &sc->sc_cmap;

	bcm->cm_map[index][0] = r;
	bcm->cm_map[index][1] = g;
	bcm->cm_map[index][2] = b;
	p9000_loadcmap_immediate(sc, index, 1);
}

void
p9000_loadcmap_immediate(struct p9000_softc *sc, u_int start, u_int ncolors)
{
	sc->sc_ramdac[BT445_ADDRESS] = start;
	for (ncolors += start; start < ncolors; start++) {
		sc->sc_ramdac[BT445_PALDATA] = sc->sc_cmap.cm_map[start][0];
		sc->sc_ramdac[BT445_PALDATA] = sc->sc_cmap.cm_map[start][1];
		sc->sc_ramdac[BT445_PALDATA] = sc->sc_cmap.cm_map[start][2];
	}
}

static __inline__ void
p9000_loadcmap_deferred(struct p9000_softc *sc, u_int start, u_int ncolors)
{
	/* Schedule an interrupt for next retrace */
	P9000_SELECT_SCR(sc);
	P9000_WRITE_CTL(sc, P9000_INTERRUPT_ENABLE,
	    IER_MASTER_ENABLE | IER_MASTER_INTERRUPT |
	    IER_VBLANK_ENABLE | IER_VBLANK_INTERRUPT);
}

void
p9000_burner(void *v, u_int on, u_int flags)
{
	struct p9000_softc *sc = v;
	u_int32_t vcr;
	int s;

	s = splhigh();
	P9000_SELECT_VCR(sc);
	vcr = P9000_READ_CTL(sc, P9000_SRTC1);
	if (on)
		vcr |= SRTC1_VIDEN;
	else
		vcr &= ~SRTC1_VIDEN;
	P9000_WRITE_CTL(sc, P9000_SRTC1, vcr);
#if NTCTRL > 0
	tadpole_set_video(on);
#endif
	splx(s);
}

int
p9000_intr(void *v)
{
	struct p9000_softc *sc = v;

	if (P9000_READ_CTL(sc, P9000_INTERRUPT) & IER_VBLANK_INTERRUPT) {
		p9000_loadcmap_immediate(sc, 0, 256);

		/* Disable further interrupts now */
		/* P9000_SELECT_SCR(sc); */
		P9000_WRITE_CTL(sc, P9000_INTERRUPT_ENABLE,
		    IER_MASTER_ENABLE | 0);

		/* Clear interrupt condition */
		P9000_WRITE_CTL(sc, P9000_INTERRUPT,
		    IER_VBLANK_ENABLE | 0);

		return (1);
	}

	return (0);
}

/*
 * Accelerated text console code
 */

static int p9000_drain(struct p9000_softc *);

static int
p9000_drain(struct p9000_softc *sc)
{
	u_int i;

	for (i = 10000; i != 0; i--) {
		if ((P9000_READ_CMD(sc, P9000_PE_STATUS) &
		    (STATUS_QUAD_BUSY | STATUS_BLIT_BUSY)) == 0)
			break;
	}

	return (i);
}

void
p9000_ras_init(struct p9000_softc *sc)
{

	if (p9000_drain(sc) == 0)
		return;

	sc->sc_sunfb.sf_ro.ri_ops.copycols = p9000_ras_copycols;
	sc->sc_sunfb.sf_ro.ri_ops.copyrows = p9000_ras_copyrows;
	sc->sc_sunfb.sf_ro.ri_ops.erasecols = p9000_ras_erasecols;
	sc->sc_sunfb.sf_ro.ri_ops.eraserows = p9000_ras_eraserows;
	sc->sc_sunfb.sf_ro.ri_do_cursor = p9000_ras_do_cursor;

	/*
	 * Setup safe defaults for the parameter and drawing engines, in
	 * order to minimize the operations to do for ri_ops.
	 */

	P9000_SELECT_DE_LOW(sc);
	P9000_WRITE_CMD(sc, P9000_DE_DRAWMODE,
	    DM_PICK_CONTROL | 0 | DM_BUFFER_CONTROL | DM_BUFFER_ENABLE0);

	P9000_WRITE_CMD(sc, P9000_DE_PATTERN_ORIGIN_X, 0);
	P9000_WRITE_CMD(sc, P9000_DE_PATTERN_ORIGIN_Y, 0);
	/* enable all planes */
	P9000_WRITE_CMD(sc, P9000_DE_PLANEMASK, 0xff);

	/* Unclip */
	P9000_WRITE_CMD(sc, P9000_DE_WINMIN, 0);
	P9000_WRITE_CMD(sc, P9000_DE_WINMAX,
	    P9000_COORDS(sc->sc_sunfb.sf_width - 1, sc->sc_sunfb.sf_height - 1));

	P9000_SELECT_PE(sc);
	P9000_WRITE_CMD(sc, P9000_PE_WINOFFSET, 0);
	P9000_WRITE_CMD(sc, P9000_PE_INDEX, 0);
	P9000_WRITE_CMD(sc, P9000_PE_WINMIN, 0);
	P9000_WRITE_CMD(sc, P9000_PE_WINMAX,
	    P9000_COORDS(sc->sc_sunfb.sf_width - 1, sc->sc_sunfb.sf_height - 1));
}

int
p9000_ras_copycols(void *v, int row, int src, int dst, int n)
{
	struct rasops_info *ri = v;
	struct p9000_softc *sc = ri->ri_hw;

	n *= ri->ri_font->fontwidth;
	n--;
	src *= ri->ri_font->fontwidth;
	src += ri->ri_xorigin;
	dst *= ri->ri_font->fontwidth;
	dst += ri->ri_xorigin;
	row *= ri->ri_font->fontheight;
	row += ri->ri_yorigin;

	p9000_drain(sc);
	P9000_SELECT_DE_LOW(sc);
	P9000_WRITE_CMD(sc, P9000_DE_RASTER,
	    P9000_RASTER_SRC & P9000_RASTER_MASK);

	P9000_SELECT_COORD(sc, P9000_DC_COORD(0));
	P9000_WRITE_CMD(sc, P9000_DC_COORD(0) + P9000_COORD_XY,
	    P9000_COORDS(src, row));
	P9000_WRITE_CMD(sc, P9000_DC_COORD(1) + P9000_COORD_XY,
	    P9000_COORDS(src + n, row + ri->ri_font->fontheight - 1));
	P9000_SELECT_COORD(sc, P9000_DC_COORD(2));
	P9000_WRITE_CMD(sc, P9000_DC_COORD(2) + P9000_COORD_XY,
	    P9000_COORDS(dst, row));
	P9000_WRITE_CMD(sc, P9000_DC_COORD(3) + P9000_COORD_XY,
	    P9000_COORDS(dst + n, row + ri->ri_font->fontheight - 1));

	sc->sc_junk = P9000_READ_CMD(sc, P9000_PE_BLIT);

	p9000_drain(sc);

	return 0;
}

int
p9000_ras_copyrows(void *v, int src, int dst, int n)
{
	struct rasops_info *ri = v;
	struct p9000_softc *sc = ri->ri_hw;

	n *= ri->ri_font->fontheight;
	n--;
	src *= ri->ri_font->fontheight;
	src += ri->ri_yorigin;
	dst *= ri->ri_font->fontheight;
	dst += ri->ri_yorigin;

	p9000_drain(sc);
	P9000_SELECT_DE_LOW(sc);
	P9000_WRITE_CMD(sc, P9000_DE_RASTER,
	    P9000_RASTER_SRC & P9000_RASTER_MASK);

	P9000_SELECT_COORD(sc, P9000_DC_COORD(0));
	P9000_WRITE_CMD(sc, P9000_DC_COORD(0) + P9000_COORD_XY,
	    P9000_COORDS(ri->ri_xorigin, src));
	P9000_WRITE_CMD(sc, P9000_DC_COORD(1) + P9000_COORD_XY,
	    P9000_COORDS(ri->ri_xorigin + ri->ri_emuwidth - 1, src + n));
	P9000_SELECT_COORD(sc, P9000_DC_COORD(2));
	P9000_WRITE_CMD(sc, P9000_DC_COORD(2) + P9000_COORD_XY,
	    P9000_COORDS(ri->ri_xorigin, dst));
	P9000_WRITE_CMD(sc, P9000_DC_COORD(3) + P9000_COORD_XY,
	    P9000_COORDS(ri->ri_xorigin + ri->ri_emuwidth - 1, dst + n));

	sc->sc_junk = P9000_READ_CMD(sc, P9000_PE_BLIT);

	p9000_drain(sc);

	return 0;
}

int
p9000_ras_erasecols(void *v, int row, int col, int n, long int attr)
{
	struct rasops_info *ri = v;
	struct p9000_softc *sc = ri->ri_hw;
	int fg, bg;

	ri->ri_ops.unpack_attr(v, attr, &fg, &bg, NULL);

	n *= ri->ri_font->fontwidth;
	col *= ri->ri_font->fontwidth;
	col += ri->ri_xorigin;
	row *= ri->ri_font->fontheight;
	row += ri->ri_yorigin;

	p9000_drain(sc);
	P9000_SELECT_DE_LOW(sc);
	P9000_WRITE_CMD(sc, P9000_DE_RASTER,
	    P9000_RASTER_PATTERN & P9000_RASTER_MASK);
	P9000_WRITE_CMD(sc, P9000_DE_FG_COLOR, bg);

	P9000_SELECT_COORD(sc, P9000_LC_RECT);
	P9000_WRITE_CMD(sc, P9000_LC_RECT + P9000_COORD_XY,
	    P9000_COORDS(col, row));
	P9000_WRITE_CMD(sc, P9000_LC_RECT + P9000_COORD_XY,
	    P9000_COORDS(col + n, row + ri->ri_font->fontheight));

	sc->sc_junk = P9000_READ_CMD(sc, P9000_PE_QUAD);

	p9000_drain(sc);

	return 0;
}

int
p9000_ras_eraserows(void *v, int row, int n, long int attr)
{
	struct rasops_info *ri = v;
	struct p9000_softc *sc = ri->ri_hw;
	int fg, bg;

	ri->ri_ops.unpack_attr(v, attr, &fg, &bg, NULL);

	p9000_drain(sc);
	P9000_SELECT_DE_LOW(sc);
	P9000_WRITE_CMD(sc, P9000_DE_RASTER,
	    P9000_RASTER_PATTERN & P9000_RASTER_MASK);
	P9000_WRITE_CMD(sc, P9000_DE_FG_COLOR, bg);

	P9000_SELECT_COORD(sc, P9000_LC_RECT);
	if (n == ri->ri_rows && ISSET(ri->ri_flg, RI_FULLCLEAR)) {
		P9000_WRITE_CMD(sc, P9000_LC_RECT + P9000_COORD_XY,
		    P9000_COORDS(0, 0));
		P9000_WRITE_CMD(sc, P9000_LC_RECT + P9000_COORD_XY,
		    P9000_COORDS(ri->ri_width, ri->ri_height));
	} else {
		n *= ri->ri_font->fontheight;
		row *= ri->ri_font->fontheight;
		row += ri->ri_yorigin;

		P9000_WRITE_CMD(sc, P9000_LC_RECT + P9000_COORD_XY,
		    P9000_COORDS(ri->ri_xorigin, row));
		P9000_WRITE_CMD(sc, P9000_LC_RECT + P9000_COORD_XY,
		    P9000_COORDS(ri->ri_xorigin + ri->ri_emuwidth, row + n));
	}

	sc->sc_junk = P9000_READ_CMD(sc, P9000_PE_QUAD);

	p9000_drain(sc);

	return 0;
}

int
p9000_ras_do_cursor(struct rasops_info *ri)
{
	struct p9000_softc *sc = ri->ri_hw;
	int row, col;

	row = ri->ri_crow * ri->ri_font->fontheight + ri->ri_yorigin;
	col = ri->ri_ccol * ri->ri_font->fontwidth + ri->ri_xorigin;

	p9000_drain(sc);

	P9000_SELECT_DE_LOW(sc);
	P9000_WRITE_CMD(sc, P9000_DE_RASTER,
	    (P9000_RASTER_PATTERN ^ P9000_RASTER_DST) & P9000_RASTER_MASK);
	P9000_WRITE_CMD(sc, P9000_DE_FG_COLOR, ri->ri_devcmap[WSCOL_BLACK]);

	P9000_SELECT_COORD(sc, P9000_LC_RECT);
	P9000_WRITE_CMD(sc, P9000_LC_RECT + P9000_COORD_XY,
	    P9000_COORDS(col, row));
	P9000_WRITE_CMD(sc, P9000_LC_RECT + P9000_COORD_XY,
	    P9000_COORDS(col + ri->ri_font->fontwidth,
	        row + ri->ri_font->fontheight));

	sc->sc_junk = P9000_READ_CMD(sc, P9000_PE_QUAD);

	p9000_drain(sc);

	return 0;
}
@


1.24
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9000.c,v 1.23 2009/09/05 14:09:35 miod Exp $	*/
a58 1
#include <sparc/dev/sbusvar.h>
@


1.23
log
@Change the wsdisplay_emulops return types from void to int; emulops will now
return zero on success and nonzero on failure.
This commit only performs mechanical changes for the existing emulops to
always return zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9000.c,v 1.22 2008/12/26 22:30:21 miod Exp $	*/
d90 3
a92 10
	p9000_ioctl,
	p9000_mmap,
	NULL,	/* alloc_screen */
	NULL,	/* free_screen */
	NULL,	/* show_screen */
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	p9000_burner,
	NULL	/* pollc */
@


1.22
log
@Move the logic responsible from deciding whether a frame buffer needs to be
cleared on attach, from the individual drivers to the common frame buffer code;
the latter will decide based on the prom font metrics and the prom console
window position, whenever possible.

This removes the need for the console window position to be hardcoded in
the p9100 driver, and will no longer require a screen clear on a vigra
VS-12 in high resolution mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9000.c,v 1.21 2008/12/26 00:43:03 miod Exp $	*/
d102 5
a106 5
void	p9000_ras_copycols(void *, int, int, int, int);
void	p9000_ras_copyrows(void *, int, int, int);
void	p9000_ras_do_cursor(struct rasops_info *);
void	p9000_ras_erasecols(void *, int, int, int, long int);
void	p9000_ras_eraserows(void *, int, int, long int);
d532 1
a532 1
void
d566 2
d570 1
a570 1
void
d602 2
d606 1
a606 1
void
d636 2
d640 1
a640 1
void
d675 2
d679 1
a679 1
void
d705 2
@


1.21
log
@Do not attach if not the console, I expect the same problems as for p9100,
but I don't know what initialization sequence is needed on the p9000...
@
text
@d1 1
a1 1
/*	$OpenBSD: p9000.c,v 1.20 2007/02/25 18:14:48 miod Exp $	*/
d197 1
a197 1
	int node, pri, row, isconsole, scr;
d258 1
a258 13
	/*
	 * If the framebuffer width is under 1024x768, we will switch from the
	 * PROM font to the more adequate 8x16 font here.
	 * However, we need to adjust two things in this case:
	 * - the display row should be overrided from the current PROM metrics,
	 *   to prevent us from overwriting the last few lines of text.
	 * - if the 80x34 screen would make a large margin appear around it,
	 *   choose to clear the screen rather than keeping old prom output in
	 *   the margins.
	 * XXX there should be a rasops "clear margins" feature
	 */
	fbwscons_init(&sc->sc_sunfb,
	    isconsole && (sc->sc_sunfb.sf_width >= 1024) ? 0 : RI_CLEAR);
d270 2
a271 8
	if (isconsole) {
		if (sc->sc_sunfb.sf_width < 1024)
			row = 0;	/* screen has been cleared above */
		else
			row = -1;

		fbwscons_console_init(&sc->sc_sunfb, row);
	}
@


1.20
log
@Disable acceleration by default; set device flags to a nonzero value to
enable.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9000.c,v 1.19 2007/02/18 18:40:35 miod Exp $	*/
d177 10
@


1.19
log
@Display the interrupt priority in dmesg, for frame buffers which register
interrupt handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9000.c,v 1.18 2006/12/02 11:24:02 miod Exp $	*/
d266 2
a267 1
	p9000_ras_init(sc);
d304 2
a305 1
			p9000_ras_init(sc);
@


1.18
log
@Use ri_devcmap to get corrected color values, instead of directly using
WSCOL_xxxx values.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9000.c,v 1.17 2006/11/29 19:08:22 miod Exp $	*/
d187 1
a187 1
	int node, row, isconsole, scr;
d191 3
d246 1
a246 2
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih, IPL_FB,
	    self->dv_xname);
@


1.17
log
@Add an unpack_attr function to struct wsdisplay_emulops, to match the
existing alloc_attr function. This allows rasops_unpack_attr to be kept
private to rasops, yet available to the screen drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9000.c,v 1.16 2006/06/02 20:00:54 miod Exp $	*/
d689 1
a689 1
	P9000_WRITE_CMD(sc, P9000_DE_FG_COLOR, WSCOL_BLACK);
@


1.16
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9000.c,v 1.15 2005/07/09 22:22:12 miod Exp $	*/
d613 1
a613 1
	rasops_unpack_attr(attr, &fg, &bg, NULL);
d645 1
a645 1
	rasops_unpack_attr(attr, &fg, &bg, NULL);
@


1.15
log
@In the interrupt handlers, clear the interrupt condition explicitely;
saves us a few unnecessary colormap updates.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9000.c,v 1.14 2005/03/23 17:16:34 miod Exp $	*/
a70 1
	struct	sbusdev sc_sd;		/* sbus device */
a264 2

	sbus_establish(&sc->sc_sd, &sc->sc_sunfb.sf_dev);
@


1.14
log
@Move the alloc_screen, free_screen and show_screen wsdisplay accessops to
the common frame buffer code, rather than duplicating it in every driver.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9000.c,v 1.13 2005/03/23 17:15:44 miod Exp $	*/
d238 4
a246 4
	/* Disable frame buffer interrupts */
	P9000_SELECT_SCR(sc);
	P9000_WRITE_CTL(sc, P9000_INTERRUPT_ENABLE, IER_MASTER_ENABLE | 0);

d468 4
@


1.13
log
@Do not set up accelerated operations if we fail to unbusy the blitter in
a reasonable amount of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9000.c,v 1.12 2005/03/07 16:44:50 miod Exp $	*/
a51 1
#include <dev/wscons/wscons_raster.h>
a77 1
	int	sc_nscreens;
d82 3
a84 5
int	p9000_alloc_screen(void *, const struct wsscreen_descr *, void **,
	    int *, int *, long *);
void	p9000_free_screen(void *, void *);
int	p9000_show_screen(void *, void *, int, void (*cb)(void *, int, int),
	    void *);
a85 3
static __inline__ void p9000_loadcmap_deferred(struct p9000_softc *,
    u_int, u_int);
void	p9000_loadcmap_immediate(struct p9000_softc *, u_int, u_int);
d93 3
a95 3
	p9000_alloc_screen,
	p9000_free_screen,
	p9000_show_screen,
d100 1
a102 1
void	p9000_ras_init(struct p9000_softc *);
d108 1
a386 37
int
p9000_alloc_screen(void *v, const struct wsscreen_descr *type, void **cookiep,
    int *curxp, int *curyp, long *attrp)
{
	struct p9000_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	sc->sc_nscreens++;
	return (0);
}

void
p9000_free_screen(void *v, void *cookie)
{
	struct p9000_softc *sc = v;

	sc->sc_nscreens--;
}

int
p9000_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
{
	return (0);
}

/*
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
 */
@


1.12
log
@Do not bother passing the blanking routine to fbwscons_console_init(),
as fbwscons_attach() can find it on its own.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9000.c,v 1.11 2005/01/05 23:04:25 miod Exp $	*/
d354 1
a354 1
			dp->curval = tadpole_get_video() & TV_ON;
d522 1
a522 1
static __inline__ void p9000_drain(struct p9000_softc *);
d524 1
a524 1
static __inline__ void
d527 9
a535 2
	while (P9000_READ_CMD(sc, P9000_PE_STATUS) &
	    (STATUS_QUAD_BUSY | STATUS_BLIT_BUSY));
d541 4
d547 4
a550 7
#if NTCTRL > 0
	if (tadpole_get_video() & TV_ACCEL) {
		sc->sc_sunfb.sf_ro.ri_ops.erasecols = p9000_ras_erasecols;
		sc->sc_sunfb.sf_ro.ri_ops.eraserows = p9000_ras_eraserows;
		sc->sc_sunfb.sf_ro.ri_do_cursor = p9000_ras_do_cursor;
	}
#endif
@


1.11
log
@Let wsdisplay drivers return zero for WSDISPLAYIO_[GS]VIDEO ioctls - most
of the work is done in the upper layer, but they get to see the ioctl,
so don't always return an error.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9000.c,v 1.10 2004/11/29 22:07:37 miod Exp $	*/
d284 1
a284 1
		fbwscons_console_init(&sc->sc_sunfb, row, p9000_burner);
@


1.10
log
@Move the struct wsscreen_descr from a per-driver global to a per-instance
field of the sunfb structure. This allows multiple instances of the same driver,
but with different resolutions (such as a couple of vigra or a TGX cgsix and
a TGX+ cgsix) to use distinct wsscreen_descr structures featuring different
resolution information.

Doing this allows more wsscreen_descr fiddling inside the sparc* fb api,
and results in some code shrinkage (about 4KB on sparc GENERIC).
@
text
@d1 1
a1 1
/*	$OpenBSD: p9000.c,v 1.9 2004/09/29 07:35:11 miod Exp $	*/
d379 2
@


1.9
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: p9000.c,v 1.8 2004/05/12 16:26:11 deraadt Exp $	*/
a82 13
struct wsscreen_descr p9000_stdscreen = {
	"std",
};

const struct wsscreen_descr *p9000_scrlist[] = {
	&p9000_stdscreen,
};

struct wsscreen_list p9000_screenlist = {
	sizeof(p9000_scrlist) / sizeof(struct wsscreen_descr *),
	    p9000_scrlist
};

a193 1
	struct wsemuldisplaydev_attach_args waa;
a272 5
	p9000_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	p9000_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	p9000_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	p9000_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

d284 1
a284 2
		fbwscons_console_init(&sc->sc_sunfb, &p9000_stdscreen, row,
		    p9000_burner);
d287 1
a287 5
	waa.console = isconsole;
	waa.scrdata = &p9000_screenlist;
	waa.accessops = &p9000_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
@


1.8
log
@if tctrl not there, still let this compile; miod ok
@
text
@d1 1
a1 1
/*	$OpenBSD: p9000.c,v 1.7 2004/05/10 09:05:52 miod Exp $	*/
d260 2
a261 1
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih, IPL_FB);
@


1.7
log
@When external power is not available, the tadpole video hardware gets
stuck in a weird mode, where not all acceleration functions are
available, and I could not figure out how to reset the chip strongly
enough to leave this mode.

Try to compensate by checking whether the external power has been removed,
when we set up the accelerated rasops (this will not cope with power being
removed after bootup, yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: p9000.c,v 1.6 2004/03/09 22:59:09 miod Exp $	*/
d557 1
d563 1
a563 1

@


1.6
log
@Real, inverted, cursor.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9000.c,v 1.5 2004/02/27 22:32:20 miod Exp $	*/
a283 5
	sc->sc_sunfb.sf_ro.ri_ops.copycols = p9000_ras_copycols;
	sc->sc_sunfb.sf_ro.ri_ops.copyrows = p9000_ras_copyrows;
	sc->sc_sunfb.sf_ro.ri_ops.erasecols = p9000_ras_erasecols;
	sc->sc_sunfb.sf_ro.ri_ops.eraserows = p9000_ras_eraserows;
	sc->sc_sunfb.sf_ro.ri_do_cursor = p9000_ras_do_cursor;
d377 1
a377 1
			dp->curval = tadpole_get_video();
d555 8
@


1.5
log
@Typos
@
text
@d1 1
a1 1
/*	$OpenBSD: p9000.c,v 1.4 2003/11/07 10:16:45 jmc Exp $	*/
d581 4
d739 2
a740 1
	    (~P9000_RASTER_DST) & P9000_RASTER_MASK);
@


1.4
log
@adress -> address, and a few more; all from Jonathon Gray;

(mvme68k/mvme88k) vs.c and (vax) if_le.c ok miod@@
isakmpd ones ok ho@@
@
text
@d1 2
a2 1
/*	$OpenBSD: p9000.c,v 1.3 2003/06/28 17:05:33 miod Exp $	*/
d561 1
a561 1
	 * Setup safe defaults for the parameter and drawing engine, in
@


1.4.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/

d283 5
d381 1
a381 1
			dp->curval = tadpole_get_video() & TV_ON;
a558 9
	sc->sc_sunfb.sf_ro.ri_ops.copycols = p9000_ras_copycols;
	sc->sc_sunfb.sf_ro.ri_ops.copyrows = p9000_ras_copyrows;
#if NTCTRL > 0
	if (tadpole_get_video() & TV_ACCEL) {
		sc->sc_sunfb.sf_ro.ri_ops.erasecols = p9000_ras_erasecols;
		sc->sc_sunfb.sf_ro.ri_ops.eraserows = p9000_ras_eraserows;
		sc->sc_sunfb.sf_ro.ri_do_cursor = p9000_ras_do_cursor;
	}
#endif
d560 1
a560 1
	 * Setup safe defaults for the parameter and drawing engines, in
a579 4
	P9000_WRITE_CMD(sc, P9000_PE_INDEX, 0);
	P9000_WRITE_CMD(sc, P9000_PE_WINMIN, 0);
	P9000_WRITE_CMD(sc, P9000_PE_WINMAX,
	    P9000_COORDS(sc->sc_sunfb.sf_width - 1, sc->sc_sunfb.sf_height - 1));
d734 1
a734 2
	    (P9000_RASTER_PATTERN ^ P9000_RASTER_DST) & P9000_RASTER_MASK);
	P9000_WRITE_CMD(sc, P9000_DE_FG_COLOR, WSCOL_BLACK);
@


1.3
log
@Sync sparc fb API with the sparc64 changes (fbwscons_init takes flags, and
the sunfb structure keeps pointer to the prom cursor coordinates).
@
text
@d1 1
a1 1
/*	$OpenBSD: p9000.c,v 1.2 2003/06/18 17:40:32 miod Exp $	*/
d167 1
a167 1
 * when writing to an adress which upper 25 bit differ from the previous
@


1.2
log
@Rename p9k to pninek, since device base names with digits are confusing;
per deraadt@@'s request.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9000.c,v 1.1 2003/06/17 21:21:32 miod Exp $	*/
d277 1
a277 1
	    isconsole && (sc->sc_sunfb.sf_width >= 1024));
@


1.1
log
@New driver and wsdisplay type for the Weitek Power9000 and Brooktree Bt445
combination, found on the Tadpole SPARCbook 3 only (later model use the
Power9100 and are already supported).

Untested for lack of hardware and volunteers, but carefully crafted; if it
does not work out of the box, this should be a good starting point.

"worth having in the tree" millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d131 1
a131 1
struct cfattach p9k_ca = {
d135 2
a136 2
struct cfdriver p9k_cd = {
	NULL, "p9k", DV_DULL
@

