head	1.30;
access;
symbols
	OPENBSD_6_0:1.30.0.12
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.8
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.30.0.10
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.30.0.6
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.29.0.14
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.12
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.10
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.8
	OPENBSD_5_0:1.29.0.6
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.4
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.28.0.4
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.6
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.2
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.27.0.8
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.27.0.6
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.4
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.25.0.4
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.24.0.2
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.21.0.6
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.21
	SMP_SYNC_B:1.21
	OPENBSD_3_5:1.21.0.4
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.16
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.12
	OPENBSD_2_8:1.9.0.10
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.8
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.6
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.6
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.4
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7;
locks; strict;
comment	@ * @;


1.30
date	2013.10.20.20.07.25;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2010.06.07.19.43.45;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2008.12.26.22.30.21;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2006.12.03.16.38.12;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2006.07.25.21.23.30;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2005.03.23.17.16.34;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2005.03.07.16.44.50;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2005.01.05.23.04.24;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2004.11.29.22.07.36;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.28.17.05.33;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.04.04.11.37;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.02.23.27.53;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.05.12.20.18.39;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	2002.11.06.21.06.20;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.23.18.13.38;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.09.22.15.16;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.12.10.44.03;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.42;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.11.01.12.13.46;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.17.13.52.28;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	98.11.20.15.57.21;	author deraadt;	state Exp;
branches
	1.9.6.1;
next	1.8;

1.8
date	97.08.08.08.24.46;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	96.08.13.08.05.21;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.08.11.05.34.09;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	95.12.18.17.02.25;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.12.15.13.56.17;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.11.09.21.34.45;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.22.11.29.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.14.27.37;	author deraadt;	state Exp;
branches;
next	;

1.9.6.1
date	2001.10.31.03.07.56;	author nate;	state Exp;
branches;
next	1.9.6.2;

1.9.6.2
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.9.6.3;

1.9.6.3
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.9.6.4;

1.9.6.4
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.9.6.5;

1.9.6.5
date	2003.05.16.00.29.40;	author niklas;	state Exp;
branches;
next	1.9.6.6;

1.9.6.6
date	2003.06.07.11.14.42;	author ho;	state Exp;
branches;
next	1.9.6.7;

1.9.6.7
date	2004.02.19.10.49.57;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2002.06.11.03.38.15;	author art;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.10.29.00.28.09;	author art;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@/*	$OpenBSD: cgfour.c,v 1.29 2010/06/07 19:43:45 miod Exp $	*/
/*	$NetBSD: cgfour.c,v 1.13 1997/05/24 20:16:06 pk Exp $	*/

/*
 * Coyrpight (c) 2002 Miodrag Vallat.  All rights reserved.
 * Copyright (c) 1996 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1995 Theo de Raadt.  All rights reserved.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from @@(#)cgthree.c	8.2 (Berkeley) 10/30/93
 */

/*
 * color display (cgfour) driver.
 *
 * Does not handle interrupts, even though they can occur.
 *
 * XXX should defer colormap updates to vertical retrace interrupts
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/mman.h>
#include <sys/tty.h>
#include <sys/conf.h>

#include <uvm/uvm_extern.h>		/* NBPG */

#include <machine/autoconf.h>
#include <machine/pmap.h>
#include <machine/eeprom.h>
#include <machine/conf.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

#include <sparc/dev/btreg.h>
#include <sparc/dev/btvar.h>
#include <sparc/dev/pfourreg.h>

/* per-display variables */
struct cgfour_softc {
	struct	sunfb sc_sunfb;		/* common base part */
	struct rom_reg	sc_phys;	/* display RAM (phys addr) */
	volatile struct fbcontrol *sc_fbc;	/* Brooktree registers */
	union	bt_cmap sc_cmap;	/* Brooktree color map */
};

int	cgfour_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	cgfour_mmap(void *, off_t, int);
void	cgfour_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);

struct wsdisplay_accessops cgfour_accessops = {
	.ioctl = cgfour_ioctl,
	.mmap = cgfour_mmap,
	.burn_screen = fb_pfour_burner
};

void	cgfourattach(struct device *, struct device *, void *);
int	cgfourmatch(struct device *, void *, void *);

struct cfattach cgfour_ca = {
	sizeof(struct cgfour_softc), cgfourmatch, cgfourattach
};

struct cfdriver cgfour_cd = {
	NULL, "cgfour", DV_DULL
};

int
cgfourmatch(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
		return (0);

	if (!CPU_ISSUN4 || ca->ca_bustype != BUS_OBIO)
		return (0);

	if (probeget(ra->ra_vaddr, 4) == -1)
		return (0);

	/*
	 * Check the pfour register.
	 */
	if (fb_pfour_id(ra->ra_vaddr) == PFOUR_ID_COLOR8P1)
		return (1);

	return (0);
}

void
cgfourattach(struct device *parent, struct device *self, void *args)
{
	struct cgfour_softc *sc = (struct cgfour_softc *)self;
	struct confargs *ca = args;
	int node = 0;
	volatile struct bt_regs *bt;
	int isconsole = 0;

	printf(": p4");

	/* Map the pfour register. */
	SET(sc->sc_sunfb.sf_flags, FB_PFOUR);
	sc->sc_sunfb.sf_pfour = (volatile u_int32_t *)
		mapiodev(ca->ca_ra.ra_reg, 0, sizeof(u_int32_t));

	if (cputyp == CPU_SUN4) {
		struct eeprom *eep = (struct eeprom *)eeprom_va;

		/*
		 * Assume this is the console if there's no eeprom info
		 * to be found.
		 */
		if (eep == NULL || eep->ee_diag.eed_console == EED_CONS_P4)
			isconsole = 1;
	}

	/*
	 * When the ROM has mapped in a cgfour display, the address
	 * maps only the video RAM, so in any case we have to map the
	 * registers ourselves.  We only need the video RAM if we are
	 * going to print characters via rconsole.
	 */

	sc->sc_phys = ca->ca_ra.ra_reg[0];

	/* enable video */
	fb_pfour_burner(sc, 1, 0);
	bt = &sc->sc_fbc->fbc_dac;
	BT_INIT(bt, 24);

	/*
	 * XXX should initialize the enable plane, instead of expecting the
	 * PROM to do so for us
	 */

	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, ca->ca_bustype);
	/*
	 * XXX this only maps the color plane, not the overlay or the enable
	 * planes
	 */
	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(ca->ca_ra.ra_reg,
	    PFOUR_COLOR_OFF_COLOR, round_page(sc->sc_sunfb.sf_fbsize));
	sc->sc_sunfb.sf_ro.ri_hw = sc;

	printf(", %dx%d\n", sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);

	fbwscons_init(&sc->sc_sunfb, isconsole);
	fbwscons_setcolormap(&sc->sc_sunfb, cgfour_setcolor);
	if (isconsole)
		fbwscons_console_init(&sc->sc_sunfb, -1);

	fbwscons_attach(&sc->sc_sunfb, &cgfour_accessops, isconsole);
}

int
cgfour_ioctl(void *v, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct cgfour_softc *sc = v;
	struct wsdisplay_fbinfo *wdf;
	struct wsdisplay_cmap *cm;
	int error;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG4;
		break;
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
		wdf->cmsize = 256;
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
		break;

	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_getcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		break;

	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		bt_loadcmap(&sc->sc_cmap, &sc->sc_fbc->fbc_dac,
		    cm->index, cm->count, 1);
		break;

	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
		break;

	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
	default:
		return (-1);	/* not supported yet */
        }

	return (0);
}

paddr_t
cgfour_mmap(void *v, off_t offset, int prot)
{
	struct cgfour_softc *sc = v;

	if (offset & PGOFSET)
		return (-1);

	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys,
		    PFOUR_COLOR_OFF_COLOR + offset) | PMAP_NC);
	}

	return (-1);
}

void
cgfour_setcolor(void *v, u_int index, u_int8_t r, u_int8_t g, u_int8_t b)
{
	struct cgfour_softc *sc = v;

	bt_setcolor(&sc->sc_cmap, &sc->sc_fbc->fbc_dac, index, r, g, b, 1);
}
@


1.29
log
@Nuke old eeprom.h compatibility defines; ok todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.28 2008/12/26 22:30:21 miod Exp $	*/
d94 3
a96 10
	cgfour_ioctl,
	cgfour_mmap,
	NULL,	/* alloc_screen */
	NULL,	/* free_screen */
	NULL,	/* show_screen */
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	fb_pfour_burner,
	NULL	/* pollc */
@


1.28
log
@Move the logic responsible from deciding whether a frame buffer needs to be
cleared on attach, from the individual drivers to the common frame buffer code;
the latter will decide based on the prom font metrics and the prom console
window position, whenever possible.

This removes the need for the console window position to be hardcoded in
the p9100 driver, and will no longer require a screen clear on a vigra
VS-12 in high resolution mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.27 2006/12/03 16:38:12 miod Exp $	*/
d165 1
a165 1
		if (eep == NULL || eep->eeConsole == EE_CONS_P4OPT)
@


1.27
log
@Clean frame buffer attachment code:
- There is no need to check for buses config(8) will not let us attach to
- Better P4 bus logic, which does not need to abuse device flags
- Do not bother trying to print a meaningful device description when it is
  not connected to sbus.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.26 2006/07/25 21:23:30 miod Exp $	*/
a195 2
	fbwscons_init(&sc->sc_sunfb, isconsole ? 0 : RI_CLEAR);
	fbwscons_setcolormap(&sc->sc_sunfb, cgfour_setcolor);
d199 3
a201 1
	if (isconsole) {
a202 1
	}
@


1.26
log
@Do not bother reading the existing colormap on attach, since we will
override it with the rasops one.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.25 2005/03/23 17:16:34 miod Exp $	*/
a123 5
	/*
	 * Mask out invalid flags from the user.
	 */
	cf->cf_flags &= FB_USERMASK;

d136 1
a136 2
	if (fb_pfour_id(ra->ra_vaddr) == PFOUR_ID_COLOR8P1) {
		cf->cf_flags |= FB_PFOUR;
a137 1
	}
d151 1
a151 1
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;
d153 4
a156 1
	printf(": cgfour/p4");
d158 1
a158 1
	if (CPU_ISSUN4) {
a167 4

	/* Map the pfour register. */
	sc->sc_sunfb.sf_pfour = (volatile u_int32_t *)
		mapiodev(ca->ca_ra.ra_reg, 0, sizeof(u_int32_t));
@


1.25
log
@Move the alloc_screen, free_screen and show_screen wsdisplay accessops to
the common frame buffer code, rather than duplicating it in every driver.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.24 2005/03/07 16:44:50 miod Exp $	*/
d154 1
a154 1
	int node = 0, i;
a185 6
	/* grab initial (current) color map */
	bt = &sc->sc_fbc->fbc_dac;
	bt->bt_addr = 0;
	for (i = 0; i < 256 * 3 / 4; i++)
		((char *)&sc->sc_cmap)[i] = bt->bt_cmap >> 24;

d188 1
@


1.24
log
@Do not bother passing the blanking routine to fbwscons_console_init(),
as fbwscons_attach() can find it on its own.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.23 2005/01/05 23:04:24 miod Exp $	*/
a73 1
#include <dev/wscons/wscons_raster.h>
a86 1
	int	sc_nscreens;
d89 3
a91 9
int cgfour_ioctl(void *, u_long, caddr_t, int, struct proc *);
int cgfour_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgfour_free_screen(void *, void *);
int cgfour_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t cgfour_mmap(void *, off_t, int);
void cgfour_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
void cgfour_burner(void *, u_int, u_int);
d96 3
a98 3
	cgfour_alloc_screen,
	cgfour_free_screen,
	cgfour_show_screen,
d102 2
a103 1
	cgfour_burner,
a116 3
/*
 * Match a cgfour.
 */
d118 1
a118 3
cgfourmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
a148 3
/*
 * Attach a display.
 */
d150 1
a150 3
cgfourattach(parent, self, args)
	struct device *parent, *self;
	void *args;
d193 1
a193 1
	cgfour_burner(sc, 1, 0);
d222 1
a222 6
cgfour_ioctl(v, cmd, data, flags, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
a275 48
int
cgfour_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
{
	struct cgfour_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	sc->sc_nscreens++;
	return (0);
}

void
cgfour_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct cgfour_softc *sc = v;

	sc->sc_nscreens--;
}

int
cgfour_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
	return (0);
}


/*
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
 */
d277 1
a277 4
cgfour_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
d293 1
a293 4
cgfour_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
	u_int8_t r, g, b;
a297 10
}

void
cgfour_burner(v, on, flags)
	void *v;
	u_int on, flags;
{
	struct cgfour_softc *sc = v;

	fb_pfour_set_video(&sc->sc_sunfb, on);
@


1.23
log
@Let wsdisplay drivers return zero for WSDISPLAYIO_[GS]VIDEO ioctls - most
of the work is done in the upper layer, but they get to see the ioctl,
so don't always return an error.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.22 2004/11/29 22:07:36 miod Exp $	*/
d232 1
a232 1
		fbwscons_console_init(&sc->sc_sunfb, -1, cgfour_burner);
@


1.22
log
@Move the struct wsscreen_descr from a per-driver global to a per-instance
field of the sunfb structure. This allows multiple instances of the same driver,
but with different resolutions (such as a couple of vigra or a TGX cgsix and
a TGX+ cgsix) to use distinct wsscreen_descr structures featuring different
resolution information.

Doing this allows more wsscreen_descr fiddling inside the sparc* fb api,
and results in some code shrinkage (about 4KB on sparc GENERIC).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.21 2003/06/28 17:05:33 miod Exp $	*/
d284 2
@


1.21
log
@Sync sparc fb API with the sparc64 changes (fbwscons_init takes flags, and
the sunfb structure keeps pointer to the prom cursor coordinates).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.20 2003/06/04 04:11:37 deraadt Exp $	*/
a90 13
struct wsscreen_descr cgfour_stdscreen = {
	"std",
};

const struct wsscreen_descr *cgfour_scrlist[] = {
	&cgfour_stdscreen,
};

struct wsscreen_list cgfour_screenlist = {
	sizeof(cgfour_scrlist) / sizeof(struct wsscreen_descr *),
	    cgfour_scrlist
};

a170 1
	struct wsemuldisplaydev_attach_args waa;
a228 5
	cgfour_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgfour_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgfour_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgfour_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

d232 1
a232 2
		fbwscons_console_init(&sc->sc_sunfb, &cgfour_stdscreen, -1,
		    cgfour_burner);
d235 1
a235 5
	waa.console = isconsole;
	waa.scrdata = &cgfour_screenlist;
	waa.accessops = &cgfour_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
@


1.20
log
@more term 3 and 4 changes
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.19 2003/06/02 23:27:53 millert Exp $	*/
d240 1
a240 1
	fbwscons_init(&sc->sc_sunfb, isconsole);
@


1.19
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.18 2003/05/12 20:18:39 jason Exp $	*/
a9 4
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by Theo de Raadt.
@


1.18
log
@use new display types; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.17 2002/11/06 21:06:20 miod Exp $	*/
d32 1
a32 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.17
log
@- always initialize colormaps, even if the frame buffer is non console; this
  helps if the ramdac does not get initialized (idea from jason@@)
- only register a shutdown hook for the frame buffers which need it, if this
  is the console frame buffer. Otherwise this is just a waste of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.16 2002/09/23 18:13:38 miod Exp $	*/
d285 1
a285 1
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
@


1.16
log
@Get the wsdisplay capabilities from rasops, rather than attempting to
guess them at compile-time. Plus this makes cgtwelve a bit more clean.

ok fgs@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.15 2002/09/09 22:15:16 miod Exp $	*/
d249 1
d260 1
a260 1
		    cgfour_setcolor, cgfour_burner);
@


1.15
log
@Register more screen capabilities to work with the recent wsemul_sun changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.14 2002/08/12 10:44:03 miod Exp $	*/
a100 5
	0, 0,	/* will be filled in */
	0,
	0, 0,
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
	WSSCREEN_REVERSE | WSSCREEN_WSCOLORS
d250 1
@


1.14
log
@Convert sparc console code from rcons and pseudo-devices to rasops and wscons.
For most framebuffers it is faster.

Other changes include:
o 24 bit support in tcx(4) for the S24 framebuffer
o accelerated cgsix(4) text console
o new cgtwelve(4) driver for the GS framebuffer
o improved serial driver code
o better keyboard support

The following framebuffers have not been tested but should work: cgfour,
cgeight and cgfourteen

These changes will require XF4 changes, to use Xwsfb instead of Xsun*, to be
commited later today.

Most of the work by me during the LSM and the week after, with code borrowed
from jason@@, NetBSD (new serial code), and feedback from mickey@@. Work on
pnozz(4) done by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.13 2002/03/14 01:26:42 millert Exp $	*/
d104 1
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.12 2001/11/06 19:53:16 miod Exp $	*/
d5 1
d73 1
a73 1
#include <uvm/uvm_extern.h>
a74 1
#include <machine/fbio.h>
a76 1
#include <machine/fbvar.h>
d80 6
d92 1
a92 2
	struct	device sc_dev;		/* base device */
	struct	fbdevice sc_fb;		/* frame buffer device */
a94 1
	int	sc_bustype;		/* type of bus we live on */
d96 13
d111 29
a139 6
/* autoconfiguration driver */
static void	cgfourattach(struct device *, struct device *, void *);
static int	cgfourmatch(struct device *, void *, void *);
#if defined(SUN4)
static void	cgfourunblank(struct device *);
#endif
a148 14
#if defined(SUN4)
/* frame buffer generic driver */
static struct fbdriver cgfourfbdriver = {
	cgfourunblank, cgfouropen, cgfourclose, cgfourioctl, cgfourmmap
};

extern int fbnode;
extern struct tty *fbconstty;

static void cgfourloadcmap(struct cgfour_softc *, int, int);
static int cgfour_get_video(struct cgfour_softc *);
static void cgfour_set_video(struct cgfour_softc *, int);
#endif

a160 3
	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
		return (0);

d166 1
a166 4
	/*
	 * Only exists on a sun4.
	 */
	if (!CPU_ISSUN4)
d169 1
a169 4
	/*
	 * Only exists on obio.
	 */
	if (ca->ca_bustype != BUS_OBIO)
a171 3
	/*
	 * Make sure there's hardware there.
	 */
a174 1
#if defined(SUN4)
a181 1
#endif
d187 1
a187 1
 * Attach a display.  We need to notice if it is the console, too.
d194 6
a199 25
#if defined(SUN4)
	register struct cgfour_softc *sc = (struct cgfour_softc *)self;
	register struct confargs *ca = args;
	register int node = 0, ramsize, i;
	register volatile struct bt_regs *bt;
	struct fbdevice *fb = &sc->sc_fb;
	int isconsole;

	fb->fb_driver = &cgfourfbdriver;
	fb->fb_device = &sc->sc_dev;
	fb->fb_type.fb_type = FBTYPE_SUN4COLOR;
	fb->fb_flags = sc->sc_dev.dv_cfdata->cf_flags;

	/*
	 * Only pfour cgfours, thank you...
	 */
	if ((ca->ca_bustype != BUS_OBIO) ||
	    ((fb->fb_flags & FB_PFOUR) == 0)) {
		printf("%s: ignoring; not a pfour\n", sc->sc_dev.dv_xname);
		return;
	}

	/* Map the pfour register. */
	fb->fb_pfour = (volatile u_int32_t *)
		mapiodev(ca->ca_ra.ra_reg, 0, sizeof(u_int32_t));
d201 1
a201 1
	ramsize = PFOUR_COLOR_OFF_END - PFOUR_COLOR_OFF_OVERLAY;
d203 1
a203 9
	fb->fb_type.fb_depth = 8;
	fb_setsize(fb, fb->fb_type.fb_depth, 1152, 900, node, ca->ca_bustype);

	fb->fb_type.fb_cmsize = 256;
	fb->fb_type.fb_size = ramsize;
	printf(": cgfour/p4, %d x %d", fb->fb_type.fb_width,
	    fb->fb_type.fb_height);

	isconsole = 0;
d213 1
a213 1
			isconsole = (fbconstty != NULL);
d216 3
a218 8
#if 0
	/*
	 * We don't do any of the console handling here.  Instead,
	 * we let the bwtwo driver pick up the overlay plane and
	 * use it instead.  Rconsole should have better performance
	 * with the 1-bit depth.
	 *	-- Jason R. Thorpe <thorpej@@NetBSD.ORG>
	 */
a226 12
	if (isconsole) {
		/* XXX this is kind of a waste */
		fb->fb_pixels = mapiodev(ca->ca_ra.ra_reg,
					 PFOUR_COLOR_OFF_OVERLAY, ramsize);
	}
#endif

	/* Map the Brooktree. */
	sc->sc_fbc = (volatile struct fbcontrol *)
		mapiodev(ca->ca_ra.ra_reg,
			 PFOUR_COLOR_OFF_CMAP, sizeof(struct fbcontrol));

a227 1
	sc->sc_bustype = ca->ca_bustype;
d235 2
d239 4
a242 9
#if 0	/* See above. */
	if (isconsole) {
		printf(" (console)\n");
#if defined(RASTERCONSOLE) && 0	/* XXX been told it doesn't work well. */
		fbrcons_init(fb);
#endif
	} else
#endif /* 0 */
		printf("\n");
d244 1
d246 2
a247 2
	 * Even though we're not using rconsole, we'd still like
	 * to notice if we're the console framebuffer.
d249 8
a256 3
	fb_attach(fb, isconsole);
#endif
}
d258 1
a258 7
int
cgfouropen(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	int unit = minor(dev);
d260 4
a263 4
	if (unit >= cgfour_cd.cd_ndevs || cgfour_cd.cd_devs[unit] == NULL)
		return (ENXIO);
	return (0);
}
d265 5
a269 8
int
cgfourclose(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{

	return (0);
d273 2
a274 2
cgfourioctl(dev, cmd, data, flags, p)
	dev_t dev;
d276 1
a276 1
	register caddr_t data;
d280 3
a282 3
#if defined(SUN4)
	register struct cgfour_softc *sc = cgfour_cd.cd_devs[minor(dev)];
	register struct fbgattr *fba;
d286 9
a294 3

	case FBIOGTYPE:
		*(struct fbtype *)data = sc->sc_fb.fb_type;
d296 2
a297 11

	case FBIOGATTR:
		fba = (struct fbgattr *)data;
		fba->real_type = sc->sc_fb.fb_type.fb_type;
		fba->owner = 0;		/* XXX ??? */
		fba->fbtype = sc->sc_fb.fb_type;
		fba->sattr.flags = 0;
		fba->sattr.emu_type = sc->sc_fb.fb_type.fb_type;
		fba->sattr.dev_specific[0] = -1;
		fba->emu_types[0] = sc->sc_fb.fb_type.fb_type;
		fba->emu_types[1] = -1;
d300 3
a302 7
	case FBIOGETCMAP:
		return (bt_getcmap((struct fbcmap *)data, &sc->sc_cmap, 256));

	case FBIOPUTCMAP:
		/* copy to software map */
#define p ((struct fbcmap *)data)
		error = bt_putcmap(p, &sc->sc_cmap, 256);
a304 4
		/* now blast them into the chip */
		/* XXX should use retrace interrupt */
		cgfourloadcmap(sc, p->index, p->count);
#undef p
d307 7
a313 2
	case FBIOGVIDEO:
		*(int *)data = cgfour_get_video(sc);
d316 10
a325 3
	case FBIOSVIDEO:
		cgfour_set_video(sc, *(int *)data);
		break;
a326 4
	default:
		return (ENOTTY);
	}
#endif
d330 7
a336 16
/*
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
 *
 * the cg4 maps it's overlay plane for 128K, followed by the enable
 * plane for 128K, followed by the colour plane (for as much colour
 * as their is.)
 *
 * As well, mapping at an offset of 0x04000000 causes the cg4 to map
 * only it's colour plane, at 0.
 */
paddr_t
cgfourmmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
d338 1
a338 2
	register struct cgfour_softc *sc = cgfour_cd.cd_devs[minor(dev)];
	int poff;
d340 2
a341 6
#define START_ENABLE	(128*1024)
#define START_COLOR	((128*1024) + (128*1024))
#define COLOR_SIZE	(sc->sc_fb.fb_type.fb_width * \
			    sc->sc_fb.fb_type.fb_height)
#define END_COLOR	(START_COLOR + COLOR_SIZE)
#define NOOVERLAY	(0x04000000)
d343 8
a350 2
	if (off & PGOFSET)
		panic("cgfourmap");
d352 6
a357 4
	if (off < 0)
		return (-1);
	if ((u_int)off >= NOOVERLAY) {
		off -= NOOVERLAY;
d359 2
a360 7
		/*
		 * X11 maps a huge chunk of the frame buffer; far more than
		 * there really is. We compensate by double-mapping the
		 * first page for as many other pages as it wants
		 */
		while ((u_int)off >= COLOR_SIZE)
			off -= COLOR_SIZE;	/* XXX thorpej ??? */
d362 10
a371 18
		poff = off + PFOUR_COLOR_OFF_COLOR;
	} else if ((u_int)off < START_ENABLE) {
		/*
		 * in overlay plane
		 */
		poff = PFOUR_COLOR_OFF_OVERLAY + off;
	} else if ((u_int)off < START_COLOR) {
		/*
		 * in enable plane
		 */
		poff = (off - START_ENABLE) + PFOUR_COLOR_OFF_ENABLE;
	} else if ((u_int)off < sc->sc_fb.fb_type.fb_size) {
		/*
		 * in colour plane
		 */
		poff = (off - START_COLOR) + PFOUR_COLOR_OFF_COLOR;
	} else
		return (-1);
a372 2
	return (REG2PHYS(&sc->sc_phys, poff) | PMAP_NC);
}
a373 1
#if defined(SUN4)
d375 2
a376 1
 * Undo the effect of an FBIOSVIDEO that turns the video off.
d378 5
a382 3
static void
cgfourunblank(dev)
	struct device *dev;
d384 1
d386 2
a387 2
	cgfour_set_video((struct cgfour_softc *)dev, 1);
}
d389 4
a392 4
static int
cgfour_get_video(sc)
	struct cgfour_softc *sc;
{
d394 1
a394 1
	return (fb_pfour_get_video(&sc->sc_fb));
d397 5
a401 4
static void
cgfour_set_video(sc, enable)
	struct cgfour_softc *sc;
	int enable;
d403 1
d405 1
a405 1
	fb_pfour_set_video(&sc->sc_fb, enable);
d408 4
a411 7
/*
 * Load a subset of the current (new) colormap into the Brooktree DAC.
 */
static void
cgfourloadcmap(sc, start, ncolors)
	register struct cgfour_softc *sc;
	register int start, ncolors;
d413 1
a413 3
	register volatile struct bt_regs *bt;
	register u_int *ip, i;
	register int count;
d415 1
a415 12
	ip = &sc->sc_cmap.cm_chip[BT_D4M3(start)];	/* start/4 * 3 */
	count = BT_D4M3(start + ncolors - 1) - BT_D4M3(start) + 3;
	bt = &sc->sc_fbc->fbc_dac;
	bt->bt_addr = BT_D4M4(start) << 24;
	while (--count >= 0) {
		i = *ip++;
		/* hardware that makes one want to pound boards with hammers */
		bt->bt_cmap = i;
		bt->bt_cmap = i << 8;
		bt->bt_cmap = i << 16;
		bt->bt_cmap = i << 24;
	}
a416 1
#endif
@


1.12
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.11 2001/11/01 12:13:46 art Exp $	*/
d96 2
a97 2
static void	cgfourattach __P((struct device *, struct device *, void *));
static int	cgfourmatch __P((struct device *, void *, void *));
d99 1
a99 1
static void	cgfourunblank __P((struct device *));
d119 3
a121 3
static void cgfourloadcmap __P((struct cgfour_softc *, int, int));
static int cgfour_get_video __P((struct cgfour_softc *));
static void cgfour_set_video __P((struct cgfour_softc *, int));
@


1.12.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.12 2001/11/06 19:53:16 miod Exp $	*/
d96 2
a97 2
static void	cgfourattach(struct device *, struct device *, void *);
static int	cgfourmatch(struct device *, void *, void *);
d99 1
a99 1
static void	cgfourunblank(struct device *);
d119 3
a121 3
static void cgfourloadcmap(struct cgfour_softc *, int, int);
static int cgfour_get_video(struct cgfour_softc *);
static void cgfour_set_video(struct cgfour_softc *, int);
@


1.12.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.12.2.1 2002/06/11 03:38:15 art Exp $	*/
a4 1
 * Coyrpight (c) 2002 Miodrag Vallat.  All rights reserved.
d72 1
a72 1
#include <uvm/uvm_extern.h>		/* NBPG */
d74 1
d77 1
a80 6
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

d87 2
a88 1
	struct	sunfb sc_sunfb;		/* common base part */
d91 1
a92 1
	int	sc_nscreens;
d95 6
a100 3
struct wsscreen_descr cgfour_stdscreen = {
	"std",
};
d102 2
a103 2
const struct wsscreen_descr *cgfour_scrlist[] = {
	&cgfour_stdscreen,
d106 2
a107 3
struct wsscreen_list cgfour_screenlist = {
	sizeof(cgfour_scrlist) / sizeof(struct wsscreen_descr *),
	    cgfour_scrlist
d110 4
a113 20
int cgfour_ioctl(void *, u_long, caddr_t, int, struct proc *);
int cgfour_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgfour_free_screen(void *, void *);
int cgfour_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t cgfour_mmap(void *, off_t, int);
void cgfour_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
void cgfour_burner(void *, u_int, u_int);

struct wsdisplay_accessops cgfour_accessops = {
	cgfour_ioctl,
	cgfour_mmap,
	cgfour_alloc_screen,
	cgfour_free_screen,
	cgfour_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	cgfour_burner,
d116 2
a117 2
void	cgfourattach(struct device *, struct device *, void *);
int	cgfourmatch(struct device *, void *, void *);
d119 4
a122 7
struct cfattach cgfour_ca = {
	sizeof(struct cgfour_softc), cgfourmatch, cgfourattach
};

struct cfdriver cgfour_cd = {
	NULL, "cgfour", DV_DULL
};
d136 3
d144 4
a147 1
	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
d150 4
a153 1
	if (!CPU_ISSUN4 || ca->ca_bustype != BUS_OBIO)
d156 3
d162 1
d170 1
d176 1
a176 1
 * Attach a display.
d183 25
a207 6
	struct cgfour_softc *sc = (struct cgfour_softc *)self;
	struct confargs *ca = args;
	struct wsemuldisplaydev_attach_args waa;
	int node = 0, i;
	volatile struct bt_regs *bt;
	int isconsole = 0;
d209 1
a209 1
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;
d211 9
a219 1
	printf(": cgfour/p4");
d229 1
a229 1
			isconsole = 1;
d232 8
a239 3
	/* Map the pfour register. */
	sc->sc_sunfb.sf_pfour = (volatile u_int32_t *)
		mapiodev(ca->ca_ra.ra_reg, 0, sizeof(u_int32_t));
d248 12
d261 1
a268 2
	/* enable video */
	cgfour_burner(sc, 1, 0);
d271 10
d282 2
a283 2
	 * XXX should initialize the enable plane, instead of expecting the
	 * PROM to do so for us
d285 3
d289 7
a295 14
	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, ca->ca_bustype);
	/*
	 * XXX this only maps the color plane, not the overlay or the enable
	 * planes
	 */
	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(ca->ca_ra.ra_reg,
	    PFOUR_COLOR_OFF_COLOR, round_page(sc->sc_sunfb.sf_fbsize));
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, isconsole);

	cgfour_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgfour_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgfour_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgfour_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;
d297 4
a300 1
	printf(", %dx%d\n", sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);
d302 6
a307 4
	if (isconsole) {
		fbwscons_console_init(&sc->sc_sunfb, &cgfour_stdscreen, -1,
		    cgfour_setcolor, cgfour_burner);
	}
d309 1
a309 5
	waa.console = isconsole;
	waa.scrdata = &cgfour_screenlist;
	waa.accessops = &cgfour_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
d313 2
a314 2
cgfour_ioctl(v, cmd, data, flags, p)
	void *v;
d316 1
a316 1
	caddr_t data;
d320 3
a322 3
	struct cgfour_softc *sc = v;
	struct wsdisplay_fbinfo *wdf;
	struct wsdisplay_cmap *cm;
d326 3
a328 2
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
d330 11
a340 9
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
		wdf->cmsize = 256;
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
d343 7
a349 3
	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_getcmap(&sc->sc_cmap, cm);
d352 8
d362 2
a363 7
	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		bt_loadcmap(&sc->sc_cmap, &sc->sc_fbc->fbc_dac,
		    cm->index, cm->count, 1);
a365 7
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
d367 3
a369 3
		return (-1);	/* not supported yet */
        }

d373 16
a388 7
int
cgfour_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
d390 2
a391 1
	struct cgfour_softc *sc = v;
d393 6
a398 2
	if (sc->sc_nscreens > 0)
		return (ENOMEM);
d400 7
a406 8
	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	sc->sc_nscreens++;
	return (0);
}
d408 7
a414 6
void
cgfour_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct cgfour_softc *sc = v;
d416 18
a433 2
	sc->sc_nscreens--;
}
d435 1
a435 9
int
cgfour_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
	return (0);
d438 1
a438 1

d440 1
a440 2
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
d442 3
a444 5
paddr_t
cgfour_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
a445 1
	struct cgfour_softc *sc = v;
d447 2
a448 2
	if (offset & PGOFSET)
		return (-1);
d450 4
a453 4
	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys,
		    PFOUR_COLOR_OFF_COLOR + offset) | PMAP_NC);
	}
d455 1
a455 1
	return (-1);
d458 4
a461 5
void
cgfour_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
	u_int8_t r, g, b;
a462 1
	struct cgfour_softc *sc = v;
d464 1
a464 1
	bt_setcolor(&sc->sc_cmap, &sc->sc_fbc->fbc_dac, index, r, g, b, 1);
d467 7
a473 4
void
cgfour_burner(v, on, flags)
	void *v;
	u_int on, flags;
d475 3
a477 1
	struct cgfour_softc *sc = v;
d479 12
a490 1
	fb_pfour_set_video(&sc->sc_sunfb, on);
d492 1
@


1.12.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a248 1
	fbwscons_setcolormap(&sc->sc_sunfb, cgfour_setcolor);
d259 1
a259 1
		    cgfour_burner);
d284 1
a284 1
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG4;
@


1.11
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.10 2001/08/17 13:52:28 mickey Exp $	*/
d72 1
a72 1
#include <vm/vm.h>
@


1.10
log
@cdev_decl cleanup; jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.9 1998/11/20 15:57:21 deraadt Exp $	*/
d384 1
a384 1
int
d387 2
a388 1
	int off, prot;
@


1.9
log
@careful off handling in mmap routines
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.8 1997/08/08 08:24:46 downsj Exp $	*/
a100 3

/* cdevsw prototypes */
cdev_decl(cgfour);
@


1.9.6.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.9 1998/11/20 15:57:21 deraadt Exp $	*/
d101 3
@


1.9.6.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d72 1
a72 1
#include <uvm/uvm_extern.h>
d384 1
a384 1
paddr_t
d387 1
a387 2
	off_t off;
	int prot;
@


1.9.6.3
log
@Merge in -current from about a week ago
@
text
@d96 2
a97 2
static void	cgfourattach(struct device *, struct device *, void *);
static int	cgfourmatch(struct device *, void *, void *);
d99 1
a99 1
static void	cgfourunblank(struct device *);
d119 3
a121 3
static void cgfourloadcmap(struct cgfour_softc *, int, int);
static int cgfour_get_video(struct cgfour_softc *);
static void cgfour_set_video(struct cgfour_softc *, int);
@


1.9.6.4
log
@Sync the SMP branch with 3.3
@
text
@a4 1
 * Coyrpight (c) 2002 Miodrag Vallat.  All rights reserved.
d72 1
a72 1
#include <uvm/uvm_extern.h>		/* NBPG */
d74 1
d77 1
a80 6
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

d87 2
a88 1
	struct	sunfb sc_sunfb;		/* common base part */
d91 1
a92 1
	int	sc_nscreens;
d95 6
a100 3
struct wsscreen_descr cgfour_stdscreen = {
	"std",
};
d102 2
a103 2
const struct wsscreen_descr *cgfour_scrlist[] = {
	&cgfour_stdscreen,
d106 2
a107 3
struct wsscreen_list cgfour_screenlist = {
	sizeof(cgfour_scrlist) / sizeof(struct wsscreen_descr *),
	    cgfour_scrlist
d110 4
a113 20
int cgfour_ioctl(void *, u_long, caddr_t, int, struct proc *);
int cgfour_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgfour_free_screen(void *, void *);
int cgfour_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t cgfour_mmap(void *, off_t, int);
void cgfour_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
void cgfour_burner(void *, u_int, u_int);

struct wsdisplay_accessops cgfour_accessops = {
	cgfour_ioctl,
	cgfour_mmap,
	cgfour_alloc_screen,
	cgfour_free_screen,
	cgfour_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	cgfour_burner,
d116 2
a117 2
void	cgfourattach(struct device *, struct device *, void *);
int	cgfourmatch(struct device *, void *, void *);
d119 4
a122 7
struct cfattach cgfour_ca = {
	sizeof(struct cgfour_softc), cgfourmatch, cgfourattach
};

struct cfdriver cgfour_cd = {
	NULL, "cgfour", DV_DULL
};
d136 3
d144 4
a147 1
	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
d150 4
a153 1
	if (!CPU_ISSUN4 || ca->ca_bustype != BUS_OBIO)
d156 3
d162 1
d170 1
d176 1
a176 1
 * Attach a display.
d183 25
a207 6
	struct cgfour_softc *sc = (struct cgfour_softc *)self;
	struct confargs *ca = args;
	struct wsemuldisplaydev_attach_args waa;
	int node = 0, i;
	volatile struct bt_regs *bt;
	int isconsole = 0;
d209 1
a209 1
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;
d211 9
a219 1
	printf(": cgfour/p4");
d229 1
a229 1
			isconsole = 1;
d232 8
a239 3
	/* Map the pfour register. */
	sc->sc_sunfb.sf_pfour = (volatile u_int32_t *)
		mapiodev(ca->ca_ra.ra_reg, 0, sizeof(u_int32_t));
d248 12
d261 1
a268 2
	/* enable video */
	cgfour_burner(sc, 1, 0);
d271 10
d282 2
a283 2
	 * XXX should initialize the enable plane, instead of expecting the
	 * PROM to do so for us
d285 3
d289 7
a295 15
	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, ca->ca_bustype);
	/*
	 * XXX this only maps the color plane, not the overlay or the enable
	 * planes
	 */
	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(ca->ca_ra.ra_reg,
	    PFOUR_COLOR_OFF_COLOR, round_page(sc->sc_sunfb.sf_fbsize));
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, isconsole);
	fbwscons_setcolormap(&sc->sc_sunfb, cgfour_setcolor);

	cgfour_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgfour_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgfour_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgfour_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;
d297 4
a300 1
	printf(", %dx%d\n", sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);
d302 6
a307 4
	if (isconsole) {
		fbwscons_console_init(&sc->sc_sunfb, &cgfour_stdscreen, -1,
		    cgfour_burner);
	}
d309 1
a309 5
	waa.console = isconsole;
	waa.scrdata = &cgfour_screenlist;
	waa.accessops = &cgfour_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
d313 2
a314 2
cgfour_ioctl(v, cmd, data, flags, p)
	void *v;
d316 1
a316 1
	caddr_t data;
d320 3
a322 3
	struct cgfour_softc *sc = v;
	struct wsdisplay_fbinfo *wdf;
	struct wsdisplay_cmap *cm;
d326 3
a328 2
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
d330 11
a340 9
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
		wdf->cmsize = 256;
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
d343 7
a349 3
	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_getcmap(&sc->sc_cmap, cm);
d352 8
d362 2
a363 7
	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		bt_loadcmap(&sc->sc_cmap, &sc->sc_fbc->fbc_dac,
		    cm->index, cm->count, 1);
a365 7
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
d367 3
a369 3
		return (-1);	/* not supported yet */
        }

d373 16
a388 7
int
cgfour_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
d390 2
a391 1
	struct cgfour_softc *sc = v;
d393 6
a398 2
	if (sc->sc_nscreens > 0)
		return (ENOMEM);
d400 7
a406 8
	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	sc->sc_nscreens++;
	return (0);
}
d408 7
a414 6
void
cgfour_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct cgfour_softc *sc = v;
d416 18
a433 2
	sc->sc_nscreens--;
}
d435 1
a435 9
int
cgfour_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
	return (0);
d438 1
a438 1

d440 1
a440 2
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
d442 3
a444 5
paddr_t
cgfour_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
a445 1
	struct cgfour_softc *sc = v;
d447 2
a448 2
	if (offset & PGOFSET)
		return (-1);
d450 4
a453 4
	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys,
		    PFOUR_COLOR_OFF_COLOR + offset) | PMAP_NC);
	}
d455 1
a455 1
	return (-1);
d458 4
a461 5
void
cgfour_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
	u_int8_t r, g, b;
a462 1
	struct cgfour_softc *sc = v;
d464 1
a464 1
	bt_setcolor(&sc->sc_cmap, &sc->sc_fbc->fbc_dac, index, r, g, b, 1);
d467 7
a473 4
void
cgfour_burner(v, on, flags)
	void *v;
	u_int on, flags;
d475 3
a477 1
	struct cgfour_softc *sc = v;
d479 12
a490 1
	fb_pfour_set_video(&sc->sc_sunfb, on);
d492 1
@


1.9.6.5
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d285 1
a285 1
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG4;
@


1.9.6.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfour.c,v 1.9.6.5 2003/05/16 00:29:40 niklas Exp $	*/
d11 4
d32 5
a36 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.9.6.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d240 1
a240 1
	fbwscons_init(&sc->sc_sunfb, isconsole ? 0 : RI_CLEAR);
@


1.8
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d405 2
d415 1
a415 1
		while (off >= COLOR_SIZE)
@


1.7
log
@Revert back to Theo's eeprom.h.
@
text
@d2 1
a2 1
/*	$NetBSD: cgfour.c,v 1.7 1996/04/01 17:29:58 christos Exp $	*/
a97 4
int		cgfouropen __P((dev_t, int, int, struct proc *));
int		cgfourclose __P((dev_t, int, int, struct proc *));
int		cgfourioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int		cgfourmmap __P((dev_t, int, int));
d102 3
d209 2
a210 2
	fb->fb_pfour = (volatile u_int32_t *)mapiodev(ca->ca_ra.ra_reg, 0,
	    sizeof(u_int32_t), ca->ca_bustype);
d231 1
a231 1
		if (eep == NULL || eep->ee_diag.eed_console == EED_CONS_P4)
d254 1
a254 1
		    PFOUR_COLOR_OFF_OVERLAY, ramsize, ca->ca_bustype);
d259 3
a261 2
	sc->sc_fbc = (volatile struct fbcontrol *)mapiodev(ca->ca_ra.ra_reg,
	    PFOUR_COLOR_OFF_CMAP, sizeof(struct fbcontrol), ca->ca_bustype);
d406 1
a406 1
		off =- NOOVERLAY;
d427 1
a427 1
	} else if ((u_int)off < END_COLOR) {
d435 1
a435 1
	return (REG2PHYS(&sc->sc_phys, poff, sc->sc_bustype) | PMAP_NC);
@


1.6
log
@netbsd port, now we merge our changes back in
@
text
@d1 1
d232 1
a232 1
		if (eep == NULL || eep->eeConsole == EE_CONS_P4OPT)
@


1.5
log
@fix fb_setsize() to set width/height for P4 frame buffers
now rconsole works on all P4 frame buffers
@
text
@d1 1
a1 1
/*	$NetBSD: cgfour.c,v 1.12 1994/11/23 07:02:07 deraadt Exp $ */
d4 1
d62 1
d69 1
d77 2
a81 1
#include <sparc/dev/cgfourreg.h>
a87 1
	volatile struct bt_regs *sc_bt;	/* Brooktree registers */
d89 1
a90 1
	int	sc_blanked;		/* true if blanked */
d101 1
d103 5
d109 2
a110 3
struct cfdriver cgfourcd = {
	NULL, "cgfour", cgfourmatch, cgfourattach,
	DV_DULL, sizeof(struct cgfour_softc)
d113 1
d123 3
d141 30
a170 1
	if (PFOUR_ID(ra->ra_pfour) == PFOUR_ID_COLOR8P1)
d172 3
d186 1
d191 1
d194 49
a242 16
	sc->sc_fb.fb_driver = &cgfourfbdriver;
	sc->sc_fb.fb_device = &sc->sc_dev;
	sc->sc_fb.fb_type.fb_type = FBTYPE_SUN4COLOR;

	pfour_reset();
	pfour_videosize(ca->ca_ra.ra_pfour, &sc->sc_fb.fb_type.fb_width,
	    &sc->sc_fb.fb_type.fb_height);

	sc->sc_fb.fb_linebytes = sc->sc_fb.fb_type.fb_width;

	ramsize = CG4REG_END - CG4REG_OVERLAY;
	sc->sc_fb.fb_type.fb_depth = 8;
	sc->sc_fb.fb_type.fb_cmsize = 256;
	sc->sc_fb.fb_type.fb_size = ramsize;
	printf(": %d x %d", sc->sc_fb.fb_type.fb_width,
	    sc->sc_fb.fb_type.fb_height);
a248 3
	 *
	 * XXX: it is insane to map the full 0x800000 space, when
	 * the mmap code down below doesn't use it all. Ridiculous!
d250 5
a254 5
	isconsole = node == fbnode && fbconstty != NULL;
	if (ca->ca_ra.ra_vaddr == NULL) {
		/* this probably cannot happen, but what the heck */
		ca->ca_ra.ra_vaddr = mapiodev(ca->ca_ra.ra_reg, 0,
		    ramsize, ca->ca_bustype);
d256 5
a260 2
	sc->sc_fb.fb_pixels = (char *)((int)ca->ca_ra.ra_vaddr +
	    CG4REG_COLOUR - CG4REG_OVERLAY);
a261 3
#define	O(memb) ((u_int)(&((struct cgfour_all *)0)->memb))
	sc->sc_bt = bt = (volatile struct bt_regs *)mapiodev(ca->ca_ra.ra_reg,
	    O(ba_btreg), sizeof(struct bt_regs), ca->ca_bustype);
d266 1
d271 1
a271 5
	/* make sure we are not blanked (see cgfourunblank) */
	bt->bt_addr = 0x06 << 24; 	/* command reg */
	bt->bt_ctrl = 0x73 << 24;	/* overlay plane */
	bt->bt_addr = 0x04 << 24;	/* read mask */
	bt->bt_ctrl = 0xff << 24;	/* color planes */
d273 1
d276 2
a277 2
#ifdef RASTERCONSOLE
		fbrcons_init(&sc->sc_fb);
d280 1
d282 7
a288 3
	if ((node == fbnode && cputyp != CPU_SUN4) ||
	    (isconsole && cputyp == CPU_SUN4))
		fb_attach(&sc->sc_fb);
d299 1
a299 1
	if (unit >= cgfourcd.cd_ndevs || cgfourcd.cd_devs[unit] == NULL)
d322 2
a323 1
	register struct cgfour_softc *sc = cgfourcd.cd_devs[minor(dev)];
d361 1
a361 1
		*(int *)data = sc->sc_blanked;
d365 1
a365 19
		if (*(int *)data)
			cgfourunblank(&sc->sc_dev);
		else if (!sc->sc_blanked) {
			register volatile struct bt_regs *bt;

			bt = sc->sc_bt;
			bt->bt_addr = 0x06 << 24;	/* command reg */
			bt->bt_ctrl = 0x70 << 24;	/* overlay plane */
			bt->bt_addr = 0x04 << 24;	/* read mask */
			bt->bt_ctrl = 0x00 << 24;	/* color planes */
			/*
			 * Set color 0 to black -- note that this overwrites
			 * R of color 1.
			 */
			bt->bt_addr = 0 << 24;
			bt->bt_cmap = 0 << 24;

			sc->sc_blanked = 1;
		}
d371 1
d376 63
a444 2
	struct cgfour_softc *sc = (struct cgfour_softc *)dev;
	register volatile struct bt_regs *bt;
d446 18
a463 15
	if (sc->sc_blanked) {
		sc->sc_blanked = 0;
		bt = sc->sc_bt;
		/* restore color 0 (and R of color 1) */
		bt->bt_addr = 0 << 24;
		bt->bt_cmap = sc->sc_cmap.cm_chip[0];
		bt->bt_cmap = sc->sc_cmap.cm_chip[0] << 8;
		bt->bt_cmap = sc->sc_cmap.cm_chip[0] << 16;

		/* restore read mask */
		bt->bt_addr = 0x06 << 24;	/* command reg */
		bt->bt_ctrl = 0x73 << 24;	/* overlay plane */
		bt->bt_addr = 0x04 << 24;	/* read mask */
		bt->bt_ctrl = 0xff << 24;	/* color planes */
	}
d480 1
a480 1
	bt = sc->sc_bt;
d491 1
a491 50

/*
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
 *
 * the cg4 maps it's overlay plane for 128K, followed by the enable
 * plane for 128K, followed by the colour plane (for as much colour
 * as their is.)
 * 
 * As well, mapping at an offset of 0x04000000 causes the cg4 to map
 * only it's colour plane, at 0.
 */
int
cgfourmmap(dev, off, prot)
	dev_t dev;
	int off, prot;
{
	register struct cgfour_softc *sc = cgfourcd.cd_devs[minor(dev)];
	int poff;

#define START_ENABLE	(128*1024)
#define START_COLOUR	(128*1024 + 128*1024)
#define COLOUR_SIZE	(sc->sc_fb.fb_type.fb_width * sc->sc_fb.fb_type.fb_height)
#define END_COLOUR	(START_COLOUR + COLOUR_SIZE)
#define NOOVERLAY	(0x04000000)

	if (off & PGOFSET)
		panic("cgfourmap");

	if ((u_int)off >= NOOVERLAY) {
		off = off - NOOVERLAY;

		/*
		 * X11 maps a huge chunk of the frame buffer; far more than
		 * there really is. We compensate by double-mapping the
		 * first page for as many other pages as it wants
		 */
		while (off >= COLOUR_SIZE)
			off = 0;
		poff = off + (CG4REG_COLOUR - CG4REG_OVERLAY);
	} else if ((u_int)off < START_ENABLE)	/* in overlay plane */
		poff = off;
	else if ((u_int)off < START_COLOUR)	/* in enable plane */
		poff = off + (CG4REG_ENABLE - CG4REG_OVERLAY) - START_ENABLE;
	else if ((u_int)off < (CG4REG_END - CG4REG_OVERLAY)) 	/* in colour plane */ 
		poff = off + (CG4REG_COLOUR - CG4REG_OVERLAY) - START_COLOUR;
	else
		return (-1);
	return (REG2PHYS(&sc->sc_phys, off, sc->sc_bustype) | PMAP_NC);
}
@


1.4
log
@new mapdev/()/mapiodev() calling convention uses "struct rom_reg *" to supply
base plus an offset
new dvma routines
@
text
@d202 3
@


1.3
log
@correct sun4 calls to fb_attach()
@
text
@d85 2
a86 1
	caddr_t	sc_phys;		/* display RAM (phys addr) */
a145 1
	register struct cgfour_all *p;
a174 1
	p = (struct cgfour_all *)ca->ca_ra.ra_paddr;
d177 2
a178 2
		ca->ca_ra.ra_vaddr = mapiodev(p->ba_overlay, ramsize,
		    ca->ca_bustype);
d183 5
a187 4
	sc->sc_bt = bt = (volatile struct bt_regs *)
	    mapiodev((caddr_t)&p->ba_btreg, sizeof(p->ba_btreg),
	    ca->ca_bustype);
	sc->sc_phys = p->ba_overlay;
d409 1
a409 1
	return ((u_int)sc->sc_phys + poff + PMAP_OBIO + PMAP_NC);
@


1.2
log
@modernize
@
text
@d204 2
a205 1
	if (node == fbnode)
@


1.1
log
@new stuff
@
text
@d91 8
a98 2
void	cgfourattach	__P((struct device *, struct device *, void *));
int	cgfourmatch	__P((struct device *, void *, void *));
d105 3
a107 2
static void cgfourunblank __P((struct device *));
static struct fbdriver cgfourfbdriver = { cgfourunblank };
a110 3
extern int (*v_putc)();
extern int nullop();
static int cgfour_cnputc();
a113 2
#define	CGFOUR_MAJOR	39		/* XXX */

d143 1
a143 1
	register int node, ramsize, i;
a147 2
	sc->sc_fb.fb_major = CGFOUR_MAJOR;	/* XXX to be removed */

a149 4
	/*
	 * The defaults below match my screen, but are not guaranteed
	 * to be correct as defaults go...
	 */
a150 1
	node = 0;
a407 4
	/*
	 * I turned on PMAP_NC here to disable the cache as I was
	 * getting horribly broken behaviour with it on.
	 */
@
