head	1.38;
access;
symbols
	OPENBSD_6_0:1.38.0.12
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.8
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.38.0.10
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.38.0.2
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.38.0.6
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.38.0.4
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.37.0.2
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.36.0.18
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.36.0.16
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.36
	OPENBSD_5_1:1.36.0.14
	OPENBSD_5_0:1.36.0.12
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.36.0.10
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.36.0.8
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.36.0.4
	OPENBSD_4_7_BASE:1.36
	OPENBSD_4_6:1.36.0.6
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.36.0.2
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.35.0.6
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.35.0.4
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.35.0.2
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.34.0.2
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.33.0.4
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.33.0.2
	OPENBSD_3_9_BASE:1.33
	OPENBSD_3_8:1.32.0.2
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.30.0.2
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.26.0.6
	OPENBSD_3_6_BASE:1.26
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	OPENBSD_3_5:1.26.0.4
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.18
	UBC:1.8.0.2
	UBC_BASE:1.8
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.10
	OPENBSD_2_8:1.4.0.8
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.6
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.4
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.0.6
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.4
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.2
	OPENBSD_2_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.38
date	2013.10.20.20.07.25;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2013.05.31.22.07.49;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2008.12.26.22.30.21;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2007.03.13.19.40.48;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2007.02.18.18.40.35;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2005.12.25.21.47.15;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2005.03.23.17.17.15;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2005.03.23.17.16.34;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.15.18.50.43;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2005.03.13.23.05.22;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.07.16.44.50;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2004.11.29.22.07.36;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.28.17.05.33;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.06.19.42.47;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.28.13.19.58;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.04.06.17.02.32;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.04.06.17.00.35;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2002.12.12.20.21.34;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2002.12.10.20.32.57;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2002.11.06.21.06.20;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2002.10.12.01.09.43;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2002.10.01.07.09.59;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.23.18.13.38;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.20.11.17.56;	author fgsch;	state Exp;
branches;
next	1.14;

1.14
date	2002.09.09.22.15.16;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2002.09.02.08.00.24;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.21.20.27.35;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2002.08.12.10.44.03;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.08.02.16.13.07;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.42;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.11.01.12.13.46;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.17.13.52.28;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.10.10.34.43;	author art;	state Exp;
branches;
next	1.4;

1.4
date	99.09.10.23.32.01;	author art;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	99.04.22.16.52.47;	author art;	state Exp;
branches;
next	1.2;

1.2
date	98.11.20.15.57.21;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	97.08.08.08.24.48;	author downsj;	state Exp;
branches;
next	;

1.4.4.1
date	2001.07.04.10.23.21;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2001.10.31.03.07.56;	author nate;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.4.4.5;

1.4.4.5
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.4.4.6;

1.4.4.6
date	2003.05.13.19.41.08;	author ho;	state Exp;
branches;
next	1.4.4.7;

1.4.4.7
date	2003.06.07.11.14.42;	author ho;	state Exp;
branches;
next	1.4.4.8;

1.4.4.8
date	2004.02.19.10.49.57;	author niklas;	state Exp;
branches;
next	;

1.8.2.1
date	2002.06.11.03.38.15;	author art;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2002.10.29.00.28.09;	author art;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@/*	$OpenBSD: cgfourteen.c,v 1.37 2013/05/31 22:07:49 deraadt Exp $	*/
/*	$NetBSD: cgfourteen.c,v 1.7 1997/05/24 20:16:08 pk Exp $ */

/*
 * Copyright (c) 2002, 2003, 2005 Miodrag Vallat.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Copyright (c) 1996
 *	The President and Fellows of Harvard College. All rights reserved.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by Harvard University.
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 *	This product includes software developed by Harvard University and
 *	its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *   Based on:
 *	NetBSD: cgthree.c,v 1.28 1996/05/31 09:59:22 pk Exp
 *	NetBSD: cgsix.c,v 1.25 1996/04/01 17:30:00 christos Exp
 */

/*
 * Driver for Campus-II on-board mbus-based video (cgfourteen).
 *
 * XXX should bring hardware cursor code back
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/mman.h>
#include <sys/tty.h>
#include <sys/conf.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/pmap.h>
#include <machine/cpu.h>
#include <machine/conf.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

#include <sparc/dev/cgfourteenreg.h>

#include <dev/cons.h>	/* for prom console hook */

/*
 * Per-display variables/state
 */

union cgfourteen_cmap {
	u_char  	cm_map[256][4];	/* 256 R/G/B/A entries (B is high)*/
	u_int32_t   	cm_chip[256];	/* the way the chip gets loaded */
};

struct cgfourteen_softc {
	struct	sunfb sc_sunfb;		/* common base part */

	struct 	rom_reg	sc_phys;	/* phys address of frame buffer */
	union	cgfourteen_cmap sc_cmap; /* current colormap */
	u_int	sc_cmap_start, sc_cmap_count;	/* deferred cmap range */

	/* registers mappings */
	struct	cg14ctl  *sc_ctl;
	struct	cg14curs *sc_hwc;
	struct 	cg14dac	 *sc_dac;
	struct	cg14xlut *sc_xlut;
	struct 	cg14clut *sc_clut1;
	struct	cg14clut *sc_clut2;
	struct	cg14clut *sc_clut3;
	u_int32_t *sc_autoincr;

	int	sc_rev;			/* VSIMM revision */
	int	sc_32;			/* can do 32bit at this resolution */
	size_t	sc_vramsize;		/* total video memory size */
	int	sc_isconsole;

	struct	intrhand sc_ih;
};

int	cgfourteen_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	cgfourteen_mmap(void *, off_t, int);
void	cgfourteen_reset(struct cgfourteen_softc *, int);
void	cgfourteen_burner(void *, u_int, u_int);

int	cgfourteen_getcmap(union cgfourteen_cmap *, struct wsdisplay_cmap *);
int	cgfourteen_intr(void *);
void	cgfourteen_loadcmap_deferred(struct cgfourteen_softc *, u_int, u_int);
void	cgfourteen_loadcmap_immediate(struct cgfourteen_softc *, u_int, u_int);
void	cgfourteen_prom(struct cgfourteen_softc *);
int	cgfourteen_putcmap(union cgfourteen_cmap *, struct wsdisplay_cmap *);
void	cgfourteen_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);

struct wsdisplay_accessops cgfourteen_accessops = {
	.ioctl = cgfourteen_ioctl,
	.mmap = cgfourteen_mmap,
	.burn_screen = cgfourteen_burner
};

void	cgfourteenattach(struct device *, struct device *, void *);
int	cgfourteenmatch(struct device *, void *, void *);
int	cgfourteenactivate(struct device *, int);

struct cfattach cgfourteen_ca = {
	sizeof(struct cgfourteen_softc), cgfourteenmatch, cgfourteenattach,
	NULL, cgfourteenactivate
};

struct cfdriver cgfourteen_cd = {
	NULL, "cgfourteen", DV_DULL
};

/*
 * Match a cgfourteen.
 */
int
cgfourteenmatch(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
		return (0);

	/*
	 * This driver should not be attached without an "addr" locator,
	 * as this is the only way to differentiate the main and secondary
	 * VSIMM.
	 */
	if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != (int)ra->ra_paddr)
		return (0);

	/*
	 * The cgfourteen is a local-bus video adaptor, accessed directly
	 * via the processor, and not through device space or an external
	 * bus. Thus we look _only_ at the obio bus.
	 * Additionally, these things exist only on the Sun4m.
	 */
	if (CPU_ISSUN4M && ca->ca_bustype == BUS_OBIO)
		return (1);

	return (0);
}

/*
 * Attach a display.
 */
void
cgfourteenattach(struct device *parent, struct device *self, void *args)
{
	struct cgfourteen_softc *sc = (struct cgfourteen_softc *)self;
	struct confargs *ca = args;
	int node, pri, i;
	u_int32_t *lut;
	char *nam;

	pri = ca->ca_ra.ra_intr[0].int_pri;
	printf(" pri %d: ", pri);

	/*
	 * Sanity checks
	 */
	if (ca->ca_ra.ra_len < 0x10000) {
		printf("expected %x bytes of control registers, got %x\n",
		    0x10000, ca->ca_ra.ra_len);
		return;
	}
	if (ca->ca_ra.ra_nreg < CG14_NREG) {
		printf("expected %d registers, got %d\n",
		    CG14_NREG, ca->ca_ra.ra_nreg);
		return;
	}
	if (ca->ca_ra.ra_nintr != 1) {
		printf("expected 1 interrupt, got %d\n", ca->ca_ra.ra_nintr);
		return;
	}

	node = ca->ca_ra.ra_node;
	nam = getpropstring(node, "model");
	if (*nam != '\0')
		printf("%s, ", nam);

	sc->sc_isconsole = node == fbnode;

	/*
	 * Map in the 8 useful pages of registers
	 */
	sc->sc_ctl = (struct cg14ctl *) mapiodev(
	    &ca->ca_ra.ra_reg[CG14_REG_CONTROL], 0, ca->ca_ra.ra_len);

	sc->sc_hwc = (struct cg14curs *) ((u_int)sc->sc_ctl +
					  CG14_OFFSET_CURS);
	sc->sc_dac = (struct cg14dac *) ((u_int)sc->sc_ctl +
					 CG14_OFFSET_DAC);
	sc->sc_xlut = (struct cg14xlut *) ((u_int)sc->sc_ctl +
					   CG14_OFFSET_XLUT);
	sc->sc_clut1 = (struct cg14clut *) ((u_int)sc->sc_ctl +
					    CG14_OFFSET_CLUT1);
	sc->sc_clut2 = (struct cg14clut *) ((u_int)sc->sc_ctl +
					    CG14_OFFSET_CLUT2);
	sc->sc_clut3 = (struct cg14clut *) ((u_int)sc->sc_ctl +
					    CG14_OFFSET_CLUT3);
	sc->sc_autoincr = (u_int32_t *) ((u_int)sc->sc_ctl +
				     CG14_OFFSET_AUTOINCR);

	sc->sc_rev =
	    (sc->sc_ctl->ctl_rsr & CG14_RSR_REVMASK) >> CG14_RSR_REVSHIFT;

	printf("%dMB, rev %d.%d", ca->ca_ra.ra_reg[CG14_REG_VRAM].rr_len >> 20,
	    sc->sc_rev, sc->sc_ctl->ctl_rsr & CG14_RSR_IMPLMASK);

	sc->sc_phys = ca->ca_ra.ra_reg[CG14_REG_VRAM];

	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, ca->ca_bustype);

	/*
	 * The prom will report depth == 8, since this is the mode it will
	 * get initialized in.
	 * Check if we will be able to use 32 bit mode later (i.e. if it will
	 * fit in the video memory. Note that, if this is not the case, the
	 * VSIMM will usually not appear in the OBP device tree!
	 */
	sc->sc_vramsize = ca->ca_ra.ra_reg[CG14_REG_VRAM].rr_len;
	sc->sc_32 = sc->sc_sunfb.sf_fbsize * 4 <= sc->sc_vramsize;

	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(&ca->ca_ra.ra_reg[CG14_REG_VRAM],
	    0,	/* CHUNKY_XBGR */
	    sc->sc_vramsize);

	printf(", %dx%d\n", sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);

	sc->sc_ih.ih_fun = cgfourteen_intr;
	sc->sc_ih.ih_arg = sc;
	intr_establish(pri, &sc->sc_ih, IPL_FB, self->dv_xname);

	/*
	 * Reset frame buffer controls
	 */
	sc->sc_sunfb.sf_depth = 0;	/* force action */
	cgfourteen_reset(sc, 8);

	/*
	 * Grab the initial colormap
	 */
	lut = (u_int32_t *)sc->sc_clut1->clut_lut;
	for (i = 0; i < CG14_CLUT_SIZE; i++)
		sc->sc_cmap.cm_chip[i] = lut[i];

	/*
	 * Enable the video.
	 */
	cgfourteen_burner(sc, 1, 0);

	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, sc->sc_isconsole);
	fbwscons_setcolormap(&sc->sc_sunfb, cgfourteen_setcolor);

	if (sc->sc_isconsole)
		fbwscons_console_init(&sc->sc_sunfb, -1);

	fbwscons_attach(&sc->sc_sunfb, &cgfourteen_accessops, sc->sc_isconsole);
}

int
cgfourteenactivate(struct device *self, int act)
{
	struct cgfourteen_softc *sc = (struct cgfourteen_softc *)self;
	int ret = 0;

	switch (act) {
	case DVACT_POWERDOWN:
		if (sc->sc_isconsole)
			cgfourteen_prom(sc);
		break;
	}

	return (ret);
}

int
cgfourteen_ioctl(void *dev, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct cgfourteen_softc *sc = dev;
	struct wsdisplay_cmap *cm;
	struct wsdisplay_fbinfo *wdf;
	int error;

	/*
	 * Note that, although the emulation (text) mode is running in a
	 * 8-bit plane, we advertize the frame buffer as 32-bit if it can
	 * support this mode.
	 */
	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG14;
		break;
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width = sc->sc_sunfb.sf_width;
		wdf->depth = sc->sc_32 ? 32 : 8;
		wdf->cmsize = sc->sc_32 ? 0 : 256;
		break;
	case WSDISPLAYIO_GETSUPPORTEDDEPTH:
		if (sc->sc_32)
			*(u_int *)data = WSDISPLAYIO_DEPTH_24_32;
		else
			return (-1);
		break;
	case WSDISPLAYIO_LINEBYTES:
		if (sc->sc_32)
			*(u_int *)data = sc->sc_sunfb.sf_linebytes * 4;
		else
			*(u_int *)data = sc->sc_sunfb.sf_linebytes;
		break;

	case WSDISPLAYIO_GETCMAP:
		if (sc->sc_32 == 0) {
			cm = (struct wsdisplay_cmap *)data;
			error = cgfourteen_getcmap(&sc->sc_cmap, cm);
			if (error)
				return (error);
		}
		break;
	case WSDISPLAYIO_PUTCMAP:
		if (sc->sc_32 == 0) {
			cm = (struct wsdisplay_cmap *)data;
			error = cgfourteen_putcmap(&sc->sc_cmap, cm);
			if (error)
				return (error);
			cgfourteen_loadcmap_deferred(sc, cm->index, cm->count);
		}
		break;

	case WSDISPLAYIO_SMODE:
		if (*(int *)data == WSDISPLAYIO_MODE_EMUL) {
			/* Back from X11 to text mode */
			cgfourteen_reset(sc, 8);
		} else {
			/* Starting X11, try to switch to 32 bit mode */
			if (sc->sc_32)
				cgfourteen_reset(sc, 32);
		}
		break;

	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_SVIDEO:
		break;

	default:
		return (-1);	/* not supported yet */
	}
	return (0);
}

/*
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
 */
paddr_t
cgfourteen_mmap(void *v, off_t offset, int prot)
{
	struct cgfourteen_softc *sc = v;
	
	if (offset & PGOFSET || offset < 0)
		return (-1);

	/* Allow mapping as a dumb framebuffer from offset 0 */
	if (offset < sc->sc_sunfb.sf_fbsize * (sc->sc_32 ? 4 : 1)) {
		return (REG2PHYS(&sc->sc_phys, offset) | PMAP_NC);
	}

	return (-1);
}

/* Initialize the framebuffer, storing away useful state for later reset */
void
cgfourteen_reset(struct cgfourteen_softc *sc, int depth)
{
	u_int i;

	if (sc->sc_sunfb.sf_depth != depth) {
		if (depth == 8) {
			/*
			 * Enable the video and put it in 8 bit mode
			 */
			if (sc->sc_rev == 0)
				sc->sc_ctl->ctl_mctl = CG14_MCTL_R0_ENABLEHW |
				    CG14_MCTL_PIXMODE_8;
			else
				sc->sc_ctl->ctl_mctl = CG14_MCTL_R1_ENABLEHW |
				    CG14_MCTL_R1_ENABLEVID |
				    CG14_MCTL_PIXMODE_8;

			fbwscons_setcolormap(&sc->sc_sunfb,
			    cgfourteen_setcolor);
		} else {
			/*
			 * Clear the screen to black
			 */
			bzero(sc->sc_sunfb.sf_ro.ri_bits,
			    sc->sc_sunfb.sf_fbsize);

			/*
			 * Enable the video, and put in 32 bit mode
			 */
			if (sc->sc_rev == 0)
				sc->sc_ctl->ctl_mctl = CG14_MCTL_R0_ENABLEHW |
				    CG14_MCTL_PIXMODE_32;
			else
				sc->sc_ctl->ctl_mctl = CG14_MCTL_R1_ENABLEHW |
				    CG14_MCTL_R1_ENABLEVID |
				    CG14_MCTL_PIXMODE_32;

			/*
			 * Zero the xlut to enable direct-color mode
			 */
			sc->sc_xlut->xlut_lutinc[0] = 0;
			for (i = CG14_CLUT_SIZE; i; i--)
				*sc->sc_autoincr = 0;
		}
	}

	sc->sc_cmap_count = 0;
	sc->sc_sunfb.sf_depth = depth;
}

void
cgfourteen_prom(struct cgfourteen_softc *sc)
{
	extern struct consdev consdev_prom;

	if (sc->sc_sunfb.sf_depth != 8) {
		/*
		 * Go back to 8-bit mode.
		 */
		cgfourteen_reset(sc, 8);

		/*
		 * Go back to prom output for the last few messages, so they
		 * will be displayed correctly.
		 */
		cn_tab = &consdev_prom;
	}
}

void
cgfourteen_burner(void *v, u_int on, u_int flags)
{
	struct cgfourteen_softc *sc = v;
	u_int bits;

	/*
	 * We can only use DPMS to power down the display if the chip revision
	 * is greater than 0.
	 */
	if (sc->sc_rev == 0)
		bits = CG14_MCTL_R0_ENABLEHW;
	else
		bits = CG14_MCTL_R1_ENABLEHW | CG14_MCTL_R1_ENABLEVID;

	if (on) {
		sc->sc_ctl->ctl_mctl |= bits;
	} else {
		sc->sc_ctl->ctl_mctl &= ~bits;
	}
}

/* Read the software shadow colormap */
int
cgfourteen_getcmap(union cgfourteen_cmap *cm, struct wsdisplay_cmap *rcm)
{
	u_int index = rcm->index, count = rcm->count, i;
	int error;

	if (index >= CG14_CLUT_SIZE || count > CG14_CLUT_SIZE - index)
                return (EINVAL);

	for (i = 0; i < count; i++) {
		if ((error = copyout(&cm->cm_map[index + i][3],
		    &rcm->red[i], 1)) != 0)
			return (error);
		if ((error = copyout(&cm->cm_map[index + i][2],
		    &rcm->green[i], 1)) != 0)
			return (error);
		if ((error = copyout(&cm->cm_map[index + i][1],
		    &rcm->blue[i], 1)) != 0)
			return (error);
	}
	return (0);
}

/* Write the software shadow colormap */
int
cgfourteen_putcmap(union cgfourteen_cmap *cm, struct wsdisplay_cmap *rcm)
{
	u_int index = rcm->index, count = rcm->count, i;
	int error;

	if (index >= CG14_CLUT_SIZE || count > CG14_CLUT_SIZE - index)
                return (EINVAL);

	for (i = 0; i < count; i++) {
		if ((error = copyin(&rcm->red[i],
		    &cm->cm_map[index + i][3], 1)) != 0)
			return (error);
		if ((error = copyin(&rcm->green[i],
		    &cm->cm_map[index + i][2], 1)) != 0)
			return (error);
		if ((error = copyin(&rcm->blue[i],
		    &cm->cm_map[index + i][1], 1)) != 0)
			return (error);
		cm->cm_map[index +i][0] = 0;	/* no alpha channel */
	}
	return (0);
}

void
cgfourteen_loadcmap_deferred(struct cgfourteen_softc *sc, u_int start,
    u_int ncolors)
{
	u_int end;

	/* Grow the deferred colormap update range if necessary */
	if (sc->sc_cmap_count == 0) {
		sc->sc_cmap_start = start;
		sc->sc_cmap_count = ncolors;
	} else {
		end = MAX(start + ncolors,
		    sc->sc_cmap_start + sc->sc_cmap_count);
		sc->sc_cmap_start = min(sc->sc_cmap_start, start);
		sc->sc_cmap_count = end - sc->sc_cmap_start;
	}

	/* Enable interrupts */
	sc->sc_ctl->ctl_mctl |= CG14_MCTL_ENABLEINTR;
}

void
cgfourteen_loadcmap_immediate(struct cgfourteen_softc *sc, u_int start,
    u_int ncolors)
{
	u_int32_t *colp = &sc->sc_cmap.cm_chip[start];

	sc->sc_clut1->clut_lutinc[start] = 0;
	while (ncolors-- != 0)
		*sc->sc_autoincr = *colp++;
}

void
cgfourteen_setcolor(void *v, u_int index, u_int8_t r, u_int8_t g, u_int8_t b)
{
	struct cgfourteen_softc *sc = v;

	sc->sc_cmap.cm_map[index][3] = r;
	sc->sc_cmap.cm_map[index][2] = g;
	sc->sc_cmap.cm_map[index][1] = b;
	sc->sc_cmap.cm_map[index][0] = 0;	/* no alpha channel */
	
	cgfourteen_loadcmap_immediate(sc, index, 1);
}

int
cgfourteen_intr(void *v)
{
	struct cgfourteen_softc *sc = v;
	u_int msr;
	int claim = 0;

	msr = sc->sc_ctl->ctl_msr;

	/* check that the interrupt is ours */
	if (!ISSET(msr, CG14_MSR_PENDING) ||
	    !ISSET(sc->sc_ctl->ctl_mctl, CG14_MCTL_ENABLEINTR)) {
		return (0);
	}

	/* vertical retrace interrupt */
	if (ISSET(msr, CG14_MSR_VRETRACE)) {
		/* acknowledge by writing to the (read only) msr */
		sc->sc_ctl->ctl_msr = 0;

		/* disable interrupts until next colormap change */
		sc->sc_ctl->ctl_mctl &= ~CG14_MCTL_ENABLEINTR;

		cgfourteen_loadcmap_immediate(sc,
		    sc->sc_cmap_start, sc->sc_cmap_count);

		claim = 1;
	}

	/* engine fault */
	if (ISSET(msr, CG14_MSR_FAULT)) {
		/* acknowledge by reading the fault status register */
		claim = 1 | sc->sc_ctl->ctl_fsr;
	}

	if (claim == 0) {
#ifdef DEBUG
		printf("%s: unknown interrupt cause, msr=%x\n",
		    sc->sc_sunfb.sf_dev.dv_xname, msr);
#endif
		claim = 1;	/* claim anyway */
	}

	return (claim & 1);
}
@


1.37
log
@Replace shutdownhooks with activate functions, properly doing those
operations only if device is console
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.36 2008/12/26 22:30:21 miod Exp $	*/
d159 3
a161 10
	cgfourteen_ioctl,
	cgfourteen_mmap,
	NULL,	/* alloc_screen */
	NULL,	/* free_screen */
	NULL,	/* show_screen */
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	cgfourteen_burner,
	NULL	/* pollc */
@


1.36
log
@Move the logic responsible from deciding whether a frame buffer needs to be
cleared on attach, from the individual drivers to the common frame buffer code;
the latter will decide based on the prom font metrics and the prom console
window position, whenever possible.

This removes the need for the console window position to be hardcoded in
the p9100 driver, and will no longer require a screen clear on a vigra
VS-12 in high resolution mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.35 2007/03/13 19:40:48 miod Exp $	*/
d140 1
d154 1
a154 1
void	cgfourteen_prom(void *);
d173 1
d176 2
a177 1
	sizeof(struct cgfourteen_softc), cgfourteenmatch, cgfourteenattach
a226 1
	int isconsole;
d255 1
a255 1
	isconsole = node == fbnode;
d327 1
a327 1
	fbwscons_init(&sc->sc_sunfb, isconsole);
d330 1
a330 1
	if (isconsole) {
d332 15
a346 1
		shutdownhook_establish(cgfourteen_prom, sc);
d349 1
a349 1
	fbwscons_attach(&sc->sc_sunfb, &cgfourteen_accessops, isconsole);
d501 1
a501 1
cgfourteen_prom(void *v)
a502 1
	struct cgfourteen_softc *sc = v;
@


1.35
log
@When about to run X11 in 32 bpp mode, advertize correctly that we are
really using 24 bpp pixels on 32 bit boundaries.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.34 2007/02/18 18:40:35 miod Exp $	*/
d325 1
a325 1
	fbwscons_init(&sc->sc_sunfb, isconsole ? 0 : RI_CLEAR);
@


1.34
log
@Display the interrupt priority in dmesg, for frame buffers which register
interrupt handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.33 2005/12/25 21:47:15 miod Exp $	*/
d359 6
@


1.33
log
@Return proper frame buffer type rather than generic SUN24 id, Xwsfb has known
the proper id for a long time already...
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.32 2005/03/23 17:17:15 miod Exp $	*/
d222 1
a222 1
	int node, i;
d224 1
a224 1
	int isconsole = 0;
d227 3
d234 1
a234 1
		printf(": expected %x bytes of control registers, got %x\n",
d239 1
a239 1
		printf(": expected %d registers, got %d\n",
d244 1
a244 1
		printf(": expected 1 interrupt, got %d\n", ca->ca_ra.ra_nintr);
a247 1
	printf(": ");
d304 1
a304 2
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih, IPL_FB,
	    self->dv_xname);
a648 1
#ifdef DIAGNOSTIC
d650 1
d653 1
a655 1
#endif
@


1.32
log
@Do not bzero() too far when setting up 32-bit mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.31 2005/03/23 17:16:34 miod Exp $	*/
d350 1
a350 4
		if (sc->sc_32)
			*(u_int *)data = WSDISPLAY_TYPE_SUN24;
		else
			*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
@


1.31
log
@Move the alloc_screen, free_screen and show_screen wsdisplay accessops to
the common frame buffer code, rather than duplicating it in every driver.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.30 2005/03/15 18:50:43 miod Exp $	*/
d454 1
a454 1
			    sc->sc_sunfb.sf_fbsize * 4);
@


1.30
log
@A potpourri of cgfourteen fixes and improvements:
- use the autoincremented luts for faster colormap programming.
- colormap changes are now deferred to the vertical retrace interrupt, causes
  less display flickering under X11 (still some visible at boot time because
  interrupts are disabled at this point).
- if the resolution choosen does not allow the VSIMM to run in 32bit mode,
  do not allow mmap()ing past the frame buffer area.
- print the VSIMM revision at boot time, and be more friendly to revision 0,
  which needs to be handled in a slightly different way.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.29 2005/03/13 23:05:22 miod Exp $	*/
a103 1
#include <dev/wscons/wscons_raster.h>
a141 1
	int	sc_nscreens;
a144 5
int	cgfourteen_alloc_screen(void *, const struct wsscreen_descr *, void **,
	    int *, int *, long *);
void	cgfourteen_free_screen(void *, void *);
int	cgfourteen_show_screen(void *, void *, int, void (*)(void *, int, int),
	    void *);
d160 3
a162 3
	cgfourteen_alloc_screen,
	cgfourteen_free_screen,
	cgfourteen_show_screen,
d167 1
a404 33
	return (0);
}

int
cgfourteen_alloc_screen(void *v, const struct wsscreen_descr *type,
    void **cookiep, int *curxp, int *curyp, long *attrp)
{
	struct cgfourteen_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	sc->sc_nscreens++;
	return (0);
}

void
cgfourteen_free_screen(void *v, void *cookie)
{
	struct cgfourteen_softc *sc = v;

	sc->sc_nscreens--;
}

int
cgfourteen_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
{
@


1.29
log
@Add missed WSDISPLAYIO_[GS]VIDEO ioctl handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.28 2005/03/07 16:44:50 miod Exp $	*/
d5 1
a5 1
 * Copyright (c) 2002, 2003 Miodrag Vallat.  All rights reserved.
a81 4
 * Does not handle interrupts, even though they can occur.
 *
 * XXX should defer colormap updates to vertical retrace interrupts
 *
d113 1
a113 1
 * per-display variables/state
d115 6
d125 2
a126 1
	union	cg14cmap sc_cmap;	/* current colormap */
d128 2
a129 1
	struct	cg14ctl  *sc_ctl; 	/* various registers */
d136 1
a136 1
	u_int	*sc_clutincr;
d138 1
d142 1
d146 17
a162 15
int cgfourteen_ioctl(void *, u_long, caddr_t, int, struct proc *);
int cgfourteen_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgfourteen_free_screen(void *, void *);
int cgfourteen_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t cgfourteen_mmap(void *, off_t, int);
void cgfourteen_reset(struct cgfourteen_softc *, int);
void cgfourteen_burner(void *, u_int, u_int);
void cgfourteen_prom(void *);

int  cgfourteen_getcmap(union cg14cmap *, struct wsdisplay_cmap *);
int  cgfourteen_putcmap(union cg14cmap *, struct wsdisplay_cmap *);
void cgfourteen_loadcmap(struct cgfourteen_softc *, int, int);
void cgfourteen_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
d191 1
a191 3
cgfourteenmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
d224 1
a224 3
cgfourteenattach(parent, self, args)
	struct device *parent, *self;
	void *args;
a232 8
	printf(": ");
	node = ca->ca_ra.ra_node;
	nam = getpropstring(node, "model");
	if (*nam != '\0')
		printf("%s, ", nam);

	isconsole = node == fbnode;

d237 2
a238 2
		printf("\n%s: expected %x bytes of control registers, got %x\n",
		    self->dv_xname, 0x10000, ca->ca_ra.ra_len);
d242 6
a247 2
		printf("\n%s: expected %d registers, got %d",
		    self->dv_xname, CG14_NREG, ca->ca_ra.ra_nreg);
d251 7
a257 1
	printf("%dMB", ca->ca_ra.ra_reg[CG14_REG_VRAM].rr_len >> 20);
d277 8
a284 2
	sc->sc_clutincr = (u_int *) ((u_int)sc->sc_ctl +
				     CG14_OFFSET_CLUTINCR);
a285 3
	/*
	 * Stash the physical address of the framebuffer for use by mmap
	 */
d306 5
d320 1
a320 1
	lut = (u_int32_t *) sc->sc_clut1->clut_lut;
d342 1
a342 6
cgfourteen_ioctl(dev, cmd, data, flags, p)
	void *dev;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
d376 6
a381 4
		cm = (struct wsdisplay_cmap *)data;
		error = cgfourteen_getcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
a382 1

d384 7
a390 6
		cm = (struct wsdisplay_cmap *)data;
		error = cgfourteen_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		/* XXX should use retrace interrupt */
		cgfourteen_loadcmap(sc, cm->index, cm->count);
d415 2
a416 6
cgfourteen_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
d433 1
a433 3
cgfourteen_free_screen(v, cookie)
	void *v;
	void *cookie;
d441 2
a442 6
cgfourteen_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
d452 1
a452 4
cgfourteen_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
d456 1
a456 1
	if (offset & PGOFSET)
d460 1
a460 1
	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize * 4) {
d469 1
a469 3
cgfourteen_reset(sc, depth)
	struct cgfourteen_softc *sc;
	int depth;
d471 1
d478 7
a484 2
			sc->sc_ctl->ctl_mctl = CG14_MCTL_ENABLEVID |
			    CG14_MCTL_PIXMODE_8 | CG14_MCTL_POWERCTL;
d493 1
a493 1
			    sc->sc_sunfb.sf_fbsize);
d496 1
a496 1
			 * Enable the video, and put in 32 bit mode.
d498 7
a504 2
			sc->sc_ctl->ctl_mctl = CG14_MCTL_ENABLEVID |
			    CG14_MCTL_PIXMODE_32 | CG14_MCTL_POWERCTL;
d509 3
a511 1
			bzero(sc->sc_xlut, CG14_CLUT_SIZE);
d515 1
d520 1
a520 2
cgfourteen_prom(v)
	void *v;
d540 1
a540 3
cgfourteen_burner(v, on, flags)
	void *v;
	u_int on, flags;
d543 1
d549 5
d555 1
a555 5
		if ((sc->sc_ctl->ctl_rsr & CG14_RSR_REVMASK) > 0)
			sc->sc_ctl->ctl_mctl |= (CG14_MCTL_ENABLEVID |
						 CG14_MCTL_POWERCTL);
		else
			sc->sc_ctl->ctl_mctl |= CG14_MCTL_ENABLEVID;
d557 1
a557 5
		if ((sc->sc_ctl->ctl_rsr & CG14_RSR_REVMASK) > 0)
			sc->sc_ctl->ctl_mctl &= ~(CG14_MCTL_ENABLEVID |
						  CG14_MCTL_POWERCTL);
		else
			sc->sc_ctl->ctl_mctl &= ~CG14_MCTL_ENABLEVID;
d563 1
a563 3
cgfourteen_getcmap(cm, rcm)
	union cg14cmap *cm;
	struct wsdisplay_cmap *rcm;
d587 1
a587 3
cgfourteen_putcmap(cm, rcm)
        union cg14cmap *cm;
        struct wsdisplay_cmap *rcm;
d611 2
a612 3
cgfourteen_loadcmap(sc, start, ncolors)
	struct cgfourteen_softc *sc;
	int start, ncolors;
d614 16
a629 1
	/* XXX switch to auto-increment, and on retrace intr */
d631 4
a634 1
	/* Setup pointers to source and dest */
a635 1
	volatile u_int32_t *lutp = &sc->sc_clut1->clut_lut[start];
d637 3
a639 3
	/* Copy by words */
	while (--ncolors >= 0)
		*lutp++ = *colp++;
d643 1
a643 4
cgfourteen_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
	u_int8_t r, g, b;
a646 2
	/* XXX - Wait for retrace? */

d652 47
a698 1
	cgfourteen_loadcmap(sc, index, 1);
@


1.28
log
@Do not bother passing the blanking routine to fbwscons_console_init(),
as fbwscons_attach() can find it on its own.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.27 2004/11/29 22:07:36 miod Exp $	*/
d391 4
@


1.27
log
@Move the struct wsscreen_descr from a per-driver global to a per-instance
field of the sunfb structure. This allows multiple instances of the same driver,
but with different resolutions (such as a couple of vigra or a TGX cgsix and
a TGX+ cgsix) to use distinct wsscreen_descr structures featuring different
resolution information.

Doing this allows more wsscreen_descr fiddling inside the sparc* fb api,
and results in some code shrinkage (about 4KB on sparc GENERIC).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.26 2003/06/28 17:05:33 miod Exp $	*/
d320 1
a320 1
		fbwscons_console_init(&sc->sc_sunfb, -1, cgfourteen_burner);
@


1.26
log
@Sync sparc fb API with the sparc64 changes (fbwscons_init takes flags, and
the sunfb structure keeps pointer to the prom cursor coordinates).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.25 2003/06/06 19:42:47 miod Exp $	*/
a139 13
struct wsscreen_descr cgfourteen_stdscreen = {
	"std",
};

const struct wsscreen_descr *cgfourteen_scrlist[] = {
	&cgfourteen_stdscreen,
};

struct wsscreen_list cgfourteen_screenlist = {
	sizeof(cgfourteen_scrlist) / sizeof(struct wsscreen_descr *),
	    cgfourteen_scrlist
};

a223 1
	struct wsemuldisplaydev_attach_args waa;
a318 5
	cgfourteen_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgfourteen_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgfourteen_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgfourteen_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

d320 1
a320 2
		fbwscons_console_init(&sc->sc_sunfb, &cgfourteen_stdscreen,
		    -1, cgfourteen_burner);
d324 1
a324 5
	waa.console = isconsole;
	waa.scrdata = &cgfourteen_screenlist;
	waa.accessops = &cgfourteen_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
@


1.25
log
@Do not bother taking care of the frame buffer flags in the softc, if the
driver does not use any. Basically this changes all drivers but those that
can handle a P4 card.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.24 2003/04/28 13:19:58 miod Exp $	*/
d330 1
a330 1
	fbwscons_init(&sc->sc_sunfb, isconsole);
@


1.24
log
@Prettier dmesg; henning
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.23 2003/04/06 17:02:32 miod Exp $	*/
a241 2

	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags & FB_USERMASK;
@


1.23
log
@Run the console in the overlay plane, or in low-depth mode, as appropriate,
and do not switch to high-depth mode until the appropriate ioctls are
issued. This lets us benefit from true color X11, with a faster text console.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.22 2003/04/06 17:00:35 miod Exp $	*/
d245 1
d248 2
a249 3
	if (*nam == '\0')
		nam = getpropstring(node, "name");
	printf(": %s", nam);
d267 1
a267 1
	printf(", %dMB", ca->ca_ra.ra_reg[CG14_REG_VRAM].rr_len >> 20);
@


1.22
log
@Check for the "addr" locator versus the physical address of the VSIMM, so
as not to attach a single VSIMM put in the secondary slot as cgfourteen0.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.21 2002/12/12 20:21:34 miod Exp $	*/
d5 1
a5 1
 * Copyright (c) 2002 Miodrag Vallat.  All rights reserved.
a80 2
 * Provides minimum emulation of a Sun cgthree 8-bit framebuffer to
 * allow X to run.
d134 3
d160 1
a160 1
void cgfourteen_reset(struct cgfourteen_softc *);
d238 1
a238 1
	int fb_depth, node, i;
d257 3
a259 3
		printf("\n");
		panic("cgfourteen: expected %x bytes of control "
		    "registers, got %x", 0x10000, ca->ca_ra.ra_len);
d262 3
a264 3
		printf("\n");
		panic("cgfourteen: expected %d registers, got %d",
		    CG14_NREG, ca->ca_ra.ra_nreg);
d295 1
a295 6
	if (ISSET(sc->sc_sunfb.sf_flags, FB_FORCELOW))
		fb_depth = 8;
	else
		fb_depth = 32;

	fb_setsize(&sc->sc_sunfb, fb_depth, 1152, 900, node, ca->ca_bustype);
d298 4
a301 4
	 * The prom will report depth == 8, since this is the mode
	 * it will get initialized in.
	 * Try to compensate and enable 32 bit mode, unless it would
	 * not fit in the video memory. Note that, in this case, the
d304 2
a305 7
	if (fb_depth == 32 && sc->sc_sunfb.sf_depth == 8 &&
	    sc->sc_sunfb.sf_fbsize * 4 <=
	    ca->ca_ra.ra_reg[CG14_REG_VRAM].rr_len) {
		sc->sc_sunfb.sf_depth = 32;
		sc->sc_sunfb.sf_linebytes *= 4;
		sc->sc_sunfb.sf_fbsize *= 4;
	}
d309 1
a309 1
	    round_page(sc->sc_sunfb.sf_fbsize));
d311 1
a311 2
	printf(", %dx%d, depth %d\n", sc->sc_sunfb.sf_width,
	    sc->sc_sunfb.sf_height, sc->sc_sunfb.sf_depth);
d316 2
a317 1
	cgfourteen_reset(sc);
d342 1
a342 2
		    sc->sc_sunfb.sf_depth == 8 ? -1 : 0,
		    cgfourteen_burner);
d366 5
d373 4
a376 1
		*(u_int *)data = WSDISPLAY_TYPE_SUN24;
d382 2
a383 2
		wdf->depth = sc->sc_sunfb.sf_depth;
		wdf->cmsize = (sc->sc_sunfb.sf_depth == 8) ? 256 : 0;
d386 4
a389 1
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
d393 4
a396 6
		if (sc->sc_sunfb.sf_depth == 8) {
			cm = (struct wsdisplay_cmap *)data;
			error = cgfourteen_getcmap(&sc->sc_cmap, cm);
			if (error)
				return (error);
		}
d400 16
a415 7
		if (sc->sc_sunfb.sf_depth == 8) {
			cm = (struct wsdisplay_cmap *)data;
			error = cgfourteen_putcmap(&sc->sc_cmap, cm);
			if (error)
				return (error);
			/* XXX should use retrace interrupt */
			cgfourteen_loadcmap(sc, cm->index, cm->count);
a418 7
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
d441 2
a442 6
	if (sc->sc_sunfb.sf_depth == 8)
		sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
		    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	else
		sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
		    0, 0, 0, attrp);
d484 1
a484 1
	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
d493 1
a493 1
cgfourteen_reset(sc)
d495 1
d498 29
a526 18
	if (sc->sc_sunfb.sf_depth == 8) {
		/*
		 * Enable the video and put it in 8 bit mode
		 */
		sc->sc_ctl->ctl_mctl = CG14_MCTL_ENABLEVID |
		    CG14_MCTL_PIXMODE_8 | CG14_MCTL_POWERCTL;
	} else {
		/*
		 * Enable the video, and put in 32 bit mode.
		 */
		sc->sc_ctl->ctl_mctl = CG14_MCTL_ENABLEVID |
		    CG14_MCTL_PIXMODE_32 | CG14_MCTL_POWERCTL;

		/*
		 * Clear the screen to white
		 */
		memset(sc->sc_sunfb.sf_ro.ri_bits, 0xff,
		    round_page(sc->sc_sunfb.sf_fbsize));
d528 1
a528 7
		/*
		 * Zero the xlut to enable direct-color mode
		 */
		bzero(sc->sc_xlut, CG14_CLUT_SIZE);

		shutdownhook_establish(cgfourteen_prom, sc);
	}
d542 1
a542 2
		sc->sc_ctl->ctl_mctl = CG14_MCTL_ENABLEVID |
		    CG14_MCTL_PIXMODE_8 | CG14_MCTL_POWERCTL;
@


1.21
log
@Remove dead prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.20 2002/12/10 20:32:57 miod Exp $	*/
d204 8
@


1.20
log
@The introduction of fbwscons_setcolormap() left out 24 bit frame buffers
operating in 8 bit mode, such as on the installation media...
Installing with a pale grey on white is not what I would call a friendly
display, ouch.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.19 2002/11/06 21:06:20 miod Exp $	*/
a158 1
int cgfourteen_is_console(int);
@


1.19
log
@- always initialize colormaps, even if the frame buffer is non console; this
  helps if the ramdac does not get initialized (idea from jason@@)
- only register a shutdown hook for the frame buffers which need it, if this
  is the console frame buffer. Otherwise this is just a waste of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.18 2002/10/12 01:09:43 krw Exp $	*/
d335 1
@


1.18
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.17 2002/10/01 07:09:59 miod Exp $	*/
d248 2
a249 1
	if (ca->ca_ra.ra_len < 0x10000)
d252 3
a254 1
	if (ca->ca_ra.ra_nreg < CG14_NREG)
d257 1
d344 2
a345 1
		    cgfourteen_setcolor, cgfourteen_burner);
@


1.17
log
@If the framebuffer is being run in 32bit mode, register a shutdown_hook
to bring it in a prom-friendly mode upon halting the system, like the
other > 8 bit framebuffers do.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.16 2002/09/23 18:13:38 miod Exp $	*/
d249 1
a249 1
		panic("\ncgfourteen: expected %x bytes of control "
d252 1
a252 1
		panic("\ncgfourteen: expected %d registers, got %d",
@


1.16
log
@Get the wsdisplay capabilities from rasops, rather than attempting to
guess them at compile-time. Plus this makes cgtwelve a bit more clean.

ok fgs@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.15 2002/09/20 11:17:56 fgsch Exp $	*/
d116 2
d162 1
d510 24
@


1.15
log
@Support to run the 24 bit fb in 8 bit mode or cg12 in 1 bit mode
via flags, using 0x0001.
miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.13 2002/09/02 08:00:24 miod Exp $	*/
a138 5
	0, 0,	/* will be filled in */
	0,
	0, 0,
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
	WSSCREEN_REVERSE | WSSCREEN_WSCOLORS
d329 1
@


1.14
log
@Register more screen capabilities to work with the recent wsemul_sun changes.
@
text
@a90 7
/*
 * Define CG14_LOWCOLOR to stick to 8 bit mode, thus having a faster console.
 */
#ifdef	SMALL_KERNEL
#define	CG14_LOWCOLOR
#endif

a205 5
	/*
	 * Mask out invalid flags from the user.
	 */
	cf->cf_flags &= FB_USERMASK;

d232 1
a232 1
	int node, i;
d237 1
a237 1
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;
d251 2
a252 2
		panic("\ncgfourteen: expected %x bytes of control registers, got %x",
		    0x10000, ca->ca_ra.ra_len);
d285 13
a297 11
#ifdef CG14_LOWCOLOR
	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, ca->ca_bustype);
#else
	fb_setsize(&sc->sc_sunfb, 32, 1152, 900, node, ca->ca_bustype);

	/*
	 * The prom will report depth == 8, since this is the mode it will get
	 * initialized in.
	 * Try to compensate and enable 32 bit mode, unless it would not fit in
	 * the video memory. Note that, in this case, the VSIMM will usually
	 * not appear in the OBP device tree!
d299 2
a300 1
	if (sc->sc_sunfb.sf_depth == 8 && sc->sc_sunfb.sf_fbsize * 4 <=
a305 1
#endif
@


1.13
log
@Make the cgfourteen work in 32bit when possible, also display the size of
the VSIMM in the dmesg.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.12 2002/08/21 20:27:35 miod Exp $	*/
d149 1
@


1.12
log
@Correctly map the video memory, for proper operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.11 2002/08/12 10:44:03 miod Exp $	*/
d92 1
a92 1
 * XXX define this to allow 24-bit operation. Rumored not to work.
d94 3
a96 1
#undef CG14_FULLCOLOR
d243 1
a243 1
	int node = 0, depth, i;
d259 12
a272 4
	if (ca->ca_ra.ra_len < 0x10000) {
		panic("\ncgfourteen: expected %x bytes of registers, got %x",
		    0x10000, ca->ca_ra.ra_len);
	}
a293 3
	if (ca->ca_ra.ra_nreg < CG14_NREG)
		panic("\ncgfourteen: expected %d registers, got %d",
		    CG14_NREG, ca->ca_ra.ra_nreg);
d296 27
a339 8
#ifdef CG14_FULLCOLOR
	depth = 32;
#else
	depth = 8;
#endif
	fb_setsize(&sc->sc_sunfb, depth, 1152, 900, node, ca->ca_bustype);
	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(&ca->ca_ra.ra_reg[CG14_REG_VRAM],
	    0, round_page(sc->sc_sunfb.sf_fbsize));
a346 3
	printf(", %dx%d, depth %d\n", sc->sc_sunfb.sf_width,
	    sc->sc_sunfb.sf_height, sc->sc_sunfb.sf_depth);

d348 2
a349 1
		fbwscons_console_init(&sc->sc_sunfb, &cgfourteen_stdscreen, -1,
d375 1
a375 1
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
d382 1
a382 1
		wdf->cmsize = 256;
d389 6
a394 4
		cm = (struct wsdisplay_cmap *)data;
		error = cgfourteen_getcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
d398 8
a405 6
		cm = (struct wsdisplay_cmap *)data;
		error = cgfourteen_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		/* XXX should use retrace interrupt */
		cgfourteen_loadcmap(sc, cm->index, cm->count);
d437 6
a442 7
#ifdef CG14_FULLCOLOR
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    0, 0, 0, attrp);
#else
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
#endif
a470 12
 *
 * The cg14 frame buffer can be mapped in either 8-bit or 32-bit mode
 * starting at the address stored in the PROM. In 8-bit mode, the X
 * channel is not present, and can be ignored. In 32-bit mode, mapping
 * at 0K delivers a 32-bpp buffer where the upper 8 bits select the X
 * channel information. We hardwire the Xlut to all zeroes to insure
 * that, regardless of this value, direct 24-bit color access will be
 * used.
 *
 * Alternatively, mapping the frame buffer at an offset of 16M seems to
 * tell the chip to ignore the X channel. XXX where does it get the X value
 * to use?
d497 24
a520 18
#ifdef CG14_FULLCOLOR
	/*
	 * Enable the video, and put in 24 bit mode.
	 */
	sc->sc_ctl->ctl_mctl = CG14_MCTL_ENABLEVID | CG14_MCTL_PIXMODE_32 |
	    CG14_MCTL_POWERCTL;

	/*
	 * Zero the xlut to enable direct-color mode
	 */
	bzero(sc->sc_xlut, CG14_CLUT_SIZE);
#else
	/*
	 * Enable the video and put it in 8 bit mode
	 */
	sc->sc_ctl->ctl_mctl = CG14_MCTL_ENABLEVID | CG14_MCTL_PIXMODE_8 |
	    CG14_MCTL_POWERCTL;
#endif
d608 1
a608 1
	
@


1.11
log
@Convert sparc console code from rcons and pseudo-devices to rasops and wscons.
For most framebuffers it is faster.

Other changes include:
o 24 bit support in tcx(4) for the S24 framebuffer
o accelerated cgsix(4) text console
o new cgtwelve(4) driver for the GS framebuffer
o improved serial driver code
o better keyboard support

The following framebuffers have not been tested but should work: cgfour,
cgeight and cgfourteen

These changes will require XF4 changes, to use Xwsfb instead of Xsun*, to be
commited later today.

Most of the work by me during the LSM and the week after, with code borrowed
from jason@@, NetBSD (new serial code), and feedback from mickey@@. Work on
pnozz(4) done by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.10 2002/08/02 16:13:07 millert Exp $	*/
a118 1
#define	CG3REG_MEM	0x800000
d250 2
d263 2
a264 2
	sc->sc_ctl = (struct cg14ctl *) mapiodev(ca->ca_ra.ra_reg, 0,
						 ca->ca_ra.ra_len);
d284 4
a287 4
	if (ca->ca_ra.ra_nreg < 2)
		panic("\ncgfourteen: expected 2 registers, got %d",
			ca->ca_ra.ra_nreg);
	sc->sc_phys = ca->ca_ra.ra_reg[1];
d312 2
a313 3
	/* XXX is this right? */
	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(ca->ca_ra.ra_reg,
	    CG3REG_MEM, round_page(sc->sc_sunfb.sf_fbsize));
@


1.10
log
@Do correct bounds checking in get/set/put cmap routines.  A few of
these check were already OK but have been modified for consistency.
Problem found by Silvio Cesare.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.9 2002/03/14 01:26:42 millert Exp $	*/
d5 25
a29 1
 * Copyright (c) 1996 
d87 2
a90 7
/* 
 * The following is for debugging only; it opens up a security hole
 * enabled by allowing any user to map the control registers for the 
 * cg14 into their space.
 */
#undef CG14_MAP_REGS

d92 1
a92 5
 * The following enables 24-bit operation: when opened, the framebuffer
 * will switch to 24-bit mode (actually 32-bit mode), and provide a 
 * simple cg8 emulation.
 *
 * XXX Note that the code enabled by this define is currently untested/broken.
d94 1
a94 1
#undef CG14_CG8
a107 1
#include <machine/fbio.h>
a109 1
#include <machine/fbvar.h>
d113 7
a120 1
#include <sparc/dev/cgfourteenvar.h>
d122 68
a189 4
/* autoconfiguration driver */
static void	cgfourteenattach(struct device *, struct device *, void *);
static int	cgfourteenmatch(struct device *, void *, void *);
static void	cgfourteenunblank(struct device *);
a198 20
/* frame buffer generic driver */
static struct fbdriver cgfourteenfbdriver = {
	cgfourteenunblank, cgfourteenopen, cgfourteenclose, cgfourteenioctl, 
	cgfourteenmmap
};

extern int fbnode;
extern struct tty *fbconstty;

static void cg14_set_video(struct cgfourteen_softc *, int);
static int  cg14_get_video(struct cgfourteen_softc *);
static int  cg14_get_cmap(struct fbcmap *, union cg14cmap *, int);
static int  cg14_put_cmap(struct fbcmap *, union cg14cmap *, int);
static void cg14_load_hwcmap(struct cgfourteen_softc *, int, int);
static void cg14_init(struct cgfourteen_softc *);
static void cg14_reset(struct cgfourteen_softc *);
static void cg14_loadomap(struct cgfourteen_softc *);/* cursor overlay */
static void cg14_setcursor(struct cgfourteen_softc *);/* set position */
static void cg14_loadcursor(struct cgfourteen_softc *);/* set shape */

a215 1
	/* Check driver name */
d226 2
a227 1
		return(1);
d232 1
a232 1
 * Attach a display.  We need to notice if it is the console, too.
d239 7
a245 5
	register struct cgfourteen_softc *sc = (struct cgfourteen_softc *)self;
	register struct confargs *ca = args;
	register int node = 0, ramsize;
	register u_int32_t *lut;
	int i, isconsole;
d247 1
a247 12
	sc->sc_fb.fb_driver = &cgfourteenfbdriver;
	sc->sc_fb.fb_device = &sc->sc_dev;
	sc->sc_fb.fb_flags = sc->sc_dev.dv_cfdata->cf_flags;

	/*
	 * We're emulating a cg3/8, so represent ourselves as one
	 */
#ifdef CG14_CG8
	sc->sc_fb.fb_type.fb_type = FBTYPE_MEMCOLOR;
#else
	sc->sc_fb.fb_type.fb_type = FBTYPE_SUN3COLOR;
#endif
d250 2
a251 10
#ifdef CG14_CG8
	sc->sc_fb.fb_type.fb_depth = 32;
#else
	sc->sc_fb.fb_type.fb_depth = 8;
#endif
	fb_setsize(&sc->sc_fb, sc->sc_fb.fb_type.fb_depth,
	    1152, 900, node, ca->ca_bustype);

	ramsize = round_page(sc->sc_fb.fb_type.fb_height *
			     sc->sc_fb.fb_linebytes);
d253 1
a253 2
	sc->sc_fb.fb_type.fb_cmsize = CG14_CLUT_SIZE;
	sc->sc_fb.fb_type.fb_size = ramsize;
d256 1
a256 1
	 * Now map in the 8 useful pages of registers
d259 2
a260 4
#ifdef DIAGNOSTIC
		printf("warning: can't find all cgfourteen registers...\n");
#endif
		ca->ca_ra.ra_len = 0x10000;
d262 1
a262 1
	sc->sc_ctl = (struct cg14ctl *) mapiodev(ca->ca_ra.ra_reg, 0, 
d265 1
a265 1
	sc->sc_hwc = (struct cg14curs *) ((u_int)sc->sc_ctl + 
d279 1
a279 1
	
d284 2
a285 2
		panic("cgfourteen with only one register set; can't find"
		      " framebuffer");
a287 15
#if defined(DEBUG) && defined(CG14_MAP_REGS)
	/* Store the physical address of the control registers */
	sc->sc_regphys = ca->ca_ra.ra_reg[0];
#endif

	/*
	 * Let the user know that we're here
	 */
#ifdef CG14_CG8
	printf(": cgeight emulated at %dx%dx24bpp",
	    sc->sc_fb.fb_type.fb_width, sc->sc_fb.fb_type.fb_height);
#else
	printf(": cgthree emulated at %dx%dx8bpp",
	       sc->sc_fb.fb_type.fb_width, sc->sc_fb.fb_type.fb_height);
#endif
d289 1
a289 1
	 * Enable the video, but don't change the pixel depth.
d291 1
a291 1
	cg14_set_video(sc, 1);
a299 3
	/* See if we're the console */
	isconsole = node == fbnode && fbconstty != NULL;

d301 1
a301 2
	 * We don't use the raster console since the cg14 is fast enough
	 * already.
d303 1
a303 13
#ifdef notdef
	/*
	 * When the ROM has mapped in a cgfourteen display, the address
	 * maps only the video RAM, so in any case we have to map the
	 * registers ourselves.  We only need the video RAM if we are
	 * going to print characters via rconsole.
	 */
	if ((sc->sc_fb.fb_pixels = ca->ca_ra.ra_vaddr) == NULL && isconsole) {
		/* this probably cannot happen, but what the heck */
		sc->sc_fb.fb_pixels = mapiodev(ca->ca_ra.ra_reg, CG3REG_MEM,
					       ramsize);
	}
#endif /* notdef */
d305 4
a308 6

	if (isconsole) {
		printf(" (console)\n");
#ifdef notdef
#ifdef RASTERCONSOLE
		fbrcons_init(&sc->sc_fb);
d310 10
a319 8
#endif /* notdef */
	} else
		printf("\n");

	/* Attach to /dev/fb */
	if (node == fbnode)
		fb_attach(&sc->sc_fb, isconsole);
}
d321 2
a322 7
/*
 * Keep track of the number of opens made. In the 24-bit driver, we need to 
 * switch to 24-bit mode on the first open, and switch back to 8-bit on
 * the last close. This kind of nonsense is needed to give screenblank
 * a fighting chance of working.
 */
static int cg14_opens = 0;
d324 4
a327 39
int
cgfourteenopen(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	register struct cgfourteen_softc *sc = cgfourteen_cd.cd_devs[minor(dev)];
	int unit = minor(dev);
	int s, oldopens;

	if (unit >= cgfourteen_cd.cd_ndevs || 
	    cgfourteen_cd.cd_devs[unit] == NULL)
		return (ENXIO);

	s = splhigh();
	oldopens = cg14_opens++;
	splx(s);

	/* Setup the cg14 as we want it, and save the original PROM state */
	if (oldopens == 0)	/* first open only, to make screenblank work */
		cg14_init(sc);

	return (0);
}

int
cgfourteenclose(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	register struct cgfourteen_softc *sc = cgfourteen_cd.cd_devs[minor(dev)];
	int s, opens;

	s = splhigh();
	opens = --cg14_opens;
	if (cg14_opens < 0)
		opens = cg14_opens = 0;
	splx(s);
d329 5
a333 7
	/*
	 * Restore video state to make the PROM happy, on last close.
	 */
	if (opens == 0)
		cg14_reset(sc);

	return (0);
d337 2
a338 2
cgfourteenioctl(dev, cmd, data, flags, p)
	dev_t dev;
d340 1
a340 1
	register caddr_t data;
d344 4
a347 5
	register struct cgfourteen_softc *sc = cgfourteen_cd.cd_devs[minor(dev)];
	register struct fbgattr *fba;
	union cg14cursor_cmap tcm;
	int v, error;
	u_int count;
d350 12
a361 3

	case FBIOGTYPE:
		*(struct fbtype *)data = sc->sc_fb.fb_type;
d364 5
a368 10
	case FBIOGATTR:
		fba = (struct fbgattr *)data;
		fba->real_type = FBTYPE_MDICOLOR;
		fba->owner = 0;		/* XXX ??? */
		fba->fbtype = sc->sc_fb.fb_type;
		fba->sattr.flags = 0;
		fba->sattr.emu_type = sc->sc_fb.fb_type.fb_type;
		fba->sattr.dev_specific[0] = -1;
		fba->emu_types[0] = sc->sc_fb.fb_type.fb_type;
		fba->emu_types[1] = -1;
d371 3
a373 11
	case FBIOGETCMAP:
		return (cg14_get_cmap((struct fbcmap *)data, &sc->sc_cmap, 
				     CG14_CLUT_SIZE));

	case FBIOPUTCMAP:
		/* copy to software map */
#define p ((struct fbcmap *)data)
#ifdef CG14_CG8
		p->index &= 0xffffff;
#endif
		error = cg14_put_cmap(p, &sc->sc_cmap, CG14_CLUT_SIZE);
a375 1
		/* now blast them into the chip */
d377 1
a377 115
		cg14_load_hwcmap(sc, p->index, p->count);
#undef p
		break;

	case FBIOGVIDEO:
		*(int *)data = cg14_get_video(sc);
		break;

	case FBIOSVIDEO:
		cg14_set_video(sc, *(int *)data);
		break;

/* these are for both FBIOSCURSOR and FBIOGCURSOR */
#define p ((struct fbcursor *)data)
#define cc (&sc->sc_cursor)
	case FBIOGCURSOR:
		/* do not quite want everything here... */
		p->set = FB_CUR_SETALL;	/* close enough, anyway */
		p->enable = cc->cc_enable;
		p->pos = cc->cc_pos;
		p->hot = cc->cc_hot;
		p->size = cc->cc_size;

		/* begin ugh ... can we lose some of this crap?? */
		if (p->image != NULL) {
			count = cc->cc_size.y * 32 / NBBY;
			error = copyout((caddr_t)cc->cc_cplane,
			    (caddr_t)p->image, count);
			if (error)
				return (error);
			error = copyout((caddr_t)cc->cc_eplane,
			    (caddr_t)p->mask, count);
			if (error)
				return (error);
		}
		if (p->cmap.red != NULL) {
			error = cg14_get_cmap(&p->cmap,
			    (union cg14cmap *)&cc->cc_color, 2);
			if (error)
				return (error);
		} else {
			p->cmap.index = 0;
			p->cmap.count = 2;
		}
		/* end ugh */
		break;

	case FBIOSCURSOR:
		/*
		 * For setcmap and setshape, verify parameters, so that
		 * we do not get halfway through an update and then crap
		 * out with the software state screwed up.
		 */
		v = p->set;
		if (v & FB_CUR_SETCMAP) {
			/*
			 * This use of a temporary copy of the cursor
			 * colormap is not terribly efficient, but these
			 * copies are small (8 bytes)...
			 */
			tcm = cc->cc_color;
			error = cg14_put_cmap(&p->cmap, (union cg14cmap *)&tcm,
					      2);
			if (error)
				return (error);
		}
		if (v & FB_CUR_SETSHAPE) {
			if ((u_int)p->size.x > 32 || (u_int)p->size.y > 32)
				return (EINVAL);
			count = p->size.y * 32 / NBBY;
			if (!uvm_useracc(p->image, count, B_READ) ||
			    !uvm_useracc(p->mask, count, B_READ))
				return (EFAULT);
		}

		/* parameters are OK; do it */
		if (v & (FB_CUR_SETCUR | FB_CUR_SETPOS | FB_CUR_SETHOT)) {
			if (v & FB_CUR_SETCUR)
				cc->cc_enable = p->enable;
			if (v & FB_CUR_SETPOS)
				cc->cc_pos = p->pos;
			if (v & FB_CUR_SETHOT)
				cc->cc_hot = p->hot;
			cg14_setcursor(sc);
		}
		if (v & FB_CUR_SETCMAP) {
			cc->cc_color = tcm;
			cg14_loadomap(sc); /* XXX defer to vertical retrace */
		}
		if (v & FB_CUR_SETSHAPE) {
			cc->cc_size = p->size;
			count = p->size.y * 32 / NBBY;
			bzero((caddr_t)cc->cc_eplane, sizeof cc->cc_eplane);
			bzero((caddr_t)cc->cc_cplane, sizeof cc->cc_cplane);
			bcopy(p->mask, (caddr_t)cc->cc_eplane, count);
			bcopy(p->image, (caddr_t)cc->cc_cplane, count);
			cg14_loadcursor(sc);
		}
		break;

#undef cc
#undef p
	case FBIOGCURPOS:
		*(struct fbcurpos *)data = sc->sc_cursor.cc_pos;
		break;

	case FBIOSCURPOS:
		sc->sc_cursor.cc_pos = *(struct fbcurpos *)data;
		cg14_setcursor(sc);
		break;

	case FBIOGCURMAX:
		/* max cursor size is 32x32 */
		((struct fbcurpos *)data)->x = 32;
		((struct fbcurpos *)data)->y = 32;
d380 7
d388 1
a388 1
		return (ENOTTY);
d393 31
a423 6
/*
 * Undo the effect of an FBIOSVIDEO that turns the video off.
 */
static void
cgfourteenunblank(dev)
	struct device *dev;
d425 1
d427 12
a438 1
	cg14_set_video((struct cgfourteen_softc *)dev, 1);
d452 2
a453 2
 * 
 * Alternatively, mapping the frame buffer at an offset of 16M seems to 
d458 3
a460 3
cgfourteenmmap(dev, off, prot)
	dev_t dev;
	off_t off;
d463 1
a463 1
	register struct cgfourteen_softc *sc = cgfourteen_cd.cd_devs[minor(dev)];
d465 1
a465 8
#define CG3START		(128*1024 + 128*1024)
#define CG8START		(256*1024)
#define NOOVERLAY	(0x04000000)

	if (off & PGOFSET)
		panic("cgfourteenmmap");

	if (off < 0)
d468 3
a470 32
#if defined(DEBUG) && defined(CG14_MAP_REGS) /* XXX: security hole */
	/*
	 * Map the control registers into user space. Should only be 
	 * used for debugging!
	 */
	if ((u_int)off >= 0x10000000 && (u_int)off < 0x10000000 + 16*4096) {
		off -= 0x10000000;
		return (REG2PHYS(&sc->sc_regphys, off, 0) | PMAP_NC);
	}
#endif
	
	if ((u_int)off >= NOOVERLAY)
		off -= NOOVERLAY;
#ifdef CG14_CG8
	else if ((u_int)off >= CG8START) {
		off -= CG8START;
	}
#else
	else if ((u_int)off >= CG3START)
		off -= CG3START;
#endif
	else
		off = 0;

	if ((unsigned)off >= sc->sc_fb.fb_type.fb_size *
		sc->sc_fb.fb_type.fb_depth/8) {
#ifdef DEBUG
		printf("\nmmap request out of bounds: request 0x%x, "
		    "bound 0x%x\n", (unsigned) off, 
		    (unsigned)sc->sc_fb.fb_type.fb_size);
#endif
		return (-1);
d473 1
a473 5
	/*
	 * Use PMAP_NC to disable the cache, since otherwise refresh is
	 * very confused.
	 */
	return (REG2PHYS(&sc->sc_phys, off) | PMAP_NC);
a475 4
/*
 * Miscellaneous helper functions 
 */

d477 2
a478 2
static void 
cg14_init(sc)
a480 21
	register u_int32_t *clut;
	register u_int8_t  *xlut;
	register int i;

	/*
	 * We stash away the following to restore on close:
	 *
	 * 	color look-up table 1 	(sc->sc_saveclut)
	 *	x look-up table		(sc->sc_savexlut)
	 *	control register	(sc->sc_savectl)
	 *	cursor control register (sc->sc_savehwc)
	 */
	sc->sc_savectl = sc->sc_ctl->ctl_mctl;
	sc->sc_savehwc = sc->sc_hwc->curs_ctl;

	clut = (u_int32_t *) sc->sc_clut1->clut_lut;
	xlut = (u_int8_t *) sc->sc_xlut->xlut_lut;
	for (i = 0; i < CG14_CLUT_SIZE; i++) {
		sc->sc_saveclut.cm_chip[i] = clut[i];
		sc->sc_savexlut[i] = xlut[i];
	}
d482 1
a482 1
#ifdef CG14_CG8
d487 1
a487 1
		CG14_MCTL_POWERCTL;
d489 1
a489 1
	/* 
d498 1
a498 1
		CG14_MCTL_POWERCTL;
d502 4
a505 3
static void
cg14_reset(sc)	/* Restore the state saved on cg14_init */
	struct cgfourteen_softc *sc;
d507 1
a507 28
	register u_int32_t *clut;
	register u_int8_t  *xlut;
	register int i;

	/*
	 * We restore the following, saved in cg14_init:
	 *
	 * 	color look-up table 1 	(sc->sc_saveclut)
	 *	x look-up table		(sc->sc_savexlut)
	 *	control register	(sc->sc_savectl)
	 *	cursor control register (sc->sc_savehwc)
	 *
	 * Note that we don't touch the video enable bits in the
	 * control register; otherwise, screenblank wouldn't work.
	 */
	sc->sc_ctl->ctl_mctl = (sc->sc_ctl->ctl_mctl & (CG14_MCTL_ENABLEVID |
							CG14_MCTL_POWERCTL)) |
				(sc->sc_savectl & ~(CG14_MCTL_ENABLEVID |
						    CG14_MCTL_POWERCTL));
	sc->sc_hwc->curs_ctl = sc->sc_savehwc;

	clut = (u_int32_t *) sc->sc_clut1->clut_lut;
	xlut = (u_int8_t *) sc->sc_xlut->xlut_lut;
	for (i = 0; i < CG14_CLUT_SIZE; i++) {
		clut[i] = sc->sc_saveclut.cm_chip[i];
		xlut[i] = sc->sc_savexlut[i];
	}
}
d509 1
a509 7
/* Enable/disable video display; power down monitor if DPMS-capable */
static void
cg14_set_video(sc, enable)
	struct cgfourteen_softc *sc;
	int enable;
{
	/* 
d513 1
a513 1
	if (enable) {
a527 8
/* Get status of video display */
static int
cg14_get_video(sc)
	struct cgfourteen_softc *sc;
{
	return ((sc->sc_ctl->ctl_mctl & CG14_MCTL_ENABLEVID) != 0);
}

d529 2
a530 3
static int 
cg14_get_cmap(p, cm, cmsize)
	register struct fbcmap *p;
d532 1
a532 1
	int cmsize;
d534 4
a537 11
        register u_int i, start, count;
        register u_char *cp;
 
        start = p->index;
        count = p->count;
	if (start >= cmsize || count > cmsize - start)
#ifdef DEBUG
	{
		printf("putcmaperror: start %u cmsize %d count %u\n",
		    start, cmsize, count);
#endif
d539 11
a549 1
#ifdef DEBUG
d551 1
a551 12
#endif

        if (!uvm_useracc(p->red, count, B_WRITE) ||
            !uvm_useracc(p->green, count, B_WRITE) ||
            !uvm_useracc(p->blue, count, B_WRITE))
                return (EFAULT);
        for (cp = &cm->cm_map[start][0], i = 0; i < count; cp += 4, i++) {
                p->red[i] = cp[3];
                p->green[i] = cp[2];
                p->blue[i] = cp[1];
        }
        return (0);
d555 2
a556 3
static int
cg14_put_cmap(p, cm, cmsize)
        register struct fbcmap *p;
d558 1
a558 1
        int cmsize;
d560 4
a563 11
        register u_int i, start, count;
        register u_char *cp;
 
        start = p->index;
        count = p->count;
	if (start >= cmsize || count > cmsize - start)
#ifdef DEBUG
	{
		printf("putcmaperror: start %u cmsize %d count %u\n",
		    start, cmsize, count);
#endif
d565 12
a576 1
#ifdef DEBUG
d578 2
a579 1
#endif
d581 4
a584 17
        if (!uvm_useracc(p->red, count, B_READ) ||
            !uvm_useracc(p->green, count, B_READ) ||
            !uvm_useracc(p->blue, count, B_READ))
                return (EFAULT);
        for (cp = &cm->cm_map[start][0], i = 0; i < count; cp += 4, i++) {
                cp[3] = p->red[i];
                cp[2] = p->green[i];
                cp[1] = p->blue[i];
		cp[0] = 0;	/* no alpha channel */
        }
        return (0);
}

static void
cg14_load_hwcmap(sc, start, ncolors)
	register struct cgfourteen_softc *sc;
	register int start, ncolors;
d589 2
a590 2
	register u_int32_t *colp = &sc->sc_cmap.cm_chip[start];
	volatile register u_int32_t *lutp = &sc->sc_clut1->clut_lut[start];
d597 16
a612 52
/*
 * Load the cursor (overlay `foreground' and `background') colors.
 */
static void
cg14_setcursor(sc)
	register struct cgfourteen_softc *sc;
{
	/* we need to subtract the hot-spot value here */
#define COORD(f) (sc->sc_cursor.cc_pos.f - sc->sc_cursor.cc_hot.f)

	sc->sc_hwc->curs_ctl = (sc->sc_cursor.cc_enable ? CG14_CURS_ENABLE : 0);
	sc->sc_hwc->curs_x = COORD(x);
	sc->sc_hwc->curs_y = COORD(y);

#undef COORD
}

static void
cg14_loadcursor(sc)
	register struct cgfourteen_softc *sc;
{
	register volatile struct cg14curs *hwc;
	register u_int edgemask, m;
	register int i;

	/*
	 * Keep the top size.x bits.  Here we *throw out* the top
	 * size.x bits from an all-one-bits word, introducing zeros in
	 * the top size.x bits, then invert all the bits to get what
	 * we really wanted as our mask.  But this fails if size.x is
	 * 32---a sparc uses only the low 5 bits of the shift count---
	 * so we have to special case that.
	 */
	edgemask = ~0;
	if (sc->sc_cursor.cc_size.x < 32)
		edgemask = ~(edgemask >> sc->sc_cursor.cc_size.x);
	hwc = sc->sc_hwc;
	for (i = 0; i < 32; i++) {
		m = sc->sc_cursor.cc_eplane[i] & edgemask;
		hwc->curs_plane0[i] = m;
		hwc->curs_plane1[i] = m & sc->sc_cursor.cc_cplane[i];
	}
}

static void
cg14_loadomap(sc)
	register struct cgfourteen_softc *sc;
{
	/* set background color */
	sc->sc_hwc->curs_color1 = sc->sc_cursor.cc_color.cm_chip[0];
	/* set foreground color */
	sc->sc_hwc->curs_color2 = sc->sc_cursor.cc_color.cm_chip[1];
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.8 2001/11/06 19:53:16 miod Exp $	*/
d751 1
a751 1
        if (start >= cmsize || start + count > cmsize)
d754 2
a755 2
		printf("putcmaperror: start %d cmsize %d count %d\n",
		    start,cmsize,count);
d786 1
a786 1
        if (start >= cmsize || start + count > cmsize)
d789 2
a790 2
		printf("putcmaperror: start %d cmsize %d count %d\n",
		    start,cmsize,count);
@


1.8
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.7 2001/11/01 12:13:46 art Exp $	*/
d125 10
a134 10
static void cg14_set_video __P((struct cgfourteen_softc *, int));
static int  cg14_get_video __P((struct cgfourteen_softc *));
static int  cg14_get_cmap __P((struct fbcmap *, union cg14cmap *, int));
static int  cg14_put_cmap __P((struct fbcmap *, union cg14cmap *, int));
static void cg14_load_hwcmap __P((struct cgfourteen_softc *, int, int));
static void cg14_init __P((struct cgfourteen_softc *));
static void cg14_reset __P((struct cgfourteen_softc *));
static void cg14_loadomap __P((struct cgfourteen_softc *));/* cursor overlay */
static void cg14_setcursor __P((struct cgfourteen_softc *));/* set position */
static void cg14_loadcursor __P((struct cgfourteen_softc *));/* set shape */
@


1.8.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.8 2001/11/06 19:53:16 miod Exp $	*/
d125 10
a134 10
static void cg14_set_video(struct cgfourteen_softc *, int);
static int  cg14_get_video(struct cgfourteen_softc *);
static int  cg14_get_cmap(struct fbcmap *, union cg14cmap *, int);
static int  cg14_put_cmap(struct fbcmap *, union cg14cmap *, int);
static void cg14_load_hwcmap(struct cgfourteen_softc *, int, int);
static void cg14_init(struct cgfourteen_softc *);
static void cg14_reset(struct cgfourteen_softc *);
static void cg14_loadomap(struct cgfourteen_softc *);/* cursor overlay */
static void cg14_setcursor(struct cgfourteen_softc *);/* set position */
static void cg14_loadcursor(struct cgfourteen_softc *);/* set shape */
@


1.8.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.8.2.1 2002/06/11 03:38:15 art Exp $	*/
d5 1
a5 25
 * Copyright (c) 2002 Miodrag Vallat.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Copyright (c) 1996
d63 13
d77 1
a77 1
 * XXX should bring hardware cursor code back
d79 1
d93 1
d96 1
a99 6
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

d101 1
d103 4
a106 1
#include <dev/cons.h>	/* for prom console hook */
d108 2
a109 19
/*
 * per-display variables/state
 */
struct cgfourteen_softc {
	struct	sunfb sc_sunfb;		/* common base part */

	struct 	rom_reg	sc_phys;	/* phys address of frame buffer */
	union	cg14cmap sc_cmap;	/* current colormap */

	struct	cg14ctl  *sc_ctl; 	/* various registers */
	struct	cg14curs *sc_hwc;
	struct 	cg14dac	 *sc_dac;
	struct	cg14xlut *sc_xlut;
	struct 	cg14clut *sc_clut1;
	struct	cg14clut *sc_clut2;
	struct	cg14clut *sc_clut3;
	u_int	*sc_clutincr;

	int	sc_nscreens;
d112 2
a113 2
struct wsscreen_descr cgfourteen_stdscreen = {
	"std",
d116 4
a119 2
const struct wsscreen_descr *cgfourteen_scrlist[] = {
	&cgfourteen_stdscreen,
d122 2
a123 4
struct wsscreen_list cgfourteen_screenlist = {
	sizeof(cgfourteen_scrlist) / sizeof(struct wsscreen_descr *),
	    cgfourteen_scrlist
};
d125 10
a134 39
int cgfourteen_ioctl(void *, u_long, caddr_t, int, struct proc *);
int cgfourteen_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgfourteen_free_screen(void *, void *);
int cgfourteen_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t cgfourteen_mmap(void *, off_t, int);
int cgfourteen_is_console(int);
void cgfourteen_reset(struct cgfourteen_softc *);
void cgfourteen_burner(void *, u_int, u_int);
void cgfourteen_prom(void *);

int  cgfourteen_getcmap(union cg14cmap *, struct wsdisplay_cmap *);
int  cgfourteen_putcmap(union cg14cmap *, struct wsdisplay_cmap *);
void cgfourteen_loadcmap(struct cgfourteen_softc *, int, int);
void cgfourteen_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);

struct wsdisplay_accessops cgfourteen_accessops = {
	cgfourteen_ioctl,
	cgfourteen_mmap,
	cgfourteen_alloc_screen,
	cgfourteen_free_screen,
	cgfourteen_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	cgfourteen_burner,
};

void	cgfourteenattach(struct device *, struct device *, void *);
int	cgfourteenmatch(struct device *, void *, void *);

struct cfattach cgfourteen_ca = {
	sizeof(struct cgfourteen_softc), cgfourteenmatch, cgfourteenattach
};

struct cfdriver cgfourteen_cd = {
	NULL, "cgfourteen", DV_DULL
};
d148 6
d164 1
a164 2
		return (1);

d169 1
a169 1
 * Attach a display.
d176 9
a184 7
	struct cgfourteen_softc *sc = (struct cgfourteen_softc *)self;
	struct confargs *ca = args;
	struct wsemuldisplaydev_attach_args waa;
	int fb_depth, node, i;
	u_int32_t *lut;
	int isconsole = 0;
	char *nam;
d186 8
a193 1
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags & FB_USERMASK;
d196 7
a202 4
	nam = getpropstring(node, "model");
	if (*nam == '\0')
		nam = getpropstring(node, "name");
	printf(": %s", nam);
d204 2
a205 1
	isconsole = node == fbnode;
d207 2
a208 11
	/*
	 * Sanity checks
	 */
	if (ca->ca_ra.ra_len < 0x10000)
		panic("cgfourteen: expected %x bytes of control "
		    "registers, got %x", 0x10000, ca->ca_ra.ra_len);
	if (ca->ca_ra.ra_nreg < CG14_NREG)
		panic("cgfourteen: expected %d registers, got %d",
		    CG14_NREG, ca->ca_ra.ra_nreg);

	printf(", %dMB", ca->ca_ra.ra_reg[CG14_REG_VRAM].rr_len >> 20);
d211 1
a211 1
	 * Map in the 8 useful pages of registers
d213 8
a220 2
	sc->sc_ctl = (struct cg14ctl *) mapiodev(
	    &ca->ca_ra.ra_reg[CG14_REG_CONTROL], 0, ca->ca_ra.ra_len);
d222 1
a222 1
	sc->sc_hwc = (struct cg14curs *) ((u_int)sc->sc_ctl +
d236 1
a236 1

d240 9
a248 8
	sc->sc_phys = ca->ca_ra.ra_reg[CG14_REG_VRAM];

	if (ISSET(sc->sc_sunfb.sf_flags, FB_FORCELOW))
		fb_depth = 8;
	else
		fb_depth = 32;

	fb_setsize(&sc->sc_sunfb, fb_depth, 1152, 900, node, ca->ca_bustype);
d251 1
a251 5
	 * The prom will report depth == 8, since this is the mode
	 * it will get initialized in.
	 * Try to compensate and enable 32 bit mode, unless it would
	 * not fit in the video memory. Note that, in this case, the
	 * VSIMM will usually not appear in the OBP device tree!
d253 7
a259 15
	if (fb_depth == 32 && sc->sc_sunfb.sf_depth == 8 &&
	    sc->sc_sunfb.sf_fbsize * 4 <=
	    ca->ca_ra.ra_reg[CG14_REG_VRAM].rr_len) {
		sc->sc_sunfb.sf_depth = 32;
		sc->sc_sunfb.sf_linebytes *= 4;
		sc->sc_sunfb.sf_fbsize *= 4;
	}

	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(&ca->ca_ra.ra_reg[CG14_REG_VRAM],
	    0,	/* CHUNKY_XBGR */
	    round_page(sc->sc_sunfb.sf_fbsize));

	printf(", %dx%d, depth %d\n", sc->sc_sunfb.sf_width,
	    sc->sc_sunfb.sf_height, sc->sc_sunfb.sf_depth);

d261 1
a261 1
	 * Reset frame buffer controls
d263 1
a263 1
	cgfourteen_reset(sc);
d272 3
d276 2
a277 1
	 * Enable the video.
d279 29
a307 1
	cgfourteen_burner(sc, 1, 0);
d309 41
a349 2
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, isconsole);
d351 5
a355 4
	cgfourteen_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgfourteen_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgfourteen_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgfourteen_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;
d357 5
a361 5
	if (isconsole) {
		fbwscons_console_init(&sc->sc_sunfb, &cgfourteen_stdscreen,
		    sc->sc_sunfb.sf_depth == 8 ? -1 : 0,
		    cgfourteen_setcolor, cgfourteen_burner);
	}
d363 1
a363 5
	waa.console = isconsole;
	waa.scrdata = &cgfourteen_screenlist;
	waa.accessops = &cgfourteen_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
d367 2
a368 2
cgfourteen_ioctl(dev, cmd, data, flags, p)
	void *dev;
d370 1
a370 1
	caddr_t data;
d374 5
a378 4
	struct cgfourteen_softc *sc = dev;
	struct wsdisplay_cmap *cm;
	struct wsdisplay_fbinfo *wdf;
	int error;
d381 3
a383 2
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_SUN24;
d385 11
a395 6
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width = sc->sc_sunfb.sf_width;
		wdf->depth = sc->sc_sunfb.sf_depth;
		wdf->cmsize = (sc->sc_sunfb.sf_depth == 8) ? 256 : 0;
d397 26
a422 2
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
d425 20
a444 4
	case WSDISPLAYIO_GETCMAP:
		if (sc->sc_sunfb.sf_depth == 8) {
			cm = (struct wsdisplay_cmap *)data;
			error = cgfourteen_getcmap(&sc->sc_cmap, cm);
d448 10
d460 16
a475 4
	case WSDISPLAYIO_PUTCMAP:
		if (sc->sc_sunfb.sf_depth == 8) {
			cm = (struct wsdisplay_cmap *)data;
			error = cgfourteen_putcmap(&sc->sc_cmap, cm);
a477 2
			/* XXX should use retrace interrupt */
			cgfourteen_loadcmap(sc, cm->index, cm->count);
d479 49
a529 7
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
d531 1
a531 1
		return (-1);	/* not supported yet */
d536 6
a541 30
int
cgfourteen_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
{
	struct cgfourteen_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	if (sc->sc_sunfb.sf_depth == 8)
		sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
		    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	else
		sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
		    0, 0, 0, attrp);
	sc->sc_nscreens++;
	return (0);
}

void
cgfourteen_free_screen(v, cookie)
	void *v;
	void *cookie;
a542 1
	struct cgfourteen_softc *sc = v;
d544 1
a544 12
	sc->sc_nscreens--;
}

int
cgfourteen_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
	return (0);
d550 12
d564 3
a566 3
cgfourteen_mmap(v, offset, prot)
	void *v;
	off_t offset;
d569 1
a569 1
	struct cgfourteen_softc *sc = v;
d571 8
a578 1
	if (offset & PGOFSET)
d581 16
a596 3
	/* Allow mapping as a dumb framebuffer from offset 0 */
	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys, offset) | PMAP_NC);
d598 6
d605 15
a619 1
	return (-1);
d622 4
d627 2
a628 2
void
cgfourteen_reset(sc)
d631 3
d635 10
a644 12
	if (sc->sc_sunfb.sf_depth == 8) {
		/*
		 * Enable the video and put it in 8 bit mode
		 */
		sc->sc_ctl->ctl_mctl = CG14_MCTL_ENABLEVID |
		    CG14_MCTL_PIXMODE_8 | CG14_MCTL_POWERCTL;
	} else {
		/*
		 * Enable the video, and put in 32 bit mode.
		 */
		sc->sc_ctl->ctl_mctl = CG14_MCTL_ENABLEVID |
		    CG14_MCTL_PIXMODE_32 | CG14_MCTL_POWERCTL;
d646 6
a651 5
		/*
		 * Clear the screen to white
		 */
		memset(sc->sc_sunfb.sf_ro.ri_bits, 0xff,
		    round_page(sc->sc_sunfb.sf_fbsize));
d653 6
a658 4
		/*
		 * Zero the xlut to enable direct-color mode
		 */
		bzero(sc->sc_xlut, CG14_CLUT_SIZE);
d660 11
a670 2
		shutdownhook_establish(cgfourteen_prom, sc);
	}
d673 3
a675 3
void
cgfourteen_prom(v)
	void *v;
d677 3
a679 2
	struct cgfourteen_softc *sc = v;
	extern struct consdev consdev_prom;
d681 22
a702 12
	if (sc->sc_sunfb.sf_depth != 8) {
		/*
		 * Go back to 8-bit mode.
		 */
		sc->sc_ctl->ctl_mctl = CG14_MCTL_ENABLEVID |
		    CG14_MCTL_PIXMODE_8 | CG14_MCTL_POWERCTL;

		/*
		 * Go back to prom output for the last few messages, so they
		 * will be displayed correctly.
		 */
		cn_tab = &consdev_prom;
d706 5
a710 4
void
cgfourteen_burner(v, on, flags)
	void *v;
	u_int on, flags;
d712 1
a712 3
	struct cgfourteen_softc *sc = v;

	/*
d716 1
a716 1
	if (on) {
d731 8
d740 3
a742 2
int
cgfourteen_getcmap(cm, rcm)
d744 1
a744 1
	struct wsdisplay_cmap *rcm;
d746 11
a756 4
	u_int index = rcm->index, count = rcm->count, i;
	int error;

	if (index >= CG14_CLUT_SIZE || count > CG14_CLUT_SIZE - index)
d758 3
d762 10
a771 12
	for (i = 0; i < count; i++) {
		if ((error = copyout(&cm->cm_map[index + i][3],
		    &rcm->red[i], 1)) != 0)
			return (error);
		if ((error = copyout(&cm->cm_map[index + i][2],
		    &rcm->green[i], 1)) != 0)
			return (error);
		if ((error = copyout(&cm->cm_map[index + i][1],
		    &rcm->blue[i], 1)) != 0)
			return (error);
	}
	return (0);
d775 3
a777 2
int
cgfourteen_putcmap(cm, rcm)
d779 1
a779 1
        struct wsdisplay_cmap *rcm;
d781 11
a791 4
	u_int index = rcm->index, count = rcm->count, i;
	int error;

	if (index >= CG14_CLUT_SIZE || count > CG14_CLUT_SIZE - index)
d793 1
a793 12

	for (i = 0; i < count; i++) {
		if ((error = copyin(&rcm->red[i],
		    &cm->cm_map[index + i][3], 1)) != 0)
			return (error);
		if ((error = copyin(&rcm->green[i],
		    &cm->cm_map[index + i][2], 1)) != 0)
			return (error);
		if ((error = copyin(&rcm->blue[i],
		    &cm->cm_map[index + i][1], 1)) != 0)
			return (error);
		cm->cm_map[index +i][0] = 0;	/* no alpha channel */
d795 1
a795 2
	return (0);
}
d797 17
a813 4
void
cgfourteen_loadcmap(sc, start, ncolors)
	struct cgfourteen_softc *sc;
	int start, ncolors;
d816 1
a816 1

d818 2
a819 2
	u_int32_t *colp = &sc->sc_cmap.cm_chip[start];
	volatile u_int32_t *lutp = &sc->sc_clut1->clut_lut[start];
d826 52
a877 16
void
cgfourteen_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
	u_int8_t r, g, b;
{
	struct cgfourteen_softc *sc = v;

	/* XXX - Wait for retrace? */

	sc->sc_cmap.cm_map[index][3] = r;
	sc->sc_cmap.cm_map[index][2] = g;
	sc->sc_cmap.cm_map[index][1] = b;
	sc->sc_cmap.cm_map[index][0] = 0;	/* no alpha channel */
	
	cgfourteen_loadcmap(sc, index, 1);
@


1.8.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d5 1
a5 1
 * Copyright (c) 2002, 2003 Miodrag Vallat.  All rights reserved.
d81 2
a135 3
	int	sc_32;			/* can do 32bit at this resolution */
	size_t	sc_vramsize;		/* total video memory size */

d159 2
a160 1
void cgfourteen_reset(struct cgfourteen_softc *, int);
a207 8
	 * This driver should not be attached without an "addr" locator,
	 * as this is the only way to differentiate the main and secondary
	 * VSIMM.
	 */
	if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != (int)ra->ra_paddr)
		return (0);

	/*
d230 1
a230 1
	int node, i;
a236 1
	printf(": ");
d239 3
a241 2
	if (*nam != '\0')
		printf("%s, ", nam);
d248 6
a253 10
	if (ca->ca_ra.ra_len < 0x10000) {
		printf("\n%s: expected %x bytes of control registers, got %x\n",
		    self->dv_xname, 0x10000, ca->ca_ra.ra_len);
		return;
	}
	if (ca->ca_ra.ra_nreg < CG14_NREG) {
		printf("\n%s: expected %d registers, got %d",
		    self->dv_xname, CG14_NREG, ca->ca_ra.ra_nreg);
		return;
	}
d255 1
a255 1
	printf("%dMB", ca->ca_ra.ra_reg[CG14_REG_VRAM].rr_len >> 20);
d283 6
a288 1
	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, ca->ca_bustype);
d291 4
a294 4
	 * The prom will report depth == 8, since this is the mode it will
	 * get initialized in.
	 * Check if we will be able to use 32 bit mode later (i.e. if it will
	 * fit in the video memory. Note that, if this is not the case, the
d297 7
a303 2
	sc->sc_vramsize = ca->ca_ra.ra_reg[CG14_REG_VRAM].rr_len;
	sc->sc_32 = sc->sc_sunfb.sf_fbsize * 4 <= sc->sc_vramsize;
d307 1
a307 1
	    sc->sc_vramsize);
d309 2
a310 1
	printf(", %dx%d\n", sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);
d315 1
a315 2
	sc->sc_sunfb.sf_depth = 0;	/* force action */
	cgfourteen_reset(sc, 8);
a330 1
	fbwscons_setcolormap(&sc->sc_sunfb, cgfourteen_setcolor);
d339 2
a340 2
		    -1, cgfourteen_burner);
		shutdownhook_establish(cgfourteen_prom, sc);
a362 5
	/*
	 * Note that, although the emulation (text) mode is running in a
	 * 8-bit plane, we advertize the frame buffer as 32-bit if it can
	 * support this mode.
	 */
d365 1
a365 4
		if (sc->sc_32)
			*(u_int *)data = WSDISPLAY_TYPE_SUN24;
		else
			*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
d371 2
a372 2
		wdf->depth = sc->sc_32 ? 32 : 8;
		wdf->cmsize = sc->sc_32 ? 0 : 256;
d375 1
a375 4
		if (sc->sc_32)
			*(u_int *)data = sc->sc_sunfb.sf_linebytes * 4;
		else
			*(u_int *)data = sc->sc_sunfb.sf_linebytes;
d379 6
a384 4
		cm = (struct wsdisplay_cmap *)data;
		error = cgfourteen_getcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
d388 7
a394 16
		cm = (struct wsdisplay_cmap *)data;
		error = cgfourteen_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		/* XXX should use retrace interrupt */
		cgfourteen_loadcmap(sc, cm->index, cm->count);
		break;

	case WSDISPLAYIO_SMODE:
		if (*(int *)data == WSDISPLAYIO_MODE_EMUL) {
			/* Back from X11 to text mode */
			cgfourteen_reset(sc, 8);
		} else {
			/* Starting X11, try to switch to 32 bit mode */
			if (sc->sc_32)
				cgfourteen_reset(sc, 32);
d398 7
d427 6
a432 2
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
d474 1
a474 1
	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize * 4) {
d483 1
a483 1
cgfourteen_reset(sc, depth)
a484 1
	int depth;
d487 25
a511 28
	if (sc->sc_sunfb.sf_depth != depth) {
		if (depth == 8) {
			/*
			 * Enable the video and put it in 8 bit mode
			 */
			sc->sc_ctl->ctl_mctl = CG14_MCTL_ENABLEVID |
			    CG14_MCTL_PIXMODE_8 | CG14_MCTL_POWERCTL;

			fbwscons_setcolormap(&sc->sc_sunfb,
			    cgfourteen_setcolor);
		} else {
			/*
			 * Clear the screen to black
			 */
			bzero(sc->sc_sunfb.sf_ro.ri_bits,
			    sc->sc_sunfb.sf_fbsize);

			/*
			 * Enable the video, and put in 32 bit mode.
			 */
			sc->sc_ctl->ctl_mctl = CG14_MCTL_ENABLEVID |
			    CG14_MCTL_PIXMODE_32 | CG14_MCTL_POWERCTL;

			/*
			 * Zero the xlut to enable direct-color mode
			 */
			bzero(sc->sc_xlut, CG14_CLUT_SIZE);
		}
a512 2

	sc->sc_sunfb.sf_depth = depth;
d526 2
a527 1
		cgfourteen_reset(sc, 8);
@


1.7
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.6 2001/08/17 13:52:28 mickey Exp $	*/
d91 1
a91 1
#include <vm/vm.h>
@


1.6
log
@cdev_decl cleanup; jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.5 2001/05/10 10:34:43 art Exp $	*/
d563 1
a563 1
int
d566 2
a567 1
	int off, prot;
@


1.5
log
@UVM is no longer optional on sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.4 1999/09/10 23:32:01 art Exp $	*/
a106 3

/* cdevsw prototypes */
cdev_decl(cgfourteen);
@


1.4
log
@roundup(foo, NBPG) -> round_page(foo)
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.3 1999/04/22 16:52:47 art Exp $	*/
a485 1
#if defined(UVM)
a488 5
#else
			if (!useracc(p->image, count, B_READ) ||
			    !useracc(p->mask, count, B_READ))
				return (EFAULT);
#endif
a763 1
#if defined(UVM)
a767 6
#else
        if (!useracc(p->red, count, B_WRITE) ||
            !useracc(p->green, count, B_WRITE) ||
            !useracc(p->blue, count, B_WRITE))
                return (EFAULT);
#endif
a798 1
#if defined(UVM)
a802 6
#else
        if (!useracc(p->red, count, B_READ) ||
            !useracc(p->green, count, B_READ) ||
            !useracc(p->blue, count, B_READ))
                return (EFAULT);
#endif
@


1.4.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.4 1999/09/10 23:32:01 art Exp $	*/
d486 1
d490 5
d770 1
d775 6
d812 1
d817 6
@


1.4.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.4.4.1 2001/07/04 10:23:21 niklas Exp $	*/
d107 3
@


1.4.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d91 1
a91 1
#include <uvm/uvm_extern.h>
d563 1
a563 1
paddr_t
d566 1
a566 2
	off_t off;
	int prot;
@


1.4.4.4
log
@Merge in -current from about a week ago
@
text
@d125 10
a134 10
static void cg14_set_video(struct cgfourteen_softc *, int);
static int  cg14_get_video(struct cgfourteen_softc *);
static int  cg14_get_cmap(struct fbcmap *, union cg14cmap *, int);
static int  cg14_put_cmap(struct fbcmap *, union cg14cmap *, int);
static void cg14_load_hwcmap(struct cgfourteen_softc *, int, int);
static void cg14_init(struct cgfourteen_softc *);
static void cg14_reset(struct cgfourteen_softc *);
static void cg14_loadomap(struct cgfourteen_softc *);/* cursor overlay */
static void cg14_setcursor(struct cgfourteen_softc *);/* set position */
static void cg14_loadcursor(struct cgfourteen_softc *);/* set shape */
@


1.4.4.5
log
@Sync the SMP branch with 3.3
@
text
@d5 1
a5 25
 * Copyright (c) 2002 Miodrag Vallat.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Copyright (c) 1996
d63 13
d77 1
a77 1
 * XXX should bring hardware cursor code back
d79 1
d93 1
d96 1
a99 6
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

d101 1
d103 4
a106 1
#include <dev/cons.h>	/* for prom console hook */
d108 2
a109 19
/*
 * per-display variables/state
 */
struct cgfourteen_softc {
	struct	sunfb sc_sunfb;		/* common base part */

	struct 	rom_reg	sc_phys;	/* phys address of frame buffer */
	union	cg14cmap sc_cmap;	/* current colormap */

	struct	cg14ctl  *sc_ctl; 	/* various registers */
	struct	cg14curs *sc_hwc;
	struct 	cg14dac	 *sc_dac;
	struct	cg14xlut *sc_xlut;
	struct 	cg14clut *sc_clut1;
	struct	cg14clut *sc_clut2;
	struct	cg14clut *sc_clut3;
	u_int	*sc_clutincr;

	int	sc_nscreens;
d112 2
a113 6
struct wsscreen_descr cgfourteen_stdscreen = {
	"std",
};

const struct wsscreen_descr *cgfourteen_scrlist[] = {
	&cgfourteen_stdscreen,
d116 4
a119 3
struct wsscreen_list cgfourteen_screenlist = {
	sizeof(cgfourteen_scrlist) / sizeof(struct wsscreen_descr *),
	    cgfourteen_scrlist
d122 2
a123 34
int cgfourteen_ioctl(void *, u_long, caddr_t, int, struct proc *);
int cgfourteen_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgfourteen_free_screen(void *, void *);
int cgfourteen_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t cgfourteen_mmap(void *, off_t, int);
void cgfourteen_reset(struct cgfourteen_softc *);
void cgfourteen_burner(void *, u_int, u_int);
void cgfourteen_prom(void *);

int  cgfourteen_getcmap(union cg14cmap *, struct wsdisplay_cmap *);
int  cgfourteen_putcmap(union cg14cmap *, struct wsdisplay_cmap *);
void cgfourteen_loadcmap(struct cgfourteen_softc *, int, int);
void cgfourteen_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);

struct wsdisplay_accessops cgfourteen_accessops = {
	cgfourteen_ioctl,
	cgfourteen_mmap,
	cgfourteen_alloc_screen,
	cgfourteen_free_screen,
	cgfourteen_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	cgfourteen_burner,
};

void	cgfourteenattach(struct device *, struct device *, void *);
int	cgfourteenmatch(struct device *, void *, void *);

struct cfattach cgfourteen_ca = {
	sizeof(struct cgfourteen_softc), cgfourteenmatch, cgfourteenattach
};
d125 10
a134 3
struct cfdriver cgfourteen_cd = {
	NULL, "cgfourteen", DV_DULL
};
d148 6
d164 1
a164 2
		return (1);

d169 1
a169 1
 * Attach a display.
d176 9
a184 7
	struct cgfourteen_softc *sc = (struct cgfourteen_softc *)self;
	struct confargs *ca = args;
	struct wsemuldisplaydev_attach_args waa;
	int fb_depth, node, i;
	u_int32_t *lut;
	int isconsole = 0;
	char *nam;
d186 8
a193 1
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags & FB_USERMASK;
d196 10
a205 4
	nam = getpropstring(node, "model");
	if (*nam == '\0')
		nam = getpropstring(node, "name");
	printf(": %s", nam);
d207 2
a208 1
	isconsole = node == fbnode;
d211 1
a211 1
	 * Sanity checks
d214 4
a217 3
		printf("\n");
		panic("cgfourteen: expected %x bytes of control "
		    "registers, got %x", 0x10000, ca->ca_ra.ra_len);
d219 2
a220 13
	if (ca->ca_ra.ra_nreg < CG14_NREG) {
		printf("\n");
		panic("cgfourteen: expected %d registers, got %d",
		    CG14_NREG, ca->ca_ra.ra_nreg);
	}

	printf(", %dMB", ca->ca_ra.ra_reg[CG14_REG_VRAM].rr_len >> 20);

	/*
	 * Map in the 8 useful pages of registers
	 */
	sc->sc_ctl = (struct cg14ctl *) mapiodev(
	    &ca->ca_ra.ra_reg[CG14_REG_CONTROL], 0, ca->ca_ra.ra_len);
d222 1
a222 1
	sc->sc_hwc = (struct cg14curs *) ((u_int)sc->sc_ctl +
d236 1
a236 1

d240 9
a248 8
	sc->sc_phys = ca->ca_ra.ra_reg[CG14_REG_VRAM];

	if (ISSET(sc->sc_sunfb.sf_flags, FB_FORCELOW))
		fb_depth = 8;
	else
		fb_depth = 32;

	fb_setsize(&sc->sc_sunfb, fb_depth, 1152, 900, node, ca->ca_bustype);
d251 1
a251 5
	 * The prom will report depth == 8, since this is the mode
	 * it will get initialized in.
	 * Try to compensate and enable 32 bit mode, unless it would
	 * not fit in the video memory. Note that, in this case, the
	 * VSIMM will usually not appear in the OBP device tree!
d253 7
a259 15
	if (fb_depth == 32 && sc->sc_sunfb.sf_depth == 8 &&
	    sc->sc_sunfb.sf_fbsize * 4 <=
	    ca->ca_ra.ra_reg[CG14_REG_VRAM].rr_len) {
		sc->sc_sunfb.sf_depth = 32;
		sc->sc_sunfb.sf_linebytes *= 4;
		sc->sc_sunfb.sf_fbsize *= 4;
	}

	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(&ca->ca_ra.ra_reg[CG14_REG_VRAM],
	    0,	/* CHUNKY_XBGR */
	    round_page(sc->sc_sunfb.sf_fbsize));

	printf(", %dx%d, depth %d\n", sc->sc_sunfb.sf_width,
	    sc->sc_sunfb.sf_height, sc->sc_sunfb.sf_depth);

d261 1
a261 1
	 * Reset frame buffer controls
d263 1
a263 1
	cgfourteen_reset(sc);
d272 3
d276 2
a277 1
	 * Enable the video.
d279 13
a291 1
	cgfourteen_burner(sc, 1, 0);
a292 8
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, isconsole);
	fbwscons_setcolormap(&sc->sc_sunfb, cgfourteen_setcolor);

	cgfourteen_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgfourteen_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgfourteen_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgfourteen_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;
d295 67
a361 5
		fbwscons_console_init(&sc->sc_sunfb, &cgfourteen_stdscreen,
		    sc->sc_sunfb.sf_depth == 8 ? -1 : 0,
		    cgfourteen_burner);
		shutdownhook_establish(cgfourteen_prom, sc);
	}
d363 1
a363 5
	waa.console = isconsole;
	waa.scrdata = &cgfourteen_screenlist;
	waa.accessops = &cgfourteen_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
d367 2
a368 2
cgfourteen_ioctl(dev, cmd, data, flags, p)
	void *dev;
d370 1
a370 1
	caddr_t data;
d374 5
a378 4
	struct cgfourteen_softc *sc = dev;
	struct wsdisplay_cmap *cm;
	struct wsdisplay_fbinfo *wdf;
	int error;
d381 3
a383 2
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_SUN24;
d385 11
a395 6
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width = sc->sc_sunfb.sf_width;
		wdf->depth = sc->sc_sunfb.sf_depth;
		wdf->cmsize = (sc->sc_sunfb.sf_depth == 8) ? 256 : 0;
d397 18
a414 2
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
d417 28
a444 4
	case WSDISPLAYIO_GETCMAP:
		if (sc->sc_sunfb.sf_depth == 8) {
			cm = (struct wsdisplay_cmap *)data;
			error = cgfourteen_getcmap(&sc->sc_cmap, cm);
d448 10
d460 16
a475 4
	case WSDISPLAYIO_PUTCMAP:
		if (sc->sc_sunfb.sf_depth == 8) {
			cm = (struct wsdisplay_cmap *)data;
			error = cgfourteen_putcmap(&sc->sc_cmap, cm);
a477 2
			/* XXX should use retrace interrupt */
			cgfourteen_loadcmap(sc, cm->index, cm->count);
d479 49
a529 7
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
d531 1
a531 1
		return (-1);	/* not supported yet */
d536 6
a541 30
int
cgfourteen_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
{
	struct cgfourteen_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	if (sc->sc_sunfb.sf_depth == 8)
		sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
		    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	else
		sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
		    0, 0, 0, attrp);
	sc->sc_nscreens++;
	return (0);
}

void
cgfourteen_free_screen(v, cookie)
	void *v;
	void *cookie;
a542 4
	struct cgfourteen_softc *sc = v;

	sc->sc_nscreens--;
}
d544 1
a544 9
int
cgfourteen_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
	return (0);
d550 12
d564 3
a566 3
cgfourteen_mmap(v, offset, prot)
	void *v;
	off_t offset;
d569 1
a569 1
	struct cgfourteen_softc *sc = v;
d571 8
a578 1
	if (offset & PGOFSET)
d581 32
a612 3
	/* Allow mapping as a dumb framebuffer from offset 0 */
	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys, offset) | PMAP_NC);
d615 5
a619 1
	return (-1);
d622 4
d627 2
a628 2
void
cgfourteen_reset(sc)
d631 3
d635 10
a644 12
	if (sc->sc_sunfb.sf_depth == 8) {
		/*
		 * Enable the video and put it in 8 bit mode
		 */
		sc->sc_ctl->ctl_mctl = CG14_MCTL_ENABLEVID |
		    CG14_MCTL_PIXMODE_8 | CG14_MCTL_POWERCTL;
	} else {
		/*
		 * Enable the video, and put in 32 bit mode.
		 */
		sc->sc_ctl->ctl_mctl = CG14_MCTL_ENABLEVID |
		    CG14_MCTL_PIXMODE_32 | CG14_MCTL_POWERCTL;
d646 6
a651 5
		/*
		 * Clear the screen to white
		 */
		memset(sc->sc_sunfb.sf_ro.ri_bits, 0xff,
		    round_page(sc->sc_sunfb.sf_fbsize));
d653 6
a658 4
		/*
		 * Zero the xlut to enable direct-color mode
		 */
		bzero(sc->sc_xlut, CG14_CLUT_SIZE);
d660 11
a670 2
		shutdownhook_establish(cgfourteen_prom, sc);
	}
d673 3
a675 3
void
cgfourteen_prom(v)
	void *v;
d677 3
a679 2
	struct cgfourteen_softc *sc = v;
	extern struct consdev consdev_prom;
d681 22
a702 12
	if (sc->sc_sunfb.sf_depth != 8) {
		/*
		 * Go back to 8-bit mode.
		 */
		sc->sc_ctl->ctl_mctl = CG14_MCTL_ENABLEVID |
		    CG14_MCTL_PIXMODE_8 | CG14_MCTL_POWERCTL;

		/*
		 * Go back to prom output for the last few messages, so they
		 * will be displayed correctly.
		 */
		cn_tab = &consdev_prom;
d706 5
a710 4
void
cgfourteen_burner(v, on, flags)
	void *v;
	u_int on, flags;
d712 1
a712 3
	struct cgfourteen_softc *sc = v;

	/*
d716 1
a716 1
	if (on) {
d731 8
d740 3
a742 2
int
cgfourteen_getcmap(cm, rcm)
d744 1
a744 1
	struct wsdisplay_cmap *rcm;
d746 11
a756 4
	u_int index = rcm->index, count = rcm->count, i;
	int error;

	if (index >= CG14_CLUT_SIZE || count > CG14_CLUT_SIZE - index)
d758 3
d762 10
a771 12
	for (i = 0; i < count; i++) {
		if ((error = copyout(&cm->cm_map[index + i][3],
		    &rcm->red[i], 1)) != 0)
			return (error);
		if ((error = copyout(&cm->cm_map[index + i][2],
		    &rcm->green[i], 1)) != 0)
			return (error);
		if ((error = copyout(&cm->cm_map[index + i][1],
		    &rcm->blue[i], 1)) != 0)
			return (error);
	}
	return (0);
d775 3
a777 2
int
cgfourteen_putcmap(cm, rcm)
d779 1
a779 1
        struct wsdisplay_cmap *rcm;
d781 11
a791 4
	u_int index = rcm->index, count = rcm->count, i;
	int error;

	if (index >= CG14_CLUT_SIZE || count > CG14_CLUT_SIZE - index)
d793 1
a793 12

	for (i = 0; i < count; i++) {
		if ((error = copyin(&rcm->red[i],
		    &cm->cm_map[index + i][3], 1)) != 0)
			return (error);
		if ((error = copyin(&rcm->green[i],
		    &cm->cm_map[index + i][2], 1)) != 0)
			return (error);
		if ((error = copyin(&rcm->blue[i],
		    &cm->cm_map[index + i][1], 1)) != 0)
			return (error);
		cm->cm_map[index +i][0] = 0;	/* no alpha channel */
d795 1
a795 2
	return (0);
}
d797 17
a813 4
void
cgfourteen_loadcmap(sc, start, ncolors)
	struct cgfourteen_softc *sc;
	int start, ncolors;
d816 1
a816 1

d818 2
a819 2
	u_int32_t *colp = &sc->sc_cmap.cm_chip[start];
	volatile u_int32_t *lutp = &sc->sc_clut1->clut_lut[start];
d826 52
a877 16
void
cgfourteen_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
	u_int8_t r, g, b;
{
	struct cgfourteen_softc *sc = v;

	/* XXX - Wait for retrace? */

	sc->sc_cmap.cm_map[index][3] = r;
	sc->sc_cmap.cm_map[index][2] = g;
	sc->sc_cmap.cm_map[index][1] = b;
	sc->sc_cmap.cm_map[index][0] = 0;	/* no alpha channel */
	
	cgfourteen_loadcmap(sc, index, 1);
@


1.4.4.6
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.4.4.5 2003/03/27 23:49:25 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 2002, 2003 Miodrag Vallat.  All rights reserved.
d81 2
a135 3
	int	sc_32;			/* can do 32bit at this resolution */
	size_t	sc_vramsize;		/* total video memory size */

d159 1
a159 1
void cgfourteen_reset(struct cgfourteen_softc *, int);
a206 8
	 * This driver should not be attached without an "addr" locator,
	 * as this is the only way to differentiate the main and secondary
	 * VSIMM.
	 */
	if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != (int)ra->ra_paddr)
		return (0);

	/*
d229 1
a229 1
	int node, i;
a235 1
	printf(": ");
d238 3
a240 2
	if (*nam != '\0')
		printf("%s, ", nam);
d248 3
a250 3
		printf("\n%s: expected %x bytes of control registers, got %x\n",
		    self->dv_xname, 0x10000, ca->ca_ra.ra_len);
		return;
d253 3
a255 3
		printf("\n%s: expected %d registers, got %d",
		    self->dv_xname, CG14_NREG, ca->ca_ra.ra_nreg);
		return;
d258 1
a258 1
	printf("%dMB", ca->ca_ra.ra_reg[CG14_REG_VRAM].rr_len >> 20);
d286 6
a291 1
	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, ca->ca_bustype);
d294 4
a297 4
	 * The prom will report depth == 8, since this is the mode it will
	 * get initialized in.
	 * Check if we will be able to use 32 bit mode later (i.e. if it will
	 * fit in the video memory. Note that, if this is not the case, the
d300 7
a306 2
	sc->sc_vramsize = ca->ca_ra.ra_reg[CG14_REG_VRAM].rr_len;
	sc->sc_32 = sc->sc_sunfb.sf_fbsize * 4 <= sc->sc_vramsize;
d310 1
a310 1
	    sc->sc_vramsize);
d312 2
a313 1
	printf(", %dx%d\n", sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);
d318 1
a318 2
	sc->sc_sunfb.sf_depth = 0;	/* force action */
	cgfourteen_reset(sc, 8);
d343 2
a344 1
		    -1, cgfourteen_burner);
a367 5
	/*
	 * Note that, although the emulation (text) mode is running in a
	 * 8-bit plane, we advertize the frame buffer as 32-bit if it can
	 * support this mode.
	 */
d370 1
a370 4
		if (sc->sc_32)
			*(u_int *)data = WSDISPLAY_TYPE_SUN24;
		else
			*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
d376 2
a377 2
		wdf->depth = sc->sc_32 ? 32 : 8;
		wdf->cmsize = sc->sc_32 ? 0 : 256;
d380 1
a380 4
		if (sc->sc_32)
			*(u_int *)data = sc->sc_sunfb.sf_linebytes * 4;
		else
			*(u_int *)data = sc->sc_sunfb.sf_linebytes;
d384 6
a389 4
		cm = (struct wsdisplay_cmap *)data;
		error = cgfourteen_getcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
d393 7
a399 16
		cm = (struct wsdisplay_cmap *)data;
		error = cgfourteen_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		/* XXX should use retrace interrupt */
		cgfourteen_loadcmap(sc, cm->index, cm->count);
		break;

	case WSDISPLAYIO_SMODE:
		if (*(int *)data == WSDISPLAYIO_MODE_EMUL) {
			/* Back from X11 to text mode */
			cgfourteen_reset(sc, 8);
		} else {
			/* Starting X11, try to switch to 32 bit mode */
			if (sc->sc_32)
				cgfourteen_reset(sc, 32);
d403 7
d432 6
a437 2
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
d479 1
a479 1
	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize * 4) {
d488 1
a488 1
cgfourteen_reset(sc, depth)
a489 1
	int depth;
d492 25
a516 28
	if (sc->sc_sunfb.sf_depth != depth) {
		if (depth == 8) {
			/*
			 * Enable the video and put it in 8 bit mode
			 */
			sc->sc_ctl->ctl_mctl = CG14_MCTL_ENABLEVID |
			    CG14_MCTL_PIXMODE_8 | CG14_MCTL_POWERCTL;

			fbwscons_setcolormap(&sc->sc_sunfb,
			    cgfourteen_setcolor);
		} else {
			/*
			 * Clear the screen to black
			 */
			bzero(sc->sc_sunfb.sf_ro.ri_bits,
			    sc->sc_sunfb.sf_fbsize);

			/*
			 * Enable the video, and put in 32 bit mode.
			 */
			sc->sc_ctl->ctl_mctl = CG14_MCTL_ENABLEVID |
			    CG14_MCTL_PIXMODE_32 | CG14_MCTL_POWERCTL;

			/*
			 * Zero the xlut to enable direct-color mode
			 */
			bzero(sc->sc_xlut, CG14_CLUT_SIZE);
		}
a517 2

	sc->sc_sunfb.sf_depth = depth;
d531 2
a532 1
		cgfourteen_reset(sc, 8);
@


1.4.4.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.4.4.6 2003/05/13 19:41:08 ho Exp $	*/
d242 2
@


1.4.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d330 1
a330 1
	fbwscons_init(&sc->sc_sunfb, isconsole ? 0 : RI_CLEAR);
@


1.3
log
@UVM fixes, just a few useracc -> uvm_useracc
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.2 1998/11/20 15:57:21 deraadt Exp $	*/
d207 2
a208 2
	ramsize = roundup(sc->sc_fb.fb_type.fb_height * sc->sc_fb.fb_linebytes,
		NBPG);
@


1.2
log
@careful off handling in mmap routines
@
text
@d1 1
a1 1
/*	$OpenBSD: cgfourteen.c,v 1.1 1997/08/08 08:24:48 downsj Exp $	*/
d486 5
d494 1
d770 6
d780 1
d812 6
d822 1
@


1.1
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d579 3
@

