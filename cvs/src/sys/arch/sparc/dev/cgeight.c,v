head	1.31;
access;
symbols
	OPENBSD_6_0:1.31.0.12
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.8
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.31.0.10
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.31.0.6
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.4
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.30.0.14
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.12
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.10
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.8
	OPENBSD_5_0:1.30.0.6
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.4
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.2
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.29.0.4
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.29.0.6
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.2
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.28.0.8
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.6
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.4
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.2
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.25.0.4
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.24.0.2
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.21.0.6
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.21
	SMP_SYNC_B:1.21
	OPENBSD_3_5:1.21.0.4
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.16
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.12
	OPENBSD_2_8:1.9.0.10
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.8
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.6
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.6
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.4
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7;
locks; strict;
comment	@ * @;


1.31
date	2013.10.20.20.07.25;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2010.06.07.19.43.45;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2008.12.26.22.30.21;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2006.12.03.22.13.05;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2006.12.03.16.38.12;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2006.07.25.21.23.30;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2005.03.23.17.16.34;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2005.03.07.16.44.50;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2005.01.05.23.04.24;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2004.11.29.22.07.36;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.28.17.05.33;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.02.23.27.53;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.12.20.18.39;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2002.12.12.20.21.34;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2002.11.06.21.06.20;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.23.18.13.38;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.09.22.15.15;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.12.10.44.03;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.42;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.11.01.12.13.46;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.17.13.52.28;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	98.11.20.15.57.21;	author deraadt;	state Exp;
branches
	1.9.6.1;
next	1.8;

1.8
date	97.08.08.08.24.44;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	96.08.13.08.05.20;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.08.11.05.34.08;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	95.12.15.13.56.16;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.11.09.21.34.45;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.10.28.14.49.57;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.22.11.28.57;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.14.27.39;	author deraadt;	state Exp;
branches;
next	;

1.9.6.1
date	2001.10.31.03.07.56;	author nate;	state Exp;
branches;
next	1.9.6.2;

1.9.6.2
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.9.6.3;

1.9.6.3
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.9.6.4;

1.9.6.4
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.9.6.5;

1.9.6.5
date	2003.05.16.00.29.40;	author niklas;	state Exp;
branches;
next	1.9.6.6;

1.9.6.6
date	2003.06.07.11.14.42;	author ho;	state Exp;
branches;
next	1.9.6.7;

1.9.6.7
date	2004.02.19.10.49.57;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2002.06.11.03.38.15;	author art;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.10.29.00.28.09;	author art;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@/*	$OpenBSD: cgeight.c,v 1.30 2010/06/07 19:43:45 miod Exp $	*/
/*	$NetBSD: cgeight.c,v 1.13 1997/05/24 20:16:04 pk Exp $	*/

/*
 * Copyright (c) 2002 Miodrag Vallat.  All rights reserved.
 * Copyright (c) 1996 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1995 Theo de Raadt
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from @@(#)cgthree.c	8.2 (Berkeley) 10/30/93
 */

/*
 * color display (cgeight) driver.
 *
 * For performance reasons, we run the emulation mode in the (monochrome)
 * overlay plane, but X11 in the 24-bit color plane.
 *
 * Does not handle interrupts, even though they can occur.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/mman.h>
#include <sys/tty.h>
#include <sys/conf.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/pmap.h>
#include <machine/eeprom.h>
#include <machine/conf.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

#include <sparc/dev/btreg.h>
#include <sparc/dev/btvar.h>
#include <sparc/dev/pfourreg.h>

/* per-display variables */
struct cgeight_softc {
	struct	sunfb sc_sunfb;			/* common base device */
	struct	rom_reg	sc_phys;
	volatile struct fbcontrol *sc_fbc;	/* Brooktree registers */
	volatile u_char *sc_enable;		/* enable plane */
};

int	cgeight_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	cgeight_mmap(void *, off_t, int);
void	cgeight_reset(struct cgeight_softc *, int);

struct wsdisplay_accessops cgeight_accessops = {
	.ioctl = cgeight_ioctl,
	.mmap = cgeight_mmap,
	.burn_screen = fb_pfour_burner
};

void	cgeightattach(struct device *, struct device *, void *);
int	cgeightmatch(struct device *, void *, void *);

struct cfattach cgeight_ca = {
	sizeof(struct cgeight_softc), cgeightmatch, cgeightattach
};

struct cfdriver cgeight_cd = {
	NULL, "cgeight", DV_DULL
};

int
cgeightmatch(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
		return (0);

	if (!CPU_ISSUN4 || ca->ca_bustype != BUS_OBIO)
		return (0);

	/*
	 * Make sure there's hardware there.
	 */
	if (probeget(ra->ra_vaddr, 4) == -1)
		return (0);

	/*
	 * Check the pfour register.
	 */
	if (fb_pfour_id(ra->ra_vaddr) == PFOUR_ID_COLOR24)
		return (1);

	return (0);
}

void
cgeightattach(struct device *parent, struct device *self, void *args)
{
	struct cgeight_softc *sc = (struct cgeight_softc *)self;
	struct confargs *ca = args;
	int node = 0;
	volatile struct bt_regs *bt;
	int isconsole = 0;

	/* Map the pfour register. */
	SET(sc->sc_sunfb.sf_flags, FB_PFOUR);
	sc->sc_sunfb.sf_pfour = (volatile u_int32_t *)
	    mapiodev(ca->ca_ra.ra_reg, 0, sizeof(u_int32_t));

	if (cputyp == CPU_SUN4) {
		struct eeprom *eep = (struct eeprom *)eeprom_va;

		/*
		 * Assume this is the console if there's no eeprom info
		 * to be found.
		 */
		if (eep == NULL || eep->ee_diag.eed_console == EED_CONS_P4)
			isconsole = 1;
	}

	/* Map the Brooktree. */
	sc->sc_fbc = (volatile struct fbcontrol *)
	    mapiodev(ca->ca_ra.ra_reg,
		     PFOUR_COLOR_OFF_CMAP, sizeof(struct fbcontrol));

	sc->sc_phys = ca->ca_ra.ra_reg[0];

	/* enable video */
	fb_pfour_burner(sc, 1, 0);
	bt = &sc->sc_fbc->fbc_dac;
	BT_INIT(bt, 0);

	fb_setsize(&sc->sc_sunfb, 1, 1152, 900, node, ca->ca_bustype);
	sc->sc_sunfb.sf_ro.ri_hw = sc;

	/*
	 * Map the overlay and overlay enable planes.
	 */
	sc->sc_enable = (volatile u_char *)mapiodev(ca->ca_ra.ra_reg,
	    PFOUR_COLOR_OFF_ENABLE, round_page(sc->sc_sunfb.sf_fbsize));
	sc->sc_sunfb.sf_ro.ri_bits =  mapiodev(ca->ca_ra.ra_reg,
	    PFOUR_COLOR_OFF_OVERLAY, round_page(sc->sc_sunfb.sf_fbsize));

	cgeight_reset(sc, WSDISPLAYIO_MODE_EMUL);
	printf(": p4, %dx%d", sc->sc_sunfb.sf_width,
	    sc->sc_sunfb.sf_height);

	fbwscons_init(&sc->sc_sunfb, isconsole);
	if (isconsole)
		fbwscons_console_init(&sc->sc_sunfb, -1);

	fbwscons_attach(&sc->sc_sunfb, &cgeight_accessops, isconsole);
}

void
cgeight_reset(struct cgeight_softc *sc, int mode)
{
	volatile struct bt_regs *bt;
	union bt_cmap cm;
	u_int c;

	bt = &sc->sc_fbc->fbc_dac;

	/*
	 * Depending on the mode requested, disable or enable
	 * the overlay plane.
	 */
	if (mode == WSDISPLAYIO_MODE_EMUL) {
		memset((void *)sc->sc_enable, 0xff,
		    round_page(sc->sc_sunfb.sf_fbsize));

		/* Setup a strict mono colormap */
		cm.cm_map[0][0] = cm.cm_map[0][1] = cm.cm_map[0][2] = 0x00;
		for (c = 1; c < 256; c++) {
			cm.cm_map[c][0] = cm.cm_map[c][1] = cm.cm_map[c][2] =
			    0xff;
		}
	} else {
		memset((void *)sc->sc_enable, 0x00,
		    round_page(sc->sc_sunfb.sf_fbsize));

		/* Setup a ramp colormap (direct color) */
		for (c = 0; c < 256; c++) {
			cm.cm_map[c][0] = cm.cm_map[c][1] = cm.cm_map[c][2] = c;
		}
	}

	/* Upload the colormap into the DAC */
	bt_loadcmap(&cm, bt, 0, 256, 0);
}

int
cgeight_ioctl(void *v, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct cgeight_softc *sc = v;
	struct wsdisplay_fbinfo *wdf;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG8;
		break;
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width = sc->sc_sunfb.sf_width;
		wdf->depth = 24;
		wdf->cmsize = 0;
		break;
	case WSDISPLAYIO_SMODE:
		cgeight_reset(sc, *(int *)data);
		break;
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
		break;

	case WSDISPLAYIO_GETCMAP:	/* nothing to do */
	case WSDISPLAYIO_PUTCMAP:	/* nothing to do */
	case WSDISPLAYIO_GCURPOS:	/* not supported */
	case WSDISPLAYIO_SCURPOS:	/* not supported */
	case WSDISPLAYIO_GCURMAX:	/* not supported */
	case WSDISPLAYIO_GCURSOR:	/* not supported */
	case WSDISPLAYIO_SCURSOR:	/* not supported */
	default:
		return (-1);
	}

	return (0);
}

paddr_t
cgeight_mmap(void *v, off_t offset, int prot)
{
	struct cgeight_softc *sc = v;

	if (offset & PGOFSET)
		return (-1);

	/* Allow mapping of the 24-bit color planes */
	if (offset >= 0 && offset < round_page(24 * sc->sc_sunfb.sf_fbsize)) {
		return (REG2PHYS(&sc->sc_phys,
		    offset + PFOUR_COLOR_OFF_COLOR) | PMAP_NC);
	}

	return (-1);
}
@


1.30
log
@Nuke old eeprom.h compatibility defines; ok todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.29 2008/12/26 22:30:21 miod Exp $	*/
d95 3
a97 10
	cgeight_ioctl,
	cgeight_mmap,
	NULL,	/* alloc_screen */
	NULL,	/* free_screen */
	NULL,	/* show_screen */
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	fb_pfour_burner,
	NULL	/* pollc */
@


1.29
log
@Move the logic responsible from deciding whether a frame buffer needs to be
cleared on attach, from the individual drivers to the common frame buffer code;
the latter will decide based on the prom font metrics and the prom console
window position, whenever possible.

This removes the need for the console window position to be hardcoded in
the p9100 driver, and will no longer require a screen clear on a vigra
VS-12 in high resolution mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.28 2006/12/03 22:13:05 miod Exp $	*/
d167 1
a167 1
		if (eep == NULL || eep->eeConsole == EE_CONS_P4OPT)
@


1.28
log
@Change cgeight to run the console in the monochrome overlay plane (as cgtwelve
does), and only use the 24 bit color planes when running X.

Not tested, but can't be worse than before - the code it replaces was busted
anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.27 2006/12/03 16:38:12 miod Exp $	*/
a194 1
	fbwscons_init(&sc->sc_sunfb, isconsole ? 0 : RI_CLEAR);
d198 2
a199 1
	if (isconsole) {
a200 1
	}
@


1.27
log
@Clean frame buffer attachment code:
- There is no need to check for buses config(8) will not let us attach to
- Better P4 bus logic, which does not need to abuse device flags
- Do not bother trying to print a meaningful device description when it is
  not connected to sbus.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.26 2006/07/25 21:23:30 miod Exp $	*/
d50 3
a53 2
 *
 * XXX should defer colormap updates to vertical retrace interrupts
d84 2
a85 2
	struct	sunfb sc_sunfb;		/* common base part */
	struct	rom_reg	sc_phys;	/* display RAM (phys addr) */
d87 1
a87 1
	union	bt_cmap sc_cmap;	/* Brooktree color map */
d92 1
a92 1
void	cgeight_reset(struct cgeight_softc *);
d183 1
a183 1
	fb_setsize(&sc->sc_sunfb, 24, 1152, 900, node, ca->ca_bustype);
d185 6
d193 2
a195 1

d206 37
a246 1
	struct wsdisplay_cmap *cm;
a247 1
	int error;
d257 2
a258 8
		wdf->depth = sc->sc_sunfb.sf_depth;
		wdf->cmsize = 256;
		break;
	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_getcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
d260 2
a261 7
	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		bt_loadcmap(&sc->sc_cmap, &sc->sc_fbc->fbc_dac,
		    cm->index, cm->count, 0);
a262 1

d267 7
a273 5
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
d275 1
a275 2
		return (-1);	/* not supported yet */

d289 4
a292 4
	/* Allow mapping as a dumb framebuffer from offset 0 */
	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys, offset +
		    PFOUR_COLOR_OFF_OVERLAY) | PMAP_NC);
@


1.26
log
@Do not bother reading the existing colormap on attach, since we will
override it with the rasops one.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.25 2005/03/23 17:16:34 miod Exp $	*/
a123 5
	/*
	 * Mask out invalid flags from the user.
	 */
	cf->cf_flags &= FB_USERMASK;

d139 1
a139 2
	if (fb_pfour_id(ra->ra_vaddr) == PFOUR_ID_COLOR24) {
		cf->cf_flags |= FB_PFOUR;
a140 1
	}
a153 2
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;

d155 1
d188 1
a188 1
	printf(": cgeight/p4, %dx%d", sc->sc_sunfb.sf_width,
@


1.25
log
@Move the alloc_screen, free_screen and show_screen wsdisplay accessops to
the common frame buffer code, rather than duplicating it in every driver.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.24 2005/03/07 16:44:50 miod Exp $	*/
d157 1
a157 1
	int node = 0, i;
a184 6
	/* grab initial (current) color map */
	bt = &sc->sc_fbc->fbc_dac;
	bt->bt_addr = 0;
	for (i = 0; i < 256 * 3 / 4; i++)
		sc->sc_cmap.cm_chip[i] = bt->bt_cmap;

d187 1
@


1.24
log
@Do not bother passing the blanking routine to fbwscons_console_init(),
as fbwscons_attach() can find it on its own.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.23 2005/01/05 23:04:24 miod Exp $	*/
a73 1
#include <dev/wscons/wscons_raster.h>
a86 1
	int	sc_nscreens;
d89 3
a91 9
int cgeight_ioctl(void *, u_long, caddr_t, int, struct proc *);
int cgeight_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgeight_free_screen(void *, void *);
int cgeight_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t cgeight_mmap(void *, off_t, int);
void cgeight_reset(struct cgeight_softc *);
void cgeight_burner(void *, u_int, u_int);
d96 3
a98 3
	cgeight_alloc_screen,
	cgeight_free_screen,
	cgeight_show_screen,
d102 2
a103 1
	cgeight_burner,
a116 3
/*
 * Match a cgeight.
 */
d118 1
a118 3
cgeightmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
a151 3
/*
 * Attach a display.
 */
d153 1
a153 3
cgeightattach(parent, self, args)
	struct device *parent, *self;
	void *args;
d192 1
a192 1
	cgeight_burner(sc, 1, 0);
d212 1
a212 6
cgeight_ioctl(v, cmd, data, flags, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
a261 47
int
cgeight_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
{
	struct cgeight_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    0, 0, 0, attrp);
	sc->sc_nscreens++;
	return (0);
}

void
cgeight_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct cgeight_softc *sc = v;

	sc->sc_nscreens--;
}

int
cgeight_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
	return (0);
}

/*
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
 */
d263 1
a263 4
cgeight_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
d276 1
a276 11
	return (-1);	/* not a user-map offset */
}

void
cgeight_burner(v, on, flags)
	void *v;
	u_int on, flags;
{
	struct cgeight_softc *sc = v;

	fb_pfour_set_video(&sc->sc_sunfb, on);
@


1.23
log
@Let wsdisplay drivers return zero for WSDISPLAYIO_[GS]VIDEO ioctls - most
of the work is done in the upper layer, but they get to see the ioctl,
so don't always return an error.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.22 2004/11/29 22:07:36 miod Exp $	*/
d222 1
a222 1
		fbwscons_console_init(&sc->sc_sunfb, -1, cgeight_burner);
@


1.22
log
@Move the struct wsscreen_descr from a per-driver global to a per-instance
field of the sunfb structure. This allows multiple instances of the same driver,
but with different resolutions (such as a couple of vigra or a TGX cgsix and
a TGX+ cgsix) to use distinct wsscreen_descr structures featuring different
resolution information.

Doing this allows more wsscreen_descr fiddling inside the sparc* fb api,
and results in some code shrinkage (about 4KB on sparc GENERIC).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.21 2003/06/28 17:05:33 miod Exp $	*/
d269 2
@


1.21
log
@Sync sparc fb API with the sparc64 changes (fbwscons_init takes flags, and
the sunfb structure keeps pointer to the prom cursor coordinates).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.20 2003/06/02 23:27:53 millert Exp $	*/
a90 13
struct wsscreen_descr cgeight_stdscreen = {
	"std",
};

const struct wsscreen_descr *cgeight_scrlist[] = {
	&cgeight_stdscreen,
};

struct wsscreen_list cgeight_screenlist = {
	sizeof(cgeight_scrlist) /sizeof(struct wsscreen_descr *),
	    cgeight_scrlist
};

a173 1
	struct wsemuldisplaydev_attach_args waa;
a217 5
	cgeight_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgeight_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgeight_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgeight_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

d222 1
a222 2
		fbwscons_console_init(&sc->sc_sunfb, &cgeight_stdscreen, -1,
		    cgeight_burner);
d225 1
a225 5
	waa.console = isconsole;
	waa.scrdata = &cgeight_screenlist;
	waa.accessops = &cgeight_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
@


1.20
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.19 2003/05/12 20:18:39 jason Exp $	*/
d230 1
a230 1
	fbwscons_init(&sc->sc_sunfb, isconsole);
@


1.19
log
@use new display types; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.18 2002/12/12 20:21:34 miod Exp $	*/
d28 1
a28 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.18
log
@Remove dead prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.17 2002/11/06 21:06:20 miod Exp $	*/
d271 1
a271 1
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
@


1.17
log
@- always initialize colormaps, even if the frame buffer is non console; this
  helps if the ramdac does not get initialized (idea from jason@@)
- only register a shutdown hook for the frame buffers which need it, if this
  is the console frame buffer. Otherwise this is just a waste of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.16 2002/09/23 18:13:38 miod Exp $	*/
a114 1
int cgeight_is_console(int);
@


1.16
log
@Get the wsdisplay capabilities from rasops, rather than attempting to
guess them at compile-time. Plus this makes cgtwelve a bit more clean.

ok fgs@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.15 2002/09/09 22:15:15 miod Exp $	*/
d247 1
a247 1
		    NULL, cgeight_burner);
@


1.15
log
@Register more screen capabilities to work with the recent wsemul_sun changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.14 2002/08/12 10:44:03 miod Exp $	*/
a96 5
	0, 0,	/* will be filled in */
	0,
	0, 0,
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
	WSSCREEN_REVERSE | WSSCREEN_WSCOLORS
d237 1
@


1.14
log
@Convert sparc console code from rcons and pseudo-devices to rasops and wscons.
For most framebuffers it is faster.

Other changes include:
o 24 bit support in tcx(4) for the S24 framebuffer
o accelerated cgsix(4) text console
o new cgtwelve(4) driver for the GS framebuffer
o improved serial driver code
o better keyboard support

The following framebuffers have not been tested but should work: cgfour,
cgeight and cgfourteen

These changes will require XF4 changes, to use Xwsfb instead of Xsun*, to be
commited later today.

Most of the work by me during the LSM and the week after, with code borrowed
from jason@@, NetBSD (new serial code), and feedback from mickey@@. Work on
pnozz(4) done by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.13 2002/03/14 01:26:42 millert Exp $	*/
d100 1
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.12 2001/11/06 19:53:16 miod Exp $	*/
d5 1
a70 1
#include <machine/fbio.h>
a72 1
#include <machine/fbvar.h>
d76 6
d88 2
a89 3
	struct	device sc_dev;		/* base device */
	struct	fbdevice sc_fb;		/* frame buffer device */
	struct rom_reg	sc_phys;	/* display RAM (phys addr) */
a90 1
	int	sc_bustype;		/* type of bus we live on */
d92 13
d107 30
a136 6
/* autoconfiguration driver */
static void	cgeightattach(struct device *, struct device *, void *);
static int	cgeightmatch(struct device *, void *, void *);
#if defined(SUN4)
static void	cgeightunblank(struct device *);
#endif
a145 14
#if defined(SUN4)
/* frame buffer generic driver */
static struct fbdriver cgeightfbdriver = {
	cgeightunblank, cgeightopen, cgeightclose, cgeightioctl, cgeightmmap
};

extern int fbnode;
extern struct tty *fbconstty;

static void cgeightloadcmap(struct cgeight_softc *, int, int);
static int cgeight_get_video(struct cgeight_softc *);
static void cgeight_set_video(struct cgeight_softc *, int);
#endif

a157 3
	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
		return (0);

d163 1
a163 4
	/*
	 * Only exists on a sun4.
	 */
	if (!CPU_ISSUN4)
d166 1
a166 4
	/*
	 * Only exists on obio.
	 */
	if (ca->ca_bustype != BUS_OBIO)
a174 1
#if defined(SUN4)
a181 1
#endif
d187 1
a187 1
 * Attach a display.  We need to notice if it is the console, too.
d194 6
a199 12
#if defined(SUN4)
	register struct cgeight_softc *sc = (struct cgeight_softc *)self;
	register struct confargs *ca = args;
	register int node = 0, ramsize, i;
	register volatile struct bt_regs *bt;
	struct fbdevice *fb = &sc->sc_fb;
	int isconsole;

	fb->fb_driver = &cgeightfbdriver;
	fb->fb_device = &sc->sc_dev;
	fb->fb_type.fb_type = FBTYPE_MEMCOLOR;
	fb->fb_flags = sc->sc_dev.dv_cfdata->cf_flags;
d201 1
a201 8
	/*
	 * Only pfour cgfours, thank you...
	 */
	if ((ca->ca_bustype != BUS_OBIO) ||
	    ((fb->fb_flags & FB_PFOUR) == 0)) {
		printf("%s: ignoring; not a pfour\n", sc->sc_dev.dv_xname);
		return;
	}
d204 1
a204 1
	fb->fb_pfour = (volatile u_int32_t *)
a206 12
	ramsize = PFOUR_COLOR_OFF_END - PFOUR_COLOR_OFF_OVERLAY;

	fb->fb_type.fb_depth = 24;
	fb_setsize(fb, fb->fb_type.fb_depth, 1152, 900, node, ca->ca_bustype);

	sc->sc_fb.fb_type.fb_cmsize = 256;
	sc->sc_fb.fb_type.fb_size = ramsize;
	printf(": cgeight/p4, %d x %d", fb->fb_type.fb_width,
	    fb->fb_type.fb_height);

	isconsole = 0;

d215 1
a215 1
			isconsole = (fbconstty != NULL);
a217 23
#if 0
	/*
	 * We don't do any of the console handling here.  Instead,
	 * we let the bwtwo driver pick up the overlay plane and
	 * use it instead.  Rconsole should have better performance
	 * with the 1-bit depth.
	 *      -- Jason R. Thorpe <thorpej@@NetBSD.ORG>
	 */

	/*
	 * When the ROM has mapped in a cgfour display, the address
	 * maps only the video RAM, so in any case we have to map the
	 * registers ourselves.  We only need the video RAM if we are
	 * going to print characters via rconsole.
	 */

	if (isconsole) {
		/* XXX this is kind of a waste */
		fb->fb_pixels = mapiodev(ca->ca_ra.ra_reg,
					 PFOUR_COLOR_OFF_OVERLAY, ramsize);
	}
#endif

a223 7
	sc->sc_bustype = ca->ca_bustype;

#if 0	/* XXX thorpej ??? */
	/* tell the enable plane to look at the mono image */
	memset(ca->ca_ra.ra_vaddr, 0xff,
	    sc->sc_fb.fb_type.fb_width * sc->sc_fb.fb_type.fb_height / 8);
#endif
d231 2
d235 9
a243 9
#if 0	/* see above */
	if (isconsole) {
		printf(" (console)\n");
#if defined(RASTERCONSOLE) && 0	/* XXX been told it doesn't work well. */
		fbrcons_init(fb);
#endif
	} else
#endif /* 0 */
		printf("\n");
d245 2
a246 7
	/*
	 * Even though we're not using rconsole, we'd still like
	 * to notice if we're the console framebuffer.
	 */
	fb_attach(&sc->sc_fb, isconsole);
#endif
}
d248 4
a251 7
int
cgeightopen(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	int unit = minor(dev);
d253 5
a257 3
	if (unit >= cgeight_cd.cd_ndevs || cgeight_cd.cd_devs[unit] == NULL)
		return (ENXIO);
	return (0);
d261 2
a262 12
cgeightclose(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{

	return (0);
}

int
cgeightioctl(dev, cmd, data, flags, p)
	dev_t dev;
d264 1
a264 1
	register caddr_t data;
d268 3
a270 3
#if defined(SUN4)
	register struct cgeight_softc *sc = cgeight_cd.cd_devs[minor(dev)];
	register struct fbgattr *fba;
d274 2
a275 3

	case FBIOGTYPE:
		*(struct fbtype *)data = sc->sc_fb.fb_type;
d277 6
a282 11

	case FBIOGATTR:
		fba = (struct fbgattr *)data;
		fba->real_type = sc->sc_fb.fb_type.fb_type;
		fba->owner = 0;		/* XXX ??? */
		fba->fbtype = sc->sc_fb.fb_type;
		fba->sattr.flags = 0;
		fba->sattr.emu_type = sc->sc_fb.fb_type.fb_type;
		fba->sattr.dev_specific[0] = -1;
		fba->emu_types[0] = sc->sc_fb.fb_type.fb_type;
		fba->emu_types[1] = -1;
d284 3
a286 8

	case FBIOGETCMAP:
		return (bt_getcmap((struct fbcmap *)data, &sc->sc_cmap, 256));

	case FBIOPUTCMAP:
		/* copy to software map */
#define p ((struct fbcmap *)data)
		error = bt_putcmap(p, &sc->sc_cmap, 256);
a288 4
		/* now blast them into the chip */
		/* XXX should use retrace interrupt */
		cgeightloadcmap(sc, p->index, p->count);
#undef p
d290 7
a296 3

	case FBIOGVIDEO:
		*(int *)data = cgeight_get_video(sc);
d299 9
a307 3
	case FBIOSVIDEO:
		cgeight_set_video(sc, *(int *)data);
		break;
a308 2
	default:
		return (ENOTTY);
d310 1
a310 1
#endif
d314 7
a320 14
/*
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
 *
 * The cg8 maps it's overlay plane at 0 for 128K, followed by the
 * enable plane for 128K, followed by the colour for as long as it
 * goes. Starting at 8MB, it maps the ramdac for NBPG, then the p4
 * register for NBPG, then the bootrom for 0x40000.
 */
paddr_t
cgeightmmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
d322 1
a322 2
	register struct cgeight_softc *sc = cgeight_cd.cd_devs[minor(dev)];
	int poff;
d324 2
a325 8
#define START_ENABLE	(128*1024)
#define START_COLOR	((128*1024) + (128*1024))
#define COLOR_SIZE	(sc->sc_fb.fb_type.fb_width * \
			    sc->sc_fb.fb_type.fb_height * 3)
#define END_COLOR	(START_COLOR + COLOR_SIZE)
#define START_SPECIAL	0x800000
#define PROMSIZE	0x40000
#define NOOVERLAY	(0x04000000)
d327 8
a334 2
	if (off & PGOFSET)
		panic("cgeightmap");
d336 6
a341 4
	if (off < 0)
		return (-1);
	if ((u_int)off >= NOOVERLAY) {
		off -= NOOVERLAY;
d343 2
a344 7
		/*
		 * X11 maps a huge chunk of the frame buffer; far more than
		 * there really is. We compensate by double-mapping the
		 * first page for as many other pages as it wants
		 */
		while ((u_int)off >= COLOR_SIZE)
			off -= COLOR_SIZE;	/* XXX thorpej ??? */
d346 9
a354 44
		poff = off + PFOUR_COLOR_OFF_COLOR;
	} else if ((u_int)off < START_ENABLE) {
		/*
		 * in overlay plane
		 */
		poff = PFOUR_COLOR_OFF_OVERLAY + off;
	} else if ((u_int)off < START_COLOR) {
		/*
		 * in enable plane
		 */
		poff = (off - START_ENABLE) + PFOUR_COLOR_OFF_ENABLE;
	} else if ((u_int)off < sc->sc_fb.fb_type.fb_size) {
		/*
		 * in colour plane
		 */
		poff = (off - START_COLOR) + PFOUR_COLOR_OFF_COLOR;
	} else if ((u_int)off < START_SPECIAL) {
		/*
		 * hole
		 */
		poff = 0;	/* XXX */
	} else if ((u_int)off == START_SPECIAL) {
		/*
		 * colour map (Brooktree)
		 */
		poff = PFOUR_COLOR_OFF_CMAP;
	} else if ((u_int)off == START_SPECIAL + NBPG) {
		/*
		 * p4 register
		 */
		poff = 0;
	} else if ((u_int)off > (START_SPECIAL + (NBPG * 2)) &&
	    (u_int) off < (START_SPECIAL + (NBPG * 2) + PROMSIZE)) {
		/*
		 * rom
		 */
		poff = 0x8000 + (off - (START_SPECIAL + (NBPG * 2)));
	} else
		return (-1);
	/*
	 * I turned on PMAP_NC here to disable the cache as I was
	 * getting horribly broken behaviour with it on.
	 */
	return (REG2PHYS(&sc->sc_phys, poff) | PMAP_NC);
a356 1
#if defined(SUN4)
d358 2
a359 1
 * Undo the effect of an FBIOSVIDEO that turns the video off.
d361 5
a365 3
static void
cgeightunblank(dev)
	struct device *dev;
d367 1
d369 2
a370 2
	cgeight_set_video((struct cgeight_softc *)dev, 1);
}
d372 5
a376 4
static int
cgeight_get_video(sc)
	struct cgeight_softc *sc;
{
d378 1
a378 1
	return (fb_pfour_get_video(&sc->sc_fb));
d381 4
a384 4
static void
cgeight_set_video(sc, enable)
	struct cgeight_softc *sc;
	int enable;
d386 1
d388 1
a388 21
	fb_pfour_set_video(&sc->sc_fb, enable);
}

/*
 * Load a subset of the current (new) colormap into the Brooktree DAC.
 */
static void
cgeightloadcmap(sc, start, ncolors)
	register struct cgeight_softc *sc;
	register int start, ncolors;
{
	register volatile struct bt_regs *bt;
	register u_int *ip;
	register int count;

	ip = &sc->sc_cmap.cm_chip[BT_D4M3(start)];	/* start/4 * 3 */
	count = BT_D4M3(start + ncolors - 1) - BT_D4M3(start) + 3;
	bt = &sc->sc_fbc->fbc_dac;
	bt->bt_addr = BT_D4M4(start);
	while (--count >= 0)
		bt->bt_cmap = *ip++;
a389 1
#endif
@


1.12
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.11 2001/11/01 12:13:46 art Exp $	*/
d95 1
a95 1
static void	cgeightunblank __P((struct device *));
d115 3
a117 3
static void cgeightloadcmap __P((struct cgeight_softc *, int, int));
static int cgeight_get_video __P((struct cgeight_softc *));
static void cgeight_set_video __P((struct cgeight_softc *, int));
@


1.12.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.12 2001/11/06 19:53:16 miod Exp $	*/
d95 1
a95 1
static void	cgeightunblank(struct device *);
d115 3
a117 3
static void cgeightloadcmap(struct cgeight_softc *, int, int);
static int cgeight_get_video(struct cgeight_softc *);
static void cgeight_set_video(struct cgeight_softc *, int);
@


1.12.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.12.2.1 2002/06/11 03:38:15 art Exp $	*/
a4 1
 * Copyright (c) 2002 Miodrag Vallat.  All rights reserved.
d70 1
d73 1
a76 6
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

d83 3
a85 2
	struct	sunfb sc_sunfb;		/* common base part */
	struct	rom_reg	sc_phys;	/* display RAM (phys addr) */
d87 1
a88 1
	int	sc_nscreens;
d91 6
a96 3
struct wsscreen_descr cgeight_stdscreen = {
	"std",
};
d98 2
a99 2
const struct wsscreen_descr *cgeight_scrlist[] = {
	&cgeight_stdscreen,
d102 2
a103 3
struct wsscreen_list cgeight_screenlist = {
	sizeof(cgeight_scrlist) /sizeof(struct wsscreen_descr *),
	    cgeight_scrlist
d106 4
a109 21
int cgeight_ioctl(void *, u_long, caddr_t, int, struct proc *);
int cgeight_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgeight_free_screen(void *, void *);
int cgeight_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t cgeight_mmap(void *, off_t, int);
int cgeight_is_console(int);
void cgeight_reset(struct cgeight_softc *);
void cgeight_burner(void *, u_int, u_int);

struct wsdisplay_accessops cgeight_accessops = {
	cgeight_ioctl,
	cgeight_mmap,
	cgeight_alloc_screen,
	cgeight_free_screen,
	cgeight_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	cgeight_burner,
d112 2
a113 2
void	cgeightattach(struct device *, struct device *, void *);
int	cgeightmatch(struct device *, void *, void *);
d115 4
a118 7
struct cfattach cgeight_ca = {
	sizeof(struct cgeight_softc), cgeightmatch, cgeightattach
};

struct cfdriver cgeight_cd = {
	NULL, "cgeight", DV_DULL
};
d132 3
d140 4
a143 1
	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
d146 4
a149 1
	if (!CPU_ISSUN4 || ca->ca_bustype != BUS_OBIO)
d158 1
d166 1
d172 1
a172 1
 * Attach a display.
d179 12
a190 6
	struct cgeight_softc *sc = (struct cgeight_softc *)self;
	struct confargs *ca = args;
	struct wsemuldisplaydev_attach_args waa;
	int node = 0, i;
	volatile struct bt_regs *bt;
	int isconsole = 0;
d192 8
a199 1
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;
d202 1
a202 1
	sc->sc_sunfb.sf_pfour = (volatile u_int32_t *)
d205 12
d225 1
a225 1
			isconsole = 1;
d228 23
d257 7
a270 2
	/* enable video */
	cgeight_burner(sc, 1, 0);
d273 25
a297 10
	fb_setsize(&sc->sc_sunfb, 24, 1152, 900, node, ca->ca_bustype);
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	sc->sc_sunfb.sf_ro.ri_bits =  mapiodev(ca->ca_ra.ra_reg,
	    PFOUR_COLOR_OFF_OVERLAY, round_page(sc->sc_sunfb.sf_fbsize));
	fbwscons_init(&sc->sc_sunfb, isconsole);

	cgeight_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgeight_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgeight_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgeight_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;
d299 4
a302 2
	printf(": cgeight/p4, %dx%d", sc->sc_sunfb.sf_width,
	    sc->sc_sunfb.sf_height);
d304 6
a309 4
	if (isconsole) {
		fbwscons_console_init(&sc->sc_sunfb, &cgeight_stdscreen, -1,
		    NULL, cgeight_burner);
	}
d311 1
a311 5
	waa.console = isconsole;
	waa.scrdata = &cgeight_screenlist;
	waa.accessops = &cgeight_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
d315 2
a316 2
cgeight_ioctl(v, cmd, data, flags, p)
	void *v;
d318 1
a318 1
	caddr_t data;
d322 3
a324 3
	struct cgeight_softc *sc = v;
	struct wsdisplay_cmap *cm;
	struct wsdisplay_fbinfo *wdf;
d328 3
a330 2
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
d332 11
a342 6
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width = sc->sc_sunfb.sf_width;
		wdf->depth = sc->sc_sunfb.sf_depth;
		wdf->cmsize = 256;
d344 8
a351 3
	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_getcmap(&sc->sc_cmap, cm);
d354 8
d363 3
a365 7
	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		bt_loadcmap(&sc->sc_cmap, &sc->sc_fbc->fbc_dac,
		    cm->index, cm->count, 0);
a367 7
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
d369 1
a369 2
		return (-1);	/* not supported yet */

d371 1
a371 1

d375 14
a388 7
int
cgeight_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
d390 19
a408 1
	struct cgeight_softc *sc = v;
d410 7
a416 2
	if (sc->sc_nscreens > 0)
		return (ENOMEM);
d418 44
a461 7
	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    0, 0, 0, attrp);
	sc->sc_nscreens++;
	return (0);
d464 7
a470 4
void
cgeight_free_screen(v, cookie)
	void *v;
	void *cookie;
a471 1
	struct cgeight_softc *sc = v;
d473 1
a473 1
	sc->sc_nscreens--;
d476 3
a478 7
int
cgeight_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
d480 2
a481 1
	return (0);
d484 4
a487 9
/*
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
 */
paddr_t
cgeight_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
a488 1
	struct cgeight_softc *sc = v;
d490 1
a490 10
	if (offset & PGOFSET)
		return (-1);

	/* Allow mapping as a dumb framebuffer from offset 0 */
	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys, offset +
		    PFOUR_COLOR_OFF_OVERLAY) | PMAP_NC);
	}

	return (-1);	/* not a user-map offset */
d493 7
a499 4
void
cgeight_burner(v, on, flags)
	void *v;
	u_int on, flags;
d501 3
a503 1
	struct cgeight_softc *sc = v;
d505 6
a510 1
	fb_pfour_set_video(&sc->sc_sunfb, on);
d512 1
@


1.12.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d115 1
d247 1
a247 1
		    cgeight_burner);
d272 1
a272 1
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG8;
@


1.11
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.10 2001/08/17 13:52:28 mickey Exp $	*/
d68 1
a68 1
#include <vm/vm.h>
@


1.10
log
@cdev_decl cleanup; jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.9 1998/11/20 15:57:21 deraadt Exp $	*/
d384 1
a384 1
int
d387 2
a388 1
	int off, prot;
@


1.9
log
@careful off handling in mmap routines
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.8 1997/08/08 08:24:44 downsj Exp $	*/
a96 3

/* cdevsw prototypes */
cdev_decl(cgeight);
@


1.9.6.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.9 1998/11/20 15:57:21 deraadt Exp $	*/
d97 3
@


1.9.6.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d68 1
a68 1
#include <uvm/uvm_extern.h>
d384 1
a384 1
paddr_t
d387 1
a387 2
	off_t off;
	int prot;
@


1.9.6.3
log
@Merge in -current from about a week ago
@
text
@d95 1
a95 1
static void	cgeightunblank(struct device *);
d115 3
a117 3
static void cgeightloadcmap(struct cgeight_softc *, int, int);
static int cgeight_get_video(struct cgeight_softc *);
static void cgeight_set_video(struct cgeight_softc *, int);
@


1.9.6.4
log
@Sync the SMP branch with 3.3
@
text
@a4 1
 * Copyright (c) 2002 Miodrag Vallat.  All rights reserved.
d70 1
d73 1
a76 6
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

d83 3
a85 2
	struct	sunfb sc_sunfb;		/* common base part */
	struct	rom_reg	sc_phys;	/* display RAM (phys addr) */
d87 1
a88 1
	int	sc_nscreens;
d91 6
a96 3
struct wsscreen_descr cgeight_stdscreen = {
	"std",
};
d98 2
a99 2
const struct wsscreen_descr *cgeight_scrlist[] = {
	&cgeight_stdscreen,
d102 2
a103 3
struct wsscreen_list cgeight_screenlist = {
	sizeof(cgeight_scrlist) /sizeof(struct wsscreen_descr *),
	    cgeight_scrlist
d106 4
a109 20
int cgeight_ioctl(void *, u_long, caddr_t, int, struct proc *);
int cgeight_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgeight_free_screen(void *, void *);
int cgeight_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t cgeight_mmap(void *, off_t, int);
void cgeight_reset(struct cgeight_softc *);
void cgeight_burner(void *, u_int, u_int);

struct wsdisplay_accessops cgeight_accessops = {
	cgeight_ioctl,
	cgeight_mmap,
	cgeight_alloc_screen,
	cgeight_free_screen,
	cgeight_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	cgeight_burner,
d112 2
a113 2
void	cgeightattach(struct device *, struct device *, void *);
int	cgeightmatch(struct device *, void *, void *);
d115 4
a118 7
struct cfattach cgeight_ca = {
	sizeof(struct cgeight_softc), cgeightmatch, cgeightattach
};

struct cfdriver cgeight_cd = {
	NULL, "cgeight", DV_DULL
};
d132 3
d140 4
a143 1
	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
d146 4
a149 1
	if (!CPU_ISSUN4 || ca->ca_bustype != BUS_OBIO)
d158 1
d166 1
d172 1
a172 1
 * Attach a display.
d179 12
a190 6
	struct cgeight_softc *sc = (struct cgeight_softc *)self;
	struct confargs *ca = args;
	struct wsemuldisplaydev_attach_args waa;
	int node = 0, i;
	volatile struct bt_regs *bt;
	int isconsole = 0;
d192 8
a199 1
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;
d202 1
a202 1
	sc->sc_sunfb.sf_pfour = (volatile u_int32_t *)
d205 12
d225 1
a225 1
			isconsole = 1;
d228 23
d257 7
a270 2
	/* enable video */
	cgeight_burner(sc, 1, 0);
d273 25
a297 10
	fb_setsize(&sc->sc_sunfb, 24, 1152, 900, node, ca->ca_bustype);
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	sc->sc_sunfb.sf_ro.ri_bits =  mapiodev(ca->ca_ra.ra_reg,
	    PFOUR_COLOR_OFF_OVERLAY, round_page(sc->sc_sunfb.sf_fbsize));
	fbwscons_init(&sc->sc_sunfb, isconsole);

	cgeight_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgeight_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgeight_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgeight_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;
d299 4
a302 2
	printf(": cgeight/p4, %dx%d", sc->sc_sunfb.sf_width,
	    sc->sc_sunfb.sf_height);
d304 6
a309 4
	if (isconsole) {
		fbwscons_console_init(&sc->sc_sunfb, &cgeight_stdscreen, -1,
		    cgeight_burner);
	}
d311 1
a311 5
	waa.console = isconsole;
	waa.scrdata = &cgeight_screenlist;
	waa.accessops = &cgeight_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
d315 2
a316 2
cgeight_ioctl(v, cmd, data, flags, p)
	void *v;
d318 1
a318 1
	caddr_t data;
d322 3
a324 3
	struct cgeight_softc *sc = v;
	struct wsdisplay_cmap *cm;
	struct wsdisplay_fbinfo *wdf;
d328 3
a330 2
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
d332 11
a342 6
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width = sc->sc_sunfb.sf_width;
		wdf->depth = sc->sc_sunfb.sf_depth;
		wdf->cmsize = 256;
d344 8
a351 3
	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_getcmap(&sc->sc_cmap, cm);
d354 8
d363 3
a365 7
	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		bt_loadcmap(&sc->sc_cmap, &sc->sc_fbc->fbc_dac,
		    cm->index, cm->count, 0);
a367 7
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
d369 1
a369 2
		return (-1);	/* not supported yet */

d371 1
a371 1

d375 14
a388 7
int
cgeight_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
d390 19
a408 1
	struct cgeight_softc *sc = v;
d410 7
a416 2
	if (sc->sc_nscreens > 0)
		return (ENOMEM);
d418 44
a461 7
	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    0, 0, 0, attrp);
	sc->sc_nscreens++;
	return (0);
d464 7
a470 4
void
cgeight_free_screen(v, cookie)
	void *v;
	void *cookie;
a471 1
	struct cgeight_softc *sc = v;
d473 1
a473 1
	sc->sc_nscreens--;
d476 3
a478 7
int
cgeight_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
d480 2
a481 1
	return (0);
d484 4
a487 9
/*
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
 */
paddr_t
cgeight_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
a488 1
	struct cgeight_softc *sc = v;
d490 1
a490 10
	if (offset & PGOFSET)
		return (-1);

	/* Allow mapping as a dumb framebuffer from offset 0 */
	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys, offset +
		    PFOUR_COLOR_OFF_OVERLAY) | PMAP_NC);
	}

	return (-1);	/* not a user-map offset */
d493 7
a499 4
void
cgeight_burner(v, on, flags)
	void *v;
	u_int on, flags;
d501 3
a503 1
	struct cgeight_softc *sc = v;
d505 6
a510 1
	fb_pfour_set_video(&sc->sc_sunfb, on);
d512 1
@


1.9.6.5
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d271 1
a271 1
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG8;
@


1.9.6.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgeight.c,v 1.9.6.5 2003/05/16 00:29:40 niklas Exp $	*/
d28 5
a32 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.9.6.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d230 1
a230 1
	fbwscons_init(&sc->sc_sunfb, isconsole ? 0 : RI_CLEAR);
@


1.8
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d407 2
d417 1
a417 1
		while (off >= COLOR_SIZE)
@


1.7
log
@Revert back to Theo's eeprom.h.
@
text
@d2 1
a2 1
/*	$NetBSD: cgeight.c,v 1.7 1996/04/01 17:29:57 christos Exp $	*/
a93 4
int		cgeightopen __P((dev_t, int, int, struct proc *));
int		cgeightclose __P((dev_t, int, int, struct proc *));
int		cgeightioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int		cgeightmmap __P((dev_t, int, int));
d98 3
d205 2
a206 2
	fb->fb_pfour = (volatile u_int32_t *)mapiodev(ca->ca_ra.ra_reg, 0,
	    sizeof(u_int32_t), ca->ca_bustype);
d227 1
a227 1
		if (eep == NULL || eep->ee_diag.eed_console == EED_CONS_P4)
d250 1
a250 1
		    PFOUR_COLOR_OFF_OVERLAY, ramsize, ca->ca_bustype);
d255 3
a257 2
	sc->sc_fbc = (volatile struct fbcontrol *)mapiodev(ca->ca_ra.ra_reg,
	    PFOUR_COLOR_OFF_CMAP, sizeof(struct fbcontrol), ca->ca_bustype);
d408 1
a408 1
		off =- NOOVERLAY;
d429 1
a429 1
	} else if ((u_int)off < END_COLOR) {
d461 1
a461 1
	return (REG2PHYS(&sc->sc_phys, poff, sc->sc_bustype) | PMAP_NC);
@


1.6
log
@netbsd port, now we merge our changes back in
@
text
@d1 1
d228 1
a228 1
		if (eep == NULL || eep->eeConsole == EE_CONS_P4OPT)
@


1.5
log
@new mapdev/()/mapiodev() calling convention uses "struct rom_reg *" to supply
base plus an offset
new dvma routines
@
text
@d1 1
a1 1
/*	$NetBSD: cgeight.c,v 1.12 1994/11/23 07:02:07 deraadt Exp $ */
d4 1
d58 1
d65 1
d73 2
a77 1
#include <sparc/dev/cgeightreg.h>
a83 1
	volatile struct bt_regs *sc_bt;	/* Brooktree registers */
d85 1
a86 1
	int	sc_blanked;		/* true if blanked */
d97 1
d99 5
d105 2
a106 3
struct cfdriver cgeightcd = {
	NULL, "cgeight", cgeightmatch, cgeightattach,
	DV_DULL, sizeof(struct cgeight_softc)
d109 1
d119 3
d137 30
a166 1
	if (PFOUR_ID(ra->ra_pfour) == PFOUR_ID_COLOR24)
d168 3
d182 1
d187 1
a187 1
	register struct cgeight_all *p;
a188 3
#ifdef RASTERCONSOLE
	struct fbdevice fbd;
#endif
d190 19
a208 7
	sc->sc_fb.fb_driver = &cgeightfbdriver;
	sc->sc_fb.fb_device = &sc->sc_dev;
	sc->sc_fb.fb_type.fb_type = FBTYPE_MEMCOLOR;

	pfour_reset();
	pfour_videosize(ca->ca_ra.ra_pfour, &sc->sc_fb.fb_type.fb_width,
	    &sc->sc_fb.fb_type.fb_height);
d210 2
a211 1
	sc->sc_fb.fb_linebytes = sc->sc_fb.fb_type.fb_width * 4;
a212 2
	ramsize = CG8REG_END - CG8REG_OVERLAY;
	sc->sc_fb.fb_type.fb_depth = 24;
d215 15
a229 2
	printf(": %d x %d", sc->sc_fb.fb_type.fb_width,
	    sc->sc_fb.fb_type.fb_height);
d231 1
d233 9
a241 1
	 * When the ROM has mapped in a cgeight display, the address
a244 4
	 *
	 * XXX: it is insane to map the full 0x800000 space, when
	 * the mmap code down below doesn't want it that way.
	 * Ridiculous!
d246 5
a250 5
	isconsole = node == fbnode && fbconstty != NULL;
	if (ca->ca_ra.ra_vaddr == NULL) {
		/* this probably cannot happen, but what the heck */
		ca->ca_ra.ra_vaddr = mapiodev(ca->ca_ra.ra_reg, 0,
		    ramsize, ca->ca_bustype);
d252 5
a256 2
	sc->sc_fb.fb_pixels = (char *)((int)ca->ca_ra.ra_vaddr +
	    CG8REG_COLOUR - CG8REG_OVERLAY);
a257 3
#define	O(memb) ((u_int)(&((struct cgeight_all *)0)->memb))
	sc->sc_bt = bt = (volatile struct bt_regs *)mapiodev(ca->ca_ra.ra_reg,
	    O(ba_btreg), sizeof(struct bt_regs), ca->ca_bustype);
d261 1
a264 4
#if 0
	memset((caddr_t)((int)ca->ca_ra.ra_vaddr +
	    CG8REG_ENABLE - CG8REG_OVERLAY), 0x00,
	    sc->sc_fb.fb_type.fb_width * sc->sc_fb.fb_type.fb_height / 8);
d268 1
a271 5
	/* make sure we are not blanked (see cgeightunblank) */
	bt->bt_addr = 0x06;		/* command reg */
	bt->bt_ctrl = 0x73;		/* overlay plane */
	bt->bt_addr = 0x04;		/* read mask */
	bt->bt_ctrl = 0xff;		/* color planes */
d273 3
d278 2
a279 14
#ifdef RASTERCONSOLE
		/*
		 * Like SunOS and the bootrom, we want to do full-screen
		 * text on the overlay plane. But rcons_init() requires
		 * our fbdevice pointer to remain the same; so we hack
		 * the fbdevice, pass it in, and then restore it's
		 * values. Ugly -- should change rcons_init()'s interface.
		 */
		bcopy(&sc->sc_fb, &fbd, sizeof fbd);
		sc->sc_fb.fb_type.fb_depth = 1;
		sc->sc_fb.fb_linebytes = sc->sc_fb.fb_type.fb_width / 8;
		sc->sc_fb.fb_pixels = ca->ca_ra.ra_vaddr;
		rcons_init(&fbd);
		bcopy(&fbd, &sc->sc_fb, sizeof fbd);
d282 1
d284 7
a290 3
	if ((node == fbnode && cputyp != CPU_SUN4) ||
	    (isconsole && cputyp == CPU_SUN4))
		fb_attach(&sc->sc_fb);
d301 1
a301 1
	if (unit >= cgeightcd.cd_ndevs || cgeightcd.cd_devs[unit] == NULL)
d324 2
a325 1
	register struct cgeight_softc *sc = cgeightcd.cd_devs[minor(dev)];
d363 1
a363 1
		*(int *)data = sc->sc_blanked;
d367 1
a367 19
		if (*(int *)data)
			cgeightunblank(&sc->sc_dev);
		else if (!sc->sc_blanked) {
			register volatile struct bt_regs *bt;

			bt = sc->sc_bt;
			bt->bt_addr = 0x06;	/* command reg */
			bt->bt_ctrl = 0x70;	/* overlay plane */
			bt->bt_addr = 0x04;	/* read mask */
			bt->bt_ctrl = 0x00;	/* color planes */
			/*
			 * Set color 0 to black -- note that this overwrites
			 * R of color 1.
			 */
			bt->bt_addr = 0;
			bt->bt_cmap = 0;

			sc->sc_blanked = 1;
		}
d373 1
a377 45
 * Undo the effect of an FBIOSVIDEO that turns the video off.
 */
static void
cgeightunblank(dev)
	struct device *dev;
{
	struct cgeight_softc *sc = (struct cgeight_softc *)dev;
	register volatile struct bt_regs *bt;

	if (sc->sc_blanked) {
		sc->sc_blanked = 0;
		bt = sc->sc_bt;
		/* restore color 0 (and R of color 1) */
		bt->bt_addr = 0;
		bt->bt_cmap = sc->sc_cmap.cm_chip[0];

		/* restore read mask */
		bt->bt_addr = 0x06;	/* command reg */
		bt->bt_ctrl = 0x73;	/* overlay plane */
		bt->bt_addr = 0x04;	/* read mask */
		bt->bt_ctrl = 0xff;	/* color planes */
	}
}

/*
 * Load a subset of the current (new) colormap into the Brooktree DAC.
 */
static void
cgeightloadcmap(sc, start, ncolors)
	register struct cgeight_softc *sc;
	register int start, ncolors;
{
	register volatile struct bt_regs *bt;
	register u_int *ip;
	register int count;

	ip = &sc->sc_cmap.cm_chip[BT_D4M3(start)];	/* start/4 * 3 */
	count = BT_D4M3(start + ncolors - 1) - BT_D4M3(start) + 3;
	bt = sc->sc_bt;
	bt->bt_addr = BT_D4M4(start);
	while (--count >= 0)
		bt->bt_cmap = *ip++;
}

/*
d391 1
a391 1
	register struct cgeight_softc *sc = cgeightcd.cd_devs[minor(dev)];
d395 4
a398 4
#define START_COLOUR	(128*1024 + 128*1024)
#define COLOUR_SIZE	(sc->sc_fb.fb_type.fb_width * \
			    sc->sc_fb.fb_type.fb_height * 4)
#define END_COLOUR	(START_COLOUR + COLOUR_SIZE)
d407 1
a407 1
		off = off - NOOVERLAY;
d414 33
a446 10
		while (off >= COLOUR_SIZE)
			off = 0;
		poff = off + (CG8REG_COLOUR - CG8REG_OVERLAY);
	} else if ((u_int)off < START_ENABLE)	/* in overlay plane */
		poff = off;
	else if ((u_int)off < START_COLOUR)	/* in enable plane */
		poff = off + (CG8REG_ENABLE - CG8REG_OVERLAY) - START_ENABLE;
	else if ((u_int)off < END_COLOUR) 	/* in colour plane */ 
		poff = off + (CG8REG_COLOUR - CG8REG_OVERLAY) - START_COLOUR;
	else if ((u_int)off < START_SPECIAL)	/* hole */
d448 7
a454 8
	else if ((u_int)off == START_SPECIAL)	/* colour map */
		poff = CG8REG_CMAP;
	else if ((u_int)off == START_SPECIAL + NBPG) /* p4 register */
		poff = PFOUR_REG;
	else if ((u_int)off > START_SPECIAL + NBPG*2 &&
	    (u_int) off < START_SPECIAL + NBPG*2 + PROMSIZE)	/* rom */
		poff = CG8REG_P4REG + 0x8000 + off - START_SPECIAL + NBPG*2;
	else
d460 1
a460 1
	return (REG2PHYS(&sc->sc_phys, off, sc->sc_bustype) | PMAP_NC);
d462 50
@


1.4
log
@correct sun4 calls to fb_attach()
@
text
@d81 2
a82 1
	caddr_t	sc_phys;		/* display RAM (phys addr) */
a175 1
	p = (struct cgeight_all *)ca->ca_ra.ra_paddr;
d178 2
a179 2
		ca->ca_ra.ra_vaddr = mapiodev(p->ba_overlay, ramsize,
		    ca->ca_bustype);
d184 5
a188 4
	sc->sc_bt = bt = (volatile struct bt_regs *)
	    mapiodev((caddr_t)&p->ba_btreg, sizeof(p->ba_btreg),
	    ca->ca_bustype);
	sc->sc_phys = p->ba_overlay;
d439 1
a439 1
	return ((u_int)sc->sc_phys + poff + PMAP_OBIO + PMAP_NC);
@


1.3
log
@RCONSOLE -> RASTERCONSOLE
@
text
@d227 2
a228 1
	if (node == fbnode)
@


1.2
log
@modernize
@
text
@d143 1
a143 1
#ifdef RCONSOLE
d210 1
a210 1
#ifdef RCONSOLE
@


1.1
log
@new stuff
@
text
@d89 6
d101 3
a103 2
static void	cgeightunblank(struct device *);
static struct fbdriver cgeightfbdriver = { cgeightunblank };
a106 3
extern int (*v_putc)();
extern int nullop();
static int cgeight_cnputc();
a109 2
#define	CGEIGHT_MAJOR	64		/* XXX */

d139 1
a139 1
	register int node, ramsize, i;
a146 2
	sc->sc_fb.fb_major = CGEIGHT_MAJOR;	/* XXX to be removed */

a148 4
	/*
	 * The defaults below match my screen, but are not guaranteed
	 * to be correct as defaults go...
	 */
a149 1
	node = 0;
a150 1
	/* all cg8's are the same size */
d154 1
@
