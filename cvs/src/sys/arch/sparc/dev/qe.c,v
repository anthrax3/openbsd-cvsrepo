head	1.50;
access;
symbols
	OPENBSD_6_0:1.50.0.2
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.49.0.2
	OPENBSD_5_9_BASE:1.49
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.36.0.4
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.33.0.12
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.10
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.8
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.6
	OPENBSD_5_0:1.33.0.4
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.33.0.2
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.32.0.8
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.4
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.6
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.2
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.30.0.10
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.8
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.6
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.30.0.4
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.24.0.6
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.24.0.4
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	UBC_SYNC_A:1.23
	OPENBSD_3_3:1.23.0.4
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	UBC_SYNC_B:1.23
	UBC:1.17.0.4
	UBC_BASE:1.17
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4;
locks; strict;
comment	@ * @;


1.50
date	2016.04.13.11.34.00;	author mpi;	state Exp;
branches;
next	1.49;
commitid	RI1iBTF6Zaycxppg;

1.49
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.48;
commitid	J9apD0jq2AjFmqZc;

1.48
date	2015.11.25.11.20.38;	author mpi;	state Exp;
branches;
next	1.47;
commitid	f4dx5ry1aOiKJw33;

1.47
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.46;
commitid	B0kwmVGiD5DVx4kv;

1.46
date	2015.11.24.17.11.38;	author mpi;	state Exp;
branches;
next	1.45;
commitid	5gdEnqVoJuTuwdTu;

1.45
date	2015.11.24.13.33.18;	author mpi;	state Exp;
branches;
next	1.44;
commitid	5DvsamK0GblTp8ww;

1.44
date	2015.11.14.17.26.40;	author mpi;	state Exp;
branches;
next	1.43;
commitid	BU9j1tIQLqhcXEX9;

1.43
date	2015.11.12.10.26.09;	author dlg;	state Exp;
branches;
next	1.42;
commitid	4KEiv7rQSJNlE4x2;

1.42
date	2015.10.25.13.22.09;	author mpi;	state Exp;
branches;
next	1.41;
commitid	n8mxDftG1cK0Rpp7;

1.41
date	2015.09.14.11.18.49;	author stsp;	state Exp;
branches;
next	1.40;
commitid	AyPOP6b7LKyRd0yH;

1.40
date	2015.06.24.09.40.53;	author mpi;	state Exp;
branches;
next	1.39;
commitid	MVWrtktB46JRxFWT;

1.39
date	2015.03.29.10.59.47;	author mpi;	state Exp;
branches;
next	1.38;
commitid	5gSSQiWXj4PXfvMR;

1.38
date	2015.03.28.19.07.07;	author miod;	state Exp;
branches;
next	1.37;
commitid	nwbHy4sQv9NnJnmZ;

1.37
date	2014.12.22.02.26.54;	author tedu;	state Exp;
branches;
next	1.36;
commitid	2Ez9mHW0jDzojG4V;

1.36
date	2014.07.22.10.35.35;	author mpi;	state Exp;
branches;
next	1.35;
commitid	EXpEDqO4x724IPl8;

1.35
date	2013.11.27.08.56.31;	author mpi;	state Exp;
branches;
next	1.34;

1.34
date	2013.09.05.20.55.58;	author bluhm;	state Exp;
branches;
next	1.33;

1.33
date	2010.11.11.17.46.58;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.27.23.59.07;	author jason;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.25.22.41.41;	author djm;	state Exp;
branches;
next	1.28;

1.28
date	2005.11.09.06.14.50;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2005.06.08.17.03.02;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2005.01.15.05.24.10;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2004.09.29.07.35.11;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.02.18.40.59;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2002.08.07.17.23.44;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2002.04.30.01.12.29;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.01.26.43;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.08.19.02.41;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.08.18.53.38;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.01.21.39.42;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.30.21.50.06;	author jason;	state Exp;
branches
	1.17.4.1;
next	1.16;

1.16
date	2001.06.26.21.58.48;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.20.19.39.34;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.30.07.17.07;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2000.11.17.17.38.32;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2000.11.16.19.31.10;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.16.16.27.38;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.16.15.47.57;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.18.17.36.59;	author jason;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	99.12.08.22.46.10;	author jason;	state Exp;
branches
	1.8.2.1
	1.8.4.1;
next	1.7;

1.7
date	99.02.24.06.57.45;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	99.02.08.13.39.30;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	98.11.02.05.50.59;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	98.10.21.04.12.10;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	98.10.20.00.57.52;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	98.10.19.19.55.54;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	98.10.19.05.41.19;	author jason;	state Exp;
branches;
next	;

1.8.2.1
date	2001.05.14.21.37.08;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.07.04.10.23.27;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2001.10.31.03.07.56;	author nate;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2002.03.06.02.04.46;	author niklas;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.8.2.6;

1.8.2.6
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.8.2.7;

1.8.2.7
date	2003.06.07.11.14.43;	author ho;	state Exp;
branches;
next	;

1.8.4.1
date	2000.11.17.18.52.06;	author jason;	state Exp;
branches;
next	;

1.9.2.1
date	2000.11.17.20.20.09;	author jason;	state Exp;
branches;
next	;

1.17.4.1
date	2002.01.31.22.55.22;	author niklas;	state Exp;
branches;
next	1.17.4.2;

1.17.4.2
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	1.17.4.3;

1.17.4.3
date	2002.10.29.00.28.09;	author art;	state Exp;
branches;
next	;


desc
@@


1.50
log
@G/C IFQ_SET_READY().
@
text
@/*	$OpenBSD: qe.c,v 1.49 2015/12/08 13:34:22 tedu Exp $	*/

/*
 * Copyright (c) 1998, 2000 Jason L. Wright.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Driver for the SBus qec+qe QuadEthernet board.
 *
 * This driver was written using the AMD MACE Am79C940 documentation, some
 * ideas gleaned from the S/Linux driver for this card, Solaris header files,
 * and a loan of a card from Paul Southworth of the Internet Engineering
 * Group (www.ieng.com).
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/syslog.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include "bpfilter.h"
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/autoconf.h>
#include <machine/cpu.h>

#include <sparc/dev/dmareg.h>
#include <sparc/dev/dmavar.h>

#include <sparc/dev/qecvar.h>
#include <sparc/dev/qecreg.h>
#include <sparc/dev/qereg.h>
#include <sparc/dev/qevar.h>

int	qematch(struct device *, void *, void *);
void	qeattach(struct device *, struct device *, void *);

void	qeinit(struct qesoftc *);
void	qestart(struct ifnet *);
void	qestop(struct qesoftc *);
void	qewatchdog(struct ifnet *);
int	qeioctl(struct ifnet *, u_long, caddr_t);
void	qereset(struct qesoftc *);

int		qeintr(void *);
int		qe_eint(struct qesoftc *, u_int32_t);
int		qe_rint(struct qesoftc *);
int		qe_tint(struct qesoftc *);
void		qe_read(struct qesoftc *, int, int);
void		qe_mcreset(struct qesoftc *);
void		qe_ifmedia_sts(struct ifnet *, struct ifmediareq *);
int		qe_ifmedia_upd(struct ifnet *);

struct cfdriver qe_cd = {
	NULL, "qe", DV_IFNET
};

struct cfattach qe_ca = {
	sizeof(struct qesoftc), qematch, qeattach
};

int
qematch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
	register struct romaux *ra = &ca->ca_ra;

	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
		return (0);
	return (1);
}

void
qeattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct qec_softc *qec = (struct qec_softc *)parent;
	struct qesoftc *sc = (struct qesoftc *)self;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct confargs *ca = aux;
	struct bootpath *bp;
	extern void myetheraddr(u_char *);
	int pri;

	if (qec->sc_pri == 0) {
		printf(": no interrupt found on parent\n");
		return;
	}
	pri = qec->sc_pri;

	sc->sc_rev = getpropint(ca->ca_ra.ra_node, "mace-version", -1);

	sc->sc_cr = mapiodev(&ca->ca_ra.ra_reg[0], 0, sizeof(struct qe_cregs));
	sc->sc_mr = mapiodev(&ca->ca_ra.ra_reg[1], 0, sizeof(struct qe_mregs));
	sc->sc_qec = qec;
	sc->sc_qr = qec->sc_regs;
	qestop(sc);

	sc->sc_channel = getpropint(ca->ca_ra.ra_node, "channel#", -1);
	sc->sc_burst = qec->sc_burst;

	sc->sc_ih.ih_fun = qeintr;
	sc->sc_ih.ih_arg = sc;
	intr_establish(pri, &sc->sc_ih, IPL_NET, self->dv_xname);

	myetheraddr(sc->sc_arpcom.ac_enaddr);

	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_start = qestart;
	ifp->if_ioctl = qeioctl;
	ifp->if_watchdog = qewatchdog;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX |
	    IFF_MULTICAST;

	ifmedia_init(&sc->sc_ifmedia, IFM_IMASK,
	    qe_ifmedia_upd, qe_ifmedia_sts);
	ifmedia_add(&sc->sc_ifmedia,
	    IFM_MAKEWORD(IFM_ETHER, IFM_10_T, 0, 0), 0, NULL);
	ifmedia_set(&sc->sc_ifmedia, IFM_ETHER | IFM_10_T);

	IFQ_SET_MAXLEN(&ifp->if_snd, QE_TX_RING_SIZE);

	/* Attach the interface. */
	if_attach(ifp);
	ether_ifattach(ifp);

	printf(" pri %d: rev %x address %s\n", pri, sc->sc_rev,
	    ether_sprintf(sc->sc_arpcom.ac_enaddr));

	bp = ca->ca_ra.ra_bp;
	if (bp != NULL && strcmp(bp->name, "qe") == 0 &&
	    sc->sc_dev.dv_unit == bp->val[1])
		bp->dev = &sc->sc_dev;
}

/*
 * Start output on interface.
 * We make two assumptions here:
 *  1) that the current priority is set to splnet _before_ this code
 *     is called *and* is returned to the appropriate priority after
 *     return
 *  2) that the IFF_OACTIVE flag is checked before this code is called
 *     (i.e. that the output part of the interface is idle)
 */
void
qestart(ifp)
	struct ifnet *ifp;
{
	struct qesoftc *sc = (struct qesoftc *)ifp->if_softc;
	struct mbuf *m;
	int bix, len;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	bix = sc->sc_last_td;

	for (;;) {
		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;

#if NBPFILTER > 0
		/*
		 * If BPF is listening on this interface, let it see the
		 * packet before we commit it to the wire.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

		/*
		 * Copy the mbuf chain into the transmit buffer.
		 */
		len = qec_put(sc->sc_bufs->tx_buf[bix & QE_TX_RING_MASK], m);

		/*
		 * Initialize transmit registers and start transmission
		 */
		sc->sc_desc->qe_txd[bix].tx_flags =
			QE_TXD_OWN | QE_TXD_SOP | QE_TXD_EOP |
			(len & QE_TXD_LENGTH);
		sc->sc_cr->ctrl = QE_CR_CTRL_TWAKEUP;

		if (++bix == QE_TX_RING_MAXSIZE)
			bix = 0;

		if (++sc->sc_no_td == QE_TX_RING_SIZE) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}
	}

	sc->sc_last_td = bix;
}

void
qestop(sc)
	struct qesoftc *sc;
{	
	struct qe_cregs *cr = sc->sc_cr;
	struct qe_mregs *mr = sc->sc_mr;
	int n;

	mr->biucc = QE_MR_BIUCC_SWRST;
	for (n = 200; n > 0; n--) {
		if ((mr->biucc & QE_MR_BIUCC_SWRST) == 0)
			break;
		DELAY(20);
	}

	cr->ctrl = QE_CR_CTRL_RESET;
	for (n = 200; n > 0; n--) {
		if ((cr->ctrl & QE_CR_CTRL_RESET) == 0)
			break;
		DELAY(20);
	}
}

/*
 * Reset interface.
 */
void
qereset(sc)
	struct qesoftc *sc;
{
	qestop(sc);
	qeinit(sc);
}

void
qewatchdog(ifp)
	struct ifnet *ifp;
{
	struct qesoftc *sc = ifp->if_softc;
	int s;

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	++sc->sc_arpcom.ac_if.if_oerrors;

	s = splnet();
	qereset(sc);
	splx(s);
}

/*
 * Interrupt dispatch.
 */
int
qeintr(v)
	void *v;
{
	struct qesoftc *sc = (struct qesoftc *)v;
	u_int32_t qecstat, qestat;
	int r = 0;

	qecstat = sc->sc_qr->stat >> (4 * sc->sc_channel);
	if ((qecstat & 0xf) == 0)
		return (r);

	qestat = sc->sc_cr->stat;

	if (qestat & QE_CR_STAT_ALLERRORS) {
		r |= qe_eint(sc, qestat);
		if (r == -1)
			return (1);
	}

	if (qestat & QE_CR_STAT_TXIRQ)
		r |= qe_tint(sc);

	if (qestat & QE_CR_STAT_RXIRQ)
		r |= qe_rint(sc);

	return (1);
}

/*
 * Transmit interrupt.
 */
int
qe_tint(sc)
	struct qesoftc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int bix;
	struct qe_txd txd;

	bix = sc->sc_first_td;

	for (;;) {
		if (sc->sc_no_td <= 0)
			break;

		txd.tx_flags = sc->sc_desc->qe_txd[bix].tx_flags;
		if (txd.tx_flags & QE_TXD_OWN)
			break;

		ifp->if_opackets++;

		if (++bix == QE_TX_RING_MAXSIZE)
			bix = 0;

		--sc->sc_no_td;
	}

	if (sc->sc_no_td == 0)
		ifp->if_timer = 0;

	/*
	 * If we freed up at least one descriptor and tx is blocked,
	 * unblock it and start it up again.
	 */
	if (sc->sc_first_td != bix) {
		sc->sc_first_td = bix;
		if (ifq_is_oactive(&ifp->if_snd)) {
			ifq_clr_oactive(&ifp->if_snd);
			qestart(ifp);
		}
	}

	return (1);
}

/*
 * Receive interrupt.
 */
int
qe_rint(sc)
	struct qesoftc *sc;
{
	int bix, len;

	bix = sc->sc_last_rd;

	/*
	 * Process all buffers with valid data.
	 */
	for (;;) {
		if (sc->sc_desc->qe_rxd[bix].rx_flags & QE_RXD_OWN)
			break;

		len = (sc->sc_desc->qe_rxd[bix].rx_flags & QE_RXD_LENGTH) - 4;
		qe_read(sc, bix, len);
		sc->sc_desc->qe_rxd[(bix + QE_RX_RING_SIZE) & QE_RX_RING_MAXMASK].rx_flags =
		    QE_RXD_OWN | QE_RXD_LENGTH;

		if (++bix == QE_RX_RING_MAXSIZE)
			bix = 0;
	}

	sc->sc_last_rd = bix;

	return (1);
}

/*
 * Error interrupt.
 */
int
qe_eint(sc, why)
	struct qesoftc *sc;
	u_int32_t why;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int r = 0, rst = 0;

	if (why & QE_CR_STAT_EDEFER) {
		printf("%s: excessive tx defers.\n", sc->sc_dev.dv_xname);
		r |= 1;
		ifp->if_oerrors++;
	}

	if (why & QE_CR_STAT_CLOSS) {
		ifp->if_oerrors++;
		r |= 1;
	}

	if (why & QE_CR_STAT_ERETRIES) {
		printf("%s: excessive tx retries\n", sc->sc_dev.dv_xname);
		ifp->if_oerrors++;
		r |= 1;
		rst = 1;
	}

	if (why & QE_CR_STAT_LCOLL) {
		printf("%s: late tx transmission\n", sc->sc_dev.dv_xname);
		ifp->if_oerrors++;
		r |= 1;
		rst = 1;
	}

	if (why & QE_CR_STAT_FUFLOW) {
		printf("%s: tx fifo underflow\n", sc->sc_dev.dv_xname);
		ifp->if_oerrors++;
		r |= 1;
		rst = 1;
	}

	if (why & QE_CR_STAT_JERROR) {
		printf("%s: jabber seen\n", sc->sc_dev.dv_xname);
		r |= 1;
	}

	if (why & QE_CR_STAT_BERROR) {
		printf("%s: babble seen\n", sc->sc_dev.dv_xname);
		r |= 1;
	}

	if (why & QE_CR_STAT_TCCOFLOW) {
		ifp->if_collisions += 256;
		ifp->if_oerrors += 256;
		r |= 1;
	}

	if (why & QE_CR_STAT_TXDERROR) {
		printf("%s: tx descriptor is bad\n", sc->sc_dev.dv_xname);
		rst = 1;
		r |= 1;
	}

	if (why & QE_CR_STAT_TXLERR) {
		printf("%s: tx late error\n", sc->sc_dev.dv_xname);
		ifp->if_oerrors++;
		rst = 1;
		r |= 1;
	}

	if (why & QE_CR_STAT_TXPERR) {
		printf("%s: tx dma parity error\n", sc->sc_dev.dv_xname);
		ifp->if_oerrors++;
		rst = 1;
		r |= 1;
	}

	if (why & QE_CR_STAT_TXSERR) {
		printf("%s: tx dma sbus error ack\n", sc->sc_dev.dv_xname);
		ifp->if_oerrors++;
		rst = 1;
		r |= 1;
	}

	if (why & QE_CR_STAT_RCCOFLOW) {
		ifp->if_collisions += 256;
		ifp->if_ierrors += 256;
		r |= 1;
	}

	if (why & QE_CR_STAT_RUOFLOW) {
		ifp->if_ierrors += 256;
		r |= 1;
	}

	if (why & QE_CR_STAT_MCOFLOW) {
		ifp->if_ierrors += 256;
		r |= 1;
	}

	if (why & QE_CR_STAT_RXFOFLOW) {
		printf("%s: rx fifo overflow\n", sc->sc_dev.dv_xname);
		ifp->if_ierrors++;
		r |= 1;
	}

	if (why & QE_CR_STAT_RLCOLL) {
		printf("%s: rx late collision\n", sc->sc_dev.dv_xname);
		ifp->if_ierrors++;
		ifp->if_collisions++;
		r |= 1;
	}

	if (why & QE_CR_STAT_FCOFLOW) {
		ifp->if_ierrors += 256;
		r |= 1;
	}

	if (why & QE_CR_STAT_CECOFLOW) {
		ifp->if_ierrors += 256;
		r |= 1;
	}

	if (why & QE_CR_STAT_RXDROP) {
		printf("%s: rx packet dropped\n", sc->sc_dev.dv_xname);
		ifp->if_ierrors++;
		r |= 1;
	}

	if (why & QE_CR_STAT_RXSMALL) {
		printf("%s: rx buffer too small\n", sc->sc_dev.dv_xname);
		ifp->if_ierrors++;
		r |= 1;
		rst = 1;
	}

	if (why & QE_CR_STAT_RXLERR) {
		printf("%s: rx late error\n", sc->sc_dev.dv_xname);
		ifp->if_ierrors++;
		r |= 1;
		rst = 1;
	}

	if (why & QE_CR_STAT_RXPERR) {
		printf("%s: rx dma parity error\n", sc->sc_dev.dv_xname);
		ifp->if_ierrors++;
		r |= 1;
		rst = 1;
	}

	if (why & QE_CR_STAT_RXSERR) {
		printf("%s: rx dma sbus error ack\n", sc->sc_dev.dv_xname);
		ifp->if_ierrors++;
		r |= 1;
		rst = 1;
	}

	if (r == 0)
		printf("%s: unexpected interrupt error: %08x\n",
			sc->sc_dev.dv_xname, why);

	if (rst) {
		printf("%s: resetting...\n", sc->sc_dev.dv_xname);
		qereset(sc);
		return (-1);
	}

	return (r);
}

int
qeioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct qesoftc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		qeinit(sc);
		break;

	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running, then
			 * stop it.
			 */
			qestop(sc);
			ifp->if_flags &= ~IFF_RUNNING;
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
		    (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped, then
			 * start it.
			 */
			qeinit(sc);
		} else {
			/*
			 * Reset the interface to pick up changes in any other
			 * flags that affect hardware registers.
			 */
			qestop(sc);
			qeinit(sc);
		}
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_ifmedia, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			qeinit(sc);
		error = 0;
	}

	splx(s);
	return (error);
}

void
qeinit(sc)
	struct qesoftc *sc;
{
	struct qe_mregs *mr = sc->sc_mr;
	struct qe_cregs *cr = sc->sc_cr;
	struct qec_softc *qec = sc->sc_qec;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int s = splnet();
	int i;

	qestop(sc);

	/*
	 * Allocate descriptor ring and buffers, if not already done
	 */
	if (sc->sc_desc == NULL)
		sc->sc_desc_dva = (struct qe_desc *) dvma_malloc(
		    sizeof(struct qe_desc), &sc->sc_desc, M_NOWAIT | M_ZERO);

	if (sc->sc_bufs == NULL)
		sc->sc_bufs_dva = (struct qe_bufs *) dvma_malloc(
		    sizeof(struct qe_bufs), &sc->sc_bufs, M_NOWAIT | M_ZERO);

	for (i = 0; i < QE_TX_RING_MAXSIZE; i++)
		sc->sc_desc->qe_txd[i].tx_addr =
			(u_int32_t)sc->sc_bufs_dva->tx_buf[i & QE_TX_RING_MASK];
	for (i = 0; i < QE_RX_RING_MAXSIZE; i++) {
		sc->sc_desc->qe_rxd[i].rx_addr =
			(u_int32_t)sc->sc_bufs_dva->rx_buf[i & QE_RX_RING_MASK];
		if (i < QE_RX_RING_SIZE)
			sc->sc_desc->qe_rxd[i].rx_flags =
				QE_RXD_OWN | QE_RXD_LENGTH;
	}

	cr->rxds = (u_int32_t)sc->sc_desc_dva->qe_rxd;
	cr->txds = (u_int32_t)sc->sc_desc_dva->qe_txd;

	sc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;
	sc->sc_last_rd = 0;

	cr->rimask = 0;
	cr->timask = 0;
	cr->qmask = 0;
	cr->mmask = QE_CR_MMASK_RXCOLL | QE_CR_MMASK_CLOSS;
	cr->ccnt = 0;
	cr->pipg = 0;
	cr->rxwbufptr = cr->rxrbufptr = sc->sc_channel * qec->sc_msize;
	cr->txwbufptr = cr->txrbufptr = cr->rxrbufptr + qec->sc_rsize;

	/*
	 * When switching from mace<->qec always guarantee an sbus
	 * turnaround (if last op was read, perform a dummy write, and
	 * vice versa).
	 */
	i = cr->qmask;		/* dummy */

	mr->biucc = QE_MR_BIUCC_BSWAP | QE_MR_BIUCC_64TS;
	mr->fifofc = QE_MR_FIFOCC_TXF16 | QE_MR_FIFOCC_RXF32 |
	    QE_MR_FIFOCC_RFWU | QE_MR_FIFOCC_TFWU;
	mr->xmtfc = QE_MR_XMTFC_APADXMT;
	mr->rcvfc = 0;
	mr->imr = QE_MR_IMR_CERRM | QE_MR_IMR_RCVINTM;
	mr->phycc = QE_MR_PHYCC_ASEL;
	mr->plscc = QE_MR_PLSCC_TP;

	qe_ifmedia_upd(ifp);

	mr->iac = QE_MR_IAC_ADDRCHG | QE_MR_IAC_PHYADDR;
	for (i = 100; i > 0; i--) {
		if ((mr->iac & QE_MR_IAC_ADDRCHG) == 0)
			break;
		DELAY(2);
	}
	mr->padr = sc->sc_arpcom.ac_enaddr[0];
	mr->padr = sc->sc_arpcom.ac_enaddr[1];
	mr->padr = sc->sc_arpcom.ac_enaddr[2];
	mr->padr = sc->sc_arpcom.ac_enaddr[3];
	mr->padr = sc->sc_arpcom.ac_enaddr[4];
	mr->padr = sc->sc_arpcom.ac_enaddr[5];
	qe_mcreset(sc);
	mr->iac = 0;

	i = mr->mpc;	/* cleared on read */

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	mr->maccc = QE_MR_MACCC_ENXMT | QE_MR_MACCC_ENRCV |
	    ((ifp->if_flags & IFF_PROMISC) ? QE_MR_MACCC_PROM : 0);
	splx(s);
}

/*
 * Pass a packet to the higher levels.
 */
void
qe_read(sc, idx, len)
	struct qesoftc *sc;
	int idx, len;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;

	if (len <= sizeof(struct ether_header) ||
	    len > ETHERMTU + sizeof(struct ether_header)) {

		printf("%s: invalid packet size %d; dropping\n",
			ifp->if_xname, len);

		ifp->if_ierrors++;
		return;
	}

	/*
	 * Pull packet off interface.
	 */
	m = qec_get(sc->sc_bufs->rx_buf[idx & QE_RX_RING_MASK], len);
	if (m == NULL) {
		ifp->if_ierrors++;
		return;
	}

	ml_enqueue(&ml, m);
	if_input(ifp, &ml);
}

/*
 * Reset multicast filter.
 */
void
qe_mcreset(sc)
	struct qesoftc *sc;
{
	struct arpcom *ac = &sc->sc_arpcom;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct qe_mregs *mr = sc->sc_mr;
	struct ether_multi *enm;
	struct ether_multistep step;
	u_int32_t crc;
	u_int16_t hash[4];
	u_int8_t octet, *ladrp = (u_int8_t *)&hash[0];
	int i, j;

	if (ac->ac_multirangecnt > 0)
		ifp->if_flags |= IFF_ALLMULTI;

	if (ifp->if_flags & IFF_ALLMULTI) {
		mr->iac = QE_MR_IAC_ADDRCHG | QE_MR_IAC_LOGADDR;
		for (i = 100; i > 0; i--) {
			if ((mr->iac & QE_MR_IAC_ADDRCHG) == 0)
				break;
			DELAY(2);
		}
		for (i = 0; i < 8; i++)
			mr->ladrf = 0xff;
		return;
	}

	hash[3] = hash[2] = hash[1] = hash[0] = 0;

	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		crc = 0xffffffff;

		for (i = 0; i < ETHER_ADDR_LEN; i++) {
			octet = enm->enm_addrlo[i];

			for (j = 0; j < 8; j++) {
				if ((crc & 1) ^ (octet & 1)) {
					crc >>= 1;
					crc ^= MC_POLY_LE;
				}
				else
					crc >>= 1;
				octet >>= 1;
			}
		}

		crc >>= 26;
		hash[crc >> 4] |= 1 << (crc & 0xf);
		ETHER_NEXT_MULTI(step, enm);
	}

	mr->iac = QE_MR_IAC_ADDRCHG | QE_MR_IAC_LOGADDR;
	for (i = 100; i > 0; i--) {
		if ((mr->iac & QE_MR_IAC_ADDRCHG) == 0)
			break;
		DELAY(2);
	}
	for (i = 0; i < 8; i++)
		mr->ladrf = ladrp[i];
}

void
qe_ifmedia_sts(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
{
	struct qesoftc *sc = (struct qesoftc *)ifp->if_softc;
	u_int8_t phycc;

	ifmr->ifm_active = IFM_ETHER | IFM_10_T;
	phycc = sc->sc_mr->phycc;
	if ((phycc & QE_MR_PHYCC_DLNKTST) == 0) {
		ifmr->ifm_status |= IFM_AVALID;
		if (phycc & QE_MR_PHYCC_LNKFL)
			ifmr->ifm_status &= ~IFM_ACTIVE;
		else
			ifmr->ifm_status |= IFM_ACTIVE;
	}
}

int
qe_ifmedia_upd(ifp)
	struct ifnet *ifp;
{
	struct qesoftc *sc = (struct qesoftc *)ifp->if_softc;
	uint64_t media = sc->sc_ifmedia.ifm_media;

	if (IFM_TYPE(media) != IFM_ETHER)
		return (EINVAL);

	if (IFM_SUBTYPE(media) != IFM_10_T)
		return (EINVAL);

	return (0);
}
@


1.49
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.48 2015/11/25 11:20:38 mpi Exp $	*/
a161 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.48
log
@Network drivers should not include <net/route.h> or <net/netisr.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.47 2015/11/25 03:09:58 dlg Exp $	*/
d152 1
a152 1
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS |
@


1.47
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.46 2015/11/24 17:11:38 mpi Exp $	*/
a49 1
#include <net/netisr.h>
@


1.46
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.45 2015/11/24 13:33:18 mpi Exp $	*/
d195 1
a195 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d231 1
a231 1
			ifp->if_flags |= IFF_OACTIVE;
d358 2
a359 2
		if (ifp->if_flags & IFF_OACTIVE) {
			ifp->if_flags &= ~IFF_OACTIVE;
d720 1
a720 1
	ifp->if_flags &= ~IFF_OACTIVE;
@


1.45
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.44 2015/11/14 17:26:40 mpi Exp $	*/
a48 1
#include <net/if_dl.h>
@


1.44
log
@No need to include <net/bpfdesc.h>

Now that "struct bpf_d" depends on <sys/srp.h> this is one of the offender
for removing the header from <sys/param.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.43 2015/11/12 10:26:09 dlg Exp $	*/
a49 1
#include <net/if_types.h>
@


1.43
log
@can just IFQ_DEQUEUE instead of POLL followed immediately by DEQUEUE

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.42 2015/10/25 13:22:09 mpi Exp $	*/
a59 1
#include <net/bpfdesc.h>
@


1.42
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.41 2015/09/14 11:18:49 stsp Exp $	*/
d204 1
a204 1
		IFQ_POLL(&ifp->if_snd, m);
a206 2

		IFQ_DEQUEUE(&ifp->if_snd, m);
@


1.41
log
@Fix more ifmedia64 fallout in the kernel. It's hiding everywhere...
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.40 2015/06/24 09:40:53 mpi Exp $	*/
a582 1
	struct ifaddr *ifa = (struct ifaddr *)data;
d591 1
a591 9
		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
			qeinit(sc);
			arp_ifinit(&sc->sc_arpcom, ifa);
			break;
		default:
			qeinit(sc);
			break;
		}
@


1.40
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.39 2015/03/29 10:59:47 mpi Exp $	*/
d867 1
a867 1
	int media = sc->sc_ifmedia.ifm_media;
@


1.39
log
@Convert qe(4) et be(4) to if_input().

Tested by miod@@, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.38 2015/03/28 19:07:07 miod Exp $	*/
a770 1
	ifp->if_ipackets++;
@


1.38
log
@Don't include sbusvar.h if you need neither sbus_translate() nor sbus_testdma().
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.37 2014/12/22 02:26:54 tedu Exp $	*/
d750 1
d766 1
a766 1
	m = qec_get(ifp, sc->sc_bufs->rx_buf[idx & QE_RX_RING_MASK], len);
d773 2
a774 10
#if NBPFILTER > 0
	/*
	 * Check if there's a BPF listener on this interface.
	 * If so, hand off the raw packet to BPF.
	 */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
	/* Pass the packet up. */
	ether_input_mbuf(ifp, m);
@


1.37
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.36 2014/07/22 10:35:35 mpi Exp $	*/
a65 1
#include <sparc/dev/sbusvar.h>
@


1.36
log
@<netinet/in_systm.h> is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.35 2013/11/27 08:56:31 mpi Exp $	*/
a593 1
#ifdef INET
a597 1
#endif /* INET */
@


1.35
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not change the behavior of any driver but if you encounter
any problem, feel free to revert the offending chunk and ping me about
it.

ok naddy@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.34 2013/09/05 20:55:58 bluhm Exp $	*/
a53 1
#ifdef INET
a54 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a55 1
#endif
@


1.34
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Remove these include lines from mvme68k, mvme88k,
sparc drivers.
test and OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.33 2010/11/11 17:46:58 miod Exp $	*/
d808 3
a810 1
allmulti:
a826 16
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi,
		    ETHER_ADDR_LEN)) {
			/*
			 * We must listen to a range of multicast
			 * addresses. For now, just accept all
			 * multicasts, rather than trying to set only
			 * those filter bits needed to match the range.
			 * (At this time, the only use of address
			 * ranges is for IP multicast routing, for
			 * which the range is big enough to require
			 * all bits set.)
			 */
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
		}

@


1.33
log
@Pass a few more M_ZERO to malloc() or its wrappers, when useful; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.32 2008/11/28 02:44:17 brad Exp $	*/
a56 1
#include <netinet/in_var.h>
@


1.32
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.31 2008/10/02 20:21:13 brad Exp $	*/
d674 1
a674 2
			sizeof(struct qe_desc), &sc->sc_desc, M_NOWAIT);
	bzero(sc->sc_desc, sizeof(struct qe_desc));
d678 1
a678 2
			sizeof(struct qe_bufs), &sc->sc_bufs, M_NOWAIT);
	bzero(sc->sc_bufs, sizeof(struct qe_bufs));
@


1.31
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.30 2006/05/27 23:59:07 jason Exp $	*/
a636 16
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom):
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				qeinit(sc);
			error = 0;
		}
		break;
d641 1
d644 6
@


1.30
log
@unknown ioctl is ENOTTY not EINVAL
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.29 2006/03/25 22:41:41 djm Exp $	*/
d658 1
a658 6
		if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
			splx(s);
			return (error);
		}
		error = ENOTTY;
		break;
d660 1
@


1.29
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.28 2005/11/09 06:14:50 brad Exp $	*/
d662 1
a662 1
		error = EINVAL;
@


1.28
log
@splimp -> splnet
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.27 2005/06/08 17:03:02 henning Exp $	*/
d222 1
a222 1
			bpf_mtap(ifp->if_bpf, m);
d801 1
a801 1
		bpf_mtap(ifp->if_bpf, m);
@


1.27
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.26 2005/01/15 05:24:10 brad Exp $	*/
d677 1
a677 1
	int s = splimp();
@


1.26
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.25 2004/09/29 07:35:11 miod Exp $	*/
a604 18
#ifdef NS
		/* XXX - This code is probably wrong. */
		case AF_NS:
		    {
			struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host = *(union ns_host *)
				    (sc->sc_arpcom.ac_enaddr);
			else
				bcopy(ina->x_host.c_host,
				    sc->sc_arpcom.ac_enaddr,
				    sizeof(sc->sc_arpcom.ac_enaddr));
			/* Set new address. */
			qeinit(sc);
			break;
		    }
#endif /* NS */
@


1.25
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.24 2003/06/02 18:40:59 jason Exp $	*/
d666 1
a666 1
			if (ifp->if_flags & IFF_UP)
@


1.24
log
@nuke my clause 3 & 4 (and a couple jointly (c) with Theo).
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.23 2002/08/07 17:23:44 jason Exp $	*/
d153 1
a153 1
	intr_establish(pri, &sc->sc_ih, IPL_NET);
@


1.23
log
@KNF (parenthesized returns)
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.22 2002/04/30 01:12:29 art Exp $	*/
a14 2
 * 3. The name of the authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.22
log
@Fix an ancient problem in how sparc interrupts are handled.

There are many interrupt handlers that assume that they don't need to do
any spl protection in their code because the interrupt of some level can't
be interrupted by an interrupt of the same level. The problem is that some
interrupt handlers have hardware levels that are lower then their "software"
levels.

Fix this by adding an additional field to struct intrhand that specifies which
"software" level an interrupt handler has and blocks that level while handling
the interrupt. This new field is initialized in intr_establish which gets
an additional argument (which can be -1 meaning that the interrupt handler
doesn't need to block any additional level).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.21 2002/03/14 01:26:43 millert Exp $	*/
d314 1
a314 1
		return r;
d321 1
a321 1
			return 1;
d409 1
a409 1
	return 1;
d578 1
a578 1
		return -1;
d581 1
a581 1
	return r;
d680 1
a680 1
			return error;
d686 1
a686 1
	return error;
@


1.21
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.20 2002/02/08 19:02:41 jason Exp $	*/
d155 1
a155 1
	intr_establish(pri, &sc->sc_ih);
@


1.20
log
@since we're checking, avoid an unnecessary write
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.19 2002/02/08 18:53:38 jason Exp $	*/
d82 2
a83 2
int	qematch __P((struct device *, void *, void *));
void	qeattach __P((struct device *, struct device *, void *));
d85 15
a99 15
void	qeinit __P((struct qesoftc *));
void	qestart __P((struct ifnet *));
void	qestop __P((struct qesoftc *));
void	qewatchdog __P((struct ifnet *));
int	qeioctl __P((struct ifnet *, u_long, caddr_t));
void	qereset __P((struct qesoftc *));

int		qeintr __P((void *));
int		qe_eint __P((struct qesoftc *, u_int32_t));
int		qe_rint __P((struct qesoftc *));
int		qe_tint __P((struct qesoftc *));
void		qe_read __P((struct qesoftc *, int, int));
void		qe_mcreset __P((struct qesoftc *));
void		qe_ifmedia_sts __P((struct ifnet *, struct ifmediareq *));
int		qe_ifmedia_upd __P((struct ifnet *));
d133 1
a133 1
	extern void myetheraddr __P((u_char *));
@


1.19
log
@Better IFF_OACTIVE handling; don't bother calling qestart() unless
we were IFF_OACTIVE and we freed at least one slot.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.18 2002/01/01 21:39:42 jason Exp $	*/
d369 6
a374 3
	if ((sc->sc_first_td != bix) && (ifp->if_flags & IFF_OACTIVE)) {
		ifp->if_flags &= ~IFF_OACTIVE;
		qestart(ifp);
a375 2

	sc->sc_first_td = bix;
@


1.18
log
@Don't whine about not having carrier... ifconfig on the interface will say so.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.17 2001/07/30 21:50:06 jason Exp $	*/
d212 1
a212 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
d216 2
d330 1
a330 1
	return r;
a353 1
		ifp->if_flags &= ~IFF_OACTIVE;
d362 2
a363 1
	sc->sc_first_td = bix;
d365 8
a372 1
	qestart(ifp);
d374 1
a374 2
	if (sc->sc_no_td == 0)
		ifp->if_timer = 0;
d376 1
a376 1
	return 1;
@


1.17
log
@convert to ALTQ style macros (these drivers appear to meet the criteria for
ALTQ, anyone more familiar with it wanna have a look?)
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.16 2001/06/26 21:58:48 fgsch Exp $	*/
a420 1
		printf("%s: no carrier, link down?\n", sc->sc_dev.dv_xname);
@


1.17.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.18 2002/01/01 21:39:42 jason Exp $	*/
d421 1
@


1.17.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.17.4.1 2002/01/31 22:55:22 niklas Exp $	*/
d82 2
a83 2
int	qematch(struct device *, void *, void *);
void	qeattach(struct device *, struct device *, void *);
d85 15
a99 15
void	qeinit(struct qesoftc *);
void	qestart(struct ifnet *);
void	qestop(struct qesoftc *);
void	qewatchdog(struct ifnet *);
int	qeioctl(struct ifnet *, u_long, caddr_t);
void	qereset(struct qesoftc *);

int		qeintr(void *);
int		qe_eint(struct qesoftc *, u_int32_t);
int		qe_rint(struct qesoftc *);
int		qe_tint(struct qesoftc *);
void		qe_read(struct qesoftc *, int, int);
void		qe_mcreset(struct qesoftc *);
void		qe_ifmedia_sts(struct ifnet *, struct ifmediareq *);
int		qe_ifmedia_upd(struct ifnet *);
d133 1
a133 1
	extern void myetheraddr(u_char *);
d155 1
a155 1
	intr_establish(pri, &sc->sc_ih, IPL_NET);
d212 1
a212 1
		IFQ_POLL(&ifp->if_snd, m);
a215 2
		IFQ_DEQUEUE(&ifp->if_snd, m);

d328 1
a328 1
	return (1);
d352 1
d361 4
d368 1
a368 13
	/*
	 * If we freed up at least one descriptor and tx is blocked,
	 * unblock it and start it up again.
	 */
	if (sc->sc_first_td != bix) {
		sc->sc_first_td = bix;
		if (ifp->if_flags & IFF_OACTIVE) {
			ifp->if_flags &= ~IFF_OACTIVE;
			qestart(ifp);
		}
	}

	return (1);
@


1.17.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.17.4.2 2002/06/11 03:38:16 art Exp $	*/
d314 1
a314 1
		return (r);
d321 1
a321 1
			return (1);
d409 1
a409 1
	return (1);
d578 1
a578 1
		return (-1);
d581 1
a581 1
	return (r);
d680 1
a680 1
			return (error);
d686 1
a686 1
	return (error);
@


1.16
log
@trivial ether_input_mbuf() conversions.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.15 2001/02/20 19:39:34 mickey Exp $	*/
d173 3
d212 2
a213 2
		IF_DEQUEUE(&ifp->if_snd, m);
		if (m == 0)
@


1.15
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.14 2001/01/30 07:17:07 jason Exp $	*/
a781 1
	struct ether_header *eh;
a803 3
	/* We assume that the header fit entirely in one mbuf. */
	eh = mtod(m, struct ether_header *);

d812 2
a813 3
	/* Pass the packet up, with the ether header sort-of removed. */
	m_adj(m, sizeof(struct ether_header));
	ether_input(ifp, eh, m);
@


1.14
log
@- take advantage of the fact that qe's and be's require qec's and move
some common functionality into qec's driver (rx and tx frame fetching)
- avoid modulus operations
- some style
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.13 2000/11/17 17:38:32 jason Exp $	*/
a178 5

#if NBPFILTER > 0
	bpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
	    sizeof(struct ether_header));
#endif
@


1.13
log
@seems the qe/mace combination needs a delay between accesses to the
two chips.  Better fix for the NMI problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.12 2000/11/16 19:31:10 jason Exp $	*/
a95 1
int		qe_put __P((struct qesoftc *, int, struct mbuf *));
a96 1
struct mbuf *	qe_get __P((struct qesoftc *, int, int));
d230 1
a230 1
		len = qe_put(sc, bix, m);
d393 1
a393 1
		sc->sc_desc->qe_rxd[(bix + QE_RX_RING_SIZE) % QE_RX_RING_MAXSIZE].rx_flags =
d711 1
a711 1
			(u_int32_t) &sc->sc_bufs_dva->tx_buf[i % QE_TX_RING_SIZE][0];
d714 2
a715 2
			(u_int32_t) &sc->sc_bufs_dva->rx_buf[i % QE_RX_RING_SIZE][0];
		if ((i / QE_RX_RING_SIZE) == 0)
d720 2
a721 2
	cr->rxds = (u_int32_t) &sc->sc_desc_dva->qe_rxd[0];
	cr->txds = (u_int32_t) &sc->sc_desc_dva->qe_txd[0];
a778 28
 * Routine to copy from mbuf chain to transmit buffer in
 * network buffer memory.
 */
int
qe_put(sc, idx, m)
	struct qesoftc *sc;
	int idx;
	struct mbuf *m;
{
	struct mbuf *n;
	int len, tlen = 0, boff = 0;

	for (; m; m = n) {
		len = m->m_len;
		if (len == 0) {
			MFREE(m, n);
			continue;
		}
		bcopy(mtod(m, caddr_t),
		      &sc->sc_bufs->tx_buf[idx % QE_TX_RING_SIZE][boff], len);
		boff += len;
		tlen += len;
		MFREE(m, n);
	}
	return tlen;
}

/*
d803 1
a803 1
	m = qe_get(sc, idx, len);
a823 59
}

/*
 * Pull data off an interface.
 * Len is the length of data, with local net header stripped.
 * We copy the data into mbufs.  When full cluster sized units are present,
 * we copy into clusters.
 */
struct mbuf *
qe_get(sc, idx, totlen)
	struct qesoftc *sc;
	int idx, totlen;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf *m;
	struct mbuf *top, **mp;
	int len, pad, boff = 0;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (NULL);
	m->m_pkthdr.rcvif = ifp;
	m->m_pkthdr.len = totlen;
	pad = ALIGN(sizeof(struct ether_header)) - sizeof(struct ether_header);
	len = MHLEN;
	if (totlen >= MINCLSIZE) {
		MCLGET(m, M_DONTWAIT);
		if (m->m_flags & M_EXT)
			len = MCLBYTES;
	}
	m->m_data += pad;
	len -= pad;
	top = NULL;
	mp = &top;

	while (totlen > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == NULL) {
				m_freem(top);
				return NULL;
			}
			len = MLEN;
		}
		if (top && totlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if (m->m_flags & M_EXT)
				len = MCLBYTES;
		}
		m->m_len = len = min(totlen, len);
		bcopy(&sc->sc_bufs->rx_buf[idx % QE_RX_RING_SIZE][boff],
		      mtod(m, caddr_t), len);
		boff += len;
		totlen -= len;
		*mp = m;
		mp = &m->m_next;
	}

	return (top);
@


1.12
log
@- remove other media types, the MACE isn't as bright as one would hope
- always set it to autoselect, tp
- remove the wait for media stuff: appears to be a local issue on
- simplify the ifmedia callbacks appropriately
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.11 2000/11/16 16:27:38 jason Exp $	*/
d737 6
a742 5
	for (i = 500; i > 0; i--) {
		if ((mr->biucc & QE_MR_BIUCC_SWRST) == 0)
			break;
		DELAY(10);
	}
d770 1
a770 1
	i = mr->mpc;
@


1.11
log
@wait for the MACE to figure out whether it has media or not, and then
clear interrupt status and such before enabling rx and tx.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.10 2000/11/16 15:47:57 jason Exp $	*/
d173 1
a173 5
	ifmedia_add(&sc->sc_ifmedia,
	    IFM_MAKEWORD(IFM_ETHER, IFM_10_5, 0, 0), 0, NULL);
	ifmedia_add(&sc->sc_ifmedia,
	    IFM_MAKEWORD(IFM_ETHER, IFM_AUTO, 0, 0), 0, NULL);
	ifmedia_set(&sc->sc_ifmedia, IFM_ETHER | IFM_AUTO);
d731 1
a731 1
	cr->mmask = QE_CR_MMASK_RXCOLL;
d749 2
a768 4
	DELAY(50000);
	i = mr->phycc;
	i = sc->sc_qr->stat;
	i = cr->stat;
d1001 1
a1001 22
	struct qe_mregs *mr = sc->sc_mr;
	u_int8_t plscc, phycc;

	plscc = mr->plscc;
	phycc = mr->phycc;

	if (phycc & QE_MR_PHYCC_ASEL)
		ifmr->ifm_active = IFM_ETHER | IFM_AUTO;
	else {
		switch (plscc & QE_MR_PLSCC_PORTMASK) {
		case QE_MR_PLSCC_TP:
			ifmr->ifm_active = IFM_ETHER | IFM_10_T;
			break;
		case QE_MR_PLSCC_AUI:
			ifmr->ifm_active = IFM_ETHER | IFM_10_5;
			break;
		case QE_MR_PLSCC_DAI:
		case QE_MR_PLSCC_GPSI:
			/* ... */
			break;
		}
	}
d1003 2
a1018 1
	struct qe_mregs *mr = sc->sc_mr;
a1019 1
	u_int8_t plscc, phycc;
d1024 1
a1024 10
	plscc = mr->plscc & (~QE_MR_PLSCC_PORTMASK);
	phycc = mr->phycc & (~QE_MR_PHYCC_ASEL);

	if (IFM_SUBTYPE(media) == IFM_AUTO)
		phycc |= QE_MR_PHYCC_ASEL;
	else if (IFM_SUBTYPE(media) == IFM_10_T)
		plscc |= QE_MR_PLSCC_TP;
	else if (IFM_SUBTYPE(media) == IFM_10_5)
		plscc |= QE_MR_PLSCC_AUI;
	else
a1025 3

	mr->plscc = plscc;
	mr->phycc = phycc;
@


1.10
log
@- Fix the NMI problem: it seems the qec channel reset also resets the MACE, and
a race condition existed where after a qec channel reset, accesses to the
MACE would cause an NMI: so wait for the MACE to come out of reset before
accessing.

- add ifmedia support (mainly so I can get at the link status from other code)
- move some of the spl handling around (more correct)
- rewrite qe_mcreset() again so that all it does is set the multicast filter
- use bzero to initialize the buffers and descriptors
- rearrange the MACE setup to conform to the suggestions in the datasheet
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.9 2000/06/18 17:36:59 jason Exp $	*/
d771 5
a775 1
	i = mr->mpc;	/* cleared on read */
@


1.9
log
@hmm, you'd never know these started out as if_ie.c....
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.8 1999/12/08 22:46:10 jason Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Jason L. Wright.
d53 1
d100 2
d169 10
d264 1
a264 1
	int tries;
a265 1
	tries = 200;
d267 3
a269 1
	while ((mr->biucc & QE_MR_BIUCC_SWRST) && --tries)
d271 1
a272 1
	tries = 200;
d274 3
a276 1
	while ((cr->ctrl & QE_CR_CTRL_RESET) && --tries)
d278 1
a287 3
	int s;

	s = splnet();
a289 1
	splx(s);
d297 1
d302 1
d304 1
a440 1

d668 2
a669 1
			qe_mcreset(sc);
d673 4
d700 2
d708 2
d713 3
a715 2
	
	for (i = 0; i < QE_TX_RING_MAXSIZE; i++) {
a717 2
		sc->sc_desc->qe_txd[i].tx_flags = 0;
	}
a723 2
		else
			sc->sc_desc->qe_rxd[i].rx_flags = 0;
a731 2
	qestop(sc);

d736 2
a739 2
	cr->ccnt = 0;
	cr->pipg = 0;
d741 9
a749 1
	mr->phycc = QE_MR_PHYCC_ASEL;
d753 2
a754 4
	mr->biucc = QE_MR_BIUCC_BSWAP | QE_MR_BIUCC_64TS;
	mr->fifofc = QE_MR_FIFOCC_TXF16 | QE_MR_FIFOCC_RXF32 |
	    QE_MR_FIFOCC_RFWU | QE_MR_FIFOCC_TFWU;
	mr->plscc = QE_MR_PLSCC_TP;
d757 5
d768 1
a768 4

	mr->iac = QE_MR_IAC_ADDRCHG | QE_MR_IAC_LOGADDR;
	for (i = 0; i < 8; i++)
		mr->ladrf = 0;
a770 4
	delay(50000);
	if ((mr->phycc & QE_MR_PHYCC_LNKFL) == QE_MR_PHYCC_LNKFL)
		printf("%s: no carrier\n", sc->sc_dev.dv_xname);

a772 2
	qe_mcreset(sc);

d775 3
d933 1
a933 6
	if (ifp->if_flags & IFF_PROMISC) {
		mr->maccc = QE_MR_MACCC_PROM | QE_MR_MACCC_ENXMT |
		    QE_MR_MACCC_ENRCV;
		return;
	}

d936 5
a942 2
		mr->iac = 0;
		mr->maccc = QE_MR_MACCC_ENXMT | QE_MR_MACCC_ENRCV;
a961 4
			mr->iac = QE_MR_IAC_ADDRCHG | QE_MR_IAC_LOGADDR;
			for (i = 0; i < 8; i++)
				mr->ladrf = 0xff;
			mr->iac = 0;
d963 1
a963 1
			break;
d988 5
d995 66
a1060 1
	mr->iac = 0;
d1062 1
a1062 1
	mr->maccc = QE_MR_MACCC_ENXMT | QE_MR_MACCC_ENRCV;
@


1.9.2.1
log
@Pull in patches from current:
Errata (003):
Configuring a qec+qe causes a NMI panic.
Fix (jason):
- Fix the NMI problem: it seems the qec channel reset also resets the MACE, and
a race condition existed where after a qec channel reset, accesses to the
MACE would cause an NMI: so wait for the MACE to come out of reset before
accessing.

- add ifmedia support (mainly so I can get at the link status from other code)
- move some of the spl handling around (more correct)
- rewrite qe_mcreset() again so that all it does is set the multicast filter
- use bzero to initialize the buffers and descriptors
- rearrange the MACE setup to conform to the suggestions in the datasheet
----------------------------
wait for the MACE to figure out whether it has media or not, and then
clear interrupt status and such before enabling rx and tx.
----------------------------
- remove other media types, the MACE isn't as bright as one would hope
- always set it to autoselect, tp
- remove the wait for media stuff: appears to be a local issue on
- simplify the ifmedia callbacks appropriately
----------------------------
seems the qe/mace combination needs a delay between accesses to the
two chips.  Better fix for the NMI problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.13 2000/11/17 17:38:32 jason Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998, 2000 Jason L. Wright.
a52 1
#include <net/if_media.h>
a98 2
void		qe_ifmedia_sts __P((struct ifnet *, struct ifmediareq *));
int		qe_ifmedia_upd __P((struct ifnet *));
a165 6
	ifmedia_init(&sc->sc_ifmedia, IFM_IMASK,
	    qe_ifmedia_upd, qe_ifmedia_sts);
	ifmedia_add(&sc->sc_ifmedia,
	    IFM_MAKEWORD(IFM_ETHER, IFM_10_T, 0, 0), 0, NULL);
	ifmedia_set(&sc->sc_ifmedia, IFM_ETHER | IFM_10_T);

d251 1
a251 1
	int n;
d253 1
d255 1
a255 3
	for (n = 200; n > 0; n--) {
		if ((mr->biucc & QE_MR_BIUCC_SWRST) == 0)
			break;
a256 1
	}
d258 1
d260 1
a260 3
	for (n = 200; n > 0; n--) {
		if ((cr->ctrl & QE_CR_CTRL_RESET) == 0)
			break;
a261 1
	}
d271 3
d276 1
a283 1
	int s;
a287 1
	s = splnet();
a288 1
	splx(s);
d425 1
d653 1
a653 2
			if (ifp->if_flags & IFF_UP)
				qeinit(sc);
a656 4
	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_ifmedia, cmd);
		break;
a679 2
	qestop(sc);

a685 2
	bzero(sc->sc_desc, sizeof(struct qe_desc));

d689 2
a690 3
	bzero(sc->sc_bufs, sizeof(struct qe_bufs));

	for (i = 0; i < QE_TX_RING_MAXSIZE; i++)
d693 2
d701 2
d711 2
d716 3
a718 1
	cr->mmask = QE_CR_MMASK_RXCOLL | QE_CR_MMASK_CLOSS;
a720 9
	cr->rxwbufptr = cr->rxrbufptr = sc->sc_channel * qec->sc_msize;
	cr->txwbufptr = cr->txrbufptr = cr->rxrbufptr + qec->sc_rsize;

	/*
	 * When switching from mace<->qec always guarantee an sbus
	 * turnaround (if last op was read, perform a dummy write, and
	 * vice versa).
	 */
	i = cr->qmask;		/* dummy */
d722 4
a728 4
	mr->xmtfc = QE_MR_XMTFC_APADXMT;
	mr->rcvfc = 0;
	mr->imr = QE_MR_IMR_CERRM | QE_MR_IMR_RCVINTM;
	mr->phycc = QE_MR_PHYCC_ASEL;
a730 2
	qe_ifmedia_upd(ifp);

a731 5
	for (i = 100; i > 0; i--) {
		if ((mr->iac & QE_MR_IAC_ADDRCHG) == 0)
			break;
		DELAY(2);
	}
d738 4
a741 1
	qe_mcreset(sc);
d744 4
d750 2
a753 3

	mr->maccc = QE_MR_MACCC_ENXMT | QE_MR_MACCC_ENRCV |
	    ((ifp->if_flags & IFF_PROMISC) ? QE_MR_MACCC_PROM : 0);
d909 6
a914 1
allmulti:
a916 5
		for (i = 100; i > 0; i--) {
			if ((mr->iac & QE_MR_IAC_ADDRCHG) == 0)
				break;
			DELAY(2);
		}
d919 2
d940 4
d945 1
a945 1
			goto allmulti;
a969 5
	for (i = 100; i > 0; i--) {
		if ((mr->iac & QE_MR_IAC_ADDRCHG) == 0)
			break;
		DELAY(2);
	}
d972 1
a972 33
}

void
qe_ifmedia_sts(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
{
	struct qesoftc *sc = (struct qesoftc *)ifp->if_softc;
	u_int8_t phycc;

	ifmr->ifm_active = IFM_ETHER | IFM_10_T;
	phycc = sc->sc_mr->phycc;
	if ((phycc & QE_MR_PHYCC_DLNKTST) == 0) {
		ifmr->ifm_status |= IFM_AVALID;
		if (phycc & QE_MR_PHYCC_LNKFL)
			ifmr->ifm_status &= ~IFM_ACTIVE;
		else
			ifmr->ifm_status |= IFM_ACTIVE;
	}
}

int
qe_ifmedia_upd(ifp)
	struct ifnet *ifp;
{
	struct qesoftc *sc = (struct qesoftc *)ifp->if_softc;
	int media = sc->sc_ifmedia.ifm_media;

	if (IFM_TYPE(media) != IFM_ETHER)
		return (EINVAL);

	if (IFM_SUBTYPE(media) != IFM_10_T)
		return (EINVAL);
d974 1
a974 1
	return (0);
@


1.8
log
@fix mbuf chain allocation to comply with m_devget() way.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.7 1999/02/24 06:57:45 jason Exp $	*/
a639 6
#ifdef IEDEBUG   
		if (ifp->if_flags & IFF_DEBUG)
			sc->sc_debug = IED_ALL;
		else
			sc->sc_debug = 0;
#endif
@


1.8.2.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.15 2001/02/20 19:39:34 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998, 2000 Jason L. Wright.
a52 1
#include <net/if_media.h>
d95 1
d97 1
a98 2
void		qe_ifmedia_sts __P((struct ifnet *, struct ifmediareq *));
int		qe_ifmedia_upd __P((struct ifnet *));
a165 6
	ifmedia_init(&sc->sc_ifmedia, IFM_IMASK,
	    qe_ifmedia_upd, qe_ifmedia_sts);
	ifmedia_add(&sc->sc_ifmedia,
	    IFM_MAKEWORD(IFM_ETHER, IFM_10_T, 0, 0), 0, NULL);
	ifmedia_set(&sc->sc_ifmedia, IFM_ETHER | IFM_10_T);

d173 5
d223 1
a223 1
		len = qec_put(sc->sc_bufs->tx_buf[bix & QE_TX_RING_MASK], m);
d251 1
a251 1
	int n;
d253 1
d255 1
a255 3
	for (n = 200; n > 0; n--) {
		if ((mr->biucc & QE_MR_BIUCC_SWRST) == 0)
			break;
a256 1
	}
d258 1
d260 1
a260 3
	for (n = 200; n > 0; n--) {
		if ((cr->ctrl & QE_CR_CTRL_RESET) == 0)
			break;
a261 1
	}
d271 3
d276 1
a283 1
	int s;
a287 1
	s = splnet();
a288 1
	splx(s);
d383 1
a383 1
		sc->sc_desc->qe_rxd[(bix + QE_RX_RING_SIZE) & QE_RX_RING_MAXMASK].rx_flags =
d425 1
d640 6
d659 1
a659 2
			if (ifp->if_flags & IFF_UP)
				qeinit(sc);
a662 4
	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_ifmedia, cmd);
		break;
a685 2
	qestop(sc);

a691 2
	bzero(sc->sc_desc, sizeof(struct qe_desc));

d695 2
a696 3
	bzero(sc->sc_bufs, sizeof(struct qe_bufs));

	for (i = 0; i < QE_TX_RING_MAXSIZE; i++)
d698 3
a700 1
			(u_int32_t)sc->sc_bufs_dva->tx_buf[i & QE_TX_RING_MASK];
d703 2
a704 2
			(u_int32_t)sc->sc_bufs_dva->rx_buf[i & QE_RX_RING_MASK];
		if (i < QE_RX_RING_SIZE)
d707 2
d711 2
a712 2
	cr->rxds = (u_int32_t)sc->sc_desc_dva->qe_rxd;
	cr->txds = (u_int32_t)sc->sc_desc_dva->qe_txd;
d717 2
d722 3
a724 1
	cr->mmask = QE_CR_MMASK_RXCOLL | QE_CR_MMASK_CLOSS;
a726 9
	cr->rxwbufptr = cr->rxrbufptr = sc->sc_channel * qec->sc_msize;
	cr->txwbufptr = cr->txrbufptr = cr->rxrbufptr + qec->sc_rsize;

	/*
	 * When switching from mace<->qec always guarantee an sbus
	 * turnaround (if last op was read, perform a dummy write, and
	 * vice versa).
	 */
	i = cr->qmask;		/* dummy */
d728 4
a734 4
	mr->xmtfc = QE_MR_XMTFC_APADXMT;
	mr->rcvfc = 0;
	mr->imr = QE_MR_IMR_CERRM | QE_MR_IMR_RCVINTM;
	mr->phycc = QE_MR_PHYCC_ASEL;
a736 2
	qe_ifmedia_upd(ifp);

a737 5
	for (i = 100; i > 0; i--) {
		if ((mr->iac & QE_MR_IAC_ADDRCHG) == 0)
			break;
		DELAY(2);
	}
d744 4
a747 1
	qe_mcreset(sc);
d750 4
d756 2
d760 2
d763 26
a788 3
	mr->maccc = QE_MR_MACCC_ENXMT | QE_MR_MACCC_ENRCV |
	    ((ifp->if_flags & IFF_PROMISC) ? QE_MR_MACCC_PROM : 0);
	splx(s);
d816 1
a816 1
	m = qec_get(ifp, sc->sc_bufs->rx_buf[idx & QE_RX_RING_MASK], len);
d840 59
d915 6
a920 1
allmulti:
a922 5
		for (i = 100; i > 0; i--) {
			if ((mr->iac & QE_MR_IAC_ADDRCHG) == 0)
				break;
			DELAY(2);
		}
d925 2
d946 4
d951 1
a951 1
			goto allmulti;
a975 5
	for (i = 100; i > 0; i--) {
		if ((mr->iac & QE_MR_IAC_ADDRCHG) == 0)
			break;
		DELAY(2);
	}
d978 1
a978 33
}

void
qe_ifmedia_sts(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
{
	struct qesoftc *sc = (struct qesoftc *)ifp->if_softc;
	u_int8_t phycc;

	ifmr->ifm_active = IFM_ETHER | IFM_10_T;
	phycc = sc->sc_mr->phycc;
	if ((phycc & QE_MR_PHYCC_DLNKTST) == 0) {
		ifmr->ifm_status |= IFM_AVALID;
		if (phycc & QE_MR_PHYCC_LNKFL)
			ifmr->ifm_status &= ~IFM_ACTIVE;
		else
			ifmr->ifm_status |= IFM_ACTIVE;
	}
}

int
qe_ifmedia_upd(ifp)
	struct ifnet *ifp;
{
	struct qesoftc *sc = (struct qesoftc *)ifp->if_softc;
	int media = sc->sc_ifmedia.ifm_media;

	if (IFM_TYPE(media) != IFM_ETHER)
		return (EINVAL);

	if (IFM_SUBTYPE(media) != IFM_10_T)
		return (EINVAL);
d980 1
a980 1
	return (0);
@


1.8.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.8.2.1 2001/05/14 21:37:08 niklas Exp $	*/
d782 1
d805 3
d816 3
a818 2
	/* Pass the packet up. */
	ether_input_mbuf(ifp, m);
@


1.8.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.8.2.2 2001/07/04 10:23:27 niklas Exp $	*/
a172 3
	IFQ_SET_MAXLEN(&ifp->if_snd, QE_TX_RING_SIZE);
	IFQ_SET_READY(&ifp->if_snd);

d209 2
a210 2
		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
@


1.8.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d212 1
a212 1
		IFQ_POLL(&ifp->if_snd, m);
a215 2
		IFQ_DEQUEUE(&ifp->if_snd, m);

d328 1
a328 1
	return (1);
d352 1
d361 4
d368 1
a368 13
	/*
	 * If we freed up at least one descriptor and tx is blocked,
	 * unblock it and start it up again.
	 */
	if (sc->sc_first_td != bix) {
		sc->sc_first_td = bix;
		if (ifp->if_flags & IFF_OACTIVE) {
			ifp->if_flags &= ~IFF_OACTIVE;
			qestart(ifp);
		}
	}

	return (1);
d421 1
@


1.8.2.5
log
@Merge in -current from about a week ago
@
text
@d82 2
a83 2
int	qematch(struct device *, void *, void *);
void	qeattach(struct device *, struct device *, void *);
d85 15
a99 15
void	qeinit(struct qesoftc *);
void	qestart(struct ifnet *);
void	qestop(struct qesoftc *);
void	qewatchdog(struct ifnet *);
int	qeioctl(struct ifnet *, u_long, caddr_t);
void	qereset(struct qesoftc *);

int		qeintr(void *);
int		qe_eint(struct qesoftc *, u_int32_t);
int		qe_rint(struct qesoftc *);
int		qe_tint(struct qesoftc *);
void		qe_read(struct qesoftc *, int, int);
void		qe_mcreset(struct qesoftc *);
void		qe_ifmedia_sts(struct ifnet *, struct ifmediareq *);
int		qe_ifmedia_upd(struct ifnet *);
d133 1
a133 1
	extern void myetheraddr(u_char *);
@


1.8.2.6
log
@Sync the SMP branch with 3.3
@
text
@d155 1
a155 1
	intr_establish(pri, &sc->sc_ih, IPL_NET);
d314 1
a314 1
		return (r);
d321 1
a321 1
			return (1);
d409 1
a409 1
	return (1);
d578 1
a578 1
		return (-1);
d581 1
a581 1
	return (r);
d680 1
a680 1
			return (error);
d686 1
a686 1
	return (error);
@


1.8.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.8.2.6 2003/03/27 23:49:25 niklas Exp $	*/
d15 2
@


1.8.4.1
log
@Pull in patches from current:
Fix (jason):
- Fix the NMI problem: it seems the qec channel reset also resets the MACE, and
a race condition existed where after a qec channel reset, accesses to the
MACE would cause an NMI: so wait for the MACE to come out of reset before
accessing.

- add ifmedia support (mainly so I can get at the link status from other code)
- move some of the spl handling around (more correct)
- rewrite qe_mcreset() again so that all it does is set the multicast filter
- use bzero to initialize the buffers and descriptors
- rearrange the MACE setup to conform to the suggestions in the datasheet
----------------------------
wait for the MACE to figure out whether it has media or not, and then
clear interrupt status and such before enabling rx and tx.
----------------------------
- remove other media types, the MACE isn't as bright as one would hope
- always set it to autoselect, tp
- remove the wait for media stuff: appears to be a local issue on
- simplify the ifmedia callbacks appropriately
----------------------------
seems the qe/mace combination needs a delay between accesses to the
two chips.  Better fix for the NMI problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.13 2000/11/17 17:38:32 jason Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998, 2000 Jason L. Wright.
a52 1
#include <net/if_media.h>
a98 2
void		qe_ifmedia_sts __P((struct ifnet *, struct ifmediareq *));
int		qe_ifmedia_upd __P((struct ifnet *));
a165 6
	ifmedia_init(&sc->sc_ifmedia, IFM_IMASK,
	    qe_ifmedia_upd, qe_ifmedia_sts);
	ifmedia_add(&sc->sc_ifmedia,
	    IFM_MAKEWORD(IFM_ETHER, IFM_10_T, 0, 0), 0, NULL);
	ifmedia_set(&sc->sc_ifmedia, IFM_ETHER | IFM_10_T);

d251 1
a251 1
	int n;
d253 1
d255 1
a255 3
	for (n = 200; n > 0; n--) {
		if ((mr->biucc & QE_MR_BIUCC_SWRST) == 0)
			break;
a256 1
	}
d258 1
d260 1
a260 3
	for (n = 200; n > 0; n--) {
		if ((cr->ctrl & QE_CR_CTRL_RESET) == 0)
			break;
a261 1
	}
d271 3
d276 1
a283 1
	int s;
a287 1
	s = splnet();
a288 1
	splx(s);
d425 1
d659 1
a659 2
			if (ifp->if_flags & IFF_UP)
				qeinit(sc);
a662 4
	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_ifmedia, cmd);
		break;
a685 2
	qestop(sc);

a691 2
	bzero(sc->sc_desc, sizeof(struct qe_desc));

d695 2
a696 3
	bzero(sc->sc_bufs, sizeof(struct qe_bufs));

	for (i = 0; i < QE_TX_RING_MAXSIZE; i++)
d699 2
d707 2
d717 2
d722 3
a724 1
	cr->mmask = QE_CR_MMASK_RXCOLL | QE_CR_MMASK_CLOSS;
a726 9
	cr->rxwbufptr = cr->rxrbufptr = sc->sc_channel * qec->sc_msize;
	cr->txwbufptr = cr->txrbufptr = cr->rxrbufptr + qec->sc_rsize;

	/*
	 * When switching from mace<->qec always guarantee an sbus
	 * turnaround (if last op was read, perform a dummy write, and
	 * vice versa).
	 */
	i = cr->qmask;		/* dummy */
d728 4
a734 4
	mr->xmtfc = QE_MR_XMTFC_APADXMT;
	mr->rcvfc = 0;
	mr->imr = QE_MR_IMR_CERRM | QE_MR_IMR_RCVINTM;
	mr->phycc = QE_MR_PHYCC_ASEL;
a736 2
	qe_ifmedia_upd(ifp);

a737 5
	for (i = 100; i > 0; i--) {
		if ((mr->iac & QE_MR_IAC_ADDRCHG) == 0)
			break;
		DELAY(2);
	}
d744 4
a747 1
	qe_mcreset(sc);
d750 4
d756 2
a759 3

	mr->maccc = QE_MR_MACCC_ENXMT | QE_MR_MACCC_ENRCV |
	    ((ifp->if_flags & IFF_PROMISC) ? QE_MR_MACCC_PROM : 0);
d915 6
a920 1
allmulti:
a922 5
		for (i = 100; i > 0; i--) {
			if ((mr->iac & QE_MR_IAC_ADDRCHG) == 0)
				break;
			DELAY(2);
		}
d925 2
d946 4
d951 1
a951 1
			goto allmulti;
a975 5
	for (i = 100; i > 0; i--) {
		if ((mr->iac & QE_MR_IAC_ADDRCHG) == 0)
			break;
		DELAY(2);
	}
d978 1
a978 33
}

void
qe_ifmedia_sts(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
{
	struct qesoftc *sc = (struct qesoftc *)ifp->if_softc;
	u_int8_t phycc;

	ifmr->ifm_active = IFM_ETHER | IFM_10_T;
	phycc = sc->sc_mr->phycc;
	if ((phycc & QE_MR_PHYCC_DLNKTST) == 0) {
		ifmr->ifm_status |= IFM_AVALID;
		if (phycc & QE_MR_PHYCC_LNKFL)
			ifmr->ifm_status &= ~IFM_ACTIVE;
		else
			ifmr->ifm_status |= IFM_ACTIVE;
	}
}

int
qe_ifmedia_upd(ifp)
	struct ifnet *ifp;
{
	struct qesoftc *sc = (struct qesoftc *)ifp->if_softc;
	int media = sc->sc_ifmedia.ifm_media;

	if (IFM_TYPE(media) != IFM_ETHER)
		return (EINVAL);

	if (IFM_SUBTYPE(media) != IFM_10_T)
		return (EINVAL);
d980 1
a980 1
	return (0);
@


1.7
log
@better promisc & allmulti handling
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.6 1999/02/08 13:39:30 jason Exp $	*/
d861 6
d868 1
a868 1
	len = MHLEN - pad;
@


1.6
log
@match be & qe as part of the bootpath
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.5 1998/11/02 05:50:59 jason Exp $	*/
a616 1
		sc->sc_promisc = ifp->if_flags & (IFF_PROMISC | IFF_ALLMULTI);
d756 1
a756 2
	mr->maccc = QE_MR_MACCC_ENXMT | QE_MR_MACCC_ENRCV |
		((ifp->if_flags & IFF_PROMISC) ? QE_MR_MACCC_PROM : 0);
d906 1
a906 1
	u_int8_t octet, maccc = 0, *ladrp = (u_int8_t *)&hash[0];
d909 6
d920 2
a922 4
	else if (ifp->if_flags & IFF_PROMISC) {
		maccc |= QE_MR_MACCC_PROM;
	}
	else {
d924 1
a924 1
		hash[3] = hash[2] = hash[1] = hash[0] = 0;
d926 21
a946 21
		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			if (bcmp(enm->enm_addrlo, enm->enm_addrhi,
			    ETHER_ADDR_LEN)) {
				/*
				 * We must listen to a range of multicast
				 * addresses. For now, just accept all
				 * multicasts, rather than trying to set only
				 * those filter bits needed to match the range.
				 * (At this time, the only use of address
				 * ranges is for IP multicast routing, for
				 * which the range is big enough to require
				 * all bits set.)
				 */
				mr->iac = QE_MR_IAC_ADDRCHG | QE_MR_IAC_LOGADDR;
				for (i = 0; i < 8; i++)
					mr->ladrf = 0xff;
				mr->iac = 0;
				ifp->if_flags |= IFF_ALLMULTI;
				break;
			}
d948 1
a948 1
			crc = 0xffffffff;
d950 2
a951 2
			for (i = 0; i < ETHER_ADDR_LEN; i++) {
				octet = enm->enm_addrlo[i];
d953 4
a956 8
				for (j = 0; j < 8; j++) {
					if ((crc & 1) ^ (octet & 1)) {
						crc >>= 1;
						crc ^= MC_POLY_LE;
					}
					else
						crc >>= 1;
					octet >>= 1;
d958 3
a961 4

			crc >>= 26;
			hash[crc >> 4] |= 1 << (crc & 0xf);
			ETHER_NEXT_MULTI(step, enm);
d964 3
a966 4
		mr->iac = QE_MR_IAC_ADDRCHG | QE_MR_IAC_LOGADDR;
		for (i = 0; i < 8; i++)
			mr->ladrf = ladrp[i];
		mr->iac = 0;
d969 6
a974 1
	mr->maccc = maccc | QE_MR_MACCC_ENXMT | QE_MR_MACCC_ENRCV;
@


1.5
log
@First step at unifying qe & be drivers:
o qe & be drivers now only access qec globals directly at interrupt time
o more initialization done in qec_reset
o qe & be drivers handle the qec internal buffer identically
o nuked unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.4 1998/10/21 04:12:10 jason Exp $	*/
d131 1
d177 5
@


1.4
log
@The qec global reset should only be allowed to happen once per qec card, not
once per channel init.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.3 1998/10/20 00:57:52 jason Exp $	*/
a147 3
	sc->sc_mem = qec->sc_buffer;
	sc->sc_memsize = qec->sc_bufsiz;

d676 1
a676 1
	struct qecregs *qr = sc->sc_qr;
a681 15
	 * init QEC: 'qe' specific initializations
	 */
	qr->msize = sc->sc_memsize / 4;
	qr->rsize = sc->sc_memsize / 8;
	qr->tsize = sc->sc_memsize / 8;
	qr->psize = QEC_PSIZE_2048;
	if (sc->sc_burst & SBUS_BURST_64)
		i = QEC_CTRL_B64;
	else if (sc->sc_burst & SBUS_BURST_32)
		i = QEC_CTRL_B32;
	else
		i = QEC_CTRL_B16;
	qr->ctrl = QEC_CTRL_MMODE | i;

	/*
d718 2
a719 2
	cr->rxwbufptr = cr->rxrbufptr = sc->sc_channel * sc->sc_qr->msize;
	cr->txwbufptr = cr->txrbufptr = cr->rxrbufptr + sc->sc_qr->rsize;
@


1.3
log
@o Only read the per-channel status reg if the global int mask says something
interesting happened.
o Base all interrupt decisions on per-channel status reg.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.2 1998/10/19 19:55:54 jason Exp $	*/
a682 2

	qec_reset(sc->sc_qec);
@


1.2
log
@Use register definitions from AMD databook.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.1 1998/10/19 05:41:19 jason Exp $	*/
a299 1
	qestat = sc->sc_cr->stat;
d303 3
a305 1
	if (qecstat & QEC_STAT_ER || qecstat & QEC_STAT_BM) {
d311 1
a311 1
	if (qecstat & QEC_STAT_TX && qestat & QE_CR_STAT_TXIRQ)
d314 1
a314 1
	if (qecstat & QEC_STAT_RX && qestat & QE_CR_STAT_RXIRQ)
@


1.1
log
@Support for the qec+qe (SBus QuadEthernet board)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d742 1
a742 1
	mr->phycc = QE_MR_PHYCC_AUTO;
d751 1
a751 1
	mr->iac = QE_MR_IAC_ACHNGE | QE_MR_IAC_PARESET;
d759 1
a759 1
	mr->iac = QE_MR_IAC_ACHNGE | QE_MR_IAC_LARESET;
d765 1
a765 1
	if ((mr->phycc & QE_MR_PHYCC_LSTAT) == QE_MR_PHYCC_LSTAT)
d770 2
a771 1
	mr->maccc = QE_MR_MACCC_TXENAB | QE_MR_MACCC_RXENAB;
d925 1
a925 1
		mr->iac = QE_MR_IAC_ACHNGE | QE_MR_IAC_LARESET;
d931 1
a931 1
		maccc |= QE_MR_MACCC_PROMISC;
d951 1
a951 1
				mr->iac = QE_MR_IAC_ACHNGE | QE_MR_IAC_LARESET;
d980 1
a980 1
		mr->iac = QE_MR_IAC_ACHNGE | QE_MR_IAC_LARESET;
d986 1
a986 1
	mr->maccc = maccc | QE_MR_MACCC_TXENAB | QE_MR_MACCC_RXENAB;
@

