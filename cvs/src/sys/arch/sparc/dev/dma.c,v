head	1.31;
access;
symbols
	OPENBSD_6_0:1.31.0.6
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.31.0.4
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.30.0.4
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.28.0.18
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.14
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.12
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.10
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.8
	OPENBSD_5_0:1.28.0.6
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.4
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.2
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.25.0.4
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.6
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.2
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.24.0.6
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.4
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.22.0.4
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.21.0.6
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.4
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.19.0.4
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.6
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.17
	UBC:1.16.0.14
	UBC_BASE:1.16
	OPENBSD_3_0:1.16.0.12
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.10
	OPENBSD_2_8:1.16.0.8
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.16.0.6
	OPENBSD_2_7_BASE:1.16
	SMP:1.16.0.4
	SMP_BASE:1.16
	kame_19991208:1.16
	OPENBSD_2_6:1.16.0.2
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.14.0.2
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2015.03.30.20.30.22;	author miod;	state Exp;
branches;
next	1.30;
commitid	f66FukLLgPJs9j5H;

1.30
date	2014.07.28.18.31.39;	author miod;	state Exp;
branches;
next	1.29;
commitid	KwJ20CkzgJkW6nEl;

1.29
date	2014.05.09.20.15.06;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2010.07.10.19.32.24;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2010.06.27.05.52.01;	author beck;	state Exp;
branches;
next	1.26;

1.26
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2008.12.26.15.13.07;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.29.09.54.07;	author sobrado;	state Exp;
branches;
next	1.23;

1.23
date	2007.04.10.17.47.54;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2006.06.02.20.00.54;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2005.03.02.16.42.37;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2005.02.27.22.01.03;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.02.01.15.39.37;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.05.12.27.02;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.26.42;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	99.09.10.23.32.02;	author art;	state Exp;
branches
	1.16.4.1
	1.16.14.1;
next	1.15;

1.15
date	99.07.09.21.34.44;	author art;	state Exp;
branches;
next	1.14;

1.14
date	99.02.28.19.12.32;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	98.11.11.00.50.31;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	98.07.05.09.24.25;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.02.05.19.02.30;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	98.01.28.17.21.46;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	97.09.17.06.47.08;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	97.08.08.08.24.57;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	96.11.23.21.46.13;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	96.08.11.05.34.13;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.01.12.22.02.15;	author chuck;	state Exp;
branches;
next	1.4;

1.4
date	95.12.15.13.56.20;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.11.21.13.02.12;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.18.17.20.15;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.38;	author deraadt;	state Exp;
branches;
next	;

1.16.4.1
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.16.4.2;

1.16.4.2
date	2003.06.07.11.14.42;	author ho;	state Exp;
branches;
next	1.16.4.3;

1.16.4.3
date	2004.02.19.10.49.57;	author niklas;	state Exp;
branches;
next	;

1.16.14.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Add a bus_dma_tag_t for DVMA usage, suitable for use for devices not sitting
behind a sun4m iommu.

Move the existing dvma routines from vm_machdep.c to this new dvma.c; this
allows for a few declarations to be removed from public headers.

Extend the device attachment arguments (struct confargs) to pass a
bus_dma_tag_t. mainbus receives the dvma bus_dma_tag_t, and devices pass the
tag unchanged to their children, except for iommu(4) which replaces it with
its own.

Change the few sun4m-only drivers to pick the bus_dma_tag_t from confargs
rather than assume iommu; this allows qlw(4) to attach and work on sun4c.

ok kettenis@@
@
text
@/*	$OpenBSD: dma.c,v 1.30 2014/07/28 18:31:39 miod Exp $	*/
/*	$NetBSD: dma.c,v 1.46 1997/08/27 11:24:16 bouyer Exp $ */

/*
 * Copyright (c) 1994 Paul Kranenburg.  All rights reserved.
 * Copyright (c) 1994 Peter Galbavy.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/proc.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>

#include <sparc/sparc/cpuvar.h>

#include <net/if.h>
#include <net/if_media.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <uvm/uvm_extern.h>

#include <dev/ic/ncr53c9xreg.h>
#include <dev/ic/ncr53c9xvar.h>

#include <sparc/dev/sbusvar.h>
#include <sparc/dev/dmareg.h>
#include <sparc/dev/dmavar.h>
#include <sparc/dev/espvar.h>

int dmaprint(void *, const char *);
void dmaattach(struct device *, struct device *, void *);
int dmamatch(struct device *, void *, void *);
void dma_reset(struct dma_softc *, int);
void espdma_reset(struct dma_softc *);
int ledmamatch(struct device *, void *, void *);
void ledma_reset(struct dma_softc *);
void dma_enintr(struct dma_softc *);
int dma_isintr(struct dma_softc *);
int espdmaintr(struct dma_softc *);
int ledmaintr(struct dma_softc *);
int dma_setup(struct dma_softc *, caddr_t *, size_t *,
			     int, size_t *);
void dma_go(struct dma_softc *);

struct cfattach dma_ca = {
	sizeof(struct dma_softc), dmamatch, dmaattach
};

struct cfdriver dma_cd = {
	NULL, "dma", DV_DULL
};

struct cfattach ledma_ca = {
	sizeof(struct dma_softc), ledmamatch, dmaattach
};

struct cfdriver ledma_cd = {
	NULL, "ledma", DV_DULL
};

int
dmaprint(aux, name)
	void *aux;
	const char *name;
{
	struct confargs *ca = aux;

	if (name)
		printf("%s at %s", ca->ca_ra.ra_name, name);
	printf(" offset 0x%x", ca->ca_offset);
	return (UNCONF);
}

int
dmamatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

	if (strcmp(cf->cf_driver->cd_name, ra->ra_name) &&
	    strcmp("espdma", ra->ra_name))
		return (0);
#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	if (ca->ca_bustype == BUS_SBUS) {
		if (!sbus_testdma((struct sbus_softc *)parent, ca))
			return (0);
		return (1);
	}
#endif
	ra->ra_len = NBPG;
	return (probeget(ra->ra_vaddr, 4) != -1);
}

/*
 * Attach all the sub-devices we can find
 */
void
dmaattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct confargs *ca = aux;
	struct dma_softc *sc = (void *)self;
	int devnode;
#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	int node;
	struct confargs oca;
	char *name;
#endif

	if (ca->ca_ra.ra_vaddr == NULL || ca->ca_ra.ra_nvaddrs == 0)
		ca->ca_ra.ra_vaddr =
		    mapiodev(ca->ca_ra.ra_reg, 0, ca->ca_ra.ra_len);

	sc->sc_regs = (struct dma_regs *) ca->ca_ra.ra_vaddr;
	devnode = ca->ca_ra.ra_node;

	/*
	 * If we're a ledma, check to see what cable type is currently 
	 * active and set the appropriate bit in the ledma csr so that
	 * it gets used. If we didn't netboot, the PROM won't have the
	 * "cable-selection" property; default to TP and then the user
	 * can change it via a "link0" option to ifconfig.
	 */
	if (strcmp(ca->ca_ra.ra_name, "ledma") == 0) {
		char *cabletype = getpropstring(devnode, "cable-selection");
		if (strcmp(cabletype, "tpe") == 0) {
			sc->sc_regs->csr |= E_TP_AUI;
			sc->sc_defaultmedia = IFM_ETHER | IFM_10_T;
		} else if (strcmp(cabletype, "aui") == 0) {
			sc->sc_regs->csr &= ~E_TP_AUI;
			sc->sc_defaultmedia = IFM_ETHER | IFM_10_5;
		} else {
			/* assume TP if nothing there */
			sc->sc_regs->csr |= E_TP_AUI;
			sc->sc_defaultmedia = IFM_ETHER | IFM_AUTO;
		}
		delay(20000);	/* manual says we need 20ms delay */
	}

	/*
	 * Get transfer burst size from PROM and plug it into the
	 * controller registers. This is needed on the Sun4m; do
	 * others need it too?
	 */
	if (CPU_ISSUN4M) {
		int sbusburst = ((struct sbus_softc *)parent)->sc_burst;
		if (sbusburst == 0)
			sbusburst = SBUS_BURST_32 - 1; /* 1->16 */

		sc->sc_burst = getpropint(devnode, "burst-sizes", -1);
		if (sc->sc_burst == -1)
			/* take SBus burst sizes */
			sc->sc_burst = sbusburst;

		/* Clamp at parent's burst sizes */
		sc->sc_burst &= sbusburst;
	}

	printf(": rev ");
	sc->sc_rev = sc->sc_regs->csr & D_DEV_ID;
	switch (sc->sc_rev) {
	case DMAREV_0:
		printf("0");
		break;
	case DMAREV_ESC:
		printf("esc");
		break;
	case DMAREV_1:
		printf("1");
		break;
	case DMAREV_PLUS:
		printf("1+");
		break;
	case DMAREV_2:
		printf("2");
		break;
	case DMAREV_HME:
		printf("fas");
		break;
	default:
		printf("unknown (0x%x)", sc->sc_rev);
	}
	printf("\n");

	/* indirect functions */
	dma_setuphandlers(sc);

	if (CPU_ISSUN4)
		goto espsearch;

#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	/* Propagate bootpath */
	if (ca->ca_ra.ra_bp != NULL &&
	    (strcmp(ca->ca_ra.ra_bp->name, "espdma") == 0 ||
	     strcmp(ca->ca_ra.ra_bp->name, "dma") == 0 ||
	     strcmp(ca->ca_ra.ra_bp->name, "ledma") == 0))
		oca.ca_ra.ra_bp = ca->ca_ra.ra_bp + 1;
	else
		oca.ca_ra.ra_bp = NULL;

	/* search through children */
	node = firstchild(devnode);
	if (node != 0) {
		do {
			name = getpropstring(node, "name");
			if (!romprop(&oca.ca_ra, name, node))
				continue;

			sbus_translate(parent, &oca);
			oca.ca_bustype = BUS_SBUS;
			oca.ca_dmat = ca->ca_dmat;
			config_found(&sc->sc_dev, (void *)&oca, dmaprint);
		} while ((node = nextsibling(node)) != 0);
	} else
#endif /* SUN4C || SUN4D || SUN4E || SUN4M */

	if (strcmp(ca->ca_ra.ra_name, "dma") == 0) {
espsearch:
		/*
		 * find the ESP by poking around the esp device structures
		 *
		 * What happens here is that if the esp driver has not been
		 * configured, then this returns a NULL pointer. Then when the
		 * esp actually gets configured, it does the opposing test, and
		 * if the sc->sc_dma field in its softc is NULL, then tries to
		 * find the matching dma driver.
		 *
		 */
		sc->sc_esp = (struct esp_softc *)
			     getdevunit("esp", sc->sc_dev.dv_unit);

		/*
		 * and a back pointer to us, for DMA
		 */
		if (sc->sc_esp)
			sc->sc_esp->sc_dma = sc;
	}
}

void
dma_setuphandlers(struct dma_softc *sc)
{
	if (sc->sc_dev.dv_cfdata == NULL ||	/* happens on SUNW,fas */
	    sc->sc_dev.dv_cfdata->cf_attach == &dma_ca) {
		sc->reset = espdma_reset;
		sc->intr = espdmaintr;
	} else {
		sc->reset = ledma_reset;
		sc->intr = ledmaintr;
	}
	sc->enintr = dma_enintr;
	sc->isintr = dma_isintr;
	sc->setup = dma_setup;
	sc->go = dma_go;
}

#define DMAWAIT(SC, COND, MSG, DONTPANIC) do if (COND) {		\
	int count = 500000;						\
	while ((COND) && --count > 0) DELAY(1);				\
	if (count == 0) {						\
		printf("%s: line %d: CSR = 0x%lx\n", __FILE__, __LINE__, \
			(SC)->sc_regs->csr);				\
		if (DONTPANIC)						\
			printf(MSG);					\
		else							\
			panic(MSG);					\
	}								\
} while (0)

#define DMA_DRAIN(sc, dontpanic) do {					\
	/*								\
	 * DMA rev0 & rev1: we are not allowed to touch the DMA "flush"	\
	 *     and "drain" bits while it is still thinking about a	\
	 *     request.							\
	 * other revs: D_ESC_R_PEND bit reads as 0			\
	 */								\
	DMAWAIT(sc, sc->sc_regs->csr & D_ESC_R_PEND, "R_PEND", dontpanic);\
	if (sc->sc_rev != DMAREV_HME) {					\
		/*							\
		 * Select drain bit based on revision			\
		 * also clears errors and D_TC flag			\
		 */							\
		if (sc->sc_rev == DMAREV_1 || sc->sc_rev == DMAREV_0)	\
			DMACSR(sc) |= D_ESC_DRAIN;			\
		else							\
			DMACSR(sc) |= D_INVALIDATE;			\
	}								\
	/*								\
	 * Wait for draining to finish					\
	 *  rev0 & rev1 call this PACKCNT				\
	 */								\
	DMAWAIT(sc, sc->sc_regs->csr & D_DRAINING, "DRAINING", dontpanic);\
} while(0)

#define DMA_FLUSH(sc, dontpanic) do {					\
	int csr;							\
	/*								\
	 * DMA rev0 & rev1: we are not allowed to touch the DMA "flush"	\
	 *     and "drain" bits while it is still thinking about a	\
	 *     request.							\
	 * other revs: D_ESC_R_PEND bit reads as 0			\
	 */								\
	DMAWAIT(sc, sc->sc_regs->csr & D_ESC_R_PEND, "R_PEND", dontpanic);\
	csr = DMACSR(sc);						\
	csr &= ~(D_WRITE|D_EN_DMA);	/* no-ops on ENET */		\
	csr |= D_INVALIDATE;		/* XXX FAS ? */			\
	DMACSR(sc) = csr;						\
} while(0)

void
dma_reset(sc, isledma)
	struct dma_softc *sc;
	int isledma;
{
	int csr;

	DMA_FLUSH(sc, 1);
	csr = DMACSR(sc);

	if (sc->sc_rev == DMAREV_HME)
		DMACSR(sc) = csr | D_HW_RESET_FAS366;

	csr |= D_RESET;				/* reset DMA */
	DMACSR(sc) = csr;
	DELAY(200);				/* > 10 SBus clocks(?) */

	/*DMAWAIT1(sc); why was this here? */
	DMACSR(sc) &= ~D_RESET;			/* de-assert reset line */
	DELAY(5);

	csr = DMACSR(sc);
	csr |= D_INT_EN;			/* enable interrupts */
	if (sc->sc_rev > DMAREV_1 && isledma == 0) {
		if (sc->sc_rev == DMAREV_HME)
			csr |= D_TWO_CYCLE;
		else
			csr |= D_FASTER;
	}

	switch (sc->sc_rev) {
	case DMAREV_HME:
	case DMAREV_2:
		csr &= ~L64854_BURST_SIZE; /* must clear first */
		if (sc->sc_burst & SBUS_BURST_32) {
			csr |= L64854_BURST_32;
		} else if (sc->sc_burst & SBUS_BURST_16) {
			csr |= L64854_BURST_16;
		} else {
			csr |= L64854_BURST_0;
		}
		break;
	case DMAREV_ESC:
		csr |= D_ESC_AUTODRAIN;	/* Auto-drain */
		if (sc->sc_burst & SBUS_BURST_32) {
			csr &= ~D_ESC_BURST;
		} else
			csr |= D_ESC_BURST;
		break;
	default:
		break;
	}
	DMACSR(sc) = csr;

	if (sc->sc_rev == DMAREV_HME) {
		DMADDR(sc) = 0;
		sc->sc_dmactl = csr;
	}

	sc->sc_active = 0;			/* and of course we aren't */
}

void
espdma_reset(sc)
	struct dma_softc *sc;
{
	dma_reset(sc, 0);
}

int
ledmamatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

        if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
		return (0);
#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	if (!sbus_testdma((struct sbus_softc *)parent, ca))
		return(0);
#endif
	return (1);
}

void
ledma_reset(sc)
	struct dma_softc *sc;
{
	dma_reset(sc, 1);
}

void
dma_enintr(sc)
	struct dma_softc *sc;
{
	sc->sc_regs->csr |= D_INT_EN;
}

int
dma_isintr(sc)
	struct dma_softc *sc;
{
	return (sc->sc_regs->csr & (D_INT_PEND|D_ERR_PEND));
}

#define DMAMAX(a)	(0x01000000 - ((a) & 0x00ffffff))


/*
 * setup a dma transfer
 */
int
dma_setup(sc, addr, len, datain, dmasize)
	struct dma_softc *sc;
	caddr_t *addr;
	size_t *len;
	int datain;
	size_t *dmasize;	/* IN-OUT */
{
	u_long csr;

	DMA_FLUSH(sc, 0);

#if 0
	DMACSR(sc) &= ~D_INT_EN;
#endif
	sc->sc_dmaaddr = addr;
	sc->sc_dmalen = len;

	NCR_DMA(("%s: start %zd@@%p,%d\n", sc->sc_dev.dv_xname,
		*sc->sc_dmalen, *sc->sc_dmaaddr, datain ? 1 : 0));

	/*
	 * the rules say we cannot transfer more than the limit
	 * of this DMA chip (64k for old and 16Mb for new),
	 * and we cannot cross a 16Mb boundary.
	 */
	*dmasize = sc->sc_dmasize =
		min(*dmasize, DMAMAX((size_t) *sc->sc_dmaaddr));

	NCR_DMA(("dma_setup: dmasize = %zd\n", sc->sc_dmasize));

	/*
	 * XXX what length?
	 */
	if (sc->sc_rev == DMAREV_HME) {
		DMACSR(sc) = sc->sc_dmactl | L64854_RESET;
		DMACSR(sc) = sc->sc_dmactl;
		DMACNT(sc) = *dmasize;
	}

	/* Program the DMA address */
	if (CPU_ISSUN4M && sc->sc_dmasize) {
		/*
		 * Use dvma mapin routines to map the buffer into DVMA space.
		 */
		sc->sc_dvmaaddr = *sc->sc_dmaaddr;
		sc->sc_dvmakaddr = kdvma_mapin(sc->sc_dvmaaddr,
					       sc->sc_dmasize, 0);
		if (sc->sc_dvmakaddr == NULL)
			panic("dma: cannot allocate DVMA address");
		DMADDR(sc) = sc->sc_dvmakaddr;
	} else
		DMADDR(sc) = *sc->sc_dmaaddr;

	if (sc->sc_rev == DMAREV_ESC) {
		/* DMA ESC chip bug work-around */
		long bcnt = sc->sc_dmasize;
		long eaddr = bcnt + (long)*sc->sc_dmaaddr;
		if ((eaddr & PGOFSET) != 0)
			bcnt = round_page(bcnt);
		DMACNT(sc) = bcnt;
	}
	/* Setup DMA control register */
	csr = DMACSR(sc);
	if (datain)
		csr |= D_WRITE;
	else
		csr &= ~D_WRITE;
	csr |= D_INT_EN;

	if (sc->sc_rev == DMAREV_HME) {
		csr |= (D_DSBL_SCSI_DRN | D_EN_DMA);
	}

	DMACSR(sc) = csr;

	return 0;
}

void
dma_go(sc)
	struct dma_softc *sc;
{

	/* Start DMA */
	DMACSR(sc) |= D_EN_DMA;
	sc->sc_active = 1;
}

/*
 * Pseudo (chained) interrupt from the esp driver to kick the
 * current running DMA transfer. I am replying on espintr() to
 * pickup and clean errors for now
 *
 * return 1 if it was a DMA continue.
 */
int
espdmaintr(sc)
	struct dma_softc *sc;
{
	struct ncr53c9x_softc *nsc = &sc->sc_esp->sc_ncr53c9x;
	int trans, resid;
	u_long csr;

	csr = DMACSR(sc);

	NCR_DMA(("%s: intr: addr %p, csr %lb\n", sc->sc_dev.dv_xname,
		 DMADDR(sc), csr, DDMACSR_BITS));

	if (csr & (D_ERR_PEND|D_SLAVE_ERR)) {
		printf("%s: error: csr=%lb\n", sc->sc_dev.dv_xname,
			csr, DDMACSR_BITS);
		DMACSR(sc) &= ~D_EN_DMA;	/* Stop DMA */
		/* Invalidate the queue; SLAVE_ERR bit is write-to-clear */
		DMACSR(sc) |= D_INVALIDATE|D_SLAVE_ERR;
		return (-1);
	}

	/* This is an "assertion" :) */
	if (sc->sc_active == 0)
		panic("dmaintr: DMA wasn't active");

	DMA_DRAIN(sc, 0);

	/* DMA has stopped */
	DMACSR(sc) &= ~D_EN_DMA;
	sc->sc_active = 0;

	if (sc->sc_dmasize == 0) {
		/* A "Transfer Pad" operation completed */
		NCR_DMA(("dmaintr: discarded %d bytes (tcl=%d, tcm=%d)\n",
			NCR_READ_REG(nsc, NCR_TCL) |
				(NCR_READ_REG(nsc, NCR_TCM) << 8),
			NCR_READ_REG(nsc, NCR_TCL),
			NCR_READ_REG(nsc, NCR_TCM)));
		return 0;
	}

	resid = 0;
	/*
	 * If a transfer onto the SCSI bus gets interrupted by the device
	 * (e.g. for a SAVEPOINTER message), the data in the FIFO counts
	 * as residual since the ESP counter registers get decremented as
	 * bytes are clocked into the FIFO.
	 */
	if (!(csr & D_WRITE) &&
	    (resid = (NCR_READ_REG(nsc, NCR_FFLAG) & NCRFIFO_FF)) != 0) {
		NCR_DMA(("dmaintr: empty esp FIFO of %d ", resid));
	}

	if ((nsc->sc_espstat & NCRSTAT_TC) == 0) {
		/*
		 * `Terminal count' is off, so read the residue
		 * out of the ESP counter registers.
		 */
		resid += (NCR_READ_REG(nsc, NCR_TCL) |
			  (NCR_READ_REG(nsc, NCR_TCM) << 8) |
			   ((nsc->sc_cfg2 & NCRCFG2_FE)
				? (NCR_READ_REG(nsc, NCR_TCH) << 16)
				: 0));

		if (resid == 0 && sc->sc_dmasize == 65536 &&
		    (nsc->sc_cfg2 & NCRCFG2_FE) == 0)
			/* A transfer of 64K is encoded as `TCL=TCM=0' */
			resid = 65536;
	}

	trans = sc->sc_dmasize - resid;
	if (trans < 0) {			/* transferred < 0 ? */
#if 0
		/*
		 * This situation can happen in perfectly normal operation
		 * if the ESP is reselected while using DMA to select
		 * another target.  As such, don't print the warning.
		 */
		printf("%s: xfer (%d) > req (%d)\n",
		    sc->sc_dev.dv_xname, trans, sc->sc_dmasize);
#endif
		trans = sc->sc_dmasize;
	}

	NCR_DMA(("dmaintr: tcl=%d, tcm=%d, tch=%d; trans=%d, resid=%d\n",
		NCR_READ_REG(nsc, NCR_TCL),
		NCR_READ_REG(nsc, NCR_TCM),
		(nsc->sc_cfg2 & NCRCFG2_FE)
			? NCR_READ_REG(nsc, NCR_TCH) : 0,
		trans, resid));

	if (csr & D_WRITE)
		cpuinfo.cache_flush(*sc->sc_dmaaddr, trans);

	if (CPU_ISSUN4M && sc->sc_dvmakaddr)
		dvma_mapout((vaddr_t)sc->sc_dvmakaddr,
			    (vaddr_t)sc->sc_dvmaaddr, sc->sc_dmasize);

	*sc->sc_dmalen -= trans;
	*sc->sc_dmaaddr += trans;

#if 0	/* this is not normal operation just yet */
	if (*sc->sc_dmalen == 0 ||
	    nsc->sc_phase != nsc->sc_prevphase)
		return 0;

	/* and again */
	dma_start(sc, sc->sc_dmaaddr, sc->sc_dmalen, DMACSR(sc) & D_WRITE);
	return 1;
#endif
	return 0;
}

/*
 * Pseudo (chained) interrupt from the le driver to handle DMA
 * errors.
 *
 * XXX: untested
 */
int
ledmaintr(sc)
	struct dma_softc *sc;
{
	u_long csr;

	csr = DMACSR(sc);

	if (csr & D_ERR_PEND) {
		DMACSR(sc) &= ~D_EN_DMA;	/* Stop DMA */
		DMACSR(sc) |= D_INVALIDATE;
		printf("%s: error: csr=%lb\n", sc->sc_dev.dv_xname,
			csr, DDMACSR_BITS);
		DMA_RESET(sc);
	}
	return 1;
}
@


1.30
log
@On SPARCbook systems, the ledma device node has a `cable-selection' property
specifying which media the on-board interface uses. We already query it to
set up proper register values; extend this to be able to pass a default
media to the le(4) child.

This makes SPARCbook system default to AUI without needing for a manual media
change.

tested by sebastia@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.29 2014/05/09 20:15:06 miod Exp $	*/
d41 2
a42 2
#include <sparc/autoconf.h>
#include <sparc/cpu.h>
d239 12
a250 9
	if (node != 0) do {
		name = getpropstring(node, "name");
		if (!romprop(&oca.ca_ra, name, node))
			continue;

		sbus_translate(parent, &oca);
		oca.ca_bustype = BUS_SBUS;
		(void) config_found(&sc->sc_dev, (void *)&oca, dmaprint);
	} while ((node = nextsibling(node)) != 0); else
@


1.29
log
@format string fixes and removal of -Wno-format for sparc kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.28 2010/07/10 19:32:24 miod Exp $	*/
d35 1
d46 3
d164 1
d167 1
d171 1
@


1.28
log
@sun4e (i.e. SPARCengine 1e) support. This platform is a mix between sun4 and
sun4c, as it has a sun4c OpenPROM but a sun4 8KB pagesize. VME devices are
not supported yet.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.27 2010/06/27 05:52:01 beck Exp $	*/
d468 1
a468 1
	NCR_DMA(("%s: start %d@@%p,%d\n", sc->sc_dev.dv_xname,
d479 1
a479 1
	NCR_DMA(("dma_setup: dmasize = %d\n", sc->sc_dmasize));
d556 1
a556 1
	NCR_DMA(("%s: intr: addr %p, csr %b\n", sc->sc_dev.dv_xname,
d560 1
a560 1
		printf("%s: error: csr=%b\n", sc->sc_dev.dv_xname,
d677 1
a677 1
		printf("%s: error: csr=%b\n", sc->sc_dev.dv_xname,
@


1.27
log
@make sparc compile again after tag team viking/guenther breakage.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.26 2010/06/26 23:24:44 guenther Exp $	*/
d114 1
a114 1
#if defined(SUN4C) || defined(SUN4M)
d136 1
a136 1
#if defined(SUN4C) || defined(SUN4M)
d220 1
a220 1
#if defined(SUN4C) || defined(SUN4M)
d241 1
a241 1
#endif /* SUN4C || SUN4M */
d416 1
a416 1
#if defined(SUN4C) || defined(SUN4M)
@


1.26
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.25 2008/12/26 15:13:07 miod Exp $	*/
d47 2
@


1.25
log
@Correctly report unconfigured child devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.24 2007/05/29 09:54:07 sobrado Exp $	*/
a38 1
#include <sys/user.h>
@


1.24
log
@use the right capitalization for `SBus'

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.23 2007/04/10 17:47:54 miod Exp $	*/
d96 1
a96 1
		printf("[%s at %s]", ca->ca_ra.ra_name, name);
@


1.23
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.22 2006/06/02 20:00:54 miod Exp $	*/
d350 1
a350 1
	DELAY(200);				/* > 10 Sbus clocks(?) */
@


1.22
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.21 2005/03/02 16:42:37 miod Exp $	*/
d250 1
a250 1
		 * if the sc->sc_dma field in it's softc is NULL, then tries to
@


1.21
log
@Support for SUNW,fas SCSI, currently restricted to the lower 8 targets due
to MI esp code limitations.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.20 2005/02/27 22:01:03 miod Exp $	*/
a219 3
	if (ca->ca_bustype == BUS_SBUS)
		sbus_establish(&sc->sc_sd, &sc->sc_dev);

@


1.20
log
@Use the DMA defines from dev/ic/lsi64854reg.h whenever possible; no functional
change.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.19 2004/02/01 15:39:37 miod Exp $	*/
d134 1
d146 1
d156 1
a156 2
		char *cabletype = getpropstring(ca->ca_ra.ra_node,
						"cable-selection");
d178 1
a178 1
		sc->sc_burst = getpropint(ca->ca_ra.ra_node,"burst-sizes", -1);
d205 3
d214 1
a214 11
	if (sc->sc_dev.dv_cfdata->cf_attach == &dma_ca) {
		sc->reset = espdma_reset;
		sc->intr = espdmaintr;
	} else {
		sc->reset = ledma_reset;
		sc->intr = ledmaintr;
	}
	sc->enintr = dma_enintr;
	sc->isintr = dma_isintr;
	sc->setup = dma_setup;
	sc->go = dma_go;
a215 1
	sc->sc_node = ca->ca_ra.ra_node;
d233 1
a233 1
	node = firstchild(sc->sc_node);
d268 17
d306 10
a315 8
	/*								\
	 * Select drain bit based on revision				\
	 * also clears errors and D_TC flag				\
	 */								\
	if (sc->sc_rev == DMAREV_1 || sc->sc_rev == DMAREV_0)		\
		DMACSR(sc) |= D_ESC_DRAIN;				\
	else								\
		DMACSR(sc) |= D_INVALIDATE;				\
d333 2
a334 2
	csr &= ~(D_WRITE|D_EN_DMA);					\
	csr |= D_INVALIDATE;						\
d343 2
d346 9
a354 2
	DMACSR(sc) |= D_RESET;			/* reset DMA */
	DELAY(200);				/* what should this be ? */
d357 10
a366 3
	DMACSR(sc) |= D_INT_EN;			/* enable interrupts */
	if (sc->sc_rev > DMAREV_1 && isledma == 0)
		DMACSR(sc) |= D_FASTER;
d369 1
d371 1
a371 1
		sc->sc_regs->csr &= ~L64854_BURST_SIZE; /* must clear first */
d373 1
a373 1
			DMACSR(sc) |= L64854_BURST_32;
d375 1
a375 1
			DMACSR(sc) |= L64854_BURST_16;
d377 1
a377 1
			DMACSR(sc) |= L64854_BURST_0;
d381 1
a381 1
		DMACSR(sc) |= D_ESC_AUTODRAIN;	/* Auto-drain */
d383 1
a383 1
			DMACSR(sc) &= ~0x800;
d385 1
a385 1
			DMACSR(sc) |= 0x800;
d390 6
d483 9
d521 5
d555 1
d561 1
a561 3
	if (csr & D_ERR_PEND) {
		DMACSR(sc) &= ~D_EN_DMA;	/* Stop DMA */
		DMACSR(sc) |= D_INVALIDATE;
d564 4
a567 1
		return -1;
@


1.19
log
@Trivial touches to compile with gcc 3.
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.18 2003/06/05 12:27:02 deraadt Exp $	*/
d157 1
a157 1
			sc->sc_regs->csr |= DE_AUI_TP;
d159 1
a159 1
			sc->sc_regs->csr &= ~DE_AUI_TP;
d162 1
a162 1
			sc->sc_regs->csr |= DE_AUI_TP;
d293 1
a293 1
	 * other revs: D_R_PEND bit reads as 0				\
d295 1
a295 1
	DMAWAIT(sc, sc->sc_regs->csr & D_R_PEND, "R_PEND", dontpanic);	\
d301 1
a301 1
		DMACSR(sc) |= D_DRAIN;					\
d317 1
a317 1
	 * other revs: D_R_PEND bit reads as 0				\
d319 1
a319 1
	DMAWAIT(sc, sc->sc_regs->csr & D_R_PEND, "R_PEND", dontpanic);	\
d342 1
a342 1
		sc->sc_regs->csr &= ~D_BURST_SIZE; /* must clear first */
d344 1
a344 1
			DMACSR(sc) |= D_BURST_32;
d346 1
a346 1
			DMACSR(sc) |= D_BURST_16;
d348 1
a348 1
			DMACSR(sc) |= D_BURST_0;
d352 1
a352 1
		DMACSR(sc) |= D_AUTODRAIN;	/* Auto-drain */
d509 1
a509 1
		 DMADDR(sc), csr, DMACSRBITS));
d515 1
a515 1
			csr, DMACSRBITS);
d629 1
a629 1
			csr, DMACSRBITS);
@


1.18
log
@3/4 knockout for peter galbavy
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.17 2002/03/14 01:26:42 millert Exp $	*/
d359 1
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.16 1999/09/10 23:32:02 art Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Peter Galbavy.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.16
log
@roundup(foo, NBPG) -> round_page(foo)
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.15 1999/07/09 21:34:44 art Exp $	*/
d62 14
a75 14
int dmaprint		__P((void *, const char *));
void dmaattach		__P((struct device *, struct device *, void *));
int dmamatch		__P((struct device *, void *, void *));
void dma_reset		__P((struct dma_softc *, int));
void espdma_reset	__P((struct dma_softc *));
int ledmamatch		__P((struct device *, void *, void *));
void ledma_reset	__P((struct dma_softc *));
void dma_enintr		__P((struct dma_softc *));
int dma_isintr		__P((struct dma_softc *));
int espdmaintr		__P((struct dma_softc *));
int ledmaintr		__P((struct dma_softc *));
int dma_setup		__P((struct dma_softc *, caddr_t *, size_t *,
			     int, size_t *));
void dma_go		__P((struct dma_softc *));
@


1.16.14.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.16 1999/09/10 23:32:02 art Exp $	*/
d62 14
a75 14
int dmaprint(void *, const char *);
void dmaattach(struct device *, struct device *, void *);
int dmamatch(struct device *, void *, void *);
void dma_reset(struct dma_softc *, int);
void espdma_reset(struct dma_softc *);
int ledmamatch(struct device *, void *, void *);
void ledma_reset(struct dma_softc *);
void dma_enintr(struct dma_softc *);
int dma_isintr(struct dma_softc *);
int espdmaintr(struct dma_softc *);
int ledmaintr(struct dma_softc *);
int dma_setup(struct dma_softc *, caddr_t *, size_t *,
			     int, size_t *);
void dma_go(struct dma_softc *);
@


1.16.4.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d62 14
a75 14
int dmaprint(void *, const char *);
void dmaattach(struct device *, struct device *, void *);
int dmamatch(struct device *, void *, void *);
void dma_reset(struct dma_softc *, int);
void espdma_reset(struct dma_softc *);
int ledmamatch(struct device *, void *, void *);
void ledma_reset(struct dma_softc *);
void dma_enintr(struct dma_softc *);
int dma_isintr(struct dma_softc *);
int espdmaintr(struct dma_softc *);
int ledmaintr(struct dma_softc *);
int dma_setup(struct dma_softc *, caddr_t *, size_t *,
			     int, size_t *);
void dma_go(struct dma_softc *);
@


1.16.4.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.16.4.1 2002/03/28 10:57:10 niklas Exp $	*/
d16 5
@


1.16.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a358 1
		break;
@


1.15
log
@vm_offset_t -> {v,p}addr_t and vm_size_t -> {v,p}size_t
remove "register" keywords
Various cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.14 1999/02/28 19:12:32 jason Exp $	*/
d471 1
a471 1
			bcnt = roundup(bcnt, NBPG);
@


1.14
log
@conditionalize use of sbus_testdma()
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.13 1998/11/11 00:50:31 jason Exp $	*/
d98 1
a98 1
	register struct confargs *ca = aux;
d111 3
a113 3
	register struct cfdata *cf = vcf;
	register struct confargs *ca = aux;
	register struct romaux *ra = &ca->ca_ra;
d137 1
a137 1
	register struct confargs *ca = aux;
d381 3
a383 3
	register struct cfdata *cf = vcf;
	register struct confargs *ca = aux;
	register struct romaux *ra = &ca->ca_ra;
d468 2
a469 2
		register long bcnt = sc->sc_dmasize;
		register long eaddr = bcnt + (long)*sc->sc_dmaaddr;
d597 2
a598 2
		dvma_mapout((vm_offset_t)sc->sc_dvmakaddr,
			    (vm_offset_t)sc->sc_dvmaaddr, sc->sc_dmasize);
@


1.13
log
@A few more dma in non-dma slot checks
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.12 1998/07/05 09:24:25 deraadt Exp $	*/
d118 1
d124 1
d387 1
d390 1
@


1.12
log
@do not print fake slot numbers
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.11 1998/02/05 19:02:30 jason Exp $	*/
d67 1
d86 1
a86 1
	sizeof(struct dma_softc), matchbyname, dmaattach
d118 3
a120 1
	if (ca->ca_bustype == BUS_SBUS)
d122 1
d372 16
@


1.11
log
@sync with netbsd: 4/300 dma fix
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.10 1998/01/28 17:21:46 jason Exp $	*/
d101 1
a101 1
	printf(" slot 0x%x offset 0x%x", ca->ca_slot, ca->ca_offset);
@


1.10
log
@Undo the 4/300 dmaselect hack and fix it correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.9 1997/09/17 06:47:08 downsj Exp $	*/
a287 3
									\
	if (sc->sc_rev == DMAREV_0)					\
		DMACSR(sc) |= D_INVALIDATE;				\
d310 15
d330 1
a330 2
	DMA_DRAIN(sc, 1);
	DMACSR(sc) &= ~D_EN_DMA;		/* Stop DMA */
d407 1
a407 1
	DMA_DRAIN(sc, 0);
@


1.9
log
@NETBSD_CURRENT_970916.  Lot's just ID changes, since changes don't apply to
us.  Includes some pmap changes, for which I don't have the original commit
message(s) handy.
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.8 1997/08/08 08:24:57 downsj Exp $	*/
d288 3
@


1.8
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: dma.c,v 1.45 1997/07/29 09:58:06 fair Exp $ */
@


1.7
log
@added const to second parameter of cfprint_t routines
@
text
@d1 2
a2 1
/*	$NetBSD: dma.c,v 1.28.2.2 1996/07/02 23:46:29 jtc Exp $ */
d49 2
d54 3
a59 1
#include <sparc/dev/espreg.h>
d65 3
a67 1
void dma_reset		__P((struct dma_softc *));
d110 1
a110 1
	struct cfdata *cf = vcf;
d141 1
a141 2
		    mapiodev(ca->ca_ra.ra_reg, 0, ca->ca_ra.ra_len,
			     ca->ca_bustype);
d165 1
a165 1
	
d167 3
a169 3
	 * Get transfer burst size from PROM and plug it into the controller
	 * registers. This is needed on the Sun4m; do others need it too?
	 * XXX
d172 4
d177 6
a182 21
		if (sc->sc_burst == -1) {
			/* check parent SBus for burst sizes */
			if (((struct sbus_softc *)parent)->sc_burst == 0)
				sc->sc_burst = SBUS_BURST_32 - 1; /* 1->16 */
			else
				sc->sc_burst = 
					((struct sbus_softc *)parent)->sc_burst;
		}
		sc->sc_regs->csr &= ~D_BURST_SIZE; /* must clear first */
		if (sc->sc_burst & SBUS_BURST_32) {
			sc->sc_regs->csr |= D_BURST_32;
		} else if (sc->sc_burst & SBUS_BURST_16) {
			sc->sc_regs->csr |= D_BURST_16;
		} else if (strcmp(ca->ca_ra.ra_name,"espdma") == 0) {
			/* only espdma supports non-burst */
			sc->sc_regs->csr |= D_BURST_0;
#ifdef DIAGNOSTIC
		} else {
			printf(" <unknown burst size 0x%x>", sc->sc_burst);
#endif
		}
d191 3
d204 1
a204 1
		printf("unknown");
d210 1
d213 1
a217 1
	sc->reset = dma_reset;
d274 36
d311 1
a311 1
dma_reset(sc)
d313 1
d315 1
a315 2
	DMAWAIT(sc);
	DMA_DRAIN(sc);				/* Drain (DMA rev 1) */
a316 1
	DMAWAIT1(sc);				/* let things drain */
d319 1
a319 1
	DMAWAIT1(sc);
d322 1
a322 1
	if (sc->sc_rev > DMAREV_1)
d324 22
d349 13
d393 1
a393 6
	/* clear errors and D_TC flag */
	DMAWAIT(sc);
	DMA_DRAIN(sc);		/* ? */
	DMAWAIT1(sc);
	DMACSR(sc) |= D_INVALIDATE;
	DMAWAIT1(sc);
d401 1
a401 1
	ESP_DMA(("%s: start %d@@%p,%d\n", sc->sc_dev.dv_xname,
d412 1
a412 1
	ESP_DMA(("dma_setup: dmasize = %d\n", sc->sc_dmasize));
d428 8
d469 1
d474 1
a474 1
	ESP_DMA(("%s: intr: addr %p, csr %b\n", sc->sc_dev.dv_xname,
d482 1
a482 1
		return 0;
d489 1
a489 6
	/* clear errors and D_TC flag */
	DMAWAIT(sc);
	DMA_DRAIN(sc);		/* ? */
	DMAWAIT1(sc);
	DMACSR(sc) |= D_INVALIDATE;
	DMAWAIT1(sc);
d497 5
a501 5
		ESP_DMA(("dmaintr: discarded %d bytes (tcl=%d, tcm=%d)\n",
			ESP_READ_REG(sc->sc_esp, ESP_TCL) |
				(ESP_READ_REG(sc->sc_esp, ESP_TCM) << 8),
			ESP_READ_REG(sc->sc_esp, ESP_TCL),
			ESP_READ_REG(sc->sc_esp, ESP_TCM)));
d513 2
a514 3
	    (resid = (ESP_READ_REG(sc->sc_esp, ESP_FFLAG) & ESPFIFO_FF)) != 0) {
		ESP_DMA(("dmaintr: empty esp FIFO of %d ", resid));
		ESPCMD(sc->sc_esp, ESPCMD_FLUSH);
d517 1
a517 1
	if ((sc->sc_esp->sc_espstat & ESPSTAT_TC) == 0) {
d522 4
a525 4
		resid += ( ESP_READ_REG(sc->sc_esp, ESP_TCL) |
			  (ESP_READ_REG(sc->sc_esp, ESP_TCM) << 8) |
			   ((sc->sc_esp->sc_cfg2 & ESPCFG2_FE)
				? (ESP_READ_REG(sc->sc_esp, ESP_TCH) << 16)
d529 1
a529 1
		    (sc->sc_esp->sc_cfg2 & ESPCFG2_FE) == 0)
d536 6
d544 1
d548 5
a552 5
	ESP_DMA(("dmaintr: tcl=%d, tcm=%d, tch=%d; trans=%d, resid=%d\n",
		ESP_READ_REG(sc->sc_esp, ESP_TCL),
		ESP_READ_REG(sc->sc_esp, ESP_TCM),
		(sc->sc_esp->sc_cfg2 & ESPCFG2_FE)
			? ESP_READ_REG(sc->sc_esp, ESP_TCH) : 0,
d556 1
a556 1
		cache_flush(*sc->sc_dmaaddr, trans);
d567 1
a567 1
	    sc->sc_esp->sc_phase != sc->sc_esp->sc_prevphase)
a591 1
		printf("Lance DMA error, see your doctor!\n");
d595 2
a596 1
			(u_int)csr, DMACSRBITS);
@


1.6
log
@netbsd port, now we merge our changes back in
@
text
@d57 1
a57 1
int dmaprint		__P((void *, char *));
d88 1
a88 1
	char *name;
@


1.5
log
@dmamatch never added in the offset for the dma registers to the VA,
and thus probed the wrong address on the 4/300 (but it worked because
it was probing the esp0 registers!).

now that bus_tmp() adds the offset in for us [as of obio 1.15] i
discoved that a byte access to the dma registers is not allowed.
so, i've change probeget to use a word access.
@
text
@d1 1
a1 1
/*	$NetBSD: dma.c,v 1.8 1995/02/01 12:37:21 pk Exp $ */
d4 1
a4 29
 * Copyright (c) 1995 Theo de Raadt
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
a51 1
#include <sparc/dev/sbusreg.h>
d57 1
a57 6
#include <sparc/sparc/cache.h>

/*#define DMA_TEST*/

extern int sbus_print	__P((void *, char *));

d60 8
d69 2
a70 3
struct cfdriver dmacd = {
	NULL, "dma", dmamatch, dmaattach,
	DV_DULL, sizeof(struct dma_softc)
d73 2
a74 3
struct cfdriver ledmacd = {
	NULL, "ledma", dmamatch, dmaattach,
	DV_DULL, sizeof(struct dma_softc)
d77 2
a78 3
struct cfdriver espdmacd = {
	NULL, "espdma", dmamatch, dmaattach,
	DV_DULL, sizeof(struct dma_softc)
d81 17
d100 2
a101 2
	struct	device *parent;
	void	*vcf, *aux;
d103 1
a103 1
	struct	cfdata *cf = vcf;
d107 2
a108 1
	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
d121 2
a122 2
	struct	device *parent, *self;
	void	*aux;
d125 12
a136 11
	struct	confargs oca;
	struct	dma_softc *sc = (void *)self;
	int	node, base, slot;
	char	*name;

	/* XXX modifying ra_vaddr is bad! */
	if (ca->ca_ra.ra_vaddr == NULL)
		ca->ca_ra.ra_vaddr = mapiodev(ca->ca_ra.ra_reg, 0,
		    ca->ca_ra.ra_len, ca->ca_bustype);
	if ((u_long)ca->ca_ra.ra_paddr & PGOFSET)
		(u_long)ca->ca_ra.ra_vaddr |= ((u_long)ca->ca_ra.ra_paddr & PGOFSET);
d140 24
a163 5
	 * What happens here is that if the esp driver has not been
	 * configured, then this returns a NULL pointer. Then when the
	 * esp actually gets configured, it does the opposing test, and
	 * if the sc->sc_dma field in it's softc is NULL, then tries to
	 * find the matching dma driver.
d165 24
a188 4
	sc->sc_esp = ((struct esp_softc *)
	    getdevunit("esp", sc->sc_dev.dv_unit));
	if (sc->sc_esp)
		sc->sc_esp->sc_dma = sc;
d193 2
a194 2
	case DMAREV_4300:
		printf("4/300\n");
d197 1
a197 4
		printf("1\n");
		break;
	case DMAREV_ESC1:
		printf("ESC1\n");
d200 1
a200 1
		printf("1+\n");
d203 1
a203 1
		printf("2\n");
d206 9
a214 1
		printf("unknown\n");
d216 9
d227 1
a227 2
	if (ca->ca_bustype == BUS_SBUS) {
		sc->sc_node = ca->ca_ra.ra_node;
d230 24
d255 8
a262 3
		 * If the device is in an SBUS slave slot, report
		 * it (but we don't care, because the corresponding
		 * ESP will also realize the same thing.)
d264 2
a265 1
		(void) sbus_slavecheck(self, ca);
d268 1
a268 3
		 * if our name is not "dma", we may have subdevices
		 * below us in the device tree (like an esp)
		 * XXX: TDR: should we do this even if it is "dma"?
d270 2
a271 37
		if (strcmp(ca->ca_ra.ra_name, "dma") == 0)
			return;

		/* search through children */
		for (node = firstchild(sc->sc_node); node;
		    node = nextsibling(node)) {
			name = getpropstring(node, "name");
			if (!romprop(&oca.ca_ra, name, node))
				continue;

			/*
			 * advance bootpath if it currently points to us
			 * XXX There appears to be strangeness in the unit
			 * number on at least one espdma system (SS5 says
			 * espdma5, but nothing is available to compare
			 * against that digit 5...
			 */
			if (ca->ca_ra.ra_bp &&
			    !strcmp(ca->ca_ra.ra_bp->name, ca->ca_ra.ra_name) &&
			    ca->ca_ra.ra_bp->val[1] == (int)ca->ca_ra.ra_paddr)
				oca.ca_ra.ra_bp = ca->ca_ra.ra_bp + 1;
			else
				oca.ca_ra.ra_bp = NULL;

			base = (int)oca.ca_ra.ra_paddr;
			if (SBUS_ABS(base)) {
				oca.ca_slot = SBUS_ABS_TO_SLOT(base);
				oca.ca_offset = SBUS_ABS_TO_OFFSET(base);
			} else {
				oca.ca_slot = slot = ca->ca_ra.ra_iospace;
				oca.ca_offset = base;
				oca.ca_ra.ra_paddr = (void *)SBUS_ADDR(slot, base);
			}
			oca.ca_bustype = BUS_SBUS;
			(void) config_found(&sc->sc_dev, (void *)&oca, sbus_print);
		}

a272 1
#endif /* SUN4C || SUN4M */
d276 2
a277 2
dmareset(sc)
	struct	dma_softc *sc;
d279 4
a282 1
	DMAWAIT_PEND(sc);
d285 1
d287 5
a292 11
	switch (sc->sc_rev) {
	case DMAREV_1:
	case DMAREV_4300:
	case DMAREV_ESC1:
		break;
	case DMAREV_PLUS:
	case DMAREV_2:
		if (sc->sc_esp->sc_rev >= ESP100A)
			DMACSR(sc) |= D_FASTER;
		break;
	}
d294 5
a298 1
	sc->sc_active = 0;			/* and of course we aren't */
d302 1
a302 1
dmapending(sc)
d308 1
a308 2
/* bytes between loc and the end of this 16M region of memory */
#define DMAMAX(loc)	(0x01000000 - ((loc) & 0x00ffffff))
a309 2
#define ESPMAX	((sc->sc_esp->sc_rev > ESP100A) ? \
		    (16 * 1024 * 1024) : (64 * 1024))
d312 1
a312 3
 * Start a dma transfer or keep it going.
 * We do the loading of the transfer counter.
 * XXX: what about write-back caches?
d314 7
a320 6
void
dmastart(sc, addr, len, datain, poll)
	struct	dma_softc *sc;
	void	*addr;
	size_t	*len;
	int	datain, poll;
d322 1
a322 2
	struct espregs *espr = sc->sc_esp->sc_regs;
	int	size;
d324 6
a329 2
	if (sc->sc_active)
		panic("dma: dmastart() called while active\n");
d331 3
d336 3
a338 2
	sc->sc_dmapolling = poll;
	sc->sc_dmadev2mem = datain;
d345 27
a371 11
	size = min(*sc->sc_dmalen, ESPMAX);
	size = min(size, DMAMAX((size_t) *sc->sc_dmaaddr));
	sc->sc_segsize = size;

#ifdef DMA_TEST
	printf("%s: start %d@@0x%08x [%s scsi] [chunk=%d] %d\n",
	    sc->sc_dev.dv_xname,
	    *sc->sc_dmalen, *sc->sc_dmaaddr,
	    datain ? "read from" : "write to",
	    sc->sc_segsize, poll);
#endif
d373 2
a374 9
	espr->espr_tcl = size;
	espr->espr_tcm = size >> 8;
	if (sc->sc_esp->sc_rev > ESP100A)
		espr->espr_tch = size >> 16;
	espr->espr_cmd = ESPCMD_DMA|ESPCMD_NOP;	/* load the count in */

	DMADDR(sc) = *sc->sc_dmaaddr;
	DMACSR(sc) = (DMACSR(sc) & ~(D_WRITE|D_INT_EN)) | D_EN_DMA |
	    (datain ? D_WRITE : 0) | (poll ? 0 : D_INT_EN);
d376 4
a379 2
	/* and kick the SCSI */
	espr->espr_cmd = ESPCMD_DMA|ESPCMD_TRANS;
d381 2
d388 2
a389 1
 * current running DMA transfer. espintr() cleans up errors.
d391 1
a391 2
 * return 1 if a dma operation is being continued (for when all
 * the data could not be transferred in one dma operation).
d394 2
a395 3
dmaintr(sc, restart)
	struct	dma_softc *sc;
	int restart;
d397 3
a399 2
	struct espregs *espr = sc->sc_esp->sc_regs;
	int	trans = 0, resid;
d401 2
a402 3
#ifdef DMA_TEST
	printf("%s: intr\n", sc->sc_dev.dv_xname);
#endif
d404 2
a405 4
	if (DMACSR(sc) & D_ERR_PEND) {
		printf("%s: error", sc->sc_dev.dv_xname);
		if (sc->sc_rev == DMAREV_4300)
			DMAWAIT_PEND(sc);
d407 3
a409 1
		return (0);
d412 1
d416 8
a423 4
	/* DMA has stopped, but flush it first */
	dmadrain(sc);
	if (DMACSR(sc) & D_DRAINING)
		printf("drain failed %d left\n", DMACSR(sc) & D_DRAINING);
d427 16
a442 7
	/* 
	 * XXX: The subtracting of resid and throwing away up to 31
	 * bytes cannot be the best/right way to do this. There's got
	 * to be a better way, such as letting the DMA take control
	 * again and putting it into memory, or pulling it out and
	 * putting it in memory by ourselves.
	 * XXX in the meantime, just do this job silently
d444 21
a464 8
	resid = 0;
	if (!sc->sc_dmadev2mem &&
	    (resid = (espr->espr_fflag & ESPFIFO_FF)) != 0) {
#if 0
		printf("empty FIFO of %d ", resid);
#endif
		espr->espr_cmd = ESPCMD_FLUSH;
		DELAY(1);
d466 2
a467 3
	resid += espr->espr_tcl | (espr->espr_tcm << 8) |
	    (sc->sc_esp->sc_rev > ESP100A ? (espr->espr_tch << 16) : 0);
	trans = sc->sc_segsize - resid;
d470 2
a471 2
		    sc->sc_dev.dv_xname, trans, sc->sc_segsize);
		trans = sc->sc_segsize;
d474 6
a479 3
#ifdef DMA_TEST
	printf("dmaintr: resid=%d, trans=%d\n", resid, trans);
#endif
d481 1
a481 1
	if (sc->sc_dmadev2mem && vactype != VAC_NONE)
d484 4
a487 1
	sc->sc_segsize -= trans;
d491 4
a494 8
#ifdef DMA_TEST
	printf("%s: %d/%d bytes left\n", sc->sc_dev.dv_xname,
	    *sc->sc_dmalen, sc->sc_segsize);
#endif

	/* completely finished with the DMA transaction */
	if (sc->sc_segsize == 0 && *sc->sc_dmalen == 0)
		return (0);
a495 2
	if (restart == 0)
		return (1);
d497 4
a500 3
	dmastart(sc, sc->sc_dmaaddr, sc->sc_dmalen, sc->sc_dmadev2mem,
	    sc->sc_dmapolling);
	return (1);
d504 4
a507 3
 * We have to ask rev 1 and 4/300 dma controllers to drain their fifo.
 * Apparently the other chips have drained by the time we get an
 * interrupt, but we check anyways.
d509 2
a510 38
void
dmadrain(sc)
	struct dma_softc *sc;
{
	switch (sc->sc_rev) {
	case DMAREV_1:
	case DMAREV_4300:
	case DMAREV_PLUS:
	case DMAREV_2:
		if (DMACSR(sc) & D_DRAINING)
			DMAWAIT_DRAIN(sc);
		break;
	case DMAREV_ESC1:
		DMAWAIT_PEND(sc)
		DMAWAIT_DRAIN(sc);		/* XXX: needed? */
		break;
	}
	DMACSR(sc) |= D_INVALIDATE;
}

/*
 * XXX
 * During autoconfig we are in polled mode and we execute some commands.
 * eventually we execute the last polled command. esp interrupts go through
 * the dma chip's D_INT_EN gate. thus, because we have our data, we're happy
 * and return. the esp chip has not, however, become unbusy. as soon as we
 * execute our first non-polled command, we find the esp state machine is
 * non-idle. it has not finished getting off the scsi bus, because it didn't
 * get interrupts (and the polled code has long since gone it's merry way.)
 * 
 * therefore, whenever we finish with a polled mode command, we enable
 * interrupts so that we can get our data. it is probably safe to do so,
 * since the scsi transfer has happened without error. the interrupts that
 * will happen have no bearing on the higher level scsi subsystem, since it
 * just functions to let the esp chip "clean up" it's state.
 */
void
dmaenintr(sc)
d513 1
a513 2
	DMACSR(sc) |= D_INT_EN;
}
d515 1
a515 5
int
dmadisintr(sc)
	struct dma_softc *sc;
{
	int x = DMACSR(sc) & D_INT_EN;
d517 8
a524 2
	DMACSR(sc) &= ~D_INT_EN;
	return x;
@


1.4
log
@new mapdev/()/mapiodev() calling convention uses "struct rom_reg *" to supply
base plus an offset
new dvma routines
@
text
@d124 1
a124 1
	return (probeget(ra->ra_vaddr, 1) != -1);
@


1.3
log
@fix copyrights
@
text
@d143 1
a143 1
		ca->ca_ra.ra_vaddr = mapiodev(ca->ca_ra.ra_paddr,
@


1.2
log
@new driver by me
@
text
@d4 29
a33 1
 * Copyright (c) 1995 Theo de Raadt.  All rights reserved.
d45 1
a45 2
 *	This product includes software developed by Peter Galbavy and
 *	Theo de Raadt.
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: dma.c,v 1.10 1995/08/18 10:43:49 pk Exp $ */
d5 2
d17 2
a18 1
 *	This product includes software developed by Peter Galbavy.
d53 1
d59 6
a64 1
int dmaprint		__P((void *, char *));
a66 5
void dma_reset		__P((struct dma_softc *));
void dma_enintr		__P((struct dma_softc *));
int dma_isintr		__P((struct dma_softc *));
void dma_start		__P((struct dma_softc *, caddr_t *, size_t *, int));
int dmaintr		__P((struct dma_softc *));
d74 1
a74 1
	NULL, "ledma", matchbyname, dmaattach,
d79 1
a79 1
	NULL, "espdma", matchbyname, dmaattach,
a83 8
dmaprint(aux, name)
	void *aux;
	char *name;
{
	return -1;
}

int
d85 2
a86 2
	struct device *parent;
	void *vcf, *aux;
d88 1
a88 1
	struct cfdata *cf = vcf;
d105 2
a106 2
	struct device *parent, *self;
	void *aux;
d109 4
a112 3
	struct dma_softc *sc = (void *)self;
	int node, base, slot;
	char *name;
d114 1
a114 3
	/*
	 * do basic sbus stuff (I think)
	 */
a122 2
	 * find the ESP by poking around the esp device structures
	 *
a127 1
	 *
a130 4

	/*
	 * and a back pointer to us, for DMA
	 */
d137 2
a138 2
	case DMAREV_0:
		printf("0");
d141 4
a144 1
		printf("1");
d147 1
a147 1
		printf("1+");
d150 1
a150 1
		printf("2");
d153 1
a153 1
		printf("unknown");
a154 1
	printf("\n");
a155 8
	/* indirect functions */
	sc->enintr = dma_enintr;
	sc->isintr = dma_isintr;
	sc->reset = dma_reset;
	sc->start = dma_start;
	sc->intr = dmaintr;

	sc->sc_node = ca->ca_ra.ra_node;
d157 2
a158 1
	if (ca->ca_bustype == BUS_SBUS)
a159 1
#endif /* SUN4C || SUN4M */
d161 47
a207 18
#ifdef notyet
	/* return if we are a plain "dma" with no children */
	if (strcmp(getpropstring(node, "name"), "dma") == 0)
		return;

	/* search through children */
	for (node = firstchild(sc->sc_node); node; node = nextsibling(node)) {
		name = getpropstring(node, "name");
		if (!romprop(&ca->ca_ra, name, node))
			continue;
		base = (int)ca->ca_ra.ra_paddr;
		if (SBUS_ABS(base)) {
			ca->ca_slot = SBUS_ABS_TO_SLOT(base);
			ca->ca_offset = SBUS_ABS_TO_OFFSET(base);
		} else {
			ca->ca_slot = slot = ca->ca_ra.ra_iospace;
			ca->ca_offset = base;
			ca->ca_ra.ra_paddr = (void *)SBUS_ADDR(slot, base);
d209 1
a209 1
		(void) config_found(&sc->sc_dev, (void *)&ca, dmaprint);
d211 1
a211 1
#endif
d215 2
a216 2
dma_reset(sc)
	struct dma_softc *sc;
d218 1
a218 1
	DMAWAIT1(sc);				/* let things drain */
a221 5
	DMACSR(sc) |= D_INT_EN;			/* enable interrupts */
	if (sc->sc_rev > DMAREV_1)
		DMACSR(sc) |= D_FASTER;
	sc->sc_active = 0;			/* and of course we aren't */
}
d223 11
d235 1
a235 5
void
dma_enintr(sc)
	struct dma_softc *sc;
{
	sc->sc_regs->csr |= D_INT_EN;
d239 1
a239 1
dma_isintr(sc)
d245 5
a249 3
#define ESPMAX		((sc->sc_esp->sc_rev > ESP100A) ? \
			    (16 * 1024 * 1024) : (64 * 1024))
#define DMAMAX(a)	(0x01000000 - ((a) & 0x00ffffff))
a250 1
/*!!!*/int xdmadebug = 0;
d252 3
a254 1
 * start a dma transfer or keep it going
d257 5
a261 5
dma_start(sc, addr, len, datain)
	struct dma_softc *sc;
	caddr_t *addr;
	size_t *len;
	int datain;
d263 5
a267 3
	/* we do the loading of the transfer counter */
	volatile caddr_t esp = sc->sc_esp->sc_reg;
	size_t size;
d271 2
a272 2

	ESP_DMA(("%s: start %d@@0x%08x,%d\n", sc->sc_dev.dv_xname, *sc->sc_dmalen, *sc->sc_dmaaddr, datain ? 1 : 0));
d281 1
a281 1
	sc->sc_dmasize = size;
d283 7
a289 9
	ESP_DMA(("dma_start: dmasize = %d\n", sc->sc_dmasize));

	esp[ESP_TCL] = size;
	esp[ESP_TCM] = size >> 8;
	if (sc->sc_esp->sc_rev > ESP100A) {
		esp[ESP_TCH] = size >> 16;
	}  
	/* load the count in */
	ESPCMD(sc->sc_esp, ESPCMD_NOP|ESPCMD_DMA);
d291 5
a295 5
	DMAWAIT1(sc);

	/* clear errors and D_TC flag */
	DMACSR(sc) |= D_INVALIDATE;
	DMAWAIT1(sc);
d298 2
a299 5
	DMACSR(sc) |= datain|D_EN_DMA|D_INT_EN;

	/* and clear from last read if this is a write */
	if (!datain)
		DMACSR(sc) &= ~D_WRITE;
d301 2
a302 8
	/*
	 * and kick the SCSI
	 * Note that if `size' is 0, we've already transceived all
	 * the bytes we want but we're still in the DATA PHASE.
	 * Apparently, the device needs padding. Also, a transfer
	 * size of 0 means "maximum" to the chip DMA logic.
	 */
	ESPCMD(sc->sc_esp, (size==0?ESPCMD_TRPAD:ESPCMD_TRANS)|ESPCMD_DMA);
d309 1
a309 2
 * current running DMA transfer. I am replying on espintr() to
 * pickup and clean errors for now
d311 2
a312 1
 * return 1 if it was a DMA continue.
d315 3
a317 2
dmaintr(sc)
	struct dma_softc *sc;
d319 2
a320 2
	volatile caddr_t esp = sc->sc_esp->sc_reg;
	int trans = 0, resid = 0;
d322 3
a324 1
	ESP_DMA(("%s: intr\n", sc->sc_dev.dv_xname));
d328 2
d331 1
a331 1
		return 0;
a333 1
	/* This is an "assertion" :) */
d337 4
a340 1
	/* DMA has stopped */
d344 12
a355 8
	if (sc->sc_dmasize == 0) {
		/* A "Transfer Pad" operation completed */
		ESP_DMA(("dmaintr: discarded %d bytes (tcl=%d, tcm=%d)\n", esp[ESP_TCL] | (esp[ESP_TCM] << 8), esp[ESP_TCL], esp[ESP_TCM]));
		return 0;
	}

	if (!(DMACSR(sc) & D_WRITE) &&
	    (resid = (esp[ESP_FFLAG] & ESPFIFO_FF)) != 0) {
d357 2
a358 1
		ESPCMD(sc->sc_esp, ESPCMD_FLUSH);
d361 3
a363 4

	resid += esp[ESP_TCL] | (esp[ESP_TCM] << 8) |
	    (sc->sc_esp->sc_rev > ESP100A ? (esp[ESP_TCH] << 16) : 0);
	trans = sc->sc_dmasize - resid;
d366 2
a367 2
		    sc->sc_dev.dv_xname, trans, sc->sc_dmasize);
		trans = sc->sc_dmasize;
d370 3
a372 1
	ESP_DMA(("dmaintr: tcl=%d, tcm=%d, tch=%d; resid=%d, trans=%d\n", esp[ESP_TCL],esp[ESP_TCM], esp[ESP_TCH], trans, resid));
d374 1
a374 1
	if (DMACSR(sc) & D_WRITE)
d377 1
d381 8
a388 3
	if (*sc->sc_dmalen == 0 ||
	    sc->sc_esp->sc_phase != sc->sc_esp->sc_prevphase)
		return 0;
d390 2
d393 61
a453 2
	dma_start(sc, sc->sc_dmaaddr, sc->sc_dmalen, DMACSR(sc) & D_WRITE);
	return 1;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
