head	1.6;
access;
symbols
	OPENBSD_6_0:1.6.0.42
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.38
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.40
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.32
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.36
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.34
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.30
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.28
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.26
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.24
	OPENBSD_5_0:1.6.0.22
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.20
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.18
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.14
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.16
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.12
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.12
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.10
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.4.0.6
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.10
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.8
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.6
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2006.06.02.20.00.54;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.02.18.40.59;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.16.15.47.57;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	99.02.24.06.57.45;	author jason;	state Exp;
branches
	1.3.6.1
	1.3.8.1
	1.3.10.1;
next	1.2;

1.2
date	98.11.02.05.50.59;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	98.10.19.05.41.21;	author jason;	state Exp;
branches;
next	;

1.3.6.1
date	2001.05.14.21.37.09;	author niklas;	state Exp;
branches;
next	1.3.6.2;

1.3.6.2
date	2003.06.07.11.14.43;	author ho;	state Exp;
branches;
next	;

1.3.8.1
date	2000.11.17.18.52.06;	author jason;	state Exp;
branches;
next	;

1.3.10.1
date	2000.11.17.20.20.09;	author jason;	state Exp;
branches;
next	;


desc
@@


1.6
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@/*	$OpenBSD: qevar.h,v 1.5 2003/06/02 18:40:59 jason Exp $	*/

/*
 * Copyright (c) 1998, 2000 Jason L. Wright.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

struct qesoftc {
	struct	device sc_dev;
	struct	intrhand sc_ih;		/* interrupt vectoring */
	struct	arpcom sc_arpcom;	/* ethernet common */

	struct	qec_softc *sc_qec;	/* QEC parent */
	struct	qecregs *sc_qr;		/* QEC registers */
	struct	qe_mregs *sc_mr;	/* MACE registers */
	struct	qe_cregs *sc_cr;	/* Channel registers */

	int	sc_channel;
	u_int	sc_rev;

	int	sc_burst;

	struct	qe_bufs *sc_bufs, *sc_bufs_dva;
	struct	qe_desc *sc_desc, *sc_desc_dva;

	int	sc_no_td, sc_first_td, sc_last_td;
	int	sc_last_rd;
	struct	ifmedia sc_ifmedia;
};
@


1.5
log
@nuke my clause 3 & 4 (and a couple jointly (c) with Theo).
@
text
@d1 1
a1 1
/*	$OpenBSD: qevar.h,v 1.4 2000/11/16 15:47:57 jason Exp $	*/
a29 1
	struct	sbusdev sc_sd;		/* sbus device */
@


1.4
log
@- Fix the NMI problem: it seems the qec channel reset also resets the MACE, and
a race condition existed where after a qec channel reset, accesses to the
MACE would cause an NMI: so wait for the MACE to come out of reset before
accessing.

- add ifmedia support (mainly so I can get at the link status from other code)
- move some of the spl handling around (more correct)
- rewrite qe_mcreset() again so that all it does is set the multicast filter
- use bzero to initialize the buffers and descriptors
- rearrange the MACE setup to conform to the suggestions in the datasheet
@
text
@d1 1
a1 1
/*	$OpenBSD: qevar.h,v 1.3 1999/02/24 06:57:45 jason Exp $	*/
a14 2
 * 3. The name of the authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.3
log
@better promisc & allmulti handling
@
text
@d1 1
a1 1
/*	$OpenBSD: qevar.h,v 1.2 1998/11/02 05:50:59 jason Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Jason L. Wright.
d51 1
@


1.3.6.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: qevar.h,v 1.4 2000/11/16 15:47:57 jason Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998, 2000 Jason L. Wright.
a50 1
	struct	ifmedia sc_ifmedia;
@


1.3.6.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: qevar.h,v 1.3.6.1 2001/05/14 21:37:09 niklas Exp $	*/
d15 2
@


1.3.10.1
log
@Pull in patches from current:
Errata (003):
Configuring a qec+qe causes a NMI panic.
Fix (jason):
- Fix the NMI problem: it seems the qec channel reset also resets the MACE, and
a race condition existed where after a qec channel reset, accesses to the
MACE would cause an NMI: so wait for the MACE to come out of reset before
accessing.

- add ifmedia support (mainly so I can get at the link status from other code)
- move some of the spl handling around (more correct)
- rewrite qe_mcreset() again so that all it does is set the multicast filter
- use bzero to initialize the buffers and descriptors
- rearrange the MACE setup to conform to the suggestions in the datasheet
----------------------------
wait for the MACE to figure out whether it has media or not, and then
clear interrupt status and such before enabling rx and tx.
----------------------------
- remove other media types, the MACE isn't as bright as one would hope
- always set it to autoselect, tp
- remove the wait for media stuff: appears to be a local issue on
- simplify the ifmedia callbacks appropriately
----------------------------
seems the qe/mace combination needs a delay between accesses to the
two chips.  Better fix for the NMI problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: qevar.h,v 1.4 2000/11/16 15:47:57 jason Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998, 2000 Jason L. Wright.
a50 1
	struct	ifmedia sc_ifmedia;
@


1.3.8.1
log
@Pull in patches from current:
Fix (jason):
- Fix the NMI problem: it seems the qec channel reset also resets the MACE, and
a race condition existed where after a qec channel reset, accesses to the
MACE would cause an NMI: so wait for the MACE to come out of reset before
accessing.

- add ifmedia support (mainly so I can get at the link status from other code)
- move some of the spl handling around (more correct)
- rewrite qe_mcreset() again so that all it does is set the multicast filter
- use bzero to initialize the buffers and descriptors
- rearrange the MACE setup to conform to the suggestions in the datasheet
----------------------------
wait for the MACE to figure out whether it has media or not, and then
clear interrupt status and such before enabling rx and tx.
----------------------------
- remove other media types, the MACE isn't as bright as one would hope
- always set it to autoselect, tp
- remove the wait for media stuff: appears to be a local issue on
- simplify the ifmedia callbacks appropriately
----------------------------
seems the qe/mace combination needs a delay between accesses to the
two chips.  Better fix for the NMI problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: qevar.h,v 1.4 2000/11/16 15:47:57 jason Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998, 2000 Jason L. Wright.
a50 1
	struct	ifmedia sc_ifmedia;
@


1.2
log
@First step at unifying qe & be drivers:
o qe & be drivers now only access qec globals directly at interrupt time
o more initialization done in qec_reset
o qe & be drivers handle the qec internal buffer identically
o nuked unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: qevar.h,v 1.1 1998/10/19 05:41:21 jason Exp $	*/
a43 1
	int	sc_promisc;
@


1.1
log
@Support for the qec+qe (SBus QuadEthernet board)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a40 2
	void	*sc_mem;
	int	sc_memsize;
@

