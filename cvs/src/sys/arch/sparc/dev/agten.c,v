head	1.14;
access;
symbols
	OPENBSD_6_0:1.14.0.6
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.6
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.20
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.18
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.16
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.14
	OPENBSD_5_0:1.12.0.12
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.10
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.8
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.4
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.4
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	UBC:1.2.0.6
	UBC_SYNC_A:1.2
	SMP:1.2.0.4
	OPENBSD_3_3:1.2.0.2
	OPENBSD_3_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.14
date	2015.03.28.19.07.07;	author miod;	state Exp;
branches;
next	1.13;
commitid	nwbHy4sQv9NnJnmZ;

1.13
date	2013.10.20.20.07.25;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2008.12.26.22.30.21;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2008.12.25.23.56.29;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.02.20.00.54;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.23.17.16.34;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.07.16.44.50;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.05.23.04.24;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.11.29.22.07.36;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.28.17.05.33;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.24.21.55.05;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.06.19.42.47;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.06.22.17.49;	author miod;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2003.03.06.21.48.28;	author miod;	state Exp;
branches;
next	;

1.2.4.1
date	2003.06.07.11.14.42;	author ho;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2004.02.19.10.49.57;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Don't include sbusvar.h if you need neither sbus_translate() nor sbus_testdma().
@
text
@/*	$OpenBSD: agten.c,v 1.13 2013/10/20 20:07:25 miod Exp $	*/
/*
 * Copyright (c) 2002, 2003, Miodrag Vallat.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 * Fujitsu AG-10 framebuffer driver.
 *
 * The AG-10 is mostly made of:
 * - a 3DLabs 300SX Glint chip, with two 6MB independent framebuffer spaces
 * - a Number Nine Imagine 128 chip with its own 4MB framebuffer space
 * - a Weitek P9100 with its own 2MB of framebuffer memory
 * - an IBM PaletteDAC 561 ramdac
 * - an Analog Devices ADSP-21062
 *
 * All of these chips (memory, registers, etc) are mapped in the SBus
 * memory space associated to the board. What is unexpected, however, is
 * that there are also PCI registers mappings for the first three chips!
 *
 * The three graphics chips act as overlays of each other, for the final
 * video output.
 *
 * The PROM initialization will use the I128 framebuffer memory for output,
 * which is ``above'' the P9100. The P9100 seems to only be there to provide
 * a simple RAMDAC interface, but its frame buffer memory is accessible and
 * will appear as an ``underlay'' plane.
 */

/*
 * TODO
 * - initialize the I128 in 32bit mode
 * - use the i128 acceleration features
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/mman.h>
#include <sys/tty.h>
#include <sys/conf.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/pmap.h>
#include <machine/cpu.h>
#include <machine/conf.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

#include <dev/ic/p9000.h>
#include <dev/ic/ibm561reg.h>

struct agten_cmap {
	u_int8_t	cm_red[256];
	u_int8_t	cm_green[256];
	u_int8_t	cm_blue[256];
};

/* per-display variables */
struct agten_softc {
	struct	sunfb sc_sunfb;			/* common base part */

	struct	rom_reg sc_phys;		/* physical address and */
	off_t	sc_physoffset;			/* offset for frame buffer */

	volatile u_int8_t *sc_p9100;
	struct agten_cmap sc_cmap;		/* shadow color map */

	volatile u_int32_t *sc_i128_fb;
};

int	agten_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	agten_mmap(void *, off_t, int);
void	agten_reset(struct agten_softc *);
void	agten_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);

static __inline__
void	ibm561_write(struct agten_softc *, u_int32_t, u_int32_t);
int	agten_getcmap(struct agten_cmap *, struct wsdisplay_cmap *);
int	agten_putcmap(struct agten_cmap *, struct wsdisplay_cmap *);
void	agten_loadcmap(struct agten_softc *, u_int, u_int);

struct wsdisplay_accessops agten_accessops = {
	.ioctl = agten_ioctl,
	.mmap = agten_mmap
};

int	agtenmatch(struct device *, void *, void *);
void	agtenattach(struct device *, struct device *, void *);

struct cfattach agten_ca = {
	sizeof(struct agten_softc), agtenmatch, agtenattach
};

struct cfdriver agten_cd = {
	NULL, "agten", DV_DULL
};

int
agtenmatch(struct device *parent, void *vcf, void *aux)
{
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

	if (strcmp(ra->ra_name, "PFU,aga") != 0)
		return (0);

	return (1);
}

void
agtenattach(struct device *parent, struct device *self, void *args)
{
	struct agten_softc *sc = (struct agten_softc *)self;
	struct confargs *ca = args;
	int node, isconsole;
	char *nam;

	node = ca->ca_ra.ra_node;
	nam = getpropstring(node, "model");
	printf(": model %s", nam);

	isconsole = node == fbnode;

	sc->sc_phys = ca->ca_ra.ra_reg[0];

	/*
	 * Map the various beasts of this card we are interested in.
	 */

	sc->sc_physoffset =
	    (off_t)getpropint(node, "i128_fb_physaddr", 0x8000000);
	sc->sc_i128_fb = mapiodev(ca->ca_ra.ra_reg, sc->sc_physoffset,
	    getpropint(node, "i128_fb_size", 0x400000));
	sc->sc_p9100 = mapiodev(ca->ca_ra.ra_reg,
	    getpropint(node, "p9100_reg_physaddr", 0x10a0000),
	    0x4000);

	/*
	 * For some reason the agten does not use the canonical name for
	 * properties, but uses an ffb_ prefix; and the linebytes property is
	 * missing.
	 * The following is a specific version of
	 *   fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, BUS_SBUS);
	 * using the correct property names.
	 */
#ifdef notyet
	sc->sc_sunfb.sf_depth = 32;
#else
	sc->sc_sunfb.sf_depth = getpropint(node, "ffb_depth", 8);
#endif
	sc->sc_sunfb.sf_width = getpropint(node, "ffb_width", 1152);
	sc->sc_sunfb.sf_height = getpropint(node, "ffb_height", 900);
	sc->sc_sunfb.sf_linebytes =
	    roundup(sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_depth) *
	        sc->sc_sunfb.sf_depth / 8;
	sc->sc_sunfb.sf_fbsize =
	    sc->sc_sunfb.sf_height * sc->sc_sunfb.sf_linebytes;

	printf(", %dx%d, depth %d\n",
	    sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height,
	    sc->sc_sunfb.sf_depth);

	sc->sc_sunfb.sf_ro.ri_bits = (void *)sc->sc_i128_fb;
	
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, isconsole);
	fbwscons_setcolormap(&sc->sc_sunfb, agten_setcolor);

	if (isconsole)
		fbwscons_console_init(&sc->sc_sunfb, -1);

	fbwscons_attach(&sc->sc_sunfb, &agten_accessops, isconsole);
}

int
agten_ioctl(void *dev, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct agten_softc *sc = dev;
	struct wsdisplay_cmap *cm;
	struct wsdisplay_fbinfo *wdf;
	int error;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_AGTEN;
		break;
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width = sc->sc_sunfb.sf_width;
		wdf->depth = sc->sc_sunfb.sf_depth;
		wdf->cmsize = (sc->sc_sunfb.sf_depth == 8) ? 256 : 0;
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
		break;

	case WSDISPLAYIO_GETCMAP:
		if (sc->sc_sunfb.sf_depth == 8) {
			cm = (struct wsdisplay_cmap *)data;
			error = agten_getcmap(&sc->sc_cmap, cm);
			if (error)
				return (error);
		}
		break;
	case WSDISPLAYIO_PUTCMAP:
		if (sc->sc_sunfb.sf_depth == 8) {
			cm = (struct wsdisplay_cmap *)data;
			error = agten_putcmap(&sc->sc_cmap, cm);
			if (error)
				return (error);
			agten_loadcmap(sc, 0, 256);
		}
		break;

	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
		break;

	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
	default:
		return (-1);	/* not supported yet */
	}

	return (0);
}

paddr_t
agten_mmap(void *v, off_t offset, int prot)
{
	struct agten_softc *sc = v;

	if (offset & PGOFSET)
		return (-1);

	/* Allow mapping as a dumb framebuffer from offset 0 */
	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys, sc->sc_physoffset + offset) |
		    PMAP_NC);
	}

	return (-1);
}

void
agten_setcolor(void *v, u_int index, u_int8_t r, u_int8_t g, u_int8_t b)
{
	struct agten_softc *sc = v;

	sc->sc_cmap.cm_red[index] = r;
	sc->sc_cmap.cm_green[index] = g;
	sc->sc_cmap.cm_blue[index] = b;

	agten_loadcmap(sc, index, 1);
}

int
agten_getcmap(struct agten_cmap *cm, struct wsdisplay_cmap *rcm)
{
	u_int index = rcm->index, count = rcm->count;
	int error;

	if (index >= 256 || count > 256 - index)
		return (EINVAL);

	if ((error = copyout(&cm->cm_red[index], rcm->red, count)) != 0)
		return (error);
	if ((error = copyout(&cm->cm_green[index], rcm->green, count)) != 0)
		return (error);
	if ((error = copyout(&cm->cm_blue[index], rcm->blue, count)) != 0)
		return (error);

	return (0);
}

int
agten_putcmap(struct agten_cmap *cm, struct wsdisplay_cmap *rcm)
{
	u_int index = rcm->index, count = rcm->count;
	int error;

	if (index >= 256 || count > 256 - index)
		return (EINVAL);

	if ((error = copyin(rcm->red, &cm->cm_red[index], count)) != 0)
		return (error);
	if ((error = copyin(rcm->green, &cm->cm_green[index], count)) != 0)
		return (error);
	if ((error = copyin(rcm->blue, &cm->cm_blue[index], count)) != 0)
		return (error);

	return (0);
}

static __inline__ void
ibm561_write(struct agten_softc *sc, u_int32_t reg, u_int32_t value)
{
	/*
	 * For some design reason the IBM561 PaletteDac needs to be fed
	 * values shifted left by 16 bits. What happened to simplicity?
	 */
	*(volatile u_int32_t *)(sc->sc_p9100 + P9100_RAMDAC_REGISTER(reg)) =
	    (value) << 16;
}

void
agten_loadcmap(struct agten_softc *sc, u_int start, u_int ncolors)
{
	int i;
	u_int8_t *red, *green, *blue;

	ibm561_write(sc, IBM561_ADDR_LOW,
	    (IBM561_CMAP_TABLE + start) & 0xff);
	ibm561_write(sc, IBM561_ADDR_HIGH,
	    ((IBM561_CMAP_TABLE + start) >> 8) & 0xff);

	red = sc->sc_cmap.cm_red;
	green = sc->sc_cmap.cm_green;
	blue = sc->sc_cmap.cm_blue;
	for (i = start; i < start + ncolors; i++) {
		ibm561_write(sc, IBM561_CMD_CMAP, *red++);
		ibm561_write(sc, IBM561_CMD_CMAP, *green++);
		ibm561_write(sc, IBM561_CMD_CMAP, *blue++);
	}
}
@


1.13
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: agten.c,v 1.12 2008/12/26 22:30:21 miod Exp $	*/
a81 2

#include <sparc/dev/sbusvar.h>
@


1.12
log
@Move the logic responsible from deciding whether a frame buffer needs to be
cleared on attach, from the individual drivers to the common frame buffer code;
the latter will decide based on the prom font metrics and the prom console
window position, whenever possible.

This removes the need for the console window position to be hardcoded in
the p9100 driver, and will no longer require a screen clear on a vigra
VS-12 in high resolution mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: agten.c,v 1.11 2008/12/25 23:56:29 miod Exp $	*/
d116 2
a117 10
	agten_ioctl,
	agten_mmap,
	NULL,	/* alloc_screen */
	NULL,	/* free_screen */
	NULL,	/* show_screen */
	NULL,   /* load_font */
	NULL,   /* scrollback */
	NULL,   /* getchar */
	NULL,	/* burner */
	NULL	/* pollc */
@


1.11
log
@Return proper display types to the WSDISPLAYIO_GTYPE ioctl, instead of
deprecated WSDISPLAY_TYPE_SUN24; X11 knows about them since several releases
already.
@
text
@d1 1
a1 1
/*	$OpenBSD: agten.c,v 1.10 2006/06/02 20:00:54 miod Exp $	*/
d207 1
a207 1
	fbwscons_init(&sc->sc_sunfb, isconsole ? 0 : RI_CLEAR);
d210 1
a210 1
	if (isconsole) {
a211 1
	}
@


1.10
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: agten.c,v 1.9 2005/03/23 17:16:34 miod Exp $	*/
d227 1
a227 1
		*(u_int *)data = WSDISPLAY_TYPE_SUN24;
@


1.9
log
@Move the alloc_screen, free_screen and show_screen wsdisplay accessops to
the common frame buffer code, rather than duplicating it in every driver.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: agten.c,v 1.8 2005/03/07 16:44:50 miod Exp $	*/
a93 1
	struct	sbusdev sc_sd;			/* sbus device */
a212 2

	sbus_establish(&sc->sc_sd, &sc->sc_sunfb.sf_dev);
@


1.8
log
@Do not bother passing the blanking routine to fbwscons_console_init(),
as fbwscons_attach() can find it on its own.
@
text
@d1 1
a1 1
/*	$OpenBSD: agten.c,v 1.7 2005/01/05 23:04:24 miod Exp $	*/
a76 1
#include <dev/wscons/wscons_raster.h>
a102 2

	int	sc_nscreens;
d105 10
a114 14
int agten_ioctl(void *, u_long, caddr_t, int, struct proc *);
int agten_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void agten_free_screen(void *, void *);
int agten_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t agten_mmap(void *, off_t, int);
void agten_reset(struct agten_softc *);
void agten_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);

static __inline__ void ibm561_write(struct agten_softc *, u_int32_t, u_int32_t);
int agten_getcmap(struct agten_cmap *, struct wsdisplay_cmap *);
int agten_putcmap(struct agten_cmap *, struct wsdisplay_cmap *);
void agten_loadcmap(struct agten_softc *, u_int, u_int);
d119 3
a121 3
	agten_alloc_screen,
	agten_free_screen,
	agten_show_screen,
d126 1
d129 2
a130 2
int agtenmatch(struct device *, void *, void *);
void agtenattach(struct device *, struct device *, void *);
d221 1
a221 6
agten_ioctl(dev, cmd, data, flags, p)
	void *dev;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
a276 4
/*
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
 */
d278 1
a278 4
agten_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
d291 1
a291 1
	return (-1);	/* not a user-map offset */
d295 1
a295 4
agten_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
	u_int8_t r, g, b;
a303 48
}

int
agten_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
{
	struct agten_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	if (sc->sc_sunfb.sf_depth == 8) {
		sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
		    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	} else {
		sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
		    0, 0, 0, attrp);
	}
	sc->sc_nscreens++;
	return (0);
}

void
agten_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct agten_softc *sc = v;

	sc->sc_nscreens--;
}

int
agten_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
	return (0);
@


1.7
log
@Let wsdisplay drivers return zero for WSDISPLAYIO_[GS]VIDEO ioctls - most
of the work is done in the upper layer, but they get to see the ioctl,
so don't always return an error.
@
text
@d1 1
a1 1
/*	$OpenBSD: agten.c,v 1.6 2004/11/29 22:07:36 miod Exp $	*/
d218 1
a218 1
		fbwscons_console_init(&sc->sc_sunfb, -1, NULL);
@


1.6
log
@Move the struct wsscreen_descr from a per-driver global to a per-instance
field of the sunfb structure. This allows multiple instances of the same driver,
but with different resolutions (such as a couple of vigra or a TGX cgsix and
a TGX+ cgsix) to use distinct wsscreen_descr structures featuring different
resolution information.

Doing this allows more wsscreen_descr fiddling inside the sparc* fb api,
and results in some code shrinkage (about 4KB on sparc GENERIC).
@
text
@d1 1
a1 1
/*	$OpenBSD: agten.c,v 1.5 2003/06/28 17:05:33 miod Exp $	*/
d274 2
@


1.5
log
@Sync sparc fb API with the sparc64 changes (fbwscons_init takes flags, and
the sunfb structure keeps pointer to the prom cursor coordinates).
@
text
@d1 1
a1 1
/*	$OpenBSD: agten.c,v 1.4 2003/06/24 21:55:05 miod Exp $	*/
a107 12
struct wsscreen_descr agten_stdscreen = {
	"std",
};

const struct wsscreen_descr *agten_scrlist[] = {
	&agten_stdscreen,
};

struct wsscreen_list agten_screenlist = {
	sizeof(agten_scrlist) / sizeof(struct wsscreen_descr *), agten_scrlist
};

a162 1
	struct wsemuldisplaydev_attach_args waa;
a216 5
	agten_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	agten_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	agten_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	agten_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

d218 1
a218 2
		fbwscons_console_init(&sc->sc_sunfb, &agten_stdscreen, -1,
		    NULL);
d223 1
a223 5
	waa.console = isconsole;
	waa.scrdata = &agten_screenlist;
	waa.accessops = &agten_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
@


1.4
log
@Use the common Power9000 definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: agten.c,v 1.3 2003/06/06 19:42:47 miod Exp $	*/
d227 1
a227 1
	fbwscons_init(&sc->sc_sunfb, isconsole);
@


1.3
log
@Do not bother taking care of the frame buffer flags in the softc, if the
driver does not use any. Basically this changes all drivers but those that
can handle a P4 card.
@
text
@d1 1
a1 1
/*	$OpenBSD: agten.c,v 1.2 2003/03/06 22:17:49 miod Exp $	*/
d81 1
d100 1
a100 1
	volatile u_int32_t *sc_dac;
d195 3
a197 3
	sc->sc_dac = mapiodev(ca->ca_ra.ra_reg,
	    getpropint(node, "p9100_reg_physaddr", 0x10a0000) + 0x200,
	    0x800 - 0x200);
d441 2
a442 1
	sc->sc_dac[reg] = (value) << 16;
@


1.2
log
@Improve comments, including type fixes; lebel@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agten.c,v 1.1 2003/03/06 21:48:28 miod Exp $	*/
a159 1
	struct cfdata *cf = vcf;
a162 5
	/*
	 * Mask out invalid flags from the user.
	 */
	cf->cf_flags &= FB_USERMASK;

a176 2

	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;
@


1.2.4.1
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: agten.c,v 1.2 2003/03/06 22:17:49 miod Exp $	*/
d160 1
d164 5
d183 2
@


1.2.4.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a80 1
#include <dev/ic/p9000.h>
d99 1
a99 1
	volatile u_int8_t *sc_p9100;
d194 3
a196 3
	sc->sc_p9100 = mapiodev(ca->ca_ra.ra_reg,
	    getpropint(node, "p9100_reg_physaddr", 0x10a0000),
	    0x4000);
d226 1
a226 1
	fbwscons_init(&sc->sc_sunfb, isconsole ? 0 : RI_CLEAR);
d440 1
a440 2
	*(volatile u_int32_t *)(sc->sc_p9100 + P9100_RAMDAC_REGISTER(reg)) =
	    (value) << 16;
@


1.1
log
@Premiliminary driver for the Fujitsu AG-10e SBus frame buffer.
It will currently only work in 8bit mode, and without using the i128
acceleration features (but that's a good start for 3.3).

Written initially in november 2002, but it took some time in experiments
until I realized the ramdac had to be fed values shifted left by 16 bits in
order to work as intended, for no good reason.

So, I am now officially founding a ``RAMDAC Hater's Club''. Feel free to
apply.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d33 1
a33 1
 * - a 3DLabs 300SX Glint chip, with two 6MB independant framebuffer spaces
d95 3
a97 2
	struct	rom_reg sc_phys;		/* phys addr of h/w */
	off_t	sc_physoffset;
d195 1
a195 1
	 * Map the various beasts of this card.
@

