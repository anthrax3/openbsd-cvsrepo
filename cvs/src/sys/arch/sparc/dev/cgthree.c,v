head	1.37;
access;
symbols
	OPENBSD_6_0:1.37.0.6
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.37.0.4
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.36.0.6
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.36.0.4
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.35.0.20
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.35.0.18
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.16
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.14
	OPENBSD_5_0:1.35.0.12
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.10
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.8
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.35.0.4
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.35.0.6
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.35.0.2
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.33.0.8
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.6
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.33.0.4
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.33.0.2
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.31.0.2
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.29.0.4
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.29.0.2
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.24.0.6
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.24.0.4
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.17
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.10
	OPENBSD_2_8:1.9.0.8
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.6
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.4
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2015.03.28.19.07.07;	author miod;	state Exp;
branches;
next	1.36;
commitid	nwbHy4sQv9NnJnmZ;

1.36
date	2013.10.20.20.07.25;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2008.12.26.22.30.21;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2008.12.26.15.35.06;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2007.02.18.18.40.35;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2006.12.03.16.38.13;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2006.07.25.21.23.30;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2006.06.02.20.00.54;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2005.03.23.17.16.34;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.07.16.44.50;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2005.01.05.23.04.24;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2004.11.29.22.07.36;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2004.09.29.07.35.11;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.08.01.19.24.49;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.28.17.05.33;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.06.19.42.47;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.02.23.27.54;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.02.18.40.59;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.28.21.40.40;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2002.11.06.21.06.20;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2002.09.23.18.13.38;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.09.22.15.16;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.12.10.44.03;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.09.23.33.15;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.42;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.11.01.12.13.46;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.17.13.52.28;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	99.09.10.23.32.02;	author art;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	98.11.20.15.57.22;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.09.01.03.56.45;	author todd;	state Exp;
branches;
next	1.6;

1.6
date	97.08.08.08.24.53;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.08.11.05.34.11;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.12.15.13.56.18;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.10.22.11.29.56;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.19.13.15.47;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.38;	author deraadt;	state Exp;
branches;
next	;

1.9.4.1
date	2001.10.31.03.07.56;	author nate;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.9.4.3;

1.9.4.3
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.9.4.4;

1.9.4.4
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.9.4.5;

1.9.4.5
date	2003.05.13.19.41.08;	author ho;	state Exp;
branches;
next	1.9.4.6;

1.9.4.6
date	2003.06.07.11.14.42;	author ho;	state Exp;
branches;
next	1.9.4.7;

1.9.4.7
date	2004.02.19.10.49.57;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2002.06.11.03.38.15;	author art;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.10.29.00.28.09;	author art;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Don't include sbusvar.h if you need neither sbus_translate() nor sbus_testdma().
@
text
@/*	$OpenBSD: cgthree.c,v 1.36 2013/10/20 20:07:25 miod Exp $	*/
/*	$NetBSD: cgthree.c,v 1.33 1997/05/24 20:16:11 pk Exp $ */

/*
 * Copyright (c) 2002 Miodrag Vallat.  All rights reserved.
 * Copyright (c) 2001 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 *
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)cgthree.c	8.2 (Berkeley) 10/30/93
 */

/*
 * Color display (cgthree) driver.
 * Works with the real Sun hardware, as well as various clones from Tatung,
 * Integrix (S20), and the Vigra VS10-EK.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/pmap.h>
#include <machine/cpu.h>
#include <machine/conf.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

#include <sparc/dev/btreg.h>
#include <sparc/dev/btvar.h>
#include <sparc/dev/cgthreereg.h>

/* per-display variables */
struct cgthree_softc {
	struct	sunfb sc_sunfb;		/* common base part */
	struct rom_reg	sc_phys;	/* phys address description */
	volatile struct fbcontrol *sc_fbc;	/* Brooktree registers */
	union	bt_cmap sc_cmap;	/* Brooktree color map */
	struct intrhand sc_ih;
};

void	cgthree_burner(void *, u_int, u_int);
int	cgthree_intr(void *);
int	cgthree_ioctl(void *, u_long, caddr_t, int, struct proc *);
static __inline__
void	cgthree_loadcmap_deferred(struct cgthree_softc *, u_int, u_int);
paddr_t	cgthree_mmap(void *, off_t, int);
void	cgthree_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);

struct wsdisplay_accessops cgthree_accessops = {
	.ioctl = cgthree_ioctl,
	.mmap = cgthree_mmap,
	.burn_screen = cgthree_burner
};

int	cgthreematch(struct device *, void *, void *);
void	cgthreeattach(struct device *, struct device *, void *);

struct cfattach cgthree_ca = {
	sizeof (struct cgthree_softc), cgthreematch, cgthreeattach
};

struct cfdriver cgthree_cd = {
	NULL, "cgthree", DV_DULL
};

/* Video control parameters */
struct cg3_videoctrl {
	u_int8_t	sense;
	u_int8_t	vctrl[12];
} cg3_videoctrl[] = {
	{	/* cpd-1790 */
		FBS_1152X900 | FBS_ID_COLOR,
		{ 0xbb, 0x2b, 0x04, 0x14, 0xae, 0x03,
		  0xa8, 0x24, 0x01, 0x05, 0xff, 0x01 },
	},
	{	/* gdm-20e20 */
		FBS_1280X1024 | FBS_ID_COLOR,
		{ 0xb7, 0x27, 0x03, 0x0f, 0xae, 0x03,
		  0xae, 0x2a, 0x01, 0x09, 0xff, 0x01 },
	},
	{	/* defaults, should be last */
		0xff,
		{ 0xbb, 0x2b, 0x03, 0x0b, 0xb3, 0x03,
		  0xaf, 0x2b, 0x02, 0x0a, 0xff, 0x01 },
	},
};

int
cgthreematch(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

	if (strcmp(cf->cf_driver->cd_name, ra->ra_name) &&
	    strcmp("cgRDI", ra->ra_name))
		return (0);

	if (ca->ca_bustype != BUS_SBUS)
		return (0);

	return (1);
}

void
cgthreeattach(struct device *parent, struct device *self, void *args)
{
	struct cgthree_softc *sc = (struct cgthree_softc *)self;
	struct confargs *ca = args;
	int node, pri, isrdi = 0, i;
	volatile struct bt_regs *bt;
	int isconsole;
	char *nam;

	pri = ca->ca_ra.ra_intr[0].int_pri;
	printf(" pri %d: ", pri);

	node = ca->ca_ra.ra_node;

	if (strcmp(ca->ca_ra.ra_name, "cgRDI") == 0) {
		isrdi = 1;
		nam = "cgRDI";
	} else
		nam = getpropstring(node, "model");

	if (nam != NULL && *nam != '\0')
		printf("%s, ", nam);

	isconsole = node == fbnode;

	sc->sc_fbc = (volatile struct fbcontrol *)
	    mapiodev(ca->ca_ra.ra_reg, CG3REG_REG,
		     sizeof(struct fbcontrol));

	/* Transfer video magic to board, if it's not running */
	if (isrdi == 0 && (sc->sc_fbc->fbc_ctrl & FBC_TIMING) == 0)
		for (i = 0; i < nitems(cg3_videoctrl); i++) {
			volatile struct fbcontrol *fbc = sc->sc_fbc;
			if (cg3_videoctrl[i].sense == 0xff ||
			    (fbc->fbc_status & FBS_MSENSE) ==
			     cg3_videoctrl[i].sense) {
				int j;
#ifdef DEBUG
				printf(" (setting video ctrl)");
#endif
				for (j = 0; j < 12; j++)
					fbc->fbc_vcontrol[j] =
						cg3_videoctrl[i].vctrl[j];
				fbc->fbc_ctrl |= FBC_TIMING;
				break;
			}
		}

	sc->sc_phys = ca->ca_ra.ra_reg[0];

	sc->sc_ih.ih_fun = cgthree_intr;
	sc->sc_ih.ih_arg = sc;
	intr_establish(pri, &sc->sc_ih, IPL_FB, self->dv_xname);

	/* enable video */
	cgthree_burner(sc, 1, 0);
	bt = &sc->sc_fbc->fbc_dac;
	BT_INIT(bt, 0);

	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, ca->ca_bustype);
	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(ca->ca_ra.ra_reg, CG3REG_MEM,
	    round_page(sc->sc_sunfb.sf_fbsize));
	sc->sc_sunfb.sf_ro.ri_hw = sc;

	printf("%dx%d\n", sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);

	fbwscons_init(&sc->sc_sunfb, isconsole);
	fbwscons_setcolormap(&sc->sc_sunfb, cgthree_setcolor);

	if (isconsole)
		fbwscons_console_init(&sc->sc_sunfb, -1);

	fbwscons_attach(&sc->sc_sunfb, &cgthree_accessops, isconsole);
}

int
cgthree_ioctl(void *v, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct cgthree_softc *sc = v;
	struct wsdisplay_fbinfo *wdf;
	struct wsdisplay_cmap *cm;
	int error;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG3;
		break;
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
		wdf->cmsize = 256;
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
		break;

	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_getcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		break;

	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		cgthree_loadcmap_deferred(sc, cm->index, cm->count);
		break;

	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
		break;

	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
	default:
		return (-1);	/* not supported yet */
        }

	return (0);
}

paddr_t
cgthree_mmap(void *v, off_t offset, int prot)
{
	struct cgthree_softc *sc = v;

	if (offset & PGOFSET)
		return (-1);

	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys,
		    CG3REG_MEM + offset) | PMAP_NC);
	}

	return (-1);
}

void
cgthree_setcolor(void *v, u_int index, u_int8_t r, u_int8_t g, u_int8_t b)
{
	struct cgthree_softc *sc = v;

	bt_setcolor(&sc->sc_cmap, &sc->sc_fbc->fbc_dac, index, r, g, b, 0);
}

static __inline__ void
cgthree_loadcmap_deferred(struct cgthree_softc *sc, u_int start, u_int ncolors)
{

	sc->sc_fbc->fbc_ctrl |= FBC_IENAB;
}

void
cgthree_burner(void *v, u_int on, u_int flags)
{
	struct cgthree_softc *sc = v;
	int s;

	s = splhigh();
	if (on)
		sc->sc_fbc->fbc_ctrl |= FBC_VENAB | FBC_TIMING;
	else {
		sc->sc_fbc->fbc_ctrl &= ~FBC_VENAB;
		if (flags & WSDISPLAY_BURN_VBLANK)
			sc->sc_fbc->fbc_ctrl &= ~FBC_TIMING;
	}
	splx(s);
}

int
cgthree_intr(void *v)
{
	struct cgthree_softc *sc = v;

	if (!ISSET(sc->sc_fbc->fbc_ctrl, FBC_IENAB) ||
	    !ISSET(sc->sc_fbc->fbc_status, FBS_INTR)) {
		/* Not expecting an interrupt, it's not for us. */
		return (0);
	}

	/* Acknowledge the interrupt and disable it. */
	sc->sc_fbc->fbc_ctrl &= ~FBC_IENAB;

	bt_loadcmap(&sc->sc_cmap, &sc->sc_fbc->fbc_dac, 0, 256, 0);
	return (1);
}
@


1.36
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.35 2008/12/26 22:30:21 miod Exp $	*/
a98 1
#include <sparc/dev/sbusvar.h>
@


1.35
log
@Move the logic responsible from deciding whether a frame buffer needs to be
cleared on attach, from the individual drivers to the common frame buffer code;
the latter will decide based on the prom font metrics and the prom console
window position, whenever possible.

This removes the need for the console window position to be hardcoded in
the p9100 driver, and will no longer require a screen clear on a vigra
VS-12 in high resolution mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.34 2008/12/26 15:35:06 miod Exp $	*/
d119 3
a121 10
	cgthree_ioctl,
	cgthree_mmap,
	NULL,	/* alloc_screen */
	NULL,	/* free_screen */
	NULL,	/* show_screen */
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	cgthree_burner,
	NULL	/* pollc */
@


1.34
log
@Use nitems() and FBS_xxx symbolic constants in the video timing tables.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.33 2007/02/18 18:40:35 miod Exp $	*/
d248 1
a248 14
	/*
	 * If the framebuffer width is under 1024x768, which is the case for
	 * some clones on laptops, as well as with the VS10-EK, switch from
	 * the PROM font to the more adequate 8x16 font here.
	 * However, we need to adjust two things in this case:
	 * - the display row should be overrided from the current PROM metrics,
	 *   to prevent us from overwriting the last few lines of text.
	 * - if the 80x34 screen would make a large margin appear around it,
	 *   choose to clear the screen rather than keeping old prom output in
	 *   the margins.
	 * XXX there should be a rasops "clear margins" feature
	 */
	fbwscons_init(&sc->sc_sunfb, isconsole &&
	    (sc->sc_sunfb.sf_width >= 1024) ? 0 : RI_CLEAR);
d251 2
a252 4
	if (isconsole) {
		fbwscons_console_init(&sc->sc_sunfb,
		    sc->sc_sunfb.sf_width >= 1024 ? -1 : 0);
	}
@


1.33
log
@Display the interrupt priority in dmesg, for frame buffers which register
interrupt handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.32 2006/12/03 16:38:13 miod Exp $	*/
a81 6
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/mman.h>
#include <sys/tty.h>
d148 1
a148 1
		0x31,
d153 1
a153 1
		0x41,
d213 1
a213 2
		for (i = 0; i < sizeof(cg3_videoctrl)/sizeof(cg3_videoctrl[0]);
		     i++) {
@


1.32
log
@Clean frame buffer attachment code:
- There is no need to check for buses config(8) will not let us attach to
- Better P4 bus logic, which does not need to abuse device flags
- Do not bother trying to print a meaningful device description when it is
  not connected to sbus.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.31 2006/07/25 21:23:30 miod Exp $	*/
d192 1
a192 1
	int node, isrdi = 0, i;
d194 1
a194 1
	int isconsole = 0;
d197 2
a198 1
	printf(": ");
d241 1
a241 2
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih, IPL_FB,
	    self->dv_xname);
@


1.31
log
@Do not bother reading the existing colormap on attach, since we will
override it with the rasops one.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.30 2006/06/02 20:00:54 miod Exp $	*/
d181 2
a182 2
	if (ca->ca_bustype == BUS_SBUS)
		return (1);
d184 1
a184 2
	ra->ra_len = NBPG;
	return (probeget(ra->ra_vaddr, 4) != -1);
d192 1
a192 1
	int node = 0, isrdi = 0, i;
d194 2
a195 2
	int isconsole = 0, sbus = 1;
	char *nam = NULL;
d197 1
a197 15
	switch (ca->ca_bustype) {
	case BUS_OBIO:
		if (CPU_ISSUN4M) {	/* 4m has framebuffer on obio */
			sbus = 0;
			node = ca->ca_ra.ra_node;
			nam = getpropstring(node, "model");
			if (*nam == '\0')
				nam = "cgthree";
			break;
		}
	case BUS_VME32:
	case BUS_VME16:
		sbus = node = 0;
		nam = "cgthree";
		break;
d199 1
a199 7
	case BUS_SBUS:
		node = ca->ca_ra.ra_node;
		nam = getpropstring(node, "model");
		if (*nam == '\0')
			nam = "cgthree";
		break;
	}
d201 1
a201 1
	if (!strcmp(ca->ca_ra.ra_name, "cgRDI")) {
d204 2
a205 1
	}
d207 2
a208 1
	printf(": %s", nam);
d253 1
a253 1
	printf(", %dx%d\n", sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);
@


1.30
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.29 2005/03/23 17:16:34 miod Exp $	*/
a261 6
	/* grab initial (current) color map */
	bt = &sc->sc_fbc->fbc_dac;
	bt->bt_addr = 0;
	for (i = 0; i < 256 * 3 / 4; i++)
		sc->sc_cmap.cm_chip[i] = bt->bt_cmap;

d264 1
@


1.29
log
@Move the alloc_screen, free_screen and show_screen wsdisplay accessops to
the common frame buffer code, rather than duplicating it in every driver.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.28 2005/03/07 16:44:50 miod Exp $	*/
a109 1
	struct	sbusdev sc_sd;		/* sbus device */
a298 5

#if defined(SUN4C) || defined(SUN4M)
	if (sbus)
		sbus_establish(&sc->sc_sd, &sc->sc_sunfb.sf_dev);
#endif
@


1.28
log
@Do not bother passing the blanking routine to fbwscons_console_init(),
as fbwscons_attach() can find it on its own.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.27 2005/01/05 23:04:24 miod Exp $	*/
a98 1
#include <dev/wscons/wscons_raster.h>
a114 1
	int	sc_nscreens;
d117 7
a123 12
int cgthree_ioctl(void *, u_long, caddr_t, int, struct proc *);
int cgthree_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgthree_free_screen(void *, void *);
int cgthree_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t cgthree_mmap(void *, off_t, int);
void cgthree_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
static __inline__ void cgthree_loadcmap_deferred(struct cgthree_softc *,
    u_int, u_int);
void cgthree_burner(void *, u_int, u_int);
int cgthree_intr(void *);
d128 3
a130 3
	cgthree_alloc_screen,
	cgthree_free_screen,
	cgthree_show_screen,
d135 1
a170 3
/*
 * Match a cgthree.
 */
d172 1
a172 3
cgthreematch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
a188 3
/*
 * Attach a display.
 */
d190 1
a190 3
cgthreeattach(parent, self, args)
	struct device *parent, *self;
	void *args;
d310 1
a310 6
cgthree_ioctl(v, cmd, data, flags, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
a362 47
int
cgthree_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
{
	struct cgthree_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	sc->sc_nscreens++;
	return (0);
}

void
cgthree_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct cgthree_softc *sc = v;

	sc->sc_nscreens--;
}

int
cgthree_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
	return (0);
}

/*
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
 */
d364 1
a364 4
cgthree_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
d380 1
a380 4
cgthree_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
	u_int8_t r, g, b;
d395 1
a395 3
cgthree_burner(v, on, flags)
	void *v;
	u_int on, flags;
d412 1
a412 2
cgthree_intr(v)
	void *v;
@


1.27
log
@Let wsdisplay drivers return zero for WSDISPLAYIO_[GS]VIDEO ioctls - most
of the work is done in the upper layer, but they get to see the ioctl,
so don't always return an error.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.26 2004/11/29 22:07:36 miod Exp $	*/
d314 1
a314 1
		    sc->sc_sunfb.sf_width >= 1024 ? -1 : 0, cgthree_burner);
@


1.26
log
@Move the struct wsscreen_descr from a per-driver global to a per-instance
field of the sunfb structure. This allows multiple instances of the same driver,
but with different resolutions (such as a couple of vigra or a TGX cgsix and
a TGX+ cgsix) to use distinct wsscreen_descr structures featuring different
resolution information.

Doing this allows more wsscreen_descr fiddling inside the sparc* fb api,
and results in some code shrinkage (about 4KB on sparc GENERIC).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.25 2004/09/29 07:35:11 miod Exp $	*/
d370 2
@


1.25
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.24 2003/08/01 19:24:49 miod Exp $	*/
a118 13
struct wsscreen_descr cgthree_stdscreen = {
	"std",
};

const struct wsscreen_descr *cgthree_scrlist[] = {
	&cgthree_stdscreen,
};

struct wsscreen_list cgthree_screenlist = {
	sizeof(cgthree_scrlist) / sizeof(struct wsscreen_descr *),
	    cgthree_scrlist
};

a209 1
	struct wsemuldisplaydev_attach_args waa;
a311 5
	cgthree_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgthree_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgthree_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgthree_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

d313 1
a313 1
		fbwscons_console_init(&sc->sc_sunfb, &cgthree_stdscreen,
d322 1
a322 5
	waa.console = isconsole;
	waa.scrdata = &cgthree_screenlist;
	waa.accessops = &cgthree_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
@


1.24
log
@The Vigra VS10-EK is recognized as a cgthree clone, but due to its utterly
ridiculous resolution, we need to plug the "clear the screen and switch font"
trick here too.

[Thanks to Andrey Smagin for providing a card for testing]
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.23 2003/06/28 17:05:33 miod Exp $	*/
d290 2
a291 1
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih, IPL_FB);
@


1.23
log
@Sync sparc fb API with the sparc64 changes (fbwscons_init takes flags, and
the sunfb structure keeps pointer to the prom cursor coordinates).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.22 2003/06/06 19:42:47 miod Exp $	*/
d75 3
a77 2
 * color display (cgthree) driver.
 *
d306 17
a322 1
	fbwscons_init(&sc->sc_sunfb, isconsole ? 0 : RI_CLEAR);
a329 2
	printf(", %dx%d\n", sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);

d331 2
a332 2
		fbwscons_console_init(&sc->sc_sunfb, &cgthree_stdscreen, -1,
		    cgthree_burner);
d334 1
@


1.22
log
@Do not bother taking care of the frame buffer flags in the softc, if the
driver does not use any. Basically this changes all drivers but those that
can handle a P4 card.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.21 2003/06/02 23:27:54 millert Exp $	*/
d305 1
a305 1
	fbwscons_init(&sc->sc_sunfb, isconsole);
@


1.21
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.20 2003/06/02 18:40:59 jason Exp $	*/
a200 5
	/*
	 * Mask out invalid flags from the user.
	 */
	cf->cf_flags &= FB_USERMASK;

a226 2

	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;
@


1.20
log
@nuke my clause 3 & 4 (and a couple jointly (c) with Theo).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.19 2003/04/28 21:40:40 jason Exp $	*/
d55 1
a55 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.19
log
@use the new display types
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.18 2002/11/06 21:06:20 miod Exp $	*/
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.18
log
@- always initialize colormaps, even if the frame buffer is non console; this
  helps if the ramdac does not get initialized (idea from jason@@)
- only register a shutdown hook for the frame buffers which need it, if this
  is the console frame buffer. Otherwise this is just a waste of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.17 2002/09/23 18:13:38 miod Exp $	*/
d362 1
a362 1
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
@


1.17
log
@Get the wsdisplay capabilities from rasops, rather than attempting to
guess them at compile-time. Plus this makes cgtwelve a bit more clean.

ok fgs@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.16 2002/09/09 22:15:16 miod Exp $	*/
d322 1
d333 1
a333 1
		    cgthree_setcolor, cgthree_burner);
@


1.16
log
@Register more screen capabilities to work with the recent wsemul_sun changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.15 2002/08/12 10:44:03 miod Exp $	*/
a128 5
	0, 0,	/* will be filled in */
	0,
	0, 0,
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
	WSSCREEN_REVERSE | WSSCREEN_WSCOLORS
d323 1
@


1.15
log
@Convert sparc console code from rcons and pseudo-devices to rasops and wscons.
For most framebuffers it is faster.

Other changes include:
o 24 bit support in tcx(4) for the S24 framebuffer
o accelerated cgsix(4) text console
o new cgtwelve(4) driver for the GS framebuffer
o improved serial driver code
o better keyboard support

The following framebuffers have not been tested but should work: cgfour,
cgeight and cgfourteen

These changes will require XF4 changes, to use Xwsfb instead of Xsun*, to be
commited later today.

Most of the work by me during the LSM and the week after, with code borrowed
from jason@@, NetBSD (new serial code), and feedback from mickey@@. Work on
pnozz(4) done by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.13 2002/03/14 01:26:42 millert Exp $	*/
d132 1
@


1.14
log
@try to disable vsync timing if sparc_vsyncblank is set
@
text
@d5 35
a85 3
 * Does not handle interrupts, even though they can occur.
 *
 * XXX should defer colormap updates to vertical retrace interrupts
a99 1
#include <machine/fbio.h>
a101 1
#include <machine/fbvar.h>
d105 6
d118 1
a118 1
	struct	device sc_dev;		/* base device */
a119 1
	struct	fbdevice sc_fb;		/* frame buffer device */
a121 2
	int	sc_bustype;		/* type of bus we live on */
	int	sc_isrdi;		/* is an RDI */
d123 2
d127 7
a133 4
/* autoconfiguration driver */
static void	cgthreeattach(struct device *, struct device *, void *);
static int	cgthreematch(struct device *, void *, void *);
static void	cgthreeunblank(struct device *);
d135 2
a136 2
struct cfattach cgthree_ca = {
	sizeof(struct cgthree_softc), cgthreematch, cgthreeattach
d139 3
a141 2
struct cfdriver cgthree_cd = {
	NULL, "cgthree", DV_DULL
d144 23
a166 3
/* frame buffer generic driver */
static struct fbdriver cgthreefbdriver = {
	cgthreeunblank, cgthreeopen, cgthreeclose, cgthreeioctl, cgthreemmap
d169 6
a174 2
extern int fbnode;
extern struct tty *fbconstty;
d176 3
a178 3
static void cgthreeloadcmap(struct cgthree_softc *, int, int);
static void cgthree_set_video(struct cgthree_softc *, int);
static int cgthree_get_video(struct cgthree_softc *);
d182 2
a183 2
	unsigned char	sense;		/* Monitor sense value */
	unsigned char	vctrl[12];
d185 14
a198 3
/* Missing entries: sense 0x10, 0x30, 0x50 */
	{ 0x40, /* this happens to be my 19'' 1152x900 gray-scale monitor */
	   {0xbb, 0x2b, 0x3, 0xb, 0xb3, 0x3, 0xaf, 0x2b, 0x2, 0xa, 0xff, 0x1}
a199 3
	{ 0x00, /* default? must be last */
	   {0xbb, 0x2b, 0x3, 0xb, 0xb3, 0x3, 0xaf, 0x2b, 0x2, 0xa, 0xff, 0x1}
	}
d219 2
a220 2
	if (strcmp(cf->cf_driver->cd_name, ra->ra_name) && 
	    strcmp("cgRDI",ra->ra_name))
d222 1
d224 2
a225 1
		return(1);
d231 1
a231 1
 * Attach a display.  We need to notice if it is the console, too.
d238 6
a243 6
	register struct cgthree_softc *sc = (struct cgthree_softc *)self;
	register struct confargs *ca = args;
	register int node = 0, ramsize, i;
	register volatile struct bt_regs *bt;
	int isconsole;
	int sbus = 1;
d246 2
a247 8
	sc->sc_fb.fb_driver = &cgthreefbdriver;
	sc->sc_fb.fb_device = &sc->sc_dev;
	sc->sc_fb.fb_flags = sc->sc_dev.dv_cfdata->cf_flags;
	/*
	 * The defaults below match my screen, but are not guaranteed
	 * to be correct as defaults go...
	 */
	sc->sc_fb.fb_type.fb_type = FBTYPE_SUN3COLOR;
d254 2
d267 2
d272 2
a273 5
	sc->sc_fb.fb_type.fb_depth = 8;
	fb_setsize(&sc->sc_fb, sc->sc_fb.fb_type.fb_depth,
    		1152, 900, node, ca->ca_bustype);
	if(!strcmp(ca->ca_ra.ra_name, "cgRDI")) {
		sc->sc_isrdi = 1;
d277 3
a279 6
	ramsize = round_page(sc->sc_fb.fb_type.fb_height *
			     sc->sc_fb.fb_linebytes);
	sc->sc_fb.fb_type.fb_cmsize = 256;
	sc->sc_fb.fb_type.fb_size = ramsize;
	printf(": %s, %d x %d", nam,
	    sc->sc_fb.fb_type.fb_width, sc->sc_fb.fb_type.fb_height);
a280 12
	/*
	 * When the ROM has mapped in a cgthree display, the address
	 * maps only the video RAM, so in any case we have to map the
	 * registers ourselves.  We only need the video RAM if we are
	 * going to print characters via rconsole.
	 */
	isconsole = node == fbnode && fbconstty != NULL;
	if ((sc->sc_fb.fb_pixels = ca->ca_ra.ra_vaddr) == NULL && isconsole) {
		/* this probably cannot happen, but what the heck */
		sc->sc_fb.fb_pixels = mapiodev(ca->ca_ra.ra_reg, CG3REG_MEM,
					       ramsize);
	}
d286 1
a286 1
	if (!sc->sc_isrdi && (sc->sc_fbc->fbc_ctrl & FBC_TIMING) == 0)
d290 2
a291 1
			if ((fbc->fbc_status & FBS_MSENSE) ==
d294 3
a296 1
				printf(" setting video ctrl");
d306 4
a309 1
	sc->sc_bustype = ca->ca_bustype;
d317 2
a318 2
	/* make sure we are not blanked */
	cgthree_set_video(sc, 1);
d321 12
d334 6
a339 3
		printf(" (console)\n");
#ifdef RASTERCONSOLE
		fbrcons_init(&sc->sc_fb);
a340 20
	} else
		printf("\n");
	if (sbus)
		sbus_establish(&sc->sc_sd, &sc->sc_dev);
	if (node == fbnode)
		fb_attach(&sc->sc_fb, isconsole);
}

int
cgthreeopen(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	int unit = minor(dev);

	if (unit >= cgthree_cd.cd_ndevs || cgthree_cd.cd_devs[unit] == NULL)
		return (ENXIO);
	return (0);
}
d342 5
a346 8
int
cgthreeclose(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{

	return (0);
d350 2
a351 2
cgthreeioctl(dev, cmd, data, flags, p)
	dev_t dev;
d353 1
a353 1
	register caddr_t data;
d357 3
a359 2
	register struct cgthree_softc *sc = cgthree_cd.cd_devs[minor(dev)];
	register struct fbgattr *fba;
d363 12
a374 3

	case FBIOGTYPE:
		*(struct fbtype *)data = sc->sc_fb.fb_type;
d377 5
a381 10
	case FBIOGATTR:
		fba = (struct fbgattr *)data;
		fba->real_type = sc->sc_fb.fb_type.fb_type;
		fba->owner = 0;		/* XXX ??? */
		fba->fbtype = sc->sc_fb.fb_type;
		fba->sattr.flags = 0;
		fba->sattr.emu_type = sc->sc_fb.fb_type.fb_type;
		fba->sattr.dev_specific[0] = -1;
		fba->emu_types[0] = sc->sc_fb.fb_type.fb_type;
		fba->emu_types[1] = -1;
d384 3
a386 7
	case FBIOGETCMAP:
		return (bt_getcmap((struct fbcmap *)data, &sc->sc_cmap, 256));

	case FBIOPUTCMAP:
		/* copy to software map */
#define p ((struct fbcmap *)data)
		error = bt_putcmap(p, &sc->sc_cmap, 256);
d389 1
a389 4
		/* now blast them into the chip */
		/* XXX should use retrace interrupt */
		cgthreeloadcmap(sc, p->index, p->count);
#undef p
d392 42
a433 3
	case FBIOGVIDEO:
		*(int *)data = cgthree_get_video(sc);
		break;
d435 2
a436 3
	case FBIOSVIDEO:
		cgthree_set_video(sc, *(int *)data);
		break;
d438 8
a445 3
	default:
		return (ENOTTY);
	}
d450 2
a451 1
 * Undo the effect of an FBIOSVIDEO that turns the video off.
d453 5
a457 3
static void
cgthreeunblank(dev)
	struct device *dev;
d459 9
d469 1
a469 1
	cgthree_set_video((struct cgthree_softc *)dev, 1);
d472 5
a476 4
static void
cgthree_set_video(sc, enable)
	struct cgthree_softc *sc;
	int enable;
d478 1
a478 1
	extern int sparc_vsyncblank;
d480 1
a480 7
	if (enable)
		sc->sc_fbc->fbc_ctrl |= FBC_VENAB | FBC_TIMING;
	else {
		sc->sc_fbc->fbc_ctrl &= ~FBC_VENAB;
		if (sparc_vsyncblank)
			sc->sc_fbc->fbc_ctrl &= ~FBC_TIMING;
	}
d483 2
a484 3
static int
cgthree_get_video(sc)
	struct cgthree_softc *sc;
d487 1
a487 1
	return ((sc->sc_fbc->fbc_ctrl & FBC_VENAB) != 0);
d490 7
a496 11
/*
 * Load a subset of the current (new) colormap into the Brooktree DAC.
 */
static void
cgthreeloadcmap(sc, start, ncolors)
	register struct cgthree_softc *sc;
	register int start, ncolors;
{
	register volatile struct bt_regs *bt;
	register u_int *ip;
	register int count;
d498 9
a506 6
	ip = &sc->sc_cmap.cm_chip[BT_D4M3(start)];	/* start/4 * 3 */
	count = BT_D4M3(start + ncolors - 1) - BT_D4M3(start) + 3;
	bt = &sc->sc_fbc->fbc_dac;
	bt->bt_addr = BT_D4M4(start);
	while (--count >= 0)
		bt->bt_cmap = *ip++;
d509 3
a511 19
/*
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
 *
 * The cg3 is mapped starting at 256KB, for pseudo-compatibility with
 * the cg4 (which had an overlay plane in the first 128K and an enable
 * plane in the next 128K).  X11 uses only 256k+ region but tries to
 * map the whole thing, so we repeatedly map the first 256K to the
 * first page of the color screen.  If someone tries to use the overlay
 * and enable regions, they will get a surprise....
 *
 * As well, mapping at an offset of 0x04000000 causes the cg3 to be
 * mapped in flat mode without the cg4 emulation.
 */
paddr_t
cgthreemmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
d513 7
a519 3
	register struct cgthree_softc *sc = cgthree_cd.cd_devs[minor(dev)];
#define START		(128*1024 + 128*1024)
#define NOOVERLAY	(0x04000000)
d521 2
a522 2
	if (off & PGOFSET)
		panic("cgthreemmap");
d524 2
a525 15
	if (off < 0)
		return (-1);
	if ((u_int)off >= NOOVERLAY)
		off -= NOOVERLAY;
	else if ((u_int)off >= START)
		off -= START;
	else
		off = 0;
	if ((unsigned)off >= sc->sc_fb.fb_type.fb_size)
		return (-1);
	/*
	 * I turned on PMAP_NC here to disable the cache as I was
	 * getting horribly broken behaviour with it on.
	 */
	return (REG2PHYS(&sc->sc_phys, CG3REG_MEM+off) | PMAP_NC);
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.12 2001/11/06 19:53:16 miod Exp $	*/
d373 1
d376 2
a377 2
		sc->sc_fbc->fbc_ctrl |= FBC_VENAB;
	else
d379 3
@


1.12
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.11 2001/11/01 12:13:46 art Exp $	*/
d113 3
a115 3
static void cgthreeloadcmap __P((struct cgthree_softc *, int, int));
static void cgthree_set_video __P((struct cgthree_softc *, int));
static int cgthree_get_video __P((struct cgthree_softc *));
@


1.12.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.12 2001/11/06 19:53:16 miod Exp $	*/
d113 3
a115 3
static void cgthreeloadcmap(struct cgthree_softc *, int, int);
static void cgthree_set_video(struct cgthree_softc *, int);
static int cgthree_get_video(struct cgthree_softc *);
@


1.12.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.12.2.1 2002/06/11 03:38:15 art Exp $	*/
a4 35
 * Copyright (c) 2002 Miodrag Vallat.  All rights reserved.
 * Copyright (c) 2001 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 *
d51 3
d68 1
d71 1
a74 6
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

d82 1
a82 1
	struct	sunfb sc_sunfb;		/* common base part */
d84 1
d87 2
a89 2
	struct intrhand sc_ih;
	int	sc_nscreens;
d92 4
a95 3
struct wsscreen_descr cgthree_stdscreen = {
	"std",
};
d97 2
a98 2
const struct wsscreen_descr *cgthree_scrlist[] = {
	&cgthree_stdscreen,
d101 2
a102 3
struct wsscreen_list cgthree_screenlist = {
	sizeof(cgthree_scrlist) / sizeof(struct wsscreen_descr *),
	    cgthree_scrlist
d105 3
a107 23
int cgthree_ioctl(void *, u_long, caddr_t, int, struct proc *);
int cgthree_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgthree_free_screen(void *, void *);
int cgthree_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t cgthree_mmap(void *, off_t, int);
void cgthree_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
static __inline__ void cgthree_loadcmap_deferred(struct cgthree_softc *,
    u_int, u_int);
void cgthree_burner(void *, u_int, u_int);
int cgthree_intr(void *);

struct wsdisplay_accessops cgthree_accessops = {
	cgthree_ioctl,
	cgthree_mmap,
	cgthree_alloc_screen,
	cgthree_free_screen,
	cgthree_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	cgthree_burner,
d110 2
a111 2
int	cgthreematch(struct device *, void *, void *);
void	cgthreeattach(struct device *, struct device *, void *);
d113 3
a115 7
struct cfattach cgthree_ca = {
	sizeof (struct cgthree_softc), cgthreematch, cgthreeattach
};

struct cfdriver cgthree_cd = {
	NULL, "cgthree", DV_DULL
};
d119 2
a120 2
	u_int8_t	sense;
	u_int8_t	vctrl[12];
d122 3
a124 14
	{	/* cpd-1790 */
		0x31,
		{ 0xbb, 0x2b, 0x04, 0x14, 0xae, 0x03,
		  0xa8, 0x24, 0x01, 0x05, 0xff, 0x01 },
	},
	{	/* gdm-20e20 */
		0x41,
		{ 0xb7, 0x27, 0x03, 0x0f, 0xae, 0x03,
		  0xae, 0x2a, 0x01, 0x09, 0xff, 0x01 },
	},
	{	/* defaults, should be last */
		0xff,
		{ 0xbb, 0x2b, 0x03, 0x0b, 0xb3, 0x03,
		  0xaf, 0x2b, 0x02, 0x0a, 0xff, 0x01 },
d126 3
d148 2
a149 2
	if (strcmp(cf->cf_driver->cd_name, ra->ra_name) &&
	    strcmp("cgRDI", ra->ra_name))
a150 1

d152 1
a152 2
		return (1);

d158 1
a158 1
 * Attach a display.
d165 6
a170 6
	struct cgthree_softc *sc = (struct cgthree_softc *)self;
	struct confargs *ca = args;
	struct wsemuldisplaydev_attach_args waa;
	int node = 0, isrdi = 0, i;
	volatile struct bt_regs *bt;
	int isconsole = 0, sbus = 1;
d173 8
a180 2
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;

a186 2
			if (*nam == '\0')
				nam = "cgthree";
a197 2
		if (*nam == '\0')
			nam = "cgthree";
d201 5
a205 2
	if (!strcmp(ca->ca_ra.ra_name, "cgRDI")) {
		isrdi = 1;
d209 6
a214 3
	printf(": %s", nam);

	isconsole = node == fbnode;
d216 12
d233 1
a233 1
	if (isrdi == 0 && (sc->sc_fbc->fbc_ctrl & FBC_TIMING) == 0)
d237 1
a237 2
			if (cg3_videoctrl[i].sense == 0xff ||
			    (fbc->fbc_status & FBS_MSENSE) ==
d240 1
a240 3
#ifdef DEBUG
				printf(" (setting video ctrl)");
#endif
d250 1
a250 4

	sc->sc_ih.ih_fun = cgthree_intr;
	sc->sc_ih.ih_arg = sc;
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih, IPL_FB);
d258 2
a259 2
	/* enable video */
	cgthree_burner(sc, 1, 0);
d262 20
a281 10
	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, ca->ca_bustype);
	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(ca->ca_ra.ra_reg, CG3REG_MEM,
	    round_page(sc->sc_sunfb.sf_fbsize));
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, isconsole);

	cgthree_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgthree_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgthree_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgthree_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;
d283 4
a286 1
	printf(", %dx%d\n", sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);
d288 6
a293 8
	if (isconsole) {
		fbwscons_console_init(&sc->sc_sunfb, &cgthree_stdscreen, -1,
		    cgthree_setcolor, cgthree_burner);
	}
#if defined(SUN4C) || defined(SUN4M)
	if (sbus)
		sbus_establish(&sc->sc_sd, &sc->sc_sunfb.sf_dev);
#endif
d295 1
a295 5
	waa.console = isconsole;
	waa.scrdata = &cgthree_screenlist;
	waa.accessops = &cgthree_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
d299 2
a300 2
cgthree_ioctl(v, cmd, data, flags, p)
	void *v;
d302 1
a302 1
	caddr_t data;
d306 2
a307 3
	struct cgthree_softc *sc = v;
	struct wsdisplay_fbinfo *wdf;
	struct wsdisplay_cmap *cm;
d311 3
a313 2
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
d315 11
a325 9
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
		wdf->cmsize = 256;
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
d328 7
a334 3
	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_getcmap(&sc->sc_cmap, cm);
d337 4
d343 6
a348 6
	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		cgthree_loadcmap_deferred(sc, cm->index, cm->count);
a350 7
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
d352 2
a353 3
		return (-1);	/* not supported yet */
        }

d357 6
a362 7
int
cgthree_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
a363 1
	struct cgthree_softc *sc = v;
d365 8
a372 2
	if (sc->sc_nscreens > 0)
		return (ENOMEM);
d374 4
a377 7
	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	sc->sc_nscreens++;
	return (0);
d380 3
a382 4
void
cgthree_free_screen(v, cookie)
	void *v;
	void *cookie;
a383 1
	struct cgthree_softc *sc = v;
d385 1
a385 1
	sc->sc_nscreens--;
d388 18
a405 9
int
cgthree_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
	return (0);
d411 10
d423 3
a425 3
cgthree_mmap(v, offset, prot)
	void *v;
	off_t offset;
d428 6
a433 1
	struct cgthree_softc *sc = v;
d435 9
a443 1
	if (offset & PGOFSET)
d445 5
a449 63

	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys,
		    CG3REG_MEM + offset) | PMAP_NC);
	}

	return (-1);
}

void
cgthree_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
	u_int8_t r, g, b;
{
	struct cgthree_softc *sc = v;

	bt_setcolor(&sc->sc_cmap, &sc->sc_fbc->fbc_dac, index, r, g, b, 0);
}

static __inline__ void
cgthree_loadcmap_deferred(struct cgthree_softc *sc, u_int start, u_int ncolors)
{

	sc->sc_fbc->fbc_ctrl |= FBC_IENAB;
}

void
cgthree_burner(v, on, flags)
	void *v;
	u_int on, flags;
{
	struct cgthree_softc *sc = v;
	int s;

	s = splhigh();
	if (on)
		sc->sc_fbc->fbc_ctrl |= FBC_VENAB | FBC_TIMING;
	else {
		sc->sc_fbc->fbc_ctrl &= ~FBC_VENAB;
		if (flags & WSDISPLAY_BURN_VBLANK)
			sc->sc_fbc->fbc_ctrl &= ~FBC_TIMING;
	}
	splx(s);
}

int
cgthree_intr(v)
	void *v;
{
	struct cgthree_softc *sc = v;

	if (!ISSET(sc->sc_fbc->fbc_ctrl, FBC_IENAB) ||
	    !ISSET(sc->sc_fbc->fbc_status, FBS_INTR)) {
		/* Not expecting an interrupt, it's not for us. */
		return (0);
	}

	/* Acknowledge the interrupt and disable it. */
	sc->sc_fbc->fbc_ctrl &= ~FBC_IENAB;

	bt_loadcmap(&sc->sc_cmap, &sc->sc_fbc->fbc_dac, 0, 256, 0);
	return (1);
@


1.12.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a321 1
	fbwscons_setcolormap(&sc->sc_sunfb, cgthree_setcolor);
d332 1
a332 1
		    cgthree_burner);
d361 1
a361 1
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG3;
@


1.11
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.10 2001/08/17 13:52:28 mickey Exp $	*/
d66 1
a66 1
#include <vm/vm.h>
@


1.10
log
@cdev_decl cleanup; jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.9 1999/09/10 23:32:02 art Exp $	*/
d422 1
a422 1
int
d425 2
a426 1
	int off, prot;
@


1.9
log
@roundup(foo, NBPG) -> round_page(foo)
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.8 1998/11/20 15:57:22 deraadt Exp $	*/
a95 3

/* cdevsw prototypes */
cdev_decl(cgthree);
@


1.9.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.9 1999/09/10 23:32:02 art Exp $	*/
d96 3
@


1.9.4.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d66 1
a66 1
#include <uvm/uvm_extern.h>
d422 1
a422 1
paddr_t
d425 1
a425 2
	off_t off;
	int prot;
@


1.9.4.3
log
@Merge in -current from about a week ago
@
text
@d113 3
a115 3
static void cgthreeloadcmap(struct cgthree_softc *, int, int);
static void cgthree_set_video(struct cgthree_softc *, int);
static int cgthree_get_video(struct cgthree_softc *);
@


1.9.4.4
log
@Sync the SMP branch with 3.3
@
text
@a4 35
 * Copyright (c) 2002 Miodrag Vallat.  All rights reserved.
 * Copyright (c) 2001 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 *
d51 3
d68 1
d71 1
a74 6
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

d82 1
a82 1
	struct	sunfb sc_sunfb;		/* common base part */
d84 1
d87 2
a89 2
	struct intrhand sc_ih;
	int	sc_nscreens;
d92 4
a95 3
struct wsscreen_descr cgthree_stdscreen = {
	"std",
};
d97 2
a98 2
const struct wsscreen_descr *cgthree_scrlist[] = {
	&cgthree_stdscreen,
d101 2
a102 3
struct wsscreen_list cgthree_screenlist = {
	sizeof(cgthree_scrlist) / sizeof(struct wsscreen_descr *),
	    cgthree_scrlist
d105 3
a107 23
int cgthree_ioctl(void *, u_long, caddr_t, int, struct proc *);
int cgthree_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgthree_free_screen(void *, void *);
int cgthree_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t cgthree_mmap(void *, off_t, int);
void cgthree_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
static __inline__ void cgthree_loadcmap_deferred(struct cgthree_softc *,
    u_int, u_int);
void cgthree_burner(void *, u_int, u_int);
int cgthree_intr(void *);

struct wsdisplay_accessops cgthree_accessops = {
	cgthree_ioctl,
	cgthree_mmap,
	cgthree_alloc_screen,
	cgthree_free_screen,
	cgthree_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	cgthree_burner,
d110 2
a111 2
int	cgthreematch(struct device *, void *, void *);
void	cgthreeattach(struct device *, struct device *, void *);
d113 3
a115 7
struct cfattach cgthree_ca = {
	sizeof (struct cgthree_softc), cgthreematch, cgthreeattach
};

struct cfdriver cgthree_cd = {
	NULL, "cgthree", DV_DULL
};
d119 2
a120 2
	u_int8_t	sense;
	u_int8_t	vctrl[12];
d122 3
a124 14
	{	/* cpd-1790 */
		0x31,
		{ 0xbb, 0x2b, 0x04, 0x14, 0xae, 0x03,
		  0xa8, 0x24, 0x01, 0x05, 0xff, 0x01 },
	},
	{	/* gdm-20e20 */
		0x41,
		{ 0xb7, 0x27, 0x03, 0x0f, 0xae, 0x03,
		  0xae, 0x2a, 0x01, 0x09, 0xff, 0x01 },
	},
	{	/* defaults, should be last */
		0xff,
		{ 0xbb, 0x2b, 0x03, 0x0b, 0xb3, 0x03,
		  0xaf, 0x2b, 0x02, 0x0a, 0xff, 0x01 },
d126 3
d148 2
a149 2
	if (strcmp(cf->cf_driver->cd_name, ra->ra_name) &&
	    strcmp("cgRDI", ra->ra_name))
a150 1

d152 1
a152 2
		return (1);

d158 1
a158 1
 * Attach a display.
d165 6
a170 6
	struct cgthree_softc *sc = (struct cgthree_softc *)self;
	struct confargs *ca = args;
	struct wsemuldisplaydev_attach_args waa;
	int node = 0, isrdi = 0, i;
	volatile struct bt_regs *bt;
	int isconsole = 0, sbus = 1;
d173 8
a180 2
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;

a186 2
			if (*nam == '\0')
				nam = "cgthree";
a197 2
		if (*nam == '\0')
			nam = "cgthree";
d201 5
a205 2
	if (!strcmp(ca->ca_ra.ra_name, "cgRDI")) {
		isrdi = 1;
d209 6
a214 3
	printf(": %s", nam);

	isconsole = node == fbnode;
d216 12
d233 1
a233 1
	if (isrdi == 0 && (sc->sc_fbc->fbc_ctrl & FBC_TIMING) == 0)
d237 1
a237 2
			if (cg3_videoctrl[i].sense == 0xff ||
			    (fbc->fbc_status & FBS_MSENSE) ==
d240 1
a240 3
#ifdef DEBUG
				printf(" (setting video ctrl)");
#endif
d250 1
a250 4

	sc->sc_ih.ih_fun = cgthree_intr;
	sc->sc_ih.ih_arg = sc;
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih, IPL_FB);
d258 2
a259 2
	/* enable video */
	cgthree_burner(sc, 1, 0);
d262 20
a281 11
	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, ca->ca_bustype);
	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(ca->ca_ra.ra_reg, CG3REG_MEM,
	    round_page(sc->sc_sunfb.sf_fbsize));
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, isconsole);
	fbwscons_setcolormap(&sc->sc_sunfb, cgthree_setcolor);

	cgthree_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgthree_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgthree_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgthree_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;
d283 4
a286 1
	printf(", %dx%d\n", sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);
d288 6
a293 8
	if (isconsole) {
		fbwscons_console_init(&sc->sc_sunfb, &cgthree_stdscreen, -1,
		    cgthree_burner);
	}
#if defined(SUN4C) || defined(SUN4M)
	if (sbus)
		sbus_establish(&sc->sc_sd, &sc->sc_sunfb.sf_dev);
#endif
d295 1
a295 5
	waa.console = isconsole;
	waa.scrdata = &cgthree_screenlist;
	waa.accessops = &cgthree_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
d299 2
a300 2
cgthree_ioctl(v, cmd, data, flags, p)
	void *v;
d302 1
a302 1
	caddr_t data;
d306 2
a307 3
	struct cgthree_softc *sc = v;
	struct wsdisplay_fbinfo *wdf;
	struct wsdisplay_cmap *cm;
d311 3
a313 2
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
d315 11
a325 9
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
		wdf->cmsize = 256;
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
d328 7
a334 3
	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_getcmap(&sc->sc_cmap, cm);
d337 4
d343 6
a348 6
	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		cgthree_loadcmap_deferred(sc, cm->index, cm->count);
a350 7
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
d352 2
a353 3
		return (-1);	/* not supported yet */
        }

d357 6
a362 7
int
cgthree_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
a363 1
	struct cgthree_softc *sc = v;
d365 8
a372 2
	if (sc->sc_nscreens > 0)
		return (ENOMEM);
d374 4
a377 7
	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	sc->sc_nscreens++;
	return (0);
d380 3
a382 4
void
cgthree_free_screen(v, cookie)
	void *v;
	void *cookie;
a383 1
	struct cgthree_softc *sc = v;
d385 1
a385 1
	sc->sc_nscreens--;
d388 18
a405 9
int
cgthree_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
	return (0);
d411 10
d423 3
a425 3
cgthree_mmap(v, offset, prot)
	void *v;
	off_t offset;
d428 6
a433 1
	struct cgthree_softc *sc = v;
d435 9
a443 1
	if (offset & PGOFSET)
d445 5
a449 63

	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys,
		    CG3REG_MEM + offset) | PMAP_NC);
	}

	return (-1);
}

void
cgthree_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
	u_int8_t r, g, b;
{
	struct cgthree_softc *sc = v;

	bt_setcolor(&sc->sc_cmap, &sc->sc_fbc->fbc_dac, index, r, g, b, 0);
}

static __inline__ void
cgthree_loadcmap_deferred(struct cgthree_softc *sc, u_int start, u_int ncolors)
{

	sc->sc_fbc->fbc_ctrl |= FBC_IENAB;
}

void
cgthree_burner(v, on, flags)
	void *v;
	u_int on, flags;
{
	struct cgthree_softc *sc = v;
	int s;

	s = splhigh();
	if (on)
		sc->sc_fbc->fbc_ctrl |= FBC_VENAB | FBC_TIMING;
	else {
		sc->sc_fbc->fbc_ctrl &= ~FBC_VENAB;
		if (flags & WSDISPLAY_BURN_VBLANK)
			sc->sc_fbc->fbc_ctrl &= ~FBC_TIMING;
	}
	splx(s);
}

int
cgthree_intr(v)
	void *v;
{
	struct cgthree_softc *sc = v;

	if (!ISSET(sc->sc_fbc->fbc_ctrl, FBC_IENAB) ||
	    !ISSET(sc->sc_fbc->fbc_status, FBS_INTR)) {
		/* Not expecting an interrupt, it's not for us. */
		return (0);
	}

	/* Acknowledge the interrupt and disable it. */
	sc->sc_fbc->fbc_ctrl &= ~FBC_IENAB;

	bt_loadcmap(&sc->sc_cmap, &sc->sc_fbc->fbc_dac, 0, 256, 0);
	return (1);
@


1.9.4.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.9.4.4 2003/03/27 23:49:25 niklas Exp $	*/
d362 1
a362 1
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG3;
@


1.9.4.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.9.4.5 2003/05/13 19:41:08 ho Exp $	*/
d17 5
d60 5
a64 1
 * 3. Neither the name of the University nor the names of its contributors
d210 5
d241 2
@


1.9.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d75 2
a76 3
 * Color display (cgthree) driver.
 * Works with the real Sun hardware, as well as various clones from Tatung,
 * Integrix (S20), and the Vigra VS10-EK.
d305 1
a305 17

	printf(", %dx%d\n", sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);

	/*
	 * If the framebuffer width is under 1024x768, which is the case for
	 * some clones on laptops, as well as with the VS10-EK, switch from
	 * the PROM font to the more adequate 8x16 font here.
	 * However, we need to adjust two things in this case:
	 * - the display row should be overrided from the current PROM metrics,
	 *   to prevent us from overwriting the last few lines of text.
	 * - if the 80x34 screen would make a large margin appear around it,
	 *   choose to clear the screen rather than keeping old prom output in
	 *   the margins.
	 * XXX there should be a rasops "clear margins" feature
	 */
	fbwscons_init(&sc->sc_sunfb, isconsole &&
	    (sc->sc_sunfb.sf_width >= 1024) ? 0 : RI_CLEAR);
d313 2
d316 2
a317 2
		fbwscons_console_init(&sc->sc_sunfb, &cgthree_stdscreen,
		    sc->sc_sunfb.sf_width >= 1024 ? -1 : 0, cgthree_burner);
a318 1

@


1.8
log
@careful off handling in mmap routines
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.7 1997/09/01 03:56:45 todd Exp $	*/
d212 2
a213 2
	ramsize = roundup(sc->sc_fb.fb_type.fb_height * sc->sc_fb.fb_linebytes,
		NBPG);
@


1.7
log
@Thanks go to Jason Downs <downsj@@openbsd.org> who virtually handed me this
patch.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.6 1997/08/08 08:24:53 downsj Exp $	*/
d436 3
@


1.6
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d88 1
d151 2
a152 1
	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
d206 5
a210 1
	    1152, 900, node, ca->ca_bustype);
d236 1
a236 1
	if ((sc->sc_fbc->fbc_ctrl & FBC_TIMING) == 0)
@


1.5
log
@netbsd port, now we merge our changes back in
@
text
@d1 2
a2 1
/*	$NetBSD: cgthree.c,v 1.27 1996/04/01 17:30:03 christos Exp $ */
a93 4
int		cgthreeopen __P((dev_t, int, int, struct proc *));
int		cgthreeclose __P((dev_t, int, int, struct proc *));
int		cgthreeioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int		cgthreemmap __P((dev_t, int, int));
d96 3
d119 14
d223 1
a223 1
						ramsize, ca->ca_bustype);
d227 18
a244 1
		     sizeof(struct fbcontrol), ca->ca_bustype);
d442 1
a442 1
	return (REG2PHYS(&sc->sc_phys, CG3REG_MEM+off, sc->sc_bustype) | PMAP_NC);
@


1.4
log
@new mapdev/()/mapiodev() calling convention uses "struct rom_reg *" to supply
base plus an offset
new dvma routines
@
text
@d1 1
a1 1
/*	$NetBSD: cgthree.c,v 1.16 1995/10/08 01:39:18 pk Exp $ */
d56 1
d63 1
d71 2
d84 2
a85 2
	volatile struct bt_regs *sc_bt;	/* Brooktree registers */
	struct rom_reg sc_phys;		/* display RAM (phys addr) */
a86 1
	int	sc_blanked;		/* true if blanked */
d99 6
a104 3
struct cfdriver cgthreecd = {
	NULL, "cgthree", cgthreematch, cgthreeattach,
	DV_DULL, sizeof(struct cgthree_softc)
d116 2
d131 5
d154 1
a154 1
	register int node = ca->ca_ra.ra_node, ramsize, i;
a155 1
	register struct cgthree_all *p;
d157 2
a158 1
	char *nam;
d162 1
a168 1
#if defined(SUN4M)
d170 3
a172 1
		if (cputyp == CPU_SUN4M)	/* 4m has framebuffer on obio */
d174 2
a175 3
		break;
#endif

d177 2
a178 1
		node = 0;
d181 1
d183 1
d193 1
a193 1
	    NBPG);
a205 1
	p = (struct cgthree_all *)ca->ca_ra.ra_paddr;
d209 1
a209 1
		    ramsize, ca->ca_bustype);
d211 3
a213 2
	sc->sc_bt = bt = (volatile struct bt_regs *)mapiodev(ca->ca_ra.ra_reg,
	    CG3REG_REG, sizeof(struct bt_regs), ca->ca_bustype);
d219 1
d223 4
a226 5
	/* make sure we are not blanked (see cgthreeunblank) */
	bt->bt_addr = 0x06;		/* command reg */
	bt->bt_ctrl = 0x73;		/* overlay plane */
	bt->bt_addr = 0x04;		/* read mask */
	bt->bt_ctrl = 0xff;		/* color planes */
d235 1
a235 2
#if defined(SUN4C) || defined(SUN4M)
	if (ca->ca_bustype == BUS_SBUS)
a236 1
#endif /* SUN4C || SUN4M */
d238 1
a238 1
		fb_attach(&sc->sc_fb);
d249 1
a249 1
	if (unit >= cgthreecd.cd_ndevs || cgthreecd.cd_devs[unit] == NULL)
d272 1
a272 1
	register struct cgthree_softc *sc = cgthreecd.cd_devs[minor(dev)];
d310 1
a310 1
		*(int *)data = sc->sc_blanked;
d314 1
a314 19
		if (*(int *)data)
			cgthreeunblank(&sc->sc_dev);
		else if (!sc->sc_blanked) {
			register volatile struct bt_regs *bt;

			bt = sc->sc_bt;
			bt->bt_addr = 0x06;	/* command reg */
			bt->bt_ctrl = 0x70;	/* overlay plane */
			bt->bt_addr = 0x04;	/* read mask */
			bt->bt_ctrl = 0x00;	/* color planes */
			/*
			 * Set color 0 to black -- note that this overwrites
			 * R of color 1.
			 */
			bt->bt_addr = 0;
			bt->bt_cmap = 0;

			sc->sc_blanked = 1;
		}
a329 2
	struct cgthree_softc *sc = (struct cgthree_softc *)dev;
	register volatile struct bt_regs *bt;
d331 21
a351 13
	if (sc->sc_blanked) {
		sc->sc_blanked = 0;
		bt = sc->sc_bt;
		/* restore color 0 (and R of color 1) */
		bt->bt_addr = 0;
		bt->bt_cmap = sc->sc_cmap.cm_chip[0];

		/* restore read mask */
		bt->bt_addr = 0x06;	/* command reg */
		bt->bt_ctrl = 0x73;	/* overlay plane */
		bt->bt_addr = 0x04;	/* read mask */
		bt->bt_ctrl = 0xff;	/* color planes */
	}
d368 1
a368 1
	bt = sc->sc_bt;
d384 1
a384 1
 * 
d393 1
a393 1
	register struct cgthree_softc *sc = cgthreecd.cd_devs[minor(dev)];
@


1.3
log
@cleanup
@
text
@d81 2
a82 1
	caddr_t	sc_phys;		/* display RAM (phys addr) */
d141 1
a141 1
	register int node, ramsize, i;
d155 7
a166 1
		node = ca->ca_ra.ra_node;
d192 2
a193 1
		sc->sc_fb.fb_pixels = mapiodev(p->ba_ram, ramsize, ca->ca_bustype);
d195 5
a199 3
	sc->sc_bt = bt = (volatile struct bt_regs *)
	    mapiodev((caddr_t)&p->ba_btreg, sizeof(p->ba_btreg), ca->ca_bustype);
	sc->sc_phys = p->ba_ram;
d408 1
a408 1
	return ((int)sc->sc_phys + off + PMAP_OBIO + PMAP_NC);
@


1.2
log
@no obio or vme16 cg3
@
text
@a106 3
extern int (*v_putc)();
extern int nullop();
static int cgthree_cnputc();
@


1.1
log
@Initial revision
@
text
@a146 1
	int sbus = 1;
a156 1
	case BUS_OBIO:
d158 1
a158 2
	case BUS_VME16:
		sbus = node = 0;
a160 1

d172 1
a172 1
		NBPG);
d211 2
a212 1
	if (sbus)
d214 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
