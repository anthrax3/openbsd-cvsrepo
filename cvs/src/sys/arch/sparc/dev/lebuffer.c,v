head	1.10;
access;
symbols
	OPENBSD_6_0:1.10.0.6
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.9.0.16
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.20
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.18
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.14
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.12
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.10
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.8
	OPENBSD_5_0:1.9.0.6
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.4
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.2
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.7.0.4
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.5.0.18
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.16
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.14
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.12
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.10
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.8
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.4.0.16
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.14
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.12
	OPENBSD_2_8:1.4.0.10
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.8
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.6
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.0.2
	OPENBSD_2_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.03.30.20.30.22;	author miod;	state Exp;
branches;
next	1.9;
commitid	f66FukLLgPJs9j5H;

1.9
date	2010.07.10.19.32.24;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.7;

1.7
date	2008.12.26.15.13.07;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.02.20.00.54;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.43;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.11.11.00.26.00;	author jason;	state Exp;
branches
	1.4.6.1
	1.4.16.1;
next	1.3;

1.3
date	98.07.05.09.24.23;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	98.03.09.09.33.39;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	97.08.08.08.25.16;	author downsj;	state Exp;
branches;
next	;

1.4.6.1
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	;

1.4.16.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Add a bus_dma_tag_t for DVMA usage, suitable for use for devices not sitting
behind a sun4m iommu.

Move the existing dvma routines from vm_machdep.c to this new dvma.c; this
allows for a few declarations to be removed from public headers.

Extend the device attachment arguments (struct confargs) to pass a
bus_dma_tag_t. mainbus receives the dvma bus_dma_tag_t, and devices pass the
tag unchanged to their children, except for iommu(4) which replaces it with
its own.

Change the few sun4m-only drivers to pick the bus_dma_tag_t from confargs
rather than assume iommu; this allows qlw(4) to attach and work on sun4c.

ok kettenis@@
@
text
@/*	$OpenBSD: lebuffer.c,v 1.9 2010/07/10 19:32:24 miod Exp $	*/
/*	$NetBSD: lebuffer.c,v 1.3 1997/05/24 20:16:28 pk Exp $ */

/*
 * Copyright (c) 1996 Paul Kranenburg.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Peter Galbavy.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/proc.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>

#include <sparc/dev/sbusvar.h>
#include <sparc/dev/lebuffervar.h>
#include <sparc/dev/dmareg.h>/*XXX*/

int	lebufprint(void *, const char *);
int	lebufmatch(struct device *, void *, void *);
void	lebufattach(struct device *, struct device *, void *);

struct cfattach lebuffer_ca = {
	sizeof(struct lebuf_softc), lebufmatch, lebufattach
};

struct cfdriver lebuffer_cd = {
	NULL, "lebuffer", DV_DULL
};

int
lebufprint(aux, name)
	void *aux;
	const char *name;
{
	register struct confargs *ca = aux;

	if (name)
		printf("%s at %s", ca->ca_ra.ra_name, name);
	printf(" offset 0x%x", ca->ca_offset);
	return (UNCONF);
}

/*
 * Match a lebuffer card in a slot capable of dma.
 */
int
lebufmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
		return(0);

	if (!sbus_testdma((struct sbus_softc *)parent, ca))
		return(0);

	return (1);
}

/*
 * Attach all the sub-devices we can find
 */
void
lebufattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	register struct confargs *ca = aux;
	struct lebuf_softc *sc = (void *)self;
	int node;
	struct confargs oca;
	char *name;
	int sbusburst;

	if (ca->ca_ra.ra_vaddr == NULL || ca->ca_ra.ra_nvaddrs == 0)
		ca->ca_ra.ra_vaddr =
		    mapiodev(ca->ca_ra.ra_reg, 0, ca->ca_ra.ra_len);

	/*
	 * This device's "register space" is just a buffer where the
	 * Lance ring-buffers can be stored. Note the buffer's location
	 * and size, so the `le' driver can pick them up.
	 */
	sc->sc_buffer = (caddr_t)ca->ca_ra.ra_vaddr;
	sc->sc_bufsiz = ca->ca_ra.ra_len;

	/*
	 * Get transfer burst size from PROM
	 */
	sbusburst = ((struct sbus_softc *)parent)->sc_burst;
	if (sbusburst == 0)
		sbusburst = SBUS_BURST_32 - 1; /* 1->16 */

	sc->sc_burst = getpropint(ca->ca_ra.ra_node, "burst-sizes", -1);
	if (sc->sc_burst == -1)
		/* take SBus burst sizes */
		sc->sc_burst = sbusburst;

	/* Clamp at parent's burst sizes */
	sc->sc_burst &= sbusburst;

	printf(": %dK memory\n", sc->sc_bufsiz / 1024);

	node = sc->sc_node = ca->ca_ra.ra_node;

	/* Propagate bootpath */
	if (ca->ca_ra.ra_bp != NULL)
		oca.ca_ra.ra_bp = ca->ca_ra.ra_bp + 1;
	else
		oca.ca_ra.ra_bp = NULL;

	/* search through children */
	for (node = firstchild(node); node; node = nextsibling(node)) {
		name = getpropstring(node, "name");
		if (!romprop(&oca.ca_ra, name, node))
			continue;

		sbus_translate(parent, &oca);
		oca.ca_bustype = BUS_SBUS;
		oca.ca_dmat = ca->ca_dmat;
		config_found(&sc->sc_dev, (void *)&oca, lebufprint);
	}
#endif /* SUN4C || SUN4D || SUN4E || SUN4M */
}
@


1.9
log
@sun4e (i.e. SPARCengine 1e) support. This platform is a mix between sun4 and
sun4c, as it has a sun4c OpenPROM but a sun4 8KB pagesize. VME devices are
not supported yet.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lebuffer.c,v 1.8 2010/06/26 23:24:44 guenther Exp $	*/
d44 2
a45 2
#include <sparc/autoconf.h>
#include <sparc/cpu.h>
d86 1
a86 1
	register struct romaux *ra = &ca->ca_ra;
d158 2
a159 1
		(void) config_found(&sc->sc_dev, (void *)&oca, lebufprint);
@


1.8
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lebuffer.c,v 1.7 2008/12/26 15:13:07 miod Exp $	*/
d105 1
a105 1
#if defined(SUN4C) || defined(SUN4M)
d160 1
a160 1
#endif /* SUN4C || SUN4M */
@


1.7
log
@Correctly report unconfigured child devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: lebuffer.c,v 1.6 2006/06/02 20:00:54 miod Exp $	*/
a42 1
#include <sys/user.h>
@


1.6
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: lebuffer.c,v 1.5 2002/03/14 01:26:43 millert Exp $	*/
d72 1
a72 1
		printf("[%s at %s]", ca->ca_ra.ra_name, name);
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: lebuffer.c,v 1.4 1998/11/11 00:26:00 jason Exp $	*/
a143 3

	if (ca->ca_bustype == BUS_SBUS)
		sbus_establish(&sc->sc_sd, &sc->sc_dev);
@


1.4
log
@Detect cards that require dma that are in non-dma slots and don't allow
them to be attach'd.
@
text
@d1 1
a1 1
/*	$OpenBSD: lebuffer.c,v 1.3 1998/07/05 09:24:23 deraadt Exp $	*/
d52 3
a54 3
int	lebufprint __P((void *, const char *));
int	lebufmatch __P((struct device *, void *, void *));
void	lebufattach __P((struct device *, struct device *, void *));
@


1.4.16.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: lebuffer.c,v 1.4 1998/11/11 00:26:00 jason Exp $	*/
d52 3
a54 3
int	lebufprint(void *, const char *);
int	lebufmatch(struct device *, void *, void *);
void	lebufattach(struct device *, struct device *, void *);
@


1.4.6.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 3
a54 3
int	lebufprint(void *, const char *);
int	lebufmatch(struct device *, void *, void *);
void	lebufattach(struct device *, struct device *, void *);
@


1.3
log
@do not print fake slot numbers
@
text
@d1 1
a1 1
/*	$OpenBSD: lebuffer.c,v 1.2 1998/03/09 09:33:39 deraadt Exp $	*/
d53 1
d57 1
a57 1
	sizeof(struct lebuf_softc), matchbyname, lebufattach
d75 21
@


1.2
log
@print how much memory
@
text
@d1 1
a1 1
/*	$OpenBSD: lebuffer.c,v 1.1 1997/08/08 08:25:16 downsj Exp $	*/
d72 1
a72 1
	printf(" slot 0x%x offset 0x%x", ca->ca_slot, ca->ca_offset);
@


1.1
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d119 1
a119 1
	printf("\n");
@

