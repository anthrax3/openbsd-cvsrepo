head	1.72;
access;
symbols
	OPENBSD_6_0:1.72.0.8
	OPENBSD_6_0_BASE:1.72
	OPENBSD_5_9:1.72.0.4
	OPENBSD_5_9_BASE:1.72
	OPENBSD_5_8:1.72.0.6
	OPENBSD_5_8_BASE:1.72
	OPENBSD_5_7:1.72.0.2
	OPENBSD_5_7_BASE:1.72
	OPENBSD_5_6:1.62.0.4
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.61.0.4
	OPENBSD_5_5_BASE:1.61
	OPENBSD_5_4:1.58.0.2
	OPENBSD_5_4_BASE:1.58
	OPENBSD_5_3:1.57.0.4
	OPENBSD_5_3_BASE:1.57
	OPENBSD_5_2:1.57.0.2
	OPENBSD_5_2_BASE:1.57
	OPENBSD_5_1_BASE:1.56
	OPENBSD_5_1:1.56.0.4
	OPENBSD_5_0:1.56.0.2
	OPENBSD_5_0_BASE:1.56
	OPENBSD_4_9:1.53.0.2
	OPENBSD_4_9_BASE:1.53
	OPENBSD_4_8:1.48.0.2
	OPENBSD_4_8_BASE:1.48
	OPENBSD_4_7:1.47.0.2
	OPENBSD_4_7_BASE:1.47
	OPENBSD_4_6:1.44.0.6
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.44.0.2
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.43.0.4
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.43.0.2
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.41.0.2
	OPENBSD_4_2_BASE:1.41
	OPENBSD_4_1:1.34.0.2
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.29.0.4
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.28.0.4
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.28.0.2
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.24.0.4
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.24.0.2
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	UBC_SYNC_B:1.24
	UBC:1.20.0.2
	UBC_BASE:1.20
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_8:1.15.0.2
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.14.0.6
	OPENBSD_2_7_BASE:1.14
	SMP:1.14.0.4
	SMP_BASE:1.14
	kame_19991208:1.14
	OPENBSD_2_6:1.14.0.2
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.13.0.4
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.9.0.4
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.72
date	2015.02.08.01.30.09;	author dlg;	state Exp;
branches;
next	1.71;
commitid	iDqffw2rcczvRdaf;

1.71
date	2015.01.16.20.18.24;	author miod;	state Exp;
branches;
next	1.70;
commitid	jsnGT5pb7CAZju6U;

1.70
date	2015.01.15.21.17.54;	author miod;	state Exp;
branches;
next	1.69;
commitid	DYNfPenXY8PUhMer;

1.69
date	2015.01.14.21.17.09;	author miod;	state Exp;
branches;
next	1.68;
commitid	hIC3tK7p4HkOnEHa;

1.68
date	2015.01.14.21.14.49;	author miod;	state Exp;
branches;
next	1.67;
commitid	PgF6jY0brASd4A0j;

1.67
date	2015.01.14.21.13.46;	author miod;	state Exp;
branches;
next	1.66;
commitid	D8IgstMlgb5ty7i2;

1.66
date	2015.01.14.19.02.59;	author miod;	state Exp;
branches;
next	1.65;
commitid	1kQrxNkHrTSZQ4NN;

1.65
date	2015.01.14.19.01.00;	author miod;	state Exp;
branches;
next	1.64;
commitid	ud1N0wF51836kdIY;

1.64
date	2015.01.13.20.40.11;	author miod;	state Exp;
branches;
next	1.63;
commitid	GfyK6mpEK4OZiTtd;

1.63
date	2015.01.12.21.31.06;	author miod;	state Exp;
branches;
next	1.62;
commitid	PSJsKbBjegdV1GBa;

1.62
date	2014.07.11.16.35.40;	author jsg;	state Exp;
branches;
next	1.61;
commitid	7NtJNW9udCOFtDNM;

1.61
date	2013.11.01.17.36.19;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2013.10.20.10.11.16;	author krw;	state Exp;
branches;
next	1.59;

1.59
date	2013.10.14.23.26.22;	author krw;	state Exp;
branches;
next	1.58;

1.58
date	2013.06.11.16.42.11;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2012.07.01.12.11.53;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2011.07.06.04.49.35;	author matthew;	state Exp;
branches;
next	1.55;

1.55
date	2011.06.05.18.40.33;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	2011.06.03.21.14.11;	author matthew;	state Exp;
branches;
next	1.53;

1.53
date	2010.11.11.17.46.58;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2010.09.22.06.40.25;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2010.09.22.01.18.57;	author matthew;	state Exp;
branches;
next	1.50;

1.50
date	2010.09.08.14.47.10;	author jsing;	state Exp;
branches;
next	1.49;

1.49
date	2010.08.28.20.23.22;	author matthew;	state Exp;
branches;
next	1.48;

1.48
date	2010.05.23.10.49.19;	author dlg;	state Exp;
branches;
next	1.47;

1.47
date	2009.09.05.15.37.04;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2009.09.05.00.48.39;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2009.08.13.15.23.12;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2009.01.04.16.51.05;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2007.11.28.16.33.20;	author martin;	state Exp;
branches;
next	1.42;

1.42
date	2007.10.01.16.11.19;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2007.07.01.19.06.57;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2007.06.24.16.52.04;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2007.06.20.18.16.24;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2007.06.07.03.42.51;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.06.17.15.12;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.05.00.38.18;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2007.04.29.18.59.37;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2007.02.15.00.53.26;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2006.12.03.16.40.43;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.15.20.20.41;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2006.01.20.23.27.25;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2006.01.20.00.20.38;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2004.09.29.07.35.11;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.15.02.45.46;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.12.11.35.08;	author jmc;	state Exp;
branches;
next	1.26;

1.26
date	2003.09.29.09.08.19;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2003.08.15.20.32.14;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.08.18.52.45;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.29.08.28.36;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2002.04.30.01.12.29;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.01.26.43;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2001.09.11.20.05.24;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.24.10.07.20;	author ho;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.22.22.11.46;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.10.15.33.07;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	2000.07.04.13.15.12;	author art;	state Exp;
branches;
next	1.14;

1.14
date	99.07.09.21.34.46;	author art;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	98.10.03.21.18.58;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.03.01.08.42.19;	author johns;	state Exp;
branches;
next	1.11;

1.11
date	97.08.08.21.46.50;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	97.08.08.08.25.35;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	96.08.12.20.24.05;	author chuck;	state Exp;
branches;
next	1.8;

1.8
date	96.08.11.05.34.30;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.03.04.20.35.23;	author chuck;	state Exp;
branches;
next	1.6;

1.6
date	96.02.08.04.43.45;	author chuck;	state Exp;
branches;
next	1.5;

1.5
date	96.01.13.03.45.01;	author chuck;	state Exp;
branches;
next	1.4;

1.4
date	96.01.12.23.09.08;	author chuck;	state Exp;
branches;
next	1.3;

1.3
date	96.01.12.20.20.51;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.15.13.56.27;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.40;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.40;	author deraadt;	state Exp;
branches;
next	;

1.14.4.1
date	2001.05.14.21.37.10;	author niklas;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2001.10.31.03.07.56;	author nate;	state Exp;
branches;
next	1.14.4.3;

1.14.4.3
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.14.4.4;

1.14.4.4
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.14.4.5;

1.14.4.5
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.14.4.6;

1.14.4.6
date	2004.02.19.10.49.58;	author niklas;	state Exp;
branches;
next	1.14.4.7;

1.14.4.7
date	2004.06.05.23.10.58;	author niklas;	state Exp;
branches;
next	;

1.20.2.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	;


desc
@@


1.72
log
@replace hand rolled code to maintain a list of bufs with a fifo
bufq.

guenther pointed out this is one of the last things using the compat
in struct buf that we still have from the disksort days. not anymore.

ok miod@@ guenther@@
@
text
@/*	$OpenBSD: xd.c,v 1.71 2015/01/16 20:18:24 miod Exp $	*/
/*	$NetBSD: xd.c,v 1.37 1997/07/29 09:58:16 fair Exp $	*/

/*
 * Copyright (c) 1995 Charles D. Cranor
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 *
 * x d . c   x y l o g i c s   7 5 3 / 7 0 5 3   v m e / s m d   d r i v e r
 *
 * author: Chuck Cranor <chuck@@ccrc.wustl.edu>
 * id: $NetBSD: xd.c,v 1.37 1997/07/29 09:58:16 fair Exp $
 * started: 27-Feb-95
 * references: [1] Xylogics Model 753 User's Manual
 *                 part number: 166-753-001, Revision B, May 21, 1988.
 *                 "Your Partner For Performance"
 *             [2] other NetBSD disk device drivers
 *
 * Special thanks go to Scott E. Campbell of Xylogics, Inc. for taking
 * the time to answer some of my questions about the 753/7053.
 *
 * note: the 753 and the 7053 are programmed the same way, but are
 * different sizes.   the 753 is a 6U VME card, while the 7053 is a 9U
 * VME card (found in many VME based suns).
 */

#undef XDC_DEBUG		/* full debug */
#if !defined(SMALL_KERNEL)
#define XDC_DIAG		/* extra sanity checks */
#endif
#if defined(DIAGNOSTIC) && !defined(XDC_DIAG)
#define XDC_DIAG		/* link in with master DIAG option */
#endif

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/buf.h>
#include <sys/uio.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/disk.h>
#include <sys/syslog.h>
#include <sys/dkbad.h>
#include <sys/conf.h>
#include <sys/timeout.h>
#include <sys/dkio.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <dev/sun/disklabel.h>
#include <machine/conf.h>

#include <sparc/dev/xdreg.h>
#include <sparc/dev/xdvar.h>
#include <sparc/sparc/vaddrs.h>
#include <sparc/sparc/cpuvar.h>

/*
 * macros
 */

/*
 * XDC_TWAIT: add iorq "N" to tail of SC's wait queue
 */
#define XDC_TWAIT(SC, N) { \
	(SC)->waitq[(SC)->waitend] = (N); \
	(SC)->waitend = ((SC)->waitend + 1) % XDC_MAXIOPB; \
	(SC)->nwait++; \
}

/*
 * XDC_HWAIT: add iorq "N" to head of SC's wait queue
 */
#define XDC_HWAIT(SC, N) { \
	(SC)->waithead = ((SC)->waithead == 0) ? \
		(XDC_MAXIOPB - 1) : ((SC)->waithead - 1); \
	(SC)->waitq[(SC)->waithead] = (N); \
	(SC)->nwait++; \
}

/*
 * XDC_GET_WAITER: gets the first request waiting on the waitq
 * and removes it (so it can be submitted)
 */
#define XDC_GET_WAITER(XDCSC, RQ) { \
	(RQ) = (XDCSC)->waitq[(XDCSC)->waithead]; \
	(XDCSC)->waithead = ((XDCSC)->waithead + 1) % XDC_MAXIOPB; \
	xdcsc->nwait--; \
}

/*
 * XDC_FREE: add iorq "N" to SC's free list
 */
#define XDC_FREE(SC, N) { \
	(SC)->freereq[(SC)->nfree++] = (N); \
	(SC)->reqs[N].mode = 0; \
	if ((SC)->nfree == 1) wakeup(&(SC)->nfree); \
}


/*
 * XDC_RQALLOC: allocate an iorq off the free list (assume nfree > 0).
 */
#define XDC_RQALLOC(XDCSC) (XDCSC)->freereq[--((XDCSC)->nfree)]

/*
 * XDC_GO: start iopb ADDR (DVMA addr in a u_long) on XDC
 */
#define XDC_GO(XDC, ADDR) { \
	(XDC)->xdc_iopbaddr0 = ((ADDR) & 0xff); \
	(ADDR) = ((ADDR) >> 8); \
	(XDC)->xdc_iopbaddr1 = ((ADDR) & 0xff); \
	(ADDR) = ((ADDR) >> 8); \
	(XDC)->xdc_iopbaddr2 = ((ADDR) & 0xff); \
	(ADDR) = ((ADDR) >> 8); \
	(XDC)->xdc_iopbaddr3 = (ADDR); \
	(XDC)->xdc_iopbamod = XDC_ADDRMOD; \
	(XDC)->xdc_csr = XDC_ADDIOPB; /* go! */ \
}

/*
 * XDC_WAIT: wait for XDC's csr "BITS" to come on in "TIME".
 *   LCV is a counter.  If it goes to zero then we timed out.
 */
#define XDC_WAIT(XDC, LCV, TIME, BITS) { \
	(LCV) = (TIME); \
	while ((LCV) > 0) { \
		if ((XDC)->xdc_csr & (BITS)) break; \
		(LCV) = (LCV) - 1; \
		DELAY(1); \
	} \
}

/*
 * XDC_DONE: don't need IORQ, get error code and free (done after xdc_cmd)
 */
#define XDC_DONE(SC,RQ,ER) { \
	if ((RQ) == XD_ERR_FAIL) { \
		(ER) = (RQ); \
	} else { \
		if ((SC)->ndone-- == XDC_SUBWAITLIM) \
		wakeup(&(SC)->ndone); \
		(ER) = (SC)->reqs[RQ].errno; \
		XDC_FREE((SC), (RQ)); \
	} \
}

/*
 * XDC_ADVANCE: advance iorq's pointers by a number of sectors
 */
#define XDC_ADVANCE(IORQ, N) { \
	if (N) { \
		(IORQ)->sectcnt -= (N); \
		(IORQ)->blockno += (N); \
		(IORQ)->dbuf += ((N)*XDFM_BPS); \
	} \
}

/*
 * note - addresses you can sleep on:
 *   [1] & of xd_softc's "state" (waiting for a chance to attach a drive)
 *   [2] & of xdc_softc's "nfree" (waiting for a free iorq/iopb)
 *   [3] & of xdc_softc's "ndone" (waiting for number of done iorq/iopb's
 *                                 to drop below XDC_SUBWAITLIM)
 *   [4] & an iorq (waiting for an XD_SUB_WAIT iorq to finish)
 */


/*
 * function prototypes
 * "xdc_*" functions are internal, all others are external interfaces
 */

extern int pil_to_vme[];	/* from obio.c */

/* internals */
int	xdc_cmd(struct xdc_softc *, int, int, int, int, int, char *, int);
const char *xdc_e2str(int);
int	xdc_error(struct xdc_softc *, struct xd_iorq *,
		   struct xd_iopb *, int, int);
void	xdc_perror(struct xd_iorq *, struct xd_iopb *, int);
int	xdc_piodriver(struct xdc_softc *, int, int);
int	xdc_remove_iorq(struct xdc_softc *);
int	xdc_reset(struct xdc_softc *, int, int, int, struct xd_softc *);
inline void xdc_rqinit(struct xd_iorq *, struct xdc_softc *,
			    struct xd_softc *, int, u_long, int,
			    caddr_t, struct buf *);
void	xdc_rqtopb(struct xd_iorq *, struct xd_iopb *, int, int);
void	xdc_start(struct xdc_softc *, int);
int	xdc_startbuf(struct xdc_softc *);
int	xdc_submit_iorq(struct xdc_softc *, int, int);
void	xdc_tick(void *);
void	xdc_xdreset(struct xdc_softc *, struct xd_softc *);

/* machine interrupt hook */
int	xdcintr(void *);

/* autoconf */
int	xdcmatch(struct device *, void *, void *);
void	xdcattach(struct device *, struct device *, void *);
int	xdmatch(struct device *, void *, void *);
void	xdattach(struct device *, struct device *, void *);

static	void xddummystrat(struct buf *);
int	xdgetdisklabel(dev_t, struct xd_softc *, struct disklabel *, int);

/*
 * cfdrivers: device driver interface to autoconfig
 */

struct cfattach xdc_ca = {
	sizeof(struct xdc_softc), xdcmatch, xdcattach
};


struct cfdriver xdc_cd = {
	NULL, "xdc", DV_DULL
};

struct cfattach xd_ca = {
	sizeof(struct xd_softc), xdmatch, xdattach
};

struct cfdriver xd_cd = {
	NULL, "xd", DV_DISK
};

struct xdc_attach_args {	/* this is the "aux" args to xdattach */
	int	driveno;	/* unit number */
	char	*buf;		/* scratch buffer for reading disk label */
	char	*dvmabuf;	/* DVMA address of above */
	int	fullmode;	/* submit mode */
	int	booting;	/* are we booting or not? */
};

static void
xddummystrat(bp)
	struct buf *bp;
{
	struct xd_softc *xd;
	size_t sz;

	xd = (struct xd_softc *)xd_cd.cd_devs[DISKUNIT(bp->b_dev)];
	sz = MIN(bp->b_bcount, XDFM_BPS);
	bcopy(xd->xd_labeldata, bp->b_data, sz);
	bp->b_resid = bp->b_bcount - sz;
	if (bp->b_resid != 0) {
		bp->b_flags |= B_ERROR;
		bp->b_error = EIO;
	}
	bp->b_flags |= B_DONE;
}

int
xdgetdisklabel(dev, xd, lp, spoofonly)
	dev_t dev;
	struct xd_softc *xd;
	struct disklabel *lp;
	int spoofonly;
{
	int error;

	bzero(lp, sizeof(struct disklabel));
	/* Required parameters for readdisklabel() */
	lp->d_secsize = XDFM_BPS;
	if (xd->state == XD_DRIVE_ATTACHING || xd->state == XD_DRIVE_NOLABEL) {
		/* needs to be nonzero */
		lp->d_secpercyl = 1;
	} else {
		/*
		 * Disk geometry is known from a previously found label.
		 * Use it.
		 */
		lp->d_ntracks = xd->nhead;
		lp->d_nsectors = xd->nsect;
		lp->d_ncylinders = xd->ncyl;
		lp->d_acylinders = xd->acyl;
		lp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;
		DL_SETDSIZE(lp, (u_int64_t)lp->d_secpercyl * lp->d_ncylinders);
	}
	lp->d_type = DTYPE_SMD;
	lp->d_version = 1;

	/* These are as defined in <ufs/ffs/fs.h> */
	lp->d_bbsize = 8192; /* BBSIZE */
	lp->d_sbsize = 8192; /* SBSIZE */

	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = dkcksum(lp);

	error = readdisklabel(DISKLABELDEV(dev),
	    xd->state == XD_DRIVE_ATTACHING ? xddummystrat : xdstrategy,
	    lp, spoofonly);
	if (error)
		return error;

	/*
	 * If a label was found, get our geometry from it.
	 */
	if (xd->state == XD_DRIVE_ATTACHING || xd->state == XD_DRIVE_NOLABEL) {
		/*
		 * Note that this relies upon pcyl == cyl + acyl, and will
		 * ignore the explicit pcyl value from the converted SunOS
		 * label.
		 */
		xd->pcyl = lp->d_ncylinders + lp->d_acylinders;
		xd->ncyl = lp->d_ncylinders;
		xd->acyl = lp->d_acylinders;
		xd->nhead = lp->d_ntracks;
		xd->nsect = lp->d_nsectors;
		xd->sectpercyl = lp->d_secpercyl;
	}

	return 0;
}

/*
 * a u t o c o n f i g   f u n c t i o n s
 */

/*
 * xdcmatch: determine if xdc is present or not.   we do a
 * soft reset to detect the xdc.
 */

int xdcmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;
	struct xdc *xdc;
	int     del = 0;

	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
		return (0);

	switch (ca->ca_bustype) {
	case BUS_OBIO:
	case BUS_SBUS:
	case BUS_VME16:
	default:
		return (0);
	case BUS_VME32:
		xdc = (struct xdc *) ra->ra_vaddr;
		if (probeget((caddr_t) &xdc->xdc_csr, 1) == -1)
			return (0);
		xdc->xdc_csr = XDC_RESET;
		XDC_WAIT(xdc, del, XDC_RESETUSEC, XDC_RESET);
		if (del <= 0)
			return (0);
		return (1);
	}
}

/*
 * xdcattach: attach controller
 */
void
xdcattach(parent, self, aux)
	struct device *parent, *self;
	void   *aux;

{
	struct xdc_softc *xdc = (void *) self;
	struct confargs *ca = aux;
	struct xdc_attach_args xa;
	int     lcv, rqno, err, pri;
	struct xd_iopb_ctrl *ctl;

	/* get addressing and intr level stuff from autoconfig and load it
	 * into our xdc_softc. */

	ca->ca_ra.ra_vaddr = mapiodev(ca->ca_ra.ra_reg, 0, sizeof(struct xdc));

	xdc->xdc = (struct xdc *) ca->ca_ra.ra_vaddr;
	pri = ca->ca_ra.ra_intr[0].int_pri;
	xdc->ipl = pil_to_vme[pri];
	xdc->vector = ca->ca_ra.ra_intr[0].int_vec;
	printf(" pri %d", pri);

	for (lcv = 0; lcv < XDC_MAXDEV; lcv++)
		xdc->sc_drives[lcv] = (struct xd_softc *) 0;

	/* allocate and zero buffers
	 *
	 * note: we simplify the code by allocating the max number of iopbs and
	 * iorq's up front.   thus, we avoid linked lists and the costs
	 * associated with them in exchange for wasting a little memory. */

	xdc->dvmaiopb = (struct xd_iopb *)
	    dvma_malloc(XDC_MAXIOPB * sizeof(struct xd_iopb), &xdc->iopbase,
	      M_NOWAIT | M_ZERO);
	xdc->iopbase = xdc->dvmaiopb; /* XXX TMP HACK */
	/* Setup device view of DVMA address */
	xdc->dvmaiopb = (struct xd_iopb *) ((u_long) xdc->iopbase - DVMA_BASE);

	xdc->reqs = malloc(XDC_MAXIOPB * sizeof(struct xd_iorq), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
	if (xdc->reqs == NULL)
		panic("xdc malloc");

	/* init free list, iorq to iopb pointers, and non-zero fields in the
	 * iopb which never change. */

	for (lcv = 0; lcv < XDC_MAXIOPB; lcv++) {
		xdc->reqs[lcv].iopb = &xdc->iopbase[lcv];
		xdc->freereq[lcv] = lcv;
		xdc->iopbase[lcv].fixd = 1;	/* always the same */
		xdc->iopbase[lcv].naddrmod = XDC_ADDRMOD; /* always the same */
		xdc->iopbase[lcv].intr_vec = xdc->vector; /* always the same */
	}
	xdc->nfree = XDC_MAXIOPB;
	xdc->nrun = 0;
	xdc->waithead = xdc->waitend = xdc->nwait = 0;
	xdc->ndone = 0;

	/* init queue of waiting bufs */
	bufq_init(&xdc->sc_bufq, BUFQ_FIFO);

	/*
	 * section 7 of the manual tells us how to init the controller:
	 * - read controller parameters (6/0)
	 * - write controller parameters (5/0)
	 */

	/* read controller parameters and insure we have a 753/7053 */

	rqno = xdc_cmd(xdc, XDCMD_RDP, XDFUN_CTL, 0, 0, 0, 0, XD_SUB_POLL);
	if (rqno == XD_ERR_FAIL) {
		printf(": couldn't read controller params\n");
		return;		/* shouldn't ever happen */
	}
	ctl = (struct xd_iopb_ctrl *) & xdc->iopbase[rqno];
	if (ctl->ctype != XDCT_753) {
		if (xdc->reqs[rqno].errno)
			printf(": %s: ", xdc_e2str(xdc->reqs[rqno].errno));
		printf(": doesn't identify as a 753/7053\n");
		XDC_DONE(xdc, rqno, err);
		return;
	}
	printf(": Xylogics 753/7053, PROM=0x%x.%02x.%02x\n",
	    ctl->eprom_partno, ctl->eprom_lvl, ctl->eprom_rev);
	XDC_DONE(xdc, rqno, err);

	/* now write controller parameters (xdc_cmd sets all params for us) */

	rqno = xdc_cmd(xdc, XDCMD_WRP, XDFUN_CTL, 0, 0, 0, 0, XD_SUB_POLL);
	XDC_DONE(xdc, rqno, err);
	if (err) {
		printf("%s: controller config error: %s\n",
			xdc->sc_dev.dv_xname, xdc_e2str(err));
		return;
	}
	/* link in interrupt with higher level software */

	xdc->sc_ih.ih_fun = xdcintr;
	xdc->sc_ih.ih_arg = xdc;
	vmeintr_establish(ca->ca_ra.ra_intr[0].int_vec,
	    ca->ca_ra.ra_intr[0].int_pri, &xdc->sc_ih, IPL_BIO,
	    self->dv_xname);

	/* now we must look for disks using autoconfig */
	xa.dvmabuf = (char *)dvma_malloc(XDFM_BPS, &xa.buf, M_NOWAIT);
	xa.fullmode = XD_SUB_POLL;
	xa.booting = 1;

	if (ca->ca_ra.ra_bp && ca->ca_ra.ra_bp->val[0] == -1 &&
	    ca->ca_ra.ra_bp->val[1] == xdc->sc_dev.dv_unit) {
		bootpath_store(1, ca->ca_ra.ra_bp + 1); /* advance bootpath */
	}

	for (xa.driveno = 0; xa.driveno < XDC_MAXDEV; xa.driveno++)
		(void) config_found(self, (void *) &xa, NULL);

	dvma_free(xa.dvmabuf, XDFM_BPS, &xa.buf);
	bootpath_store(1, NULL);

	/* start the watchdog clock */
	timeout_set(&xdc->xdc_tick_tmo, xdc_tick, xdc);
	timeout_add(&xdc->xdc_tick_tmo, XDC_TICKCNT);

}

/*
 * xdmatch: probe for disk.
 *
 * note: we almost always say disk is present.   this allows us to
 * spin up and configure a disk after the system is booted (we can
 * call xdattach!).
 */
int
xdmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct cfdata *cf = vcf;
	struct xdc_attach_args *xa = aux;

	/* looking for autoconf wildcard or exact match */

	if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != xa->driveno)
		return 0;

	return 1;

}

/*
 * xdattach: attach a disk.   this can be called from autoconf and also
 * from xdopen/xdstrategy.
 */
void
xdattach(parent, self, aux)
	struct device *parent, *self;
	void   *aux;

{
	struct xd_softc *xd = (void *) self;
	struct xdc_softc *xdc = (void *) parent;
	struct xdc_attach_args *xa = aux;
	int     rqno, err, spt = 0, mb, blk, lcv, fmode, s = 0, newstate;
	struct xd_iopb_drive *driopb;
	struct dkbad *dkb;
	struct bootpath *bp;

	/*
	 * Always re-initialize the disk structure.  We want statistics
	 * to start with a clean slate.
	 */
	bzero(&xd->sc_dk, sizeof(xd->sc_dk));
	xd->sc_dk.dk_name = xd->sc_dev.dv_xname;

	/* if booting, init the xd_softc */

	if (xa->booting) {
		xd->state = XD_DRIVE_UNKNOWN;	/* to start */
		xd->flags = 0;
		xd->parent = xdc;
	}
	xd->xd_drive = xa->driveno;
	fmode = xa->fullmode;
	xdc->sc_drives[xa->driveno] = xd;

	/* if not booting, make sure we are the only process in the attach for
	 * this drive.   if locked out, sleep on it. */

	if (!xa->booting) {
		s = splbio();
		while (xd->state == XD_DRIVE_ATTACHING) {
			if (tsleep(&xd->state, PRIBIO, "xdattach", 0)) {
				splx(s);
				return;
			}
		}
		printf("%s at %s",
			xd->sc_dev.dv_xname, xd->parent->sc_dev.dv_xname);
	}
	/* we now have control */

	xd->state = XD_DRIVE_ATTACHING;
	newstate = XD_DRIVE_UNKNOWN;

	/* first try and reset the drive */

	rqno = xdc_cmd(xdc, XDCMD_RST, 0, xd->xd_drive, 0, 0, 0, fmode);
	XDC_DONE(xdc, rqno, err);
	if (err == XD_ERR_NRDY) {
		printf(" drive %d: off-line\n", xa->driveno);
		goto done;
	}
	if (err) {
		printf(": ERROR 0x%02x (%s)\n", err, xdc_e2str(err));
		goto done;
	}
	printf(" drive %d: ready\n", xa->driveno);

	/* now set format parameters */

	rqno = xdc_cmd(xdc, XDCMD_WRP, XDFUN_FMT, xd->xd_drive, 0, 0, 0, fmode);
	XDC_DONE(xdc, rqno, err);
	if (err) {
		printf("%s: write format parameters failed: %s\n",
			xd->sc_dev.dv_xname, xdc_e2str(err));
		goto done;
	}

	/* get drive parameters */
	rqno = xdc_cmd(xdc, XDCMD_RDP, XDFUN_DRV, xd->xd_drive, 0, 0, 0, fmode);
	if (rqno != XD_ERR_FAIL) {
		driopb = (struct xd_iopb_drive *) & xdc->iopbase[rqno];
		spt = driopb->sectpertrk;
	}
	XDC_DONE(xdc, rqno, err);
	if (err) {
		printf("%s: read drive parameters failed: %s\n",
			xd->sc_dev.dv_xname, xdc_e2str(err));
		goto done;
	}

	/*
	 * now set drive parameters (to semi-bogus values) so we can read the
	 * disk label.
	 */
	xd->pcyl = xd->ncyl = 1;
	xd->acyl = 0;
	xd->nhead = 1;
	xd->nsect = 1;
	xd->sectpercyl = 1;
	for (lcv = 0; lcv < NBT_BAD; lcv++)	/* init empty bad144 table */
		xd->dkb.bt_bad[lcv].bt_cyl = xd->dkb.bt_bad[lcv].bt_trksec = 0xffff;
	rqno = xdc_cmd(xdc, XDCMD_WRP, XDFUN_DRV, xd->xd_drive, 0, 0, 0, fmode);
	XDC_DONE(xdc, rqno, err);
	if (err) {
		printf("%s: write drive parameters failed: %s\n",
			xd->sc_dev.dv_xname, xdc_e2str(err));
		goto done;
	}

	/* read disk label */
	rqno = xdc_cmd(xdc, XDCMD_RD, 0, xd->xd_drive, 0, 1, xa->dvmabuf, fmode);
	XDC_DONE(xdc, rqno, err);
	if (err) {
		printf("%s: reading disk label failed: %s\n",
			xd->sc_dev.dv_xname, xdc_e2str(err));
		goto done;
	}
	newstate = XD_DRIVE_NOLABEL;

	xd->hw_spt = spt;
	/* Attach the disk: must be before getdisklabel to malloc label */
	disk_attach(&xd->sc_dev, &xd->sc_dk);

	xd->xd_labeldata = xa->buf;
	if (xdgetdisklabel(MAKEDISKDEV(0, xd->sc_dev.dv_unit, 0), xd,
	    xd->sc_dk.dk_label, 0) != 0) {
		printf("%s: no label, unknown geometry\n", xd->sc_dev.dv_xname);
		goto done;
	}

	/* inform the user of what is up */
	printf("%s: <%s>, pcyl %d, hw_spt %d\n", xd->sc_dev.dv_xname,
		xa->buf, xd->pcyl, spt);
	mb = xd->ncyl * (xd->nhead * xd->nsect) / (1048576 / XDFM_BPS);
	printf("%s: %dMB, %d cyl, %d head, %d sec, %d bytes/sec\n",
		xd->sc_dev.dv_xname, mb, xd->ncyl, xd->nhead, xd->nsect,
		XDFM_BPS);

	/* now set the real drive parameters! */

	rqno = xdc_cmd(xdc, XDCMD_WRP, XDFUN_DRV, xd->xd_drive, 0, 0, 0, fmode);
	XDC_DONE(xdc, rqno, err);
	if (err) {
		printf("%s: write real drive parameters failed: %s\n",
			xd->sc_dev.dv_xname, xdc_e2str(err));
		goto done;
	}
	newstate = XD_DRIVE_ONLINE;

	/*
	 * read bad144 table. this table resides on the first sector of the
	 * last track of the disk (i.e. second cyl of "acyl" area).
	 */

	blk = (xd->ncyl + xd->acyl - 1) * (xd->nhead * xd->nsect) + /* last cyl */
	    (xd->nhead - 1) * xd->nsect;	/* last head */
	rqno = xdc_cmd(xdc, XDCMD_RD, 0, xd->xd_drive, blk, 1, xa->dvmabuf, fmode);
	XDC_DONE(xdc, rqno, err);
	if (err) {
		printf("%s: reading bad144 failed: %s\n",
			xd->sc_dev.dv_xname, xdc_e2str(err));
		goto done;
	}

	/* check dkbad for sanity */
	dkb = (struct dkbad *) xa->buf;
	for (lcv = 0; lcv < NBT_BAD; lcv++) {
		if ((dkb->bt_bad[lcv].bt_cyl == 0xffff ||
				dkb->bt_bad[lcv].bt_cyl == 0) &&
		     dkb->bt_bad[lcv].bt_trksec == 0xffff)
			continue;	/* blank */
		if (dkb->bt_bad[lcv].bt_cyl >= xd->ncyl)
			break;
		if ((dkb->bt_bad[lcv].bt_trksec >> 8) >= xd->nhead)
			break;
		if ((dkb->bt_bad[lcv].bt_trksec & 0xff) >= xd->nsect)
			break;
	}
	if (lcv != NBT_BAD) {
		printf("%s: warning: invalid bad144 sector!\n",
			xd->sc_dev.dv_xname);
	} else {
		bcopy(xa->buf, &xd->dkb, XDFM_BPS);
	}

	if (xa->booting) {
		/* restore bootpath! (do this via attach_args again?)*/
		bp = bootpath_store(0, NULL);
		if (bp && strcmp("xd", bp->name) == 0 &&
						xd->xd_drive == bp->val[0])
			bp->dev = &xd->sc_dev;
	}

done:
	xd->state = newstate;
	if (!xa->booting) {
		wakeup(&xd->state);
		splx(s);
	}
}

/*
 * end of autoconfig functions
 */

/*
 * { b , c } d e v s w   f u n c t i o n s
 */

/*
 * xdclose: close device
 */
int
xdclose(dev, flag, fmt, p)
	dev_t   dev;
	int     flag, fmt;
	struct proc *p;
{
	struct xd_softc *xd = xd_cd.cd_devs[DISKUNIT(dev)];
	int     part = DISKPART(dev);

	/* clear mask bits */

	switch (fmt) {
	case S_IFCHR:
		xd->sc_dk.dk_copenmask &= ~(1 << part);
		break;
	case S_IFBLK:
		xd->sc_dk.dk_bopenmask &= ~(1 << part);
		break;
	}
	xd->sc_dk.dk_openmask = xd->sc_dk.dk_copenmask | xd->sc_dk.dk_bopenmask;

	return 0;
}

/*
 * xddump: crash dump system
 */
int
xddump(dev, blkno, va, size)
	dev_t dev;
	daddr_t blkno;
	caddr_t va;
	size_t size;
{
	int     unit, part;
	struct xd_softc *xd;

	unit = DISKUNIT(dev);
	if (unit >= xd_cd.cd_ndevs)
		return ENXIO;
	part = DISKPART(dev);

	xd = xd_cd.cd_devs[unit];

	printf("%s%c: crash dump not supported (yet)\n", xd->sc_dev.dv_xname,
	    'a' + part);

	return ENXIO;
}

/*
 * xdioctl: ioctls on XD drives.   based on ioctl's of other netbsd disks.
 */
int
xdioctl(dev, command, addr, flag, p)
	dev_t   dev;
	u_long  command;
	caddr_t addr;
	int     flag;
	struct proc *p;

{
	struct xd_softc *xd;
	int     error, s, unit;

	unit = DISKUNIT(dev);

	if (unit >= xd_cd.cd_ndevs || (xd = xd_cd.cd_devs[unit]) == NULL)
		return (ENXIO);

	/* switch on ioctl type */

	switch (command) {
	case DIOCSBAD:		/* set bad144 info */
		if ((flag & FWRITE) == 0)
			return EBADF;
		s = splbio();
		bcopy(addr, &xd->dkb, sizeof(xd->dkb));
		splx(s);
		return 0;

	case DIOCGPDINFO:
		xdgetdisklabel(dev, xd, (struct disklabel *)addr, 1);
		return 0;

	case DIOCGDINFO:	/* get disk label */
		bcopy(xd->sc_dk.dk_label, addr, sizeof(struct disklabel));
		return 0;

	case DIOCGPART:	/* get partition info */
		((struct partinfo *)addr)->disklab = xd->sc_dk.dk_label;
		((struct partinfo *)addr)->part =
		    &xd->sc_dk.dk_label->d_partitions[DISKPART(dev)];
		return 0;

	case DIOCWDINFO:	/* write disk label */
	case DIOCSDINFO:	/* set disk label */
		if ((flag & FWRITE) == 0)
			return EBADF;
		error = setdisklabel(xd->sc_dk.dk_label,
		    (struct disklabel *)addr, /* xd->sc_dk.dk_openmask : */ 0);
		if (error == 0) {
			if (xd->state == XD_DRIVE_NOLABEL)
				xd->state = XD_DRIVE_ONLINE;

			if (command == DIOCWDINFO) {
				/*
				 * Simulate opening partition 0 so write
				 * succeeds.
				 */
				xd->sc_dk.dk_openmask |= (1 << 0);
				error = writedisklabel(DISKLABELDEV(dev),
				    xdstrategy, xd->sc_dk.dk_label);
				xd->sc_dk.dk_openmask = xd->sc_dk.dk_copenmask |
				    xd->sc_dk.dk_bopenmask;
			}
		}
		return error;

	default:
		return ENOTTY;
	}
}
/*
 * xdopen: open drive
 */

int
xdopen(dev, flag, fmt, p)
	dev_t   dev;
	int     flag, fmt;
	struct proc *p;
{
	int     unit, part;
	struct xd_softc *xd;
	struct xdc_attach_args xa;

	/* first, could it be a valid target? */

	unit = DISKUNIT(dev);
	if (unit >= xd_cd.cd_ndevs || (xd = xd_cd.cd_devs[unit]) == NULL)
		return (ENXIO);
	part = DISKPART(dev);

	/* do we need to attach the drive? */

	if (xd->state == XD_DRIVE_UNKNOWN) {
		xa.driveno = xd->xd_drive;
		xa.dvmabuf = (char *)dvma_malloc(XDFM_BPS, &xa.buf, M_NOWAIT);
		xa.fullmode = XD_SUB_WAIT;
		xa.booting = 0;
		xdattach((struct device *) xd->parent, (struct device *) xd, &xa);
		dvma_free(xa.dvmabuf, XDFM_BPS, &xa.buf);
		if (xd->state == XD_DRIVE_UNKNOWN) {
			return (EIO);
		}
	}
	/* check for partition */

	if (part != RAW_PART &&
	    (part >= xd->sc_dk.dk_label->d_npartitions ||
		xd->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {
		return (ENXIO);
	}
	/* set open masks */

	switch (fmt) {
	case S_IFCHR:
		xd->sc_dk.dk_copenmask |= (1 << part);
		break;
	case S_IFBLK:
		xd->sc_dk.dk_bopenmask |= (1 << part);
		break;
	}
	xd->sc_dk.dk_openmask = xd->sc_dk.dk_copenmask | xd->sc_dk.dk_bopenmask;

	return 0;
}

int
xdread(dev, uio, flags)
	dev_t   dev;
	struct uio *uio;
	int flags;
{

	return (physio(xdstrategy, dev, B_READ, minphys, uio));
}

int
xdwrite(dev, uio, flags)
	dev_t   dev;
	struct uio *uio;
	int flags;
{

	return (physio(xdstrategy, dev, B_WRITE, minphys, uio));
}


/*
 * xdsize: return size of a partition for a dump
 */

daddr_t
xdsize(dev)
	dev_t   dev;

{
	struct xd_softc *xdsc;
	int     unit, part, omask;
	daddr_t size;

	/* valid unit? */
	unit = DISKUNIT(dev);
	if (unit >= xd_cd.cd_ndevs || (xdsc = xd_cd.cd_devs[unit]) == NULL)
		return (-1);

	part = DISKPART(dev);
	omask = xdsc->sc_dk.dk_openmask & (1 << part);

	if (omask == 0 && xdopen(dev, 0, S_IFBLK, NULL) != 0)
		return (-1);

	/* do it */
	if (xdsc->sc_dk.dk_label->d_partitions[part].p_fstype != FS_SWAP)
		size = -1;	/* only give valid size for swap partitions */
	else
		size = DL_GETPSIZE(&xdsc->sc_dk.dk_label->d_partitions[part]) *
		    (xdsc->sc_dk.dk_label->d_secsize / DEV_BSIZE);
	if (omask == 0 && xdclose(dev, 0, S_IFBLK, NULL) != 0)
		return (-1);
	return (size);
}
/*
 * xdstrategy: buffering system interface to xd.
 */

void
xdstrategy(bp)
	struct buf *bp;

{
	struct xd_softc *xd;
	struct xdc_softc *parent;
	int     s, unit;
	struct xdc_attach_args xa;

	unit = DISKUNIT(bp->b_dev);

	/* check for live device */

	if (unit >= xd_cd.cd_ndevs || (xd = xd_cd.cd_devs[unit]) == 0) {
		bp->b_error = EINVAL;
		goto bad;
	}
	/* do we need to attach the drive? */

	if (xd->state == XD_DRIVE_UNKNOWN) {
		xa.driveno = xd->xd_drive;
		xa.dvmabuf = (char *)dvma_malloc(XDFM_BPS, &xa.buf, M_NOWAIT);
		xa.fullmode = XD_SUB_WAIT;
		xa.booting = 0;
		xdattach((struct device *)xd->parent, (struct device *)xd, &xa);
		dvma_free(xa.dvmabuf, XDFM_BPS, &xa.buf);
		if (xd->state == XD_DRIVE_UNKNOWN) {
			bp->b_error = EIO;
			goto bad;
		}
	}
	if (xd->state != XD_DRIVE_ONLINE && DISKPART(bp->b_dev) != RAW_PART) {
		/* no I/O to unlabeled disks, unless raw partition */
		bp->b_error = EIO;
		goto bad;
	}

	/* Validate the request. */
	if (bounds_check_with_label(bp, xd->sc_dk.dk_label) == -1)
		goto done;

	/*
	 * now we know we have a valid buf structure that we need to do I/O
	 * on.
	 */
	parent = xd->parent;
	bufq_queue(&parent->sc_bufq, bp);

	s = splbio();
	while (parent->nfree > 0 && bufq_peek(&parent->sc_bufq)) {
		if (xdc_startbuf(parent) != XD_ERR_AOK)
			break;
	}
	splx(s);
	return;

 bad:				/* tells upper layers we have an error */
	bp->b_flags |= B_ERROR;
	bp->b_resid = bp->b_bcount;
 done:				/* tells upper layers we are done with this
				 * buf */
	s = splbio();
	biodone(bp);
	splx(s);
}
/*
 * end of {b,c}devsw functions
 */

/*
 * i n t e r r u p t   f u n c t i o n
 *
 * xdcintr: hardware interrupt.
 */
int
xdcintr(v)
	void   *v;

{
	struct xdc_softc *xdcsc = v;

	/* remove as many done IOPBs as possible */

	xdc_remove_iorq(xdcsc);

	/* start any iorq's already waiting */

	xdc_start(xdcsc, XDC_MAXIOPB);

	/* fill up any remaining iorq's with queue'd buffers */

	while (xdcsc->nfree > 0 && bufq_peek(&xdcsc->sc_bufq))
		if (xdc_startbuf(xdcsc) != XD_ERR_AOK)
			break;

	return (1);
}
/*
 * end of interrupt function
 */

/*
 * i n t e r n a l   f u n c t i o n s
 */

/*
 * xdc_rqinit: fill out the fields of an I/O request
 */

inline void
xdc_rqinit(rq, xdc, xd, md, blk, cnt, db, bp)
	struct xd_iorq *rq;
	struct xdc_softc *xdc;
	struct xd_softc *xd;
	int     md;
	u_long  blk;
	int     cnt;
	caddr_t db;
	struct buf *bp;
{
	rq->xdc = xdc;
	rq->xd = xd;
	rq->ttl = XDC_MAXTTL + 10;
	rq->mode = md;
	rq->tries = rq->errno = rq->lasterror = 0;
	rq->blockno = blk;
	rq->sectcnt = cnt;
	rq->dbuf = rq->dbufbase = db;
	rq->buf = bp;
}
/*
 * xdc_rqtopb: load up an IOPB based on an iorq
 */

void
xdc_rqtopb(iorq, iopb, cmd, subfun)
	struct xd_iorq *iorq;
	struct xd_iopb *iopb;
	int     cmd, subfun;

{
	u_long  block, dp;

	/* standard stuff */

	iopb->errs = iopb->done = 0;
	iopb->comm = cmd;
	iopb->errno = iopb->status = 0;
	iopb->subfun = subfun;
	if (iorq->xd)
		iopb->unit = iorq->xd->xd_drive;
	else
		iopb->unit = 0;

	/* check for alternate IOPB format */

	if (cmd == XDCMD_WRP) {
		switch (subfun) {
		case XDFUN_CTL:{
			struct xd_iopb_ctrl *ctrl =
				(struct xd_iopb_ctrl *) iopb;
			iopb->lll = 0;
			iopb->intl = (XD_STATE(iorq->mode) == XD_SUB_POLL)
					? 0
					: iorq->xdc->ipl;
			ctrl->param_a = XDPA_TMOD | XDPA_DACF;
			ctrl->param_b = XDPB_ROR | XDPB_TDT_3_2USEC;
			ctrl->param_c = XDPC_OVS | XDPC_COP | XDPC_ASR |
					XDPC_RBC | XDPC_ECC2;
			ctrl->throttle = XDC_THROTTLE;
#ifdef __sparc__
			if (CPU_ISSUN4 && cpuinfo.cpu_type == CPUTYP_4_300)
				ctrl->delay = XDC_DELAY_4_300;
			else
				ctrl->delay = XDC_DELAY_SPARC;
#endif
#ifdef sun3
			ctrl->delay = XDC_DELAY_SUN3;
#endif
			break;
			}
		case XDFUN_DRV:{
			struct xd_iopb_drive *drv =
				(struct xd_iopb_drive *)iopb;
			/* we assume that the disk label has the right
			 * info */
			if (XD_STATE(iorq->mode) == XD_SUB_POLL)
				drv->dparam_ipl = (XDC_DPARAM << 3);
			else
				drv->dparam_ipl = (XDC_DPARAM << 3) |
						  iorq->xdc->ipl;
			drv->maxsect = iorq->xd->nsect - 1;
			drv->maxsector = drv->maxsect;
			/* note: maxsector != maxsect only if you are
			 * doing cyl sparing */
			drv->headoff = 0;
			drv->maxcyl = iorq->xd->pcyl - 1;
			drv->maxhead = iorq->xd->nhead - 1;
			break;
			}
		case XDFUN_FMT:{
			struct xd_iopb_format *form =
					(struct xd_iopb_format *) iopb;
			if (XD_STATE(iorq->mode) == XD_SUB_POLL)
				form->interleave_ipl = (XDC_INTERLEAVE << 3);
			else
				form->interleave_ipl = (XDC_INTERLEAVE << 3) |
						       iorq->xdc->ipl;
			form->field1 = XDFM_FIELD1;
			form->field2 = XDFM_FIELD2;
			form->field3 = XDFM_FIELD3;
			form->field4 = XDFM_FIELD4;
			form->bytespersec = XDFM_BPS;
			form->field6 = XDFM_FIELD6;
			form->field7 = XDFM_FIELD7;
			break;
			}
		}
	} else {

		/* normal IOPB case (harmless to RDP command) */

		iopb->lll = 0;
		iopb->intl = (XD_STATE(iorq->mode) == XD_SUB_POLL)
				? 0
				: iorq->xdc->ipl;
		iopb->sectcnt = iorq->sectcnt;
		block = iorq->blockno;
		if (iorq->xd == NULL || block == 0) {
			iopb->sectno = iopb->headno = iopb->cylno = 0;
		} else {
			iopb->sectno = block % iorq->xd->nsect;
			block = block / iorq->xd->nsect;
			iopb->headno = block % iorq->xd->nhead;
			block = block / iorq->xd->nhead;
			iopb->cylno = block;
		}
		dp = (u_long) iorq->dbuf - DVMA_BASE;
		dp = iopb->daddr = (iorq->dbuf == NULL) ? 0 : dp;
		iopb->addrmod = ((dp + (XDFM_BPS * iorq->sectcnt)) > 0x1000000)
					? XDC_ADDRMOD32
					: XDC_ADDRMOD;
	}
}

/*
 * xdc_cmd: front end for POLL'd and WAIT'd commands.  Returns rqno.
 * If you've already got an IORQ, you can call submit directly (currently
 * there is no need to do this).    NORM requests are handled separately.
 */
int
xdc_cmd(xdcsc, cmd, subfn, unit, block, scnt, dptr, fullmode)
	struct xdc_softc *xdcsc;
	int     cmd, subfn, unit, block, scnt;
	char   *dptr;
	int     fullmode;

{
	int     rqno, submode = XD_STATE(fullmode), retry;
	struct xd_iorq *iorq;
	struct xd_iopb *iopb;

	/* get iorq/iopb */
	switch (submode) {
	case XD_SUB_POLL:
		while (xdcsc->nfree == 0) {
			if (xdc_piodriver(xdcsc, 0, 1) != XD_ERR_AOK)
				return (XD_ERR_FAIL);
		}
		break;
	case XD_SUB_WAIT:
		retry = 1;
		while (retry) {
			while (xdcsc->nfree == 0) {
			    if (tsleep(&xdcsc->nfree, PRIBIO, "xdnfree", 0))
				return (XD_ERR_FAIL);
			}
			while (xdcsc->ndone > XDC_SUBWAITLIM) {
			    if (tsleep(&xdcsc->ndone, PRIBIO, "xdsubwait", 0))
				return (XD_ERR_FAIL);
			}
			if (xdcsc->nfree)
				retry = 0;	/* got it */
		}
		break;
	default:
		return (XD_ERR_FAIL);	/* illegal */
	}
	if (xdcsc->nfree == 0)
		panic("xdcmd nfree");
	rqno = XDC_RQALLOC(xdcsc);
	iorq = &xdcsc->reqs[rqno];
	iopb = iorq->iopb;


	/* init iorq/iopb */

	xdc_rqinit(iorq, xdcsc,
	    (unit == XDC_NOUNIT) ? NULL : xdcsc->sc_drives[unit],
	    fullmode, block, scnt, dptr, NULL);

	/* load IOPB from iorq */

	xdc_rqtopb(iorq, iopb, cmd, subfn);

	/* submit it for processing */

	xdc_submit_iorq(xdcsc, rqno, fullmode);	/* error code will be in iorq */

	return (rqno);
}
/*
 * xdc_startbuf
 * start a buffer running, assumes nfree > 0
 */

int
xdc_startbuf(xdcsc)
	struct xdc_softc *xdcsc;

{
	int     rqno, partno;
	struct xd_softc *xdsc;
	struct xd_iorq *iorq;
	struct xd_iopb *iopb;
	struct buf *bp;
	u_long  block;
	caddr_t dbuf;

	if (!xdcsc->nfree)
		panic("xdc_startbuf free");
	rqno = XDC_RQALLOC(xdcsc);
	iorq = &xdcsc->reqs[rqno];
	iopb = iorq->iopb;

	/* get buf */
	bp = bufq_dequeue(&xdcsc->sc_bufq);
	if (bp == NULL)
		panic("xdc_startbuf bp");

	xdsc = xdcsc->sc_drives[DISKUNIT(bp->b_dev)];
	partno = DISKPART(bp->b_dev);
#ifdef XDC_DEBUG
	printf("xdc_startbuf: %s%c: %s block %lld\n",
	    xdsc->sc_dev.dv_xname, 'a' + partno,
	    (bp->b_flags & B_READ) ? "read" : "write", (long long)bp->b_blkno);
	printf("xdc_startbuf: b_bcount %d, b_data 0x%x\n",
	    bp->b_bcount, bp->b_data);
#endif

	/*
	 * load request.  we have to calculate the correct block number based
	 * on partition info.
	 *
	 * note that iorq points to the buffer as mapped into DVMA space,
	 * where as the bp->b_data points to its non-DVMA mapping.
	 */

	block = bp->b_blkno + ((partno == RAW_PART) ? 0 :
	    DL_GETPOFFSET(&xdsc->sc_dk.dk_label->d_partitions[partno]));

	dbuf = kdvma_mapin(bp->b_data, bp->b_bcount, 0);
	if (dbuf == NULL) {	/* out of DVMA space */
		printf("%s: warning: out of DVMA space\n",
			xdcsc->sc_dev.dv_xname);
		XDC_FREE(xdcsc, rqno);
		bufq_queue(&xdcsc->sc_bufq, bp); /* put at end of queue */
		return (XD_ERR_FAIL);	/* XXX: need some sort of
					 * call-back scheme here? */
	}

	/* init iorq and load iopb from it */

	xdc_rqinit(iorq, xdcsc, xdsc, XD_SUB_NORM | XD_MODE_VERBO, block,
	    bp->b_bcount / XDFM_BPS, dbuf, bp);

	xdc_rqtopb(iorq, iopb, (bp->b_flags & B_READ) ? XDCMD_RD : XDCMD_WR, 0);

	/* Instrumentation. */
	disk_busy(&xdsc->sc_dk);

	/* now submit [note that xdc_submit_iorq can never fail on NORM reqs] */

	xdc_submit_iorq(xdcsc, rqno, XD_SUB_NORM);
	return (XD_ERR_AOK);
}


/*
 * xdc_submit_iorq: submit an iorq for processing.  returns XD_ERR_AOK
 * if ok.  if it fail returns an error code.  type is XD_SUB_*.
 *
 * note: caller frees iorq in all cases except NORM
 *
 * return value:
 *   NORM: XD_AOK (req pending), XD_FAIL (couldn't submit request)
 *   WAIT: XD_AOK (success), <error-code> (failed)
 *   POLL: <same as WAIT>
 *   NOQ : <same as NORM>
 *
 * there are three sources for i/o requests:
 * [1] xdstrategy: normal block I/O, using "struct buf" system.
 * [2] autoconfig/crash dump: these are polled I/O requests, no interrupts.
 * [3] open/ioctl: these are I/O requests done in the context of a process,
 *                 and the process should block until they are done.
 *
 * software state is stored in the iorq structure.  each iorq has an
 * iopb structure.  the hardware understands the iopb structure.
 * every command must go through an iopb.  a 7053 can only handle
 * XDC_MAXIOPB (31) active iopbs at one time.  iopbs are allocated in
 * DVMA space at boot up time.  what happens if we run out of iopb's?
 * for i/o type [1], the buffers are queued at the "buff" layer and
 * picked up later by the interrupt routine.  for case [2] the
 * programmed i/o driver is called with a special flag that says
 * return when one iopb is free.  for case [3] the process can sleep
 * on the iorq free list until some iopbs are available.
 */


int
xdc_submit_iorq(xdcsc, iorqno, type)
	struct xdc_softc *xdcsc;
	int     iorqno;
	int     type;

{
	u_long  iopbaddr;
	struct xd_iorq *iorq = &xdcsc->reqs[iorqno];

#ifdef XDC_DEBUG
	printf("xdc_submit_iorq(%s, no=%d, type=%d)\n", xdcsc->sc_dev.dv_xname,
	    iorqno, type);
#endif

	/* first check and see if controller is busy */
	if (xdcsc->xdc->xdc_csr & XDC_ADDING) {
#ifdef XDC_DEBUG
		printf("xdc_submit_iorq: XDC not ready (ADDING)\n");
#endif
		if (type == XD_SUB_NOQ)
			return (XD_ERR_FAIL);	/* failed */
		XDC_TWAIT(xdcsc, iorqno);	/* put at end of waitq */
		switch (type) {
		case XD_SUB_NORM:
			return XD_ERR_AOK;	/* success */
		case XD_SUB_WAIT:
			while (iorq->iopb->done == 0) {
				tsleep(iorq, PRIBIO, "xdiorq", 0);
			}
			return (iorq->errno);
		case XD_SUB_POLL:
			return (xdc_piodriver(xdcsc, iorqno, 0));
		default:
			panic("xdc_submit_iorq adding");
		}
	}
#ifdef XDC_DEBUG
	{
		u_char *rio = (u_char *) iorq->iopb;
		int     sz = sizeof(struct xd_iopb), lcv;
		printf("%s: aio #%d [",
			xdcsc->sc_dev.dv_xname, iorq - xdcsc->reqs);
		for (lcv = 0; lcv < sz; lcv++)
			printf(" %02x", rio[lcv]);
		printf("]\n");
	}
#endif				/* XDC_DEBUG */

	/* controller not busy, start command */
	iopbaddr = (u_long) iorq->iopb - (u_long) DVMA_BASE;
	XDC_GO(xdcsc->xdc, iopbaddr);	/* go! */
	xdcsc->nrun++;
	/* command now running, wrap it up */
	switch (type) {
	case XD_SUB_NORM:
	case XD_SUB_NOQ:
		return (XD_ERR_AOK);	/* success */
	case XD_SUB_WAIT:
		while (iorq->iopb->done == 0) {
			tsleep(iorq, PRIBIO, "xdiorq", 0);
		}
		return (iorq->errno);
	case XD_SUB_POLL:
		return (xdc_piodriver(xdcsc, iorqno, 0));
	default:
		panic("xdc_submit_iorq wrap up");
	}
	panic("xdc_submit_iorq");
	return 0;	/* not reached */
}


/*
 * xdc_piodriver
 *
 * programmed i/o driver.   this function takes over the computer
 * and drains off all i/o requests.   it returns the status of the iorq
 * the caller is interesting in.   if freeone is true, then it returns
 * when there is a free iorq.
 */
int
xdc_piodriver(xdcsc, iorqno, freeone)
	struct xdc_softc *xdcsc;
	int    iorqno;   
	int    freeone;

{
	int     nreset = 0;
	int     retval = 0;
	u_long  count;
	struct xdc *xdc = xdcsc->xdc;
#ifdef XDC_DEBUG
	printf("xdc_piodriver(%s, %d, freeone=%d)\n", xdcsc->sc_dev.dv_xname,
	    iorqno, freeone);
#endif

	while (xdcsc->nwait || xdcsc->nrun) {
#ifdef XDC_DEBUG
		printf("xdc_piodriver: wait=%d, run=%d\n",
			xdcsc->nwait, xdcsc->nrun);
#endif
		XDC_WAIT(xdc, count, XDC_MAXTIME, (XDC_REMIOPB | XDC_F_ERROR));
#ifdef XDC_DEBUG
		printf("xdc_piodriver: done wait with count = %d\n", count);
#endif
		/* we expect some progress soon */
		if (count == 0 && nreset >= 2) {
			xdc_reset(xdcsc, 0, XD_RSET_ALL, XD_ERR_FAIL, 0);
#ifdef XDC_DEBUG
			printf("xdc_piodriver: timeout\n");
#endif
			return (XD_ERR_FAIL);
		}
		if (count == 0) {
			if (xdc_reset(xdcsc, 0,
				      (nreset++ == 0) ? XD_RSET_NONE : iorqno,
				      XD_ERR_FAIL,
				      0) == XD_ERR_FAIL)
				return (XD_ERR_FAIL);	/* flushes all but POLL
							 * requests, resets */
			continue;
		}
		xdc_remove_iorq(xdcsc);	/* could resubmit request */
		if (freeone) {
			if (xdcsc->nrun < XDC_MAXIOPB) {
#ifdef XDC_DEBUG
				printf("xdc_piodriver: done: one free\n");
#endif
				return (XD_ERR_AOK);
			}
			continue;	/* don't xdc_start */
		}
		xdc_start(xdcsc, XDC_MAXIOPB);
	}

	/* get return value */

	retval = xdcsc->reqs[iorqno].errno;

#ifdef XDC_DEBUG
	printf("xdc_piodriver: done, retval = 0x%x (%s)\n",
	    xdcsc->reqs[iorqno].errno, xdc_e2str(xdcsc->reqs[iorqno].errno));
#endif

	/* now that we've drained everything, start up any bufs that have
	 * queued */

	while (xdcsc->nfree > 0 && bufq_peek(&xdcsc->sc_bufq))
		if (xdc_startbuf(xdcsc) != XD_ERR_AOK)
			break;

	return (retval);
}

/*
 * xdc_reset: reset one drive.   NOTE: assumes xdc was just reset.
 * we steal iopb[0] for this, but we put it back when we are done.
 */
void
xdc_xdreset(xdcsc, xdsc)
	struct xdc_softc *xdcsc;
	struct xd_softc *xdsc;

{
	struct xd_iopb tmpiopb;
	u_long  addr;
	int     del;
	bcopy(xdcsc->iopbase, &tmpiopb, sizeof(tmpiopb));
	bzero(xdcsc->iopbase, sizeof(tmpiopb));
	xdcsc->iopbase->comm = XDCMD_RST;
	xdcsc->iopbase->unit = xdsc->xd_drive;
	addr = (u_long) xdcsc->dvmaiopb;
	XDC_GO(xdcsc->xdc, addr);	/* go! */
	XDC_WAIT(xdcsc->xdc, del, XDC_RESETUSEC, XDC_REMIOPB);
	if (del <= 0 || xdcsc->iopbase->errs) {
		printf("%s: off-line: %s\n", xdcsc->sc_dev.dv_xname,
		    xdc_e2str(xdcsc->iopbase->errno));
		xdcsc->xdc->xdc_csr = XDC_RESET;
		XDC_WAIT(xdcsc->xdc, del, XDC_RESETUSEC, XDC_RESET);
		if (del <= 0)
			panic("xdc_reset");
	} else {
		xdcsc->xdc->xdc_csr = XDC_CLRRIO;	/* clear RIO */
	}
	bcopy(&tmpiopb, xdcsc->iopbase, sizeof(tmpiopb));
}


/*
 * xdc_reset: reset everything: requests are marked as errors except
 * a polled request (which is resubmitted)
 */
int
xdc_reset(xdcsc, quiet, blastmode, error, xdsc)
	struct xdc_softc *xdcsc;
	int     quiet, blastmode, error;
	struct xd_softc *xdsc;

{
	int     del = 0, lcv, retval = XD_ERR_AOK;
	int     oldfree = xdcsc->nfree;

	/* soft reset hardware */

	if (!quiet)
		printf("%s: soft reset\n", xdcsc->sc_dev.dv_xname);
	xdcsc->xdc->xdc_csr = XDC_RESET;
	XDC_WAIT(xdcsc->xdc, del, XDC_RESETUSEC, XDC_RESET);
	if (del <= 0) {
		blastmode = XD_RSET_ALL;	/* dead, flush all requests */
		retval = XD_ERR_FAIL;
	}
	if (xdsc)
		xdc_xdreset(xdcsc, xdsc);

	/* fix queues based on "blast-mode" */

	for (lcv = 0; lcv < XDC_MAXIOPB; lcv++) {
		struct xd_iorq *iorq = &xdcsc->reqs[lcv];

		if (XD_STATE(iorq->mode) != XD_SUB_POLL &&
		    XD_STATE(iorq->mode) != XD_SUB_WAIT &&
		    XD_STATE(iorq->mode) != XD_SUB_NORM)
			/* is it active? */
			continue;

		xdcsc->nrun--;	/* it isn't running any more */
		if (blastmode == XD_RSET_ALL || blastmode != lcv) {
			/* failed */
			iorq->errno = error;
			xdcsc->iopbase[lcv].done = xdcsc->iopbase[lcv].errs = 1;
			switch (XD_STATE(xdcsc->reqs[lcv].mode)) {
			case XD_SUB_NORM:
			    iorq->buf->b_error = EIO;
			    iorq->buf->b_flags |= B_ERROR;
			    iorq->buf->b_resid =
			       iorq->sectcnt * XDFM_BPS;
			    dvma_mapout((vaddr_t)iorq->dbufbase,
				    (vaddr_t)iorq->buf->b_data,
				    iorq->buf->b_bcount);
			    disk_unbusy(&xdcsc->reqs[lcv].xd->sc_dk,
				(xdcsc->reqs[lcv].buf->b_bcount -
				xdcsc->reqs[lcv].buf->b_resid),
				(xdcsc->reqs[lcv].buf->b_flags & B_READ));
			    biodone(iorq->buf);
			    XDC_FREE(xdcsc, lcv);	/* add to free list */
			    break;
			case XD_SUB_WAIT:
			    wakeup(iorq);
			case XD_SUB_POLL:
			    xdcsc->ndone++;
			    iorq->mode =
				XD_NEWSTATE(iorq->mode, XD_SUB_DONE);
			    break;
			}

		} else {

			/* resubmit, put at front of wait queue */
			XDC_HWAIT(xdcsc, lcv);
		}
	}

	/*
	 * now, if stuff is waiting, start it.
	 * since we just reset it should go
	 */
	xdc_start(xdcsc, XDC_MAXIOPB);

	/* ok, we did it */
	if (oldfree == 0 && xdcsc->nfree)
		wakeup(&xdcsc->nfree);

#ifdef XDC_DIAG
	del = xdcsc->nwait + xdcsc->nrun + xdcsc->nfree + xdcsc->ndone;
	if (del != XDC_MAXIOPB)
		printf("%s: diag: xdc_reset miscount (%d should be %d)!\n",
		    xdcsc->sc_dev.dv_xname, del, XDC_MAXIOPB);
	else
		if (xdcsc->ndone > XDC_MAXIOPB - XDC_SUBWAITLIM)
			printf("%s: diag: lots of done jobs (%d)\n",
			    xdcsc->sc_dev.dv_xname, xdcsc->ndone);
#endif
	printf("RESET DONE\n");
	return (retval);
}
/*
 * xdc_start: start all waiting buffers
 */

void
xdc_start(xdcsc, maxio)
	struct xdc_softc *xdcsc;
	int     maxio;

{
	int     rqno;
	while (maxio && xdcsc->nwait &&
		(xdcsc->xdc->xdc_csr & XDC_ADDING) == 0) {
		XDC_GET_WAITER(xdcsc, rqno);	/* note: rqno is an "out"
						 * param */
		if (xdc_submit_iorq(xdcsc, rqno, XD_SUB_NOQ) != XD_ERR_AOK)
			panic("xdc_start");	/* should never happen */
		maxio--;
	}
}
/*
 * xdc_remove_iorq: remove "done" IOPB's.
 */

int
xdc_remove_iorq(xdcsc)
	struct xdc_softc *xdcsc;

{
	int     errno, rqno, comm, errs;
	struct xdc *xdc = xdcsc->xdc;
	struct xd_iopb *iopb;
	struct xd_iorq *iorq;
	struct buf *bp;

	if (xdc->xdc_csr & XDC_F_ERROR) {
		/*
		 * FATAL ERROR: should never happen under normal use. This
		 * error is so bad, you can't even tell which IOPB is bad, so
		 * we dump them all.
		 */
		errno = xdc->xdc_f_err;
		printf("%s: fatal error 0x%02x: %s\n", xdcsc->sc_dev.dv_xname,
		    errno, xdc_e2str(errno));
		if (xdc_reset(xdcsc, 0, XD_RSET_ALL, errno, 0) != XD_ERR_AOK) {
			printf("%s: soft reset failed!\n",
				xdcsc->sc_dev.dv_xname);
			panic("xdc_remove_iorq: controller DEAD");
		}
		return (XD_ERR_AOK);
	}

	/*
	 * get iopb that is done
	 *
	 * hmm... I used to read the address of the done IOPB off the VME
	 * registers and calculate the rqno directly from that.   that worked
	 * until I started putting a load on the controller.   when loaded, i
	 * would get interrupts but neither the REMIOPB or F_ERROR bits would
	 * be set, even after DELAY'ing a while!   later on the timeout
	 * routine would detect IOPBs that were marked "running" but their
	 * "done" bit was set.   rather than dealing directly with this
	 * problem, it is just easier to look at all running IOPB's for the
	 * done bit.
	 */
	if (xdc->xdc_csr & XDC_REMIOPB) {
		xdc->xdc_csr = XDC_CLRRIO;
	}

	for (rqno = 0; rqno < XDC_MAXIOPB; rqno++) {
		iorq = &xdcsc->reqs[rqno];
		if (iorq->mode == 0 || XD_STATE(iorq->mode) == XD_SUB_DONE)
			continue;	/* free, or done */
		iopb = &xdcsc->iopbase[rqno];
		if (iopb->done == 0)
			continue;	/* not done yet */

#ifdef XDC_DEBUG
		{
			u_char *rio = (u_char *) iopb;
			int     sz = sizeof(struct xd_iopb), lcv;
			printf("%s: rio #%d [", xdcsc->sc_dev.dv_xname, rqno);
			for (lcv = 0; lcv < sz; lcv++)
				printf(" %02x", rio[lcv]);
			printf("]\n");
		}
#endif				/* XDC_DEBUG */

		xdcsc->nrun--;

		comm = iopb->comm;
		errs = iopb->errs;

		if (errs)
			iorq->errno = iopb->errno;
		else
			iorq->errno = 0;

		/* handle non-fatal errors */

		if (errs &&
		    xdc_error(xdcsc, iorq, iopb, rqno, comm) == XD_ERR_AOK)
			continue;	/* AOK: we resubmitted it */


		/* this iorq is now done (hasn't been restarted or anything) */

		if ((iorq->mode & XD_MODE_VERBO) && iorq->lasterror)
			xdc_perror(iorq, iopb, 0);

		/* now, if read/write check to make sure we got all the data
		 * we needed. (this may not be the case if we got an error in
		 * the middle of a multisector request).   */

		if ((iorq->mode & XD_MODE_B144) != 0 && errs == 0 &&
		    (comm == XDCMD_RD || comm == XDCMD_WR)) {
			/* we just successfully processed a bad144 sector
			 * note: if we are in bad 144 mode, the pointers have
			 * been advanced already (see above) and are pointing
			 * at the bad144 sector.   to exit bad144 mode, we
			 * must advance the pointers 1 sector and issue a new
			 * request if there are still sectors left to process
			 *
			 */
			XDC_ADVANCE(iorq, 1);	/* advance 1 sector */

			/* exit b144 mode */
			iorq->mode = iorq->mode & (~XD_MODE_B144);

			if (iorq->sectcnt) {	/* more to go! */
				iorq->lasterror = iorq->errno = iopb->errno = 0;
				iopb->errs = iopb->done = 0;
				iorq->tries = 0;
				iopb->sectcnt = iorq->sectcnt;
				iopb->cylno = iorq->blockno /
						iorq->xd->sectpercyl;
				iopb->headno =
					(iorq->blockno / iorq->xd->nhead) %
						iorq->xd->nhead;
				iopb->sectno = iorq->blockno % iorq->xd->nsect;
				iopb->daddr = (u_long) iorq->dbuf - DVMA_BASE;
				XDC_HWAIT(xdcsc, rqno);
				xdc_start(xdcsc, 1);	/* resubmit */
				continue;
			}
		}
		/* final cleanup, totally done with this request */

		switch (XD_STATE(iorq->mode)) {
		case XD_SUB_NORM:
			bp = iorq->buf;
			if (errs) {
				bp->b_error = EIO;
				bp->b_flags |= B_ERROR;
				bp->b_resid = iorq->sectcnt * XDFM_BPS;
			} else {
				bp->b_resid = 0;	/* done */
			}
			dvma_mapout((vaddr_t) iorq->dbufbase,
				    (vaddr_t) bp->b_data,
				    bp->b_bcount);
			disk_unbusy(&iorq->xd->sc_dk,
			    (bp->b_bcount - bp->b_resid),
			    (bp->b_flags & B_READ));
			XDC_FREE(xdcsc, rqno);
			biodone(bp);
			break;
		case XD_SUB_WAIT:
			iorq->mode = XD_NEWSTATE(iorq->mode, XD_SUB_DONE);
			xdcsc->ndone++;
			wakeup(iorq);
			break;
		case XD_SUB_POLL:
			iorq->mode = XD_NEWSTATE(iorq->mode, XD_SUB_DONE);
			xdcsc->ndone++;
			break;
		}
	}

	return (XD_ERR_AOK);
}

/*
 * xdc_perror: print error.
 * - if still_trying is true: we got an error, retried and got a
 *   different error.  in that case lasterror is the old error,
 *   and errno is the new one.
 * - if still_trying is not true, then if we ever had an error it
 *   is in lasterror. also, if iorq->errno == 0, then we recovered
 *   from that error (otherwise iorq->errno == iorq->lasterror).
 */
void
xdc_perror(iorq, iopb, still_trying)
	struct xd_iorq *iorq;
	struct xd_iopb *iopb;
	int     still_trying;

{

	int     error = iorq->lasterror;

	printf("%s", (iorq->xd) ? iorq->xd->sc_dev.dv_xname
	    : iorq->xdc->sc_dev.dv_xname);
	if (iorq->buf)
		printf("%c: ", 'a' + DISKPART(iorq->buf->b_dev));
	if (iopb->comm == XDCMD_RD || iopb->comm == XDCMD_WR)
		printf("%s %d/%d/%d: ",
			(iopb->comm == XDCMD_RD) ? "read" : "write",
			iopb->cylno, iopb->headno, iopb->sectno);
	printf("%s", xdc_e2str(error));

	if (still_trying)
		printf(" [still trying, new error=%s]", xdc_e2str(iorq->errno));
	else
		if (iorq->errno == 0)
			printf(" [recovered in %d tries]", iorq->tries);

	printf("\n");
}

/*
 * xdc_error: non-fatal error encountered... recover.
 * return AOK if resubmitted, return FAIL if this iopb is done
 */
int
xdc_error(xdcsc, iorq, iopb, rqno, comm)
	struct xdc_softc *xdcsc;
	struct xd_iorq *iorq;
	struct xd_iopb *iopb;
	int     rqno, comm;

{
	int     errno = iorq->errno;
	int     erract = errno & XD_ERA_MASK;
	int     oldmode, advance, i;

	if (erract == XD_ERA_RSET) {	/* some errors require a reset */
		oldmode = iorq->mode;
		iorq->mode = XD_SUB_DONE | (~XD_SUB_MASK & oldmode);
		xdcsc->ndone++;
		/* make xdc_start ignore us */
		xdc_reset(xdcsc, 1, XD_RSET_NONE, errno, iorq->xd);
		iorq->mode = oldmode;
		xdcsc->ndone--;
	}
	/* check for read/write to a sector in bad144 table if bad: redirect
	 * request to bad144 area */

	if ((comm == XDCMD_RD || comm == XDCMD_WR) &&
	    (iorq->mode & XD_MODE_B144) == 0) {
		advance = iorq->sectcnt - iopb->sectcnt;
		XDC_ADVANCE(iorq, advance);
		if ((i = isbad(&iorq->xd->dkb, iorq->blockno / iorq->xd->sectpercyl,
			    (iorq->blockno / iorq->xd->nsect) % iorq->xd->nhead,
			    iorq->blockno % iorq->xd->nsect)) != -1) {
			iorq->mode |= XD_MODE_B144;	/* enter bad144 mode &
							 * redirect */
			iopb->errno = iopb->done = iopb->errs = 0;
			iopb->sectcnt = 1;
			iopb->cylno = (iorq->xd->ncyl + iorq->xd->acyl) - 2;
			/* second to last acyl */
			i = iorq->xd->sectpercyl - 1 - i;	/* follow bad144
								 * standard */
			iopb->headno = i % iorq->xd->nhead;
			iopb->sectno = i / iorq->xd->nhead;
			iopb->daddr = (u_long) iorq->dbuf - DVMA_BASE;
			XDC_HWAIT(xdcsc, rqno);
			xdc_start(xdcsc, 1);	/* resubmit */
			return (XD_ERR_AOK);	/* recovered! */
		}
	}

	/*
	 * it isn't a bad144 sector, must be real error! see if we can retry
	 * it?
	 */
	if ((iorq->mode & XD_MODE_VERBO) && iorq->lasterror)
		xdc_perror(iorq, iopb, 1);	/* inform of error state
						 * change */
	iorq->lasterror = errno;

	if ((erract == XD_ERA_RSET || erract == XD_ERA_HARD)
	    && iorq->tries < XDC_MAXTRIES) {	/* retry? */
		iorq->tries++;
		iorq->errno = iopb->errno = iopb->done = iopb->errs = 0;
		XDC_HWAIT(xdcsc, rqno);
		xdc_start(xdcsc, 1);	/* restart */
		return (XD_ERR_AOK);	/* recovered! */
	}

	/* failed to recover from this error */
	return (XD_ERR_FAIL);
}

/*
 * xdc_tick: make sure xd is still alive and ticking (err, kicking).
 */
void
xdc_tick(arg)
	void   *arg;

{
	struct xdc_softc *xdcsc = arg;
	int     lcv, s, reset = 0;
#ifdef XDC_DIAG
	int     wait, run, free, done, whd = 0;
	u_char  fqc[XDC_MAXIOPB], wqc[XDC_MAXIOPB], mark[XDC_MAXIOPB];
	s = splbio();
	wait = xdcsc->nwait;
	run = xdcsc->nrun;
	free = xdcsc->nfree;
	done = xdcsc->ndone;
	bcopy(xdcsc->waitq, wqc, sizeof(wqc));
	bcopy(xdcsc->freereq, fqc, sizeof(fqc));
	splx(s);
	if (wait + run + free + done != XDC_MAXIOPB) {
		printf("%s: diag: IOPB miscount (got w/f/r/d %d/%d/%d/%d, wanted %d)\n",
		    xdcsc->sc_dev.dv_xname, wait, free, run, done, XDC_MAXIOPB);
		bzero(mark, sizeof(mark));
		printf("FREE: ");
		for (lcv = free; lcv > 0; lcv--) {
			printf("%d ", fqc[lcv - 1]);
			mark[fqc[lcv - 1]] = 1;
		}
		printf("\nWAIT: ");
		lcv = wait;
		while (lcv > 0) {
			printf("%d ", wqc[whd]);
			mark[wqc[whd]] = 1;
			whd = (whd + 1) % XDC_MAXIOPB;
			lcv--;
		}
		printf("\n");
		for (lcv = 0; lcv < XDC_MAXIOPB; lcv++) {
			if (mark[lcv] == 0)
				printf("MARK: running %d: mode %d done %d errs %d errno 0x%x ttl %d buf %p\n",
				lcv, xdcsc->reqs[lcv].mode,
				xdcsc->iopbase[lcv].done,
				xdcsc->iopbase[lcv].errs,
				xdcsc->iopbase[lcv].errno,
				xdcsc->reqs[lcv].ttl, xdcsc->reqs[lcv].buf);
		}
	} else
		if (done > XDC_MAXIOPB - XDC_SUBWAITLIM)
			printf("%s: diag: lots of done jobs (%d)\n",
				xdcsc->sc_dev.dv_xname, done);

#endif
#ifdef XDC_DEBUG
	printf("%s: tick: csr 0x%x, w/f/r/d %d/%d/%d/%d\n",
		xdcsc->sc_dev.dv_xname,
		xdcsc->xdc->xdc_csr, xdcsc->nwait, xdcsc->nfree, xdcsc->nrun,
		xdcsc->ndone);
	for (lcv = 0; lcv < XDC_MAXIOPB; lcv++) {
		if (xdcsc->reqs[lcv].mode)
		  printf("running %d: mode %d done %d errs %d errno 0x%x\n",
			 lcv,
			 xdcsc->reqs[lcv].mode, xdcsc->iopbase[lcv].done,
			 xdcsc->iopbase[lcv].errs, xdcsc->iopbase[lcv].errno);
	}
#endif

	/* reduce ttl for each request if one goes to zero, reset xdc */
	s = splbio();
	for (lcv = 0; lcv < XDC_MAXIOPB; lcv++) {
		if (xdcsc->reqs[lcv].mode == 0 ||
		    XD_STATE(xdcsc->reqs[lcv].mode) == XD_SUB_DONE)
			continue;
		xdcsc->reqs[lcv].ttl--;
		if (xdcsc->reqs[lcv].ttl == 0) {
			reset = 1;
			break;	/* we're going to fail all requests anyway */
		}
	}
	if (reset) {
		printf("%s: watchdog timeout\n", xdcsc->sc_dev.dv_xname);
		xdc_reset(xdcsc, 0, XD_RSET_NONE, XD_ERR_FAIL, NULL);
	}
	splx(s);

	/* until next time */

	timeout_add(&xdcsc->xdc_tick_tmo, XDC_TICKCNT);
}

/*
 * xdc_e2str: convert error code number into an error string
 */
const char *
xdc_e2str(no)
	int     no;
{
	switch (no) {
	case XD_ERR_FAIL:
		return ("Software fatal error");
	case XD_ERR_AOK:
		return ("Successful completion");
	case XD_ERR_ICYL:
		return ("Illegal cylinder address");
	case XD_ERR_IHD:
		return ("Illegal head address");
	case XD_ERR_ISEC:
		return ("Illgal sector address");
	case XD_ERR_CZER:
		return ("Count zero");
	case XD_ERR_UIMP:
		return ("Unimplemented command");
	case XD_ERR_IF1:
		return ("Illegal field length 1");
	case XD_ERR_IF2:
		return ("Illegal field length 2");
	case XD_ERR_IF3:
		return ("Illegal field length 3");
	case XD_ERR_IF4:
		return ("Illegal field length 4");
	case XD_ERR_IF5:
		return ("Illegal field length 5");
	case XD_ERR_IF6:
		return ("Illegal field length 6");
	case XD_ERR_IF7:
		return ("Illegal field length 7");
	case XD_ERR_ISG:
		return ("Illegal scatter/gather length");
	case XD_ERR_ISPT:
		return ("Not enough sectors per track");
	case XD_ERR_ALGN:
		return ("Next IOPB address alignment error");
	case XD_ERR_SGAL:
		return ("Scatter/gather address alignment error");
	case XD_ERR_SGEC:
		return ("Scatter/gather with auto-ECC");
	case XD_ERR_SECC:
		return ("Soft ECC corrected");
	case XD_ERR_SIGN:
		return ("ECC ignored");
	case XD_ERR_ASEK:
		return ("Auto-seek retry recovered");
	case XD_ERR_RTRY:
		return ("Soft retry recovered");
	case XD_ERR_HECC:
		return ("Hard data ECC");
	case XD_ERR_NHDR:
		return ("Header not found");
	case XD_ERR_NRDY:
		return ("Drive not ready");
	case XD_ERR_TOUT:
		return ("Operation timeout");
	case XD_ERR_VTIM:
		return ("VMEDMA timeout");
	case XD_ERR_DSEQ:
		return ("Disk sequencer error");
	case XD_ERR_HDEC:
		return ("Header ECC error");
	case XD_ERR_RVFY:
		return ("Read verify");
	case XD_ERR_VFER:
		return ("Fatal VMEDMA error");
	case XD_ERR_VBUS:
		return ("VMEbus error");
	case XD_ERR_DFLT:
		return ("Drive faulted");
	case XD_ERR_HECY:
		return ("Header error/cylinder");
	case XD_ERR_HEHD:
		return ("Header error/head");
	case XD_ERR_NOCY:
		return ("Drive not on-cylinder");
	case XD_ERR_SEEK:
		return ("Seek error");
	case XD_ERR_ILSS:
		return ("Illegal sector size");
	case XD_ERR_SEC:
		return ("Soft ECC");
	case XD_ERR_WPER:
		return ("Write-protect error");
	case XD_ERR_IRAM:
		return ("IRAM self test failure");
	case XD_ERR_MT3:
		return ("Maintenance test 3 failure (DSKCEL RAM)");
	case XD_ERR_MT4:
		return ("Maintenance test 4 failure (header shift reg)");
	case XD_ERR_MT5:
		return ("Maintenance test 5 failure (VMEDMA regs)");
	case XD_ERR_MT6:
		return ("Maintenance test 6 failure (REGCEL chip)");
	case XD_ERR_MT7:
		return ("Maintenance test 7 failure (buffer parity)");
	case XD_ERR_MT8:
		return ("Maintenance test 8 failure (disk FIFO)");
	case XD_ERR_IOCK:
		return ("IOPB checksum miscompare");
	case XD_ERR_IODM:
		return ("IOPB DMA fatal");
	case XD_ERR_IOAL:
		return ("IOPB address alignment error");
	case XD_ERR_FIRM:
		return ("Firmware error");
	case XD_ERR_MMOD:
		return ("Illegal maintenance mode test number");
	case XD_ERR_ACFL:
		return ("ACFAIL asserted");
	default:
		return ("Unknown error");
	}
}
@


1.71
log
@Revert forcing a rachitic `c' slice size when the drive geometry is not known,
now that the disklabel code will reduce MAXDISKSIZE to the real size if a Sun
label is found.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.70 2015/01/15 21:17:54 miod Exp $	*/
d219 1
a219 1
int	xdc_startbuf(struct xdc_softc *, struct xd_softc *, struct buf *);
d450 1
a450 4

	xdc->sc_wq.b_active = 0;
	xdc->sc_wq.b_actf = 0;
	xdc->sc_wq.b_actb = &xdc->sc_wq.b_actf;
a998 1
	struct buf *wq;
a1036 3
	 *
	 * note that we don't disksort because the controller has a sorting
	 * algorithm built into the hardware.
d1038 2
d1041 3
a1043 6
	s = splbio();		/* protect the queues */

	/* first, give jobs in front of us a chance */
	parent = xd->parent;
	while (parent->nfree > 0 && parent->sc_wq.b_actf)
		if (xdc_startbuf(parent, NULL, NULL) != XD_ERR_AOK)
a1044 13

	/* if there are no free iorq's, then we just queue and return. the
	 * buffs will get picked up later by xdcintr().
	 */

	if (parent->nfree == 0) {
		wq = &xd->parent->sc_wq;
		bp->b_actf = 0;
		bp->b_actb = wq->b_actb;
		*wq->b_actb = bp;
		wq->b_actb = &bp->b_actf;
		splx(s);
		return;
a1045 9

	/* now we have free iopb's and we are at splbio... start 'em up */
	if (xdc_startbuf(parent, xd, bp) != XD_ERR_AOK) {
		splx(s);
		return;
	}

	/* done! */

d1084 2
a1085 2
	while (xdcsc->nfree > 0 && xdcsc->sc_wq.b_actf)
		if (xdc_startbuf(xdcsc, NULL, NULL) != XD_ERR_AOK)
d1310 1
a1310 1
xdc_startbuf(xdcsc, xdsc, bp)
a1311 2
	struct xd_softc *xdsc;
	struct buf *bp;
d1315 1
d1318 1
a1318 1
	struct buf *wq;
d1329 3
d1333 1
a1333 12
	if (bp == NULL) {
		bp = xdcsc->sc_wq.b_actf;
		if (!bp)
			panic("xdc_startbuf bp");
		wq = bp->b_actf;
		if (wq)
			wq->b_actb = bp->b_actb;
		else
			xdcsc->sc_wq.b_actb = bp->b_actb;
		*bp->b_actb = wq;
		xdsc = xdcsc->sc_drives[DISKUNIT(bp->b_dev)];
	}
d1359 1
a1359 5
		wq = &xdcsc->sc_wq;	/* put at end of queue */
		bp->b_actf = 0;
		bp->b_actb = wq->b_actb;
		*wq->b_actb = bp;
		wq->b_actb = &bp->b_actf;
d1560 2
a1561 2
	while (xdcsc->nfree > 0 && xdcsc->sc_wq.b_actf)
		if (xdc_startbuf(xdcsc, NULL, NULL) != XD_ERR_AOK)
@


1.70
log
@Rework the disk label handling once again. Disk label is read at attach time
because it teaches us the drive geometry, but from then on there is no reason
not to implement disklabel spoof support and a proper DIOCGPDINFO ioctl.

As a result, this makes disklabel -A now work on SMD disks.

The drawback of this, is that, since native labels do not have a pcylinders
value, the code will now always assume pcylinders == ncylinders + acylinders.
(this ought to be the case by default for labels produced by SunOS format(8).)
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.69 2015/01/14 21:17:09 miod Exp $	*/
a297 2
		/* prevent initdisklabel() from putting MAXDISKSIZE */
		DL_SETDSIZE(lp, 1ULL);
@


1.69
log
@When a read or write operation fails on a sector found on the bad block table,
be sure to adjust the IOPB data pointer before redirecting the I/O for this
particular sector to the replacement location.

Otherwise, the data pointer still points to the first sector of the I/O, which
may not necessarily be the one which failed.

(This is yet another 19 years old bug, making your filesystems self-destruct
even faster than intended)
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.68 2015/01/14 21:14:49 miod Exp $	*/
d234 1
a234 1
int	xdgetdisklabel(struct xd_softc *, void *);
a264 4
/*
 * start: disk label fix code (XXX)
 */

d270 1
d273 7
a279 3
	if (bp->b_bcount != XDFM_BPS)
		panic("xddummystrat");
	bcopy(xd->xd_labeldata, bp->b_data, XDFM_BPS);
d284 2
a285 1
xdgetdisklabel(xd, b)
d287 2
a288 1
	void *b;
a289 2
	struct disklabel *lp = xd->sc_dk.dk_label;
	struct sun_disklabel *sl = b;
d295 5
a299 3
	if (sl->sl_magic == SUN_DKMAGIC) {
		lp->d_secpercyl = sl->sl_nsectors * sl->sl_ntracks;
		DL_SETDSIZE(lp, (u_int64_t)lp->d_secpercyl * sl->sl_ncylinders);
d301 10
a310 1
		lp->d_secpercyl = 1;
d313 1
d315 11
a325 5
	/* We already have the label data in `b'; setup for dummy strategy */
	xd->xd_labeldata = b;

	error = readdisklabel(MAKEDISKDEV(0, xd->sc_dev.dv_unit, RAW_PART),
	    xddummystrat, lp, 0);
d327 1
a327 1
		return (error);
d329 15
a343 11
	/* Ok, we have the label; fill in `pcyl' if there's SunOS magic */
	sl = b;
	if (sl->sl_magic == SUN_DKMAGIC)
		xd->pcyl = sl->sl_pcylinders;
	else {
		printf("%s: WARNING: no `pcyl' in disk label.\n",
			xd->sc_dev.dv_xname);
		xd->pcyl = lp->d_ncylinders +
			lp->d_acylinders;
		printf("%s: WARNING: guessing pcyl=%d (ncyl+acyl)\n",
		xd->sc_dev.dv_xname, xd->pcyl);
d346 1
a346 6
	xd->ncyl = lp->d_ncylinders;
	xd->acyl = lp->d_acylinders;
	xd->nhead = lp->d_ntracks;
	xd->nsect = lp->d_nsectors;
	xd->sectpercyl = lp->d_secpercyl;
	return (0);
a349 4
 * end: disk label fix code (XXX)
 */

/*
d670 4
a673 1
	if (xdgetdisklabel(xd, xa->buf) != XD_ERR_AOK)
d675 1
d840 4
a844 1
	case DIOCGPDINFO:	/* no separate 'physical' info available. */
d849 2
a850 2
		((struct partinfo *) addr)->disklab = xd->sc_dk.dk_label;
		((struct partinfo *) addr)->part =
d859 1
a859 1
		    (struct disklabel *) addr, /* xd->sc_dk.dk_openmask : */ 0);
@


1.68
log
@When the outcome of the watchdog processing is a reset, do not bother checking
further pending requests, since they will be forcefully failed by the reset
routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.67 2015/01/14 21:13:46 miod Exp $	*/
d1988 1
@


1.67
log
@Make the special buffer used for the few sector I/O at attach time a per-softc
member, rather than a global. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.66 2015/01/14 19:02:59 miod Exp $	*/
d2091 1
a2091 1
		if (xdcsc->reqs[lcv].ttl == 0)
d2093 2
@


1.66
log
@Make x[dy]c_e2str return a const char *.
Remove obsolete comments in x[dy]dump().
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.65 2015/01/14 19:01:00 miod Exp $	*/
a268 2
static void *xd_labeldata;

d273 3
d278 1
a278 1
	bcopy(xd_labeldata, bp->b_data, XDFM_BPS);
d303 1
a303 1
	xd_labeldata = b;
@


1.65
log
@Remove pass-through ioctl for SMD disks (DIOSXDCMD). Nothing uses this, because
noone wrote an equivalent of SunOS format(8) and noone ever will.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.64 2015/01/13 20:40:11 miod Exp $	*/
d207 1
a207 1
char   *xdc_e2str(int);
a787 13

	/* outline: globals: "dumplo" == sector number of partition to start
	 * dump at (convert to physical sector with partition table)
	 * "dumpsize" == size of dump in clicks "physmem" == size of physical
	 * memory (clicks, ptoa() to get bytes) (normal case: dumpsize ==
	 * physmem)
	 *
	 * dump a copy of physical memory to the dump device starting at sector
	 * "dumplo" in the swap partition (make sure > 0).   map in pages as
	 * we go.   use polled I/O.
	 *
	 * XXX how to handle NON_CONTIG? */

d2107 1
a2107 1
char *
@


1.64
log
@Initialize d_type to DTYPE_SMD in the default label to avoid disklabel(8)
asking for the device type upon labeling a freshly formatted disk.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.63 2015/01/12 21:31:06 miod Exp $	*/
a83 1
#include <sparc/dev/xio.h>
a209 1
int	xdc_ioctlcmd(struct xd_softc *, dev_t dev, struct xd_iocmd *);
a815 1
	struct xd_iocmd *xio;
a868 6
	case DIOSXDCMD:
		xio = (struct xd_iocmd *) addr;
		if ((error = suser(p, 0)) != 0)
			return (error);
		return (xdc_ioctlcmd(xd, dev, xio));

a2114 131
}

/*
 * xdc_ioctlcmd: this function provides a user level interface to the
 * controller via ioctl.   this allows "format" programs to be written
 * in user code, and is also useful for some debugging.   we return
 * an error code.   called at user priority.
 */
int
xdc_ioctlcmd(xd, dev, xio)
	struct xd_softc *xd;
	dev_t   dev;
	struct xd_iocmd *xio;

{
	int     s, err, rqno, dummy;
	caddr_t dvmabuf = NULL, buf = NULL;
	struct xdc_softc *xdcsc;

	/* check sanity of requested command */

	switch (xio->cmd) {

	case XDCMD_NOP:	/* no op: everything should be zero */
		if (xio->subfn || xio->dptr || xio->dlen ||
		    xio->block || xio->sectcnt)
			return (EINVAL);
		break;

	case XDCMD_RD:		/* read / write sectors (up to XD_IOCMD_MAXS) */
	case XDCMD_WR:
		if (xio->subfn || xio->sectcnt > XD_IOCMD_MAXS ||
		    xio->sectcnt * XDFM_BPS != xio->dlen || xio->dptr == NULL)
			return (EINVAL);
		break;

	case XDCMD_SK:		/* seek: doesn't seem useful to export this */
		return (EINVAL);

	case XDCMD_WRP:	/* write parameters */
		return (EINVAL);/* not useful, except maybe drive
				 * parameters... but drive parameters should
				 * go via disklabel changes */

	case XDCMD_RDP:	/* read parameters */
		if (xio->subfn != XDFUN_DRV ||
		    xio->dlen || xio->block || xio->dptr)
			return (EINVAL);	/* allow read drive params to
						 * get hw_spt */
		xio->sectcnt = xd->hw_spt;	/* we already know the answer */
		return (0);
		break;

	case XDCMD_XRD:	/* extended read/write */
	case XDCMD_XWR:

		switch (xio->subfn) {

		case XDFUN_THD:/* track headers */
			if (xio->sectcnt != xd->hw_spt ||
			    (xio->block % xd->nsect) != 0 ||
			    xio->dlen != XD_IOCMD_HSZ * xd->hw_spt ||
			    xio->dptr == NULL)
				return (EINVAL);
			xio->sectcnt = 0;
			break;

		case XDFUN_FMT:/* NOTE: also XDFUN_VFY */
			if (xio->cmd == XDCMD_XRD)
				return (EINVAL);	/* no XDFUN_VFY */
			if (xio->sectcnt || xio->dlen ||
			    (xio->block % xd->nsect) != 0 || xio->dptr)
				return (EINVAL);
			break;

		case XDFUN_HDR:/* header, header verify, data, data ECC */
			return (EINVAL);	/* not yet */

		case XDFUN_DM:	/* defect map */
		case XDFUN_DMX:/* defect map (alternate location) */
			if (xio->sectcnt || xio->dlen != XD_IOCMD_DMSZ ||
			    (xio->block % xd->nsect) != 0 || xio->dptr == NULL)
				return (EINVAL);
			break;

		default:
			return (EINVAL);
		}
		break;

	case XDCMD_TST:	/* diagnostics */
		return (EINVAL);

	default:
		return (EINVAL);/* ??? */
	}

	/* create DVMA buffer for request if needed */

	if (xio->dlen) {
		dvmabuf = dvma_malloc(xio->dlen, &buf, M_WAITOK);
		if (xio->cmd == XDCMD_WR || xio->cmd == XDCMD_XWR) {
			if ((err = copyin(xio->dptr, buf, xio->dlen)) != 0) {
				dvma_free(dvmabuf, xio->dlen, &buf);
				return (err);
			}
		}
	}
	/* do it! */

	err = 0;
	xdcsc = xd->parent;
	s = splbio();
	rqno = xdc_cmd(xdcsc, xio->cmd, xio->subfn, xd->xd_drive, xio->block,
	    xio->sectcnt, dvmabuf, XD_SUB_WAIT);
	if (rqno == XD_ERR_FAIL) {
		err = EIO;
		goto done;
	}
	xio->errno = xdcsc->reqs[rqno].errno;
	xio->tries = xdcsc->reqs[rqno].tries;
	XDC_DONE(xdcsc, rqno, dummy);

	if (xio->cmd == XDCMD_RD || xio->cmd == XDCMD_XRD)
		err = copyout(buf, xio->dptr, xio->dlen);

done:
	splx(s);
	if (dvmabuf)
		dvma_free(dvmabuf, xio->dlen, &buf);
	return (err);
@


1.63
log
@Fix two 19 years old (since day one) bug in bad144 sector reassignment logic:
- when entering bad144 mode, correctly compute the actual C/H/S values for the
  logical block number.
- when leaving bad144 mode and resuming normal I/O operation, when computing
  back the C/H/S values for the next logical block number, compute the
  sector number correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.62 2014/07/11 16:35:40 jsg Exp $	*/
d301 1
@


1.62
log
@Chuck Cranor rescinded clauses in his license
on the 2nd of February 2011 in NetBSD.

http://marc.info/?l=netbsd-source-changes&m=129658899212732&w=2
http://marc.info/?l=netbsd-source-changes&m=129659095515558&w=2
http://marc.info/?l=netbsd-source-changes&m=129659157916514&w=2
http://marc.info/?l=netbsd-source-changes&m=129665962324372&w=2
http://marc.info/?l=netbsd-source-changes&m=129666033625342&w=2
http://marc.info/?l=netbsd-source-changes&m=129666052825545&w=2
http://marc.info/?l=netbsd-source-changes&m=129666922906480&w=2
http://marc.info/?l=netbsd-source-changes&m=129667725518082&w=2
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.61 2013/11/01 17:36:19 krw Exp $	*/
d1882 1
a1882 1
				iopb->sectno = iorq->blockno % XDFM_BPS;
d2006 2
a2007 2
			iopb->headno = i / iorq->xd->nhead;
			iopb->sectno = i % iorq->xd->nhead;
@


1.61
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.60 2013/10/20 10:11:16 krw Exp $	*/
a4 1
 *
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Charles D. Cranor.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.60
log
@(daddr_t) -> (u_int64_t) when multiplying ncylinders * secpercyl to
get disk size, since DL_SETDSIZE() takes disk sector values, not
512-byte block values.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.59 2013/10/14 23:26:22 krw Exp $	*/
d1384 1
a1384 1
	    (bp->b_flags & B_READ) ? "read" : "write", bp->b_blkno);
@


1.59
log
@XXsize() returns daddr_t, so calculate the return value in a daddr_t
variable and not (usually) an int.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.58 2013/06/11 16:42:11 deraadt Exp $	*/
d303 1
a303 1
		DL_SETDSIZE(lp, (daddr_t)lp->d_secpercyl * sl->sl_ncylinders);
@


1.58
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.57 2012/07/01 12:11:53 miod Exp $	*/
d974 2
a975 1
	int     unit, part, size, omask;
@


1.57
log
@Do not define XDC_DIAG if option SMALL_KERNEL; shaves about 14KB, and allows
sparc floppies to fit again.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.56 2011/07/06 04:49:35 matthew Exp $	*/
d303 1
a303 1
		DL_SETDSIZE(lp, (daddr64_t)lp->d_secpercyl * sl->sl_ncylinders);
d777 1
a777 1
	daddr64_t blkno;
d968 1
a968 1
daddr64_t
@


1.56
log
@Eliminate redundant buf validation checks in xxstrategy() methods now
that they're implemented consistently in bounds_check_with_label().

Also, per krw's request, change bounds_check_with_label() to return 0
if the checks succeed, and change the drivers to test == -1 instead of
<= 0.  (Man page update to follow; intentionally omitting
arch/vax/mba/hp.c from this commit because it doesn't even build
currently and miod@@ promises to kill it soon.)

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.55 2011/06/05 18:40:33 matthew Exp $	*/
d56 1
d58 1
@


1.55
log
@Drop kernel support for the useless DIOCWLABEL ioctl and prune a lot
of silly flag twiddling code in various disk drivers.

ok deraadt@@, miod@@

N.B., users will need a -current disklabel(8) to be able to write new
disklabels to disk now.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.54 2011/06/03 21:14:11 matthew Exp $	*/
d1014 1
a1014 3
	if (unit >= xd_cd.cd_ndevs || (xd = xd_cd.cd_devs[unit]) == 0 ||
	    bp->b_blkno < 0 ||
	    (bp->b_bcount % xd->sc_dk.dk_label->d_secsize) != 0) {
a1036 1
	/* short circuit zero length request */
d1038 2
a1039 9
	if (bp->b_bcount == 0)
		goto done;

	/* check bounds with label (disksubr.c).  Determine the size of the
	 * transfer, and make sure it is within the boundaries of the
	 * partition. Adjust transfer if needed, and signal errors or early
	 * completion. */

	if (bounds_check_with_label(bp, xd->sc_dk.dk_label) <= 0)
d1083 1
a1083 1
bad:				/* tells upper layers we have an error */
d1085 2
a1086 1
done:				/* tells upper layers we are done with this
a1087 1
	bp->b_resid = bp->b_bcount;
@


1.54
log
@Get rid of the wlabel argument to bounds_check_with_label().  It's
never done anything in OpenBSD and just clutters disk drivers with
silly flag handling.

More cleanup to follow.

ok deraadt@@, millert@@; no objections krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.53 2010/11/11 17:46:58 miod Exp $	*/
a848 9
		return 0;

	case DIOCWLABEL:	/* change write status of disk label */
		if ((flag & FWRITE) == 0)
			return EBADF;
		if (*(int *) addr)
			xd->flags |= XD_WLABEL;
		else
			xd->flags &= ~XD_WLABEL;
@


1.53
log
@Pass a few more M_ZERO to malloc() or its wrappers, when useful; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.52 2010/09/22 06:40:25 krw Exp $	*/
d1058 1
a1058 2
	if (bounds_check_with_label(bp, xd->sc_dk.dk_label,
	    (xd->flags & XD_WLABEL) != 0) <= 0)
@


1.52
log
@Add DIOCGPDINFO to drivers that were lacking it. Where there
is no easily available physical information outside of the stored
disklabel just make it a synonym for DIOCGDINFO.

Commit on the theory it is unlikely to harm, and fallout can be
addressed in the mass re-compile that will follow j2k10.

Should allow auto-allocation of disks to work with all devices.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.51 2010/09/22 01:18:57 matthew Exp $	*/
d416 1
a416 1
			M_NOWAIT);
a417 1
	bzero(xdc->iopbase, XDC_MAXIOPB * sizeof(struct xd_iopb));
@


1.51
log
@All users of physio(9) now pass NULL as the buf pointer argument, so
no point in keeping it around.

"i like this" thib@@ (a while back); ok krw@@ and oga@@; reminder to
update the man page and tweaks jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.50 2010/09/08 14:47:10 jsing Exp $	*/
d842 1
@


1.50
log
@Store a struct device pointer within struct disk and populate this when
disk_attach() is called by the device driver. We will be building on
this shortly.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.48 2010/05/23 10:49:19 dlg Exp $	*/
d957 1
a957 1
	return (physio(xdstrategy, NULL, dev, B_READ, minphys, uio));
d967 1
a967 1
	return (physio(xdstrategy, NULL, dev, B_WRITE, minphys, uio));
@


1.49
log
@Garbage collect struct dkdriver.

ok miod@@; "please go ahead" jsing@@
@
text
@d659 1
a659 1
	disk_attach(&xd->sc_dk);
@


1.48
log
@add dkio.h to the last of the disk ioctl users i can find.

requested by deraadt@@ who was rightly disparaging of my grep skillz.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.47 2009/09/05 15:37:04 deraadt Exp $	*/
a271 6
 * dkdriver
 */

struct dkdriver xddkdriver = {xdstrategy};

/*
a558 1
	xd->sc_dk.dk_driver = &xddkdriver;
@


1.47
log
@fix typos
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.46 2009/09/05 00:48:39 krw Exp $	*/
d78 1
@


1.46
log
@Make DIOCSDINFO code consistant everywhere.

ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.45 2009/08/13 15:23:12 deraadt Exp $	*/
d876 1
a876 1
			if (cmd == DIOCWDINFO) {
@


1.45
log
@Replace the error strings that were being passed around with much simpler
errnos.  Note that the error strings are being ignored, since we long ago
decided to not spam the console, and there is no other nice way to use the
errors (without changing the ioctls to pass it back)
The errno is now useful, since we can pass b_error from failing IO up, and
the drive can decide how to use that
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.44 2009/01/04 16:51:05 miod Exp $	*/
a856 11
	case DIOCSDINFO:	/* set disk label */
		if ((flag & FWRITE) == 0)
			return EBADF;
		error = setdisklabel(xd->sc_dk.dk_label,
		    (struct disklabel *) addr, /* xd->sc_dk.dk_openmask : */ 0);
		if (error == 0) {
			if (xd->state == XD_DRIVE_NOLABEL)
				xd->state = XD_DRIVE_ONLINE;
		}
		return error;

d867 1
d876 11
a886 6
			/* Simulate opening partition 0 so write succeeds. */
			xd->sc_dk.dk_openmask |= (1 << 0);
			error = writedisklabel(DISKLABELDEV(dev), xdstrategy,
			    xd->sc_dk.dk_label);
			xd->sc_dk.dk_openmask =
			    xd->sc_dk.dk_copenmask | xd->sc_dk.dk_bopenmask;
@


1.44
log
@In x[dy]dummystrat, do not clear B_BUSY from the buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.43 2007/11/28 16:33:20 martin Exp $	*/
d299 1
a299 1
	char *err;
d314 1
a314 1
	err = readdisklabel(MAKEDISKDEV(0, xd->sc_dev.dv_unit, RAW_PART),
d316 2
a317 4
	if (err) {
		/*printf("%s: %s\n", xd->sc_dev.dv_xname, err);*/
		return (XD_ERR_FAIL);
	}
d337 1
a337 1
	return (XD_ERR_AOK);
@


1.43
log
@ctob/btoc -> ptoa/atop

from Rodolfo Gouveia
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.42 2007/10/01 16:11:19 krw Exp $	*/
a289 1
	bp->b_flags &= ~B_BUSY;
@


1.42
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...' where
obvious.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.41 2007/07/01 19:06:57 miod Exp $	*/
d807 1
a807 1
	 * memory (clicks, ctob() to get bytes) (normal case: dumpsize ==
@


1.41
log
@Perform minimal disklabel setup without needing to do the disklabel_to_sun()
dance, so that we do not depend on its behaviour. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.40 2007/06/24 16:52:04 miod Exp $	*/
d430 2
a431 2
	xdc->reqs = (struct xd_iorq *)
	    malloc(XDC_MAXIOPB * sizeof(struct xd_iorq), M_DEVBUF, M_NOWAIT);
a433 1
	bzero(xdc->reqs, XDC_MAXIOPB * sizeof(struct xd_iorq));
@


1.40
log
@Fix xd and xy disklabel handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.39 2007/06/20 18:16:24 deraadt Exp $	*/
d299 1
a299 1
	struct sun_disklabel *sdl = b;
a300 2
	extern char *disklabel_sun_to_bsd(struct sun_disklabel *,
	    struct disklabel *);
d303 6
a308 5
	if (sdl->sl_magic == SUN_DKMAGIC)
		disklabel_sun_to_bsd(sdl, lp);
	else {
		/* Required parameters for readdisklabel() */
		lp->d_secsize = XDFM_BPS;
d323 3
a325 3
	sdl = b;
	if (sdl->sl_magic == SUN_DKMAGIC)
		xd->pcyl = sdl->sl_pcylinders;
d339 1
a339 2
	xd->sectpercyl = lp->d_secpercyl = xd->nhead * xd->nsect;
	lp->d_secsize = XDFM_BPS; /* not handled by sun->bsd */
@


1.39
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it.. except
these two drivers.  knock out that code for now to let it compile while
miod gets his fix ready for these drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.38 2007/06/07 03:42:51 deraadt Exp $	*/
d298 2
d301 11
a315 4
	/* Required parameters for readdisklabel() */
	xd->sc_dk.dk_label->d_secsize = XDFM_BPS;
	xd->sc_dk.dk_label->d_secpercyl = 1;

d317 1
a317 2
			    xddummystrat,
			    xd->sc_dk.dk_label, 0);
d320 1
a320 1
		return(XD_ERR_FAIL);
a322 3
#ifdef FIXME
	struct sun_disklabel *sdl;

d324 1
a324 1
	sdl = (struct sun_disklabel *)xd->sc_dk.dk_cpulabel->cd_block;
d329 3
a331 3
							xd->sc_dev.dv_xname);
		xd->pcyl = xd->sc_dk.dk_label->d_ncylinders +
			xd->sc_dk.dk_label->d_acylinders;
d333 1
a333 1
			xd->sc_dev.dv_xname, xd->pcyl);
a334 1
#endif
d336 7
a342 9
	xd->ncyl = xd->sc_dk.dk_label->d_ncylinders;
	xd->acyl = xd->sc_dk.dk_label->d_acylinders;
	xd->nhead = xd->sc_dk.dk_label->d_ntracks;
	xd->nsect = xd->sc_dk.dk_label->d_nsectors;
	xd->sectpercyl = xd->sc_dk.dk_label->d_secpercyl =
	    xd->nhead * xd->nsect;
	xd->sc_dk.dk_label->d_secsize = XDFM_BPS; /* not handled by
						  * sun->bsd */
	return(XD_ERR_AOK);
d649 1
a649 1
	for (lcv = 0; lcv < 126; lcv++)	/* init empty bad144 table */
d712 1
a712 1
	for (lcv = 0; lcv < 126; lcv++) {
d724 1
a724 1
	if (lcv != 126) {
@


1.38
log
@more XXsize() fallout
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.37 2007/06/06 17:15:12 deraadt Exp $	*/
a298 1
	struct sun_disklabel *sdl;
d309 1
a309 1
			    xd->sc_dk.dk_label, xd->sc_dk.dk_cpulabel, 0);
d315 3
d330 1
d865 1
a865 2
		    (struct disklabel *) addr, /* xd->sc_dk.dk_openmask : */ 0,
		    xd->sc_dk.dk_cpulabel);
d885 1
a885 2
		    (struct disklabel *) addr, /* xd->sc_dk.dk_openmask : */ 0,
		    xd->sc_dk.dk_cpulabel);
d893 1
a893 1
			    xd->sc_dk.dk_label, xd->sc_dk.dk_cpulabel);
d1074 1
a1074 1
	    xd->sc_dk.dk_cpulabel, (xd->flags & XD_WLABEL) != 0) <= 0)
@


1.37
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.36 2007/06/05 00:38:18 deraadt Exp $	*/
d989 1
a989 1
int
@


1.36
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.35 2007/04/29 18:59:37 krw Exp $	*/
d783 1
a783 1
	daddr_t blkno;
d1413 3
a1415 2
	printf("xdc_startbuf: %s%c: %s block %d\n", xdsc->sc_dev.dv_xname,
	    'a' + partno, (bp->b_flags & B_READ) ? "read" : "write", bp->b_blkno);
@


1.35
log
@Replace expansions of DISKLABELDEV() with DISKLABELDEV(). Shorter, and
more consistant. No change to code.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.34 2007/02/15 00:53:26 krw Exp $	*/
d1012 1
a1012 1
		size = xdsc->sc_dk.dk_label->d_partitions[part].p_size *
d1428 1
a1428 1
	    xdsc->sc_dk.dk_label->d_partitions[partno].p_offset);
@


1.34
log
@Don't print the error strings returned by readdisklabel().  If you
need the debug info uncomment the printf's you need. Crude but
effective way to suppress 'no disklabel' errors that pop up at the
most innconvenient times to frighten users. More elegant method,
DPRINTF-like constructs or something, later.

"Yay!" marco@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.33 2006/12/03 16:40:43 miod Exp $	*/
d891 2
a892 3
			error = writedisklabel(MAKEDISKDEV(major(dev), DISKUNIT(dev), RAW_PART),
			    xdstrategy, xd->sc_dk.dk_label,
			    xd->sc_dk.dk_cpulabel);
@


1.33
log
@Initialize more fields of the proto disklabel before invoking readdisklabel(),
to pass its recent sanity checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.32 2006/03/15 20:20:41 miod Exp $	*/
d312 1
a312 1
		printf("%s: %s\n", xd->sc_dev.dv_xname, err);
@


1.32
log
@Nuke dk_establish(), no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.31 2006/01/20 23:27:25 miod Exp $	*/
d304 1
a304 1
	/* Required parameter for readdisklabel() */
d306 1
d333 2
a334 1
	xd->sectpercyl = xd->nhead * xd->nsect;
@


1.31
log
@b_un.b_addr -> b_data; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.30 2006/01/20 00:20:38 miod Exp $	*/
a730 2

	dk_establish(&xd->sc_dk, &xd->sc_dev);		/* XXX */
@


1.30
log
@Use <dev/sun/disklabel.h> instead of similar <machine/sun_disklabel.h> on
sparc and remove unused sun_dkioctl(). No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.29 2004/09/29 07:35:11 miod Exp $	*/
d288 1
a288 1
	bcopy(xd_labeldata, bp->b_un.b_addr, XDFM_BPS);
d1732 1
a1732 1
				    (vaddr_t)iorq->buf->b_un.b_addr,
d1939 1
a1939 1
				    (vaddr_t) bp->b_un.b_addr,
@


1.29
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.28 2004/02/15 02:45:46 tedu Exp $	*/
d82 1
a82 1
#include <machine/sun_disklabel.h>
@


1.28
log
@new arg to disk_unbusy, to record separate read/write statistics.
looked at by various, testing henning@@ mcbride@@ dan weeks
mostly from netbsd via Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.27 2004/01/12 11:35:08 jmc Exp $	*/
d491 2
a492 3
			  ca->ca_ra.ra_intr[0].int_pri, &xdc->sc_ih, IPL_BIO);
	evcnt_attach(&xdc->sc_dev, "intr", &xdc->sc_intrcnt);

a1141 4

	/* kick the event counter */

	xdcsc->sc_intrcnt.ev_count++;
@


1.27
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.26 2003/09/29 09:08:19 miod Exp $	*/
d1741 2
a1742 1
				xdcsc->reqs[lcv].buf->b_resid));
d1947 2
a1948 1
			    (bp->b_bcount - bp->b_resid));
@


1.26
log
@avaliable -> available
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.25 2003/08/15 20:32:14 tedu Exp $	*/
d2367 1
a2367 1
		return ("Fatail VMEDMA error");
d2373 1
a2373 1
		return ("Header error/cyliner");
@


1.25
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.24 2002/06/08 18:52:45 art Exp $	*/
d1494 1
a1494 1
 * on the iorq free list until some iopbs are avaliable.
@


1.24
log
@Use tsleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.23 2002/05/29 08:28:36 art Exp $	*/
d902 1
a902 1
		if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.23
log
@splbio around biodone.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.22 2002/04/30 01:12:29 art Exp $	*/
d1526 1
a1526 1
				sleep(iorq, PRIBIO);
d1558 1
a1558 1
			sleep(iorq, PRIBIO);
@


1.22
log
@Fix an ancient problem in how sparc interrupts are handled.

There are many interrupt handlers that assume that they don't need to do
any spl protection in their code because the interrupt of some level can't
be interrupted by an interrupt of the same level. The problem is that some
interrupt handlers have hardware levels that are lower then their "software"
levels.

Fix this by adding an additional field to struct intrhand that specifies which
"software" level an interrupt handler has and blocks that level while handling
the interrupt. This new field is initialized in intr_establish which gets
an additional argument (which can be -1 meaning that the interrupt handler
doesn't need to block any additional level).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.21 2002/03/14 01:26:43 millert Exp $	*/
d1124 1
d1126 1
@


1.21
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.20 2001/11/06 19:53:16 miod Exp $	*/
d491 1
a491 1
			  ca->ca_ra.ra_intr[0].int_pri, &xdc->sc_ih);
@


1.20
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.19 2001/09/11 20:05:24 miod Exp $	*/
d210 10
a219 10
int	xdc_cmd __P((struct xdc_softc *, int, int, int, int, int, char *, int));
char   *xdc_e2str __P((int));
int	xdc_error __P((struct xdc_softc *, struct xd_iorq *,
		   struct xd_iopb *, int, int));
int	xdc_ioctlcmd __P((struct xd_softc *, dev_t dev, struct xd_iocmd *));
void	xdc_perror __P((struct xd_iorq *, struct xd_iopb *, int));
int	xdc_piodriver __P((struct xdc_softc *, int, int));
int	xdc_remove_iorq __P((struct xdc_softc *));
int	xdc_reset __P((struct xdc_softc *, int, int, int, struct xd_softc *));
inline void xdc_rqinit __P((struct xd_iorq *, struct xdc_softc *,
d221 7
a227 7
			    caddr_t, struct buf *));
void	xdc_rqtopb __P((struct xd_iorq *, struct xd_iopb *, int, int));
void	xdc_start __P((struct xdc_softc *, int));
int	xdc_startbuf __P((struct xdc_softc *, struct xd_softc *, struct buf *));
int	xdc_submit_iorq __P((struct xdc_softc *, int, int));
void	xdc_tick __P((void *));
void	xdc_xdreset __P((struct xdc_softc *, struct xd_softc *));
d230 1
a230 1
int	xdcintr __P((void *));
d233 4
a236 4
int	xdcmatch __P((struct device *, void *, void *));
void	xdcattach __P((struct device *, struct device *, void *));
int	xdmatch __P((struct device *, void *, void *));
void	xdattach __P((struct device *, struct device *, void *));
d238 2
a239 2
static	void xddummystrat __P((struct buf *));
int	xdgetdisklabel __P((struct xd_softc *, void *));
@


1.20.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.20 2001/11/06 19:53:16 miod Exp $	*/
d210 10
a219 10
int	xdc_cmd(struct xdc_softc *, int, int, int, int, int, char *, int);
char   *xdc_e2str(int);
int	xdc_error(struct xdc_softc *, struct xd_iorq *,
		   struct xd_iopb *, int, int);
int	xdc_ioctlcmd(struct xd_softc *, dev_t dev, struct xd_iocmd *);
void	xdc_perror(struct xd_iorq *, struct xd_iopb *, int);
int	xdc_piodriver(struct xdc_softc *, int, int);
int	xdc_remove_iorq(struct xdc_softc *);
int	xdc_reset(struct xdc_softc *, int, int, int, struct xd_softc *);
inline void xdc_rqinit(struct xd_iorq *, struct xdc_softc *,
d221 7
a227 7
			    caddr_t, struct buf *);
void	xdc_rqtopb(struct xd_iorq *, struct xd_iopb *, int, int);
void	xdc_start(struct xdc_softc *, int);
int	xdc_startbuf(struct xdc_softc *, struct xd_softc *, struct buf *);
int	xdc_submit_iorq(struct xdc_softc *, int, int);
void	xdc_tick(void *);
void	xdc_xdreset(struct xdc_softc *, struct xd_softc *);
d230 1
a230 1
int	xdcintr(void *);
d233 4
a236 4
int	xdcmatch(struct device *, void *, void *);
void	xdcattach(struct device *, struct device *, void *);
int	xdmatch(struct device *, void *, void *);
void	xdattach(struct device *, struct device *, void *);
d238 2
a239 2
static	void xddummystrat(struct buf *);
int	xdgetdisklabel(struct xd_softc *, void *);
d491 1
a491 1
			  ca->ca_ra.ra_intr[0].int_pri, &xdc->sc_ih, IPL_BIO);
a1123 1
	s = splbio();
a1124 1
	splx(s);
d1524 1
a1524 1
				tsleep(iorq, PRIBIO, "xdiorq", 0);
d1556 1
a1556 1
			tsleep(iorq, PRIBIO, "xdiorq", 0);
@


1.19
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.18 2001/03/24 10:07:20 ho Exp $	*/
d79 1
a79 1
#include <vm/vm.h>
@


1.18
log
@Convert to new timeout API. art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.17 2001/02/22 22:11:46 art Exp $	*/
a79 1
#include <vm/vm_kern.h>
@


1.17
log
@ifdef sparc -> ifdef __sparc__
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.16 2000/11/10 15:33:07 provos Exp $	*/
d77 1
d513 2
a514 1
	timeout(xdc_tick, xdc, XDC_TICKCNT);
d2161 1
a2161 1
	timeout(xdc_tick, xdcsc, XDC_TICKCNT);
@


1.16
log
@seperate -> separate, okay aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.15 2000/07/04 13:15:12 art Exp $	*/
d1234 1
a1234 1
#ifdef sparc
@


1.15
log
@missing splx
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.14 1999/07/09 21:34:46 art Exp $	*/
d1312 1
a1312 1
 * there is no need to do this).    NORM requests are handled seperately.
@


1.14
log
@vm_offset_t -> {v,p}addr_t and vm_size_t -> {v,p}size_t
remove "register" keywords
Various cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.13 1998/10/03 21:18:58 millert Exp $	*/
d1109 1
@


1.14.4.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.18 2001/03/24 10:07:20 ho Exp $	*/
a76 1
#include <sys/timeout.h>
d512 1
a512 2
	timeout_set(&xdc->xdc_tick_tmo, xdc_tick, xdc);
	timeout_add(&xdc->xdc_tick_tmo, XDC_TICKCNT);
a1108 1
		splx(s);
d1233 1
a1233 1
#ifdef __sparc__
d1311 1
a1311 1
 * there is no need to do this).    NORM requests are handled separately.
d2158 1
a2158 1
	timeout_add(&xdcsc->xdc_tick_tmo, XDC_TICKCNT);
@


1.14.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.14.4.1 2001/05/14 21:37:10 niklas Exp $	*/
d80 1
@


1.14.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d79 1
a79 1
#include <uvm/uvm_extern.h>
@


1.14.4.4
log
@Merge in -current from about a week ago
@
text
@d210 10
a219 10
int	xdc_cmd(struct xdc_softc *, int, int, int, int, int, char *, int);
char   *xdc_e2str(int);
int	xdc_error(struct xdc_softc *, struct xd_iorq *,
		   struct xd_iopb *, int, int);
int	xdc_ioctlcmd(struct xd_softc *, dev_t dev, struct xd_iocmd *);
void	xdc_perror(struct xd_iorq *, struct xd_iopb *, int);
int	xdc_piodriver(struct xdc_softc *, int, int);
int	xdc_remove_iorq(struct xdc_softc *);
int	xdc_reset(struct xdc_softc *, int, int, int, struct xd_softc *);
inline void xdc_rqinit(struct xd_iorq *, struct xdc_softc *,
d221 7
a227 7
			    caddr_t, struct buf *);
void	xdc_rqtopb(struct xd_iorq *, struct xd_iopb *, int, int);
void	xdc_start(struct xdc_softc *, int);
int	xdc_startbuf(struct xdc_softc *, struct xd_softc *, struct buf *);
int	xdc_submit_iorq(struct xdc_softc *, int, int);
void	xdc_tick(void *);
void	xdc_xdreset(struct xdc_softc *, struct xd_softc *);
d230 1
a230 1
int	xdcintr(void *);
d233 4
a236 4
int	xdcmatch(struct device *, void *, void *);
void	xdcattach(struct device *, struct device *, void *);
int	xdmatch(struct device *, void *, void *);
void	xdattach(struct device *, struct device *, void *);
d238 2
a239 2
static	void xddummystrat(struct buf *);
int	xdgetdisklabel(struct xd_softc *, void *);
@


1.14.4.5
log
@Sync the SMP branch with 3.3
@
text
@d491 1
a491 1
			  ca->ca_ra.ra_intr[0].int_pri, &xdc->sc_ih, IPL_BIO);
a1123 1
	s = splbio();
a1124 1
	splx(s);
d1524 1
a1524 1
				tsleep(iorq, PRIBIO, "xdiorq", 0);
d1556 1
a1556 1
			tsleep(iorq, PRIBIO, "xdiorq", 0);
@


1.14.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d902 1
a902 1
		if ((error = suser(p, 0)) != 0)
d1494 1
a1494 1
 * on the iorq free list until some iopbs are available.
d2367 1
a2367 1
		return ("Fatal VMEDMA error");
d2373 1
a2373 1
		return ("Header error/cylinder");
@


1.14.4.7
log
@Merge with the trunk
@
text
@d1741 1
a1741 2
				xdcsc->reqs[lcv].buf->b_resid),
				(xdcsc->reqs[lcv].buf->b_flags & B_READ));
d1946 1
a1946 2
			    (bp->b_bcount - bp->b_resid),
			    (bp->b_flags & B_READ));
@


1.13
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.12 1998/03/01 08:42:19 johns Exp $	*/
d1713 1
a1713 1
		register struct xd_iorq *iorq = &xdcsc->reqs[lcv];
d1732 2
a1733 3
			    dvma_mapout(
				    (vm_offset_t)iorq->dbufbase,
				    (vm_offset_t)iorq->buf->b_un.b_addr,
d1938 2
a1939 2
			dvma_mapout((vm_offset_t) iorq->dbufbase,
				    (vm_offset_t) bp->b_un.b_addr,
@


1.12
log
@Fixed declaration of iorqno in xd_piodriver(),
should have been int, used to be a char.
Prototype for xd_piodriver() also said int..
Fix required for gcc 2.8 ...
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.11 1997/08/08 21:46:50 niklas Exp $	*/
d309 1
a309 1
			    xd->sc_dk.dk_label, xd->sc_dk.dk_cpulabel);
@


1.11
log
@Change the bounds_check_with_label API to also take a cpu_disklabel
reference for making transferral of meta-information possible from
readdisklabel to bounds_check_with_label.  The first (and maybe only)
thing that will use this is the multi-disklabel-format code on the
alpha where the labelsector is passed via cpu_disklabel so the label
write-protection can work correctly no matter what label was found.

Also use a new macro DKBAD to get at the dkbad field of the cpu_disklabel
implementations that contain it.  This too is for multi-disklabel
architectures where the "bad" field can be inside a union.  Use this
macro as a means for a driver to check if an architecture supports
dkbad constructs.

Remove proto of bounds_check_with_label from all MD disklabel.h as it
is in sys/disklabel.h.

I have not been able to test the changes everywhere, if I break anything
I apologize, and promise to fix it as soon as I become aware of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: xd.c,v 1.10 1997/08/08 08:25:35 downsj Exp $	*/
d1578 2
a1579 2
	char    iorqno;
	int     freeone;
@


1.10
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1074 1
a1074 1
		(xd->flags & XD_WLABEL) != 0) <= 0)
@


1.9
log
@repair XDC_HWAIT macro to handle the fact that waithead is now
unsigned.   should fix xdc watchdog timeouts noted in port-sparc
by nathanw@@mit.edu.
@
text
@d1 2
a2 1
/*	$NetBSD: xd.c,v 1.25 1996/04/22 02:42:06 christos Exp $	*/
d40 1
a40 1
 * id: $NetBSD: xd.c,v 1.25 1996/04/22 02:42:06 christos Exp $
d89 1
d351 1
a351 1
int xdcmatch(parent, match, aux)
d353 1
a353 1
	void   *match, *aux;
d355 1
a355 1
	struct cfdata *cf = match;
d364 7
a370 1
	if (CPU_ISSUN4) {
d378 1
a379 1
	return (1);
d400 1
a400 2
	ca->ca_ra.ra_vaddr = mapiodev(ca->ca_ra.ra_reg, 0,
	    sizeof(struct xdc), ca->ca_bustype);
d473 1
a473 1
	printf(": Xylogics 753/7053, PROM=%x.%02x.%02x\n",
d524 1
a524 1
xdmatch(parent, match, aux)
d526 1
a526 2
	void   *match, *aux;

d528 1
a528 1
	struct cfdata *cf = match;
d996 1
a996 1
	int     part, size;
d998 4
a1001 1
	/* valid unit?  try an open */
d1003 4
a1006 1
	if (xdopen(dev, 0, S_IFBLK, NULL) != 0)
a1009 3

	xdsc = xd_cd.cd_devs[DISKUNIT(dev)];
	part = DISKPART(dev);
d1013 5
a1017 4
		size = xdsc->sc_dk.dk_label->d_partitions[part].p_size;
	if (xdclose(dev, 0, S_IFBLK, NULL) != 0)
		return -1;
	return size;
d1234 1
a1234 1
			if (CPU_ISSUN4 && cpumod == SUN4_300)
@


1.8
log
@netbsd port, now we merge our changes back in
@
text
@d106 2
a107 1
	(SC)->waithead = ((SC)->waithead - 1) % XDC_MAXIOPB; \
@


1.7
log
@Fix two bugs reported by Don Koch <aardvark@@poirot.krl.com>(NetBSD PR#216{8,9})
 [1] check return value from malloc() for NULL before trying to bzero it.
 [2] use "=" rather than "|=" when writing to CSR (otherwise you may
        ACK something you don't mean to!).
@
text
@d1 1
a1 1
/* $NetBSD: xd.c,v 1.11 1996/01/07 22:03:02 thorpej Exp $ */
d39 1
a39 1
 * id: $Id: xd.c,v 1.6 1996/02/08 04:43:45 chuck Exp $
a63 1
#include <sys/conf.h>
d75 2
d82 1
d220 1
a220 1
int	xdc_start __P((struct xdc_softc *, int));
d224 1
a224 1
int	xdc_xdreset __P((struct xdc_softc *, struct xd_softc *));
a228 10
/* {b,c}devsw */
int	xdclose __P((dev_t, int, int));
int	xddump __P((dev_t));
int	xdioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int	xdopen __P((dev_t, int, int));
int	xdread __P((dev_t, struct uio *));
int	xdwrite __P((dev_t, struct uio *));
int	xdsize __P((dev_t));
void	xdstrategy __P((struct buf *));

d242 11
a252 2
struct cfdriver xdccd = {
	NULL, "xdc", xdcmatch, xdcattach, DV_DULL, sizeof(struct xdc_softc)
d255 2
a256 2
struct cfdriver xdcd = {
	NULL, "xd", xdmatch, xdattach, DV_DISK, sizeof(struct xd_softc)
d317 1
a317 1
		printf("%s: WARNING: no `pcyl' in disk label.\n", 
d321 1
a321 1
		printf("%s: WARNING: guessing pcyl=%d (ncyl+acyl)\n", 
d361 1
a361 1
	if (cputyp == CPU_SUN4) {
d363 1
a363 1
		if (probeget(&xdc->xdc_csr, 1) == -1)
d376 1
a376 1
void 
d404 1
a404 1
	 * 
d515 1
a515 1
int 
a520 1
	struct xdc_softc *xdc = (void *) parent;
d537 1
a537 1
void 
d546 1
a546 1
	int     rqno, err, spt, mb, blk, lcv, fmode, s, newstate;
d720 1
a720 1
		if (bp && strcmp("xd", bp->name) == 0 && 
d722 1
a722 1
			bootdv = &xd->sc_dev;
d746 2
a747 2
int 
xdclose(dev, flag, fmt)
d750 1
a750 1

d752 1
a752 1
	struct xd_softc *xd = xdcd.cd_devs[DISKUNIT(dev)];
d773 6
a778 4
int 
xddump(dev)
	dev_t   dev;

d784 1
a784 1
	if (unit >= xdcd.cd_ndevs)
d788 1
a788 1
	xd = xdcd.cd_devs[unit];
d800 1
a800 1
	 * 
d804 1
a804 1
	 * 
d812 1
a812 1
int 
d827 1
a827 1
	if (unit >= xdcd.cd_ndevs || (xd = xdcd.cd_devs[unit]) == NULL)
d906 2
a907 2
int 
xdopen(dev, flag, fmt)
d910 1
a910 1

d919 1
a919 1
	if (unit >= xdcd.cd_ndevs || (xd = xdcd.cd_devs[unit]) == NULL)
d959 1
a959 1
xdread(dev, uio)
d962 1
d969 1
a969 1
xdwrite(dev, uio)
d972 1
d983 1
a983 1
int 
d989 1
a989 1
	int     unit, part, size;
d993 1
a993 1
	if (xdopen(dev, 0, S_IFBLK) != 0)
d998 1
a998 1
	xdsc = xdcd.cd_devs[DISKUNIT(dev)];
d1004 1
a1004 1
	if (xdclose(dev, 0, S_IFBLK) != 0)
d1012 1
a1012 1
void 
d1027 1
a1027 1
	if (unit >= xdcd.cd_ndevs || (xd = xdcd.cd_devs[unit]) == 0 ||
d1069 1
a1069 1
	 * 
d1122 1
a1122 1
int 
a1127 2
	struct xd_softc *xd;
	struct buf *bp;
d1161 1
a1161 1
inline void 
d1186 1
a1186 1
void 
d1223 1
a1223 1
			if (cputyp == CPU_SUN4 && cpumod == SUN4_300)
d1302 1
a1302 1
int 
a1310 1
	u_long  dp;
d1368 1
a1368 1
int 
d1379 1
a1379 1
	u_long  block, dp;
d1413 1
a1413 1
	 * 
d1483 1
a1483 1
int 
d1564 1
a1564 1
int 
d1642 1
a1642 1
int 
d1676 1
a1676 1
int 
d1683 1
a1683 1
	int     del = 0, lcv, poll = -1, retval = XD_ERR_AOK;
d1726 1
a1726 1
				(xdcsc->reqs[lcv].buf->b_bcount - 
d1774 1
a1774 1
int 
d1794 1
a1794 1
int 
a1800 1
	u_long  addr;
d1824 1
a1824 1
	 * 
d1892 1
a1892 1
			 * 
d1960 1
a1960 1
void 
d1993 1
a1993 1
int 
d2065 1
a2065 1
void 
d2073 1
a2073 1
	int     wait, run, free, done, whd;
d2103 1
a2103 1
				printf("MARK: running %d: mode %d done %d errs %d errno 0x%x ttl %d buf %x\n",
d2157 1
a2157 1
int 
d2251 1
a2251 1
			if (err = copyin(xio->dptr, buf, xio->dlen)) {
@


1.6
log
@- moved disk_busy() call from xdstrategy() to xdc_startbuf()
        [prevents disk_unbusy panic when disk is loaded (if no
        free IOPBs, xdstrategy() would queue the buffer for pickup
        by xdcintr() but xdcintr() would never call disk_busy().
        xdc_startbuf() is a better place since all bufs are routed
        through here]   problem detected by girish@@dworkin.wustl.edu,
        diagnosed and corrected by me.
- move disk_unbusy() call in xdc_remove_iorq() before the call to
        XDC_FREE() [don't want to access a data structure that was just put
        on a free list]
@
text
@d39 1
a39 1
 * id: $Id: xd.c,v 1.5 1996/01/13 03:45:01 chuck Exp $
d146 1
a146 1
	(XDC)->xdc_csr |= XDC_ADDIOPB; /* go! */ \
a417 1
	bzero(xdc->reqs, XDC_MAXIOPB * sizeof(struct xd_iorq));
d420 1
d1665 1
a1665 1
		xdcsc->xdc->xdc_csr |= XDC_CLRRIO;	/* clear RIO */
d1836 1
a1836 1
		xdc->xdc_csr |= XDC_CLRRIO;
@


1.5
log
@ - call mapiodev() with sizeof(struct xdc/xyc) rather than ra_len (which is
	zero since xdcmatch/xycmatch no longer sets it).   [if you call
	mapiodev() with a zero size it will reuse the KVA it returns, swiping
	the device out from under you!]
 - make xdc/xyc->iopbase point in the kernels DVMA space rather than at the
	normal malloc'd KVA.   this isn't compatable with sun4m [doesn't
	have a kernel DVMA space] and will need to be changed later (XXX).
 - move disk_attach() to before reading the disk label as per Jason.
	otherwise we are reading into an unallocated buffer (oops!)
@
text
@d39 1
a39 1
 * id: $Id: xd.c,v 1.4 1996/01/12 23:09:08 chuck Exp $
a1096 3
	/* Instrumentation. */
	disk_busy(&xd->sc_dk);

d1441 3
a1930 1
			XDC_FREE(xdcsc, rqno);
d1933 1
@


1.4
log
@we no longer need to add in the offset to the mapped VA to get the correct
device address (bus_tmp, bus_map, and mapiodev now do this for us).

also, we handle all our mappings, so don't have obio.c do any for us
(i.e. don't set ra->ra_len in xycmatch).

nuke uneeded variable in match function.
@
text
@d39 1
a39 1
 * id: $Id: xd.c,v 1.3 1996/01/12 20:20:51 deraadt Exp $
d391 1
a391 1
	    ca->ca_ra.ra_len, ca->ca_bustype);
d411 1
d656 3
a723 3

	/* Attach the disk. */
	disk_attach(&xd->sc_dk);
@


1.3
log
@from netbsd;
New generic disk framework.  Highlights:
New metrics handling.  Metrics are now kept in the new `struct disk'.
Busy time is now stored as a timeval, and transfer count in bytes.
Storage for disklabels is now dynamically allocated, so that the size
of the disk structure is not machine-dependent.
Several new functions for attaching and detaching disks, and handling
metrics calculation.
Old-style instrumentation is still supported in drivers that did it
before.  However, old-style instrumentation is being deprecated, and
will go away once the userland utilities are updated for the new
framework.
For usage and architectural details, see the forthcoming disk(9)
manual page.
@
text
@d39 1
a39 1
 * id: $Id: xd.c,v 1.11 1996/01/07 22:03:02 thorpej Exp $
a355 1
	void	*vaddr;
d361 1
a361 4
		vaddr = ra->ra_vaddr;
		if ((u_long) ra->ra_paddr & PGOFSET)
			(u_long) vaddr |= ((u_long) ra->ra_paddr & PGOFSET);
		xdc = (struct xdc *) vaddr;
a367 1
		ra->ra_len = NBPG;
a391 3
	if ((u_long) ca->ca_ra.ra_paddr & PGOFSET)
		(u_long) ca->ca_ra.ra_vaddr |=
				((u_long) ca->ca_ra.ra_paddr & PGOFSET);
@


1.2
log
@new mapdev/()/mapiodev() calling convention uses "struct rom_reg *" to supply
base plus an offset
new dvma routines
@
text
@d1 1
a1 1
/* $NetBSD: xd.c,v 1.10 1995/12/11 12:40:20 pk Exp $ */
d39 1
a39 1
 * id: $Id: xd.c,v 1.10 1995/12/11 12:40:20 pk Exp $
d301 1
a301 1
	xd->sc_dk.dk_label.d_secsize = XDFM_BPS;
d305 1
a305 1
			    &xd->sc_dk.dk_label, &xd->sc_dk.dk_cpulabel);
d312 1
a312 1
	sdl = (struct sun_disklabel *)xd->sc_dk.dk_cpulabel.cd_block;
d318 2
a319 2
		xd->pcyl = xd->sc_dk.dk_label.d_ncylinders +
			xd->sc_dk.dk_label.d_acylinders;
d324 4
a327 4
	xd->ncyl = xd->sc_dk.dk_label.d_ncylinders;
	xd->acyl = xd->sc_dk.dk_label.d_acylinders;
	xd->nhead = xd->sc_dk.dk_label.d_ntracks;
	xd->nsect = xd->sc_dk.dk_label.d_nsectors;
d329 1
a329 1
	xd->sc_dk.dk_label.d_secsize = XDFM_BPS; /* not handled by
d558 8
a721 2
		xd->sc_dk.dk_driver = &xddkdriver;	/* link in dkdriver */

d729 4
a732 1
	dk_establish(&xd->sc_dk, &xd->sc_dev);
d847 1
a847 1
		bcopy(&xd->sc_dk.dk_label, addr, sizeof(struct disklabel));
d851 1
a851 1
		((struct partinfo *) addr)->disklab = &xd->sc_dk.dk_label;
d853 1
a853 1
		    &xd->sc_dk.dk_label.d_partitions[DISKPART(dev)];
d859 1
a859 1
		error = setdisklabel(&xd->sc_dk.dk_label,
d861 1
a861 1
		    &xd->sc_dk.dk_cpulabel);
d880 1
a880 1
		error = setdisklabel(&xd->sc_dk.dk_label,
d882 1
a882 1
		    &xd->sc_dk.dk_cpulabel);
d890 2
a891 2
			    xdstrategy, &xd->sc_dk.dk_label,
			    &xd->sc_dk.dk_cpulabel);
d944 2
a945 2
	    (part >= xd->sc_dk.dk_label.d_npartitions ||
		xd->sc_dk.dk_label.d_partitions[part].p_fstype == FS_UNUSED)) {
d1003 1
a1003 1
	if (xdsc->sc_dk.dk_label.d_partitions[part].p_fstype != FS_SWAP)
d1006 1
a1006 1
		size = xdsc->sc_dk.dk_label.d_partitions[part].p_size;
d1032 1
a1032 1
	    (bp->b_bcount % xd->sc_dk.dk_label.d_secsize) != 0) {
d1065 1
a1065 1
	if (bounds_check_with_label(bp, &xd->sc_dk.dk_label,
d1103 4
d1428 1
a1428 1
	    xdsc->sc_dk.dk_label.d_partitions[partno].p_offset);
d1731 3
d1939 2
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $NetBSD: xd.c,v 1.9 1995/09/25 20:12:44 chuck Exp $ */
d39 1
a39 1
 * id: $Id: xd.c,v 1.9 1995/09/25 20:12:44 chuck Exp $
a201 5
/* external (XXX should migrate to std include file?) */
extern caddr_t dvma_malloc __P((size_t));
extern void dvma_free __P((caddr_t, size_t));
extern caddr_t dvma_mapin __P((struct vm_map *, vm_offset_t, int, int));
extern void dvma_mapout __P((vm_offset_t, vm_offset_t, int));
d260 2
a261 1
	char	*dvmabuf;	/* scratch buffer for reading disk label */
d395 1
a395 1
	ca->ca_ra.ra_vaddr = mapiodev(ca->ca_ra.ra_paddr,
d416 3
a418 2
	xdc->iopbase = (struct xd_iopb *)
	    dvma_malloc(XDC_MAXIOPB * sizeof(struct xd_iopb));	/* KVA */
d420 1
d422 1
d494 1
a494 1
	xa.dvmabuf = (char *) dvma_malloc(XDFM_BPS);
d506 1
a506 1
	dvma_free(xa.dvmabuf, XDFM_BPS);
d655 1
a655 1
	if (xdgetdisklabel(xd, xa->dvmabuf) != XD_ERR_AOK)
d660 1
a660 1
		xa->dvmabuf, xd->pcyl, spt);
d693 1
a693 1
	dkb = (struct dkbad *) xa->dvmabuf;
d710 1
a710 1
		bcopy(xa->dvmabuf, &xd->dkb, XDFM_BPS);
d923 1
a923 1
		xa.dvmabuf = (char *) dvma_malloc(XDFM_BPS);
d927 1
a927 1
		dvma_free(xa.dvmabuf, XDFM_BPS);
d1031 1
a1031 1
		xa.dvmabuf = (char *) dvma_malloc(XDFM_BPS);
d1035 1
a1035 1
		dvma_free(xa.dvmabuf, XDFM_BPS);
a1067 24
	{			/* XXX DVMA mapin */

		/* DVMA: if we've got a kernel buf structure we map it into
		 * DVMA space here.   the advantage to this is that it allows
		 * us to sleep if there isn't space in the DVMA area.   the
		 * disadvantage to this is that we are mapping this in earlier
		 * than we have to, and thus possibly wasting DVMA space.   in
		 * an ideal world we would like to map it in once we know we
		 * can submit an IOPB (at this point we don't know if we can
		 * submit or not).   (XXX) If the DVMA system gets redone this
		 * mapin can be moved elsewhere. */

		caddr_t x;
		if ((bp->b_flags & B_PHYS) == 0) {
			x = dvma_mapin(kernel_map, (vm_offset_t)bp->b_data,
					bp->b_bcount, 1);
			if (x == NULL)
				panic("xd mapin");
			bp->b_resid = (long) x;	/* XXX we store DVMA addr in
						 * b_resid, thus overloading
						 * it */
		}
	} /* XXX end DVMA mapin */

a1070 1

d1077 2
a1078 1
	 * buffs will get picked up later by xdcintr(). */
d1089 1
a1090 1

d1410 2
a1411 11
	 * also, note that there are two kinds of buf structures, those with
	 * B_PHYS set and those without B_PHYS.   if B_PHYS is set, then it is
	 * a raw I/O (to a cdevsw) and we are doing I/O directly to the users'
	 * buffer which has already been mapped into DVMA space. however, if
	 * B_PHYS is not set, then the buffer is a normal system buffer which
	 * does *not* live in DVMA space.   in that case we call dvma_mapin to
	 * map it into DVMA space so we can do the DMA I/O to it.
	 * 
	 * in cases where we do a dvma_mapin, note that iorq points to the buffer
	 * as mapped into DVMA space, where as the bp->b_data points to its
	 * non-DVMA mapping.
d1417 12
a1428 25
	if ((bp->b_flags & B_PHYS) == 0) {
		dbuf = (caddr_t) bp->b_resid;	/* XXX: overloaded resid from
						 * xdstrategy() */
		bp->b_resid = bp->b_bcount;	/* XXX? */
#ifdef someday

		/* XXX: this is where we would really like to do the DVMA
		 * mapin, but we get called from intr here so we can't sleep
		 * so we can't do it. */
		/* allocate DVMA, map in */

		if (dbuf == NULL) {	/* out of DVMA space */
			printf("%s: warning: out of DVMA space\n", xdcsc->sc_dev.dv_xname);
			XDC_FREE(xdcsc, rqno);
			wq = &xdcsc->sc_wq;	/* put at end of queue */
			bp->b_actf = 0;
			bp->b_actb = wq->b_actb;
			*wq->b_actb = bp;
			wq->b_actb = &bp->b_actf;
			return (XD_ERR_FAIL);	/* XXX: need some sort of
						 * call-back scheme here? */
		}
#endif				/* someday */
	} else {
		dbuf = bp->b_data;
d1695 5
a1699 3
		if (XD_STATE(xdcsc->reqs[lcv].mode) != XD_SUB_POLL &&
		    XD_STATE(xdcsc->reqs[lcv].mode) != XD_SUB_WAIT &&
		    XD_STATE(xdcsc->reqs[lcv].mode) != XD_SUB_NORM)
d1706 1
a1706 1
			xdcsc->reqs[lcv].errno = error;
d1710 9
a1718 11
			    xdcsc->reqs[lcv].buf->b_error = EIO;
			    xdcsc->reqs[lcv].buf->b_flags |= B_ERROR;
			    xdcsc->reqs[lcv].buf->b_resid =
			       xdcsc->reqs[lcv].sectcnt * XDFM_BPS;
			    if ((xdcsc->reqs[lcv].buf->b_flags & B_PHYS) == 0) {
				dvma_mapout(
				    (vm_offset_t)xdcsc->reqs[lcv].dbufbase,
				    (vm_offset_t)xdcsc->reqs[lcv].buf->b_un.b_addr,
				    xdcsc->reqs[lcv].buf->b_bcount);
				}
			    biodone(xdcsc->reqs[lcv].buf);
d1722 1
a1722 1
			    wakeup(&xdcsc->reqs[lcv]);
d1725 2
a1726 2
			    xdcsc->reqs[lcv].mode =
				XD_NEWSTATE(xdcsc->reqs[lcv].mode, XD_SUB_DONE);
d1919 3
a1921 5
			if ((bp->b_flags & B_PHYS) == 0) {
				dvma_mapout((vm_offset_t) iorq->dbufbase,
					    (vm_offset_t) bp->b_un.b_addr,
					    bp->b_bcount);
			}
d2154 1
a2154 1
	caddr_t dvmabuf = NULL;
d2238 1
a2238 1
		dvmabuf = dvma_malloc(xio->dlen);
d2240 2
a2241 2
			if (err = copyin(xio->dptr, dvmabuf, xio->dlen)) {
				dvma_free(dvmabuf, xio->dlen);
d2262 1
a2262 1
		err = copyout(dvmabuf, xio->dptr, xio->dlen);
d2267 1
a2267 1
		dvma_free(dvmabuf, xio->dlen);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

