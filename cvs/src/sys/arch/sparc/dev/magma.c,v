head	1.30;
access;
symbols
	OPENBSD_6_0:1.30.0.2
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.29.0.4
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.6
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.27.0.18
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.14
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.12
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.10
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.8
	OPENBSD_5_0:1.27.0.6
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.4
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.21.0.4
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.19.0.16
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.14
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.12
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.10
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.8
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.6
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.4
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.2
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.13
	UBC:1.8.0.4
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.4.0.6
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.4
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.30
date	2016.03.14.18.01.18;	author stefan;	state Exp;
branches;
next	1.29;
commitid	mzWTMngNKluORs3y;

1.29
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.28;
commitid	C5iGb36LQxjM60Q3;

1.28
date	2014.07.12.18.44.43;	author tedu;	state Exp;
branches;
next	1.27;
commitid	uKVPYMN2MLxdZxzH;

1.27
date	2010.07.02.17.27.01;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2010.06.28.14.13.30;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.31.12.00.07;	author fgsch;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.31.06.40.16;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2009.04.10.20.53.51;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2008.11.29.01.55.06;	author ray;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.02.21.16.10;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2004.09.29.07.35.11;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2003.10.03.16.44.50;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2003.09.23.16.51.11;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.15.20.32.14;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.11.19.20.26;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2002.04.30.01.12.29;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2002.04.28.03.51.19;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.03.48.56;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.25.02.37.43;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.11.05.17.30;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.16.12.49.48;	author ho;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2001.03.24.10.07.19;	author ho;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.05.13.13.20;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.05.12.53.20;	author art;	state Exp;
branches;
next	1.4;

1.4
date	99.07.25.23.49.37;	author jason;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	98.06.02.06.37.17;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	98.05.22.09.28.02;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	98.05.20.19.29.17;	author deraadt;	state Exp;
branches;
next	;

1.4.4.1
date	2001.05.14.21.37.07;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2001.07.04.10.23.27;	author niklas;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2002.03.06.02.04.46;	author niklas;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.4.4.5;

1.4.4.5
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.4.4.6;

1.4.4.6
date	2004.02.19.10.49.57;	author niklas;	state Exp;
branches;
next	;

1.8.4.1
date	2002.01.31.22.55.22;	author niklas;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	1.8.4.3;

1.8.4.3
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Convert sparc drivers bpp and magma to uiomove

Compile test and ok tobiasu@@
@
text
@/*	$OpenBSD: magma.c,v 1.29 2015/02/10 21:56:09 miod Exp $	*/

/*-
 * Copyright (c) 1998 Iain Hibbert
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Driver for Magma SBus Serial/Parallel cards using the Cirrus Logic
 * CD1400 & CD1190 chips
 */

#include "magma.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/device.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/tty.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/conf.h>
#include <sys/errno.h>

#include <sparc/autoconf.h>
#include <sparc/conf.h>
#include <sparc/cpu.h>
#include <sparc/ctlreg.h>

#include <sparc/sparc/asm.h>

#include <dev/ic/cd1400reg.h>
#include <dev/ic/cd1190reg.h>

#include <sparc/bppioctl.h>
#include <sparc/dev/magmareg.h>

#ifdef MAGMA_DEBUG
#define dprintf(x) printf x
#else
#define dprintf(x)
#endif

/*
 * Supported cards table.
 *
 *  The table below lists the cards that this driver is likely to
 *  be able to support.
 *
 *  Cards with parallel ports: except for the LC2+1Sp, they all use
 *  the CD1190 chip which I know nothing about.  I've tried to leave
 *  hooks for it so it shouldn't be too hard to add support later.
 *  (I think somebody is working on this separately)
 *
 *  Thanks to Bruce at Magma for telling me the hardware offsets.
 */
static const struct magma_board_info supported_cards[] = {
	{
		"MAGMA_Sp", "MAGMA,4_Sp", "Magma 4 Sp", 4, 0,
		1, 0xa000, 0xc000, 0xe000, { 0x8000, 0, 0, 0 },
		0, { 0, 0 }
	},
	{
		"MAGMA_Sp", "MAGMA,8_Sp", "Magma 8 Sp", 8, 0,
		2, 0xa000, 0xc000, 0xe000, { 0x4000, 0x6000, 0, 0 },
		0, { 0, 0 }
	},
	{
		"MAGMA_Sp", "MAGMA,_8HS_Sp", "Magma Fast 8 Sp", 8, 0,
		2, 0x2000, 0x4000, 0x6000, { 0x8000, 0xa000, 0, 0 },
		0, { 0, 0 }
	},
	{
		"MAGMA_Sp", "MAGMA,_8SP_422", "Magma 8 Sp - 422", 8, 0,
		2, 0x2000, 0x4000, 0x6000, { 0x8000, 0xa000, 0, 0 },
		0, { 0, 0 }
	},
	{
		"MAGMA_Sp", "MAGMA,12_Sp", "Magma 12 Sp", 12, 0,
		3, 0xa000, 0xc000, 0xe000, { 0x2000, 0x4000, 0x6000, 0 },
		0, { 0, 0 }
	},
	{
		"MAGMA_Sp", "MAGMA,16_Sp", "Magma 16 Sp", 16, 0,
		4, 0xd000, 0xe000, 0xf000, { 0x8000, 0x9000, 0xa000, 0xb000 },
		0, { 0, 0 }
	},
	{
		"MAGMA_Sp", "MAGMA,16_Sp_2", "Magma 16 Sp", 16, 0,
		4, 0x2000, 0x4000, 0x6000, { 0x8000, 0xa000, 0xc000, 0xe000 },
		0, { 0, 0 }
	},
	{
		"MAGMA_Sp", "MAGMA,16HS_Sp", "Magma Fast 16 Sp", 16, 0,
		4, 0x2000, 0x4000, 0x6000, { 0x8000, 0xa000, 0xc000, 0xe000 },
		0, { 0, 0 }
	},
	{
		"MAGMA_Sp", "MAGMA,21_Sp", "Magma LC 2+1 Sp", 2, 1,
		1, 0xa000, 0xc000, 0xe000, { 0x8000, 0, 0, 0 },
		0, { 0, 0 }
	},
	{
		"MAGMA_Sp", "MAGMA,21HS_Sp", "Magma 2+1 Sp", 2, 1,
		1, 0xa000, 0xc000, 0xe000, { 0x4000, 0, 0, 0 },
		1, { 0x6000, 0 }
	},
	{
		"MAGMA_Sp", "MAGMA,41_Sp", "Magma 4+1 Sp", 4, 1,
		1, 0xa000, 0xc000, 0xe000, { 0x4000, 0, 0, 0 },
		1, { 0x6000, 0 }
	},
	{
		"MAGMA_Sp", "MAGMA,82_Sp", "Magma 8+2 Sp", 8, 2,
		2, 0xd000, 0xe000, 0xf000, { 0x8000, 0x9000, 0, 0 },
		2, { 0xa000, 0xb000 }
	},
	{
		"MAGMA_Sp", "MAGMA,P1_Sp", "Magma P1 Sp", 0, 1,
		0, 0, 0, 0, { 0, 0, 0, 0 },
		1, { 0x8000, 0 }
	},
	{
		"MAGMA_Sp", "MAGMA,P2_Sp", "Magma P2 Sp", 0, 2,
		0, 0, 0, 0, { 0, 0, 0, 0 },
		2, { 0x4000, 0x8000 }
	},
	{
		"MAGMA 2+1HS Sp", "", "Magma 2+1HS Sp", 2, 0,
		1, 0xa000, 0xc000, 0xe000, { 0x4000, 0, 0, 0 },
		1, { 0x8000, 0 }
	},
	{
		NULL, NULL, NULL, 0, 0,
		0, 0, 0, 0, { 0, 0, 0, 0 },
		0, { 0, 0 }
	}
};

/************************************************************************
 *
 *  Autoconfig Stuff
 */

struct cfattach magma_ca = {
	sizeof(struct magma_softc), magma_match, magma_attach
};

struct cfdriver magma_cd = {
	NULL, "magma", DV_DULL
};

struct cfattach mtty_ca = {
	sizeof(struct mtty_softc), mtty_match, mtty_attach
};

struct cfdriver mtty_cd = {
	NULL, "mtty", DV_TTY
};

struct cfattach mbpp_ca = {
	sizeof(struct mbpp_softc), mbpp_match, mbpp_attach
};

struct cfdriver mbpp_cd = {
	NULL, "mbpp", DV_DULL
};

/************************************************************************
 *
 *  CD1400 Routines
 *
 *	cd1400_compute_baud		calculate COR/BPR register values
 *	cd1400_write_ccr		write a value to CD1400 ccr
 *	cd1400_read_reg			read from a CD1400 register
 *	cd1400_write_reg		write to a CD1400 register
 *	cd1400_enable_transmitter	enable transmitting on CD1400 channel
 */

/*
 * compute the bpr/cor pair for any baud rate
 * returns 0 for success, 1 for failure
 */
int
cd1400_compute_baud(speed, clock, cor, bpr)
	speed_t speed;
	int clock;
	int *cor, *bpr;
{
	int c, co, br;

	if (speed < 50 || speed > 150000)
		return (1);

	for (c = 0, co = 8 ; co <= 2048 ; co <<= 2, c++) {
		br = ((clock * 1000000) + (co * speed) / 2) / (co * speed);
		if (br < 0x100) {
			*bpr = br;
			*cor = c;
			return (0);
		}
	}

	return (1);
}

/*
 * Write a CD1400 channel command, should have a timeout?
 */
__inline void
cd1400_write_ccr(cd, cmd)
	struct cd1400 *cd;
	u_char cmd;
{
	while (cd1400_read_reg(cd, CD1400_CCR))
		;

	cd1400_write_reg(cd, CD1400_CCR, cmd);
}

/*
 * read a value from a cd1400 register
 */
__inline u_char
cd1400_read_reg(cd, reg)
	struct cd1400 *cd;
	int reg;
{
	return (cd->cd_reg[reg]);
}

/*
 * write a value to a cd1400 register
 */
__inline void
cd1400_write_reg(cd, reg, value)
	struct cd1400 *cd;
	int reg;
	u_char value;
{
	cd->cd_reg[reg] = value;
}

/*
 * enable transmit service requests for cd1400 channel
 */
void
cd1400_enable_transmitter(cd, channel)
	struct cd1400 *cd;
	int channel;
{
	register int s, srer;

	s = spltty();
	cd1400_write_reg(cd, CD1400_CAR, channel);
	srer = cd1400_read_reg(cd, CD1400_SRER);
	SET(srer, CD1400_SRER_TXRDY);
	cd1400_write_reg(cd, CD1400_SRER, srer);
	splx(s);
}

/************************************************************************
 *
 *  CD1190 Routines
 */

/* XXX well, there are none yet */

/************************************************************************
 *
 *  Magma Routines
 *
 * magma_match		reports if we have a magma board available
 * magma_attach		attaches magma boards to the sbus
 * magma_hard		hardware level interrupt routine
 * magma_soft		software level interrupt routine
 */

int
magma_match(parent, vcf, args)
	struct device *parent;
	void *vcf, *args;
{
	struct confargs *ca = args;
	struct romaux *ra = &ca->ca_ra;
	const struct magma_board_info *card;

	for (card = supported_cards; ; card++) {
		if (card->mb_sbusname == NULL)
			/* End of table: no match */
			return (0);
		if (strcmp(ra->ra_name, card->mb_sbusname) == 0)
			break;
	}

#if defined(MAGMA_DEBUG)
{
	int i;

	printf("magma: matched `%s', nvaddrs %d, nreg %d, nintr %d\n",
	    ra->ra_name, ra->ra_nvaddrs, ra->ra_nreg, ra->ra_nintr);
	printf("magma: magma_prom `%s'\n",
	    getpropstring(ra->ra_node, "magma_prom"));
	printf("magma: intlevels `%s'\n",
	    getpropstring(ra->ra_node, "intlevels"));
	printf("magma: chiprev `%s'\n",
	    getpropstring(ra->ra_node, "chiprev"));
	printf("magma: clock `%s'\n",
	    getpropstring(ra->ra_node, "clock"));

	for (i = 0 ; i < ra->ra_nreg ; i++)
		printf("magma: reg  %d; ra_iospace = %d, ra_paddr = 0x%x, ra_len = %d\n",
		    i, ra->ra_reg[i].rr_iospace,
		    (int)ra->ra_reg[i].rr_paddr, ra->ra_reg[i].rr_len);
	for (i = 0 ; i < ra->ra_nintr ; i++)
		printf("magma: intr %d; pri = %d, vec = %d\n",
		    i, ra->ra_intr[i].int_pri, ra->ra_intr[i].int_vec);
}
#endif

	return (1);
}

void
magma_attach(parent, dev, args)
	struct device *parent;
	struct device *dev;
	void *args;
{
	struct confargs *ca = args;
	struct romaux *ra = &ca->ca_ra;
	struct magma_softc *sc = (struct magma_softc *)dev;
	const struct magma_board_info *card;
	char magma_prom[40], *clockstr;
	int chip, cd_clock, len;
	void *base;

	len = getprop(ra->ra_node, "magma_prom",
	    magma_prom, sizeof(magma_prom) - 1);
	if (len == -1)
		len = 0;
	magma_prom[len] = '\0';

	for (card = supported_cards; card->mb_name != NULL; card++) {
		if (strcmp(ra->ra_name, card->mb_sbusname) != 0)
			continue;
		if (strcmp(magma_prom, card->mb_name) == 0)
			break;
	}

	if (card->mb_name == NULL) {
		printf(" %s (unsupported)\n", magma_prom);
		return;
	}


	clockstr = getpropstring(ra->ra_node, "clock");
	if (strlen(clockstr) == 0)
		cd_clock = 0;
	else {
		cd_clock = 0;
		while (*clockstr != '\0')
			cd_clock = cd_clock * 10 + *clockstr++ - '0';
	}

	dprintf((" addr 0x%x", sc));
	printf(" pri %d softpri %d:", ra->ra_intr[0].int_pri, IPL_TTY);
	printf(" %s\n", card->mb_realname);

	sc->ms_board = card;
	sc->ms_ncd1400 = card->mb_ncd1400;
	sc->ms_ncd1190 = card->mb_ncd1190;

	base = mapiodev(&(ra->ra_reg[0]), 0, ra->ra_reg[0].rr_len);

	/* the SVCACK* lines are daisychained */
	sc->ms_svcackr = base + card->mb_svcackr;
	sc->ms_svcackt = base + card->mb_svcackt;
	sc->ms_svcackm = base + card->mb_svcackm;

	/* Init the cd1400 chips */
	for (chip = 0 ; chip < card->mb_ncd1400 ; chip++) {
		struct cd1400 *cd = &sc->ms_cd1400[chip];

		cd->cd_reg = base + card->mb_cd1400[chip];

		cd->cd_clock = cd_clock;

		/* getpropstring(ra->ra_node, "chiprev"); */
		/* seemingly the Magma drivers just ignore the propstring */
		cd->cd_chiprev = cd1400_read_reg(cd, CD1400_GFRCR);

		dprintf(("%s attach CD1400 %d addr 0x%x rev %x clock %dMHz\n",
		    sc->ms_dev.dv_xname, chip,
		    cd->cd_reg, cd->cd_chiprev, cd->cd_clock));

		/* clear GFRCR */
		cd1400_write_reg(cd, CD1400_GFRCR, 0x00);

		/* reset whole chip */
		cd1400_write_ccr(cd, CD1400_CCR_CMDRESET | CD1400_CCR_FULLRESET);

		/* wait for revision code to be restored */
		while (cd1400_read_reg(cd, CD1400_GFRCR) != cd->cd_chiprev)
		        ;

		/* set the Prescaler Period Register to tick at 1ms */
		cd1400_write_reg(cd, CD1400_PPR,
		    ((cd->cd_clock * 1000000 / CD1400_PPR_PRESCALER + 500) /
		    1000));

		/*
		 * The LC2+1Sp card is the only card that doesn't have a CD1190
		 * for the parallel port, but uses channel 0 of the CD1400, so
		 * we make a note of it for later and set up the CD1400 for
		 * parallel mode operation.
		 */
		if (card->mb_npar && card->mb_ncd1190 == 0) {
			cd1400_write_reg(cd, CD1400_GCR, CD1400_GCR_PARALLEL);
			cd->cd_parmode = 1;
		}
	}

	/* init the cd1190 chips */
	for (chip = 0 ; chip < card->mb_ncd1190 ; chip++) {
		struct cd1190 *cd = &sc->ms_cd1190[chip];

		cd->cd_reg = base + card->mb_cd1190[chip];
		dprintf(("%s attach CD1190 %d addr 0x%x (failed)\n",
		    sc->ms_dev.dv_xname, chip, cd->cd_reg));
		/* XXX don't know anything about these chips yet */
	}

	/* configure the children */
	(void)config_found(dev, mtty_match, NULL);
	(void)config_found(dev, mbpp_match, NULL);

	/*
	 * enable the interrupt handlers
	 */
	sc->ms_hardint.ih_fun = magma_hard;
	sc->ms_hardint.ih_arg = sc;
	intr_establish(ra->ra_intr[0].int_pri, &sc->ms_hardint, -1,
	    dev->dv_xname);

	sc->ms_softint = softintr_establish(IPL_SOFTTTY, magma_soft, sc);
}

/*
 * hard interrupt routine
 *
 *  returns 1 if it handled it, otherwise 0
 *
 *  runs at interrupt priority
 */
int
magma_hard(arg)
	void *arg;
{
	struct magma_softc *sc = arg;
	struct cd1400 *cd;
	int chip, status = 0;
	int serviced = 0;
	int needsoftint = 0;

	/*
	 * check status of all the CD1400 chips
	 */
	for (chip = 0 ; chip < sc->ms_ncd1400 ; chip++)
		status |= cd1400_read_reg(&sc->ms_cd1400[chip], CD1400_SVRR);

	if (ISSET(status, CD1400_SVRR_RXRDY)) {
		/* enter rx service context */
		u_char rivr = *sc->ms_svcackr;
		int port = rivr >> 4;

		if (rivr & (1 << 3)) {			/* parallel port */
		struct mbpp_port *mbpp;
		int n_chars;

			mbpp = &sc->ms_mbpp->ms_port[port];
			cd = mbpp->mp_cd1400;

			/* don't think we have to handle exceptions */
			n_chars = cd1400_read_reg(cd, CD1400_RDCR);
			while (n_chars--) {
				if (mbpp->mp_cnt == 0) {
					SET(mbpp->mp_flags, MBPPF_WAKEUP);
					needsoftint = 1;
					break;
				}
				*mbpp->mp_ptr = cd1400_read_reg(cd, CD1400_RDSR);
				mbpp->mp_ptr++;
				mbpp->mp_cnt--;
			}
		} else {				/* serial port */
			register struct mtty_port *mtty;
			register u_char *ptr, n_chars, line_stat;

			mtty = &sc->ms_mtty->ms_port[port];
			cd = mtty->mp_cd1400;

			if (ISSET(rivr, CD1400_RIVR_EXCEPTION)) {
				line_stat = cd1400_read_reg(cd, CD1400_RDSR);
				n_chars = 1;
			} else { /* no exception, received data OK */
				line_stat = 0;
				n_chars = cd1400_read_reg(cd, CD1400_RDCR);
			}

			ptr = mtty->mp_rput;
			while (n_chars--) {
				*ptr++ = line_stat;
				*ptr++ = cd1400_read_reg(cd, CD1400_RDSR);
				if (ptr == mtty->mp_rend)
				    ptr = mtty->mp_rbuf;
				if (ptr == mtty->mp_rget) {
					if (ptr == mtty->mp_rbuf)
					    ptr = mtty->mp_rend;
					ptr -= 2;
					SET(mtty->mp_flags, MTTYF_RING_OVERFLOW);
					break;
				}
			}
			mtty->mp_rput = ptr;

			needsoftint = 1;
		}

		/* end service context */
		cd1400_write_reg(cd, CD1400_EOSRR, 0);
		serviced = 1;
	} /* if (rx_service...) */

	if (ISSET(status, CD1400_SVRR_MDMCH)) {
		/* enter mdm service context */
		u_char mivr = *sc->ms_svcackm;
		int port = mivr >> 4;
		struct mtty_port *mtty;
		int carrier;
		u_char msvr;

		/*
		 * Handle CD (LC2+1Sp = DSR) changes.
		 */
		mtty = &sc->ms_mtty->ms_port[port];
		cd = mtty->mp_cd1400;
		msvr = cd1400_read_reg(cd, CD1400_MSVR2);
		carrier = ISSET(msvr,
		    cd->cd_parmode ? CD1400_MSVR2_DSR : CD1400_MSVR2_CD);

		if (mtty->mp_carrier != carrier) {
			SET(mtty->mp_flags, MTTYF_CARRIER_CHANGED);
			mtty->mp_carrier = carrier;
			needsoftint = 1;
		}

		/* end service context */
		cd1400_write_reg(cd, CD1400_EOSRR, 0);
		serviced = 1;
	} /* if (mdm_service...) */

	if (ISSET(status, CD1400_SVRR_TXRDY)) {
		/* enter tx service context */
		u_char tivr = *sc->ms_svcackt;
		int port = tivr >> 4;

		if (tivr & (1 << 3)) {	/* parallel port */
			struct mbpp_port *mbpp;

			mbpp = &sc->ms_mbpp->ms_port[port];
			cd = mbpp->mp_cd1400;

			if (mbpp->mp_cnt) {
				int count = 0;

				/* fill the fifo */
				while (mbpp->mp_cnt &&
				    count++ < CD1400_PAR_FIFO_SIZE) {
					cd1400_write_reg(cd, CD1400_TDR,
					    *mbpp->mp_ptr);
					mbpp->mp_ptr++;
					mbpp->mp_cnt--;
				}
			} else {
				/*
				 * fifo is empty and we got no more data to
				 * send, so shut off interrupts and signal for
				 * a wakeup, which can't be done here in case
				 * we beat mbpp_send to the tsleep call
				 * (we are running at psl > spltty).
				 */
				cd1400_write_reg(cd, CD1400_SRER, 0);
				SET(mbpp->mp_flags, MBPPF_WAKEUP);
				needsoftint = 1;
			}
		} else {		/* serial port */
			struct mtty_port *mtty;
			struct tty *tp;

			mtty = &sc->ms_mtty->ms_port[port];
			cd = mtty->mp_cd1400;
			tp = mtty->mp_tty;

			if (!ISSET(mtty->mp_flags, MTTYF_STOP)) {
				register int count = 0;

				/* check if we should start/stop a break */
				if (ISSET(mtty->mp_flags, MTTYF_SET_BREAK)) {
					cd1400_write_reg(cd, CD1400_TDR, 0);
					cd1400_write_reg(cd, CD1400_TDR, 0x81);
					/* should we delay too? */
					CLR(mtty->mp_flags, MTTYF_SET_BREAK);
					count += 2;
				}

				if (ISSET(mtty->mp_flags, MTTYF_CLR_BREAK)) {
					cd1400_write_reg(cd, CD1400_TDR, 0);
					cd1400_write_reg(cd, CD1400_TDR, 0x83);
					CLR(mtty->mp_flags, MTTYF_CLR_BREAK);
					count += 2;
				}

				/*
				 * I don't quite fill the fifo in case the last
				 * one is a NULL which I have to double up
				 * because its the escape code for embedded
				 * transmit characters.
				 */
				while (mtty->mp_txc > 0 &&
				    count < CD1400_TX_FIFO_SIZE - 1) {
					register u_char ch;

					ch = *mtty->mp_txp;

					mtty->mp_txc--;
					mtty->mp_txp++;

					if (ch == 0) {
						cd1400_write_reg(cd,
						    CD1400_TDR, ch);
						count++;
					}

					cd1400_write_reg(cd, CD1400_TDR, ch);
					count++;
				}
			}

			/*
			 * If we ran out of work or are requested to STOP then
			 * shut off the txrdy interrupts and signal DONE to
			 * flush out the chars we have sent.
			 */
			if (mtty->mp_txc == 0 ||
			    ISSET(mtty->mp_flags, MTTYF_STOP)) {
				register int srer;

				srer = cd1400_read_reg(cd, CD1400_SRER);
				CLR(srer, CD1400_SRER_TXRDY);
				cd1400_write_reg(cd, CD1400_SRER, srer);
				CLR(mtty->mp_flags, MTTYF_STOP);

				SET(mtty->mp_flags, MTTYF_DONE);
				needsoftint = 1;
			}
		}

		/* end service context */
		cd1400_write_reg(cd, CD1400_EOSRR, 0);
		serviced = 1;
	} /* if (tx_service...) */

	/* XXX service CD1190 interrupts too
	for (chip = 0 ; chip < sc->ms_ncd1190 ; chip++) {
	}
	*/

	if (needsoftint)	/* trigger the soft interrupt */
		softintr_schedule(sc->ms_softint);

	return (serviced);
}

/*
 * magma soft interrupt handler
 *
 *  runs at spltty()
 */
void
magma_soft(arg)
	void *arg;
{
	struct magma_softc *sc = arg;
	struct mtty_softc *mtty = sc->ms_mtty;
	struct mbpp_softc *mbpp = sc->ms_mbpp;
	int port;
	int s, flags;

	/*
	 * check the tty ports (if any) to see what needs doing
	 */
	if (mtty) {
		for (port = 0 ; port < mtty->ms_nports ; port++) {
			struct mtty_port *mp = &mtty->ms_port[port];
			struct tty *tp = mp->mp_tty;

			if (!ISSET(tp->t_state, TS_ISOPEN))
				continue;

			/*
			 * handle any received data
			 */
			while (mp->mp_rget != mp->mp_rput) {
				u_char stat;
				int data;

				stat = mp->mp_rget[0];
				data = mp->mp_rget[1];
				mp->mp_rget =
				    ((mp->mp_rget + 2) == mp->mp_rend) ?
				      mp->mp_rbuf : (mp->mp_rget + 2);

				if (stat & (CD1400_RDSR_BREAK | CD1400_RDSR_FE))
					data |= TTY_FE;
				if (stat & CD1400_RDSR_PE)
					data |= TTY_PE;

				if (stat & CD1400_RDSR_OE)
					log(LOG_WARNING,
					    "%s%x: fifo overflow\n",
					    mtty->ms_dev.dv_xname, port);

				(*linesw[tp->t_line].l_rint)(data, tp);
			}

			s = splhigh();	/* block out hard interrupt routine */
			flags = mp->mp_flags;
			CLR(mp->mp_flags, MTTYF_DONE | MTTYF_CARRIER_CHANGED |
			    MTTYF_RING_OVERFLOW);
			splx(s);	/* ok */

			if (ISSET(flags, MTTYF_CARRIER_CHANGED)) {
				dprintf(("%s%x: cd %s\n",
				    mtty->ms_dev.dv_xname, port,
				    mp->mp_carrier ? "on" : "off"));
				(*linesw[tp->t_line].l_modem)(tp,
				    mp->mp_carrier);
			}

			if (ISSET(flags, MTTYF_RING_OVERFLOW)) {
				log(LOG_WARNING,
				    "%s%x: ring buffer overflow\n",
				    mtty->ms_dev.dv_xname, port);
			}

			if (ISSET(flags, MTTYF_DONE)) {
				ndflush(&tp->t_outq,
				    mp->mp_txp - tp->t_outq.c_cf);
				CLR(tp->t_state, TS_BUSY);
				/* might be some more */
				(*linesw[tp->t_line].l_start)(tp);
			}
		} /* for (each mtty...) */
	}

	/*
	 * check the bpp ports (if any) to see what needs doing
	 */
	if (mbpp) {
		for (port = 0 ; port < mbpp->ms_nports ; port++) {
			struct mbpp_port *mp = &mbpp->ms_port[port];

			if (!ISSET(mp->mp_flags, MBPPF_OPEN))
				continue;

			s = splhigh();	/* block out hard intr routine */
			flags = mp->mp_flags;
			CLR(mp->mp_flags, MBPPF_WAKEUP);
			splx(s);

			if (ISSET(flags, MBPPF_WAKEUP)) {
				wakeup(mp);
			}
		} /* for (each mbpp...) */
	}
}

/************************************************************************
 *
 *  MTTY Routines
 *
 *	mtty_match		match one mtty device
 *	mtty_attach		attach mtty devices
 *	mttyopen		open mtty device
 *	mttyclose		close mtty device
 *	mttyread		read from mtty
 *	mttywrite		write to mtty
 *	mttyioctl		do ioctl on mtty
 *	mttytty			return tty pointer for mtty
 *	mttystop		stop mtty device
 *	mtty_start		start mtty device
 *	mtty_param		set mtty parameters
 *	mtty_modem_control	set modem control lines
 */

int
mtty_match(parent, vcf, args)
	struct device *parent;
	void *vcf, *args;
{
	struct magma_softc *sc = (struct magma_softc *)parent;

	return (args == mtty_match && sc->ms_board->mb_nser &&
	    sc->ms_mtty == NULL);
}

void
mtty_attach(parent, dev, args)
	struct device *parent;
	struct device *dev;
	void *args;
{
	struct magma_softc *sc = (struct magma_softc *)parent;
	struct mtty_softc *ms = (struct mtty_softc *)dev;
	int port, chip, chan;

	sc->ms_mtty = ms;
	dprintf((" addr 0x%x", ms));

	for (port = chip = chan = 0 ; port < sc->ms_board->mb_nser ; port++) {
		struct mtty_port *mp = &ms->ms_port[port];
		struct tty *tp;

		mp->mp_cd1400 = &sc->ms_cd1400[chip];
		if (mp->mp_cd1400->cd_parmode && chan == 0)
			chan = 1; /* skip channel 0 if parmode */
		mp->mp_channel = chan;

		tp = ttymalloc(0);
		tp->t_oproc = mtty_start;
		tp->t_param = mtty_param;

		mp->mp_tty = tp;

		mp->mp_rbuf = malloc(MTTY_RBUF_SIZE, M_DEVBUF, M_NOWAIT);
		if (mp->mp_rbuf == NULL)
			break;

		mp->mp_rend = mp->mp_rbuf + MTTY_RBUF_SIZE;

		chan = (chan + 1) % CD1400_NO_OF_CHANNELS;
		if (chan == 0)
			chip++;
	}

	ms->ms_nports = port;
	printf(": %d tty%s\n", port, port == 1 ? "" : "s");
}

/*
 * open routine. returns zero if successful, else error code
 */
int
mttyopen(dev, flags, mode, p)
	dev_t dev;
	int flags;
	int mode;
	struct proc *p;
{
	int card = MAGMA_CARD(dev);
	int port = MAGMA_PORT(dev);
	struct mtty_softc *ms;
	struct mtty_port *mp;
	struct tty *tp;
	struct cd1400 *cd;
	int s;

	if (card >= mtty_cd.cd_ndevs || (ms = mtty_cd.cd_devs[card]) == NULL ||
	    port >= ms->ms_nports)
		return (ENXIO);	/* device not configured */

	mp = &ms->ms_port[port];
	tp = mp->mp_tty;
	tp->t_dev = dev;

	if (!ISSET(tp->t_state, TS_ISOPEN)) {
		SET(tp->t_state, TS_WOPEN);

		/* set defaults */
		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_cflag = TTYDEF_CFLAG;
		if (ISSET(mp->mp_openflags, TIOCFLAG_CLOCAL))
			SET(tp->t_cflag, CLOCAL);
		if (ISSET(mp->mp_openflags, TIOCFLAG_CRTSCTS))
			SET(tp->t_cflag, CRTSCTS);
		if (ISSET(mp->mp_openflags, TIOCFLAG_MDMBUF))
			SET(tp->t_cflag, MDMBUF);
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;

		/* init ring buffer */
		mp->mp_rput = mp->mp_rget = mp->mp_rbuf;

		s = spltty();

		/* reset CD1400 channel */
		cd = mp->mp_cd1400;
		cd1400_write_reg(cd, CD1400_CAR, mp->mp_channel);
		cd1400_write_ccr(cd, CD1400_CCR_CMDRESET);

		/* encode the port number in top half of LIVR */
		cd1400_write_reg(cd, CD1400_LIVR, port << 4);

		/* sets parameters and raises DTR */
		(void)mtty_param(tp, &tp->t_termios);

		/* set tty watermarks */
		ttsetwater(tp);

		/* enable service requests */
		cd1400_write_reg(cd, CD1400_SRER,
		    CD1400_SRER_RXDATA | CD1400_SRER_MDMCH);

		/* tell the tty about the carrier status */
		if (ISSET(mp->mp_openflags, TIOCFLAG_SOFTCAR) || mp->mp_carrier)
			SET(tp->t_state, TS_CARR_ON);
		else
			CLR(tp->t_state, TS_CARR_ON);
	} else if (ISSET(tp->t_state, TS_XCLUDE) && suser(p, 0) != 0) {
		return (EBUSY);	/* superuser can break exclusive access */
	} else {
		s = spltty();
	}

	/* wait for carrier if necessary */
	if (!ISSET(flags, O_NONBLOCK)) {
		while (!ISSET(tp->t_cflag, CLOCAL) &&
		    !ISSET(tp->t_state, TS_CARR_ON)) {
			int error;

			SET(tp->t_state, TS_WOPEN);
			error = ttysleep(tp, &tp->t_rawq, TTIPRI | PCATCH,
			    "mttydcd", 0);
			if (error != 0) {
				splx(s);
				CLR(tp->t_state, TS_WOPEN);
				return (error);
			}
		}
	}

	splx(s);

	return ((*linesw[tp->t_line].l_open)(dev, tp, p));
}

/*
 * close routine. returns zero if successful, else error code
 */
int
mttyclose(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	struct mtty_softc *ms = mtty_cd.cd_devs[MAGMA_CARD(dev)];
	struct mtty_port *mp = &ms->ms_port[MAGMA_PORT(dev)];
	struct tty *tp = mp->mp_tty;
	int s;

	(*linesw[tp->t_line].l_close)(tp, flag, p);
	s = spltty();

	/*
	 * If HUPCL is set, and the tty is no longer open,
	 * shut down the port.
	 */
	if (ISSET(tp->t_cflag, HUPCL) || !ISSET(tp->t_state, TS_ISOPEN)) {
		/* XXX wait until FIFO is empty before turning off the channel
		struct cd1400 *cd = mp->mp_cd1400;
		*/

		/* drop DTR and RTS */
		(void)mtty_modem_control(mp, 0, DMSET);

		/* turn off the channel
		cd1400_write_reg(cd, CD1400_CAR, mp->mp_channel);
		cd1400_write_ccr(cd, CD1400_CCR_CMDRESET);
		*/
	}

	splx(s);
	ttyclose(tp);

	return (0);
}

/*
 * Read routine
 */
int
mttyread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	struct mtty_softc *ms = mtty_cd.cd_devs[MAGMA_CARD(dev)];
	struct mtty_port *mp = &ms->ms_port[MAGMA_PORT(dev)];
	struct tty *tp = mp->mp_tty;

	return ((*linesw[tp->t_line].l_read)(tp, uio, flags));
}

/*
 * Write routine
 */
int
mttywrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	struct mtty_softc *ms = mtty_cd.cd_devs[MAGMA_CARD(dev)];
	struct mtty_port *mp = &ms->ms_port[MAGMA_PORT(dev)];
	struct tty *tp = mp->mp_tty;

	return ((*linesw[tp->t_line].l_write)(tp, uio, flags));
}

/*
 * return tty pointer
 */
struct tty *
mttytty(dev)
	dev_t dev;
{
	struct mtty_softc *ms = mtty_cd.cd_devs[MAGMA_CARD(dev)];
	struct mtty_port *mp = &ms->ms_port[MAGMA_PORT(dev)];

	return (mp->mp_tty);
}

/*
 * ioctl routine
 */
int
mttyioctl(dev, cmd, data, flags, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
{
	struct mtty_softc *ms = mtty_cd.cd_devs[MAGMA_CARD(dev)];
	struct mtty_port *mp = &ms->ms_port[MAGMA_PORT(dev)];
	struct tty *tp = mp->mp_tty;
	int error;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flags, p);
	if (error >= 0)
		return (error);

	error = ttioctl(tp, cmd, data, flags, p);
	if (error >= 0)
		return (error);

	error = 0;

	switch(cmd) {
	case TIOCSBRK:	/* set break */
		SET(mp->mp_flags, MTTYF_SET_BREAK);
		cd1400_enable_transmitter(mp->mp_cd1400, mp->mp_channel);
		break;

	case TIOCCBRK:	/* clear break */
		SET(mp->mp_flags, MTTYF_CLR_BREAK);
		cd1400_enable_transmitter(mp->mp_cd1400, mp->mp_channel);
		break;

	case TIOCSDTR:	/* set DTR */
		mtty_modem_control(mp, TIOCM_DTR, DMBIS);
		break;

	case TIOCCDTR:	/* clear DTR */
		mtty_modem_control(mp, TIOCM_DTR, DMBIC);
		break;

	case TIOCMSET:	/* set modem lines */
		mtty_modem_control(mp, *((int *)data), DMSET);
		break;

	case TIOCMBIS:	/* bit set modem lines */
		mtty_modem_control(mp, *((int *)data), DMBIS);
		break;

	case TIOCMBIC:	/* bit clear modem lines */
		mtty_modem_control(mp, *((int *)data), DMBIC);
		break;

	case TIOCMGET:	/* get modem lines */
		*((int *)data) = mtty_modem_control(mp, 0, DMGET);
		break;

	case TIOCGFLAGS:
		*((int *)data) = mp->mp_openflags;
		break;

	case TIOCSFLAGS:
		if (suser(p, 0))
			error = EPERM;
		else
			mp->mp_openflags = *((int *)data) &
				(TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL |
				TIOCFLAG_CRTSCTS | TIOCFLAG_MDMBUF);
		break;

	default:
		error = ENOTTY;
	}

	return (error);
}

/*
 * Stop output, e.g., for ^S or output flush.
 */
int
mttystop(tp, flags)
	struct tty *tp;
	int flags;
{
	struct mtty_softc *ms = mtty_cd.cd_devs[MAGMA_CARD(tp->t_dev)];
	struct mtty_port *mp = &ms->ms_port[MAGMA_PORT(tp->t_dev)];
	int s;

	s = spltty();

	if (ISSET(tp->t_state, TS_BUSY)) {
		if (!ISSET(tp->t_state, TS_TTSTOP))
			SET(tp->t_state, TS_FLUSH);

		/*
		 * the transmit interrupt routine will disable transmit when it
		 * notices that MTTYF_STOP has been set.
		 */
		SET(mp->mp_flags, MTTYF_STOP);
	}

	splx(s);
	return (0);
}

/*
 * Start output, after a stop.
 */
void
mtty_start(tp)
	struct tty *tp;
{
	struct mtty_softc *ms = mtty_cd.cd_devs[MAGMA_CARD(tp->t_dev)];
	struct mtty_port *mp = &ms->ms_port[MAGMA_PORT(tp->t_dev)];
	int s;

	s = spltty();

	/*
	 * We only need to do something if we are not already busy
	 * or delaying or stopped.
	 */
	if (!ISSET(tp->t_state, TS_TTSTOP | TS_TIMEOUT | TS_BUSY)) {

		/*
		 * If we are sleeping and output has drained below
		 * low water mark, awaken.
		 */
		ttwakeupwr(tp);

		/*
		 * If there is something to send, start transmitting.
		 */
		if (tp->t_outq.c_cc) {
			mp->mp_txc = ndqb(&tp->t_outq, 0);
			mp->mp_txp = tp->t_outq.c_cf;
			SET(tp->t_state, TS_BUSY);
			cd1400_enable_transmitter(mp->mp_cd1400,
			    mp->mp_channel);
		}
	}

	splx(s);
}

/*
 * set/get modem line status
 *
 * bits can be: TIOCM_DTR, TIOCM_RTS, TIOCM_CTS, TIOCM_CD, TIOCM_RI, TIOCM_DSR
 *
 * note that DTR and RTS lines are exchanged, and that DSR is
 * not available on the LC2+1Sp card (used as CD)
 *
 * only let them fiddle with RTS if CRTSCTS is not enabled
 */
int
mtty_modem_control(mp, bits, howto)
	struct mtty_port *mp;
	int bits;
	int howto;
{
	struct cd1400 *cd = mp->mp_cd1400;
	struct tty *tp = mp->mp_tty;
	int s, msvr;

	s = spltty();

	cd1400_write_reg(cd, CD1400_CAR, mp->mp_channel);

	switch(howto) {
	case DMGET:	/* get bits */
		bits = 0;

		bits |= TIOCM_LE;

		msvr = cd1400_read_reg(cd, CD1400_MSVR1);
		if (msvr & CD1400_MSVR1_RTS)
			bits |= TIOCM_DTR;

		msvr = cd1400_read_reg(cd, CD1400_MSVR2);
		if (msvr & CD1400_MSVR2_DTR)
			bits |= TIOCM_RTS;
		if (msvr & CD1400_MSVR2_CTS)
		    bits |= TIOCM_CTS;
		if (msvr & CD1400_MSVR2_RI)
		    bits |= TIOCM_RI;
		if (msvr & CD1400_MSVR2_DSR)
		    bits |= (cd->cd_parmode ? TIOCM_CD : TIOCM_DSR);
		if (msvr & CD1400_MSVR2_CD)
		    bits |= (cd->cd_parmode ? 0 : TIOCM_CD);

		break;

	case DMSET:	/* reset bits */
		if (!ISSET(tp->t_cflag, CRTSCTS))
			cd1400_write_reg(cd, CD1400_MSVR2,
			    ((bits & TIOCM_RTS) ? CD1400_MSVR2_DTR : 0));

		cd1400_write_reg(cd, CD1400_MSVR1,
		    ((bits & TIOCM_DTR) ? CD1400_MSVR1_RTS : 0));

		break;

	case DMBIS:	/* set bits */
		if ((bits & TIOCM_RTS) && !ISSET(tp->t_cflag, CRTSCTS))
			cd1400_write_reg(cd, CD1400_MSVR2, CD1400_MSVR2_DTR);

		if (bits & TIOCM_DTR)
			cd1400_write_reg(cd, CD1400_MSVR1, CD1400_MSVR1_RTS);

		break;

	case DMBIC:	/* clear bits */
		if ((bits & TIOCM_RTS) && !ISSET(tp->t_cflag, CRTSCTS))
			cd1400_write_reg(cd, CD1400_MSVR2, 0);

		if (bits & TIOCM_DTR)
			cd1400_write_reg(cd, CD1400_MSVR1, 0);

		break;
	}

	splx(s);
	return (bits);
}

/*
 * Set tty parameters, returns error or 0 on success
 */
int
mtty_param(tp, t)
	struct tty *tp;
	struct termios *t;
{
	struct mtty_softc *ms = mtty_cd.cd_devs[MAGMA_CARD(tp->t_dev)];
	struct mtty_port *mp = &ms->ms_port[MAGMA_PORT(tp->t_dev)];
	struct cd1400 *cd = mp->mp_cd1400;
	int rbpr, tbpr, rcor, tcor;
	u_char mcor1 = 0, mcor2 = 0;
	int s, opt;

	if (t->c_ospeed &&
	    cd1400_compute_baud(t->c_ospeed, cd->cd_clock, &tcor, &tbpr))
		return (EINVAL);

	if (t->c_ispeed &&
	    cd1400_compute_baud(t->c_ispeed, cd->cd_clock, &rcor, &rbpr))
		return (EINVAL);

	s = spltty();

	/* hang up the line if ospeed is zero, else raise DTR */
	(void)mtty_modem_control(mp, TIOCM_DTR,
	    (t->c_ospeed == 0 ? DMBIC : DMBIS));

	/* select channel, done in mtty_modem_control() */
	/* cd1400_write_reg(cd, CD1400_CAR, mp->mp_channel); */

	/* set transmit speed */
	if (t->c_ospeed) {
		cd1400_write_reg(cd, CD1400_TCOR, tcor);
		cd1400_write_reg(cd, CD1400_TBPR, tbpr);
	}

	/* set receive speed */
	if (t->c_ispeed) {
		cd1400_write_reg(cd, CD1400_RCOR, rcor);
		cd1400_write_reg(cd, CD1400_RBPR, rbpr);
	}

	/* enable transmitting and receiving on this channel */
	opt = CD1400_CCR_CMDCHANCTL | CD1400_CCR_XMTEN | CD1400_CCR_RCVEN;
	cd1400_write_ccr(cd, opt);

	/* set parity, data and stop bits */
	opt = 0;
	if (ISSET(t->c_cflag, PARENB))
		opt |= (ISSET(t->c_cflag, PARODD) ?
		    CD1400_COR1_PARODD : CD1400_COR1_PARNORMAL);

	if (!ISSET(t->c_iflag, INPCK))
		opt |= CD1400_COR1_NOINPCK; /* no parity checking */

	if (ISSET(t->c_cflag, CSTOPB))
		opt |= CD1400_COR1_STOP2;

	switch (t->c_cflag & CSIZE) {
	case CS5:
		opt |= CD1400_COR1_CS5;
		break;

	case CS6:
		opt |= CD1400_COR1_CS6;
		break;

	case CS7:
		opt |= CD1400_COR1_CS7;
		break;

	default:
		opt |= CD1400_COR1_CS8;
		break;
	}

	cd1400_write_reg(cd, CD1400_COR1, opt);

	/*
	 * enable Embedded Transmit Commands (for breaks)
	 * use the CD1400 automatic CTS flow control if CRTSCTS is set
	 */
	opt = CD1400_COR2_ETC;
	if (ISSET(t->c_cflag, CRTSCTS))
		opt |= CD1400_COR2_CCTS_OFLOW;
	cd1400_write_reg(cd, CD1400_COR2, opt);

	cd1400_write_reg(cd, CD1400_COR3, MTTY_RX_FIFO_THRESHOLD);

	cd1400_write_ccr(cd, CD1400_CCR_CMDCORCHG | CD1400_CCR_COR1 |
	    CD1400_CCR_COR2 | CD1400_CCR_COR3);

	cd1400_write_reg(cd, CD1400_COR4, CD1400_COR4_PFO_EXCEPTION);
	cd1400_write_reg(cd, CD1400_COR5, 0);

	/*
	 * if automatic RTS handshaking enabled, set DTR threshold
	 * (RTS and DTR lines are switched, CD1400 thinks its DTR)
	 */
	if (ISSET(t->c_cflag, CRTSCTS))
		mcor1 = MTTY_RX_DTR_THRESHOLD;

	/* set up `carrier detect' interrupts */
	if (cd->cd_parmode) {
		SET(mcor1, CD1400_MCOR1_DSRzd);
		SET(mcor2, CD1400_MCOR2_DSRod);
	} else {
		SET(mcor1, CD1400_MCOR1_CDzd);
		SET(mcor2, CD1400_MCOR2_CDod);
	}

	cd1400_write_reg(cd, CD1400_MCOR1, mcor1);
	cd1400_write_reg(cd, CD1400_MCOR2, mcor2);

	/* receive timeout 2ms */
	cd1400_write_reg(cd, CD1400_RTPR, 2);

	splx(s);
	return (0);
}

/************************************************************************
 *
 *  MBPP Routines
 *
 *	mbpp_match	match one mbpp device
 *	mbpp_attach	attach mbpp devices
 *	mbppopen	open mbpp device
 *	mbppclose	close mbpp device
 *	mbppread	read from mbpp
 *	mbppwrite	write to mbpp
 *	mbppioctl	do ioctl on mbpp
 *	mbpppoll	do poll on mbpp
 *	mbpp_rw		general rw routine
 *	mbpp_timeout	rw timeout
 *	mbpp_start	rw start after delay
 *	mbpp_send	send data
 *	mbpp_recv	recv data
 */

int
mbpp_match(parent, vcf, args)
	struct device *parent;
	void *vcf, *args;
{
	register struct magma_softc *sc = (struct magma_softc *)parent;

	return (args == mbpp_match && sc->ms_board->mb_npar &&
	    sc->ms_mbpp == NULL);
}

void
mbpp_attach(parent, dev, args)
	struct device *parent;
	struct device *dev;
	void *args;
{
	struct magma_softc *sc = (struct magma_softc *)parent;
	struct mbpp_softc *ms = (struct mbpp_softc *)dev;
	struct mbpp_port *mp;
	int port;

	sc->ms_mbpp = ms;
	dprintf((" addr 0x%x", ms));

	for (port = 0 ; port < sc->ms_board->mb_npar ; port++) {
		mp = &ms->ms_port[port];

		if (sc->ms_ncd1190)
			mp->mp_cd1190 = &sc->ms_cd1190[port];
		else
			mp->mp_cd1400 = &sc->ms_cd1400[0];

		timeout_set(&mp->mp_timeout_tmo, mbpp_timeout, mp);
		timeout_set(&mp->mp_start_tmo, mbpp_start, mp);
	}

	ms->ms_nports = port;
	printf(": %d port%s\n", port, port == 1 ? "" : "s");
}

/*
 * open routine. returns zero if successful, else error code
 */
int
mbppopen(dev, flags, mode, p)
	dev_t dev;
	int flags;
	int mode;
	struct proc *p;
{
	int card = MAGMA_CARD(dev);
	int port = MAGMA_PORT(dev);
	struct mbpp_softc *ms;
	struct mbpp_port *mp;
	int s;

	if (card >= mbpp_cd.cd_ndevs || (ms = mbpp_cd.cd_devs[card]) == NULL ||
	    port >= ms->ms_nports)
		return (ENXIO);

	mp = &ms->ms_port[port];

	s = spltty();
	if (ISSET(mp->mp_flags, MBPPF_OPEN)) {
		splx(s);
		return (EBUSY);
	}
	SET(mp->mp_flags, MBPPF_OPEN);
	splx(s);

	/* set defaults */
	mp->mp_burst = BPP_BURST;
	mp->mp_timeout = mbpp_mstohz(BPP_TIMEOUT);
	mp->mp_delay = mbpp_mstohz(BPP_DELAY);

	/* init chips */
	if (mp->mp_cd1400) {	/* CD1400 */
		struct cd1400 *cd = mp->mp_cd1400;

		/* set up CD1400 channel */
		s = spltty();
		cd1400_write_reg(cd, CD1400_CAR, 0);
		cd1400_write_ccr(cd, CD1400_CCR_CMDRESET);
		cd1400_write_reg(cd, CD1400_LIVR, (1 << 3));
		splx(s);
	} else {		/* CD1190 */
		mp->mp_flags = 0;
		return (ENXIO);
	}

	return (0);
}

/*
 * close routine. returns zero if successful, else error code
 */
int
mbppclose(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	struct mbpp_softc *ms = mbpp_cd.cd_devs[MAGMA_CARD(dev)];
	struct mbpp_port *mp = &ms->ms_port[MAGMA_PORT(dev)];

	mp->mp_flags = 0;
	return (0);
}

/*
 * Read routine
 */
int
mbppread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	return (mbpp_rw(dev, uio));
}

/*
 * Write routine
 */
int
mbppwrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	return (mbpp_rw(dev, uio));
}

/*
 * ioctl routine
 */
int
mbppioctl(dev, cmd, data, flags, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
{
	struct mbpp_softc *ms = mbpp_cd.cd_devs[MAGMA_CARD(dev)];
	register struct mbpp_port *mp = &ms->ms_port[MAGMA_PORT(dev)];
	struct bpp_param *bp;
	int error = 0;
	int s;

	switch(cmd) {
	case BPPIOCSPARAM:
		bp = (struct bpp_param *)data;
		if (bp->bp_burst < BPP_BURST_MIN ||
		    bp->bp_burst > BPP_BURST_MAX ||
		    bp->bp_delay < BPP_DELAY_MIN ||
		    bp->bp_delay > BPP_DELAY_MIN) {
			error = EINVAL;
		} else {
			mp->mp_burst = bp->bp_burst;
			mp->mp_timeout = mbpp_mstohz(bp->bp_timeout);
			mp->mp_delay = mbpp_mstohz(bp->bp_delay);
		}
		break;
	case BPPIOCGPARAM:
		bp = (struct bpp_param *)data;
		bp->bp_burst = mp->mp_burst;
		bp->bp_timeout = mbpp_hztoms(mp->mp_timeout);
		bp->bp_delay = mbpp_hztoms(mp->mp_delay);
		break;
	case BPPIOCGSTAT:
		/* XXX make this more generic */
		s = spltty();
		cd1400_write_reg(mp->mp_cd1400, CD1400_CAR, 0);
		*(int *)data = cd1400_read_reg(mp->mp_cd1400, CD1400_PSVR);
		splx(s);
		break;
	default:
		error = ENOTTY;
	}

	return (error);
}

/*
 * poll routine
 */
int
mbpppoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
{
	return (seltrue(dev, events, p));
}

int
mbpp_rw(dev, uio)
	dev_t dev;
	struct uio *uio;
{
	int card = MAGMA_CARD(dev);
	int port = MAGMA_PORT(dev);
	struct mbpp_softc *ms = mbpp_cd.cd_devs[card];
	register struct mbpp_port *mp = &ms->ms_port[port];
	caddr_t buffer, ptr;
	size_t buflen, cnt, len;
	int s, error = 0;
	int gotdata = 0;

	if (uio->uio_resid == 0)
		return (0);

	buflen = ulmin(uio->uio_resid, mp->mp_burst);
	buffer = malloc(buflen, M_DEVBUF, M_WAITOK);

	SET(mp->mp_flags, MBPPF_UIO);

	/*
	 * start timeout, if needed
	 */
	if (mp->mp_timeout > 0) {
		SET(mp->mp_flags, MBPPF_TIMEOUT);
		timeout_add(&mp->mp_timeout_tmo, mp->mp_timeout);
	}

	len = cnt = 0;
	while (uio->uio_resid > 0) {
		len = ulmin(buflen, uio->uio_resid);
		ptr = buffer;

		if (uio->uio_rw == UIO_WRITE) {
			error = uiomove(ptr, len, uio);
			if (error)
				break;
		}
again:		/* goto bad */
		/* timed out?  */
		if (!ISSET(mp->mp_flags, MBPPF_UIO))
			break;

		/*
		 * perform the operation
		 */
		if (uio->uio_rw == UIO_WRITE) {
			cnt = mbpp_send(mp, ptr, len);
		} else {
			cnt = mbpp_recv(mp, ptr, len);
		}

		if (uio->uio_rw == UIO_READ) {
			if (cnt) {
				error = uiomove(ptr, cnt, uio);
				if (error)
					break;
				gotdata++;
			}
			else if (gotdata)	/* consider us done */
				break;
		}

		/* timed out?  */
		if (!ISSET(mp->mp_flags, MBPPF_UIO))
			break;

		/*
		 * poll delay?
		 */
		if (mp->mp_delay > 0) {
			s = spltty();	/* XXX */
			SET(mp->mp_flags, MBPPF_DELAY);
			timeout_add(&mp->mp_start_tmo, mp->mp_delay);
			error = tsleep(mp, PCATCH | PZERO, "mbppdelay", 0);
			splx(s);
			if (error)
				break;
		}

		/*
		 * Don't call uiomove again until we used all the data we
		 * grabbed.
		 */
		if (uio->uio_rw == UIO_WRITE && cnt != len) {
			ptr += cnt;
			len -= cnt;
			cnt = 0;
			goto again;
		}
	}

	/*
	 * clear timeouts
	 */
	s = spltty();	/* XXX */
	if (ISSET(mp->mp_flags, MBPPF_TIMEOUT)) {
		timeout_del(&mp->mp_timeout_tmo);
		CLR(mp->mp_flags, MBPPF_TIMEOUT);
	}
	if (ISSET(mp->mp_flags, MBPPF_DELAY)) {
		timeout_del(&mp->mp_start_tmo);
		CLR(mp->mp_flags, MBPPF_DELAY);
	}
	splx(s);

	/*
	 * Adjust for those chars that we uiomoved but never actually wrote.
	 */
	if (uio->uio_rw == UIO_WRITE && cnt != len) {
		uio->uio_resid += (len - cnt);
	}

	free(buffer, M_DEVBUF, 0);
	return (error);
}

void
mbpp_timeout(arg)
	void *arg;
{
	struct mbpp_port *mp = arg;

	CLR(mp->mp_flags, MBPPF_UIO | MBPPF_TIMEOUT);
	wakeup(mp);
}

void
mbpp_start(arg)
	void *arg;
{
	struct mbpp_port *mp = arg;

	CLR(mp->mp_flags, MBPPF_DELAY);
	wakeup(mp);
}

int
mbpp_send(mp, ptr, len)
	struct mbpp_port *mp;
	caddr_t ptr;
	int len;
{
	int s;
	struct cd1400 *cd = mp->mp_cd1400;

	/* set up io information */
	mp->mp_ptr = ptr;
	mp->mp_cnt = len;

	/* start transmitting */
	s = spltty();
	if (cd) {
		cd1400_write_reg(cd, CD1400_CAR, 0);

		/* output strobe width ~1microsecond */
		cd1400_write_reg(cd, CD1400_TBPR, 10);

		/* enable channel */
		cd1400_write_ccr(cd, CD1400_CCR_CMDCHANCTL | CD1400_CCR_XMTEN);
		cd1400_write_reg(cd, CD1400_SRER, CD1400_SRER_TXRDY);
	}

	/* zzz... */
	tsleep(mp, PCATCH | PZERO, "mbpp_send", 0);

	/* stop transmitting */
	if (cd) {
		cd1400_write_reg(cd, CD1400_CAR, 0);

		/* disable transmitter */
		cd1400_write_reg(cd, CD1400_SRER, 0);
		cd1400_write_ccr(cd, CD1400_CCR_CMDCHANCTL | CD1400_CCR_XMTDIS);

		/* flush fifo */
		cd1400_write_ccr(cd, CD1400_CCR_CMDRESET | CD1400_CCR_FTF);
	}
	splx(s);

	/* return number of chars sent */
	return (len - mp->mp_cnt);
}

int
mbpp_recv(mp, ptr, len)
	struct mbpp_port *mp;
	caddr_t ptr;
	int len;
{
	int s;
	struct cd1400 *cd = mp->mp_cd1400;

	/* set up io information */
	mp->mp_ptr = ptr;
	mp->mp_cnt = len;

	/* start receiving */
	s = spltty();
	if (cd) {
		int rcor, rbpr;

		cd1400_write_reg(cd, CD1400_CAR, 0);

		/* input strobe at 100kbaud (10microseconds) */
		cd1400_compute_baud(100000, cd->cd_clock, &rcor, &rbpr);
		cd1400_write_reg(cd, CD1400_RCOR, rcor);
		cd1400_write_reg(cd, CD1400_RBPR, rbpr);

		/* rx threshold */
		cd1400_write_reg(cd, CD1400_COR3, MBPP_RX_FIFO_THRESHOLD);
		cd1400_write_ccr(cd, CD1400_CCR_CMDCORCHG | CD1400_CCR_COR3);

		/* enable channel */
		cd1400_write_ccr(cd, CD1400_CCR_CMDCHANCTL | CD1400_CCR_RCVEN);
		cd1400_write_reg(cd, CD1400_SRER, CD1400_SRER_RXDATA);
	}

	/* zzz... */
	tsleep(mp, PCATCH | PZERO, "mbpp_recv", 0);

	/* stop receiving */
	if (cd) {
		cd1400_write_reg(cd, CD1400_CAR, 0);

		/* disable receiving */
		cd1400_write_reg(cd, CD1400_SRER, 0);
		cd1400_write_ccr(cd, CD1400_CCR_CMDCHANCTL | CD1400_CCR_RCVDIS);
	}
	splx(s);

	/* return number of chars received */
	return (len - mp->mp_cnt);
}

int
mbpp_hztoms(h)
	int h;
{
	int m = h;

	if (m > 0)
		m = m * 1000 / hz;
	return (m);
}

int
mbpp_mstohz(m)
	int m;
{
	int h = m;

	if (h > 0) {
		h = h * hz / 1000;
		if (h == 0)
			h = 1000 / hz;
	}
	return (h);
}
@


1.29
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.28 2014/07/12 18:44:43 tedu Exp $	*/
d1652 1
a1652 1
	int buflen, cnt, len;
d1659 1
a1659 1
	buflen = min(uio->uio_resid, mp->mp_burst);
d1674 1
a1674 1
		len = min(buflen, uio->uio_resid);
d1678 1
a1678 1
			error = uiomovei(ptr, len, uio);
d1698 1
a1698 1
				error = uiomovei(ptr, cnt, uio);
@


1.28
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.27 2010/07/02 17:27:01 nicm Exp $	*/
d1678 1
a1678 1
			error = uiomove(ptr, len, uio);
d1698 1
a1698 1
				error = uiomove(ptr, cnt, uio);
@


1.27
log
@Move common code for waking up writers on a tty into a function.

ok deraadt matthew millert
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.26 2010/06/28 14:13:30 deraadt Exp $	*/
d1757 1
a1757 1
	free(buffer, M_DEVBUF);
@


1.26
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.25 2010/04/12 12:57:52 tedu Exp $	*/
d1204 1
a1204 8
		if (tp->t_outq.c_cc <= tp->t_lowat) {
			if (ISSET(tp->t_state, TS_ASLEEP)) {
				CLR(tp->t_state, TS_ASLEEP);
				wakeup(&tp->t_outq);
			}

			selwakeup(&tp->t_wsel);
		}
@


1.25
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.24 2009/11/09 17:53:39 nicm Exp $	*/
d864 1
a864 1
		tp = ttymalloc();
@


1.24
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.23 2009/10/31 12:00:07 fgsch Exp $	*/
d981 1
a981 1
	return ((*linesw[tp->t_line].l_open)(dev, tp));
d999 1
a999 1
	(*linesw[tp->t_line].l_close)(tp, flag);
@


1.23
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.22 2009/10/31 06:40:16 deraadt Exp $	*/
a1210 1
			KNOTE(&tp->t_wsel.si_note, 0);
@


1.22
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.21 2009/04/10 20:53:51 miod Exp $	*/
d956 1
a956 1
	} else if (ISSET(tp->t_state, TS_XCLUDE) && p->p_ucred->cr_uid != 0) {
@


1.21
log
@generic soft interrupts support for sparc. Soft interrupt handlers are now
kept in a separate intrhand array, with their own enable bits so that
soft interrupts sharing the same level only get invoked if really triggered.
Inspired by NetBSD with significant changes.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.20 2008/11/29 01:55:06 ray Exp $	*/
d1211 1
@


1.20
log
@Iain Hibbert (plunky@@netbsd) removed clauses 3 and 4 from his
licenses as well. Thanks!

"Groovy" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.19 2004/11/02 21:16:10 miod Exp $	*/
a61 13
/*
 * Select tty soft interrupt bit based on TTY ipl. (stolen from zs.c)
 */
#if IPL_TTY == 1
# define IE_MSOFT IE_L1
#elif IPL_TTY == 4
# define IE_MSOFT IE_L4
#elif IPL_TTY == 6
# define IE_MSOFT IE_L6
#else
# error "no suitable software interrupt bit"
#endif

d470 1
a470 3
	sc->ms_softint.ih_fun = magma_soft;
	sc->ms_softint.ih_arg = sc;
	intr_establish(IPL_TTY, &sc->ms_softint, IPL_TTY, dev->dv_xname);
d703 2
a704 8
	if (needsoftint) {	/* trigger the soft interrupt */
#if defined(SUN4M)
		if (CPU_ISSUN4M)
			raise(0, IPL_TTY);
		else
#endif
			ienab_bis(IE_MSOFT);
	}
a711 2
 *  returns 1 if it handled it, 0 otherwise
 *
d714 1
a714 1
int
a721 1
	int serviced = 0;
a758 1
				serviced = 1;
a772 1
				serviced = 1;
a778 1
				serviced = 1;
a786 1
				serviced = 1;
a807 1
				serviced = 1;
a810 2

	return (serviced);
@


1.19
log
@KNF, constify structures, do not wrap the contents under #if NMAGMA > 0 as
if we were still running in pre-4.4BSD config(9) times.
@
text
@d1 3
a3 4
/*	$OpenBSD: magma.c,v 1.18 2004/09/29 07:35:11 miod Exp $	*/
/*
 * magma.c
 *
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Iain Hibbert
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
a25 1
 *
@


1.18
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.17 2003/10/03 16:44:50 miod Exp $	*/
a32 1
#define MAGMA_DEBUG
a40 1
#if NMAGMA > 0
d67 1
a67 1
#include "magmareg.h"
d70 1
a70 1
 * Select tty soft interrupt bit based on TTY ipl. (stole from zs.c)
d82 8
a89 1
/* supported cards
d101 1
a101 1
static struct magma_board_info supported_cards[] = {
d230 3
a232 3
speed_t speed;
int clock;
int *cor, *bpr;
d234 1
a234 1
int c, co, br;
d236 2
a237 2
	if( speed < 50 || speed > 150000 )
		return(1);
d239 1
a239 1
	for( c = 0, co = 8 ; co <= 2048 ; co <<= 2, c++ ) {
d241 1
a241 1
		if( br < 0x100 ) {
d244 1
a244 1
			return(0);
d248 1
a248 1
	return(1);
d256 2
a257 2
struct cd1400 *cd;
u_char cmd;
d259 1
a259 1
	while( cd1400_read_reg(cd, CD1400_CCR) )
d270 2
a271 2
struct cd1400 *cd;
int reg;
d273 1
a273 1
	return(cd->cd_reg[reg]);
d281 3
a283 3
struct cd1400 *cd;
int reg;
u_char value;
d293 2
a294 2
struct cd1400 *cd;
int channel;
d296 1
a296 1
register int s, srer;
d311 1
a311 1
/* well, there are none yet */
d330 1
a330 1
	struct magma_board_info *card;
d342 1
a342 1
int i;
d344 18
a361 10
	printf("magma: matched `%s', nvaddrs %d, nreg %d, nintr %d\n", ra->ra_name, ra->ra_nvaddrs, ra->ra_nreg, ra->ra_nintr);
	printf("magma: magma_prom `%s'\n", getpropstring(ra->ra_node, "magma_prom"));
	printf("magma: intlevels `%s'\n", getpropstring(ra->ra_node, "intlevels"));
	printf("magma: chiprev `%s'\n", getpropstring(ra->ra_node, "chiprev"));
	printf("magma: clock `%s'\n", getpropstring(ra->ra_node, "clock"));

	for( i = 0 ; i < ra->ra_nreg ; i++ )
		printf("magma: reg  %d; ra_iospace = %d, ra_paddr = 0x%x, ra_len = %d\n", i, ra->ra_reg[i].rr_iospace, (int)ra->ra_reg[i].rr_paddr, ra->ra_reg[i].rr_len);
	for( i = 0 ; i < ra->ra_nintr ; i++ )
		printf("magma: intr %d; pri = %d, vec = %d\n", i, ra->ra_intr[i].int_pri, ra->ra_intr[i].int_vec);
d370 11
a380 12
struct device *parent;
struct device *dev;
void *args;
{
struct confargs *ca = args;
struct romaux *ra = &ca->ca_ra;
struct magma_softc *sc = (struct magma_softc *)dev;
struct magma_board_info *card;
char magma_prom[40], *clockstr;
int chip, cd_clock, len;
void *base;

d395 1
a395 1
	if( card->mb_name == NULL ) {
d425 2
a426 2
	/* init the cd1400 chips */
	for( chip = 0 ; chip < card->mb_ncd1400 ; chip++ ) {
d437 3
a439 1
		dprintf(("%s attach CD1400 %d addr 0x%x rev %x clock %dMHz\n", sc->ms_dev.dv_xname, chip, cd->cd_reg, cd->cd_chiprev, cd->cd_clock));
d448 1
a448 1
		while( cd1400_read_reg(cd, CD1400_GFRCR) != cd->cd_chiprev )
d452 3
a454 1
		cd1400_write_reg(cd, CD1400_PPR, ((cd->cd_clock * 1000000 / CD1400_PPR_PRESCALER + 500) / 1000));
d456 5
a460 3
		/* The LC2+1Sp card is the only card that doesn't have a CD1190 for the
		 * parallel port, but uses channel 0 of the CD1400, so we make a note
		 * of it for later and set up the CD1400 for parallel mode operation.
d462 1
a462 1
		if( card->mb_npar && card->mb_ncd1190 == 0 ) {
d469 2
a470 2
	for( chip = 0 ; chip < card->mb_ncd1190 ; chip++ ) {
	struct cd1190 *cd = &sc->ms_cd1190[chip];
d473 2
a474 1
		dprintf(("%s attach CD1190 %d addr 0x%x (failed)\n", sc->ms_dev.dv_xname, chip, cd->cd_reg));
d504 1
a504 1
void *arg;
d506 5
a510 5
struct magma_softc *sc = arg;
struct cd1400 *cd;
int chip, status = 0;
int serviced = 0;
int needsoftint = 0;
d515 1
a515 1
	for( chip = 0 ; chip < sc->ms_ncd1400 ; chip++ )
d518 4
a521 3
	if( ISSET(status, CD1400_SVRR_RXRDY) ) {
	u_char rivr = *sc->ms_svcackr;	/* enter rx service context */
	int port = rivr >> 4;
d523 1
a523 1
		if( rivr & (1<<3) ) {			/* parallel port */
d532 2
a533 2
			while( n_chars-- ) {
				if( mbpp->mp_cnt == 0 ) {
d543 2
a544 2
		register struct mtty_port *mtty;
		register u_char *ptr, n_chars, line_stat;
d549 1
a549 1
			if( ISSET(rivr, CD1400_RIVR_EXCEPTION) ) {
d558 1
a558 1
			while( n_chars-- ) {
d561 5
a565 3
				if( ptr == mtty->mp_rend ) ptr = mtty->mp_rbuf;
				if( ptr == mtty->mp_rget ) {
					if( ptr == mtty->mp_rbuf ) ptr = mtty->mp_rend;
d576 2
a577 1
		cd1400_write_reg(cd, CD1400_EOSRR, 0);	/* end service context */
d579 1
a579 1
	} /* if(rx_service...) */
d581 7
a587 6
	if( ISSET(status, CD1400_SVRR_MDMCH) ) {
	u_char mivr = *sc->ms_svcackm;	/* enter mdm service context */
	int port = mivr >> 4;
	struct mtty_port *mtty;
	int carrier;
	u_char msvr;
d595 2
a596 1
		carrier = ISSET(msvr, cd->cd_parmode ? CD1400_MSVR2_DSR : CD1400_MSVR2_CD);
d598 1
a598 1
		if( mtty->mp_carrier != carrier ) {
d604 2
a605 1
		cd1400_write_reg(cd, CD1400_EOSRR, 0);	/* end service context */
d607 1
a607 1
	} /* if(mdm_service...) */
d609 4
a612 3
	if( ISSET(status, CD1400_SVRR_TXRDY) ) {
	u_char tivr = *sc->ms_svcackt;	/* enter tx service context */
	int port = tivr >> 4;
d614 2
a615 2
		if( tivr & (1<<3) ) {	/* parallel port */
		struct mbpp_port *mbpp;
d620 2
a621 2
			if( mbpp->mp_cnt ) {
			int count = 0;
d624 4
a627 2
				while( mbpp->mp_cnt && count++ < CD1400_PAR_FIFO_SIZE ) {
					cd1400_write_reg(cd, CD1400_TDR, *mbpp->mp_ptr);
d632 6
a637 4
				/* fifo is empty and we got no more data to send, so shut
				 * off interrupts and signal for a wakeup, which can't be
				 * done here in case we beat mbpp_send to the tsleep call
				 * (we are running at >spltty)
d644 2
a645 2
		struct mtty_port *mtty;
		struct tty *tp;
d651 2
a652 2
			if( !ISSET(mtty->mp_flags, MTTYF_STOP) ) {
			register int count = 0;
d655 1
a655 1
				if( ISSET(mtty->mp_flags, MTTYF_SET_BREAK) ) {
d663 1
a663 1
				if( ISSET(mtty->mp_flags, MTTYF_CLR_BREAK) ) {
d670 5
a674 3
				/* I don't quite fill the fifo in case the last one is a
				 * NULL which I have to double up because its the escape
				 * code for embedded transmit characters.
d676 3
a678 2
				while( mtty->mp_txc > 0 && count < CD1400_TX_FIFO_SIZE - 1 ) {
				register u_char ch;
d685 3
a687 2
					if( ch == 0 ) {
						cd1400_write_reg(cd, CD1400_TDR, ch);
d696 4
a699 3
			/* if we ran out of work or are requested to STOP then
			 * shut off the txrdy interrupts and signal DONE to flush
			 * out the chars we have sent.
d701 3
a703 2
			if( mtty->mp_txc == 0 || ISSET(mtty->mp_flags, MTTYF_STOP) ) {
			register int srer;
d715 2
a716 1
		cd1400_write_reg(cd, CD1400_EOSRR, 0);	/* end service context */
d718 1
a718 1
	} /* if(tx_service...) */
d721 1
a721 1
	for( chip = 0 ; chip < sc->ms_ncd1190 ; chip++ ) {
d725 1
a725 1
	if( needsoftint ) {	/* trigger the soft interrupt */
d727 1
a727 1
		if( CPU_ISSUN4M )
d734 1
a734 1
	return(serviced);
d746 1
a746 1
void *arg;
d748 6
a753 6
struct magma_softc *sc = arg;
struct mtty_softc *mtty = sc->ms_mtty;
struct mbpp_softc *mbpp = sc->ms_mbpp;
int port;
int serviced = 0;
int s, flags;
d758 4
a761 4
	if( mtty ) {
		for( port = 0 ; port < mtty->ms_nports ; port++ ) {
		struct mtty_port *mp = &mtty->ms_port[port];
		struct tty *tp = mp->mp_tty;
d763 2
a764 1
			if( !ISSET(tp->t_state, TS_ISOPEN) ) continue;
d769 3
a771 3
			while( mp->mp_rget != mp->mp_rput ) {
			u_char stat;
			int data;
d775 3
a777 1
				mp->mp_rget = ((mp->mp_rget + 2) == mp->mp_rend) ? mp->mp_rbuf : (mp->mp_rget + 2);
d779 1
a779 1
				if( stat & (CD1400_RDSR_BREAK | CD1400_RDSR_FE) )
d781 1
a781 1
				if( stat & CD1400_RDSR_PE )
d784 4
a787 2
				if( stat & CD1400_RDSR_OE )
					log(LOG_WARNING, "%s%x: fifo overflow\n", mtty->ms_dev.dv_xname, port);
d795 2
a796 1
			CLR(mp->mp_flags, MTTYF_DONE | MTTYF_CARRIER_CHANGED | MTTYF_RING_OVERFLOW);
d799 6
a804 3
			if( ISSET(flags, MTTYF_CARRIER_CHANGED) ) {
				dprintf(("%s%x: cd %s\n", mtty->ms_dev.dv_xname, port, mp->mp_carrier ? "on" : "off"));
				(*linesw[tp->t_line].l_modem)(tp, mp->mp_carrier);
d808 4
a811 2
			if( ISSET(flags, MTTYF_RING_OVERFLOW) ) {
				log(LOG_WARNING, "%s%x: ring buffer overflow\n", mtty->ms_dev.dv_xname, port);
d815 3
a817 2
			if( ISSET(flags, MTTYF_DONE) ) {
				ndflush(&tp->t_outq, mp->mp_txp - tp->t_outq.c_cf);
d819 2
a820 1
				(*linesw[tp->t_line].l_start)(tp);	/* might be some more */
d823 1
a823 1
		} /* for(each mtty...) */
d829 3
a831 3
	if( mbpp ) {
		for( port = 0 ; port < mbpp->ms_nports ; port++ ) {
		struct mbpp_port *mp = &mbpp->ms_port[port];
d833 2
a834 1
			if( !ISSET(mp->mp_flags, MBPPF_OPEN) ) continue;
d841 1
a841 1
			if( ISSET(flags, MBPPF_WAKEUP) ) {
d845 1
a845 1
		} /* for(each mbpp...) */
d848 1
a848 1
	return(serviced);
d871 2
a872 2
struct device *parent;
void *vcf, *args;
d874 1
a874 1
struct magma_softc *sc = (struct magma_softc *)parent;
d876 2
a877 1
	return( args == mtty_match && sc->ms_board->mb_nser && sc->ms_mtty == NULL );
d882 7
a888 7
struct device *parent;
struct device *dev;
void *args;
{
struct magma_softc *sc = (struct magma_softc *)parent;
struct mtty_softc *ms = (struct mtty_softc *)dev;
int port, chip, chan;
d893 3
a895 3
	for( port = 0, chip = 0, chan = 0 ; port < sc->ms_board->mb_nser ; port++ ) {
	struct mtty_port *mp = &ms->ms_port[port];
	struct tty *tp;
d898 2
a899 1
		if( mp->mp_cd1400->cd_parmode && chan == 0 ) chan = 1; /* skip channel 0 if parmode */
d909 2
a910 1
		if( mp->mp_rbuf == NULL ) break;
d915 2
a916 1
		if( chan == 0 ) chip++;
d928 12
a939 12
dev_t dev;
int flags;
int mode;
struct proc *p;
{
int card = MAGMA_CARD(dev);
int port = MAGMA_PORT(dev);
struct mtty_softc *ms;
struct mtty_port *mp;
struct tty *tp;
struct cd1400 *cd;
int s;
d941 3
a943 2
	if( card >= mtty_cd.cd_ndevs || (ms = mtty_cd.cd_devs[card]) == NULL || port >= ms->ms_nports )
		return(ENXIO);	/* device not configured */
d949 1
a949 1
	if( !ISSET(tp->t_state, TS_ISOPEN) ) {
d957 1
a957 1
		if( ISSET(mp->mp_openflags, TIOCFLAG_CLOCAL) )
d959 1
a959 1
		if( ISSET(mp->mp_openflags, TIOCFLAG_CRTSCTS) )
d961 1
a961 1
		if( ISSET(mp->mp_openflags, TIOCFLAG_MDMBUF) )
d977 1
a977 1
		cd1400_write_reg(cd, CD1400_LIVR, port << 4 );
d986 2
a987 1
		cd1400_write_reg(cd, CD1400_SRER, CD1400_SRER_RXDATA | CD1400_SRER_MDMCH);
d990 1
a990 1
		if( ISSET(mp->mp_openflags, TIOCFLAG_SOFTCAR) || mp->mp_carrier )
d994 2
a995 2
	} else if( ISSET(tp->t_state, TS_XCLUDE) && p->p_ucred->cr_uid != 0 ) {
		return(EBUSY);	/* superuser can break exclusive access */
d1001 4
a1004 3
	if( !ISSET(flags, O_NONBLOCK) ) {
		while( !ISSET(tp->t_cflag, CLOCAL) && !ISSET(tp->t_state, TS_CARR_ON) ) {
		int error;
d1007 3
a1009 2
			error = ttysleep(tp, &tp->t_rawq, TTIPRI | PCATCH, "mttydcd", 0);
			if( error != 0 ) {
d1012 1
a1012 1
				return(error);
d1019 1
a1019 1
	return( (*linesw[tp->t_line].l_open)(dev, tp) );
d1027 9
a1035 9
dev_t dev;
int flag;
int mode;
struct proc *p;
{
struct mtty_softc *ms = mtty_cd.cd_devs[MAGMA_CARD(dev)];
struct mtty_port *mp = &ms->ms_port[MAGMA_PORT(dev)];
struct tty *tp = mp->mp_tty;
int s;
d1040 3
a1042 2
	/* if HUPCL is set, and the tty is no longer open
	 * shut down the port
d1044 4
a1047 4
	if( ISSET(tp->t_cflag, HUPCL) || !ISSET(tp->t_state, TS_ISOPEN) ) {
	/* XXX wait until FIFO is empty before turning off the channel
	struct cd1400 *cd = mp->mp_cd1400;
	*/
d1061 1
a1061 1
	return(0);
d1069 7
a1075 7
dev_t dev;
struct uio *uio;
int flags;
{
struct mtty_softc *ms = mtty_cd.cd_devs[MAGMA_CARD(dev)];
struct mtty_port *mp = &ms->ms_port[MAGMA_PORT(dev)];
struct tty *tp = mp->mp_tty;
d1077 1
a1077 1
	return( (*linesw[tp->t_line].l_read)(tp, uio, flags) );
d1085 7
a1091 7
dev_t dev;
struct uio *uio;
int flags;
{
struct mtty_softc *ms = mtty_cd.cd_devs[MAGMA_CARD(dev)];
struct mtty_port *mp = &ms->ms_port[MAGMA_PORT(dev)];
struct tty *tp = mp->mp_tty;
d1093 1
a1093 1
	return( (*linesw[tp->t_line].l_write)(tp, uio, flags) );
d1101 1
a1101 1
dev_t dev;
d1103 2
a1104 2
struct mtty_softc *ms = mtty_cd.cd_devs[MAGMA_CARD(dev)];
struct mtty_port *mp = &ms->ms_port[MAGMA_PORT(dev)];
d1106 1
a1106 1
	return(mp->mp_tty);
d1114 10
a1123 10
dev_t dev;
u_long cmd;
caddr_t data;
int flags;
struct proc *p;
{
struct mtty_softc *ms = mtty_cd.cd_devs[MAGMA_CARD(dev)];
struct mtty_port *mp = &ms->ms_port[MAGMA_PORT(dev)];
struct tty *tp = mp->mp_tty;
int error;
d1126 2
a1127 1
	if( error >= 0 ) return(error);
d1130 2
a1131 1
	if( error >= 0 ) return(error);
d1175 1
a1175 1
		if( suser(p, 0) )
d1187 1
a1187 1
	return(error);
d1195 2
a1196 2
struct tty *tp;
int flags;
d1198 3
a1200 3
struct mtty_softc *ms = mtty_cd.cd_devs[MAGMA_CARD(tp->t_dev)];
struct mtty_port *mp = &ms->ms_port[MAGMA_PORT(tp->t_dev)];
int s;
d1204 2
a1205 2
	if( ISSET(tp->t_state, TS_BUSY) ) {
		if( !ISSET(tp->t_state, TS_TTSTOP) )
d1216 1
a1216 1
	return(0);
d1224 1
a1224 1
struct tty *tp;
d1226 3
a1228 3
struct mtty_softc *ms = mtty_cd.cd_devs[MAGMA_CARD(tp->t_dev)];
struct mtty_port *mp = &ms->ms_port[MAGMA_PORT(tp->t_dev)];
int s;
d1232 3
a1234 2
	/* we only need to do something if we are not already busy
	 * or delaying or stopped
d1236 1
a1236 1
	if( !ISSET(tp->t_state, TS_TTSTOP | TS_TIMEOUT | TS_BUSY) ) {
d1238 3
a1240 2
		/* if we are sleeping and output has drained below
		 * low water mark, awaken
d1242 2
a1243 2
		if( tp->t_outq.c_cc <= tp->t_lowat ) {
			if( ISSET(tp->t_state, TS_ASLEEP) ) {
d1251 2
a1252 1
		/* if something to send, start transmitting
d1254 1
a1254 1
		if( tp->t_outq.c_cc ) {
d1258 2
a1259 1
			cd1400_enable_transmitter(mp->mp_cd1400, mp->mp_channel);
d1278 7
a1284 7
struct mtty_port *mp;
int bits;
int howto;
{
struct cd1400 *cd = mp->mp_cd1400;
struct tty *tp = mp->mp_tty;
int s, msvr;
d1297 2
a1298 1
		if( msvr & CD1400_MSVR1_RTS ) bits |= TIOCM_DTR;
d1301 10
a1310 5
		if( msvr & CD1400_MSVR2_DTR ) bits |= TIOCM_RTS;
		if( msvr & CD1400_MSVR2_CTS ) bits |= TIOCM_CTS;
		if( msvr & CD1400_MSVR2_RI ) bits |= TIOCM_RI;
		if( msvr & CD1400_MSVR2_DSR ) bits |= (cd->cd_parmode ? TIOCM_CD : TIOCM_DSR);
		if( msvr & CD1400_MSVR2_CD ) bits |= (cd->cd_parmode ? 0 : TIOCM_CD);
d1315 3
a1317 2
		if( !ISSET(tp->t_cflag, CRTSCTS) )
			cd1400_write_reg(cd, CD1400_MSVR2, ((bits & TIOCM_RTS) ? CD1400_MSVR2_DTR : 0));
d1319 2
a1320 1
		cd1400_write_reg(cd, CD1400_MSVR1, ((bits & TIOCM_DTR) ? CD1400_MSVR1_RTS : 0));
d1325 1
a1325 1
		if( (bits & TIOCM_RTS) && !ISSET(tp->t_cflag, CRTSCTS) )
d1328 1
a1328 1
		if( bits & TIOCM_DTR )
d1334 1
a1334 1
		if( (bits & TIOCM_RTS) && !ISSET(tp->t_cflag, CRTSCTS) )
d1337 1
a1337 1
		if( bits & TIOCM_DTR )
d1344 1
a1344 1
	return(bits);
d1352 2
a1353 2
struct tty *tp;
struct termios *t;
d1355 14
a1368 12
struct mtty_softc *ms = mtty_cd.cd_devs[MAGMA_CARD(tp->t_dev)];
struct mtty_port *mp = &ms->ms_port[MAGMA_PORT(tp->t_dev)];
struct cd1400 *cd = mp->mp_cd1400;
int rbpr, tbpr, rcor, tcor;
u_char mcor1 = 0, mcor2 = 0;
int s, opt;

	if( t->c_ospeed && cd1400_compute_baud(t->c_ospeed, cd->cd_clock, &tcor, &tbpr) )
		return(EINVAL);

	if( t->c_ispeed && cd1400_compute_baud(t->c_ispeed, cd->cd_clock, &rcor, &rbpr) )
		return(EINVAL);
d1373 2
a1374 1
	(void)mtty_modem_control(mp, TIOCM_DTR, (t->c_ospeed == 0 ? DMBIC : DMBIS));
d1380 1
a1380 1
	if( t->c_ospeed ) {
d1386 1
a1386 1
	if( t->c_ispeed ) {
d1397 3
a1399 2
	if( ISSET(t->c_cflag, PARENB) )
		opt |= (ISSET(t->c_cflag, PARODD) ? CD1400_COR1_PARODD : CD1400_COR1_PARNORMAL);
d1401 1
a1401 1
	if( !ISSET(t->c_iflag, INPCK) )
d1404 1
a1404 1
	if( ISSET(t->c_cflag, CSTOPB) )
d1407 1
a1407 1
	switch( t->c_cflag & CSIZE ) {
d1432 2
a1433 1
	if( ISSET(t->c_cflag, CRTSCTS) ) opt |= CD1400_COR2_CCTS_OFLOW;
d1438 2
a1439 1
	cd1400_write_ccr(cd, CD1400_CCR_CMDCORCHG | CD1400_CCR_COR1 | CD1400_CCR_COR2 | CD1400_CCR_COR3);
d1448 1
a1448 1
	if( ISSET(t->c_cflag, CRTSCTS) )
d1452 1
a1452 1
	if( cd->cd_parmode ) {
d1467 1
a1467 1
	return(0);
d1491 2
a1492 2
struct device *parent;
void *vcf, *args;
d1494 1
a1494 1
register struct magma_softc *sc = (struct magma_softc *)parent;
d1496 2
a1497 1
	return( args == mbpp_match && sc->ms_board->mb_npar && sc->ms_mbpp == NULL );
d1502 8
a1509 8
struct device *parent;
struct device *dev;
void *args;
{
struct magma_softc *sc = (struct magma_softc *)parent;
struct mbpp_softc *ms = (struct mbpp_softc *)dev;
struct mbpp_port *mp;
int port;
d1514 1
a1514 1
	for( port = 0 ; port < sc->ms_board->mb_npar ; port++ ) {
d1517 1
a1517 1
		if( sc->ms_ncd1190 )
d1535 14
a1548 13
dev_t dev;
int flags;
int mode;
struct proc *p;
{
int card = MAGMA_CARD(dev);
int port = MAGMA_PORT(dev);
struct mbpp_softc *ms;
struct mbpp_port *mp;
int s;

	if( card >= mbpp_cd.cd_ndevs || (ms = mbpp_cd.cd_devs[card]) == NULL || port >= ms->ms_nports )
		return(ENXIO);
d1553 1
a1553 1
	if( ISSET(mp->mp_flags, MBPPF_OPEN) ) {
d1555 1
a1555 1
		return(EBUSY);
d1566 2
a1567 2
	if( mp->mp_cd1400 ) {	/* CD1400 */
	struct cd1400 *cd = mp->mp_cd1400;
d1573 1
a1573 1
		cd1400_write_reg(cd, CD1400_LIVR, (1<<3));
d1577 1
a1577 1
		return(ENXIO);
d1580 1
a1580 1
	return(0);
d1588 4
a1591 4
dev_t dev;
int flag;
int mode;
struct proc *p;
d1593 2
a1594 2
struct mbpp_softc *ms = mbpp_cd.cd_devs[MAGMA_CARD(dev)];
struct mbpp_port *mp = &ms->ms_port[MAGMA_PORT(dev)];
d1597 1
a1597 1
	return(0);
d1605 3
a1607 3
dev_t dev;
struct uio *uio;
int flags;
d1609 1
a1609 1
	return( mbpp_rw(dev, uio) );
d1617 3
a1619 3
dev_t dev;
struct uio *uio;
int flags;
d1621 1
a1621 1
	return( mbpp_rw(dev, uio) );
d1629 11
a1639 11
dev_t dev;
u_long cmd;
caddr_t data;
int flags;
struct proc *p;
{
struct mbpp_softc *ms = mbpp_cd.cd_devs[MAGMA_CARD(dev)];
register struct mbpp_port *mp = &ms->ms_port[MAGMA_PORT(dev)];
struct bpp_param *bp;
int error = 0;
int s;
d1644 4
a1647 2
		if( bp->bp_burst < BPP_BURST_MIN || bp->bp_burst > BPP_BURST_MAX ||
		    bp->bp_delay < BPP_DELAY_MIN || bp->bp_delay > BPP_DELAY_MIN ) {
d1672 1
a1672 1
	return(error);
d1680 3
a1682 3
dev_t dev;
int events;
struct proc *p;
d1684 1
a1684 1
	return(seltrue(dev, events, p));
d1689 2
a1690 2
dev_t dev;
struct uio *uio;
d1692 8
a1699 8
int card = MAGMA_CARD(dev);
int port = MAGMA_PORT(dev);
struct mbpp_softc *ms = mbpp_cd.cd_devs[card];
register struct mbpp_port *mp = &ms->ms_port[port];
caddr_t buffer, ptr;
int buflen, cnt, len;
int s, error = 0;
int gotdata = 0;
d1701 2
a1702 2
	if( uio->uio_resid == 0 )
		return(0);
d1712 1
a1712 1
	if( mp->mp_timeout > 0 ) {
d1718 1
a1718 1
	while( uio->uio_resid > 0 ) {
d1722 1
a1722 1
		if( uio->uio_rw == UIO_WRITE ) {
d1724 2
a1725 1
			if( error ) break;
d1729 1
a1729 1
		if( !ISSET(mp->mp_flags, MBPPF_UIO) )
d1735 1
a1735 1
		if( uio->uio_rw == UIO_WRITE ) {
d1741 2
a1742 2
		if( uio->uio_rw == UIO_READ ) {
			if( cnt ) {
d1744 2
a1745 1
				if( error ) break;
d1748 1
a1748 1
			else if( gotdata )	/* consider us done */
d1753 1
a1753 1
		if( !ISSET(mp->mp_flags, MBPPF_UIO) )
d1759 1
a1759 1
		if( mp->mp_delay > 0 ) {
d1765 2
a1766 1
			if( error ) break;
d1770 2
a1771 1
		 * don't call uiomove again until we used all the data we grabbed
d1773 1
a1773 1
		if( uio->uio_rw == UIO_WRITE && cnt != len ) {
d1785 1
a1785 1
	if( ISSET(mp->mp_flags, MBPPF_TIMEOUT) ) {
d1789 1
a1789 1
	if( ISSET(mp->mp_flags, MBPPF_DELAY) ) {
d1796 1
a1796 1
	 * adjust for those chars that we uiomoved but never actually wrote
d1798 1
a1798 1
	if( uio->uio_rw == UIO_WRITE && cnt != len ) {
d1803 1
a1803 1
	return(error);
d1808 1
a1808 1
void *arg;
d1810 1
a1810 1
struct mbpp_port *mp = arg;
d1818 1
a1818 1
void *arg;
d1820 1
a1820 1
struct mbpp_port *mp = arg;
d1828 3
a1830 3
struct mbpp_port *mp;
caddr_t ptr;
int len;
d1832 2
a1833 2
int s;
struct cd1400 *cd = mp->mp_cd1400;
d1841 1
a1841 1
	if( cd ) {
d1852 1
a1852 1
	/* ZZzzz... */
d1856 1
a1856 1
	if( cd ) {
d1869 1
a1869 1
	return(len - mp->mp_cnt);
d1874 3
a1876 3
struct mbpp_port *mp;
caddr_t ptr;
int len;
d1878 2
a1879 2
int s;
struct cd1400 *cd = mp->mp_cd1400;
d1887 2
a1888 2
	if( cd ) {
	int rcor, rbpr;
d1906 1
a1906 1
	/* ZZzzz... */
d1910 1
a1910 1
	if( cd ) {
d1920 1
a1920 1
	return(len - mp->mp_cnt);
d1925 1
a1925 1
int h;
d1927 1
a1927 1
int m = h;
d1929 1
a1929 1
	if( m > 0 )
d1931 1
a1931 1
	return(m);
d1936 1
a1936 1
int m;
d1938 1
a1938 1
int h = m;
d1940 1
a1940 1
	if( h > 0 ) {
d1942 1
a1942 1
		if( h == 0 )
d1945 1
a1945 1
	return(h);
a1946 2

#endif /* NMAGMA */
@


1.17
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.16 2003/09/23 16:51:11 millert Exp $	*/
d468 2
a469 1
	intr_establish(ra->ra_intr[0].int_pri, &sc->ms_hardint, -1);
d473 1
a473 1
	intr_establish(IPL_TTY, &sc->ms_softint, IPL_TTY);
@


1.16
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.15 2003/08/15 20:32:14 tedu Exp $	*/
a847 2
		if( tp == NULL ) break;
		tty_attach(tp);
@


1.15
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.14 2003/02/11 19:20:26 mickey Exp $	*/
d1401 1
a1401 1
 *	mbppselect	do select on mbpp
d1592 1
a1592 1
 * select routine
d1595 1
a1595 1
mbppselect(dev, rw, p)
d1597 1
a1597 1
int rw;
d1600 1
a1600 1
	return(ENODEV);
@


1.14
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.13 2002/04/30 01:12:29 art Exp $	*/
d1113 1
a1113 1
		if( suser(p->p_ucred, &p->p_acflag) )
@


1.13
log
@Fix an ancient problem in how sparc interrupts are handled.

There are many interrupt handlers that assume that they don't need to do
any spl protection in their code because the interrupt of some level can't
be interrupted by an interrupt of the same level. The problem is that some
interrupt handlers have hardware levels that are lower then their "software"
levels.

Fix this by adding an additional field to struct intrhand that specifies which
"software" level an interrupt handler has and blocks that level while handling
the interrupt. This new field is initialized in intr_establish which gets
an additional argument (which can be -1 meaning that the interrupt handler
doesn't need to block any additional level).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.12 2002/04/28 03:51:19 art Exp $	*/
d425 1
a425 1
		dprintf(("%s attach CD1400 %d addr 0x%x rev %x clock %dMhz\n", sc->ms_dev.dv_xname, chip, cd->cd_reg, cd->cd_chiprev, cd->cd_clock));
@


1.12
log
@Rename all PIL_* constants to IPL_* to match other archs and make them
usable in MD code in the future.
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.11 2002/03/14 03:48:56 jason Exp $	*/
d468 1
a468 1
	intr_establish(ra->ra_intr[0].int_pri, &sc->ms_hardint);
d472 1
a472 1
	intr_establish(IPL_TTY, &sc->ms_softint);
@


1.11
log
@use getprop, not getpropstring to fetch 'magma_prom' property...
ra->ra_name is needed and is the result of getpropstring
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.10 2002/01/25 02:37:43 jason Exp $	*/
d74 1
a74 1
#if PIL_TTY == 1
d76 1
a76 1
#elif PIL_TTY == 4
d78 1
a78 1
#elif PIL_TTY == 6
d399 1
a399 1
	printf(" pri %d softpri %d:", ra->ra_intr[0].int_pri, PIL_TTY);
d472 1
a472 1
	intr_establish(PIL_TTY, &sc->ms_softint);
d689 1
a689 1
			raise(0, PIL_TTY);
@


1.10
log
@Add support for the "Magma 2+1HS Sp" (from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.9 2002/01/11 05:17:30 jason Exp $	*/
d365 2
a366 2
char *magma_prom, *clockstr;
int chip, cd_clock;
d369 7
a375 1
	magma_prom = getpropstring(ra->ra_node, "magma_prom");
@


1.9
log
@for the "Magma LC 2+1 Sp", we have to check the 'clock' property (it's
64Mhz vs. the "normal" 25Mhz).  This (with the cs4231 patch) makes this
board work.
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.8 2001/05/16 12:49:48 ho Exp $	*/
d98 1
a98 1
		"MAGMA,4_Sp", "Magma 4 Sp", 4, 0,
d103 1
a103 1
		"MAGMA,8_Sp", "Magma 8 Sp", 8, 0,
d108 1
a108 1
		"MAGMA,_8HS_Sp", "Magma Fast 8 Sp", 8, 0,
d113 1
a113 1
		"MAGMA,_8SP_422", "Magma 8 Sp - 422", 8, 0,
d118 1
a118 1
		"MAGMA,12_Sp", "Magma 12 Sp", 12, 0,
d123 1
a123 1
		"MAGMA,16_Sp", "Magma 16 Sp", 16, 0,
d128 1
a128 1
		"MAGMA,16_Sp_2", "Magma 16 Sp", 16, 0,
d133 1
a133 1
		"MAGMA,16HS_Sp", "Magma Fast 16 Sp", 16, 0,
d138 1
a138 1
		"MAGMA,21_Sp", "Magma LC 2+1 Sp", 2, 1,
d143 1
a143 1
		"MAGMA,21HS_Sp", "Magma 2+1 Sp", 2, 1,
d148 1
a148 1
		"MAGMA,41_Sp", "Magma 4+1 Sp", 4, 1,
d153 1
a153 1
		"MAGMA,82_Sp", "Magma 8+2 Sp", 8, 2,
d158 1
a158 1
		"MAGMA,P1_Sp", "Magma P1 Sp", 0, 1,
d163 1
a163 1
		"MAGMA,P2_Sp", "Magma P2 Sp", 0, 2,
d168 6
a173 1
		NULL, NULL, 0, 0,
d320 2
a321 2
struct device *parent;
void *vcf, *args;
d323 11
a333 6
register struct confargs *ca = args;
register struct romaux *ra = &ca->ca_ra;

	/* is it a magma Sp card? */
	if( strcmp(ra->ra_name, "MAGMA_Sp") != 0 )
		return(0);
d364 3
a366 3
struct magma_board_info *card = supported_cards;
char *magma_prom = getpropstring(ra->ra_node, "magma_prom");
int chip;
d369 7
a375 6
	/* find the card type */
	while( card->mb_name && strcmp(magma_prom, card->mb_name) )
		card++;

	dprintf((" addr 0x%x", sc));
	printf(" pri %d softpri %d:", ra->ra_intr[0].int_pri, PIL_TTY);
d382 12
a408 1
		char *str;
d413 1
a413 10
		str = getpropstring(ra->ra_node, "clock");
		if (strlen(str) == 0)
			cd->cd_clock = 25;
		else {
			char *cp = str;

			cd->cd_clock = 0;
			while (*cp != '\0')
				cd->cd_clock = cd->cd_clock * 10 + *cp++ - '0';
		}
@


1.8
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.7 2001/03/24 10:07:19 ho Exp $	*/
d386 2
a387 1
	struct cd1400 *cd = &sc->ms_cd1400[chip];
d391 10
a400 2
		/* XXX getpropstring(ra->ra_node, "clock") */
		cd->cd_clock = 25;
@


1.8.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.10 2002/01/25 02:37:43 jason Exp $	*/
d98 1
a98 1
		"MAGMA_Sp", "MAGMA,4_Sp", "Magma 4 Sp", 4, 0,
d103 1
a103 1
		"MAGMA_Sp", "MAGMA,8_Sp", "Magma 8 Sp", 8, 0,
d108 1
a108 1
		"MAGMA_Sp", "MAGMA,_8HS_Sp", "Magma Fast 8 Sp", 8, 0,
d113 1
a113 1
		"MAGMA_Sp", "MAGMA,_8SP_422", "Magma 8 Sp - 422", 8, 0,
d118 1
a118 1
		"MAGMA_Sp", "MAGMA,12_Sp", "Magma 12 Sp", 12, 0,
d123 1
a123 1
		"MAGMA_Sp", "MAGMA,16_Sp", "Magma 16 Sp", 16, 0,
d128 1
a128 1
		"MAGMA_Sp", "MAGMA,16_Sp_2", "Magma 16 Sp", 16, 0,
d133 1
a133 1
		"MAGMA_Sp", "MAGMA,16HS_Sp", "Magma Fast 16 Sp", 16, 0,
d138 1
a138 1
		"MAGMA_Sp", "MAGMA,21_Sp", "Magma LC 2+1 Sp", 2, 1,
d143 1
a143 1
		"MAGMA_Sp", "MAGMA,21HS_Sp", "Magma 2+1 Sp", 2, 1,
d148 1
a148 1
		"MAGMA_Sp", "MAGMA,41_Sp", "Magma 4+1 Sp", 4, 1,
d153 1
a153 1
		"MAGMA_Sp", "MAGMA,82_Sp", "Magma 8+2 Sp", 8, 2,
d158 1
a158 1
		"MAGMA_Sp", "MAGMA,P1_Sp", "Magma P1 Sp", 0, 1,
d163 1
a163 1
		"MAGMA_Sp", "MAGMA,P2_Sp", "Magma P2 Sp", 0, 2,
d168 1
a168 6
		"MAGMA 2+1HS Sp", "", "Magma 2+1HS Sp", 2, 0,
		1, 0xa000, 0xc000, 0xe000, { 0x4000, 0, 0, 0 },
		1, { 0x8000, 0 }
	},
	{
		NULL, NULL, NULL, 0, 0,
d315 2
a316 2
	struct device *parent;
	void *vcf, *args;
d318 6
a323 11
	struct confargs *ca = args;
	struct romaux *ra = &ca->ca_ra;
	struct magma_board_info *card;

	for (card = supported_cards; ; card++) {
		if (card->mb_sbusname == NULL)
			/* End of table: no match */
			return (0);
		if (strcmp(ra->ra_name, card->mb_sbusname) == 0)
			break;
	}
d354 3
a356 3
struct magma_board_info *card;
char *magma_prom, *clockstr;
int chip, cd_clock;
d359 6
a364 7
	magma_prom = getpropstring(ra->ra_node, "magma_prom");
	for (card = supported_cards; card->mb_name != NULL; card++) {
		if (strcmp(ra->ra_name, card->mb_sbusname) != 0)
			continue;
		if (strcmp(magma_prom, card->mb_name) == 0)
			break;
	}
a370 12

	clockstr = getpropstring(ra->ra_node, "clock");
	if (strlen(clockstr) == 0)
		cd_clock = 0;
	else {
		cd_clock = 0;
		while (*clockstr != '\0')
			cd_clock = cd_clock * 10 + *clockstr++ - '0';
	}

	dprintf((" addr 0x%x", sc));
	printf(" pri %d softpri %d:", ra->ra_intr[0].int_pri, PIL_TTY);
d386 1
a386 1
		struct cd1400 *cd = &sc->ms_cd1400[chip];
d390 2
a391 1
		cd->cd_clock = cd_clock;
@


1.8.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.8.4.1 2002/01/31 22:55:22 niklas Exp $	*/
d74 1
a74 1
#if IPL_TTY == 1
d76 1
a76 1
#elif IPL_TTY == 4
d78 1
a78 1
#elif IPL_TTY == 6
d365 2
a366 2
char magma_prom[40], *clockstr;
int chip, cd_clock, len;
d369 1
a369 7

	len = getprop(ra->ra_node, "magma_prom",
	    magma_prom, sizeof(magma_prom) - 1);
	if (len == -1)
		len = 0;
	magma_prom[len] = '\0';

d393 1
a393 1
	printf(" pri %d softpri %d:", ra->ra_intr[0].int_pri, IPL_TTY);
d462 1
a462 1
	intr_establish(ra->ra_intr[0].int_pri, &sc->ms_hardint, -1);
d466 1
a466 1
	intr_establish(IPL_TTY, &sc->ms_softint, IPL_TTY);
d683 1
a683 1
			raise(0, IPL_TTY);
@


1.8.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d425 1
a425 1
		dprintf(("%s attach CD1400 %d addr 0x%x rev %x clock %dMHz\n", sc->ms_dev.dv_xname, chip, cd->cd_reg, cd->cd_chiprev, cd->cd_clock));
@


1.7
log
@Convert to new timeout API. art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.6 2000/07/05 13:13:20 art Exp $	*/
a1593 2
	if( buffer == NULL )
		return(ENOMEM);
@


1.6
log
@Change splsoftclock to spltty. spltty is probably too paranoid, but it's
less wrong than using splsoftclock which is defined to be a lowering spl
(this doesn't matter on the sparc yet, because spls on sparc are wrong,
but it will matter soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.5 2000/07/05 12:53:20 art Exp $	*/
d1412 3
d1604 1
a1604 1
		timeout(mbpp_timeout, mp, mp->mp_timeout);
d1650 1
a1650 1
			timeout(mbpp_start, mp, mp->mp_delay);
d1672 1
a1672 1
		untimeout(mbpp_timeout, mp);
d1676 1
a1676 1
		untimeout(mbpp_start, mp);
@


1.5
log
@OpenBSD-tag
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1645 1
a1645 1
			s = splsoftclock();
d1667 1
a1667 1
	s = splsoftclock();
@


1.4
log
@move around ioctl definitions
@
text
@d1 1
@


1.4.4.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@a0 1
/*	$OpenBSD: magma.c,v 1.7 2001/03/24 10:07:19 ho Exp $	*/
a1410 3

		timeout_set(&mp->mp_timeout_tmo, mbpp_timeout, mp);
		timeout_set(&mp->mp_start_tmo, mbpp_start, mp);
d1600 1
a1600 1
		timeout_add(&mp->mp_timeout_tmo, mp->mp_timeout);
d1644 1
a1644 1
			s = spltty();	/* XXX */
d1646 1
a1646 1
			timeout_add(&mp->mp_start_tmo, mp->mp_delay);
d1666 1
a1666 1
	s = spltty();	/* XXX */
d1668 1
a1668 1
		timeout_del(&mp->mp_timeout_tmo);
d1672 1
a1672 1
		timeout_del(&mp->mp_start_tmo);
@


1.4.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.4.4.1 2001/05/14 21:37:07 niklas Exp $	*/
d1594 2
@


1.4.4.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d98 1
a98 1
		"MAGMA_Sp", "MAGMA,4_Sp", "Magma 4 Sp", 4, 0,
d103 1
a103 1
		"MAGMA_Sp", "MAGMA,8_Sp", "Magma 8 Sp", 8, 0,
d108 1
a108 1
		"MAGMA_Sp", "MAGMA,_8HS_Sp", "Magma Fast 8 Sp", 8, 0,
d113 1
a113 1
		"MAGMA_Sp", "MAGMA,_8SP_422", "Magma 8 Sp - 422", 8, 0,
d118 1
a118 1
		"MAGMA_Sp", "MAGMA,12_Sp", "Magma 12 Sp", 12, 0,
d123 1
a123 1
		"MAGMA_Sp", "MAGMA,16_Sp", "Magma 16 Sp", 16, 0,
d128 1
a128 1
		"MAGMA_Sp", "MAGMA,16_Sp_2", "Magma 16 Sp", 16, 0,
d133 1
a133 1
		"MAGMA_Sp", "MAGMA,16HS_Sp", "Magma Fast 16 Sp", 16, 0,
d138 1
a138 1
		"MAGMA_Sp", "MAGMA,21_Sp", "Magma LC 2+1 Sp", 2, 1,
d143 1
a143 1
		"MAGMA_Sp", "MAGMA,21HS_Sp", "Magma 2+1 Sp", 2, 1,
d148 1
a148 1
		"MAGMA_Sp", "MAGMA,41_Sp", "Magma 4+1 Sp", 4, 1,
d153 1
a153 1
		"MAGMA_Sp", "MAGMA,82_Sp", "Magma 8+2 Sp", 8, 2,
d158 1
a158 1
		"MAGMA_Sp", "MAGMA,P1_Sp", "Magma P1 Sp", 0, 1,
d163 1
a163 1
		"MAGMA_Sp", "MAGMA,P2_Sp", "Magma P2 Sp", 0, 2,
d168 1
a168 6
		"MAGMA 2+1HS Sp", "", "Magma 2+1HS Sp", 2, 0,
		1, 0xa000, 0xc000, 0xe000, { 0x4000, 0, 0, 0 },
		1, { 0x8000, 0 }
	},
	{
		NULL, NULL, NULL, 0, 0,
d315 2
a316 2
	struct device *parent;
	void *vcf, *args;
d318 6
a323 11
	struct confargs *ca = args;
	struct romaux *ra = &ca->ca_ra;
	struct magma_board_info *card;

	for (card = supported_cards; ; card++) {
		if (card->mb_sbusname == NULL)
			/* End of table: no match */
			return (0);
		if (strcmp(ra->ra_name, card->mb_sbusname) == 0)
			break;
	}
d354 3
a356 3
struct magma_board_info *card;
char *magma_prom, *clockstr;
int chip, cd_clock;
d359 6
a364 7
	magma_prom = getpropstring(ra->ra_node, "magma_prom");
	for (card = supported_cards; card->mb_name != NULL; card++) {
		if (strcmp(ra->ra_name, card->mb_sbusname) != 0)
			continue;
		if (strcmp(magma_prom, card->mb_name) == 0)
			break;
	}
a370 12

	clockstr = getpropstring(ra->ra_node, "clock");
	if (strlen(clockstr) == 0)
		cd_clock = 0;
	else {
		cd_clock = 0;
		while (*clockstr != '\0')
			cd_clock = cd_clock * 10 + *clockstr++ - '0';
	}

	dprintf((" addr 0x%x", sc));
	printf(" pri %d softpri %d:", ra->ra_intr[0].int_pri, PIL_TTY);
d386 1
a386 1
		struct cd1400 *cd = &sc->ms_cd1400[chip];
d390 2
a391 1
		cd->cd_clock = cd_clock;
@


1.4.4.4
log
@Merge in -current from about a week ago
@
text
@d365 2
a366 2
char magma_prom[40], *clockstr;
int chip, cd_clock, len;
d369 1
a369 7

	len = getprop(ra->ra_node, "magma_prom",
	    magma_prom, sizeof(magma_prom) - 1);
	if (len == -1)
		len = 0;
	magma_prom[len] = '\0';

@


1.4.4.5
log
@Sync the SMP branch with 3.3
@
text
@d74 1
a74 1
#if IPL_TTY == 1
d76 1
a76 1
#elif IPL_TTY == 4
d78 1
a78 1
#elif IPL_TTY == 6
d399 1
a399 1
	printf(" pri %d softpri %d:", ra->ra_intr[0].int_pri, IPL_TTY);
d425 1
a425 1
		dprintf(("%s attach CD1400 %d addr 0x%x rev %x clock %dMHz\n", sc->ms_dev.dv_xname, chip, cd->cd_reg, cd->cd_chiprev, cd->cd_clock));
d468 1
a468 1
	intr_establish(ra->ra_intr[0].int_pri, &sc->ms_hardint, -1);
d472 1
a472 1
	intr_establish(IPL_TTY, &sc->ms_softint, IPL_TTY);
d689 1
a689 1
			raise(0, IPL_TTY);
@


1.4.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d848 2
d1113 1
a1113 1
		if( suser(p, 0) )
d1401 1
a1401 1
 *	mbpppoll	do poll on mbpp
d1592 1
a1592 1
 * poll routine
d1595 1
a1595 1
mbpppoll(dev, events, p)
d1597 1
a1597 1
int events;
d1600 1
a1600 1
	return(seltrue(dev, events, p));
@


1.3
log
@newer fixes from plunky@@skate.demon.co.uk
@
text
@d67 1
a67 1
#include "bppioctl.h"
@


1.2
log
@do not assume ttys or bpps exist; plunky@@skate.demon.co.uk
@
text
@d67 1
d474 2
a475 1
		struct mbpp_port *mbpp = &sc->ms_mbpp->ms_port[port];
d477 1
d479 13
d563 1
a563 6
			/* if we have anything to send, then send what we can.. otherwise
			 * shut off the interrupts and signal for a wakeup (can't be done
			 * at this spl because its sleeping in spltty() in mbppwrite
			 */

			if( mbpp->mp_txc ) {
d566 5
a570 4
				while( count++ < CD1400_PAR_FIFO_SIZE && mbpp->mp_txc ) {
					cd1400_write_reg(cd, CD1400_TDR, *mbpp->mp_txp);
					mbpp->mp_txc--;
					mbpp->mp_txp++;
d573 7
a579 7
			register int srer;

				srer = cd1400_read_reg(cd, CD1400_SRER);
				CLR(srer, CD1400_SRER_TXRDY);
				cd1400_write_reg(cd, CD1400_SRER, srer);

				SET(mbpp->mp_flags, MBPPF_DONE);
d690 4
a693 3
	if( mtty ) for( port = 0 ; port < mtty->ms_nports ; port++ ) {
	struct mtty_port *mp = &mtty->ms_port[port];
	struct tty *tp = mp->mp_tty;
d695 1
a695 1
		if( !ISSET(tp->t_state, TS_ISOPEN) ) continue;
d697 15
a711 15
		/*
		 * handle any received data
		 */
		while( mp->mp_rget != mp->mp_rput ) {
		u_char stat;
		int data;

			stat = mp->mp_rget[0];
			data = mp->mp_rget[1];
			mp->mp_rget = ((mp->mp_rget + 2) == mp->mp_rend) ? mp->mp_rbuf : (mp->mp_rget + 2);

			if( stat & (CD1400_RDSR_BREAK | CD1400_RDSR_FE) )
				data |= TTY_FE;
			if( stat & CD1400_RDSR_PE )
				data |= TTY_PE;
d713 2
a714 2
			if( stat & CD1400_RDSR_OE )
				log(LOG_WARNING, "%s%x: fifo overflow\n", mtty->ms_dev.dv_xname, port);
d716 3
a718 3
			(*linesw[tp->t_line].l_rint)(data, tp);
			serviced = 1;
		}
d720 10
a729 10
		s = splhigh();	/* block out hard interrupt routine */
		flags = mp->mp_flags;
		CLR(mp->mp_flags, MTTYF_DONE | MTTYF_CARRIER_CHANGED | MTTYF_RING_OVERFLOW);
		splx(s);	/* ok */

		if( ISSET(flags, MTTYF_CARRIER_CHANGED) ) {
			dprintf(("%s%x: cd %s\n", mtty->ms_dev.dv_xname, port, mp->mp_carrier ? "on" : "off"));
			(*linesw[tp->t_line].l_modem)(tp, mp->mp_carrier);
			serviced = 1;
		}
d731 4
a734 4
		if( ISSET(flags, MTTYF_RING_OVERFLOW) ) {
			log(LOG_WARNING, "%s%x: ring buffer overflow\n", mtty->ms_dev.dv_xname, port);
			serviced = 1;
		}
d736 8
a743 7
		if( ISSET(flags, MTTYF_DONE) ) {
			ndflush(&tp->t_outq, mp->mp_txp - tp->t_outq.c_cf);
			CLR(tp->t_state, TS_BUSY);
			(*linesw[tp->t_line].l_start)(tp);	/* might be some more */
			serviced = 1;
		}
	} /* for(each mtty...) */
d748 17
a764 16
	if( mbpp ) for( port = 0 ; port < mbpp->ms_nports ; port++ ) {
	struct mbpp_port *mp = &mbpp->ms_port[port];

		if( !ISSET(mp->mp_flags, MBPPF_OPEN) ) continue;

		s = splhigh();
		flags = mp->mp_flags;
		CLR(mp->mp_flags, MBPPF_DONE);
		splx(s);

		if( ISSET(flags, MBPPF_DONE) ) {
			wakeup(mp);
			serviced = 1;
		}

	} /* for(each mbpp...) */
d1373 5
d1399 1
a1399 1
int port = 0;
a1410 11

		mp->mp_txbuf = malloc(MBPP_TXBUF_SIZE, M_DEVBUF, M_NOWAIT);
		if( mp->mp_txbuf == NULL ) break;

		/*
		 * default strobe and timeout settings
		 */
		mp->mp_read_strobe = 1000;	/* 1 microsecond */
		mp->mp_read_timeout = 5 * hz;	/* 5 seconds */
		mp->mp_write_strobe = 1000;	/* 1 microsecond */
		mp->mp_write_timeout = 5 * hz;	/* 5 seconds */
d1431 1
a1431 1
int error = 0, s;
d1446 7
a1452 1
	if( mp->mp_cd1400 ) {	/* CD1400 chip */
a1458 1
		cd1400_write_reg(cd, CD1400_TBPR, (mp->mp_write_strobe * cd->cd_clock / 2000));
a1459 1
		cd1400_write_ccr(cd, CD1400_CCR_CMDCHANCTL | CD1400_CCR_XMTEN);
d1461 3
a1463 2
	} else {		/* CD1190 chip */
		error = ENXIO;
d1466 1
a1466 1
	return(error);
a1481 11
	if( mp->mp_cd1400 ) {
	struct cd1400 *cd = mp->mp_cd1400;
	int s;

		s = spltty();
		/* turn off the channel */
		cd1400_write_reg(cd, CD1400_CAR, 0);
		cd1400_write_ccr(cd, CD1400_CCR_CMDRESET);
		splx(s);
	}

a1482 1

d1495 1
a1495 1
	return(ENODEV);
d1507 1
a1507 27
struct mbpp_softc *ms = mbpp_cd.cd_devs[MAGMA_CARD(dev)];
register struct mbpp_port *mp = &ms->ms_port[MAGMA_PORT(dev)];
int error = 0;
int s;

	while( uio->uio_resid ) {
		mp->mp_txc = MIN(uio->uio_resid, MBPP_TXBUF_SIZE);
		mp->mp_txp = mp->mp_txbuf;

		error = uiomove((caddr_t)mp->mp_txp, mp->mp_txc, uio);
		if( error ) break;

		s = spltty();
		if( mp->mp_cd1400 )
			cd1400_enable_transmitter(mp->mp_cd1400, 0);
		error = tsleep(mp, PCATCH | PZERO, "mbppwrite", mp->mp_write_timeout);
		splx(s);

		if( error ) break;
	} /* while(more to send...) */

	if( error == EWOULDBLOCK ) {
		log(LOG_INFO, "%s%d: write timeout\n", ms->ms_dev.dv_xname, MAGMA_PORT(dev));
		/* XXX check paper out, printer offline etc.. */
	}

	return(error);
d1521 36
a1556 2
	/* we want to be able to get & set strobe and timeout values */
	return(ENODEV);
d1569 259
@


1.1
log
@magma serial driver; plunky@@skate.demon.co.uk
@
text
@d676 1
a676 1
	 * check the tty ports to see what needs doing
d678 1
a678 1
	for( port = 0 ; port < mtty->ms_nports ; port++ ) {
d732 1
a732 1
	 * check the bpp ports to see what needs doing
d734 1
a734 1
	for( port = 0 ; port < mbpp->ms_nports ; port++ ) {
@

