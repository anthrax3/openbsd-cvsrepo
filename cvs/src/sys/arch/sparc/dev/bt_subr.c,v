head	1.9;
access;
symbols
	OPENBSD_6_0:1.9.0.54
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.50
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.52
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.44
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.48
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.46
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.42
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.40
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.38
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.36
	OPENBSD_5_0:1.9.0.34
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.32
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.30
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.26
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.28
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.24
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.22
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.20
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.18
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.16
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.14
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.12
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.8
	UBC:1.6.0.2
	UBC_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.10
	OPENBSD_2_8:1.4.0.8
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.6
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.4
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2003.06.02.23.27.53;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.12.10.44.03;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2002.08.02.16.13.07;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.05.10.10.34.42;	author art;	state Exp;
branches;
next	1.4;

1.4
date	99.04.22.16.52.46;	author art;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	97.08.08.08.24.39;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.08.11.05.34.06;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.37;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.37;	author deraadt;	state Exp;
branches;
next	;

1.4.4.1
date	2001.07.04.10.23.21;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2003.06.07.11.14.42;	author ho;	state Exp;
branches;
next	;

1.6.2.1
date	2002.10.29.00.28.09;	author art;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@/*	$OpenBSD: bt_subr.c,v 1.8 2002/08/12 10:44:03 miod Exp $	*/
/*	$NetBSD: bt_subr.c,v 1.5 1996/03/14 19:44:32 christos Exp $ */

/*
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)bt_subr.c	8.2 (Berkeley) 1/21/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/errno.h>

#include <uvm/uvm_extern.h>

#include <dev/wscons/wsconsio.h>

#include <sparc/dev/btreg.h>
#include <sparc/dev/btvar.h>

/*
 * Common code for dealing with Brooktree video DACs.
 */

int
bt_getcmap(bcm, rcm)
	union bt_cmap *bcm;
	struct wsdisplay_cmap *rcm;
{
	u_int index = rcm->index, count = rcm->count, i;
	int error;

	if (index >= 256 || count > 256 - index)
		return (EINVAL);
	for (i = 0; i < count; i++) {
		if ((error = copyout(&bcm->cm_map[index + i][0],
		    &rcm->red[i], 1)) != 0)
			return (error);
		if ((error = copyout(&bcm->cm_map[index + i][1],
		    &rcm->green[i], 1)) != 0)
			return (error);
		if ((error = copyout(&bcm->cm_map[index + i][2],
		    &rcm->blue[i], 1)) != 0)
			return (error);
	}
	return (0);
}

int
bt_putcmap(bcm, rcm)
	union bt_cmap *bcm;
	struct wsdisplay_cmap *rcm;
{
	u_int index = rcm->index, count = rcm->count, i;
	int error;

	if (index >= 256 || count > 256 - index)
		return (EINVAL);
	for (i = 0; i < count; i++) {
		if ((error = copyin(&rcm->red[i],
		    &bcm->cm_map[index + i][0], 1)) != 0)
			return (error);
		if ((error = copyin(&rcm->green[i],
		    &bcm->cm_map[index + i][1], 1)) != 0)
			return (error);
		if ((error = copyin(&rcm->blue[i],
		    &bcm->cm_map[index + i][2], 1)) != 0)
			return (error);
	}
	return (0);
}

void
bt_loadcmap(cm, bt, start, ncolors, cgsix)
	union bt_cmap *cm;
	volatile struct bt_regs *bt;
	u_int start, ncolors;
	int cgsix;
{
	u_int *ip, i;
	int count;

	ip = &cm->cm_chip[BT_D4M3(start)];	/* start/4 * 3 */
	count = BT_D4M3(start + ncolors - 1) - BT_D4M3(start) + 3;

	if (cgsix) {
		/* hardware that makes one want to pound boards with hammers */
		bt->bt_addr = BT_D4M4(start) << 24;
		while (--count >= 0) {
			i = *ip++;
			bt->bt_cmap = i;
			bt->bt_cmap = i << 8;
			bt->bt_cmap = i << 16;
			bt->bt_cmap = i << 24;
		}
	} else {
		bt->bt_addr = BT_D4M4(start);
		while (--count >= 0)
			bt->bt_cmap = *ip++;
	}
}

void
bt_setcolor(cm, bt, index, r, g, b, cgsix)
	union bt_cmap *cm;
	volatile struct bt_regs *bt;
	u_int index;
	u_int8_t r, g, b;
	int cgsix;
{

	cm->cm_map[index][0] = r;
	cm->cm_map[index][1] = g;
	cm->cm_map[index][2] = b;
	bt_loadcmap(cm, bt, index, 1, cgsix);
}
@


1.8
log
@Convert sparc console code from rcons and pseudo-devices to rasops and wscons.
For most framebuffers it is faster.

Other changes include:
o 24 bit support in tcx(4) for the S24 framebuffer
o accelerated cgsix(4) text console
o new cgtwelve(4) driver for the GS framebuffer
o improved serial driver code
o better keyboard support

The following framebuffers have not been tested but should work: cgfour,
cgeight and cgfourteen

These changes will require XF4 changes, to use Xwsfb instead of Xsun*, to be
commited later today.

Most of the work by me during the LSM and the week after, with code borrowed
from jason@@, NetBSD (new serial code), and feedback from mickey@@. Work on
pnozz(4) done by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bt_subr.c,v 1.7 2002/08/02 16:13:07 millert Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@Do correct bounds checking in get/set/put cmap routines.  A few of
these check were already OK but have been modified for consistency.
Problem found by Silvio Cesare.
@
text
@d1 1
a1 1
/*	$OpenBSD: bt_subr.c,v 1.6 2001/11/06 19:53:16 miod Exp $	*/
d55 1
a55 1
#include <machine/fbio.h>
a61 2
 * (Contains some software-only code as well, since the colormap
 * ioctls are shared between the cgthree and cgsix drivers.)
a63 3
/*
 * Implement an FBIOGETCMAP-like ioctl.
 */
d65 3
a67 4
bt_getcmap(p, cm, cmsize)
	register struct fbcmap *p;
	union bt_cmap *cm;
	int cmsize;
d69 2
a70 2
	register u_int i, start, count;
	register u_char *cp;
d72 1
a72 3
	start = p->index;
	count = p->count;
	if (start >= cmsize || count > cmsize - start)
d74 10
a83 8
	if (!uvm_useracc(p->red, count, B_WRITE) ||
	    !uvm_useracc(p->green, count, B_WRITE) ||
	    !uvm_useracc(p->blue, count, B_WRITE))
		return (EFAULT);
	for (cp = &cm->cm_map[start][0], i = 0; i < count; cp += 3, i++) {
		p->red[i] = cp[0];
		p->green[i] = cp[1];
		p->blue[i] = cp[2];
a87 3
/*
 * Implement the software portion of an FBIOPUTCMAP-like ioctl.
 */
d89 3
a91 4
bt_putcmap(p, cm, cmsize)
	register struct fbcmap *p;
	union bt_cmap *cm;
	int cmsize;
d93 2
a94 2
	register u_int i, start, count;
	register u_char *cp;
d96 1
a96 3
	start = p->index;
	count = p->count;
	if (start >= cmsize || count > cmsize - start)
d98 10
a107 8
	if (!uvm_useracc(p->red, count, B_READ) ||
	    !uvm_useracc(p->green, count, B_READ) ||
	    !uvm_useracc(p->blue, count, B_READ))
		return (EFAULT);
	for (cp = &cm->cm_map[start][0], i = 0; i < count; cp += 3, i++) {
		cp[0] = p->red[i];
		cp[1] = p->green[i];
		cp[2] = p->blue[i];
d110 45
@


1.6
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: bt_subr.c,v 1.5 2001/05/10 10:34:42 art Exp $	*/
d80 1
a80 1
	if (start >= cmsize || start + count > cmsize)
d108 1
a108 1
	if (start >= cmsize || start + count > cmsize)
@


1.6.2.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bt_subr.c,v 1.6 2001/11/06 19:53:16 miod Exp $	*/
d55 1
a55 1
#include <dev/wscons/wsconsio.h>
d62 2
d66 3
d70 4
a73 3
bt_getcmap(bcm, rcm)
	union bt_cmap *bcm;
	struct wsdisplay_cmap *rcm;
d75 2
a76 2
	u_int index = rcm->index, count = rcm->count, i;
	int error;
d78 3
a80 1
	if (index >= 256 || count > 256 - index)
d82 8
a89 10
	for (i = 0; i < count; i++) {
		if ((error = copyout(&bcm->cm_map[index + i][0],
		    &rcm->red[i], 1)) != 0)
			return (error);
		if ((error = copyout(&bcm->cm_map[index + i][1],
		    &rcm->green[i], 1)) != 0)
			return (error);
		if ((error = copyout(&bcm->cm_map[index + i][2],
		    &rcm->blue[i], 1)) != 0)
			return (error);
d94 3
d98 4
a101 3
bt_putcmap(bcm, rcm)
	union bt_cmap *bcm;
	struct wsdisplay_cmap *rcm;
d103 2
a104 2
	u_int index = rcm->index, count = rcm->count, i;
	int error;
d106 3
a108 1
	if (index >= 256 || count > 256 - index)
d110 8
a117 10
	for (i = 0; i < count; i++) {
		if ((error = copyin(&rcm->red[i],
		    &bcm->cm_map[index + i][0], 1)) != 0)
			return (error);
		if ((error = copyin(&rcm->green[i],
		    &bcm->cm_map[index + i][1], 1)) != 0)
			return (error);
		if ((error = copyin(&rcm->blue[i],
		    &bcm->cm_map[index + i][2], 1)) != 0)
			return (error);
a119 45
}

void
bt_loadcmap(cm, bt, start, ncolors, cgsix)
	union bt_cmap *cm;
	volatile struct bt_regs *bt;
	u_int start, ncolors;
	int cgsix;
{
	u_int *ip, i;
	int count;

	ip = &cm->cm_chip[BT_D4M3(start)];	/* start/4 * 3 */
	count = BT_D4M3(start + ncolors - 1) - BT_D4M3(start) + 3;

	if (cgsix) {
		/* hardware that makes one want to pound boards with hammers */
		bt->bt_addr = BT_D4M4(start) << 24;
		while (--count >= 0) {
			i = *ip++;
			bt->bt_cmap = i;
			bt->bt_cmap = i << 8;
			bt->bt_cmap = i << 16;
			bt->bt_cmap = i << 24;
		}
	} else {
		bt->bt_addr = BT_D4M4(start);
		while (--count >= 0)
			bt->bt_cmap = *ip++;
	}
}

void
bt_setcolor(cm, bt, index, r, g, b, cgsix)
	union bt_cmap *cm;
	volatile struct bt_regs *bt;
	u_int index;
	u_int8_t r, g, b;
	int cgsix;
{

	cm->cm_map[index][0] = r;
	cm->cm_map[index][1] = g;
	cm->cm_map[index][2] = b;
	bt_loadcmap(cm, bt, index, 1, cgsix);
@


1.5
log
@UVM is no longer optional on sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: bt_subr.c,v 1.4 1999/04/22 16:52:46 art Exp $	*/
d53 1
a53 1
#include <vm/vm.h>
@


1.4
log
@UVM fixes, just a few useracc -> uvm_useracc
@
text
@d1 1
a1 1
/*	$OpenBSD: bt_subr.c,v 1.3 1997/08/08 08:24:39 downsj Exp $	*/
a81 1
#if defined(UVM)
a85 6
#else
	if (!useracc(p->red, count, B_WRITE) ||
	    !useracc(p->green, count, B_WRITE) ||
	    !useracc(p->blue, count, B_WRITE))
		return (EFAULT);
#endif
a109 1
#if defined(UVM)
a113 6
#else
	if (!useracc(p->red, count, B_READ) ||
	    !useracc(p->green, count, B_READ) ||
	    !useracc(p->blue, count, B_READ))
		return (EFAULT);
#endif
@


1.4.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: bt_subr.c,v 1.4 1999/04/22 16:52:46 art Exp $	*/
d82 1
d87 6
d117 1
d122 6
@


1.4.4.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 1
a53 1
#include <uvm/uvm_extern.h>
@


1.4.4.3
log
@Sync the SMP branch with 3.3
@
text
@d55 1
a55 1
#include <dev/wscons/wsconsio.h>
d62 2
d66 3
d70 4
a73 3
bt_getcmap(bcm, rcm)
	union bt_cmap *bcm;
	struct wsdisplay_cmap *rcm;
d75 2
a76 2
	u_int index = rcm->index, count = rcm->count, i;
	int error;
d78 3
a80 1
	if (index >= 256 || count > 256 - index)
d82 8
a89 10
	for (i = 0; i < count; i++) {
		if ((error = copyout(&bcm->cm_map[index + i][0],
		    &rcm->red[i], 1)) != 0)
			return (error);
		if ((error = copyout(&bcm->cm_map[index + i][1],
		    &rcm->green[i], 1)) != 0)
			return (error);
		if ((error = copyout(&bcm->cm_map[index + i][2],
		    &rcm->blue[i], 1)) != 0)
			return (error);
d94 3
d98 4
a101 3
bt_putcmap(bcm, rcm)
	union bt_cmap *bcm;
	struct wsdisplay_cmap *rcm;
d103 2
a104 2
	u_int index = rcm->index, count = rcm->count, i;
	int error;
d106 3
a108 1
	if (index >= 256 || count > 256 - index)
d110 8
a117 10
	for (i = 0; i < count; i++) {
		if ((error = copyin(&rcm->red[i],
		    &bcm->cm_map[index + i][0], 1)) != 0)
			return (error);
		if ((error = copyin(&rcm->green[i],
		    &bcm->cm_map[index + i][1], 1)) != 0)
			return (error);
		if ((error = copyin(&rcm->blue[i],
		    &bcm->cm_map[index + i][2], 1)) != 0)
			return (error);
a119 45
}

void
bt_loadcmap(cm, bt, start, ncolors, cgsix)
	union bt_cmap *cm;
	volatile struct bt_regs *bt;
	u_int start, ncolors;
	int cgsix;
{
	u_int *ip, i;
	int count;

	ip = &cm->cm_chip[BT_D4M3(start)];	/* start/4 * 3 */
	count = BT_D4M3(start + ncolors - 1) - BT_D4M3(start) + 3;

	if (cgsix) {
		/* hardware that makes one want to pound boards with hammers */
		bt->bt_addr = BT_D4M4(start) << 24;
		while (--count >= 0) {
			i = *ip++;
			bt->bt_cmap = i;
			bt->bt_cmap = i << 8;
			bt->bt_cmap = i << 16;
			bt->bt_cmap = i << 24;
		}
	} else {
		bt->bt_addr = BT_D4M4(start);
		while (--count >= 0)
			bt->bt_cmap = *ip++;
	}
}

void
bt_setcolor(cm, bt, index, r, g, b, cgsix)
	union bt_cmap *cm;
	volatile struct bt_regs *bt;
	u_int index;
	u_int8_t r, g, b;
	int cgsix;
{

	cm->cm_map[index][0] = r;
	cm->cm_map[index][1] = g;
	cm->cm_map[index][2] = b;
	bt_loadcmap(cm, bt, index, 1, cgsix);
@


1.4.4.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bt_subr.c,v 1.4.4.3 2003/03/27 23:49:25 niklas Exp $	*/
d25 5
a29 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.3
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d82 6
d92 1
d117 6
d127 1
@


1.2
log
@netbsd port, now we merge our changes back in
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: bt_subr.c,v 1.4 1994/11/20 20:51:54 deraadt Exp $ */
d48 1
d51 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
