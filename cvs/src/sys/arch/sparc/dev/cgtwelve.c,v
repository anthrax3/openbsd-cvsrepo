head	1.20;
access;
symbols
	OPENBSD_6_0:1.20.0.6
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.18
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.16
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.14
	OPENBSD_5_0:1.17.0.12
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.10
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.8
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.4
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.6
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.2
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.16.0.6
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.7
	SMP:1.5.0.4
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	UBC:1.4.0.4
	UBC_SYNC_B:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4;
locks; strict;
comment	@ * @;


1.20
date	2015.03.28.19.07.07;	author miod;	state Exp;
branches;
next	1.19;
commitid	nwbHy4sQv9NnJnmZ;

1.19
date	2013.10.20.20.07.25;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2013.05.31.22.07.49;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2008.12.26.22.30.21;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.13.19.40.48;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.02.20.00.54;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.23.17.16.34;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.13.23.05.22;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.07.16.44.50;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.03.09.49.05;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.29.22.07.36;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.28.17.05.33;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.06.19.42.47;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.12.20.18.39;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.06.17.02.32;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2002.11.06.21.06.20;	author miod;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2002.09.23.18.13.38;	author miod;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2002.09.20.11.17.56;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.09.22.15.16;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2002.08.12.10.44.03;	author miod;	state Exp;
branches;
next	;

1.4.4.1
date	2002.10.29.00.28.09;	author art;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;

1.5.4.1
date	2003.05.13.19.41.08;	author ho;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2003.05.16.00.29.40;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2003.06.07.11.14.42;	author ho;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2004.02.19.10.49.57;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Don't include sbusvar.h if you need neither sbus_translate() nor sbus_testdma().
@
text
@/*	$OpenBSD: cgtwelve.c,v 1.19 2013/10/20 20:07:25 miod Exp $	*/

/*
 * Copyright (c) 2002, 2003 Miodrag Vallat.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * cgtwelve (GS) accelerated 24-bit framebuffer driver.
 *
 * Enough experiments and SMI's cg12reg.h made this possible.
 */

/*
 * The cgtwelve framebuffer is a 3-slot SBUS card, that will fit only in
 * SPARCstation 1, 1+, 2 and 5, or in an xbox SBUS extension.
 *
 * It is a 24-bit 3D accelerated framebuffer made by Matrox, featuring 4MB
 * (regular model) or 8MB (high-res model) of video memory, a complex
 * windowing engine, double buffering modes, three video planes (overlay,
 * 8 bit and 24 bit color), and a lot of colormap combinations.
 *
 * All of this is driven by a set of three Bt462 ramdacs (latched unless
 * explicitely programmed), and a couple of other Matrox-specific chips.
 *
 * XXX The high res card is untested.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/mman.h>
#include <sys/tty.h>
#include <sys/conf.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/pmap.h>
#include <machine/cpu.h>
#include <machine/conf.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

#include <sparc/dev/cgtwelvereg.h>

#include <dev/cons.h>	/* for prom console hook */

/* per-display variables */
struct cgtwelve_softc {
	struct	sunfb	sc_sunfb;	/* common base device */
	struct	rom_reg sc_phys;

	volatile struct cgtwelve_dpu *sc_dpu;
	volatile struct cgtwelve_apu *sc_apu;
	volatile struct cgtwelve_dac *sc_ramdac;	/* RAMDAC registers */
	volatile u_char *sc_overlay;	/* overlay or enable plane */
	volatile u_long *sc_inten;	/* true color plane */

	int	sc_highres;
	int	sc_isconsole;
};

int	cgtwelve_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	cgtwelve_mmap(void *, off_t, int);
void	cgtwelve_prom(struct cgtwelve_softc *);
static __inline__
void	cgtwelve_ramdac_wraddr(struct cgtwelve_softc *, u_int32_t);
void	cgtwelve_reset(struct cgtwelve_softc *, int);

struct wsdisplay_accessops cgtwelve_accessops = {
	.ioctl = cgtwelve_ioctl,
	.mmap = cgtwelve_mmap
};

int	cgtwelvematch(struct device *, void *, void *);
void	cgtwelveattach(struct device *, struct device *, void *);
int	cgtwelveactivate(struct device *, int);

struct cfattach cgtwelve_ca = {
	sizeof(struct cgtwelve_softc), cgtwelvematch, cgtwelveattach,
	NULL, cgtwelveactivate
};

struct cfdriver cgtwelve_cd = {
	NULL, "cgtwelve", DV_DULL
};


int
cgtwelvematch(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

	if (strcmp(cf->cf_driver->cd_name, ra->ra_name) != 0)
		return (0);

	return (1);
}

void
cgtwelveattach(struct device *parent, struct device *self, void *args)
{
	struct cgtwelve_softc *sc = (struct cgtwelve_softc *)self;
	struct confargs *ca = args;
	int node;
	char *ps;

	node = ca->ca_ra.ra_node;

	printf(": %s", getpropstring(node, "model"));
	ps = getpropstring(node, "dev_id");
	if (*ps != '\0')
		printf(" (%s)", ps);
	printf("\n");

	sc->sc_isconsole = node == fbnode;

	sc->sc_phys = ca->ca_ra.ra_reg[0];

	/*
	 * Map registers
	 */
	sc->sc_dpu = (struct cgtwelve_dpu *)mapiodev(ca->ca_ra.ra_reg,
	    CG12_OFF_DPU, sizeof(struct cgtwelve_dpu));
	sc->sc_apu = (struct cgtwelve_apu *)mapiodev(ca->ca_ra.ra_reg,
	    CG12_OFF_APU, sizeof(struct cgtwelve_apu));
	sc->sc_ramdac = (struct cgtwelve_dac *)mapiodev(ca->ca_ra.ra_reg,
	    CG12_OFF_DAC, sizeof(struct cgtwelve_dac));

	/*
	 * The console is using the 1-bit overlay plane, while the prom
	 * will correctly report 32 bit depth.
	 */
	fb_setsize(&sc->sc_sunfb, 1, CG12_WIDTH, CG12_HEIGHT,
	    node, ca->ca_bustype);
	sc->sc_sunfb.sf_depth = 1;
	sc->sc_sunfb.sf_linebytes = sc->sc_sunfb.sf_width / 8;
	sc->sc_sunfb.sf_fbsize = sc->sc_sunfb.sf_height *
	    sc->sc_sunfb.sf_linebytes;

	sc->sc_highres = sc->sc_sunfb.sf_width == CG12_WIDTH_HR;

	/*
	 * Map planes
	 */
	sc->sc_overlay = mapiodev(ca->ca_ra.ra_reg,
	    sc->sc_highres ? CG12_OFF_OVERLAY0_HR : CG12_OFF_OVERLAY0,
	    round_page(sc->sc_highres ? CG12_SIZE_OVERLAY_HR :
	        CG12_SIZE_OVERLAY));
	sc->sc_inten = mapiodev(ca->ca_ra.ra_reg,
	    sc->sc_highres ? CG12_OFF_INTEN_HR : CG12_OFF_INTEN,
	    round_page(sc->sc_highres ? CG12_SIZE_COLOR24_HR :
	        CG12_SIZE_COLOR24));

	/* reset cursor & frame buffer controls */
	sc->sc_sunfb.sf_depth = 0;	/* force action */
	cgtwelve_reset(sc, 1);

	sc->sc_sunfb.sf_ro.ri_bits = (void *)sc->sc_overlay;
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, sc->sc_isconsole);

	if (sc->sc_isconsole)
		fbwscons_console_init(&sc->sc_sunfb, -1);

	printf("%s: %dx%d", self->dv_xname,
	    sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);
	ps = getpropstring(node, "ucoderev");
	if (*ps != '\0')
		printf(", microcode rev. %s", ps);
	printf("\n");

	fbwscons_attach(&sc->sc_sunfb, &cgtwelve_accessops, sc->sc_isconsole);
}

int
cgtwelveactivate(struct device *self, int act)
{
	struct cgtwelve_softc *sc = (struct cgtwelve_softc *)self;
	int ret = 0;

	switch (act) {
	case DVACT_POWERDOWN:
		if (sc->sc_isconsole)
			cgtwelve_prom(sc);
		break;
	}

	return (ret); 
}

int
cgtwelve_ioctl(void *dev, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct cgtwelve_softc *sc = dev;
	struct wsdisplay_fbinfo *wdf;

	/*
	 * Note that, although the emulation (text) mode is running in the
	 * overlay plane, we advertize the frame buffer as the full-blown
	 * 32-bit beast it is.
	 */
	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG12;
		break;
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width = sc->sc_sunfb.sf_width;
		wdf->depth = 32;
		wdf->cmsize = 0;
		break;
	case WSDISPLAYIO_GETSUPPORTEDDEPTH:
		*(u_int *)data = WSDISPLAYIO_DEPTH_24_32;
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes * 32;
		break;

	case WSDISPLAYIO_GETCMAP:
	case WSDISPLAYIO_PUTCMAP:
		break;

	case WSDISPLAYIO_SMODE:
		if (*(int *)data == WSDISPLAYIO_MODE_EMUL) {
			/* Back from X11 to text mode */
			cgtwelve_reset(sc, 1);
		} else {
			/* Starting X11, switch to 32 bit mode */
			cgtwelve_reset(sc, 32);
		}
		break;

	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
		break;

	default:
		return (-1);	/* not supported yet */
	}

	return (0);
}

void
cgtwelve_reset(struct cgtwelve_softc *sc, int depth)
{
	u_int32_t c;

	if (sc->sc_sunfb.sf_depth != depth) {
		if (depth == 1) {
			/*
			 * Select the enable plane as sc_overlay, and fill it.
			 */
			sc->sc_apu->hpage = sc->sc_highres ?
			    CG12_HPAGE_ENABLE_HR : CG12_HPAGE_ENABLE;
			sc->sc_apu->haccess = CG12_HACCESS_ENABLE;
			sc->sc_dpu->pln_sl_host = CG12_PLN_SL_ENABLE;
			sc->sc_dpu->pln_rd_msk_host = CG12_PLN_RD_ENABLE;
			sc->sc_dpu->pln_wr_msk_host = CG12_PLN_WR_ENABLE;

			memset((void *)sc->sc_overlay, 0xff, sc->sc_highres ?
			    CG12_SIZE_ENABLE_HR : CG12_SIZE_ENABLE);

			/*
			 * Select the overlay plane as sc_overlay.
			 */
			sc->sc_apu->hpage = sc->sc_highres ?
			    CG12_HPAGE_OVERLAY_HR : CG12_HPAGE_OVERLAY;
			sc->sc_apu->haccess = CG12_HACCESS_OVERLAY;
			sc->sc_dpu->pln_sl_host = CG12_PLN_SL_OVERLAY;
			sc->sc_dpu->pln_rd_msk_host = CG12_PLN_RD_OVERLAY;
			sc->sc_dpu->pln_wr_msk_host = CG12_PLN_WR_OVERLAY;

			/*
			 * Upload a strict mono colormap, or the text
			 * upon returning from 32 bit mode would appear
			 * as (slightly dark) white on white.
			 */
			cgtwelve_ramdac_wraddr(sc, 0);
			sc->sc_ramdac->color = 0x00000000;
			for (c = 1; c < 256; c++)
				sc->sc_ramdac->color = 0x00ffffff;
		} else {
			/*
			 * Select the overlay plane as sc_overlay.
			 */
			sc->sc_apu->hpage = sc->sc_highres ?
			    CG12_HPAGE_OVERLAY_HR : CG12_HPAGE_OVERLAY;
			sc->sc_apu->haccess = CG12_HACCESS_OVERLAY;
			sc->sc_dpu->pln_sl_host = CG12_PLN_SL_OVERLAY;
			sc->sc_dpu->pln_rd_msk_host = CG12_PLN_RD_OVERLAY;
			sc->sc_dpu->pln_wr_msk_host = CG12_PLN_WR_OVERLAY;

			/*
			 * Do not attempt to somewhat preserve screen
			 * contents - reading the overlay plane and writing
			 * to the color plane at the same time is not
			 * reliable, and allocating memory to save a copy
			 * of the overlay plane would be awful.
			 */
			bzero((void *)sc->sc_overlay, sc->sc_highres ?
			    CG12_SIZE_OVERLAY_HR : CG12_SIZE_OVERLAY);

			/*
			 * Select the enable plane as sc_overlay, and clear it.
			 */
			sc->sc_apu->hpage = sc->sc_highres ?
			    CG12_HPAGE_ENABLE_HR : CG12_HPAGE_ENABLE;
			sc->sc_apu->haccess = CG12_HACCESS_ENABLE;
			sc->sc_dpu->pln_sl_host = CG12_PLN_SL_ENABLE;
			sc->sc_dpu->pln_rd_msk_host = CG12_PLN_RD_ENABLE;
			sc->sc_dpu->pln_wr_msk_host = CG12_PLN_WR_ENABLE;

			bzero((void *)sc->sc_overlay, sc->sc_highres ?
			    CG12_SIZE_ENABLE_HR : CG12_SIZE_ENABLE);

			/*
			 * Select the intensity (color) plane, and clear it.
			 */
			sc->sc_apu->hpage = sc->sc_highres ?
			    CG12_HPAGE_24BIT_HR : CG12_HPAGE_24BIT;
			sc->sc_apu->haccess = CG12_HACCESS_24BIT;
			sc->sc_dpu->pln_sl_host = CG12_PLN_SL_24BIT;
			sc->sc_dpu->pln_rd_msk_host = CG12_PLN_RD_24BIT;
			sc->sc_dpu->pln_wr_msk_host = CG12_PLN_WR_24BIT;

			memset((void *)sc->sc_inten, 0x00ffffff,
			    sc->sc_highres ?
			      CG12_SIZE_COLOR24_HR : CG12_SIZE_COLOR24);

			/*
			 * Use a direct colormap (ramp)
			 */
			cgtwelve_ramdac_wraddr(sc, 0);
			for (c = 0; c < 256; c++)
				sc->sc_ramdac->color = c | (c << 8) | (c << 16);
		}
	}

	sc->sc_sunfb.sf_depth = depth;
}

paddr_t
cgtwelve_mmap(void *v, off_t offset, int prot)
{
	struct cgtwelve_softc *sc = v;

	if (offset & PGOFSET || offset < 0)
		return (-1);

	/*
	 * Note that mmap() will invoke this function only if we are NOT
	 * in emulation mode, so we can assume 32 bit mode safely here.
	 */
	if (offset < sc->sc_sunfb.sf_fbsize * 32) {
		return (REG2PHYS(&sc->sc_phys,
		    (sc->sc_highres ? CG12_OFF_INTEN_HR :
		    CG12_OFF_INTEN) + offset) | PMAP_NC);
	}

	return (-1);
}

/*
 * Simple Bt462 programming routines.
 */

static __inline__ void 
cgtwelve_ramdac_wraddr(struct cgtwelve_softc *sc, u_int32_t addr)
{
	sc->sc_ramdac->addr_lo = (addr & 0xff);
	sc->sc_ramdac->addr_hi = ((addr >> 8) & 0xff);
}

/*
 * Shutdown hook used to restore PROM-compatible video mode on shutdown,
 * so that the PROM prompt is visible again.
 */
void
cgtwelve_prom(struct cgtwelve_softc *sc)
{
	extern struct consdev consdev_prom;

	if (sc->sc_sunfb.sf_depth != 1) {
		cgtwelve_reset(sc, 1);

		/*
		 * Go back to prom output for the last few messages, so they
		 * will be displayed correctly.
		 */
		cn_tab = &consdev_prom;
	}
}
@


1.19
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwelve.c,v 1.18 2013/05/31 22:07:49 deraadt Exp $	*/
a71 1
#include <sparc/dev/sbusvar.h>
@


1.18
log
@Replace shutdownhooks with activate functions, properly doing those
operations only if device is console
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwelve.c,v 1.17 2008/12/26 22:30:21 miod Exp $	*/
d99 2
a100 10
	cgtwelve_ioctl,
	cgtwelve_mmap,
	NULL,	/* alloc_screen */
	NULL,	/* free_screen */
	NULL,	/* show_screen */
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	NULL,	/* burner */
	NULL	/* pollc */
@


1.17
log
@Move the logic responsible from deciding whether a frame buffer needs to be
cleared on attach, from the individual drivers to the common frame buffer code;
the latter will decide based on the prom font metrics and the prom console
window position, whenever possible.

This removes the need for the console window position to be hardcoded in
the p9100 driver, and will no longer require a screen clear on a vigra
VS-12 in high resolution mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwelve.c,v 1.16 2007/03/13 19:40:48 miod Exp $	*/
d88 1
d93 1
a93 1
void	cgtwelve_prom(void *);
d113 1
d116 2
a117 1
	sizeof(struct cgtwelve_softc), cgtwelvematch, cgtwelveattach
a143 1
	int isconsole = 0;
d154 1
a154 1
	isconsole = node == fbnode;
d199 1
a199 1
	fbwscons_init(&sc->sc_sunfb, isconsole);
d201 1
a201 1
	if (isconsole) {
a202 2
		shutdownhook_establish(cgtwelve_prom, sc);
	}
d211 17
a227 1
	fbwscons_attach(&sc->sc_sunfb, &cgtwelve_accessops, isconsole);
d420 1
a420 2
cgtwelve_prom(v)
	void *v;
a421 1
	struct cgtwelve_softc *sc = v;
@


1.16
log
@When about to run X11 in 32 bpp mode, advertize correctly that we are
really using 24 bpp pixels on 32 bit boundaries.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwelve.c,v 1.15 2006/06/02 20:00:54 miod Exp $	*/
d197 1
a197 1
	fbwscons_init(&sc->sc_sunfb, isconsole ? 0 : RI_CLEAR);
@


1.15
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwelve.c,v 1.14 2005/03/23 17:16:34 miod Exp $	*/
d235 3
@


1.14
log
@Move the alloc_screen, free_screen and show_screen wsdisplay accessops to
the common frame buffer code, rather than duplicating it in every driver.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwelve.c,v 1.13 2005/03/13 23:05:22 miod Exp $	*/
a78 1
	struct	sbusdev sc_sd;		/* sbus device */
a202 2

	sbus_establish(&sc->sc_sd, &sc->sc_sunfb.sf_dev);
@


1.13
log
@Add missed WSDISPLAYIO_[GS]VIDEO ioctl handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwelve.c,v 1.12 2005/03/07 16:44:50 miod Exp $	*/
a67 1
#include <dev/wscons/wscons_raster.h>
a88 1
	int	sc_nscreens;
d91 6
a96 12
int cgtwelve_ioctl(void *, u_long, caddr_t, int, struct proc *);
int cgtwelve_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgtwelve_free_screen(void *, void *);
int cgtwelve_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t cgtwelve_mmap(void *, off_t, int);
void cgtwelve_reset(struct cgtwelve_softc *, int);
void cgtwelve_prom(void *);

static __inline__ void cgtwelve_ramdac_wraddr(struct cgtwelve_softc *sc,
    u_int32_t addr);
d101 3
a103 3
	cgtwelve_alloc_screen,
	cgtwelve_free_screen,
	cgtwelve_show_screen,
d108 1
d111 2
a112 2
int cgtwelvematch(struct device *, void *, void *);
void cgtwelveattach(struct device *, struct device *, void *);
a122 3
/*
 * Match a cgtwelve.
 */
d124 1
a124 3
cgtwelvematch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
a135 3
/*
 * Attach a display.
 */
d137 1
a137 3
cgtwelveattach(parent, self, args)
	struct device *parent, *self;
	void *args;
d218 1
a218 6
cgtwelve_ioctl(dev, cmd, data, flags, p)
	void *dev;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
a267 3
/*
 * Clean up hardware state (e.g., after bootup or after X crashes).
 */
d269 1
a269 3
cgtwelve_reset(sc, depth)
	struct cgtwelve_softc *sc;
	int depth;
a366 4
/*
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
 */
d368 1
a368 4
cgtwelve_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
d385 1
a385 44
	return (-1);	/* not a user-map offset */
}

int
cgtwelve_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
{
	struct cgtwelve_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	     0, 0, 0, attrp);
	sc->sc_nscreens++;
	return (0);
}

void
cgtwelve_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct cgtwelve_softc *sc = v;

	sc->sc_nscreens--;
}

int
cgtwelve_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
	return (0);
@


1.12
log
@Do not bother passing the blanking routine to fbwscons_console_init(),
as fbwscons_attach() can find it on its own.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwelve.c,v 1.11 2005/03/03 09:49:05 miod Exp $	*/
d277 4
@


1.11
log
@Sync a few comments with reality.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwelve.c,v 1.10 2004/11/29 22:07:36 miod Exp $	*/
d218 1
a218 1
		fbwscons_console_init(&sc->sc_sunfb, -1, NULL);
@


1.10
log
@Move the struct wsscreen_descr from a per-driver global to a per-instance
field of the sunfb structure. This allows multiple instances of the same driver,
but with different resolutions (such as a couple of vigra or a TGX cgsix and
a TGX+ cgsix) to use distinct wsscreen_descr structures featuring different
resolution information.

Doing this allows more wsscreen_descr fiddling inside the sparc* fb api,
and results in some code shrinkage (about 4KB on sparc GENERIC).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwelve.c,v 1.9 2003/06/28 17:05:33 miod Exp $	*/
d36 1
a36 1
 * SPARCstation 1, 1+, 2 and 5, or in an xbox SBUS extension (untested).
@


1.9
log
@Sync sparc fb API with the sparc64 changes (fbwscons_init takes flags, and
the sunfb structure keeps pointer to the prom cursor coordinates).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwelve.c,v 1.8 2003/06/06 19:42:47 miod Exp $	*/
a92 13
struct wsscreen_descr cgtwelve_stdscreen = {
	"std",
};

const struct wsscreen_descr *cgtwelve_scrlist[] = {
	&cgtwelve_stdscreen,
};

struct wsscreen_list cgtwelve_screenlist = {
	sizeof(cgtwelve_scrlist) / sizeof(struct wsscreen_descr *),
	    cgtwelve_scrlist
};

a157 1
	struct wsemuldisplaydev_attach_args waa;
a216 5
	cgtwelve_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgtwelve_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgtwelve_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgtwelve_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

d218 1
a218 2
		fbwscons_console_init(&sc->sc_sunfb,
		    &cgtwelve_stdscreen, -1, NULL);
d231 1
a231 5
	waa.console = isconsole;
	waa.scrdata = &cgtwelve_screenlist;
	waa.accessops = &cgtwelve_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
@


1.8
log
@Do not bother taking care of the frame buffer flags in the softc, if the
driver does not use any. Basically this changes all drivers but those that
can handle a P4 card.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwelve.c,v 1.7 2003/05/12 20:18:39 jason Exp $	*/
d229 1
a229 1
	fbwscons_init(&sc->sc_sunfb, isconsole);
@


1.7
log
@use new display types; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwelve.c,v 1.6 2003/04/06 17:02:32 miod Exp $	*/
a175 1
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags & FB_USERMASK;
@


1.6
log
@Run the console in the overlay plane, or in low-depth mode, as appropriate,
and do not switch to high-depth mode until the appropriate ioctls are
issued. This lets us benefit from true color X11, with a faster text console.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwelve.c,v 1.5 2002/11/06 21:06:20 miod Exp $	*/
d277 1
a277 1
		*(u_int *)data = WSDISPLAY_TYPE_SUN24;
@


1.5
log
@- always initialize colormaps, even if the frame buffer is non console; this
  helps if the ramdac does not get initialized (idea from jason@@)
- only register a shutdown hook for the frame buffers which need it, if this
  is the console frame buffer. Otherwise this is just a waste of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwelve.c,v 1.4 2002/09/23 18:13:38 miod Exp $	*/
d4 1
a4 1
 * Copyright (c) 2002 Miodrag Vallat.  All rights reserved.
d39 3
a41 3
 * (regular model) or 8MB (high-res model) of video memory, a complex windowing
 * engine, double buffering modes, three video planes (overlay, 8 bit and 24 bit
 * color), and a lot of colormap combinations.
d43 2
a44 2
 * All of this is driven by a set of three Bt462 ramdacs, and a couple of
 * Matrox-specific chips.
d113 1
a113 2
void cgtwelve_reset(struct cgtwelve_softc *);
void cgtwelve_burner(void *, u_int, u_int);
a117 2
void cgtwelve_initcmap(struct cgtwelve_softc *);
void cgtwelve_darkcmap(struct cgtwelve_softc *);
d128 1
a128 1
	cgtwelve_burner
d155 1
a155 1
	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
d158 1
a158 4
	if (ca->ca_bustype == BUS_SBUS)
		return (1);

	return (0);
d172 1
a172 1
	int fb_depth, node;
d200 2
a201 1
	 * Compute framebuffer size
d203 1
a203 6
	if (ISSET(sc->sc_sunfb.sf_flags, FB_FORCELOW))
		fb_depth = 1;
	else
		fb_depth = 32;

	fb_setsize(&sc->sc_sunfb, fb_depth, CG12_WIDTH, CG12_HEIGHT,
d205 4
a208 8

	if (fb_depth == 1 && sc->sc_sunfb.sf_depth == 32) {
		/* the prom will report depth == 32, so compensate */
		sc->sc_sunfb.sf_depth = 1;
		sc->sc_sunfb.sf_linebytes = sc->sc_sunfb.sf_width / 8;
		sc->sc_sunfb.sf_fbsize = sc->sc_sunfb.sf_height *
		    sc->sc_sunfb.sf_linebytes;
	}
d219 4
a222 5
	if (sc->sc_sunfb.sf_depth != 1)
		sc->sc_inten = mapiodev(ca->ca_ra.ra_reg,
		    sc->sc_highres ? CG12_OFF_INTEN_HR : CG12_OFF_INTEN,
		    round_page(sc->sc_highres ? CG12_SIZE_COLOR24_HR :
		        CG12_SIZE_COLOR24));
d225 2
a226 11
	cgtwelve_reset(sc);

	if (sc->sc_sunfb.sf_depth != 1) {
		/* enable video */
		cgtwelve_burner(sc, 1, 0);
	}

	if (sc->sc_sunfb.sf_depth == 1)
		sc->sc_sunfb.sf_ro.ri_bits = (void *)sc->sc_overlay;
	else 
		sc->sc_sunfb.sf_ro.ri_bits = (void *)sc->sc_inten;
d228 1
d238 2
a239 11
		if (sc->sc_sunfb.sf_depth == 1) {
			fbwscons_console_init(&sc->sc_sunfb,
			    &cgtwelve_stdscreen, -1, NULL);
		} else {
			/*
			 * Since the screen has been cleared, restart at the
			 * top of the screen.
			 */
			fbwscons_console_init(&sc->sc_sunfb,
			    &cgtwelve_stdscreen, 0, cgtwelve_burner);
		}
d270 5
d277 1
a277 4
		if (sc->sc_sunfb.sf_depth == 1)
			*(u_int *)data = WSDISPLAY_TYPE_SUNBW;
		else
			*(u_int *)data = WSDISPLAY_TYPE_SUN24;
d283 1
a283 1
		wdf->depth = sc->sc_sunfb.sf_depth;
d287 1
a287 1
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
d294 10
a303 7
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
d315 1
a315 1
cgtwelve_reset(sc)
d317 1
d319 1
a319 2
	if (sc->sc_sunfb.sf_depth == 1)
		return;
d321 44
a364 9
	/*
	 * Select the overlay plane as sc_overlay.
	 */
	sc->sc_apu->hpage =
	    sc->sc_highres ? CG12_HPAGE_OVERLAY_HR : CG12_HPAGE_OVERLAY;
	sc->sc_apu->haccess = CG12_HACCESS_OVERLAY;
	sc->sc_dpu->pln_sl_host = CG12_PLN_SL_OVERLAY;
	sc->sc_dpu->pln_rd_msk_host = CG12_PLN_RD_OVERLAY;
	sc->sc_dpu->pln_wr_msk_host = CG12_PLN_WR_OVERLAY;
d366 9
a374 8
	/*
	 * Do not attempt to somewhat preserve screen contents - reading the
	 * overlay plane and writing to the color plane at the same time is not
	 * reliable, and allocating memory to save a copy of the overlay plane
	 * would be awful.
	 */
	bzero((void *)sc->sc_overlay,
	    sc->sc_highres ? CG12_SIZE_OVERLAY_HR : CG12_SIZE_OVERLAY);
d376 9
a384 9
	/*
	 * Select the enable plane as sc_overlay, and clear it.
	 */
	sc->sc_apu->hpage =
	    sc->sc_highres ? CG12_HPAGE_ENABLE_HR : CG12_HPAGE_ENABLE;
	sc->sc_apu->haccess = CG12_HACCESS_ENABLE;
	sc->sc_dpu->pln_sl_host = CG12_PLN_SL_ENABLE;
	sc->sc_dpu->pln_rd_msk_host = CG12_PLN_RD_ENABLE;
	sc->sc_dpu->pln_wr_msk_host = CG12_PLN_WR_ENABLE;
d386 2
a387 2
	bzero((void *)sc->sc_overlay,
	    sc->sc_highres ? CG12_SIZE_ENABLE_HR : CG12_SIZE_ENABLE);
d389 13
a401 9
	/*
	 * Select the intensity (color) plane, and clear it.
	 */
	sc->sc_apu->hpage =
	    sc->sc_highres ? CG12_HPAGE_24BIT_HR : CG12_HPAGE_24BIT;
	sc->sc_apu->haccess = CG12_HACCESS_24BIT;
	sc->sc_dpu->pln_sl_host = CG12_PLN_SL_24BIT;
	sc->sc_dpu->pln_rd_msk_host = CG12_PLN_RD_24BIT;
	sc->sc_dpu->pln_wr_msk_host = CG12_PLN_WR_24BIT;
d403 8
a410 2
	memset((void *)sc->sc_inten, 0x00ffffff,
	    sc->sc_highres ? CG12_SIZE_COLOR24_HR : CG12_SIZE_COLOR24);
d412 1
a412 1
	shutdownhook_establish(cgtwelve_prom, sc);
d427 1
a427 1
	if (offset & PGOFSET)
d430 8
a437 11
	/* Allow mapping as a dumb framebuffer from offset 0 */
	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		if (sc->sc_sunfb.sf_depth == 1) {
			return (REG2PHYS(&sc->sc_phys,
			    (sc->sc_highres ? CG12_OFF_OVERLAY0_HR :
			    CG12_OFF_OVERLAY0) + offset) | PMAP_NC);
		} else {
			return (REG2PHYS(&sc->sc_phys,
			    (sc->sc_highres ? CG12_OFF_INTEN_HR :
			    CG12_OFF_INTEN) + offset) | PMAP_NC);
		}
a496 44
void
cgtwelve_initcmap(sc)
	struct cgtwelve_softc *sc;
{
	u_int32_t c;

	/*
	 * Since we are using the framebuffer in true color mode, there is
	 * theoretically no ramdac initialisation to do.
	 * In practice, we have to load a ramp on each ramdac first.
	 * Fortunately they are latched on each other at this point, so by
	 * loading one single ramp, all of them get initialized.
	 */
	cgtwelve_ramdac_wraddr(sc, 0);
	for (c = 0; c < 256; c++)
		sc->sc_ramdac->color = c | (c << 8) | (c << 16);
}

void
cgtwelve_darkcmap(sc)
	struct cgtwelve_softc *sc;
{
	u_int32_t c;

	cgtwelve_ramdac_wraddr(sc, 0);
	for (c = 0; c < 256; c++)
		sc->sc_ramdac->color = 0;
}

void cgtwelve_burner(v, on, flags)
	void *v;
	u_int on, flags;
{
	struct cgtwelve_softc *sc = v;

	if (sc->sc_sunfb.sf_depth == 1)
		return;

	if (on)
		cgtwelve_initcmap(sc);
	else
		cgtwelve_darkcmap(sc);
}

a505 1
	int c;
d508 2
a509 9
	/*
	 * Select the overlay plane.
	 */
	sc->sc_apu->hpage =
	    sc->sc_highres ? CG12_HPAGE_OVERLAY_HR : CG12_HPAGE_OVERLAY;
	sc->sc_apu->haccess = CG12_HACCESS_OVERLAY;
	sc->sc_dpu->pln_sl_host = CG12_PLN_SL_OVERLAY;
	sc->sc_dpu->pln_rd_msk_host = CG12_PLN_RD_OVERLAY;
	sc->sc_dpu->pln_wr_msk_host = CG12_PLN_WR_OVERLAY;
d511 6
a516 16
	/*
	 * Do not touch enable and intensity planes, so that kernel
	 * messages can still be read when back to the prom.
	 * However, we need to fix the colormap, or the prompt will come
	 * back as white on white.
	 */
	cgtwelve_ramdac_wraddr(sc, 0);
	sc->sc_ramdac->color = 0x00ffffff;
	for (c = 1; c < 256; c++)
		sc->sc_ramdac->color = 0x00000000;

	/*
	 * Go back to prom output for the last few messages, so they
	 * will be displayed correctly.
	 */
	cn_tab = &consdev_prom;
@


1.5.4.1
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwelve.c,v 1.5 2002/11/06 21:06:20 miod Exp $	*/
d4 1
a4 1
 * Copyright (c) 2002, 2003 Miodrag Vallat.  All rights reserved.
d39 3
a41 3
 * (regular model) or 8MB (high-res model) of video memory, a complex
 * windowing engine, double buffering modes, three video planes (overlay,
 * 8 bit and 24 bit color), and a lot of colormap combinations.
d43 2
a44 2
 * All of this is driven by a set of three Bt462 ramdacs (latched unless
 * explicitely programmed), and a couple of other Matrox-specific chips.
d113 2
a114 1
void cgtwelve_reset(struct cgtwelve_softc *, int);
d119 2
d131 1
a131 1
	NULL,	/* burner */
d158 1
a158 1
	if (strcmp(cf->cf_driver->cd_name, ra->ra_name) != 0)
d161 4
a164 1
	return (1);
d178 1
a178 1
	int node;
d206 1
a206 2
	 * The console is using the 1-bit overlay plane, while the prom
	 * will correctly report 32 bit depth.
d208 6
a213 1
	fb_setsize(&sc->sc_sunfb, 1, CG12_WIDTH, CG12_HEIGHT,
d215 8
a222 4
	sc->sc_sunfb.sf_depth = 1;
	sc->sc_sunfb.sf_linebytes = sc->sc_sunfb.sf_width / 8;
	sc->sc_sunfb.sf_fbsize = sc->sc_sunfb.sf_height *
	    sc->sc_sunfb.sf_linebytes;
d233 5
a237 4
	sc->sc_inten = mapiodev(ca->ca_ra.ra_reg,
	    sc->sc_highres ? CG12_OFF_INTEN_HR : CG12_OFF_INTEN,
	    round_page(sc->sc_highres ? CG12_SIZE_COLOR24_HR :
	        CG12_SIZE_COLOR24));
d240 11
a250 2
	sc->sc_sunfb.sf_depth = 0;	/* force action */
	cgtwelve_reset(sc, 1);
a251 1
	sc->sc_sunfb.sf_ro.ri_bits = (void *)sc->sc_overlay;
d261 11
a271 2
		fbwscons_console_init(&sc->sc_sunfb,
		    &cgtwelve_stdscreen, -1, NULL);
a301 5
	/*
	 * Note that, although the emulation (text) mode is running in the
	 * overlay plane, we advertize the frame buffer as the full-blown
	 * 32-bit beast it is.
	 */
d304 4
a307 1
		*(u_int *)data = WSDISPLAY_TYPE_SUN24;
d313 1
a313 1
		wdf->depth = 32;
d317 1
a317 1
		*(u_int *)data = sc->sc_sunfb.sf_linebytes * 32;
d324 7
a330 10
	case WSDISPLAYIO_SMODE:
		if (*(int *)data == WSDISPLAYIO_MODE_EMUL) {
			/* Back from X11 to text mode */
			cgtwelve_reset(sc, 1);
		} else {
			/* Starting X11, switch to 32 bit mode */
			cgtwelve_reset(sc, 32);
		}
		break;

d342 1
a342 1
cgtwelve_reset(sc, depth)
a343 1
	int depth;
d345 2
a346 1
	u_int32_t c;
d348 9
a356 11
	if (sc->sc_sunfb.sf_depth != depth) {
		if (depth == 1) {
			/*
			 * Select the enable plane as sc_overlay, and fill it.
			 */
			sc->sc_apu->hpage = sc->sc_highres ?
			    CG12_HPAGE_ENABLE_HR : CG12_HPAGE_ENABLE;
			sc->sc_apu->haccess = CG12_HACCESS_ENABLE;
			sc->sc_dpu->pln_sl_host = CG12_PLN_SL_ENABLE;
			sc->sc_dpu->pln_rd_msk_host = CG12_PLN_RD_ENABLE;
			sc->sc_dpu->pln_wr_msk_host = CG12_PLN_WR_ENABLE;
d358 8
a365 2
			memset((void *)sc->sc_overlay, 0xff, sc->sc_highres ?
			    CG12_SIZE_ENABLE_HR : CG12_SIZE_ENABLE);
d367 9
a375 9
			/*
			 * Select the overlay plane as sc_overlay.
			 */
			sc->sc_apu->hpage = sc->sc_highres ?
			    CG12_HPAGE_OVERLAY_HR : CG12_HPAGE_OVERLAY;
			sc->sc_apu->haccess = CG12_HACCESS_OVERLAY;
			sc->sc_dpu->pln_sl_host = CG12_PLN_SL_OVERLAY;
			sc->sc_dpu->pln_rd_msk_host = CG12_PLN_RD_OVERLAY;
			sc->sc_dpu->pln_wr_msk_host = CG12_PLN_WR_OVERLAY;
d377 2
a378 19
			/*
			 * Upload a strict mono colormap, or the text
			 * upon returning from 32 bit mode would appear
			 * as (slightly dark) white on white.
			 */
			cgtwelve_ramdac_wraddr(sc, 0);
			sc->sc_ramdac->color = 0x00000000;
			for (c = 1; c < 256; c++)
				sc->sc_ramdac->color = 0x00ffffff;
		} else {
			/*
			 * Select the overlay plane as sc_overlay.
			 */
			sc->sc_apu->hpage = sc->sc_highres ?
			    CG12_HPAGE_OVERLAY_HR : CG12_HPAGE_OVERLAY;
			sc->sc_apu->haccess = CG12_HACCESS_OVERLAY;
			sc->sc_dpu->pln_sl_host = CG12_PLN_SL_OVERLAY;
			sc->sc_dpu->pln_rd_msk_host = CG12_PLN_RD_OVERLAY;
			sc->sc_dpu->pln_wr_msk_host = CG12_PLN_WR_OVERLAY;
d380 9
a388 22
			/*
			 * Do not attempt to somewhat preserve screen
			 * contents - reading the overlay plane and writing
			 * to the color plane at the same time is not
			 * reliable, and allocating memory to save a copy
			 * of the overlay plane would be awful.
			 */
			bzero((void *)sc->sc_overlay, sc->sc_highres ?
			    CG12_SIZE_OVERLAY_HR : CG12_SIZE_OVERLAY);

			/*
			 * Select the enable plane as sc_overlay, and clear it.
			 */
			sc->sc_apu->hpage = sc->sc_highres ?
			    CG12_HPAGE_ENABLE_HR : CG12_HPAGE_ENABLE;
			sc->sc_apu->haccess = CG12_HACCESS_ENABLE;
			sc->sc_dpu->pln_sl_host = CG12_PLN_SL_ENABLE;
			sc->sc_dpu->pln_rd_msk_host = CG12_PLN_RD_ENABLE;
			sc->sc_dpu->pln_wr_msk_host = CG12_PLN_WR_ENABLE;

			bzero((void *)sc->sc_overlay, sc->sc_highres ?
			    CG12_SIZE_ENABLE_HR : CG12_SIZE_ENABLE);
d390 2
a391 13
			/*
			 * Select the intensity (color) plane, and clear it.
			 */
			sc->sc_apu->hpage = sc->sc_highres ?
			    CG12_HPAGE_24BIT_HR : CG12_HPAGE_24BIT;
			sc->sc_apu->haccess = CG12_HACCESS_24BIT;
			sc->sc_dpu->pln_sl_host = CG12_PLN_SL_24BIT;
			sc->sc_dpu->pln_rd_msk_host = CG12_PLN_RD_24BIT;
			sc->sc_dpu->pln_wr_msk_host = CG12_PLN_WR_24BIT;

			memset((void *)sc->sc_inten, 0x00ffffff,
			    sc->sc_highres ?
			      CG12_SIZE_COLOR24_HR : CG12_SIZE_COLOR24);
d393 1
a393 10
			/*
			 * Use a direct colormap (ramp)
			 */
			cgtwelve_ramdac_wraddr(sc, 0);
			for (c = 0; c < 256; c++)
				sc->sc_ramdac->color = c | (c << 8) | (c << 16);
		}
	}

	sc->sc_sunfb.sf_depth = depth;
d408 1
a408 1
	if (offset & PGOFSET || offset < 0)
d411 11
a421 8
	/*
	 * Note that mmap() will invoke this function only if we are NOT
	 * in emulation mode, so we can assume 32 bit mode safely here.
	 */
	if (offset < sc->sc_sunfb.sf_fbsize * 32) {
		return (REG2PHYS(&sc->sc_phys,
		    (sc->sc_highres ? CG12_OFF_INTEN_HR :
		    CG12_OFF_INTEN) + offset) | PMAP_NC);
d481 44
d534 1
d537 20
a556 2
	if (sc->sc_sunfb.sf_depth != 1) {
		cgtwelve_reset(sc, 1);
d558 5
a562 6
		/*
		 * Go back to prom output for the last few messages, so they
		 * will be displayed correctly.
		 */
		cn_tab = &consdev_prom;
	}
@


1.5.4.2
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d277 1
a277 1
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG12;
@


1.5.4.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwelve.c,v 1.5.4.2 2003/05/16 00:29:40 niklas Exp $	*/
d176 1
@


1.5.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d229 1
a229 1
	fbwscons_init(&sc->sc_sunfb, isconsole ? 0 : RI_CLEAR);
@


1.4
log
@Get the wsdisplay capabilities from rasops, rather than attempting to
guess them at compile-time. Plus this makes cgtwelve a bit more clean.

ok fgs@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwelve.c,v 1.3 2002/09/20 11:17:56 fgsch Exp $	*/
d263 1
a263 1
			    &cgtwelve_stdscreen, -1, NULL, NULL);
d270 1
a270 1
			    &cgtwelve_stdscreen, 0, NULL, cgtwelve_burner);
d272 1
@


1.4.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.4.4.2
log
@sync
@
text
@d4 1
a4 1
 * Copyright (c) 2002, 2003 Miodrag Vallat.  All rights reserved.
d39 3
a41 3
 * (regular model) or 8MB (high-res model) of video memory, a complex
 * windowing engine, double buffering modes, three video planes (overlay,
 * 8 bit and 24 bit color), and a lot of colormap combinations.
d43 2
a44 2
 * All of this is driven by a set of three Bt462 ramdacs (latched unless
 * explicitely programmed), and a couple of other Matrox-specific chips.
d113 2
a114 1
void cgtwelve_reset(struct cgtwelve_softc *, int);
d119 2
d131 1
a131 1
	NULL,	/* burner */
d158 1
a158 1
	if (strcmp(cf->cf_driver->cd_name, ra->ra_name) != 0)
d161 4
a164 1
	return (1);
d178 1
a178 1
	int node;
d206 1
a206 2
	 * The console is using the 1-bit overlay plane, while the prom
	 * will correctly report 32 bit depth.
d208 6
a213 1
	fb_setsize(&sc->sc_sunfb, 1, CG12_WIDTH, CG12_HEIGHT,
d215 8
a222 4
	sc->sc_sunfb.sf_depth = 1;
	sc->sc_sunfb.sf_linebytes = sc->sc_sunfb.sf_width / 8;
	sc->sc_sunfb.sf_fbsize = sc->sc_sunfb.sf_height *
	    sc->sc_sunfb.sf_linebytes;
d233 5
a237 4
	sc->sc_inten = mapiodev(ca->ca_ra.ra_reg,
	    sc->sc_highres ? CG12_OFF_INTEN_HR : CG12_OFF_INTEN,
	    round_page(sc->sc_highres ? CG12_SIZE_COLOR24_HR :
	        CG12_SIZE_COLOR24));
d240 11
a250 2
	sc->sc_sunfb.sf_depth = 0;	/* force action */
	cgtwelve_reset(sc, 1);
a251 1
	sc->sc_sunfb.sf_ro.ri_bits = (void *)sc->sc_overlay;
d261 11
a271 3
		fbwscons_console_init(&sc->sc_sunfb,
		    &cgtwelve_stdscreen, -1, NULL);
		shutdownhook_establish(cgtwelve_prom, sc);
a300 5
	/*
	 * Note that, although the emulation (text) mode is running in the
	 * overlay plane, we advertize the frame buffer as the full-blown
	 * 32-bit beast it is.
	 */
d303 4
a306 1
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG12;
d312 1
a312 1
		wdf->depth = 32;
d316 1
a316 1
		*(u_int *)data = sc->sc_sunfb.sf_linebytes * 32;
d323 7
a329 10
	case WSDISPLAYIO_SMODE:
		if (*(int *)data == WSDISPLAYIO_MODE_EMUL) {
			/* Back from X11 to text mode */
			cgtwelve_reset(sc, 1);
		} else {
			/* Starting X11, switch to 32 bit mode */
			cgtwelve_reset(sc, 32);
		}
		break;

d341 1
a341 1
cgtwelve_reset(sc, depth)
a342 1
	int depth;
d344 2
a345 1
	u_int32_t c;
d347 9
a355 11
	if (sc->sc_sunfb.sf_depth != depth) {
		if (depth == 1) {
			/*
			 * Select the enable plane as sc_overlay, and fill it.
			 */
			sc->sc_apu->hpage = sc->sc_highres ?
			    CG12_HPAGE_ENABLE_HR : CG12_HPAGE_ENABLE;
			sc->sc_apu->haccess = CG12_HACCESS_ENABLE;
			sc->sc_dpu->pln_sl_host = CG12_PLN_SL_ENABLE;
			sc->sc_dpu->pln_rd_msk_host = CG12_PLN_RD_ENABLE;
			sc->sc_dpu->pln_wr_msk_host = CG12_PLN_WR_ENABLE;
d357 8
a364 2
			memset((void *)sc->sc_overlay, 0xff, sc->sc_highres ?
			    CG12_SIZE_ENABLE_HR : CG12_SIZE_ENABLE);
d366 9
a374 9
			/*
			 * Select the overlay plane as sc_overlay.
			 */
			sc->sc_apu->hpage = sc->sc_highres ?
			    CG12_HPAGE_OVERLAY_HR : CG12_HPAGE_OVERLAY;
			sc->sc_apu->haccess = CG12_HACCESS_OVERLAY;
			sc->sc_dpu->pln_sl_host = CG12_PLN_SL_OVERLAY;
			sc->sc_dpu->pln_rd_msk_host = CG12_PLN_RD_OVERLAY;
			sc->sc_dpu->pln_wr_msk_host = CG12_PLN_WR_OVERLAY;
d376 2
a377 19
			/*
			 * Upload a strict mono colormap, or the text
			 * upon returning from 32 bit mode would appear
			 * as (slightly dark) white on white.
			 */
			cgtwelve_ramdac_wraddr(sc, 0);
			sc->sc_ramdac->color = 0x00000000;
			for (c = 1; c < 256; c++)
				sc->sc_ramdac->color = 0x00ffffff;
		} else {
			/*
			 * Select the overlay plane as sc_overlay.
			 */
			sc->sc_apu->hpage = sc->sc_highres ?
			    CG12_HPAGE_OVERLAY_HR : CG12_HPAGE_OVERLAY;
			sc->sc_apu->haccess = CG12_HACCESS_OVERLAY;
			sc->sc_dpu->pln_sl_host = CG12_PLN_SL_OVERLAY;
			sc->sc_dpu->pln_rd_msk_host = CG12_PLN_RD_OVERLAY;
			sc->sc_dpu->pln_wr_msk_host = CG12_PLN_WR_OVERLAY;
d379 9
a387 22
			/*
			 * Do not attempt to somewhat preserve screen
			 * contents - reading the overlay plane and writing
			 * to the color plane at the same time is not
			 * reliable, and allocating memory to save a copy
			 * of the overlay plane would be awful.
			 */
			bzero((void *)sc->sc_overlay, sc->sc_highres ?
			    CG12_SIZE_OVERLAY_HR : CG12_SIZE_OVERLAY);

			/*
			 * Select the enable plane as sc_overlay, and clear it.
			 */
			sc->sc_apu->hpage = sc->sc_highres ?
			    CG12_HPAGE_ENABLE_HR : CG12_HPAGE_ENABLE;
			sc->sc_apu->haccess = CG12_HACCESS_ENABLE;
			sc->sc_dpu->pln_sl_host = CG12_PLN_SL_ENABLE;
			sc->sc_dpu->pln_rd_msk_host = CG12_PLN_RD_ENABLE;
			sc->sc_dpu->pln_wr_msk_host = CG12_PLN_WR_ENABLE;

			bzero((void *)sc->sc_overlay, sc->sc_highres ?
			    CG12_SIZE_ENABLE_HR : CG12_SIZE_ENABLE);
d389 2
a390 13
			/*
			 * Select the intensity (color) plane, and clear it.
			 */
			sc->sc_apu->hpage = sc->sc_highres ?
			    CG12_HPAGE_24BIT_HR : CG12_HPAGE_24BIT;
			sc->sc_apu->haccess = CG12_HACCESS_24BIT;
			sc->sc_dpu->pln_sl_host = CG12_PLN_SL_24BIT;
			sc->sc_dpu->pln_rd_msk_host = CG12_PLN_RD_24BIT;
			sc->sc_dpu->pln_wr_msk_host = CG12_PLN_WR_24BIT;

			memset((void *)sc->sc_inten, 0x00ffffff,
			    sc->sc_highres ?
			      CG12_SIZE_COLOR24_HR : CG12_SIZE_COLOR24);
d392 1
a392 10
			/*
			 * Use a direct colormap (ramp)
			 */
			cgtwelve_ramdac_wraddr(sc, 0);
			for (c = 0; c < 256; c++)
				sc->sc_ramdac->color = c | (c << 8) | (c << 16);
		}
	}

	sc->sc_sunfb.sf_depth = depth;
d407 1
a407 1
	if (offset & PGOFSET || offset < 0)
d410 11
a420 8
	/*
	 * Note that mmap() will invoke this function only if we are NOT
	 * in emulation mode, so we can assume 32 bit mode safely here.
	 */
	if (offset < sc->sc_sunfb.sf_fbsize * 32) {
		return (REG2PHYS(&sc->sc_phys,
		    (sc->sc_highres ? CG12_OFF_INTEN_HR :
		    CG12_OFF_INTEN) + offset) | PMAP_NC);
d480 44
d533 1
d536 20
a555 2
	if (sc->sc_sunfb.sf_depth != 1) {
		cgtwelve_reset(sc, 1);
d557 5
a561 6
		/*
		 * Go back to prom output for the last few messages, so they
		 * will be displayed correctly.
		 */
		cn_tab = &consdev_prom;
	}
@


1.3
log
@Support to run the 24 bit fb in 8 bit mode or cg12 in 1 bit mode
via flags, using 0x0001.
miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwelve.c,v 1.1 2002/08/12 10:44:03 miod Exp $	*/
a94 13
	0, 0,	/* will be filled in */
	0,
	0, 0,
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
	WSSCREEN_REVERSE | WSSCREEN_WSCOLORS
};

struct wsscreen_descr cgtwelve_monoscreen = {
	"std",
	0, 0,	/* will be filled in */
	0,
	0, 0,
	WSSCREEN_UNDERLINE | WSSCREEN_REVERSE
a100 4
const struct wsscreen_descr *cgtwelve_monoscrlist[] = {
	&cgtwelve_monoscreen,
};

a105 5
struct wsscreen_list cgtwelve_monoscreenlist = {
	sizeof(cgtwelve_monoscrlist) / sizeof(struct wsscreen_descr *),
	    cgtwelve_monoscrlist
};

d255 1
d284 1
a284 4
	if (sc->sc_sunfb.sf_depth == 1)
		waa.scrdata = &cgtwelve_monoscreenlist;
	else
		waa.scrdata = &cgtwelve_screenlist;
@


1.2
log
@Register more screen capabilities to work with the recent wsemul_sun changes.
@
text
@a76 8
/*
 * Define CG12_MONO to only use the overlay plane of the CG12, thus having
 * a very fast, though monochrome, framebuffer.
 */
#ifdef	SMALL_KERNEL
#define	CG12_MONO
#endif

a86 1
#ifndef CG12_MONO
a87 1
#endif
a97 3
#ifdef CG12_MONO
	WSSCREEN_UNDERLINE | WSSCREEN_REVERSE
#else
d100 8
a107 1
#endif
d114 4
d119 7
a125 1
	sizeof(cgtwelve_scrlist) / sizeof(struct wsscreen_descr *), cgtwelve_scrlist
a135 1
#ifndef CG12_MONO
a142 1
#endif
a149 1
#ifndef CG12_MONO
d153 1
a153 2
	cgtwelve_burner,
#endif
a179 5
	/*
	 * Mask out invalid flags from the user.
	 */
	cf->cf_flags &= FB_USERMASK;

d200 1
a200 1
	int node;
d204 1
a204 1
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;
d230 6
a235 2
#ifdef CG12_MONO
	fb_setsize(&sc->sc_sunfb, 1, CG12_WIDTH, CG12_HEIGHT,
d238 7
a244 9
	/* the prom will report depth == 32, so compensate */
	sc->sc_sunfb.sf_depth = 1;
	sc->sc_sunfb.sf_linebytes = sc->sc_sunfb.sf_width / 8;
	sc->sc_sunfb.sf_fbsize = sc->sc_sunfb.sf_height *
		sc->sc_sunfb.sf_linebytes;
#else
	fb_setsize(&sc->sc_sunfb, 32, CG12_WIDTH, CG12_HEIGHT,
	    node, ca->ca_bustype);
#endif
d255 5
a259 6
#ifndef CG12_MONO
	sc->sc_inten = mapiodev(ca->ca_ra.ra_reg,
	    sc->sc_highres ? CG12_OFF_INTEN_HR : CG12_OFF_INTEN,
	    round_page(sc->sc_highres ? CG12_SIZE_COLOR24_HR :
	        CG12_SIZE_COLOR24));
#endif
d264 10
a273 10
#ifndef CG12_MONO
	/* enable video */
	cgtwelve_burner(sc, 1, 0);
#endif

#ifdef CG12_MONO
	sc->sc_sunfb.sf_ro.ri_bits = (void *)sc->sc_overlay;
#else
	sc->sc_sunfb.sf_ro.ri_bits = (void *)sc->sc_inten;
#endif
d282 11
a292 11
#ifdef CG12_MONO
		fbwscons_console_init(&sc->sc_sunfb, &cgtwelve_stdscreen, -1,
		    NULL, NULL);
#else
		/*
		 * Since the screen has been cleared, restart at the top
		 * of the screen.
		 */
		fbwscons_console_init(&sc->sc_sunfb, &cgtwelve_stdscreen, 0,
		    NULL, cgtwelve_burner);
#endif
d305 4
a308 1
	waa.scrdata = &cgtwelve_screenlist;
d327 4
a330 5
#ifdef CG12_MONO
		*(u_int *)data = WSDISPLAY_TYPE_SUNBW;
#else
		*(u_int *)data = WSDISPLAY_TYPE_SUN24;
#endif
d368 3
a370 1
#ifndef CG12_MONO
a416 1
#endif
d436 9
a444 9
#ifdef CG12_MONO
		return (REG2PHYS(&sc->sc_phys,
		    (sc->sc_highres ? CG12_OFF_OVERLAY0_HR :
		    CG12_OFF_OVERLAY0) + offset) | PMAP_NC);
#else
		return (REG2PHYS(&sc->sc_phys,
		    (sc->sc_highres ? CG12_OFF_INTEN_HR :
		    CG12_OFF_INTEN) + offset) | PMAP_NC);
#endif
a492 1
#ifndef CG12_MONO
d539 3
a586 1
#endif
@


1.1
log
@Convert sparc console code from rcons and pseudo-devices to rasops and wscons.
For most framebuffers it is faster.

Other changes include:
o 24 bit support in tcx(4) for the S24 framebuffer
o accelerated cgsix(4) text console
o new cgtwelve(4) driver for the GS framebuffer
o improved serial driver code
o better keyboard support

The following framebuffers have not been tested but should work: cgfour,
cgeight and cgfourteen

These changes will require XF4 changes, to use Xwsfb instead of Xsun*, to be
commited later today.

Most of the work by me during the LSM and the week after, with code borrowed
from jason@@, NetBSD (new serial code), and feedback from mickey@@. Work on
pnozz(4) done by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d109 1
a109 1
	WSSCREEN_REVERSE
d111 1
@

