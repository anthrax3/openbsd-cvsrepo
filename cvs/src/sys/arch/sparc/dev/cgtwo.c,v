head	1.39;
access;
symbols
	OPENBSD_6_0:1.39.0.12
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.8
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.39.0.10
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.39.0.6
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.38.0.14
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.38.0.12
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.38.0.10
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.8
	OPENBSD_5_0:1.38.0.6
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.38.0.4
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.38.0.2
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.37.0.4
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.37.0.6
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.37.0.2
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.36.0.8
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.36.0.6
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.36.0.4
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.36.0.2
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.34.0.2
	OPENBSD_4_0_BASE:1.34
	OPENBSD_3_9:1.33.0.4
	OPENBSD_3_9_BASE:1.33
	OPENBSD_3_8:1.33.0.2
	OPENBSD_3_8_BASE:1.33
	OPENBSD_3_7:1.32.0.2
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.29.0.6
	OPENBSD_3_6_BASE:1.29
	SMP_SYNC_A:1.29
	SMP_SYNC_B:1.29
	OPENBSD_3_5:1.29.0.4
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	UBC_SYNC_A:1.26
	OPENBSD_3_3:1.25.0.2
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.24.0.2
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	UBC_SYNC_B:1.24
	UBC:1.18.0.2
	UBC_BASE:1.18
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.13.0.8
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.6
	OPENBSD_2_7_BASE:1.13
	SMP:1.13.0.4
	SMP_BASE:1.13
	kame_19991208:1.13
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.11.0.6
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.11.0.4
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.10.0.4
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.10.0.2
	OPENBSD_2_0_BASE:1.10
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.39
date	2013.10.20.20.07.25;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2010.06.07.19.43.45;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2008.12.26.22.30.21;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2006.12.03.16.40.06;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2006.12.03.16.38.13;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2006.06.29.17.52.21;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2005.03.23.17.16.34;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2005.03.07.16.44.50;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2005.01.05.23.04.25;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2004.11.29.22.07.36;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.28.17.05.33;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.06.19.42.47;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.02.23.27.54;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2003.05.12.20.18.39;	author jason;	state Exp;
branches;
next	1.25;

1.25
date	2002.11.06.21.06.20;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2002.09.23.18.13.38;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2002.09.09.22.15.16;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2002.08.12.10.44.03;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2002.08.02.16.13.07;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.14.03.15.59;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.01.26.42;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.11.01.12.13.46;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.16.00.42.44;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.17.13.52.28;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2001.04.06.04.42.05;	author csapuntz;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	99.09.10.23.32.02;	author art;	state Exp;
branches
	1.13.4.1
	1.13.8.1;
next	1.12;

1.12
date	98.11.20.15.57.22;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.08.08.08.24.55;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	96.08.13.08.05.23;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	96.08.11.05.34.12;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	95.12.18.17.04.07;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	95.12.15.13.56.19;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	95.11.19.00.11.39;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	95.11.09.21.34.47;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.11.03.03.24.27;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.10.22.11.29.33;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.19.12.51.53;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.38;	author deraadt;	state Exp;
branches;
next	;

1.13.4.1
date	2001.05.14.21.37.03;	author niklas;	state Exp;
branches;
next	1.13.4.2;

1.13.4.2
date	2001.10.31.03.07.56;	author nate;	state Exp;
branches;
next	1.13.4.3;

1.13.4.3
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.13.4.4;

1.13.4.4
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.13.4.5;

1.13.4.5
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.13.4.6;

1.13.4.6
date	2003.05.16.00.29.40;	author niklas;	state Exp;
branches;
next	1.13.4.7;

1.13.4.7
date	2003.06.07.11.14.42;	author ho;	state Exp;
branches;
next	1.13.4.8;

1.13.4.8
date	2004.02.19.10.49.57;	author niklas;	state Exp;
branches;
next	;

1.13.8.1
date	2001.09.16.15.22.02;	author miod;	state Exp;
branches;
next	;

1.14.2.1
date	2001.10.14.20.44.48;	author jason;	state Exp;
branches;
next	;

1.18.2.1
date	2002.06.11.03.38.15;	author art;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2002.10.29.00.28.09;	author art;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@/*	$OpenBSD: cgtwo.c,v 1.38 2010/06/07 19:43:45 miod Exp $	*/
/*	$NetBSD: cgtwo.c,v 1.22 1997/05/24 20:16:12 pk Exp $ */

/*
 * Copyright (c) 2002 Miodrag Vallat.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)cgthree.c	8.2 (Berkeley) 10/30/93
 */

/*
 * color display (cgtwo) driver.
 *
 * Does not handle interrupts, even though they can occur.
 *
 * XXX should defer colormap updates to vertical retrace interrupts
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/mman.h>
#include <sys/tty.h>
#include <sys/conf.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/pmap.h>
#if defined(SUN4)
#include <machine/eeprom.h>
#endif
#include <machine/conf.h>

#include <sparc/dev/cgtworeg.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>


/* per-display variables */
struct cgtwo_softc {
	struct	sunfb sc_sunfb;		/* common base part */
	struct	rom_reg	sc_phys;	/* display RAM (phys addr) */
	volatile struct cg2statusreg *sc_reg;	/* CG2 control registers */
	volatile u_short *sc_ppmask;
	volatile u_short *sc_cmap;
#define sc_redmap(cmap)		((cmap))
#define sc_greenmap(cmap)	((cmap) + CG2_CMSIZE)
#define sc_bluemap(cmap)	((cmap) + 2 * CG2_CMSIZE)
};

void	cgtwo_burner(void *, u_int, u_int);
int	cgtwo_getcmap(struct cgtwo_softc *, struct wsdisplay_cmap *);
int	cgtwo_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	cgtwo_mmap(void *, off_t, int);
int	cgtwo_putcmap(struct cgtwo_softc *, struct wsdisplay_cmap *);
void	cgtwo_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);

struct wsdisplay_accessops cgtwo_accessops = {
	.ioctl = cgtwo_ioctl,
	.mmap = cgtwo_mmap,
	.burn_screen = cgtwo_burner
};

int	cgtwomatch(struct device *, void *, void *);
void	cgtwoattach(struct device *, struct device *, void *);

struct cfattach cgtwo_ca = {
	sizeof(struct cgtwo_softc), cgtwomatch, cgtwoattach
};

struct cfdriver cgtwo_cd = {
	NULL, "cgtwo", DV_DULL
};

int
cgtwomatch(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;
	caddr_t tmp;

	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
		return (0);

	if (!CPU_ISSUN4 || ca->ca_bustype != BUS_VME16)
		return (0);

	/* XXX - Must do our own mapping at CG2_CTLREG_OFF */
	bus_untmp();
	tmp = (caddr_t)mapdev(ra->ra_reg, TMPMAP_VA, CG2_CTLREG_OFF, NBPG);
	if (probeget(tmp, 2) != -1)
		return (1);

	return (0);
}

void
cgtwoattach(struct device *parent, struct device *self, void *args)
{
	struct cgtwo_softc *sc = (struct cgtwo_softc *)self;
	struct confargs *ca = args;
	int node = 0;
	int isconsole = 0;

	if (CPU_ISSUN4) {
		struct eeprom *eep = (struct eeprom *)eeprom_va;
		/*
		 * Assume this is the console if there's no eeprom info
		 * to be found.
		 */
		if (eep == NULL || eep->ee_diag.eed_console == EED_CONS_COLOR)
			isconsole = 1;
	}

	/*
	 * When the ROM has mapped in a cgtwo display, the address
	 * maps only the video RAM, so in any case we have to map the
	 * registers ourselves.
	 */
	sc->sc_phys = ca->ca_ra.ra_reg[0];
	/* Apparently, the pixels are 32-bit data space */
	sc->sc_phys.rr_iospace = PMAP_VME32;

	sc->sc_reg = (volatile struct cg2statusreg *)
	    mapiodev(ca->ca_ra.ra_reg,
		CG2_ROPMEM_OFF + offsetof(struct cg2fb, status.reg),
		sizeof(struct cg2statusreg));

	sc->sc_ppmask = (volatile u_short *)
	    mapiodev(ca->ca_ra.ra_reg,
		CG2_ROPMEM_OFF + offsetof(struct cg2fb, ppmask.reg),
		sizeof(u_short));

	sc->sc_cmap = (volatile u_short *)
	    mapiodev(ca->ca_ra.ra_reg,
		     CG2_ROPMEM_OFF + offsetof(struct cg2fb, redmap),
		     3 * CG2_CMSIZE * sizeof(u_short));

	/* enable video */
	*sc->sc_ppmask = 0xffff;	/* enable all color planes... */
	cgtwo_burner(sc, 1, 0);		/* ... and video signals */

	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, ca->ca_bustype);
	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(&sc->sc_phys, CG2_PIXMAP_OFF,
	    round_page(sc->sc_sunfb.sf_fbsize));
	sc->sc_sunfb.sf_ro.ri_hw = sc;

	printf(": %dx%d\n", sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);

	fbwscons_init(&sc->sc_sunfb, isconsole);
	fbwscons_setcolormap(&sc->sc_sunfb, cgtwo_setcolor);

	if (isconsole) {
		fbwscons_console_init(&sc->sc_sunfb, -1);
	}

	fbwscons_attach(&sc->sc_sunfb, &cgtwo_accessops, isconsole);
}

int
cgtwo_ioctl(void *v, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct cgtwo_softc *sc = v;
	struct wsdisplay_fbinfo *wdf;
	struct wsdisplay_cmap *cm;
	int error;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG2;
		break;
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
		wdf->cmsize = CG2_CMSIZE;
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
		break;
		
	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = cgtwo_getcmap(sc, cm);
		if (error)
			return (error);
		break;

	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = cgtwo_putcmap(sc, cm);
		if (error)
			return (error);
		break;

	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
		break;

	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
	default:
		return (-1);	/* not supported yet */
	}

	return (0);
}

paddr_t
cgtwo_mmap(void *v, off_t offset, int prot)
{
	struct cgtwo_softc *sc = v;

	if (offset & PGOFSET)
		return (-1);

	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys,
		    CG2_PIXMAP_OFF + offset) | PMAP_NC);
	}

	return (-1);
}

void
cgtwo_burner(void *v, u_int on, u_int flags)
{
	struct cgtwo_softc *sc = v;
	int s;

	s = splhigh();
	if (on)
		sc->sc_reg->video_enab = 1;
	else
		sc->sc_reg->video_enab = 0;
	splx(s);
}

int
cgtwo_getcmap(struct cgtwo_softc *sc, struct wsdisplay_cmap *cmap)
{
	u_int index = cmap->index, count = cmap->count, i;
	u_char red[CG2_CMSIZE], green[CG2_CMSIZE], blue[CG2_CMSIZE];
	volatile u_short *hwcmap = sc->sc_cmap;
	int error;
	volatile u_short *p;


	if (index >= CG2_CMSIZE || count >= CG2_CMSIZE - index)
		return (EINVAL);

	while (sc->sc_reg->retrace == 0)
		DELAY(1);

	sc->sc_reg->update_cmap = 0;

	/* Copy hardware to local arrays. */
	p = &sc_redmap(hwcmap)[index];
	for (i = 0; i < count; i++)
		red[i] = *p++;
	p = &sc_greenmap(hwcmap)[index];
	for (i = 0; i < count; i++)
		green[i] = *p++;
	p = &sc_bluemap(hwcmap)[index];
	for (i = 0; i < count; i++)
		blue[i] = *p++;

	sc->sc_reg->update_cmap = 1;

	/* Copy local arrays to user space. */
	if ((error = copyout(red, cmap->red, count)) != 0)
		return (error);
	if ((error = copyout(green, cmap->green, count)) != 0)
		return (error);
	if ((error = copyout(blue, cmap->blue, count)) != 0)
		return (error);

	return (0);
}

int
cgtwo_putcmap(struct cgtwo_softc *sc, struct wsdisplay_cmap *cmap)
{
	u_int index = cmap->index, count = cmap->count, i;
	u_char red[CG2_CMSIZE], green[CG2_CMSIZE], blue[CG2_CMSIZE];
	volatile u_short *hwcmap = sc->sc_cmap;
	int error;
	volatile u_short *p;

	if (index >= CG2_CMSIZE || count >= CG2_CMSIZE - index)
		return (EINVAL);

	/* Copy from user space to local arrays. */
	if ((error = copyin(cmap->red, red, count)) != 0)
		return (error);
	if ((error = copyin(cmap->green, green, count)) != 0)
		return (error);
	if ((error = copyin(cmap->blue, blue, count)) != 0)
		return (error);

	while (sc->sc_reg->retrace == 0)
		DELAY(1);

	sc->sc_reg->update_cmap = 0;

	/* Copy from local arrays to hardware. */
	p = &sc_redmap(hwcmap)[index];
	for (i = 0; i < count; i++)
		*p++ = red[i];
	p = &sc_greenmap(hwcmap)[index];
	for (i = 0; i < count; i++)
		*p++ = green[i];
	p = &sc_bluemap(hwcmap)[index];
	for (i = 0; i < count; i++)
		*p++ = blue[i];

	sc->sc_reg->update_cmap = 1;

	return (0);
}

void
cgtwo_setcolor(void *v, u_int index, u_int8_t r, u_int8_t g, u_int8_t b)
{
	struct cgtwo_softc *sc = v;

	while (sc->sc_reg->retrace == 0)
		DELAY(1);

	sc->sc_reg->update_cmap = 0;

	sc_redmap(sc->sc_cmap)[index] = r;
	sc_greenmap(sc->sc_cmap)[index] = g;
	sc_bluemap(sc->sc_cmap)[index] = b;

	sc->sc_reg->update_cmap = 1;
}
@


1.38
log
@Nuke old eeprom.h compatibility defines; ok todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.37 2008/12/26 22:30:21 miod Exp $	*/
d123 3
a125 10
	cgtwo_ioctl,
	cgtwo_mmap,
	NULL,	/* alloc_screen */
	NULL,	/* free_screen */
	NULL,	/* show_screen */
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	cgtwo_burner,
	NULL	/* pollc */
@


1.37
log
@Move the logic responsible from deciding whether a frame buffer needs to be
cleared on attach, from the individual drivers to the common frame buffer code;
the latter will decide based on the prom font metrics and the prom console
window position, whenever possible.

This removes the need for the console window position to be hardcoded in
the p9100 driver, and will no longer require a screen clear on a vigra
VS-12 in high resolution mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.36 2006/12/03 16:40:06 miod Exp $	*/
d183 1
a183 1
		if (eep == NULL || eep->eeConsole == EE_CONS_COLOR)
@


1.36
log
@Enable all color planes on attach and wait for retrace to program the
colormap, this finally makes color work.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.35 2006/12/03 16:38:13 miod Exp $	*/
a218 2
	fbwscons_init(&sc->sc_sunfb, isconsole ? 0 : RI_CLEAR);
	fbwscons_setcolormap(&sc->sc_sunfb, cgtwo_setcolor);
d221 3
@


1.35
log
@Clean frame buffer attachment code:
- There is no need to check for buses config(8) will not let us attach to
- Better P4 bus logic, which does not need to abuse device flags
- Do not bother trying to print a meaningful device description when it is
  not connected to sbus.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.34 2006/06/29 17:52:21 miod Exp $	*/
d108 1
d110 3
a112 3
#define sc_redmap(cmap)		((u_short *)(cmap))
#define sc_greenmap(cmap)	((u_short *)(cmap) + CG2_CMSIZE)
#define sc_bluemap(cmap)	((u_short *)(cmap) + 2 * CG2_CMSIZE)
d116 1
a116 1
int	cgtwo_getcmap(volatile u_short *, struct wsdisplay_cmap *);
d119 1
a119 1
int	cgtwo_putcmap(volatile u_short *, struct wsdisplay_cmap *);
d198 7
a204 2
		     CG2_ROPMEM_OFF + offsetof(struct cg2fb, status.reg),
		     sizeof(struct cg2statusreg));
d212 2
a213 1
	cgtwo_burner(sc, 1, 0);
d256 1
a256 1
		error = cgtwo_getcmap(sc->sc_cmap, cm);
d263 1
a263 1
		error = cgtwo_putcmap(sc->sc_cmap, cm);
d315 1
a315 1
cgtwo_getcmap(volatile u_short *hwcmap, struct wsdisplay_cmap *cmap)
d319 1
d327 4
a330 1
	/* XXX - Wait for retrace? */
d343 2
d357 1
a357 1
cgtwo_putcmap(volatile u_short *hwcmap, struct wsdisplay_cmap *cmap)
d361 1
d376 4
a379 1
	/* XXX - Wait for retrace? */
d392 2
d402 5
a406 1
	/* XXX - Wait for retrace? */
d410 2
@


1.34
log
@Map the correct size for the colormap registers (not that it really matters
since this is rounded up one page).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.33 2005/03/23 17:16:34 miod Exp $	*/
a174 14
	char *nam = NULL;

	switch (ca->ca_bustype) {
	case BUS_VME16:
		node = 0;
		nam = "cgtwo";
		break;

	default:
		panic("cgtwoattach: impossible bustype");
		/* NOTREACHED */
	}

	printf(": %s", nam);
d215 1
a215 1
	printf(", %dx%d\n", sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);
@


1.33
log
@Move the alloc_screen, free_screen and show_screen wsdisplay accessops to
the common frame buffer code, rather than duplicating it in every driver.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.32 2005/03/07 16:44:50 miod Exp $	*/
d216 2
a217 2
		     CG2_ROPMEM_OFF + offsetof(struct cg2fb, redmap[0]),
		     3 * CG2_CMSIZE);
@


1.32
log
@Do not bother passing the blanking routine to fbwscons_console_init(),
as fbwscons_attach() can find it on its own.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.31 2005/01/05 23:04:25 miod Exp $	*/
a98 1
#include <dev/wscons/wscons_raster.h>
a111 1
	int	sc_nscreens;
d114 6
a119 10
int cgtwo_ioctl(void *, u_long, caddr_t, int, struct proc *);
int cgtwo_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgtwo_free_screen(void *, void *);
int cgtwo_show_screen(void *, void *, int, void (*)(void *, int, int), void *);
paddr_t cgtwo_mmap(void *, off_t, int);
int cgtwo_putcmap(volatile u_short *, struct wsdisplay_cmap *);
int cgtwo_getcmap(volatile u_short *, struct wsdisplay_cmap *);
void cgtwo_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
void cgtwo_burner(void *, u_int, u_int);
d124 3
a126 3
	cgtwo_alloc_screen,
	cgtwo_free_screen,
	cgtwo_show_screen,
d131 1
d134 2
a135 2
int cgtwomatch(struct device *, void *, void *);
void cgtwoattach(struct device *, struct device *, void *);
a144 3
/*
 * Match a cgtwo.
 */
d146 1
a146 3
cgtwomatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
a167 3
/*
 * Attach a display.
 */
d169 1
a169 3
cgtwoattach(parent, self, args)
	struct device *parent, *self;
	void *args;
d239 1
a239 6
cgtwo_ioctl(v, cmd, data, flags, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
a290 43
int
cgtwo_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
{
	struct cgtwo_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	sc->sc_nscreens++;
	return (0);
}

void
cgtwo_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct cgtwo_softc *sc = v;

	sc->sc_nscreens--;
}

int
cgtwo_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
	return (0);
}

d292 1
a292 4
cgtwo_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
d308 1
a308 3
cgtwo_burner(v, on, flags)
	void *v;
	u_int on, flags;
d322 1
a322 3
cgtwo_getcmap(hwcmap, cmap)
	volatile u_short *hwcmap;
	struct wsdisplay_cmap *cmap;
d358 1
a358 3
cgtwo_putcmap(hwcmap, cmap)
	volatile u_short *hwcmap;
	struct wsdisplay_cmap *cmap;
d393 1
a393 4
cgtwo_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
	u_int8_t r, g, b;
a395 11
#if 0
	struct wsdisplay_cmap cm;

	cm.red = &r;
	cm.green = &g;
	cm.blue = &b;
	cm.index = index;
	cm.count = 1;

	cgtwo_putcmap(sc->sc_cmap, &cm);
#else
a397 1

a400 1
#endif
@


1.31
log
@Let wsdisplay drivers return zero for WSDISPLAYIO_[GS]VIDEO ioctls - most
of the work is done in the upper layer, but they get to see the ioctl,
so don't always return an error.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.30 2004/11/29 22:07:36 miod Exp $	*/
d247 1
a247 1
		fbwscons_console_init(&sc->sc_sunfb, -1, cgtwo_burner);
@


1.30
log
@Move the struct wsscreen_descr from a per-driver global to a per-instance
field of the sunfb structure. This allows multiple instances of the same driver,
but with different resolutions (such as a couple of vigra or a TGX cgsix and
a TGX+ cgsix) to use distinct wsscreen_descr structures featuring different
resolution information.

Doing this allows more wsscreen_descr fiddling inside the sparc* fb api,
and results in some code shrinkage (about 4KB on sparc GENERIC).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.29 2003/06/28 17:05:33 miod Exp $	*/
d297 2
@


1.29
log
@Sync sparc fb API with the sparc64 changes (fbwscons_init takes flags, and
the sunfb structure keeps pointer to the prom cursor coordinates).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.28 2003/06/06 19:42:47 miod Exp $	*/
a115 13
struct wsscreen_descr cgtwo_stdscreen = {
	"std",
};

const struct wsscreen_descr *cgtwo_scrlist[] = {
	&cgtwo_stdscreen,
};

struct wsscreen_list cgtwo_screenlist = {
	sizeof(cgtwo_scrlist) / sizeof(struct wsscreen_descr *),
	    cgtwo_scrlist
};

a187 1
	struct wsemuldisplaydev_attach_args waa;
a243 5
	cgtwo_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgtwo_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgtwo_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgtwo_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

d247 1
a247 2
		fbwscons_console_init(&sc->sc_sunfb, &cgtwo_stdscreen, -1,
		    cgtwo_burner);
d250 1
a250 5
	waa.console = isconsole;
	waa.scrdata = &cgtwo_screenlist;
	waa.accessops = &cgtwo_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
@


1.28
log
@Do not bother taking care of the frame buffer flags in the softc, if the
driver does not use any. Basically this changes all drivers but those that
can handle a P4 card.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.27 2003/06/02 23:27:54 millert Exp $	*/
d255 1
a255 1
	fbwscons_init(&sc->sc_sunfb, isconsole);
@


1.27
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.26 2003/05/12 20:18:39 jason Exp $	*/
a175 5
	/*
	 * Mask out invalid flags from the user.
	 */
	cf->cf_flags &= FB_USERMASK;

a204 2

	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;
@


1.26
log
@use new display types; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.25 2002/11/06 21:06:20 miod Exp $	*/
d49 1
a49 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.25
log
@- always initialize colormaps, even if the frame buffer is non console; this
  helps if the ramdac does not get initialized (idea from jason@@)
- only register a shutdown hook for the frame buffers which need it, if this
  is the console frame buffer. Otherwise this is just a waste of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.24 2002/09/23 18:13:38 miod Exp $	*/
d303 1
a303 1
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
@


1.24
log
@Get the wsdisplay capabilities from rasops, rather than attempting to
guess them at compile-time. Plus this makes cgtwelve a bit more clean.

ok fgs@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.23 2002/09/09 22:15:16 miod Exp $	*/
d267 1
d278 1
a278 1
		    cgtwo_setcolor, cgtwo_burner);
@


1.23
log
@Register more screen capabilities to work with the recent wsemul_sun changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.22 2002/08/12 10:44:03 miod Exp $	*/
a121 5
	0, 0,	/* will be filled in */
	0,
	0, 0,
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
	WSSCREEN_REVERSE | WSSCREEN_WSCOLORS
d268 1
@


1.22
log
@Convert sparc console code from rcons and pseudo-devices to rasops and wscons.
For most framebuffers it is faster.

Other changes include:
o 24 bit support in tcx(4) for the S24 framebuffer
o accelerated cgsix(4) text console
o new cgtwelve(4) driver for the GS framebuffer
o improved serial driver code
o better keyboard support

The following framebuffers have not been tested but should work: cgfour,
cgeight and cgfourteen

These changes will require XF4 changes, to use Xwsfb instead of Xsun*, to be
commited later today.

Most of the work by me during the LSM and the week after, with code borrowed
from jason@@, NetBSD (new serial code), and feedback from mickey@@. Work on
pnozz(4) done by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.21 2002/08/02 16:13:07 millert Exp $	*/
d125 1
@


1.21
log
@Do correct bounds checking in get/set/put cmap routines.  A few of
these check were already OK but have been modified for consistency.
Problem found by Silvio Cesare.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.20 2002/03/14 03:15:59 millert Exp $	*/
d5 24
a91 1
#include <machine/fbio.h>
a93 1
#include <machine/fbvar.h>
d98 8
a105 1
#include <machine/cgtworeg.h>
d110 2
a111 4
	struct	device sc_dev;		/* base device */
	struct	fbdevice sc_fb;		/* frame buffer device */
	struct rom_reg	sc_phys;	/* display RAM (phys addr) */
	int	sc_bustype;		/* type of bus we live on */
d114 21
a134 3
#define sc_redmap(sc)	((sc)->sc_cmap)
#define sc_greenmap(sc)	((sc)->sc_cmap + CG2_CMSIZE)
#define sc_bluemap(sc)	((sc)->sc_cmap + 2 * CG2_CMSIZE)
d137 25
a161 6
/* autoconfiguration driver */
static void	cgtwoattach(struct device *, struct device *, void *);
static int	cgtwomatch(struct device *, void *, void *);
static void	cgtwounblank(struct device *);
int		cgtwogetcmap(struct cgtwo_softc *, struct fbcmap *);
int		cgtwoputcmap(struct cgtwo_softc *, struct fbcmap *);
a170 8
/* frame buffer generic driver */
static struct fbdriver cgtwofbdriver = {
	cgtwounblank, cgtwoopen, cgtwoclose, cgtwoioctl, cgtwommap
};

extern int fbnode;
extern struct tty *fbconstty;

a181 1
#if defined(SUN4)
a182 1
#endif
a188 3
	if (ca->ca_bustype != BUS_VME16)
		return (0);

d192 1
a192 2
#if defined(SUN4)
	if (!CPU_ISSUN4 || cf->cf_unit != 0)
d199 3
a201 3
		return 1;
#endif
	return 0;
d205 1
a205 1
 * Attach a display.  We need to notice if it is the console, too.
d212 4
a215 3
	register struct cgtwo_softc *sc = (struct cgtwo_softc *)self;
	register struct confargs *ca = args;
	register int node = 0;
d219 1
a219 4
	sc->sc_fb.fb_driver = &cgtwofbdriver;
	sc->sc_fb.fb_device = &sc->sc_dev;
	sc->sc_fb.fb_type.fb_type = FBTYPE_SUN2COLOR;
	sc->sc_fb.fb_flags = sc->sc_dev.dv_cfdata->cf_flags;
d232 1
a232 8
	sc->sc_fb.fb_type.fb_depth = 8;
	fb_setsize(&sc->sc_fb, sc->sc_fb.fb_type.fb_depth,
	    1152, 900, node, ca->ca_bustype);

	sc->sc_fb.fb_type.fb_cmsize = 256;
	sc->sc_fb.fb_type.fb_size = round_page(CG2_MAPPED_SIZE);
	printf(": %s, %d x %d", nam,
	    sc->sc_fb.fb_type.fb_width, sc->sc_fb.fb_type.fb_height);
a233 7
	/*
	 * When the ROM has mapped in a cgtwo display, the address
	 * maps only the video RAM, so in any case we have to map the
	 * registers ourselves.  We only need the video RAM if we are
	 * going to print characters via rconsole.
	 */
#if defined(SUN4)
d241 1
a241 3
			isconsole = (fbconstty != NULL);
		else
			isconsole = 0;
d243 6
a248 1
#endif
a251 7
	sc->sc_bustype = ca->ca_bustype;

	if ((sc->sc_fb.fb_pixels = ca->ca_ra.ra_vaddr) == NULL && isconsole) {
		/* this probably cannot happen, but what the heck */
		sc->sc_fb.fb_pixels = mapiodev(&sc->sc_phys, CG2_PIXMAP_OFF,
					       CG2_PIXMAP_SIZE);
	}
d263 15
d279 3
a281 6
		printf(" (console)\n");
#ifdef RASTERCONSOLE
		fbrcons_init(&sc->sc_fb);
#endif
	} else
		printf("\n");
d283 5
a287 2
	if (node == fbnode || CPU_ISSUN4)
		fb_attach(&sc->sc_fb, isconsole);
d291 5
a295 3
cgtwoopen(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
d298 44
a341 1
	int unit = minor(dev);
a342 2
	if (unit >= cgtwo_cd.cd_ndevs || cgtwo_cd.cd_devs[unit] == NULL)
		return (ENXIO);
d347 6
a352 4
cgtwoclose(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
d354 4
d359 6
d368 4
a371 7
int
cgtwoioctl(dev, cmd, data, flags, p)
	dev_t dev;
	u_long cmd;
	register caddr_t data;
	int flags;
	struct proc *p;
d373 1
a373 2
	register struct cgtwo_softc *sc = cgtwo_cd.cd_devs[minor(dev)];
	register struct fbgattr *fba;
d375 2
a376 1
	switch (cmd) {
d378 10
a387 3
	case FBIOGTYPE:
		*(struct fbtype *)data = sc->sc_fb.fb_type;
		break;
d389 7
a395 11
	case FBIOGATTR:
		fba = (struct fbgattr *)data;
		fba->real_type = sc->sc_fb.fb_type.fb_type;
		fba->owner = 0;		/* XXX ??? */
		fba->fbtype = sc->sc_fb.fb_type;
		fba->sattr.flags = 0;
		fba->sattr.emu_type = sc->sc_fb.fb_type.fb_type;
		fba->sattr.dev_specific[0] = -1;
		fba->emu_types[0] = sc->sc_fb.fb_type.fb_type;
		fba->emu_types[1] = -1;
		break;
d397 2
a398 2
	case FBIOGETCMAP:
		return cgtwogetcmap(sc, (struct fbcmap *) data);
d400 4
a403 6
	case FBIOPUTCMAP:
		return cgtwoputcmap(sc, (struct fbcmap *) data);

	case FBIOGVIDEO:
		*(int *)data = sc->sc_reg->video_enab;
		break;
d405 1
a405 8
	case FBIOSVIDEO:
		sc->sc_reg->video_enab = (*(int *)data) & 1;
		break;

	default:
		return (ENOTTY);
	}
	return (0);
d408 4
a411 6
/*
 * Undo the effect of an FBIOSVIDEO that turns the video off.
 */
static void
cgtwounblank(dev)
	struct device *dev;
d413 9
a421 2
	struct cgtwo_softc *sc = (struct cgtwo_softc *)dev;
	sc->sc_reg->video_enab = 1;
a423 2
/*
 */
d425 3
a427 3
cgtwogetcmap(sc, cmap)
	register struct cgtwo_softc *sc;
	register struct fbcmap *cmap;
d429 1
d432 4
a435 8
	u_int start, count, ecount;
	register u_int i;
	register volatile u_short *p;

	start = cmap->index;
	count = cmap->count;
	ecount = start + count;
	if (start >= CG2_CMSIZE || count > CG2_CMSIZE - start)
d441 2
a442 2
	p = &sc_redmap(sc)[start];
	for (i = start; i < ecount; i++)
d444 2
a445 2
	p = &sc_greenmap(sc)[start];
	for (i = start; i < ecount; i++)
d447 2
a448 2
	p = &sc_bluemap(sc)[start];
	for (i = start; i < ecount; i++)
d452 1
a452 1
	if ((error = copyout(red + start, cmap->red, count)) != 0)
d454 1
a454 1
	if ((error = copyout(green + start, cmap->green, count)) != 0)
d456 1
a456 1
	if ((error = copyout(blue + start, cmap->blue, count)) != 0)
a461 2
/*
 */
d463 3
a465 3
cgtwoputcmap(sc, cmap)
	register struct cgtwo_softc *sc;
	register struct fbcmap *cmap;
d467 1
d470 3
a472 8
	u_int start, count, ecount;
	register u_int i;
	register volatile u_short *p;

	start = cmap->index;
	count = cmap->count;
	ecount = start + count;
	if (start >= CG2_CMSIZE || count > CG2_CMSIZE - start)
d476 1
a476 1
	if ((error = copyin(cmap->red, red + start, count)) != 0)
d478 1
a478 1
	if ((error = copyin(cmap->green, green + start, count)) != 0)
d480 1
a480 1
	if ((error = copyin(cmap->blue, blue + start, count)) != 0)
d486 2
a487 2
	p = &sc_redmap(sc)[start];
	for (i = start; i < ecount; i++)
d489 2
a490 2
	p = &sc_greenmap(sc)[start];
	for (i = start; i < ecount; i++)
d492 2
a493 2
	p = &sc_bluemap(sc)[start];
	for (i = start; i < ecount; i++)
d499 5
a503 9
/*
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
 */
paddr_t
cgtwommap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
d505 9
a513 1
	register struct cgtwo_softc *sc = cgtwo_cd.cd_devs[minor(dev)];
d515 2
a516 2
	if (off & PGOFSET)
		panic("cgtwommap");
d518 1
a518 4
	if (off < 0)
		return (-1);
	if ((unsigned)off >= sc->sc_fb.fb_type.fb_size)
		return (-1);
d520 4
a523 1
	return (REG2PHYS(&sc->sc_phys, off) | PMAP_NC);
@


1.20
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.19 2002/03/14 01:26:42 millert Exp $	*/
d344 1
a344 1
	if (start >= CG2_CMSIZE || ecount > CG2_CMSIZE)
d387 1
a387 1
	if (start >= CG2_CMSIZE || ecount > CG2_CMSIZE)
@


1.19
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.18 2001/11/06 19:53:16 miod Exp $	*/
d308 1
a308 1
		sc->sc_reg->video_enab = (*(int*)data) & 1;
@


1.18
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.17 2001/11/01 12:13:46 art Exp $	*/
d93 5
a97 5
static void	cgtwoattach __P((struct device *, struct device *, void *));
static int	cgtwomatch __P((struct device *, void *, void *));
static void	cgtwounblank __P((struct device *));
int		cgtwogetcmap __P((struct cgtwo_softc *, struct fbcmap *));
int		cgtwoputcmap __P((struct cgtwo_softc *, struct fbcmap *));
@


1.18.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.18 2001/11/06 19:53:16 miod Exp $	*/
d93 5
a97 5
static void	cgtwoattach(struct device *, struct device *, void *);
static int	cgtwomatch(struct device *, void *, void *);
static void	cgtwounblank(struct device *);
int		cgtwogetcmap(struct cgtwo_softc *, struct fbcmap *);
int		cgtwoputcmap(struct cgtwo_softc *, struct fbcmap *);
d308 1
a308 1
		sc->sc_reg->video_enab = (*(int *)data) & 1;
@


1.18.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.18.2.1 2002/06/11 03:38:15 art Exp $	*/
a4 24
 * Copyright (c) 2002 Miodrag Vallat.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *
d68 1
d71 1
d76 1
a76 8

#include <sparc/dev/cgtworeg.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>
d81 4
a84 2
	struct	sunfb sc_sunfb;		/* common base part */
	struct	rom_reg	sc_phys;	/* display RAM (phys addr) */
d87 3
a89 17
#define sc_redmap(cmap)		((u_short *)(cmap))
#define sc_greenmap(cmap)	((u_short *)(cmap) + CG2_CMSIZE)
#define sc_bluemap(cmap)	((u_short *)(cmap) + 2 * CG2_CMSIZE)
	int	sc_nscreens;
};

struct wsscreen_descr cgtwo_stdscreen = {
	"std",
};

const struct wsscreen_descr *cgtwo_scrlist[] = {
	&cgtwo_stdscreen,
};

struct wsscreen_list cgtwo_screenlist = {
	sizeof(cgtwo_scrlist) / sizeof(struct wsscreen_descr *),
	    cgtwo_scrlist
d92 6
a97 25
int cgtwo_ioctl(void *, u_long, caddr_t, int, struct proc *);
int cgtwo_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgtwo_free_screen(void *, void *);
int cgtwo_show_screen(void *, void *, int, void (*)(void *, int, int), void *);
paddr_t cgtwo_mmap(void *, off_t, int);
int cgtwo_putcmap(volatile u_short *, struct wsdisplay_cmap *);
int cgtwo_getcmap(volatile u_short *, struct wsdisplay_cmap *);
void cgtwo_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
void cgtwo_burner(void *, u_int, u_int);

struct wsdisplay_accessops cgtwo_accessops = {
	cgtwo_ioctl,
	cgtwo_mmap,
	cgtwo_alloc_screen,
	cgtwo_free_screen,
	cgtwo_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	cgtwo_burner,
};

int cgtwomatch(struct device *, void *, void *);
void cgtwoattach(struct device *, struct device *, void *);
d107 8
d126 1
d128 1
d135 3
d141 2
a142 1
	if (!CPU_ISSUN4 || ca->ca_bustype != BUS_VME16)
d149 3
a151 3
		return (1);

	return (0);
d155 1
a155 1
 * Attach a display.
d162 3
a164 4
	struct cgtwo_softc *sc = (struct cgtwo_softc *)self;
	struct confargs *ca = args;
	struct wsemuldisplaydev_attach_args waa;
	int node = 0;
d168 4
a171 1
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;
d184 8
a191 1
	printf(": %s", nam);
d193 7
d207 3
a209 1
			isconsole = 1;
d211 1
a211 6

	/*
	 * When the ROM has mapped in a cgtwo display, the address
	 * maps only the video RAM, so in any case we have to map the
	 * registers ourselves.
	 */
d215 7
a232 16
	/* enable video */
	cgtwo_burner(sc, 1, 0);

	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, ca->ca_bustype);
	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(&sc->sc_phys, CG2_PIXMAP_OFF,
	    round_page(sc->sc_sunfb.sf_fbsize));
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, isconsole);

	cgtwo_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgtwo_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgtwo_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgtwo_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

	printf(", %dx%d\n", sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);

d234 6
a239 3
		fbwscons_console_init(&sc->sc_sunfb, &cgtwo_stdscreen, -1,
		    cgtwo_setcolor, cgtwo_burner);
	}
d241 2
a242 5
	waa.console = isconsole;
	waa.scrdata = &cgtwo_screenlist;
	waa.accessops = &cgtwo_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
d246 3
a248 5
cgtwo_ioctl(v, cmd, data, flags, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flags;
d251 1
a251 4
	struct cgtwo_softc *sc = v;
	struct wsdisplay_fbinfo *wdf;
	struct wsdisplay_cmap *cm;
	int error;
d253 4
a256 21
	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
		break;
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
		wdf->cmsize = CG2_CMSIZE;
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
		break;
		
	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = cgtwo_getcmap(sc->sc_cmap, cm);
		if (error)
			return (error);
		break;
d258 6
a263 17
	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = cgtwo_putcmap(sc->sc_cmap, cm);
		if (error)
			return (error);
		break;

	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
	default:
		return (-1);	/* not supported yet */
	}
d269 6
a274 6
cgtwo_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
d276 2
a277 1
	struct cgtwo_softc *sc = v;
d279 1
a279 2
	if (sc->sc_nscreens > 0)
		return (ENOMEM);
d281 3
a283 8
	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	sc->sc_nscreens++;
	return (0);
}
d285 11
a295 6
void
cgtwo_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct cgtwo_softc *sc = v;
d297 2
a298 2
	sc->sc_nscreens--;
}
d300 2
a301 10
int
cgtwo_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
	return (0);
}
d303 3
a305 7
paddr_t
cgtwo_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
{
	struct cgtwo_softc *sc = v;
d307 3
a309 2
	if (offset & PGOFSET)
		return (-1);
d311 2
a312 3
	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys,
		    CG2_PIXMAP_OFF + offset) | PMAP_NC);
d314 1
a314 2

	return (-1);
d317 6
a322 4
void
cgtwo_burner(v, on, flags)
	void *v;
	u_int on, flags;
d324 2
a325 9
	struct cgtwo_softc *sc = v;
	int s;

	s = splhigh();
	if (on)
		sc->sc_reg->video_enab = 1;
	else
		sc->sc_reg->video_enab = 0;
	splx(s);
d328 2
d331 3
a333 3
cgtwo_getcmap(hwcmap, cmap)
	volatile u_short *hwcmap;
	struct wsdisplay_cmap *cmap;
a334 1
	u_int index = cmap->index, count = cmap->count, i;
d337 8
a344 4
	volatile u_short *p;


	if (index >= CG2_CMSIZE || count >= CG2_CMSIZE - index)
d350 2
a351 2
	p = &sc_redmap(hwcmap)[index];
	for (i = 0; i < count; i++)
d353 2
a354 2
	p = &sc_greenmap(hwcmap)[index];
	for (i = 0; i < count; i++)
d356 2
a357 2
	p = &sc_bluemap(hwcmap)[index];
	for (i = 0; i < count; i++)
d361 1
a361 1
	if ((error = copyout(red, cmap->red, count)) != 0)
d363 1
a363 1
	if ((error = copyout(green, cmap->green, count)) != 0)
d365 1
a365 1
	if ((error = copyout(blue, cmap->blue, count)) != 0)
d371 2
d374 3
a376 3
cgtwo_putcmap(hwcmap, cmap)
	volatile u_short *hwcmap;
	struct wsdisplay_cmap *cmap;
a377 1
	u_int index = cmap->index, count = cmap->count, i;
d380 8
a387 3
	volatile u_short *p;

	if (index >= CG2_CMSIZE || count >= CG2_CMSIZE - index)
d391 1
a391 1
	if ((error = copyin(cmap->red, red, count)) != 0)
d393 1
a393 1
	if ((error = copyin(cmap->green, green, count)) != 0)
d395 1
a395 1
	if ((error = copyin(cmap->blue, blue, count)) != 0)
d401 2
a402 2
	p = &sc_redmap(hwcmap)[index];
	for (i = 0; i < count; i++)
d404 2
a405 2
	p = &sc_greenmap(hwcmap)[index];
	for (i = 0; i < count; i++)
d407 2
a408 2
	p = &sc_bluemap(hwcmap)[index];
	for (i = 0; i < count; i++)
d414 9
a422 5
void
cgtwo_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
	u_int8_t r, g, b;
d424 1
a424 9
	struct cgtwo_softc *sc = v;
#if 0
	struct wsdisplay_cmap cm;

	cm.red = &r;
	cm.green = &g;
	cm.blue = &b;
	cm.index = index;
	cm.count = 1;
d426 2
a427 2
	cgtwo_putcmap(sc->sc_cmap, &cm);
#else
d429 4
a432 1
	/* XXX - Wait for retrace? */
d434 1
a434 4
	sc_redmap(sc->sc_cmap)[index] = r;
	sc_greenmap(sc->sc_cmap)[index] = g;
	sc_bluemap(sc->sc_cmap)[index] = b;
#endif
@


1.18.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a266 1
	fbwscons_setcolormap(&sc->sc_sunfb, cgtwo_setcolor);
d277 1
a277 1
		    cgtwo_burner);
d302 1
a302 1
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG2;
@


1.17
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.16 2001/09/16 00:42:44 millert Exp $	*/
d66 1
a66 1
#include <vm/vm.h>
@


1.16
log
@Add some missing lengths checks when passing data from userland to
kernel.  From based on NetBSD patches.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.15 2001/08/17 13:52:28 mickey Exp $	*/
d418 1
a418 1
int
d421 2
a422 1
	int off, prot;
@


1.15
log
@cdev_decl cleanup; jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.14 2001/04/06 04:42:05 csapuntz Exp $	*/
d336 2
a337 1
	int error, start, count, ecount;
d379 2
a380 1
	int error, start, count, ecount;
@


1.14
log
@

Move offsetof define into sys/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.13 1999/09/10 23:32:02 art Exp $	*/
a97 3

/* cdevsw prototypes */
cdev_decl(cgtwo);
@


1.14.2.1
log
@MFS (from millert):
Add some missing lengths checks when passing data from userland to
kernel.  From based on NetBSD patches.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.14 2001/04/06 04:42:05 csapuntz Exp $	*/
d339 1
a339 2
	int error;
	u_int start, count, ecount;
d381 1
a381 2
	int error;
	u_int start, count, ecount;
@


1.13
log
@roundup(foo, NBPG) -> round_page(foo)
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.12 1998/11/20 15:57:22 deraadt Exp $	*/
a224 3
#ifndef offsetof
#define	offsetof(type, member)  ((size_t)(&((type *)0)->member))
#endif
@


1.13.8.1
log
@MFC:
Add some missing lengths checks when passing data from userland to the
kernel. From NetBSD via millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.16 2001/09/16 00:42:44 millert Exp $	*/
d342 1
a342 2
	int error;
	u_int start, count, ecount;
d384 1
a384 2
	int error;
	u_int start, count, ecount;
@


1.13.4.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.14 2001/04/06 04:42:05 csapuntz Exp $	*/
d225 3
@


1.13.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.13.4.1 2001/05/14 21:37:03 niklas Exp $	*/
d99 3
d339 1
a339 2
	int error;
	u_int start, count, ecount;
d381 1
a381 2
	int error;
	u_int start, count, ecount;
@


1.13.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d66 1
a66 1
#include <uvm/uvm_extern.h>
d418 1
a418 1
paddr_t
d421 1
a421 2
	off_t off;
	int prot;
@


1.13.4.4
log
@Merge in -current from about a week ago
@
text
@d93 5
a97 5
static void	cgtwoattach(struct device *, struct device *, void *);
static int	cgtwomatch(struct device *, void *, void *);
static void	cgtwounblank(struct device *);
int		cgtwogetcmap(struct cgtwo_softc *, struct fbcmap *);
int		cgtwoputcmap(struct cgtwo_softc *, struct fbcmap *);
d308 1
a308 1
		sc->sc_reg->video_enab = (*(int *)data) & 1;
@


1.13.4.5
log
@Sync the SMP branch with 3.3
@
text
@a4 24
 * Copyright (c) 2002 Miodrag Vallat.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *
d68 1
d71 1
d76 1
a76 8

#include <sparc/dev/cgtworeg.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>
d81 4
a84 2
	struct	sunfb sc_sunfb;		/* common base part */
	struct	rom_reg	sc_phys;	/* display RAM (phys addr) */
d87 3
a89 17
#define sc_redmap(cmap)		((u_short *)(cmap))
#define sc_greenmap(cmap)	((u_short *)(cmap) + CG2_CMSIZE)
#define sc_bluemap(cmap)	((u_short *)(cmap) + 2 * CG2_CMSIZE)
	int	sc_nscreens;
};

struct wsscreen_descr cgtwo_stdscreen = {
	"std",
};

const struct wsscreen_descr *cgtwo_scrlist[] = {
	&cgtwo_stdscreen,
};

struct wsscreen_list cgtwo_screenlist = {
	sizeof(cgtwo_scrlist) / sizeof(struct wsscreen_descr *),
	    cgtwo_scrlist
d92 6
a97 25
int cgtwo_ioctl(void *, u_long, caddr_t, int, struct proc *);
int cgtwo_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgtwo_free_screen(void *, void *);
int cgtwo_show_screen(void *, void *, int, void (*)(void *, int, int), void *);
paddr_t cgtwo_mmap(void *, off_t, int);
int cgtwo_putcmap(volatile u_short *, struct wsdisplay_cmap *);
int cgtwo_getcmap(volatile u_short *, struct wsdisplay_cmap *);
void cgtwo_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
void cgtwo_burner(void *, u_int, u_int);

struct wsdisplay_accessops cgtwo_accessops = {
	cgtwo_ioctl,
	cgtwo_mmap,
	cgtwo_alloc_screen,
	cgtwo_free_screen,
	cgtwo_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	cgtwo_burner,
};

int cgtwomatch(struct device *, void *, void *);
void cgtwoattach(struct device *, struct device *, void *);
d107 8
d126 1
d128 1
d135 3
d141 2
a142 1
	if (!CPU_ISSUN4 || ca->ca_bustype != BUS_VME16)
d149 3
a151 3
		return (1);

	return (0);
d155 1
a155 1
 * Attach a display.
d162 3
a164 4
	struct cgtwo_softc *sc = (struct cgtwo_softc *)self;
	struct confargs *ca = args;
	struct wsemuldisplaydev_attach_args waa;
	int node = 0;
d168 4
a171 1
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;
d184 8
a191 1
	printf(": %s", nam);
d193 7
d207 3
a209 1
			isconsole = 1;
d211 1
a211 6

	/*
	 * When the ROM has mapped in a cgtwo display, the address
	 * maps only the video RAM, so in any case we have to map the
	 * registers ourselves.
	 */
d215 7
a232 17
	/* enable video */
	cgtwo_burner(sc, 1, 0);

	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, ca->ca_bustype);
	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(&sc->sc_phys, CG2_PIXMAP_OFF,
	    round_page(sc->sc_sunfb.sf_fbsize));
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, isconsole);
	fbwscons_setcolormap(&sc->sc_sunfb, cgtwo_setcolor);

	cgtwo_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgtwo_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgtwo_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgtwo_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

	printf(", %dx%d\n", sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);

d234 6
a239 3
		fbwscons_console_init(&sc->sc_sunfb, &cgtwo_stdscreen, -1,
		    cgtwo_burner);
	}
d241 2
a242 5
	waa.console = isconsole;
	waa.scrdata = &cgtwo_screenlist;
	waa.accessops = &cgtwo_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
d246 3
a248 5
cgtwo_ioctl(v, cmd, data, flags, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flags;
d251 1
a251 4
	struct cgtwo_softc *sc = v;
	struct wsdisplay_fbinfo *wdf;
	struct wsdisplay_cmap *cm;
	int error;
d253 4
a256 21
	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
		break;
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
		wdf->cmsize = CG2_CMSIZE;
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
		break;
		
	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = cgtwo_getcmap(sc->sc_cmap, cm);
		if (error)
			return (error);
		break;
d258 6
a263 17
	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = cgtwo_putcmap(sc->sc_cmap, cm);
		if (error)
			return (error);
		break;

	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
	default:
		return (-1);	/* not supported yet */
	}
d269 6
a274 6
cgtwo_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
d276 2
a277 1
	struct cgtwo_softc *sc = v;
d279 1
a279 2
	if (sc->sc_nscreens > 0)
		return (ENOMEM);
d281 3
a283 8
	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	sc->sc_nscreens++;
	return (0);
}
d285 11
a295 6
void
cgtwo_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct cgtwo_softc *sc = v;
d297 2
a298 2
	sc->sc_nscreens--;
}
d300 2
a301 10
int
cgtwo_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
	return (0);
}
d303 3
a305 7
paddr_t
cgtwo_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
{
	struct cgtwo_softc *sc = v;
d307 3
a309 2
	if (offset & PGOFSET)
		return (-1);
d311 2
a312 3
	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys,
		    CG2_PIXMAP_OFF + offset) | PMAP_NC);
d314 1
a314 2

	return (-1);
d317 6
a322 4
void
cgtwo_burner(v, on, flags)
	void *v;
	u_int on, flags;
d324 2
a325 9
	struct cgtwo_softc *sc = v;
	int s;

	s = splhigh();
	if (on)
		sc->sc_reg->video_enab = 1;
	else
		sc->sc_reg->video_enab = 0;
	splx(s);
d328 2
d331 3
a333 3
cgtwo_getcmap(hwcmap, cmap)
	volatile u_short *hwcmap;
	struct wsdisplay_cmap *cmap;
a334 1
	u_int index = cmap->index, count = cmap->count, i;
d337 8
a344 4
	volatile u_short *p;


	if (index >= CG2_CMSIZE || count >= CG2_CMSIZE - index)
d350 2
a351 2
	p = &sc_redmap(hwcmap)[index];
	for (i = 0; i < count; i++)
d353 2
a354 2
	p = &sc_greenmap(hwcmap)[index];
	for (i = 0; i < count; i++)
d356 2
a357 2
	p = &sc_bluemap(hwcmap)[index];
	for (i = 0; i < count; i++)
d361 1
a361 1
	if ((error = copyout(red, cmap->red, count)) != 0)
d363 1
a363 1
	if ((error = copyout(green, cmap->green, count)) != 0)
d365 1
a365 1
	if ((error = copyout(blue, cmap->blue, count)) != 0)
d371 2
d374 3
a376 3
cgtwo_putcmap(hwcmap, cmap)
	volatile u_short *hwcmap;
	struct wsdisplay_cmap *cmap;
a377 1
	u_int index = cmap->index, count = cmap->count, i;
d380 8
a387 3
	volatile u_short *p;

	if (index >= CG2_CMSIZE || count >= CG2_CMSIZE - index)
d391 1
a391 1
	if ((error = copyin(cmap->red, red, count)) != 0)
d393 1
a393 1
	if ((error = copyin(cmap->green, green, count)) != 0)
d395 1
a395 1
	if ((error = copyin(cmap->blue, blue, count)) != 0)
d401 2
a402 2
	p = &sc_redmap(hwcmap)[index];
	for (i = 0; i < count; i++)
d404 2
a405 2
	p = &sc_greenmap(hwcmap)[index];
	for (i = 0; i < count; i++)
d407 2
a408 2
	p = &sc_bluemap(hwcmap)[index];
	for (i = 0; i < count; i++)
d414 9
a422 5
void
cgtwo_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
	u_int8_t r, g, b;
d424 1
a424 9
	struct cgtwo_softc *sc = v;
#if 0
	struct wsdisplay_cmap cm;

	cm.red = &r;
	cm.green = &g;
	cm.blue = &b;
	cm.index = index;
	cm.count = 1;
d426 2
a427 2
	cgtwo_putcmap(sc->sc_cmap, &cm);
#else
d429 4
a432 1
	/* XXX - Wait for retrace? */
d434 1
a434 4
	sc_redmap(sc->sc_cmap)[index] = r;
	sc_greenmap(sc->sc_cmap)[index] = g;
	sc_bluemap(sc->sc_cmap)[index] = b;
#endif
@


1.13.4.6
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d303 1
a303 1
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG2;
@


1.13.4.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.13.4.6 2003/05/16 00:29:40 niklas Exp $	*/
d49 5
a53 1
 * 3. Neither the name of the University nor the names of its contributors
d180 5
d214 2
@


1.13.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d255 1
a255 1
	fbwscons_init(&sc->sc_sunfb, isconsole ? 0 : RI_CLEAR);
@


1.12
log
@careful off handling in mmap routines
@
text
@d1 1
a1 1
/*	$OpenBSD: cgtwo.c,v 1.11 1997/08/08 08:24:55 downsj Exp $	*/
d192 1
a192 1
	sc->sc_fb.fb_type.fb_size = roundup(CG2_MAPPED_SIZE, NBPG);
@


1.11
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d432 2
@


1.10
log
@Revert back to Theo's eeprom.h.
@
text
@d2 1
a2 1
/*	$NetBSD: cgtwo.c,v 1.16 1996/05/18 12:19:14 mrg Exp $ */
a94 4
int		cgtwoopen __P((dev_t, int, int, struct proc *));
int		cgtwoclose __P((dev_t, int, int, struct proc *));
int		cgtwoioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int		cgtwommap __P((dev_t, int, int));
d99 3
d150 1
a150 1
	tmp = (caddr_t)bus_tmp(ra->ra_paddr + CG2_CTLREG_OFF, ca->ca_bustype);
d209 1
a209 1
		if (eep == NULL || eep->ee_diag.eed_console == EED_CONS_COLOR)
d216 2
d222 2
a223 3
		sc->sc_fb.fb_pixels = mapiodev(ca->ca_ra.ra_reg, CG2_PIXMAP_OFF,
					       CG2_PIXMAP_SIZE,
					       PMAP_VME32/*ca->ca_bustype*/);
d232 1
a232 1
		     sizeof(struct cg2statusreg), ca->ca_bustype);
d237 1
a237 1
		     3 * CG2_CMSIZE, ca->ca_bustype);
d435 1
a435 1
	return (REG2PHYS(&sc->sc_phys, off, PMAP_VME32/*sc->sc_bustype*/) | PMAP_NC);
@


1.9
log
@netbsd port, now we merge our changes back in
@
text
@d1 1
d210 1
a210 1
		if (eep == NULL || eep->eeConsole == EE_CONS_COLOR)
@


1.8
log
@cgtwo only exists on vmes; and thus only sun4 (we will deal with
the sun4/600 later)
@
text
@d1 1
a1 1
/*	$NetBSD: cgtwo.c,v 1.5 1995/10/08 01:39:15 pk Exp $ */
d56 1
d63 1
d71 1
d73 3
a76 1
#include <machine/cgtworeg.h>
d99 2
d102 6
a107 3
struct cfdriver cgtwocd = {
	NULL, "cgtwo", cgtwomatch, cgtwoattach,
	DV_DULL, sizeof(struct cgtwo_softc)
a117 2
static void cgtwoloadcmap __P((struct cgtwo_softc *, int, int));

d129 1
a129 1
	int probe;
d131 9
d144 4
d153 2
a154 1
	return (0);
d167 3
a169 5
	register int node = 0, i;
	register struct cgtwo_all *p;
	struct eeprom *eep = (struct eeprom *)eeprom_va;
	int isconsole;
	char *nam;
d174 12
d193 2
a194 2
	printf(": cgtwo, %d x %d", sc->sc_fb.fb_type.fb_width,
	    sc->sc_fb.fb_type.fb_height);
d202 13
a214 5
	if (eep == NULL || eep->ee_diag.eed_console == EED_CONS_COLOR)
		isconsole = (fbconstty != NULL);
	else
		isconsole = 0;

d221 2
a222 1
		    CG2_PIXMAP_SIZE, ca->ca_bustype);
d228 9
a236 7
	sc->sc_reg = (volatile struct cg2statusreg *)mapiodev(ca->ca_ra.ra_reg,
	    CG2_ROPMEM_OFF + offsetof(struct cg2fb, status.reg),
	    sizeof(struct cg2statusreg), ca->ca_bustype);

	sc->sc_cmap = (volatile u_short *)mapiodev(ca->ca_ra.ra_reg,
	    CG2_ROPMEM_OFF + offsetof(struct cg2fb, redmap[0]),
	    3 * CG2_CMSIZE, ca->ca_bustype);
d245 3
a247 2
	if (isconsole)
		fb_attach(&sc->sc_fb);
d258 1
a258 1
	if (unit >= cgtwocd.cd_ndevs || cgtwocd.cd_devs[unit] == NULL)
d281 1
a281 1
	register struct cgtwo_softc *sc = cgtwocd.cd_devs[minor(dev)];
a282 1
	int error;
d303 1
a303 1
		return cgtwogetcmap(sc, data);
d306 1
a306 1
		return cgtwoputcmap(sc, data);
a329 1

d426 1
a426 1
	register struct cgtwo_softc *sc = cgtwocd.cd_devs[minor(dev)];
d434 1
a434 1
	return (REG2PHYS(&sc->sc_phys, off, PMAP_VME32) | PMAP_NC);
@


1.7
log
@new mapdev/()/mapiodev() calling convention uses "struct rom_reg *" to supply
base plus an offset
new dvma routines
@
text
@a68 1
#if defined(SUN4)
a69 1
#endif
a126 4
#if defined(SUN4)
	if (cputyp != CPU_SUN4 || cf->cf_unit != 0)
		return (0);

a131 1
#endif
d147 1
d170 5
a174 13
#if defined(SUN4)
	if (cputyp == CPU_SUN4) {
		struct eeprom *eep = (struct eeprom *)eeprom_va;
		/*
		 * Assume this is the console if there's no eeprom info
		 * to be found.
		 */
		if (eep == NULL || eep->ee_diag.eed_console == EED_CONS_COLOR)
			isconsole = (fbconstty != NULL);
		else
			isconsole = 0;
	}
#endif
d198 1
a198 2
		if (ca->ca_bustype != BUS_PFOUR)
			fbrcons_init(&sc->sc_fb);
d202 1
a202 2
	if ((node == fbnode && cputyp != CPU_SUN4) ||
	    (isconsole && cputyp == CPU_SUN4))
@


1.6
log
@rcons does NOT work on p4 bwtwo/cgtwo, probably because of alignment problems?
@
text
@d79 2
a80 1
	caddr_t	sc_phys;		/* display RAM (phys addr) */
d189 3
a191 1
	sc->sc_phys = (caddr_t)ca->ca_ra.ra_paddr;
d194 1
a194 1
		sc->sc_fb.fb_pixels = mapiodev(sc->sc_phys + CG2_PIXMAP_OFF,
d201 7
a207 9
	sc->sc_reg = (volatile struct cg2statusreg *)
	    mapiodev((caddr_t)sc->sc_phys +
		CG2_ROPMEM_OFF + offsetof(struct cg2fb, status.reg),
		sizeof(struct cg2statusreg), ca->ca_bustype);

	sc->sc_cmap = (volatile u_short *)
	    mapiodev((caddr_t)sc->sc_phys +
		CG2_ROPMEM_OFF + offsetof(struct cg2fb, redmap[0]),
		3 * CG2_CMSIZE, ca->ca_bustype);
d408 1
a408 1
	return ((int)sc->sc_phys + off + PMAP_VME32 + PMAP_NC);
@


1.5
log
@correct sun4 calls to fb_attach()
@
text
@d211 2
a212 1
		fbrcons_init(&sc->sc_fb);
@


1.4
log
@can map pixels in VME32 space
@
text
@d215 2
a216 1
	if (node == fbnode)
@


1.3
log
@cannot exist on sbus
@
text
@d405 1
a405 1
	return ((int)sc->sc_phys + off + PMAP_VME16 + PMAP_NC);
@


1.2
log
@use new eeprom.h
@
text
@a73 1
#include <sparc/dev/sbusvar.h>
a77 1
	struct	sbusdev sc_sd;		/* sbus device */
d88 2
a89 2
static void	cgtwoattach(struct device *, struct device *, void *);
static int	cgtwomatch(struct device *, void *, void *);
d94 1
a94 1
static void	cgtwounblank(struct device *);
a107 2
extern int nullop();
static int cgtwo_cnputc();
a124 3
	if (ca->ca_bustype != BUS_VME16)
		return (0);

d138 1
a138 1
	return 0;
d151 1
a151 1
	register int node, i;
a153 1
	int sbus = 1;
a159 11
	switch (ca->ca_bustype) {
	case BUS_VME16:
		sbus = node = 0;
		nam = "cgtwo";
		break;

	default:
		panic("cgtwoattach: impossible bustype");
		/* NOTREACHED */
	}

d166 2
a167 2
	printf(": %s, %d x %d", nam,
	    sc->sc_fb.fb_type.fb_width, sc->sc_fb.fb_type.fb_height);
a187 4
#if defined(SUN4C) || defined(SUN4M)
	if (cputyp == CPU_SUN4C || cputyp == CPU_SUN4M)
		isconsole = node == fbnode && fbconstty != NULL;
#endif
a214 2
	if (sbus)
		sbus_establish(&sc->sc_sd, &sc->sc_dev);
d300 1
@


1.1
log
@Initial revision
@
text
@d201 1
a201 1
		if (eep == NULL || eep->eeConsole == EE_CONS_COLOR)
d215 1
a215 2
					       CG2_PIXMAP_SIZE,
					       ca->ca_bustype);
d223 2
a224 2
		     CG2_ROPMEM_OFF + offsetof(struct cg2fb, status.reg),
		     sizeof(struct cg2statusreg), ca->ca_bustype);
d228 2
a229 2
		     CG2_ROPMEM_OFF + offsetof(struct cg2fb, redmap[0]),
		     3 * CG2_CMSIZE, ca->ca_bustype);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
