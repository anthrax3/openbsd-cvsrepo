head	1.38;
access;
symbols
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.36.0.6
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.35.0.4
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.33.0.6
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.4
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.2
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.8
	OPENBSD_5_0:1.31.0.6
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.4
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.2
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.29.0.12
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.8
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.6
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.4
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.29.0.2
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.28.0.4
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.26.0.4
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.23.0.6
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	OPENBSD_3_5:1.23.0.4
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.20.0.4
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.20
	UBC:1.18.0.4
	UBC_BASE:1.18
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_8:1.16.0.10
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.16.0.8
	OPENBSD_2_7_BASE:1.16
	SMP:1.16.0.6
	SMP_BASE:1.16
	kame_19991208:1.16
	OPENBSD_2_6:1.16.0.4
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.16.0.2
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.6.0.4
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.38
date	2015.12.10.19.48.04;	author mmcc;	state Exp;
branches;
next	1.37;
commitid	IegoPc6ss7aut6L1;

1.37
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.36;
commitid	6vhYvh5CxZAHMnsN;

1.36
date	2014.12.22.02.26.54;	author tedu;	state Exp;
branches;
next	1.35;
commitid	2Ez9mHW0jDzojG4V;

1.35
date	2014.07.28.18.31.39;	author miod;	state Exp;
branches;
next	1.34;
commitid	KwJ20CkzgJkW6nEl;

1.34
date	2013.09.24.20.10.49;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2012.07.30.16.58.19;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2012.07.25.18.18.59;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2010.07.10.19.32.24;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.26.20.17.27;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.29.09.54.09;	author sobrado;	state Exp;
branches;
next	1.28;

1.28
date	2006.06.02.20.00.54;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2006.06.02.19.58.32;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2005.04.19.21.30.19;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2005.02.27.22.01.04;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2004.09.29.07.35.11;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.04.22.08.17;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2003.05.22.07.28.11;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.05.14.23.35.30;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2002.04.30.01.12.29;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.01.26.43;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.11.00.29.49;	author miod;	state Exp;
branches
	1.18.4.1;
next	1.17;

1.17
date	2001.01.15.23.23.57;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	99.02.28.19.12.34;	author jason;	state Exp;
branches
	1.16.6.1;
next	1.15;

1.15
date	98.12.22.15.40.30;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	98.12.13.21.47.09;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.11.11.00.50.31;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	98.09.28.05.15.57;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	98.09.19.15.11.50;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	98.09.18.20.27.15;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.09.16.22.41.18;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	97.09.17.06.47.09;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.08.08.08.25.12;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.08.11.05.34.21;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	95.12.15.13.53.06;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.10.23.15.27.38;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.10.23.12.36.33;	author davem;	state Exp;
branches;
next	1.2;

1.2
date	95.10.18.17.15.19;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.39;	author deraadt;	state Exp;
branches;
next	;

1.16.6.1
date	2001.05.14.21.37.06;	author niklas;	state Exp;
branches;
next	1.16.6.2;

1.16.6.2
date	2001.07.04.10.23.25;	author niklas;	state Exp;
branches;
next	1.16.6.3;

1.16.6.3
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.16.6.4;

1.16.6.4
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.16.6.5;

1.16.6.5
date	2003.05.16.00.29.40;	author niklas;	state Exp;
branches;
next	1.16.6.6;

1.16.6.6
date	2003.06.07.11.14.43;	author ho;	state Exp;
branches;
next	;

1.18.4.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	1.18.4.2;

1.18.4.2
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Remove remaining Solbourne code.

ok deraadt@@
@
text
@/*	$OpenBSD: if_le.c,v 1.37 2015/09/11 13:02:28 stsp Exp $	*/
/*	$NetBSD: if_le.c,v 1.50 1997/09/09 20:54:48 pk Exp $	*/

/*-
 * Copyright (c) 1997 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1996
 *	The President and Fellows of Harvard College. All rights reserved.
 * Copyright (c) 1995 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell and Rick Macklem.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Aaron Brown and
 *	Harvard University.
 *	This product includes software developed for the NetBSD Project
 *	by Jason R. Thorpe.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)if_le.c	8.2 (Berkeley) 11/16/93
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/syslog.h>
#include <sys/socket.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>

#include <sparc/dev/sbusvar.h>
#include <sparc/dev/dmareg.h>
#include <sparc/dev/dmavar.h>
#include <sparc/dev/lebuffervar.h>

#include <dev/ic/lancereg.h>
#include <dev/ic/lancevar.h>
#include <dev/ic/am7990reg.h>
#include <dev/ic/am7990var.h>

#include <sparc/dev/if_lereg.h>
#include <sparc/dev/if_levar.h>

int	lematch(struct device *, void *, void *);
void	leattach(struct device *, struct device *, void *);

/*
 * ifmedia interfaces
 */
int	lemediachange(struct lance_softc *);
void	lemediastatus(struct lance_softc *, struct ifmediareq *);

#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
static uint64_t lebufmedia[] = {
	IFM_ETHER | IFM_10_T
};
#endif
#if defined(SUN4M)
static uint64_t ledmamedia[] = {
	IFM_ETHER | IFM_10_T,
	IFM_ETHER | IFM_10_5,
	IFM_ETHER | IFM_AUTO
};
#endif
static uint64_t lebaremedia[] = {
	IFM_ETHER | IFM_10_5
};

#if defined(SUN4M)
/*
 * media change methods (only for sun4m)
 */
void	lesetutp(struct lance_softc *);
void	lesetaui(struct lance_softc *);
#endif /* SUN4M */

#if defined(SUN4M)	/* XXX */
int	myleintr(void *);
int	ledmaintr(struct dma_softc *);

int
myleintr(void *arg)
{
	struct le_softc *lesc = arg;
	static int dodrain=0;

	if (lesc->sc_dma->sc_regs->csr & D_ERR_PEND) {
		dodrain = 1;
		return ledmaintr(lesc->sc_dma);
	}

	if (dodrain) {	/* XXX - is this necessary with D_DSBL_WRINVAL on? */
		int i = 10;
		while (i-- > 0 && (lesc->sc_dma->sc_regs->csr & D_DRAINING))
			delay(1);
	}

	return (am7990_intr(arg));
}
#endif

struct cfattach le_ca = {
	sizeof(struct le_softc), lematch, leattach
};

void	lewrcsr(struct lance_softc *, uint16_t, uint16_t);
uint16_t lerdcsr(struct lance_softc *, uint16_t);
void	lehwreset(struct lance_softc *);
void	lehwinit(struct lance_softc *);
#if defined(SUN4M)
void	lenocarrier(struct lance_softc *);
#endif

void
lewrcsr(struct lance_softc *sc, uint16_t port, uint16_t val)
{
	struct lereg1 *ler1 = ((struct le_softc *)sc)->sc_r1;
#if defined(SUN4M)
	volatile uint16_t discard;
#endif

	ler1->ler1_rap = port;
	ler1->ler1_rdp = val;
#if defined(SUN4M)
	/* 
	 * We need to flush the SBus->MBus write buffers. This can most
	 * easily be accomplished by reading back the register that we
	 * just wrote (thanks to Chris Torek for this solution).
	 */	   
	if (CPU_ISSUN4M)
		discard = ler1->ler1_rdp;
#endif
}

uint16_t
lerdcsr(struct lance_softc *sc, uint16_t port)
{
	struct lereg1 *ler1 = ((struct le_softc *)sc)->sc_r1;
	uint16_t val;

	ler1->ler1_rap = port;
	val = ler1->ler1_rdp;
	return (val);
}

#if defined(SUN4M)
void
lesetutp(struct lance_softc *sc)
{
	struct le_softc *lesc = (struct le_softc *)sc;
	u_int32_t csr;
	int tries = 5;

	while (--tries) {
		csr = lesc->sc_dma->sc_regs->csr;
		csr |= E_TP_AUI;
		lesc->sc_dma->sc_regs->csr = csr;
		delay(20000);	/* must not touch le for 20ms */
		if (lesc->sc_dma->sc_regs->csr & E_TP_AUI)
			return;
	}
}

void
lesetaui(struct lance_softc *sc)
{
	struct le_softc *lesc = (struct le_softc *)sc;
	u_int32_t csr;
	int tries = 5;

	while (--tries) {
		csr = lesc->sc_dma->sc_regs->csr;
		csr &= ~E_TP_AUI;
		lesc->sc_dma->sc_regs->csr = csr;
		delay(20000);	/* must not touch le for 20ms */
		if ((lesc->sc_dma->sc_regs->csr & E_TP_AUI) == 0)
			return;
	}
}
#endif

int
lemediachange(struct lance_softc *sc)
{
	struct ifmedia *ifm = &sc->sc_ifmedia;
#if defined(SUN4M)
	struct le_softc *lesc = (struct le_softc *)sc;
#endif

	if (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)
		return (EINVAL);

	/*
	 * Switch to the selected media.  If autoselect is
	 * set, we don't really have to do anything.  We'll
	 * switch to the other media when we detect loss of
	 * carrier.
	 */
	switch (IFM_SUBTYPE(ifm->ifm_media)) {
#if defined(SUN4M)
	case IFM_10_T:
		if (CPU_ISSUN4M && lesc->sc_dma)
			lesetutp(sc);
		else
			return (EOPNOTSUPP);
		break;

	case IFM_AUTO:
		if (CPU_ISSUN4M && lesc->sc_dma)
			return (0);
		else
			return (EOPNOTSUPP);
		break;
#endif

	case IFM_10_5:
#if defined(SUN4M)
		if (CPU_ISSUN4M && lesc->sc_dma)
			lesetaui(sc);
#else
		return (0);
#endif
		break;


	default:
		return (EINVAL);
	}

	return (0);
}

void
lemediastatus(struct lance_softc *sc, struct ifmediareq *ifmr)
{
#if defined(SUN4M)
	struct le_softc *lesc = (struct le_softc *)sc;

	if (lesc->sc_dma == NULL) {
		if (lesc->sc_lebufchild)
			ifmr->ifm_active = IFM_ETHER | IFM_10_T;
		else
			ifmr->ifm_active = IFM_ETHER | IFM_10_5;
		return;
	}

	if (CPU_ISSUN4M) {
		/*
		 * Notify the world which media we're currently using.
		 */
		if (lesc->sc_dma->sc_regs->csr & E_TP_AUI)
			ifmr->ifm_active = IFM_ETHER | IFM_10_T;
		else
			ifmr->ifm_active = IFM_ETHER | IFM_10_5;
	} else
		ifmr->ifm_active = IFM_ETHER | IFM_10_5;
#else
	ifmr->ifm_active = IFM_ETHER | IFM_10_5;
#endif
}

void
lehwreset(struct lance_softc *sc)
{
#if defined(SUN4M) 
	struct le_softc *lesc = (struct le_softc *)sc;

	/*
	 * Reset DMA channel.
	 */
	if (CPU_ISSUN4M && lesc->sc_dma) {
		u_int32_t aui;

		aui = lesc->sc_dma->sc_regs->csr & E_TP_AUI;
		DMA_RESET(lesc->sc_dma);
		lesc->sc_dma->sc_regs->en_bar = lesc->sc_laddr & 0xff000000;
		DMA_ENINTR(lesc->sc_dma);
#define D_DSBL_WRINVAL D_DSBL_SCSI_DRN	/* XXX: fix dmareg.h */
		/* Disable E-cache invalidates on chip writes */
		lesc->sc_dma->sc_regs->csr |= D_DSBL_WRINVAL | aui;
		delay(20000);	/* must not touch le for 20ms */
	}
#endif
}

void
lehwinit(struct lance_softc *sc)
{
#if defined(SUN4M) 
	struct le_softc *lesc = (struct le_softc *)sc;

	if (CPU_ISSUN4M && lesc->sc_dma) {
		switch (IFM_SUBTYPE(sc->sc_ifmedia.ifm_cur->ifm_media)) {
		case IFM_10_T:
			lesetutp(sc);
			break;

		case IFM_10_5:
			lesetaui(sc);
			break;

		case IFM_AUTO:
			lesetutp(sc);
			break;

		default:	/* XXX shouldn't happen */
			lesetutp(sc);
			break;
		}
	}
#endif
}

#if defined(SUN4M)
void
lenocarrier(struct lance_softc *sc)
{
	struct le_softc *lesc = (struct le_softc *)sc;

	if (lesc->sc_dma) {
		/* 
		 * Check if the user has requested a certain cable type, and
		 * if so, honor that request.
		 */
		if (lesc->sc_dma->sc_regs->csr & E_TP_AUI) {
			switch (IFM_SUBTYPE(sc->sc_ifmedia.ifm_media)) {
			case IFM_10_5:
			case IFM_AUTO:
				printf("%s: lost carrier on UTP port"
				    ", switching to AUI port\n",
				    sc->sc_dev.dv_xname);
				lesetaui(sc);
			}
		} else {
			switch (IFM_SUBTYPE(sc->sc_ifmedia.ifm_media)) {
			case IFM_10_T:
			case IFM_AUTO:
				printf("%s: lost carrier on AUI port"
				    ", switching to UTP port\n",
				    sc->sc_dev.dv_xname);
				lesetutp(sc);
			}
		}
	}
}
#endif

int
lematch(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
		return (0);
#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	if (ca->ca_bustype == BUS_SBUS) {
		if (!sbus_testdma((struct sbus_softc *)parent, ca))
			return (0);
		return (1);
	}
#endif

	return (probeget(ra->ra_vaddr, 2) != -1);
}

void
leattach(struct device *parent, struct device *self, void *aux)
{
	struct le_softc *lesc = (struct le_softc *)self;
	struct lance_softc *sc = &lesc->sc_am7990.lsc;
	struct confargs *ca = aux;
	int pri;
	struct bootpath *bp;
#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	int sbuschild = strcmp(parent->dv_cfdata->cf_driver->cd_name, "sbus") == 0;
	int lebufchild = strcmp(parent->dv_cfdata->cf_driver->cd_name, "lebuffer") == 0;
	int dmachild = strcmp(parent->dv_cfdata->cf_driver->cd_name, "ledma") == 0;
	struct lebuf_softc *lebuf;
#endif

	/* XXX the following declarations should be elsewhere */
	extern void myetheraddr(u_char *);

	if (ca->ca_ra.ra_nintr != 1) {
		printf(": expected 1 interrupt, got %d\n", ca->ca_ra.ra_nintr);
		return;
	}
	pri = ca->ca_ra.ra_intr[0].int_pri;
	printf(" pri %d", pri);

#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	lesc->sc_lebufchild = lebufchild;
#endif

	lesc->sc_r1 = (struct lereg1 *)
		mapiodev(ca->ca_ra.ra_reg, 0, sizeof(struct lereg1));

#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	lebuf = NULL;
	if (lebufchild) {
		lebuf = (struct lebuf_softc *)parent;
	} else if (sbuschild) {
		extern struct cfdriver lebuffer_cd;
		struct lebuf_softc *lebufsc;
		int i;

		for (i = 0; i < lebuffer_cd.cd_ndevs; i++) {
			lebufsc = (struct lebuf_softc *)lebuffer_cd.cd_devs[i];
			if (lebufsc == NULL || lebufsc->attached != 0)
				continue;

			lebuf = lebufsc;
			break;
		}
	}
	if (lebuf != NULL) {
		sc->sc_mem = lebuf->sc_buffer;
		sc->sc_memsize = lebuf->sc_bufsiz;
		sc->sc_addr = 0; /* Lance view is offset by buffer location */
		lebuf->attached = 1;

		/* That old black magic... */
		sc->sc_conf3 = getpropint(ca->ca_ra.ra_node,
			 	"busmaster-regval",
				LE_C3_BSWP | LE_C3_ACON | LE_C3_BCON);
	} else
#endif
	{
		u_long laddr;

#if defined(SUN4) || defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
		if (sbuschild && CPU_ISSUN4DOR4M)
			laddr = (u_long)dvma_malloc_space(MEMSIZE,
			     &sc->sc_mem, M_NOWAIT, M_SPACE_D24);
		else
#endif
			laddr = (u_long)dvma_malloc(MEMSIZE,
			     &sc->sc_mem, M_NOWAIT);
#endif	/* SUN4 || SUN4C || SUN4D || SUN4E || SUN4M */
#if defined(SUN4D) || defined (SUN4M)
		if ((laddr & 0xffffff) >= (laddr & 0xffffff) + MEMSIZE)
			panic("if_le: Lance buffer crosses 16MB boundary");
#endif
			sc->sc_addr = laddr & 0xffffff;
		sc->sc_memsize = MEMSIZE;
			sc->sc_conf3 = LE_C3_BSWP | LE_C3_ACON | LE_C3_BCON;
#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
		if (dmachild) {
			lesc->sc_dma = (struct dma_softc *)parent;
			lesc->sc_dma->sc_le = lesc;
			lesc->sc_laddr = laddr;
		}
#endif
	}

	bp = ca->ca_ra.ra_bp;
	switch (ca->ca_bustype) {
#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
#define SAME_LANCE(bp, ca) \
	((bp->val[0] == ca->ca_slot && bp->val[1] == ca->ca_offset) || \
	 (bp->val[0] == -1 && bp->val[1] == sc->sc_dev.dv_unit))

	case BUS_SBUS:
		if (bp != NULL && strcmp(bp->name, le_cd.cd_name) == 0 &&
		    SAME_LANCE(bp, ca))
			bp->dev = &sc->sc_dev;
		break;
#endif /* SUN4C || SUN4D || SUN4E || SUN4M */

	default:
		if (bp != NULL && strcmp(bp->name, le_cd.cd_name) == 0 &&
		    sc->sc_dev.dv_unit == bp->val[1])
			bp->dev = &sc->sc_dev;
		break;
	}

	myetheraddr(sc->sc_arpcom.ac_enaddr);

	sc->sc_copytodesc = lance_copytobuf_contig;
	sc->sc_copyfromdesc = lance_copyfrombuf_contig;
	sc->sc_copytobuf = lance_copytobuf_contig;
	sc->sc_copyfrombuf = lance_copyfrombuf_contig;
	sc->sc_zerobuf = lance_zerobuf_contig;

	sc->sc_rdcsr = lerdcsr;
	sc->sc_wrcsr = lewrcsr;
	sc->sc_hwinit = lehwinit;
#if defined(SUN4M)
	if (CPU_ISSUN4M)
		sc->sc_nocarrier = lenocarrier;
#endif
	sc->sc_hwreset = lehwreset;

	sc->sc_mediachange = lemediachange;
	sc->sc_mediastatus = lemediastatus;
#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	if (lebufchild) {
		sc->sc_supmedia = lebufmedia;
		sc->sc_nsupmedia = nitems(lebufmedia);
		sc->sc_defaultmedia = sc->sc_supmedia[sc->sc_nsupmedia - 1];
	} else
#endif
#if defined(SUN4M)
	if (CPU_ISSUN4M && lesc->sc_dma) {
		sc->sc_supmedia = ledmamedia;
		sc->sc_nsupmedia = nitems(ledmamedia);
		sc->sc_defaultmedia = lesc->sc_dma->sc_defaultmedia;
	} else
#endif
	{
		sc->sc_supmedia = lebaremedia;
		sc->sc_nsupmedia = nitems(lebaremedia);
		sc->sc_defaultmedia = sc->sc_supmedia[sc->sc_nsupmedia - 1];
	}

	am7990_config(&lesc->sc_am7990);

	lesc->sc_ih.ih_fun = am7990_intr;
#if defined(SUN4M) /*XXX*/
	if (CPU_ISSUN4M && lesc->sc_dma)
		lesc->sc_ih.ih_fun = myleintr;
#endif
	lesc->sc_ih.ih_arg = sc;
	intr_establish(pri, &lesc->sc_ih, IPL_NET, self->dv_xname);

	/* now initialize DMA */
	lehwreset(sc);
}
@


1.37
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.36 2014/12/22 02:26:54 tedu Exp $	*/
a79 6
#ifdef solbourne
#include <sparc/sparc/asm.h>
#include <machine/idt.h>
#include <machine/kap.h>
#endif

a148 4
#if defined(solbourne)
void	kap_copytobuf(struct lance_softc *, void *, int, int);
void	kap_copyfrombuf(struct lance_softc *, void *, int, int);
#endif
a392 5
#if defined(solbourne)
	if (CPU_ISKAP) {
		return (ca->ca_bustype == BUS_OBIO);
	}
#endif
a468 20
#if defined(solbourne)
		if (CPU_ISKAP && ca->ca_bustype == BUS_OBIO) {
			/*
			 * Use the fixed buffer allocated in pmap_bootstrap().
			 * for now, until I get the iCU translation to work...
			 */
			extern vaddr_t lance_va;

			laddr = PTW1_TO_PHYS(lance_va);
			sc->sc_mem = (void *)PHYS_TO_PTW2(laddr);

			/* disable ICU translations for ethernet */
			sta(ICU_TER, ASI_PHYS_IO,
			    lda(ICU_TER, ASI_PHYS_IO) & ~TER_ETHERNET);

			/* stash the high 15 bits of the physical address */
			sta(SE_BASE + 0x18, ASI_PHYS_IO,
			    laddr & 0xfffe0000);
		} /* else */
#endif	/* solbourne */
a482 5
#if defined(solbourne)
		if (CPU_ISKAP && ca->ca_bustype == BUS_OBIO)
			sc->sc_addr = laddr & 0x01ffff;
		else
#endif
a484 5
#if defined(solbourne)
		if (CPU_ISKAP && ca->ca_bustype == BUS_OBIO)
			sc->sc_conf3 = LE_C3_BSWP;
		else
#endif
a556 11
#if defined(solbourne)
	if (CPU_ISKAP && ca->ca_bustype == BUS_OBIO) {
		sc->sc_copytodesc = kap_copytobuf;
		sc->sc_copyfromdesc = kap_copyfrombuf;

		sc->sc_initaddr = 1 << 23 | (sc->sc_initaddr & 0x01ffff);
		sc->sc_rmdaddr = 1 << 23 | (sc->sc_rmdaddr & 0x01ffff);
		sc->sc_tmdaddr = 1 << 23 | (sc->sc_tmdaddr & 0x01ffff);
	}
#endif

a567 13

#if defined(solbourne)
void
kap_copytobuf(struct lance_softc *sc, void *to, int boff, int len)
{
	return (lance_copytobuf_contig(sc, to, boff & ~(1 << 23), len));
}
void
kap_copyfrombuf(struct lance_softc *sc, void *from, int boff, int len)
{
	return (lance_copyfrombuf_contig(sc, from, boff & ~(1 << 23), len));
}
#endif
@


1.36
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.35 2014/07/28 18:31:39 miod Exp $	*/
d96 1
a96 1
static int lebufmedia[] = {
d101 1
a101 1
static int ledmamedia[] = {
d107 1
a107 1
static int lebaremedia[] = {
@


1.35
log
@On SPARCbook systems, the ledma device node has a `cable-selection' property
specifying which media the on-board interface uses. We already query it to
set up proper register values; extend this to be able to pass a default
media to the le(4) child.

This makes SPARCbook system default to AUI without needing for a manual media
change.

tested by sebastia@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.34 2013/09/24 20:10:49 miod Exp $	*/
a60 1
#ifdef INET
a62 1
#endif
@


1.34
log
@Sync the MI LANCE code ( le(4) ) with NetBSD, except for the following:
- the am7990_get() - now lance_get() - is unchanged.
- the interrupt acknowledge logic is unchanged, and will disable interrupts,
  then acknowledge all interrupt conditions.

Add ILACC (79900) support (from NetBSD).

Both LANCE (am7990.c) and ILACC (am79900.c) code share as much common code
(lance.c) as possible. This affects all le(4) attachments, but the changes
are mostly mechanical, to split am7990-specific parts from lance-agnostic
parts.

Compile tested on all affected platforms. Tested on alpha, hp300, luna88k,
mvme88k, sparc, sparc64 and vax.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.33 2012/07/30 16:58:19 miod Exp $	*/
d586 1
d593 1
d599 1
a600 1
	sc->sc_defaultmedia = sc->sc_supmedia[sc->sc_nsupmedia - 1];
@


1.33
log
@Revert previous change, and don't set IFM_AVALID | IFM_ACTIVE in ifm_status
to appease dhcpd, as dhcpd has now been fixed to not require this.
repeated prodding and special ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.31 2010/07/10 19:32:24 miod Exp $	*/
d74 2
d94 18
a111 2
int	lemediachange(struct ifnet *);
void	lemediastatus(struct ifnet *, struct ifmediareq *);
d117 2
a118 2
void	lesetutp(struct am7990_softc *);
void	lesetaui(struct am7990_softc *);
d126 1
a126 2
myleintr(arg)
	void	*arg;
d128 1
a128 1
	register struct le_softc *lesc = arg;
d150 4
a153 4
hide void lewrcsr(struct am7990_softc *, u_int16_t, u_int16_t);
hide u_int16_t lerdcsr(struct am7990_softc *, u_int16_t);
hide void lehwreset(struct am7990_softc *);
hide void lehwinit(struct am7990_softc *);
d155 1
a155 1
hide void lenocarrier(struct am7990_softc *);
d158 2
a159 2
hide void kap_copytobuf(struct am7990_softc *, void *, int, int);
hide void kap_copyfrombuf(struct am7990_softc *, void *, int, int);
d162 2
a163 4
hide void
lewrcsr(sc, port, val)
	struct am7990_softc *sc;
	u_int16_t port, val;
d165 1
a165 1
	register struct lereg1 *ler1 = ((struct le_softc *)sc)->sc_r1;
d167 1
a167 1
	volatile u_int16_t discard;
d183 2
a184 4
hide u_int16_t
lerdcsr(sc, port)
	struct am7990_softc *sc;
	u_int16_t port;
d186 2
a187 2
	register struct lereg1 *ler1 = ((struct le_softc *)sc)->sc_r1;
	u_int16_t val;
d196 1
a196 2
lesetutp(sc)
	struct am7990_softc *sc;
d213 1
a213 2
lesetaui(sc)
	struct am7990_softc *sc;
d231 1
a231 2
lemediachange(ifp)
	struct ifnet *ifp;
a232 1
	struct am7990_softc *sc = ifp->if_softc;
d282 1
a282 3
lemediastatus(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
a284 1
	struct am7990_softc *sc = ifp->if_softc;
d303 1
a303 2
	}
	else
d310 2
a311 3
hide void
lehwreset(sc)
	struct am7990_softc *sc;
d334 2
a335 3
hide void
lehwinit(sc)
	struct am7990_softc *sc;
d363 2
a364 3
hide void
lenocarrier(sc)
	struct am7990_softc *sc;
d397 1
a397 3
lematch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
d401 1
a401 1
	register struct romaux *ra = &ca->ca_ra;
d422 1
a422 3
leattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d425 1
a425 1
	struct am7990_softc *sc = &lesc->sc_am7990;
a445 1
	sc->sc_hasifmedia = 1;
d565 5
a569 5
	sc->sc_copytodesc = am7990_copytobuf_contig;
	sc->sc_copyfromdesc = am7990_copyfrombuf_contig;
	sc->sc_copytobuf = am7990_copytobuf_contig;
	sc->sc_copyfrombuf = am7990_copyfrombuf_contig;
	sc->sc_zerobuf = am7990_zerobuf_contig;
d580 2
a581 1
	ifmedia_init(&sc->sc_ifmedia, 0, lemediachange, lemediastatus);
d584 2
a585 2
		ifmedia_add(&sc->sc_ifmedia, IFM_ETHER | IFM_10_T, 0, NULL);
		ifmedia_set(&sc->sc_ifmedia, IFM_ETHER | IFM_10_T);
d590 2
a591 4
		ifmedia_add(&sc->sc_ifmedia, IFM_ETHER | IFM_10_T, 0, NULL);
		ifmedia_add(&sc->sc_ifmedia, IFM_ETHER | IFM_10_5, 0, NULL);
		ifmedia_add(&sc->sc_ifmedia, IFM_ETHER | IFM_AUTO, 0, NULL);
		ifmedia_set(&sc->sc_ifmedia, IFM_ETHER | IFM_AUTO);
d595 2
a596 2
		ifmedia_add(&sc->sc_ifmedia, IFM_ETHER | IFM_10_5, 0, NULL);
		ifmedia_set(&sc->sc_ifmedia, IFM_ETHER | IFM_10_5);
d598 1
d600 1
a600 1
	am7990_config(sc);
d626 2
a627 2
hide void
kap_copytobuf(struct am7990_softc *sc, void *to, int boff, int len)
d629 1
a629 1
	return (am7990_copytobuf_contig(sc, to, boff & ~(1 << 23), len));
d631 2
a632 2
hide void
kap_copyfrombuf(struct am7990_softc *sc, void *from, int boff, int len)
d634 1
a634 1
	return (am7990_copyfrombuf_contig(sc, from, boff & ~(1 << 23), len));
@


1.32
log
@When reporting media state, be sure to set IFM_AVALID and IFM_ACTIVE in
ifm_status, for dhclient's sake. Current dhclient interface_status()
considers interfaces able to report media information but not returning
IFM_AVALID as down. Note that these interfaces usually have mii(4) or
have specific code reporting correct values; sparc le(4) is an exception.
Found the hard way by sebastia@@; joint work with krw@@, ok deraadt@@
@
text
@a280 2
	ifmr->ifm_status = IFM_AVALID | IFM_ACTIVE;

a300 1
	ifmr->ifm_status = IFM_AVALID | IFM_ACTIVE;
@


1.31
log
@sun4e (i.e. SPARCengine 1e) support. This platform is a mix between sun4 and
sun4c, as it has a sun4c OpenPROM but a sun4 8KB pagesize. VME devices are
not supported yet.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.30 2009/10/26 20:17:27 deraadt Exp $	*/
d281 2
d303 1
@


1.30
log
@Do not do strncmp comparisons on dv_xname because longer device names which
look similar could arrive in the future.  Instead, compare directly against
dv_cfdata->cf_driver->cd_name
Issue originally spotted by miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.29 2007/05/29 09:54:09 sobrado Exp $	*/
d410 1
a410 1
#if defined(SUN4C) || defined(SUN4M)
d431 1
a431 1
#if defined(SUN4C) || defined(SUN4M)
d449 1
a449 1
#if defined(SUN4C) || defined(SUN4M)
d456 1
a456 1
#if defined(SUN4C) || defined(SUN4M)
d509 3
a511 3
#if defined(SUN4) || defined(SUN4C) || defined(SUN4M)
#if defined(SUN4C) || defined(SUN4M)
		if (sbuschild && CPU_ISSUN4M)
d518 2
a519 2
#endif	/* SUN4 || SUN4C || SUN4M */
#if defined (SUN4M)
d536 1
a536 1
#if defined(SUN4C) || defined(SUN4M)
d547 1
a547 1
#if defined(SUN4C) || defined(SUN4M)
d557 1
a557 1
#endif /* SUN4C || SUN4M */
d584 1
a584 1
#if defined(SUN4C) || defined(SUN4M)
@


1.29
log
@use the right capitalization for `MBus' and `SBus'

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.28 2006/06/02 20:00:54 miod Exp $	*/
d432 3
a434 3
	int sbuschild = strncmp(parent->dv_xname, "sbus", 4) == 0;
	int lebufchild = strncmp(parent->dv_xname, "lebuffer", 8) == 0;
	int dmachild = strncmp(parent->dv_xname, "ledma", 5) == 0;
@


1.28
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.27 2006/06/02 19:58:32 miod Exp $	*/
d159 1
a159 1
	 * We need to flush the Sbus->Mbus write buffers. This can most
@


1.27
log
@When trying to find leaf lebuffer devices, to work around broken old PROMs,
walk the lebuffer_cd device list, instead of the sbus children list.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.26 2005/04/19 21:30:19 miod Exp $	*/
a552 8
		lesc->sc_sd.sd_reset = (void *)am7990_reset;
		if (sbuschild) {
			sbus_establish(&lesc->sc_sd, &sc->sc_dev);
		} else {
			/* Assume SBus is grandparent */
			sbus_establish(&lesc->sc_sd, parent);
		}

@


1.26
log
@As a late birthday present, a preliminary port to the Solbourne IDT systems
(S3000, S4000 and S4000DX).

Currently limited to diskless and serial console, and userland has issues.
Things will get better in the near future.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.25 2005/02/27 22:01:04 miod Exp $	*/
d461 8
a468 2
		struct sbus_softc *sbus = (struct sbus_softc *)parent;
		struct sbusdev *sd;
d470 2
a471 13
		/*
		 * Find last "unallocated" lebuffer and pair it with
		 * this `le' device on the assumption that we're on
		 * a pre-historic ROM that doesn't establish le<=>lebuffer
		 * parent-child relationships.
		 */
		for (sd = sbus->sc_sbdev; sd != NULL; sd = sd->sd_bchain) {
			if (strncmp("lebuffer", sd->sd_dev->dv_xname, 8) != 0)
				continue;
			if (((struct lebuf_softc *)sd->sd_dev)->attached == 0) {
				lebuf = (struct lebuf_softc *)sd->sd_dev;
				break;
			}
@


1.25
log
@Use the DMA defines from dev/ic/lsi64854reg.h whenever possible; no functional
change.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.24 2004/09/29 07:35:11 miod Exp $	*/
d80 6
d140 4
d405 5
d494 21
d523 1
d528 6
a533 1
		sc->sc_addr = laddr & 0xffffff;
d535 6
a540 1
		sc->sc_conf3 = LE_C3_BSWP | LE_C3_ACON | LE_C3_BCON;
d618 11
d640 13
@


1.24
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.23 2003/06/04 22:08:17 deraadt Exp $	*/
a113 1
#define E_DRAIN 0x400 /* XXX: fix dmareg.h */
d182 1
a182 1
		csr |= DE_AUI_TP;
d185 1
a185 1
		if (lesc->sc_dma->sc_regs->csr & DE_AUI_TP)
d200 1
a200 1
		csr &= ~DE_AUI_TP;
d203 1
a203 1
		if ((lesc->sc_dma->sc_regs->csr & DE_AUI_TP) == 0)
d283 1
a283 1
		if (lesc->sc_dma->sc_regs->csr & DE_AUI_TP)
d308 1
a308 1
		aui = lesc->sc_dma->sc_regs->csr & DE_AUI_TP;
d361 1
a361 1
		if (lesc->sc_dma->sc_regs->csr & DE_AUI_TP) {
@


1.23
log
@Delete UCB term 3.  When there are other copyright owners, we affirm
that we can see no legal situation under which they could require that
term to remain (ie. This is equivelant to us taking the old UCB file,
removing term 3 as specified by UCB, then re-applying each diff
afterwards from the various authors)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.22 2003/05/22 07:28:11 miod Exp $	*/
d578 1
a578 1
	intr_establish(pri, &lesc->sc_ih, IPL_NET);
@


1.22
log
@Let this compile on SUN4 or SUN4C only kernels, PR #3269
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.21 2003/05/14 23:35:30 miod Exp $	*/
a28 2
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
@


1.21
log
@Silence the "lost carrier on FOO port" messages when the port has been set
in stone with "ifconfig le0 media foo". Inspired by previous am7990.c change.

ok todd@@ jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.20 2002/04/30 01:12:29 art Exp $	*/
d134 1
d136 1
@


1.20
log
@Fix an ancient problem in how sparc interrupts are handled.

There are many interrupt handlers that assume that they don't need to do
any spl protection in their code because the interrupt of some level can't
be interrupted by an interrupt of the same level. The problem is that some
interrupt handlers have hardware levels that are lower then their "software"
levels.

Fix this by adding an additional field to struct intrhand that specifies which
"software" level an interrupt handler has and blocks that level while handling
the interrupt. This new field is initialized in intr_establish which gets
an additional argument (which can be -1 meaning that the interrupt handler
doesn't need to block any additional level).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.19 2002/03/14 01:26:43 millert Exp $	*/
d350 1
a354 1
#if defined(SUN4M)
d357 1
a357 1
	if (CPU_ISSUN4M && lesc->sc_dma) {
a361 1
		printf("%s: lost carrier on ", sc->sc_dev.dv_xname);
a362 1
			printf("UTP port");
d366 3
a368 1
				printf(", switching to AUI port");
a371 1
			printf("AUI port");
d375 3
a377 1
				printf(", switching to UTP port");
d381 2
a382 2
		printf("\n");
	} else
a383 2
		printf("%s: lost carrier\n", sc->sc_dev.dv_xname);
}
d544 4
a547 1
	sc->sc_nocarrier = lenocarrier;
@


1.19
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.18 2001/06/11 00:29:49 miod Exp $	*/
d576 1
a576 1
	intr_establish(pri, &lesc->sc_ih);
@


1.18
log
@Being able to compile sun4 (non-sun4c non-4m) kernels doesn't hurt.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.17 2001/01/15 23:23:57 jason Exp $	*/
d82 2
a83 2
int	lematch __P((struct device *, void *, void *));
void	leattach __P((struct device *, struct device *, void *));
d88 2
a89 2
int	lemediachange __P((struct ifnet *));
void	lemediastatus __P((struct ifnet *, struct ifmediareq *));
d95 2
a96 2
void	lesetutp __P((struct am7990_softc *));
void	lesetaui __P((struct am7990_softc *));
d100 2
a101 2
int	myleintr __P((void *));
int	ledmaintr __P((struct dma_softc *));
d130 5
a134 5
hide void lewrcsr __P((struct am7990_softc *, u_int16_t, u_int16_t));
hide u_int16_t lerdcsr __P((struct am7990_softc *, u_int16_t));
hide void lehwreset __P((struct am7990_softc *));
hide void lehwinit __P((struct am7990_softc *));
hide void lenocarrier __P((struct am7990_softc *));
d426 1
a426 1
	extern void myetheraddr __P((u_char *));
@


1.18.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.18 2001/06/11 00:29:49 miod Exp $	*/
d82 2
a83 2
int	lematch(struct device *, void *, void *);
void	leattach(struct device *, struct device *, void *);
d88 2
a89 2
int	lemediachange(struct ifnet *);
void	lemediastatus(struct ifnet *, struct ifmediareq *);
d95 2
a96 2
void	lesetutp(struct am7990_softc *);
void	lesetaui(struct am7990_softc *);
d100 2
a101 2
int	myleintr(void *);
int	ledmaintr(struct dma_softc *);
d130 5
a134 5
hide void lewrcsr(struct am7990_softc *, u_int16_t, u_int16_t);
hide u_int16_t lerdcsr(struct am7990_softc *, u_int16_t);
hide void lehwreset(struct am7990_softc *);
hide void lehwinit(struct am7990_softc *);
hide void lenocarrier(struct am7990_softc *);
d426 1
a426 1
	extern void myetheraddr(u_char *);
d576 1
a576 1
	intr_establish(pri, &lesc->sc_ih, IPL_NET);
@


1.18.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a349 1
#if defined(SUN4M)
d354 1
d357 1
a357 1
	if (lesc->sc_dma) {
d362 1
d364 1
d368 1
a368 3
				printf("%s: lost carrier on UTP port"
				    ", switching to AUI port\n",
				    sc->sc_dev.dv_xname);
d372 1
d376 1
a376 3
				printf("%s: lost carrier on AUI port"
				    ", switching to UTP port\n",
				    sc->sc_dev.dv_xname);
d380 4
a383 1
	}
a384 1
#endif
d545 1
a545 4
#if defined(SUN4M)
	if (CPU_ISSUN4M)
		sc->sc_nocarrier = lenocarrier;
#endif
@


1.17
log
@- increase the amount of space mapped for dvma on sun4m
- use a flag to specify allocations for 24 bit devices
- compatibility macros to deal with the 32 bit devices

This fixes the 'le at sbus' on sun4m problem (with the extent fixes
earlier), and allows the Artecon ethernet cards to work in sun4m machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.16 1999/02/28 19:12:34 jason Exp $	*/
d481 1
d486 1
@


1.16
log
@conditionalize use of sbus_testdma()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.15 1998/12/22 15:40:30 jason Exp $	*/
d480 7
a486 1
		laddr = (u_long)dvma_malloc(MEMSIZE, &sc->sc_mem, M_NOWAIT);
@


1.16.6.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.17 2001/01/15 23:23:57 jason Exp $	*/
d480 1
a480 7

		if (sbuschild && CPU_ISSUN4M)
			laddr = (u_long)dvma_malloc_space(MEMSIZE,
			     &sc->sc_mem, M_NOWAIT, M_SPACE_D24);
		else
			laddr = (u_long)dvma_malloc(MEMSIZE,
			     &sc->sc_mem, M_NOWAIT);
@


1.16.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.16.6.1 2001/05/14 21:37:06 niklas Exp $	*/
a480 1
#if defined(SUN4C) || defined(SUN4M)
a484 1
#endif
@


1.16.6.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d82 2
a83 2
int	lematch(struct device *, void *, void *);
void	leattach(struct device *, struct device *, void *);
d88 2
a89 2
int	lemediachange(struct ifnet *);
void	lemediastatus(struct ifnet *, struct ifmediareq *);
d95 2
a96 2
void	lesetutp(struct am7990_softc *);
void	lesetaui(struct am7990_softc *);
d100 2
a101 2
int	myleintr(void *);
int	ledmaintr(struct dma_softc *);
d130 5
a134 5
hide void lewrcsr(struct am7990_softc *, u_int16_t, u_int16_t);
hide u_int16_t lerdcsr(struct am7990_softc *, u_int16_t);
hide void lehwreset(struct am7990_softc *);
hide void lehwinit(struct am7990_softc *);
hide void lenocarrier(struct am7990_softc *);
d426 1
a426 1
	extern void myetheraddr(u_char *);
@


1.16.6.4
log
@Sync the SMP branch with 3.3
@
text
@d576 1
a576 1
	intr_establish(pri, &lesc->sc_ih, IPL_NET);
@


1.16.6.5
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@a349 1
#if defined(SUN4M)
d354 1
d357 1
a357 1
	if (lesc->sc_dma) {
d362 1
d364 1
d368 1
a368 3
				printf("%s: lost carrier on UTP port"
				    ", switching to AUI port\n",
				    sc->sc_dev.dv_xname);
d372 1
d376 1
a376 3
				printf("%s: lost carrier on AUI port"
				    ", switching to UTP port\n",
				    sc->sc_dev.dv_xname);
d380 4
a383 1
	}
a384 1
#endif
d545 1
a545 4
#if defined(SUN4M)
	if (CPU_ISSUN4M)
		sc->sc_nocarrier = lenocarrier;
#endif
@


1.16.6.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.16.6.5 2003/05/16 00:29:40 niklas Exp $	*/
d29 2
a133 1
#if defined(SUN4M)
a134 1
#endif
@


1.15
log
@only define le_softc variables ifdef SUN4M; C. W. Wilkerson (wilker@@purdue116.gte.net).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.14 1998/12/13 21:47:09 deraadt Exp $	*/
d397 1
d403 1
@


1.14
log
@be more careful with media handlings
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.13 1998/11/11 00:50:31 jason Exp $	*/
d216 1
d218 1
@


1.13
log
@A few more dma in non-dma slot checks
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.12 1998/09/28 05:15:57 jason Exp $	*/
d108 1
a108 1
static int dodrain=0;
d216 1
d230 1
a230 1
		if (CPU_ISSUN4M)
d237 1
a237 1
		if (CPU_ISSUN4M)
d246 1
a246 1
		if (CPU_ISSUN4M)
@


1.12
log
@Remember the status of the aui/tp bit, and reset it and wait
appropriately during lehwreset(); idea from pk@@NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.11 1998/09/19 15:11:50 jason Exp $	*/
a188 1
	printf("Setting utp: bit won't stick\n");
a206 1
	printf("Setting aui: bit won't stick\n");
d394 3
a396 1
	if (ca->ca_bustype == BUS_SBUS)
d398 1
@


1.11
log
@lebuffer based le's use UTP
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.10 1998/09/18 20:27:15 deraadt Exp $	*/
d306 3
d314 2
a315 1
		lesc->sc_dma->sc_regs->csr |= D_DSBL_WRINVAL;
@


1.10
log
@lebuffer cards are UTP
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.9 1998/09/16 22:41:18 jason Exp $	*/
d272 4
a275 1
		ifmr->ifm_active = IFM_ETHER | IFM_10_5;
d426 3
@


1.9
log
@o if_media'fied am7990
o if_media'fied sun4m le.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.8 1997/09/17 06:47:09 downsj Exp $	*/
d525 6
d537 3
a539 2
	}
	else {
a542 4
#else
	ifmedia_add(&sc->sc_ifmedia, IFM_ETHER | IFM_10_5, 0, NULL);
	ifmedia_set(&sc->sc_ifmedia, IFM_ETHER | IFM_10_5);
#endif
@


1.8
log
@NETBSD_CURRENT_970916.  Lot's just ID changes, since changes don't apply to
us.  Includes some pmap changes, for which I don't have the original commit
message(s) handy.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.7 1997/08/08 08:25:12 downsj Exp $	*/
a60 2
#if defined(__NetBSD__)
#include <net/if_ether.h>
a61 1
#endif	/* __NetBSD__ */
a64 3
#if defined(__NetBSD__)
#include <netinet/if_inarp.h>
#else
a65 1
#endif	/* __NetBSD__ */
a81 3
#if defined(__NetBSD__)
int	lematch __P((struct device *, struct cfdata *, void *));
#else
a82 1
#endif	/* __NetBSD__ */
d85 14
a125 22
#if defined(SUN4M)
#if defined(__NetBSD__)
/*
 * Media types supported by the Sun4m.
 */
int lemediasun4m[] = {
	IFM_ETHER|IFM_10_T,
	IFM_ETHER|IFM_10_5,
	IFM_ETHER|IFM_AUTO,
};
#define NLEMEDIASUN4M	(sizeof(lemediasun4m) / sizeof(lemediasun4m[0]))
#endif	/* __NetBSD__ */

void	lesetutp __P((struct am7990_softc *));
void	lesetaui __P((struct am7990_softc *));

int	lemediachange __P((struct am7990_softc *));
#if defined(__NetBSD__)
void	lemediastatus __P((struct am7990_softc *, struct ifmediareq *));
#endif	/* __NetBSD__ */
#endif /* SUN4M */

d178 2
d181 9
a189 2
	lesc->sc_dma->sc_regs->csr |= DE_AUI_TP;
	delay(20000);	/* must not touch le for 20ms */
d197 2
d200 9
a208 2
	lesc->sc_dma->sc_regs->csr &= ~DE_AUI_TP;
	delay(20000);	/* must not touch le for 20ms */
d210 1
d213 2
a214 2
lemediachange(sc)
	struct am7990_softc *sc;
d216 2
a217 2
#if defined(__NetBSD__)
	struct ifmedia *ifm = &sc->sc_media;
d229 1
d231 4
a234 1
		lesetutp(sc);
d237 8
d246 6
a251 1
		lesetaui(sc);
a253 2
	case IFM_AUTO:
		break;
a257 2
#else
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
a258 5
	if (ifp->if_flags & IFF_LINK0)
		lesetutp(sc);
	else if (ifp->if_flags & IFF_LINK1)
		lesetaui(sc);
#endif	/* __NetBSD__ */
a261 1
#if defined(__NetBSD__)
d263 2
a264 2
lemediastatus(sc, ifmr)
	struct am7990_softc *sc;
d267 2
d271 2
a272 1
	if (lesc->sc_dma == NULL)
d274 1
d276 9
a284 5
	/*
	 * Notify the world which media we're currently using.
	 */
	if (lesc->sc_dma->sc_regs->csr & DE_AUI_TP)
		ifmr->ifm_active = IFM_ETHER|IFM_10_T;
d286 4
a289 1
		ifmr->ifm_active = IFM_ETHER|IFM_10_5;
a290 2
#endif	/* __NetBSD__ */
#endif /* SUN4M */
a319 4
	/*
	 * Make sure we're using the currently-enabled media type.
	 * XXX Actually, this is probably unnecessary, now.
	 */
d321 1
a321 2
#if defined(__NetBSD__)
		switch (IFM_SUBTYPE(sc->sc_media.ifm_cur->ifm_media)) {
a328 3
		}
#else
		struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d330 5
a334 1
		if (ifp->if_flags & IFF_LINK0)
d336 2
a337 3
		else if (ifp->if_flags & IFF_LINK1)
			lesetaui(sc);
#endif	/* __NetBSD__ */
a347 3
#if !defined(__NetBSD__)
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
#endif	/* __NetBSD__ */
d357 1
a357 2
#if defined(__NetBSD__)
			switch (IFM_SUBTYPE(sc->sc_media.ifm_media)) {
a362 6
#else
			if (!(ifp->if_flags & IFF_LINK0)) {
				printf(", switching to AUI port");
				lesetaui(sc);
			}
#endif	/* __NetBSD__ */
d365 1
a365 2
#if defined(__NetBSD__)
			switch (IFM_SUBTYPE(sc->sc_media.ifm_media)) {
a370 6
#else
			if (!(ifp->if_flags & IFF_LINK1)) {
				printf(", switching to UTP port");
				lesetutp(sc);
			}
#endif	/* __NetBSD__ */
a378 7
#if defined(__NetBSD__)
lematch(parent, cf, aux)
	struct device *parent;
	struct cfdata *cf;
	void *aux;
{
#else
a383 1
#endif	/* __NetBSD__ */
d422 2
a509 3
#if defined(__NetBSD__)
	myetheraddr(sc->sc_enaddr);
#else
a510 1
#endif	/* __NetBSD__ */
d524 2
a525 1
#if defined(SUN4M) && defined(__NetBSD__)
d527 4
a530 5
		sc->sc_mediachange = lemediachange;
		sc->sc_mediastatus = lemediastatus;
		sc->sc_supmedia = lemediasun4m;
		sc->sc_nsupmedia = NLEMEDIASUN4M;
		sc->sc_defaultmedia = IFM_ETHER|IFM_AUTO;
d532 7
@


1.7
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: if_le.c,v 1.49 1997/07/07 16:28:44 pk Exp $	*/
d105 1
d107 2
a108 1
	if (lesc->sc_dma->sc_regs->csr & D_ERR_PEND)
d110 8
d290 3
@


1.6
log
@netbsd port, now we merge our changes back in
@
text
@d1 2
a2 1
/*	$NetBSD: if_le.c,v 1.35.4.1 1996/07/17 01:46:00 jtc Exp $	*/
d5 1
d27 2
d61 4
d68 3
d72 1
d81 1
d89 3
d93 1
d109 1
a109 9
	/*
	 * XXX There is a bug somewhere in the interrupt code that causes stray
	 * ethernet interrupts under high network load. This bug has been
	 * impossible to locate, so until it is found, we just ignore stray
	 * interrupts, as they do not in fact correspond to dropped packets.
	 */

	/* return */ am7990_intr(arg);
	return 1;
d113 22
d141 1
d143 1
d151 3
d157 9
d181 103
d291 4
d296 11
d310 1
a310 1
			lesc->sc_dma->sc_regs->csr |= DE_AUI_TP;
d312 5
a316 1
			lesc->sc_dma->sc_regs->csr &= ~DE_AUI_TP;
d318 49
a366 2
		delay(20000);	/* must not touch le for 20ms */
	}
d368 1
d372 8
a379 1
lematch(parent, match, aux)
d381 1
a381 1
	void *match, *aux;
d383 2
a384 1
	struct cfdata *cf = match;
a405 1
	u_long laddr;
d408 3
d423 41
a463 5
	lesc->sc_r1 = (struct lereg1 *)mapiodev(ca->ca_ra.ra_reg, 0,
					      sizeof(struct lereg1),
					      ca->ca_bustype);
	sc->sc_conf3 = LE_C3_BSWP | LE_C3_ACON | LE_C3_BCON;
	laddr = (u_long)dvma_malloc(MEMSIZE, &sc->sc_mem, M_NOWAIT);
d465 2
a466 2
	if ((laddr & 0xffffff) >= (laddr & 0xffffff) + MEMSIZE)
		panic("if_le: Lance buffer crosses 16MB boundary");
d468 11
a478 16
	sc->sc_addr = laddr & 0xffffff;
	sc->sc_memsize = MEMSIZE;

	myetheraddr(sc->sc_arpcom.ac_enaddr);

	sc->sc_copytodesc = am7990_copytobuf_contig;
	sc->sc_copyfromdesc = am7990_copyfrombuf_contig;
	sc->sc_copytobuf = am7990_copytobuf_contig;
	sc->sc_copyfrombuf = am7990_copyfrombuf_contig;
	sc->sc_zerobuf = am7990_zerobuf_contig;

	sc->sc_rdcsr = lerdcsr;
	sc->sc_wrcsr = lewrcsr;
	sc->sc_hwinit = lehwinit;

	am7990_config(sc);
a489 1
			lesc->sc_dma = NULL;
a491 3
			lesc->sc_dma = (struct dma_softc *)parent;
			lesc->sc_dma->sc_le = lesc;
			lesc->sc_dma->sc_regs->en_bar = laddr & 0xff000000;
d509 30
d541 1
a541 1
	if (CPU_ISSUN4M)
d548 1
a548 3
	if (lesc->sc_dma) {
		DMA_ENINTR(lesc->sc_dma);
	}
@


1.5
log
@MI le driver
@
text
@d1 1
a1 1
/*	$NetBSD: if_le.c,v 1.24 1995/12/11 12:43:28 pk Exp $	*/
d4 2
d23 2
d69 1
a69 2
#include <sparc/dev/if_lereg.h>
#include <sparc/dev/if_levar.h>
a70 1
#define	LE_NEED_BUF_CONTIG
d73 2
a74 2
#define	LE_SOFTC(unit)	lecd.cd_devs[unit]
#define	LE_DELAY(x)	DELAY(x)
a77 1
int	leintr __P((void *));
d79 27
a105 2
struct	cfdriver lecd = {
	NULL, "le", lematch, leattach, DV_IFNET, sizeof(struct le_softc)
d108 5
a112 1
integrate void
d114 1
a114 1
	struct le_softc *sc;
d117 1
a117 1
	register struct lereg1 *ler1 = sc->sc_r1;
d123 1
a123 1
integrate u_int16_t
d125 1
a125 1
	struct le_softc *sc;
d128 1
a128 1
	register struct lereg1 *ler1 = sc->sc_r1;
d134 21
a154 1
} 
d178 2
a179 1
	struct le_softc *sc = (void *)self;
d184 3
a186 1
	int dmachild = strncmp(parent->dv_xname, "ledma", 5) == 0;
d189 1
a189 1
	extern void myetheraddr(u_char *);
d198 1
a198 1
	sc->sc_r1 = (struct lereg1 *)mapiodev(ca->ca_ra.ra_reg, 0,
d204 1
a204 1
	if ((laddr & 0xffffff) >= (laddr & 0xffffff) + MEMSIZE) 
d212 9
a220 5
	sc->sc_copytodesc = copytobuf_contig;
	sc->sc_copyfromdesc = copyfrombuf_contig;
	sc->sc_copytobuf = copytobuf_contig;
	sc->sc_copyfrombuf = copyfrombuf_contig;
	sc->sc_zerobuf = zerobuf_contig;
d222 1
a222 2
	sc->sc_arpcom.ac_if.if_name = lecd.cd_name;
	leconfig(sc);
d232 4
a235 8
		sc->sc_sd.sd_reset = (void *)lereset;
		if (dmachild) {
#ifdef notyet
			sc->sc_dma = (struct dma_softc *)parent;
			sc->sc_dma->sc_le = sc;
			sc->sc_dma->sc_regs->en_bar = laddr & 0xff000000;
			sbus_establish(&sc->sc_sd, parent);
#endif
d237 5
a241 2
			sc->sc_dma = NULL;
			sbus_establish(&sc->sc_sd, &sc->sc_dev);
d244 1
a244 1
		if (bp != NULL && strcmp(bp->name, lecd.cd_name) == 0 &&
d246 1
a246 1
			bootdv = &sc->sc_dev;
d251 1
a251 1
		if (bp != NULL && strcmp(bp->name, lecd.cd_name) == 0 &&
d253 1
a253 1
			bootdv = &sc->sc_dev;
d257 4
a260 4
	sc->sc_ih.ih_fun = leintr;
#if defined(SUN4M) && 0
	if (cputyp == CPU_SUN4M)
		sc->sc_ih.ih_fun = myleintr;
d262 2
a263 2
	sc->sc_ih.ih_arg = sc;
	intr_establish(pri, &sc->sc_ih);
d266 2
a267 2
	if (sc->sc_dma) {
		dmaenintr(sc->sc_dma);
a269 2

#include <dev/ic/am7990.c>
@


1.4
log
@pretty
@
text
@d1 1
a1 1
/*	$NetBSD: if_le.c,v 1.20 1995/04/12 08:47:21 pk Exp $ */
d4 2
a5 1
 * Copyright (c) 1982, 1992, 1993
d8 3
d39 1
a39 1
 *	@@(#)if_le.c	8.2 (Berkeley) 10/30/93
a43 3
/*
 * AMD 7990 LANCE
 */
a44 1
#include <sys/device.h>
a45 1
#include <sys/kernel.h>
d47 1
a47 1
#include <sys/buf.h>
d49 1
a49 2
#include <sys/syslog.h>
#include <sys/ioctl.h>
a50 3
#include <sys/errno.h>

#include <vm/vm.h>
a52 7
#include <net/netisr.h>
#include <net/route.h>
#if NBPFILTER > 0
#include <sys/select.h>
#include <net/bpf.h>
#include <net/bpfdesc.h>
#endif
a55 3
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
a58 9
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

#ifdef APPLETALK
#include <netddp/atalk.h>
#endif

a60 1
#include <machine/pmap.h>
d62 3
d66 11
a76 1
#include <sparc/dev/sbusvar.h>
d78 3
a80 2
/* DVMA address to LANCE address -- the Sbus/MMU will resupply the 0xff */
#define	LANCE_ADDR(x)	((int)(x) & ~0xff000000)
d82 6
a87 1
int	ledebug = 0;		/* console error messages */
d89 3
a91 4
#ifdef PACKETSTATS
long	lexpacketsizes[LEMTU+1];
long	lerpacketsizes[LEMTU+1];
#endif
d93 7
a99 46
/* Per interface statistics */
/* XXX this should go in something like if_levar.h */
struct	lestats {
	long	lexints;	/* transmitter interrupts */
	long	lerints;	/* receiver interrupts */
	long	lerbufs;	/* total buffers received during interrupts */
	long	lerhits;	/* times current rbuf was full */
	long	lerscans;	/* rbufs scanned before finding first full */
};

/*
 * Ethernet software status per interface.
 *
 * Each interface is referenced by a network interface structure,
 * le_if, which the routing code uses to locate the interface.
 * This structure contains the output queue for the interface, its address, ...
 */
struct le_softc {
	struct	device sc_dev;		/* base device */
	struct	sbusdev sc_sd;		/* sbus device */
	struct	intrhand sc_ih;		/* interrupt vectoring */
	struct	evcnt sc_intrcnt;	/* # of interrupts, per le */
	struct	evcnt sc_errcnt;	/* # of errors, per le */

	struct	arpcom sc_ac;		/* common Ethernet structures */
#define	sc_if	sc_ac.ac_if		/* network-visible interface */
#define	sc_addr	sc_ac.ac_enaddr		/* hardware Ethernet address */
	volatile struct	lereg1 *sc_r1;	/* LANCE registers */
	volatile struct	lereg2 *sc_r2;	/* dual-port RAM */
	int	sc_rmd;			/* predicted next rmd to process */
	int	sc_runt;
	int	sc_jab;
	int	sc_merr;
	int	sc_babl;
	int	sc_cerr;
	int	sc_miss;
	int	sc_xint;
	int	sc_xown;
	int	sc_uflo;
	int	sc_rxlen;
	int	sc_rxoff;
	int	sc_txoff;
	int	sc_busy;
	short	sc_iflags;
	struct	lestats sc_lestats;	/* per interface statistics */
};
d101 4
a104 23

/* autoconfiguration driver */
void	leattach(struct device *, struct device *, void *);
int	lematch(struct device *, void *, void *);
struct	cfdriver lecd =
    { NULL, "le", lematch, leattach, DV_IFNET, sizeof(struct le_softc) };

/* Forwards */
void	leattach(struct device *, struct device *, void *);
void	lesetladrf(struct le_softc *);
void	lereset(struct device *);
int	leinit(int);
void	lestart(struct ifnet *);
int	leintr(void *);
void	lexint(struct le_softc *);
void	lerint(struct le_softc *);
void	leread(struct le_softc *, char *, int);
int	leput(char *, struct mbuf *);
struct mbuf *leget(char *, int, int, struct ifnet *);
int	leioctl(struct ifnet *, u_long, caddr_t);
void	leerror(struct le_softc *, int);
void	lererror(struct le_softc *, char *);
void	lexerror(struct le_softc *);
d107 1
a107 1
lematch(parent, vcf, aux)
d109 1
a109 1
	void *vcf, *aux;
d111 2
a112 2
	struct cfdata *cf = vcf;
	register struct confargs *ca = aux;
d119 1
a122 5
/*
 * Interface exists: make available by filling in network interface
 * record.  System will initialize the interface when it is ready
 * to accept packets.
 */
d124 10
a133 11
leattach(parent, self, args)
	struct device *parent;
	struct device *self;
	void *args;
{
	register struct le_softc *sc = (struct le_softc *)self;
	register struct confargs *ca = args;
	register volatile struct lereg2 *ler2;
	struct ifnet *ifp = &sc->sc_if;
	register struct bootpath *bp;
	register int a, pri;
a136 1
	extern caddr_t dvma_malloc(size_t);
a143 37
	sc->sc_r1 = (volatile struct lereg1 *)
	    mapiodev(ca->ca_ra.ra_paddr, sizeof(struct lereg1), ca->ca_bustype);
	ler2 = sc->sc_r2 = (volatile struct lereg2 *)
	    dvma_malloc(sizeof(struct lereg2));

	myetheraddr(sc->sc_addr);
	printf(": hardware address %s\n", ether_sprintf(sc->sc_addr));

	/*
	 * Setup for transmit/receive
	 *
	 * According to Van, some versions of the Lance only use this
	 * address to receive packets; it doesn't put them in
	 * output packets. We'll want to make sure that lestart()
	 * installs the address.
	 */
	ler2->ler2_padr[0] = sc->sc_addr[1];
	ler2->ler2_padr[1] = sc->sc_addr[0];
	ler2->ler2_padr[2] = sc->sc_addr[3];
	ler2->ler2_padr[3] = sc->sc_addr[2];
	ler2->ler2_padr[4] = sc->sc_addr[5];
	ler2->ler2_padr[5] = sc->sc_addr[4];
	a = LANCE_ADDR(&ler2->ler2_rmd);
	ler2->ler2_rlen = LE_RLEN | (a >> 16);
	ler2->ler2_rdra = a;
	a = LANCE_ADDR(&ler2->ler2_tmd);
	ler2->ler2_tlen = LE_TLEN | (a >> 16);
	ler2->ler2_tdra = a;

	/*
	 * Link into sbus, and establish interrupt handler.
	 */
	sc->sc_sd.sd_reset = lereset;
#if defined(SUN4C) || defined(SUN4M)
	if (ca->ca_bustype==BUS_SBUS)
		sbus_establish(&sc->sc_sd, &sc->sc_dev);
#endif /* SUN4C || SUN4M */
d145 19
a163 3
	sc->sc_ih.ih_fun = leintr;
	sc->sc_ih.ih_arg = sc;
	intr_establish(pri, &sc->sc_ih);
d165 2
a166 20
	/*
	 * Set up event counters.
	 */
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);
	evcnt_attach(&sc->sc_dev, "errs", &sc->sc_errcnt);

	ifp->if_unit = sc->sc_dev.dv_unit;
	ifp->if_name = "le";
	ifp->if_ioctl = leioctl;
	ifp->if_start = lestart;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
#ifdef IFF_NOTRAILERS
	/* XXX still compile when the blasted things are gone... */
	ifp->if_flags |= IFF_NOTRAILERS;
#endif
#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
#endif
	if_attach(ifp);
	ether_ifattach(ifp);
d168 3
a174 2
	bp = ca->ca_ra.ra_bp;
	switch (ca->ca_bustype) {
d176 14
a189 1
		if (bp != NULL && strcmp(bp->name, "le") == 0 &&
d193 2
d196 1
a196 1
		if (bp != NULL && strcmp(bp->name, "le") == 0 &&
a200 1
}
d202 4
a205 92
/*
 * Setup the logical address filter
 */
void
lesetladrf(sc)
	register struct le_softc *sc;
{
	register volatile struct lereg2 *ler2 = sc->sc_r2;
	register struct ifnet *ifp = &sc->sc_if;
	register struct ether_multi *enm;
	register u_char *cp, c;
	register u_long crc;
	register int i, len;
	struct ether_multistep step;

	/*
	 * Set up multicast address filter by passing all multicast
	 * addresses through a crc generator, and then using the high
	 * order 6 bits as a index into the 64 bit logical address
	 * filter. The high order two bits select the word, while the
	 * rest of the bits select the bit within the word.
	 */

	ler2->ler2_ladrf[0] = 0;
	ler2->ler2_ladrf[1] = 0;
	ler2->ler2_ladrf[2] = 0;
	ler2->ler2_ladrf[3] = 0;
	ifp->if_flags &= ~IFF_ALLMULTI;
	ETHER_FIRST_MULTI(step, &sc->sc_ac, enm);
	while (enm != NULL) {
		if (bcmp((caddr_t)&enm->enm_addrlo,
		    (caddr_t)&enm->enm_addrhi, sizeof(enm->enm_addrlo)) != 0) {
			/*
			 * We must listen to a range of multicast
			 * addresses. For now, just accept all
			 * multicasts, rather than trying to set only
			 * those filter bits needed to match the range.
			 * (At this time, the only use of address
			 * ranges is for IP multicast routing, for
			 * which the range is big enough to require all
			 * bits set.)
			 */
			ler2->ler2_ladrf[0] = 0xffff;
			ler2->ler2_ladrf[1] = 0xffff;
			ler2->ler2_ladrf[2] = 0xffff;
			ler2->ler2_ladrf[3] = 0xffff;
			ifp->if_flags |= IFF_ALLMULTI;
			return;
		}

		/*
		 * One would think, given the AM7990 document's polynomial
		 * of 0x04c11db6, that this should be 0x6db88320 (the bit
		 * reversal of the AMD value), but that is not right.  See
		 * the BASIC listing: bit 0 (our bit 31) must then be set.
		 */
		cp = (unsigned char *)&enm->enm_addrlo;
		crc = 0xffffffff;
		for (len = 6; --len >= 0;) {
			c = *cp++;
			for (i = 0; i < 8; i++) {
				if ((c & 0x01) ^ (crc & 0x01)) {
					crc >>= 1;
					crc = crc ^ 0xedb88320;
				} else
					crc >>= 1;
				c >>= 1;
			}
		}
		/* Just want the 6 most significant bits. */
		crc = crc >> 26;

		/* Turn on the corresponding bit in the filter. */
		ler2->ler2_ladrf[crc >> 4] |= 1 << (crc & 0xf);

		ETHER_NEXT_MULTI(step, enm);
	}
}

void
lereset(dev)
	struct device *dev;
{
	register struct le_softc *sc = (struct le_softc *)dev;
	register volatile struct lereg1 *ler1 = sc->sc_r1;
	register volatile struct lereg2 *ler2 = sc->sc_r2;
	register int i, a, timo, stat;

#if NBPFILTER > 0
	if (sc->sc_if.if_flags & IFF_PROMISC)
		ler2->ler2_mode = LE_MODE_NORMAL | LE_MODE_PROM;
	else
d207 2
a208 369
		ler2->ler2_mode = LE_MODE_NORMAL;
	ler1->ler1_rap = LE_CSR0;
	ler1->ler1_rdp = LE_C0_STOP;

	/* Setup the logical address filter */
	lesetladrf(sc);

	/* init receive and transmit rings */
	for (i = 0; i < LERBUF; i++) {
		a = LANCE_ADDR(&ler2->ler2_rbuf[i][0]);
		ler2->ler2_rmd[i].rmd0 = a;
		ler2->ler2_rmd[i].rmd1_hadr = a >> 16;
		ler2->ler2_rmd[i].rmd1_bits = LE_R1_OWN;
		ler2->ler2_rmd[i].rmd2 = -LEMTU | LE_XMD2_ONES;
		ler2->ler2_rmd[i].rmd3 = 0;
	}
	for (i = 0; i < LETBUF; i++) {
		a = LANCE_ADDR(&ler2->ler2_tbuf[i][0]);
		ler2->ler2_tmd[i].tmd0 = a;
		ler2->ler2_tmd[i].tmd1_hadr = a >> 16;
		ler2->ler2_tmd[i].tmd1_bits = 0;
		ler2->ler2_tmd[i].tmd2 = LE_XMD2_ONES;
		ler2->ler2_tmd[i].tmd3 = 0;
	}

	bzero((void *)&ler2->ler2_rbuf[0][0], (LERBUF + LETBUF) * LEMTU);
	/* lance will stuff packet into receive buffer 0 next */
	sc->sc_rmd = 0;

	/* tell the chip where to find the initialization block */
	a = LANCE_ADDR(&ler2->ler2_mode);
	ler1->ler1_rap = LE_CSR1;
	ler1->ler1_rdp = a;
	ler1->ler1_rap = LE_CSR2;
	ler1->ler1_rdp = a >> 16;
	ler1->ler1_rap = LE_CSR3;
	ler1->ler1_rdp = LE_C3_BSWP | LE_C3_ACON | LE_C3_BCON;
	ler1->ler1_rap = LE_CSR0;
	ler1->ler1_rdp = LE_C0_INIT;
	timo = 100000;
	while (((stat = ler1->ler1_rdp) & (LE_C0_ERR | LE_C0_IDON)) == 0) {
		if (--timo == 0) {
			printf("%s: init timeout, stat=%b\n",
			    sc->sc_dev.dv_xname, stat, LE_C0_BITS);
			break;
		}
	}
	if (stat & LE_C0_ERR)
		printf("%s: init failed, stat=%b\n",
		    sc->sc_dev.dv_xname, stat, LE_C0_BITS);
	else
		ler1->ler1_rdp = LE_C0_IDON;	/* clear IDON */
	ler1->ler1_rdp = LE_C0_STRT | LE_C0_INEA;
	sc->sc_if.if_flags &= ~IFF_OACTIVE;
}

/*
 * Initialization of interface
 */
int
leinit(unit)
	int unit;
{
	register struct le_softc *sc = lecd.cd_devs[unit];
	register struct ifnet *ifp = &sc->sc_if;
	register int s;

	if ((ifp->if_flags & IFF_RUNNING) == 0) {
		s = splimp();
		ifp->if_flags |= IFF_RUNNING;
		lereset(&sc->sc_dev);
		lestart(ifp);
		splx(s);
	}
	return (0);
}

/*
 * Start output on interface.  Get another datagram to send
 * off of the interface queue, and copy it to the interface
 * before starting the output.
 */
void
lestart(ifp)
	register struct ifnet *ifp;
{
	register struct le_softc *sc = lecd.cd_devs[ifp->if_unit];
	register volatile struct letmd *tmd;
	register struct mbuf *m;
	register int len;

	if ((sc->sc_if.if_flags & IFF_RUNNING) == 0)
		return;
	IF_DEQUEUE(&sc->sc_if.if_snd, m);
	if (m == 0)
		return;
	len = leput((char *)sc->sc_r2->ler2_tbuf[0], m);
#if NBPFILTER > 0
	/*
	 * If bpf is listening on this interface, let it
	 * see the packet before we commit it to the wire.
	 */
	if (sc->sc_if.if_bpf)
		bpf_tap(sc->sc_if.if_bpf, (u_char *)sc->sc_r2->ler2_tbuf[0], len);
#endif

#ifdef PACKETSTATS
	if (len <= LEMTU)
		lexpacketsizes[len]++;
#endif
	tmd = sc->sc_r2->ler2_tmd;
	tmd->tmd3 = 0;
	tmd->tmd2 = -len | LE_XMD2_ONES;
	tmd->tmd1_bits = LE_T1_OWN | LE_T1_STP | LE_T1_ENP;
	sc->sc_if.if_flags |= IFF_OACTIVE;
	return;
}

int
leintr(dev)
	register void *dev;
{
	register struct le_softc *sc = dev;
	register volatile struct lereg1 *ler1 = sc->sc_r1;
	register int csr0;

	csr0 = ler1->ler1_rdp;
	if ((csr0 & LE_C0_INTR) == 0)
		return (0);
	sc->sc_intrcnt.ev_count++;

	if (csr0 & LE_C0_ERR) {
		sc->sc_errcnt.ev_count++;
		leerror(sc, csr0);
		if (csr0 & LE_C0_MERR) {
			sc->sc_merr++;
			lereset(&sc->sc_dev);
			return (1);
		}
		if (csr0 & LE_C0_BABL)
			sc->sc_babl++;
		if (csr0 & LE_C0_CERR)
			sc->sc_cerr++;
		if (csr0 & LE_C0_MISS)
			sc->sc_miss++;
		ler1->ler1_rdp = LE_C0_BABL|LE_C0_CERR|LE_C0_MISS|LE_C0_INEA;
	}
	if ((csr0 & LE_C0_RXON) == 0) {
		sc->sc_rxoff++;
		lereset(&sc->sc_dev);
		return (1);
	}
	if ((csr0 & LE_C0_TXON) == 0) {
		sc->sc_txoff++;
		lereset(&sc->sc_dev);
		return (1);
	}
	if (csr0 & LE_C0_RINT) {
		/* interrupt is cleared in lerint */
		lerint(sc);
	}
	if (csr0 & LE_C0_TINT) {
		ler1->ler1_rdp = LE_C0_TINT|LE_C0_INEA;
		lexint(sc);
	}
	return (1);
}

/*
 * Ethernet interface transmitter interrupt.
 * Start another output if more data to send.
 */
void
lexint(sc)
	register struct le_softc *sc;
{
	register volatile struct letmd *tmd = sc->sc_r2->ler2_tmd;

	sc->sc_lestats.lexints++;
	if ((sc->sc_if.if_flags & IFF_OACTIVE) == 0) {
		sc->sc_xint++;
		return;
	}
	if (tmd->tmd1_bits & LE_T1_OWN) {
		sc->sc_xown++;
		return;
	}
	if (tmd->tmd1_bits & LE_T1_ERR) {
err:
		lexerror(sc);
		sc->sc_if.if_oerrors++;
		if (tmd->tmd3 & (LE_T3_BUFF|LE_T3_UFLO)) {
			sc->sc_uflo++;
			lereset(&sc->sc_dev);
		} else if (tmd->tmd3 & LE_T3_LCOL)
			sc->sc_if.if_collisions++;
		else if (tmd->tmd3 & LE_T3_RTRY)
			sc->sc_if.if_collisions += 16;
	}
	else if (tmd->tmd3 & LE_T3_BUFF)
		/* XXX documentation says BUFF not included in ERR */
		goto err;
	else if (tmd->tmd1_bits & LE_T1_ONE)
		sc->sc_if.if_collisions++;
	else if (tmd->tmd1_bits & LE_T1_MORE)
		/* what is the real number? */
		sc->sc_if.if_collisions += 2;
	else
		sc->sc_if.if_opackets++;
	sc->sc_if.if_flags &= ~IFF_OACTIVE;
	lestart(&sc->sc_if);
}

#define	LENEXTRMP \
	if (++bix == LERBUF) bix = 0, rmd = sc->sc_r2->ler2_rmd; else ++rmd

/*
 * Ethernet interface receiver interrupt.
 * If input error just drop packet.
 * Decapsulate packet based on type and pass to type specific
 * higher-level input routine.
 */
void
lerint(sc)
	register struct le_softc *sc;
{
	register int bix = sc->sc_rmd;
	register volatile struct lermd *rmd = &sc->sc_r2->ler2_rmd[bix];

	sc->sc_lestats.lerints++;
	/*
	 * Out of sync with hardware, should never happen?
	 */
	if (rmd->rmd1_bits & LE_R1_OWN) {
		do {
			sc->sc_lestats.lerscans++;
			LENEXTRMP;
		} while ((rmd->rmd1_bits & LE_R1_OWN) && bix != sc->sc_rmd);
		if (bix == sc->sc_rmd)
			printf("%s: RINT with no buffer\n",
			    sc->sc_dev.dv_xname);
	} else
		sc->sc_lestats.lerhits++;

	/*
	 * Process all buffers with valid data
	 */
	while ((rmd->rmd1_bits & LE_R1_OWN) == 0) {
		int len = rmd->rmd3;

		/* Clear interrupt to avoid race condition */
		sc->sc_r1->ler1_rdp = LE_C0_RINT|LE_C0_INEA;

		if (rmd->rmd1_bits & LE_R1_ERR) {
			sc->sc_rmd = bix;
			lererror(sc, "bad packet");
			sc->sc_if.if_ierrors++;
		} else if ((rmd->rmd1_bits & (LE_R1_STP|LE_R1_ENP)) !=
		    (LE_R1_STP|LE_R1_ENP)) {
			/* XXX make a define for LE_R1_STP|LE_R1_ENP? */
			/*
			 * Find the end of the packet so we can see how long
			 * it was.  We still throw it away.
			 */
			do {
				sc->sc_r1->ler1_rdp = LE_C0_RINT|LE_C0_INEA;
				rmd->rmd3 = 0;
				rmd->rmd1_bits = LE_R1_OWN;
				LENEXTRMP;
			} while (!(rmd->rmd1_bits &
			    (LE_R1_OWN|LE_R1_ERR|LE_R1_STP|LE_R1_ENP)));
			sc->sc_rmd = bix;
			lererror(sc, "chained buffer");
			sc->sc_rxlen++;
			/*
			 * If search terminated without successful completion
			 * we reset the hardware (conservative).
			 */
			if ((rmd->rmd1_bits &
			    (LE_R1_OWN|LE_R1_ERR|LE_R1_STP|LE_R1_ENP)) !=
			    LE_R1_ENP) {
				lereset(&sc->sc_dev);
				return;
			}
		} else {
			leread(sc, (char *)sc->sc_r2->ler2_rbuf[bix], len);
#ifdef PACKETSTATS
			lerpacketsizes[len]++;
#endif
			sc->sc_lestats.lerbufs++;
		}
		rmd->rmd3 = 0;
		rmd->rmd1_bits = LE_R1_OWN;
		LENEXTRMP;
	}
	sc->sc_rmd = bix;
}

void
leread(sc, pkt, len)
	register struct le_softc *sc;
	char *pkt;
	int len;
{
	register struct ether_header *et;
	register struct ifnet *ifp = &sc->sc_if;
	struct mbuf *m;
	struct ifqueue *inq;
	int flags;

	ifp->if_ipackets++;
	et = (struct ether_header *)pkt;
	et->ether_type = ntohs((u_short)et->ether_type);
	/* adjust input length to account for header and CRC */
	len -= sizeof(struct ether_header) + 4;

	if (len <= 0) {
		if (ledebug)
			log(LOG_WARNING,
			    "%s: ierror(runt packet): from %s: len=%d\n",
			    sc->sc_dev.dv_xname,
			    ether_sprintf(et->ether_shost), len);
		sc->sc_runt++;
		ifp->if_ierrors++;
		return;
	}

	/* Setup mbuf flags we'll need later */
	flags = 0;
	if (bcmp((caddr_t)etherbroadcastaddr,
	    (caddr_t)et->ether_dhost, sizeof(etherbroadcastaddr)) == 0)
		flags |= M_BCAST;
	if (et->ether_dhost[0] & 1)
		flags |= M_MCAST;

#if NBPFILTER > 0
	/*
	 * Check if there's a bpf filter listening on this interface.
	 * If so, hand off the raw packet to enet, then discard things
	 * not destined for us (but be sure to keep broadcast/multicast).
	 */
	if (sc->sc_if.if_bpf) {
		bpf_tap(sc->sc_if.if_bpf, pkt,
		    len + sizeof(struct ether_header));
		if ((flags & (M_BCAST | M_MCAST)) == 0 &&
		    bcmp(et->ether_dhost, sc->sc_addr,
			    sizeof(et->ether_dhost)) != 0)
			return;
	}
#endif
	m = leget(pkt, len, 0, ifp);
	if (m == 0)
		return;
	ether_input(ifp, et, m);
}

/*
 * Routine to copy from mbuf chain to transmit
 * buffer in board local memory.
 *
 * ### this can be done by remapping in some cases
 */
int
leput(lebuf, m)
	register char *lebuf;
	register struct mbuf *m;
{
	register struct mbuf *mp;
	register int len, tlen = 0;
d210 3
a212 12
	for (mp = m; mp; mp = mp->m_next) {
		len = mp->m_len;
		if (len == 0)
			continue;
		tlen += len;
		bcopy(mtod(mp, char *), lebuf, len);
		lebuf += len;
	}
	m_freem(m);
	if (tlen < LEMINSIZE) {
		bzero(lebuf, LEMINSIZE - tlen);
		tlen = LEMINSIZE;
a213 1
	return (tlen);
d216 1
a216 226
/*
 * Routine to copy from board local memory into mbufs.
 */
struct mbuf *
leget(lebuf, totlen, off0, ifp)
	char *lebuf;
	int totlen, off0;
	struct ifnet *ifp;
{
	register struct mbuf *m;
	struct mbuf *top = 0, **mp = &top;
	register int off = off0, len;
	register char *cp;
	char *epkt;

	lebuf += sizeof(struct ether_header);
	cp = lebuf;
	epkt = cp + totlen;
	if (off) {
		cp += off + 2 * sizeof(u_short);
		totlen -= 2 * sizeof(u_short);
	}

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == 0)
		return (0);
	m->m_pkthdr.rcvif = ifp;
	m->m_pkthdr.len = totlen;
	m->m_len = MHLEN;

	while (totlen > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == 0) {
				m_freem(top);
				return (0);
			}
			m->m_len = MLEN;
		}
		len = min(totlen, epkt - cp);
		if (len >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if (m->m_flags & M_EXT)
				m->m_len = len = min(len, MCLBYTES);
			else
				len = m->m_len;
		} else {
			/*
			 * Place initial small packet/header at end of mbuf.
			 */
			if (len < m->m_len) {
				if (top == 0 && len + max_linkhdr <= m->m_len)
					m->m_data += max_linkhdr;
				m->m_len = len;
			} else
				len = m->m_len;
		}
		bcopy(cp, mtod(m, caddr_t), (unsigned)len);
		cp += len;
		*mp = m;
		mp = &m->m_next;
		totlen -= len;
		if (cp == epkt)
			cp = lebuf;
	}
	return (top);
}

/*
 * Process an ioctl request.
 */
int
leioctl(ifp, cmd, data)
	register struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	register struct ifaddr *ifa;
	register struct le_softc *sc = lecd.cd_devs[ifp->if_unit];
	register volatile struct lereg1 *ler1;
	int s = splimp(), error = 0;

	switch (cmd) {

	case SIOCSIFADDR:
		ifa = (struct ifaddr *)data;
		ifp->if_flags |= IFF_UP;
		switch (ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			(void)leinit(ifp->if_unit);
			arp_ifinit(&sc->sc_ac, ifa);
			break;
#endif
#ifdef NS
		case AF_NS:
		    {
			register struct ns_addr *ina = &(IA_SNS(ifa)->sns_addr);

			if (ns_nullhost(*ina))
				ina->x_host = *(union ns_host *)(sc->sc_addr);
			else {
				/*
				 * The manual says we can't change the address
				 * while the receiver is armed,
				 * so reset everything
				 */
				ifp->if_flags &= ~IFF_RUNNING;
				bcopy((caddr_t)ina->x_host.c_host,
				    (caddr_t)sc->sc_addr, sizeof(sc->sc_addr));
			}
			(void)leinit(ifp->if_unit);	/* does le_setaddr() */
			break;
		    }
#endif
		default:
			(void)leinit(ifp->if_unit);
			break;
		}
		break;

	case SIOCSIFFLAGS:
		ler1 = sc->sc_r1;
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    ifp->if_flags & IFF_RUNNING) {
			ler1->ler1_rdp = LE_C0_STOP;
			ifp->if_flags &= ~IFF_RUNNING;
		} else if (ifp->if_flags & IFF_UP &&
		    (ifp->if_flags & IFF_RUNNING) == 0)
			(void)leinit(ifp->if_unit);
		/*
		 * If the state of the promiscuous bit changes, the interface
		 * must be reset to effect the change.
		 */
		if (((ifp->if_flags ^ sc->sc_iflags) & IFF_PROMISC) &&
		    (ifp->if_flags & IFF_RUNNING)) {
			sc->sc_iflags = ifp->if_flags;
			lereset(&sc->sc_dev);
			lestart(ifp);
		}
		break;

	case SIOCADDMULTI:
		error = ether_addmulti((struct ifreq *)data, &sc->sc_ac);
		goto update_multicast;

	case SIOCDELMULTI:
		error = ether_delmulti((struct ifreq *)data, &sc->sc_ac);
	update_multicast:
		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			lereset(&sc->sc_dev);
			error = 0;
		}
		break;

	default:
		error = EINVAL;
	}
	splx(s);
	return (error);
}

void
leerror(sc, stat)
	register struct le_softc *sc;
	int stat;
{
	if (!ledebug)
		return;

	/*
	 * Not all transceivers implement heartbeat
	 * so we only log CERR once.
	 */
	if ((stat & LE_C0_CERR) && sc->sc_cerr)
		return;
	log(LOG_WARNING, "%s: error: stat=%b\n",
	    sc->sc_dev.dv_xname, stat, LE_C0_BITS);
}

void
lererror(sc, msg)
	register struct le_softc *sc;
	char *msg;
{
	register volatile struct lermd *rmd;
	int len;

	if (!ledebug)
		return;

	rmd = &sc->sc_r2->ler2_rmd[sc->sc_rmd];
	len = rmd->rmd3;
	log(LOG_WARNING, "%s: ierror(%s): from %s: buf=%d, len=%d, rmd1=%b\n",
	    sc->sc_dev.dv_xname, msg, len > 11 ?
	    ether_sprintf((u_char *)&sc->sc_r2->ler2_rbuf[sc->sc_rmd][6]) :
	    "unknown",
	    sc->sc_rmd, len, rmd->rmd1_bits, LE_R1_BITS);
}

void
lexerror(sc)
	register struct le_softc *sc;
{
	register volatile struct letmd *tmd;
	register int len, tmd3, tdr;

	if (!ledebug)
		return;

	tmd = sc->sc_r2->ler2_tmd;
	tmd3 = tmd->tmd3;
	tdr = tmd3 & LE_T3_TDR_MASK;
	len = -(tmd->tmd2 & ~LE_XMD2_ONES);
	log(LOG_WARNING,
    "%s: oerror: to %s: buf=%d, len=%d, tmd1=%b, tmd3=%b, tdr=%d (%d nsecs)\n",
	    sc->sc_dev.dv_xname, len > 5 ?
	    ether_sprintf((u_char *)&sc->sc_r2->ler2_tbuf[0][0]) : "unknown",
	    0, len,
	    tmd->tmd1_bits, LE_T1_BITS,
	    tmd3, LE_T3_BITS, tdr, tdr * 100);
}
@


1.3
log
@Cast in places where we discard volatile pointers in function calls.  We
know that what we are doing is ok, so let gcc know this.
@
text
@d415 1
a415 1
bzero((void *)&ler2->ler2_rbuf[0][0], (LERBUF + LETBUF) * LEMTU);
@


1.2
log
@ra_len is useless
@
text
@d415 1
a415 1
bzero(&ler2->ler2_rbuf[0][0], (LERBUF + LETBUF) * LEMTU);
d486 1
a486 1
	len = leput(sc->sc_r2->ler2_tbuf[0], m);
d493 1
a493 1
		bpf_tap(sc->sc_if.if_bpf, sc->sc_r2->ler2_tbuf[0], len);
d675 1
a675 1
			leread(sc, sc->sc_r2->ler2_rbuf[bix], len);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: if_le.c,v 1.21 1995/06/23 13:19:44 pk Exp $ */
a183 1
	ra->ra_len = NBPG;
a456 1
	/* not yet, if address still unknown */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
