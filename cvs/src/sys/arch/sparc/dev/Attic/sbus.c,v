head	1.22;
access;
symbols
	OPENBSD_6_0:1.21.0.6
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.19.0.14
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.18
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.16
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.12
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.10
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.8
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.6
	OPENBSD_5_0:1.19.0.4
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.16.0.10
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.12
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.8
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.6
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.13.0.10
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.8
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.10.0.2
	UBC_BASE:1.10
	OPENBSD_3_0:1.8.0.12
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.10
	OPENBSD_2_8:1.8.0.8
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.6
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.4
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2016.09.01.09.23.42;	author tedu;	state dead;
branches;
next	1.21;
commitid	Q2PxaFNhqAe0Wmla;

1.21
date	2015.03.30.20.30.22;	author miod;	state Exp;
branches;
next	1.20;
commitid	f66FukLLgPJs9j5H;

1.20
date	2015.03.21.19.55.31;	author miod;	state Exp;
branches;
next	1.19;
commitid	OfcnEu8uBAPP2zIO;

1.19
date	2010.12.26.15.37.20;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2010.09.05.18.10.10;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2010.07.10.19.32.24;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.29.09.54.13;	author sobrado;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.02.20.00.54;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.02.25.23.41.39;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.18.17.33.33;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.23.27.54;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.43;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.19.19.22.43;	author deraadt;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	99.04.18.03.24.25;	author jason;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	98.12.14.17.51.35;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.11.11.00.26.00;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	97.08.08.08.25.27;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.21.46.18;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.08.11.05.34.28;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.18.17.08.04;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.40;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.40;	author deraadt;	state Exp;
branches;
next	;

1.8.4.1
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2001.12.05.00.39.13;	author niklas;	state Exp;
branches;
next	1.8.4.3;

1.8.4.3
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.8.4.4;

1.8.4.4
date	2003.06.07.11.14.43;	author ho;	state Exp;
branches;
next	1.8.4.5;

1.8.4.5
date	2004.02.19.10.49.58;	author niklas;	state Exp;
branches;
next	;

1.10.2.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: sbus.c,v 1.21 2015/03/30 20:30:22 miod Exp $	*/
/*	$NetBSD: sbus.c,v 1.17 1997/06/01 22:10:39 pk Exp $ */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)sbus.c	8.1 (Berkeley) 6/11/93
 */

/*
 * SBus stuff.
 */

#include <sys/param.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>

#include <sparc/dev/sbusreg.h>
#include <sparc/dev/sbusvar.h>
#include <sparc/dev/xboxreg.h>
#include <sparc/dev/xboxvar.h>
#include <sparc/dev/dmareg.h>

int sbus_print(void *, const char *);

/* autoconfiguration driver */
void	sbus_attach(struct device *, struct device *, void *);
int	sbus_match(struct device *, void *, void *);
int	sbus_search(struct device *, void *, void *);

struct cfattach sbus_ca = {
	sizeof(struct sbus_softc), sbus_match, sbus_attach
};

struct cfdriver sbus_cd = {
	NULL, "sbus", DV_DULL
};

/*
 * SBus driver attach arguments.
 * We carry a few more information than a mere struct confargs internally,
 * for the sake of sbus_match() and sbus_print().
 */
struct sbus_attach_args {
	struct confargs	sa_ca;
	int		sa_slave_only;
	int		sa_unsupported;
};

static /*const*/ char *sl = "slave-only";

/*
 * Print the location of some sbus-attached device (called just
 * before attaching that device).  If `sbus' is not NULL, the
 * device was found but not configured; print the sbus as well.
 * Return UNCONF (config_find ignores this if the device was configured).
 */
int
sbus_print(void *args, const char *sbus)
{
	struct sbus_attach_args *sa = args;
	char *class;

	if (sbus != NULL) {
		printf("\"%s\" at %s", sa->sa_ca.ca_ra.ra_name, sbus);
		class = getpropstring(sa->sa_ca.ca_ra.ra_node, "device_type");
		if (*class != '\0')
			printf(" class %s", class);
	}
	if (sa->sa_slave_only)
		printf(" %s", sl);
	printf(" slot %d offset 0x%x", sa->sa_ca.ca_slot, sa->sa_ca.ca_offset);

	return sa->sa_unsupported != 0 ? UNSUPP : UNCONF;
}

int
sbus_match(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

	if (CPU_ISSUN4)
		return (0);

	if (ca->ca_bustype == BUS_XBOX) {
		struct xbox_softc *xsc = (struct xbox_softc *)parent;

		/* Prevent multiple attachments */
		if (xsc->sc_attached == 0) {
			xsc->sc_attached = 1;
			return (1);
		}

		return (0);
	}

	return (strcmp(cf->cf_driver->cd_name, ra->ra_name) == 0);
}

/*
 * Attach an SBus.
 */
void
sbus_attach(struct device *parent, struct device *self, void *aux)
{
	struct sbus_softc *sc = (struct sbus_softc *)self;
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;
	int node;
	char *name;
	struct sbus_attach_args saa;
	int rlen;

	/*
	 * XXX there is only one SBus, for now -- do not know how to
	 * address children on others
	 */
	if (sc->sc_dev.dv_unit > 0 && ca->ca_bustype != BUS_XBOX) {
		printf(" unsupported\n");
		return;
	}

	/*
	 * Record clock frequency for synchronous SCSI.
	 * IS THIS THE CORRECT DEFAULT??
	 */
	node = ra->ra_node;
	sc->sc_clockfreq = getpropint(node, "clock-frequency", -1);
	if (sc->sc_clockfreq <= 0)
		sc->sc_clockfreq = getpropint(findroot(), "clock-frequency",
		    25 * 1000 * 1000);
	printf(": %s MHz\n", clockfreq(sc->sc_clockfreq));

	/*
	 * Get the SBus burst transfer size if burst transfers are supported
	 */
	sc->sc_burst = getpropint(node, "burst-sizes", 0);
	sc->sc_burst = sc->sc_burst & ~SBUS_BURST_64;

	if (ca->ca_bustype == BUS_XBOX) {
		struct xbox_softc *xsc = (struct xbox_softc *)parent;

		/* Parent has already done the leg work */
		sc->sc_nrange = xsc->sc_nrange;
		sc->sc_range = xsc->sc_range;
		xsc->sc_attached = 2;

		sc->sc_slave_only = getpropint(node, sl, 0);
	} else {
		/* Check root node for 'slave-only' property */
		sc->sc_slave_only = getpropint(0, sl, 0);

		rlen = getproplen(node, "ranges");
		if (rlen > 0) {
			sc->sc_nrange = rlen / sizeof(struct rom_range);
			sc->sc_range =
			    (struct rom_range *)malloc(rlen, M_DEVBUF, M_NOWAIT);
			if (sc->sc_range == NULL)
				panic("sbus: PROM ranges too large: %d", rlen);
			(void)getprop(node, "ranges", sc->sc_range, rlen);
		}
	}

	if (ca->ca_bustype != BUS_XBOX && ra->ra_bp != NULL &&
	    strcmp(ra->ra_bp->name, "sbus") == 0)
		saa.sa_ca.ca_ra.ra_bp = ra->ra_bp + 1;
	else
		saa.sa_ca.ca_ra.ra_bp = NULL;

	/*
	 * Loop through ROM children, fixing any relative addresses
	 * and then configuring each device.
	 */
	for (node = firstchild(node); node; node = nextsibling(node)) {
		name = getpropstring(node, "name");
#ifdef SUN4E
		if (CPU_ISSUN4E && strcmp(name, "vm") == 0)
			continue;
#endif
		if (!romprop(&saa.sa_ca.ca_ra, name, node))
			continue;

		saa.sa_ca.ca_bustype = BUS_SBUS;
		saa.sa_ca.ca_dmat = ca->ca_dmat;
		saa.sa_unsupported = sbus_translate(self, &saa.sa_ca) != 0;
		saa.sa_slave_only =
		    sc->sc_slave_only & (1 << saa.sa_ca.ca_slot);

		config_found_sm(&sc->sc_dev, (void *)&saa, sbus_print,
		    sbus_search);
	}
}

int
sbus_search(struct device *parent, void *vcf, void *args)
{
	struct cfdata *cf = vcf;
	struct sbus_attach_args *saa = args;

	if (saa->sa_unsupported != 0)
		return 0;

	return (cf->cf_attach->ca_match)(parent, cf, &saa->sa_ca);
}

int
sbus_translate(struct device *dev, struct confargs *ca)
{
	struct sbus_softc *sc = (struct sbus_softc *)dev;
	int base, slot;
	int i;

	if (sc->sc_nrange == 0) {
		/* Old-style SBus configuration */
		base = (int)ca->ca_ra.ra_paddr;
		if (SBUS_ABS(base)) {
			ca->ca_slot = SBUS_ABS_TO_SLOT(base);
			ca->ca_offset = SBUS_ABS_TO_OFFSET(base);
		} else {
			if (!CPU_ISSUN4C && !CPU_ISSUN4E) {
				printf("%s: relative sbus addressing not supported\n",
				    dev->dv_xname);
				return ENXIO;
			}
			ca->ca_slot = slot = ca->ca_ra.ra_iospace;
			ca->ca_offset = base;

			/* Fix all register banks */
			for (i = 0; i < ca->ca_ra.ra_nreg; i++) {
				base = (int)ca->ca_ra.ra_reg[i].rr_paddr;
				if ((base & ~SBUS_PAGE_MASK) != 0)
					return ENXIO;
				ca->ca_ra.ra_reg[i].rr_paddr =
					(void *)SBUS_ADDR(slot, base);
				ca->ca_ra.ra_reg[i].rr_iospace = PMAP_OBIO;
			}
		}
	} else {
		ca->ca_slot = ca->ca_ra.ra_iospace;
		ca->ca_offset = (int)ca->ca_ra.ra_paddr;

		/* Translate into parent address spaces */
		for (i = 0; i < ca->ca_ra.ra_nreg; i++) {
			int j, cspace = ca->ca_ra.ra_reg[i].rr_iospace;

			for (j = 0; j < sc->sc_nrange; j++) {
				if (sc->sc_range[j].cspace == cspace) {
					ca->ca_ra.ra_reg[i].rr_paddr +=
						sc->sc_range[j].poffset;
					ca->ca_ra.ra_reg[i].rr_iospace =
						sc->sc_range[j].pspace;
					break;
				}
			}
		}
	}

	return 0;
}

/*
 * Returns true if this sbus slot is capable of dma
 */
int
sbus_testdma(struct sbus_softc *sc, struct confargs *ca)
{
        struct romaux *ra = &ca->ca_ra;

	if (sc->sc_slave_only & (1 << ca->ca_slot)) {
		printf("%s: dma card found in non-dma sbus slot %d"
			": not supported\n", ra->ra_name, ca->ca_slot);
		return (0);
	}

	return (1);
}
@


1.21
log
@Add a bus_dma_tag_t for DVMA usage, suitable for use for devices not sitting
behind a sun4m iommu.

Move the existing dvma routines from vm_machdep.c to this new dvma.c; this
allows for a few declarations to be removed from public headers.

Extend the device attachment arguments (struct confargs) to pass a
bus_dma_tag_t. mainbus receives the dvma bus_dma_tag_t, and devices pass the
tag unchanged to their children, except for iommu(4) which replaces it with
its own.

Change the few sun4m-only drivers to pick the bus_dma_tag_t from confargs
rather than assume iommu; this allows qlw(4) to attach and work on sun4c.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.20 2015/03/21 19:55:31 miod Exp $	*/
@


1.20
log
@When an IOMMU is not available, and an sbus board has register ranges not
reachable with the default slot aperture (such as hme(4) devices, which have
their registers at offset 0x08c00000 from the slot base), force the attachment
of the device to fail.

While hme would fail early due to being unable to talk on the mdio bus, hme+esp
boards would have the esp part of the board get nuts and would spin during
autoconf. Of course, you are not supposed to use such boards on sun4c, because
(as mentioned above) they can't run without an iommu.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.19 2010/12/26 15:37:20 kettenis Exp $	*/
d78 13
d97 1
a97 3
sbus_print(args, sbus)
	void *args;
	const char *sbus;
d99 1
a99 1
	struct confargs *ca = args;
a100 1
	static char *sl = "slave-only";
d103 2
a104 2
		printf("\"%s\" at %s", ca->ca_ra.ra_name, sbus);
		class = getpropstring(ca->ca_ra.ra_node, "device_type");
d108 1
a108 2
	/* Check root node for 'slave-only' property */
	if (getpropint(0, sl, 0) & (1 << ca->ca_slot))
d110 1
a110 1
	printf(" slot %d offset 0x%x", ca->ca_slot, ca->ca_offset);
d112 1
a112 1
	return ca->ca_bustype < 0 ? UNSUPP : UNCONF;
d116 1
a116 3
sbus_match(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
d118 3
a120 3
	register struct cfdata *cf = vcf;
	register struct confargs *ca = aux;
	register struct romaux *ra = &ca->ca_ra;
d144 1
a144 4
sbus_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d146 1
a146 1
	register struct sbus_softc *sc = (struct sbus_softc *)self;
d148 4
a151 4
	register struct romaux *ra = &ca->ca_ra;
	register int node;
	register char *name;
	struct confargs oca;
d187 2
d190 2
a191 4
		if (ra->ra_bp != NULL && strcmp(ra->ra_bp->name, "sbus") == 0)
			oca.ca_ra.ra_bp = ra->ra_bp + 1;
		else
			oca.ca_ra.ra_bp = NULL;
d197 2
a198 2
				(struct rom_range *)malloc(rlen, M_DEVBUF, M_NOWAIT);
			if (sc->sc_range == 0)
d204 6
d220 1
a220 1
		if (!romprop(&oca.ca_ra, name, node))
d223 5
a227 4
		if (sbus_translate(self, &oca) == 0)
			oca.ca_bustype = BUS_SBUS;
		else
			oca.ca_bustype = -1;	/* force attach to fail */
d229 1
a229 1
		config_found_sm(&sc->sc_dev, (void *)&oca, sbus_print,
d238 1
a238 1
	struct confargs *oca = args;
d240 1
a240 1
	if (oca->ca_bustype < 0)
d243 1
a243 1
	return (cf->cf_attach->ca_match)(parent, cf, oca);
d247 1
a247 3
sbus_translate(dev, ca)
	struct device *dev;
	struct confargs *ca;
d305 1
a305 3
sbus_testdma(sc, ca)
	struct sbus_softc *sc;
	struct confargs *ca;
d309 1
a309 5
	/*
	 * XXX how to handle more than one sbus?
	 */

	if (getpropint(0, "slave-only", 0) & (1 << ca->ca_slot)) {
@


1.19
log
@Clean up how we print the sbus(4) clock speed.  Purely cosmetic.

ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.18 2010/09/05 18:10:10 kettenis Exp $	*/
d67 1
d102 2
a103 1
	return (UNCONF);
d183 1
a183 2
	}
	else {
d213 7
a219 3
		sbus_translate(self, &oca);
		oca.ca_bustype = BUS_SBUS;
		(void) config_found(&sc->sc_dev, (void *)&oca, sbus_print);
d223 13
a235 1
void
d241 2
a242 2
	register int base, slot;
	register int i;
d251 5
a255 2
			if (!CPU_ISSUN4C && !CPU_ISSUN4E)
				panic("relative sbus addressing not supported");
a257 2
			ca->ca_ra.ra_paddr = (void *)SBUS_ADDR(slot, base);
			ca->ca_ra.ra_iospace = PMAP_OBIO;
d259 2
a260 2
			/* Fix any remaining register banks */
			for (i = 1; i < ca->ca_ra.ra_nreg; i++) {
d262 2
a268 1

a269 1

d288 2
@


1.18
log
@Remove bogus LHS casts.  makes gcc4 happy.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.17 2010/07/10 19:32:24 miod Exp $	*/
d166 1
a166 1
	printf(": clock = %s MHz\n", clockfreq(sc->sc_clockfreq));
@


1.17
log
@sun4e (i.e. SPARCengine 1e) support. This platform is a mix between sun4 and
sun4c, as it has a sun4c OpenPROM but a sun4 8KB pagesize. VME devices are
not supported yet.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.16 2007/05/29 09:54:13 sobrado Exp $	*/
d261 1
a261 1
					(int)ca->ca_ra.ra_reg[i].rr_paddr +=
d263 1
a263 1
					(int)ca->ca_ra.ra_reg[i].rr_iospace =
@


1.16
log
@use the right capitalization for `SBus'

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.15 2006/06/02 20:00:54 miod Exp $	*/
d162 4
a165 1
	sc->sc_clockfreq = getpropint(node, "clock-frequency", 25*1000*1000);
d205 4
d234 1
a234 1
			if (!CPU_ISSUN4C)
@


1.15
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.14 2006/02/25 23:41:39 kettenis Exp $	*/
d45 1
a45 1
 * Sbus stuff.
d132 1
a132 1
 * Attach an Sbus.
d149 1
a149 1
	 * XXX there is only one Sbus, for now -- do not know how to
d221 1
a221 1
		/* Old-style Sbus configuration */
@


1.14
log
@Put quotation marks around names of unconfigured devices.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.13 2003/06/18 17:33:33 miod Exp $	*/
a62 1
void sbusreset(int);
a260 56
		}
	}
}

/*
 * Each attached device calls sbus_establish after it initializes
 * its sbusdev portion.
 */
void
sbus_establish(sd, dev)
	register struct sbusdev *sd;
	register struct device *dev;
{
	register struct sbus_softc *sc;
	register struct device *curdev;

	/*
	 * We have to look for the sbus by name, since it is not necessarily
	 * our immediate parent (i.e. sun4m /iommu/sbus/espdma/esp)
	 * We don't just use the device structure of the above-attached
	 * sbus, since we might (in the future) support multiple sbus's.
	 */
	for (curdev = dev->dv_parent; ; curdev = curdev->dv_parent) {
		if (!curdev || !curdev->dv_xname)
			panic("sbus_establish: can't find sbus parent for %s",
			      sd->sd_dev->dv_xname
					? sd->sd_dev->dv_xname
					: "<unknown>" );

		if (strncmp(curdev->dv_xname, "sbus", 4) == 0)
			break;
	}
	sc = (struct sbus_softc *) curdev;

	sd->sd_dev = dev;
	sd->sd_bchain = sc->sc_sbdev;
	sc->sc_sbdev = sd;
}

/*
 * Reset the given sbus. (???)
 */
void
sbusreset(sbus)
	int sbus;
{
	register struct sbusdev *sd;
	struct sbus_softc *sc = sbus_cd.cd_devs[sbus];
	struct device *dev;

	printf("reset %s:", sc->sc_dev.dv_xname);
	for (sd = sc->sc_sbdev; sd != NULL; sd = sd->sd_bchain) {
		if (sd->sd_reset) {
			dev = sd->sd_dev;
			(*sd->sd_reset)(dev);
			printf(" %s", dev->dv_xname);
@


1.13
log
@When reporting unknown sbus hardware, also report the hardware class (audio,
block device...) if it advertizes one.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.12 2003/06/02 23:27:54 millert Exp $	*/
d93 1
a93 1
		printf("%s at %s", ca->ca_ra.ra_name, sbus);
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.11 2002/03/14 01:26:43 millert Exp $	*/
d88 2
a89 1
	register struct confargs *ca = args;
d92 1
a92 1
	if (sbus)
d94 4
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.10 2001/11/19 19:22:43 deraadt Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.10
log
@more than typo
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.9 2001/11/06 19:53:16 miod Exp $	*/
d66 2
a67 2
int sbus_print __P((void *, const char *));
void sbusreset __P((int));
d70 2
a71 2
void	sbus_attach __P((struct device *, struct device *, void *));
int	sbus_match __P((struct device *, void *, void *));
@


1.10.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.10 2001/11/19 19:22:43 deraadt Exp $	*/
d66 2
a67 2
int sbus_print(void *, const char *);
void sbusreset(int);
d70 2
a71 2
void	sbus_attach(struct device *, struct device *, void *);
int	sbus_match(struct device *, void *, void *);
@


1.9
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.8 1999/04/18 03:24:25 jason Exp $	*/
d332 1
a332 1
	 * XXX how to handle more then one sbus?
@


1.8
log
@Support for the Sun SBus Expansion Subsystem (SUNW,xbox)
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.7 1998/12/14 17:51:35 deraadt Exp $	*/
d56 1
a56 1
#include <vm/vm.h>
@


1.8.4.1
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 1
a56 1
#include <uvm/uvm_extern.h>
@


1.8.4.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.8.4.1 2001/11/13 21:04:17 niklas Exp $	*/
d332 1
a332 1
	 * XXX how to handle more than one sbus?
@


1.8.4.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d66 2
a67 2
int sbus_print(void *, const char *);
void sbusreset(int);
d70 2
a71 2
void	sbus_attach(struct device *, struct device *, void *);
int	sbus_match(struct device *, void *, void *);
@


1.8.4.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.8.4.3 2002/03/28 10:57:10 niklas Exp $	*/
d25 5
a29 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.8.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d88 1
a88 2
	struct confargs *ca = args;
	char *class;
d91 1
a91 1
	if (sbus != NULL) {
a92 4
		class = getpropstring(ca->ca_ra.ra_node, "device_type");
		if (*class != '\0')
			printf(" class %s", class);
	}
@


1.7
log
@ss20 machines which claim to have SBUS_BURST_64 are lying
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.6 1998/11/11 00:26:00 jason Exp $	*/
d62 2
d116 12
d152 1
a152 1
	if (sc->sc_dev.dv_unit > 0) {
d171 23
a193 13
	if (ra->ra_bp != NULL && strcmp(ra->ra_bp->name, "sbus") == 0)
		oca.ca_ra.ra_bp = ra->ra_bp + 1;
	else
		oca.ca_ra.ra_bp = NULL;

	rlen = getproplen(node, "ranges");
	if (rlen > 0) {
		sc->sc_nrange = rlen / sizeof(struct rom_range);
		sc->sc_range =
			(struct rom_range *)malloc(rlen, M_DEVBUF, M_NOWAIT);
		if (sc->sc_range == 0)
			panic("sbus: PROM ranges too large: %d", rlen);
		(void)getprop(node, "ranges", sc->sc_range, rlen);
@


1.6
log
@Detect cards that require dma that are in non-dma slots and don't allow
them to be attach'd.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.5 1997/08/08 08:25:27 downsj Exp $	*/
d62 1
d155 1
@


1.5
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d90 1
d94 3
d293 23
@


1.4
log
@added const to second parameter of cfprint_t routines
@
text
@d1 2
a2 1
/*	$NetBSD: sbus.c,v 1.10 1996/04/22 02:35:03 abrown Exp $ */
d53 1
d56 1
d102 1
a102 1
	struct cfdata *cf = vcf;
d127 1
d156 9
a164 2
	sc->sc_range = ra->ra_range;
	sc->sc_nrange = ra->ra_nrange;
d197 2
d201 3
a203 2
			ca->ca_ra.ra_paddr =
				(void *)SBUS_ADDR(slot, base);
d209 1
d255 4
a258 3
		    panic("sbus_establish: can't find sbus parent for %s",
			  (sd->sd_dev->dv_xname ? sd->sd_dev->dv_xname :
			   "<unknown>"));
d261 1
a261 1
		    break;
@


1.3
log
@netbsd port, now we merge our changes back in
@
text
@d60 1
a60 1
int sbus_print __P((void *, char *));
d84 1
a84 1
	char *sbus;
@


1.2
log
@+ sbus_slavecheck()
@
text
@d1 1
a1 1
/*	$NetBSD: sbus.c,v 1.6 1995/02/01 12:37:28 pk Exp $ */
d52 1
d60 3
d66 7
a72 3
struct cfdriver sbuscd = {
	NULL, "sbus", sbus_match, sbus_attach,
	DV_DULL, sizeof(struct sbus_softc)
d103 1
a103 1
	if (cputyp==CPU_SUN4)
d105 1
d121 1
a121 2
	register int base, node, slot;
	register int i;
d142 5
d152 3
d163 19
a181 1
		base = (int)oca.ca_ra.ra_paddr;
d183 2
a184 2
			oca.ca_slot = SBUS_ABS_TO_SLOT(base);
			oca.ca_offset = SBUS_ABS_TO_OFFSET(base);
d186 4
a189 3
			oca.ca_slot = slot = oca.ca_ra.ra_iospace;
			oca.ca_offset = base;
			oca.ca_ra.ra_paddr = (void *)SBUS_ADDR(slot, base);
d191 3
a193 3
			for (i = 1; i < oca.ca_ra.ra_nreg; i++) {
				base = (int)oca.ca_ra.ra_reg[i].rr_paddr;
				oca.ca_ra.ra_reg[i].rr_paddr =
d197 20
a216 2
		oca.ca_bustype = BUS_SBUS;
		(void) config_found(&sc->sc_dev, (void *)&oca, sbus_print);
d229 19
a247 1
	register struct sbus_softc *sc = (struct sbus_softc *)dev->dv_parent;
d262 1
a262 1
	struct sbus_softc *sc = sbuscd.cd_devs[sbus];
a272 21
}

/*
 * Returns true if this device is in a slave slot, so that drivers
 * can bail rather than fail.
 */
int
sbus_slavecheck(self, ca)
	struct device *self;
	struct confargs *ca;
{
	int	slave_only;

	slave_only = getpropint(findroot(), "slave-only", 8);

	if (slave_only & (1<<ca->ca_slot)) {
		printf("%s: slave sbus slot -- not supported\n",
		    self->dv_xname);
		return (1);
	}
	return (0);
@


1.1
log
@Initial revision
@
text
@d203 21
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
