head	1.14;
access;
symbols
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.14
	UBC:1.12.0.4
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.6.0.14
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.12
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.10
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2002.08.12.10.44.04;	author miod;	state dead;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.42;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.01.11.43.26;	author ho;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2001.03.03.23.36.05;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.20.18.24.55;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.06.15.42.48;	author ho;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.05.13.16.12;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.28.20.22.14;	author mjacob;	state Exp;
branches;
next	1.6;

1.6
date	97.08.08.08.24.56;	author downsj;	state Exp;
branches
	1.6.12.1;
next	1.5;

1.5
date	96.08.13.08.05.24;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.08.11.05.34.13;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.10.25.10.07.06;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.23.09.54.14;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.38;	author deraadt;	state Exp;
branches;
next	;

1.6.12.1
date	2001.05.14.21.37.04;	author niklas;	state Exp;
branches;
next	1.6.12.2;

1.6.12.2
date	2001.07.04.10.23.23;	author niklas;	state Exp;
branches;
next	1.6.12.3;

1.6.12.3
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.6.12.4;

1.6.12.4
date	2003.03.27.23.49.25;	author niklas;	state dead;
branches;
next	;

1.12.4.1
date	2002.06.11.03.38.15;	author art;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2002.10.29.00.28.09;	author art;	state dead;
branches;
next	;


desc
@@


1.14
log
@Convert sparc console code from rcons and pseudo-devices to rasops and wscons.
For most framebuffers it is faster.

Other changes include:
o 24 bit support in tcx(4) for the S24 framebuffer
o accelerated cgsix(4) text console
o new cgtwelve(4) driver for the GS framebuffer
o improved serial driver code
o better keyboard support

The following framebuffers have not been tested but should work: cgfour,
cgeight and cgfourteen

These changes will require XF4 changes, to use Xwsfb instead of Xsun*, to be
commited later today.

Most of the work by me during the LSM and the week after, with code borrowed
from jason@@, NetBSD (new serial code), and feedback from mickey@@. Work on
pnozz(4) done by millert@@
@
text
@/*	$OpenBSD: cons.c,v 1.13 2002/03/14 01:26:42 millert Exp $	*/
/*	$NetBSD: cons.c,v 1.30 1997/07/07 23:30:23 pk Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)cons.c	8.3 (Berkeley) 12/14/93
 */

/*
 * Console (indirect) driver.
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/conf.h>
#include <sys/timeout.h>

#include <dev/cons.h>

#include <machine/bsd_openprom.h>
#include <machine/eeprom.h>
#include <machine/psl.h>
#include <machine/cpu.h>
#include <machine/kbd.h>
#if defined(SUN4)
#include <machine/oldmon.h>
#endif
#include <machine/autoconf.h>
#include <machine/conf.h>

#ifdef RASTERCONSOLE
#include <machine/fbio.h>
#include <machine/fbvar.h>
#endif

#include "zs.h"
#include "kbd.h"

struct	tty *constty = 0;	/* virtual console output device */
struct	tty *fbconstty = 0;	/* tty structure for frame buffer console */
int	rom_console_input;	/* when set, hardclock calls cnrom() */

int	cons_ocount;		/* output byte count */

/*
 * The output driver may munge the minor number in cons.t_dev.
 */
struct tty cons;		/* rom console tty device */
struct timeout cons_cnfbdma_tmo;/* for cnfdbma() timeouts */
static int (*fcnstop)(struct tty *, int);

static void cnstart(struct tty *);
int cnstop(struct tty *, int);

static void cnfbstart(struct tty *);
static int cnfbstop(struct tty *, int);
static void cnfbdma(void *);
static struct tty  *xxcntty(dev_t);

extern char char_type[];

/*XXX*/
static struct tty *
xxcntty(dev_t dev)
{
	return &cons;
}

void
consinit()
{
	register struct tty *tp = &cons;
	register int in, out;

/*XXX*/	cdevsw[0].d_tty = xxcntty;
	tp->t_dev = makedev(0, 0);	/* /dev/console */
	tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;
	tp->t_param = (int (*)(struct tty *, struct termios *))nullop;

	if (promvec->pv_romvec_vers > 2) {
		/* We need to probe the PROM device tree */
		register int node,fd;
		char buffer[128];
		register struct nodeops *no;
		register struct v2devops *op;
		register char *cp;
		extern int fbnode;

		in = out = -1;
		no = promvec->pv_nodeops;
		op = &promvec->pv_v2devops;

		node = findroot();
		if (no->no_proplen(node, "stdin-path") >= sizeof(buffer)) {
			printf("consinit: increase buffer size and recompile\n");
			goto setup_output;
		}
		/* XXX: fix above */

		no->no_getprop(node, "stdin-path",buffer);

		/*
		 * Open an "instance" of this device.
		 * You'd think it would be appropriate to call v2_close()
		 * on the handle when we're done with it. But that seems
		 * to cause the device to shut down somehow; for the moment,
		 * we simply leave it open...
		 */
		if ((fd = op->v2_open(buffer)) == 0 ||
		     (node = op->v2_fd_phandle(fd)) == 0) {
			printf("consinit: bogus stdin path %s.\n",buffer);
			goto setup_output;
		}
		if (no->no_proplen(node,"keyboard") >= 0) {
			in = PROMDEV_KBD;
			goto setup_output;
		}
		if (strcmp(getpropstring(node,"device_type"),"serial") != 0) {
			/* not a serial, not keyboard. what is it?!? */
			in = -1;
			goto setup_output;
		}
		/*
		 * At this point we assume the device path is in the form
		 *   ....device@@x,y:a for ttya and ...device@@x,y:b for ttyb.
		 * If it isn't, we defer to the ROM
		 */
		cp = buffer;
		while (*cp)
		    cp++;
		cp -= 2;
#ifdef DEBUG
		if (cp < buffer)
		    panic("consinit: bad stdin path %s",buffer);
#endif
		/* XXX: only allows tty's a->z, assumes PROMDEV_TTYx contig */
		if (cp[0]==':' && cp[1] >= 'a' && cp[1] <= 'z')
		    in = PROMDEV_TTYA + (cp[1] - 'a');
		/* else use rom */
setup_output:
		node = findroot();
		if (no->no_proplen(node, "stdout-path") >= sizeof(buffer)) {
			printf("consinit: increase buffer size and recompile\n");
			goto setup_console;
		}
		/* XXX: fix above */

		no->no_getprop(node, "stdout-path", buffer);

		if ((fd = op->v2_open(buffer)) == 0 ||
		     (node = op->v2_fd_phandle(fd)) == 0) {
			printf("consinit: bogus stdout path %s.\n",buffer);
			goto setup_output;
		}
		if (strcmp(getpropstring(node,"device_type"),"display") == 0) {
			/* frame buffer output */
			out = PROMDEV_SCREEN;
			fbnode = node;
		} else if (strcmp(getpropstring(node,"device_type"), "serial")
			   != 0) {
			/* not screen, not serial. Whatzit? */
			out = -1;
		} else { /* serial console. which? */
			/*
			 * At this point we assume the device path is in the
			 * form:
			 * ....device@@x,y:a for ttya, etc.
			 * If it isn't, we defer to the ROM
			 */
			cp = buffer;
			while (*cp)
			    cp++;
			cp -= 2;
#ifdef DEBUG
			if (cp < buffer)
				panic("consinit: bad stdout path %s",buffer);
#endif
			/* XXX: only allows tty's a->z, assumes PROMDEV_TTYx contig */
			if (cp[0]==':' && cp[1] >= 'a' && cp[1] <= 'z')
			    out = PROMDEV_TTYA + (cp[1] - 'a');
			else out = -1;
		}
	} else {
		in = *promvec->pv_stdin;
		out = *promvec->pv_stdout;
	}
setup_console:
	switch (in) {
#if NZS > 0
	case PROMDEV_TTYA:
		zsconsole(tp, 0, 0, NULL);
		break;

	case PROMDEV_TTYB:
		zsconsole(tp, 1, 0, NULL);
		break;
#endif
#if	NKBD > 0
	case PROMDEV_KBD:
		/*
		 * Tell the keyboard driver to direct ASCII input here.
		 */
		kbd_ascii(tp);
		break;
#endif

	default:
		rom_console_input = 1;
		printf("unknown console input source %d; using rom\n", in);
		break;
	}
	switch (out) {

#if NZS > 0
	case PROMDEV_TTYA:
		zsconsole(tp, 0, 1, &fcnstop);
		break;

	case PROMDEV_TTYB:
		zsconsole(tp, 1, 1, &fcnstop);
		break;
#endif

	case PROMDEV_SCREEN:
		fbconstty = tp;
		tp->t_oproc = cnfbstart;
		fcnstop = cnfbstop;
		break;

	default:
		printf("unknown console output sink %d; using rom\n", out);
		tp->t_oproc = cnstart;
		fcnstop = (int (*)(struct tty *, int))nullop;
		break;
	}
}

/* ARGSUSED */
int
cnopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	register struct tty *tp = &cons;
 	static int firstopen = 1;
	static int rows = 0, cols = 0;

	if (firstopen) {
		clalloc(&tp->t_rawq, 1024, 1);
		clalloc(&tp->t_canq, 1024, 1);
		/* output queue doesn't need quoting */
		clalloc(&tp->t_outq, 1024, 0);
		tty_attach(tp);
		timeout_set(&cons_cnfbdma_tmo, cnfbdma, tp);

		/*
		 * get the console struct winsize.
		 */
		if (fbconstty) {
#ifdef RASTERCONSOLE
			rows = fbrcons_rows();
			cols = fbrcons_cols();
#else
			if (CPU_ISSUN4COR4M) {
				int i;
				char *prop;

				if (rows == 0 &&
				    (prop = getpropstring(optionsnode,
				    "screen-#rows"))) {
					i = 0;
					while (*prop != '\0')
						i = i * 10 + *prop++ - '0';
					rows = (unsigned short)i;
				}
				if (cols == 0 &&
				    (prop = getpropstring(optionsnode,
				    "screen-#columns"))) {
					i = 0;
					while (*prop != '\0')
						i = i * 10 + *prop++ - '0';
					cols = (unsigned short)i;
				}
			}
			if (CPU_ISSUN4) {
				struct eeprom *ep = (struct eeprom *)eeprom_va;

				if (ep) {
					if (rows == 0)
						rows = (u_short)ep->eeTtyRows;
					if (cols == 0)
						cols = (u_short)ep->eeTtyCols;
				}
			}
#endif
		}
		firstopen = 0;
	}

	if ((tp->t_state & TS_ISOPEN) == 0) {
		/*
		 * Leave baud rate alone!
		 */
		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_cflag = TTYDEF_CFLAG;
		tp->t_state = TS_ISOPEN | TS_CARR_ON;
		(void)(*tp->t_param)(tp, &tp->t_termios);
		ttsetwater(tp);
		tp->t_winsize.ws_row = rows;
		tp->t_winsize.ws_col = cols;
	} else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0)
		return (EBUSY);
	return ((*linesw[tp->t_line].l_open)(dev, tp));
}

/* ARGSUSED */
int
cnclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	register struct tty *tp = &cons;

	(*linesw[tp->t_line].l_close)(tp, flag);
	ttyclose(tp);
	return (0);
}

/* ARGSUSED */
int
cnread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	register struct tty *tp = &cons;

	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

/* ARGSUSED */
int
cnwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	register struct tty *tp;

	if ((tp = constty) == NULL ||
	    (tp->t_state & (TS_CARR_ON|TS_ISOPEN)) != (TS_CARR_ON|TS_ISOPEN))
		tp = &cons;
	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

int
cnioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	register struct tty *tp;
	int error;

	/*
	 * Superuser can always use this to wrest control of console
	 * output from the "virtual" console.
	 */
	if (cmd == TIOCCONS && constty) {
		error = suser(p->p_ucred, (u_short *)NULL);
		if (error)
			return (error);
		constty = NULL;
		return (0);
	}
	tp = &cons;
	if ((error = linesw[tp->t_line].l_ioctl(tp, cmd, data, flag, p)) >= 0)
		return (error);
	if ((error = ttioctl(tp, cmd, data, flag, p)) >= 0)
		return (error);
	return (ENOTTY);
}

int
cnselect(dev, which, p)
	dev_t dev;
	int which;
	struct proc *p;
{

	return (ttselect(makedev(major(dev), 0), which, p));
}

int
cnkqfilter(dev, kn)
	dev_t dev;
	struct knote *kn;
{
	if (cdevsw[major(dev)].d_type & D_KQFILTER)
		return ((*cdevsw[major(dev)].d_kqfilter)(makedev(major(dev), 0), kn));
	return (1);
}

/*
 * The rest of this code is run only when we are using the ROM vectors.
 */

/*
 * Generic output.  We just call putchar.  (Very bad for performance.)
 */
static void
cnstart(tp)
	register struct tty *tp;
{
	register int c, s;
	register union {
		void (*v1)(int);
		int  (*v3)(int, void *, int);
	} putc;
	register int fd = 0, v;

	s = spltty();
	if (tp->t_state & (TS_TIMEOUT | TS_TTSTOP)) {
		splx(s);
		return;
	}
	if ((v = promvec->pv_romvec_vers) > 2) {
		putc.v3 = promvec->pv_v2devops.v2_write;
		fd = *promvec->pv_v2bootargs.v2_fd1;
	} else
		putc.v1 = promvec->pv_putchar;
	while (tp->t_outq.c_cc) {
		int ss;

		c = getc(&tp->t_outq);
		/*
		 * *%&!*& ROM monitor console putchar is not reentrant!
		 * splhigh/tty around it so as not to run so long with
		 * clock interrupts blocked.
		 */
		ss = splhigh();
		if (v > 2) {
			unsigned char c0 = c & 0177;
			(*putc.v3)(fd, &c0, 1);
		} else
			(*putc.v1)(c & 0177);
		splx(ss);
	}
	if (tp->t_state & TS_ASLEEP) {		/* can't happen? */
		tp->t_state &= ~TS_ASLEEP;
		wakeup((caddr_t)&tp->t_outq);
	}
	selwakeup(&tp->t_wsel);
	splx(s);
}

int
cnstop(tp, flag)
	register struct tty *tp;
	int flag;
{
	(void)(*fcnstop)(tp, flag);
	return 0;
}

/*
 * Frame buffer output.
 * We use pseudo-DMA, via the ROM `write string' function, called from
 * software clock interrupts.
 */
static void
cnfbstart(tp)
	register struct tty *tp;
{
	register int s;

	s = spltty();		/* paranoid: splsoftclock should suffice */
	if (tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP)) {
		splx(s);
		return;
	}
	/*
	 * If there are sleepers, and output has drained below low
	 * water mark, awaken.
	 */
	if (tp->t_outq.c_cc <= tp->t_lowat) {
		if (tp->t_state & TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
	}
	if (tp->t_outq.c_cc) {
		tp->t_state |= TS_BUSY;
		/*
		 * XXX - this is just too ugly.
		 */
		if (s == 0) {
			(void) spllowersoftclock();
			cnfbdma((void *)tp);
		} else
			timeout_add(&cons_cnfbdma_tmo, 1);
	}
	splx(s);
}

/*
 * Stop frame buffer output: just assert TS_FLUSH if necessary.
 */
static int
cnfbstop(tp, flag)
	register struct tty *tp;
	int flag;
{
	register int s = spltty();	/* paranoid */

	if ((tp->t_state & (TS_BUSY | TS_TTSTOP)) == TS_BUSY)
		tp->t_state |= TS_FLUSH;
	splx(s);
	return 0;
}

/*
 * Do pseudo-dma (called from software interrupt).
 */
static void
cnfbdma(tpaddr)
	void *tpaddr;
{
	register struct tty *tp = tpaddr;
	register unsigned char *p, *q;
	register int n, c, s;

	s = spltty();			/* paranoid */
	if (tp->t_state & TS_FLUSH) {
		tp->t_state &= ~(TS_BUSY | TS_FLUSH);
		splx(s);
	} else {
		tp->t_state &= ~TS_BUSY;
		splx(s);
		p = tp->t_outq.c_cf;
		n = ndqb(&tp->t_outq, 0);
		for (q = p, c = n; --c >= 0; q++)
			if (*q & 0200)	/* high bits seem to be bad */
				*q &= ~0200;
		if (promvec->pv_romvec_vers > 2) {
			(*promvec->pv_v2devops.v2_write)
				(*promvec->pv_v2bootargs.v2_fd1, p, n);
		} else
			(*promvec->pv_putstr)((char *)p, n);
		ndflush(&tp->t_outq, n);
	}
	if (tp->t_line)
		(*linesw[tp->t_line].l_start)(tp);
	else
		cnfbstart(tp);
}

/*
 * The following is for rom console input.  The rom will not call
 * an `interrupt' routine on console input ready, so we must poll.
 * This is all rather sad.
 */
volatile int	cn_rxc = -1;		/* XXX receive `silo' */

/* called from hardclock, which is above spltty, so no tty calls! */
int
cnrom()
{
	register int c;

	if (cn_rxc >= 0)
		return (1);
	if (promvec->pv_romvec_vers > 2) {
		unsigned char c0;
		if ((*promvec->pv_v2devops.v2_read)
			(*promvec->pv_v2bootargs.v2_fd0, &c0, 1) <= 0)
			return (0);
		c = c0;
	} else if ((c = (*promvec->pv_nbgetchar)()) < 0)
		return (0);
	cn_rxc = c;
	return (1);
}

/* pseudo console software interrupt scheduled when cnrom() returns 1 */
void
cnrint()
{
	register struct tty *tp;
	register int c, s;

	s = splclock();
	c = cn_rxc;
	cn_rxc = -1;
	splx(s);
	if (c < 0)
		return;
	tp = &cons;
	if ((tp->t_cflag & CSIZE) == CS7) {
		/* XXX this should be done elsewhere, if at all */
		if (tp->t_cflag & PARENB)
			if (tp->t_cflag & PARODD ?
			    (char_type[c & 0177] & 0200) == (c & 0200) :
			    (char_type[c & 0177] & 0200) != (c & 0200))
				c |= TTY_PE;
		c &= ~0200;
	}
	(*linesw[tp->t_line].l_rint)(c, tp);
}

int
cngetc()
{
	register int s, c;

	if (promvec->pv_romvec_vers > 2) {
		register int n = 0;
		unsigned char c0;
		s = splhigh();
		while (n <= 0) {
			n = (*promvec->pv_v2devops.v2_read)
				(*promvec->pv_v2bootargs.v2_fd0, &c0, 1);
		}
		splx(s);
		c = c0;
	} else {
#if defined(SUN4)
		/* SUN4 PROM: must turn off echo to avoid double char echo */
		extern struct om_vector *oldpvec;
		int saveecho = 0;
#endif

		s = splhigh();
#if defined(SUN4)
		if (CPU_ISSUN4) {
			saveecho = *(oldpvec->echo);
			*(oldpvec->echo) = 0;
		}
#endif
		c = (*promvec->pv_getchar)();
#if defined(SUN4)
		if (CPU_ISSUN4)
			*(oldpvec->echo) = saveecho;
#endif
		splx(s);
	}
	if (c == '\r')
		c = '\n';
	return (c);
}

void
cnputc(c)
	register int c;
{
	register int s;

	if (c == '\n')
		cnputc('\r');
	s = splhigh();
	if (promvec->pv_romvec_vers > 2) {
		unsigned char c0 = c;
		(*promvec->pv_v2devops.v2_write)
			(*promvec->pv_v2bootargs.v2_fd1, &c0, 1);
	} else
		(*promvec->pv_putchar)(c);
	splx(s);
}

void
cnpollc(on)
	int on;
{
}
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.12 2001/05/01 11:43:26 ho Exp $	*/
@


1.12
log
@Convert to new timeouts. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.11 2001/03/03 23:36:05 provos Exp $	*/
d93 1
a93 1
static int (*fcnstop) __P((struct tty *, int));
d95 2
a96 2
static void cnstart __P((struct tty *));
int cnstop __P((struct tty *, int));
d98 4
a101 4
static void cnfbstart __P((struct tty *));
static int cnfbstop __P((struct tty *, int));
static void cnfbdma __P((void *));
static struct tty  *xxcntty __P((dev_t));
d467 2
a468 2
		void (*v1)__P((int));
		int  (*v3)__P((int, void *, int));
@


1.12.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.12 2001/05/01 11:43:26 ho Exp $	*/
d93 1
a93 1
static int (*fcnstop)(struct tty *, int);
d95 2
a96 2
static void cnstart(struct tty *);
int cnstop(struct tty *, int);
d98 4
a101 4
static void cnfbstart(struct tty *);
static int cnfbstop(struct tty *, int);
static void cnfbdma(void *);
static struct tty  *xxcntty(dev_t);
d467 2
a468 2
		void (*v1)(int);
		int  (*v3)(int, void *, int);
@


1.12.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.12.4.1 2002/06/11 03:38:15 art Exp $	*/
@


1.11
log
@cnkqfilter for sparc
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.10 2001/01/20 18:24:55 deraadt Exp $	*/
d59 1
d92 1
d298 1
d552 1
a552 1
			timeout(cnfbdma, tp, 1);
@


1.10
log
@if using serial console, do not apply graphics rows/cols to tty settings; joost@@c-lab.de
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.9 2000/07/06 15:42:48 ho Exp $	*/
d439 10
@


1.9
log
@Change splsoftclock() call to spllowersoftclock() to conform with other
code and keep old behaviour. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.8 2000/07/05 13:16:12 art Exp $	*/
d300 1
a301 1
		if (fbconstty) {
d304 21
a324 20
		}
#endif

		if (CPU_ISSUN4COR4M) {
			int i;
			char *prop;

			if (rows == 0 &&
			    (prop = getpropstring(optionsnode, "screen-#rows"))) {
				i = 0;
				while (*prop != '\0')
					i = i * 10 + *prop++ - '0';
				rows = (unsigned short)i;
			}
			if (cols == 0 &&
			    (prop = getpropstring(optionsnode, "screen-#columns"))) {
				i = 0;
				while (*prop != '\0')
					i = i * 10 + *prop++ - '0';
				cols = (unsigned short)i;
d326 2
a327 3
		}
		if (CPU_ISSUN4) {
			struct eeprom *ep = (struct eeprom *)eeprom_va;
d329 6
a334 5
			if (ep) {
				if (rows == 0)
					rows = (u_short)ep->eeTtyRows;
				if (cols == 0)
					cols = (u_short)ep->eeTtyCols;
d336 1
@


1.8
log
@Fix spl-handling in cnstart.
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.7 2000/06/28 20:22:14 mjacob Exp $	*/
d534 1
a534 1
			(void) splsoftclock();
@


1.7
log
@look in kbd.h to see whether we have configured a keyboard
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.6 1997/08/08 08:24:56 downsj Exp $	*/
d468 2
d476 1
a476 1
		(void) splhigh();
d482 1
a482 1
		(void) spltty();
d530 3
@


1.6
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.5 1996/08/13 08:05:24 downsj Exp $	*/
d79 1
d239 1
a239 1

d246 1
@


1.6.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.11 2001/03/03 23:36:05 provos Exp $	*/
a78 1
#include "kbd.h"
d238 1
a238 1
#if	NKBD > 0
a244 1
#endif
d298 1
a299 1
#ifdef RASTERCONSOLE
d302 13
a314 21
#else
			if (CPU_ISSUN4COR4M) {
				int i;
				char *prop;

				if (rows == 0 &&
				    (prop = getpropstring(optionsnode,
				    "screen-#rows"))) {
					i = 0;
					while (*prop != '\0')
						i = i * 10 + *prop++ - '0';
					rows = (unsigned short)i;
				}
				if (cols == 0 &&
				    (prop = getpropstring(optionsnode,
				    "screen-#columns"))) {
					i = 0;
					while (*prop != '\0')
						i = i * 10 + *prop++ - '0';
					cols = (unsigned short)i;
				}
d316 10
a325 2
			if (CPU_ISSUN4) {
				struct eeprom *ep = (struct eeprom *)eeprom_va;
d327 5
a331 6
				if (ep) {
					if (rows == 0)
						rows = (u_short)ep->eeTtyRows;
					if (cols == 0)
						cols = (u_short)ep->eeTtyCols;
				}
a332 1
#endif
a436 10
int
cnkqfilter(dev, kn)
	dev_t dev;
	struct knote *kn;
{
	if (cdevsw[major(dev)].d_type & D_KQFILTER)
		return ((*cdevsw[major(dev)].d_kqfilter)(makedev(major(dev), 0), kn));
	return (1);
}

a465 2
		int ss;

d472 1
a472 1
		ss = splhigh();
d478 1
a478 1
		splx(ss);
a525 3
		/*
		 * XXX - this is just too ugly.
		 */
d527 1
a527 1
			(void) spllowersoftclock();
@


1.6.12.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.6.12.1 2001/05/14 21:37:04 niklas Exp $	*/
a58 1
#include <sys/timeout.h>
a90 1
struct timeout cons_cnfbdma_tmo;/* for cnfdbma() timeouts */
a295 1
		timeout_set(&cons_cnfbdma_tmo, cnfbdma, tp);
d549 1
a549 1
			timeout_add(&cons_cnfbdma_tmo, 1);
@


1.6.12.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d93 1
a93 1
static int (*fcnstop)(struct tty *, int);
d95 2
a96 2
static void cnstart(struct tty *);
int cnstop(struct tty *, int);
d98 4
a101 4
static void cnfbstart(struct tty *);
static int cnfbstop(struct tty *, int);
static void cnfbdma(void *);
static struct tty  *xxcntty(dev_t);
d467 2
a468 2
		void (*v1)(int);
		int  (*v3)(int, void *, int);
@


1.6.12.4
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.6.12.3 2002/03/28 10:57:10 niklas Exp $	*/
@


1.5
log
@Revert back to Theo's eeprom.h.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: cons.c,v 1.23.4.1 1996/06/02 09:07:53 mrg Exp $ */
d73 5
d294 1
d298 7
d309 2
a310 1
			if ((prop = getpropstring(optionsnode, "screen-#rows"))) {
d316 2
a317 1
			if ((prop = getpropstring(optionsnode, "screen-#columns"))) {
d328 4
a331 2
				rows = (u_short)ep->ee_diag.eed_rowsize;
				cols = (u_short)ep->ee_diag.eed_colsize;
@


1.4
log
@netbsd port, now we merge our changes back in
@
text
@d1 1
d313 2
a314 2
				rows = (u_short)ep->eeTtyRows;
				cols = (u_short)ep->eeTtyCols;
@


1.3
log
@need <sys/types.h>
@
text
@d1 1
a1 1
/*	$NetBSD: cons.c,v 1.15 1995/07/13 12:02:19 pk Exp $ */
a51 1
#include <sys/types.h>
d59 2
d62 1
d64 3
a66 1
#ifdef SUN4
d69 2
a79 2
extern struct promvec *promvec;

d84 1
a84 1
static void (*fcnstop) __P((struct tty *, int));
d87 1
a87 1
void cnstop __P((struct tty *, int));
d90 1
a90 1
static void cnfbstop __P((struct tty *, int));
d92 1
d96 3
a98 2
/*XXX*/static struct tty *
cntty()
a107 1
	void zsconsole();
d109 1
a109 1
/*XXX*/	cdevsw[0].d_tty = cntty;
d113 109
a221 2
	in = *promvec->pv_stdin;
	out = *promvec->pv_stdout;
a222 1

d266 1
a266 1
		fcnstop = (void (*)(struct tty *, int))nullop;
d272 1
d280 1
d282 1
a282 1
	if(firstopen) {
d287 29
d331 2
d339 1
d353 1
d365 1
d372 1
a372 1
	
d379 1
d409 1
d433 1
a433 1
		void (*v3)__P((int, u_char *, int));
d435 1
a435 1
	register int fd, v;
d443 1
a443 1
		putc.v3 = (void (*))promvec->pv_v2devops.v2_write;
d456 1
a456 1
			u_char c0 = c & 0177;
d470 1
a470 1
void
d475 2
a476 1
	(*fcnstop)(tp, flag);
d520 1
a520 1
static void
d530 1
d541 1
a541 1
	register char *p, *q;
d560 1
a560 1
			(*promvec->pv_putstr)(p, n);
d577 1
d597 1
d622 1
d630 1
a631 1
			s = splhigh();
a633 1
			splx(s);
d635 1
d638 1
a638 1
#ifdef SUN4
d641 1
a641 1
		int saveecho;
d645 2
a646 2
#ifdef SUN4
		if (cputyp == CPU_SUN4) {
d652 2
a653 2
#ifdef SUN4
		if (cputyp == CPU_SUN4) 
d663 1
d681 1
@


1.2
log
@two variants of putc functions
@
text
@d52 1
@


1.1
log
@Initial revision
@
text
@d281 4
a284 1
	register void (*putc)__P((...));
d293 1
a293 1
		putc = (void (*))promvec->pv_v2devops.v2_write;
d296 1
a296 1
		putc = promvec->pv_putchar;
d306 2
a307 2
			unsigned char c0 = c & 0177;
			(*putc)(fd, &c0, 1);
d309 1
a309 1
			(*putc)(c & 0177);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
