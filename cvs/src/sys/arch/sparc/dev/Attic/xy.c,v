head	1.69;
access;
symbols
	OPENBSD_6_0:1.68.0.8
	OPENBSD_6_0_BASE:1.68
	OPENBSD_5_9:1.68.0.4
	OPENBSD_5_9_BASE:1.68
	OPENBSD_5_8:1.68.0.6
	OPENBSD_5_8_BASE:1.68
	OPENBSD_5_7:1.68.0.2
	OPENBSD_5_7_BASE:1.68
	OPENBSD_5_6:1.59.0.4
	OPENBSD_5_6_BASE:1.59
	OPENBSD_5_5:1.58.0.4
	OPENBSD_5_5_BASE:1.58
	OPENBSD_5_4:1.54.0.2
	OPENBSD_5_4_BASE:1.54
	OPENBSD_5_3:1.53.0.8
	OPENBSD_5_3_BASE:1.53
	OPENBSD_5_2:1.53.0.6
	OPENBSD_5_2_BASE:1.53
	OPENBSD_5_1_BASE:1.53
	OPENBSD_5_1:1.53.0.4
	OPENBSD_5_0:1.53.0.2
	OPENBSD_5_0_BASE:1.53
	OPENBSD_4_9:1.50.0.2
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.45.0.2
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.44.0.2
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.41.0.6
	OPENBSD_4_6_BASE:1.41
	OPENBSD_4_5:1.41.0.2
	OPENBSD_4_5_BASE:1.41
	OPENBSD_4_4:1.40.0.4
	OPENBSD_4_4_BASE:1.40
	OPENBSD_4_3:1.40.0.2
	OPENBSD_4_3_BASE:1.40
	OPENBSD_4_2:1.38.0.2
	OPENBSD_4_2_BASE:1.38
	OPENBSD_4_1:1.30.0.2
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.25.0.4
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.24.0.4
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.21.0.4
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.21
	UBC:1.17.0.2
	UBC_BASE:1.17
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.13.0.8
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.6
	OPENBSD_2_7_BASE:1.13
	SMP:1.13.0.4
	SMP_BASE:1.13
	kame_19991208:1.13
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.10.0.4
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.8.0.4
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.69
date	2016.09.01.09.23.42;	author tedu;	state dead;
branches;
next	1.68;
commitid	Q2PxaFNhqAe0Wmla;

1.68
date	2015.01.16.20.18.24;	author miod;	state Exp;
branches;
next	1.67;
commitid	jsnGT5pb7CAZju6U;

1.67
date	2015.01.15.21.17.54;	author miod;	state Exp;
branches;
next	1.66;
commitid	DYNfPenXY8PUhMer;

1.66
date	2015.01.14.21.17.09;	author miod;	state Exp;
branches;
next	1.65;
commitid	hIC3tK7p4HkOnEHa;

1.65
date	2015.01.14.21.14.49;	author miod;	state Exp;
branches;
next	1.64;
commitid	PgF6jY0brASd4A0j;

1.64
date	2015.01.14.21.13.46;	author miod;	state Exp;
branches;
next	1.63;
commitid	D8IgstMlgb5ty7i2;

1.63
date	2015.01.14.19.02.59;	author miod;	state Exp;
branches;
next	1.62;
commitid	1kQrxNkHrTSZQ4NN;

1.62
date	2015.01.14.19.01.00;	author miod;	state Exp;
branches;
next	1.61;
commitid	ud1N0wF51836kdIY;

1.61
date	2015.01.13.20.40.11;	author miod;	state Exp;
branches;
next	1.60;
commitid	GfyK6mpEK4OZiTtd;

1.60
date	2015.01.12.21.31.06;	author miod;	state Exp;
branches;
next	1.59;
commitid	PSJsKbBjegdV1GBa;

1.59
date	2014.07.11.16.35.40;	author jsg;	state Exp;
branches;
next	1.58;
commitid	7NtJNW9udCOFtDNM;

1.58
date	2013.11.20.00.15.32;	author dlg;	state Exp;
branches;
next	1.57;

1.57
date	2013.11.01.17.36.19;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2013.10.20.10.11.16;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2013.10.14.23.26.22;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2013.06.11.16.42.11;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2011.07.06.04.49.35;	author matthew;	state Exp;
branches;
next	1.52;

1.52
date	2011.06.05.18.40.33;	author matthew;	state Exp;
branches;
next	1.51;

1.51
date	2011.06.03.21.14.11;	author matthew;	state Exp;
branches;
next	1.50;

1.50
date	2010.09.22.06.40.25;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2010.09.22.01.18.57;	author matthew;	state Exp;
branches;
next	1.48;

1.48
date	2010.09.08.14.47.10;	author jsing;	state Exp;
branches;
next	1.47;

1.47
date	2010.09.06.14.44.19;	author jasper;	state Exp;
branches;
next	1.46;

1.46
date	2010.08.28.20.23.22;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	2010.05.23.10.49.19;	author dlg;	state Exp;
branches;
next	1.44;

1.44
date	2009.09.05.15.37.04;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2009.09.05.00.48.39;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2009.08.13.15.23.12;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2009.01.04.16.51.05;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2007.11.28.16.33.20;	author martin;	state Exp;
branches;
next	1.39;

1.39
date	2007.10.01.16.11.19;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2007.07.01.19.06.57;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.24.16.52.04;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.20.18.16.24;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2007.06.07.14.38.39;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.07.03.42.51;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.06.17.15.12;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.05.00.38.18;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2007.04.29.18.59.37;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2007.02.15.00.53.26;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2006.12.03.16.40.43;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.15.20.20.41;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2006.01.20.23.27.25;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2006.01.20.00.20.38;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2004.09.29.07.35.11;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.15.02.45.46;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2003.09.29.09.08.19;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.08.15.20.32.14;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.08.18.52.45;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.29.08.28.36;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2002.04.30.01.12.29;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.26.43;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.09.11.20.05.24;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.24.10.07.21;	author ho;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.10.15.33.07;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	99.07.09.21.34.46;	author art;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	99.01.11.05.11.57;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.10.03.21.18.58;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.08.08.21.46.51;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.08.08.08.25.39;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	96.08.11.05.34.33;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.03.04.20.35.25;	author chuck;	state Exp;
branches;
next	1.6;

1.6
date	96.02.21.03.43.18;	author chuck;	state Exp;
branches;
next	1.5;

1.5
date	96.01.13.03.45.03;	author chuck;	state Exp;
branches;
next	1.4;

1.4
date	96.01.12.23.09.10;	author chuck;	state Exp;
branches;
next	1.3;

1.3
date	96.01.12.20.20.53;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.15.13.56.29;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.41;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.41;	author deraadt;	state Exp;
branches;
next	;

1.13.4.1
date	2001.05.14.21.37.10;	author niklas;	state Exp;
branches;
next	1.13.4.2;

1.13.4.2
date	2001.10.31.03.07.56;	author nate;	state Exp;
branches;
next	1.13.4.3;

1.13.4.3
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.13.4.4;

1.13.4.4
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.13.4.5;

1.13.4.5
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.13.4.6;

1.13.4.6
date	2004.02.19.10.49.58;	author niklas;	state Exp;
branches;
next	1.13.4.7;

1.13.4.7
date	2004.06.05.23.10.58;	author niklas;	state Exp;
branches;
next	;

1.17.2.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	;


desc
@@


1.69
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: xy.c,v 1.68 2015/01/16 20:18:24 miod Exp $	*/
/*	$NetBSD: xy.c,v 1.26 1997/07/19 21:43:56 pk Exp $	*/

/*
 * Copyright (c) 1995 Charles D. Cranor
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 *
 * x y . c   x y l o g i c s   4 5 0 / 4 5 1   s m d   d r i v e r
 *
 * author: Chuck Cranor <chuck@@ccrc.wustl.edu>
 * id: $NetBSD: xy.c,v 1.26 1997/07/19 21:43:56 pk Exp $
 * started: 14-Sep-95
 * references: [1] Xylogics Model 753 User's Manual
 *                 part number: 166-753-001, Revision B, May 21, 1988.
 *                 "Your Partner For Performance"
 *             [2] other NetBSD disk device drivers
 *	       [3] Xylogics Model 450 User's Manual
 *		   part number: 166-017-001, Revision B, 1983.
 *	       [4] Addendum to Xylogics Model 450 Disk Controller User's
 *			Manual, Jan. 1985.
 *	       [5] The 451 Controller, Rev. B3, September 2, 1986.
 *	       [6] David Jones <dej@@achilles.net>'s unfinished 450/451 driver
 *
 */

#undef XYC_DEBUG		/* full debug */
#undef XYC_DIAG			/* extra sanity checks */
#if defined(DIAGNOSTIC) && !defined(XYC_DIAG)
#define XYC_DIAG		/* link in with master DIAG option */
#endif

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/buf.h>
#include <sys/uio.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/disk.h>
#include <sys/syslog.h>
#include <sys/dkbad.h>
#include <sys/conf.h>
#include <sys/timeout.h>
#include <sys/dkio.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <dev/sun/disklabel.h>
#include <machine/conf.h>

#include <sparc/dev/xyreg.h>
#include <sparc/dev/xyvar.h>
#include <sparc/sparc/vaddrs.h>

/*
 * macros
 */

/*
 * XYC_GO: start iopb ADDR (DVMA addr in a u_long) on XYC
 */
#define XYC_GO(XYC, ADDR) { \
	(XYC)->xyc_addr_lo = ((ADDR) & 0xff); \
	(ADDR) = ((ADDR) >> 8); \
	(XYC)->xyc_addr_hi = ((ADDR) & 0xff); \
	(ADDR) = ((ADDR) >> 8); \
	(XYC)->xyc_reloc_lo = ((ADDR) & 0xff); \
	(ADDR) = ((ADDR) >> 8); \
	(XYC)->xyc_reloc_hi = (ADDR); \
	(XYC)->xyc_csr = XYC_GBSY; /* go! */ \
}

/*
 * XYC_DONE: don't need IORQ, get error code and free (done after xyc_cmd)
 */

#define XYC_DONE(SC,ER) { \
	if ((ER) == XY_ERR_AOK) { \
		(ER) = (SC)->ciorq->errno; \
		(SC)->ciorq->mode = XY_SUB_FREE; \
		wakeup((SC)->ciorq); \
	} \
	}

/*
 * XYC_ADVANCE: advance iorq's pointers by a number of sectors
 */

#define XYC_ADVANCE(IORQ, N) { \
	if (N) { \
		(IORQ)->sectcnt -= (N); \
		(IORQ)->blockno += (N); \
		(IORQ)->dbuf += ((N)*XYFM_BPS); \
	} \
}

/*
 * note - addresses you can sleep on:
 *   [1] & of xy_softc's "state" (waiting for a chance to attach a drive)
 *   [2] & an iorq (waiting for an XY_SUB_WAIT iorq to finish)
 */


/*
 * function prototypes
 * "xyc_*" functions are internal, all others are external interfaces
 */

extern int pil_to_vme[];	/* from obio.c */

/* internals */
struct xy_iopb *xyc_chain(struct xyc_softc *, struct xy_iorq *);
int	xyc_cmd(struct xyc_softc *, int, int, int, int, int, char *, int);
const char *xyc_e2str(int);
int	xyc_entoact(int);
int	xyc_error(struct xyc_softc *, struct xy_iorq *,
		   struct xy_iopb *, int);
void	xyc_perror(struct xy_iorq *, struct xy_iopb *, int);
int	xyc_piodriver(struct xyc_softc *, struct xy_iorq *);
int	xyc_remove_iorq(struct xyc_softc *);
int	xyc_reset(struct xyc_softc *, int, struct xy_iorq *, int,
			struct xy_softc *);
inline void xyc_rqinit(struct xy_iorq *, struct xyc_softc *,
			    struct xy_softc *, int, u_long, int,
			    caddr_t, struct buf *);
void	xyc_rqtopb(struct xy_iorq *, struct xy_iopb *, int, int);
void	xyc_start(struct xyc_softc *, struct xy_iorq *);
int	xyc_startbuf(struct xyc_softc *, struct xy_softc *, struct buf *);
int	xyc_submit_iorq(struct xyc_softc *, struct xy_iorq *, int);
void	xyc_tick(void *);
int	xyc_unbusy(struct xyc *, int);
void	xyc_xyreset(struct xyc_softc *, struct xy_softc *);

/* machine interrupt hook */
int	xycintr(void *);

/* autoconf */
int	xycmatch(struct device *, void *, void *);
void	xycattach(struct device *, struct device *, void *);
int	xymatch(struct device *, void *, void *);
void	xyattach(struct device *, struct device *, void *);

static	void xydummystrat(struct buf *);
int	xygetdisklabel(dev_t, struct xy_softc *, struct disklabel *, int);

/*
 * cfdrivers: device driver interface to autoconfig
 */

struct cfattach xyc_ca = {
	sizeof(struct xyc_softc), xycmatch, xycattach
};

struct cfdriver xyc_cd = {
	NULL, "xyc", DV_DULL
};

struct cfattach xy_ca = {
	sizeof(struct xy_softc), xymatch, xyattach
};

struct cfdriver xy_cd = {
	NULL, "xy", DV_DISK
};

struct xyc_attach_args {	/* this is the "aux" args to xyattach */
	int	driveno;	/* unit number */
	char	*buf;		/* scratch buffer for reading disk label */
	char	*dvmabuf;	/* DVMA address of above */
	int	fullmode;	/* submit mode */
	int	booting;	/* are we booting or not? */
};

static void
xydummystrat(bp)
	struct buf *bp;
{
	struct xy_softc *xy;
	size_t sz;

	xy = (struct xy_softc *)xy_cd.cd_devs[DISKUNIT(bp->b_dev)];
	sz = MIN(bp->b_bcount, XYFM_BPS);
	bcopy(xy->xy_labeldata, bp->b_data, sz);
	bp->b_resid = bp->b_bcount - sz;
	if (bp->b_resid != 0) {
		bp->b_flags |= B_ERROR;
		bp->b_error = EIO;
	}
	bp->b_flags |= B_DONE;
}

int
xygetdisklabel(dev, xy, lp, spoofonly)
	dev_t dev;
	struct xy_softc *xy;
	struct disklabel *lp;
	int spoofonly;
{
	int error;

	bzero(lp, sizeof(struct disklabel));
	/* Required parameters for readdisklabel() */
	lp->d_secsize = XYFM_BPS;
	if (xy->state == XY_DRIVE_ATTACHING || xy->state == XY_DRIVE_NOLABEL) {
		/* needs to be nonzero */
		lp->d_secpercyl = 1;
	} else {
		/*
		 * Disk geometry is known for a previously found label.
		 * Use it.
		 */
		lp->d_ntracks = xy->nhead;
		lp->d_nsectors = xy->nsect;
		lp->d_ncylinders = xy->ncyl;
		lp->d_acylinders = xy->acyl;
		lp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;
		DL_SETDSIZE(lp, (u_int64_t)lp->d_secpercyl * lp->d_ncylinders);
	}
	lp->d_type = DTYPE_SMD;
	lp->d_version = 1;

	/* These are as defined in <ufs/ffs/fs.h> */
	lp->d_bbsize = 8192; /* BBSIZE */
	lp->d_sbsize = 8192; /* SBSIZE */

	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = dkcksum(lp);

	error = readdisklabel(DISKLABELDEV(dev),
	    xy->state == XY_DRIVE_ATTACHING ? xydummystrat : xystrategy,
	    lp, spoofonly);
	if (error)
		return error;

	/*
	 * If a label was found, get our geometry from it.
	 */
	if (xy->state == XY_DRIVE_ATTACHING || xy->state == XY_DRIVE_NOLABEL) {
		/*
		 * Note that this relies upon pcyl == cyl + acyl, and will
		 * ignore the explicit pcyl value from the converted SunOS
		 * label.
		 */
		xy->pcyl = lp->d_ncylinders + lp->d_acylinders;
		xy->ncyl = lp->d_ncylinders;
		xy->acyl = lp->d_acylinders;
		xy->nhead = lp->d_ntracks;
		xy->nsect = lp->d_nsectors;
		xy->sectpercyl = lp->d_secpercyl;
	}
	return 0;
}

/*
 * a u t o c o n f i g   f u n c t i o n s
 */

/*
 * xycmatch: determine if xyc is present or not.   we do a
 * soft reset to detect the xyc.
 */

int xycmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;
	struct xyc *xyc;

	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
		return (0);

	switch (ca->ca_bustype) {
	case BUS_OBIO:
	case BUS_SBUS:
	case BUS_VME32:
	default:
		return (0);
	case BUS_VME16:
		xyc = (struct xyc *) ra->ra_vaddr;
		if (probeget((caddr_t) &xyc->xyc_rsetup, 1) == -1)
			return (0);
		if (xyc_unbusy(xyc, XYC_RESETUSEC) == XY_ERR_FAIL)
			return(0);
		return (1);
	}
}

/*
 * xycattach: attach controller
 */
void
xycattach(parent, self, aux)
	struct device *parent, *self;
	void   *aux;

{
	struct xyc_softc *xyc = (void *) self;
	struct confargs *ca = aux;
	struct xyc_attach_args xa;
	int     lcv, err, pri, res, pbsz;
	void	*tmp, *tmp2;
	void	*dtmp, *dtmp2;
	u_long	ultmp;

	/* get addressing and intr level stuff from autoconfig and load it
	 * into our xyc_softc. */

	ca->ca_ra.ra_vaddr = mapiodev(ca->ca_ra.ra_reg, 0, sizeof(struct xyc));

	xyc->xyc = (struct xyc *) ca->ca_ra.ra_vaddr;
	pri = ca->ca_ra.ra_intr[0].int_pri;
	xyc->ipl = pil_to_vme[pri];
	xyc->vector = ca->ca_ra.ra_intr[0].int_vec;
	printf(" pri %d", pri);
	xyc->no_ols = 0; /* XXX should be from config */

	for (lcv = 0; lcv < XYC_MAXDEV; lcv++)
		xyc->sc_drives[lcv] = (struct xy_softc *) 0;

	/*
	 * allocate and zero buffers
	 * check boundaries of the KVA's ... all IOPBs must reside in
 	 * the same 64K region.
	 */

	pbsz = XYC_MAXIOPB * sizeof(struct xy_iopb);
	dtmp = dtmp2 = (struct xy_iopb *)dvma_malloc(pbsz, &tmp, M_NOWAIT);
	tmp2 = tmp;
	ultmp = (u_long) dtmp;
	if ((ultmp & 0xffff0000) != ((ultmp + pbsz) & 0xffff0000)) {
		dtmp = (struct xy_iopb *)
		    dvma_malloc(pbsz, &tmp, M_NOWAIT); /* retry! */
		dvma_free(dtmp2, pbsz, &tmp2);
		ultmp = (u_long) dtmp;
		if ((ultmp & 0xffff0000) != ((ultmp + pbsz) & 0xffff0000)) {
			printf("%s: can't alloc IOPB mem in 64K\n",
				xyc->sc_dev.dv_xname);
			return;
		}
	}
	bzero(tmp, pbsz);
	xyc->iopbase = tmp;
	xyc->iopbase = dtmp; /* XXX TMP HACK */
	xyc->dvmaiopb = (struct xy_iopb *) ((u_long)dtmp - DVMA_BASE);
	xyc->reqs = malloc(XYC_MAXIOPB * sizeof(struct xy_iorq), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
	if (xyc->reqs == NULL)
		panic("xyc malloc");

	/*
	 * init iorq to iopb pointers, and non-zero fields in the
	 * iopb which never change.
	 */

	for (lcv = 0; lcv < XYC_MAXIOPB; lcv++) {
		xyc->xy_chain[lcv] = NULL;
		xyc->reqs[lcv].iopb = &xyc->iopbase[lcv];
		xyc->iopbase[lcv].asr = 1;	/* always the same */
		xyc->iopbase[lcv].eef = 1;	/* always the same */
		xyc->iopbase[lcv].ecm = XY_ECM;	/* always the same */
		xyc->iopbase[lcv].aud = 1;	/* always the same */
		xyc->iopbase[lcv].relo = 1;	/* always the same */
		xyc->iopbase[lcv].thro = XY_THRO;/* always the same */
	}
	xyc->ciorq = &xyc->reqs[XYC_CTLIOPB];    /* shorthand name */
	xyc->ciopb = &xyc->iopbase[XYC_CTLIOPB]; /* shorthand name */
	xyc->xy_hand = 0;

	/* read controller parameters and insure we have a 450/451 */

	err = xyc_cmd(xyc, XYCMD_ST, 0, 0, 0, 0, 0, XY_SUB_POLL);
	res = xyc->ciopb->ctyp;
	XYC_DONE(xyc, err);
	if (res != XYCT_450) {
		if (err)
			printf(": %s: ", xyc_e2str(err));
		printf(": doesn't identify as a 450/451\n");
		return;
	}
	printf(": Xylogics 450/451");
	if (xyc->no_ols)
		printf(" [OLS disabled]"); /* 450 doesn't overlap seek right */
	printf("\n");
	if (err) {
		printf("%s: error: %s\n", xyc->sc_dev.dv_xname,
				xyc_e2str(err));
		return;
	}
	if ((xyc->xyc->xyc_csr & XYC_ADRM) == 0) {
		printf("%s: 24 bit addressing turned off\n",
			xyc->sc_dev.dv_xname);
		printf("please set hardware jumpers JM1-JM2=in, JM3-JM4=out\n");
		printf("to enable 24 bit mode and this driver\n");
		return;
	}

	/* link in interrupt with higher level software */

	xyc->sc_ih.ih_fun = xycintr;
	xyc->sc_ih.ih_arg = xyc;
	vmeintr_establish(ca->ca_ra.ra_intr[0].int_vec,
	    ca->ca_ra.ra_intr[0].int_pri, &xyc->sc_ih, IPL_BIO,
	    self->dv_xname);

	/* now we must look for disks using autoconfig */
	xa.dvmabuf = (char *)dvma_malloc(XYFM_BPS, &xa.buf, M_NOWAIT);
	xa.fullmode = XY_SUB_POLL;
	xa.booting = 1;

	if (ca->ca_ra.ra_bp && ca->ca_ra.ra_bp->val[0] == -1 &&
	    ca->ca_ra.ra_bp->val[1] == xyc->sc_dev.dv_unit) {
		bootpath_store(1, ca->ca_ra.ra_bp + 1); /* advance bootpath */
	}

	for (xa.driveno = 0; xa.driveno < XYC_MAXDEV; xa.driveno++)
		(void) config_found(self, (void *) &xa, NULL);

	dvma_free(xa.dvmabuf, XYFM_BPS, &xa.buf);
	bootpath_store(1, NULL);

	/* start the watchdog clock */
	timeout_set(&xyc->xyc_tick_tmo, xyc_tick, xyc);
	timeout_add(&xyc->xyc_tick_tmo, XYC_TICKCNT);

}

/*
 * xymatch: probe for disk.
 *
 * note: we almost always say disk is present.   this allows us to
 * spin up and configure a disk after the system is booted (we can
 * call xyattach!).
 */
int
xymatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct cfdata *cf = vcf;
	struct xyc_attach_args *xa = aux;

	/* looking for autoconf wildcard or exact match */

	if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != xa->driveno)
		return 0;

	return 1;

}

/*
 * xyattach: attach a disk.   this can be called from autoconf and also
 * from xyopen/xystrategy.
 */
void
xyattach(parent, self, aux)
	struct device *parent, *self;
	void   *aux;

{
	struct xy_softc *xy = (void *) self, *oxy;
	struct xyc_softc *xyc = (void *) parent;
	struct xyc_attach_args *xa = aux;
	int     err, spt, mb, blk, lcv, fmode, s = 0, newstate;
	struct dkbad *dkb;
	struct bootpath *bp;

	/*
	 * Always re-initialize the disk structure.  We want statistics
	 * to start with a clean slate.
	 */
	bzero(&xy->sc_dk, sizeof(xy->sc_dk));
	xy->sc_dk.dk_name = xy->sc_dev.dv_xname;

	/* if booting, init the xy_softc */

	if (xa->booting) {
		xy->state = XY_DRIVE_UNKNOWN;	/* to start */
		xy->flags = 0;
		xy->parent = xyc;

		/* init queue of waiting bufs */
		bufq_init(&xy->xy_bufq, BUFQ_DEFAULT);

		xy->xyrq = &xyc->reqs[xa->driveno];

	}
	xy->xy_drive = xa->driveno;
	fmode = xa->fullmode;
	xyc->sc_drives[xa->driveno] = xy;

	/* if not booting, make sure we are the only process in the attach for
	 * this drive.   if locked out, sleep on it. */

	if (!xa->booting) {
		s = splbio();
		while (xy->state == XY_DRIVE_ATTACHING) {
			if (tsleep(&xy->state, PRIBIO, "xyattach", 0)) {
				splx(s);
				return;
			}
		}
		printf("%s at %s",
			xy->sc_dev.dv_xname, xy->parent->sc_dev.dv_xname);
	}
	/* we now have control */

	xy->state = XY_DRIVE_ATTACHING;
	newstate = XY_DRIVE_UNKNOWN;

	/* first try and reset the drive */

	err = xyc_cmd(xyc, XYCMD_RST, 0, xy->xy_drive, 0, 0, 0, fmode);
	XYC_DONE(xyc, err);
	if (err == XY_ERR_DNRY) {
		printf(" drive %d: off-line\n", xa->driveno);
		goto done;
	}
	if (err) {
		printf(": ERROR 0x%02x (%s)\n", err, xyc_e2str(err));
		goto done;
	}
	printf(" drive %d: ready", xa->driveno);

	/*
	 * now set drive parameters (to semi-bogus values) so we can read the
	 * disk label.
	 */
	xy->pcyl = xy->ncyl = 1;
	xy->acyl = 0;
	xy->nhead = 1;
	xy->nsect = 1;
	xy->sectpercyl = 1;
	for (lcv = 0; lcv < NBT_BAD; lcv++)	/* init empty bad144 table */
		xy->dkb.bt_bad[lcv].bt_cyl =
			xy->dkb.bt_bad[lcv].bt_trksec = 0xffff;

	/* read disk label */
	for (xy->drive_type = 0 ; xy->drive_type <= XYC_MAXDT ;
						xy->drive_type++) {
		err = xyc_cmd(xyc, XYCMD_RD, 0, xy->xy_drive, 0, 1,
						xa->dvmabuf, fmode);
		XYC_DONE(xyc, err);
		if (err == XY_ERR_AOK) break;
	}

	if (err != XY_ERR_AOK) {
		printf("\n%s: reading disk label failed: %s\n",
			xy->sc_dev.dv_xname, xyc_e2str(err));
		goto done;
	}
	printf(" (drive type %d)\n", xy->drive_type);

	newstate = XY_DRIVE_NOLABEL;

	xy->hw_spt = spt = 0; /* XXX needed ? */
	/* Attach the disk: must be before getdisklabel to malloc label */
	disk_attach(&xy->sc_dev, &xy->sc_dk);

	xy->xy_labeldata = xa->buf;
	if (xygetdisklabel(MAKEDISKDEV(0, xy->sc_dev.dv_unit, 0), xy,
	    xy->sc_dk.dk_label, 0) != 0) {
		printf("%s: no label, unknown geometry\n", xy->sc_dev.dv_xname);
		goto done;
	}

	/* inform the user of what is up */
	printf("%s: <%s>, pcyl %d\n", xy->sc_dev.dv_xname,
		xa->buf, xy->pcyl);
	mb = xy->ncyl * (xy->nhead * xy->nsect) / (1048576 / XYFM_BPS);
	printf("%s: %dMB, %d cyl, %d head, %d sec, %d bytes/sec\n",
		xy->sc_dev.dv_xname, mb, xy->ncyl, xy->nhead, xy->nsect,
		XYFM_BPS);

	/*
	 * 450/451 stupidity: the drive type is encoded into the format
	 * of the disk.   the drive type in the IOPB must match the drive
	 * type in the format, or you will not be able to do I/O to the
	 * disk (you get header not found errors).  if you have two drives
	 * of different sizes that have the same drive type in their
	 * formatting then you are out of luck.
	 *
	 * this problem was corrected in the 753/7053.
	 */

	for (lcv = 0 ; lcv < XYC_MAXDEV ; lcv++) {
		oxy = xyc->sc_drives[lcv];
		if (oxy == NULL || oxy == xy) continue;
		if (oxy->drive_type != xy->drive_type) continue;
		if (xy->nsect != oxy->nsect || xy->pcyl != oxy->pcyl ||
			xy->nhead != oxy->nhead) {
			printf("%s: %s and %s must be the same size!\n",
				xyc->sc_dev.dv_xname, xy->sc_dev.dv_xname,
				oxy->sc_dev.dv_xname);
			panic("xy drive size mismatch");
		}
	}


	/* now set the real drive parameters! */

	blk = (xy->nsect - 1) +
		((xy->nhead - 1) * xy->nsect) +
		((xy->pcyl - 1) * xy->nsect * xy->nhead);
	err = xyc_cmd(xyc, XYCMD_SDS, 0, xy->xy_drive, blk, 0, 0, fmode);
	XYC_DONE(xyc, err);
	if (err) {
		printf("%s: write drive size failed: %s\n",
			xy->sc_dev.dv_xname, xyc_e2str(err));
		goto done;
	}
	newstate = XY_DRIVE_ONLINE;

	/*
	 * read bad144 table. this table resides on the first sector of the
	 * last track of the disk (i.e. second cyl of "acyl" area).
	 */

	blk = (xy->ncyl + xy->acyl - 1) * (xy->nhead * xy->nsect) +
								/* last cyl */
	    (xy->nhead - 1) * xy->nsect;	/* last head */
	err = xyc_cmd(xyc, XYCMD_RD, 0, xy->xy_drive, blk, 1,
						xa->dvmabuf, fmode);
	XYC_DONE(xyc, err);
	if (err) {
		printf("%s: reading bad144 failed: %s\n",
			xy->sc_dev.dv_xname, xyc_e2str(err));
		goto done;
	}

	/* check dkbad for sanity */
	dkb = (struct dkbad *) xa->buf;
	for (lcv = 0; lcv < NBT_BAD; lcv++) {
		if ((dkb->bt_bad[lcv].bt_cyl == 0xffff ||
				dkb->bt_bad[lcv].bt_cyl == 0) &&
		     dkb->bt_bad[lcv].bt_trksec == 0xffff)
			continue;	/* blank */
		if (dkb->bt_bad[lcv].bt_cyl >= xy->ncyl)
			break;
		if ((dkb->bt_bad[lcv].bt_trksec >> 8) >= xy->nhead)
			break;
		if ((dkb->bt_bad[lcv].bt_trksec & 0xff) >= xy->nsect)
			break;
	}
	if (lcv != NBT_BAD) {
		printf("%s: warning: invalid bad144 sector!\n",
			xy->sc_dev.dv_xname);
	} else {
		bcopy(xa->buf, &xy->dkb, XYFM_BPS);
	}

	if (xa->booting) {
		/* restore bootpath! (do this via attach_args again?)*/
		bp = bootpath_store(0, NULL);
		if (bp && strcmp("xy", bp->name) == 0 &&
					xy->xy_drive == bp->val[0])
			bp->dev = &xy->sc_dev;
	}

done:
	xy->state = newstate;
	if (!xa->booting) {
		wakeup(&xy->state);
		splx(s);
	}
}

/*
 * end of autoconfig functions
 */

/*
 * { b , c } d e v s w   f u n c t i o n s
 */

/*
 * xyclose: close device
 */
int
xyclose(dev, flag, fmt, p)
	dev_t   dev;
	int     flag, fmt;
	struct proc *p;

{
	struct xy_softc *xy = xy_cd.cd_devs[DISKUNIT(dev)];
	int     part = DISKPART(dev);

	/* clear mask bits */

	switch (fmt) {
	case S_IFCHR:
		xy->sc_dk.dk_copenmask &= ~(1 << part);
		break;
	case S_IFBLK:
		xy->sc_dk.dk_bopenmask &= ~(1 << part);
		break;
	}
	xy->sc_dk.dk_openmask = xy->sc_dk.dk_copenmask | xy->sc_dk.dk_bopenmask;

	return 0;
}

/*
 * xydump: crash dump system
 */
int
xydump(dev, blkno, va, size)
	dev_t dev;
	daddr_t blkno;
	caddr_t va;
	size_t size;
{
	int     unit, part;
	struct xy_softc *xy;

	unit = DISKUNIT(dev);
	if (unit >= xy_cd.cd_ndevs)
		return ENXIO;
	part = DISKPART(dev);

	xy = xy_cd.cd_devs[unit];

	printf("%s%c: crash dump not supported (yet)\n", xy->sc_dev.dv_xname,
	    'a' + part);

	return ENXIO;
}

/*
 * xyioctl: ioctls on XY drives.   based on ioctl's of other netbsd disks.
 */
int
xyioctl(dev, command, addr, flag, p)
	dev_t   dev;
	u_long  command;
	caddr_t addr;
	int     flag;
	struct proc *p;

{
	struct xy_softc *xy;
	int     error, s, unit;

	unit = DISKUNIT(dev);

	if (unit >= xy_cd.cd_ndevs || (xy = xy_cd.cd_devs[unit]) == NULL)
		return (ENXIO);

	/* switch on ioctl type */

	switch (command) {
	case DIOCSBAD:		/* set bad144 info */
		if ((flag & FWRITE) == 0)
			return EBADF;
		s = splbio();
		bcopy(addr, &xy->dkb, sizeof(xy->dkb));
		splx(s);
		return 0;

	case DIOCGPDINFO:
		xygetdisklabel(dev, xy, (struct disklabel *)addr, 1);
		return 0;

	case DIOCGDINFO:	/* get disk label */
		bcopy(xy->sc_dk.dk_label, addr, sizeof(struct disklabel));
		return 0;

	case DIOCGPART:	/* get partition info */
		((struct partinfo *)addr)->disklab = xy->sc_dk.dk_label;
		((struct partinfo *)addr)->part =
		    &xy->sc_dk.dk_label->d_partitions[DISKPART(dev)];
		return 0;

	case DIOCWDINFO:	/* write disk label */
	case DIOCSDINFO:	/* set disk label */
		if ((flag & FWRITE) == 0)
			return EBADF;
		error = setdisklabel(xy->sc_dk.dk_label,
		    (struct disklabel *)addr, /* xy->sc_dk.dk_openmask : */ 0);
		if (error == 0) {
			if (xy->state == XY_DRIVE_NOLABEL)
				xy->state = XY_DRIVE_ONLINE;

			if (command == DIOCWDINFO) {
				/*
				 * Simulate opening partition 0 so write
				 * succeeds.
				 */
				xy->sc_dk.dk_openmask |= (1 << 0);
				error = writedisklabel(DISKLABELDEV(dev),
				    xystrategy, xy->sc_dk.dk_label);
				xy->sc_dk.dk_openmask = xy->sc_dk.dk_copenmask |
				    xy->sc_dk.dk_bopenmask;
			}
		}
		return error;

	default:
		return ENOTTY;
	}
}

/*
 * xyopen: open drive
 */

int
xyopen(dev, flag, fmt, p)
	dev_t   dev;
	int     flag, fmt;
	struct proc *p;
{
	int     unit, part;
	struct xy_softc *xy;
	struct xyc_attach_args xa;

	/* first, could it be a valid target? */

	unit = DISKUNIT(dev);
	if (unit >= xy_cd.cd_ndevs || (xy = xy_cd.cd_devs[unit]) == NULL)
		return (ENXIO);
	part = DISKPART(dev);

	/* do we need to attach the drive? */

	if (xy->state == XY_DRIVE_UNKNOWN) {
		xa.driveno = xy->xy_drive;
		xa.dvmabuf = (char *)dvma_malloc(XYFM_BPS, &xa.buf, M_NOWAIT);
		xa.fullmode = XY_SUB_WAIT;
		xa.booting = 0;
		xyattach((struct device *) xy->parent,
						(struct device *) xy, &xa);
		dvma_free(xa.dvmabuf, XYFM_BPS, &xa.buf);
		if (xy->state == XY_DRIVE_UNKNOWN) {
			return (EIO);
		}
	}
	/* check for partition */

	if (part != RAW_PART &&
	    (part >= xy->sc_dk.dk_label->d_npartitions ||
		xy->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {
		return (ENXIO);
	}
	/* set open masks */

	switch (fmt) {
	case S_IFCHR:
		xy->sc_dk.dk_copenmask |= (1 << part);
		break;
	case S_IFBLK:
		xy->sc_dk.dk_bopenmask |= (1 << part);
		break;
	}
	xy->sc_dk.dk_openmask = xy->sc_dk.dk_copenmask | xy->sc_dk.dk_bopenmask;

	return 0;
}

int
xyread(dev, uio, flags)
	dev_t   dev;
	struct uio *uio;
	int flags;
{

	return (physio(xystrategy, dev, B_READ, minphys, uio));
}

int
xywrite(dev, uio, flags)
	dev_t   dev;
	struct uio *uio;
	int flags;
{

	return (physio(xystrategy, dev, B_WRITE, minphys, uio));
}


/*
 * xysize: return size of a partition for a dump
 */

daddr_t
xysize(dev)
	dev_t   dev;

{
	struct xy_softc *xysc;
	int     unit, part, omask;
	daddr_t size;

	/* valid unit? */
	unit = DISKUNIT(dev);
	if (unit >= xy_cd.cd_ndevs || (xysc = xy_cd.cd_devs[unit]) == NULL)
		return (-1);

	part = DISKPART(dev);
	omask = xysc->sc_dk.dk_openmask & (1 << part);

	if (omask == 0 && xyopen(dev, 0, S_IFBLK, NULL) != 0)
		return (-1);

	/* do it */
	if (xysc->sc_dk.dk_label->d_partitions[part].p_fstype != FS_SWAP)
		size = -1;	/* only give valid size for swap partitions */
	else
		size = DL_GETPSIZE(&xysc->sc_dk.dk_label->d_partitions[part]) *
		    (xysc->sc_dk.dk_label->d_secsize / DEV_BSIZE);
	if (omask == 0 && xyclose(dev, 0, S_IFBLK, NULL) != 0)
		return (-1);
	return (size);
}

/*
 * xystrategy: buffering system interface to xy.
 */

void
xystrategy(bp)
	struct buf *bp;

{
	struct xy_softc *xy;
	int     s, unit;
	struct xyc_attach_args xa;

	unit = DISKUNIT(bp->b_dev);

	/* check for live device */

	if (unit >= xy_cd.cd_ndevs || (xy = xy_cd.cd_devs[unit]) == 0) {
		bp->b_error = EINVAL;
		goto bad;
	}
	/* do we need to attach the drive? */

	if (xy->state == XY_DRIVE_UNKNOWN) {
		xa.driveno = xy->xy_drive;
		xa.dvmabuf = (char *)dvma_malloc(XYFM_BPS, &xa.buf, M_NOWAIT);
		xa.fullmode = XY_SUB_WAIT;
		xa.booting = 0;
		xyattach((struct device *)xy->parent, (struct device *)xy, &xa);
		dvma_free(xa.dvmabuf, XYFM_BPS, &xa.buf);
		if (xy->state == XY_DRIVE_UNKNOWN) {
			bp->b_error = EIO;
			goto bad;
		}
	}
	if (xy->state != XY_DRIVE_ONLINE && DISKPART(bp->b_dev) != RAW_PART) {
		/* no I/O to unlabeled disks, unless raw partition */
		bp->b_error = EIO;
		goto bad;
	}

	/* Validate the request. */
	if (bounds_check_with_label(bp, xy->sc_dk.dk_label) == -1)
		goto done;

	bufq_queue(&xy->xy_bufq, bp);

	/*
	 * now we know we have a valid buf structure that we need to do I/O
	 * on.
	 */
	s = splbio();		/* protect the queues */

	/* start 'em up */

	xyc_start(xy->parent, NULL);

	/* done! */

	splx(s);
	return;

 bad:				/* tells upper layers we have an error */
	bp->b_flags |= B_ERROR;
	bp->b_resid = bp->b_bcount;
 done:				/* tells upper layers we are done with this
				 * buf */
	s = splbio();
	biodone(bp);
	splx(s);
}
/*
 * end of {b,c}devsw functions
 */

/*
 * i n t e r r u p t   f u n c t i o n
 *
 * xycintr: hardware interrupt.
 */
int
xycintr(v)
	void   *v;

{
	struct xyc_softc *xycsc = v;

	/* remove as many done IOPBs as possible */

	xyc_remove_iorq(xycsc);

	/* start any iorq's already waiting */

	xyc_start(xycsc, NULL);

	return (1);
}
/*
 * end of interrupt function
 */

/*
 * i n t e r n a l   f u n c t i o n s
 */

/*
 * xyc_rqinit: fill out the fields of an I/O request
 */

inline void
xyc_rqinit(rq, xyc, xy, md, blk, cnt, db, bp)
	struct xy_iorq *rq;
	struct xyc_softc *xyc;
	struct xy_softc *xy;
	int     md;
	u_long  blk;
	int     cnt;
	caddr_t db;
	struct buf *bp;
{
	rq->xyc = xyc;
	rq->xy = xy;
	rq->ttl = XYC_MAXTTL + 10;
	rq->mode = md;
	rq->tries = rq->errno = rq->lasterror = 0;
	rq->blockno = blk;
	rq->sectcnt = cnt;
	rq->dbuf = rq->dbufbase = db;
	rq->buf = bp;
}

/*
 * xyc_rqtopb: load up an IOPB based on an iorq
 */

void
xyc_rqtopb(iorq, iopb, cmd, subfun)
	struct xy_iorq *iorq;
	struct xy_iopb *iopb;
	int     cmd, subfun;

{
	u_long  block, dp;

	/* normal IOPB case, standard stuff */

	/* chain bit handled later */
	iopb->ien = (XY_STATE(iorq->mode) == XY_SUB_POLL) ? 0 : 1;
	iopb->com = cmd;
	iopb->errno = 0;
	iopb->errs = 0;
	iopb->done = 0;
	if (iorq->xy) {
		iopb->unit = iorq->xy->xy_drive;
		iopb->dt = iorq->xy->drive_type;
	} else {
		iopb->unit = 0;
		iopb->dt = 0;
	}
	block = iorq->blockno;
	if (iorq->xy == NULL || block == 0) {
		iopb->sect = iopb->head = iopb->cyl = 0;
	} else {
		iopb->sect = block % iorq->xy->nsect;
		block = block / iorq->xy->nsect;
		iopb->head = block % iorq->xy->nhead;
		block = block / iorq->xy->nhead;
		iopb->cyl = block;
	}
	iopb->scnt = iorq->sectcnt;
	dp = (u_long) iorq->dbuf - DVMA_BASE;
	if (iorq->dbuf == NULL) {
		iopb->dataa = 0;
		iopb->datar = 0;
	} else {
		iopb->dataa = (dp & 0xffff);
		iopb->datar = ((dp & 0xff0000) >> 16);
	}
	iopb->subfn = subfun;
}


/*
 * xyc_unbusy: wait for the xyc to go unbusy, or timeout.
 */

int
xyc_unbusy(xyc, del)

struct xyc *xyc;
int del;

{
	while (del-- > 0) {
		if ((xyc->xyc_csr & XYC_GBSY) == 0)
			break;
		DELAY(1);
	}
	return(del == 0 ? XY_ERR_FAIL : XY_ERR_AOK);
}

/*
 * xyc_cmd: front end for POLL'd and WAIT'd commands.  Returns 0 or error.
 * note that NORM requests are handled separately.
 */
int
xyc_cmd(xycsc, cmd, subfn, unit, block, scnt, dptr, fullmode)
	struct xyc_softc *xycsc;
	int     cmd, subfn, unit, block, scnt;
	char   *dptr;
	int     fullmode;

{
	int     submode = XY_STATE(fullmode);
	struct xy_iorq *iorq = xycsc->ciorq;
	struct xy_iopb *iopb = xycsc->ciopb;

	/*
	 * is someone else using the control iopq wait for it if we can
	 */
start:
	if (submode == XY_SUB_WAIT && XY_STATE(iorq->mode) != XY_SUB_FREE) {
		if (tsleep(iorq, PRIBIO, "xyc_cmd", 0))
                                return(XY_ERR_FAIL);
		goto start;
	}

	if (XY_STATE(iorq->mode) != XY_SUB_FREE) {
		DELAY(1000000);		/* XY_SUB_POLL: steal the iorq */
		iorq->mode = XY_SUB_FREE;
		printf("%s: stole control iopb\n", xycsc->sc_dev.dv_xname);
	}

	/* init iorq/iopb */

	xyc_rqinit(iorq, xycsc,
	    (unit == XYC_NOUNIT) ? NULL : xycsc->sc_drives[unit],
	    fullmode, block, scnt, dptr, NULL);

	/* load IOPB from iorq */

	xyc_rqtopb(iorq, iopb, cmd, subfn);

	/* submit it for processing */

	xyc_submit_iorq(xycsc, iorq, fullmode);	/* error code will be in iorq */

	return(XY_ERR_AOK);
}

/*
 * xyc_startbuf
 * start a buffer for running
 */

int
xyc_startbuf(xycsc, xysc, bp)
	struct xyc_softc *xycsc;
	struct xy_softc *xysc;
	struct buf *bp;

{
	int     partno;
	struct xy_iorq *iorq;
	struct xy_iopb *iopb;
	daddr_t  block;
	caddr_t dbuf;

	iorq = xysc->xyrq;
	iopb = iorq->iopb;

	/* get buf */

	if (bp == NULL)
		panic("xyc_startbuf null buf");

	partno = DISKPART(bp->b_dev);
#ifdef XYC_DEBUG
	printf("xyc_startbuf: %s%c: %s block %lld\n",
	    xysc->sc_dev.dv_xname, 'a' + partno,
	    (bp->b_flags & B_READ) ? "read" : "write", (long long)bp->b_blkno);
	printf("xyc_startbuf: b_bcount %d, b_data 0x%x\n",
	    bp->b_bcount, bp->b_data);
#endif

	/*
	 * load request.  we have to calculate the correct block number based
	 * on partition info.
	 *
	 * note that iorq points to the buffer as mapped into DVMA space,
	 * where as the bp->b_data points to its non-DVMA mapping.
	 */

	block = bp->b_blkno + ((partno == RAW_PART) ? 0 :
	    DL_GETPOFFSET(&xysc->sc_dk.dk_label->d_partitions[partno]));

	dbuf = kdvma_mapin(bp->b_data, bp->b_bcount, 0);
	if (dbuf == NULL) {	/* out of DVMA space */
		printf("%s: warning: out of DVMA space\n",
			xycsc->sc_dev.dv_xname);
		return (XY_ERR_FAIL);	/* XXX: need some sort of
					 * call-back scheme here? */
	}

	/* init iorq and load iopb from it */

	xyc_rqinit(iorq, xycsc, xysc, XY_SUB_NORM | XY_MODE_VERBO, block,
	    bp->b_bcount / XYFM_BPS, dbuf, bp);

	xyc_rqtopb(iorq, iopb, (bp->b_flags & B_READ) ? XYCMD_RD : XYCMD_WR, 0);

	/* Instrumentation. */
	disk_busy(&xysc->sc_dk);

	return (XY_ERR_AOK);
}


/*
 * xyc_submit_iorq: submit an iorq for processing.  returns XY_ERR_AOK
 * if ok.  if it fail returns an error code.  type is XY_SUB_*.
 *
 * note: caller frees iorq in all cases except NORM
 *
 * return value:
 *   NORM: XY_AOK (req pending), XY_FAIL (couldn't submit request)
 *   WAIT: XY_AOK (success), <error-code> (failed)
 *   POLL: <same as WAIT>
 *   NOQ : <same as NORM>
 *
 * there are three sources for i/o requests:
 * [1] xystrategy: normal block I/O, using "struct buf" system.
 * [2] autoconfig/crash dump: these are polled I/O requests, no interrupts.
 * [3] open/ioctl: these are I/O requests done in the context of a process,
 *                 and the process should block until they are done.
 *
 * software state is stored in the iorq structure.  each iorq has an
 * iopb structure.  the hardware understands the iopb structure.
 * every command must go through an iopb.  a 450 handles one iopb at a
 * time, where as a 451 can take them in chains.  [the 450 claims it
 * can handle chains, but is appears to be buggy...]   iopb are allocated
 * in DVMA space at boot up time.  each disk gets one iopb, and the
 * controller gets one (for POLL and WAIT commands).  what happens if
 * the iopb is busy?  for i/o type [1], the buffers are queued at the
 * "buff" layer and * picked up later by the interrupt routine.  for case
 * [2] we can only be blocked if there is a WAIT type I/O request being
 * run.   since this can only happen when we are crashing, we wait a sec
 * and then steal the IOPB.  for case [3] the process can sleep
 * on the iorq free list until some iopbs are available.
 */


int
xyc_submit_iorq(xycsc, iorq, type)
	struct xyc_softc *xycsc;
	struct xy_iorq *iorq;
	int     type;

{
	struct xy_iopb *iopb;
	u_long  iopbaddr;

#ifdef XYC_DEBUG
	printf("xyc_submit_iorq(%s, addr=0x%x, type=%d)\n",
		xycsc->sc_dev.dv_xname, iorq, type);
#endif

	/* first check and see if controller is busy */
	if ((xycsc->xyc->xyc_csr & XYC_GBSY) != 0) {
#ifdef XYC_DEBUG
		printf("xyc_submit_iorq: XYC not ready (BUSY)\n");
#endif
		if (type == XY_SUB_NOQ)
			return (XY_ERR_FAIL);	/* failed */
		switch (type) {
		case XY_SUB_NORM:
			return XY_ERR_AOK;	/* success */
		case XY_SUB_WAIT:
			while (iorq->iopb->done == 0) {
				tsleep(iorq, PRIBIO, "xyiorq", 0);
			}
			return (iorq->errno);
		case XY_SUB_POLL:		/* steal controller */
			iopbaddr = xycsc->xyc->xyc_rsetup; /* RESET */
			if (xyc_unbusy(xycsc->xyc,XYC_RESETUSEC) == XY_ERR_FAIL)
				panic("xyc_submit_iorq: stuck xyc");
			printf("%s: stole controller\n",
				xycsc->sc_dev.dv_xname);
			break;
		default:
			panic("xyc_submit_iorq adding");
		}
	}

	iopb = xyc_chain(xycsc, iorq);	 /* build chain */
	if (iopb == NULL) { /* nothing doing? */
		if (type == XY_SUB_NORM || type == XY_SUB_NOQ)
			return(XY_ERR_AOK);
		panic("xyc_submit_iorq: xyc_chain failed!");
	}
	iopbaddr = (u_long) iopb - DVMA_BASE;

	XYC_GO(xycsc->xyc, iopbaddr);

	/* command now running, wrap it up */
	switch (type) {
	case XY_SUB_NORM:
	case XY_SUB_NOQ:
		return (XY_ERR_AOK);	/* success */
	case XY_SUB_WAIT:
		while (iorq->iopb->done == 0) {
			tsleep(iorq, PRIBIO, "xyiorq", 0);
		}
		return (iorq->errno);
	case XY_SUB_POLL:
		return (xyc_piodriver(xycsc, iorq));
	default:
		panic("xyc_submit_iorq wrap up");
	}
	panic("xyc_submit_iorq");
	return 0;	/* not reached */
}


/*
 * xyc_chain: build a chain.  return dvma address of first element in
 * the chain.   iorq != NULL: means we only want that item on the chain.
 */

struct xy_iopb *
xyc_chain(xycsc, iorq)

struct xyc_softc *xycsc;
struct xy_iorq *iorq;

{
  int togo, chain, hand;
  struct xy_iopb *iopb, *prev_iopb;
  bzero(xycsc->xy_chain, sizeof(xycsc->xy_chain));

  /*
   * promote control IOPB to the top
   */
  if (iorq == NULL) {
    if ((XY_STATE(xycsc->reqs[XYC_CTLIOPB].mode) == XY_SUB_POLL ||
        XY_STATE(xycsc->reqs[XYC_CTLIOPB].mode) == XY_SUB_WAIT) &&
		xycsc->iopbase[XYC_CTLIOPB].done == 0)
    iorq = &xycsc->reqs[XYC_CTLIOPB];
  }
  /*
   * special case: if iorq != NULL then we have a POLL or WAIT request.
   * we let these take priority and do them first.
   */
  if (iorq) {
    xycsc->xy_chain[0] = iorq;
    iorq->iopb->chen = 0;
    return(iorq->iopb);
  }

  /*
   * NORM case: do round robin and maybe chain (if allowed and possible)
   */

  chain = 0;
  hand = xycsc->xy_hand;
  xycsc->xy_hand = (xycsc->xy_hand + 1) % XYC_MAXIOPB;

  for (togo = XYC_MAXIOPB ; togo > 0 ; togo--, hand = (hand + 1) % XYC_MAXIOPB){

    if (XY_STATE(xycsc->reqs[hand].mode) != XY_SUB_NORM ||
		xycsc->iopbase[hand].done)
      continue;   /* not ready-for-i/o */

    xycsc->xy_chain[chain] = &xycsc->reqs[hand];
    iopb = xycsc->xy_chain[chain]->iopb;
    iopb->chen = 0;
    if (chain != 0) {   /* adding a link to a chain? */
      prev_iopb = xycsc->xy_chain[chain-1]->iopb;
      prev_iopb->chen = 1;
      prev_iopb->nxtiopb = ((u_long) iopb - DVMA_BASE) & 0xffff;
    } else {            /* head of chain */
      iorq = xycsc->xy_chain[chain];
    }
    chain++;
    if (xycsc->no_ols) break;   /* quit if chaining dis-allowed */
  }
  return(iorq ? iorq->iopb : NULL);
}

/*
 * xyc_piodriver
 *
 * programmed i/o driver.   this function takes over the computer
 * and drains off the polled i/o request.   it returns the status of the iorq
 * the caller is interesting in.
 */
int
xyc_piodriver(xycsc, iorq)
	struct xyc_softc *xycsc;
	struct xy_iorq  *iorq;

{
	int     nreset = 0;
	int     retval = 0;
	u_long  res;
#ifdef XYC_DEBUG
	printf("xyc_piodriver(%s, 0x%x)\n", xycsc->sc_dev.dv_xname, iorq);
#endif

	while (iorq->iopb->done == 0) {

		res = xyc_unbusy(xycsc->xyc, XYC_MAXTIME);

		/* we expect some progress soon */
		if (res == XY_ERR_FAIL && nreset >= 2) {
			xyc_reset(xycsc, 0, XY_RSET_ALL, XY_ERR_FAIL, 0);
#ifdef XYC_DEBUG
			printf("xyc_piodriver: timeout\n");
#endif
			return (XY_ERR_FAIL);
		}
		if (res == XY_ERR_FAIL) {
			if (xyc_reset(xycsc, 0,
				      (nreset++ == 0) ? XY_RSET_NONE : iorq,
				      XY_ERR_FAIL,
				      0) == XY_ERR_FAIL)
				return (XY_ERR_FAIL);	/* flushes all but POLL
							 * requests, resets */
			continue;
		}

		xyc_remove_iorq(xycsc);	 /* may resubmit request */

		if (iorq->iopb->done == 0)
			xyc_start(xycsc, iorq);
	}

	/* get return value */

	retval = iorq->errno;

#ifdef XYC_DEBUG
	printf("xyc_piodriver: done, retval = 0x%x (%s)\n",
	    iorq->errno, xyc_e2str(iorq->errno));
#endif

	/* start up any bufs that have queued */

	xyc_start(xycsc, NULL);

	return (retval);
}

/*
 * xyc_xyreset: reset one drive.   NOTE: assumes xyc was just reset.
 * we steal iopb[XYC_CTLIOPB] for this, but we put it back when we are done.
 */
void
xyc_xyreset(xycsc, xysc)
	struct xyc_softc *xycsc;
	struct xy_softc *xysc;

{
	struct xy_iopb tmpiopb;
	u_long  addr;
	int     del;
	bcopy(xycsc->ciopb, &tmpiopb, sizeof(tmpiopb));
	xycsc->ciopb->chen = xycsc->ciopb->done = xycsc->ciopb->errs = 0;
	xycsc->ciopb->ien = 0;
	xycsc->ciopb->com = XYCMD_RST;
	xycsc->ciopb->unit = xysc->xy_drive;
	addr = (u_long) xycsc->ciopb - DVMA_BASE;

	XYC_GO(xycsc->xyc, addr);

	del = XYC_RESETUSEC;
	while (del > 0) {
		if ((xycsc->xyc->xyc_csr & XYC_GBSY) == 0) break;
		DELAY(1);
		del--;
	}

	if (del <= 0 || xycsc->ciopb->errs) {
		printf("%s: off-line: %s\n", xycsc->sc_dev.dv_xname,
		    xyc_e2str(xycsc->ciopb->errno));
		del = xycsc->xyc->xyc_rsetup;
		if (xyc_unbusy(xycsc->xyc, XYC_RESETUSEC) == XY_ERR_FAIL)
			panic("xyc_reset");
	} else {
		xycsc->xyc->xyc_csr = XYC_IPND;	/* clear IPND */
	}
	bcopy(&tmpiopb, xycsc->ciopb, sizeof(tmpiopb));
}


/*
 * xyc_reset: reset everything: requests are marked as errors except
 * a polled request (which is resubmitted)
 */
int
xyc_reset(xycsc, quiet, blastmode, error, xysc)
	struct xyc_softc *xycsc;
	int     quiet, error;
	struct xy_iorq *blastmode;
	struct xy_softc *xysc;

{
	int     del = 0, lcv, retval = XY_ERR_AOK;

	/* soft reset hardware */

	if (!quiet)
		printf("%s: soft reset\n", xycsc->sc_dev.dv_xname);
	del = xycsc->xyc->xyc_rsetup;
	del = xyc_unbusy(xycsc->xyc, XYC_RESETUSEC);
	if (del == XY_ERR_FAIL) {
		blastmode = XY_RSET_ALL;	/* dead, flush all requests */
		retval = XY_ERR_FAIL;
	}
	if (xysc)
		xyc_xyreset(xycsc, xysc);

	/* fix queues based on "blast-mode" */

	for (lcv = 0; lcv < XYC_MAXIOPB; lcv++) {
		struct xy_iorq *iorq = &xycsc->reqs[lcv];

		if (XY_STATE(iorq->mode) != XY_SUB_POLL &&
		    XY_STATE(iorq->mode) != XY_SUB_WAIT &&
		    XY_STATE(iorq->mode) != XY_SUB_NORM)
			/* is it active? */
			continue;

		if (blastmode == XY_RSET_ALL ||
				blastmode != iorq) {
			/* failed */
			iorq->errno = error;
			xycsc->iopbase[lcv].done = xycsc->iopbase[lcv].errs = 1;
			switch (XY_STATE(iorq->mode)) {
			case XY_SUB_NORM:
			    iorq->buf->b_error = EIO;
			    iorq->buf->b_flags |= B_ERROR;
			    iorq->buf->b_resid = iorq->sectcnt * XYFM_BPS;
			    dvma_mapout((vaddr_t)iorq->dbufbase,
					(vaddr_t)iorq->buf->b_data,
					iorq->buf->b_bcount);
			    disk_unbusy(&xycsc->reqs[lcv].xy->sc_dk,
				(xycsc->reqs[lcv].buf->b_bcount -
				xycsc->reqs[lcv].buf->b_resid),
				(xycsc->reqs[lcv].buf->b_flags & B_READ));
			    biodone(iorq->buf);
			    iorq->mode = XY_SUB_FREE;
			    break;
			case XY_SUB_WAIT:
			    wakeup(iorq);
			case XY_SUB_POLL:
			    iorq->mode =
				XY_NEWSTATE(iorq->mode, XY_SUB_DONE);
			    break;
			}

		} else {

			/* resubmit, no need to do anything here */
		}
	}

	/*
	 * now, if stuff is waiting, start it.
	 * since we just reset it should go
	 */
	xyc_start(xycsc, NULL);

	return (retval);
}

/*
 * xyc_start: start waiting buffers
 */

void
xyc_start(xycsc, iorq)
	struct xyc_softc *xycsc;
	struct xy_iorq *iorq;

{
	int lcv;
	struct xy_softc *xy;

	if (iorq == NULL) {
		for (lcv = 0; lcv < XYC_MAXDEV ; lcv++) {
			if ((xy = xycsc->sc_drives[lcv]) == NULL) continue;
			if (!bufq_peek(&xy->xy_bufq)) continue;
			if (xy->xyrq->mode != XY_SUB_FREE) continue;
			xyc_startbuf(xycsc, xy, bufq_dequeue(&xy->xy_bufq));
		}
	}
	xyc_submit_iorq(xycsc, iorq, XY_SUB_NOQ);
}

/*
 * xyc_remove_iorq: remove "done" IOPB's.
 */

int
xyc_remove_iorq(xycsc)
	struct xyc_softc *xycsc;

{
	int     errno, rq, comm, errs;
	struct xyc *xyc = xycsc->xyc;
	u_long  addr;
	struct xy_iopb *iopb;
	struct xy_iorq *iorq;
	struct buf *bp;

	if (xyc->xyc_csr & XYC_DERR) {
		/*
		 * DOUBLE ERROR: should never happen under normal use. This
		 * error is so bad, you can't even tell which IOPB is bad, so
		 * we dump them all.
		 */
		errno = XY_ERR_DERR;
		printf("%s: DOUBLE ERROR!\n", xycsc->sc_dev.dv_xname);
		if (xyc_reset(xycsc, 0, XY_RSET_ALL, errno, 0) != XY_ERR_AOK) {
			printf("%s: soft reset failed!\n",
				xycsc->sc_dev.dv_xname);
			panic("xyc_remove_iorq: controller DEAD");
		}
		return (XY_ERR_AOK);
	}

	/*
	 * get iopb that is done, loop down the chain
	 */

	if (xyc->xyc_csr & XYC_ERR) {
		xyc->xyc_csr = XYC_ERR; /* clear error condition */
	}
	if (xyc->xyc_csr & XYC_IPND) {
		xyc->xyc_csr = XYC_IPND; /* clear interrupt */
	}

	for (rq = 0; rq < XYC_MAXIOPB; rq++) {
		iorq = xycsc->xy_chain[rq];
		if (iorq == NULL) break; /* done ! */
		if (iorq->mode == 0 || XY_STATE(iorq->mode) == XY_SUB_DONE)
			continue;	/* free, or done */
		iopb = iorq->iopb;
		if (iopb->done == 0)
			continue;	/* not done yet */

		comm = iopb->com;
		errs = iopb->errs;

		if (errs)
			iorq->errno = iopb->errno;
		else
			iorq->errno = 0;

		/* handle non-fatal errors */

		if (errs &&
		    xyc_error(xycsc, iorq, iopb, comm) == XY_ERR_AOK)
			continue;	/* AOK: we resubmitted it */


		/* this iorq is now done (hasn't been restarted or anything) */

		if ((iorq->mode & XY_MODE_VERBO) && iorq->lasterror)
			xyc_perror(iorq, iopb, 0);

		/* now, if read/write check to make sure we got all the data
		 * we needed. (this may not be the case if we got an error in
		 * the middle of a multisector request).   */

		if ((iorq->mode & XY_MODE_B144) != 0 && errs == 0 &&
		    (comm == XYCMD_RD || comm == XYCMD_WR)) {
			/* we just successfully processed a bad144 sector
			 * note: if we are in bad 144 mode, the pointers have
			 * been advanced already (see above) and are pointing
			 * at the bad144 sector.   to exit bad144 mode, we
			 * must advance the pointers 1 sector and issue a new
			 * request if there are still sectors left to process
			 *
			 */
			XYC_ADVANCE(iorq, 1);	/* advance 1 sector */

			/* exit b144 mode */
			iorq->mode = iorq->mode & (~XY_MODE_B144);

			if (iorq->sectcnt) {	/* more to go! */
				iorq->lasterror = iorq->errno = iopb->errno = 0;
				iopb->errs = iopb->done = 0;
				iorq->tries = 0;
				iopb->scnt = iorq->sectcnt;
				iopb->cyl = iorq->blockno /
						iorq->xy->sectpercyl;
				iopb->head =
					(iorq->blockno / iorq->xy->nhead) %
						iorq->xy->nhead;
				iopb->sect = iorq->blockno % iorq->xy->nsect;
				addr = (u_long) iorq->dbuf - DVMA_BASE;
				iopb->dataa = (addr & 0xffff);
				iopb->datar = ((addr & 0xff0000) >> 16);
				/* will resubmit at end */
				continue;
			}
		}
		/* final cleanup, totally done with this request */

		switch (XY_STATE(iorq->mode)) {
		case XY_SUB_NORM:
			bp = iorq->buf;
			if (errs) {
				bp->b_error = EIO;
				bp->b_flags |= B_ERROR;
				bp->b_resid = iorq->sectcnt * XYFM_BPS;
			} else {
				bp->b_resid = 0;	/* done */
			}
			dvma_mapout((vaddr_t) iorq->dbufbase,
				    (vaddr_t) bp->b_data,
				    bp->b_bcount);
			disk_unbusy(&iorq->xy->sc_dk,
			    (bp->b_bcount - bp->b_resid),
			    (bp->b_flags & B_READ));
			iorq->mode = XY_SUB_FREE;
			biodone(bp);
			break;
		case XY_SUB_WAIT:
			iorq->mode = XY_NEWSTATE(iorq->mode, XY_SUB_DONE);
			wakeup(iorq);
			break;
		case XY_SUB_POLL:
			iorq->mode = XY_NEWSTATE(iorq->mode, XY_SUB_DONE);
			break;
		}
	}

	return (XY_ERR_AOK);
}

/*
 * xyc_perror: print error.
 * - if still_trying is true: we got an error, retried and got a
 *   different error.  in that case lasterror is the old error,
 *   and errno is the new one.
 * - if still_trying is not true, then if we ever had an error it
 *   is in lasterror. also, if iorq->errno == 0, then we recovered
 *   from that error (otherwise iorq->errno == iorq->lasterror).
 */
void
xyc_perror(iorq, iopb, still_trying)
	struct xy_iorq *iorq;
	struct xy_iopb *iopb;
	int     still_trying;

{

	int     error = iorq->lasterror;

	printf("%s", (iorq->xy) ? iorq->xy->sc_dev.dv_xname
	    : iorq->xyc->sc_dev.dv_xname);
	if (iorq->buf)
		printf("%c: ", 'a' + DISKPART(iorq->buf->b_dev));
	if (iopb->com == XYCMD_RD || iopb->com == XYCMD_WR)
		printf("%s %d/%d/%d: ",
			(iopb->com == XYCMD_RD) ? "read" : "write",
			iopb->cyl, iopb->head, iopb->sect);
	printf("%s", xyc_e2str(error));

	if (still_trying)
		printf(" [still trying, new error=%s]", xyc_e2str(iorq->errno));
	else
		if (iorq->errno == 0)
			printf(" [recovered in %d tries]", iorq->tries);

	printf("\n");
}

/*
 * xyc_error: non-fatal error encountered... recover.
 * return AOK if resubmitted, return FAIL if this iopb is done
 */
int
xyc_error(xycsc, iorq, iopb, comm)
	struct xyc_softc *xycsc;
	struct xy_iorq *iorq;
	struct xy_iopb *iopb;
	int     comm;

{
	int     errno = iorq->errno;
	int     erract = xyc_entoact(errno);
	int     oldmode, advance, i;
	u_long  addr;

	if (erract == XY_ERA_RSET) {	/* some errors require a reset */
		oldmode = iorq->mode;
		iorq->mode = XY_SUB_DONE | (~XY_SUB_MASK & oldmode);
		/* make xyc_start ignore us */
		xyc_reset(xycsc, 1, XY_RSET_NONE, errno, iorq->xy);
		iorq->mode = oldmode;
	}
	/* check for read/write to a sector in bad144 table if bad: redirect
	 * request to bad144 area */

	if ((comm == XYCMD_RD || comm == XYCMD_WR) &&
	    (iorq->mode & XY_MODE_B144) == 0) {
		advance = iorq->sectcnt - iopb->scnt;
		XYC_ADVANCE(iorq, advance);
		if ((i = isbad(&iorq->xy->dkb, iorq->blockno / iorq->xy->sectpercyl,
			    (iorq->blockno / iorq->xy->nsect) % iorq->xy->nhead,
			    iorq->blockno % iorq->xy->nsect)) != -1) {
			iorq->mode |= XY_MODE_B144;	/* enter bad144 mode &
							 * redirect */
			iopb->errno = iopb->done = iopb->errs = 0;
			iopb->scnt = 1;
			iopb->cyl = (iorq->xy->ncyl + iorq->xy->acyl) - 2;
			/* second to last acyl */
			i = iorq->xy->sectpercyl - 1 - i;	/* follow bad144
								 * standard */
			iopb->head = i % iorq->xy->nhead;
			iopb->sect = i / iorq->xy->nhead;

			addr = (u_long) iorq->dbuf - DVMA_BASE;
			iopb->dataa = (addr & 0xffff);
			iopb->datar = ((addr & 0xff0000) >> 16);

			/* will resubmit when we come out of remove_iorq */
			return (XY_ERR_AOK);	/* recovered! */
		}
	}

	/*
	 * it isn't a bad144 sector, must be real error! see if we can retry
	 * it?
	 */
	if ((iorq->mode & XY_MODE_VERBO) && iorq->lasterror)
		xyc_perror(iorq, iopb, 1);	/* inform of error state
						 * change */
	iorq->lasterror = errno;

	if ((erract == XY_ERA_RSET || erract == XY_ERA_HARD)
	    && iorq->tries < XYC_MAXTRIES) {	/* retry? */
		iorq->tries++;
		iorq->errno = iopb->errno = iopb->done = iopb->errs = 0;
		/* will resubmit at end of remove_iorq */
		return (XY_ERR_AOK);	/* recovered! */
	}

	/* failed to recover from this error */
	return (XY_ERR_FAIL);
}

/*
 * xyc_tick: make sure xy is still alive and ticking (err, kicking).
 */
void
xyc_tick(arg)
	void   *arg;

{
	struct xyc_softc *xycsc = arg;
	int     lcv, s, reset = 0;

	/* reduce ttl for each request if one goes to zero, reset xyc */
	s = splbio();
	for (lcv = 0; lcv < XYC_MAXIOPB; lcv++) {
		if (xycsc->reqs[lcv].mode == 0 ||
		    XY_STATE(xycsc->reqs[lcv].mode) == XY_SUB_DONE)
			continue;
		xycsc->reqs[lcv].ttl--;
		if (xycsc->reqs[lcv].ttl == 0) {
			reset = 1;
			break;	/* we're going to fail all requests anyway */
		}
	}
	if (reset) {
		printf("%s: watchdog timeout\n", xycsc->sc_dev.dv_xname);
		xyc_reset(xycsc, 0, XY_RSET_NONE, XY_ERR_FAIL, NULL);
	}
	splx(s);

	/* until next time */

	timeout_add(&xycsc->xyc_tick_tmo, XYC_TICKCNT);
}

/*
 * xyc_e2str: convert error code number into an error string
 */
const char *
xyc_e2str(no)
	int     no;
{
	switch (no) {
	case XY_ERR_FAIL:
		return ("Software fatal error");
	case XY_ERR_DERR:
		return ("DOUBLE ERROR");
	case XY_ERR_AOK:
		return ("Successful completion");
	case XY_ERR_IPEN:
		return("Interrupt pending");
	case XY_ERR_BCFL:
		return("Busy conflict");
	case XY_ERR_TIMO:
		return("Operation timeout");
	case XY_ERR_NHDR:
		return("Header not found");
	case XY_ERR_HARD:
		return("Hard ECC error");
	case XY_ERR_ICYL:
		return("Illegal cylinder address");
	case XY_ERR_ISEC:
		return("Illegal sector address");
	case XY_ERR_SMAL:
		return("Last sector too small");
	case XY_ERR_SACK:
		return("Slave ACK error (non-existent memory)");
	case XY_ERR_CHER:
		return("Cylinder and head/header error");
	case XY_ERR_SRTR:
		return("Auto-seek retry successful");
	case XY_ERR_WPRO:
		return("Write-protect error");
	case XY_ERR_UIMP:
		return("Unimplemented command");
	case XY_ERR_DNRY:
		return("Drive not ready");
	case XY_ERR_SZER:
		return("Sector count zero");
	case XY_ERR_DFLT:
		return("Drive faulted");
	case XY_ERR_ISSZ:
		return("Illegal sector size");
	case XY_ERR_SLTA:
		return("Self test A");
	case XY_ERR_SLTB:
		return("Self test B");
	case XY_ERR_SLTC:
		return("Self test C");
	case XY_ERR_SOFT:
		return("Soft ECC error");
	case XY_ERR_SFOK:
		return("Soft ECC error recovered");
	case XY_ERR_IHED:
		return("Illegal head");
	case XY_ERR_DSEQ:
		return("Disk sequencer error");
	case XY_ERR_SEEK:
		return("Seek error");
	default:
		return ("Unknown error");
	}
}

int
xyc_entoact(errno)

int errno;

{
  switch (errno) {
    case XY_ERR_FAIL:	case XY_ERR_DERR:	case XY_ERR_IPEN:
    case XY_ERR_BCFL:	case XY_ERR_ICYL:	case XY_ERR_ISEC:
    case XY_ERR_UIMP:	case XY_ERR_SZER:	case XY_ERR_ISSZ:
    case XY_ERR_SLTA:	case XY_ERR_SLTB:	case XY_ERR_SLTC:
    case XY_ERR_IHED:	case XY_ERR_SACK:	case XY_ERR_SMAL:

	return(XY_ERA_PROG); /* program error ! */

    case XY_ERR_TIMO:	case XY_ERR_NHDR:	case XY_ERR_HARD:
    case XY_ERR_DNRY:	case XY_ERR_CHER:	case XY_ERR_SEEK:
    case XY_ERR_SOFT:

	return(XY_ERA_HARD); /* hard error, retry */

    case XY_ERR_DFLT:	case XY_ERR_DSEQ:

	return(XY_ERA_RSET); /* hard error reset */

    case XY_ERR_SRTR:	case XY_ERR_SFOK:	case XY_ERR_AOK:

	return(XY_ERA_SOFT); /* an FYI error */

    case XY_ERR_WPRO:

	return(XY_ERA_WPRO); /* write protect */
  }

  return(XY_ERA_PROG); /* ??? */
}
@


1.68
log
@Revert forcing a rachitic `c' slice size when the drive geometry is not known,
now that the disklabel code will reduce MAXDISKSIZE to the real size if a Sun
label is found.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.67 2015/01/15 21:17:54 miod Exp $	*/
@


1.67
log
@Rework the disk label handling once again. Disk label is read at attach time
because it teaches us the drive geometry, but from then on there is no reason
not to implement disklabel spoof support and a proper DIOCGPDINFO ioctl.

As a result, this makes disklabel -A now work on SMD disks.

The drawback of this, is that, since native labels do not have a pcylinders
value, the code will now always assume pcylinders == ncylinders + acylinders.
(this ought to be the case by default for labels produced by SunOS format(8).)
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.66 2015/01/14 21:17:09 miod Exp $	*/
a235 2
		/* prevent initdisklabel() from putting MAXDISKSIZE */
		DL_SETDSIZE(lp, 1ULL);
@


1.66
log
@When a read or write operation fails on a sector found on the bad block table,
be sure to adjust the IOPB data pointer before redirecting the I/O for this
particular sector to the replacement location.

Otherwise, the data pointer still points to the first sector of the I/O, which
may not necessarily be the one which failed.

(This is yet another 19 years old bug, making your filesystems self-destruct
even faster than intended)
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.65 2015/01/14 21:14:49 miod Exp $	*/
d173 1
a173 1
int	xygetdisklabel(struct xy_softc *, void *);
a202 4
/*
 * start: disk label fix code (XXX)
 */

d208 2
a209 1
       
d211 7
a217 3
	if (bp->b_bcount != XYFM_BPS)
		panic("xydummystrat");
	bcopy(xy->xy_labeldata, bp->b_data, XYFM_BPS);
d222 2
a223 1
xygetdisklabel(xy, b)
d225 2
a226 1
	void *b;
a227 2
	struct disklabel *lp = xy->sc_dk.dk_label;
	struct sun_disklabel *sl = b;
d233 5
a237 3
	if (sl->sl_magic == SUN_DKMAGIC) {
		lp->d_secpercyl = sl->sl_nsectors * sl->sl_ntracks;
		DL_SETDSIZE(lp, (u_int64_t)lp->d_secpercyl * sl->sl_ncylinders);
d239 10
a248 1
		lp->d_secpercyl = 1;
d251 1
d253 11
a263 5
	/* We already have the label data in `b'; setup for dummy strategy */
	xy->xy_labeldata = b;

	error = readdisklabel(MAKEDISKDEV(0, xy->sc_dev.dv_unit, RAW_PART),
	    xydummystrat, lp, 0);
d265 1
a265 1
		return (error);
d267 15
a281 11
	/* Ok, we have the label; fill in `pcyl' if there's SunOS magic */
	sl = b;
	if (sl->sl_magic == SUN_DKMAGIC)
		xy->pcyl = sl->sl_pcylinders;
	else {
		printf("%s: WARNING: no `pcyl' in disk label.\n",
			xy->sc_dev.dv_xname);
		xy->pcyl = lp->d_ncylinders +
			lp->d_acylinders;
		printf("%s: WARNING: guessing pcyl=%d (ncyl+acyl)\n",
		xy->sc_dev.dv_xname, xy->pcyl);
d283 1
a283 7

	xy->ncyl = lp->d_ncylinders;
	xy->acyl = lp->d_acylinders;
	xy->nhead = lp->d_ntracks;
	xy->nsect = lp->d_nsectors;
	xy->sectpercyl = lp->d_secpercyl;
	return (error);
a286 4
 * end: disk label fix code (XXX)
 */

/*
d595 4
a598 1
	if (xygetdisklabel(xy, xa->buf) != 0)
d600 1
d796 4
a800 1
	case DIOCGPDINFO:	/* no separate 'physical' info available. */
d805 2
a806 2
		((struct partinfo *) addr)->disklab = xy->sc_dk.dk_label;
		((struct partinfo *) addr)->part =
d815 1
a815 1
		    (struct disklabel *) addr, /* xy->sc_dk.dk_openmask : */ 0);
@


1.65
log
@When the outcome of the watchdog processing is a reset, do not bother checking
further pending requests, since they will be forcefully failed by the reset
routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.64 2015/01/14 21:13:46 miod Exp $	*/
d1828 1
d1857 5
@


1.64
log
@Make the special buffer used for the few sector I/O at attach time a per-softc
member, rather than a global. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.63 2015/01/14 19:02:59 miod Exp $	*/
d1900 1
a1900 1
		if (xycsc->reqs[lcv].ttl == 0)
d1902 2
@


1.63
log
@Make x[dy]c_e2str return a const char *.
Remove obsolete comments in x[dy]dump().
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.62 2015/01/14 19:01:00 miod Exp $	*/
a206 2
static void *xy_labeldata;

d211 3
d216 1
a216 1
	bcopy(xy_labeldata, bp->b_data, XYFM_BPS);
d241 1
a241 1
	xy_labeldata = b;
@


1.62
log
@Remove pass-through ioctl for SMD disks (DIOSXDCMD). Nothing uses this, because
noone wrote an equivalent of SunOS format(8) and noone ever will.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.61 2015/01/13 20:40:11 miod Exp $	*/
d143 1
a143 1
char   *xyc_e2str(int);
a744 13

	/* outline: globals: "dumplo" == sector number of partition to start
	 * dump at (convert to physical sector with partition table)
	 * "dumpsize" == size of dump in clicks "physmem" == size of physical
	 * memory (clicks, ptoa() to get bytes) (normal case: dumpsize ==
	 * physmem)
	 *
	 * dump a copy of physical memory to the dump device starting at sector
	 * "dumplo" in the swap partition (make sure > 0).   map in pages as
	 * we go.   use polled I/O.
	 *
	 * XXX how to handle NON_CONTIG? */

d1916 1
a1916 1
char *
@


1.61
log
@Initialize d_type to DTYPE_SMD in the default label to avoid disklabel(8)
asking for the device type upon labeling a freshly formatted disk.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.60 2015/01/12 21:31:06 miod Exp $	*/
a81 1
#include <sparc/dev/xio.h>
a146 1
int	xyc_ioctlcmd(struct xy_softc *, dev_t dev, struct xd_iocmd *);
a772 1
	struct xd_iocmd *xio;
a825 6
	case DIOSXDCMD:
		xio = (struct xd_iocmd *) addr;
		if ((error = suser(p, 0)) != 0)
			return (error);
		return (xyc_ioctlcmd(xy, dev, xio));

a1923 81
}

/*
 * xyc_ioctlcmd: this function provides a user level interface to the
 * controller via ioctl.   this allows "format" programs to be written
 * in user code, and is also useful for some debugging.   we return
 * an error code.   called at user priority.
 *
 * XXX missing a few commands (see the 7053 driver for ideas)
 */
int
xyc_ioctlcmd(xy, dev, xio)
	struct xy_softc *xy;
	dev_t   dev;
	struct xd_iocmd *xio;

{
	int     s, err, rqno, dummy = 0;
	caddr_t dvmabuf = NULL, buf = NULL;
	struct xyc_softc *xycsc;

	/* check sanity of requested command */

	switch (xio->cmd) {

	case XYCMD_NOP:	/* no op: everything should be zero */
		if (xio->subfn || xio->dptr || xio->dlen ||
		    xio->block || xio->sectcnt)
			return (EINVAL);
		break;

	case XYCMD_RD:		/* read / write sectors (up to XD_IOCMD_MAXS) */
	case XYCMD_WR:
		if (xio->subfn || xio->sectcnt > XD_IOCMD_MAXS ||
		    xio->sectcnt * XYFM_BPS != xio->dlen || xio->dptr == NULL)
			return (EINVAL);
		break;

	case XYCMD_SK:		/* seek: doesn't seem useful to export this */
		return (EINVAL);

		break;

	default:
		return (EINVAL);/* ??? */
	}

	/* create DVMA buffer for request if needed */

	if (xio->dlen) {
		dvmabuf = dvma_malloc(xio->dlen, &buf, M_WAITOK);
		if (xio->cmd == XYCMD_WR) {
			if ((err = copyin(xio->dptr, buf, xio->dlen)) != 0) {
				dvma_free(dvmabuf, xio->dlen, &buf);
				return (err);
			}
		}
	}
	/* do it! */

	err = 0;
	xycsc = xy->parent;
	s = splbio();
	rqno = xyc_cmd(xycsc, xio->cmd, xio->subfn, xy->xy_drive, xio->block,
	    xio->sectcnt, dvmabuf, XY_SUB_WAIT);
	if (rqno == XY_ERR_FAIL) {
		err = EIO;
		goto done;
	}
	xio->errno = xycsc->ciorq->errno;
	xio->tries = xycsc->ciorq->tries;
	XYC_DONE(xycsc, dummy);

	if (xio->cmd == XYCMD_RD)
		err = copyout(buf, xio->dptr, xio->dlen);

done:
	splx(s);
	if (dvmabuf)
		dvma_free(dvmabuf, xio->dlen, &buf);
	return (err);
@


1.60
log
@Fix two 19 years old (since day one) bug in bad144 sector reassignment logic:
- when entering bad144 mode, correctly compute the actual C/H/S values for the
  logical block number.
- when leaving bad144 mode and resuming normal I/O operation, when computing
  back the C/H/S values for the next logical block number, compute the
  sector number correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.59 2014/07/11 16:35:40 jsg Exp $	*/
d239 1
@


1.59
log
@Chuck Cranor rescinded clauses in his license
on the 2nd of February 2011 in NetBSD.

http://marc.info/?l=netbsd-source-changes&m=129658899212732&w=2
http://marc.info/?l=netbsd-source-changes&m=129659095515558&w=2
http://marc.info/?l=netbsd-source-changes&m=129659157916514&w=2
http://marc.info/?l=netbsd-source-changes&m=129665962324372&w=2
http://marc.info/?l=netbsd-source-changes&m=129666033625342&w=2
http://marc.info/?l=netbsd-source-changes&m=129666052825545&w=2
http://marc.info/?l=netbsd-source-changes&m=129666922906480&w=2
http://marc.info/?l=netbsd-source-changes&m=129667725518082&w=2
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.58 2013/11/20 00:15:32 dlg Exp $	*/
d1753 1
a1753 1
				iopb->sect = iorq->blockno % XYFM_BPS;
d1757 1
a1757 1
				/* will resubit at end */
d1874 2
a1875 2
			iopb->head = i / iorq->xy->nhead;
			iopb->sect = i % iorq->xy->nhead;
@


1.58
log
@replace bare use of disksort with bufqs. this is the last disksort user
in the tree apart from the bufq wrapper around it.

go ahead miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.57 2013/11/01 17:36:19 krw Exp $	*/
a4 1
 *
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Charles D. Cranor.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.57
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.56 2013/10/20 10:11:16 krw Exp $	*/
d511 1
a511 4

		xy->xyq.b_active = 0;
		xy->xyq.b_actf = 0;
		xy->xyq.b_actb = &xy->xyq.b_actf; /* XXX b_actb: not used? */
d1003 2
a1010 2
	disksort(&xy->xyq, bp);

a1603 1
			    iorq->xy->xyq.b_actf = iorq->buf->b_actf;
d1650 1
a1650 1
			if (xy->xyq.b_actf == NULL) continue;
d1652 1
a1652 1
			xyc_startbuf(xycsc, xy, xy->xyq.b_actf);
a1781 1
			iorq->xy->xyq.b_actf = bp->b_actf;
@


1.56
log
@(daddr_t) -> (u_int64_t) when multiplying ncylinders * secpercyl to
get disk size, since DL_SETDSIZE() takes disk sector values, not
512-byte block values.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.55 2013/10/14 23:26:22 krw Exp $	*/
d1241 1
a1241 1
	    (bp->b_flags & B_READ) ? "read" : "write", bp->b_blkno);
@


1.55
log
@XXsize() returns daddr_t, so calculate the return value in a daddr_t
variable and not (usually) an int.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.54 2013/06/11 16:42:11 deraadt Exp $	*/
d241 1
a241 1
		DL_SETDSIZE(lp, (daddr_t)lp->d_secpercyl * sl->sl_ncylinders);
@


1.54
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.53 2011/07/06 04:49:35 matthew Exp $	*/
d936 2
a937 1
	int     unit, part, size, omask;
@


1.53
log
@Eliminate redundant buf validation checks in xxstrategy() methods now
that they're implemented consistently in bounds_check_with_label().

Also, per krw's request, change bounds_check_with_label() to return 0
if the checks succeed, and change the drivers to test == -1 instead of
<= 0.  (Man page update to follow; intentionally omitting
arch/vax/mba/hp.c from this commit because it doesn't even build
currently and miod@@ promises to kill it soon.)

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.52 2011/06/05 18:40:33 matthew Exp $	*/
d241 1
a241 1
		DL_SETDSIZE(lp, (daddr64_t)lp->d_secpercyl * sl->sl_ncylinders);
d737 1
a737 1
	daddr64_t blkno;
d930 1
a930 1
daddr64_t
d1225 1
a1225 1
	daddr64_t  block;
@


1.52
log
@Drop kernel support for the useless DIOCWLABEL ioctl and prune a lot
of silly flag twiddling code in various disk drivers.

ok deraadt@@, miod@@

N.B., users will need a -current disklabel(8) to be able to write new
disklabels to disk now.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.51 2011/06/03 21:14:11 matthew Exp $	*/
d977 1
a977 3
	if (unit >= xy_cd.cd_ndevs || (xy = xy_cd.cd_devs[unit]) == 0 ||
	    bp->b_blkno < 0 ||
	    (bp->b_bcount % xy->sc_dk.dk_label->d_secsize) != 0) {
a999 1
	/* short circuit zero length request */
d1001 2
a1002 9
	if (bp->b_bcount == 0)
		goto done;

	/* check bounds with label (disksubr.c).  Determine the size of the
	 * transfer, and make sure it is within the boundaries of the
	 * partition. Adjust transfer if needed, and signal errors or early
	 * completion. */

	if (bounds_check_with_label(bp, xy->sc_dk.dk_label) <= 0)
d1022 1
a1022 1
bad:				/* tells upper layers we have an error */
d1024 2
a1025 1
done:				/* tells upper layers we are done with this
a1026 1
	bp->b_resid = bp->b_bcount;
@


1.51
log
@Get rid of the wlabel argument to bounds_check_with_label().  It's
never done anything in OpenBSD and just clutters disk drivers with
silly flag handling.

More cleanup to follow.

ok deraadt@@, millert@@; no objections krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.50 2010/09/22 06:40:25 krw Exp $	*/
a810 9
		return 0;

	case DIOCWLABEL:	/* change write status of disk label */
		if ((flag & FWRITE) == 0)
			return EBADF;
		if (*(int *) addr)
			xy->flags |= XY_WLABEL;
		else
			xy->flags &= ~XY_WLABEL;
@


1.50
log
@Add DIOCGPDINFO to drivers that were lacking it. Where there
is no easily available physical information outside of the stored
disklabel just make it a synonym for DIOCGDINFO.

Commit on the theory it is unlikely to harm, and fallout can be
addressed in the mass re-compile that will follow j2k10.

Should allow auto-allocation of disks to work with all devices.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.49 2010/09/22 01:18:57 matthew Exp $	*/
d1021 1
a1021 2
	if (bounds_check_with_label(bp, xy->sc_dk.dk_label,
	    (xy->flags & XY_WLABEL) != 0) <= 0)
@


1.49
log
@All users of physio(9) now pass NULL as the buf pointer argument, so
no point in keeping it around.

"i like this" thib@@ (a while back); ok krw@@ and oga@@; reminder to
update the man page and tweaks jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.48 2010/09/08 14:47:10 jsing Exp $	*/
d803 1
@


1.48
log
@Store a struct device pointer within struct disk and populate this when
disk_attach() is called by the device driver. We will be building on
this shortly.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.46 2010/08/28 20:23:22 matthew Exp $	*/
d920 1
a920 1
	return (physio(xystrategy, NULL, dev, B_READ, minphys, uio));
d930 1
a930 1
	return (physio(xystrategy, NULL, dev, B_WRITE, minphys, uio));
@


1.47
log
@- spello, short-hand -> shorthand

ok miod@@
@
text
@d589 1
a589 1
	disk_attach(&xy->sc_dk);
@


1.46
log
@Garbage collect struct dkdriver.

ok miod@@; "please go ahead" jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.45 2010/05/23 10:49:19 dlg Exp $	*/
d393 2
a394 2
	xyc->ciorq = &xyc->reqs[XYC_CTLIOPB];    /* short hand name */
	xyc->ciopb = &xyc->iopbase[XYC_CTLIOPB]; /* short hand name */
@


1.45
log
@add dkio.h to the last of the disk ioctl users i can find.

requested by deraadt@@ who was rightly disparaging of my grep skillz.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.44 2009/09/05 15:37:04 deraadt Exp $	*/
a211 6
 * dkdriver
 */

struct dkdriver xydkdriver = { xystrategy };

/*
a500 1
	xy->sc_dk.dk_driver = &xydkdriver;
@


1.44
log
@fix typos
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.43 2009/09/05 00:48:39 krw Exp $	*/
d78 1
@


1.43
log
@Make DIOCSDINFO code consistant everywhere.

ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.42 2009/08/13 15:23:12 deraadt Exp $	*/
d837 1
a837 1
			if (cmd == DIOCWDINFO) {
@


1.42
log
@Replace the error strings that were being passed around with much simpler
errnos.  Note that the error strings are being ignored, since we long ago
decided to not spam the console, and there is no other nice way to use the
errors (without changing the ioctls to pass it back)
The errno is now useful, since we can pass b_error from failing IO up, and
the drive can decide how to use that
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.41 2009/01/04 16:51:05 miod Exp $	*/
a817 11
	case DIOCSDINFO:	/* set disk label */
		if ((flag & FWRITE) == 0)
			return EBADF;
		error = setdisklabel(xy->sc_dk.dk_label,
		    (struct disklabel *) addr, /* xy->sc_dk.dk_openmask : */ 0);
		if (error == 0) {
			if (xy->state == XY_DRIVE_NOLABEL)
				xy->state = XY_DRIVE_ONLINE;
		}
		return error;

d828 1
d837 11
a847 6
			/* Simulate opening partition 0 so write succeeds. */
			xy->sc_dk.dk_openmask |= (1 << 0);
			error = writedisklabel(DISKLABELDEV(dev), xystrategy,
			    xy->sc_dk.dk_label);
			xy->sc_dk.dk_openmask =
			    xy->sc_dk.dk_copenmask | xy->sc_dk.dk_bopenmask;
@


1.41
log
@In x[dy]dummystrat, do not clear B_BUSY from the buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.40 2007/11/28 16:33:20 martin Exp $	*/
d239 1
a239 1
	char *err;
d254 1
a254 1
	err = readdisklabel(MAKEDISKDEV(0, xy->sc_dev.dv_unit, RAW_PART),
d256 2
a257 4
	if (err) {
		/*printf("%s: %s\n", xy->sc_dev.dv_xname, err);*/
		return (XY_ERR_FAIL);
	}
d277 1
a277 1
	return (XY_ERR_AOK);
d597 1
a597 1
	if (xygetdisklabel(xy, xa->buf) != XY_ERR_AOK)
@


1.40
log
@ctob/btoc -> ptoa/atop

from Rodolfo Gouveia
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.39 2007/10/01 16:11:19 krw Exp $	*/
a229 1
	bp->b_flags &= ~B_BUSY;
@


1.39
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...' where
obvious.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.38 2007/07/01 19:06:57 miod Exp $	*/
d768 1
a768 1
	 * memory (clicks, ctob() to get bytes) (normal case: dumpsize ==
@


1.38
log
@Perform minimal disklabel setup without needing to do the disklabel_to_sun()
dance, so that we do not depend on its behaviour. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.37 2007/06/24 16:52:04 miod Exp $	*/
d381 2
a382 2
	xyc->reqs = (struct xy_iorq *)
	    malloc(XYC_MAXIOPB * sizeof(struct xy_iorq), M_DEVBUF, M_NOWAIT);
a384 1
	bzero(xyc->reqs, XYC_MAXIOPB * sizeof(struct xy_iorq));
@


1.37
log
@Fix xd and xy disklabel handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.36 2007/06/20 18:16:24 deraadt Exp $	*/
d239 1
a239 1
	struct sun_disklabel *sdl = b;
a240 2
	extern char *disklabel_sun_to_bsd(struct sun_disklabel *,
	    struct disklabel *);
d243 6
a248 5
	if (sdl->sl_magic == SUN_DKMAGIC)
		disklabel_sun_to_bsd(sdl, lp);
	else {
		/* Required parameters for readdisklabel() */
		lp->d_secsize = XYFM_BPS;
d263 3
a265 3
	sdl = b;
	if (sdl->sl_magic == SUN_DKMAGIC)
		xy->pcyl = sdl->sl_pcylinders;
d279 1
a279 2
	xy->sectpercyl = lp->d_secpercyl = xy->nhead * xy->nsect;
	lp->d_secsize = XYFM_BPS; /* not handled by sun->bsd */
@


1.36
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it.. except
these two drivers.  knock out that code for now to let it compile while
miod gets his fix ready for these drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.35 2007/06/07 14:38:39 deraadt Exp $	*/
d238 2
d241 11
a255 4
	/* Required parameters for readdisklabel() */
	xy->sc_dk.dk_label->d_secsize = XYFM_BPS;
	xy->sc_dk.dk_label->d_secpercyl = 1;

d257 1
a257 1
	    xydummystrat, xy->sc_dk.dk_label, 0);
d260 1
a260 1
		return(XY_ERR_FAIL);
a262 3
#ifdef FIXME
	struct sun_disklabel *sdl;

d264 1
a264 1
	sdl = (struct sun_disklabel *)xy->sc_dk.dk_cpulabel->cd_block;
d270 2
a271 2
		xy->pcyl = xy->sc_dk.dk_label->d_ncylinders +
			xy->sc_dk.dk_label->d_acylinders;
a274 1
#endif
d276 7
a282 9
	xy->ncyl = xy->sc_dk.dk_label->d_ncylinders;
	xy->acyl = xy->sc_dk.dk_label->d_acylinders;
	xy->nhead = xy->sc_dk.dk_label->d_ntracks;
	xy->nsect = xy->sc_dk.dk_label->d_nsectors;
	xy->sectpercyl = xy->sc_dk.dk_label->d_secpercyl =
	    xy->nhead * xy->nsect;
	xy->sc_dk.dk_label->d_secsize = XYFM_BPS; /* not handled by
                                          	  * sun->bsd */
	return(XY_ERR_AOK);
d577 1
a577 1
	for (lcv = 0; lcv < 126; lcv++)	/* init empty bad144 table */
d672 1
a672 1
	for (lcv = 0; lcv < 126; lcv++) {
d684 1
a684 1
	if (lcv != 126) {
@


1.35
log
@another XXsize() botch
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.34 2007/06/07 03:42:51 deraadt Exp $	*/
a238 1
	struct sun_disklabel *sdl;
d248 1
a248 2
					xydummystrat,
				xy->sc_dk.dk_label, xy->sc_dk.dk_cpulabel, 0);
d254 3
d269 1
d825 1
a825 2
		    (struct disklabel *) addr, /* xy->sc_dk.dk_openmask : */ 0,
		    xy->sc_dk.dk_cpulabel);
d845 1
a845 2
		    (struct disklabel *) addr, /* xy->sc_dk.dk_openmask : */ 0,
		    xy->sc_dk.dk_cpulabel);
d853 1
a853 1
			    xy->sc_dk.dk_label, xy->sc_dk.dk_cpulabel);
d1035 1
a1035 1
	    xy->sc_dk.dk_cpulabel, (xy->flags & XY_WLABEL) != 0) <= 0)
@


1.34
log
@more XXsize() fallout
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.33 2007/06/06 17:15:12 deraadt Exp $	*/
d952 1
a952 1
daddr_t
@


1.33
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.32 2007/06/05 00:38:18 deraadt Exp $	*/
d952 1
a952 1
int
@


1.32
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.31 2007/04/29 18:59:37 krw Exp $	*/
d744 1
a744 1
	daddr_t blkno;
d1258 1
a1258 1
	u_long  block;
d1271 3
a1273 2
	printf("xyc_startbuf: %s%c: %s block %d\n", xysc->sc_dev.dv_xname,
	    'a' + partno, (bp->b_flags & B_READ) ? "read" : "write", bp->b_blkno);
@


1.31
log
@Replace expansions of DISKLABELDEV() with DISKLABELDEV(). Shorter, and
more consistant. No change to code.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.30 2007/02/15 00:53:26 krw Exp $	*/
d975 1
a975 1
		size = xysc->sc_dk.dk_label->d_partitions[part].p_size *
d1286 1
a1286 1
	    xysc->sc_dk.dk_label->d_partitions[partno].p_offset);
@


1.30
log
@Don't print the error strings returned by readdisklabel().  If you
need the debug info uncomment the printf's you need. Crude but
effective way to suppress 'no disklabel' errors that pop up at the
most innconvenient times to frighten users. More elegant method,
DPRINTF-like constructs or something, later.

"Yay!" marco@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.29 2006/12/03 16:40:43 miod Exp $	*/
d852 2
a853 3
			error = writedisklabel(MAKEDISKDEV(major(dev), DISKUNIT(dev), RAW_PART),
			    xystrategy, xy->sc_dk.dk_label,
			    xy->sc_dk.dk_cpulabel);
@


1.29
log
@Initialize more fields of the proto disklabel before invoking readdisklabel(),
to pass its recent sanity checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.28 2006/03/15 20:20:41 miod Exp $	*/
d252 1
a252 1
		printf("%s: %s\n", xy->sc_dev.dv_xname, err);
@


1.28
log
@Nuke dk_establish(), no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.27 2006/01/20 23:27:25 miod Exp $	*/
d244 1
a244 1
	/* Required parameter for readdisklabel() */
d246 1
d273 2
a274 1
	xy->sectpercyl = xy->nhead * xy->nsect;
@


1.27
log
@b_un.b_addr -> b_data; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.26 2006/01/20 00:20:38 miod Exp $	*/
a690 2

	dk_establish(&xy->sc_dk, &xy->sc_dev);		/* XXX */
@


1.26
log
@Use <dev/sun/disklabel.h> instead of similar <machine/sun_disklabel.h> on
sparc and remove unused sun_dkioctl(). No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.25 2004/09/29 07:35:11 miod Exp $	*/
d228 1
a228 1
	bcopy(xy_labeldata, bp->b_un.b_addr, XYFM_BPS);
d1637 1
a1637 1
					(vaddr_t)iorq->buf->b_un.b_addr,
d1816 1
a1816 1
				    (vaddr_t) bp->b_un.b_addr,
@


1.25
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.24 2004/02/15 02:45:46 tedu Exp $	*/
d82 1
a82 1
#include <machine/sun_disklabel.h>
@


1.24
log
@new arg to disk_unbusy, to record separate read/write statistics.
looked at by various, testing henning@@ mcbride@@ dan weeks
mostly from netbsd via Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.23 2003/09/29 09:08:19 miod Exp $	*/
d434 2
a435 3
			  ca->ca_ra.ra_intr[0].int_pri, &xyc->sc_ih, IPL_BIO);
	evcnt_attach(&xyc->sc_dev, "intr", &xyc->sc_intrcnt);

a1079 4

	/* kick the event counter */

	xycsc->sc_intrcnt.ev_count++;
@


1.23
log
@avaliable -> available
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.22 2003/08/15 20:32:14 tedu Exp $	*/
d1647 2
a1648 1
				xycsc->reqs[lcv].buf->b_resid));
d1825 2
a1826 1
			    (bp->b_bcount - bp->b_resid));
@


1.22
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.21 2002/06/08 18:52:45 art Exp $	*/
d1346 1
a1346 1
 * on the iorq free list until some iopbs are avaliable.
@


1.21
log
@Use tsleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.20 2002/05/29 08:28:36 art Exp $	*/
d863 1
a863 1
		if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.20
log
@splbio around biodone.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.19 2002/04/30 01:12:29 art Exp $	*/
d1377 1
a1377 1
				sleep(iorq, PRIBIO);
d1409 1
a1409 1
			sleep(iorq, PRIBIO);
@


1.19
log
@Fix an ancient problem in how sparc interrupts are handled.

There are many interrupt handlers that assume that they don't need to do
any spl protection in their code because the interrupt of some level can't
be interrupted by an interrupt of the same level. The problem is that some
interrupt handlers have hardware levels that are lower then their "software"
levels.

Fix this by adding an additional field to struct intrhand that specifies which
"software" level an interrupt handler has and blocks that level while handling
the interrupt. This new field is initialized in intr_establish which gets
an additional argument (which can be -1 meaning that the interrupt handler
doesn't need to block any additional level).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.18 2002/03/14 01:26:43 millert Exp $	*/
d1062 1
d1064 1
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.17 2001/11/06 19:53:16 miod Exp $	*/
d434 1
a434 1
			  ca->ca_ra.ra_intr[0].int_pri, &xyc->sc_ih);
@


1.17
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.16 2001/09/11 20:05:24 miod Exp $	*/
d147 13
a159 13
struct xy_iopb *xyc_chain __P((struct xyc_softc *, struct xy_iorq *));
int	xyc_cmd __P((struct xyc_softc *, int, int, int, int, int, char *, int));
char   *xyc_e2str __P((int));
int	xyc_entoact __P((int));
int	xyc_error __P((struct xyc_softc *, struct xy_iorq *,
		   struct xy_iopb *, int));
int	xyc_ioctlcmd __P((struct xy_softc *, dev_t dev, struct xd_iocmd *));
void	xyc_perror __P((struct xy_iorq *, struct xy_iopb *, int));
int	xyc_piodriver __P((struct xyc_softc *, struct xy_iorq *));
int	xyc_remove_iorq __P((struct xyc_softc *));
int	xyc_reset __P((struct xyc_softc *, int, struct xy_iorq *, int,
			struct xy_softc *));
inline void xyc_rqinit __P((struct xy_iorq *, struct xyc_softc *,
d161 8
a168 8
			    caddr_t, struct buf *));
void	xyc_rqtopb __P((struct xy_iorq *, struct xy_iopb *, int, int));
void	xyc_start __P((struct xyc_softc *, struct xy_iorq *));
int	xyc_startbuf __P((struct xyc_softc *, struct xy_softc *, struct buf *));
int	xyc_submit_iorq __P((struct xyc_softc *, struct xy_iorq *, int));
void	xyc_tick __P((void *));
int	xyc_unbusy __P((struct xyc *, int));
void	xyc_xyreset __P((struct xyc_softc *, struct xy_softc *));
d171 1
a171 1
int	xycintr __P((void *));
d174 4
a177 4
int	xycmatch __P((struct device *, void *, void *));
void	xycattach __P((struct device *, struct device *, void *));
int	xymatch __P((struct device *, void *, void *));
void	xyattach __P((struct device *, struct device *, void *));
d179 2
a180 2
static	void xydummystrat __P((struct buf *));
int	xygetdisklabel __P((struct xy_softc *, void *));
@


1.17.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.17 2001/11/06 19:53:16 miod Exp $	*/
d147 13
a159 13
struct xy_iopb *xyc_chain(struct xyc_softc *, struct xy_iorq *);
int	xyc_cmd(struct xyc_softc *, int, int, int, int, int, char *, int);
char   *xyc_e2str(int);
int	xyc_entoact(int);
int	xyc_error(struct xyc_softc *, struct xy_iorq *,
		   struct xy_iopb *, int);
int	xyc_ioctlcmd(struct xy_softc *, dev_t dev, struct xd_iocmd *);
void	xyc_perror(struct xy_iorq *, struct xy_iopb *, int);
int	xyc_piodriver(struct xyc_softc *, struct xy_iorq *);
int	xyc_remove_iorq(struct xyc_softc *);
int	xyc_reset(struct xyc_softc *, int, struct xy_iorq *, int,
			struct xy_softc *);
inline void xyc_rqinit(struct xy_iorq *, struct xyc_softc *,
d161 8
a168 8
			    caddr_t, struct buf *);
void	xyc_rqtopb(struct xy_iorq *, struct xy_iopb *, int, int);
void	xyc_start(struct xyc_softc *, struct xy_iorq *);
int	xyc_startbuf(struct xyc_softc *, struct xy_softc *, struct buf *);
int	xyc_submit_iorq(struct xyc_softc *, struct xy_iorq *, int);
void	xyc_tick(void *);
int	xyc_unbusy(struct xyc *, int);
void	xyc_xyreset(struct xyc_softc *, struct xy_softc *);
d171 1
a171 1
int	xycintr(void *);
d174 4
a177 4
int	xycmatch(struct device *, void *, void *);
void	xycattach(struct device *, struct device *, void *);
int	xymatch(struct device *, void *, void *);
void	xyattach(struct device *, struct device *, void *);
d179 2
a180 2
static	void xydummystrat(struct buf *);
int	xygetdisklabel(struct xy_softc *, void *);
d434 1
a434 1
			  ca->ca_ra.ra_intr[0].int_pri, &xyc->sc_ih, IPL_BIO);
a1061 1
	s = splbio();
a1062 1
	splx(s);
d1375 1
a1375 1
				tsleep(iorq, PRIBIO, "xyiorq", 0);
d1407 1
a1407 1
			tsleep(iorq, PRIBIO, "xyiorq", 0);
@


1.16
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.15 2001/03/24 10:07:21 ho Exp $	*/
d79 1
a79 1
#include <vm/vm.h>
@


1.15
log
@Convert to new timeout API. art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.14 2000/11/10 15:33:07 provos Exp $	*/
a79 1
#include <vm/vm_kern.h>
@


1.14
log
@seperate -> separate, okay aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.13 1999/07/09 21:34:46 art Exp $	*/
d77 1
d456 2
a457 1
	timeout(xyc_tick, xyc, XYC_TICKCNT);
d1976 1
a1976 1
	timeout(xyc_tick, xycsc, XYC_TICKCNT);
@


1.13
log
@vm_offset_t -> {v,p}addr_t and vm_size_t -> {v,p}size_t
remove "register" keywords
Various cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.12 1999/01/11 05:11:57 millert Exp $	*/
d1199 1
a1199 1
 * note that NORM requests are handled seperately.
@


1.13.4.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.15 2001/03/24 10:07:21 ho Exp $	*/
a76 1
#include <sys/timeout.h>
d455 1
a455 2
	timeout_set(&xyc->xyc_tick_tmo, xyc_tick, xyc);
	timeout_add(&xyc->xyc_tick_tmo, XYC_TICKCNT);
d1199 1
a1199 1
 * note that NORM requests are handled separately.
d1974 1
a1974 1
	timeout_add(&xycsc->xyc_tick_tmo, XYC_TICKCNT);
@


1.13.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.13.4.1 2001/05/14 21:37:10 niklas Exp $	*/
d80 1
@


1.13.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d79 1
a79 1
#include <uvm/uvm_extern.h>
@


1.13.4.4
log
@Merge in -current from about a week ago
@
text
@d147 13
a159 13
struct xy_iopb *xyc_chain(struct xyc_softc *, struct xy_iorq *);
int	xyc_cmd(struct xyc_softc *, int, int, int, int, int, char *, int);
char   *xyc_e2str(int);
int	xyc_entoact(int);
int	xyc_error(struct xyc_softc *, struct xy_iorq *,
		   struct xy_iopb *, int);
int	xyc_ioctlcmd(struct xy_softc *, dev_t dev, struct xd_iocmd *);
void	xyc_perror(struct xy_iorq *, struct xy_iopb *, int);
int	xyc_piodriver(struct xyc_softc *, struct xy_iorq *);
int	xyc_remove_iorq(struct xyc_softc *);
int	xyc_reset(struct xyc_softc *, int, struct xy_iorq *, int,
			struct xy_softc *);
inline void xyc_rqinit(struct xy_iorq *, struct xyc_softc *,
d161 8
a168 8
			    caddr_t, struct buf *);
void	xyc_rqtopb(struct xy_iorq *, struct xy_iopb *, int, int);
void	xyc_start(struct xyc_softc *, struct xy_iorq *);
int	xyc_startbuf(struct xyc_softc *, struct xy_softc *, struct buf *);
int	xyc_submit_iorq(struct xyc_softc *, struct xy_iorq *, int);
void	xyc_tick(void *);
int	xyc_unbusy(struct xyc *, int);
void	xyc_xyreset(struct xyc_softc *, struct xy_softc *);
d171 1
a171 1
int	xycintr(void *);
d174 4
a177 4
int	xycmatch(struct device *, void *, void *);
void	xycattach(struct device *, struct device *, void *);
int	xymatch(struct device *, void *, void *);
void	xyattach(struct device *, struct device *, void *);
d179 2
a180 2
static	void xydummystrat(struct buf *);
int	xygetdisklabel(struct xy_softc *, void *);
@


1.13.4.5
log
@Sync the SMP branch with 3.3
@
text
@d434 1
a434 1
			  ca->ca_ra.ra_intr[0].int_pri, &xyc->sc_ih, IPL_BIO);
a1061 1
	s = splbio();
a1062 1
	splx(s);
d1375 1
a1375 1
				tsleep(iorq, PRIBIO, "xyiorq", 0);
d1407 1
a1407 1
			tsleep(iorq, PRIBIO, "xyiorq", 0);
@


1.13.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d863 1
a863 1
		if ((error = suser(p, 0)) != 0)
d1346 1
a1346 1
 * on the iorq free list until some iopbs are available.
@


1.13.4.7
log
@Merge with the trunk
@
text
@d1647 1
a1647 2
				xycsc->reqs[lcv].buf->b_resid),
				(xycsc->reqs[lcv].buf->b_flags & B_READ));
d1824 1
a1824 2
			    (bp->b_bcount - bp->b_resid),
			    (bp->b_flags & B_READ));
@


1.12
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.11 1998/10/03 21:18:58 millert Exp $	*/
d1620 1
a1620 1
		register struct xy_iorq *iorq = &xycsc->reqs[lcv];
d1638 2
a1639 2
			    dvma_mapout((vm_offset_t)iorq->dbufbase,
					(vm_offset_t)iorq->buf->b_un.b_addr,
d1816 2
a1817 2
			dvma_mapout((vm_offset_t) iorq->dbufbase,
				    (vm_offset_t) bp->b_un.b_addr,
@


1.11
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.10 1997/08/08 21:46:51 niklas Exp $	*/
d1393 1
a1393 1
		panic("xyc_submit_iorq: xyc_chain failed!\n");
@


1.10
log
@Change the bounds_check_with_label API to also take a cpu_disklabel
reference for making transferral of meta-information possible from
readdisklabel to bounds_check_with_label.  The first (and maybe only)
thing that will use this is the multi-disklabel-format code on the
alpha where the labelsector is passed via cpu_disklabel so the label
write-protection can work correctly no matter what label was found.

Also use a new macro DKBAD to get at the dkbad field of the cpu_disklabel
implementations that contain it.  This too is for multi-disklabel
architectures where the "bad" field can be inside a union.  Use this
macro as a means for a driver to check if an architecture supports
dkbad constructs.

Remove proto of bounds_check_with_label from all MD disklabel.h as it
is in sys/disklabel.h.

I have not been able to test the changes everywhere, if I break anything
I apologize, and promise to fix it as soon as I become aware of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: xy.c,v 1.9 1997/08/08 08:25:39 downsj Exp $	*/
d249 1
a249 1
				xy->sc_dk.dk_label, xy->sc_dk.dk_cpulabel);
@


1.9
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1036 1
a1036 1
		(xy->flags & XY_WLABEL) != 0) <= 0)
@


1.8
log
@netbsd port, now we merge our changes back in
@
text
@d1 2
a2 1
/*	$NetBSD: xy.c,v 1.17 1996/04/22 02:42:04 christos Exp $	*/
d40 1
a40 1
 * id: $NetBSD: xy.c,v 1.17 1996/04/22 02:42:04 christos Exp $
d291 1
a291 1
int xycmatch(parent, match, aux)
d293 1
a293 1
	void   *match, *aux;
d295 1
a295 1
	struct cfdata *cf = match;
d303 7
a309 1
	if (CPU_ISSUN4) {
d315 1
a316 1
	return (1);
d339 1
a339 2
	ca->ca_ra.ra_vaddr = mapiodev(ca->ca_ra.ra_reg, 0,
	    sizeof(struct xyc), ca->ca_bustype);
d467 1
a467 1
xymatch(parent, match, aux)
d469 1
a469 2
	void   *match, *aux;

d471 1
a471 1
	struct cfdata *cf = match;
d959 6
a964 1
	int     part, size;
d966 2
a967 1
	/* valid unit?  try an open */
d969 1
a969 1
	if (xyopen(dev, 0, S_IFBLK, NULL) != 0)
a972 3

	xysc = xy_cd.cd_devs[DISKUNIT(dev)];
	part = DISKPART(dev);
d976 5
a980 4
		size = xysc->sc_dk.dk_label->d_partitions[part].p_size;
	if (xyclose(dev, 0, S_IFBLK, NULL) != 0)
		return -1;
	return size;
@


1.7
log
@Fix two bugs reported by Don Koch <aardvark@@poirot.krl.com>(NetBSD PR#216{8,9})
 [1] check return value from malloc() for NULL before trying to bzero it.
 [2] use "=" rather than "|=" when writing to CSR (otherwise you may
        ACK something you don't mean to!).
@
text
@d1 1
a1 1
/* $NetBSD: xy.c,v 1.3 1996/01/07 22:03:05 thorpej Exp $ */
d39 1
a39 1
 * id: $Id: xy.c,v 1.6 1996/02/21 03:43:18 chuck Exp $
d47 1
a47 1
 *	       [4] Addendum to Xylogics Model 450 Disk Controller User's 
a63 1
#include <sys/conf.h>
d75 2
d82 1
d156 1
a156 1
int	xyc_reset __P((struct xyc_softc *, int, struct xy_iorq *, int, 
d162 1
a162 1
int	xyc_start __P((struct xyc_softc *, struct xy_iorq *));
d167 1
a167 1
int	xyc_xyreset __P((struct xyc_softc *, struct xy_softc *));
a171 10
/* {b,c}devsw */
int	xyclose __P((dev_t, int, int));
int	xydump __P((dev_t));
int	xyioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int	xyopen __P((dev_t, int, int));
int	xyread __P((dev_t, struct uio *));
int	xywrite __P((dev_t, struct uio *));
int	xysize __P((dev_t));
void	xystrategy __P((struct buf *));

d185 6
a190 2
struct cfdriver xyccd = {
	NULL, "xyc", xycmatch, xycattach, DV_DULL, sizeof(struct xyc_softc)
d193 6
a198 2
struct cfdriver xycd = {
	NULL, "xy", xymatch, xyattach, DV_DISK, sizeof(struct xy_softc)
d259 2
a260 2
		printf("%s: WARNING: no `pcyl' in disk label.\n", 
							xy->sc_dev.dv_xname);
d263 1
a263 1
		printf("%s: WARNING: guessing pcyl=%d (ncyl+acyl)\n", 
a297 1
	int     del = 0;
d302 1
a302 1
	if (cputyp == CPU_SUN4) {
d304 1
a304 1
		if (probeget(&xyc->xyc_rsetup, 1) == -1)
d315 1
a315 1
void 
d345 1
a345 1
	/* 
d347 2
a348 2
	 * check boundaries of the KVA's ... all IOPBs must reside in 
 	 * the same 64K region. 
d361 1
a361 1
			printf("%s: can't alloc IOPB mem in 64K\n", 
d376 1
a376 1
	/* 
d378 1
a378 1
	 * iopb which never change. 
d416 2
a417 2
		printf("%s: 24 bit addressing turned off\n", 
						xyc->sc_dev.dv_xname);
d460 1
a460 1
int 
a465 1
	struct xyc_softc *xyc = (void *) parent;
d482 1
a482 1
void 
d491 1
a491 1
	int     res, err, spt, mb, blk, lcv, fmode, s, newstate;
d566 1
a566 1
		xy->dkb.bt_bad[lcv].bt_cyl = 
d570 1
a570 1
	for (xy->drive_type = 0 ; xy->drive_type <= XYC_MAXDT ; 
d572 1
a572 1
		err = xyc_cmd(xyc, XYCMD_RD, 0, xy->xy_drive, 0, 1, 
d606 3
a608 3
	 * disk (you get header not found errors).  if you have two drives 
	 * of different sizes that have the same drive type in their 
	 * formatting then you are out of luck.    
d625 1
a625 1
		
d646 1
a646 1
	blk = (xy->ncyl + xy->acyl - 1) * (xy->nhead * xy->nsect) + 
d649 1
a649 1
	err = xyc_cmd(xyc, XYCMD_RD, 0, xy->xy_drive, blk, 1, 
d682 3
a684 3
		if (bp && strcmp("xy", bp->name) == 0 && 
						xy->xy_drive == bp->val[0])
			bootdv = &xy->sc_dev;
d708 2
a709 2
int 
xyclose(dev, flag, fmt)
d712 1
d715 1
a715 1
	struct xy_softc *xy = xycd.cd_devs[DISKUNIT(dev)];
d736 6
a741 4
int 
xydump(dev)
	dev_t   dev;

d747 1
a747 1
	if (unit >= xycd.cd_ndevs)
d751 1
a751 1
	xy = xycd.cd_devs[unit];
d763 1
a763 1
	 * 
d767 1
a767 1
	 * 
d775 1
a775 1
int 
d790 1
a790 1
	if (unit >= xycd.cd_ndevs || (xy = xycd.cd_devs[unit]) == NULL)
d870 2
a871 2
int 
xyopen(dev, flag, fmt)
d874 1
a874 1

d883 1
a883 1
	if (unit >= xycd.cd_ndevs || (xy = xycd.cd_devs[unit]) == NULL)
d894 1
a894 1
		xyattach((struct device *) xy->parent, 
d924 1
a924 1
xyread(dev, uio)
d927 1
d934 1
a934 1
xywrite(dev, uio)
d937 1
d948 1
a948 1
int 
d954 1
a954 1
	int     unit, part, size;
d958 1
a958 1
	if (xyopen(dev, 0, S_IFBLK) != 0)
d963 1
a963 1
	xysc = xycd.cd_devs[DISKUNIT(dev)];
d969 1
a969 1
	if (xyclose(dev, 0, S_IFBLK) != 0)
d978 1
a978 1
void 
a983 2
	struct xyc_softc *parent;
	struct buf *wq;
d991 1
a991 1
	if (unit >= xycd.cd_ndevs || (xy = xycd.cd_devs[unit]) == 0 ||
d1063 1
a1063 1
int 
a1068 2
	struct xy_softc *xy;
	struct buf *bp;
d1096 1
a1096 1
inline void 
d1122 1
a1122 1
void 
d1192 1
a1192 1
int 
d1200 1
a1200 2
	int     submode = XY_STATE(fullmode), retry;
	u_long  dp;
d1209 1
a1209 1
		if (tsleep(iorq, PRIBIO, "xyc_cmd", 0)) 
d1242 1
a1242 1
int 
d1252 1
a1252 1
	u_long  block, dp;
d1260 1
a1260 1
	if (bp == NULL) 
d1274 1
a1274 1
	 * 
d1284 1
a1284 1
		printf("%s: warning: out of DVMA space\n", 
d1328 3
a1330 3
 * controller gets one (for POLL and WAIT commands).  what happens if 
 * the iopb is busy?  for i/o type [1], the buffers are queued at the 
 * "buff" layer and * picked up later by the interrupt routine.  for case 
d1338 1
a1338 1
int 
d1349 1
a1349 1
	printf("xyc_submit_iorq(%s, addr=0x%x, type=%d)\n", 
d1382 1
a1382 1
		if (type == XY_SUB_NORM || type == XY_SUB_NOQ) 
d1387 1
a1387 1
	
d1435 1
a1435 1
  /* 
d1439 1
a1439 1
  if (iorq) { 
d1480 1
a1480 1
 * the caller is interesting in.   
d1482 1
a1482 1
int 
a1490 1
	struct xyc *xyc = xycsc->xyc;
d1534 1
a1534 1
	xyc_start(xycsc, NULL); 
d1543 1
a1543 1
int 
d1558 1
a1558 1
	
d1585 1
a1585 1
int 
d1593 1
a1593 1
	int     del = 0, lcv, poll = -1, retval = XY_ERR_AOK;
d1619 1
a1619 1
		if (blastmode == XY_RSET_ALL || 
d1666 1
a1666 1
int 
d1687 1
a1687 1
 * xyc_remove_iorq: remove "done" IOPB's.   
d1690 1
a1690 1
int 
d1770 1
a1770 1
			 * 
d1838 1
a1838 1
void 
d1871 1
a1871 1
int 
d1939 1
a1939 1
void 
d1976 1
a1976 1
int 
d1983 1
a1983 1
	int     s, err, rqno, dummy;
d2018 1
a2018 1
			if (err = copyin(xio->dptr, buf, xio->dlen)) {
d2147 1
a2147 1
    case XY_ERR_WPRO: 
@


1.6
log
@minor clean up: revise locations of disk_busy/disk_unbusy calls to match xd.c
@
text
@d39 1
a39 1
 * id: $Id: xy.c,v 1.5 1996/01/13 03:45:03 chuck Exp $
d102 1
a102 1
	(XYC)->xyc_csr |= XYC_GBSY; /* go! */ \
a372 1
	bzero(xyc->reqs, XYC_MAXIOPB * sizeof(struct xy_iorq));
d375 1
d1578 1
a1578 1
		xycsc->xyc->xyc_csr |= XYC_IPND;	/* clear IPND */
d1726 1
a1726 1
		xyc->xyc_csr |= XYC_ERR; /* clear error condition */
d1729 1
a1729 1
		xyc->xyc_csr |= XYC_IPND; /* clear interrupt */
@


1.5
log
@ - call mapiodev() with sizeof(struct xdc/xyc) rather than ra_len (which is
	zero since xdcmatch/xycmatch no longer sets it).   [if you call
	mapiodev() with a zero size it will reuse the KVA it returns, swiping
	the device out from under you!]
 - make xdc/xyc->iopbase point in the kernels DVMA space rather than at the
	normal malloc'd KVA.   this isn't compatable with sun4m [doesn't
	have a kernel DVMA space] and will need to be changed later (XXX).
 - move disk_attach() to before reading the disk label as per Jason.
	otherwise we are reading into an unallocated buffer (oops!)
@
text
@d39 1
a39 1
 * id: $Id: xy.c,v 1.4 1996/01/12 23:09:10 chuck Exp $
a1040 3
	/* Instrumentation. */
	disk_busy(&xy->sc_dk);

d1299 3
a1812 1
			iorq->mode = XY_SUB_FREE;
d1816 1
@


1.4
log
@we no longer need to add in the offset to the mapped VA to get the correct
device address (bus_tmp, bus_map, and mapiodev now do this for us).

also, we handle all our mappings, so don't have obio.c do any for us
(i.e. don't set ra->ra_len in xycmatch).

nuke uneeded variable in match function.
@
text
@d39 1
a39 1
 * id: $Id: xy.c,v 1.3 1996/01/12 20:20:53 deraadt Exp $
d334 1
a334 1
	    ca->ca_ra.ra_len, ca->ca_bustype);
d369 1
d590 3
a687 3

	/* Attach the disk. */
	disk_attach(&xy->sc_dk);
@


1.3
log
@from netbsd;
New generic disk framework.  Highlights:
New metrics handling.  Metrics are now kept in the new `struct disk'.
Busy time is now stored as a timeval, and transfer count in bytes.
Storage for disklabels is now dynamically allocated, so that the size
of the disk structure is not machine-dependent.
Several new functions for attaching and detaching disks, and handling
metrics calculation.
Old-style instrumentation is still supported in drivers that did it
before.  However, old-style instrumentation is being deprecated, and
will go away once the userland utilities are updated for the new
framework.
For usage and architectural details, see the forthcoming disk(9)
manual page.
@
text
@d39 1
a39 1
 * id: $Id: xy.c,v 1.3 1996/01/07 22:03:05 thorpej Exp $
a298 1
	void	*vaddr;
d304 1
a304 4
		vaddr = ra->ra_vaddr;
		if ((u_long) ra->ra_paddr & PGOFSET)
			(u_long) vaddr |= ((u_long) ra->ra_paddr & PGOFSET);
		xyc = (struct xyc *) vaddr;
a308 1
		ra->ra_len = NBPG;
a334 3
	if ((u_long) ca->ca_ra.ra_paddr & PGOFSET)
		(u_long) ca->ca_ra.ra_vaddr |=
				((u_long) ca->ca_ra.ra_paddr & PGOFSET);
@


1.2
log
@new mapdev/()/mapiodev() calling convention uses "struct rom_reg *" to supply
base plus an offset
new dvma routines
@
text
@d1 1
a1 1
/* $NetBSD: xy.c,v 1.2 1995/12/11 12:40:25 pk Exp $ */
d39 1
a39 1
 * id: $Id: xy.c,v 1.2 1995/12/11 12:40:25 pk Exp $
d244 1
a244 1
	xy->sc_dk.dk_label.d_secsize = XYFM_BPS;
d248 1
a248 1
				&xy->sc_dk.dk_label, &xy->sc_dk.dk_cpulabel);
d255 1
a255 1
	sdl = (struct sun_disklabel *)xy->sc_dk.dk_cpulabel.cd_block;
d261 2
a262 2
		xy->pcyl = xy->sc_dk.dk_label.d_ncylinders +
			xy->sc_dk.dk_label.d_acylinders;
d267 4
a270 4
	xy->ncyl = xy->sc_dk.dk_label.d_ncylinders;
	xy->acyl = xy->sc_dk.dk_label.d_acylinders;
	xy->nhead = xy->sc_dk.dk_label.d_ntracks;
	xy->nsect = xy->sc_dk.dk_label.d_nsectors;
d272 1
a272 1
	xy->sc_dk.dk_label.d_secsize = XYFM_BPS; /* not handled by
d504 8
a685 2
		xy->sc_dk.dk_driver = &xydkdriver;	/* link in dkdriver */

d693 4
a696 1
	dk_establish(&xy->sc_dk, &xy->sc_dev);
d811 1
a811 1
		bcopy(&xy->sc_dk.dk_label, addr, sizeof(struct disklabel));
d815 1
a815 1
		((struct partinfo *) addr)->disklab = &xy->sc_dk.dk_label;
d817 1
a817 1
		    &xy->sc_dk.dk_label.d_partitions[DISKPART(dev)];
d823 1
a823 1
		error = setdisklabel(&xy->sc_dk.dk_label,
d825 1
a825 1
		    &xy->sc_dk.dk_cpulabel);
d844 1
a844 1
		error = setdisklabel(&xy->sc_dk.dk_label,
d846 1
a846 1
		    &xy->sc_dk.dk_cpulabel);
d854 2
a855 2
			    xystrategy, &xy->sc_dk.dk_label,
			    &xy->sc_dk.dk_cpulabel);
d910 2
a911 2
	    (part >= xy->sc_dk.dk_label.d_npartitions ||
		xy->sc_dk.dk_label.d_partitions[part].p_fstype == FS_UNUSED)) {
d969 1
a969 1
	if (xysc->sc_dk.dk_label.d_partitions[part].p_fstype != FS_SWAP)
d972 1
a972 1
		size = xysc->sc_dk.dk_label.d_partitions[part].p_size;
d999 1
a999 1
	    (bp->b_bcount % xy->sc_dk.dk_label.d_secsize) != 0) {
d1032 1
a1032 1
	if (bounds_check_with_label(bp, &xy->sc_dk.dk_label,
d1048 3
d1292 1
a1292 1
	    xysc->sc_dk.dk_label.d_partitions[partno].p_offset);
d1643 3
d1822 2
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $NetBSD: xy.c,v 1.1 1995/09/25 20:35:14 chuck Exp $ */
d39 1
a39 1
 * id: $Id: xy.c,v 1.1 1995/09/25 20:35:14 chuck Exp $
a140 5
/* external (XXX should migrate to std include file?) */
extern caddr_t dvma_malloc __P((size_t));
extern void dvma_free __P((caddr_t, size_t));
extern caddr_t dvma_mapin __P((struct vm_map *, vm_offset_t, int, int));
extern void dvma_mapout __P((vm_offset_t, vm_offset_t, int));
d203 2
a204 1
	char	*dvmabuf;	/* scratch buffer for reading disk label */
d332 1
d338 1
a338 1
	ca->ca_ra.ra_vaddr = mapiodev(ca->ca_ra.ra_paddr,
d361 3
a363 2
	tmp = tmp2 = (struct xy_iopb *) dvma_malloc(pbsz);	/* KVA */
	ultmp = (u_long) tmp;
d365 4
a368 3
		tmp = (struct xy_iopb *) dvma_malloc(pbsz); /* retry! */
		dvma_free(tmp2, pbsz);
		ultmp = (u_long) tmp;
d375 1
d377 1
a377 2
	bzero(xyc->iopbase, pbsz);
	xyc->dvmaiopb = (struct xy_iopb *) ((u_long) xyc->iopbase - DVMA_BASE);
d441 1
a441 1
	xa.dvmabuf = (char *) dvma_malloc(XYFM_BPS);
d453 1
a453 1
	dvma_free(xa.dvmabuf, XYFM_BPS);
d589 1
a589 1
	if (xygetdisklabel(xy, xa->dvmabuf) != XY_ERR_AOK)
d594 1
a594 1
		xa->dvmabuf, xy->pcyl);
d657 1
a657 1
	dkb = (struct dkbad *) xa->dvmabuf;
d674 1
a674 1
		bcopy(xa->dvmabuf, &xy->dkb, XYFM_BPS);
d888 1
a888 1
		xa.dvmabuf = (char *) dvma_malloc(XYFM_BPS);
d893 1
a893 1
		dvma_free(xa.dvmabuf, XYFM_BPS);
d998 1
a998 1
		xa.dvmabuf = (char *) dvma_malloc(XYFM_BPS);
d1002 1
a1002 1
		dvma_free(xa.dvmabuf, XYFM_BPS);
a1030 28

	{			/* XXX DVMA mapin */

		/* DVMA: if we've got a kernel buf structure we map it into
		 * DVMA space here.   the advantage to this is that it allows
		 * us to sleep if there isn't space in the DVMA area.   the
		 * disadvantage to this is that we are mapping this in earlier
		 * than we have to, and thus possibly wasting DVMA space.   in
		 * an ideal world we would like to map it in once we know we
		 * can submit an IOPB (at this point we don't know if we can
		 * submit or not).   (XXX) If the DVMA system gets redone this
		 * mapin can be moved elsewhere. */

		caddr_t x;
		if ((bp->b_flags & B_PHYS) == 0) {
			x = dvma_mapin(kernel_map, (vm_offset_t)bp->b_data,
					bp->b_bcount, 1);
			if (x == NULL)
				panic("xy mapin");
			bp->b_error = (int) x;	/* XXX we store DVMA addr in
						 * b_error, thus overloading
						 * it.    VERY ugly.  note
						 * that xd.c uses b_resid, but
						 * we can't because disksort
						 * uses it */
		}
	} /* XXX end DVMA mapin */

d1275 2
a1276 11
	 * also, note that there are two kinds of buf structures, those with
	 * B_PHYS set and those without B_PHYS.   if B_PHYS is set, then it is
	 * a raw I/O (to a cdevsw) and we are doing I/O directly to the users'
	 * buffer which has already been mapped into DVMA space. however, if
	 * B_PHYS is not set, then the buffer is a normal system buffer which
	 * does *not* live in DVMA space.   in that case we call dvma_mapin to
	 * map it into DVMA space so we can do the DMA I/O to it.
	 * 
	 * in cases where we do a dvma_mapin, note that iorq points to the buffer
	 * as mapped into DVMA space, where as the bp->b_data points to its
	 * non-DVMA mapping.
d1282 6
a1287 20
	if ((bp->b_flags & B_PHYS) == 0) {
		dbuf = (caddr_t) bp->b_error;	/* XXX: overloaded error from
						 * xystrategy() */
		bp->b_error = 0;		/* XXX? */
#ifdef someday

		/* XXX: this is where we would really like to do the DVMA
		 * mapin, but we get called from intr here so we can't sleep
		 * so we can't do it. */
		/* allocate DVMA, map in */

		if (dbuf == NULL) {	/* out of DVMA space */
			printf("%s: warning: out of DVMA space\n", 
						xycsc->sc_dev.dv_xname);
			return (XY_ERR_FAIL);	/* XXX: need some sort of
						 * call-back scheme here? */
		}
#endif				/* someday */
	} else {
		dbuf = bp->b_data;
d1609 5
a1613 3
		if (XY_STATE(xycsc->reqs[lcv].mode) != XY_SUB_POLL &&
		    XY_STATE(xycsc->reqs[lcv].mode) != XY_SUB_WAIT &&
		    XY_STATE(xycsc->reqs[lcv].mode) != XY_SUB_NORM)
d1618 1
a1618 1
				blastmode != &xycsc->reqs[lcv]) {
d1620 1
a1620 1
			xycsc->reqs[lcv].errno = error;
d1622 1
a1622 1
			switch (XY_STATE(xycsc->reqs[lcv].mode)) {
d1624 9
a1632 14
			    xycsc->reqs[lcv].buf->b_error = EIO;
			    xycsc->reqs[lcv].buf->b_flags |= B_ERROR;
			    xycsc->reqs[lcv].buf->b_resid =
			       xycsc->reqs[lcv].sectcnt * XYFM_BPS;
			    if ((xycsc->reqs[lcv].buf->b_flags & B_PHYS) == 0) {
				dvma_mapout(
				    (vm_offset_t)xycsc->reqs[lcv].dbufbase,
				    (vm_offset_t)xycsc->reqs[lcv].buf->b_un.b_addr,
				    xycsc->reqs[lcv].buf->b_bcount);
				}
			    xycsc->reqs[lcv].xy->xyq.b_actf =
				xycsc->reqs[lcv].buf->b_actf;
			    biodone(xycsc->reqs[lcv].buf);
			    xycsc->reqs[lcv].mode = XY_SUB_FREE;
d1635 1
a1635 1
			    wakeup(&xycsc->reqs[lcv]);
d1637 2
a1638 2
			    xycsc->reqs[lcv].mode =
				XY_NEWSTATE(xycsc->reqs[lcv].mode, XY_SUB_DONE);
d1802 3
a1804 5
			if ((bp->b_flags & B_PHYS) == 0) {
				dvma_mapout((vm_offset_t) iorq->dbufbase,
					    (vm_offset_t) bp->b_un.b_addr,
					    bp->b_bcount);
			}
d1977 1
a1977 1
	caddr_t dvmabuf = NULL;
d2009 1
a2009 1
		dvmabuf = dvma_malloc(xio->dlen);
d2011 2
a2012 2
			if (err = copyin(xio->dptr, dvmabuf, xio->dlen)) {
				dvma_free(dvmabuf, xio->dlen);
d2033 1
a2033 1
		err = copyout(dvmabuf, xio->dptr, xio->dlen);
d2038 1
a2038 1
		dvma_free(dvmabuf, xio->dlen);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
