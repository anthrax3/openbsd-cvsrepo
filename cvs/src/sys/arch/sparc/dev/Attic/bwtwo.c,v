head	1.41;
access;
symbols
	OPENBSD_6_0:1.40.0.6
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.39.0.6
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.38.0.14
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.38.0.12
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.38.0.10
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.8
	OPENBSD_5_0:1.38.0.6
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.38.0.4
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.38.0.2
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.35.0.4
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.35.0.6
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.35.0.2
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.34.0.8
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.34.0.6
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.34.0.4
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.34.0.2
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.33.0.2
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.32.0.4
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.32.0.2
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.31.0.2
	OPENBSD_3_7_BASE:1.31
	OPENBSD_3_6:1.27.0.6
	OPENBSD_3_6_BASE:1.27
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.27.0.4
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	UBC_SYNC_A:1.25
	OPENBSD_3_3:1.25.0.2
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.24.0.2
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	UBC_SYNC_B:1.24
	UBC:1.19.0.2
	UBC_BASE:1.19
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.8
	OPENBSD_2_8:1.16.0.6
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.16.0.4
	OPENBSD_2_7_BASE:1.16
	SMP:1.16.0.2
	SMP_BASE:1.16
	kame_19991208:1.16
	OPENBSD_2_6:1.15.0.4
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.15.0.2
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.14.0.6
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.14.0.4
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.13.0.4
	OPENBSD_2_1_BASE:1.13
	OPENBSD_2_0:1.13.0.2
	OPENBSD_2_0_BASE:1.13
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.41
date	2016.09.01.09.23.41;	author tedu;	state dead;
branches;
next	1.40;
commitid	Q2PxaFNhqAe0Wmla;

1.40
date	2015.03.28.19.07.07;	author miod;	state Exp;
branches;
next	1.39;
commitid	nwbHy4sQv9NnJnmZ;

1.39
date	2013.10.20.20.07.25;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2010.07.10.19.32.24;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2010.06.07.19.43.45;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2010.05.15.15.28.09;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2008.12.26.22.30.21;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2006.12.03.16.38.12;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2006.06.02.20.00.54;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2005.03.23.17.16.34;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2005.03.07.16.44.50;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.01.21.21.24;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2005.01.05.23.04.24;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2004.11.29.22.07.36;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.28.17.05.33;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.02.23.27.53;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.11.06.21.06.20;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2002.09.23.18.13.38;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2002.09.09.22.15.15;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2002.08.12.10.44.03;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.09.23.33.15;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.14.01.26.42;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.11.01.12.13.46;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.08.17.13.52.28;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	99.12.08.01.35.44;	author jason;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	98.11.20.15.57.21;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.08.08.08.24.43;	author downsj;	state Exp;
branches;
next	1.13;

1.13
date	96.08.13.08.05.18;	author downsj;	state Exp;
branches;
next	1.12;

1.12
date	96.08.11.05.34.07;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	95.12.18.17.02.26;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	95.12.17.09.29.46;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	95.12.15.13.56.15;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	95.11.21.13.02.11;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	95.11.19.00.11.38;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	95.11.09.21.34.44;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	95.10.24.10.16.48;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.10.23.08.15.47;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.10.22.11.28.30;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.19.13.06.07;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.37;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.37;	author deraadt;	state Exp;
branches;
next	;

1.16.2.1
date	2001.10.31.03.07.56;	author nate;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.16.2.4;

1.16.2.4
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.16.2.5;

1.16.2.5
date	2003.06.07.11.14.42;	author ho;	state Exp;
branches;
next	1.16.2.6;

1.16.2.6
date	2004.02.19.10.49.57;	author niklas;	state Exp;
branches;
next	;

1.19.2.1
date	2002.06.11.03.38.15;	author art;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2002.10.29.00.28.09;	author art;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: bwtwo.c,v 1.40 2015/03/28 19:07:07 miod Exp $	*/
/*	$NetBSD: bwtwo.c,v 1.33 1997/05/24 20:16:02 pk Exp $ */

/*
 * Copyright (c) 2002 Miodrag Vallat.  All rights reserved.
 * Copyright (c) 1996 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)bwtwo.c	8.1 (Berkeley) 6/11/93
 */

/*
 * black&white display (bwtwo) driver.
 *
 * P4 and overlay plane support by Jason R. Thorpe <thorpej@@NetBSD.ORG>.
 * Overlay plane handling hints and ideas provided by Brad Spencer.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/mman.h>
#include <sys/tty.h>
#include <sys/conf.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/eeprom.h>
#include <machine/ctlreg.h>
#include <machine/conf.h>
#include <sparc/sparc/asm.h>

#include <sparc/dev/btreg.h>
#include <sparc/dev/bwtworeg.h>
#if defined(SUN4)
#include <sparc/dev/pfourreg.h>
#endif

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

#include <machine/pmap.h>

/* per-display variables */
struct bwtwo_softc {
	struct	sunfb sc_sunfb;		/* common base part */
	volatile struct fbcontrol *sc_reg;/* control registers */
	struct rom_reg	sc_phys;	/* phys address description */
	int	sc_bustype;		/* type of bus we live on */
	int	sc_pixeloffset;		/* offset to framebuffer */
};

void	bwtwo_burner(void *, u_int, u_int);
int	bwtwo_intr(void *);
int	bwtwo_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	bwtwo_mmap(void *, off_t, int);

struct wsdisplay_accessops bwtwo_accessops = {
	.ioctl = bwtwo_ioctl,
	.mmap = bwtwo_mmap,
	.burn_screen = bwtwo_burner
};


/* autoconfiguration driver */
void	bwtwoattach(struct device *, struct device *, void *);
int	bwtwomatch(struct device *, void *, void *);

struct cfattach bwtwo_ca = {
	sizeof(struct bwtwo_softc), bwtwomatch, bwtwoattach
};

struct cfdriver bwtwo_cd = {
	NULL, "bwtwo", DV_DULL
};

int
bwtwomatch(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
		return (0);

#if 0
	if (CPU_ISSUN4 && cf->cf_unit != 0)
		return (0);
#endif

	if (ca->ca_bustype == BUS_SBUS)
		return (1);

	/*
	 * Make sure there's hardware there.
	 */
	if (probeget(ra->ra_vaddr, 4) == -1)
		return (0);

	switch (ca->ca_bustype) {
	case BUS_VME16:
	case BUS_VME32:
		return (1);
	case BUS_OBIO:
#if defined(SUN4)
		if (CPU_ISSUN4) {
			/*
			 * Check for a pfour framebuffer, but do not match the
			 * overlay planes for color pfour framebuffers.
			 */
			switch (fb_pfour_id(ra->ra_vaddr)) {
			case PFOUR_ID_BW:
			case PFOUR_NOTPFOUR:
				return (1);
			case PFOUR_ID_COLOR8P1:		/* bwtwo in ... */
			case PFOUR_ID_COLOR24:		/* ...overlay plane */
			default:
				return (0);
			}
		}
#endif
		return (1);
	default:
		return (0);
	}
}

void
bwtwoattach(struct device *parent, struct device *self, void *args)
{
	struct bwtwo_softc *sc = (struct bwtwo_softc *)self;
	struct confargs *ca = args;
	int node = ca->ca_ra.ra_node;
	int isconsole = 0;
	int sbus = 1;
	char *nam;

	printf(": ");

	/*
	 * Check if this is a P4 attachment, and map the P4 control
	 * register if necessary.
	 */
#if defined(SUN4)
	if (CPU_ISSUN4 && ca->ca_bustype == BUS_OBIO) {
		sc->sc_sunfb.sf_pfour = (volatile u_int32_t *)
		    mapiodev(ca->ca_ra.ra_reg, 0, sizeof(u_int32_t));
		if (fb_pfour_id(sc->sc_sunfb.sf_pfour) != PFOUR_NOTPFOUR)
			SET(sc->sc_sunfb.sf_flags, FB_PFOUR);
		else {
			/* XXX unmapiodev */
			sc->sc_sunfb.sf_pfour = NULL;
		}
	}
#endif

	/*
	 * Map the control register (unless done above for a P4 device).
	 */
#if defined(SUN4)
	if (!CPU_ISSUN4 || !ISSET(sc->sc_sunfb.sf_flags, FB_PFOUR))
#endif
	{
		sc->sc_reg = (volatile struct fbcontrol *)
		    mapiodev(ca->ca_ra.ra_reg, BWREG_REG,
			     sizeof(struct fbcontrol));
	}

	/* Set up default pixel offset.  May be changed below. */
	sc->sc_pixeloffset = BWREG_MEM;

	switch (ca->ca_bustype) {
	case BUS_OBIO:
		if (CPU_ISSUN4M)	/* 4m has framebuffer on obio */
			goto obp_name;

		sbus = node = 0;
#if defined(SUN4)
		if (ISSET(sc->sc_sunfb.sf_flags, FB_PFOUR)) {
			nam = "p4";
			sc->sc_pixeloffset = PFOUR_BW_OFF;
		} else
#endif
			nam = NULL;
		break;

	case BUS_VME32:
	case BUS_VME16:
		sbus = node = 0;
		nam = NULL;
		break;

	case BUS_SBUS:
obp_name:
#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
		nam = getpropstring(node, "model");
#endif
		break;
	}

	if (nam != NULL && *nam != '\0')
		printf("%s, ", nam);

#if defined(SUN4)
	if (CPU_ISSUN4) {
		struct eeprom *eep = (struct eeprom *)eeprom_va;
		int constype = ISSET(sc->sc_sunfb.sf_flags, FB_PFOUR) ?
		    EED_CONS_P4 : EED_CONS_BW;
		/*
		 * Assume this is the console if there's no eeprom info
		 * to be found.
		 */
		if (eep == NULL || eep->ee_diag.eed_console == constype)
			isconsole = 1;
		else
		/*
		 * On sun4 systems without on-board framebuffers (such as
		 * the 4/3xx models), the PROM will accept the EED_CONS_BW
		 * setting although the framebuffer is a P4.
		 * Accept this setting as well.
		 */
		if (eep->ee_diag.eed_console == EED_CONS_BW)
			isconsole = 1;
	}
#endif

	if (!CPU_ISSUN4)
		isconsole = node == fbnode;

	sc->sc_phys = ca->ca_ra.ra_reg[0];
	sc->sc_bustype = ca->ca_bustype;

	/* enable video */
	bwtwo_burner(sc, 1, 0);

	fb_setsize(&sc->sc_sunfb, 1, 1152, 900, node, ca->ca_bustype);
	printf("%dx%d\n", sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);

	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(ca->ca_ra.ra_reg,
	    sc->sc_pixeloffset, round_page(sc->sc_sunfb.sf_fbsize));
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, isconsole);

	if (isconsole)
		fbwscons_console_init(&sc->sc_sunfb, -1);

	fbwscons_attach(&sc->sc_sunfb, &bwtwo_accessops, isconsole);
}

int
bwtwo_ioctl(void *v, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct bwtwo_softc *sc = v;
	struct wsdisplay_fbinfo *wdf;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_SUNBW;
		break;
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width = sc->sc_sunfb.sf_width;
		wdf->depth = sc->sc_sunfb.sf_depth;
		wdf->cmsize = 0;	/* no colormap */
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
		break;

	case WSDISPLAYIO_GETCMAP:
	case WSDISPLAYIO_PUTCMAP:
		break;

	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
		break;

	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
	default:
		return (-1);	/* not supported yet */
	}

	return (0);
}

paddr_t
bwtwo_mmap(void *v, off_t offset, int prot)
{
	struct bwtwo_softc *sc = v;

	if (offset & PGOFSET)
		return (-1);

	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys, sc->sc_pixeloffset + offset) |
		    PMAP_NC);
	}

	return (-1);
}

void
bwtwo_burner(void *v, u_int on, u_int flags)
{
	struct bwtwo_softc *sc = v;
	int s;

#if defined(SUN4)
	if (CPU_ISSUN4 && (sc->sc_bustype == BUS_OBIO)) {
		if (ISSET(sc->sc_sunfb.sf_flags, FB_PFOUR)) {
			fb_pfour_burner(v, on, flags);
			return;
		}
		if (on)
			stba(AC_SYSENABLE, ASI_CONTROL,
			    lduba(AC_SYSENABLE, ASI_CONTROL) | SYSEN_VIDEO);
		else
			stba(AC_SYSENABLE, ASI_CONTROL,
			    lduba(AC_SYSENABLE, ASI_CONTROL) & ~SYSEN_VIDEO);

		return;
	}
#endif

	s = splhigh();
	if (on)
		sc->sc_reg->fbc_ctrl |= FBC_VENAB | FBC_TIMING;
	else {
		sc->sc_reg->fbc_ctrl &= ~FBC_VENAB;
		if (flags & WSDISPLAY_BURN_VBLANK)
			sc->sc_reg->fbc_ctrl &= ~FBC_TIMING;
	}
	splx(s);
}
@


1.40
log
@Don't include sbusvar.h if you need neither sbus_translate() nor sbus_testdma().
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.39 2013/10/20 20:07:25 miod Exp $	*/
@


1.39
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.38 2010/07/10 19:32:24 miod Exp $	*/
a71 1
#include <sparc/dev/sbusvar.h>
@


1.38
log
@sun4e (i.e. SPARCengine 1e) support. This platform is a mix between sun4 and
sun4c, as it has a sun4c OpenPROM but a sun4 8KB pagesize. VME devices are
not supported yet.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.37 2010/06/07 19:43:45 miod Exp $	*/
d99 3
a101 10
	bwtwo_ioctl,
	bwtwo_mmap,
	NULL,	/* alloc_screen */
	NULL,	/* free_screen */
	NULL,	/* show_screen */
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	bwtwo_burner,
	NULL	/* pollc */
@


1.37
log
@Nuke old eeprom.h compatibility defines; ok todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.36 2010/05/15 15:28:09 miod Exp $	*/
d243 1
a243 1
#if defined(SUN4C) || defined(SUN4M)
d275 1
a275 1
	if (CPU_ISSUN4COR4M)
@


1.36
log
@Repair identification of P4 bwtwo on 4/330 and 4/370 models, which got broken
in 1.36.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.35 2008/12/26 22:30:21 miod Exp $	*/
d256 1
a256 1
		    EE_CONS_P4OPT : EE_CONS_BW;
d261 1
a261 1
		if (eep == NULL || eep->eeConsole == constype)
d266 1
a266 1
		 * the 4/3xx models), the PROM will accept the EE_CONS_BW
d270 1
a270 1
		if (eep->eeConsole == EE_CONS_BW)
@


1.35
log
@Move the logic responsible from deciding whether a frame buffer needs to be
cleared on attach, from the individual drivers to the common frame buffer code;
the latter will decide based on the prom font metrics and the prom console
window position, whenever possible.

This removes the need for the console window position to be hardcoded in
the p9100 driver, and will no longer require a screen clear on a vigra
VS-12 in high resolution mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.34 2006/12/03 16:38:12 miod Exp $	*/
d189 2
a190 1
	 * Map the control register.
d193 1
a193 3
	if (CPU_ISSUN4 && ca->ca_bustype == BUS_OBIO &&
	    fb_pfour_id(ca->ca_ra.ra_vaddr) != PFOUR_NOTPFOUR) {
		SET(sc->sc_sunfb.sf_flags, FB_PFOUR);
d196 14
a209 1
	} else
@


1.34
log
@Clean frame buffer attachment code:
- There is no need to check for buses config(8) will not let us attach to
- Better P4 bus logic, which does not need to abuse device flags
- Do not bother trying to print a meaningful device description when it is
  not connected to sbus.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.33 2006/06/02 20:00:54 miod Exp $	*/
d278 1
a278 1
	fbwscons_init(&sc->sc_sunfb, isconsole ? 0 : RI_CLEAR);
d280 1
a280 1
	if (isconsole) {
a281 1
	}
@


1.33
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.32 2005/03/23 17:16:34 miod Exp $	*/
a130 5
	/*
	 * Mask out invalid flags from the user.
	 */
	cf->cf_flags &= FB_USERMASK;

d134 1
d137 1
d140 1
a140 1
		return(1);
d148 5
d154 14
a167 17
	if (CPU_ISSUN4 && (ca->ca_bustype == BUS_OBIO)) {
		/*
		 * Check for a pfour framebuffer, but do not match the
		 * overlay planes for color pfour framebuffers.
		 */
		switch (fb_pfour_id(ra->ra_vaddr)) {
		case PFOUR_ID_BW:
			cf->cf_flags |= FB_PFOUR;
			/* FALLTHROUGH */

		case PFOUR_NOTPFOUR:
			return (1);

		case PFOUR_ID_COLOR8P1:		/* bwtwo in ... */
		case PFOUR_ID_COLOR24:		/* ...overlay plane */
		default:
			return (0);
d169 4
a173 3
#endif

	return (0);
d184 1
a184 1
	char *nam = NULL;
d186 1
a186 1
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;
d193 2
a194 1
	    ISSET(sc->sc_sunfb.sf_flags, FB_PFOUR)) {
a196 1
		sc->sc_reg = NULL;
a202 1
		sc->sc_sunfb.sf_pfour = NULL;
d216 1
a216 1
			nam = "bwtwo/p4";
d220 1
a220 1
			nam = "bwtwo";
d226 1
a226 1
		nam = "bwtwo";
d237 2
a238 1
	printf(": %s", nam);
d273 1
a273 1
	printf(", %dx%d\n", sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);
@


1.32
log
@Move the alloc_screen, free_screen and show_screen wsdisplay accessops to
the common frame buffer code, rather than duplicating it in every driver.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.31 2005/03/07 16:44:50 miod Exp $	*/
a86 1
	struct	sbusdev sc_sd;		/* sbus device */
a282 5

#if defined(SUN4C) || defined(SUN4M)
	if (sbus)
		sbus_establish(&sc->sc_sd, &sc->sc_sunfb.sf_dev);
#endif
@


1.31
log
@Do not bother passing the blanking routine to fbwscons_console_init(),
as fbwscons_attach() can find it on its own.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.30 2005/03/01 21:21:24 miod Exp $	*/
a78 1
#include <dev/wscons/wscons_raster.h>
a91 1
	int	sc_nscreens;
d94 4
a97 9
int bwtwo_ioctl(void *, u_long, caddr_t, int, struct proc *);
int bwtwo_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void bwtwo_free_screen(void *, void *);
int bwtwo_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t bwtwo_mmap(void *, off_t, int);
void bwtwo_burner(void *, u_int, u_int);
int bwtwo_intr(void *);
d102 3
a104 3
	bwtwo_alloc_screen,
	bwtwo_free_screen,
	bwtwo_show_screen,
d109 1
a124 3
/*
 * Match a bwtwo.
 */
d126 1
a126 3
bwtwomatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
a176 3
/*
 * Attach a display.
 */
d178 1
a178 3
bwtwoattach(parent, self, args)
	struct device *parent, *self;
	void *args;
d294 1
a294 6
bwtwo_ioctl(v, cmd, data, flags, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
a333 4
/*
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
 */
d335 1
a335 4
bwtwo_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
d351 1
a351 3
bwtwo_burner(v, on, flags)
	void *v;
	u_int on, flags;
d359 1
a359 1
			fb_pfour_set_video(&sc->sc_sunfb, on);
a381 43
}

int
bwtwo_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
{
	struct bwtwo_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    0, 0, 0, attrp);
	sc->sc_nscreens++;
	return (0);
}

void
bwtwo_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct bwtwo_softc *sc = v;

	sc->sc_nscreens--;
}

int
bwtwo_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
	return (0);
@


1.30
log
@Print display resolution as %dx%d, not %d x %d.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.29 2005/01/05 23:04:24 miod Exp $	*/
d298 1
a298 1
		fbwscons_console_init(&sc->sc_sunfb, -1, bwtwo_burner);
@


1.29
log
@Let wsdisplay drivers return zero for WSDISPLAYIO_[GS]VIDEO ioctls - most
of the work is done in the upper layer, but they get to see the ioctl,
so don't always return an error.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.28 2004/11/29 22:07:36 miod Exp $	*/
d290 1
a290 1
	printf(", %d x %d\n", sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);
@


1.28
log
@Move the struct wsscreen_descr from a per-driver global to a per-instance
field of the sunfb structure. This allows multiple instances of the same driver,
but with different resolutions (such as a couple of vigra or a TGX cgsix and
a TGX+ cgsix) to use distinct wsscreen_descr structures featuring different
resolution information.

Doing this allows more wsscreen_descr fiddling inside the sparc* fb api,
and results in some code shrinkage (about 4KB on sparc GENERIC).
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.27 2003/06/28 17:05:33 miod Exp $	*/
d341 2
@


1.27
log
@Sync sparc fb API with the sparc64 changes (fbwscons_init takes flags, and
the sunfb structure keeps pointer to the prom cursor coordinates).
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.26 2003/06/02 23:27:53 millert Exp $	*/
a95 13
struct wsscreen_descr bwtwo_stdscreen = {
	"std",
};

const struct wsscreen_descr *bwtwo_scrlist[] = {
	&bwtwo_stdscreen,
};

struct wsscreen_list bwtwo_screenlist = {
	sizeof(bwtwo_scrlist) / sizeof(struct wsscreen_descr *),
	    bwtwo_scrlist
};

a197 1
	struct wsemuldisplaydev_attach_args waa;
a296 5
	bwtwo_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	bwtwo_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	bwtwo_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	bwtwo_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

d298 1
a298 2
		fbwscons_console_init(&sc->sc_sunfb, &bwtwo_stdscreen, -1,
		    bwtwo_burner);
d306 1
a306 5
	waa.console = isconsole;
	waa.scrdata = &bwtwo_screenlist;
	waa.accessops = &bwtwo_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
@


1.26
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.25 2002/11/06 21:06:20 miod Exp $	*/
d309 1
a309 1
	fbwscons_init(&sc->sc_sunfb, isconsole);
@


1.25
log
@- always initialize colormaps, even if the frame buffer is non console; this
  helps if the ramdac does not get initialized (idea from jason@@)
- only register a shutdown hook for the frame buffers which need it, if this
  is the console frame buffer. Otherwise this is just a waste of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.24 2002/09/23 18:13:38 miod Exp $	*/
d27 1
a27 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.24
log
@Get the wsdisplay capabilities from rasops, rather than attempting to
guess them at compile-time. Plus this makes cgtwelve a bit more clean.

ok fgs@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.23 2002/09/09 22:15:15 miod Exp $	*/
d322 1
a322 1
		    NULL, bwtwo_burner);
@


1.23
log
@Register more screen capabilities to work with the recent wsemul_sun changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.22 2002/08/12 10:44:03 miod Exp $	*/
a101 4
	0, 0,	/* will be filled in */
	0,
	0, 0,
	WSSCREEN_UNDERLINE | WSSCREEN_REVERSE
d315 1
@


1.22
log
@Convert sparc console code from rcons and pseudo-devices to rasops and wscons.
For most framebuffers it is faster.

Other changes include:
o 24 bit support in tcx(4) for the S24 framebuffer
o accelerated cgsix(4) text console
o new cgtwelve(4) driver for the GS framebuffer
o improved serial driver code
o better keyboard support

The following framebuffers have not been tested but should work: cgfour,
cgeight and cgfourteen

These changes will require XF4 changes, to use Xwsfb instead of Xsun*, to be
commited later today.

Most of the work by me during the LSM and the week after, with code borrowed
from jason@@, NetBSD (new serial code), and feedback from mickey@@. Work on
pnozz(4) done by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.21 2002/07/09 23:33:15 jason Exp $	*/
d105 1
a105 1
	WSSCREEN_REVERSE
@


1.21
log
@try to disable vsync timing if sparc_vsyncblank is set
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.20 2002/03/14 01:26:42 millert Exp $	*/
d5 1
a52 2
 * Does not handle interrupts, even though they can occur.
 *
a67 1
#include <machine/fbio.h>
a68 2
#include <machine/pmap.h>
#include <machine/fbvar.h>
d81 8
d91 1
a91 1
	struct	device sc_dev;		/* base device */
a92 1
	struct	fbdevice sc_fb;		/* frame buffer device */
d97 40
a136 9
#if defined(SUN4)
	/*
	 * Additional overlay plane goo.
	 */
	int	sc_ovtype;		/* what kind of color fb? */
#define BWO_NONE	0x00
#define BWO_CGFOUR	0x01
#define BWO_CGEIGHT	0x02
#endif
d139 1
d141 2
a142 5
static void	bwtwoattach(struct device *, struct device *, void *);
static int	bwtwomatch(struct device *, void *, void *);
static void	bwtwounblank(struct device *);
static void	bwtwo_set_video(struct bwtwo_softc *, int);
static int	bwtwo_get_video(struct bwtwo_softc *);
a151 10
/* XXX we do not handle frame buffer interrupts (do not know how) */

/* frame buffer generic driver */
static struct fbdriver bwtwofbdriver = {
	bwtwounblank, bwtwoopen, bwtwoclose, bwtwoioctl, bwtwommap
};

extern int fbnode;
extern struct tty *fbconstty;

d164 4
a167 2
	if (CPU_ISSUN4 && cf->cf_unit != 0)
		return (0);
d172 2
a173 4
	/*
	 * Mask out invalid flags from the user.
	 */
	cf->cf_flags &= FB_USERMASK;
d187 2
a188 1
		 * Check for a pfour framebuffer.
a191 2
		case PFOUR_ID_COLOR8P1:		/* bwtwo in ... */
		case PFOUR_ID_COLOR24:		/* ...overlay plane */
d198 2
d210 1
a210 1
 * Attach a display.  We need to notice if it is the console, too.
d217 4
a220 4
	register struct bwtwo_softc *sc = (struct bwtwo_softc *)self;
	register struct confargs *ca = args;
	register int node = ca->ca_ra.ra_node, ramsize;
	struct fbdevice *fb = &sc->sc_fb;
d225 1
a225 4
	fb->fb_driver = &bwtwofbdriver;
	fb->fb_device = &sc->sc_dev;
	fb->fb_type.fb_type = FBTYPE_SUN2BW;
	fb->fb_flags = sc->sc_dev.dv_cfdata->cf_flags;
d230 4
a233 2
	if (fb->fb_flags & FB_PFOUR) {
		fb->fb_pfour = (volatile u_int32_t *)
d236 3
a238 1
	} else {
d242 1
a242 1
		fb->fb_pfour = NULL;
d255 1
a255 1
		if (fb->fb_flags & FB_PFOUR) {
d257 1
a257 22
			/*
			 * Notice if this is an overlay plane on a color
			 * framebuffer.  Note that PFOUR_COLOR_OFF_OVERLAY
			 * is the same as PFOUR_BW_OFF, but we use the
			 * different names anyway.
			 */
			switch (PFOUR_ID(*fb->fb_pfour)) {
			case PFOUR_ID_COLOR8P1:
				sc->sc_ovtype = BWO_CGFOUR;
				sc->sc_pixeloffset = PFOUR_COLOR_OFF_OVERLAY;
				break;

			case PFOUR_ID_COLOR24:
				sc->sc_ovtype = BWO_CGEIGHT;
				sc->sc_pixeloffset = PFOUR_COLOR_OFF_OVERLAY;
				break;

			default:
				sc->sc_ovtype = BWO_NONE;
				sc->sc_pixeloffset = PFOUR_BW_OFF;
				break;
			}
d270 1
a270 1
	obp_name:
d277 1
a277 11
	sc->sc_phys = ca->ca_ra.ra_reg[0];
	sc->sc_bustype = ca->ca_bustype;

	fb->fb_type.fb_depth = 1;
	fb_setsize(fb, fb->fb_type.fb_depth, 1152, 900, node, ca->ca_bustype);

	ramsize = fb->fb_type.fb_height * fb->fb_linebytes;
	fb->fb_type.fb_cmsize = 0;
	fb->fb_type.fb_size = ramsize;
	printf(": %s, %d x %d", nam,
	    fb->fb_type.fb_width, fb->fb_type.fb_height);
d282 2
a283 2
		int constype = (fb->fb_flags & FB_PFOUR) ? EE_CONS_P4OPT :
		    EE_CONS_BW;
d289 1
a289 1
			isconsole = (fbconstty != NULL);
d291 8
a298 1
			isconsole = 0;
d303 4
a306 1
		isconsole = node == fbnode && fbconstty != NULL;
d308 5
a312 11
	/*
	 * When the ROM has mapped in a bwtwo display, the address
	 * maps only the video RAM, hence we always map the control
	 * registers ourselves.  We only need the video RAM if we are
	 * going to print characters via rconsole.
	 */
	if ((fb->fb_pixels = ca->ca_ra.ra_vaddr) == NULL && isconsole) {
		/* this probably cannot happen (on sun4c), but what the heck */
		fb->fb_pixels =
		    mapiodev(ca->ca_ra.ra_reg, sc->sc_pixeloffset, ramsize);
	}
d314 8
a321 2
	/* Insure video is enabled */
	bwtwo_set_video(sc, 1);
d324 3
a326 15
		printf(" (console)\n");
#ifdef RASTERCONSOLE
#if defined(SUN4)
		/*
		 * XXX rcons doesn't seem to work properly on the overlay
		 * XXX plane.  This is a temporary kludge until someone
		 * XXX fixes it.
		 */
		if ((fb->fb_flags & FB_PFOUR) == 0 ||
		    (sc->sc_ovtype == BWO_NONE))
#endif
			fbrcons_init(fb);
#endif
	} else
		printf("\n");
d330 1
a330 36
		sbus_establish(&sc->sc_sd, &sc->sc_dev);
#endif

#if defined(SUN4)
	if ((fb->fb_flags & FB_PFOUR) && (sc->sc_ovtype != BWO_NONE)) {
		char *ovnam;

		switch (sc->sc_ovtype) {
		case BWO_CGFOUR:
			ovnam = "cgfour";
			break;

		case BWO_CGEIGHT:
			ovnam = "cgeight";
			break;

		default:
			ovnam = "unknown";
			break;
		}
		printf("%s: %s overlay plane\n", sc->sc_dev.dv_xname, ovnam);
	}
#endif

	if (CPU_ISSUN4 || node == fbnode) {
#if defined(SUN4)
		/*
		 * If we're on an overlay plane of a color framebuffer,
		 * then we don't force the issue in fb_attach() because
		 * we'd like the color framebuffer to actually be the
		 * "console framebuffer".  We're only around to speed
		 * up rconsole.
		 */
		if ((fb->fb_flags & FB_PFOUR) && (sc->sc_ovtype != BWO_NONE ))
			fb_attach(fb, 0);
		else
a331 24
			fb_attach(fb, isconsole);
	}
}

int
bwtwoopen(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	int unit = minor(dev);

	if (unit >= bwtwo_cd.cd_ndevs || bwtwo_cd.cd_devs[unit] == NULL)
		return (ENXIO);

	return (0);
}

int
bwtwoclose(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
d333 5
a337 1
	return (0);
d341 2
a342 2
bwtwoioctl(dev, cmd, data, flags, p)
	dev_t dev;
d348 2
a349 1
	struct bwtwo_softc *sc = bwtwo_cd.cd_devs[minor(dev)];
d352 9
a360 3

	case FBIOGTYPE:
		*(struct fbtype *)data = sc->sc_fb.fb_type;
d362 2
a363 3

	case FBIOGVIDEO:
		*(int *)data = bwtwo_get_video(sc);
d366 2
a367 2
	case FBIOSVIDEO:
		bwtwo_set_video(sc, (*(int *)data));
d370 7
d378 1
a378 1
		return (ENOTTY);
d380 1
a383 9
static void
bwtwounblank(dev)
	struct device *dev;
{
	struct bwtwo_softc *sc = (struct bwtwo_softc *)dev;

	bwtwo_set_video(sc, 1);
}

d389 3
a391 3
bwtwommap(dev, off, prot)
	dev_t dev;
	off_t off;
d394 1
a394 1
	register struct bwtwo_softc *sc = bwtwo_cd.cd_devs[minor(dev)];
d396 1
a396 3
	if (off & PGOFSET)
		panic("bwtwommap");
	if (off < 0)
a397 8
	if ((unsigned)off >= sc->sc_fb.fb_type.fb_size)
		return (-1);
	/*
	 * I turned on PMAP_NC here to disable the cache as I was
	 * getting horribly broken behaviour with it on.
	 */
	return (REG2PHYS(&sc->sc_phys, sc->sc_pixeloffset + off) | PMAP_NC);
}
d399 3
a401 15
static int
bwtwo_get_video(sc)
	struct bwtwo_softc *sc;
{

#if defined(SUN4)
	if (CPU_ISSUN4 && (sc->sc_bustype == BUS_OBIO)) {
		if (sc->sc_fb.fb_flags & FB_PFOUR) {
			/*
			 * This handles the overlay plane case, too.
			 */
			return (fb_pfour_get_video(&sc->sc_fb));
		} else
			return ((lduba(AC_SYSENABLE,
			    ASI_CONTROL) & SYSEN_VIDEO) != 0);
a402 1
#endif
d404 1
a404 1
	return ((sc->sc_reg->fbc_ctrl & FBC_VENAB) != 0);
d407 4
a410 4
static void
bwtwo_set_video(sc, enable)
	struct bwtwo_softc *sc;
	int enable;
d412 2
a413 1
	extern int sparc_vsyncblank;
d417 2
a418 5
		if (sc->sc_fb.fb_flags & FB_PFOUR) {
			/*
			 * This handles the overlay plane case, too.
			 */
			fb_pfour_set_video(&sc->sc_fb, enable);
d421 1
a421 1
		if (enable)
d432 2
a433 1
	if (enable)
d437 1
a437 1
		if (sparc_vsyncblank)
d440 44
@


1.20
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.19 2001/11/06 19:53:16 miod Exp $	*/
d494 1
d518 1
a518 1
	else
d520 3
@


1.19
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.18 2001/11/01 12:13:46 art Exp $	*/
d106 5
a110 5
static void	bwtwoattach __P((struct device *, struct device *, void *));
static int	bwtwomatch __P((struct device *, void *, void *));
static void	bwtwounblank __P((struct device *));
static void	bwtwo_set_video __P((struct bwtwo_softc *, int));
static int	bwtwo_get_video __P((struct bwtwo_softc *));
@


1.19.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.19 2001/11/06 19:53:16 miod Exp $	*/
d106 5
a110 5
static void	bwtwoattach(struct device *, struct device *, void *);
static int	bwtwomatch(struct device *, void *, void *);
static void	bwtwounblank(struct device *);
static void	bwtwo_set_video(struct bwtwo_softc *, int);
static int	bwtwo_get_video(struct bwtwo_softc *);
@


1.19.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.19.2.1 2002/06/11 03:38:15 art Exp $	*/
a4 1
 * Copyright (c) 2002 Miodrag Vallat.  All rights reserved.
d52 2
d69 1
d71 2
a84 8
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

#include <machine/pmap.h>

d87 1
a87 1
	struct	sunfb sc_sunfb;		/* common base part */
d89 1
d94 9
a102 14
	int	sc_nscreens;
};

struct wsscreen_descr bwtwo_stdscreen = {
	"std",
};

const struct wsscreen_descr *bwtwo_scrlist[] = {
	&bwtwo_stdscreen,
};

struct wsscreen_list bwtwo_screenlist = {
	sizeof(bwtwo_scrlist) / sizeof(struct wsscreen_descr *),
	    bwtwo_scrlist
a104 23
int bwtwo_ioctl(void *, u_long, caddr_t, int, struct proc *);
int bwtwo_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void bwtwo_free_screen(void *, void *);
int bwtwo_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t bwtwo_mmap(void *, off_t, int);
void bwtwo_burner(void *, u_int, u_int);
int bwtwo_intr(void *);

struct wsdisplay_accessops bwtwo_accessops = {
	bwtwo_ioctl,
	bwtwo_mmap,
	bwtwo_alloc_screen,
	bwtwo_free_screen,
	bwtwo_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	bwtwo_burner,
};


d106 5
a110 2
void	bwtwoattach(struct device *, struct device *, void *);
int	bwtwomatch(struct device *, void *, void *);
d120 10
d142 6
a152 6
	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
		return (0);

	if (CPU_ISSUN4 && cf->cf_unit != 0)
		return (0);

d165 1
a165 2
		 * Check for a pfour framebuffer, but do not match the
		 * overlay planes for color pfour framebuffers.
d169 2
a176 2
		case PFOUR_ID_COLOR8P1:		/* bwtwo in ... */
		case PFOUR_ID_COLOR24:		/* ...overlay plane */
d187 1
a187 1
 * Attach a display.
d194 4
a197 4
	struct bwtwo_softc *sc = (struct bwtwo_softc *)self;
	struct confargs *ca = args;
	struct wsemuldisplaydev_attach_args waa;
	int node = ca->ca_ra.ra_node;
d202 4
a205 1
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;
d210 2
a211 4
#if defined(SUN4)
	if (CPU_ISSUN4 && ca->ca_bustype == BUS_OBIO &&
	    ISSET(sc->sc_sunfb.sf_flags, FB_PFOUR)) {
		sc->sc_sunfb.sf_pfour = (volatile u_int32_t *)
d214 1
a214 3
	} else
#endif
	{
d218 1
a218 1
		sc->sc_sunfb.sf_pfour = NULL;
d231 1
a231 1
		if (ISSET(sc->sc_sunfb.sf_flags, FB_PFOUR)) {
d233 22
a254 1
			sc->sc_pixeloffset = PFOUR_BW_OFF;
d267 1
a267 1
obp_name:
d274 11
a284 1
	printf(": %s", nam);
d289 2
a290 2
		int constype = ISSET(sc->sc_sunfb.sf_flags, FB_PFOUR) ?
		    EE_CONS_P4OPT : EE_CONS_BW;
d296 1
a296 1
			isconsole = 1;
d298 1
a298 8
		/*
		 * On sun4 systems without on-board framebuffers (such as
		 * the 4/3xx models), the PROM will accept the EE_CONS_BW
		 * setting although the framebuffer is a P4.
		 * Accept this setting as well.
		 */
		if (eep->eeConsole == EE_CONS_BW)
			isconsole = 1;
d303 1
a303 1
		isconsole = node == fbnode;
d305 11
a315 2
	sc->sc_phys = ca->ca_ra.ra_reg[0];
	sc->sc_bustype = ca->ca_bustype;
d317 2
a318 2
	/* enable video */
	bwtwo_burner(sc, 1, 0);
d320 16
a335 2
	fb_setsize(&sc->sc_sunfb, 1, 1152, 900, node, ca->ca_bustype);
	printf(", %d x %d\n", sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);
d337 4
a340 9
	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(ca->ca_ra.ra_reg,
	    sc->sc_pixeloffset, round_page(sc->sc_sunfb.sf_fbsize));
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, isconsole);

	bwtwo_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	bwtwo_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	bwtwo_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	bwtwo_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;
d342 18
a359 3
	if (isconsole) {
		fbwscons_console_init(&sc->sc_sunfb, &bwtwo_stdscreen, -1,
		    NULL, bwtwo_burner);
d361 1
d363 12
a374 3
#if defined(SUN4C) || defined(SUN4M)
	if (sbus)
		sbus_establish(&sc->sc_sd, &sc->sc_sunfb.sf_dev);
d376 24
d401 1
a401 5
	waa.console = isconsole;
	waa.scrdata = &bwtwo_screenlist;
	waa.accessops = &bwtwo_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
d405 2
a406 2
bwtwo_ioctl(v, cmd, data, flags, p)
	void *v;
d412 1
a412 2
	struct bwtwo_softc *sc = v;
	struct wsdisplay_fbinfo *wdf;
d415 3
a417 2
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_SUNBW;
d419 3
a421 9
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width = sc->sc_sunfb.sf_width;
		wdf->depth = sc->sc_sunfb.sf_depth;
		wdf->cmsize = 0;	/* no colormap */
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
d424 2
a425 2
	case WSDISPLAYIO_GETCMAP:
	case WSDISPLAYIO_PUTCMAP:
a427 7
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
d429 1
a429 1
		return (-1);	/* not supported yet */
d431 2
d434 7
a440 1
	return (0);
d448 3
a450 3
bwtwo_mmap(v, offset, prot)
	void *v;
	off_t offset;
d453 1
a453 1
	struct bwtwo_softc *sc = v;
d455 5
a459 1
	if (offset & PGOFSET)
d461 11
d473 10
a482 3
	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys, sc->sc_pixeloffset + offset) |
		    PMAP_NC);
d484 1
d486 1
a486 1
	return (-1);
d489 4
a492 4
void
bwtwo_burner(v, on, flags)
	void *v;
	u_int on, flags;
a493 2
	struct bwtwo_softc *sc = v;
	int s;
d497 5
a501 2
		if (ISSET(sc->sc_sunfb.sf_flags, FB_PFOUR)) {
			fb_pfour_set_video(&sc->sc_sunfb, on);
d504 1
a504 1
		if (on)
d515 1
a515 2
	s = splhigh();
	if (on)
d517 1
a517 1
	else {
a518 47
		if (flags & WSDISPLAY_BURN_VBLANK)
			sc->sc_reg->fbc_ctrl &= ~FBC_TIMING;
	}
	splx(s);
}

int
bwtwo_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
{
	struct bwtwo_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    0, 0, 0, attrp);
	sc->sc_nscreens++;
	return (0);
}

void
bwtwo_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct bwtwo_softc *sc = v;

	sc->sc_nscreens--;
}

int
bwtwo_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
	return (0);
@


1.19.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d322 1
a322 1
		    bwtwo_burner);
@


1.18
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.17 2001/08/17 13:52:28 mickey Exp $	*/
d67 1
a67 1
#include <vm/vm.h>
@


1.17
log
@cdev_decl cleanup; jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.16 1999/12/08 01:35:44 jason Exp $	*/
d447 1
a447 1
int
d450 2
a451 1
	int off, prot;
@


1.16
log
@make sure video timing is enabled (not always done by prom); NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.15 1998/11/20 15:57:21 deraadt Exp $	*/
a110 3

/* cdevsw prototypes */
cdev_decl(bwtwo);
@


1.16.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.16 1999/12/08 01:35:44 jason Exp $	*/
d111 3
@


1.16.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d67 1
a67 1
#include <uvm/uvm_extern.h>
d447 1
a447 1
paddr_t
d450 1
a450 2
	off_t off;
	int prot;
@


1.16.2.3
log
@Merge in -current from about a week ago
@
text
@d106 5
a110 5
static void	bwtwoattach(struct device *, struct device *, void *);
static int	bwtwomatch(struct device *, void *, void *);
static void	bwtwounblank(struct device *);
static void	bwtwo_set_video(struct bwtwo_softc *, int);
static int	bwtwo_get_video(struct bwtwo_softc *);
@


1.16.2.4
log
@Sync the SMP branch with 3.3
@
text
@a4 1
 * Copyright (c) 2002 Miodrag Vallat.  All rights reserved.
d52 2
d69 1
d71 2
a84 8
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

#include <machine/pmap.h>

d87 1
a87 1
	struct	sunfb sc_sunfb;		/* common base part */
d89 1
d94 9
a102 14
	int	sc_nscreens;
};

struct wsscreen_descr bwtwo_stdscreen = {
	"std",
};

const struct wsscreen_descr *bwtwo_scrlist[] = {
	&bwtwo_stdscreen,
};

struct wsscreen_list bwtwo_screenlist = {
	sizeof(bwtwo_scrlist) / sizeof(struct wsscreen_descr *),
	    bwtwo_scrlist
a104 23
int bwtwo_ioctl(void *, u_long, caddr_t, int, struct proc *);
int bwtwo_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void bwtwo_free_screen(void *, void *);
int bwtwo_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t bwtwo_mmap(void *, off_t, int);
void bwtwo_burner(void *, u_int, u_int);
int bwtwo_intr(void *);

struct wsdisplay_accessops bwtwo_accessops = {
	bwtwo_ioctl,
	bwtwo_mmap,
	bwtwo_alloc_screen,
	bwtwo_free_screen,
	bwtwo_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	bwtwo_burner,
};


d106 5
a110 2
void	bwtwoattach(struct device *, struct device *, void *);
int	bwtwomatch(struct device *, void *, void *);
d120 10
d142 6
a152 6
	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
		return (0);

	if (CPU_ISSUN4 && cf->cf_unit != 0)
		return (0);

d165 1
a165 2
		 * Check for a pfour framebuffer, but do not match the
		 * overlay planes for color pfour framebuffers.
d169 2
a176 2
		case PFOUR_ID_COLOR8P1:		/* bwtwo in ... */
		case PFOUR_ID_COLOR24:		/* ...overlay plane */
d187 1
a187 1
 * Attach a display.
d194 4
a197 4
	struct bwtwo_softc *sc = (struct bwtwo_softc *)self;
	struct confargs *ca = args;
	struct wsemuldisplaydev_attach_args waa;
	int node = ca->ca_ra.ra_node;
d202 4
a205 1
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;
d210 2
a211 4
#if defined(SUN4)
	if (CPU_ISSUN4 && ca->ca_bustype == BUS_OBIO &&
	    ISSET(sc->sc_sunfb.sf_flags, FB_PFOUR)) {
		sc->sc_sunfb.sf_pfour = (volatile u_int32_t *)
d214 1
a214 3
	} else
#endif
	{
d218 1
a218 1
		sc->sc_sunfb.sf_pfour = NULL;
d231 1
a231 1
		if (ISSET(sc->sc_sunfb.sf_flags, FB_PFOUR)) {
d233 22
a254 1
			sc->sc_pixeloffset = PFOUR_BW_OFF;
d267 1
a267 1
obp_name:
d274 11
a284 1
	printf(": %s", nam);
d289 2
a290 2
		int constype = ISSET(sc->sc_sunfb.sf_flags, FB_PFOUR) ?
		    EE_CONS_P4OPT : EE_CONS_BW;
d296 1
a296 1
			isconsole = 1;
d298 1
a298 8
		/*
		 * On sun4 systems without on-board framebuffers (such as
		 * the 4/3xx models), the PROM will accept the EE_CONS_BW
		 * setting although the framebuffer is a P4.
		 * Accept this setting as well.
		 */
		if (eep->eeConsole == EE_CONS_BW)
			isconsole = 1;
d303 1
a303 1
		isconsole = node == fbnode;
d305 11
a315 2
	sc->sc_phys = ca->ca_ra.ra_reg[0];
	sc->sc_bustype = ca->ca_bustype;
d317 2
a318 2
	/* enable video */
	bwtwo_burner(sc, 1, 0);
d320 16
a335 2
	fb_setsize(&sc->sc_sunfb, 1, 1152, 900, node, ca->ca_bustype);
	printf(", %d x %d\n", sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);
d337 4
a340 9
	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(ca->ca_ra.ra_reg,
	    sc->sc_pixeloffset, round_page(sc->sc_sunfb.sf_fbsize));
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, isconsole);

	bwtwo_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	bwtwo_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	bwtwo_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	bwtwo_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;
d342 18
a359 3
	if (isconsole) {
		fbwscons_console_init(&sc->sc_sunfb, &bwtwo_stdscreen, -1,
		    bwtwo_burner);
d361 1
d363 12
a374 3
#if defined(SUN4C) || defined(SUN4M)
	if (sbus)
		sbus_establish(&sc->sc_sd, &sc->sc_sunfb.sf_dev);
d376 24
d401 1
a401 5
	waa.console = isconsole;
	waa.scrdata = &bwtwo_screenlist;
	waa.accessops = &bwtwo_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
d405 2
a406 2
bwtwo_ioctl(v, cmd, data, flags, p)
	void *v;
d412 1
a412 2
	struct bwtwo_softc *sc = v;
	struct wsdisplay_fbinfo *wdf;
d415 3
a417 2
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_SUNBW;
d419 3
a421 9
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width = sc->sc_sunfb.sf_width;
		wdf->depth = sc->sc_sunfb.sf_depth;
		wdf->cmsize = 0;	/* no colormap */
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
d424 2
a425 2
	case WSDISPLAYIO_GETCMAP:
	case WSDISPLAYIO_PUTCMAP:
a427 7
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
d429 1
a429 1
		return (-1);	/* not supported yet */
d431 2
d434 7
a440 1
	return (0);
d448 3
a450 3
bwtwo_mmap(v, offset, prot)
	void *v;
	off_t offset;
d453 1
a453 1
	struct bwtwo_softc *sc = v;
d455 5
a459 1
	if (offset & PGOFSET)
d461 11
d473 10
a482 3
	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys, sc->sc_pixeloffset + offset) |
		    PMAP_NC);
d484 1
d486 1
a486 1
	return (-1);
d489 4
a492 4
void
bwtwo_burner(v, on, flags)
	void *v;
	u_int on, flags;
a493 2
	struct bwtwo_softc *sc = v;
	int s;
d497 5
a501 2
		if (ISSET(sc->sc_sunfb.sf_flags, FB_PFOUR)) {
			fb_pfour_set_video(&sc->sc_sunfb, on);
d504 1
a504 1
		if (on)
d515 1
a515 2
	s = splhigh();
	if (on)
d517 1
a517 1
	else {
a518 47
		if (flags & WSDISPLAY_BURN_VBLANK)
			sc->sc_reg->fbc_ctrl &= ~FBC_TIMING;
	}
	splx(s);
}

int
bwtwo_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
{
	struct bwtwo_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    0, 0, 0, attrp);
	sc->sc_nscreens++;
	return (0);
}

void
bwtwo_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct bwtwo_softc *sc = v;

	sc->sc_nscreens--;
}

int
bwtwo_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
	return (0);
@


1.16.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.16.2.4 2003/03/27 23:49:25 niklas Exp $	*/
d27 5
a31 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.16.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d309 1
a309 1
	fbwscons_init(&sc->sc_sunfb, isconsole ? 0 : RI_CLEAR);
@


1.15
log
@careful off handling in mmap routines
@
text
@d1 1
a1 1
/*	$OpenBSD: bwtwo.c,v 1.14 1997/08/08 08:24:43 downsj Exp $	*/
d518 1
a518 1
		sc->sc_reg->fbc_ctrl |= FBC_VENAB;
@


1.14
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d459 2
@


1.13
log
@Revert back to Theo's eeprom.h.
@
text
@d2 1
a2 1
/*	$NetBSD: bwtwo.c,v 1.26 1996/04/01 17:30:15 christos Exp $ */
a107 4
int		bwtwoopen __P((dev_t, int, int, struct proc *));
int		bwtwoclose __P((dev_t, int, int, struct proc *));
int		bwtwoioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int		bwtwommap __P((dev_t, int, int));
d112 3
d214 2
a215 3
		fb->fb_pfour =
		    (volatile u_int32_t *)mapiodev(ca->ca_ra.ra_reg, 0,
		    sizeof(u_int32_t), ca->ca_bustype);
d218 3
a220 3
		sc->sc_reg =
		    (volatile struct fbcontrol *)mapiodev(ca->ca_ra.ra_reg,
		    BWREG_REG, sizeof(struct fbcontrol), ca->ca_bustype);
d292 2
a293 2
		int constype = (fb->fb_flags & FB_PFOUR) ? EED_CONS_P4 :
		    EED_CONS_BW;
d298 1
a298 1
		if (eep == NULL || eep->ee_diag.eed_console == constype)
d317 1
a317 2
		    mapiodev(ca->ca_ra.ra_reg, sc->sc_pixeloffset,
		    ramsize, ca->ca_bustype);
d326 10
a335 1
		fbrcons_init(fb);
d465 1
a465 2
	return (REG2PHYS(&sc->sc_phys, sc->sc_pixeloffset + off,
	    sc->sc_bustype) | PMAP_NC);
@


1.12
log
@netbsd port, now we merge our changes back in
@
text
@d1 1
d294 2
a295 2
		int constype = (fb->fb_flags & FB_PFOUR) ? EE_CONS_P4OPT :
		    EE_CONS_BW;
d300 1
a300 1
		if (eep == NULL || eep->eeConsole == constype)
@


1.11
log
@fix fb_setsize() to set width/height for P4 frame buffers
now rconsole works on all P4 frame buffers
@
text
@d1 1
a1 1
/*	$NetBSD: bwtwo.c,v 1.15 1995/10/09 15:39:34 pk Exp $ */
d4 1
a4 29
 * Copyright (c) 1995 Theo de Raadt
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
d52 3
d58 1
d64 1
a71 1
#if defined(SUN4)
d74 1
a75 1
#endif
d77 1
d79 2
d82 1
a82 2
#include <sparc/dev/sbusvar.h>
#include "pfour.h"
d89 13
a101 3
	volatile struct bwtworeg *sc_reg;/* control registers */
	struct rom_reg sc_phys;		/* display RAM (phys addr) */
	int	sc_bustype;
d112 6
d119 2
a120 3
struct cfdriver bwtwocd = {
	NULL, "bwtwo", bwtwomatch, bwtwoattach,
	DV_DULL, sizeof(struct bwtwo_softc)
d123 2
a129 3
static void	bwtwoenable __P((struct bwtwo_softc *, int));
static int	bwtwostatus __P((struct bwtwo_softc *));

d145 3
d150 6
d158 20
a177 3
#if NPFOUR > 0
	if (ca->ca_bustype == BUS_PFOUR) {
		if (PFOUR_ID(ra->ra_pfour) == PFOUR_ID_BW)
d179 4
a182 1
		return (0);
d185 2
a186 1
	return (probeget(ra->ra_vaddr, 4) != -1);
d200 9
a208 2
	int isconsole;
	char *nam;
d210 17
a226 3
	sc->sc_fb.fb_driver = &bwtwofbdriver;
	sc->sc_fb.fb_device = &sc->sc_dev;
	sc->sc_fb.fb_type.fb_type = FBTYPE_SUN2BW;
a227 1
	sc->sc_bustype = ca->ca_bustype;
d229 5
d235 25
a259 10
#if NPFOUR > 0
	case BUS_PFOUR:
		node = 0;
		pfour_reset();
		pfour_videosize(ca->ca_ra.ra_pfour,
		    &sc->sc_fb.fb_type.fb_width,
		    &sc->sc_fb.fb_type.fb_height);
		sc->sc_fb.fb_linebytes = sc->sc_fb.fb_type.fb_width / 8;
		nam = "bwtwo";
		break;  
d261 6
a266 10
#endif
	case BUS_OBIO:
#if defined(SUN4M)
		if (cputyp == CPU_SUN4M) {   /* 4m has framebuffer on obio */
			nam = getpropstring(node, "model");
			break;
		}
#endif
#if defined(SUN4)
		node = 0;
d269 1
a269 1
#endif
d271 1
d274 1
a275 1
#endif
d277 1
d281 6
a286 7
	sc->sc_fb.fb_type.fb_depth = 1;
	fb_setsize(&sc->sc_fb, sc->sc_fb.fb_type.fb_depth,
	    1152, 900, node, ca->ca_bustype);

	ramsize = sc->sc_fb.fb_type.fb_height * sc->sc_fb.fb_linebytes;
	sc->sc_fb.fb_type.fb_cmsize = 0;
	sc->sc_fb.fb_type.fb_size = ramsize;
d288 1
a288 1
	    sc->sc_fb.fb_type.fb_width, sc->sc_fb.fb_type.fb_height);
d291 1
a291 1
	if (cputyp == CPU_SUN4) {
d293 2
d299 1
a299 1
		if (eep == NULL || eep->ee_diag.eed_console == EED_CONS_BW)
d305 2
a306 2
#if defined(SUN4C) || defined(SUN4M)
	if (cputyp == CPU_SUN4C || cputyp == CPU_SUN4M)
d308 1
a308 1
#endif
d311 1
a311 1
	 * maps only the video RAM, so in any case we have to map the
d315 1
a315 1
	if ((sc->sc_fb.fb_pixels = ca->ca_ra.ra_vaddr) == NULL && isconsole) {
d317 2
a318 1
		sc->sc_fb.fb_pixels = mapiodev(ca->ca_ra.ra_reg, BWREG_MEM,
a320 2
	sc->sc_reg = (volatile struct bwtworeg *)mapiodev(ca->ca_ra.ra_reg,
	    BWREG_REG, sizeof(struct bwtworeg), ca->ca_bustype);
d323 1
a323 1
	bwtwoenable(sc, 1);
d328 1
a328 1
		fbrcons_init(&sc->sc_fb);
d332 1
d334 1
a334 1
	if (ca->ca_bustype == BUS_SBUS)
d337 37
a373 3
	if ((node == fbnode && cputyp != CPU_SUN4) ||
	    (isconsole && cputyp == CPU_SUN4))
		fb_attach(&sc->sc_fb);
d384 1
a384 1
	if (unit >= bwtwocd.cd_ndevs || bwtwocd.cd_devs[unit] == NULL)
d386 1
d408 1
a408 1
	struct bwtwo_softc *sc = bwtwocd.cd_devs[minor(dev)];
d417 1
a417 1
		bwtwostatus(sc);
d421 1
a421 1
		bwtwoenable(sc, *(int *)data);
d436 1
a436 1
	bwtwoenable(sc, 1);
d448 1
a448 1
	register struct bwtwo_softc *sc = bwtwocd.cd_devs[minor(dev)];
d458 2
a459 1
	return (REG2PHYS(&sc->sc_phys, BWREG_MEM+off, sc->sc_bustype) | PMAP_NC);
d462 2
a463 3

int
bwtwostatus(sc)
d466 12
a477 10
#ifdef SUN4
#if NPFOUR > 0
	if (sc->sc_bustype == BUS_PFOUR)
		return pfourstatus();
#endif
	if (sc->sc_bustype == BUS_OBIO)
		return (lduba(AC_SYSENABLE, ASI_CONTROL) & SYSEN_VIDEO);
#endif
#if defined(SUN4C) || defined(SUN4M)
	return (sc->sc_reg->bw_ctl & CTL_VE);
d479 2
d483 2
a484 2
void
bwtwoenable(sc, on)
d486 1
a486 1
	int on;
d488 8
a495 3
#if NPFOUR > 0
		if (sc->sc_bustype == BUS_PFOUR) {
			pfourenable(on);
d498 1
a498 4
#endif
	if (on) {
#ifdef SUN4
		if (sc->sc_bustype == BUS_OBIO) {
d501 1
a501 7
			return;
		}
#endif
		sc->sc_reg->bw_ctl |= CTL_VE;
	} else {
#ifdef SUN4
		if (sc->sc_bustype == BUS_OBIO) {
d504 3
a506 2
			return;
		}
d508 5
a512 2
		sc->sc_reg->bw_ctl &= ~CTL_VE;
	}
@


1.10
log
@match correctly on pfour
@
text
@d268 1
a268 2
		if (ca->ca_bustype != BUS_PFOUR)
			fbrcons_init(&sc->sc_fb);
@


1.9
log
@new mapdev/()/mapiodev() calling convention uses "struct rom_reg *" to supply
base plus an offset
new dvma routines
@
text
@d158 5
a162 3
	if (ca->ca_bustype == BUS_PFOUR &&
	    PFOUR_ID(ra->ra_pfour) == PFOUR_ID_BW)
		return (1);
@


1.8
log
@fix copyrights
@
text
@d112 1
a112 1
	caddr_t	sc_phys;		/* display RAM (phys addr) */
a175 1
	register struct bwtwo_all *p;
d197 1
d199 7
a209 1

d213 1
a214 1
		break;
d216 2
a251 1
	p = (struct bwtwo_all *)ca->ca_ra.ra_paddr;
d254 2
a255 2
		sc->sc_fb.fb_pixels = mapiodev(p->ba_ram, ramsize,
		    ca->ca_bustype);
d257 2
a258 3
	sc->sc_reg = (volatile struct bwtworeg *)mapiodev((caddr_t)&p->ba_reg,
	    sizeof(p->ba_reg), ca->ca_bustype);
	sc->sc_phys = p->ba_ram;
d361 1
a361 1
	return ((int)sc->sc_phys + off + PMAP_OBIO + PMAP_NC);
@


1.7
log
@rcons does NOT work on p4 bwtwo/cgtwo, probably because of alignment problems?
@
text
@d4 29
@


1.6
log
@correct sun4 calls to fb_attach()
@
text
@d231 2
a232 1
		fbrcons_init(&sc->sc_fb);
@


1.5
log
@pfour bwtwo blanking control
@
text
@d239 2
a240 5
	/*
	 * XXX: this could cause a panic in fb_attach() if more
	 * than one frame buffer device is found on a Sun 4.
	 */
	if (node == fbnode || cputyp == CPU_SUN4)
@


1.4
log
@screenblank for sun4 bwtwo from thorpe
@
text
@d75 1
d128 1
a128 1
#ifdef SUN4
d158 1
d168 1
a335 2
	int on;

d337 9
a345 3
	if (cputyp == CPU_SUN4 && sc->sc_bustype == BUS_OBIO)
		on = lduba(AC_SYSENABLE, ASI_CONTROL) & SYSEN_VIDEO;
	else
a346 2
		on = sc->sc_reg->bw_ctl & CTL_VE;
	return (on);
d354 6
d362 1
a362 1
		if (cputyp == CPU_SUN4 && sc->sc_bustype == BUS_OBIO)
d365 2
a366 1
		else
d368 1
a368 1
			sc->sc_reg->bw_ctl |= CTL_VE;
d371 1
a371 1
		if (cputyp == CPU_SUN4 && sc->sc_bustype == BUS_OBIO)
d374 2
a375 1
		else
d377 1
a377 1
			sc->sc_reg->bw_ctl &= ~CTL_VE;
@


1.3
log
@remove garbage
@
text
@d68 2
d83 1
d105 3
d154 1
d223 1
a223 1
	sc->sc_reg->bw_ctl |= CTL_VE;
d284 1
a284 1
		*(int *)data = (sc->sc_reg->bw_ctl & CTL_VE) != 0;
d288 1
a288 4
		if (*(int *)data)
			sc->sc_reg->bw_ctl |= CTL_VE;
		else
			sc->sc_reg->bw_ctl &= ~CTL_VE;
d303 1
a303 1
	sc->sc_reg->bw_ctl |= CTL_VE;
d326 40
@


1.2
log
@>0 bwtwo units on sun4 possible; no VME32 bwtwo cards; support pfour cards
@
text
@d92 4
a95 5
struct cfdriver bwtwocd =
    { NULL, "bwtwo", bwtwomatch, bwtwoattach,
      DV_DULL, sizeof(struct bwtwo_softc) };

/* XXX we do not handle frame buffer interrupts (do not know how) */
a103 4
extern int (*v_putc)();
extern int nullop();
static int bwtwo_cnputc();
static struct bwtwo_softc *bwcons;
@


1.1
log
@Initial revision
@
text
@d71 1
a121 5
#if defined(SUN4)
	if (cputyp == CPU_SUN4 && cf->cf_unit != 0)
		return (0);
#endif

d126 5
a130 1

a146 1
	int sbus = 1;
d154 10
d165 1
a165 3
	case BUS_VME32:
	case BUS_VME16:
		sbus = node = 0;
d168 1
a176 1

d194 1
a194 1
		if (eep == NULL || eep->eeConsole == EE_CONS_BW)
d213 2
a214 1
		sc->sc_fb.fb_pixels = mapiodev(p->ba_ram, ramsize, ca->ca_bustype);
d216 2
a217 2
	sc->sc_reg = (volatile struct bwtworeg *)
	    mapiodev((caddr_t)&p->ba_reg, sizeof(p->ba_reg), ca->ca_bustype);
d231 1
a231 1
	if (sbus)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
