head	1.26;
access;
symbols
	OPENBSD_6_0:1.25.0.6
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.22.0.18
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.16
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.12
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.10
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.8
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.6
	OPENBSD_5_0:1.22.0.4
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.10
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.6
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.4
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.16.0.10
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.8
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.6
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.4
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.15.0.6
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.13
	UBC:1.10.0.2
	UBC_BASE:1.10
	OPENBSD_3_0:1.8.0.16
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.14
	OPENBSD_2_8:1.8.0.12
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.10
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.8
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.6
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2016.09.01.09.23.42;	author tedu;	state dead;
branches;
next	1.25;
commitid	Q2PxaFNhqAe0Wmla;

1.25
date	2015.03.30.20.30.22;	author miod;	state Exp;
branches;
next	1.24;
commitid	f66FukLLgPJs9j5H;

1.24
date	2015.03.26.18.13.56;	author miod;	state Exp;
branches;
next	1.23;
commitid	GsIAXMVFkJSo2Pn3;

1.23
date	2015.01.14.21.35.43;	author miod;	state Exp;
branches;
next	1.22;
commitid	Y0IGo6SNjICp0EB7;

1.22
date	2010.09.05.18.10.10;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.07.19.54.33;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.26.20.17.27;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.08.17.48.06;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2007.07.01.19.07.45;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.29.09.54.11;	author sobrado;	state Exp;
branches;
next	1.16;

1.16
date	2004.09.29.07.35.11;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.18.47.58;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.02.15.54.22;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.04.30.01.12.29;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.26.43;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.10.00.06.17;	author nordin;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.08.02.24.07;	author art;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	98.10.14.02.23.45;	author deraadt;	state Exp;
branches
	1.8.8.1;
next	1.7;

1.7
date	97.08.08.08.25.20;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.11.23.21.46.17;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	96.08.11.05.34.24;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.01.12.21.43.09;	author chuck;	state Exp;
branches;
next	1.3;

1.3
date	95.12.15.13.56.25;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.20.13.01.10;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.40;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.40;	author deraadt;	state Exp;
branches;
next	;

1.8.8.1
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.8.8.2;

1.8.8.2
date	2002.03.06.02.04.46;	author niklas;	state Exp;
branches;
next	1.8.8.3;

1.8.8.3
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.8.8.4;

1.8.8.4
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.8.8.5;

1.8.8.5
date	2003.06.07.11.14.43;	author ho;	state Exp;
branches;
next	;

1.10.2.1
date	2002.01.31.22.55.22;	author niklas;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: obio.c,v 1.25 2015/03/30 20:30:22 miod Exp $	*/
/*	$NetBSD: obio.c,v 1.37 1997/07/29 09:58:11 fair Exp $	*/

/*
 * Copyright (c) 1993, 1994 Theo de Raadt
 * Copyright (c) 1995, 1997 Paul Kranenburg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#ifdef DEBUG
#include <sys/proc.h>
#include <sys/syslog.h>
#endif

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/pmap.h>
#include <machine/oldmon.h>
#include <machine/cpu.h>
#include <machine/ctlreg.h>
#include <sparc/sparc/asm.h>
#include <sparc/sparc/vaddrs.h>
#include <sparc/sparc/cpuvar.h>
#include <sparc/dev/sbusvar.h>
#include <sparc/dev/vmereg.h>

struct vmebus_softc { 
	struct device	 sc_dev;	/* base device */
	struct vmebusreg *sc_reg; 	/* VME control registers */
	struct vmebusvec *sc_vec;	/* VME interrupt vector */
	struct rom_range *sc_range;	/* ROM range property */
	int		 sc_nrange;
};
struct  vmebus_softc *vmebus_sc;/*XXX*/

struct bus_softc {
	union {
		struct	device scu_dev;		/* base device */
		struct	sbus_softc scu_sbus;	/* obio is another sbus slot */
		struct	vmebus_softc scu_vme;
	} bu;
};


/* autoconfiguration driver */
int	busmatch(struct device *, void *, void *);
void	obioattach(struct device *, struct device *, void *);
void	vmesattach(struct device *, struct device *, void *);
void	vmelattach(struct device *, struct device *, void *);
void	vmeattach(struct device *, struct device *, void *);

int	busprint(void *, const char *);
int	vmeprint(void *, const char *);
int	busattach(struct device *, void *, void *, int);
int	obio_scan(struct device *, void *, void *);
int 	vmes_scan(struct device *, void *, void *);
int 	vmel_scan(struct device *, void *, void *);
void	vmebus_translate(struct device *, struct confargs *, int);
int 	vmeintr(void *);

struct cfattach obio_ca = {
	sizeof(struct bus_softc), busmatch, obioattach
};

struct cfdriver obio_cd = {
	NULL, "obio", DV_DULL
};

struct cfattach vmel_ca = {
	sizeof(struct bus_softc), busmatch, vmelattach
};

struct cfdriver vmel_cd = {
	NULL, "vmel", DV_DULL
};

struct cfattach vmes_ca = {
	sizeof(struct bus_softc), busmatch, vmesattach
};

struct cfdriver vmes_cd = {
	NULL, "vmes", DV_DULL
};

struct cfattach vme_ca = {
	sizeof(struct bus_softc), busmatch, vmeattach
};

struct cfdriver vme_cd = {
	NULL, "vme", DV_DULL
};

struct intrhand **vmeints;

/*
 * 4/110 comment: the 4/110 chops off the top 4 bits of an OBIO address.
 *	this confuses autoconf.  for example, if you try and map
 *	0xfe000000 in obio space on a 4/110 it actually maps 0x0e000000.
 *	this is easy to verify with the PROM.   this causes problems
 *	with devices like "esp0 at obio0 addr 0xfa000000" because the
 *	4/110 treats it as esp0 at obio0 addr 0x0a000000" which is the
 *	address of the 4/110's "sw0" scsi chip.   the same thing happens
 *	between zs1 and zs2.    since the sun4 line is "closed" and
 *	we know all the "obio" devices that will ever be on it we just
 *	put in some special case "if"'s in the match routines of esp,
 *	dma, and zs.
 */

int
busmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	register struct cfdata *cf = vcf;
	register struct confargs *ca = aux;
	register struct romaux *ra = &ca->ca_ra;

	if (CPU_ISSUN4M)
		return (strcmp(cf->cf_driver->cd_name, ra->ra_name) == 0);

	if (!CPU_ISSUN4)
		return (0);

	return (strcmp(cf->cf_driver->cd_name, ra->ra_name) == 0);
}

int
busprint(args, obio)
	void *args;
	const char *obio;
{
	register struct confargs *ca = args;

	if (ca->ca_ra.ra_name == NULL)
		ca->ca_ra.ra_name = "<unknown>";

	if (obio)
		printf("%s at %s", ca->ca_ra.ra_name, obio);

	printf(" addr %p", ca->ca_ra.ra_paddr);

	if (CPU_ISSUN4 && ca->ca_ra.ra_intr[0].int_vec != -1)
		printf(" vec 0x%x", ca->ca_ra.ra_intr[0].int_vec);

	return (UNCONF);
}

int
vmeprint(args, name)
	void *args;
	const char *name;
{
	register struct confargs *ca = args;

	if (name)
		printf("%s at %s", ca->ca_ra.ra_name, name);
	return (UNCONF);
}

void
obioattach(parent, self, args)
	struct device *parent, *self;
	void *args;
{
#if defined(SUN4M)
	register struct bus_softc *sc = (struct bus_softc *)self;
	struct confargs oca, *ca = args;
	register struct romaux *ra = &ca->ca_ra;
	register int node0, node;
	register char *name;
	register const char *sp;
	const char *const *ssp;
	int rlen;
	extern int autoconf_nzs;

	static const char *const special4m[] = {
		/* find these first */
		"eeprom",
		"counter",
#if 0 /* Not all sun4m's have an `auxio' */
		"auxio",
#endif
		"",
		/* place device to ignore here */
		"interrupt",
		NULL
	};
#endif

	if (CPU_ISSUN4) {
		if (self->dv_unit > 0) {
			printf(" unsupported\n");
			return;
		}
		printf("\n");

		(void)config_search(obio_scan, self, args);
		bus_untmp();
	}

#if defined(SUN4M)
	if (!CPU_ISSUN4M)
		return;

	/*
	 * There is only one obio bus (it is in fact one of the SBus slots)
	 * How about VME?
	 */
	if (self->dv_unit > 0) {
		printf(" unsupported\n");
		return;
	}

	printf("\n");

	if (ra->ra_bp != NULL && strcmp(ra->ra_bp->name, "obio") == 0)
		oca.ca_ra.ra_bp = ra->ra_bp + 1;
	else
		oca.ca_ra.ra_bp = NULL;

	node = ra->ra_node;
	rlen = getproplen(node, "ranges");
	if (rlen > 0) {
		sc->bu.scu_sbus.sc_nrange = rlen / sizeof(struct rom_range);
		sc->bu.scu_sbus.sc_range =
			(struct rom_range *)malloc(rlen, M_DEVBUF, M_NOWAIT);
		if (sc->bu.scu_sbus.sc_range == 0)
			panic("obio: PROM ranges too large: %d", rlen);
		(void)getprop(node, "ranges", sc->bu.scu_sbus.sc_range, rlen);
	}

	/*
	 * Loop through ROM children, fixing any relative addresses
	 * and then configuring each device.
	 * We first do the crucial ones, such as eeprom, etc.
	 */
	node0 = firstchild(ra->ra_node);
	for (ssp = special4m ; *(sp = *ssp) != 0; ssp++) {
		if ((node = findnode(node0, sp)) == 0) {
			printf("could not find %s amongst obio devices\n", sp);
			panic(sp);
		}
		if (!romprop(&oca.ca_ra, sp, node))
			continue;

		sbus_translate(self, &oca);
		oca.ca_bustype = BUS_OBIO;
		oca.ca_dmat = ca->ca_dmat;
		config_found(self, (void *)&oca, busprint);
	}

	for (node = node0; node; node = nextsibling(node)) {
		name = getpropstring(node, "name");
		for (ssp = special4m ; (sp = *ssp) != NULL; ssp++)
			if (strcmp(name, sp) == 0)
				break;

		if (sp != NULL || !romprop(&oca.ca_ra, name, node))
			continue;

		if (strcmp(name, "zs") == 0)
			/* XXX - see autoconf.c for this hack */
			autoconf_nzs++;

		/* Translate into parent address spaces */
		sbus_translate(self, &oca);
		oca.ca_bustype = BUS_OBIO;
		oca.ca_dmat = ca->ca_dmat;
		config_found(self, (void *)&oca, busprint);
	}
#endif
}

void
vmesattach(parent, self, args)
	struct device *parent, *self;
	void *args;
{
	if (self->dv_unit > 0 ||
	    (CPU_ISSUN4M && strcmp(parent->dv_cfdata->cf_driver->cd_name, "vme") != 0)) {
		printf(" unsupported\n");
		return;
	}
	printf("\n");

	if (vmeints == NULL) {
		vmeints = malloc(256 * sizeof(struct intrhand *), M_TEMP,
		    M_NOWAIT | M_ZERO);
		if (vmeints == NULL)
			panic("vmesattach: can't allocate intrhand");
	}
	(void)config_search(vmes_scan, self, args);
	bus_untmp();
}

void
vmelattach(parent, self, args)
	struct device *parent, *self;
	void *args;
{
	if (self->dv_unit > 0 ||
	    (CPU_ISSUN4M && strcmp(parent->dv_cfdata->cf_driver->cd_name, "vme") != 0)) {
		printf(" unsupported\n");
		return;
	}
	printf("\n");

	if (vmeints == NULL) {
		vmeints = malloc(256 * sizeof(struct intrhand *), M_TEMP,
		    M_NOWAIT | M_ZERO);
		if (vmeints == NULL)
			panic("vmelattach: can't allocate intrhand");
	}
	(void)config_search(vmel_scan, self, args);
	bus_untmp();
}

void
vmeattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct vmebus_softc *sc = (struct vmebus_softc *)self;
	struct confargs *ca = aux;
	register struct romaux *ra = &ca->ca_ra;
	int node, rlen;
	struct confargs oca;

	if (!CPU_ISSUN4M || self->dv_unit > 0) {
		printf(" unsupported\n");
		return;
	}

	node = ra->ra_node;

	sc->sc_reg = (struct vmebusreg *)
		mapiodev(&ra->ra_reg[0], 0, ra->ra_reg[0].rr_len);
	sc->sc_vec = (struct vmebusvec *)
		mapiodev(&ra->ra_reg[1], 0, ra->ra_reg[1].rr_len);

	/*
	 * Get "range" property, though we don't do anything with it yet.
	 */
	rlen = getproplen(node, "ranges");
	if (rlen > 0) {
		sc->sc_nrange = rlen / sizeof(struct rom_range);
		sc->sc_range =
			(struct rom_range *)malloc(rlen, M_DEVBUF, M_NOWAIT);
		if (sc->sc_range == 0)  
			panic("vme: PROM ranges too large: %d", rlen);
		(void)getprop(node, "ranges", sc->sc_range, rlen);
	}

	vmebus_sc = sc;
	printf(": version 0x%x\n",
	       sc->sc_reg->vmebus_cr & VMEBUS_CR_IMPL);

	if (ra->ra_bp != NULL && strcmp(ra->ra_bp->name, "vme") == 0)
		oca.ca_ra.ra_bp = ra->ra_bp + 1;
	else
		oca.ca_ra.ra_bp = NULL;

	oca.ca_ra.ra_name = "vmes";
	oca.ca_bustype = BUS_MAIN;
	oca.ca_dmat = ca->ca_dmat;
	config_found(self, (void *)&oca, vmeprint);

	oca.ca_ra.ra_name = "vmel";
	oca.ca_bustype = BUS_MAIN;
	oca.ca_dmat = ca->ca_dmat;
	config_found(self, (void *)&oca, vmeprint);
}

void
vmebus_translate(dev, ca, bustype)
	struct device *dev;
	struct confargs *ca;
	int bustype;
{
	struct vmebus_softc *sc = (struct vmebus_softc *)dev;
	register int j;
	int cspace;

	if (sc->sc_nrange == 0)
		panic("vmebus: no ranges");

	/*
	 * Find VMEbus modifier based on address space.
	 * XXX - should not be encoded in `ra_paddr'
	 */
	if (((u_long)ca->ca_ra.ra_paddr & 0xffff0000) == 0xffff0000)
		cspace = VMEMOD_A16_D_S;
	else if (((u_long)ca->ca_ra.ra_paddr & 0xff000000) == 0xff000000)
		cspace = VMEMOD_A24_D_S;
	else
		cspace = VMEMOD_A32_D_S;

	cspace |= (bustype == BUS_VME32) ? VMEMOD_D32 : 0;

	/* Translate into parent address spaces */
	for (j = 0; j < sc->sc_nrange; j++) {
		if (sc->sc_range[j].cspace == cspace) {
#if notyet
			ca->ca_ra.ra_paddr +=
				sc->sc_range[j].poffset;
#endif
			ca->ca_ra.ra_iospace =
				sc->sc_range[j].pspace;
			break;
		}
	}
}

int bt2pmt[] = {
	PMAP_OBIO,
	PMAP_OBIO,
	PMAP_VME16,
	PMAP_VME32,
	PMAP_OBIO 
}; 

int
busattach(parent, vcf, args, bustype)
	struct device *parent;
	void *vcf, *args;
	int bustype;
{
#if defined(SUN4) || defined(SUN4M)
	register struct cfdata *cf = vcf;
	register struct confargs *ca = args;
	struct confargs oca;
	paddr_t pa = (paddr_t)cf->cf_loc[0];
	caddr_t tmp;

	if (bustype == BUS_OBIO && CPU_ISSUN4) {
		/*
		 * avoid sun4m entries which don't have valid PA's.
		 * no point in even probing them. 
		 */
		if (cf->cf_loc[0] == -1) return 0;

		/*
		 * On the 4/100 obio addresses must be mapped at
		 * 0x0YYYYYYY, but alias higher up (the kernel
		 * configuration file uses addresses with the top
		 * four bits set). We ignore 4/[23]00 devices here.
		 */
		if (cpuinfo.cpu_type == CPUTYP_4_100) {
			if ((pa & 0xf0000000) != 0xf0000000)
				return 0;
		}
	}

	oca.ca_ra.ra_paddr = (void *)pa;
	oca.ca_ra.ra_len = 0;
	oca.ca_ra.ra_nreg = 1;
	if (CPU_ISSUN4M)
		vmebus_translate(parent->dv_parent, &oca, bustype);
	else
		oca.ca_ra.ra_iospace = bt2pmt[bustype];

	if (oca.ca_ra.ra_paddr)
		tmp = (caddr_t)mapdev(oca.ca_ra.ra_reg, TMPMAP_VA, 0, NBPG);
	else
		tmp = NULL;
	oca.ca_ra.ra_vaddr = tmp;
	oca.ca_ra.ra_intr[0].int_pri = cf->cf_loc[1];
	if (bustype == BUS_VME16 || bustype == BUS_VME32)
		oca.ca_ra.ra_intr[0].int_vec = cf->cf_loc[2];
	else
		oca.ca_ra.ra_intr[0].int_vec = -1;
	oca.ca_ra.ra_nintr = 1;
	oca.ca_ra.ra_name = cf->cf_driver->cd_name;
	if (ca->ca_ra.ra_bp != NULL &&
	  ((bustype == BUS_VME16 && strcmp(ca->ca_ra.ra_bp->name,"vmes") ==0) ||
	   (bustype == BUS_VME32 && strcmp(ca->ca_ra.ra_bp->name,"vmel") ==0) ||
	   (bustype == BUS_OBIO && strcmp(ca->ca_ra.ra_bp->name,"obio") == 0)))
		oca.ca_ra.ra_bp = ca->ca_ra.ra_bp + 1;
	else
		oca.ca_ra.ra_bp = NULL;
	oca.ca_bustype = bustype;

	if ((*cf->cf_attach->ca_match)(parent, cf, &oca) == 0)
		return 0;

	/*
	 * check if XXmatch routine replaced the temporary mapping with
	 * a real mapping.   If not, then make sure we don't pass the
	 * tmp mapping to the attach routine.
	 */
	if (oca.ca_ra.ra_vaddr == tmp)
		oca.ca_ra.ra_vaddr = NULL; /* wipe out tmp address */
	/*
	 * the match routine will set "ra_len" if it wants us to
	 * establish a mapping for it.
	 * (which won't be seen on future XXmatch calls,
	 * so not as useful as it seems.)
	 */
	if (oca.ca_ra.ra_len)
		oca.ca_ra.ra_vaddr =
		    bus_map(oca.ca_ra.ra_reg, oca.ca_ra.ra_len);

	config_attach(parent, cf, &oca, busprint);
	return 1;
#else
	return 0;
#endif
}

int
obio_scan(parent, child, args)
	struct device *parent;
	void *child, *args;
{
	return busattach(parent, child, args, BUS_OBIO);
}

int
vmes_scan(parent, child, args)
	struct device *parent;
	void *child, *args;
{
	return busattach(parent, child, args, BUS_VME16);
}

int
vmel_scan(parent, child, args)
	struct device *parent;
	void *child, *args;
{
	return busattach(parent, child, args, BUS_VME32);
}

int pil_to_vme[] = {
	-1,	/* pil 0 */
	-1,	/* pil 1 */
	1,	/* pil 2 */
	2,	/* pil 3 */
	-1,	/* pil 4 */
	3,	/* pil 5 */
	-1,	/* pil 6 */
	4,	/* pil 7 */
	-1,	/* pil 8 */
	5,	/* pil 9 */
	-1,	/* pil 10 */
	6,	/* pil 11 */
	-1,	/* pil 12 */
	7,	/* pil 13 */
	-1,	/* pil 14 */
	-1,	/* pil 15 */
};

int
vmeintr(arg)
	void *arg;
{
	int pil = (int)arg, level, vec;
	struct intrhand *ih;
	int r, i = 0;

	level = (pil_to_vme[pil] << 1) | 1;

	if (CPU_ISSUN4) {
		vec = ldcontrolb((caddr_t)(AC_VMEINTVEC | level));
	} else if (CPU_ISSUN4M) {
		vec = vmebus_sc->sc_vec->vmebusvec[level];
	} else
		panic("vme: spurious interrupt");

	if (vec == -1) {
		printf("vme: spurious interrupt\n");
		return 0;
	}

	for (ih = vmeints[vec]; ih; ih = ih->ih_next)
		if (ih->ih_fun) {
			r = (ih->ih_fun)(ih->ih_arg);
			if (r > 0) {
				ih->ih_count.ec_count++;
				return (r);
			}
			i |= r;
		}
	return (i);
}

void
vmeintr_establish(vec, level, ih, ipl_block, name)
	int vec, level;
	struct intrhand *ih;
	int ipl_block;
	const char *name;
{
	struct intrhand *ihs;

	if (vmeints == NULL)
		panic("vmeintr_establish: interrupt vector not allocated");

	if (vec == -1)
		panic("vmeintr_establish: uninitialized vec");

	if (vmeints[vec] == NULL)
		vmeints[vec] = ih;
	else {
		for (ihs = vmeints[vec]; ihs->ih_next; ihs = ihs->ih_next)
			;
		ihs->ih_next = ih;
	}

	if (name != NULL) {
		ih->ih_vec = vec;
		evcount_attach(&ih->ih_count, name, &ih->ih_vec);
	}

	/* ensure the interrupt subsystem will call us at this level */
	for (ihs = intrhand[level]; ihs; ihs = ihs->ih_next)
		if (ihs->ih_fun == vmeintr)
			return;

	ihs = malloc(sizeof(*ihs), M_TEMP, M_NOWAIT | M_ZERO);
	if (ihs == NULL)
		panic("vme_addirq");
	ihs->ih_fun = vmeintr;
	ihs->ih_arg = (void *)level;
	intr_establish(level, ihs, ipl_block, NULL);
}

#define	getpte(va)		lda(va, ASI_PTE)

/*
 * If we can find a mapping that was established by the rom, use it.
 * Else, create a new mapping.
 */
void *
bus_map(pa, len)
	struct rom_reg *pa;
	int len;
{
#ifdef SUN4
	if (CPU_ISSUN4 && len <= NBPG) {
		paddr_t paddr;
		vaddr_t va;
		u_long	pf, pte;
		int pgtype = PMAP_T2PTE_4(pa->rr_iospace);

		if (cpuinfo.cpu_type == CPUTYP_4_100)
			paddr = ((paddr_t)pa->rr_paddr) & 0x0fffffff;
		else
			paddr = (paddr_t)pa->rr_paddr;
		pf = paddr >> PGSHIFT;

		for (va = OLDMON_STARTVADDR; va < OLDMON_ENDVADDR; va += NBPG) {
			pte = getpte(va);
			if ((pte & PG_V) != 0 && (pte & PG_TYPE) == pgtype &&
			    (pte & PG_PFNUM) == pf)
				return ((void *)
				    (va | ((u_long)pa->rr_paddr & PGOFSET)) );
					/* note: preserve page offset */
		}
	}
#endif

	return mapiodev(pa, 0, len);
}

void
bus_untmp()
{
	pmap_remove(pmap_kernel(), TMPMAP_VA, TMPMAP_VA+NBPG);
	pmap_update(pmap_kernel());
}
@


1.25
log
@Add a bus_dma_tag_t for DVMA usage, suitable for use for devices not sitting
behind a sun4m iommu.

Move the existing dvma routines from vm_machdep.c to this new dvma.c; this
allows for a few declarations to be removed from public headers.

Extend the device attachment arguments (struct confargs) to pass a
bus_dma_tag_t. mainbus receives the dvma bus_dma_tag_t, and devices pass the
tag unchanged to their children, except for iommu(4) which replaces it with
its own.

Change the few sun4m-only drivers to pick the bus_dma_tag_t from confargs
rather than assume iommu; this allows qlw(4) to attach and work on sun4c.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: obio.c,v 1.24 2015/03/26 18:13:56 miod Exp $	*/
@


1.24
log
@de-static
@
text
@d1 1
a1 1
/*	$OpenBSD: obio.c,v 1.23 2015/01/14 21:35:43 miod Exp $	*/
d276 2
a277 1
		(void) config_found(self, (void *)&oca, busprint);
d296 2
a297 1
		(void) config_found(self, (void *)&oca, busprint);
d393 2
a394 1
	(void)config_found(self, (void *)&oca, vmeprint);
d398 2
a399 1
	(void)config_found(self, (void *)&oca, vmeprint);
@


1.23
log
@Don't forget to register event counter for VME interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: obio.c,v 1.22 2010/09/05 18:10:10 kettenis Exp $	*/
d74 14
a87 14
static int	busmatch(struct device *, void *, void *);
static void	obioattach(struct device *, struct device *, void *);
static void	vmesattach(struct device *, struct device *, void *);
static void	vmelattach(struct device *, struct device *, void *);
static void	vmeattach(struct device *, struct device *, void *);

int		busprint(void *, const char *);
int		vmeprint(void *, const char *);
static int	busattach(struct device *, void *, void *, int);
int		obio_scan(struct device *, void *, void *);
int 		vmes_scan(struct device *, void *, void *);
int 		vmel_scan(struct device *, void *, void *);
void		vmebus_translate(struct device *, struct confargs *, int);
int 		vmeintr(void *);
@


1.22
log
@Remove bogus LHS casts.  makes gcc4 happy.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: obio.c,v 1.21 2010/06/07 19:54:33 miod Exp $	*/
d632 5
@


1.21
log
@Rework the way onboard devices attach on Sun 4/110 systems (which only have a
28 bit address bus) by reusing the regular sun4 configuration stanzas (with
the upper four bits set in the device addresses), and clearing them when
searching for a PROM mapping.
This makes the obio autoconf code simpler, and all knowledge of the 4/110
specifics is now contained in a single file (dev/obio.c).

ok todd@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: obio.c,v 1.20 2009/10/26 20:17:27 deraadt Exp $	*/
d428 1
a428 1
			(int)ca->ca_ra.ra_paddr +=
d431 1
a431 1
			(int)ca->ca_ra.ra_iospace =
@


1.20
log
@Do not do strncmp comparisons on dv_xname because longer device names which
look similar could arrive in the future.  Instead, compare directly against
dv_cfdata->cf_driver->cd_name
Issue originally spotted by miod
@
text
@d1 1
a1 1
/*	$OpenBSD: obio.c,v 1.19 2007/10/08 17:48:06 krw Exp $	*/
d123 13
d456 1
a459 1

d468 3
a470 4
		 * 0x0YYYYYYY, but alias higher up (we avoid the
		 * alias condition because it causes pmap difficulties)
		 * XXX: We also assume that 4/[23]00 obio addresses
		 * must be 0xZYYYYYYY, where (Z != 0)
d472 4
a475 6
		if (cpuinfo.cpu_type == CPUTYP_4_100 &&
		    (cf->cf_loc[0] & 0xf0000000))
			return 0;
		if (cpuinfo.cpu_type != CPUTYP_4_100 &&
		    !(cf->cf_loc[0] & 0xf0000000))
			return 0;
d478 1
a478 1
	oca.ca_ra.ra_paddr = (void *)cf->cf_loc[0];
d658 1
a658 1

d660 3
a662 1
		u_long	pf = (u_long)(pa->rr_paddr) >> PGSHIFT;
d664 6
a669 1
		u_long	va, pte;
d680 1
@


1.19
log
@A few trailing bzero/memset -> M_ZERO occurrences, cast removal and
size(*p) usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: obio.c,v 1.18 2007/07/01 19:07:45 miod Exp $	*/
d293 1
a293 1
	    (CPU_ISSUN4M && strncmp(parent->dv_xname, "vme", 3) != 0)) {
d315 1
a315 1
	    (CPU_ISSUN4M && strncmp(parent->dv_xname, "vme", 3) != 0)) {
@


1.18
log
@Use mapiodev() instead of mapdev() when applicable. This is just syntactic
sugar.
@
text
@d1 1
a1 1
/*	$OpenBSD: obio.c,v 1.17 2007/05/29 09:54:11 sobrado Exp $	*/
d300 2
a301 2
		vmeints = (struct intrhand **)malloc(256 *
		    sizeof(struct intrhand *), M_TEMP, M_NOWAIT);
a303 1
		bzero(vmeints, 256 * sizeof(struct intrhand *));
d322 2
a323 2
		vmeints = (struct intrhand **)malloc(256 *
		    sizeof(struct intrhand *), M_TEMP, M_NOWAIT);
a325 1
		bzero(vmeints, 256 * sizeof(struct intrhand *));
d629 1
a629 2
	ihs = (struct intrhand *)malloc(sizeof(struct intrhand),
	    M_TEMP, M_NOWAIT);
a631 1
	bzero(ihs, sizeof *ihs);
@


1.17
log
@use the right capitalization for `SBus'

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: obio.c,v 1.16 2004/09/29 07:35:11 miod Exp $	*/
d352 1
a352 1
		mapdev(&ra->ra_reg[0], 0, 0, ra->ra_reg[0].rr_len);
d354 1
a354 1
		mapdev(&ra->ra_reg[1], 0, 0, ra->ra_reg[1].rr_len);
@


1.16
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: obio.c,v 1.15 2003/06/02 18:47:58 deraadt Exp $	*/
d221 1
a221 1
	 * There is only one obio bus (it is in fact one of the Sbus slots)
@


1.15
log
@remove terms 3 (and 4 in some places) where i am the author
@
text
@d1 1
a1 1
/*	$OpenBSD: obio.c,v 1.14 2003/06/02 15:54:22 deraadt Exp $	*/
d575 1
a575 1
	int i = 0;
d592 8
a599 2
		if (ih->ih_fun)
			i += (ih->ih_fun)(ih->ih_arg);
d604 1
a604 1
vmeintr_establish(vec, level, ih, ipl_block)
d608 1
d638 1
a638 1
	intr_establish(level, ihs, ipl_block);
@


1.14
log
@some license cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: obio.c,v 1.13 2002/04/30 01:12:29 art Exp $	*/
d17 1
a17 1
 * 4. The name of the author may not be used to endorse or promote products
@


1.13
log
@Fix an ancient problem in how sparc interrupts are handled.

There are many interrupt handlers that assume that they don't need to do
any spl protection in their code because the interrupt of some level can't
be interrupted by an interrupt of the same level. The problem is that some
interrupt handlers have hardware levels that are lower then their "software"
levels.

Fix this by adding an additional field to struct intrhand that specifies which
"software" level an interrupt handler has and blocks that level while handling
the interrupt. This new field is initialized in intr_establish which gets
an additional argument (which can be -1 meaning that the interrupt handler
doesn't need to block any additional level).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: obio.c,v 1.12 2002/03/14 01:26:43 millert Exp $	*/
a16 3
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Theo de Raadt.
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: obio.c,v 1.11 2002/01/10 00:06:17 nordin Exp $	*/
d601 1
a601 1
vmeintr_establish(vec, level, ih)
d604 1
d634 1
a634 1
	intr_establish(level, ihs);
@


1.11
log
@Check result from malloc(9) when using M_NOWAIT. jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: obio.c,v 1.10 2001/12/08 02:24:07 art Exp $	*/
d77 14
a90 14
static int	busmatch __P((struct device *, void *, void *));
static void	obioattach __P((struct device *, struct device *, void *));
static void	vmesattach __P((struct device *, struct device *, void *));
static void	vmelattach __P((struct device *, struct device *, void *));
static void	vmeattach __P((struct device *, struct device *, void *));

int		busprint __P((void *, const char *));
int		vmeprint __P((void *, const char *));
static int	busattach __P((struct device *, void *, void *, int));
int		obio_scan __P((struct device *, void *, void *));
int 		vmes_scan __P((struct device *, void *, void *));
int 		vmel_scan __P((struct device *, void *, void *));
void		vmebus_translate __P((struct device *, struct confargs *, int));
int 		vmeintr __P((void *));
@


1.10
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: obio.c,v 1.9 2001/11/06 19:53:16 miod Exp $	*/
d305 2
d328 2
@


1.10.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: obio.c,v 1.11 2002/01/10 00:06:17 nordin Exp $	*/
a304 2
		if (vmeints == NULL)
			panic("vmesattach: can't allocate intrhand");
a325 2
		if (vmeints == NULL)
			panic("vmelattach: can't allocate intrhand");
@


1.10.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: obio.c,v 1.10.2.1 2002/01/31 22:55:22 niklas Exp $	*/
d77 14
a90 14
static int	busmatch(struct device *, void *, void *);
static void	obioattach(struct device *, struct device *, void *);
static void	vmesattach(struct device *, struct device *, void *);
static void	vmelattach(struct device *, struct device *, void *);
static void	vmeattach(struct device *, struct device *, void *);

int		busprint(void *, const char *);
int		vmeprint(void *, const char *);
static int	busattach(struct device *, void *, void *, int);
int		obio_scan(struct device *, void *, void *);
int 		vmes_scan(struct device *, void *, void *);
int 		vmel_scan(struct device *, void *, void *);
void		vmebus_translate(struct device *, struct confargs *, int);
int 		vmeintr(void *);
d601 1
a601 1
vmeintr_establish(vec, level, ih, ipl_block)
a603 1
	int ipl_block;
d633 1
a633 1
	intr_establish(level, ihs, ipl_block);
@


1.9
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: obio.c,v 1.8 1998/10/14 02:23:45 deraadt Exp $	*/
d666 1
@


1.8
log
@pretty print message
@
text
@d1 1
a1 1
/*	$OpenBSD: obio.c,v 1.7 1997/08/08 08:25:20 downsj Exp $	*/
d45 1
a45 1
#include <vm/vm.h>
@


1.8.8.1
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 1
a45 1
#include <uvm/uvm_extern.h>
@


1.8.8.2
log
@Merge in trunk
@
text
@a304 2
		if (vmeints == NULL)
			panic("vmesattach: can't allocate intrhand");
a325 2
		if (vmeints == NULL)
			panic("vmelattach: can't allocate intrhand");
a665 1
	pmap_update(pmap_kernel());
@


1.8.8.3
log
@Merge in -current from about a week ago
@
text
@d77 5
a81 5
static int	busmatch(struct device *, void *, void *);
static void	obioattach(struct device *, struct device *, void *);
static void	vmesattach(struct device *, struct device *, void *);
static void	vmelattach(struct device *, struct device *, void *);
static void	vmeattach(struct device *, struct device *, void *);
d83 8
a90 8
int		busprint(void *, const char *);
int		vmeprint(void *, const char *);
static int	busattach(struct device *, void *, void *, int);
int		obio_scan(struct device *, void *, void *);
int 		vmes_scan(struct device *, void *, void *);
int 		vmel_scan(struct device *, void *, void *);
void		vmebus_translate(struct device *, struct confargs *, int);
int 		vmeintr(void *);
@


1.8.8.4
log
@Sync the SMP branch with 3.3
@
text
@d601 1
a601 1
vmeintr_establish(vec, level, ih, ipl_block)
a603 1
	int ipl_block;
d633 1
a633 1
	intr_establish(level, ihs, ipl_block);
@


1.8.8.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: obio.c,v 1.8.8.4 2003/03/27 23:49:25 niklas Exp $	*/
d17 4
a20 1
 * 3. The name of the author may not be used to endorse or promote products
@


1.7
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d156 1
a156 1
		printf("[%s at %s]", ca->ca_ra.ra_name, obio);
@


1.6
log
@added const to second parameter of cfprint_t routines
@
text
@d1 2
a2 1
/*	$NetBSD: obio.c,v 1.24 1996/05/18 12:22:49 mrg Exp $	*/
d6 1
a6 1
 * Copyright (c) 1995 Paul Kranenburg
d54 1
d56 10
d71 1
a72 1
#define sc_dev	bu.scu_dev
d75 1
d81 1
d84 1
a85 1
void *		bus_map __P((struct rom_reg *, int, int));
d89 1
d116 8
d132 1
a132 1
	struct cfdata *cf = vcf;
d166 11
d191 1
d198 1
d200 1
d227 1
a227 1
	if (sc->sc_dev.dv_unit > 0) {
d239 10
a248 2
	sc->bu.scu_sbus.sc_range = ra->ra_range;
	sc->bu.scu_sbus.sc_nrange = ra->ra_nrange;
d266 1
a266 1
		(void) config_found(&sc->sc_dev, (void *)&oca, busprint);
d285 1
a285 1
		(void) config_found(&sc->sc_dev, (void *)&oca, busprint);
d295 2
a296 1
	if (CPU_ISSUN4M || self->dv_unit > 0) {
d316 2
a317 1
	if (CPU_ISSUN4M || self->dv_unit > 0) {
d332 102
d435 1
a435 1
busattach(parent, child, args, bustype)
d437 1
a437 1
	void *args, *child;
d440 2
a441 2
#if defined(SUN4)
	struct cfdata *cf = child;
d461 2
a462 1
		if (cpumod == SUN4_100 && (cf->cf_loc[0] & 0xf0000000))
d464 2
a465 1
		if (cpumod != SUN4_100 && !(cf->cf_loc[0] & 0xf0000000))
a468 6
	if (parent->dv_cfdata->cf_driver->cd_indirect) {
		printf(" indirect devices not supported\n");
		return 0;
	}

	oca.ca_ra.ra_iospace = -1;
d472 5
d478 1
a478 2
		tmp = (caddr_t)bus_tmp(oca.ca_ra.ra_paddr,
		    bustype);
d516 1
a516 2
		    bus_map(oca.ca_ra.ra_reg,
		    oca.ca_ra.ra_len, oca.ca_bustype);
d572 1
a572 1
	int level = (int)arg, vec;
d576 7
a582 2
#ifdef DIAGNOSTIC
	if (!CPU_ISSUN4) {
a583 2
	}
#endif
a584 2
	vec = ldcontrolb((caddr_t)
	    (AC_VMEINTVEC | (pil_to_vme[level] << 1) | 1));
d603 2
a604 4
	if (!CPU_ISSUN4) {
		panic("vmeintr_establish: not supported on cpu-type %d",
		      cputyp);
	}
d607 1
a607 1
		panic("vmeintr_establish: uninitialized vec\n");
d639 1
a639 1
bus_map(pa, len, bustype)
a641 1
	int bustype;
a642 15
	u_long	pf = (u_long)(pa->rr_paddr) >> PGSHIFT;
	u_long	va, pte;
	int pgtype = -1;

	switch (bt2pmt[bustype]) {
	case PMAP_OBIO:
		pgtype = PG_OBIO;
		break;
	case PMAP_VME32:
		pgtype = PG_VME32;
		break;
	case PMAP_VME16:
		pgtype = PG_VME16;
		break;
	}
d644 5
a648 1
	if (len <= NBPG) {
a657 10
	return mapiodev(pa, 0, len, bustype);
}

void *
bus_tmp(pa, bustype)
	void *pa;
	int bustype;
{
	vm_offset_t addr = (vm_offset_t)pa & ~PGOFSET;
	int pmtype = bt2pmt[bustype];
d659 1
a659 4
	pmap_enter(pmap_kernel(), TMPMAP_VA,
		   addr | pmtype | PMAP_NC,
		   VM_PROT_READ | VM_PROT_WRITE, 1);
	return ((void *)(TMPMAP_VA | ((u_long) pa & PGOFSET)) );
@


1.5
log
@netbsd port, now we merge our changes back in
@
text
@d69 1
a69 1
int		busprint __P((void *, char *));
d125 1
a125 1
	char *obio;
@


1.4
log
@improved handling of mapping of devices who's registers do not reside on
page boundaries:
 - change bus_tmp() to include the offset from the start of page in the
	returned KVA [rather than forcing each driver to add it back in
	individually]
 - changed bus_map() to include the offset from the start of page in the
	the returned value if a mapping is found in the PROM's KVA area
 - clarified a few comments
@
text
@d1 1
a1 1
/*	$NetBSD: obio.c,v 1.15 1995/05/27 08:12:51 pk Exp $	*/
d5 1
d35 1
d53 1
d56 5
a60 2
	struct	device sc_dev;		/* base device */
	int	nothing;
d69 14
a82 2
struct cfdriver obiocd = { NULL, "obio", busmatch, obioattach,
	DV_DULL, sizeof(struct bus_softc)
d84 3
a86 2
struct cfdriver vmelcd = { NULL, "vmel", busmatch, vmelattach,
	DV_DULL, sizeof(struct bus_softc)
d88 3
a90 2
struct cfdriver vmescd = { NULL, "vmes", busmatch, vmesattach,
	DV_DULL, sizeof(struct bus_softc)
d93 10
a102 1
static int	busattach __P((struct device *, void *, void *, int));
d113 4
a116 1
	if (cputyp != CPU_SUN4)
d118 1
d131 1
d134 4
a137 2
	printf(" addr 0x%x", ca->ca_ra.ra_paddr);
	if (ca->ca_ra.ra_intr[0].int_vec != -1)
d139 1
d143 142
d288 1
a288 1
	void *child, *args;
d291 1
a292 1
	register struct bus_softc *sc = (struct bus_softc *)parent;
d297 8
a304 1
	if (bustype == BUS_OBIO && cputyp == CPU_SUN4) {
d312 4
a315 4
		if (cpumod==SUN4_100 && (cf->cf_loc[0] & 0xf0000000))
			return (0);
		if (cpumod!=SUN4_100 && !(cf->cf_loc[0] & 0xf0000000))
			return (0);
d320 1
a320 1
		return (0);
d327 5
a331 3
	tmp = NULL;
	if (oca.ca_ra.ra_paddr != (void *)-1)
		tmp = bus_tmp(oca.ca_ra.ra_paddr, bustype);
d338 1
a338 3
	oca.ca_ra.ra_nintr = 0;
	if (oca.ca_ra.ra_intr[0].int_pri != -1)
		oca.ca_ra.ra_nintr = 1;
a339 1
	oca.ca_ra.ra_bp = NULL;
d341 3
a343 3
	    ((bustype == BUS_VME16 && strcmp(ca->ca_ra.ra_bp->name, "vmes") == 0) ||
	    (bustype == BUS_VME32 && strcmp(ca->ca_ra.ra_bp->name, "vmel") == 0) ||
	    (bustype == BUS_OBIO && strcmp(ca->ca_ra.ra_bp->name, "obio") == 0)))
d345 2
d349 2
a350 2
	if ((*cf->cf_driver->cd_match)(parent, cf, &oca) == 0)
		return (0);
d353 3
a355 3
	 * check if XXmatch() replaced the temporary mapping with 
	 * a real mapping.  If not, then make sure we don't pass the
 	 * tmp mapping to the attach routine.
d360 1
a360 1
	 * the match routine will set "ra_len" if it wants us to 
d366 2
a367 1
		oca.ca_ra.ra_vaddr = bus_map(oca.ca_ra.ra_paddr,
d371 4
a374 1
	return (1);
a384 17
void
obioattach(parent, self, args)
	struct device *parent, *self;
	void *args;
{
	if (self->dv_unit > 0) {
		printf(" unsupported\n");
		return;
	}
	printf("\n");

	(void)config_search(obio_scan, self, args);
	bus_untmp();
}

struct intrhand **vmeints;

a392 20
void
vmesattach(parent, self, args)
	struct device *parent, *self;
	void *args;
{
	if (self->dv_unit > 0) {
		printf(" unsupported\n");
		return;
	}
	printf("\n");

	if (vmeints == NULL) {
		vmeints = (struct intrhand **)malloc(256 *
		    sizeof(struct intrhand *), M_TEMP, M_NOWAIT);
		bzero(vmeints, 256 * sizeof(struct intrhand *));
	}
	(void)config_search(vmes_scan, self, args);
	bus_untmp();
}

a400 20
void
vmelattach(parent, self, args)
	struct device *parent, *self;
	void *args;
{
	if (self->dv_unit > 0) {
		printf(" unsupported\n");
		return;
	}
	printf("\n");

	if (vmeints == NULL) {
		vmeints = (struct intrhand **)malloc(256 *
		    sizeof(struct intrhand *), M_TEMP, M_NOWAIT);
		bzero(vmeints, 256 * sizeof(struct intrhand *));
	}
	(void)config_search(vmel_scan, self, args);
	bus_untmp();
}

d428 8
a435 1
	vec = ldcontrolb(AC_VMEINTVEC | (pil_to_vme[level] << 1) | 1);
d438 1
a438 1
		return (0);
d451 1
a451 1
{	
d454 5
d493 1
a493 1
	void *pa;
d497 1
a497 2
	struct rom_reg rr;
	u_long	pf = (u_long)pa >> PGSHIFT;
d499 1
a499 1
	int pgtype;
d518 2
a519 1
				return ((void *)(va | ((u_long)pa & PGOFSET)));
d523 1
a523 2
	rr.rr_paddr = pa;
	return mapiodev(&rr, 0, len, bustype);
d535 2
a536 2
	    addr | pmtype | PMAP_NC,
	    VM_PROT_READ | VM_PROT_WRITE, 1);
@


1.3
log
@new mapdev/()/mapiodev() calling convention uses "struct rom_reg *" to supply
base plus an offset
new dvma routines
@
text
@d166 3
a168 2
	 * check if XXmatch() replaced the temporary
	 * mapping with a real mapping.
d170 2
a171 2
	if (tmp == oca.ca_ra.ra_vaddr)
		oca.ca_ra.ra_vaddr = NULL;
d173 2
a174 1
	 * or if it has asked us to create a mapping..
d373 2
a374 1
				return ((void *)va);
d392 1
a392 1
	return ((void *)TMPMAP_VA);
@


1.2
log
@obio.c
@
text
@d349 1
d374 2
a375 1
	return mapiodev(pa, len, bustype);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: obio.c,v 1.16 1995/08/18 08:20:26 pk Exp $	*/
a74 4
void *		bus_map __P((void *, int, int));
void *		bus_tmp __P((void *, int));
void		bus_untmp __P((void));

d100 1
a100 1
	printf(" addr %x", ca->ca_ra.ra_paddr);
a105 1

d109 1
a109 1
	void *args, *child;
d127 1
a127 1
			return 0;
d129 1
a129 1
			return 0;
d134 1
a134 1
		return 0;
d142 2
a143 3
	if (oca.ca_ra.ra_paddr)
		tmp = bus_tmp(oca.ca_ra.ra_paddr,
		    bustype);
d150 3
a152 1
	oca.ca_ra.ra_nintr = 1;
d154 1
d156 3
a158 3
	  ((bustype == BUS_VME16 && strcmp(ca->ca_ra.ra_bp->name,"vmes") ==0) ||
	   (bustype == BUS_VME32 && strcmp(ca->ca_ra.ra_bp->name,"vmel") ==0) ||
	   (bustype == BUS_OBIO && strcmp(ca->ca_ra.ra_bp->name,"obio") == 0)))
a159 2
	else
		oca.ca_ra.ra_bp = NULL;
d163 1
a163 1
		return 0;
d166 2
a167 2
	 * check if XXmatch routine replaced the
	 * temporary mapping with a real mapping.
d177 1
a177 2
		oca.ca_ra.ra_vaddr =
		    bus_map(oca.ca_ra.ra_paddr,
d181 1
a181 1
	return 1;
d295 1
a295 1
		return 0;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
