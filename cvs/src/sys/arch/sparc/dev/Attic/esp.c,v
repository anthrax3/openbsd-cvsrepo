head	1.37;
access;
symbols
	OPENBSD_6_0:1.36.0.6
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.36.0.4
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.34.0.6
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.33.0.14
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.12
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.10
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.8
	OPENBSD_5_0:1.33.0.6
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.33.0.4
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.2
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.27.0.4
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.26.0.2
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.25.0.4
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.24.0.6
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.4
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.23.0.6
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.4
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.2
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.21.0.6
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.21
	SMP_SYNC_B:1.21
	OPENBSD_3_5:1.21.0.4
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.19
	UBC:1.17.0.4
	UBC_BASE:1.17
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.4
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.15.0.8
	OPENBSD_2_7_BASE:1.15
	SMP:1.15.0.6
	SMP_BASE:1.15
	kame_19991208:1.15
	OPENBSD_2_6:1.15.0.4
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.15.0.2
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.13.0.4
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2016.09.01.09.23.41;	author tedu;	state dead;
branches;
next	1.36;
commitid	Q2PxaFNhqAe0Wmla;

1.36
date	2015.03.29.15.41.15;	author miod;	state Exp;
branches;
next	1.35;
commitid	jQD16v33i4m40exZ;

1.35
date	2015.03.28.19.08.23;	author miod;	state Exp;
branches;
next	1.34;
commitid	FzgIPoV06VfQphpM;

1.34
date	2014.01.21.03.42.21;	author dlg;	state Exp;
branches;
next	1.33;

1.33
date	2010.07.10.19.32.24;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2010.06.28.18.31.01;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2010.06.27.05.52.01;	author beck;	state Exp;
branches;
next	1.30;

1.30
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.29;

1.29
date	2010.06.07.19.54.33;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2009.10.26.20.17.27;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.26;

1.26
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.01.16.11.19;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2006.06.02.20.00.54;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.02.16.42.37;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2004.09.29.07.35.11;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.05.12.27.02;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.11.19.20.26;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2002.04.30.01.12.29;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.26.42;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.27.04.01.42;	author jason;	state Exp;
branches
	1.17.4.1;
next	1.16;

1.16
date	2000.06.12.06.10.46;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	99.02.28.19.12.33;	author jason;	state Exp;
branches
	1.15.6.1;
next	1.14;

1.14
date	98.11.11.00.25.58;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	98.01.28.17.21.47;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	98.01.14.18.30.10;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	97.09.17.06.47.08;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	97.08.08.08.25.00;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	96.11.23.21.46.15;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	96.08.11.05.34.15;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	95.12.15.13.56.21;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	95.11.21.13.02.12;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	95.10.28.14.50.16;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.10.23.06.08.43;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.10.19.11.22.25;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.18.17.20.12;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.39;	author deraadt;	state Exp;
branches;
next	;

1.15.6.1
date	2001.05.14.21.37.04;	author niklas;	state Exp;
branches;
next	1.15.6.2;

1.15.6.2
date	2001.10.31.03.07.56;	author nate;	state Exp;
branches;
next	1.15.6.3;

1.15.6.3
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.15.6.4;

1.15.6.4
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.15.6.5;

1.15.6.5
date	2003.06.07.11.14.42;	author ho;	state Exp;
branches;
next	;

1.17.4.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	1.17.4.2;

1.17.4.2
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: esp.c,v 1.36 2015/03/29 15:41:15 miod Exp $	*/
/*	$NetBSD: esp.c,v 1.69 1997/08/27 11:24:18 bouyer Exp $	*/

/*
 * Copyright (c) 1997 Jason R. Thorpe.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project
 *	by Jason R. Thorpe.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1996 Charles M. Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles M. Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1994 Peter Galbavy
 * Copyright (c) 1995 Paul Kranenburg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Based on aic6360 by Jarle Greipsland
 *
 * Acknowledgements: Many of the algorithms used in this driver are
 * inspired by the work of Julian Elischer (julian@@tfs.com) and
 * Charles Hannum (mycroft@@duality.gnu.ai.mit.edu).  Thanks a million!
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/buf.h>
#include <sys/proc.h>
#include <sys/queue.h>
#include <sys/malloc.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/scsi_message.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>

#include <dev/ic/ncr53c9xreg.h>
#include <dev/ic/ncr53c9xvar.h>

#include <sparc/dev/sbusvar.h>
#include <sparc/dev/dmareg.h>
#include <sparc/dev/dmavar.h>
#include <sparc/dev/espvar.h>

void	espattach(struct device *, struct device *, void *);
int	espmatch(struct device *, void *, void *);

/* Linkup to the rest of the kernel */
struct cfattach esp_ca = {
	sizeof(struct esp_softc), espmatch, espattach
};

/*
 * Functions and the switch for the MI code.
 */
u_char	esp_read_reg(struct ncr53c9x_softc *, int);
void	esp_write_reg(struct ncr53c9x_softc *, int, u_char);
u_char	esp_rdreg1(struct ncr53c9x_softc *, int);
void	esp_wrreg1(struct ncr53c9x_softc *, int, u_char);
int	esp_dma_isintr(struct ncr53c9x_softc *);
void	esp_dma_reset(struct ncr53c9x_softc *);
int	esp_dma_intr(struct ncr53c9x_softc *);
int	esp_dma_setup(struct ncr53c9x_softc *, caddr_t *,
	    size_t *, int, size_t *);
void	esp_dma_go(struct ncr53c9x_softc *);
void	esp_dma_stop(struct ncr53c9x_softc *);
int	esp_dma_isactive(struct ncr53c9x_softc *);

struct ncr53c9x_glue esp_glue = {
	esp_read_reg,
	esp_write_reg,
	esp_dma_isintr,
	esp_dma_reset,
	esp_dma_intr,
	esp_dma_setup,
	esp_dma_go,
	esp_dma_stop,
	esp_dma_isactive,
	NULL,			/* gl_clear_latched_intr */
};

#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
struct ncr53c9x_glue esp_glue1 = {
	esp_rdreg1,
	esp_wrreg1,
	esp_dma_isintr,
	esp_dma_reset,
	esp_dma_intr,
	esp_dma_setup,
	esp_dma_go,
	esp_dma_stop,
	esp_dma_isactive,
	NULL,			/* gl_clear_latched_intr */
};
#endif

int
espmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	if (ca->ca_bustype == BUS_SBUS) {
		if (!sbus_testdma((struct sbus_softc *)parent, ca))
			return (0);

		if (strcmp("SUNW,fas", ra->ra_name) == 0 ||
		    strcmp("ptscII", ra->ra_name) == 0)
			return (1);
	}
#endif

	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
		return (0);

#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	if (ca->ca_bustype == BUS_SBUS)
		return (1);
#endif
#ifdef SUN4
	if (cpuinfo.cpu_type == CPUTYP_4_100)
		return (0);
#endif
	ra->ra_len = NBPG;
	return (probeget(ra->ra_vaddr, 1) != -1);
}

/*
 * Attach this instance, and then all the sub-devices
 */
void
espattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	register struct confargs *ca = aux;
	struct esp_softc *esc = (void *)self;
	struct ncr53c9x_softc *sc = &esc->sc_ncr53c9x;
	struct bootpath *bp;
	int dmachild;
	unsigned int uid = 0;

	/*
	 * If no interrupts properties, bail out: this might happen
	 * on the Sparc X terminal.
	 */
	if (ca->ca_ra.ra_nintr != 1) {
		printf(": expected 1 interrupt, got %d\n", ca->ca_ra.ra_nintr);
		return;
	}

	esc->sc_pri = ca->ca_ra.ra_intr[0].int_pri;
	printf(" pri %d", esc->sc_pri);

	/* Other settings */
	esc->sc_node = ca->ca_ra.ra_node;
	if (ca->ca_bustype == BUS_SBUS) {
		sc->sc_id = getpropint(esc->sc_node, "initiator-id", 7);
		sc->sc_freq = getpropint(esc->sc_node, "clock-frequency", -1);
	} else {
		sc->sc_id = 7;
		sc->sc_freq = 24000000;
	}
	if (sc->sc_freq < 0)
		sc->sc_freq = ((struct sbus_softc *)
		    sc->sc_dev.dv_parent)->sc_clockfreq;

	/* gimme MHz */
	sc->sc_freq /= 1000000;

#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	if (ca->ca_bustype == BUS_SBUS &&
	    strcmp("SUNW,fas", ca->ca_ra.ra_name) == 0) {
		struct dma_softc *dsc;

		/*
		 * fas has 2 register spaces: DMA (lsi64854) and SCSI core
		 * (ncr53c9x).
		 */
		if (ca->ca_ra.ra_nreg != 2) {
			printf(": expected 2 register spaces, found %d\n",
			    ca->ca_ra.ra_nreg);
			return;
		}

		/*
		 * Allocate a softc for the DMA companion, which will not
		 * get a regular attachment.
		 */
		dsc = malloc(sizeof(*dsc), M_DEVBUF, M_NOWAIT | M_ZERO);
		if (dsc == NULL) {
			printf(": could not allocate dma softc\n");
			return;
		}
		strlcpy(dsc->sc_dev.dv_xname, sc->sc_dev.dv_xname,
		    sizeof(dsc->sc_dev.dv_xname));
		esc->sc_dma = dsc;

		/*
		 * Map DMA registers
		 */
		dsc->sc_regs = (struct dma_regs *)mapiodev(&ca->ca_ra.ra_reg[0],
		    0, ca->ca_ra.ra_reg[0].rr_len);
		if (dsc->sc_regs == NULL) {
			printf(": can't map DMA registers\n");
			return;
		}
		dsc->sc_rev = dsc->sc_regs->csr & D_DEV_ID;
		dsc->sc_esp = esc;

#ifdef SUN4M
		/*
		 * Get transfer burst size from PROM and plug it into the
		 * controller registers. This is needed on the Sun4m; do
		 * others need it too?
		 */
		if (CPU_ISSUN4M) {
			int sbusburst;

			sbusburst = ((struct sbus_softc *)parent)->sc_burst;
			if (sbusburst == 0)
				sbusburst = SBUS_BURST_32 - 1;	/* 1 -> 16 */

			dsc->sc_burst =
			    getpropint(ca->ca_ra.ra_node, "burst-sizes", -1);
			if (dsc->sc_burst == -1)
				/* take SBus burst sizes */
				dsc->sc_burst = sbusburst;

			/* Clamp at parent's burst sizes */
			dsc->sc_burst &= sbusburst;
		}
#endif	/* SUN4M */

		/* indirect functions */
		dma_setuphandlers(dsc);

		/*
		 * Map SCSI core registers
		 */
		esc->sc_reg = (volatile u_char *)mapiodev(&ca->ca_ra.ra_reg[1],
		    0, ca->ca_ra.ra_reg[1].rr_len);
		if (esc->sc_reg == NULL) {
			printf(": can't map SCSI core registers\n");
			return;
		}

		dmachild = 0;
	} else
#endif
	{
		/*
		 * Map my registers in, if they aren't already in virtual
		 * address space.
		 */
		if (ca->ca_ra.ra_vaddr)
			esc->sc_reg = (volatile u_char *) ca->ca_ra.ra_vaddr;
		else {
			esc->sc_reg = (volatile u_char *)
			    mapiodev(ca->ca_ra.ra_reg, 0, ca->ca_ra.ra_len);
		}

		dmachild = strcmp(parent->dv_cfdata->cf_driver->cd_name, "dma") == 0;
		if (dmachild) {
			esc->sc_dma = (struct dma_softc *)parent;
			esc->sc_dma->sc_esp = esc;
		} else {
			/*
			 * Find the DMA by poking around the DMA device
			 * structures.
			 *
			 * What happens here is that if the DMA driver has
			 * not been configured, then this returns a NULL
			 * pointer. Then when the DMA actually gets configured,
			 * it does the opposite test, and if the sc->sc_esp
			 * field in its softc is NULL, then tries to find the
			 * matching esp driver.
			 */
			esc->sc_dma = (struct dma_softc *)
			    getdevunit("dma", sc->sc_dev.dv_unit);

			/*
			 * ...and a back pointer to us, for DMA.
			 */
			if (esc->sc_dma)
				esc->sc_dma->sc_esp = esc;
			else {
				printf("\n");
				panic("espattach: no dma found");
			}
		}
	}

	/*
	 * Set up glue for MI code.
	 */
#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	if (ca->ca_bustype == BUS_SBUS &&
	    strcmp("ptscII", ca->ca_ra.ra_name) == 0) {
		sc->sc_glue = &esp_glue1;
	} else
#endif
		sc->sc_glue = &esp_glue;

	/*
	 * XXX More of this should be in ncr53c9x_attach(), but
	 * XXX should we really poke around the chip that much in
	 * XXX the MI code?  Think about this more...
	 */

	/*
	 * It is necessary to try to load the 2nd config register here,
	 * to find out what rev the esp chip is, else the ncr53c9x_reset
	 * will not set up the defaults correctly.
	 */
	sc->sc_cfg1 = sc->sc_id | NCRCFG1_PARENB;
	sc->sc_cfg2 = NCRCFG2_SCSI2 | NCRCFG2_RPE;
	sc->sc_cfg3 = NCRCFG3_CDB;
	NCR_WRITE_REG(sc, NCR_CFG2, sc->sc_cfg2);

	if ((NCR_READ_REG(sc, NCR_CFG2) & ~NCRCFG2_RSVD) !=
	    (NCRCFG2_SCSI2 | NCRCFG2_RPE)) {
		sc->sc_rev = NCR_VARIANT_ESP100;
	} else {
		sc->sc_cfg2 = NCRCFG2_SCSI2;
		NCR_WRITE_REG(sc, NCR_CFG2, sc->sc_cfg2);
		sc->sc_cfg3 = 0;
		NCR_WRITE_REG(sc, NCR_CFG3, sc->sc_cfg3);
		sc->sc_cfg3 = (NCRCFG3_CDB | NCRCFG3_FCLK);
		NCR_WRITE_REG(sc, NCR_CFG3, sc->sc_cfg3);
		if (NCR_READ_REG(sc, NCR_CFG3) !=
		    (NCRCFG3_CDB | NCRCFG3_FCLK)) {
			sc->sc_rev = NCR_VARIANT_ESP100A;
		} else {
			/* NCRCFG2_FE enables > 64K transfers */
			sc->sc_cfg2 |= NCRCFG2_FE;
			sc->sc_cfg3 = 0;
			NCR_WRITE_REG(sc, NCR_CFG3, sc->sc_cfg3);
			sc->sc_rev = NCR_VARIANT_ESP200;

			/* XXX spec says it's valid after power up or chip reset */
			uid = NCR_READ_REG(sc, NCR_UID);
			if (((uid & 0xf8) >> 3) == 0x0a) /* XXX */
				sc->sc_rev = NCR_VARIANT_FAS366;
		}
	}

	/*
	 * XXX minsync and maxxfer _should_ be set up in MI code,
	 * XXX but it appears to have some dependency on what sort
	 * XXX of DMA we're hooked up to, etc.
	 */

	/*
	 * This is the value used to start sync negotiations
	 * Note that the NCR register "SYNCTP" is programmed
	 * in "clocks per byte", and has a minimum value of 4.
	 * The SCSI period used in negotiation is one-fourth
	 * of the time (in nanoseconds) needed to transfer one byte.
	 * Since the chip's clock is given in MHz, we have the following
	 * formula: 4 * period = (1000 / freq) * 4
	 */
	sc->sc_minsync = 1000 / sc->sc_freq;

	/*
	 * Alas, we must now modify the value a bit, because it's
	 * only valid when can switch on FASTCLK and FASTSCSI bits  
	 * in config register 3... 
	 */
	switch (sc->sc_rev) {
	case NCR_VARIANT_ESP100:
		sc->sc_maxxfer = 64 * 1024;
		sc->sc_minsync = 0;	/* No synch on old chip? */
		break;

	case NCR_VARIANT_ESP100A:
		sc->sc_maxxfer = 64 * 1024;
		/* Min clocks/byte is 5 */
		sc->sc_minsync = ncr53c9x_cpb2stp(sc, 5);
		break;

	case NCR_VARIANT_ESP200:
	case NCR_VARIANT_FAS366:
		sc->sc_maxxfer = 16 * 1024 * 1024;
		/* XXX - do actually set FAST* bits */
		break;
	}

	/* and the interrupts */
	esc->sc_ih.ih_fun = (void *) ncr53c9x_intr;
	esc->sc_ih.ih_arg = sc;
	intr_establish(esc->sc_pri, &esc->sc_ih, IPL_BIO, self->dv_xname);

	/*
	 * If the boot path is "esp" at the moment and it's me, then
	 * walk our pointer to the sub-device, ready for the config
	 * below.
	 */
	bp = ca->ca_ra.ra_bp;
	if (bp != NULL && (strcmp(bp->name, "esp") == 0 ||
	    strcmp(bp->name, ca->ca_ra.ra_name) == 0)) {
		switch (ca->ca_bustype) {
		case BUS_SBUS:
			if (SAME_ESP(sc, bp, ca))
				bootpath_store(1, bp + 1);
			break;
		default:
			if (bp->val[0] == -1 &&
			    bp->val[1] == sc->sc_dev.dv_unit)
				bootpath_store(1, bp + 1);
			break;
		}
	}

	/* Turn on target selection using the `dma' method */
	if (sc->sc_rev != NCR_VARIANT_FAS366)
		sc->sc_features |= NCR_F_DMASELECT;

	/* Do the common parts of attachment. */
	ncr53c9x_attach(sc);

	bootpath_store(1, NULL);
}

/*
 * Glue functions.
 */

u_char
esp_read_reg(sc, reg)
	struct ncr53c9x_softc *sc;
	int reg;
{
	struct esp_softc *esc = (struct esp_softc *)sc;

	return (esc->sc_reg[reg * 4]);
}

void
esp_write_reg(sc, reg, val)
	struct ncr53c9x_softc *sc;
	int reg;
	u_char val;
{
	struct esp_softc *esc = (struct esp_softc *)sc;
	u_char v = val;

	esc->sc_reg[reg * 4] = v;
}

#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
u_char
esp_rdreg1(sc, reg)
	struct ncr53c9x_softc *sc;
	int reg;
{
	struct esp_softc *esc = (struct esp_softc *)sc;

	return (esc->sc_reg[reg]);
}

void
esp_wrreg1(sc, reg, val)
	struct ncr53c9x_softc *sc;
	int reg;
	u_char val;
{
	struct esp_softc *esc = (struct esp_softc *)sc;
	u_char v = val;

	esc->sc_reg[reg] = v;
}
#endif

int
esp_dma_isintr(sc)
	struct ncr53c9x_softc *sc;
{
	struct esp_softc *esc = (struct esp_softc *)sc;

	return (DMA_ISINTR(esc->sc_dma));
}

void
esp_dma_reset(sc)
	struct ncr53c9x_softc *sc;
{
	struct esp_softc *esc = (struct esp_softc *)sc;

	DMA_RESET(esc->sc_dma);
}

int
esp_dma_intr(sc)
	struct ncr53c9x_softc *sc;
{
	struct esp_softc *esc = (struct esp_softc *)sc;

	return (DMA_INTR(esc->sc_dma));
}

int
esp_dma_setup(sc, addr, len, datain, dmasize)
	struct ncr53c9x_softc *sc;
	caddr_t *addr;
	size_t *len;
	int datain;
	size_t *dmasize;
{
	struct esp_softc *esc = (struct esp_softc *)sc;

	return (DMA_SETUP(esc->sc_dma, addr, len, datain, dmasize));
}

void
esp_dma_go(sc)
	struct ncr53c9x_softc *sc;
{
	struct esp_softc *esc = (struct esp_softc *)sc;

	DMA_GO(esc->sc_dma);
}

void
esp_dma_stop(sc)
	struct ncr53c9x_softc *sc;
{
	struct esp_softc *esc = (struct esp_softc *)sc;

	DMACSR(esc->sc_dma) &= ~D_EN_DMA;
}

int
esp_dma_isactive(sc)
	struct ncr53c9x_softc *sc;
{
	struct esp_softc *esc = (struct esp_softc *)sc;

	return (DMA_ISACTIVE(esc->sc_dma));
}
@


1.36
log
@Correctly match SUNW,fas in the boot path.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.35 2015/03/28 19:08:23 miod Exp $	*/
@


1.35
log
@When attaching an sbus esp(4), do the sbus_testdma() check regardless of the
actual card name we're attaching.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.34 2014/01/21 03:42:21 dlg Exp $	*/
d487 13
a499 11
	switch (ca->ca_bustype) {
	case BUS_SBUS:
		if (bp != NULL && strcmp(bp->name, "esp") == 0 &&
		    SAME_ESP(sc, bp, ca))
			bootpath_store(1, bp + 1);
		break;
	default:
		if (bp != NULL && strcmp(bp->name, "esp") == 0 &&
			bp->val[0] == -1 && bp->val[1] == sc->sc_dev.dv_unit)
			bootpath_store(1, bp + 1);
		break;
@


1.34
log
@dtucker@@ pointed out i suck at grep.

fix ncr53c9x fallout.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.33 2010/07/10 19:32:24 miod Exp $	*/
d117 1
a118 1
#include <machine/autoconf.h>
d185 3
a187 3
	register struct cfdata *cf = vcf;
	register struct confargs *ca = aux;
	register struct romaux *ra = &ca->ca_ra;
d191 3
d202 1
d204 1
a204 3
	if (ca->ca_bustype == BUS_SBUS) {
		if (!sbus_testdma((struct sbus_softc *)parent, ca))
			return (0);
a205 1
	}
@


1.33
log
@sun4e (i.e. SPARCengine 1e) support. This platform is a mix between sun4 and
sun4c, as it has a sun4c OpenPROM but a sun4 8KB pagesize. VME devices are
not supported yet.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.32 2010/06/28 18:31:01 krw Exp $	*/
a135 7
struct scsi_adapter esp_switch = {
	ncr53c9x_scsi_cmd,
	scsi_minphys,		/* no max at this level; handled by DMA code */
	NULL,
	NULL,
};

d504 1
a504 1
	ncr53c9x_attach(sc, &esp_switch);
@


1.32
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.31 2010/06/27 05:52:01 beck Exp $	*/
d172 1
a172 1
#if defined(SUN4C) || defined(SUN4M)
d196 1
a196 1
#if defined(SUN4C) || defined(SUN4M)
d206 1
a206 1
#if defined(SUN4C) || defined(SUN4M)
d264 1
a264 1
#if defined(SUN4C) || defined(SUN4M)
d390 1
a390 1
#if defined(SUN4C) || defined(SUN4M)
d542 1
a542 1
#if defined(SUN4C) || defined(SUN4M)
@


1.31
log
@make sparc compile again after tag team viking/guenther breakage.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.30 2010/06/26 23:24:44 guenther Exp $	*/
a142 7
struct scsi_device esp_dev = {
	NULL,			/* Use default error handler */
	NULL,			/* have a queue, served by this */
	NULL,			/* have no async handler */
	NULL,			/* Use default 'done' routine */
};

d511 1
a511 1
	ncr53c9x_attach(sc, &esp_switch, &esp_dev);
@


1.30
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.29 2010/06/07 19:54:33 miod Exp $	*/
d114 2
@


1.29
log
@Rework the way onboard devices attach on Sun 4/110 systems (which only have a
28 bit address bus) by reusing the regular sun4 configuration stanzas (with
the upper four bits set in the device addresses), and clearing them when
searching for a PROM mapping.
This makes the obio autoconf code simpler, and all knowledge of the 4/110
specifics is now contained in a single file (dev/obio.c).

ok todd@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.28 2009/10/26 20:17:27 deraadt Exp $	*/
a107 1
#include <sys/user.h>
@


1.28
log
@Do not do strncmp comparisons on dv_xname because longer device names which
look similar could arrive in the future.  Instead, compare directly against
dv_cfdata->cf_driver->cd_name
Issue originally spotted by miod
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.27 2009/03/29 21:53:52 sthen Exp $	*/
d218 4
@


1.27
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.26 2009/02/16 21:19:06 miod Exp $	*/
d358 1
a358 1
		dmachild = strncmp(parent->dv_xname, "dma", 3) == 0;
@


1.26
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.25 2007/10/01 16:11:19 krw Exp $	*/
d300 1
a300 1
			printf(": could not map DMA registers\n");
d339 1
a339 1
			printf(": could not map SCSI core registers\n");
@


1.25
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...' where
obvious.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.24 2006/06/02 20:00:54 miod Exp $	*/
d137 1
a137 1
	minphys,		/* no max at this level; handled by DMA code */
@


1.24
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.23 2005/03/02 16:42:37 miod Exp $	*/
d285 1
a285 1
		dsc = malloc(sizeof(struct dma_softc), M_DEVBUF, M_NOWAIT);
a289 1
		bzero(dsc, sizeof(struct dma_softc));
@


1.23
log
@Support for SUNW,fas SCSI, currently restricted to the lower 8 targets due
to MI esp code limitations.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.22 2004/09/29 07:35:11 miod Exp $	*/
a483 11

	/* add me to the sbus structures */
	esc->sc_sd.sd_reset = (void *) ncr53c9x_reset;
#if defined(SUN4C) || defined(SUN4M)
	if (ca->ca_bustype == BUS_SBUS) {
		if (dmachild)
			sbus_establish(&esc->sc_sd, sc->sc_dev.dv_parent);
		else
			sbus_establish(&esc->sc_sd, &sc->sc_dev);
	}
#endif /* SUN4C || SUN4M */
@


1.22
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.21 2003/06/05 12:27:02 deraadt Exp $	*/
d110 1
d154 2
d178 15
d202 8
d235 2
a236 1
	int dmachild = strncmp(parent->dv_xname, "dma", 3) == 0;
d239 2
a240 7
	 * Set up glue for MI code early; we use some of it here.
	 */
	sc->sc_glue = &esp_glue;

	/*
	 * Make sure things are sane. I don't know if this is ever
	 * necessary, but it seem to be in all of Torek's code.
a249 11
	/*
	 * Map my registers in, if they aren't already in virtual
	 * address space.
	 */
	if (ca->ca_ra.ra_vaddr)
		esc->sc_reg = (volatile u_char *) ca->ca_ra.ra_vaddr;
	else {
		esc->sc_reg = (volatile u_char *)
		    mapiodev(ca->ca_ra.ra_reg, 0, ca->ca_ra.ra_len);
	}

d266 68
a333 4
	if (dmachild) {
		esc->sc_dma = (struct dma_softc *)parent;
		esc->sc_dma->sc_esp = esc;
	} else {
d335 1
a335 7
		 * find the DMA by poking around the dma device structures
		 *
		 * What happens here is that if the dma driver has not been
		 * configured, then this returns a NULL pointer. Then when the
		 * dma actually gets configured, it does the opposing test, and
		 * if the sc->sc_esp field in it's softc is NULL, then tries to
		 * find the matching esp driver.
d337 6
a342 2
		esc->sc_dma = (struct dma_softc *)
			getdevunit("dma", sc->sc_dev.dv_unit);
d344 4
d349 2
a350 1
		 * and a back pointer to us, for DMA
d352 10
a361 1
		if (esc->sc_dma)
d363 24
a386 3
		else {
			printf("\n");
			panic("espattach: no dma found");
d391 11
d436 5
d479 1
d496 1
a496 1
	/* and the interuppts */
d520 4
a526 3
	/* Turn on target selection using the `dma' method */
	sc->sc_features |= NCR_F_DMASELECT;

d555 24
@


1.21
log
@3/4 knockout for peter galbavy
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.20 2003/02/11 19:20:26 mickey Exp $	*/
d374 1
a374 2
	intr_establish(esc->sc_pri, &esc->sc_ih, IPL_BIO);
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);
@


1.20
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.19 2002/04/30 01:12:29 art Exp $	*/
a76 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Peter Galbavy
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.19
log
@Fix an ancient problem in how sparc interrupts are handled.

There are many interrupt handlers that assume that they don't need to do
any spl protection in their code because the interrupt of some level can't
be interrupted by an interrupt of the same level. The problem is that some
interrupt handlers have hardware levels that are lower then their "software"
levels.

Fix this by adding an additional field to struct intrhand that specifies which
"software" level an interrupt handler has and blocks that level while handling
the interrupt. This new field is initialized in intr_establish which gets
an additional argument (which can be -1 meaning that the interrupt handler
doesn't need to block any additional level).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.18 2002/03/14 01:26:42 millert Exp $	*/
d257 1
a257 1
	/* gimme Mhz */
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.17 2001/09/27 04:01:42 jason Exp $	*/
d379 1
a379 1
	intr_establish(esc->sc_pri, &esc->sc_ih);
@


1.17
log
@Huge merge with NetBSD.  For full details look at their revision history (1.26 -> 1.83)...
Highlights:
o tag queue support
o fas366 support (doesn't work yet on sparc, but does on sparc64)
o tons more
(thanks to hugh, fgsch and beck for testing)
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.16 2000/06/12 06:10:46 fgsch Exp $	*/
d131 2
a132 2
void	espattach	__P((struct device *, struct device *, void *));
int	espmatch	__P((struct device *, void *, void *));
d156 10
a165 10
u_char	esp_read_reg __P((struct ncr53c9x_softc *, int));
void	esp_write_reg __P((struct ncr53c9x_softc *, int, u_char));
int	esp_dma_isintr __P((struct ncr53c9x_softc *));
void	esp_dma_reset __P((struct ncr53c9x_softc *));
int	esp_dma_intr __P((struct ncr53c9x_softc *));
int	esp_dma_setup __P((struct ncr53c9x_softc *, caddr_t *,
	    size_t *, int, size_t *));
void	esp_dma_go __P((struct ncr53c9x_softc *));
void	esp_dma_stop __P((struct ncr53c9x_softc *));
int	esp_dma_isactive __P((struct ncr53c9x_softc *));
@


1.17.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.17 2001/09/27 04:01:42 jason Exp $	*/
d131 2
a132 2
void	espattach(struct device *, struct device *, void *);
int	espmatch(struct device *, void *, void *);
d156 10
a165 10
u_char	esp_read_reg(struct ncr53c9x_softc *, int);
void	esp_write_reg(struct ncr53c9x_softc *, int, u_char);
int	esp_dma_isintr(struct ncr53c9x_softc *);
void	esp_dma_reset(struct ncr53c9x_softc *);
int	esp_dma_intr(struct ncr53c9x_softc *);
int	esp_dma_setup(struct ncr53c9x_softc *, caddr_t *,
	    size_t *, int, size_t *);
void	esp_dma_go(struct ncr53c9x_softc *);
void	esp_dma_stop(struct ncr53c9x_softc *);
int	esp_dma_isactive(struct ncr53c9x_softc *);
d379 1
a379 1
	intr_establish(esc->sc_pri, &esc->sc_ih, IPL_BIO);
@


1.17.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d257 1
a257 1
	/* gimme MHz */
@


1.16
log
@move cfdriver to ncr53c9x.c and device declaration to conf/files.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.15 1999/02/28 19:12:33 jason Exp $	*/
d405 1
a405 1
	ncr53c9x_dmaselect = 1;
@


1.15
log
@conditionalize use of sbus_testdma()
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.14 1998/11/11 00:25:58 jason Exp $	*/
a136 4
};

struct cfdriver esp_cd = {
	NULL, "esp", DV_DULL
@


1.15.6.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.16 2000/06/12 06:10:46 fgsch Exp $	*/
d137 4
@


1.15.6.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.15.6.1 2001/05/14 21:37:04 niklas Exp $	*/
d405 1
a405 1
	sc->sc_features |= NCR_F_DMASELECT;
@


1.15.6.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d131 2
a132 2
void	espattach(struct device *, struct device *, void *);
int	espmatch(struct device *, void *, void *);
d156 10
a165 10
u_char	esp_read_reg(struct ncr53c9x_softc *, int);
void	esp_write_reg(struct ncr53c9x_softc *, int, u_char);
int	esp_dma_isintr(struct ncr53c9x_softc *);
void	esp_dma_reset(struct ncr53c9x_softc *);
int	esp_dma_intr(struct ncr53c9x_softc *);
int	esp_dma_setup(struct ncr53c9x_softc *, caddr_t *,
	    size_t *, int, size_t *);
void	esp_dma_go(struct ncr53c9x_softc *);
void	esp_dma_stop(struct ncr53c9x_softc *);
int	esp_dma_isactive(struct ncr53c9x_softc *);
@


1.15.6.4
log
@Sync the SMP branch with 3.3
@
text
@d257 1
a257 1
	/* gimme MHz */
d379 1
a379 1
	intr_establish(esc->sc_pri, &esc->sc_ih, IPL_BIO);
@


1.15.6.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.15.6.4 2003/03/27 23:49:25 niklas Exp $	*/
d77 5
@


1.14
log
@Detect cards that require dma that are in non-dma slots and don't allow
them to be attach'd.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.13 1998/01/28 17:21:47 jason Exp $	*/
d195 1
d201 1
@


1.13
log
@Undo the 4/300 dmaselect hack and fix it correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.12 1998/01/14 18:30:10 jason Exp $	*/
d195 3
a197 1
	if (ca->ca_bustype == BUS_SBUS)
d199 1
@


1.12
log
@For some reason the 4/300 doesn't like ncr53c9x_dmaselect.
Added code to check to see if parent device == obio, if so, disable dmaselect
More research to be done here for a real fix (if possible)
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.11 1997/09/17 06:47:08 downsj Exp $	*/
a213 1
	int use_dmaselect = strncmp(parent->dv_xname, "obio", 4);
d404 1
a404 4
	/* XXX The Sun 4/300 doesn't handle this very well, so it is */
	/* XXX disabled if the parent device == "obio" */
	/* XXX More research to do here... */
	ncr53c9x_dmaselect = use_dmaselect;
@


1.11
log
@NETBSD_CURRENT_970916.  Lot's just ID changes, since changes don't apply to
us.  Includes some pmap changes, for which I don't have the original commit
message(s) handy.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.10 1997/08/08 08:25:00 downsj Exp $	*/
d214 1
d405 4
a408 1
	ncr53c9x_dmaselect = 1;
@


1.10
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: esp.c,v 1.68 1997/07/19 21:57:01 pk Exp $	*/
@


1.9
log
@added const to second parameter of cfprint_t routines
@
text
@d1 62
a62 1
/*	$NetBSD: esp.c,v 1.47.2.1 1996/06/12 20:46:52 pk Exp $ */
d122 4
a128 1
#include <sparc/dev/espreg.h>
d131 2
a132 23
int esp_debug = 0; /*ESP_SHOWPHASE|ESP_SHOWMISC|ESP_SHOWTRAC|ESP_SHOWCMDS;*/

/*static*/ void	espattach	__P((struct device *, struct device *, void *));
/*static*/ int	espmatch	__P((struct device *, void *, void *));
/*static*/ int	espprint	__P((void *, const char *));
/*static*/ u_int	esp_adapter_info __P((struct esp_softc *));
/*static*/ void	espreadregs	__P((struct esp_softc *));
/*static*/ void	espselect	__P((struct esp_softc *,
				     u_char, u_char, u_char *, u_char));
/*static*/ void	esp_scsi_reset	__P((struct esp_softc *));
/*static*/ void	esp_reset	__P((struct esp_softc *));
/*static*/ void	esp_init	__P((struct esp_softc *, int));
/*static*/ int	esp_scsi_cmd	__P((struct scsi_xfer *));
/*static*/ int	esp_poll	__P((struct esp_softc *, struct ecb *));
/*static*/ void	esp_sched	__P((struct esp_softc *));
/*static*/ void	esp_done	__P((struct ecb *));
/*static*/ void	esp_msgin	__P((struct esp_softc *));
/*static*/ void	esp_msgout	__P((struct esp_softc *));
/*static*/ int	espintr		__P((struct esp_softc *));
/*static*/ void	esp_timeout	__P((void *arg));
/*static*/ void	esp_abort	__P((struct esp_softc *, struct ecb *));
int esp_stp2cpb __P((struct esp_softc *, int));
int esp_cpb2stp __P((struct esp_softc *, int));
d144 1
a144 1
	esp_scsi_cmd,
d157 26
a182 9
int
espprint(aux, name)
	void *aux;
	const char *name;
{
	if (name != NULL)
		printf("%s: scsibus ", name);
	return UNCONF;
}
d189 1
a189 1
	struct cfdata *cf = vcf;
d210 2
a211 1
	struct esp_softc *sc = (void *)self;
d216 5
d229 2
a230 2
	sc->sc_pri = ca->ca_ra.ra_intr[0].int_pri;
	printf(" pri %d", sc->sc_pri);
d237 1
a237 1
		sc->sc_reg = (volatile u_char *) ca->ca_ra.ra_vaddr;
d239 2
a240 2
		sc->sc_reg = (volatile u_char *)
		    mapiodev(ca->ca_ra.ra_reg, 0, ca->ca_ra.ra_len, ca->ca_bustype);
d244 1
a244 1
	sc->sc_node = ca->ca_ra.ra_node;
d246 2
a247 2
		sc->sc_id = getpropint(sc->sc_node, "initiator-id", 7);
		sc->sc_freq = getpropint(sc->sc_node, "clock-frequency", -1);
d260 2
a261 2
		sc->sc_dma = (struct dma_softc *)parent;
		sc->sc_dma->sc_esp = sc;
a270 1
		 *
d272 1
a272 1
		sc->sc_dma = (struct dma_softc *)
d278 4
a281 3
		if (sc->sc_dma)
			sc->sc_dma->sc_esp = sc;
		else
d283 1
d287 6
d294 1
a294 1
	 * to find out what rev the esp chip is, else the esp_reset
d297 8
a304 8
	sc->sc_cfg1 = sc->sc_id | ESPCFG1_PARENB;
	sc->sc_cfg2 = ESPCFG2_SCSI2 | ESPCFG2_RPE;
	sc->sc_cfg3 = ESPCFG3_CDB;
	ESP_WRITE_REG(sc, ESP_CFG2, sc->sc_cfg2);

	if ((ESP_READ_REG(sc, ESP_CFG2) & ~ESPCFG2_RSVD) != (ESPCFG2_SCSI2 | ESPCFG2_RPE)) {
		printf(": ESP100");
		sc->sc_rev = ESP100;
d306 2
a307 2
		sc->sc_cfg2 = ESPCFG2_SCSI2;
		ESP_WRITE_REG(sc, ESP_CFG2, sc->sc_cfg2);
d309 6
a314 6
		ESP_WRITE_REG(sc, ESP_CFG3, sc->sc_cfg3);
		sc->sc_cfg3 = (ESPCFG3_CDB | ESPCFG3_FCLK);
		ESP_WRITE_REG(sc, ESP_CFG3, sc->sc_cfg3);
		if (ESP_READ_REG(sc, ESP_CFG3) != (ESPCFG3_CDB | ESPCFG3_FCLK)) {
			printf(": ESP100A");
			sc->sc_rev = ESP100A;
d316 2
a317 2
			/* ESPCFG2_FE enables > 64K transfers */
			sc->sc_cfg2 |= ESPCFG2_FE;
d319 2
a320 3
			ESP_WRITE_REG(sc, ESP_CFG3, sc->sc_cfg3);
			printf(": ESP200");
			sc->sc_rev = ESP200;
d325 6
d332 1
a332 1
	 * Note that the ESP register "SYNCTP" is programmed
d343 2
a344 2
	 * only valid when can switch on FASTCLK and FASTSCSI bits
	 * in config register 3...
d347 1
a347 1
	case ESP100:
d351 2
a352 1
	case ESP100A:
d354 2
a355 1
		sc->sc_minsync = esp_cpb2stp(sc, 5); /* Min clocks/byte is 5 */
d357 2
a358 1
	case ESP200:
d361 1
a363 28
	sc->sc_ccf = FREQTOCCF(sc->sc_freq);

	/* The value *must not* be == 1. Make it 2 */
	if (sc->sc_ccf == 1)
		sc->sc_ccf = 2;

	/*
	 * The recommended timeout is 250ms. This register is loaded
	 * with a value calculated as follows, from the docs:
	 *
	 *		(timout period) x (CLK frequency)
	 *	reg = -------------------------------------
	 *		 8192 x (Clock Conversion Factor)
	 *
	 * Since CCF has a linear relation to CLK, this generally computes
	 * to the constant of 153.
	 */
	sc->sc_timeout = ((250 * 1000) * sc->sc_freq) / (8192 * sc->sc_ccf);

	/* CCF register only has 3 bits; 0 is actually 8 */
	sc->sc_ccf &= 7;

	/* Reset state & bus */
	sc->sc_state = 0;
	esp_init(sc, 1);

	printf(" %dMhz, target %d\n", sc->sc_freq, sc->sc_id);

d365 1
a365 1
	sc->sc_sd.sd_reset = (void *) esp_reset;
d369 1
a369 1
			sbus_establish(&sc->sc_sd, sc->sc_dev.dv_parent);
d371 1
a371 1
			sbus_establish(&sc->sc_sd, &sc->sc_dev);
d376 3
a378 3
	sc->sc_ih.ih_fun = (void *) espintr;
	sc->sc_ih.ih_arg = sc;
	intr_establish(sc->sc_pri, &sc->sc_ih);
a381 9
	 * fill in the prototype scsi_link.
	 */
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter_target = sc->sc_id;
	sc->sc_link.adapter = &esp_switch;
	sc->sc_link.device = &esp_dev;
	sc->sc_link.openings = 2;

	/*
d400 5
a404 4
	/*
	 * Now try to attach all the sub-devices
	 */
	config_found(self, &sc->sc_link, espprint);
d410 1
a410 6
 * This is the generic esp reset function. It does not reset the SCSI bus,
 * only this controllers, but kills any on-going commands, and also stops
 * and resets the DMA.
 *
 * After reset, registers are loaded with the defaults from the attach
 * routine above.
a411 7
void
esp_reset(sc)
	struct esp_softc *sc;
{

	/* reset DMA first */
	DMA_RESET(sc->sc_dma);
d413 4
a416 33
	/* reset SCSI chip */
	ESPCMD(sc, ESPCMD_RSTCHIP);
	ESPCMD(sc, ESPCMD_NOP);
	DELAY(500);

	/* do these backwards, and fall through */
	switch (sc->sc_rev) {
	case ESP200:
		ESP_WRITE_REG(sc, ESP_CFG3, sc->sc_cfg3);
	case ESP100A:
		ESP_WRITE_REG(sc, ESP_CFG2, sc->sc_cfg2);
	case ESP100:
		ESP_WRITE_REG(sc, ESP_CFG1, sc->sc_cfg1);
		ESP_WRITE_REG(sc, ESP_CCF, sc->sc_ccf);
		ESP_WRITE_REG(sc, ESP_SYNCOFF, 0);
		ESP_WRITE_REG(sc, ESP_TIMEOUT, sc->sc_timeout);
		break;
	default:
		printf("%s: unknown revision code, assuming ESP100\n",
		    sc->sc_dev.dv_xname);
		ESP_WRITE_REG(sc, ESP_CFG1, sc->sc_cfg1);
		ESP_WRITE_REG(sc, ESP_CCF, sc->sc_ccf);
		ESP_WRITE_REG(sc, ESP_SYNCOFF, 0);
		ESP_WRITE_REG(sc, ESP_TIMEOUT, sc->sc_timeout);
	}
}

/*
 * Reset the SCSI bus, but not the chip
 */
void
esp_scsi_reset(sc)
	struct esp_softc *sc;
d418 1
a418 73
	/* stop DMA first, as the chip will return to Bus Free phase */
	DMACSR(sc->sc_dma) &= ~D_EN_DMA;

	printf("esp: resetting SCSI bus\n");
	ESPCMD(sc, ESPCMD_RSTSCSI);
}

/*
 * Initialize esp state machine
 */
void
esp_init(sc, doreset)
	struct esp_softc *sc;
	int doreset;
{
	struct ecb *ecb;
	int r;

	ESP_TRACE(("[ESP_INIT(%d)] ", doreset));

	if (sc->sc_state == 0) {	/* First time through */
		TAILQ_INIT(&sc->ready_list);
		TAILQ_INIT(&sc->nexus_list);
		TAILQ_INIT(&sc->free_list);
		sc->sc_nexus = NULL;
		ecb = sc->sc_ecb;
		bzero(ecb, sizeof(sc->sc_ecb));
		for (r = 0; r < sizeof(sc->sc_ecb) / sizeof(*ecb); r++) {
			TAILQ_INSERT_TAIL(&sc->free_list, ecb, chain);
			ECB_SETQ(ecb, ECB_QFREE);
			ecb++;
		}
		bzero(sc->sc_tinfo, sizeof(sc->sc_tinfo));
	} else {
		sc->sc_flags |= ESP_ABORTING;
		sc->sc_state = ESP_IDLE;
		ecb = sc->sc_nexus;
		if (ecb != NULL) {
			ecb->xs->error = XS_TIMEOUT;
			esp_done(ecb);
			sc->sc_nexus = NULL;
		}
		while ((ecb = sc->nexus_list.tqh_first) != NULL) {
			ecb->xs->error = XS_TIMEOUT;
			esp_done(ecb);
		}
	}

	/*
	 * reset the chip to a known state
	 */
	esp_reset(sc);

	sc->sc_phase = sc->sc_prevphase = INVALID_PHASE;
	for (r = 0; r < 8; r++) {
		struct esp_tinfo *tp = &sc->sc_tinfo[r];
/* XXX - config flags per target: low bits: no reselect; high bits: no synch */
		int fl = sc->sc_dev.dv_cfdata->cf_flags;

		tp->flags = ((sc->sc_minsync && !(fl & (1<<(r+8))))
				? T_NEGOTIATE : 0) |
				((fl & (1<<r)) ? T_RSELECTOFF : 0) |
				T_NEED_TO_RESET;
		tp->period = sc->sc_minsync;
		tp->offset = 0;
	}
	sc->sc_flags &= ~ESP_ABORTING;

	if (doreset) {
		sc->sc_state = ESP_SBR;
		ESPCMD(sc, ESPCMD_RSTSCSI);
		return;
	}
d420 1
a420 3
	sc->sc_state = ESP_IDLE;
	esp_sched(sc);
	return;
a422 9
/*
 * Read the ESP registers, and save their contents for later use.
 * ESP_STAT, ESP_STEP & ESP_INTR are mostly zeroed out when reading
 * ESP_INTR - so make sure it is the last read.
 *
 * I think that (from reading the docs) most bits in these registers
 * only make sense when he DMA CSR has an interrupt showing. Call only
 * if an interrupt is pending.
 */
d424 4
a427 2
espreadregs(sc)
	struct esp_softc *sc;
d429 2
d432 1
a432 16
	sc->sc_espstat = ESP_READ_REG(sc, ESP_STAT);
	/* Only the stepo bits are of interest */
	sc->sc_espstep = ESP_READ_REG(sc, ESP_STEP) & ESPSTEP_MASK;
	sc->sc_espintr = ESP_READ_REG(sc, ESP_INTR);

	/*
	 * Determine the SCSI bus phase, return either a real SCSI bus phase
	 * or some pseudo phase we use to detect certain exceptions.
	 */

	sc->sc_phase = (sc->sc_espintr & ESPINTR_DIS)
			? /* Disconnected */ BUSFREE_PHASE
			: sc->sc_espstat & ESPSTAT_PHASE;

	ESP_MISC(("regs[intr=%02x,stat=%02x,step=%02x] ",
		sc->sc_espintr, sc->sc_espstat, sc->sc_espstep));
a434 3
/*
 * Convert Synchronous Transfer Period to chip register Clock Per Byte value.
 */
d436 2
a437 3
esp_stp2cpb(sc, period)
	struct esp_softc *sc;
	int period;
d439 1
a439 7
	int v;
	v = (sc->sc_freq * period) / 250;
	if (esp_cpb2stp(sc, v) < period)
		/* Correct round-down error */
		v++;
	return v;
}
d441 1
a441 9
/*
 * Convert chip register Clock Per Byte value to Synchronous Transfer Period.
 */
int
esp_cpb2stp(sc, cpb)
	struct esp_softc *sc;
	int cpb;
{
	return ((250 * cpb) / sc->sc_freq);
a443 7
/*
 * Send a command to a target, set the driver state to ESP_SELECTING
 * and let the caller take care of the rest.
 *
 * Keeping this as a function allows me to say that this may be done
 * by DMA instead of programmed I/O soon.
 */
d445 2
a446 5
espselect(sc, target, lun, cmd, clen)
	struct esp_softc *sc;
	u_char target, lun;
	u_char *cmd;
	u_char clen;
d448 1
a448 42
	struct esp_tinfo *ti = &sc->sc_tinfo[target];
	int i;

	ESP_TRACE(("[espselect(t%d,l%d,cmd:%x)] ", target, lun, *(u_char *)cmd));

	/* new state ESP_SELECTING */
	sc->sc_state = ESP_SELECTING;

	ESPCMD(sc, ESPCMD_FLUSH);

	/*
	 * The docs say the target register is never reset, and I
	 * can't think of a better place to set it
	 */
	ESP_WRITE_REG(sc, ESP_SELID, target);
	if (ti->flags & T_SYNCMODE) {
		ESP_WRITE_REG(sc, ESP_SYNCOFF, ti->offset);
		ESP_WRITE_REG(sc, ESP_SYNCTP, esp_stp2cpb(sc, ti->period));
	} else {
		ESP_WRITE_REG(sc, ESP_SYNCOFF, 0);
		ESP_WRITE_REG(sc, ESP_SYNCTP, 0);
	}

	/*
	 * Who am I. This is where we tell the target that we are
	 * happy for it to disconnect etc.
	 */
	ESP_WRITE_REG(sc, ESP_FIFO,
		MSG_IDENTIFY(lun, (ti->flags & T_RSELECTOFF)?0:1));

	if (ti->flags & T_NEGOTIATE) {
		/* Arbitrate, select and stop after IDENTIFY message */
		ESPCMD(sc, ESPCMD_SELATNS);
		return;
	}

	/* Now the command into the FIFO */
	for (i = 0; i < clen; i++)
		ESP_WRITE_REG(sc, ESP_FIFO, *cmd++);

	/* And get the targets attention */
	ESPCMD(sc, ESPCMD_SELATN);
d450 1
a452 9
/*
 * DRIVER FUNCTIONS CALLABLE FROM HIGHER LEVEL DRIVERS
 */

/*
 * Start a SCSI-command
 * This function is called by the higher level SCSI-driver to queue/run
 * SCSI-commands.
 */
d454 2
a455 2
esp_scsi_cmd(xs)
	struct scsi_xfer *xs;
d457 1
a457 50
	struct scsi_link *sc_link = xs->sc_link;
	struct esp_softc *sc = sc_link->adapter_softc;
	struct ecb 	*ecb;
	int s, flags;

	ESP_TRACE(("[esp_scsi_cmd] "));
	ESP_CMDS(("[0x%x, %d]->%d ", (int)xs->cmd->opcode, xs->cmdlen,
	    sc_link->target));

	flags = xs->flags;

	/* Get a esp command block */
	s = splbio();
	ecb = sc->free_list.tqh_first;
	if (ecb) {
		TAILQ_REMOVE(&sc->free_list, ecb, chain);
		ECB_SETQ(ecb, ECB_QNONE);
	}
	splx(s);

	if (ecb == NULL) {
		ESP_MISC(("TRY_AGAIN_LATER"));
		return TRY_AGAIN_LATER;
	}

	/* Initialize ecb */
	ecb->xs = xs;
	bcopy(xs->cmd, &ecb->cmd, xs->cmdlen);
	ecb->clen = xs->cmdlen;
	ecb->daddr = xs->data;
	ecb->dleft = xs->datalen;
	ecb->stat = 0;

	s = splbio();
	TAILQ_INSERT_TAIL(&sc->ready_list, ecb, chain);
	ECB_SETQ(ecb, ECB_QREADY);
	timeout(esp_timeout, ecb, (xs->timeout*hz)/1000);

	if (sc->sc_state == ESP_IDLE)
		esp_sched(sc);

	splx(s);

	if (flags & SCSI_POLL) {
		/* Not allowed to use interrupts, use polling instead */
		return esp_poll(sc, ecb);
	}

	ESP_MISC(("SUCCESSFULLY_QUEUED"));
	return SUCCESSFULLY_QUEUED;
d459 1
a461 3
/*
 * Used when interrupt driven I/O isn't allowed, e.g. during boot.
 */
d463 6
a468 48
esp_poll(sc, ecb)
	struct esp_softc *sc;
	struct ecb *ecb;
{
	struct scsi_xfer *xs = ecb->xs;
	int count = xs->timeout * 100;

	ESP_TRACE(("[esp_poll] "));
	while (count) {
		if (DMA_ISINTR(sc->sc_dma)) {
			espintr(sc);
		}
#if alternatively
		if (ESP_READ_REG(sc, ESP_STAT) & ESPSTAT_INT)
			espintr(sc);
#endif
		if (xs->flags & ITSDONE)
			break;
		DELAY(10);
		if (sc->sc_state == ESP_IDLE) {
			ESP_TRACE(("[esp_poll: rescheduling] "));
			esp_sched(sc);
		}
		count--;
	}

	if (count == 0) {
		ESP_MISC(("esp_poll: timeout"));
		esp_timeout((caddr_t)ecb);
	}

	return COMPLETE;
}


/*
 * LOW LEVEL SCSI UTILITIES
 */

/*
 * Schedule a scsi operation.  This has now been pulled out of the interrupt
 * handler so that we may call it from esp_scsi_cmd and esp_done.  This may
 * save us an unecessary interrupt just to get things going.  Should only be
 * called when state == ESP_IDLE and at bio pl.
 */
void
esp_sched(sc)
	struct esp_softc *sc;
d470 1
a470 7
	struct scsi_link *sc_link;
	struct ecb *ecb;
	int t;

	ESP_TRACE(("[esp_sched] "));
	if (sc->sc_state != ESP_IDLE)
		panic("esp_sched: not IDLE (state=%d)", sc->sc_state);
d472 1
a472 33
	if (sc->sc_flags & ESP_ABORTING)
		return;

	/*
	 * Find first ecb in ready queue that is for a target/lunit
	 * combinations that is not busy.
	 */
	for (ecb = sc->ready_list.tqh_first; ecb; ecb = ecb->chain.tqe_next) {
		sc_link = ecb->xs->sc_link;
		t = sc_link->target;
		if (!(sc->sc_tinfo[t].lubusy & (1 << sc_link->lun))) {
			struct esp_tinfo *ti = &sc->sc_tinfo[t];

			if ((ecb->flags & ECB_QBITS) != ECB_QREADY)
				panic("esp: busy entry on ready list");
			TAILQ_REMOVE(&sc->ready_list, ecb, chain);
			ECB_SETQ(ecb, ECB_QNONE);
			sc->sc_nexus = ecb;
			sc->sc_flags = 0;
			sc->sc_prevphase = INVALID_PHASE;
			sc->sc_dp = ecb->daddr;
			sc->sc_dleft = ecb->dleft;
			ti->lubusy |= (1<<sc_link->lun);
/*XXX*/if (sc->sc_msgpriq) {
	printf("esp: message queue not empty: %x!\n", sc->sc_msgpriq);
}
/*XXX*/sc->sc_msgpriq = sc->sc_msgout = 0;
			espselect(sc, t, sc_link->lun,
				  (u_char *)&ecb->cmd, ecb->clen);
			break;
		} else
			ESP_MISC(("%d:%d busy\n", t, sc_link->lun));
	}
a474 3
/*
 * POST PROCESSING OF SCSI_CMD (usually current)
 */
d476 2
a477 2
esp_done(ecb)
	struct ecb *ecb;
d479 1
a479 74
	struct scsi_xfer *xs = ecb->xs;
	struct scsi_link *sc_link = xs->sc_link;
	struct esp_softc *sc = sc_link->adapter_softc;
	struct esp_tinfo *ti = &sc->sc_tinfo[sc_link->target];

	ESP_TRACE(("[esp_done(error:%x)] ", xs->error));

	untimeout(esp_timeout, ecb);

	/*
	 * Now, if we've come here with no error code, i.e. we've kept the
	 * initial XS_NOERROR, and the status code signals that we should
	 * check sense, we'll need to set up a request sense cmd block and
	 * push the command back into the ready queue *before* any other
	 * commands for this target/lunit, else we lose the sense info.
	 * We don't support chk sense conditions for the request sense cmd.
	 */
	if (xs->error == XS_NOERROR) {
		if ((ecb->flags & ECB_ABORTED) != 0) {
			xs->error = XS_TIMEOUT;
		} else if ((ecb->flags & ECB_CHKSENSE) != 0) {
			xs->error = XS_SENSE;
		} else if ((ecb->stat & ST_MASK) == SCSI_CHECK) {
			struct scsi_sense *ss = (void *)&ecb->cmd;
			ESP_MISC(("requesting sense "));
			/* First, save the return values */
			xs->resid = ecb->dleft;
			xs->status = ecb->stat;
			/* Next, setup a request sense command block */
			bzero(ss, sizeof(*ss));
			ss->opcode = REQUEST_SENSE;
			/*ss->byte2 = sc_link->lun << 5;*/
			ss->length = sizeof(struct scsi_sense_data);
			ecb->clen = sizeof(*ss);
			ecb->daddr = (char *)&xs->sense;
			ecb->dleft = sizeof(struct scsi_sense_data);
			ecb->flags |= ECB_CHKSENSE;
/*XXX - must take off queue here */
			if (ecb != sc->sc_nexus) {
				panic("%s: esp_sched: floating ecb %p",
					sc->sc_dev.dv_xname, ecb);
			}
			TAILQ_INSERT_HEAD(&sc->ready_list, ecb, chain);
			ECB_SETQ(ecb, ECB_QREADY);
			ti->lubusy &= ~(1<<sc_link->lun);
			ti->senses++;
			timeout(esp_timeout, ecb, (xs->timeout*hz)/1000);
			if (sc->sc_nexus == ecb) {
				sc->sc_nexus = NULL;
				sc->sc_state = ESP_IDLE;
				esp_sched(sc);
			}
			return;
		} else {
			xs->resid = ecb->dleft;
		}
	}

	xs->flags |= ITSDONE;

#ifdef ESP_DEBUG
	if (esp_debug & ESP_SHOWMISC) {
		printf("err=0x%02x ",xs->error);
		if (xs->error == XS_SENSE) {
			printf("sense=%2x; ", xs->sense.error_code);
		}
	}
	if ((xs->resid || xs->error > XS_SENSE) && esp_debug & ESP_SHOWMISC) {
		if (xs->resid)
			printf("esp_done: resid=%d\n", xs->resid);
		if (xs->error)
			printf("esp_done: error=%d\n", xs->error);
	}
#endif
d481 1
a481 36
	/*
	 * Remove the ECB from whatever queue it's on.
	 */
	switch (ecb->flags & ECB_QBITS) {
	case ECB_QNONE:
		if (ecb != sc->sc_nexus) {
			panic("%s: floating ecb", sc->sc_dev.dv_xname);
		}
		sc->sc_nexus = NULL;
		sc->sc_state = ESP_IDLE;
		ti->lubusy &= ~(1<<sc_link->lun);
		esp_sched(sc);
		break;
	case ECB_QREADY:
		TAILQ_REMOVE(&sc->ready_list, ecb, chain);
		break;
	case ECB_QNEXUS:
		TAILQ_REMOVE(&sc->nexus_list, ecb, chain);
		ti->lubusy &= ~(1<<sc_link->lun);
		break;
	case ECB_QFREE:
		panic("%s: dequeue: busy ecb on free list",
			sc->sc_dev.dv_xname);
		break;
	default:
		panic("%s: dequeue: unknown queue %d",
			sc->sc_dev.dv_xname, ecb->flags & ECB_QBITS);
	}

	/* Put it on the free list, and clear flags. */
	TAILQ_INSERT_HEAD(&sc->free_list, ecb, chain);
	ecb->flags = ECB_QFREE;

	ti->cmds++;
	scsi_done(xs);
	return;
a483 26
/*
 * INTERRUPT/PROTOCOL ENGINE
 */

/*
 * Schedule an outgoing message by prioritizing it, and asserting
 * attention on the bus. We can only do this when we are the initiator
 * else there will be an illegal command interrupt.
 */
#define esp_sched_msgout(m) \
	do {				\
		ESP_MISC(("esp_sched_msgout %d ", m)); \
		ESPCMD(sc, ESPCMD_SETATN);	\
		sc->sc_msgpriq |= (m);	\
	} while (0)

#define IS1BYTEMSG(m) (((m) != 1 && (m) < 0x20) || (m) & 0x80)
#define IS2BYTEMSG(m) (((m) & 0xf0) == 0x20)
#define ISEXTMSG(m) ((m) == 1)

/*
 * Get an incoming message as initiator.
 *
 * The SCSI bus must already be in MESSAGE_IN_PHASE and there is a
 * byte in the FIFO
 */
d485 2
a486 2
esp_msgin(sc)
	register struct esp_softc *sc;
d488 1
a488 37
	register int v;

	ESP_TRACE(("[esp_msgin(curmsglen:%d)] ", sc->sc_imlen));

	if ((ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) == 0) {
		printf("%s: msgin: no msg byte available\n",
			sc->sc_dev.dv_xname);
		return;
	}

	/*
	 * Prepare for a new message.  A message should (according
	 * to the SCSI standard) be transmitted in one single
	 * MESSAGE_IN_PHASE. If we have been in some other phase,
	 * then this is a new message.
	 */
	if (sc->sc_prevphase != MESSAGE_IN_PHASE) {
		sc->sc_flags &= ~ESP_DROP_MSGI;
		sc->sc_imlen = 0;
	}

	v = ESP_READ_REG(sc, ESP_FIFO);
	ESP_MISC(("<msgbyte:0x%02x>", v));

#if 0
	if (sc->sc_state == ESP_RESELECTED && sc->sc_imlen == 0) {
		/*
		 * Which target is reselecting us? (The ID bit really)
		 */
		sc->sc_selid = v;
		sc->sc_selid &= ~(1<<sc->sc_id);
		ESP_MISC(("selid=0x%2x ", sc->sc_selid));
		return;
	}
#endif

	sc->sc_imess[sc->sc_imlen] = v;
d490 1
a490 352
	/*
	 * If we're going to reject the message, don't bother storing
	 * the incoming bytes.  But still, we need to ACK them.
	 */

	if ((sc->sc_flags & ESP_DROP_MSGI)) {
		ESPCMD(sc, ESPCMD_SETATN);
		ESPCMD(sc, ESPCMD_MSGOK);
		printf("<dropping msg byte %x>",
			sc->sc_imess[sc->sc_imlen]);
		return;
	}

	if (sc->sc_imlen >= ESP_MAX_MSG_LEN) {
		esp_sched_msgout(SEND_REJECT);
		sc->sc_flags |= ESP_DROP_MSGI;
	} else {
		sc->sc_imlen++;
		/*
		 * This testing is suboptimal, but most
		 * messages will be of the one byte variety, so
		 * it should not effect performance
		 * significantly.
		 */
		if (sc->sc_imlen == 1 && IS1BYTEMSG(sc->sc_imess[0]))
			goto gotit;
		if (sc->sc_imlen == 2 && IS2BYTEMSG(sc->sc_imess[0]))
			goto gotit;
		if (sc->sc_imlen >= 3 && ISEXTMSG(sc->sc_imess[0]) &&
		    sc->sc_imlen == sc->sc_imess[1] + 2)
			goto gotit;
	}
	/* Ack what we have so far */
	ESPCMD(sc, ESPCMD_MSGOK);
	return;

gotit:
	ESP_MSGS(("gotmsg(%x)", sc->sc_imess[0]));
	/*
	 * Now we should have a complete message (1 byte, 2 byte
	 * and moderately long extended messages).  We only handle
	 * extended messages which total length is shorter than
	 * ESP_MAX_MSG_LEN.  Longer messages will be amputated.
	 */
	if (sc->sc_state == ESP_HASNEXUS) {
		struct ecb *ecb = sc->sc_nexus;
		struct esp_tinfo *ti = &sc->sc_tinfo[ecb->xs->sc_link->target];

		switch (sc->sc_imess[0]) {
		case MSG_CMDCOMPLETE:
			ESP_MSGS(("cmdcomplete "));
			if (sc->sc_dleft < 0) {
				struct scsi_link *sc_link = ecb->xs->sc_link;
				printf("esp: %d extra bytes from %d:%d\n",
					-sc->sc_dleft,
					sc_link->target, sc_link->lun);
				sc->sc_dleft = 0;
			}
			ecb->xs->resid = ecb->dleft = sc->sc_dleft;
			sc->sc_flags |= ESP_BUSFREE_OK;
			break;

		case MSG_MESSAGE_REJECT:
			if (esp_debug & ESP_SHOWMSGS)
				printf("%s: our msg rejected by target\n",
				    sc->sc_dev.dv_xname);
#if 1 /* XXX - must remember last message */
sc_print_addr(ecb->xs->sc_link); printf("MSG_MESSAGE_REJECT>>");
#endif
			if (sc->sc_flags & ESP_SYNCHNEGO) {
				ti->period = ti->offset = 0;
				sc->sc_flags &= ~ESP_SYNCHNEGO;
				ti->flags &= ~T_NEGOTIATE;
			}
			/* Not all targets understand INITIATOR_DETECTED_ERR */
			if (sc->sc_msgout == SEND_INIT_DET_ERR)
				esp_sched_msgout(SEND_ABORT);
			break;
		case MSG_NOOP:
			ESP_MSGS(("noop "));
			break;
		case MSG_DISCONNECT:
			ESP_MSGS(("disconnect "));
			ti->dconns++;
			sc->sc_flags |= ESP_DISCON;
			sc->sc_flags |= ESP_BUSFREE_OK;
			if ((ecb->xs->sc_link->quirks & SDEV_AUTOSAVE) == 0)
				break;
			/*FALLTHROUGH*/
		case MSG_SAVEDATAPOINTER:
			ESP_MSGS(("save datapointer "));
			ecb->dleft = sc->sc_dleft;
			ecb->daddr = sc->sc_dp;
			break;
		case MSG_RESTOREPOINTERS:
			ESP_MSGS(("restore datapointer "));
			if (!ecb) {
				esp_sched_msgout(SEND_ABORT);
				printf("%s: no DATAPOINTERs to restore\n",
				    sc->sc_dev.dv_xname);
				break;
			}
			sc->sc_dp = ecb->daddr;
			sc->sc_dleft = ecb->dleft;
			break;
		case MSG_PARITY_ERROR:
			printf("%s:target%d: MSG_PARITY_ERROR\n",
				sc->sc_dev.dv_xname,
				ecb->xs->sc_link->target);
			break;
		case MSG_EXTENDED:
			ESP_MSGS(("extended(%x) ", sc->sc_imess[2]));
			switch (sc->sc_imess[2]) {
			case MSG_EXT_SDTR:
				ESP_MSGS(("SDTR period %d, offset %d ",
					sc->sc_imess[3], sc->sc_imess[4]));
				ti->period = sc->sc_imess[3];
				ti->offset = sc->sc_imess[4];
				if (sc->sc_minsync == 0) {
					/* We won't do synch */
					ti->offset = 0;
					esp_sched_msgout(SEND_SDTR);
				} else if (ti->offset == 0) {
					printf("%s:%d: async\n", "esp",
						ecb->xs->sc_link->target);
					ti->offset = 0;
					sc->sc_flags &= ~ESP_SYNCHNEGO;
				} else if (ti->period > 124) {
					printf("%s:%d: async\n", "esp",
						ecb->xs->sc_link->target);
					ti->offset = 0;
					esp_sched_msgout(SEND_SDTR);
				} else {
					int r = 250/ti->period;
					int s = (100*250)/ti->period - 100*r;
					int p;
					p =  esp_stp2cpb(sc, ti->period);
					ti->period = esp_cpb2stp(sc, p);
#ifdef ESP_DEBUG
					sc_print_addr(ecb->xs->sc_link);
#endif
					if ((sc->sc_flags&ESP_SYNCHNEGO) == 0) {
						/* Target initiated negotiation */
						if (ti->flags & T_SYNCMODE) {
						    ti->flags &= ~T_SYNCMODE;
#ifdef ESP_DEBUG
						    printf("renegotiated ");
#endif
						}
						ESP_WRITE_REG(sc, ESP_SYNCOFF,
							      0);
						ESP_WRITE_REG(sc, ESP_SYNCTP,
							      0);
						/* Clamp to our maxima */
						if (ti->period < sc->sc_minsync)
							ti->period = sc->sc_minsync;
						if (ti->offset > 15)
							ti->offset = 15;
						esp_sched_msgout(SEND_SDTR);
					} else {
						/* we are sync */
						sc->sc_flags &= ~ESP_SYNCHNEGO;
						ESP_WRITE_REG(sc, ESP_SYNCOFF,
							      ti->offset);
						ESP_WRITE_REG(sc, ESP_SYNCTP,
							      p);
						ti->flags |= T_SYNCMODE;
					}
#ifdef ESP_DEBUG
					printf("max sync rate %d.%02dMb/s\n",
					        r, s);
#endif
				}
				ti->flags &= ~T_NEGOTIATE;
				break;
			default: /* Extended messages we don't handle */
				ESPCMD(sc, ESPCMD_SETATN);
				break;
			}
			break;
		default:
			ESP_MSGS(("ident "));
			/* thanks for that ident... */
			if (!MSG_ISIDENTIFY(sc->sc_imess[0])) {
				ESP_MISC(("unknown "));
printf("%s: unimplemented message: %d\n", sc->sc_dev.dv_xname, sc->sc_imess[0]);
				ESPCMD(sc, ESPCMD_SETATN);
			}
			break;
		}
	} else if (sc->sc_state == ESP_RESELECTED) {
		struct scsi_link *sc_link = NULL;
		struct ecb *ecb;
		struct esp_tinfo *ti;
		u_char lunit;

		if (MSG_ISIDENTIFY(sc->sc_imess[0])) { 	/* Identify? */
			ESP_MISC(("searching "));
			/*
			 * Search wait queue for disconnected cmd
			 * The list should be short, so I haven't bothered with
			 * any more sophisticated structures than a simple
			 * singly linked list.
			 */
			lunit = sc->sc_imess[0] & 0x07;
			for (ecb = sc->nexus_list.tqh_first; ecb;
			     ecb = ecb->chain.tqe_next) {
				sc_link = ecb->xs->sc_link;
				if (sc_link->lun == lunit &&
				    sc->sc_selid == (1<<sc_link->target)) {
					TAILQ_REMOVE(&sc->nexus_list, ecb,
					    chain);
					ECB_SETQ(ecb, ECB_QNONE);
					break;
				}
			}

			if (!ecb) {		/* Invalid reselection! */
				esp_sched_msgout(SEND_ABORT);
				printf("esp: invalid reselect (idbit=0x%2x)\n",
				    sc->sc_selid);
			} else {		/* Reestablish nexus */
				/*
				 * Setup driver data structures and
				 * do an implicit RESTORE POINTERS
				 */
				ti = &sc->sc_tinfo[sc_link->target];
				sc->sc_nexus = ecb;
				sc->sc_dp = ecb->daddr;
				sc->sc_dleft = ecb->dleft;
				sc->sc_tinfo[sc_link->target].lubusy
					|= (1<<sc_link->lun);
				if (ti->flags & T_SYNCMODE) {
					ESP_WRITE_REG(sc, ESP_SYNCOFF,
						ti->offset);
					ESP_WRITE_REG(sc, ESP_SYNCTP,
						esp_stp2cpb(sc, ti->period));
				} else {
					ESP_WRITE_REG(sc, ESP_SYNCOFF, 0);
					ESP_WRITE_REG(sc, ESP_SYNCTP, 0);
				}
				ESP_MISC(("... found ecb"));
				sc->sc_state = ESP_HASNEXUS;
			}
		} else {
			printf("%s: bogus reselect (no IDENTIFY) %0x2x\n",
			    sc->sc_dev.dv_xname, sc->sc_selid);
			esp_sched_msgout(SEND_DEV_RESET);
		}
	} else { /* Neither ESP_HASNEXUS nor ESP_RESELECTED! */
		printf("%s: unexpected message in; will send DEV_RESET\n",
		    sc->sc_dev.dv_xname);
		esp_sched_msgout(SEND_DEV_RESET);
	}

	/* Ack last message byte */
	ESPCMD(sc, ESPCMD_MSGOK);

	/* Done, reset message pointer. */
	sc->sc_flags &= ~ESP_DROP_MSGI;
	sc->sc_imlen = 0;
}


/*
 * Send the highest priority, scheduled message
 */
void
esp_msgout(sc)
	register struct esp_softc *sc;
{
	struct esp_tinfo *ti;
	struct ecb *ecb;
	size_t size;

	ESP_TRACE(("[esp_msgout(priq:%x, prevphase:%x)]", sc->sc_msgpriq, sc->sc_prevphase));

	if (sc->sc_prevphase != MESSAGE_OUT_PHASE) {
		/* Pick up highest priority message */
		sc->sc_msgout = sc->sc_msgpriq & -sc->sc_msgpriq;
		sc->sc_omlen = 1;		/* "Default" message len */
		switch (sc->sc_msgout) {
		case SEND_SDTR:
			ecb = sc->sc_nexus;
			ti = &sc->sc_tinfo[ecb->xs->sc_link->target];
			sc->sc_omess[0] = MSG_EXTENDED;
			sc->sc_omess[1] = 3;
			sc->sc_omess[2] = MSG_EXT_SDTR;
			sc->sc_omess[3] = ti->period;
			sc->sc_omess[4] = ti->offset;
			sc->sc_omlen = 5;
			break;
		case SEND_IDENTIFY:
			if (sc->sc_state != ESP_HASNEXUS) {
				printf("esp at line %d: no nexus", __LINE__);
			}
			ecb = sc->sc_nexus;
			sc->sc_omess[0] = MSG_IDENTIFY(ecb->xs->sc_link->lun,0);
			break;
		case SEND_DEV_RESET:
			sc->sc_omess[0] = MSG_BUS_DEV_RESET;
			sc->sc_flags |= ESP_BUSFREE_OK;
			ecb = sc->sc_nexus;
			ti = &sc->sc_tinfo[ecb->xs->sc_link->target];
			ti->flags &= ~T_SYNCMODE;
			ti->flags |= T_NEGOTIATE;
			break;
		case SEND_PARITY_ERROR:
			sc->sc_omess[0] = MSG_PARITY_ERROR;
			break;
		case SEND_ABORT:
			sc->sc_omess[0] = MSG_ABORT;
			sc->sc_flags |= ESP_BUSFREE_OK;
			break;
		case SEND_INIT_DET_ERR:
			sc->sc_omess[0] = MSG_INITIATOR_DET_ERR;
			break;
		case SEND_REJECT:
			sc->sc_omess[0] = MSG_MESSAGE_REJECT;
			break;
		default:
			sc->sc_omess[0] = MSG_NOOP;
			break;
		}
		sc->sc_omp = sc->sc_omess;
	}

#if 1
	/* (re)send the message */
	size = min(sc->sc_omlen, sc->sc_maxxfer);
	DMA_SETUP(sc->sc_dma, &sc->sc_omp, &sc->sc_omlen, 0, &size);
	/* Program the SCSI counter */
	ESP_WRITE_REG(sc, ESP_TCL, size);
	ESP_WRITE_REG(sc, ESP_TCM, size >> 8);
	if (sc->sc_cfg2 & ESPCFG2_FE) {
		ESP_WRITE_REG(sc, ESP_TCH, size >> 16);
	}
	/* load the count in */
	ESPCMD(sc, ESPCMD_NOP|ESPCMD_DMA);
	ESPCMD(sc, (size==0?ESPCMD_TRPAD:ESPCMD_TRANS)|ESPCMD_DMA);
	DMA_GO(sc->sc_dma);
#else
	{	int i;
		ESPCMD(sc, ESPCMD_FLUSH);
		for (i = 0; i < sc->sc_omlen; i++)
			ESP_WRITE_REG(sc, FIFO, sc->sc_omess[i]);
		ESPCMD(sc, ESPCMD_TRANS);
#if test_stuck_on_msgout
printf("<<XXXmsgoutdoneXXX>>");
#endif
	}
#endif
a492 9
/*
 * This is the most critical part of the driver, and has to know
 * how to deal with *all* error conditions and phases from the SCSI
 * bus. If there are no errors and the DMA was active, then call the
 * DMA pseudo-interrupt handler. If this returns 1, then that was it
 * and we can return from here without further processing.
 *
 * Most of this needs verifying.
 */
d494 2
a495 585
espintr(sc)
	register struct esp_softc *sc;
{
	register struct ecb *ecb;
	register struct scsi_link *sc_link;
	struct esp_tinfo *ti;
	int loop;
	size_t size;

	ESP_TRACE(("[espintr]"));

	/*
	 * I have made some (maybe seriously flawed) assumptions here,
	 * but basic testing (uncomment the printf() below), show that
	 * certainly something happens when this loop is here.
	 *
	 * The idea is that many of the SCSI operations take very little
	 * time, and going away and getting interrupted is too high an
	 * overhead to pay. For example, selecting, sending a message
	 * and command and then doing some work can be done in one "pass".
	 *
	 * The DELAY is not variable because I do not understand that the
	 * DELAY loop should be fixed-time regardless of CPU speed, but
	 * I am *assuming* that the faster SCSI processors get things done
	 * quicker (sending a command byte etc), and so there is no
	 * need to be too slow.
	 *
	 * This is a heuristic. It is 2 when at 20Mhz, 2 at 25Mhz and 1
	 * at 40Mhz. This needs testing.
	 */
	for (loop = 0; 1;loop++, DELAY(50/sc->sc_freq)) {
		/* a feeling of deja-vu */
		if (!DMA_ISINTR(sc->sc_dma))
			return (loop != 0);
#if 0
		if (loop)
			printf("*");
#endif

		/* and what do the registers say... */
		espreadregs(sc);

		sc->sc_intrcnt.ev_count++;

		/*
		 * At the moment, only a SCSI Bus Reset or Illegal
		 * Command are classed as errors. A disconnect is a
		 * valid condition, and we let the code check is the
		 * "ESP_BUSFREE_OK" flag was set before declaring it
		 * and error.
		 *
		 * Also, the status register tells us about "Gross
		 * Errors" and "Parity errors". Only the Gross Error
		 * is really bad, and the parity errors are dealt
		 * with later
		 *
		 * TODO
		 *	If there are too many parity error, go to slow
		 *	cable mode ?
		 */

		/* SCSI Reset */
		if (sc->sc_espintr & ESPINTR_SBR) {
			if (ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) {
				ESPCMD(sc, ESPCMD_FLUSH);
				DELAY(1);
			}
			if (sc->sc_state != ESP_SBR) {
				printf("%s: SCSI bus reset\n",
					sc->sc_dev.dv_xname);
				esp_init(sc, 0); /* Restart everything */
				return 1;
			}
#if 0
	/*XXX*/		printf("<expected bus reset: "
				"[intr %x, stat %x, step %d]>\n",
				sc->sc_espintr, sc->sc_espstat,
				sc->sc_espstep);
#endif
			if (sc->sc_nexus)
				panic("%s: nexus in reset state",
				      sc->sc_dev.dv_xname);
			sc->sc_state = ESP_IDLE;
			esp_sched(sc);
			return 1;
		}

		ecb = sc->sc_nexus;

#define ESPINTR_ERR (ESPINTR_SBR|ESPINTR_ILL)
		if (sc->sc_espintr & ESPINTR_ERR ||
		    sc->sc_espstat & ESPSTAT_GE) {

			if (sc->sc_espstat & ESPSTAT_GE) {
				/* no target ? */
				if (ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) {
					ESPCMD(sc, ESPCMD_FLUSH);
					DELAY(1);
				}
				if (sc->sc_state == ESP_HASNEXUS ||
				    sc->sc_state == ESP_SELECTING) {
					ecb->xs->error = XS_DRIVER_STUFFUP;
					esp_done(ecb);
				}
				return 1;
			}

			if (sc->sc_espintr & ESPINTR_ILL) {
				/* illegal command, out of sync ? */
				printf("%s: illegal command: 0x%x (state %d, phase %x, prevphase %x)\n",
					sc->sc_dev.dv_xname, sc->sc_lastcmd,
					sc->sc_state, sc->sc_phase,
					sc->sc_prevphase);
				if (ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) {
					ESPCMD(sc, ESPCMD_FLUSH);
					DELAY(1);
				}
				esp_init(sc, 0); /* Restart everything */
				return 1;
			}
		}

		/*
		 * Call if DMA is active.
		 *
		 * If DMA_INTR returns true, then maybe go 'round the loop
		 * again in case there is no more DMA queued, but a phase
		 * change is expected.
		 */
		if (DMA_ISACTIVE(sc->sc_dma)) {
			DMA_INTR(sc->sc_dma);
			/* If DMA active here, then go back to work... */
			if (DMA_ISACTIVE(sc->sc_dma))
				return 1;

			if (sc->sc_dleft == 0 &&
			    (sc->sc_espstat & ESPSTAT_TC) == 0)
				printf("%s: !TC [intr %x, stat %x, step %d]"
				       " prevphase %x, resid %x\n",
					sc->sc_dev.dv_xname,
					sc->sc_espintr,
					sc->sc_espstat,
					sc->sc_espstep,
					sc->sc_prevphase,
					ecb?ecb->dleft:-1);
		}

#if 0	/* Unreliable on some ESP revisions? */
		if ((sc->sc_espstat & ESPSTAT_INT) == 0) {
			printf("%s: spurious interrupt\n", sc->sc_dev.dv_xname);
			return 1;
		}
#endif

		/*
		 * check for less serious errors
		 */
		if (sc->sc_espstat & ESPSTAT_PE) {
			printf("%s: SCSI bus parity error\n",
				sc->sc_dev.dv_xname);
			if (sc->sc_prevphase == MESSAGE_IN_PHASE)
				esp_sched_msgout(SEND_PARITY_ERROR);
			else
				esp_sched_msgout(SEND_INIT_DET_ERR);
		}

		if (sc->sc_espintr & ESPINTR_DIS) {
			ESP_MISC(("<DISC [intr %x, stat %x, step %d]>",
				sc->sc_espintr,sc->sc_espstat,sc->sc_espstep));
			if (ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) {
				ESPCMD(sc, ESPCMD_FLUSH);
				DELAY(1);
			}
			/*
			 * This command must (apparently) be issued within
			 * 250mS of a disconnect. So here you are...
			 */
			ESPCMD(sc, ESPCMD_ENSEL);
			if (sc->sc_state != ESP_IDLE) {
				if ((sc->sc_flags & ESP_SYNCHNEGO)) {
#ifdef ESP_DEBUG
					if (ecb)
						sc_print_addr(ecb->xs->sc_link);
					printf("sync nego not completed!\n");
#endif
					sc->sc_flags &= ~ESP_SYNCHNEGO;
					sc->sc_tinfo[ecb->xs->sc_link->target].offset = 0;
					sc->sc_tinfo[ecb->xs->sc_link->target].flags &= ~T_NEGOTIATE;
				}
			/*XXX*/sc->sc_msgpriq = sc->sc_msgout = 0;

				/* it may be OK to disconnect */
				if (!(sc->sc_flags & ESP_BUSFREE_OK)) {
					if (sc->sc_state == ESP_HASNEXUS) {
						sc_print_addr(ecb->xs->sc_link);
						printf("disconnect without"
							"warning\n");
					}
					ecb->xs->error = XS_TIMEOUT;
				} else if (sc->sc_flags & ESP_DISCON) {
					TAILQ_INSERT_HEAD(&sc->nexus_list, ecb, chain);
					ECB_SETQ(ecb, ECB_QNEXUS);
					sc->sc_nexus = NULL;
					sc->sc_flags &= ~ESP_DISCON;
					sc->sc_state = ESP_IDLE;
#if ESP_DEBUG
if ((esp_debug & 0x10000) && ecb->dleft == 0) {
	printf("%s: silly disconnect (ecb %p [stat %x])\n",
		sc->sc_dev.dv_xname, ecb, ecb->stat);
}
#endif
					esp_sched(sc);
					return 1;
				}

				esp_done(ecb);
				return 1;
			}
			printf("%s: DISCONNECT in IDLE state!\n",
				sc->sc_dev.dv_xname);
		}

		/* did a message go out OK ? This must be broken */
		if (sc->sc_prevphase == MESSAGE_OUT_PHASE &&
		    sc->sc_phase != MESSAGE_OUT_PHASE) {
			/* we have sent it */
			if (sc->sc_msgout == SEND_SDTR &&
			    (sc->sc_flags & ESP_SYNCHNEGO) == 0) {
				/* We've just accepted new sync parameters */
				sc->sc_tinfo[ecb->xs->sc_link->target].flags |=
					T_SYNCMODE;
if (ecb) sc_print_addr(ecb->xs->sc_link);else printf("NO nexus: ");
printf("target put in SYNC mode\n");
			}
			sc->sc_msgpriq &= ~sc->sc_msgout;
			sc->sc_msgout = 0;
		}

		switch (sc->sc_state) {

		case ESP_SBR:
			printf("%s: waiting for SCSI Bus Reset to happen\n",
				sc->sc_dev.dv_xname);
			return 1;

		case ESP_RESELECTED:
			/*
			 * we must be continuing a message ?
			 */
			if (sc->sc_phase != MESSAGE_IN_PHASE) {
				printf("%s: target didn't identify\n",
					sc->sc_dev.dv_xname);
				esp_init(sc, 1);
				return 1;
			}
printf("<<RESELECT CONT'd>>");
#if XXXX
			esp_msgin(sc);
			if (sc->sc_state != ESP_HASNEXUS) {
				/* IDENTIFY fail?! */
				printf("%s: identify failed\n",
					sc->sc_dev.dv_xname);
				esp_init(sc, 1);
				return 1;
			}
#endif
			break;

		case ESP_IDLE:
if (sc->sc_flags & ESP_ICCS) printf("[[esp: BUMMER]]");
		case ESP_SELECTING:

			if (sc->sc_espintr & ESPINTR_RESEL) {
				/*
				 * If we're trying to select a
				 * target ourselves, push our command
				 * back into the ready list.
				 */
				if (sc->sc_state == ESP_SELECTING) {
					ESP_MISC(("backoff selector "));
					sc_link = sc->sc_nexus->xs->sc_link;
					ti = &sc->sc_tinfo[sc_link->target];
					TAILQ_INSERT_HEAD(&sc->ready_list,
					    sc->sc_nexus, chain);
					ECB_SETQ(sc->sc_nexus, ECB_QREADY);
					ti->lubusy &= ~(1<<sc_link->lun);
					ecb = sc->sc_nexus = NULL;
				}
				sc->sc_state = ESP_RESELECTED;
				if (sc->sc_phase != MESSAGE_IN_PHASE) {
					/*
					 * Things are seriously fucked up.
					 * Pull the brakes, i.e. reset
					 */
					printf("%s: target didn't identify\n",
						sc->sc_dev.dv_xname);
					esp_init(sc, 1);
					return 1;
				}
				if ((ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) != 2) {
					printf("%s: RESELECT: %d bytes in FIFO!\n",
						sc->sc_dev.dv_xname,
						ESP_READ_REG(sc, ESP_FFLAG) &
						ESPFIFO_FF);
					esp_init(sc, 1);
					return 1;
				}
				sc->sc_selid = ESP_READ_REG(sc, ESP_FIFO);
				sc->sc_selid &= ~(1<<sc->sc_id);
				ESP_MISC(("selid=0x%2x ", sc->sc_selid));
				esp_msgin(sc);	/* Handle identify message */
				if (sc->sc_state != ESP_HASNEXUS) {
					/* IDENTIFY fail?! */
					printf("%s: identify failed\n",
						sc->sc_dev.dv_xname);
					esp_init(sc, 1);
					return 1;
				}
				continue; /* ie. next phase expected soon */
			}

#define	ESPINTR_DONE	(ESPINTR_FC|ESPINTR_BS)
			if ((sc->sc_espintr & ESPINTR_DONE) == ESPINTR_DONE) {
				ecb = sc->sc_nexus;
				if (!ecb)
					panic("esp: not nexus at sc->sc_nexus");

				sc_link = ecb->xs->sc_link;
				ti = &sc->sc_tinfo[sc_link->target];

				switch (sc->sc_espstep) {
				case 0:
					printf("%s: select timeout/no disconnect\n",
						sc->sc_dev.dv_xname);
					esp_abort(sc, ecb);
					return 1;
				case 1:
					if ((ti->flags & T_NEGOTIATE) == 0) {
						printf("%s: step 1 & !NEG\n",
							sc->sc_dev.dv_xname);
						esp_abort(sc, ecb);
						return 1;
					}
					if (sc->sc_phase != MESSAGE_OUT_PHASE) {
						printf("%s: !MSGOUT\n",
							sc->sc_dev.dv_xname);
						esp_abort(sc, ecb);
						return 1;
					}
					/* Start negotiating */
					ti->period = sc->sc_minsync;
					ti->offset = 15;
					sc->sc_msgpriq = SEND_SDTR;
					sc->sc_flags |= ESP_SYNCHNEGO;
					break;
				case 3:
					/*
					 * Grr, this is supposed to mean
					 * "target left command phase
					 *  prematurely". It seems to happen
					 * regularly when sync mode is on.
					 * Look at FIFO to see if command
					 * went out.
					 * (Timing problems?)
					 */
					if ((ESP_READ_REG(sc, ESP_FFLAG)&ESPFIFO_FF) == 0) {
						/* Hope for the best.. */
						break;
					}
					printf("(%s:%d:%d): selection failed;"
						" %d left in FIFO "
						"[intr %x, stat %x, step %d]\n",
						sc->sc_dev.dv_xname,
						sc_link->target,
						sc_link->lun,
						ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF,
						sc->sc_espintr, sc->sc_espstat,
						sc->sc_espstep);
					ESPCMD(sc, ESPCMD_FLUSH);
					sc->sc_flags |= ESP_ABORTING;
					esp_sched_msgout(SEND_ABORT);
					return 1;
				case 2:
					/* Select stuck at Command Phase */
					ESPCMD(sc, ESPCMD_FLUSH);
				case 4:
					/* So far, everything went fine */
					sc->sc_msgpriq = 0;
					break;
				}
#if 0
/* Why set msgpriq? (and not raise ATN) */
				if (ecb->xs->flags & SCSI_RESET)
					sc->sc_msgpriq = SEND_DEV_RESET;
				else if (ti->flags & T_NEGOTIATE)
					sc->sc_msgpriq =
					    SEND_IDENTIFY | SEND_SDTR;
				else
					sc->sc_msgpriq = SEND_IDENTIFY;
#endif
				sc->sc_state = ESP_HASNEXUS;
				/*???sc->sc_flags = 0; */
				sc->sc_prevphase = INVALID_PHASE; /* ?? */
				sc->sc_dp = ecb->daddr;
				sc->sc_dleft = ecb->dleft;
				ti->lubusy |= (1<<sc_link->lun);
				break;
			} else {
				printf("%s: unexpected status after select"
					": [intr %x, stat %x, step %x]\n",
					sc->sc_dev.dv_xname,
					sc->sc_espintr, sc->sc_espstat,
					sc->sc_espstep);
				ESPCMD(sc, ESPCMD_FLUSH);
				DELAY(1);
				esp_abort(sc, ecb);
			}
			if (sc->sc_state == ESP_IDLE) {
				printf("%s: stray interrupt\n", sc->sc_dev.dv_xname);
					return 0;
			}
			break;

		case ESP_HASNEXUS:
			if (sc->sc_flags & ESP_ICCS) {
				unsigned char msg;

				sc->sc_flags &= ~ESP_ICCS;

				if (!(sc->sc_espintr & ESPINTR_DONE)) {
					printf("%s: ICCS: "
					      ": [intr %x, stat %x, step %x]\n",
						sc->sc_dev.dv_xname,
						sc->sc_espintr, sc->sc_espstat,
						sc->sc_espstep);
				}
				if ((ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) != 2) {
					printf("%s: ICCS: expected 2, got %d "
					      ": [intr %x, stat %x, step %x]\n",
						sc->sc_dev.dv_xname,
						ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF,
						sc->sc_espintr, sc->sc_espstat,
						sc->sc_espstep);
					ESPCMD(sc, ESPCMD_FLUSH);
					esp_abort(sc, ecb);
					return 1;
				}
				ecb->stat = ESP_READ_REG(sc, ESP_FIFO);
				msg = ESP_READ_REG(sc, ESP_FIFO);
				ESP_PHASE(("<stat:(%x,%x)>", ecb->stat, msg));
				if (msg == MSG_CMDCOMPLETE) {
					sc->sc_flags |= ESP_BUSFREE_OK;
					ecb->xs->resid = ecb->dleft = sc->sc_dleft;
				} else
					printf("%s: STATUS_PHASE: msg %d\n",
						sc->sc_dev.dv_xname, msg);
				ESPCMD(sc, ESPCMD_MSGOK);
				continue; /* ie. wait for disconnect */
			}
			break;
		default:
			panic("%s: invalid state: %d",
			      sc->sc_dev.dv_xname,
			      sc->sc_state);
		}

		/*
		 * Driver is now in state ESP_HASNEXUS, i.e. we
		 * have a current command working the SCSI bus.
		 */
		if (sc->sc_state != ESP_HASNEXUS || ecb == NULL) {
			panic("esp no nexus");
		}

		switch (sc->sc_phase) {
		case MESSAGE_OUT_PHASE:
			ESP_PHASE(("MESSAGE_OUT_PHASE "));
			esp_msgout(sc);
			sc->sc_prevphase = MESSAGE_OUT_PHASE;
			break;
		case MESSAGE_IN_PHASE:
			ESP_PHASE(("MESSAGE_IN_PHASE "));
			if (sc->sc_espintr & ESPINTR_BS) {
				ESPCMD(sc, ESPCMD_FLUSH);
				sc->sc_flags |= ESP_WAITI;
				ESPCMD(sc, ESPCMD_TRANS);
			} else if (sc->sc_espintr & ESPINTR_FC) {
				if ((sc->sc_flags & ESP_WAITI) == 0) {
					printf("%s: MSGIN: unexpected FC bit: "
						"[intr %x, stat %x, step %x]\n",
					sc->sc_dev.dv_xname,
					sc->sc_espintr, sc->sc_espstat,
					sc->sc_espstep);
				}
				sc->sc_flags &= ~ESP_WAITI;
				esp_msgin(sc);
			} else {
				printf("%s: MSGIN: weird bits: "
					"[intr %x, stat %x, step %x]\n",
					sc->sc_dev.dv_xname,
					sc->sc_espintr, sc->sc_espstat,
					sc->sc_espstep);
			}
			sc->sc_prevphase = MESSAGE_IN_PHASE;
			break;
		case COMMAND_PHASE: {
			/* well, this means send the command again */
			u_char *cmd = (u_char *)&ecb->cmd;
			int i;

			ESP_PHASE(("COMMAND_PHASE 0x%02x (%d) ",
				ecb->cmd.opcode, ecb->clen));
			if (ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) {
				ESPCMD(sc, ESPCMD_FLUSH);
				DELAY(1);
			}
			/* Now the command into the FIFO */
			for (i = 0; i < ecb->clen; i++)
				ESP_WRITE_REG(sc, ESP_FIFO, *cmd++);
			ESPCMD(sc, ESPCMD_TRANS);
			sc->sc_prevphase = COMMAND_PHASE;
			}
			break;
		case DATA_OUT_PHASE:
			ESP_PHASE(("DATA_OUT_PHASE [%d] ",  sc->sc_dleft));
			ESPCMD(sc, ESPCMD_FLUSH);
			size = min(sc->sc_dleft, sc->sc_maxxfer);
			DMA_SETUP(sc->sc_dma, &sc->sc_dp, &sc->sc_dleft,
				  0, &size);
			sc->sc_prevphase = DATA_OUT_PHASE;
			goto setup_xfer;
		case DATA_IN_PHASE:
			ESP_PHASE(("DATA_IN_PHASE "));
			if (sc->sc_rev == ESP100)
				ESPCMD(sc, ESPCMD_FLUSH);
			size = min(sc->sc_dleft, sc->sc_maxxfer);
			DMA_SETUP(sc->sc_dma, &sc->sc_dp, &sc->sc_dleft,
				  1, &size);
			sc->sc_prevphase = DATA_IN_PHASE;
		setup_xfer:
			/* Program the SCSI counter */
			ESP_WRITE_REG(sc, ESP_TCL, size);
			ESP_WRITE_REG(sc, ESP_TCM, size >> 8);
			if (sc->sc_cfg2 & ESPCFG2_FE) {
				ESP_WRITE_REG(sc, ESP_TCH, size >> 16);
			}
			/* load the count in */
			ESPCMD(sc, ESPCMD_NOP|ESPCMD_DMA);

			/*
			 * Note that if `size' is 0, we've already transceived
			 * all the bytes we want but we're still in DATA PHASE.
			 * Apparently, the device needs padding. Also, a
			 * transfer size of 0 means "maximum" to the chip
			 * DMA logic.
			 */
			ESPCMD(sc,
			       (size==0?ESPCMD_TRPAD:ESPCMD_TRANS)|ESPCMD_DMA);
			DMA_GO(sc->sc_dma);
			return 1;
		case STATUS_PHASE:
			ESP_PHASE(("STATUS_PHASE "));
			sc->sc_flags |= ESP_ICCS;
			ESPCMD(sc, ESPCMD_ICCS);
			sc->sc_prevphase = STATUS_PHASE;
			break;
		case INVALID_PHASE:
			break;
		case BUSFREE_PHASE:
			if (sc->sc_flags & ESP_BUSFREE_OK) {
				/*It's fun the 1st time.. */
				sc->sc_flags &= ~ESP_BUSFREE_OK;
			}
			break;
		default:
			panic("esp: bogus bus phase\n");
		}
	}
	panic("esp: should not get here..");
}

void
esp_abort(sc, ecb)
	struct esp_softc *sc;
	struct ecb *ecb;
d497 1
a497 10
	if (ecb == sc->sc_nexus) {
		if (sc->sc_state == ESP_HASNEXUS) {
			sc->sc_flags |= ESP_ABORTING;
			esp_sched_msgout(SEND_ABORT);
		}
	} else {
		if (sc->sc_state == ESP_IDLE)
			esp_sched(sc);
	}
}
d499 1
a499 52
void
esp_timeout(arg)
	void *arg;
{
	int s = splbio();
	struct ecb *ecb = (struct ecb *)arg;
	struct esp_softc *sc;
	struct scsi_xfer *xs = ecb->xs;

	sc = xs->sc_link->adapter_softc;
	sc_print_addr(xs->sc_link);
again:
	printf("%s: timed out [ecb %p (flags 0x%x, dleft %x, stat %x)], "
	       "<state %d, nexus %p, phase(c %x, p %x), resid %x, msg(q %x,o %x) %s>",
		sc->sc_dev.dv_xname,
		ecb, ecb->flags, ecb->dleft, ecb->stat,
		sc->sc_state, sc->sc_nexus, sc->sc_phase, sc->sc_prevphase,
		sc->sc_dleft, sc->sc_msgpriq, sc->sc_msgout,
		DMA_ISACTIVE(sc->sc_dma) ? "DMA active" : "");
#if ESP_DEBUG > 0
	printf("TRACE: %s.", ecb->trace);
#endif

	if (ecb->flags & ECB_ABORTED) {
		/* abort timed out */
		printf(" AGAIN\n");
		esp_init(sc, 1);
	} else {
		/* abort the operation that has timed out */
		printf("\n");
		xs->error = XS_TIMEOUT;
		ecb->flags |= ECB_ABORTED;
		esp_abort(sc, ecb);
		/* 2 secs for the abort */
		if ((xs->flags & SCSI_POLL) == 0)
			timeout(esp_timeout, ecb, 2 * hz);
		else {
			int count = 200000;
			while (count) {
				if (DMA_ISINTR(sc->sc_dma)) {
					espintr(sc);
				}
				if (xs->flags & ITSDONE)
					break;
				DELAY(10);
				--count;
			}
			if (count == 0)
				goto again;
		}
	}
	splx(s);
@


1.8
log
@netbsd port, now we merge our changes back in
@
text
@d71 1
a71 1
/*static*/ int	espprint	__P((void *, char *));
d117 1
a117 1
	char *name;
@


1.7
log
@new mapdev/()/mapiodev() calling convention uses "struct rom_reg *" to supply
base plus an offset
new dvma routines
@
text
@d1 2
d4 4
a7 2
 * Copyright (c) 1995 Theo de Raadt
 * 
d18 1
a18 2
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt.
d22 11
a32 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d36 5
a40 8
 * Based IN PART on aic6360 by Jarle Greipsland, an older esp driver
 * by Peter Galbavy, and work by Charles Hannum on a few other drivers.
 */

/*
 * todo:
 * fix & enable sync
 * confirm parity and bus failures do not lock up driver
d62 1
a63 1
#include <sparc/dev/dmareg.h>
d67 1
a67 1
int esp_debug = ESP_SHOWPHASE|ESP_SHOWMISC|ESP_SHOWTRAC|ESP_SHOWCMDS; /**/ 
d69 26
a94 5
#if 1
#define ESPD(x)	
#else
#define ESPD(x)	printf x
#endif
d96 2
a97 21
void	espattach	__P((struct device *, struct device *, void *));
int	espmatch	__P((struct device *, void *, void *));
int	espprint	__P((void *, char *));
void	espreadregs	__P((struct esp_softc *));
int	espgetbyte	__P((struct esp_softc *, int));
void	espselect	__P((struct esp_softc *));
void	esp_reset	__P((struct esp_softc *));
void	esp_init	__P((struct esp_softc *, int));
int	esp_scsi_cmd	__P((struct scsi_xfer *));
int	esp_poll	__P((struct esp_softc *, struct ecb *));
int	espphase	__P((struct esp_softc *));
void	esp_sched	__P((struct esp_softc *));
void	esp_done	__P((struct ecb *));
void	esp_msgin	__P((struct esp_softc *));
void	esp_makemsg	__P((struct esp_softc *));
void	esp_msgout	__P((struct esp_softc *));
int	espintr		__P((struct esp_softc *));
void	esp_timeout	__P((void *arg));

struct cfdriver espcd = {
	NULL, "esp", espmatch, espattach, DV_DULL, sizeof(struct esp_softc)
d101 4
a104 1
	esp_scsi_cmd, minphys, NULL, NULL
d108 4
a111 1
	NULL, NULL, NULL, NULL
a113 3
/*
 * Does anyone actually use this, and what for ?
 */
d119 3
a121 1
	return (UNCONF);
a123 1

a140 1

a150 1
	struct espregs *espr;
d152 1
a152 1
	int freq;
d171 1
a171 1
		sc->sc_regs = (struct espregs *) ca->ca_ra.ra_vaddr;
d173 2
a174 3
		sc->sc_regs = (struct espregs *)
		    mapiodev(ca->ca_ra.ra_reg, 0, ca->ca_ra.ra_len,
		    ca->ca_bustype);
a175 1
	espr = sc->sc_regs;
d190 2
a191 1
	freq = sc->sc_freq / 1000000;		/* gimme Mhz */
d193 16
a208 7
	/*
	 * This is the value used to start sync negotiations. For a
	 * 25Mhz clock, this gives us 40, or 160nS, or 6.25Mb/s. It
	 * is constant for each adapter. In turn, notice that the ESP
	 * register "SYNCTP" is = (250 / the negotiated period).
	 */
	sc->sc_minsync = 1000 / freq;
d210 8
a217 19
	/* 0 is actually 8, even though the register only has 3 bits */
	sc->sc_ccf = FREQTOCCF(freq) & 0x07;

	/* The value must not be 1 -- make it 2 */
	if (sc->sc_ccf == 1)
		sc->sc_ccf = 2;

	/*
	 * The recommended timeout is 250ms (1/4 seconds). This
	 * register is loaded with a value calculated as follows:
	 *
	 *		(timout period) x (CLK frequency)
	 *	reg = -------------------------------------
	 *		 8192 x (Clock Conversion Factor)
	 *
	 * We have the CCF from above. For a 25MHz clock this gives
	 * a constant of 153 (we round up).
	 */
	sc->sc_timeout = (sc->sc_freq / 4 / 8192 / sc->sc_ccf) + 1;
d220 3
a222 1
	 * find the corresponding DMA controller.
a223 5
	sc->sc_dma = ((struct dma_softc *)getdevunit("dma",
	    sc->sc_dev.dv_unit));
	if (sc->sc_dma)
		sc->sc_dma->sc_esp = sc;

d225 3
a227 2
	sc->sc_cfg2 = 0;
	sc->sc_cfg3 = 0;
d229 1
a229 7
	/*
	 * The ESP100 only has a cfg1 register. The ESP100A has it, but
	 * lacks the cfg3 register. Thus, we can tell which chip we have.
	 * XXX: what about the FAS100A?
	 */
	espr->espr_cfg2 = ESPCFG2_SCSI2 | ESPCFG2_RPE;
	if ((espr->espr_cfg2 & ~ESPCFG2_RSVD) != (ESPCFG2_SCSI2 | ESPCFG2_RPE)) {
d233 7
a239 4
		espr->espr_cfg2 = 0;
		espr->espr_cfg3 = 0;
		espr->espr_cfg3 = ESPCFG3_CDB | ESPCFG3_FCLK;
		if (espr->espr_cfg3 != (ESPCFG3_CDB | ESPCFG3_FCLK)) {
a240 1
			/* XXX sc->sc_cfg2 = ESPCFG2_SCSI2 | ESPCFG2_FE; */
d243 4
a246 1
			espr->espr_cfg3 = 0;
d252 53
d308 1
a308 1
	printf(" %dMhz, target %d\n", freq, sc->sc_id);
d310 2
d314 4
a317 9
		/* add to the sbus structures */
		sc->sc_sd.sd_reset = (void *) esp_reset;
		sbus_establish(&sc->sc_sd, &sc->sc_dev);

		/*
		 * If the device is in an SBUS slave slot, bail now.
		 */
		if (sbus_slavecheck(self, ca))
			return;
d321 1
a321 1
	/* and the interupts */
d337 3
a339 4
	 * If the boot path is "esp", and the numbers point to
	 * this controller, then advance the bootpath a step.
	 * XXX boot /sbus/esp/sd@@3,0 passes in esp@@0,0 -- which
	 * is almost always wrong, but match in that case anyways.
d345 1
a345 3
		    ((bp->val[0]==ca->ca_slot &&
		     (bp->val[1]==ca->ca_offset || bp->val[1]==0)) ||
		    (bp->val[0]==-1 && bp->val[1]==sc->sc_dev.dv_unit)))
d350 1
a350 1
		    bp->val[0] == -1 && bp->val[1] == sc->sc_dev.dv_unit)
a362 1

d364 6
a369 3
 * Warning: This inserts two commands into the ESP command fifo.  Because
 * there are only 2 entries in that fifo, you may need to put a DELAY(1)
 * after calling this, if you are going to issue another command soon.
d372 1
a372 1
espflush(sc)
a374 1
	struct espregs *espr = sc->sc_regs;
d376 27
a402 3
	if (espr->espr_fflag & ESPFIFO_FF) {
		espr->espr_cmd = ESPCMD_FLUSH;
		espr->espr_cmd = ESPCMD_NOP;
d407 1
a407 1
 * returns -1 if no byte is available because fifo is empty.
d409 2
a410 2
int
espgetbyte(sc, dotrans)
a411 1
	int dotrans;
d413 2
a414 1
	struct espregs *espr = sc->sc_regs;
d416 2
a417 3
	if (espr->espr_fflag & ESPFIFO_FF)
		return espr->espr_fifo;
	return -1;
d421 1
a421 12
 * Send a command to a target, as well as any required messages.
 * There are three cases. The first two cases are fairly simple..
 * 1) command alone
 * 	load command into fifo, and use ESPCMD_SELNATN
 * 2) MSG_IDENTIFY + command
 *	load message and command into fifo, and use ESPCMD_SELATN
 * 3) a bunch of messages + command
 *	load first message byte into fifo. Use ESPCMD_SELATNS. When the
 *	next interrupt occurs, load the remainer of the message into
 *	the fifo and use ESPCMD_TRANS. When the device is ready to
 *	receive the command, it will switch into COMMAND_PHASE, and
 *	at that point we will feed it the command.
d424 1
a424 1
espselect(sc)
d426 1
d428 52
a479 20
	struct espregs *espr = sc->sc_regs;
	register struct ecb *ecb = sc->sc_nexus;
	register struct scsi_link *sc_link = ecb->xs->sc_link;
	struct esp_tinfo *ti = &sc->sc_tinfo[sc_link->target];
	u_char *cmd = (u_char *)&ecb->cmd;
	int loadcmd = 1;
	int outcmd, i;

	espr->espr_selid = sc_link->target;
	espr->espr_syncoff = ti->offset;
	espr->espr_synctp = ti->synctp;

	sc->sc_state = ESPS_SELECTING;

	if (ecb->xs->flags & SCSI_RESET)
		sc->sc_msgpriq = SEND_DEV_RESET;
	else if (ti->flags & DO_NEGOTIATE)
		sc->sc_msgpriq = SEND_SDTR;
	else
		sc->sc_msgpriq = SEND_IDENTIFY;
d481 5
a485 2
	if (sc->sc_msgpriq) {
		esp_makemsg(sc);
d487 3
a489 35
		ESPD(("OM["));
		for (i = 0; i < sc->sc_omlen; i++)
			ESPD(("%02x%c", sc->sc_omp[i],
			    (i == sc->sc_omlen-1) ? ']' : ' '));
		ESPD((" "));

		espr->espr_fifo = sc->sc_omp[0];	/* 1st msg byte only */
		if (sc->sc_omlen == 1) {
			outcmd = ESPCMD_SELATN;
		} else {
			outcmd = ESPCMD_SELATNS;
			/* and this will will load the rest of the msg bytes */
			sc->sc_state = ESPS_SELECTSTOP;
			loadcmd = 0;
		}
	} else
		outcmd = ESPCMD_SELNATN;

	ESPD(("P%d/%02x/%d ", (ecb->xs->flags & SCSI_POLL) ? 1 : 0, outcmd, loadcmd));

	if (loadcmd) {
		ESPD(("CMD["));
		for (i = 0; i < ecb->clen; i++)
			ESPD(("%02x%c", cmd[i],
			    (i == ecb->clen-1) ? ']' : ' '));
		ESPD((" "));

		/* load the command into the FIFO */
		for (i = 0; i < ecb->clen; i++)
			espr->espr_fifo = cmd[i];
	}

	espr->espr_cmd = outcmd;
	if (!(ecb->xs->flags & SCSI_POLL))
		sc->sc_flags |= ESPF_MAYDISCON;
a491 1

d493 7
a499 2
 * Reset the ESP and DMA chips. Stops any transactions dead in the water;
 * does not cause an interrupt.
d501 2
a502 2
void 
esp_reset(sc)
a504 1
	struct espregs *espr = sc->sc_regs;
d506 13
a518 1
	dmareset(sc->sc_dma);		/* reset DMA first */
d520 19
a538 4
	espr->espr_cmd = ESPCMD_RSTCHIP;
	DELAY(5);
	espr->espr_cmd = ESPCMD_NOP;
	DELAY(5);
d540 9
a548 13
	/* do these backwards, and fall through */
	switch (sc->sc_rev) {
	case ESP200:
		espr->espr_cfg3 = sc->sc_cfg3;
	case ESP100A:
		espr->espr_cfg2 = sc->sc_cfg2;
	case ESP100:
		espr->espr_cfg1 = sc->sc_cfg1;
		espr->espr_ccf = sc->sc_ccf;
		espr->espr_syncoff = 0;
		espr->espr_timeout = sc->sc_timeout;
		break;
	}
d552 5
a556 1
 * Initialize esp state machine
d559 1
a559 1
esp_init(sc, doreset)
d561 3
a563 1
	int doreset;
d565 1
a565 2
	struct espregs *espr = sc->sc_regs;
	struct ecb *ecb;
d567 21
a587 1
	
d589 2
a590 1
	 * reset the chip to a known state
d592 2
a593 1
	esp_reset(sc);
d595 4
a598 5
	if (doreset) {
		espr->espr_cmd = ESPCMD_RSTSCSI;
		DELAY(500);
		/* cheat: we don't want the state machine to reset again.. */
		esp_reset(sc);
d601 7
a607 36
	if (sc->sc_state == 0) {	/* First time through */
		TAILQ_INIT(&sc->ready_list);
		TAILQ_INIT(&sc->nexus_list);
		TAILQ_INIT(&sc->free_list);
		sc->sc_nexus = 0;
		ecb = sc->sc_ecb;
		bzero(ecb, sizeof(sc->sc_ecb));
		for (i = 0; i < sizeof(sc->sc_ecb) / sizeof(*ecb); i++) {
			TAILQ_INSERT_TAIL(&sc->free_list, ecb, chain);
			ecb++;
		}
		bzero(sc->sc_tinfo, sizeof(sc->sc_tinfo));
	} else {
		sc->sc_state = ESPS_IDLE;
		if (sc->sc_nexus != NULL) {
			sc->sc_nexus->xs->error = XS_DRIVER_STUFFUP;
			untimeout(esp_timeout, sc->sc_nexus);
			esp_done(sc->sc_nexus);
		}
		sc->sc_nexus = NULL;
		while (ecb = sc->nexus_list.tqh_first) {
			ecb->xs->error = XS_DRIVER_STUFFUP;
			untimeout(esp_timeout, ecb);
			esp_done(ecb);
		}
	}
	
	for (i = 0; i < 8; i++) {
		struct esp_tinfo *ti = &sc->sc_tinfo[i];

		ti->flags = DO_NEGOTIATE;
		ti->period = sc->sc_minsync;
		ti->synctp = 250 / ti->period;
		ti->offset = ESP_SYNC_REQOFF;
	}
	sc->sc_state = ESPS_IDLE;
d611 7
a617 2
 * Start a SCSI-command: This function is called by the higher level
 * SCSI-driver to queue/run SCSI-commands.
d619 1
a619 1
int 
d625 6
a630 4
	struct ecb *ecb;
	int	s;
	
	/*ESPD(("NS%08x/%08x/%d ", xs, xs->data, xs->datalen));*/
d632 1
a632 2
	/* XXX: set lun */
	xs->cmd->bytes[0] |= (sc_link->lun << SCSI_CMD_LUN_SHIFT);
d639 1
d642 1
a642 1
		
d644 1
a644 1
		xs->error = XS_DRIVER_STUFFUP;
a648 1
	ecb->flags = ECB_ACTIVE;
d655 1
a655 1
	
d658 2
a659 2
	if ((xs->flags & SCSI_POLL) == 0)
		timeout(esp_timeout, ecb, (xs->timeout * hz) / 1000);
d661 1
a661 1
	if (sc->sc_state == ESPS_IDLE)
d663 1
d666 2
a667 2
	/* Not allowed to use interrupts, use polling instead */
	if (xs->flags & SCSI_POLL)
d669 3
d673 1
d685 1
a685 1
	int	count = xs->timeout * 1000;
d687 1
a687 1
	ESP_TRACE(("esp_poll\n"));
d689 2
a690 8
		if (dmapending(sc->sc_dma)) {
			/*
			 * We decrement the interrupt event counter to
			 * repair it... because this isn't a real interrupt.
			 */
			if (espintr(sc))
				--sc->sc_intrcnt.ev_count;
			continue;
d692 4
d698 5
a702 1
		DELAY(1);
d707 2
a708 4
		ecb->xs->error = XS_TIMEOUT;
		sc_print_addr(ecb->xs->sc_link);
		printf("timed out\n");
		esp_reset(sc);
d710 1
a710 1
	dmaenintr(sc->sc_dma);
d716 1
a716 3
 * Notice that we do not read the live register on an ESP100. On the
 * ESP100A and above the FE (Feature Enable) bit in config 2 latches
 * the phase in the register so it is safe to read.
a717 10
int
espphase(sc)
	struct esp_softc *sc;
{

	if (sc->sc_rev > ESP100)
		return (sc->sc_regs->espr_stat & ESPSTAT_PHASE);
	return (sc->sc_espstat & ESPSTAT_PHASE);
}

d723 1
a723 1
 * called when state == ESPS_IDLE and at bio pl.
d732 7
a738 2
	
	ESP_TRACE(("esp_sched\n"));
a744 1
		caddr_t cmd = (caddr_t) &ecb->cmd;
d748 1
a748 1
			struct esp_tinfo *ti = &sc->sc_tinfo[ecb->xs->sc_link->target];
d750 2
d753 1
d756 1
a756 3
			sc_link = ecb->xs->sc_link;
			espselect(sc);
			ti = &sc->sc_tinfo[sc_link->target];
d760 6
d782 3
d786 1
a786 1
	ESP_TRACE(("esp_done "));
d789 1
a789 1
	 * Now, if we've come here with no error code, i.e. we've kept the 
d791 2
a792 2
	 * check sense, we'll need to set up a request sense cmd block and 
	 * push the command back into the ready queue *before* any other 
d797 3
a799 1
		if (ecb->flags & ECB_CHKSENSE)
d801 1
a801 1
		else if ((ecb->stat & ST_MASK) == SCSI_CHECK) {
a802 2

			ESPD(("RS "));
d810 1
a810 1
			ss->byte2 = sc_link->lun << SCSI_CMD_LUN_SHIFT;
d815 6
a820 1
			ecb->flags = ECB_ACTIVE|ECB_CHKSENSE;
d822 9
a830 8
			sc->sc_tinfo[sc_link->target].lubusy &=
			    ~(1<<sc_link->lun);
			sc->sc_tinfo[sc_link->target].senses++;
			/* found it */
			if (sc->sc_nexus != ecb)
				TAILQ_INSERT_HEAD(&sc->ready_list, ecb, chain);
			sc->sc_state = ESPS_IDLE;
			esp_sched(sc);
d832 1
a832 1
		} else
d834 1
d839 1
a839 1
#if ESP_DEBUG > 1
d841 4
a844 3
		printf("err=0x%02x ", xs->error);
		if (xs->error == XS_SENSE)
			printf("sense=%02x\n", xs->sense.error_code);
d846 1
a846 1
	if ((xs->resid || xs->error > XS_SENSE) && (esp_debug & ESP_SHOWMISC)) {
d855 1
a855 5
	 * Remove the ECB from whatever queue it's on.  We have to do a bit of
	 * a hack to figure out which queue it's on.  Note that it is *not*
	 * necessary to cdr down the ready queue, but we must cdr down the
	 * nexus queue and see if it's there, so we can mark the unit as no
	 * longer busy.  This code is sickening, but it works.
d857 5
a861 2
	if (ecb == sc->sc_nexus) {
		sc->sc_tinfo[sc_link->target].lubusy &= ~(1<<sc_link->lun);
d863 2
a864 1
		sc->sc_state = ESPS_IDLE;
d866 2
a867 1
	} else if (sc->ready_list.tqh_last == &ecb->chain.tqe_next) {
d869 13
a881 2
	} else {
		register struct ecb *ecb2;
d883 1
a883 18
		for (ecb2 = sc->nexus_list.tqh_first; ecb2;
		    ecb2 = ecb2->chain.tqe_next)
			if (ecb2 == ecb)
				break;
		if (ecb2) {
			TAILQ_REMOVE(&sc->nexus_list, ecb, chain);
			sc->sc_tinfo[sc_link->target].lubusy &=
			    ~(1<<sc_link->lun);
		} else if (ecb->chain.tqe_next) {
			TAILQ_REMOVE(&sc->ready_list, ecb, chain);
		} else {
			printf("%s: can't find matching ecb\n",
			    sc->sc_dev.dv_xname);
			Debugger();
		}
	}
	/* Put it on the free list. */
	ecb->flags = ECB_FREE;
d885 1
d887 1
a887 2
	sc->sc_tinfo[sc_link->target].cmds++;
	ESPD(("DONE%d ", xs->resid));
d889 1
d902 4
a905 4
	do { \
		sc->sc_regs->espr_cmd = ESPCMD_SETATN; \
		sc->sc_msgpriq |= (m); \
		ESPD(("Mq%02x ", sc->sc_msgpriq)); \
d908 1
a908 1
#define IS1BYTEMSG(m) (((m) != 1 && ((unsigned)(m)) < 0x20) || (m) & 0x80)
d922 7
a928 10
	struct espregs *espr = sc->sc_regs;
	struct ecb *ecb;
	int extlen;
	int x, i;
	
	ESP_TRACE(("esp_msgin "));

	/* is something wrong ? */
	if (sc->sc_phase != MESSAGE_IN_PHASE) {
		printf("%s: not MESSAGE_IN_PHASE\n", sc->sc_dev.dv_xname);
a931 3
	ESPD(("MSGIN:%d ", espr->espr_fflag & ESPFIFO_FF));

#ifdef fixme
d939 1
a939 8
		sc->sc_flags &= ~ESPF_DROP_MSGI;
		if (sc->sc_imlen > 0) {
			printf("%s: message type %02x",
			    sc->sc_dev.dv_xname, sc->sc_imess[0]);
			if (!IS1BYTEMSG(sc->sc_imess[0]))
				printf(" %02x", sc->sc_imess[1]);
			printf(" was dropped\n");
		}
a941 1
#endif
d943 12
a954 15
	/*
	 * Which target is reselecting us? (The ID bit really)
	 * On a reselection, there should be the reselecting target's
	 * id and an identify message in the fifo.
	 */
	if (sc->sc_state == ESPS_RESELECTED && sc->sc_imlen == 0) {
		x = espgetbyte(sc, 0);
		if (x == -1) {
			printf("%s: msgin reselection found fifo empty\n",
			    sc->sc_dev.dv_xname);
			return;
		}
		ESPD(("ID=%02x ", x));
		sc->sc_selid = (u_char)x & ~(1<<sc->sc_id);
		ESP_MISC(("selid=0x%02x ", sc->sc_selid));
d956 1
d958 1
a958 10
	/*
	 * If parity errors just dump everything on the floor
	 */
	if (sc->sc_espstat & ESPSTAT_PE) {
		printf("%s: SCSI bus parity error\n",
		    sc->sc_dev.dv_xname);
		esp_sched_msgout(SEND_PARITY_ERROR);
		DELAY(1);
		sc->sc_flags |= ESPF_DROP_MSGI;
	}
a962 2
	 * XXX: the above comment might be true -- this is not being
	 * done though!
d964 7
a970 34
	if ((sc->sc_flags & ESPF_DROP_MSGI) == 0) {
		x = espgetbyte(sc, 1);
		if (x == -1) {
			printf("%s: msgin fifo empty at %d\n",
			    sc->sc_dev.dv_xname, sc->sc_imlen);
			if (sc->sc_espintr & ESPINTR_BS) {
				espr->espr_cmd = ESPCMD_TRANS;
				ESPD(("MSI:y "));
			} else
				ESPD(("MSI:n "));
			return;
		}
		ESPD(("{%02x} ", (u_char)x));
		sc->sc_imess[sc->sc_imlen] = (u_char)x;
		if (sc->sc_imlen >= ESP_MSGLEN_MAX) {
			esp_sched_msgout(SEND_REJECT);
			DELAY(1);
			sc->sc_flags |= ESPF_DROP_MSGI;
		} else {
			sc->sc_imlen++;
			/* 
			 * This testing is suboptimal, but most
			 * messages will be of the one byte variety, so
			 * it should not effect performance
			 * significantly.
			 */
			if (sc->sc_imlen == 1 && IS1BYTEMSG(sc->sc_imess[0]))
				goto gotit;
			if (sc->sc_imlen == 2 && IS2BYTEMSG(sc->sc_imess[0]))
				goto gotit;
			if (sc->sc_imlen >= 3 && ISEXTMSG(sc->sc_imess[0]) &&
			    sc->sc_imlen == sc->sc_imess[1] + 2)
				goto gotit;
		}
d972 23
a994 1
	goto done;
d997 1
a997 9
	ESPD(("MP["));
	for (i=0; i<sc->sc_imlen; i++)
		ESPD(("%02x%c", sc->sc_imess[i],
		    (i==sc->sc_imlen-1) ? ']' : ' '));
	ESPD((" "));

	sc->sc_imlen = 0;	/* message is fully received */

	ESP_MISC(("gotmsg "));
d1002 1
a1002 1
	 * ESP_MSGLEN_MAX.  Longer messages will be amputated.
d1004 3
a1006 9
	if (sc->sc_state == ESPS_NEXUS ||
	    sc->sc_state == ESPS_DOINGMSGIN ||
	    sc->sc_state == ESPS_DOINGSTATUS) {
		struct esp_tinfo *ti;

		ecb = sc->sc_nexus;
		ti = &sc->sc_tinfo[ecb->xs->sc_link->target];

		sc->sc_state = ESPS_NEXUS;	/* where we go after this */
d1010 1
a1010 8
			ESP_MISC(("cmdcomplete "));
			if (!ecb) {
				esp_sched_msgout(SEND_ABORT);
				DELAY(1);
				printf("%s: CMDCOMPLETE but no command?\n",
				    sc->sc_dev.dv_xname);
				break;
			}
d1012 5
a1016 3
				sc_print_addr(ecb->xs->sc_link);
				printf("%d extra bytes\n", -sc->sc_dleft);
				ecb->dleft = 0;
d1019 1
a1019 1
			ecb->flags |= ECB_DONE;
d1021 1
d1023 10
a1032 14
			if (esp_debug & ESP_SHOWMISC)
				printf("%s targ %d: our msg rejected by target\n",
				    sc->sc_dev.dv_xname,
				    ecb->xs->sc_link->target);
			if (sc->sc_flags & ESPF_SYNCHNEGO) {
				/*
				 * Device doesn't even know what sync is
				 * (right?)
				 */
				ti->offset = 0;
				ti->period = sc->sc_minsync;
				ti->synctp = 250 / ti->period;
				sc->sc_flags &= ~ESPF_SYNCHNEGO;
				ti->flags &= ~DO_NEGOTIATE;
d1035 1
a1035 1
			if (sc->sc_msgout == SEND_INIT_DET_ERR) {
a1036 2
				DELAY(1);
			}
d1039 1
d1042 5
a1046 5
			if (!ecb) {
				esp_sched_msgout(SEND_ABORT);
				DELAY(1);
				printf("%s: nothing to DISCONNECT\n",
				    sc->sc_dev.dv_xname);
d1048 1
a1048 7
			}
			ti->dconns++;
			TAILQ_INSERT_HEAD(&sc->nexus_list, ecb, chain);
			ecb = sc->sc_nexus = NULL;
			sc->sc_state = ESPS_EXPECTDISC;
			sc->sc_flags |= ESPF_MAYDISCON;
			break;
d1050 1
a1050 8
			if (!ecb) {
				esp_sched_msgout(SEND_ABORT);
				DELAY(1);
				printf("%s: no DATAPOINTERs to save\n",
				    sc->sc_dev.dv_xname);
				break;
			}
			ESPD(("DL%d/%d ", sc->sc_dleft, ecb->dleft));
d1055 1
a1057 1
				DELAY(1);
d1065 5
d1071 1
d1074 2
d1078 7
a1084 5
				sc->sc_flags &= ~ESPF_SYNCHNEGO;
				ti->flags &= ~DO_NEGOTIATE;
				if (ti->offset == 0 ||
				    ti->offset > ESP_SYNC_MAXOFF ||
				    ti->period < sc->sc_minsync) {
d1086 46
a1131 3
					ti->period = sc->sc_minsync;
					ti->synctp = 250 / ti->period;
					break;
d1133 1
a1133 4
				printf("%s targ %d: sync, offset %d, period %dnsec\n",
				    sc->sc_dev.dv_xname, ecb->xs->sc_link->target,
				    ti->offset, ti->period * 4);
				ti->synctp = 250 / ti->period;
d1135 2
a1136 4
			default:
				/* Extended messages we don't handle */
				esp_sched_msgout(SEND_REJECT);
				DELAY(1);
d1141 2
a1142 1
			/* thanks for that ident... XXX: we should check it? */
d1144 3
a1146 2
				esp_sched_msgout(SEND_REJECT);
				DELAY(1);
d1150 4
a1153 2
	} else if (sc->sc_state == ESPS_RESELECTED) {
		struct scsi_link *sc_link;
d1162 1
a1162 1
			 * singly linked list. 
d1166 1
a1166 1
			    ecb = ecb->chain.tqe_next) {
d1172 1
d1177 1
a1177 2
			if (!ecb) {
				/* Invalid reselection! */
a1178 1
				DELAY(1);
d1181 1
a1181 1
			} else {
a1182 1
				 * Reestablish nexus:
d1186 1
d1190 11
a1200 6
				sc->sc_tinfo[sc_link->target].lubusy |=
				    (1<<sc_link->lun);
				espr->espr_syncoff =
				    sc->sc_tinfo[sc_link->target].offset;
				espr->espr_synctp = 250 /
				    sc->sc_tinfo[sc_link->target].period;
d1202 1
a1202 1
				sc->sc_state = ESPS_NEXUS;
a1207 1
			DELAY(1);
a1212 1
		DELAY(1);
a1213 13
done:
	espr->espr_cmd = ESPCMD_MSGOK;
	espr->espr_cmd = ESPCMD_NOP;
}


void
esp_makemsg(sc)
	register struct esp_softc *sc;
{
	struct esp_tinfo *ti;
	struct ecb *ecb = sc->sc_nexus;
	int i;
d1215 2
a1216 2
	sc->sc_msgout = sc->sc_msgpriq & -sc->sc_msgpriq;
	ESPD(("MQ%02x/%02x ", sc->sc_msgpriq, sc->sc_msgout));
d1218 3
a1220 42
	sc->sc_omlen = 1;		/* "Default" message len */
	switch (sc->sc_msgout) {
	case SEND_SDTR:		/* implies an IDENTIFY message */
		sc->sc_flags |= ESPF_SYNCHNEGO;
		ti = &sc->sc_tinfo[ecb->xs->sc_link->target];
		sc->sc_omess[0] = MSG_IDENTIFY(ecb->xs->sc_link->lun,
		    !(ecb->xs->flags & SCSI_POLL));
		sc->sc_omess[1] = MSG_EXTENDED;
		sc->sc_omess[2] = 3;
		sc->sc_omess[3] = MSG_EXT_SDTR;
		sc->sc_omess[4] = ti->period;
		sc->sc_omess[5] = ti->offset;
		sc->sc_omlen = 6;
		/* Fallthrough! */
	case SEND_IDENTIFY:
		sc->sc_omess[0] = MSG_IDENTIFY(ecb->xs->sc_link->lun,
		    !(ecb->xs->flags & SCSI_POLL));
		break;
	case SEND_DEV_RESET:
		sc->sc_omess[0] = MSG_BUS_DEV_RESET;
		if (sc->sc_nexus)
			sc->sc_nexus->flags |= ECB_DONE;
		break;
	case SEND_PARITY_ERROR:
		sc->sc_omess[0] = MSG_PARITY_ERROR;
		break;
	case SEND_ABORT:
		sc->sc_omess[0] = MSG_ABORT;
		if (sc->sc_nexus)
			sc->sc_nexus->flags |= ECB_DONE;
		break;
	case SEND_INIT_DET_ERR:
		sc->sc_omess[0] = MSG_INITIATOR_DET_ERR;
		break;
	case SEND_REJECT:
		sc->sc_omess[0] = MSG_MESSAGE_REJECT;
		break;
	default:
		sc->sc_omess[0] = MSG_NOOP;
		break;
	}
	sc->sc_omp = sc->sc_omess;
a1230 1
	struct espregs *espr = sc->sc_regs;
d1233 1
a1233 1
	int i;
d1235 1
a1235 8
	/* Pick up highest priority message */
	sc->sc_msgout = sc->sc_msgpriq & -sc->sc_msgpriq;
	esp_makemsg(sc);

	for (i = 0; i < sc->sc_omlen; i++)
		espr->espr_fifo = sc->sc_omp[i];
	espr->espr_cmd = ESPCMD_TRANS;
}
d1237 49
d1287 25
a1311 15
void
esp_timeout(arg)
	void *arg;
{
	struct ecb *ecb = (struct ecb *)arg;
	struct esp_softc *sc;

	sc = ecb->xs->sc_link->adapter_softc;
	sc_print_addr(ecb->xs->sc_link);
	printf("timed out at %d %d\n", sc->sc_state, sc->sc_phase);

	ecb->xs->error = XS_TIMEOUT;
	esp_reset(sc);
	esp_done(ecb);
	printf("new ecb %08x\n", sc->sc_nexus);
d1315 5
a1319 3
 * Read the ESP registers, and save their contents for later use.
 * ESP_STAT, ESP_STEP & ESP_INTR are mostly zeroed out when reading
 * ESP_INTR - so make sure it is the last read.
d1321 1
a1321 5
 * XXX: TDR: this logic seems unsound
 * I think that (from reading the docs) most bits in these registers
 * only make sense when the DMA CSR has an interrupt showing. So I have
 * coded this to not do anything if there is no interrupt or error
 * pending.
d1323 1
a1323 25
void
espreadregs(sc)
	struct esp_softc *sc;
{
	struct espregs *espr = sc->sc_regs;

	/* they mean nothing if the is no pending interrupt ??? */
	if (!(dmapending(sc->sc_dma)))
		return;

	/* Only the stepo bits are of interest */
	sc->sc_espstep = espr->espr_step & ESPSTEP_MASK;
	sc->sc_espstat = espr->espr_stat;
	sc->sc_espintr = espr->espr_intr;

	ESP_MISC(("regs[intr=%02x,stat=%02x,step=%02x] ", sc->sc_espintr,
	    sc->sc_espstat, sc->sc_espstep));
}

/*
 * Whatever we do, we must generate an interrupt if we expect to go
 * to the next state.
 * Note: this increments the events even if called from esp_poll()
 */
int 
d1327 1
a1327 2
	struct espregs *espr = sc->sc_regs;
	register struct ecb *ecb = sc->sc_nexus;
a1328 1
	u_char *cmd;
d1330 2
a1331 9
	int dmaintrwas, i;

	/*
	 * Revision 1 DMA's must have their interrupts disabled,
	 * otherwise we can get bus timeouts while reading ESP
	 * registers.
	 */
	if (sc->sc_dma->sc_rev == DMAREV_1)
		dmaintrwas = dmadisintr(sc->sc_dma);
d1333 1
a1333 1
	espreadregs(sc);
d1336 17
a1352 2
	 * If either of these two things is true, we caused an interrupt.
	 * If we didn't, let's get out of here.
d1354 8
a1361 5
	if ((sc->sc_espintr | dmapending(sc->sc_dma)) == 0) {
		if (sc->sc_dma->sc_rev == DMAREV_1 && dmaintrwas)
			dmaenintr(sc->sc_dma);
		return (0);
	}
d1363 2
a1364 1
	sc->sc_phase = espphase(sc);
d1366 1
a1366 1
	ESPD(("I%02x/%02x/%02x ", sc->sc_espintr, sc->sc_state, sc->sc_phase));
a1367 4
	if (sc->sc_espintr & ESPINTR_SBR) {
		espflush(sc);
		printf("%s: scsi bus reset\n", sc->sc_dev.dv_xname);
		esp_init(sc, 0);	/* Restart everything */
d1369 14
a1382 2
		 * No interrupt expected, since there are now no
		 * ecb's in progress.
a1383 2
		goto done;
	}
d1385 24
a1408 7
	if (sc->sc_espintr & ESPINTR_ILL) {
		printf("%s: illegal command %02x\n",
		    sc->sc_dev.dv_xname, espr->espr_cmd);
		if (sc->sc_state == ESPS_NEXUS) {
			ecb->xs->error = XS_DRIVER_STUFFUP;
			untimeout(esp_timeout, ecb);
			esp_done(ecb);
a1409 4
		esp_reset(sc);
		esp_sched(sc);		/* start next command */
		goto done;
	}
d1411 1
a1411 14
	if (sc->sc_espstat & ESPSTAT_GE) {
		/* no target ? */
		espflush(sc);
		printf("%s: gross error\n", sc->sc_dev.dv_xname);
		if (sc->sc_state == ESPS_NEXUS) {
			ecb->xs->error = XS_DRIVER_STUFFUP;
			untimeout(esp_timeout, ecb);
			esp_done(ecb);
		}
		esp_reset(sc);
		esp_sched(sc);
		/* started next command, which will interrupt us */
		goto done;
	}
d1413 17
a1429 7
	/*
	 * The `bad interrupts' have already been checked.
	 */
states:
	switch (sc->sc_state) {
	case ESPS_IDLE:
		ESPD(("I "));
d1431 13
a1443 5
		sc->sc_nexus = NULL;

		if (sc->sc_espintr & ESPINTR_RESEL) {
			sc->sc_state = ESPS_RESELECTED;
			goto states;
a1444 1
		esp_sched(sc);
d1447 5
a1451 2
		 * We will get an interrupt if esp_sched() queues
		 * anything to the scsi bus.
d1453 25
a1477 2
		goto done;
	case ESPS_SELECTING:
d1479 1
a1479 2
		 * For a simple select, we sent either
		 * ESPCMD_SELATN or ESPCMD_SELNATN
d1481 8
a1488 1
		ESPD(("S "));
d1491 6
a1496 5
			sc->sc_state = ESPS_NEXUS;	/* will cleanup */
			goto states;
		}

		if (sc->sc_espintr & ESPINTR_RESEL) {
d1498 2
a1499 2
			 * If we were trying to select a target,
			 * push our command back into the ready list.
d1501 11
a1511 26
			if (sc->sc_state == ESPS_SELECTING) {
				TAILQ_INSERT_HEAD(&sc->ready_list,
				    sc->sc_nexus, chain);
				ecb = sc->sc_nexus = NULL;
			}
			sc->sc_state = ESPS_RESELECTED;
			goto states;
		}

		if (sc->sc_espintr == (ESPINTR_FC|ESPINTR_BS)) {
			ESPD(("STEP%d ", sc->sc_espstep));
			if (sc->sc_espstep == 0) {
				/* ATN: cannot happen */
				/* NATN: target did not assert message phase */
				sc->sc_state = ESPS_IDLE;
				goto states;
			} else if (sc->sc_espstep == 2) {
				/* BOTH: target did not assert command phase */
				sc->sc_state = ESPS_IDLE;
				goto states;
			} else if (sc->sc_espstep == 3) {
				/* BOTH: changed phase during cmd transfer */
				ESPD(("FF%d ", espr->espr_fflag & ESPFIFO_FF));
				if (espr->espr_fflag & ESPFIFO_FF) {
					sc->sc_state = ESPS_IDLE;
					goto states;
d1513 28
d1542 3
d1546 11
a1556 5
			espr->espr_cmd = ESPCMD_NOP;	/* unlatch fifo counter */
			if (sc->sc_phase != DATA_IN_PHASE &&
			    sc->sc_tinfo[ecb->xs->sc_link->target].offset == 0) {
				DELAY(1);
				espflush(sc);
a1557 9

			ecb = sc->sc_nexus;
			if (!ecb)
				panic("esp: not nexus at sc->sc_nexus");
			sc_link = ecb->xs->sc_link;
			ti = &sc->sc_tinfo[sc_link->target];
			sc->sc_flags = 0;

			/* Clearly we succeeded at sending the message */
a1559 61
			if (sc->sc_msgpriq)
				espr->espr_cmd = ESPCMD_SETATN;

			sc->sc_dp = ecb->daddr;	/* implicit RESTOREDATAPOINTERS */
			sc->sc_dleft = ecb->dleft;
			ti->lubusy |= (1<<sc_link->lun);

			sc->sc_state = ESPS_NEXUS;
		}
		break;		/* handle the phase */
	case ESPS_SELECTSTOP:
		/*
		 * We wanted to select with multiple message bytes.
		 * As a result, we needed to use SELATNS. One
		 * message byte has been sent at this point. We need
		 * to send the other bytes, then the target will either
		 * switch to command phase to fetch the command or
		 * send us a message.
		 */
		ESPD(("SS%d ", sc->sc_espstep));

		if (sc->sc_espintr & ESPINTR_DIS) {
			sc->sc_state = ESPS_NEXUS;
			goto states;
		}

		if (sc->sc_espintr & ESPINTR_RESEL) {
			/*
			 * If we were trying to select a target,
			 * push our command back into the ready list.
			 */
			if (sc->sc_state == ESPS_SELECTING) {
				TAILQ_INSERT_HEAD(&sc->ready_list,
				    sc->sc_nexus, chain);
				ecb = sc->sc_nexus = NULL;
			}
			sc->sc_state = ESPS_RESELECTED;
			goto states;
		}

		if (sc->sc_espintr & (ESPINTR_BS|ESPINTR_FC)) {
			int i;

			/*
			 * Shove the remainder of the message bytes
			 * into the fifo. After we send them, command
			 * phase will request the command...
			 */
			espflush(sc);
			for (i = 1; i < sc->sc_omlen; i++)
				espr->espr_fifo = sc->sc_omp[i];
			espr->espr_cmd = ESPCMD_TRANS;
			sc->sc_state = ESPS_MULTMSGEND;
			goto done;
		}
		goto done;
	case ESPS_MULTMSGEND:
		ESPD(("MME "));
		if (sc->sc_espintr & ESPINTR_DIS) {
			sc->sc_state = ESPS_NEXUS;
			goto states;
d1562 1
a1562 8
		sc->sc_msgpriq &= ~sc->sc_msgout;
		sc->sc_msgout = 0;

		ESPD(("F%d ", espr->espr_fflag & ESPFIFO_FF));
		if (espr->espr_fflag & ESPFIFO_FF) {
			espflush(sc);
			DELAY(1);
		}
d1564 4
a1567 46
		/*
		 * If there are more messages, re-assert
		 * ATN so that we will enter MSGOUT phase
		 * again. Also, pause till that interrupt is
		 * done to see if the phase changes.
		 */
		if (sc->sc_msgpriq)
			espr->espr_cmd = ESPCMD_SETATN;
		sc->sc_state = ESPS_NEXUS;
		goto states;
	case ESPS_RESELECTED:
		ESPD(("RS "));

		if (sc->sc_phase != MESSAGE_IN_PHASE) {
			printf("%s: target didn't identify\n",
			    sc->sc_dev.dv_xname);
			esp_init(sc, 1);
			goto done;
		}
		esp_msgin(sc);
		if (sc->sc_state != ESPS_NEXUS) {
			/* IDENTIFY failed?! */
			printf("%s: identify failed\n", sc->sc_dev.dv_xname);
			esp_init(sc, 1);
			goto done;
		}

		/*
		 * We will get an interrupt because of the ESPCMD_MSGOK
		 * interrupt inside esp_msgin()
		 */
		goto done;
	case ESPS_DOINGDMA:
		/*
		 * Call if DMA is still active. If dmaintr() has finished,
		 * delay a while to let things settle, and then re-read the
		 * phase.
		 * 
		 * XXX: should check ESPINTR_DIS
		 */
		if (sc->sc_espstat & ESPSTAT_PE) {
			printf("%s: SCSI bus parity error\n",
			    sc->sc_dev.dv_xname);
			esp_sched_msgout(SEND_INIT_DET_ERR);
			/* XXX: anything else to do? */
		}
d1569 1
a1569 1
		if (sc->sc_espintr & ESPINTR_BS) {
d1571 1
a1571 5
			 * ESP says we have changed phase, or have
			 * finished transferring all the bytes. It
			 * doesn't matter which case, either way we
			 * will let the phase determine what happens
			 * next.
d1573 5
a1577 6
			ESPD(("DOINGDMA:BS:%02x/%02x ", sc->sc_espstat,
			    espr->espr_tcl));
			if (sc->sc_dma->sc_active) {
				dmaintr(sc->sc_dma, 0);
				if (sc->sc_dma->sc_active)
					goto done;
d1579 9
a1587 6
		} else {
			ESPD(("DOINGDMA:cont "));
			if (sc->sc_dma->sc_active) {
				dmaintr(sc->sc_dma, 1);
				if (sc->sc_dma->sc_active)
					goto done;
d1589 2
a1590 1
		}
d1592 3
a1594 2
		/* finished a DMA transaction */
		sc->sc_flags = 0;
d1596 48
a1643 2
		ecb->daddr = sc->sc_dp;		/* implicit SAVEDATAPOINTERS */
		ecb->dleft = sc->sc_dleft;
d1645 5
a1649 18
		/*
		 * ESP100 strangeness -- need to fetch a new phase --
		 * why?
		 */
		if (sc->sc_rev==ESP100 &&
		    sc->sc_tinfo[ecb->xs->sc_link->target].offset) {
			sc->sc_espstat = espr->espr_stat & ESPSTAT_PHASE;
			sc->sc_phase = espphase(sc);
			/* XXX should check if sync under/overran */
		}
		sc->sc_state = ESPS_NEXUS;
		break;		/* handle the phase */
	case ESPS_DOINGMSGOUT:
		ESPD(("DMO "));
		if (sc->sc_espintr & ESPINTR_DIS) {
			sc->sc_state = ESPS_NEXUS;	/* will cleanup */
			goto states;
		}
d1651 2
a1652 3
		if (sc->sc_espintr & ESPINTR_BS) {
			sc->sc_msgpriq &= ~sc->sc_msgout;
			sc->sc_msgout = 0;
d1654 84
a1737 3
			ESPD(("F%d ", espr->espr_fflag & ESPFIFO_FF));
			if (espr->espr_fflag & ESPFIFO_FF) {
				espflush(sc);
d1739 1
d1741 5
d1747 36
a1782 8
			/*
			 * If there are more messages, re-assert
			 * ATN so that we will enter MSGOUT phase
			 * again. Also, pause till that interrupt is
			 * done to see if the phase changes.
			 */
			if (sc->sc_msgpriq)
				espr->espr_cmd = ESPCMD_SETATN;
d1784 4
a1789 11
#if 0
		if (sc->sc_espintr & ESPINTR_FC) {
			/*
			 * XXX: the book claims that an ESPINTR_BS is
			 * generated, not ESPINTR_FC. Check if that is
			 * true.
			 */
		}
#endif
		break;		/* handle the phase */
	case ESPS_DOINGMSGIN:
d1791 2
a1792 3
		 * We receive two interrupts per message byte here: one for
		 * the MSGOK command in esp_msgin(), and one for the TRANS
		 * command below.
d1794 2
a1795 5
		ESPD(("DMI "));

		if (sc->sc_espintr & ESPINTR_DIS) {
			sc->sc_state = ESPS_NEXUS;	/* will cleanup */
			goto states;
d1798 35
a1832 9
		if (sc->sc_espstat & ESPSTAT_PE) {
			printf("%s: SCSI bus parity error\n",
			    sc->sc_dev.dv_xname);
			esp_sched_msgout(SEND_PARITY_ERROR);
			espflush(sc);
			sc->sc_state = ESPS_NEXUS;
			/* XXX: are we missing some fifo handling? */
			goto done;	/* will be interrupted for MSGOUT */
		}
d1834 35
a1868 22
		/*
		 * The two interrupts we receive per byte will alternate
		 * between entering the following two if() statements.
		 * XXX: just incase, are these two if()'s in the correct
		 * order?
		 */
		if (sc->sc_espintr & ESPINTR_BS) {
			/*
			 * interrupted by ESPCMD_MSGOK in esp_msgin()
			 */
			if (sc->sc_phase == MESSAGE_IN_PHASE)
				espr->espr_cmd = ESPCMD_TRANS;
			else {
				ESPD(("PC "));
				/*
				 * XXX: The phase has been changed on us. 
				 * This should lead us to discard the
				 * current (incomplete) message, perhaps
				 * assert an error(?), and go handle whatever
				 * new phase we are now in.
				 */
				break;
d1870 3
a1872 3
			goto done;
		}
		if (sc->sc_espintr & ESPINTR_FC) {
d1874 5
a1878 1
			 * interrupted by ESPCMD_TRANS a few lines above.
d1880 16
a1895 17
			esp_msgin(sc);
			goto done;
		}
		goto done;
	case ESPS_DOINGSTATUS:
		if (sc->sc_espintr & ESPINTR_DIS) {
			sc->sc_state = ESPS_NEXUS;	/* will cleanup */
			goto states;
		}

		if (sc->sc_espintr & (ESPINTR_FC|ESPINTR_BS)) {
			i = espgetbyte(sc, 0);
			if (i == -1) {
				printf("%s: ESPS_DOINGSTATUS fifo empty\n",
				    sc->sc_dev.dv_xname);
				/* XXX: how do we cleanup from this error? */
				goto done;
d1897 3
a1899 23
			if (sc->sc_espstat & ESPSTAT_PE) {
				printf("%s: SCSI bus parity error\n",
				    sc->sc_dev.dv_xname);
				/*
				 * Can't tell what the real status should
				 * be, so force a later check.
				 */
				i = SCSI_CHECK;
			}
			ecb->stat = (u_char)i;
			ESPD(("status=%02x ", (u_char)i));

			if (sc->sc_espintr & ESPINTR_FC) {
				/*
				 * XXX assumes a single byte message --
				 * and what about parity errors and other
				 * possible botches inside esp_msgin?
				 */
				esp_msgin(sc);
				sc->sc_state = ESPS_NEXUS;
			} else
				sc->sc_state = ESPS_DOINGMSGIN;
			goto done;
d1901 3
a1903 16
		goto done;
	case ESPS_EXPECTDISC:
		/*
		 * We were told to expect a disconnection interrupt.
		 * When we get it, we can go back to other work.
		 */
		ESPD(("ED "));
		if (sc->sc_espintr & ESPINTR_DIS) {
			espflush(sc);
			DELAY(1);
			espr->espr_cmd = ESPCMD_ENSEL; /* within 250ms of disconnect */
			sc->sc_state = ESPS_IDLE;
		}
		goto states;
	case ESPS_NEXUS:
		ESPD(("NX "));
d1905 9
a1913 29
		if (sc->sc_espintr & ESPINTR_DIS) {
			espflush(sc);
			DELAY(1);
			espr->espr_cmd = ESPCMD_ENSEL; /* within 250ms of disconnect */
			sc->sc_msgpriq = sc->sc_msgout = 0;

			ESPD(("DD:"));
			if (ecb->flags & ECB_DONE) {
				ESPD(("D "));
				/* successfully finished a transaction */
				untimeout(esp_timeout, ecb);
				esp_done(ecb);
			} else if (sc->sc_flags & ESPF_MAYDISCON) {
				ESPD(("M "));
				/* legal discon/recon is happening */
				TAILQ_INSERT_HEAD(&sc->nexus_list,
				    ecb, chain);
				sc->sc_nexus = NULL;
				sc->sc_state = ESPS_IDLE;
				sc->sc_flags &= ~ESPF_MAYDISCON;
				goto states;
			} else {
				ESPD(("U "));
				/* unexpected disconnection! fail. */
				ecb->xs->error = XS_TIMEOUT;
				untimeout(esp_timeout, ecb);
				esp_done(ecb);
			}
			goto done;
d1915 3
a1917 5
		break;		/* handle the phase */
	default:
		printf("%s: unknown state %d\n",
		    sc->sc_dev.dv_xname, sc->sc_state);
		panic("cannot continue");
d1919 1
d1921 8
a1928 1
	ecb = sc->sc_nexus;
d1930 13
a1942 26
	switch (sc->sc_phase) {
	case MESSAGE_OUT_PHASE:
		/*
		 * ATN was asserted, and the bus changed into MSGOUT phase.
		 * Send a message.
		 */
		esp_msgout(sc);				/* cause intr */
		sc->sc_state = ESPS_DOINGMSGOUT;
		break;
	case COMMAND_PHASE:
		/*
		 * Apparently we need to repeat the previous command.
		 */
		espflush(sc);
		DELAY(1);
		cmd = (u_char *)&ecb->cmd;

		ESPD(("CMD["));
		for (i = 0; i < ecb->clen; i++)
			ESPD(("%02x%c", cmd[i],
			    (i == ecb->clen-1) ? ']' : ' '));
		ESPD((" "));

		/* Now the command into the FIFO */
		for (i = 0; i < ecb->clen; i++)
			espr->espr_fifo = cmd[i];
d1944 27
a1970 38
		espr->espr_cmd = ESPCMD_TRANS;		/* cause intr */
		sc->sc_state = ESPS_NEXUS;
		break;
	case DATA_OUT_PHASE:
		/*
		 * We can feed the device the data now.
		 */
		espflush(sc);
		DELAY(1);
		dmastart(sc->sc_dma, &sc->sc_dp, &sc->sc_dleft, 0,
		    ecb->xs->flags & SCSI_POLL);	/* cause intr */
		sc->sc_state = ESPS_DOINGDMA;
		break;
	case DATA_IN_PHASE:
		/*
		 * The device is ready to give us the data.
		 */
		dmadrain(sc->sc_dma);
		dmastart(sc->sc_dma, &sc->sc_dp, &sc->sc_dleft, 1,
		    ecb->xs->flags & SCSI_POLL);	/* cause intr */
		sc->sc_state = ESPS_DOINGDMA;
		break;
	case MESSAGE_IN_PHASE:
		espflush(sc);
		DELAY(1);
		espr->espr_cmd = ESPCMD_TRANS;		/* cause intr */
		sc->sc_state = ESPS_DOINGMSGIN;
		break;
	case STATUS_PHASE:
		espflush(sc);
		DELAY(1);
		espr->espr_cmd = ESPCMD_ICCS;		/* cause intr */
		sc->sc_state = ESPS_DOINGSTATUS;
		break;
	default:
		printf("%s: bogus bus phase %d\n",
		    sc->sc_dev.dv_xname);
		break;
d1972 1
a1972 6

done:
	if (sc->sc_dma->sc_rev == DMAREV_1 && dmaintrwas)
		dmaenintr(sc->sc_dma);
	sc->sc_intrcnt.ev_count++;
	return (1);
@


1.6
log
@fix copyrights
@
text
@d170 1
a170 1
		    mapiodev(ca->ca_ra.ra_paddr, ca->ca_ra.ra_len,
@


1.5
log
@move espreadregs() closer to where it is used
@
text
@a1 8
 * FOR NOW, YOU MAY NOT USE THIS DRIVER WITHOUT EXPLICITLY GRANTED
 * PERMISSION.
 */


/*	$NetBSD: esp.c,v 1.18 1995/02/01 12:37:24 pk Exp $ */

/*
d3 1
a3 2
 * All rights reserved.
 *
d14 3
a16 2
 *	This product includes software developed by Theo de Raadt.
 * 4. The name of the author may not be used to endorse or promote products 
d19 11
a29 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
@


1.4
log
@note that we should probably set cfg2 for the ESP100A
@
text
@a344 30
 * Read the ESP registers, and save their contents for later use.
 * ESP_STAT, ESP_STEP & ESP_INTR are mostly zeroed out when reading
 * ESP_INTR - so make sure it is the last read.
 *
 * XXX: TDR: this logic seems unsound
 * I think that (from reading the docs) most bits in these registers
 * only make sense when the DMA CSR has an interrupt showing. So I have
 * coded this to not do anything if there is no interrupt or error
 * pending.
 */
void
espreadregs(sc)
	struct esp_softc *sc;
{
	struct espregs *espr = sc->sc_regs;

	/* they mean nothing if the is no pending interrupt ??? */
	if (!(dmapending(sc->sc_dma)))
		return;

	/* Only the stepo bits are of interest */
	sc->sc_espstep = espr->espr_step & ESPSTEP_MASK;
	sc->sc_espstat = espr->espr_stat;
	sc->sc_espintr = espr->espr_intr;

	ESP_MISC(("regs[intr=%02x,stat=%02x,step=%02x] ", sc->sc_espintr,
	    sc->sc_espstat, sc->sc_espstep));
}

/*
d1233 30
@


1.3
log
@trunk bootpath; no local minphys
@
text
@d253 1
@


1.2
log
@new driver by me
@
text
@a84 1
u_int	esp_minphys	__P((struct buf *));
d107 1
a107 1
	esp_scsi_cmd, esp_minphys, NULL, NULL
a301 1
	bootcomp = NULL;
d308 1
a308 1
			bootcomp = sc->sc_bp = bp + 1;
d311 3
a313 1
		bootcomp = sc->sc_bp = bp;
d321 2
a614 13
}

/*
 * Adjust transfer size in buffer structure
 *
 * We have no max transfer size, since the DMA driver will break it
 * down into watever is needed.
 */
u_int 
esp_minphys(bp)
	struct buf *bp;
{
	return (minphys(bp));
@


1.1
log
@Initial revision
@
text
@d1 7
a7 1
/*	$NetBSD: esp.c,v 1.26 1995/09/14 20:38:53 pk Exp $ */
d10 1
a10 1
 * Copyright (c) 1994 Peter Galbavy
d23 1
a23 1
 *	This product includes software developed by Peter Galbavy
d41 8
a48 5
 * Based on aic6360 by Jarle Greipsland
 *
 * Acknowledgements: Many of the algorithms used in this driver are
 * inspired by the work of Julian Elischer (julian@@tfs.com) and
 * Charles Hannum (mycroft@@duality.gnu.ai.mit.edu).  Thanks a million!
d65 1
d70 1
a71 1
#include <sparc/dev/dmavar.h>
d75 7
a81 1
int esp_debug = 0; /*ESP_SHOWPHASE|ESP_SHOWMISC|ESP_SHOWTRAC|ESP_SHOWCMDS;*/ 
d83 19
a101 20
/*static*/ void	espattach	__P((struct device *, struct device *, void *));
/*static*/ int	espmatch	__P((struct device *, void *, void *));
/*static*/ int  espprint	__P((void *, char *));
/*static*/ u_int	esp_adapter_info __P((struct esp_softc *));
/*static*/ void	espreadregs	__P((struct esp_softc *));
/*static*/ int	espgetbyte	__P((struct esp_softc *, u_char *));
/*static*/ void	espselect	__P((struct esp_softc *,
				     u_char, u_char, caddr_t, u_char));
/*static*/ void	esp_scsi_reset	__P((struct esp_softc *));
/*static*/ void	esp_reset	__P((struct esp_softc *));
/*static*/ void	esp_init	__P((struct esp_softc *, int));
/*static*/ int	esp_scsi_cmd	__P((struct scsi_xfer *));
/*static*/ int	esp_poll	__P((struct esp_softc *, struct ecb *));
/*static*/ int	espphase	__P((struct esp_softc *));
/*static*/ void	esp_sched	__P((struct esp_softc *));
/*static*/ void	esp_done	__P((struct ecb *));
/*static*/ void	esp_msgin	__P((struct esp_softc *));
/*static*/ void	esp_msgout	__P((struct esp_softc *));
/*static*/ int	espintr		__P((struct esp_softc *));
/*static*/ void	esp_timeout	__P((void *arg));
a102 1
/* Linkup to the rest of the kernel */
d104 1
a104 2
	NULL, "esp", espmatch, espattach,
	DV_DULL, sizeof(struct esp_softc)
d108 1
a108 4
	esp_scsi_cmd,
	minphys,		/* no max at this level; handled by DMA code */
	NULL,
	NULL,
d112 1
a112 4
	NULL,			/* Use default error handler */
	NULL,			/* have a queue, served by this */
	NULL,			/* have no async handler */
	NULL,			/* Use default 'done' routine */
d116 1
a116 66
 * Read the ESP registers, and save their contents for later use.
 * ESP_STAT, ESP_STEP & ESP_INTR are mostly zeroed out when reading
 * ESP_INTR - so make sure it is the last read.
 *
 * I think that (from reading the docs) most bits in these registers
 * only make sense when he DMA CSR has an interrupt showing. So I have
 * coded this to not do anything if there is no interrupt or error
 * pending.
 */
void
espreadregs(sc)
	struct esp_softc *sc;
{
	volatile caddr_t esp = sc->sc_reg;

	/* they mean nothing if the is no pending interrupt ??? */
	if (!(DMA_ISINTR(sc->sc_dma)))
		return;

	/* Only the stepo bits are of interest */
	sc->sc_espstep = esp[ESP_STEP] & ESPSTEP_MASK;
	sc->sc_espstat = esp[ESP_STAT];
	sc->sc_espintr = esp[ESP_INTR];

	ESP_MISC(("regs[intr=%02x,stat=%02x,step=%02x] ", sc->sc_espintr,
	    sc->sc_espstat, sc->sc_espstep));
}

/*
 * no error checking ouch
 */
int
espgetbyte(sc, v)
	struct esp_softc *sc;
	u_char *v;
{
	volatile caddr_t esp = sc->sc_reg;

	if (!(esp[ESP_FFLAG] & ESPFIFO_FF)) {
ESPCMD(sc, ESPCMD_FLUSH);
DELAY(1);
		ESPCMD(sc, ESPCMD_TRANS);
		while (!DMA_ISINTR(sc->sc_dma))
			DELAY(1);
		/*
		 * If we read something, then clear the outstanding
		 * interrupts
		 */
		espreadregs(sc);
		if (sc->sc_espintr & ESPINTR_ILL) /* Oh, why? */
			return -1;
	}
	if (!(esp[ESP_FFLAG] & ESPFIFO_FF)) {
		printf("error... ");
		return -1;
	}
	*v = esp[ESP_FIFO];
	return 0;
}

/*
 * Send a command to a target, set the driver state to ESP_SELECTING
 * and let the caller take care of the rest.
 *
 * Keeping this as a function allows me to say that this may be done
 * by DMA instead of programmed I/O soon.
a117 45
void
espselect(sc, target, lun, cmd, clen)
	struct esp_softc *sc;
	u_char target, lun;
	caddr_t cmd;
	u_char clen;
{
	volatile caddr_t esp = sc->sc_reg;
	int i;

	/*
	 * The docs say the target register is never reset, and I
	 * can't think of a better place to set it
	 */
	esp[ESP_SELID] = target;
	esp[ESP_SYNCOFF] = sc->sc_tinfo[target].offset;
	esp[ESP_SYNCTP] = 250 / sc->sc_tinfo[target].period;

	/*
	 * Who am I. This is where we tell the target that we are
	 * happy for it to disconnect etc.
	 */
#if 1
	if ((sc->sc_tinfo[target].flags & T_XXX) == 0)
#endif
		esp[ESP_FIFO] = ESP_MSG_IDENTIFY(lun);

	/* Now the command into the FIFO */
	for (i = 0; i < clen; i++)
		esp[ESP_FIFO] = *cmd++;

	/* And get the targets attention */
#if 1
	if ((sc->sc_tinfo[target].flags & T_XXX) == 0)
#endif
		ESPCMD(sc, ESPCMD_SELATN);
#if 1
	else
		ESPCMD(sc, ESPCMD_SELNATN);
#endif

	/* new state ESP_SELECTING */
	sc->sc_state = ESP_SELECTING;
}

d123 1
a123 3
	if (name != NULL)
		printf("%s: scsibus ", name);
	return UNCONF;
d126 1
d144 1
d155 1
d157 1
d176 1
a176 1
		sc->sc_reg = (volatile caddr_t) ca->ca_ra.ra_vaddr;
d178 3
a180 2
		sc->sc_reg = (volatile caddr_t)
		    mapiodev(ca->ca_ra.ra_paddr, ca->ca_ra.ra_len, ca->ca_bustype);
d182 1
d197 1
a197 2
	/* gimme Mhz */
	sc->sc_freq /= 1000000;
d200 4
a203 7
	 * This is the value used to start sync negotiations
	 * For a 25Mhz clock, this gives us 40, or 160nS, or
	 * 6.25Mb/s. It is constant for each adapter.
	 *
	 * In turn, notice that the ESP register "SYNCTP" is
	 * = (250 / the negotiated period). It works, try it
	 * on paper.
d205 1
a205 1
	sc->sc_minsync = 1000 / sc->sc_freq;
d208 1
a208 1
	sc->sc_ccf = FREQTOCCF(sc->sc_freq) & 0x07;
d210 1
a210 1
	/* The value *must not* be == 1. Make it 2 */
d215 2
a216 2
	 * The recommended timeout is 250ms. This register is loaded
	 * with a value calculated as follows, from the docs:
d222 2
a223 2
	 * We have the CCF from above, so the sum is simple, and generally
	 * gives us a constant of 153. Try working out a few and see.
d225 1
a225 1
	sc->sc_timeout = ESP_DEF_TIMEOUT;
d228 1
a228 8
	 * find the DMA by poking around the dma device structures
	 *
	 * What happens here is that if the dma driver has not been
	 * configured, then this returns a NULL pointer. Then when the
	 * dma actually gets configured, it does the opposing test, and
	 * if the sc->sc_esp field in it's softc is NULL, then tries to
	 * find the matching esp driver.
	 *
a231 4

	/*
	 * and a back pointer to us, for DMA
	 */
d235 4
d240 3
a242 3
	 * It is necessary to try to load the 2nd config register here,
	 * to find out what rev the esp chip is, else the esp_reset
	 * will not set up the defaults correctly.
d244 2
a245 6
	sc->sc_cfg1 = sc->sc_id | ESPCFG1_PARENB;
	sc->sc_cfg2 = ESPCFG2_SCSI2 | ESPCFG2_RPE;
	sc->sc_cfg3 = ESPCFG3_CDB;
	sc->sc_reg[ESP_CFG2] = sc->sc_cfg2;

	if ((sc->sc_reg[ESP_CFG2] & ~ESPCFG2_RSVD) != (ESPCFG2_SCSI2 | ESPCFG2_RPE)) {
d249 4
a252 7
		sc->sc_cfg2 = 0;
		sc->sc_reg[ESP_CFG2] = sc->sc_cfg2;
		sc->sc_cfg3 = 0;
		sc->sc_reg[ESP_CFG3] = sc->sc_cfg3;
		sc->sc_cfg3 = 5;
		sc->sc_reg[ESP_CFG3] = sc->sc_cfg3;
		if (sc->sc_reg[ESP_CFG3] != 5) {
d256 1
a256 2
			sc->sc_cfg3 = 0;
			sc->sc_reg[ESP_CFG3] = sc->sc_cfg3;
d265 1
a265 1
	printf(" %dMhz, target %d\n", sc->sc_freq, sc->sc_id);
a266 2
	/* add me to the sbus structures */
	sc->sc_sd.sd_reset = (void *) esp_reset;
d268 3
a270 1
	if (ca->ca_bustype == BUS_SBUS)
d272 7
d281 1
a281 1
	/* and the interuppts */
d297 4
a300 3
	 * If the boot path is "esp" at the moment and it's me, then
	 * walk our pointer to the sub-device, ready for the config
	 * below.
d303 1
d307 4
a310 2
		    SAME_ESP(sc, bp, ca))
			bootpath_store(1, bp + 1);
d313 1
a313 3
		if (bp != NULL && strcmp(bp->name, "esp") == 0 &&
			bp->val[0] == -1 && bp->val[1] == sc->sc_dev.dv_unit)
			bootpath_store(1, bp + 1);
d321 13
d335 4
a338 1
	bootpath_store(1, NULL);
d342 3
a344 3
 * This is the generic esp reset function. It does not reset the SCSI bus,
 * only this controllers, but kills any on-going commands, and also stops
 * and resets the DMA.
d346 123
a468 2
 * After reset, registers are loaded with the defaults from the attach
 * routine above.
d474 1
a474 1
	volatile caddr_t esp = sc->sc_reg; 
d476 1
a476 2
	/* reset DMA first */
	DMA_RESET(sc->sc_dma);
d478 4
a481 3
	ESPCMD(sc, ESPCMD_RSTCHIP);		/* reset chip */
	ESPCMD(sc, ESPCMD_NOP);
	DELAY(500);
d486 1
a486 1
		esp[ESP_CFG3] = sc->sc_cfg3;
d488 1
a488 1
		esp[ESP_CFG2] = sc->sc_cfg2;
d490 4
a493 4
		esp[ESP_CFG1] = sc->sc_cfg1;
		esp[ESP_CCF] = sc->sc_ccf;
		esp[ESP_SYNCOFF] = 0;
		esp[ESP_TIMEOUT] = sc->sc_timeout;
a494 7
	default:
		printf("%s: unknown revision code, assuming ESP100\n",
		    sc->sc_dev.dv_xname);
		esp[ESP_CFG1] = sc->sc_cfg1;
		esp[ESP_CCF] = sc->sc_ccf;
		esp[ESP_SYNCOFF] = 0;
		esp[ESP_TIMEOUT] = sc->sc_timeout;
a498 12
 * Reset the SCSI bus, but not the chip
 */
void
esp_scsi_reset(sc)
	struct esp_softc *sc;
{
	printf("esp: resetting SCSI bus\n");
	ESPCMD(sc, ESPCMD_RSTSCSI);
	DELAY(50);
}

/*
d506 1
d508 1
a508 1
	int r;
d516 2
a517 2
		ESPCMD(sc, ESPCMD_RSTSCSI);
		DELAY(50);
d529 1
a529 1
		for (r = 0; r < sizeof(sc->sc_ecb) / sizeof(*ecb); r++) {
d535 1
a535 1
		sc->sc_state = ESP_IDLE;
d549 7
a555 7
	sc->sc_phase = sc->sc_prevphase = INVALID_PHASE;
	for (r = 0; r < 8; r++) {
		struct esp_tinfo *tp = &sc->sc_tinfo[r];

		tp->flags = DO_NEGOTIATE | NEED_TO_RESET;
		tp->period = sc->sc_minsync;
		tp->offset = ESP_SYNC_REQ_ACK_OFS;
d557 1
a557 2
	sc->sc_state = ESP_IDLE;
	return;
d561 2
a562 7
 * DRIVER FUNCTIONS CALLABLE FROM HIGHER LEVEL DRIVERS
 */

/*
 * Start a SCSI-command
 * This function is called by the higher level SCSI-driver to queue/run
 * SCSI-commands.
d570 2
a571 2
	struct ecb 	*ecb;
	int s, flags;
d573 1
a573 3
	ESP_TRACE(("esp_scsi_cmd\n"));
	ESP_CMDS(("[0x%x, %d]->%d ", (int)xs->cmd->opcode, xs->cmdlen, 
	    sc_link->target));
d575 2
a576 1
	flags = xs->flags;
a587 1
		ESP_MISC(("TRY_AGAIN_LATER"));
d602 2
a603 1
	timeout(esp_timeout, ecb, (xs->timeout*hz)/1000);
d605 1
a605 1
	if (sc->sc_state == ESP_IDLE)
a606 1

d609 2
a610 2
	if (flags & SCSI_POLL) {
		/* Not allowed to use interrupts, use polling instead */
a611 3
	}

	ESP_MISC(("SUCCESSFULLY_QUEUED"));
d613 1
d615 11
d637 1
a637 1
	int count = xs->timeout * 10;
d641 8
a648 2
		if (DMA_ISINTR(sc->sc_dma)) {
			espintr(sc);
d652 1
a652 5
		DELAY(5);
		if (sc->sc_state == ESP_IDLE) {
			ESP_TRACE(("esp_poll: rescheduling"));
			esp_sched(sc);
		}
d657 4
a660 2
		ESP_MISC(("esp_poll: timeout"));
		esp_timeout((caddr_t)ecb);
d662 1
a662 1

a667 7
 * LOW LEVEL SCSI UTILITIES
 */

/*
 * Determine the SCSI bus phase, return either a real SCSI bus phase
 * or some pseudo phase we use to detect certain exceptions.
 *
a675 3
	
	if (sc->sc_espintr & ESPINTR_DIS)	/* Disconnected */
		return BUSFREE_PHASE;
d678 1
a678 2
		return (sc->sc_reg[ESP_STAT] & ESPSTAT_PHASE);

d687 1
a687 1
 * called when state == ESP_IDLE and at bio pl.
d708 1
a708 1
			struct esp_tinfo *ti = &sc->sc_tinfo[t];
a712 1
			sc->sc_prevphase = INVALID_PHASE;
d714 1
a714 1
			espselect(sc, t, sc_link->lun, cmd, ecb->clen);
d746 4
a749 2
	if (xs->error == XS_NOERROR && !(ecb->flags & ECB_CHKSENSE)) {
		if ((ecb->stat & ST_MASK)==SCSI_CHECK) {
d751 2
d760 1
a760 1
			ss->byte2 = sc_link->lun << 5;
d771 4
a774 5
			if (sc->sc_nexus == ecb) {
				sc->sc_nexus = NULL;
				sc->sc_state = ESP_IDLE;
				esp_sched(sc);
			}
d776 2
a777 7
		}
	}
	
	if (xs->error == XS_NOERROR && (ecb->flags & ECB_CHKSENSE)) {
		xs->error = XS_SENSE;
	} else {
		xs->resid = ecb->dleft;
d779 1
d782 1
a782 1
#ifdef ESP_DEBUG
d784 1
a784 1
		printf("err=0x%02x ",xs->error);
d786 1
a786 1
			printf("sense=%2x\n", xs->sense.error_code);
d788 1
a788 1
	if ((xs->resid || xs->error > XS_SENSE) && esp_debug & ESP_SHOWMISC) {
a803 1
		sc->sc_state = ESP_IDLE;
d805 2
d812 1
d815 1
a815 4
			if (ecb2 == ecb) {
				TAILQ_REMOVE(&sc->nexus_list, ecb, chain);
				sc->sc_tinfo[sc_link->target].lubusy
					&= ~(1<<sc_link->lun);
d817 5
a821 4
			}
		if (ecb2)
			;
		else if (ecb->chain.tqe_next) {
d834 1
a835 1
	return;
d848 4
a851 4
	do {				\
		ESP_MISC(("esp_sched_msgout %d ", m)); \
		ESPCMD(sc, ESPCMD_SETATN);	\
		sc->sc_msgpriq |= (m);	\
d854 1
a854 1
#define IS1BYTEMSG(m) (((m) != 1 && (m) < 0x20) || (m) & 0x80)
d868 2
a869 1
	volatile caddr_t esp = sc->sc_reg;
d871 1
d881 3
d891 8
a898 1
		sc->sc_flags &= ~ESP_DROP_MSGI;
d901 18
d920 9
a928 7
	if (sc->sc_state == ESP_RESELECTED && sc->sc_imlen == 0) {
		/*
		 * Which target is reselecting us? (The ID bit really)
		 */
		(void)espgetbyte(sc, &sc->sc_selid);
		sc->sc_selid &= ~(1<<sc->sc_id);
		ESP_MISC(("selid=0x%2x ", sc->sc_selid));
d931 17
a947 7
	for (;;) {
		/*
		 * If parity errors just dump everything on the floor
		 */
		if (sc->sc_espstat & ESPSTAT_PE) {
			esp_sched_msgout(SEND_PARITY_ERROR);
			sc->sc_flags |= ESP_DROP_MSGI;
d949 31
d981 1
a981 56
		/*
		 * If we're going to reject the message, don't bother storing
		 * the incoming bytes.  But still, we need to ACK them.
		 */
		if ((sc->sc_flags & ESP_DROP_MSGI) == 0) {
			if (espgetbyte(sc, &sc->sc_imess[sc->sc_imlen])) {
				/*
				 * XXX - hack alert.
				 * Apparently, the chip didn't grok a multibyte
				 * message from the target; set a flag that
				 * will cause selection w.o. ATN when we retry
				 * (after a SCSI reset).
				 * Set NOLUNS quirk as we won't be asking for
				 * a lun to identify.
				 */
				struct scsi_link *sc_link = sc->sc_nexus->xs->sc_link;
				printf("%s(%d,%d): "
					"MSGIN failed; trying alt selection\n",
					sc->sc_dev.dv_xname,
					sc_link->target, sc_link->lun);
				esp_sched_msgout(SEND_REJECT);
				sc->sc_tinfo[sc_link->target].flags |= T_XXX;
				sc_link->quirks |= SDEV_NOLUNS;
				if (sc->sc_state == ESP_HASNEXUS) {
					TAILQ_INSERT_HEAD(&sc->ready_list,
					    sc->sc_nexus, chain);
					sc->sc_nexus = NULL;
					sc->sc_tinfo[sc_link->target].lubusy
						&= ~(1<<sc_link->lun);
				}
				esp_scsi_reset(sc);
				sc->sc_state = ESP_IDLE;
				return;
			}
			ESP_MISC(("0x%02x ", sc->sc_imess[sc->sc_imlen]));
			if (sc->sc_imlen >= ESP_MAX_MSG_LEN) {
				esp_sched_msgout(SEND_REJECT);
				sc->sc_flags |= ESP_DROP_MSGI;
			} else {
				sc->sc_imlen++;
				/* 
				 * This testing is suboptimal, but most
				 * messages will be of the one byte variety, so
				 * it should not effect performance
				 * significantly.
				 */
				if (sc->sc_imlen == 1 && IS1BYTEMSG(sc->sc_imess[0]))
					break;
				if (sc->sc_imlen == 2 && IS2BYTEMSG(sc->sc_imess[0]))
					break;
				if (sc->sc_imlen >= 3 && ISEXTMSG(sc->sc_imess[0]) &&
				    sc->sc_imlen == sc->sc_imess[1] + 2)
					break;
			}
		}
	}
d988 1
a988 1
	 * ESP_MAX_MSG_LEN.  Longer messages will be amputated.
d990 9
a998 3
	if (sc->sc_state == ESP_HASNEXUS) {
		struct ecb *ecb = sc->sc_nexus;
		struct esp_tinfo *ti = &sc->sc_tinfo[ecb->xs->sc_link->target];
d1005 1
d1011 3
a1013 4
				struct scsi_link *sc_link = ecb->xs->sc_link;
				printf("esp: %d extra bytes from %d:%d\n",
				    -sc->sc_dleft, sc_link->target, sc_link->lun);
				sc->sc_dleft = 0;
a1014 1
			ESPCMD(sc, ESPCMD_MSGOK);
d1016 2
a1017 3
			sc->sc_flags |= ESP_BUSFREE_OK;
			return;

d1020 12
a1031 5
				printf("%s: our msg rejected by target\n",
				    sc->sc_dev.dv_xname);
			if (sc->sc_flags & ESP_SYNCHNEGO) {
				ti->period = ti->offset = 0;
				sc->sc_flags &= ~ESP_SYNCHNEGO;
d1035 1
a1035 1
			if (sc->sc_msgout == SEND_INIT_DET_ERR)
d1037 2
a1038 1
			ESPCMD(sc, ESPCMD_MSGOK);
a1040 1
			ESPCMD(sc, ESPCMD_MSGOK);
d1045 1
a1049 1
			ESPCMD(sc, ESPCMD_MSGOK);
d1053 2
a1054 2
			sc->sc_state = ESP_IDLE;
			sc->sc_flags |= ESP_BUSFREE_OK;
d1059 1
d1064 1
a1064 1
			ESPCMD(sc, ESPCMD_MSGOK);
d1071 1
a1075 1
			ESPCMD(sc, ESPCMD_MSGOK);
d1084 5
a1088 2
				if (ti->offset == 0) {
					printf("%s: async\n", TARGETNAME(ecb));
d1090 3
a1092 8
				} else if (ti->period > 124) {
					printf("%s: async\n", TARGETNAME(ecb));
					ti->offset = 0;
					esp_sched_msgout(SEND_SDTR);
				} else {	/* we are sync */
					printf("%s: sync rate %2fMb/s\n",
					    TARGETNAME(ecb),
					    sc->sc_freq/ti->period);
d1094 4
d1099 4
a1102 2
			default: /* Extended messages we don't handle */
				ESPCMD(sc, ESPCMD_SETATN);
a1104 1
			ESPCMD(sc, ESPCMD_MSGOK);
d1107 4
a1110 4
			/* thanks for that ident... */
			if (!ESP_MSG_ISIDENT(sc->sc_imess[0])) {
				ESP_MISC(("unknown "));
				ESPCMD(sc, ESPCMD_SETATN);
a1111 1
			ESPCMD(sc, ESPCMD_MSGOK);
d1114 1
a1114 1
	} else if (sc->sc_state == ESP_RESELECTED) {
a1115 1
		struct ecb *ecb;
d1117 2
a1118 1
		if (ESP_MSG_ISIDENT(sc->sc_imess[0])) { 	/* Identify? */
d1138 2
a1139 1
			if (!ecb) {		/* Invalid reselection! */
d1141 1
d1144 1
a1144 1
			} else {		/* Reestablish nexus */
d1146 1
d1153 3
a1155 3
				sc->sc_tinfo[sc_link->target].lubusy
					|= (1<<sc_link->lun);
				esp[ESP_SYNCOFF] =
d1157 2
a1158 2
				esp[ESP_SYNCTP] =
				    250 / sc->sc_tinfo[sc_link->target].period;
d1160 1
a1160 1
				sc->sc_state = ESP_HASNEXUS;
d1166 1
d1172 59
d1232 1
d1243 1
a1243 1
	volatile caddr_t esp = sc->sc_reg;
d1246 11
d1258 10
a1267 47
	if (sc->sc_prevphase != MESSAGE_OUT_PHASE) {
		/* Pick up highest priority message */
		sc->sc_msgout = sc->sc_msgpriq & -sc->sc_msgpriq;
		sc->sc_omlen = 1;		/* "Default" message len */
		switch (sc->sc_msgout) {
		case SEND_SDTR:	/* Also implies an IDENTIFY message */
			ecb = sc->sc_nexus;
			sc->sc_flags |= ESP_SYNCHNEGO;
			ti = &sc->sc_tinfo[ecb->xs->sc_link->target];
			sc->sc_omess[1] = MSG_EXTENDED;
			sc->sc_omess[2] = 3;
			sc->sc_omess[3] = MSG_EXT_SDTR;
			sc->sc_omess[4] = ti->period;
			sc->sc_omess[5] = ti->offset;
			sc->sc_omlen = 6;
			/* Fallthrough! */
		case SEND_IDENTIFY:
			if (sc->sc_state != ESP_HASNEXUS) {
				printf("esp at line %d: no nexus", __LINE__);
				Debugger();
			}
			ecb = sc->sc_nexus;
			sc->sc_omess[0] = ESP_MSG_IDENTIFY(ecb->xs->sc_link->lun);
			break;
		case SEND_DEV_RESET:
			sc->sc_omess[0] = MSG_BUS_DEV_RESET;
			sc->sc_flags |= ESP_BUSFREE_OK;
			break;
		case SEND_PARITY_ERROR:
			sc->sc_omess[0] = MSG_PARITY_ERR;
			break;
		case SEND_ABORT:
			sc->sc_omess[0] = MSG_ABORT;
			sc->sc_flags |= ESP_BUSFREE_OK;
			break;
		case SEND_INIT_DET_ERR:
			sc->sc_omess[0] = MSG_INITIATOR_DET_ERR;
			break;
		case SEND_REJECT:
			sc->sc_omess[0] = MSG_MESSAGE_REJECT;
			break;
		default:
			sc->sc_omess[0] = MSG_NOOP;
			break;
		}
		sc->sc_omp = sc->sc_omess;
	}
d1269 4
a1272 2
	/* (re)send the message */
	DMA_START(sc->sc_dma, &sc->sc_omp, &sc->sc_omlen, 0);
d1276 3
a1278 7
 * This is the most critical part of the driver, and has to know
 * how to deal with *all* error conditions and phases from the SCSI
 * bus. If there are no errors and the DMA was active, then call the
 * DMA pseudo-interrupt handler. If this returns 1, then that was it
 * and we can return from here without further processing.
 *
 * Most of this needs verifying.
d1284 1
d1287 1
a1287 1
	volatile caddr_t esp = sc->sc_reg;
d1289 11
a1299 2
	caddr_t cmd;
	int loop;
a1300 2
	ESP_TRACE(("espintr\n"));
	
d1302 2
a1303 17
	 * I have made some (maybe seriously flawed) assumptions here,
	 * but basic testing (uncomment the printf() below), show that
	 * certainly something happens when this loop is here.
	 *
	 * The idea is that many of the SCSI operations take very little
	 * time, and going away and getting interrupted is too high an
	 * overhead to pay. For example, selecting, sending a message
	 * and command and then doing some work can be done in one "pass".
	 *
	 * The DELAY is not variable because I do not understand that the
	 * DELAY loop should be fixed-time regardless of CPU speed, but
	 * I am *assuming* that the faster SCSI processors get things done
	 * quicker (sending a command byte etc), and so there is no
	 * need to be too slow.
	 *
	 * This is a heuristic. It is 2 when at 20Mhz, 2 at 25Mhz and 1
	 * at 40Mhz. This needs testing.
d1305 7
a1311 8
	for (loop = 0; 1;loop++, DELAY(50/sc->sc_freq)) {
		/* a feeling of deja-vu */
		if (!DMA_ISINTR(sc->sc_dma) && loop)
			return 1;
#if 0
		if (loop)
			printf("*");
#endif
d1313 1
a1313 2
		/* and what do the registers say... */
		espreadregs(sc);
d1315 18
a1332 3
		if (sc->sc_state == ESP_IDLE) {
			printf("%s: stray interrupt\n", sc->sc_dev.dv_xname);
			return 0;
d1334 4
d1339 30
a1368 1
		sc->sc_intrcnt.ev_count++;
d1371 2
a1372 6
		 * What phase are we in when we *entered* the
		 * interrupt handler ?
		 *
		 * On laster ESP chips (ESP236 and up) the FE (features
		 * enable) bit in config 2 latches the phase bits
		 * at each "command completion".
d1374 2
a1375 2
		sc->sc_phase = espphase(sc);

d1377 2
a1378 14
		 * At the moment, only a SCSI Bus Reset or Illegal
		 * Command are classed as errors. A diconnect is a
		 * valid condition, and we let the code check is the
		 * "ESP_BUSFREE_OK" flag was set before declaring it
		 * and error.
		 *
		 * Also, the status register tells us about "Gross
		 * Errors" and "Parity errors". Only the Gross Error
		 * is really bad, and the parity errors are dealt
		 * with later
		 *
		 * TODO
		 *	If there are too many parity error, go to slow
		 *	cable mode ?
d1380 6
a1385 1
#define ESPINTR_ERR (ESPINTR_SBR|ESPINTR_ILL)
d1387 31
a1417 7
		if (sc->sc_espintr & ESPINTR_ERR ||
		    sc->sc_espstat & ESPSTAT_GE) {
			/* SCSI Reset */
			if (sc->sc_espintr & ESPINTR_SBR) {
				if (esp[ESP_FFLAG] & ESPFIFO_FF) {
					ESPCMD(sc, ESPCMD_FLUSH);
					DELAY(1);
a1418 4
				printf("%s: SCSI bus reset\n",
				    sc->sc_dev.dv_xname);
				esp_init(sc, 0); /* Restart everything */
				return 1;
d1421 3
a1423 6
			if (sc->sc_espstat & ESPSTAT_GE) {
				/* no target ? */
				if (esp[ESP_FFLAG] & ESPFIFO_FF) {
					ESPCMD(sc, ESPCMD_FLUSH);
					DELAY(1);
				}
d1425 1
a1425 7
				if (sc->sc_state == ESP_HASNEXUS) {
					ecb->xs->error = XS_DRIVER_STUFFUP;
					untimeout(esp_timeout, ecb);
					espreadregs(sc);
					esp_done(ecb);
				}
				return 1;
d1428 45
a1472 15
			if (sc->sc_espintr & ESPINTR_ILL) {
				/* illegal command, out of sync ? */
				printf("%s: illegal command ",
				    sc->sc_dev.dv_xname);
				if (esp[ESP_FFLAG] & ESPFIFO_FF) {
					ESPCMD(sc, ESPCMD_FLUSH);
					DELAY(1);
				}
				if (sc->sc_state == ESP_HASNEXUS) {
					ecb->xs->error = XS_DRIVER_STUFFUP;
					untimeout(esp_timeout, ecb);
					esp_done(ecb);
				}
				esp_reset(sc);		/* so start again */
				return 1;
d1474 34
d1511 4
a1514 5
		 * Call if DMA is active.
		 *
		 * If DMA_INTR returns true, then maybe go 'round the loop
		 * again in case there is no more DMA queued, but a phase
		 * change is expected.
d1516 19
a1534 6
		if (sc->sc_dma->sc_active && DMA_INTR(sc->sc_dma)) {
			/* If DMA active here, then go back to work... */
			if (sc->sc_dma->sc_active)
				return 1;
			DELAY(50/sc->sc_freq);
			continue;
d1538 11
a1548 1
		 * check for less serious errors
d1551 4
a1554 5
			printf("esp: SCSI bus parity error\n");
			if (sc->sc_prevphase == MESSAGE_IN_PHASE)
				esp_sched_msgout(SEND_PARITY_ERROR);
			else 
				esp_sched_msgout(SEND_INIT_DET_ERR);
d1557 1
a1557 6
		if (sc->sc_espintr & ESPINTR_DIS) {
			ESP_MISC(("disc "));
			if (esp[ESP_FFLAG] & ESPFIFO_FF) {
				ESPCMD(sc, ESPCMD_FLUSH);
				DELAY(1);
			}
d1559 5
a1563 2
			 * This command must (apparently) be issued within
			 * 250mS of a disconnect. So here you are...
d1565 13
a1577 8
			ESPCMD(sc, ESPCMD_ENSEL);
			if (sc->sc_state != ESP_IDLE) {
				/* it may be OK to disconnect */
				if (!(sc->sc_flags & ESP_BUSFREE_OK))
					ecb->xs->error = XS_TIMEOUT;
				untimeout(esp_timeout, ecb);
				esp_done(ecb);
				return 1;
d1581 26
a1606 4
		/* did a message go out OK ? This must be broken */
		if (sc->sc_prevphase == MESSAGE_OUT_PHASE &&
		    sc->sc_phase != MESSAGE_OUT_PHASE) {
			/* we have sent it */
a1608 1
		}
d1610 5
a1614 1
		switch (sc->sc_state) {
a1615 1
		case ESP_RESELECTED:
d1617 4
a1620 1
			 * we must be continuing a message ?
d1622 2
a1623 14
			if (sc->sc_phase != MESSAGE_IN_PHASE) {
				printf("%s: target didn't identify\n",
				    sc->sc_dev.dv_xname);
				esp_init(sc, 1);
				return 1;
			}
			esp_msgin(sc);
			if (sc->sc_state != ESP_HASNEXUS) {
				/* IDENTIFY fail?! */
				printf("%s: identify failed\n",
				    sc->sc_dev.dv_xname);
				esp_init(sc, 1);
				return 1;
			}
d1625 19
d1645 4
a1648 2
		case ESP_IDLE:
		case ESP_SELECTING:
d1650 24
a1673 1
			if (sc->sc_espintr & ESPINTR_RESEL) {
d1675 5
a1679 3
				 * If we're trying to select a
				 * target ourselves, push our command
				 * back into the ready list.
a1680 27
				if (sc->sc_state == ESP_SELECTING) {
					ESP_MISC(("backoff selector "));
					TAILQ_INSERT_HEAD(&sc->ready_list,
					    sc->sc_nexus, chain);
			sc->sc_tinfo[sc->sc_nexus->xs->sc_link->target].lubusy
						&= ~(1<<sc_link->lun);
					sc->sc_nexus = NULL;
				}
				sc->sc_state = ESP_RESELECTED;
				if (sc->sc_phase != MESSAGE_IN_PHASE) {
					/*
					 * Things are seriously fucked up.
					 * Pull the brakes, i.e. reset
					 */
					printf("%s: target didn't identify\n", 
					    sc->sc_dev.dv_xname);
					esp_init(sc, 1);
					return 1;
				}
				esp_msgin(sc);	/* Handle identify message */
				if (sc->sc_state != ESP_HASNEXUS) {
					/* IDENTIFY fail?! */
					printf("%s: identify failed\n",
					    sc->sc_dev.dv_xname);
					esp_init(sc, 1);
					return 1;
				}
d1683 15
d1699 16
a1714 27
#define	ESPINTR_DONE	(ESPINTR_FC|ESPINTR_BS)
			if ((sc->sc_espintr & ESPINTR_DONE) == ESPINTR_DONE) {
				ecb = sc->sc_nexus;
				if (!ecb)
					panic("esp: not nexus at sc->sc_nexus");
				sc_link = ecb->xs->sc_link;
				ti = &sc->sc_tinfo[sc_link->target];
				if (ecb->xs->flags & SCSI_RESET)
					sc->sc_msgpriq = SEND_DEV_RESET;
				else if (ti->flags & DO_NEGOTIATE)
					sc->sc_msgpriq =
					    SEND_IDENTIFY | SEND_SDTR;
				else
					sc->sc_msgpriq = SEND_IDENTIFY;
				sc->sc_state = ESP_HASNEXUS;
				sc->sc_flags = 0;
				sc->sc_prevphase = INVALID_PHASE;
				sc->sc_dp = ecb->daddr;
				sc->sc_dleft = ecb->dleft;
				ti->lubusy |= (1<<sc_link->lun);
				break;
			} else if (sc->sc_espintr & ESPINTR_FC) {
				if (sc->sc_espstep != ESPSTEP_DONE)
					if (esp[ESP_FFLAG] & ESPFIFO_FF) {
						ESPCMD(sc, ESPCMD_FLUSH);
						DELAY(1);
					}
d1716 2
a1717 3
			/* We aren't done yet, but expect to be soon */
			DELAY(50/sc->sc_freq);
			continue;
d1719 11
a1729 4
		case ESP_HASNEXUS:
			break;
		default:
			panic("esp unknown state");
d1731 2
a1732 1

d1734 2
a1735 2
		 * Driver is now in state ESP_HASNEXUS, i.e. we
		 * have a current command working the SCSI bus.
d1737 6
a1742 3
		cmd = (caddr_t) &ecb->cmd;
		if (sc->sc_state != ESP_HASNEXUS || ecb == NULL) {
			panic("esp no nexus");
d1744 9
d1754 21
a1774 18
		switch (sc->sc_phase) {
		case MESSAGE_OUT_PHASE:
			ESP_PHASE(("MESSAGE_OUT_PHASE "));
			esp_msgout(sc);
			sc->sc_prevphase = MESSAGE_OUT_PHASE;
			break;
		case MESSAGE_IN_PHASE:
			ESP_PHASE(("MESSAGE_IN_PHASE "));
			esp_msgin(sc);
			sc->sc_prevphase = MESSAGE_IN_PHASE;
			break;
		case COMMAND_PHASE:
			/* well, this means send the command again */
			ESP_PHASE(("COMMAND_PHASE 0x%02x (%d) ",
				ecb->cmd.opcode, ecb->clen));
			if (esp[ESP_FFLAG] & ESPFIFO_FF) {
				ESPCMD(sc, ESPCMD_FLUSH);
				DELAY(1);
d1776 1
a1776 36
			espselect(sc, ecb->xs->sc_link->target,
			    ecb->xs->sc_link->lun, (caddr_t)&ecb->cmd,
			    ecb->clen);
			sc->sc_prevphase = COMMAND_PHASE;
			break;
		case DATA_OUT_PHASE:
			ESP_PHASE(("DATA_OUT_PHASE [%d] ",  sc->sc_dleft));
			ESPCMD(sc, ESPCMD_FLUSH);
			DMA_START(sc->sc_dma, &sc->sc_dp, &sc->sc_dleft, 0);
			sc->sc_prevphase = DATA_OUT_PHASE;
			break;
		case DATA_IN_PHASE:
			ESP_PHASE(("DATA_IN_PHASE "));
			ESPCMD(sc, ESPCMD_FLUSH);
			DMA_DRAIN(sc->sc_dma);
			DMA_START(sc->sc_dma, &sc->sc_dp, &sc->sc_dleft,
			    D_WRITE);
			sc->sc_prevphase = DATA_IN_PHASE;
			break;
		case STATUS_PHASE:
			ESP_PHASE(("STATUS_PHASE "));
			ESPCMD(sc, ESPCMD_ICCS);
			(void)espgetbyte(sc, &ecb->stat);
			ESP_PHASE(("0x%02x ", ecb->stat));
			sc->sc_prevphase = STATUS_PHASE;
			break;
		case INVALID_PHASE:
			break;
		case BUSFREE_PHASE:
			if (sc->sc_flags & ESP_BUSFREE_OK) {
				/*It's fun the 1st time.. */
				sc->sc_flags &= ~ESP_BUSFREE_OK;
			}
			break;
		default:
			panic("esp: bogus bus phase\n");
d1778 5
a1783 1
}
d1785 28
a1812 7
void
esp_timeout(arg)
	void *arg;
{
	int s = splbio();
	struct ecb *ecb = (struct ecb *)arg;
	struct esp_softc *sc;
d1814 39
a1852 4
	sc = ecb->xs->sc_link->adapter_softc;
	sc_print_addr(ecb->xs->sc_link);
	ecb->xs->error = XS_TIMEOUT;
	printf("timed out\n");
d1854 5
a1858 3
	esp_done(ecb);
	esp_reset(sc);
	splx(s);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
