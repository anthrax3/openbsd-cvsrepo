head	1.61;
access;
symbols
	OPENBSD_6_0:1.60.0.2
	OPENBSD_6_0_BASE:1.60
	OPENBSD_5_9:1.59.0.2
	OPENBSD_5_9_BASE:1.59
	OPENBSD_5_8:1.51.0.4
	OPENBSD_5_8_BASE:1.51
	OPENBSD_5_7:1.48.0.2
	OPENBSD_5_7_BASE:1.48
	OPENBSD_5_6:1.47.0.4
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.46.0.4
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.43.0.20
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.43.0.18
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.43.0.16
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.14
	OPENBSD_5_0:1.43.0.12
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.43.0.10
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.43.0.8
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.43.0.4
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.43.0.6
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.43.0.2
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.40.0.10
	OPENBSD_4_4_BASE:1.40
	OPENBSD_4_3:1.40.0.8
	OPENBSD_4_3_BASE:1.40
	OPENBSD_4_2:1.40.0.6
	OPENBSD_4_2_BASE:1.40
	OPENBSD_4_1:1.40.0.4
	OPENBSD_4_1_BASE:1.40
	OPENBSD_4_0:1.40.0.2
	OPENBSD_4_0_BASE:1.40
	OPENBSD_3_9:1.38.0.2
	OPENBSD_3_9_BASE:1.38
	OPENBSD_3_8:1.37.0.2
	OPENBSD_3_8_BASE:1.37
	OPENBSD_3_7:1.36.0.2
	OPENBSD_3_7_BASE:1.36
	OPENBSD_3_6:1.34.0.6
	OPENBSD_3_6_BASE:1.34
	SMP_SYNC_A:1.34
	SMP_SYNC_B:1.34
	OPENBSD_3_5:1.34.0.4
	OPENBSD_3_5_BASE:1.34
	OPENBSD_3_4:1.34.0.2
	OPENBSD_3_4_BASE:1.34
	UBC_SYNC_A:1.33
	OPENBSD_3_3:1.33.0.4
	OPENBSD_3_3_BASE:1.33
	OPENBSD_3_2:1.33.0.2
	OPENBSD_3_2_BASE:1.33
	OPENBSD_3_1:1.31.0.2
	OPENBSD_3_1_BASE:1.31
	UBC_SYNC_B:1.33
	UBC:1.29.0.2
	UBC_BASE:1.29
	OPENBSD_3_0:1.28.0.2
	OPENBSD_3_0_BASE:1.28
	OPENBSD_2_9_BASE:1.26
	OPENBSD_2_9:1.26.0.2
	OPENBSD_2_8:1.23.0.2
	OPENBSD_2_8_BASE:1.23
	OPENBSD_2_7:1.22.0.4
	OPENBSD_2_7_BASE:1.22
	SMP:1.22.0.2
	SMP_BASE:1.22
	kame_19991208:1.21
	OPENBSD_2_6:1.21.0.4
	OPENBSD_2_6_BASE:1.21
	OPENBSD_2_5:1.21.0.2
	OPENBSD_2_5_BASE:1.21
	OPENBSD_2_4:1.17.0.2
	OPENBSD_2_4_BASE:1.17;
locks; strict;
comment	@ * @;


1.61
date	2016.09.01.09.23.41;	author tedu;	state dead;
branches;
next	1.60;
commitid	Q2PxaFNhqAe0Wmla;

1.60
date	2016.04.13.11.34.00;	author mpi;	state Exp;
branches;
next	1.59;
commitid	RI1iBTF6Zaycxppg;

1.59
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.58;
commitid	J9apD0jq2AjFmqZc;

1.58
date	2015.11.25.11.20.38;	author mpi;	state Exp;
branches;
next	1.57;
commitid	f4dx5ry1aOiKJw33;

1.57
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.56;
commitid	B0kwmVGiD5DVx4kv;

1.56
date	2015.11.24.17.11.38;	author mpi;	state Exp;
branches;
next	1.55;
commitid	5gdEnqVoJuTuwdTu;

1.55
date	2015.11.24.13.33.18;	author mpi;	state Exp;
branches;
next	1.54;
commitid	5DvsamK0GblTp8ww;

1.54
date	2015.11.14.17.26.40;	author mpi;	state Exp;
branches;
next	1.53;
commitid	BU9j1tIQLqhcXEX9;

1.53
date	2015.11.12.10.26.09;	author dlg;	state Exp;
branches;
next	1.52;
commitid	4KEiv7rQSJNlE4x2;

1.52
date	2015.10.25.13.22.09;	author mpi;	state Exp;
branches;
next	1.51;
commitid	n8mxDftG1cK0Rpp7;

1.51
date	2015.06.24.09.40.53;	author mpi;	state Exp;
branches;
next	1.50;
commitid	MVWrtktB46JRxFWT;

1.50
date	2015.03.29.10.59.47;	author mpi;	state Exp;
branches;
next	1.49;
commitid	5gSSQiWXj4PXfvMR;

1.49
date	2015.03.28.19.07.07;	author miod;	state Exp;
branches;
next	1.48;
commitid	nwbHy4sQv9NnJnmZ;

1.48
date	2014.12.22.02.26.54;	author tedu;	state Exp;
branches;
next	1.47;
commitid	2Ez9mHW0jDzojG4V;

1.47
date	2014.07.22.10.35.35;	author mpi;	state Exp;
branches;
next	1.46;
commitid	EXpEDqO4x724IPl8;

1.46
date	2013.12.24.01.11.04;	author dlg;	state Exp;
branches;
next	1.45;

1.45
date	2013.11.27.08.56.31;	author mpi;	state Exp;
branches;
next	1.44;

1.44
date	2013.09.05.20.55.58;	author bluhm;	state Exp;
branches;
next	1.43;

1.43
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2008.10.15.19.12.19;	author blambert;	state Exp;
branches;
next	1.41;

1.41
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2006.05.27.23.59.07;	author jason;	state Exp;
branches;
next	1.39;

1.39
date	2006.03.25.22.41.41;	author djm;	state Exp;
branches;
next	1.38;

1.38
date	2005.11.09.06.14.50;	author brad;	state Exp;
branches;
next	1.37;

1.37
date	2005.06.08.17.03.02;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2005.01.15.05.24.10;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2004.09.29.07.35.11;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.02.18.40.58;	author jason;	state Exp;
branches;
next	1.33;

1.33
date	2002.08.08.03.32.00;	author jason;	state Exp;
branches;
next	1.32;

1.32
date	2002.04.30.01.12.28;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.14.01.26.42;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2002.02.08.19.05.25;	author jason;	state Exp;
branches;
next	1.29;

1.29
date	2001.11.27.02.47.49;	author jason;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2001.07.30.21.50.06;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.26.21.58.47;	author fgsch;	state Exp;
branches;
next	1.26;

1.26
date	2001.04.13.04.32.10;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2001.02.20.19.39.33;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2001.01.30.07.17.07;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2000.06.18.17.37.02;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	99.12.08.22.50.13;	author jason;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	99.02.15.16.22.26;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	99.02.08.13.39.29;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	99.01.07.03.14.42;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	98.11.02.05.50.59;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	98.10.21.04.12.09;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	98.10.19.05.39.29;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	98.10.09.02.29.03;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	98.10.02.17.42.23;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	98.09.28.05.12.22;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	98.09.15.22.36.20;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	98.09.08.03.05.52;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	98.09.08.02.01.06;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	98.09.04.05.59.19;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	98.09.01.20.04.14;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	98.08.28.19.06.46;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	98.08.26.05.00.51;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	98.07.11.05.47.36;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	98.07.05.09.25.53;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	98.07.05.06.50.20;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	98.07.04.20.20.57;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	98.07.04.07.57.52;	author deraadt;	state Exp;
branches;
next	;

1.22.2.1
date	2001.05.14.21.37.03;	author niklas;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2001.07.04.10.23.20;	author niklas;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2001.10.31.03.07.56;	author nate;	state Exp;
branches;
next	1.22.2.4;

1.22.2.4
date	2001.12.05.00.39.13;	author niklas;	state Exp;
branches;
next	1.22.2.5;

1.22.2.5
date	2002.03.06.02.04.46;	author niklas;	state Exp;
branches;
next	1.22.2.6;

1.22.2.6
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.22.2.7;

1.22.2.7
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.22.2.8;

1.22.2.8
date	2003.06.07.11.14.42;	author ho;	state Exp;
branches;
next	;

1.29.2.1
date	2002.06.11.03.38.15;	author art;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2002.10.29.00.28.09;	author art;	state Exp;
branches;
next	;


desc
@@


1.61
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: be.c,v 1.60 2016/04/13 11:34:00 mpi Exp $	*/

/*
 * Copyright (c) 1998 Theo de Raadt and Jason L. Wright.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/syslog.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/timeout.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include "bpfilter.h"
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/autoconf.h>
#include <machine/cpu.h>

#include <sparc/dev/dmareg.h>
#include <sparc/dev/dmavar.h>

#include <sparc/dev/qecvar.h>
#include <sparc/dev/qecreg.h>
#include <sparc/dev/bereg.h>
#include <sparc/dev/bevar.h>

int	bematch(struct device *, void *, void *);
void	beattach(struct device *, struct device *, void *);

void	beinit(struct besoftc *);
void	bestart(struct ifnet *);
void	bestop(struct besoftc *);
void	bewatchdog(struct ifnet *);
int	beioctl(struct ifnet *, u_long, caddr_t);
void	bereset(struct besoftc *);

int	beintr(void *);
int	berint(struct besoftc *);
int	betint(struct besoftc *);
int	beqint(struct besoftc *, u_int32_t);
int	beeint(struct besoftc *, u_int32_t);
void	be_read(struct besoftc *, int, int);

void	be_tcvr_idle(struct besoftc *);
void	be_tcvr_init(struct besoftc *);
void	be_tcvr_write(struct besoftc *, u_int8_t, u_int16_t);
void	be_tcvr_write_bit(struct besoftc *, int);
int	be_tcvr_read_bit1(struct besoftc *);
int	be_tcvr_read_bit2(struct besoftc *);
int	be_tcvr_read(struct besoftc *, u_int8_t);
void	be_ifmedia_sts(struct ifnet *, struct ifmediareq *);
int	be_ifmedia_upd(struct ifnet *);
void	be_mcreset(struct besoftc *);
void	betick(void *);
void	be_tx_harvest(struct besoftc *);

struct cfdriver be_cd = {
	NULL, "be", DV_IFNET
};

struct cfattach be_ca = {
	sizeof(struct besoftc), bematch, beattach
};

int
bematch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
	register struct romaux *ra = &ca->ca_ra;

	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
		return (0);
	return (1);
}

void
beattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct qec_softc *qec = (struct qec_softc *)parent;
	struct besoftc *sc = (struct besoftc *)self;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct confargs *ca = aux;
	struct bootpath *bp;
	extern void myetheraddr(u_char *);
	int pri, bmsr;

	if (ca->ca_ra.ra_nintr != 1) {
		printf(": expected 1 interrupt, got %d\n", ca->ca_ra.ra_nintr);
		return;
	}
	pri = ca->ca_ra.ra_intr[0].int_pri;
	sc->sc_rev = getpropint(ca->ca_ra.ra_node, "board-version", -1);

	timeout_set(&sc->sc_tick, betick, sc);

	sc->sc_cr = mapiodev(&ca->ca_ra.ra_reg[0], 0, sizeof(struct be_cregs));
	sc->sc_br = mapiodev(&ca->ca_ra.ra_reg[1], 0, sizeof(struct be_bregs));
	sc->sc_tr = mapiodev(&ca->ca_ra.ra_reg[2], 0, sizeof(struct be_tregs));
	sc->sc_qec = qec;
	sc->sc_qr = qec->sc_regs;
	bestop(sc);

	sc->sc_channel = getpropint(ca->ca_ra.ra_node, "channel#", -1);
	if (sc->sc_channel == -1)
		sc->sc_channel = 0;

	sc->sc_burst = getpropint(ca->ca_ra.ra_node, "burst-sizes", -1);
	if (sc->sc_burst == -1)
		sc->sc_burst = qec->sc_burst;

	/* Clamp at parent's burst sizes */
	sc->sc_burst &= qec->sc_burst;

	sc->sc_ih.ih_fun = beintr;
	sc->sc_ih.ih_arg = sc;
	intr_establish(pri, &sc->sc_ih, IPL_NET, sc->sc_dev.dv_xname);

	myetheraddr(sc->sc_arpcom.ac_enaddr);

	be_tcvr_init(sc);

	ifmedia_init(&sc->sc_ifmedia, 0, be_ifmedia_upd, be_ifmedia_sts);
	bmsr = be_tcvr_read(sc, PHY_BMSR);
	if (bmsr == BE_TCVR_READ_INVALID)
		return;

	if (bmsr & PHY_BMSR_10BASET_HALF) {
		ifmedia_add(&sc->sc_ifmedia, IFM_ETHER | IFM_10_T, 0, NULL);
		ifmedia_add(&sc->sc_ifmedia,
		    IFM_ETHER | IFM_10_T | IFM_HDX, 0, NULL);
		sc->sc_ifmedia.ifm_media = IFM_ETHER | IFM_10_T | IFM_HDX;
	}

	if (bmsr & PHY_BMSR_10BASET_FULL) {
		ifmedia_add(&sc->sc_ifmedia,
		    IFM_ETHER | IFM_10_T | IFM_FDX, 0, NULL);
		sc->sc_ifmedia.ifm_media = IFM_ETHER | IFM_10_T | IFM_FDX;
	}

	if (bmsr & PHY_BMSR_100BASETX_HALF) {
		ifmedia_add(&sc->sc_ifmedia, IFM_ETHER | IFM_100_TX, 0, NULL);
		ifmedia_add(&sc->sc_ifmedia,
		    IFM_ETHER | IFM_100_TX | IFM_HDX, 0, NULL);
		sc->sc_ifmedia.ifm_media = IFM_ETHER | IFM_100_TX | IFM_HDX;
	}

	if (bmsr & PHY_BMSR_100BASETX_FULL) {
		ifmedia_add(&sc->sc_ifmedia,
		    IFM_ETHER | IFM_100_TX | IFM_FDX, 0, NULL);
		sc->sc_ifmedia.ifm_media = IFM_ETHER | IFM_100_TX | IFM_FDX;
	}

	if (bmsr & PHY_BMSR_100BASET4) {
		ifmedia_add(&sc->sc_ifmedia,
		    IFM_ETHER | IFM_100_T4, 0, NULL);
		sc->sc_ifmedia.ifm_media = IFM_ETHER | IFM_100_T4;
	}

	if (bmsr & PHY_BMSR_ANC) {
		ifmedia_add(&sc->sc_ifmedia,
		    IFM_ETHER | IFM_AUTO, 0, NULL);
		sc->sc_ifmedia.ifm_media = IFM_ETHER | IFM_AUTO;
	}

	ifmedia_set(&sc->sc_ifmedia, sc->sc_ifmedia.ifm_media);

	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_start = bestart;
	ifp->if_ioctl = beioctl;
	ifp->if_watchdog = bewatchdog;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX |
	    IFF_MULTICAST;

	IFQ_SET_MAXLEN(&ifp->if_snd, BE_TX_RING_SIZE);

	/* Attach the interface. */
	if_attach(ifp);
	ether_ifattach(ifp);

	printf(" pri %d: rev %x address %s\n", pri, sc->sc_rev,
	    ether_sprintf(sc->sc_arpcom.ac_enaddr));

	bp = ca->ca_ra.ra_bp;
	if (bp != NULL && strcmp(bp->name, "be") == 0 &&
	    sc->sc_dev.dv_unit == bp->val[1])
		bp->dev = &sc->sc_dev;
}

/*
 * Start output on interface.
 * We make two assumptions here:
 *  1) that the current priority is set to splnet _before_ this code
 *     is called *and* is returned to the appropriate priority after
 *     return
 *  2) that the IFF_OACTIVE flag is checked before this code is called
 *     (i.e. that the output part of the interface is idle)
 */
void
bestart(ifp)
	struct ifnet *ifp;
{
	struct besoftc *sc = (struct besoftc *)ifp->if_softc;
	struct mbuf *m;
	int bix, len, cnt;

	if (sc->sc_no_td > 0) {
		/* Try to free previous stuff */
		be_tx_harvest(sc);
	}

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	bix = sc->sc_last_td;
	cnt = sc->sc_no_td;

	for (;;) {
		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;

#if NBPFILTER > 0
		/*
		 * If BPF is listening on this interface, let it see the
		 * packet before we commit it to the wire.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

		/*
		 * Copy the mbuf chain into the transmit buffer.
		 */
		len = qec_put(sc->sc_bufs->tx_buf[bix & BE_TX_RING_MASK], m);

		/*
		 * Initialize transmit registers and start transmission
		 */
		sc->sc_desc->be_txd[bix].tx_flags =
			BE_TXD_OWN | BE_TXD_SOP | BE_TXD_EOP |
			(len & BE_TXD_LENGTH);
		sc->sc_cr->ctrl = BE_CR_CTRL_TWAKEUP;

		if (++bix == BE_TX_RING_MAXSIZE)
			bix = 0;

		if (++cnt == BE_TX_RING_SIZE) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}
	}

	if (cnt > BE_TX_HIGH_WATER) {
		/* turn on interrupt */
		sc->sc_tx_intr = 1;
		sc->sc_cr->timask = 0;
	}

	if (cnt != sc->sc_no_td) {
		ifp->if_timer = 5;
		sc->sc_last_td = bix;
		sc->sc_no_td = cnt;
	}
}

void
bestop(sc)
	struct besoftc *sc;
{
	int tries;

	sc->sc_arpcom.ac_if.if_timer = 0;
	timeout_del(&sc->sc_tick);

	tries = 32;
	sc->sc_br->tx_cfg = 0;
	while (sc->sc_br->tx_cfg != 0 && --tries)
		DELAY(20);

	tries = 32;
	sc->sc_br->rx_cfg = 0;
	while (sc->sc_br->rx_cfg != 0 && --tries)
		DELAY(20);
}

/*
 * Reset interface.
 */
void
bereset(sc)
	struct besoftc *sc;
{
	int s;

	s = splnet();
	bestop(sc);
	beinit(sc);
	splx(s);
}

void
bewatchdog(ifp)
	struct ifnet *ifp;
{
	struct besoftc *sc = ifp->if_softc;

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	++sc->sc_arpcom.ac_if.if_oerrors;

	bereset(sc);
}

int
beintr(v)
	void *v;
{
	struct besoftc *sc = (struct besoftc *)v;
	u_int32_t whyq, whyb, whyc;
	int r = 0;

	whyq = sc->sc_qr->stat;		/* qec status */
	whyc = sc->sc_cr->stat;		/* be channel status */
	whyb = sc->sc_br->stat;		/* be status */

	if (whyq & QEC_STAT_BM)
		r |= beeint(sc, whyb);

	if (whyq & QEC_STAT_ER)
		r |= beqint(sc, whyc);

	if (sc->sc_tx_intr && (whyq & QEC_STAT_TX) && (whyc & BE_CR_STAT_TXIRQ))
		r |= betint(sc);

	if (whyq & QEC_STAT_RX && whyc & BE_CR_STAT_RXIRQ)
		r |= berint(sc);

	return (r);
}

/*
 * QEC Interrupt.
 */
int
beqint(sc, why)
	struct besoftc *sc;
	u_int32_t why;
{
	int r = 0, rst = 0;

	if (why & BE_CR_STAT_TXIRQ)
		r |= 1;
	if (why & BE_CR_STAT_RXIRQ)
		r |= 1;

	if (why & BE_CR_STAT_ERRORS) {
		r |= 1;
		rst = 1;
	}

	if (rst || r == 0) {
		printf("%s:%s qstat=%b\n", sc->sc_dev.dv_xname,
		    (r) ? "" : " unexpected",
		    why, BE_CR_STAT_BITS);
		printf("%s: resetting\n", sc->sc_dev.dv_xname);
		bereset(sc);
	}

	return r;
}

/*
 * Error interrupt.
 */
int
beeint(sc, why)
	struct besoftc *sc;
	u_int32_t why;
{
	int r = 0;

	if (why & (BE_BR_STAT_RFIFOVF | BE_BR_STAT_TFIFO_UND |
		   BE_BR_STAT_MAXPKTERR)) {
		r |= 1;
	}

	printf("%s:%s stat=%b\n", sc->sc_dev.dv_xname,
	    (r) ? "" : " unexpected", why, BE_BR_STAT_BITS);

	printf("%s: resetting\n", sc->sc_dev.dv_xname);
	bereset(sc);

	return r;
}

void
be_tx_harvest(sc)
	struct besoftc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int bix, cnt;
	struct be_txd txd;

	bix = sc->sc_first_td;
	cnt = sc->sc_no_td;

	for (;;) {
		if (cnt <= 0)
			break;

		txd.tx_flags = sc->sc_desc->be_txd[bix].tx_flags;

		if (txd.tx_flags & BE_TXD_OWN)
			break;

		ifp->if_opackets++;

		if (++bix == BE_TX_RING_MAXSIZE)
			bix = 0;

		--cnt;
	}

	if (cnt <= 0)
		ifp->if_timer = 0;

	if (sc->sc_no_td != cnt) {
		sc->sc_first_td = bix;
		sc->sc_no_td = cnt;
		ifq_clr_oactive(&ifp->if_snd);
	}

	if (sc->sc_no_td < BE_TX_LOW_WATER) {
		/* turn off interrupt */
		sc->sc_tx_intr = 0;
		sc->sc_cr->timask = 0xffffffff;
	}
}

/*
 * Transmit interrupt.
 */
int
betint(sc)
	struct besoftc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	bestart(ifp);
	return (1);
}

/*
 * Receive interrupt.
 */
int
berint(sc)
	struct besoftc *sc;
{
	int bix, len;

	bix = sc->sc_last_rd;

	/*
	 * Process all buffers with valid data.
	 */
	for (;;) {
		if (sc->sc_desc->be_rxd[bix].rx_flags & BE_RXD_OWN)
			break;

		len = sc->sc_desc->be_rxd[bix].rx_flags & BE_RXD_LENGTH;
		be_read(sc, bix, len);

		sc->sc_desc->be_rxd[(bix + BE_RX_RING_SIZE) & BE_RX_RING_MAXMASK].rx_flags =
		    BE_RXD_OWN | (BE_PKT_BUF_SZ & BE_RXD_LENGTH);

		if (++bix == BE_RX_RING_MAXSIZE)
			bix = 0;
	}

	sc->sc_last_rd = bix;

	return 1;
}

void
betick(vsc)
	void *vsc;
{
	struct besoftc *sc = vsc;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct be_bregs *br = sc->sc_br;
	int s;

	s = splnet();
	/*
	 * Get collision counters
	 */
	ifp->if_collisions += br->nc_ctr + br->fc_ctr + br->ex_ctr + br->lt_ctr;
	br->nc_ctr = 0;
	br->fc_ctr = 0;
	br->ex_ctr = 0;
	br->lt_ctr = 0;
	bestart(ifp);
	splx(s);
	timeout_add_sec(&sc->sc_tick, 1);
}

int
beioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct besoftc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		beinit(sc);
		break;

	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running, then
			 * stop it.
			 */
			bestop(sc);
			ifp->if_flags &= ~IFF_RUNNING;
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
		    (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped, then
			 * start it.
			 */
			beinit(sc);
		} else {
			/*
			 * Reset the interface to pick up changes in any other
			 * flags that affect hardware registers.
			 */
			bestop(sc);
			beinit(sc);
		}
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_ifmedia, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			be_mcreset(sc);
		error = 0;
	}

	splx(s);
	return error;
}

void
beinit(sc)
	struct besoftc *sc;
{
	struct be_bregs *br = sc->sc_br;
	struct be_cregs *cr = sc->sc_cr;
	struct qec_softc *qec = sc->sc_qec;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int s = splnet();
	int i;

	/*
	 * Allocate descriptor ring and buffers, if not already done
	 */
	if (sc->sc_desc == NULL)
		sc->sc_desc_dva = (struct be_desc *) dvma_malloc(
			sizeof(struct be_desc), &sc->sc_desc, M_NOWAIT);
	if (sc->sc_bufs == NULL)
		sc->sc_bufs_dva = (struct be_bufs *) dvma_malloc(
			sizeof(struct be_bufs), &sc->sc_bufs, M_NOWAIT);
	
	for (i = 0; i < BE_TX_RING_MAXSIZE; i++) {
		sc->sc_desc->be_txd[i].tx_addr =
			(u_int32_t)sc->sc_bufs_dva->tx_buf[i & BE_TX_RING_MASK];
		sc->sc_desc->be_txd[i].tx_flags = 0;
	}
	for (i = 0; i < BE_RX_RING_MAXSIZE; i++) {
		sc->sc_desc->be_rxd[i].rx_addr =
		    (u_int32_t)sc->sc_bufs_dva->rx_buf[i & BE_RX_RING_MASK];
		if (i < BE_RX_RING_SIZE)
			sc->sc_desc->be_rxd[i].rx_flags =
			    BE_RXD_OWN | (BE_PKT_BUF_SZ & BE_RXD_LENGTH);
		else
			sc->sc_desc->be_rxd[i].rx_flags = 0;
	}

	sc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;
	sc->sc_last_rd = 0;

	be_tcvr_init(sc);

	be_ifmedia_upd(ifp);

	bestop(sc);

	br->mac_addr2 = (sc->sc_arpcom.ac_enaddr[4] << 8) |
	    sc->sc_arpcom.ac_enaddr[5];
	br->mac_addr1 = (sc->sc_arpcom.ac_enaddr[2] << 8) |
	    sc->sc_arpcom.ac_enaddr[3];
	br->mac_addr0 = (sc->sc_arpcom.ac_enaddr[0] << 8) |
	    sc->sc_arpcom.ac_enaddr[1];

	br->rx_cfg = BE_BR_RXCFG_HENABLE | BE_BR_RXCFG_FIFO;

	be_mcreset(sc);

	DELAY(20);

	br->tx_cfg = BE_BR_TXCFG_FIFO;
	br->rand_seed = 0xbd;

	br->xif_cfg = BE_BR_XCFG_ODENABLE | BE_BR_XCFG_RESV;

	cr->rxds = (u_int32_t)sc->sc_desc_dva->be_rxd;
	cr->txds = (u_int32_t)sc->sc_desc_dva->be_txd;

	cr->rxwbufptr = cr->rxrbufptr = sc->sc_channel * qec->sc_msize;
	cr->txwbufptr = cr->txrbufptr = cr->rxrbufptr + qec->sc_rsize;

	/*
	 * Turn off counter expiration interrupts as well as
	 * 'gotframe' and 'sentframe'
	 */
	br->imask = BE_BR_IMASK_GOTFRAME	|
		    BE_BR_IMASK_RCNTEXP		|
		    BE_BR_IMASK_ACNTEXP		|
		    BE_BR_IMASK_CCNTEXP		|
		    BE_BR_IMASK_LCNTEXP		|
		    BE_BR_IMASK_CVCNTEXP	|
		    BE_BR_IMASK_SENTFRAME	|
		    BE_BR_IMASK_NCNTEXP		|
		    BE_BR_IMASK_ECNTEXP		|
		    BE_BR_IMASK_LCCNTEXP	|
		    BE_BR_IMASK_FCNTEXP		|
		    BE_BR_IMASK_DTIMEXP;

	cr->rimask = 0;

	/* disable tx interrupts initially */
	cr->timask = 0xffffffff;
	sc->sc_tx_intr = 0;

	cr->qmask = 0;
	cr->bmask = 0;

	br->jsize = 4;

	cr->ccnt = 0;

	br->tx_cfg |= BE_BR_TXCFG_ENABLE;
	br->rx_cfg |= BE_BR_RXCFG_ENABLE;

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
	splx(s);

	timeout_add_sec(&sc->sc_tick, 1);
	bestart(ifp);
}

/*
 * Set the tcvr to an idle state
 */
void
be_tcvr_idle(sc)
	struct besoftc *sc;
{
	struct be_tregs *tr = sc->sc_tr;
	volatile u_int32_t x;
	int i = 20;

	while (i--) {
		tr->mgmt_pal = MGMT_PAL_INT_MDIO | MGMT_PAL_EXT_MDIO |
			       MGMT_PAL_OENAB;
		x = tr->mgmt_pal;
		tr->mgmt_pal = MGMT_PAL_INT_MDIO | MGMT_PAL_EXT_MDIO |
			       MGMT_PAL_OENAB | MGMT_PAL_DCLOCK;
		x = tr->mgmt_pal;
	}
}

/*
 * Initialize the transceiver and figure out whether we're using the
 * external or internal one.
 */
void
be_tcvr_init(sc)
	struct besoftc *sc;
{
	volatile u_int32_t x;
	struct be_tregs *tr = sc->sc_tr;

	be_tcvr_idle(sc);

	if (sc->sc_rev != 1) {
		printf("%s: rev %d PAL not supported.\n",
			sc->sc_dev.dv_xname,
			sc->sc_rev);
		return;
	}

	tr->mgmt_pal = MGMT_PAL_INT_MDIO | MGMT_PAL_EXT_MDIO | MGMT_PAL_DCLOCK;
	x = tr->mgmt_pal;

	tr->mgmt_pal = MGMT_PAL_INT_MDIO | MGMT_PAL_EXT_MDIO;
	x = tr->mgmt_pal;
	DELAY(200);

	if (tr->mgmt_pal & MGMT_PAL_EXT_MDIO) {
		sc->sc_tcvr_type = BE_TCVR_EXTERNAL;
		tr->tcvr_pal = ~(TCVR_PAL_EXTLBACK | TCVR_PAL_MSENSE |
				 TCVR_PAL_LTENABLE);
		x = tr->tcvr_pal;
	}
	else if (tr->mgmt_pal & MGMT_PAL_INT_MDIO) {
		sc->sc_tcvr_type = BE_TCVR_INTERNAL;
		tr->tcvr_pal = ~(TCVR_PAL_EXTLBACK | TCVR_PAL_MSENSE |
				 TCVR_PAL_LTENABLE | TCVR_PAL_SERIAL);
		x = tr->tcvr_pal;
	}
	else {
		printf("%s: no internal or external transceiver found.\n",
			sc->sc_dev.dv_xname);
	}
}

int
be_tcvr_read(sc, reg)
	struct besoftc *sc;
	u_int8_t reg;
{
	int phy, i;
	u_int32_t ret = 0;

	if (sc->sc_tcvr_type == BE_TCVR_INTERNAL)
		phy = BE_PHY_INTERNAL;
	else if (sc->sc_tcvr_type == BE_TCVR_EXTERNAL)
		phy = BE_PHY_EXTERNAL;
	else {
		printf("%s: invalid tcvr type\n", sc->sc_dev.dv_xname);
		return BE_TCVR_READ_INVALID;
	}

	be_tcvr_idle(sc);

	be_tcvr_write_bit(sc, 0);
	be_tcvr_write_bit(sc, 1);
	be_tcvr_write_bit(sc, 1);
	be_tcvr_write_bit(sc, 0);

	for (i = 4; i >= 0; i--)
		be_tcvr_write_bit(sc, (phy >> i) & 1);

	for (i = 4; i >= 0; i--)
		be_tcvr_write_bit(sc, (reg >> i) & 1);

	if (sc->sc_tcvr_type == BE_TCVR_EXTERNAL) {
		(void) be_tcvr_read_bit2(sc);
		(void) be_tcvr_read_bit2(sc);

		for (i = 15; i >= 0; i--) {
			int b;

			b = be_tcvr_read_bit2(sc);
			ret |= (b & 1) << i;
		}

		(void) be_tcvr_read_bit2(sc);
		(void) be_tcvr_read_bit2(sc);
		(void) be_tcvr_read_bit2(sc);
	}
	else {
		(void) be_tcvr_read_bit1(sc);
		(void) be_tcvr_read_bit1(sc);

		for (i = 15; i >= 0; i--) {
			int b;

			b = be_tcvr_read_bit1(sc);
			ret |= (b & 1) << i;
		}

		(void) be_tcvr_read_bit1(sc);
		(void) be_tcvr_read_bit1(sc);
		(void) be_tcvr_read_bit1(sc);
	}
	return ret;
}

int
be_tcvr_read_bit1(sc)
	struct besoftc *sc;
{
	volatile u_int32_t x;
	struct be_tregs *tr = sc->sc_tr;
	int ret = 0;

	if (sc->sc_tcvr_type == BE_TCVR_INTERNAL) {
		tr->mgmt_pal = MGMT_PAL_EXT_MDIO;
		x = tr->mgmt_pal;
		tr->mgmt_pal = MGMT_PAL_EXT_MDIO | MGMT_PAL_DCLOCK;
		x = tr->mgmt_pal;
		DELAY(20);
		ret = (tr->mgmt_pal & MGMT_PAL_INT_MDIO) >> 3;
	} else if (sc->sc_tcvr_type == BE_TCVR_EXTERNAL) {
		tr->mgmt_pal = MGMT_PAL_INT_MDIO;
		x = tr->mgmt_pal;
		tr->mgmt_pal = MGMT_PAL_INT_MDIO | MGMT_PAL_DCLOCK;
		x = tr->mgmt_pal;
		DELAY(20);
		ret = (tr->mgmt_pal & MGMT_PAL_EXT_MDIO) >> 2;
	} else {
		printf("%s: invalid tcvr type\n", sc->sc_dev.dv_xname);
	}
	return (ret & 1);
}

int
be_tcvr_read_bit2(sc)
	struct besoftc *sc;
{
	volatile u_int32_t x;
	struct be_tregs *tr = sc->sc_tr;
	int ret = 0;

	if (sc->sc_tcvr_type == BE_TCVR_INTERNAL) {
		tr->mgmt_pal = MGMT_PAL_EXT_MDIO;
		x = tr->mgmt_pal;
		DELAY(20);
		ret = (tr->mgmt_pal & MGMT_PAL_INT_MDIO) >> 3;
		tr->mgmt_pal = MGMT_PAL_EXT_MDIO | MGMT_PAL_DCLOCK;
		x = tr->mgmt_pal;
	} else if (sc->sc_tcvr_type == BE_TCVR_EXTERNAL) {
		tr->mgmt_pal = MGMT_PAL_INT_MDIO;
		x = tr->mgmt_pal;
		DELAY(20);
		ret = (tr->mgmt_pal & MGMT_PAL_EXT_MDIO) >> 2;
		tr->mgmt_pal = MGMT_PAL_INT_MDIO | MGMT_PAL_DCLOCK;
		x = tr->mgmt_pal;
	} else {
		printf("%s: invalid tcvr type\n", sc->sc_dev.dv_xname);
	}
	return ret;
}

void
be_tcvr_write(sc, reg, val)
	struct besoftc *sc;
	u_int8_t reg;
	u_int16_t val;
{
	int phy, i;

	if (sc->sc_tcvr_type == BE_TCVR_INTERNAL)
		phy = BE_PHY_INTERNAL;
	else if (sc->sc_tcvr_type == BE_TCVR_EXTERNAL)
		phy = BE_PHY_EXTERNAL;
	else {
		printf("%s: invalid tcvr type\n", sc->sc_dev.dv_xname);
		return;
	}

	be_tcvr_idle(sc);

	be_tcvr_write_bit(sc, 0);
	be_tcvr_write_bit(sc, 1);
	be_tcvr_write_bit(sc, 0);
	be_tcvr_write_bit(sc, 1);

	for (i = 4; i >= 0; i--)
		be_tcvr_write_bit(sc, (phy >> i) & 1);

	for (i = 4; i >= 0; i--)
		be_tcvr_write_bit(sc, (reg >> i) & 1);

	be_tcvr_write_bit(sc, 1);
	be_tcvr_write_bit(sc, 0);

	for (i = 15; i >= 0; i--)
		be_tcvr_write_bit(sc, (val >> i) & 1);
}

void
be_tcvr_write_bit(sc, bit)
	struct besoftc *sc;
	int bit;
{
	volatile u_int32_t x;

	if (sc->sc_tcvr_type == BE_TCVR_INTERNAL) {
		bit = ((bit & 1) << 3) | MGMT_PAL_OENAB | MGMT_PAL_EXT_MDIO;
		sc->sc_tr->mgmt_pal = bit;
		x = sc->sc_tr->mgmt_pal;
		sc->sc_tr->mgmt_pal = bit | MGMT_PAL_DCLOCK;
		x = sc->sc_tr->mgmt_pal;
	} else {
		bit = ((bit & 1) << 2) | MGMT_PAL_OENAB | MGMT_PAL_INT_MDIO;
		sc->sc_tr->mgmt_pal = bit;
		x = sc->sc_tr->mgmt_pal;
		sc->sc_tr->mgmt_pal = bit | MGMT_PAL_DCLOCK;
		x = sc->sc_tr->mgmt_pal;
	}
}

/*
 * Pass a packet to the higher levels.
 */
void
be_read(sc, idx, len)
	struct besoftc *sc;
	int idx, len;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;

	if (len <= sizeof(struct ether_header) ||
	    len > ETHERMTU + sizeof(struct ether_header)) {

		printf("%s: invalid packet size %d; dropping\n",
			ifp->if_xname, len);

		ifp->if_ierrors++;
		return;
	}

	/*
	 * Pull packet off interface.
	 */
	m = qec_get(sc->sc_bufs->rx_buf[idx & BE_RX_RING_MASK], len);
	if (m == NULL) {
		ifp->if_ierrors++;
		return;
	}

	ml_enqueue(&ml, m);
	if_input(ifp, &ml);
}

/*
 * Get current media settings.
 */
void
be_ifmedia_sts(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
{
	struct besoftc *sc = ifp->if_softc;
	int bmcr, bmsr;

	bmcr = be_tcvr_read(sc, PHY_BMCR);

	switch (bmcr & (PHY_BMCR_SPEED | PHY_BMCR_DUPLEX)) {
	case (PHY_BMCR_SPEED | PHY_BMCR_DUPLEX):
		ifmr->ifm_active = IFM_ETHER | IFM_100_TX | IFM_FDX;
		break;
	case PHY_BMCR_SPEED:
		ifmr->ifm_active = IFM_ETHER | IFM_100_TX | IFM_HDX;
		break;
	case PHY_BMCR_DUPLEX:
		ifmr->ifm_active = IFM_ETHER | IFM_10_T | IFM_FDX;
		break;
	case 0:
		ifmr->ifm_active = IFM_ETHER | IFM_10_T | IFM_HDX;
		break;
	}

	bmsr = be_tcvr_read(sc, PHY_BMSR);
	if (bmsr & PHY_BMSR_LINKSTATUS)
		ifmr->ifm_status |=  IFM_AVALID | IFM_ACTIVE;
	else {
		ifmr->ifm_status |=  IFM_AVALID;
		ifmr->ifm_status &= ~IFM_ACTIVE;
	}
}

/*
 * Set media options.
 */
int
be_ifmedia_upd(ifp)
	struct ifnet *ifp;
{
	struct besoftc *sc = ifp->if_softc;
	struct ifmedia *ifm = &sc->sc_ifmedia;
	int bmcr, tries;

	if (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)
		return (EINVAL);

	be_tcvr_write(sc, PHY_BMCR,
		PHY_BMCR_LOOPBACK | PHY_BMCR_PDOWN | PHY_BMCR_ISOLATE);
	be_tcvr_write(sc, PHY_BMCR, PHY_BMCR_RESET);

	for (tries = 16; tries >= 0; tries--) {
		bmcr = be_tcvr_read(sc, PHY_BMCR);
		if ((bmcr & PHY_BMCR_RESET) == 0)
			break;
		DELAY(20);
	}
	if (tries == 0) {
		printf("%s: bmcr reset failed\n", sc->sc_dev.dv_xname);
		return (EIO);
	}

	bmcr = be_tcvr_read(sc, PHY_BMCR);

	if (IFM_SUBTYPE(ifm->ifm_media) == IFM_100_T4) {
		bmcr |= PHY_BMCR_SPEED;
		bmcr &= ~PHY_BMCR_DUPLEX;
	}

	if (IFM_SUBTYPE(ifm->ifm_media) == IFM_100_TX) {
		bmcr |= PHY_BMCR_SPEED;
	}

	if (IFM_SUBTYPE(ifm->ifm_media) == IFM_10_T) {
		bmcr &= ~PHY_BMCR_SPEED;
	}

	if ((ifm->ifm_media & IFM_GMASK) == IFM_FDX) {
		bmcr |= PHY_BMCR_DUPLEX;
		sc->sc_br->tx_cfg |= BE_BR_TXCFG_FULLDPLX;
	}
	else {
		bmcr &= ~PHY_BMCR_DUPLEX;
		sc->sc_br->tx_cfg &= ~BE_BR_TXCFG_FULLDPLX;
	}

	be_tcvr_write(sc, PHY_BMCR, bmcr & (~PHY_BMCR_ISOLATE));

	for (tries = 32; tries >= 0; tries--) {
		bmcr = be_tcvr_read(sc, PHY_BMCR);
		if ((bmcr & PHY_BMCR_ISOLATE) == 0)
			break;
		DELAY(20);
	}
	if (tries == 0) {
		printf("%s: bmcr unisolate failed\n", sc->sc_dev.dv_xname);
		return (EIO);
	}

	return (0);
}

void
be_mcreset(sc)
	struct besoftc *sc;
{
	struct arpcom *ac = &sc->sc_arpcom;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct be_bregs *br = sc->sc_br;
	u_int32_t crc;
	u_int16_t hash[4];
	u_int8_t octet;
	int i, j;
	struct ether_multi *enm;
	struct ether_multistep step;

	if (ifp->if_flags & IFF_PROMISC) {
		br->rx_cfg |= BE_BR_RXCFG_PMISC;
		return;
	}
	else
		br->rx_cfg &= ~BE_BR_RXCFG_PMISC;

	if (ac->ac_multirangecnt > 0)
		ifp->if_flags |= IFF_ALLMULTI;

	if (ifp->if_flags & IFF_ALLMULTI) {
		br->htable3 = 0xffff;
		br->htable2 = 0xffff;
		br->htable1 = 0xffff;
		br->htable0 = 0xffff;
		return;
	}

	hash[3] = hash[2] = hash[1] = hash[0] = 0;

	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		crc = 0xffffffff;

		for (i = 0; i < ETHER_ADDR_LEN; i++) {
			octet = enm->enm_addrlo[i];

			for (j = 0; j < 8; j++) {
				if ((crc & 1) ^ (octet & 1)) {
					crc >>= 1;
					crc ^= MC_POLY_LE;
				}
				else
					crc >>= 1;
				octet >>= 1;
			}
		}

		crc >>= 26;
		hash[crc >> 4] |= 1 << (crc & 0xf);
		ETHER_NEXT_MULTI(step, enm);
	}

	br->htable3 = hash[3];
	br->htable2 = hash[2];
	br->htable1 = hash[1];
	br->htable0 = hash[0];
	ifp->if_flags &= ~IFF_ALLMULTI;
}
@


1.60
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.59 2015/12/08 13:34:22 tedu Exp $	*/
@


1.59
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.58 2015/11/25 11:20:38 mpi Exp $	*/
a215 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.58
log
@Network drivers should not include <net/route.h> or <net/netisr.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.57 2015/11/25 03:09:58 dlg Exp $	*/
d212 1
a212 1
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS |
@


1.57
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.56 2015/11/24 17:11:38 mpi Exp $	*/
a40 1
#include <net/netisr.h>
@


1.56
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.55 2015/11/24 13:33:18 mpi Exp $	*/
d254 1
a254 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d291 1
a291 1
			ifp->if_flags |= IFF_OACTIVE;
d472 1
a472 1
		ifp->if_flags &= ~IFF_OACTIVE;
d717 1
a717 1
	ifp->if_flags &= ~IFF_OACTIVE;
@


1.55
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.54 2015/11/14 17:26:40 mpi Exp $	*/
a40 1
#include <net/if_dl.h>
@


1.54
log
@No need to include <net/bpfdesc.h>

Now that "struct bpf_d" depends on <sys/srp.h> this is one of the offender
for removing the header from <sys/param.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.53 2015/11/12 10:26:09 dlg Exp $	*/
a41 1
#include <net/if_types.h>
@


1.53
log
@can just IFQ_DEQUEUE instead of POLL followed immediately by DEQUEUE

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.52 2015/10/25 13:22:09 mpi Exp $	*/
a51 1
#include <net/bpfdesc.h>
@


1.52
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.51 2015/06/24 09:40:53 mpi Exp $	*/
d264 1
a264 1
		IFQ_POLL(&ifp->if_snd, m);
a266 2

		IFQ_DEQUEUE(&ifp->if_snd, m);
@


1.51
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.50 2015/03/29 10:59:47 mpi Exp $	*/
a562 1
	struct ifaddr *ifa = (struct ifaddr *)data;
d571 1
a571 9
		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
			beinit(sc);
			arp_ifinit(&sc->sc_arpcom, ifa);
			break;
		default:
			beinit(sc);
			break;
		}
@


1.50
log
@Convert qe(4) et be(4) to if_input().

Tested by miod@@, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.49 2015/03/28 19:07:07 miod Exp $	*/
a1011 1
	ifp->if_ipackets++;
@


1.49
log
@Don't include sbusvar.h if you need neither sbus_translate() nor sbus_testdma().
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.48 2014/12/22 02:26:54 tedu Exp $	*/
d991 1
d1007 1
a1007 1
	m = qec_get(ifp, sc->sc_bufs->rx_buf[idx & BE_RX_RING_MASK], len);
d1014 2
a1015 11

#if NBPFILTER > 0
	/*
	 * Check if there's a BPF listener on this interface.
	 * If so, hand off the raw packet to BPF.
	 */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
	/* Pass the packet up. */
	ether_input_mbuf(ifp, m);
@


1.48
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.47 2014/07/22 10:35:35 mpi Exp $	*/
a57 1
#include <sparc/dev/sbusvar.h>
@


1.47
log
@<netinet/in_systm.h> is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.46 2013/12/24 01:11:04 dlg Exp $	*/
a573 1
#ifdef INET
a577 1
#endif /* INET */
@


1.46
log
@get rid of if (timeout_pending()) timeout_del(). this is racy. any
conditionals you did on timeout_pending can now be done on timeout_del
now that it returns what it did.

ok and a very good fix from kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.45 2013/11/27 08:56:31 mpi Exp $	*/
a45 1
#ifdef INET
a46 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a47 1
#endif
@


1.45
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not change the behavior of any driver but if you encounter
any problem, feel free to revert the offending chunk and ping me about
it.

ok naddy@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.44 2013/09/05 20:55:58 bluhm Exp $	*/
d326 1
a326 2
	if (timeout_pending(&sc->sc_tick))
		timeout_del(&sc->sc_tick);
@


1.44
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Remove these include lines from mvme68k, mvme88k,
sparc drivers.
test and OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.43 2008/11/28 02:44:17 brad Exp $	*/
d1161 3
a1175 19
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			/*
			 * We must listen to a range of multicast
			 * addresses.  For now, just accept all
			 * multicasts, rather than trying to set only
			 * those filter bits needed to match the range.
			 * (At this time, the only use of address
			 * ranges is for IP multicast routing, for
			 * which the range is big enough to require
			 * all bits set.)
			 */
			br->htable3 = 0xffff;
			br->htable2 = 0xffff;
			br->htable1 = 0xffff;
			br->htable0 = 0xffff;
			ifp->if_flags |= IFF_ALLMULTI;
			return;
		}

@


1.43
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.42 2008/10/15 19:12:19 blambert Exp $	*/
a48 1
#include <netinet/in_var.h>
@


1.42
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.41 2008/10/02 20:21:13 brad Exp $	*/
a617 16
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom):
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				be_mcreset(sc);
			error = 0;
		}
		break;
d622 1
d625 6
@


1.41
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.40 2006/05/27 23:59:07 jason Exp $	*/
d560 1
a560 1
	timeout_add(&sc->sc_tick, hz);
d752 1
a752 1
	timeout_add(&sc->sc_tick, hz);
@


1.40
log
@unknown ioctl is ENOTTY not EINVAL
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.39 2006/03/25 22:41:41 djm Exp $	*/
d639 1
a639 6
		if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
			splx(s);
			return error;
		}
		error = ENOTTY;
		break;
d641 1
@


1.39
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.38 2005/11/09 06:14:50 brad Exp $	*/
d643 1
a643 1
		error = EINVAL;
@


1.38
log
@splimp -> splnet
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.37 2005/06/08 17:03:02 henning Exp $	*/
d282 1
a282 1
			bpf_mtap(ifp->if_bpf, m);
d1042 1
a1042 1
		bpf_mtap(ifp->if_bpf, m);
@


1.37
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.36 2005/01/15 05:24:10 brad Exp $	*/
d658 1
a658 1
	int s = splimp();
@


1.36
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.35 2004/09/29 07:35:11 miod Exp $	*/
a585 18
#ifdef NS
		/* XXX - This code is probably wrong. */
		case AF_NS:
		    {
			struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host = *(union ns_host *)
				    (sc->sc_arpcom.ac_enaddr);
			else
				bcopy(ina->x_host.c_host,
				    sc->sc_arpcom.ac_enaddr,
				    sizeof(sc->sc_arpcom.ac_enaddr));
			/* Set new address. */
			beinit(sc);
			break;
		    }
#endif /* NS */
@


1.35
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.34 2003/06/02 18:40:58 jason Exp $	*/
d647 2
a648 1
			be_mcreset(sc);
@


1.34
log
@nuke my clause 3 & 4 (and a couple jointly (c) with Theo).
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.33 2002/08/08 03:32:00 jason Exp $	*/
d166 1
a166 1
	intr_establish(pri, &sc->sc_ih, IPL_NET);
@


1.33
log
@Completely rework transmit interrupt handling:
- try to handle tx ring reclaim in bestart()
- if we pass over the high water mark, enable TX interrupts
- disable them again when the low water mark is passed
Thanks to mickey@@ for enduring 4 versions of this =)
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.32 2002/04/30 01:12:28 art Exp $	*/
a14 2
 * 3. The name of the authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.32
log
@Fix an ancient problem in how sparc interrupts are handled.

There are many interrupt handlers that assume that they don't need to do
any spl protection in their code because the interrupt of some level can't
be interrupted by an interrupt of the same level. The problem is that some
interrupt handlers have hardware levels that are lower then their "software"
levels.

Fix this by adding an additional field to struct intrhand that specifies which
"software" level an interrupt handler has and blocks that level while handling
the interrupt. This new field is initialized in intr_establish which gets
an additional argument (which can be -1 meaning that the interrupt handler
doesn't need to block any additional level).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.31 2002/03/14 01:26:42 millert Exp $	*/
d40 1
d101 2
d146 2
d258 6
a263 1
	int bix, len;
d269 1
d303 1
a303 1
		if (++sc->sc_no_td == BE_TX_RING_SIZE) {
d309 11
a319 1
	sc->sc_last_td = bix;
d328 4
d388 1
a388 1
	if (whyq & QEC_STAT_TX && whyc & BE_CR_STAT_TXIRQ)
d452 2
a453 5
/*
 * Transmit interrupt.
 */
int
betint(sc)
d457 1
a457 2
	struct be_bregs *br = sc->sc_br;
	int bix;
a459 9
	/*
	 * Get collision counters
	 */
	ifp->if_collisions += br->nc_ctr + br->fc_ctr + br->ex_ctr + br->lt_ctr;
	br->nc_ctr = 0;
	br->fc_ctr = 0;
	br->ex_ctr = 0;
	br->lt_ctr = 0;

d461 1
d464 1
a464 1
		if (sc->sc_no_td <= 0)
d477 1
a477 1
		--sc->sc_no_td;
d480 1
a480 1
	if (sc->sc_no_td == 0)
d483 1
a483 5
	/*
	 * If we freed up at least one descriptor and tx is blocked,
	 * unblock it and start it up again.
	 */
	if (sc->sc_first_td != bix) {
d485 8
a492 4
		if (ifp->if_flags & IFF_OACTIVE) {
			ifp->if_flags &= ~IFF_OACTIVE;
			bestart(ifp);
		}
d494 1
d496 10
d542 23
d756 5
a760 1
	cr->timask = 0;
d774 3
@


1.31
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.30 2002/02/08 19:05:25 jason Exp $	*/
d163 1
a163 1
	intr_establish(pri, &sc->sc_ih);
@


1.30
log
@Better tx interrupt handling; don't call bestart() from betint() unless
we're OACTIVE and cleared at least one slot
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.29 2001/11/27 02:47:49 jason Exp $	*/
d73 2
a74 2
int	bematch __P((struct device *, void *, void *));
void	beattach __P((struct device *, struct device *, void *));
d76 24
a99 24
void	beinit __P((struct besoftc *));
void	bestart __P((struct ifnet *));
void	bestop __P((struct besoftc *));
void	bewatchdog __P((struct ifnet *));
int	beioctl __P((struct ifnet *, u_long, caddr_t));
void	bereset __P((struct besoftc *));

int	beintr __P((void *));
int	berint __P((struct besoftc *));
int	betint __P((struct besoftc *));
int	beqint __P((struct besoftc *, u_int32_t));
int	beeint __P((struct besoftc *, u_int32_t));
void	be_read __P((struct besoftc *, int, int));

void	be_tcvr_idle __P((struct besoftc *));
void	be_tcvr_init __P((struct besoftc *));
void	be_tcvr_write __P((struct besoftc *, u_int8_t, u_int16_t));
void	be_tcvr_write_bit __P((struct besoftc *, int));
int	be_tcvr_read_bit1 __P((struct besoftc *));
int	be_tcvr_read_bit2 __P((struct besoftc *));
int	be_tcvr_read __P((struct besoftc *, u_int8_t));
void	be_ifmedia_sts __P((struct ifnet *, struct ifmediareq *));
int	be_ifmedia_upd __P((struct ifnet *));
void	be_mcreset __P((struct besoftc *));
d133 1
a133 1
	extern void myetheraddr __P((u_char *));
@


1.29
log
@garbage collect sc_nticks
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.28 2001/07/30 21:50:06 jason Exp $	*/
d261 1
a261 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
d265 2
a458 1
		ifp->if_flags &= ~IFF_OACTIVE;
a466 4
	sc->sc_first_td = bix;

	bestart(ifp);

d470 13
a482 1
	return 1;
@


1.29.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.29 2001/11/27 02:47:49 jason Exp $	*/
d73 2
a74 2
int	bematch(struct device *, void *, void *);
void	beattach(struct device *, struct device *, void *);
d76 24
a99 24
void	beinit(struct besoftc *);
void	bestart(struct ifnet *);
void	bestop(struct besoftc *);
void	bewatchdog(struct ifnet *);
int	beioctl(struct ifnet *, u_long, caddr_t);
void	bereset(struct besoftc *);

int	beintr(void *);
int	berint(struct besoftc *);
int	betint(struct besoftc *);
int	beqint(struct besoftc *, u_int32_t);
int	beeint(struct besoftc *, u_int32_t);
void	be_read(struct besoftc *, int, int);

void	be_tcvr_idle(struct besoftc *);
void	be_tcvr_init(struct besoftc *);
void	be_tcvr_write(struct besoftc *, u_int8_t, u_int16_t);
void	be_tcvr_write_bit(struct besoftc *, int);
int	be_tcvr_read_bit1(struct besoftc *);
int	be_tcvr_read_bit2(struct besoftc *);
int	be_tcvr_read(struct besoftc *, u_int8_t);
void	be_ifmedia_sts(struct ifnet *, struct ifmediareq *);
int	be_ifmedia_upd(struct ifnet *);
void	be_mcreset(struct besoftc *);
d133 1
a133 1
	extern void myetheraddr(u_char *);
d163 1
a163 1
	intr_establish(pri, &sc->sc_ih, IPL_NET);
d261 1
a261 1
		IFQ_POLL(&ifp->if_snd, m);
a264 2
		IFQ_DEQUEUE(&ifp->if_snd, m);

d457 1
d466 4
d473 1
a473 13
	/*
	 * If we freed up at least one descriptor and tx is blocked,
	 * unblock it and start it up again.
	 */
	if (sc->sc_first_td != bix) {
		sc->sc_first_td = bix;
		if (ifp->if_flags & IFF_OACTIVE) {
			ifp->if_flags &= ~IFF_OACTIVE;
			bestart(ifp);
		}
	}

	return (1);
@


1.29.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.29.2.1 2002/06/11 03:38:15 art Exp $	*/
a39 1
#include <sys/timeout.h>
a99 2
void	betick(void *);
void	be_tx_harvest(struct besoftc *);
a142 2
	timeout_set(&sc->sc_tick, betick, sc);

d253 1
a253 6
	int bix, len, cnt;

	if (sc->sc_no_td > 0) {
		/* Try to free previous stuff */
		be_tx_harvest(sc);
	}
a258 1
	cnt = sc->sc_no_td;
d292 1
a292 1
		if (++cnt == BE_TX_RING_SIZE) {
d298 1
a298 11
	if (cnt > BE_TX_HIGH_WATER) {
		/* turn on interrupt */
		sc->sc_tx_intr = 1;
		sc->sc_cr->timask = 0;
	}

	if (cnt != sc->sc_no_td) {
		ifp->if_timer = 5;
		sc->sc_last_td = bix;
		sc->sc_no_td = cnt;
	}
a306 4
	sc->sc_arpcom.ac_if.if_timer = 0;
	if (timeout_pending(&sc->sc_tick))
		timeout_del(&sc->sc_tick);

d363 1
a363 1
	if (sc->sc_tx_intr && (whyq & QEC_STAT_TX) && (whyc & BE_CR_STAT_TXIRQ))
d427 5
a431 2
void
be_tx_harvest(sc)
d435 2
a436 1
	int bix, cnt;
d439 9
a448 1
	cnt = sc->sc_no_td;
d451 1
a451 1
		if (cnt <= 0)
d464 1
a464 1
		--cnt;
d467 1
a467 1
	if (cnt <= 0)
d470 5
a474 1
	if (sc->sc_no_td != cnt) {
d476 4
a479 2
		sc->sc_no_td = cnt;
		ifp->if_flags &= ~IFF_OACTIVE;
a481 17
	if (sc->sc_no_td < BE_TX_LOW_WATER) {
		/* turn off interrupt */
		sc->sc_tx_intr = 0;
		sc->sc_cr->timask = 0xffffffff;
	}
}

/*
 * Transmit interrupt.
 */
int
betint(sc)
	struct besoftc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	bestart(ifp);
a517 23
void
betick(vsc)
	void *vsc;
{
	struct besoftc *sc = vsc;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct be_bregs *br = sc->sc_br;
	int s;

	s = splnet();
	/*
	 * Get collision counters
	 */
	ifp->if_collisions += br->nc_ctr + br->fc_ctr + br->ex_ctr + br->lt_ctr;
	br->nc_ctr = 0;
	br->fc_ctr = 0;
	br->ex_ctr = 0;
	br->lt_ctr = 0;
	bestart(ifp);
	splx(s);
	timeout_add(&sc->sc_tick, hz);
}

d709 1
a709 5

	/* disable tx interrupts initially */
	cr->timask = 0xffffffff;
	sc->sc_tx_intr = 0;

a722 3

	timeout_add(&sc->sc_tick, hz);
	bestart(ifp);
@


1.28
log
@convert to ALTQ style macros (these drivers appear to meet the criteria for
ALTQ, anyone more familiar with it wanna have a look?)
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.27 2001/06/26 21:58:47 fgsch Exp $	*/
a622 2

	sc->sc_nticks = 0;
@


1.27
log
@trivial ether_input_mbuf() conversions.
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.26 2001/04/13 04:32:10 brad Exp $	*/
d222 3
d261 2
a262 2
		IF_DEQUEUE(&ifp->if_snd, m);
		if (m == 0)
@


1.26
log
@silence printfs from media selection.
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.25 2001/02/20 19:39:33 mickey Exp $	*/
a967 1
	struct ether_header *eh;
a989 2
	/* We assume that the header fit entirely in one mbuf. */
	eh = mtod(m, struct ether_header *);
d999 2
a1000 3
	/* Pass the packet up, with the ether header sort-of removed. */
	m_adj(m, sizeof(struct ether_header));
	ether_input(ifp, eh, m);
@


1.25
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.24 2001/01/30 07:17:07 jason Exp $	*/
a1077 1
		printf("%s: selecting 100baseT4", sc->sc_dev.dv_xname);
a1081 1
		printf("%s: selecting 100baseTX", sc->sc_dev.dv_xname);
a1085 1
		printf("%s: selecting 10baseT", sc->sc_dev.dv_xname);
a1090 1
		printf(" full-duplex\n");
a1094 1
		printf(" half-duplex\n");
@


1.24
log
@- take advantage of the fact that qe's and be's require qec's and move
some common functionality into qec's driver (rx and tx frame fetching)
- avoid modulus operations
- some style
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.23 2000/06/18 17:37:02 jason Exp $	*/
a227 5

#if NBPFILTER > 0
	bpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
	    sizeof(struct ether_header));
#endif
@


1.23
log
@hmm, you'd never know these started out as if_ie.c....
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.22 1999/12/08 22:50:13 jason Exp $	*/
a87 1
int	be_put __P((struct besoftc *, int, struct mbuf *));
a88 1
struct mbuf *	be_get __P((struct besoftc *, int, int));
d279 1
a279 1
		len = be_put(sc, bix, m);
d499 1
a499 1
		sc->sc_desc->be_rxd[(bix + BE_RX_RING_SIZE)%BE_RX_RING_MAXSIZE].rx_flags =
d640 1
a640 1
			(u_int32_t) &sc->sc_bufs_dva->tx_buf[i % BE_TX_RING_SIZE][0];
d645 2
a646 2
			(u_int32_t) &sc->sc_bufs_dva->rx_buf[i % BE_RX_RING_SIZE][0];
		if ((i / BE_RX_RING_SIZE) == 0)
d648 1
a648 2
				BE_RXD_OWN |
				(BE_PKT_BUF_SZ & BE_RXD_LENGTH);
d680 2
a681 2
	cr->rxds = (u_int32_t) &sc->sc_desc_dva->be_rxd[0];
	cr->txds = (u_int32_t) &sc->sc_desc_dva->be_txd[0];
a964 28
 * Routine to copy from mbuf chain to transmit buffer in
 * network buffer memory.
 */
int
be_put(sc, idx, m)
	struct besoftc *sc;
	int idx;
	struct mbuf *m;
{
	struct mbuf *n;
	int len, tlen = 0, boff = 0;

	for (; m; m = n) {
		len = m->m_len;
		if (len == 0) {
			MFREE(m, n);
			continue;
		}
		bcopy(mtod(m, caddr_t),
		      &sc->sc_bufs->tx_buf[idx % BE_TX_RING_SIZE][boff], len);
		boff += len;
		tlen += len;
		MFREE(m, n);
	}
	return tlen;
}

/*
d989 1
a989 1
	m = be_get(sc, idx, len);
a1009 59
}

/*
 * Pull data off an interface.
 * Len is the length of data, with local net header stripped.
 * We copy the data into mbufs.  When full cluster sized units are present,
 * we copy into clusters.
 */
struct mbuf *
be_get(sc, idx, totlen)
	struct besoftc *sc;
	int idx, totlen;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf *m;
	struct mbuf *top, **mp;
	int len, pad, boff = 0;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (NULL);
	m->m_pkthdr.rcvif = ifp;
	m->m_pkthdr.len = totlen;
	pad = ALIGN(sizeof(struct ether_header)) - sizeof(struct ether_header);
	len = MHLEN;
	if (totlen >= MINCLSIZE) {
		MCLGET(m, M_DONTWAIT);
		if (m->m_flags & M_EXT)
			len = MCLBYTES;
	}
	m->m_data += pad;
	len -= pad;
	top = NULL;
	mp = &top;

	while (totlen > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == NULL) {
				m_freem(top);
				return NULL;
			}
			len = MLEN;
		}
		if (top && totlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if (m->m_flags & M_EXT)
				len = MCLBYTES;
		}
		m->m_len = len = min(totlen, len);
		bcopy(&sc->sc_bufs->rx_buf[idx % BE_RX_RING_SIZE][boff],
		      mtod(m, caddr_t), len);
		boff += len;
		totlen -= len;
		*mp = m;
		mp = &m->m_next;
	}

	return (top);
@


1.22
log
@fix mbuf chain allocation to comply with m_devget() way
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.21 1999/02/15 16:22:26 jason Exp $	*/
a583 6
#ifdef IEDEBUG   
		if (ifp->if_flags & IFF_DEBUG)
			sc->sc_debug = IED_ALL;
		else
			sc->sc_debug = 0;
#endif
@


1.22.2.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.26 2001/04/13 04:32:10 brad Exp $	*/
d88 1
d90 1
d231 5
d281 1
a281 1
		len = qec_put(sc->sc_bufs->tx_buf[bix & BE_TX_RING_MASK], m);
d501 1
a501 1
		sc->sc_desc->be_rxd[(bix + BE_RX_RING_SIZE) & BE_RX_RING_MAXMASK].rx_flags =
d584 6
d648 1
a648 1
			(u_int32_t)sc->sc_bufs_dva->tx_buf[i & BE_TX_RING_MASK];
d653 2
a654 2
		    (u_int32_t)sc->sc_bufs_dva->rx_buf[i & BE_RX_RING_MASK];
		if (i < BE_RX_RING_SIZE)
d656 2
a657 1
			    BE_RXD_OWN | (BE_PKT_BUF_SZ & BE_RXD_LENGTH);
d689 2
a690 2
	cr->rxds = (u_int32_t)sc->sc_desc_dva->be_rxd;
	cr->txds = (u_int32_t)sc->sc_desc_dva->be_txd;
d974 28
d1026 1
a1026 1
	m = qec_get(ifp, sc->sc_bufs->rx_buf[idx & BE_RX_RING_MASK], len);
d1050 59
d1179 1
d1184 1
d1189 1
d1195 1
d1200 1
@


1.22.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.22.2.1 2001/05/14 21:37:03 niklas Exp $	*/
d968 1
d991 2
d1002 3
a1004 2
	/* Pass the packet up. */
	ether_input_mbuf(ifp, m);
@


1.22.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.22.2.2 2001/07/04 10:23:20 niklas Exp $	*/
a221 3
	IFQ_SET_MAXLEN(&ifp->if_snd, BE_TX_RING_SIZE);
	IFQ_SET_READY(&ifp->if_snd);

d258 2
a259 2
		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
@


1.22.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.22.2.3 2001/10/31 03:07:56 nate Exp $	*/
d623 2
@


1.22.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d261 1
a261 1
		IFQ_POLL(&ifp->if_snd, m);
a264 2
		IFQ_DEQUEUE(&ifp->if_snd, m);

d457 1
d466 4
d473 1
a473 13
	/*
	 * If we freed up at least one descriptor and tx is blocked,
	 * unblock it and start it up again.
	 */
	if (sc->sc_first_td != bix) {
		sc->sc_first_td = bix;
		if (ifp->if_flags & IFF_OACTIVE) {
			ifp->if_flags &= ~IFF_OACTIVE;
			bestart(ifp);
		}
	}

	return (1);
@


1.22.2.6
log
@Merge in -current from about a week ago
@
text
@d73 2
a74 2
int	bematch(struct device *, void *, void *);
void	beattach(struct device *, struct device *, void *);
d76 24
a99 24
void	beinit(struct besoftc *);
void	bestart(struct ifnet *);
void	bestop(struct besoftc *);
void	bewatchdog(struct ifnet *);
int	beioctl(struct ifnet *, u_long, caddr_t);
void	bereset(struct besoftc *);

int	beintr(void *);
int	berint(struct besoftc *);
int	betint(struct besoftc *);
int	beqint(struct besoftc *, u_int32_t);
int	beeint(struct besoftc *, u_int32_t);
void	be_read(struct besoftc *, int, int);

void	be_tcvr_idle(struct besoftc *);
void	be_tcvr_init(struct besoftc *);
void	be_tcvr_write(struct besoftc *, u_int8_t, u_int16_t);
void	be_tcvr_write_bit(struct besoftc *, int);
int	be_tcvr_read_bit1(struct besoftc *);
int	be_tcvr_read_bit2(struct besoftc *);
int	be_tcvr_read(struct besoftc *, u_int8_t);
void	be_ifmedia_sts(struct ifnet *, struct ifmediareq *);
int	be_ifmedia_upd(struct ifnet *);
void	be_mcreset(struct besoftc *);
d133 1
a133 1
	extern void myetheraddr(u_char *);
@


1.22.2.7
log
@Sync the SMP branch with 3.3
@
text
@a39 1
#include <sys/timeout.h>
a99 2
void	betick(void *);
void	be_tx_harvest(struct besoftc *);
a142 2
	timeout_set(&sc->sc_tick, betick, sc);

d163 1
a163 1
	intr_establish(pri, &sc->sc_ih, IPL_NET);
d253 1
a253 6
	int bix, len, cnt;

	if (sc->sc_no_td > 0) {
		/* Try to free previous stuff */
		be_tx_harvest(sc);
	}
a258 1
	cnt = sc->sc_no_td;
d292 1
a292 1
		if (++cnt == BE_TX_RING_SIZE) {
d298 1
a298 11
	if (cnt > BE_TX_HIGH_WATER) {
		/* turn on interrupt */
		sc->sc_tx_intr = 1;
		sc->sc_cr->timask = 0;
	}

	if (cnt != sc->sc_no_td) {
		ifp->if_timer = 5;
		sc->sc_last_td = bix;
		sc->sc_no_td = cnt;
	}
a306 4
	sc->sc_arpcom.ac_if.if_timer = 0;
	if (timeout_pending(&sc->sc_tick))
		timeout_del(&sc->sc_tick);

d363 1
a363 1
	if (sc->sc_tx_intr && (whyq & QEC_STAT_TX) && (whyc & BE_CR_STAT_TXIRQ))
d427 5
a431 2
void
be_tx_harvest(sc)
d435 2
a436 1
	int bix, cnt;
d439 9
a448 1
	cnt = sc->sc_no_td;
d451 1
a451 1
		if (cnt <= 0)
d464 1
a464 1
		--cnt;
d467 1
a467 1
	if (cnt <= 0)
d470 5
a474 1
	if (sc->sc_no_td != cnt) {
d476 4
a479 2
		sc->sc_no_td = cnt;
		ifp->if_flags &= ~IFF_OACTIVE;
a481 17
	if (sc->sc_no_td < BE_TX_LOW_WATER) {
		/* turn off interrupt */
		sc->sc_tx_intr = 0;
		sc->sc_cr->timask = 0xffffffff;
	}
}

/*
 * Transmit interrupt.
 */
int
betint(sc)
	struct besoftc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	bestart(ifp);
a517 23
void
betick(vsc)
	void *vsc;
{
	struct besoftc *sc = vsc;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct be_bregs *br = sc->sc_br;
	int s;

	s = splnet();
	/*
	 * Get collision counters
	 */
	ifp->if_collisions += br->nc_ctr + br->fc_ctr + br->ex_ctr + br->lt_ctr;
	br->nc_ctr = 0;
	br->fc_ctr = 0;
	br->ex_ctr = 0;
	br->lt_ctr = 0;
	bestart(ifp);
	splx(s);
	timeout_add(&sc->sc_tick, hz);
}

d709 1
a709 5

	/* disable tx interrupts initially */
	cr->timask = 0xffffffff;
	sc->sc_tx_intr = 0;

a722 3

	timeout_add(&sc->sc_tick, hz);
	bestart(ifp);
@


1.22.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.22.2.7 2003/03/27 23:49:25 niklas Exp $	*/
d15 2
@


1.21
log
@better promisc/allmulti handling
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.20 1999/02/08 13:39:29 jason Exp $	*/
d1071 6
d1078 1
a1078 1
	len = MHLEN - pad;
@


1.20
log
@match be & qe as part of the bootpath
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.19 1999/01/07 03:14:42 jason Exp $	*/
a560 1
		sc->sc_promisc = ifp->if_flags & (IFF_PROMISC | IFF_ALLMULTI);
d678 3
a680 4
	br->htable3 = 0;
	br->htable2 = 0;
	br->htable1 = 0;
	br->htable0 = 0;
a681 1
	br->rx_cfg = BE_BR_RXCFG_HENABLE | BE_BR_RXCFG_FIFO;
d1227 7
a1238 5
		return;
	}

	if (ifp->if_flags & IFF_PROMISC) {
		br->rx_cfg |= BE_BR_RXCFG_PMISC;
@


1.19
log
@Take advantage of kernel printf %b
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.18 1998/11/02 05:50:59 jason Exp $	*/
d134 1
d235 5
@


1.18
log
@First step at unifying qe & be drivers:
o qe & be drivers now only access qec globals directly at interrupt time
o more initialization done in qec_reset
o qe & be drivers handle the qec internal buffer identically
o nuked unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.17 1998/10/21 04:12:09 jason Exp $	*/
d383 1
a383 1
	if (why & BE_CR_STAT_BERROR) {
a385 1
		printf("%s: bigmac error\n", sc->sc_dev.dv_xname);
d388 4
a391 51
	if (why & BE_CR_STAT_TXDERR) {
		r |= 1;
		rst = 1;
		printf("%s: bogus tx descriptor\n", sc->sc_dev.dv_xname);
	}

	if (why & (BE_CR_STAT_TXLERR | BE_CR_STAT_TXPERR | BE_CR_STAT_TXSERR)) {
		r |= 1;
		rst = 1;
		printf("%s: tx dma error ( ", sc->sc_dev.dv_xname);
		if (why & BE_CR_STAT_TXLERR)
			printf("Late ");
		if (why & BE_CR_STAT_TXPERR)
			printf("Parity ");
		if (why & BE_CR_STAT_TXSERR)
			printf("Generic ");
		printf(")\n");
	}

	if (why & BE_CR_STAT_RXDROP) {
		r |= 1;
		rst = 1;
		printf("%s: out of rx descriptors\n", sc->sc_dev.dv_xname);
	}

	if (why & BE_CR_STAT_RXSMALL) {
		r |= 1;
		rst = 1;
		printf("%s: rx descriptor too small\n", sc->sc_dev.dv_xname);
	}

	if (why & (BE_CR_STAT_RXLERR | BE_CR_STAT_RXPERR | BE_CR_STAT_RXSERR)) {
		r |= 1;
		rst = 1;
		printf("%s: rx dma error ( ", sc->sc_dev.dv_xname);
		if (why & BE_CR_STAT_RXLERR)
			printf("Late ");
		if (why & BE_CR_STAT_RXPERR)
			printf("Parity ");
		if (why & BE_CR_STAT_RXSERR)
			printf("Generic ");
		printf(")\n");
	}

	if (!r) {
		rst = 1;
		printf("%s: unexpected error interrupt %08x\n",
			sc->sc_dev.dv_xname, why);
	}

	if (rst) {
d407 1
a407 1
	int r = 0, rst = 0;
d409 2
a410 1
	if (why & BE_BR_STAT_RFIFOVF) {
a411 12
		rst = 1;
		printf("%s: receive fifo overrun\n", sc->sc_dev.dv_xname);
	}
	if (why & BE_BR_STAT_TFIFO_UND) {
		r |= 1;
		rst = 1;
		printf("%s: transmit fifo underrun\n", sc->sc_dev.dv_xname);
	}
	if (why & BE_BR_STAT_MAXPKTERR) {
		r |= 1;
		rst = 1;
		printf("%s: max packet size error\n", sc->sc_dev.dv_xname);
d414 2
a415 5
	if (!r) {
		rst = 1;
		printf("%s: unexpected error interrupt %08x\n",
			sc->sc_dev.dv_xname, why);
	}
d417 2
a418 4
	if (rst) {
		printf("%s: resetting\n", sc->sc_dev.dv_xname);
		bereset(sc);
	}
@


1.17
log
@The qec global reset should only be allowed to happen once per qec card, not
once per channel init.
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.16 1998/10/19 05:39:29 jason Exp $	*/
d151 3
a153 2
	sc->sc_mem = qec->sc_buffer;
	sc->sc_memsize = qec->sc_bufsiz;
d686 3
a695 15
	 * init QEC: 'be' specific initializations
	 */
	sc->sc_qr->msize = sc->sc_memsize;
	sc->sc_qr->rsize = sc->sc_memsize / 2;
	sc->sc_qr->tsize = sc->sc_memsize / 2;
	sc->sc_qr->psize = QEC_PSIZE_2048;
	if (sc->sc_burst & SBUS_BURST_64)
		i = QEC_CTRL_B64;
	else if (sc->sc_burst & SBUS_BURST_32)
		i = QEC_CTRL_B32;
	else
		i = QEC_CTRL_B16;
	sc->sc_qr->ctrl = QEC_CTRL_BMODE | i;

	/*
d730 1
a730 1
	sc->sc_br->mac_addr2 = (sc->sc_arpcom.ac_enaddr[4] << 8) |
d732 1
a732 1
	sc->sc_br->mac_addr1 = (sc->sc_arpcom.ac_enaddr[2] << 8) |
d734 1
a734 1
	sc->sc_br->mac_addr0 = (sc->sc_arpcom.ac_enaddr[0] << 8) |
d737 4
a740 4
	sc->sc_br->htable3 = 0;
	sc->sc_br->htable2 = 0;
	sc->sc_br->htable1 = 0;
	sc->sc_br->htable0 = 0;
d742 1
a742 1
	sc->sc_br->rx_cfg = BE_BR_RXCFG_HENABLE | BE_BR_RXCFG_FIFO;
d745 2
a746 2
	sc->sc_br->tx_cfg = BE_BR_TXCFG_FIFO;
	sc->sc_br->rand_seed = 0xbd;
d748 1
a748 1
	sc->sc_br->xif_cfg = BE_BR_XCFG_ODENABLE | BE_BR_XCFG_RESV;
d750 2
a751 2
	sc->sc_cr->rxds = (u_int32_t) &sc->sc_desc_dva->be_rxd[0];
	sc->sc_cr->txds = (u_int32_t) &sc->sc_desc_dva->be_txd[0];
d753 2
a754 4
	sc->sc_cr->rxwbufptr = 0;
	sc->sc_cr->rxrbufptr = 0;
	sc->sc_cr->txwbufptr = sc->sc_qr->tsize;
	sc->sc_cr->txrbufptr = sc->sc_qr->tsize;
d760 17
a776 17
	sc->sc_br->imask = BE_BR_IMASK_GOTFRAME	|
			   BE_BR_IMASK_RCNTEXP	|
			   BE_BR_IMASK_ACNTEXP	|
			   BE_BR_IMASK_CCNTEXP	|
			   BE_BR_IMASK_LCNTEXP	|
			   BE_BR_IMASK_CVCNTEXP	|
			   BE_BR_IMASK_SENTFRAME|
			   BE_BR_IMASK_NCNTEXP	|
			   BE_BR_IMASK_ECNTEXP	|
			   BE_BR_IMASK_LCCNTEXP	|
			   BE_BR_IMASK_FCNTEXP	|
			   BE_BR_IMASK_DTIMEXP;

	sc->sc_cr->rimask = 0;
	sc->sc_cr->timask = 0;
	sc->sc_cr->qmask = 0;
	sc->sc_cr->bmask = 0;
d778 1
a778 1
	sc->sc_br->jsize = 4;
d780 1
a780 1
	sc->sc_cr->ccnt = 0;
d782 2
a783 2
	sc->sc_br->tx_cfg |= BE_BR_TXCFG_ENABLE;
	sc->sc_br->rx_cfg |= BE_BR_RXCFG_ENABLE;
@


1.16
log
@Garbage collect an unused variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.15 1998/10/09 02:29:03 jason Exp $	*/
a689 2

	qec_reset(sc->sc_qec);
@


1.15
log
@Turn off all "counter expired" interrupts (missed defer-counter expired counter)
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.14 1998/10/02 17:42:23 jason Exp $	*/
a152 1
	sc->sc_conf3 = getpropint(ca->ca_ra.ra_node, "busmaster-regval", 0);
@


1.14
log
@Fixed multicast filter setup.
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.13 1998/09/28 05:12:22 jason Exp $	*/
a471 4
	if (why & BE_BR_STAT_DTIMEXP) {
		r |= 1;
		printf("%s: defer timer expired\n", sc->sc_dev.dv_xname);
	}
d776 12
a787 12
	sc->sc_br->imask = BE_BR_IMASK_GOTFRAME |
			   BE_BR_IMASK_RCNTEXP  |
			   BE_BR_IMASK_ACNTEXP  |
			   BE_BR_IMASK_CCNTEXP  |
			   BE_BR_IMASK_LCNTEXP  |
			   BE_BR_IMASK_CVCNTEXP |
			   BE_BR_IMASK_NCNTEXP  |
			   BE_BR_IMASK_ECNTEXP  |
			   BE_BR_IMASK_LCCNTEXP |
			   BE_BR_IMASK_LCNTEXP  |
			   BE_BR_IMASK_LCNTEXP  |
			   BE_BR_IMASK_SENTFRAME;
@


1.13
log
@don't use bcopy to get the tx_flags value, get it directly
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.12 1998/09/15 22:36:20 jason Exp $	*/
d1301 6
d1313 1
d1315 2
a1316 1
	else if (ifp->if_flags & IFF_PROMISC) {
d1318 1
a1319 5
	else {
		struct ether_multi *enm;
		struct ether_multistep step;
		u_int16_t hash[4];
		u_int32_t crc = 0xffffffffU;
d1321 1
a1321 2
		br->htable3 = br->htable2 = br->htable1 = br->htable0 = 0;
		hash[3] = hash[2] = hash[1] = hash[0] = 0;
d1323 20
a1342 3
		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			int i, j;
d1344 1
a1344 2
			for (i = 0; i < ETHER_ADDR_LEN; i++) {
				u_int8_t octet = enm->enm_addrlo[i];
d1346 2
a1347 2
				for (j = 0; j < 8; j++) {
					u_int8_t bit;
d1349 2
a1350 1
					bit = (octet << j) & 1;
d1352 1
a1352 2
					if ((bit ^ crc) & 1)
						crc = crc ^ MC_POLY_LE;
d1354 3
a1357 3
			crc >>= 26;
			hash[crc >> 4] |= 1 << (crc & 0x0f);
			ETHER_NEXT_MULTI(step, enm);
a1358 4
		br->htable0 = hash[0];
		br->htable1 = hash[1];
		br->htable2 = hash[2];
		br->htable3 = hash[3];
d1360 3
d1364 6
@


1.12
log
@multicast support + a little KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.11 1998/09/08 03:05:52 jason Exp $	*/
d518 1
a518 1
		bcopy(&sc->sc_desc->be_txd[bix], &txd, sizeof(txd));
@


1.11
log
@changed order of ifmedia_add's (purely cosmetic)
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.10 1998/09/08 02:01:06 jason Exp $	*/
d81 1
a81 1
void	bereset __P((struct besoftc *sc));
d92 7
a98 7
void	be_tcvr_idle __P((struct besoftc *sc));
void	be_tcvr_init __P((struct besoftc *sc));
void	be_tcvr_write __P((struct besoftc *sc, u_int8_t reg, u_int16_t val));
void	be_tcvr_write_bit __P((struct besoftc *sc, int bit));
int	be_tcvr_read_bit1 __P((struct besoftc *sc));
int	be_tcvr_read_bit2 __P((struct besoftc *sc));
int	be_tcvr_read __P((struct besoftc *sc, u_int8_t reg));
d101 1
d666 1
a666 3
#if 0
			mc_reset(sc);
#endif
d1292 54
@


1.10
log
@Correct braino in ifmedia status
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.9 1998/09/04 05:59:19 jason Exp $	*/
d175 1
a177 1
		ifmedia_add(&sc->sc_ifmedia, IFM_ETHER | IFM_10_T, 0, NULL);
d188 1
a190 1
		ifmedia_add(&sc->sc_ifmedia, IFM_ETHER | IFM_100_TX, 0, NULL);
@


1.9
log
@ifmedia-fy qec+be
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.8 1998/09/01 20:04:14 jason Exp $	*/
d1197 2
a1198 2
	if ((bmcr & (PHY_BMCR_SPEED | PHY_BMCR_DUPLEX)) ==
	    (PHY_BMCR_SPEED | PHY_BMCR_DUPLEX)) {
d1200 2
a1201 4
		return;
	}

	if (bmcr & PHY_BMCR_SPEED) {
d1203 2
a1204 4
		return;
	}

	if (bmcr & PHY_BMCR_DUPLEX) {
d1206 4
a1209 1
		return;
a1211 2
	ifmr->ifm_active = IFM_ETHER | IFM_10_T | IFM_HDX;

d1214 1
a1214 1
		ifmr->ifm_active |=  IFM_AVALID | IFM_ACTIVE;
d1216 2
a1217 2
		ifmr->ifm_active |=  IFM_AVALID;
		ifmr->ifm_active &= ~IFM_ACTIVE;
@


1.8
log
@o sun4c supported now
o added collision counters
o general improvements
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.7 1998/08/28 19:06:46 jason Exp $	*/
d45 1
a93 1
void	be_tcvr_setspeed __P((struct besoftc *sc));
d99 2
a100 2

void	be_negotiate_watchdog __P((void *));
d134 1
a134 1
	int pri;
d167 47
d671 4
a694 1
	untimeout(be_negotiate_watchdog, sc);
d744 2
a745 1
	be_tcvr_setspeed(sc);
a810 32
void
be_tcvr_setspeed(sc)
	struct besoftc *sc;
{
	int x, tries, i;

	be_tcvr_write(sc, PHY_BMCR,
		PHY_BMCR_LOOPBACK | PHY_BMCR_PDOWN | PHY_BMCR_ISOLATE);
	be_tcvr_write(sc, PHY_BMCR, PHY_BMCR_RESET);

	for (tries = 0; tries < 16; i++) {
		x = be_tcvr_read(sc, PHY_BMCR);
		if ((x & PHY_BMCR_RESET) == 0)
			break;
		DELAY(20);
	}

	x = be_tcvr_read(sc, PHY_BMCR);
	be_tcvr_write(sc, PHY_BMCR, x & (~PHY_BMCR_ISOLATE));

	for (tries = 0; tries < 32; i++) {
		x = be_tcvr_read(sc, PHY_BMCR);
		if ((x & PHY_BMCR_ISOLATE) == 0)
			break;
		DELAY(20);
	}

	x = be_tcvr_read(sc, PHY_BMSR);
	if ((x & PHY_BMSR_LINKSTATUS) == 0)
		timeout(be_negotiate_watchdog, sc, (12 * hz)/10);
}

d1184 3
d1188 3
a1190 2
be_negotiate_watchdog(v)
	void *v;
d1192 10
a1201 2
	struct besoftc *sc = (struct besoftc *)v;
	int x;
d1203 2
a1204 3
	if (sc->sc_nticks == BE_NEGOTIATE_MAXTICKS) {
		sc->sc_nticks = 0;
		be_tcvr_setspeed(sc);
a1206 1
	sc->sc_nticks++;
d1208 2
a1209 3
	x = be_tcvr_read(sc, PHY_BMSR);
	if ((x & PHY_BMSR_LINKSTATUS) == 0) {
		timeout(be_negotiate_watchdog, sc, (12 * hz)/10);
d1213 83
a1295 5
	x = be_tcvr_read(sc, PHY_BMCR);
	printf("%s: %d Mb/s %s duplex, link up.\n",
			sc->sc_dev.dv_xname,
			(x & PHY_BMCR_SPEED) ? 100 : 10,
			(x & PHY_BMCR_DUPLEX) ? "full" : "half");
@


1.7
log
@o added link negotiation
o sun4c support (XXX: will be revised)
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.6 1998/08/26 05:00:51 jason Exp $	*/
d451 1
d455 9
a501 1
	struct be_rxd rxd;
d509 1
a509 3
		bcopy(&sc->sc_desc->be_rxd[bix], &rxd, sizeof(rxd));

		if (rxd.rx_flags & BE_RXD_OWN)
d512 1
a512 1
		len = rxd.rx_flags & BE_RXD_LENGTH;
d515 2
a516 3
		rxd.rx_flags =	BE_RXD_OWN | (BE_PKT_BUF_SZ & BE_RXD_LENGTH);

		bcopy(&rxd, &sc->sc_desc->be_rxd[bix], sizeof(rxd));
d682 6
a687 3
		sc->sc_desc->be_rxd[i].rx_flags =
			BE_RXD_OWN |
			(BE_PKT_BUF_SZ & BE_RXD_LENGTH);
d1056 1
a1056 1
		      ((char *)sc->sc_desc->be_txd[idx].tx_addr) + boff, len);
d1154 1
a1154 1
		bcopy(((char *)sc->sc_desc->be_rxd[idx].rx_addr) + boff,
@


1.6
log
@First cut at qec+be support.  Works in 10mbit/half duplex mode.
Removed qec+be dependency on stp2002.
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.5 1998/07/11 05:47:36 deraadt Exp $	*/
d32 3
d36 1
a37 2
#include <sys/ioctl.h>
#include <sys/socket.h>
d100 2
d237 1
a237 1
		if (++bix == BE_TX_RING_SIZE)
d468 1
a468 1
		if (++bix == BE_TX_RING_SIZE)
d512 1
a512 1
		if (++bix == BE_RX_RING_SIZE)
d638 3
d668 1
a668 1
	for (i = 0; i < BE_TX_RING_SIZE; i++) {
d670 1
a670 1
			(u_int32_t) &sc->sc_bufs_dva->tx_buf[i][0];
d673 1
a673 1
	for (i = 0; i < BE_RX_RING_SIZE; i++) {
d675 1
a675 1
			(u_int32_t) &sc->sc_bufs_dva->rx_buf[i][0];
d755 22
a776 1
	int x;
a777 1
	be_tcvr_write(sc, PHY_BMCR, 0);
d779 2
d1046 2
a1047 1
		bcopy(mtod(m, caddr_t), &sc->sc_bufs->tx_buf[idx][boff], len);
d1145 2
a1146 1
		bcopy(&sc->sc_bufs->rx_buf[idx][boff], mtod(m, caddr_t), len);
d1154 27
@


1.5
log
@fix attach() messages
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.4 1998/07/05 09:25:53 deraadt Exp $	*/
d4 2
a5 1
 * Copyright (c) 1998 Theo de Raadt.  All rights reserved.
d15 1
a15 1
 * 3. The name of the author may not be used to endorse or promote products
d18 1
a18 1
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
d21 1
a21 1
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
a73 1
void	be_meminit __P((struct besoftc *));
d78 1
d81 1
d83 7
a89 3
int	berint __P((struct besoftc *));
int	beqint __P((struct besoftc *));
int	beeint __P((struct besoftc *));
d92 5
d139 1
a139 1
	sc->sc_cr = mapiodev(ca->ca_ra.ra_reg, 0, sizeof(struct be_cregs));
d142 1
d197 1
a197 3
printf("start\n");
#if 0
	struct besoftc *sc = ifp->if_softc;
d199 1
a199 1
	int bix;
a206 2
		/* XXX TODO: Some magic */

d210 1
d220 1
a220 1
		/* XXX TODO
d223 3
a225 1
		/* XXX TODO
d228 4
d233 1
a233 1
		if (++bix == TX_RING_SIZE)
d236 1
a236 1
		if (++sc->sc_no_td == TX_RING_SIZE) {
a242 1
#endif
d262 15
a280 3
printf("watchdog\n");

#if 0
a286 1
#endif
d294 1
a294 1
	u_int32_t why;
d297 9
a305 1
	why = sc->sc_qr->stat;
d307 1
a307 1
	if (why & QEC_STAT_TX)
d309 2
a310 1
	if (why & QEC_STAT_RX)
d312 1
a312 6
	if (why & QEC_STAT_BM)
		r |= beqint(sc);
	if (why & QEC_STAT_ER)
		r |= beeint(sc);
	if (r)
		printf("%s: intr: why=%08x\n", sc->sc_dev.dv_xname, why);
d316 3
d320 1
a320 1
betint(sc)
d322 1
d324 69
a392 1
	return (0);
d395 3
d399 1
a399 1
berint(sc)
d401 1
d403 34
a436 1
	return (0);
d439 3
d443 1
a443 1
beqint(sc)
d446 32
a477 1
	return (0);
d480 3
d484 1
a484 1
beeint(sc)
d487 28
a514 1
	return (0);
a626 12
be_tcvr_init(sc)
	struct besoftc *sc;
{
}

void
be_tcvr_setspeed(sc)
	struct besoftc *sc;
{
}

void
d634 1
a634 1
	bestop(sc);
d636 3
a638 1
	/* init QEC */
d642 1
a642 1
	sc->sc_qr->psize = 2048;
d651 16
a666 14
	/* Allocate memory if not done yet */
	if (sc->sc_desc_dva == NULL)
		sc->sc_desc_dva = (struct be_desc *)dvma_malloc(
		    sizeof(struct be_desc), &sc->sc_desc, M_NOWAIT);
	if (sc->sc_bufs_dva == NULL)
		sc->sc_bufs_dva = (struct be_bufs *)dvma_malloc(
		    sizeof(struct be_bufs), &sc->sc_bufs, M_NOWAIT);

	/* chain descriptors into buffers */
	sc->sc_txnew = 0;
	sc->sc_rxnew = 0;
	sc->sc_txold = 0;
	sc->sc_rxold = 0;
	for (i = 0; i < RX_RING_SIZE; i++) {
d668 4
a671 6
		    (u_int32_t)&sc->sc_bufs_dva->rx_buf[i][0];
		sc->sc_desc->be_rxd[i].rx_flags = 0;
	}
	for (i = 0; i < TX_RING_SIZE; i++) {
		sc->sc_desc->be_txd[i].tx_addr = 0;
		sc->sc_desc->be_txd[i].tx_flags = 0;
d673 3
d694 1
a694 1
	sc->sc_br->rx_cfg = BE_RXCFG_HENABLE | BE_RXCFG_FIFO;
d697 1
a697 1
	sc->sc_br->tx_cfg = BE_TXCFG_FIFO;
d700 1
a700 1
	sc->sc_br->xif_cfg = BE_XCFG_ODENABLE | BE_XCFG_RESV;
d702 2
a703 2
	sc->sc_cr->rxds = (u_int32_t)&sc->sc_desc_dva->be_rxd[0];
	sc->sc_cr->txds = (u_int32_t)&sc->sc_desc_dva->be_txd[0];
d707 19
a725 4
	sc->sc_cr->txwbufptr = sc->sc_memsize;
	sc->sc_cr->txrbufptr = sc->sc_memsize;
	
	sc->sc_br->imask = 0;
d736 2
a737 2
	sc->sc_br->tx_cfg |= BE_TXCFG_ENABLE;
	sc->sc_br->rx_cfg |= BE_RXCFG_ENABLE;
d742 381
@


1.4
log
@basic chip setup
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.3 1998/07/05 06:50:20 deraadt Exp $	*/
d118 1
a120 3
	/* XXX the following declarations should be elsewhere */
	extern void myetheraddr __P((u_char *));

a125 1
	printf(" pri %d", pri);
a126 1
	printf(": rev %x", sc->sc_rev);
d163 4
d169 1
a169 1
	printf("\n");
@


1.3
log
@start at irq framework
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.2 1998/07/04 20:20:57 deraadt Exp $	*/
d73 1
d84 2
d142 7
d167 2
a267 1
	int r = 0;
d270 1
a271 1
#if 1
a283 2

#endif
a326 4
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return error;
	}
d413 4
d418 1
d425 12
d440 3
d445 2
a446 1
#if 0
d451 4
a454 9
	/*sc->sc_qr->ctrl = QEC_CTRL_BMODE | QEC_CTRL_B32;*/

	be_meminit(sc);

	be_write32(&treg->int_mask, 0xffff);

	c = be_read32(&treg->cfg);
	if (sc->sc_flags & HFLAG_FENABLE)
		be_write32(&treg->cfg, c & ~(TCV_CFG_BENABLE));
d456 2
a457 1
		be_write32(&treg->cfg, c | TCV_CFG_BENABLE);
d459 21
a479 11
	be_tcvr_check(sc);
	switch (sc->tcvr_type) {
	case none:
		printf("%s: no transceiver type!\n", sc->sc_dev.dv_xname);
		return;
	case internal:
		be_write32(&breg->xif_cfg, 0);
		break;
	case external:
		be_write32(&breg->xif_cfg, BIGMAC_XCFG_MIIDISAB);
		break;
a480 1
	be_tcvr_reset(sc);
d482 2
a483 2
	be_reset_tx(sc);
	be_reset_rx(sc);
d485 1
a485 14
	be_write32(&breg->jsize, BE_DEFAULT_JSIZE);
	be_write32(&breg->ipkt_gap1, BE_DEFAULT_IPKT_GAP1);
	be_write32(&breg->ipkt_gap2, BE_DEFAULT_IPKT_GAP2);
	be_write32(&breg->htable3, 0);
	be_write32(&breg->htable2, 0);
	be_write32(&breg->htable1, 0);
	be_write32(&breg->htable0, 0);

	be_write32(&erxreg->rx_ring,
		sc->sc_block_addr +
		((u_long) &sc->sc_block->be_rxd[0]) - ((u_long)sc->sc_block));
	be_write32(&etxreg->tx_ring,
		sc->sc_block_addr +
		((u_long) &sc->sc_block->be_txd[0]) - ((u_long)sc->sc_block));
d487 36
a522 10
	if (sc->sc_burst & SBUS_BURST_64)
		be_write32(&greg->cfg, GREG_CFG_BURST64);
	else if (sc->sc_burst & SBUS_BURST_32)
		be_write32(&greg->cfg, GREG_CFG_BURST32);
	else if (sc->sc_burst & SBUS_BURST_16)
		be_write32(&greg->cfg, GREG_CFG_BURST16);
	else {
		printf("%s: burst size unknown\n", sc->sc_dev.dv_xname);
		be_write32(&greg->cfg, 0);
	}
d524 1
a524 2
	/* XXX TODO: set interrupt mask: (GOTFRAME | RCNTEXP) */
	be_write32(&greg->imask, GREG_IMASK_SENTFRAME | GREG_IMASK_TXPERR);
d526 2
a527 3
	be_write32(&etxreg->tx_rsize, (TX_RING_SIZE >> ETX_RSIZE_SHIFT) - 1);
	be_write32(&etxreg->cfg, be_read32(&etxreg->cfg) | ETX_CFG_DMAENABLE);
	be_write32(&breg->rx_cfg, BIGMAC_RXCFG_HENABLE);
d529 3
a531 2
	be_auto_negotiate(sc);
#endif
@


1.2
log
@network driver framework in place
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d65 1
d76 2
d79 4
a82 1
int	beioctl __P((struct ifnet *, u_long, caddr_t));
d132 1
d256 1
a256 1
#if 0
d260 2
a261 1
	why = be_read32(&greg->stat);
d263 10
a272 2
	if (why & GREG_STAT_TXALL)
		be_tint(sc);
a273 1
	printf("%s: intr: why=%08x\n", sc->sc_dev.dv_xname, why);
d275 28
d418 2
d421 5
a425 4
	u_int32_t c;
	struct be_bregs *br = sc->sc_bregs;
	struct be_cregs *cr = sc->sc_cregs;
	struct be_tregs *tr = sc->sc_tregs;
a426 1
	bestop(sc);
@


1.1
log
@map registers of the qec+be 100mbit card
@
text
@d1 27
a27 1
#include "bpfilter.h"
d33 1
d39 3
d45 3
d51 6
d71 6
a76 2
int	beintr __P((void *arg));
void	bestop __P((struct be_softc *));
d83 1
a83 1
	sizeof(struct be_softc), bematch, beattach
d105 3
a107 1
	struct be_softc *sc = (struct be_softc *)self;
a109 1
	struct qec_softc *qec = (struct qec_softc *)parent;
a121 1
	myetheraddr(sc->sc_arpcom.ac_enaddr);
d136 14
d153 59
d214 1
a214 1
	struct be_softc *sc;
d229 16
d246 2
a247 2
beintr(arg)
	void *arg;
d249 11
d261 183
@

