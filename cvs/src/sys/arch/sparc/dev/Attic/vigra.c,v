head	1.21;
access;
symbols
	OPENBSD_6_0:1.20.0.6
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.20
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.18
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.16
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.14
	OPENBSD_5_0:1.18.0.12
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.10
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.8
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.4
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.6
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.17.0.8
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.6
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.4
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.15.0.4
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.6
	SMP:1.5.0.4
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	UBC:1.4.0.2
	UBC_SYNC_B:1.4
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3;
locks; strict;
comment	@ * @;


1.21
date	2016.09.01.09.23.42;	author tedu;	state dead;
branches;
next	1.20;
commitid	Q2PxaFNhqAe0Wmla;

1.20
date	2015.03.28.19.07.08;	author miod;	state Exp;
branches;
next	1.19;
commitid	nwbHy4sQv9NnJnmZ;

1.19
date	2013.10.20.20.07.26;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2008.12.26.22.30.21;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2007.02.18.18.40.35;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.06.02.20.00.54;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.23.17.16.34;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.07.16.44.50;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.03.09.49.05;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.05.23.04.25;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.29.22.07.37;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.29.07.35.11;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.28.17.05.33;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.06.19.42.47;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.25.21.43.09;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.06.16.59.33;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2002.11.06.21.06.20;	author miod;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2002.10.12.01.09.43;	author krw;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2002.09.23.18.13.39;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.09.22.15.16;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2002.08.31.10.47.20;	author miod;	state Exp;
branches;
next	;

1.4.2.1
date	2002.10.29.00.28.10;	author art;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;

1.5.4.1
date	2003.05.13.19.41.08;	author ho;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2003.06.07.11.14.43;	author ho;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2004.02.19.10.49.58;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: vigra.c,v 1.20 2015/03/28 19:07:08 miod Exp $	*/

/*
 * Copyright (c) 2002, 2003, Miodrag Vallat.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 * Driver for the Vigra VS series of SBus framebuffers.
 *
 * The VS10, VS11 and VS12 models are supported. VS10-EK is handled by the
 * regular cgthree driver.
 *
 * The monochrome VS14, 16 grays VS15, and color VS18 are not supported.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/mman.h>
#include <sys/tty.h>
#include <sys/conf.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/pmap.h>
#include <machine/cpu.h>
#include <machine/conf.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

/*
 * The hardware information below has been gathered through experiments, as
 * well as the debug information of the SunOS 4.x vigfb driver.
 */

/*
 * Control and status registers
 */

struct csregs {
	u_int32_t	sosr;
	u_int32_t	g3rr;
	u_int32_t	bcr;	/* board control register */
	u_int32_t	spr;
	u_int32_t	g3sr;	/* ramdac status register */
#define	STATUS_INTR	0x0001
	u_int32_t	imr;	/* interrupt mode register */
	u_int32_t	ewcr;
	u_int32_t	ssr;
};

/*
 * G300 layout
 */

struct g300dac {
	u_int32_t	cmap[256];
	u_int32_t	g3null;
	u_int32_t	unused1[32];
	u_int32_t	half_sync;
	u_int32_t	back_porch;
	u_int32_t	display;
	u_int32_t	short_display;
	u_int32_t	broad_pulse;
	u_int32_t	vsync;
	u_int32_t	vblank;
	u_int32_t	vdisplay;
	u_int32_t	line_time;
	u_int32_t	tos1;
	u_int32_t	mem_init;
	u_int32_t	transfer_delay;
	u_int32_t	unused2[19];
	u_int32_t	mask;
	u_int32_t	unused3[31];
	u_int32_t	cr;
	u_int32_t	unused4[31];
	u_int32_t	tos2;
	u_int32_t	unused5[31];
	u_int32_t	boot_location;
};

/*
 * G335 layout
 */

struct g335dac {
	u_int32_t	boot_location;
	u_int32_t	unused1[32];
	u_int32_t	half_sync;
	u_int32_t	back_porch;
	u_int32_t	display;
	u_int32_t	short_display;
	u_int32_t	broad_pulse;
	u_int32_t	vsync;
	u_int32_t	vpre_equalize;
	u_int32_t	vpost_equalize;
	u_int32_t	vblank;
	u_int32_t	vdisplay;
	u_int32_t	line_time;
	u_int32_t	tos1;
	u_int32_t	mem_init;
	u_int32_t	transfer_delay;
	u_int32_t	unused2[17];
	u_int32_t	mask;
	u_int32_t	unused3[31];
	u_int32_t	cra;
	u_int32_t	unused4[15];
	u_int32_t	crb;
	u_int32_t	unused5[15];
	u_int32_t	tos2;
	u_int32_t	unused6[32];
	u_int32_t	cursor_palette[3];
	u_int32_t	unused7[28];
	u_int32_t	checksum[3];
	u_int32_t	unused8[4];
	u_int32_t	cursor_position;
	u_int32_t	unused9[56];
	u_int32_t	cmap[256];
	u_int32_t	cursor_store[512];
};

union dac {
	struct g300dac	g300;
	struct g335dac	g335;
};

/*
 * SBUS register mappings
 */
#define	VIGRA_REG_RAMDAC	1	/* either G300 or G335 */
#define	VIGRA_REG_CSR		2
#define	VIGRA_REG_VRAM		3

#define	VIGRA_NREG		4

union vigracmap {
	u_char		cm_map[256][4];	/* 256 R/G/B entries plus pad */
	u_int32_t	cm_chip[256];	/* the way the chip gets loaded */
};

/* per-display variables */
struct vigra_softc {
	struct	sunfb sc_sunfb;		/* common base part */
	struct	rom_reg	sc_phys;	/* phys address description */
	volatile struct	csregs *sc_regs;/* control registers */
	volatile union dac *sc_ramdac;	/* ramdac registers */
	union	vigracmap sc_cmap;	/* current colormap */
	int	sc_g300;
	struct	intrhand sc_ih;
};

void	vigra_burner(void *, u_int, u_int);
int	vigra_getcmap(union vigracmap *, struct wsdisplay_cmap *, int);
int	vigra_intr(void *);
int	vigra_ioctl(void *, u_long, caddr_t, int, struct proc *);
static __inline__
void	vigra_loadcmap_deferred(struct vigra_softc *, u_int, u_int);
void	vigra_loadcmap_immediate(struct vigra_softc *, int, int);
paddr_t	vigra_mmap(void *, off_t, int);
int	vigra_putcmap(union vigracmap *, struct wsdisplay_cmap *, int);
void	vigra_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);

struct wsdisplay_accessops vigra_accessops = {
	.ioctl = vigra_ioctl,
	.mmap = vigra_mmap,
	.burn_screen = vigra_burner
};

int	vigramatch(struct device *, void *, void *);
void	vigraattach(struct device *, struct device *, void *);

struct cfattach vigra_ca = {
	sizeof (struct vigra_softc), vigramatch, vigraattach
};

struct cfdriver vigra_cd = {
	NULL, "vigra", DV_DULL
};

/*
 * Match a supported vigra card.
 */
int
vigramatch(struct device *parent, void *vcf, void *aux)
{
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

	if (strcmp("vs10", ra->ra_name) != 0 &&
	    strcmp("vs11", ra->ra_name) != 0 &&
	    strcmp("vs12", ra->ra_name) != 0)
		return (0);

	return (1);
}

/*
 * Attach and initialize a vigra display, as well as a child wsdisplay.
 */
void
vigraattach(struct device *parent, struct device *self, void *args)
{
	struct vigra_softc *sc = (struct vigra_softc *)self;
	struct confargs *ca = args;
	int node, pri, isconsole = 0;
	char *nam;

	pri = ca->ca_ra.ra_intr[0].int_pri;
	printf(" pri %d", pri);

	if (ca->ca_ra.ra_nreg < VIGRA_NREG) {
		printf("\n%s: expected %d registers, got %d",
		    self->dv_xname, VIGRA_NREG, ca->ca_ra.ra_nreg);
		return;
	}

	node = ca->ca_ra.ra_node;
	nam = getpropstring(node, "model");
	if (*nam == '\0')
		nam = (char *)ca->ca_ra.ra_name;
	printf(": %s", nam);

	isconsole = node == fbnode;

	/*
	 * Check whether we are using an G300 or an G335 chip.
	 * The VS10 and VS12 use the G300, while the VS11 uses a G335.
	 */
	sc->sc_g300 = strncmp(nam, "VIGRA,vs11", strlen("VIGRA,vs11"));

	sc->sc_regs = mapiodev(&ca->ca_ra.ra_reg[VIGRA_REG_CSR], 0,
	    ca->ca_ra.ra_reg[VIGRA_REG_CSR].rr_len);
	sc->sc_ramdac = mapiodev(&ca->ca_ra.ra_reg[VIGRA_REG_RAMDAC], 0,
	    ca->ca_ra.ra_reg[VIGRA_REG_RAMDAC].rr_len);
	sc->sc_phys = ca->ca_ra.ra_reg[VIGRA_REG_VRAM];

	sc->sc_ih.ih_fun = vigra_intr;
	sc->sc_ih.ih_arg = sc;
	intr_establish(pri, &sc->sc_ih, IPL_FB, self->dv_xname);

	/* enable video */
	vigra_burner(sc, 1, 0);

	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, ca->ca_bustype);
	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(&ca->ca_ra.ra_reg[VIGRA_REG_VRAM],
	    0, round_page(sc->sc_sunfb.sf_fbsize));
	sc->sc_sunfb.sf_ro.ri_hw = sc;

	printf(", %dx%d\n", sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);

	fbwscons_init(&sc->sc_sunfb, isconsole);
	fbwscons_setcolormap(&sc->sc_sunfb, vigra_setcolor);

	if (isconsole)
		fbwscons_console_init(&sc->sc_sunfb, -1);

	fbwscons_attach(&sc->sc_sunfb, &vigra_accessops, isconsole);
}

int
vigra_ioctl(void *v, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct vigra_softc *sc = v;
	struct wsdisplay_cmap *cm;
	struct wsdisplay_fbinfo *wdf;
	int error;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
		break;
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
		wdf->cmsize = 256;
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
		break;

	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = vigra_getcmap(&sc->sc_cmap, cm, sc->sc_g300);
		if (error)
			return (error);
		break;
	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = vigra_putcmap(&sc->sc_cmap, cm, sc->sc_g300);
		if (error)
			return (error);
		vigra_loadcmap_deferred(sc, cm->index, cm->count);
		break;

	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
		break;

	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
	default:
		return (-1);	/* not supported yet */
        }

	return (0);
}

paddr_t
vigra_mmap(void *v, off_t offset, int prot)
{
	struct vigra_softc *sc = v;

	if (offset & PGOFSET)
		return (-1);

	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys, offset) | PMAP_NC);
	}

	return (-1);
}

void
vigra_setcolor(void *v, u_int index, u_int8_t r, u_int8_t g, u_int8_t b)
{
	struct vigra_softc *sc = v;

	if (sc->sc_g300) {
		sc->sc_cmap.cm_map[index][3] = r;
		sc->sc_cmap.cm_map[index][2] = g;
		sc->sc_cmap.cm_map[index][1] = b;
	} else {
		sc->sc_cmap.cm_map[index][3] = b;
		sc->sc_cmap.cm_map[index][2] = g;
		sc->sc_cmap.cm_map[index][1] = r;
	}
	sc->sc_cmap.cm_map[index][0] = 0;	/* no alpha channel */

	vigra_loadcmap_immediate(sc, index, 1);
}

int
vigra_getcmap(union vigracmap *cm, struct wsdisplay_cmap *rcm, int g300)
{
	u_int index = rcm->index, count = rcm->count, i;
	int error;

	if (index >= 256 || count > 256 - index)
		return (EINVAL);

	if (g300) {
		for (i = 0; i < count; i++) {
			if ((error = copyout(&cm->cm_map[index + i][3],
			    &rcm->red[i], 1)) != 0)
				return (error);
			if ((error = copyout(&cm->cm_map[index + i][1],
			    &rcm->blue[i], 1)) != 0)
				return (error);
		}
	} else {
		for (i = 0; i < count; i++) {
			if ((error = copyout(&cm->cm_map[index + i][1],
			    &rcm->red[i], 1)) != 0)
				return (error);
			if ((error = copyout(&cm->cm_map[index + i][3],
			    &rcm->blue[i], 1)) != 0)
				return (error);
		}
	}

	for (i = 0; i < count; i++) {
		if ((error = copyout(&cm->cm_map[index + i][2],
		    &rcm->green[i], 1)) != 0)
			return (error);
	}
	return (0);
}

int
vigra_putcmap(union vigracmap *cm, struct wsdisplay_cmap *rcm, int g300)
{
	u_int index = rcm->index, count = rcm->count, i;
	int error;

	if (index >= 256 || count > 256 - index)
		return (EINVAL);

	if (g300) {
		for (i = 0; i < count; i++) {
			if ((error = copyin(&rcm->red[i],
			    &cm->cm_map[index + i][3], 1)) != 0)
				return (error);
			if ((error = copyin(&rcm->blue[i],
			    &cm->cm_map[index + i][1], 1)) != 0)
				return (error);
		}
	} else {
		for (i = 0; i < count; i++) {
			if ((error = copyin(&rcm->red[i],
			    &cm->cm_map[index + i][1], 1)) != 0)
				return (error);
			if ((error = copyin(&rcm->blue[i],
			    &cm->cm_map[index + i][3], 1)) != 0)
				return (error);
		}
	}

	for (i = 0; i < count; i++) {
		if ((error = copyin(&rcm->green[i],
		    &cm->cm_map[index + i][2], 1)) != 0)
			return (error);
		cm->cm_map[index + i][0] = 0;	/* no alpha channel */
	}
	return (0);
}

void
vigra_loadcmap_immediate(struct vigra_softc *sc, int start, int ncolors)
{
	u_int32_t *colp = &sc->sc_cmap.cm_chip[start];
	volatile u_int32_t *lutp;
       
	if (sc->sc_g300)
		lutp = &(sc->sc_ramdac->g300.cmap[start]);
	else
		lutp = &(sc->sc_ramdac->g335.cmap[start]);

	while (--ncolors >= 0)
		*lutp++ = *colp++;
}

static __inline__ void
vigra_loadcmap_deferred(struct vigra_softc *sc, u_int start, u_int ncolors)
{

	sc->sc_regs->imr = 1;
}

void
vigra_burner(void *v, u_int on, u_int flags)
{
	struct vigra_softc *sc = v;

	if (on) {
		sc->sc_regs->bcr = 0;
	} else {
		sc->sc_regs->bcr = 1;
	}
}

int
vigra_intr(void *v)
{
	struct vigra_softc *sc = v;

	if (sc->sc_regs->imr == 0 ||
	    !ISSET(sc->sc_regs->g3sr, STATUS_INTR)) {
		/* Not expecting an interrupt, it's not for us. */
		return (0);
	}

	/* Acknowledge the interrupt and disable it. */
	sc->sc_regs->imr = 0;

	vigra_loadcmap_immediate(sc, 0, 256);

	return (1);
}
@


1.20
log
@Don't include sbusvar.h if you need neither sbus_translate() nor sbus_testdma().
@
text
@d1 1
a1 1
/*	$OpenBSD: vigra.c,v 1.19 2013/10/20 20:07:26 miod Exp $	*/
@


1.19
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vigra.c,v 1.18 2008/12/26 22:30:21 miod Exp $	*/
a59 2

#include <sparc/dev/sbusvar.h>
@


1.18
log
@Move the logic responsible from deciding whether a frame buffer needs to be
cleared on attach, from the individual drivers to the common frame buffer code;
the latter will decide based on the prom font metrics and the prom console
window position, whenever possible.

This removes the need for the console window position to be hardcoded in
the p9100 driver, and will no longer require a screen clear on a vigra
VS-12 in high resolution mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: vigra.c,v 1.17 2007/02/18 18:40:35 miod Exp $	*/
d196 3
a198 10
	vigra_ioctl,
	vigra_mmap,
	NULL,	/* alloc_screen */
	NULL,	/* free_screen */
	NULL,	/* show_screen */
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	vigra_burner,
	NULL	/* pollc */
@


1.17
log
@Display the interrupt priority in dmesg, for frame buffers which register
interrupt handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: vigra.c,v 1.16 2006/06/02 20:00:54 miod Exp $	*/
d244 1
a244 1
	int node, pri, row, isconsole = 0;
d290 1
a290 17
	/*
	 * If the framebuffer width is under 1024x768, we will switch from the
	 * PROM font to the more adequate 8x16 font here.
	 * However, we need to adjust two things in this case:
	 * - the display row should be overrided from the current PROM metrics,
	 *   to prevent us from overwriting the last few lines of text.
	 * - if the 80x34 screen would make a large margin appear around it,
	 *   choose to clear the screen rather than keeping old prom output in
	 *   the margins.
	 * XXX there should be a rasops "clear margins" feature
	 *
	 * Also, in 1280x1024 resolution, the PROM display is not centered
	 * vertically (why? no other frame buffer does this in such a mode!),
	 * so be lazy and clear the screen here too anyways...
	 */
	fbwscons_init(&sc->sc_sunfb, isconsole && (sc->sc_sunfb.sf_width != 800
	    && sc->sc_sunfb.sf_width != 1280) ? 0 : RI_CLEAR);
d293 2
a294 16
	if (isconsole) {
		switch (sc->sc_sunfb.sf_width) {
		case 640:
			row = sc->sc_sunfb.sf_ro.ri_rows - 1;
			break;
		case 800:
		case 1280:
			row = 0;	/* screen has been cleared above */
			break;
		default:
			row = -1;
			break;
		}

		fbwscons_console_init(&sc->sc_sunfb, row);
	}
@


1.16
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: vigra.c,v 1.15 2005/03/23 17:16:34 miod Exp $	*/
d244 1
a244 1
	int node, row, isconsole = 0;
d247 9
a263 6
	if (ca->ca_ra.ra_nreg < VIGRA_NREG) {
		printf("\n%s: expected %d registers, got %d",
		    self->dv_xname, VIGRA_NREG, ca->ca_ra.ra_nreg);
		return;
	}

d278 1
a278 2
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih, IPL_FB,
	    self->dv_xname);
@


1.15
log
@Move the alloc_screen, free_screen and show_screen wsdisplay accessops to
the common frame buffer code, rather than duplicating it in every driver.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vigra.c,v 1.14 2005/03/07 16:44:50 miod Exp $	*/
a175 1
	struct	sbusdev sc_sd;		/* sbus device */
a322 2

	sbus_establish(&sc->sc_sd, &sc->sc_sunfb.sf_dev);
@


1.14
log
@Do not bother passing the blanking routine to fbwscons_console_init(),
as fbwscons_attach() can find it on its own.
@
text
@d1 1
a1 1
/*	$OpenBSD: vigra.c,v 1.13 2005/03/03 09:49:05 miod Exp $	*/
a57 1
#include <dev/wscons/wscons_raster.h>
a182 1
	int	sc_nscreens;
d185 10
a194 15
int vigra_ioctl(void *, u_long, caddr_t, int, struct proc *);
int vigra_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void vigra_free_screen(void *, void *);
int vigra_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t vigra_mmap(void *, off_t, int);
void vigra_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
int vigra_getcmap(union vigracmap *, struct wsdisplay_cmap *, int);
int vigra_putcmap(union vigracmap *, struct wsdisplay_cmap *, int);
void vigra_loadcmap_immediate(struct vigra_softc *, int, int);
static __inline__ void vigra_loadcmap_deferred(struct vigra_softc *,
    u_int, u_int);
void vigra_burner(void *, u_int, u_int);
int vigra_intr(void *);
d199 3
a201 3
	vigra_alloc_screen,
	vigra_free_screen,
	vigra_show_screen,
d206 1
a382 37
int
vigra_alloc_screen(void *v, const struct wsscreen_descr *type, void **cookiep,
    int *curxp, int *curyp, long *attrp)
{
	struct vigra_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	sc->sc_nscreens++;
	return (0);
}

void
vigra_free_screen(void *v, void *cookie)
{
	struct vigra_softc *sc = v;

	sc->sc_nscreens--;
}

int
vigra_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
{
	return (0);
}

/*
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
 */
@


1.13
log
@Sync a few comments with reality.
@
text
@d1 1
a1 1
/*	$OpenBSD: vigra.c,v 1.12 2005/01/05 23:04:25 miod Exp $	*/
d328 1
a328 1
		fbwscons_console_init(&sc->sc_sunfb, row, vigra_burner);
@


1.12
log
@Let wsdisplay drivers return zero for WSDISPLAYIO_[GS]VIDEO ioctls - most
of the work is done in the upper layer, but they get to see the ioctl,
so don't always return an error.
@
text
@d1 1
a1 1
/*	$OpenBSD: vigra.c,v 1.11 2004/11/29 22:07:37 miod Exp $	*/
d33 2
a34 2
 * The VS10, VS11 and VS12 models are supported. VS10-EK should also work
 * (but it might be driven by the regular cgthree driver?)
@


1.11
log
@Move the struct wsscreen_descr from a per-driver global to a per-instance
field of the sunfb structure. This allows multiple instances of the same driver,
but with different resolutions (such as a couple of vigra or a TGX cgsix and
a TGX+ cgsix) to use distinct wsscreen_descr structures featuring different
resolution information.

Doing this allows more wsscreen_descr fiddling inside the sparc* fb api,
and results in some code shrinkage (about 4KB on sparc GENERIC).
@
text
@d1 1
a1 1
/*	$OpenBSD: vigra.c,v 1.10 2004/09/29 07:35:11 miod Exp $	*/
d375 2
@


1.10
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vigra.c,v 1.9 2003/06/28 17:05:33 miod Exp $	*/
a186 13
struct wsscreen_descr vigra_stdscreen = {
	"std",
};

const struct wsscreen_descr *vigra_scrlist[] = {
	&vigra_stdscreen,
};

struct wsscreen_list vigra_screenlist = {
	sizeof(vigra_scrlist) / sizeof(struct wsscreen_descr *),
	    vigra_scrlist
};

a250 1
	struct wsemuldisplaydev_attach_args waa;
a313 5
	vigra_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	vigra_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	vigra_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	vigra_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

d317 1
a317 1
			row = vigra_stdscreen.nrows - 1;
d328 1
a328 2
		fbwscons_console_init(&sc->sc_sunfb, &vigra_stdscreen, row,
		    vigra_burner);
d333 1
a333 5
	waa.console = isconsole;
	waa.scrdata = &vigra_screenlist;
	waa.accessops = &vigra_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
@


1.9
log
@Sync sparc fb API with the sparc64 changes (fbwscons_init takes flags, and
the sunfb structure keeps pointer to the prom cursor coordinates).
@
text
@d1 1
a1 1
/*	$OpenBSD: vigra.c,v 1.8 2003/06/06 19:42:47 miod Exp $	*/
d296 2
a297 1
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih, IPL_FB);
@


1.8
log
@Do not bother taking care of the frame buffer flags in the softc, if the
driver does not use any. Basically this changes all drivers but those that
can handle a P4 card.
@
text
@d1 1
a1 1
/*	$OpenBSD: vigra.c,v 1.7 2003/05/25 21:43:09 miod Exp $	*/
d323 2
a324 2
	fbwscons_init(&sc->sc_sunfb, isconsole &&
	    (sc->sc_sunfb.sf_width != 800 && sc->sc_sunfb.sf_width != 1280));
@


1.7
log
@Support for the Vigra VS11 frame buffer. This is basically the same as the
VS12, but with a different ramdac that allows higher refresh rates.
@
text
@d1 1
a1 1
/*	$OpenBSD: vigra.c,v 1.6 2003/04/06 16:59:33 miod Exp $	*/
a244 1
	struct cfdata *cf = vcf;
a247 5
	/*
	 * Mask out invalid flags from the user.
	 */
	cf->cf_flags &= FB_USERMASK;

a266 2

	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;
@


1.6
log
@When encountering an older or unexpected model this driver can not handle,
return early in attach() rather than panic.
@
text
@d1 1
a1 1
/*	$OpenBSD: vigra.c,v 1.5 2002/11/06 21:06:20 miod Exp $	*/
d4 2
a5 1
 * Copyright (c) 2002 Miodrag Vallat.  All rights reserved.
d33 2
a34 4
 * The VS10 and VS12 models are supported. VS10-EK should also work.
 *
 * The VS11 uses an INMOS G335 dac instead of the G300 found in VS10/12, and
 * should be relatively easy to support once the dac diffs are sorted out.
d65 22
a86 1
 * INMOS G300 registers (very incomplete...)
d89 69
a157 10
struct g300regs {
	u_int32_t	unknown00;
	u_int32_t	unknown04;
	u_int32_t	disable;
	u_int32_t	unknown0c;
	u_int32_t	status;
#define	G300S_INTR	0x0001
	u_int32_t	intr;
	u_int32_t	unknown18;
	u_int32_t	unknown1c;
d163 3
a165 3
#define	VIGRA_REG_CMAP	1
#define	VIGRA_REG_G300	2
#define	VIGRA_REG_VRAM	3
d167 1
a167 1
#define	VIGRA_NREG	4
d179 2
a180 2
	volatile struct	g300regs *sc_regs;	/* ramdac registers */
	volatile u_int32_t *sc_physcmap;	/* ramdac palette */
d182 1
d208 2
a209 2
int vigra_getcmap(union vigracmap *, struct wsdisplay_cmap *);
int vigra_putcmap(union vigracmap *, struct wsdisplay_cmap *);
d240 1
a240 1
 * Match a vigra.
d243 1
a243 3
vigramatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
d254 3
a256 4
	if (strcmp("vs10", ra->ra_name) && strcmp("vs12", ra->ra_name))
		return (0);

	if (ca->ca_bustype != BUS_SBUS)
d263 1
a263 1
 * Attach a display.
d266 1
a266 3
vigraattach(parent, self, args)
	struct device *parent, *self;
	void *args;
d290 10
a299 4
	sc->sc_regs = mapiodev(&ca->ca_ra.ra_reg[VIGRA_REG_G300], 0,
	    sizeof(*sc->sc_regs));
	sc->sc_physcmap = mapiodev(&ca->ca_ra.ra_reg[VIGRA_REG_CMAP], 0,
	    256 * sizeof(u_int32_t));
d326 4
d331 2
a332 2
	fbwscons_init(&sc->sc_sunfb,
	    isconsole && (sc->sc_sunfb.sf_width != 800));
d346 1
d368 1
a368 6
vigra_ioctl(v, cmd, data, flags, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
d392 1
a392 1
		error = vigra_getcmap(&sc->sc_cmap, cm);
d398 1
a398 1
		error = vigra_putcmap(&sc->sc_cmap, cm);
d419 2
a420 6
vigra_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
d437 1
a437 3
vigra_free_screen(v, cookie)
	void *v;
	void *cookie;
d445 2
a446 6
vigra_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
d456 1
a456 4
vigra_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
d471 1
a471 4
vigra_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
	u_int8_t r, g, b;
d475 9
a483 3
	sc->sc_cmap.cm_map[index][3] = r;
	sc->sc_cmap.cm_map[index][2] = g;
	sc->sc_cmap.cm_map[index][1] = b;
d490 1
a490 3
vigra_getcmap(cm, rcm)
	union vigracmap *cm;
	struct wsdisplay_cmap *rcm;
d498 20
a518 3
		if ((error = copyout(&cm->cm_map[index + i][3],
		    &rcm->red[i], 1)) != 0)
			return (error);
a521 3
		if ((error = copyout(&cm->cm_map[index + i][1],
		    &rcm->blue[i], 1)) != 0)
			return (error);
d527 1
a527 3
vigra_putcmap(cm, rcm)
	union vigracmap *cm;
	struct wsdisplay_cmap *rcm;
d535 20
a555 3
		if ((error = copyin(&rcm->red[i],
		    &cm->cm_map[index + i][3], 1)) != 0)
			return (error);
a558 3
		if ((error = copyin(&rcm->blue[i],
		    &cm->cm_map[index + i][1], 1)) != 0)
			return (error);
d565 1
a565 3
vigra_loadcmap_immediate(sc, start, ncolors)
	struct vigra_softc *sc;
	int start, ncolors;
d568 6
a573 1
	volatile u_int32_t *lutp = &sc->sc_physcmap[start];
d583 1
a583 1
	sc->sc_regs->intr = 1;
d587 1
a587 3
vigra_burner(v, on, flags)
	void *v;
	u_int on, flags;
d592 1
a592 1
		sc->sc_regs->disable = 0;
d594 1
a594 1
		sc->sc_regs->disable = 1;
d599 1
a599 2
vigra_intr(v)
	void *v;
d603 2
a604 2
	if (sc->sc_regs->intr == 0 ||
	    !ISSET(sc->sc_regs->status, G300S_INTR)) {
d610 1
a610 1
	sc->sc_regs->intr = 0;
@


1.5
log
@- always initialize colormaps, even if the frame buffer is non console; this
  helps if the ramdac does not get initialized (idea from jason@@)
- only register a shutdown hook for the frame buffers which need it, if this
  is the console frame buffer. Otherwise this is just a waste of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vigra.c,v 1.4 2002/10/12 01:09:43 krw Exp $	*/
d209 5
a213 3
	if (ca->ca_ra.ra_nreg < VIGRA_NREG)
		panic("expected %d registers, got %d",
		    VIGRA_NREG, ca->ca_ra.ra_nreg);
@


1.5.4.1
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: vigra.c,v 1.5 2002/11/06 21:06:20 miod Exp $	*/
d209 3
a211 5
	if (ca->ca_ra.ra_nreg < VIGRA_NREG) {
		printf("\n%s: expected %d registers, got %d",
		    self->dv_xname, VIGRA_NREG, ca->ca_ra.ra_nreg);
		return;
	}
@


1.5.4.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vigra.c,v 1.5.4.1 2003/05/13 19:41:08 ho Exp $	*/
d4 1
a4 2
 * Copyright (c) 2002, 2003, Miodrag Vallat.
 * All rights reserved.
d32 4
a35 2
 * The VS10, VS11 and VS12 models are supported. VS10-EK should also work
 * (but it might be driven by the regular cgthree driver?)
d66 1
a66 6
 * The hardware information below has been gathered through experiments, as
 * well as the debug information of the SunOS 4.x vigfb driver.
 */

/*
 * Control and status registers
d69 10
a78 85
struct csregs {
	u_int32_t	sosr;
	u_int32_t	g3rr;
	u_int32_t	bcr;	/* board control register */
	u_int32_t	spr;
	u_int32_t	g3sr;	/* ramdac status register */
#define	STATUS_INTR	0x0001
	u_int32_t	imr;	/* interrupt mode register */
	u_int32_t	ewcr;
	u_int32_t	ssr;
};

/*
 * G300 layout
 */

struct g300dac {
	u_int32_t	cmap[256];
	u_int32_t	g3null;
	u_int32_t	unused1[32];
	u_int32_t	half_sync;
	u_int32_t	back_porch;
	u_int32_t	display;
	u_int32_t	short_display;
	u_int32_t	broad_pulse;
	u_int32_t	vsync;
	u_int32_t	vblank;
	u_int32_t	vdisplay;
	u_int32_t	line_time;
	u_int32_t	tos1;
	u_int32_t	mem_init;
	u_int32_t	transfer_delay;
	u_int32_t	unused2[19];
	u_int32_t	mask;
	u_int32_t	unused3[31];
	u_int32_t	cr;
	u_int32_t	unused4[31];
	u_int32_t	tos2;
	u_int32_t	unused5[31];
	u_int32_t	boot_location;
};

/*
 * G335 layout
 */

struct g335dac {
	u_int32_t	boot_location;
	u_int32_t	unused1[32];
	u_int32_t	half_sync;
	u_int32_t	back_porch;
	u_int32_t	display;
	u_int32_t	short_display;
	u_int32_t	broad_pulse;
	u_int32_t	vsync;
	u_int32_t	vpre_equalize;
	u_int32_t	vpost_equalize;
	u_int32_t	vblank;
	u_int32_t	vdisplay;
	u_int32_t	line_time;
	u_int32_t	tos1;
	u_int32_t	mem_init;
	u_int32_t	transfer_delay;
	u_int32_t	unused2[17];
	u_int32_t	mask;
	u_int32_t	unused3[31];
	u_int32_t	cra;
	u_int32_t	unused4[15];
	u_int32_t	crb;
	u_int32_t	unused5[15];
	u_int32_t	tos2;
	u_int32_t	unused6[32];
	u_int32_t	cursor_palette[3];
	u_int32_t	unused7[28];
	u_int32_t	checksum[3];
	u_int32_t	unused8[4];
	u_int32_t	cursor_position;
	u_int32_t	unused9[56];
	u_int32_t	cmap[256];
	u_int32_t	cursor_store[512];
};

union dac {
	struct g300dac	g300;
	struct g335dac	g335;
d84 3
a86 3
#define	VIGRA_REG_RAMDAC	1	/* either G300 or G335 */
#define	VIGRA_REG_CSR		2
#define	VIGRA_REG_VRAM		3
d88 1
a88 1
#define	VIGRA_NREG		4
d100 2
a101 2
	volatile struct	csregs *sc_regs;/* control registers */
	volatile union dac *sc_ramdac;	/* ramdac registers */
a102 1
	int	sc_g300;
d128 2
a129 2
int vigra_getcmap(union vigracmap *, struct wsdisplay_cmap *, int);
int vigra_putcmap(union vigracmap *, struct wsdisplay_cmap *, int);
d160 1
a160 1
 * Match a supported vigra card.
d163 3
a165 1
vigramatch(struct device *parent, void *vcf, void *aux)
d167 1
d171 9
a179 3
	if (strcmp("vs10", ra->ra_name) != 0 &&
	    strcmp("vs11", ra->ra_name) != 0 &&
	    strcmp("vs12", ra->ra_name) != 0)
d186 1
a186 1
 * Attach and initialize a vigra display, as well as a child wsdisplay.
d189 3
a191 1
vigraattach(struct device *parent, struct device *self, void *args)
d199 2
d215 4
a218 10
	/*
	 * Check whether we are using an G300 or an G335 chip.
	 * The VS10 and VS12 use the G300, while the VS11 uses a G335.
	 */
	sc->sc_g300 = strncmp(nam, "VIGRA,vs11", strlen("VIGRA,vs11"));

	sc->sc_regs = mapiodev(&ca->ca_ra.ra_reg[VIGRA_REG_CSR], 0,
	    ca->ca_ra.ra_reg[VIGRA_REG_CSR].rr_len);
	sc->sc_ramdac = mapiodev(&ca->ca_ra.ra_reg[VIGRA_REG_RAMDAC], 0,
	    ca->ca_ra.ra_reg[VIGRA_REG_RAMDAC].rr_len);
a244 4
	 *
	 * Also, in 1280x1024 resolution, the PROM display is not centered
	 * vertically (why? no other frame buffer does this in such a mode!),
	 * so be lazy and clear the screen here too anyways...
d246 2
a247 2
	fbwscons_init(&sc->sc_sunfb, isconsole &&
	    (sc->sc_sunfb.sf_width != 800 && sc->sc_sunfb.sf_width != 1280));
a260 1
		case 1280:
d282 6
a287 1
vigra_ioctl(void *v, u_long cmd, caddr_t data, int flags, struct proc *p)
d311 1
a311 1
		error = vigra_getcmap(&sc->sc_cmap, cm, sc->sc_g300);
d317 1
a317 1
		error = vigra_putcmap(&sc->sc_cmap, cm, sc->sc_g300);
d338 6
a343 2
vigra_alloc_screen(void *v, const struct wsscreen_descr *type, void **cookiep,
    int *curxp, int *curyp, long *attrp)
d360 3
a362 1
vigra_free_screen(void *v, void *cookie)
d370 6
a375 2
vigra_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
d385 4
a388 1
vigra_mmap(void *v, off_t offset, int prot)
d403 4
a406 1
vigra_setcolor(void *v, u_int index, u_int8_t r, u_int8_t g, u_int8_t b)
d410 3
a412 9
	if (sc->sc_g300) {
		sc->sc_cmap.cm_map[index][3] = r;
		sc->sc_cmap.cm_map[index][2] = g;
		sc->sc_cmap.cm_map[index][1] = b;
	} else {
		sc->sc_cmap.cm_map[index][3] = b;
		sc->sc_cmap.cm_map[index][2] = g;
		sc->sc_cmap.cm_map[index][1] = r;
	}
d419 3
a421 1
vigra_getcmap(union vigracmap *cm, struct wsdisplay_cmap *rcm, int g300)
a428 20
	if (g300) {
		for (i = 0; i < count; i++) {
			if ((error = copyout(&cm->cm_map[index + i][3],
			    &rcm->red[i], 1)) != 0)
				return (error);
			if ((error = copyout(&cm->cm_map[index + i][1],
			    &rcm->blue[i], 1)) != 0)
				return (error);
		}
	} else {
		for (i = 0; i < count; i++) {
			if ((error = copyout(&cm->cm_map[index + i][1],
			    &rcm->red[i], 1)) != 0)
				return (error);
			if ((error = copyout(&cm->cm_map[index + i][3],
			    &rcm->blue[i], 1)) != 0)
				return (error);
		}
	}

d430 3
d436 3
d444 3
a446 1
vigra_putcmap(union vigracmap *cm, struct wsdisplay_cmap *rcm, int g300)
a453 20
	if (g300) {
		for (i = 0; i < count; i++) {
			if ((error = copyin(&rcm->red[i],
			    &cm->cm_map[index + i][3], 1)) != 0)
				return (error);
			if ((error = copyin(&rcm->blue[i],
			    &cm->cm_map[index + i][1], 1)) != 0)
				return (error);
		}
	} else {
		for (i = 0; i < count; i++) {
			if ((error = copyin(&rcm->red[i],
			    &cm->cm_map[index + i][1], 1)) != 0)
				return (error);
			if ((error = copyin(&rcm->blue[i],
			    &cm->cm_map[index + i][3], 1)) != 0)
				return (error);
		}
	}

d455 3
d461 3
d470 3
a472 1
vigra_loadcmap_immediate(struct vigra_softc *sc, int start, int ncolors)
d475 1
a475 6
	volatile u_int32_t *lutp;
       
	if (sc->sc_g300)
		lutp = &(sc->sc_ramdac->g300.cmap[start]);
	else
		lutp = &(sc->sc_ramdac->g335.cmap[start]);
d485 1
a485 1
	sc->sc_regs->imr = 1;
d489 3
a491 1
vigra_burner(void *v, u_int on, u_int flags)
d496 1
a496 1
		sc->sc_regs->bcr = 0;
d498 1
a498 1
		sc->sc_regs->bcr = 1;
d503 2
a504 1
vigra_intr(void *v)
d508 2
a509 2
	if (sc->sc_regs->imr == 0 ||
	    !ISSET(sc->sc_regs->g3sr, STATUS_INTR)) {
d515 1
a515 1
	sc->sc_regs->imr = 0;
@


1.5.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d323 2
a324 2
	fbwscons_init(&sc->sc_sunfb, isconsole && (sc->sc_sunfb.sf_width != 800
	    && sc->sc_sunfb.sf_width != 1280) ? 0 : RI_CLEAR);
@


1.4
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: vigra.c,v 1.3 2002/09/23 18:13:39 miod Exp $	*/
d246 1
d267 1
a267 1
		    vigra_setcolor, vigra_burner);
@


1.4.2.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.4.2.2
log
@sync
@
text
@d209 3
a211 5
	if (ca->ca_ra.ra_nreg < VIGRA_NREG) {
		printf("\n%s: expected %d registers, got %d",
		    self->dv_xname, VIGRA_NREG, ca->ca_ra.ra_nreg);
		return;
	}
a245 1
	fbwscons_setcolormap(&sc->sc_sunfb, vigra_setcolor);
d266 1
a266 1
		    vigra_burner);
@


1.3
log
@Get the wsdisplay capabilities from rasops, rather than attempting to
guess them at compile-time. Plus this makes cgtwelve a bit more clean.

ok fgs@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vigra.c,v 1.2 2002/09/09 22:15:16 miod Exp $	*/
d210 1
a210 1
		panic("\nexpected %d registers, got %d",
@


1.2
log
@Register more screen capabilities to work with the recent wsemul_sun changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vigra.c,v 1.1 2002/08/31 10:47:20 miod Exp $	*/
a108 5
	0, 0,	/* will be filled in */
	0,
	0, 0,
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
	WSSCREEN_REVERSE | WSSCREEN_WSCOLORS
d247 1
@


1.1
log
@Driver for the Vigra VS10 and VS12 SBus framebuffers, and possibly more from
this series.
Thanks to Andrey Smagin (andrey at smagin dot com) for providing a VS10 card.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d112 1
@

