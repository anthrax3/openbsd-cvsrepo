head	1.37;
access;
symbols
	OPENBSD_6_0:1.36.0.8
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.4
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.36.0.6
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.35.0.20
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.35.0.18
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.35.0.14
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.35.0.12
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.10
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.8
	OPENBSD_5_0:1.35.0.6
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.4
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.2
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.32.0.4
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.6
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.2
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.30.0.2
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.29.0.2
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.27.0.2
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.25.0.2
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.21.0.8
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.6
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.4
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.19.0.4
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.18.0.4
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.18
	UBC:1.14.0.8
	UBC_BASE:1.14
	OPENBSD_3_0:1.14.0.6
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.4
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.13.0.6
	OPENBSD_2_7_BASE:1.13
	SMP:1.13.0.4
	SMP_BASE:1.13
	kame_19991208:1.13
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.11.0.6
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.11.0.4
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2016.09.01.09.23.42;	author tedu;	state dead;
branches;
next	1.36;
commitid	Q2PxaFNhqAe0Wmla;

1.36
date	2015.01.12.21.34.15;	author miod;	state Exp;
branches;
next	1.35;
commitid	MHu755Csz0mp9eEX;

1.35
date	2010.06.28.18.31.01;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2010.06.27.05.52.01;	author beck;	state Exp;
branches;
next	1.33;

1.33
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.32;

1.32
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2009.01.04.16.51.44;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2008.06.26.05.42.13;	author ray;	state Exp;
branches;
next	1.29;

1.29
date	2007.12.29.03.04.19;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2007.11.27.16.22.13;	author martynas;	state Exp;
branches;
next	1.27;

1.27
date	2007.07.01.19.05.37;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.09.14.21.44;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2006.12.13.21.12.58;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2006.12.10.16.15.03;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2006.12.10.16.14.22;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2004.11.29.06.20.02;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2004.09.29.07.35.11;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2003.11.14.19.05.36;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2002.10.12.01.09.43;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2002.04.30.01.12.29;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.03.15.59;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.43;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2000.09.21.17.45.12;	author mickey;	state Exp;
branches
	1.14.8.1;
next	1.13;

1.13
date	99.07.09.21.34.45;	author art;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	99.01.11.05.11.56;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.09.17.06.47.11;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	97.08.08.08.25.29;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	97.05.07.01.04.15;	author gene;	state Exp;
branches;
next	1.8;

1.8
date	96.11.23.21.46.19;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	96.08.11.05.34.29;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.01.12.20.20.50;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.01.05.13.36.48;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.01.04.01.31.44;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.15.13.56.26;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.18.01.06.12;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.40;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.40;	author deraadt;	state Exp;
branches;
next	;

1.13.4.1
date	2001.05.14.21.37.09;	author niklas;	state Exp;
branches;
next	1.13.4.2;

1.13.4.2
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.13.4.3;

1.13.4.3
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.13.4.4;

1.13.4.4
date	2004.02.19.10.49.58;	author niklas;	state Exp;
branches;
next	;

1.14.8.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	1.14.8.2;

1.14.8.2
date	2002.10.29.00.28.09;	author art;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: si.c,v 1.36 2015/01/12 21:34:15 miod Exp $	*/
/*	$NetBSD: si.c,v 1.38 1997/08/27 11:24:20 bouyer Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Adam Glass, David Jones, Gordon W. Ross, and Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This file contains only the machine-dependent parts of the
 * Sun4 SCSI driver.  (Autoconfig stuff and DMA functions.)
 * The machine-independent parts are in ncr5380sbc.c
 *
 * Supported hardware includes:
 * Sun "SCSI Weird" on OBIO (sw: Sun 4/100-series)
 * Sun SCSI-3 on VME (si: Sun 4/200-series, others)
 *
 * The VME variant has a bit to enable or disable the DMA engine,
 * but that bit also gates the interrupt line from the NCR5380!
 * Therefore, in order to get any interrupt from the 5380, (i.e.
 * for reselect) one must clear the DMA engine transfer count and
 * then enable DMA.  This has the further complication that you
 * CAN NOT touch the NCR5380 while the DMA enable bit is set, so
 * we have to turn DMA back off before we even look at the 5380.
 *
 * What wonderfully whacky hardware this is!
 *
 * David Jones wrote the initial version of this module for NetBSD/sun3,
 * which included support for the VME adapter only. (no reselection).
 *
 * Gordon Ross added support for the Sun 3 OBIO adapter, and re-worked
 * both the VME and OBIO code to support disconnect/reselect.
 * (Required figuring out the hardware "features" noted above.)
 *
 * The autoconfiguration boilerplate came from Adam Glass.
 *
 * Jason R. Thorpe ported the autoconfiguration and VME portions to
 * NetBSD/sparc, and added initial support for the 4/100 "SCSI Weird",
 * a wacky OBIO variant of the VME SCSI-3.  Many thanks to Chuck Cranor
 * for lots of helpful tips and suggestions.  Thanks also to Paul Kranenburg
 * and Chris Torek for bits of insight needed along the way.  Thanks to
 * David Gilbert and Andrew Gillham who risked filesystem life-and-limb
 * for the sake of testing.  Andrew Gillham helped work out the bugs
 * in the 4/100 DMA code.
 */

/*
 * NOTE: support for the 4/100 "SCSI Weird" is not complete!  DMA
 * works, but interrupts (and, thus, reselection) don't.  I don't know
 * why, and I don't have a machine to test this on further.
 *
 * DMA, DMA completion interrupts, and reselection work fine on my
 * 4/260 with modern SCSI-II disks attached.  I've had reports of
 * reselection failing on Sun Shoebox-type configurations where
 * there are multiple non-SCSI devices behind Emulex or Adaptec
 * bridges.  These devices pre-date the SCSI-I spec, and might not
 * behave the way the 5380 code expects.  For this reason, only
 * DMA is enabled by default in this driver.
 *
 *	Jason R. Thorpe <thorpej@@NetBSD.ORG>
 *	December 8, 1995
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/buf.h>
#include <sys/proc.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_debug.h>
#include <scsi/scsiconf.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/pmap.h>

#include <sparc/sparc/vaddrs.h>
#include <sparc/sparc/cpuvar.h>

#define COUNT_SW_LEFTOVERS	XXX	/* See sw DMA completion code */

#include <dev/ic/ncr5380reg.h>
#include <dev/ic/ncr5380var.h>

#include <sparc/dev/sireg.h>

/*
 * Transfers smaller than this are done using PIO
 * (on assumption they're not worth DMA overhead)
 */
#define	MIN_DMA_LEN 128

/*
 * Transfers larger than 65535 bytes need to be split-up.
 * (Some of the FIFO logic has only 16 bits counters.)
 * Make the size an integer multiple of the page size
 * to avoid buf/cluster remap problems.  (paranoid?)
 */
#define	MAX_DMA_LEN 0xE000

#ifdef	DEBUG
int si_debug = 0;
static int si_link_flags = 0 /* | SDEV_DB2 */ ;
#endif

/*
 * This structure is used to keep track of mapped DMA requests.
 */
struct si_dma_handle {
	int 		dh_flags;
#define	SIDH_BUSY	0x01		/* This DH is in use */
#define	SIDH_OUT	0x02		/* DMA does data out (write) */
	u_char *	dh_addr;	/* KVA of start of buffer */
	int 		dh_maplen;	/* Original data length */
	long		dh_dvma;	/* VA of buffer in DVMA space */
	long		dh_startingpa;	/* PA of buffer; for "sw" */
};

/*
 * The first structure member has to be the ncr5380_softc
 * so we can just cast to go back and fourth between them.
 */
struct si_softc {
	struct ncr5380_softc	ncr_sc;
	volatile struct si_regs	*sc_regs;
	struct intrhand	sc_ih;
	int		sc_adapter_type;
	int		sc_adapter_iv_am; /* int. vec + address modifier */
	struct si_dma_handle *sc_dma;
	int		sc_xlen;	/* length of current DMA segment. */
	int		sc_options;	/* options for this instance. */
};

/*
 * Options.  By default, configuration files enable DMA and disable
 * DMA completion interrupts and reselect.  You may enable additional features
 * the `flags' directive in your kernel's configuration file.
 *
 * On the "sw", interrupts (and thus) reselection don't work, so they're
 * disabled.  DMA is still a little dangerous, too.
 */
#define	SI_ENABLE_DMA	0x01	/* Use DMA (maybe polled) */
#define	SI_DMA_INTR	0x02	/* DMA completion interrupts */
#define	SI_DO_RESELECT	0x04	/* Allow disconnect/reselect */
#define	SI_OPTIONS_MASK	(SI_ENABLE_DMA|SI_DMA_INTR|SI_DO_RESELECT)
#define	SW_OPTIONS_MASK	(SI_ENABLE_DMA)
#define SI_OPTIONS_BITS	"\10\3RESELECT\2DMA_INTR\1DMA"

/* How long to wait for DMA before declaring an error. */
int si_dma_intr_timo = 500;	/* ticks (sec. X 100) */

static int	si_match(struct device *, void *, void *);
static void	si_attach(struct device *, struct device *, void *);
static int	si_intr(void *);
static void	si_reset_adapter(struct ncr5380_softc *);
static void	si_minphys(struct buf *, struct scsi_link *);

void si_dma_alloc(struct ncr5380_softc *);
void si_dma_free(struct ncr5380_softc *);
void si_dma_poll(struct ncr5380_softc *);

void si_vme_dma_setup(struct ncr5380_softc *);
void si_vme_dma_start(struct ncr5380_softc *);
void si_vme_dma_stop(struct ncr5380_softc *);

void si_vme_intr_on(struct ncr5380_softc *);
void si_vme_intr_off(struct ncr5380_softc *);

void si_obio_dma_setup(struct ncr5380_softc *);
void si_obio_dma_start(struct ncr5380_softc *);
void si_obio_dma_stop(struct ncr5380_softc *);

void si_obio_intr_on(struct ncr5380_softc *);
void si_obio_intr_off(struct ncr5380_softc *);

static struct scsi_adapter	si_ops = {
	ncr5380_scsi_cmd,		/* scsi_cmd() */
	si_minphys,			/* scsi_minphys() */
	NULL,				/* probe_dev() */
	NULL,				/* free_dev() */
};

/* The Sun SCSI-3 VME controller. */
struct cfattach si_ca = {
	sizeof(struct si_softc), si_match, si_attach
};

struct cfdriver si_cd = {
	NULL, "si", DV_DULL
};

/* The Sun "SCSI Weird" 4/100 obio controller. */
struct cfattach sw_ca = {
	sizeof(struct si_softc), si_match, si_attach
};

struct cfdriver sw_cd = {
	NULL, "sw", DV_DULL
};

static int
si_match(parent, vcf, aux)
	struct device	*parent;
	void *vcf, *aux;
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

	/* Are we looking for the right thing? */
	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
		return (0);

	/* Nothing but a Sun 4 is going to have these devices. */
	if (!CPU_ISSUN4)
		return (0);

	/*
	 * Default interrupt priority always is 3.  At least, that's
	 * what my board seems to be at.  --thorpej
	 */
	if (ra->ra_intr[0].int_pri == -1)
		ra->ra_intr[0].int_pri = 3;

	/* Figure out the bus type and look for the appropriate adapter. */
	switch (ca->ca_bustype) {
	case BUS_VME16:
		/* AFAIK, the `si' can only exist on the vmes. */
		if (strcmp(ra->ra_name, "si") ||
		    cpuinfo.cpu_type == CPUTYP_4_100)
			return (0);
		break;

	case BUS_OBIO:
		/* AFAIK, an `sw' can only exist on the obio. */
		if (strcmp(ra->ra_name, "sw") ||
		    cpuinfo.cpu_type != CPUTYP_4_100)
			return (0);
		break;

	default:
		/* Don't know what we ended up with ... */
		return (0);
	}

	/* Make sure there is something there... */
	if (probeget(ra->ra_vaddr + 1, 1) == -1)
		return (0);

	/*
	 * If this is a VME SCSI board, we have to determine whether
	 * it is an "sc" (Sun2) or "si" (Sun3) SCSI board.  This can
	 * be determined using the fact that the "sc" board occupies
	 * 4K bytes in VME space but the "si" board occupies 2K bytes.
	 */
	if (strcmp(cf->cf_driver->cd_name, "si") == 0)
		if (probeget(ra->ra_vaddr + 0x801, 1) != -1)
			return(0);

	return (1);
}

static void
si_attach(parent, self, args)
	struct device	*parent, *self;
	void		*args;
{
	struct si_softc *sc = (struct si_softc *) self;
	struct ncr5380_softc *ncr_sc = (struct ncr5380_softc *)sc;
	struct scsibus_attach_args saa;
	volatile struct si_regs *regs;
	struct confargs *ca = args;
	struct romaux *ra = &ca->ca_ra;
	struct bootpath *bp;
	int i;

	/*
	 * Pull in the options flags.  Allow the user to completely
	 * override the default values.
	 */
	sc->sc_options = ncr_sc->sc_dev.dv_cfdata->cf_flags &
	    (ca->ca_bustype == BUS_OBIO ? SW_OPTIONS_MASK : SI_OPTIONS_MASK);

	/* Map the controller registers. */
	regs = (struct si_regs *)
		mapiodev(ra->ra_reg, 0, sizeof(struct si_regs));

	/*
	 * Fill in the prototype scsi_link.
	 */
	ncr_sc->sc_link.adapter_softc = sc;
	ncr_sc->sc_link.adapter_target = 7;
	ncr_sc->sc_link.adapter = &si_ops;
	ncr_sc->sc_link.openings = 4;

	/*
	 * Initialize fields used by the MI code
	 */
	ncr_sc->sci_r0 = &regs->sci.sci_r0;
	ncr_sc->sci_r1 = &regs->sci.sci_r1;
	ncr_sc->sci_r2 = &regs->sci.sci_r2;
	ncr_sc->sci_r3 = &regs->sci.sci_r3;
	ncr_sc->sci_r4 = &regs->sci.sci_r4;
	ncr_sc->sci_r5 = &regs->sci.sci_r5;
	ncr_sc->sci_r6 = &regs->sci.sci_r6;
	ncr_sc->sci_r7 = &regs->sci.sci_r7;

	/*
	 * MD function pointers used by the MI code.
	 */
	ncr_sc->sc_pio_out = ncr5380_pio_out;
	ncr_sc->sc_pio_in =  ncr5380_pio_in;
	if (sc->sc_options & SI_ENABLE_DMA) {
		ncr_sc->sc_dma_alloc = si_dma_alloc;
		ncr_sc->sc_dma_free  = si_dma_free;
		ncr_sc->sc_dma_poll  = si_dma_poll;
	}

	switch (ca->ca_bustype) {
	case BUS_VME16:
		if (sc->sc_options & SI_ENABLE_DMA) {
			ncr_sc->sc_dma_setup = si_vme_dma_setup;
			ncr_sc->sc_dma_start = si_vme_dma_start;
			ncr_sc->sc_dma_stop  = si_vme_dma_stop;
			if (sc->sc_options & SI_DO_RESELECT) {
				/*
				 * Need to enable interrupts (and DMA!)
				 * on this H/W for reselect to work.
				 */
				ncr_sc->sc_intr_on   = si_vme_intr_on;
				ncr_sc->sc_intr_off  = si_vme_intr_off;
			}
		}
		break;

	case BUS_OBIO:
		if (sc->sc_options & SI_ENABLE_DMA) {
			ncr_sc->sc_dma_setup = si_obio_dma_setup;
			ncr_sc->sc_dma_start = si_obio_dma_start;
			ncr_sc->sc_dma_stop  = si_obio_dma_stop;
		}
		ncr_sc->sc_intr_on   = si_obio_intr_on;
		ncr_sc->sc_intr_off  = si_obio_intr_off;
		break;

	default:
		panic("si_attach: impossible bus type 0x%x", ca->ca_bustype);
		/* NOTREACHED */
	}

	ncr_sc->sc_flags = 0;
	if ((sc->sc_options & SI_DO_RESELECT) == 0)
		ncr_sc->sc_flags |= NCR5380_PERMIT_RESELECT;
	if ((sc->sc_options & (SI_ENABLE_DMA | SI_DMA_INTR)) !=
	    (SI_ENABLE_DMA | SI_DMA_INTR))
		ncr_sc->sc_flags |= NCR5380_FORCE_POLLING;
	ncr_sc->sc_min_dma_len = MIN_DMA_LEN;

	/*
	 * Initialize fields used only here in the MD code.
	 */
	sc->sc_regs = regs;
	sc->sc_adapter_type = ca->ca_bustype;
	/*  sc_adapter_iv_am = (was set above) */

	/*
	 * Allocate DMA handles.
	 */
	i = SCI_OPENINGS * sizeof(struct si_dma_handle);
	sc->sc_dma = (struct si_dma_handle *)malloc(i, M_DEVBUF, M_NOWAIT);
	if (sc->sc_dma == NULL)
		panic("si: dma handle malloc failed");
	for (i = 0; i < SCI_OPENINGS; i++)
		sc->sc_dma[i].dh_flags = 0;

	sc->sc_regs = regs;
	sc->sc_adapter_type = ca->ca_bustype;

	/* Establish the interrupt. */
	sc->sc_ih.ih_fun = si_intr;
	sc->sc_ih.ih_arg = sc;

	switch (ca->ca_bustype) {
	case BUS_OBIO:
		/*
		 * This will be an "sw" controller.
		 */
		intr_establish(ra->ra_intr[0].int_pri, &sc->sc_ih, IPL_BIO,
		    self->dv_xname);
		break;

	case BUS_VME16:
		/*
		 * This will be an "si" controller.
		 */
		vmeintr_establish(ra->ra_intr[0].int_vec,
		    ra->ra_intr[0].int_pri, &sc->sc_ih, IPL_BIO,
		    self->dv_xname);
		sc->sc_adapter_iv_am =
		    VME_SUPV_DATA_24 | (ra->ra_intr[0].int_vec & 0xFF);
		break;

	default:
		/* Impossible case handled above. */
		break;
	}
	printf(" pri %d\n", ra->ra_intr[0].int_pri);
#ifdef	DEBUG
	if (sc->sc_options) {
		printf("%s: options=%b\n", ncr_sc->sc_dev.dv_xname,
			sc->sc_options, SI_OPTIONS_BITS);
	}
	if (si_debug)
		printf("si: Set TheSoftC=%p TheRegs=%p\n", sc, regs);
	ncr_sc->sc_link.flags |= si_link_flags;
#endif

	/*
	 *  Initialize si board itself.
	 */
	si_reset_adapter(ncr_sc);
	ncr5380_init(ncr_sc);
	ncr5380_reset_scsibus(ncr_sc);
	DELAY(2000000);

	/*
	 * If the boot path is "sw" or "si" at the moment and it's me, then
	 * walk out pointer to the sub-device, ready for the config
	 * below.
	 */
	bp = ra->ra_bp;
	if (bp != NULL && strcmp(bp->name, ra->ra_name) == 0 &&
	    bp->val[0] == -1 && bp->val[1] == ncr_sc->sc_dev.dv_unit)
		bootpath_store(1, bp + 1);

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &(ncr_sc->sc_link);

	/* Configure sub-devices */
	config_found(self, &saa, scsiprint);

	bootpath_store(1, NULL);
}

static void
si_minphys(struct buf *bp, struct scsi_link *sl)
{
	if (bp->b_bcount > MAX_DMA_LEN) {
#ifdef DEBUG
		if (si_debug) {
			printf("si_minphys len = 0x%x.\n", MAX_DMA_LEN);
#ifdef DDB
			Debugger();
#endif
		}
#endif
		bp->b_bcount = MAX_DMA_LEN;
	}
	minphys(bp);
}

#define CSR_WANT (SI_CSR_SBC_IP | SI_CSR_DMA_IP | \
	SI_CSR_DMA_CONFLICT | SI_CSR_DMA_BUS_ERR )

static int
si_intr(void *arg)
{
	struct si_softc *sc = arg;
	volatile struct si_regs *si = sc->sc_regs;
	int dma_error, claimed;
	u_short csr;

	claimed = 0;
	dma_error = 0;

	/* SBC interrupt? DMA interrupt? */
	if (sc->sc_adapter_type == BUS_OBIO)
		csr = si->sw_csr;
	else
		csr = si->si_csr;
	NCR_TRACE("si_intr: csr=0x%x\n", csr);

	if (csr & SI_CSR_DMA_CONFLICT) {
		dma_error |= SI_CSR_DMA_CONFLICT;
		printf("si_intr: DMA conflict\n");
	}
	if (csr & SI_CSR_DMA_BUS_ERR) {
		dma_error |= SI_CSR_DMA_BUS_ERR;
		printf("si_intr: DMA bus error\n");
	}
	if (dma_error) {
		if (sc->ncr_sc.sc_state & NCR_DOINGDMA)
			sc->ncr_sc.sc_state |= NCR_ABORTING;
		/* Make sure we will call the main isr. */
		csr |= SI_CSR_DMA_IP;
	}

	if (csr & (SI_CSR_SBC_IP | SI_CSR_DMA_IP)) {
		claimed = ncr5380_intr(&sc->ncr_sc);
#ifdef DEBUG
		if (!claimed) {
			printf("si_intr: spurious from SBC\n");
#ifdef DDB
			if (si_debug & 4) {
				Debugger();	/* XXX */
			}
#endif
		}
#endif
	}

	return (claimed);
}


static void
si_reset_adapter(struct ncr5380_softc *ncr_sc)
{
	struct si_softc *sc = (struct si_softc *)ncr_sc;
	volatile struct si_regs *si = sc->sc_regs;

#ifdef	DEBUG
	if (si_debug) {
		printf("si_reset_adapter\n");
	}
#endif

	/*
	 * The SCSI3 controller has an 8K FIFO to buffer data between the
	 * 5380 and the DMA.  Make sure it starts out empty.
	 *
	 * The reset bits in the CSR are active low.
	 */
	switch(sc->sc_adapter_type) {
	case BUS_VME16:
		si->si_csr = 0;
		delay(10);
		si->si_csr = SI_CSR_FIFO_RES | SI_CSR_SCSI_RES | SI_CSR_INTR_EN;
		delay(10);
		si->fifo_count = 0;
		si->dma_addrh = 0;
		si->dma_addrl = 0;
		si->dma_counth = 0;
		si->dma_countl = 0;
		si->si_iv_am = sc->sc_adapter_iv_am;
		si->fifo_cnt_hi = 0;
		break;

	case BUS_OBIO:
		si->sw_csr = 0;
		delay(10);
		si->sw_csr = SI_CSR_SCSI_RES;
		si->dma_addr = 0;
		si->dma_count = 0;
		delay(10);
		si->sw_csr |= SI_CSR_INTR_EN;
		break;
	}

	SCI_CLR_INTR(ncr_sc);
}


/*****************************************************************
 * Common functions for DMA
 ****************************************************************/

/*
 * Allocate a DMA handle and put it in sc->sc_dma.  Prepare
 * for DMA transfer.  On the Sun4, this means mapping the buffer
 * into DVMA space.
 */
void
si_dma_alloc(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct si_softc *sc = (struct si_softc *)ncr_sc;
	struct sci_req *sr = ncr_sc->sc_current;
	struct scsi_xfer *xs = sr->sr_xs;
	struct si_dma_handle *dh;
	int i, xlen;
	u_long addr;

#ifdef DIAGNOSTIC
	if (sr->sr_dma_hand != NULL)
		panic("si_dma_alloc: already have DMA handle");
#endif

#if 1	/* XXX - Temporary */
	/* XXX - In case we think DMA is completely broken... */
	if ((sc->sc_options & SI_ENABLE_DMA) == 0)
		return;
#endif

	addr = (u_long) ncr_sc->sc_dataptr;
	xlen = ncr_sc->sc_datalen;

	/* If the DMA start addr is misaligned then do PIO */
	if ((addr & 1) || (xlen & 1)) {
#ifdef DEBUG
		printf("si_dma_alloc: misaligned.\n");
#endif
		return;
	}

	/* Make sure our caller checked sc_min_dma_len. */
	if (xlen < MIN_DMA_LEN)
		panic("si_dma_alloc: xlen=0x%x", xlen);

	/* Find free DMA handle.  Guaranteed to find one since we have
	   as many DMA handles as the driver has processes. */
	for (i = 0; i < SCI_OPENINGS; i++) {
		if ((sc->sc_dma[i].dh_flags & SIDH_BUSY) == 0)
			goto found;
	}
	panic("si: no free DMA handles.");
found:

	dh = &sc->sc_dma[i];
	dh->dh_flags = SIDH_BUSY;
	dh->dh_addr = (u_char *) addr;
	dh->dh_maplen  = xlen;
	dh->dh_dvma = 0;

	/* Copy the "write" flag for convenience. */
	if (xs->flags & SCSI_DATA_OUT)
		dh->dh_flags |= SIDH_OUT;

	/*
	 * Double-map the buffer into DVMA space.  If we can't re-map
	 * the buffer, we print a warning and fall back to PIO mode.
	 *
	 * NOTE: it is not safe to sleep here!
	 */
	dh->dh_dvma = (long)kdvma_mapin((caddr_t)addr, xlen, 0);
	if (dh->dh_dvma == 0) {
		/* Can't remap segment */
		printf("si_dma_alloc: can't remap %p/0x%x, doing PIO\n",
			dh->dh_addr, dh->dh_maplen);
		dh->dh_flags = 0;
		return;
	}

	/* success */
	sr->sr_dma_hand = dh;

	return;
}


void
si_dma_free(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct sci_req *sr = ncr_sc->sc_current;
	struct si_dma_handle *dh = sr->sr_dma_hand;

#ifdef DIAGNOSTIC
	if (dh == NULL)
		panic("si_dma_free: no DMA handle");
#endif

	if (ncr_sc->sc_state & NCR_DOINGDMA)
		panic("si_dma_free: free while in progress");

	if (dh->dh_flags & SIDH_BUSY) {
		/* XXX - Should separate allocation and mapping. */

		/* Give back the DVMA space. */
		dvma_mapout((vaddr_t)dh->dh_dvma, (vaddr_t)dh->dh_addr,
			    dh->dh_maplen);

		dh->dh_dvma = 0;
		dh->dh_flags = 0;
	}
	sr->sr_dma_hand = NULL;
}


/*
 * Poll (spin-wait) for DMA completion.
 * Called right after xx_dma_start(), and
 * xx_dma_stop() will be called next.
 * Same for either VME or OBIO.
 */
void
si_dma_poll(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct si_softc *sc = (struct si_softc *)ncr_sc;
	struct sci_req *sr = ncr_sc->sc_current;
	volatile struct si_regs *si = sc->sc_regs;
	int tmo, csr_mask, csr;

	/* Make sure DMA started successfully. */
	if (ncr_sc->sc_state & NCR_ABORTING)
		return;

	csr_mask = SI_CSR_SBC_IP | SI_CSR_DMA_IP |
		SI_CSR_DMA_CONFLICT | SI_CSR_DMA_BUS_ERR;

	tmo = 50000;	/* X100 = 5 sec. */
	for (;;) {
		if (sc->sc_adapter_type == BUS_OBIO)
			csr = si->sw_csr;
		else
			csr = si->si_csr;
		if (csr & csr_mask)
			break;
		if (--tmo <= 0) {
			printf("%s: DMA timeout (while polling)\n",
			    ncr_sc->sc_dev.dv_xname);
			/* Indicate timeout as MI code would. */
			sr->sr_flags |= SR_OVERDUE;
			break;
		}
		delay(100);
	}

#ifdef	DEBUG
	if (si_debug) {
		printf("si_dma_poll: done, csr=0x%x\n", csr);
	}
#endif
}


/*****************************************************************
 * VME functions for DMA
 ****************************************************************/


/*
 * This is called when the bus is going idle,
 * so we want to enable the SBC interrupts.
 * That is controlled by the DMA enable!
 * Who would have guessed!
 * What a NASTY trick!
 */
void
si_vme_intr_on(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct si_softc *sc = (struct si_softc *)ncr_sc;
	volatile struct si_regs *si = sc->sc_regs;

	si_vme_dma_setup(ncr_sc);
	si->si_csr |= SI_CSR_DMA_EN;
}

/*
 * This is called when the bus is idle and we are
 * about to start playing with the SBC chip.
 */
void
si_vme_intr_off(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct si_softc *sc = (struct si_softc *)ncr_sc;
	volatile struct si_regs *si = sc->sc_regs;

	si->si_csr &= ~SI_CSR_DMA_EN;
}

/*
 * This function is called during the COMMAND or MSG_IN phase
 * that precedes a DATA_IN or DATA_OUT phase, in case we need
 * to setup the DMA engine before the bus enters a DATA phase.
 *
 * XXX: The VME adapter appears to suppress SBC interrupts
 * when the FIFO is not empty or the FIFO count is non-zero!
 *
 * On the VME version we just clear the DMA count and address
 * here (to make sure it stays idle) and do the real setup
 * later, in dma_start.
 */
void
si_vme_dma_setup(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct si_softc *sc = (struct si_softc *)ncr_sc;
	volatile struct si_regs *si = sc->sc_regs;

	/* Reset the FIFO */
	si->si_csr &= ~SI_CSR_FIFO_RES;		/* active low */
	si->si_csr |= SI_CSR_FIFO_RES;

	/* Set direction (assume recv here) */
	si->si_csr &= ~SI_CSR_SEND;
	/* Assume worst alignment */
	si->si_csr |= SI_CSR_BPCON;

	si->dma_addrh = 0;
	si->dma_addrl = 0;

	si->dma_counth = 0;
	si->dma_countl = 0;

	/* Clear FIFO counter. (also hits dma_count) */
	si->fifo_cnt_hi = 0;
	si->fifo_count = 0;
}


void
si_vme_dma_start(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct si_softc *sc = (struct si_softc *)ncr_sc;
	struct sci_req *sr = ncr_sc->sc_current;
	struct si_dma_handle *dh = sr->sr_dma_hand;
	volatile struct si_regs *si = sc->sc_regs;
	u_long data_pa;
	int xlen;

	/*
	 * Get the DVMA mapping for this segment.
	 * XXX - Should separate allocation and mapin.
	 */
	data_pa = (u_long)(dh->dh_dvma - DVMA_BASE);
	if (data_pa & 1)
		panic("si_dma_start: bad pa=0x%lx", data_pa);
	xlen = ncr_sc->sc_datalen;
	xlen &= ~1;
	sc->sc_xlen = xlen;	/* XXX: or less... */

#ifdef	DEBUG
	if (si_debug & 2) {
		printf("si_dma_start: dh=%p, pa=0x%lx, xlen=%d\n",
			   dh, data_pa, xlen);
	}
#endif

	/*
	 * Set up the DMA controller.
	 * Note that (dh->dh_len < sc_datalen)
	 */
	si->si_csr &= ~SI_CSR_FIFO_RES;		/* active low */
	si->si_csr |= SI_CSR_FIFO_RES;

	/* Set direction (send/recv) */
	if (dh->dh_flags & SIDH_OUT) {
		si->si_csr |= SI_CSR_SEND;
	} else {
		si->si_csr &= ~SI_CSR_SEND;
	}

	if (data_pa & 2) {
		si->si_csr |= SI_CSR_BPCON;
	} else {
		si->si_csr &= ~SI_CSR_BPCON;
	}

	si->dma_addrh = (u_short)(data_pa >> 16);
	si->dma_addrl = (u_short)(data_pa & 0xFFFF);

	si->dma_counth = (u_short)(xlen >> 16);
	si->dma_countl = (u_short)(xlen & 0xFFFF);

#if 1
	/* Set it anyway, even though dma_count hits it? */
	si->fifo_cnt_hi = (u_short)(xlen >> 16);
	si->fifo_count  = (u_short)(xlen & 0xFFFF);
#endif

#ifdef DEBUG
	if (si->fifo_count != xlen) {
		printf("si_dma_start: Fifo_count=0x%x, xlen=0x%x\n",
		    si->fifo_count, xlen);
#ifdef DDB
		Debugger();
#endif
	}
#endif

	/*
	 * Acknowledge the phase change.  (After DMA setup!)
	 * Put the SBIC into DMA mode, and start the transfer.
	 */
	if (dh->dh_flags & SIDH_OUT) {
		*ncr_sc->sci_tcmd = PHASE_DATA_OUT;
		SCI_CLR_INTR(ncr_sc);
		*ncr_sc->sci_icmd = SCI_ICMD_DATA;
		*ncr_sc->sci_mode |= (SCI_MODE_DMA | SCI_MODE_DMA_IE);
		*ncr_sc->sci_dma_send = 0;	/* start it */
	} else {
		*ncr_sc->sci_tcmd = PHASE_DATA_IN;
		SCI_CLR_INTR(ncr_sc);
		*ncr_sc->sci_icmd = 0;
		*ncr_sc->sci_mode |= (SCI_MODE_DMA | SCI_MODE_DMA_IE);
		*ncr_sc->sci_irecv = 0;		/* start it */
	}

	/* Let'er rip! */
	si->si_csr |= SI_CSR_DMA_EN;

	ncr_sc->sc_state |= NCR_DOINGDMA;

#ifdef	DEBUG
	if (si_debug & 2) {
		printf("si_dma_start: started, flags=0x%x\n",
			   ncr_sc->sc_state);
	}
#endif
}


void
si_vme_dma_stop(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct si_softc *sc = (struct si_softc *)ncr_sc;
	struct sci_req *sr = ncr_sc->sc_current;
	struct si_dma_handle *dh = sr->sr_dma_hand;
	volatile struct si_regs *si = sc->sc_regs;
	int resid, ntrans;

	if ((ncr_sc->sc_state & NCR_DOINGDMA) == 0) {
#ifdef	DEBUG
		printf("si_dma_stop: dma not running\n");
#endif
		return;
	}
	ncr_sc->sc_state &= ~NCR_DOINGDMA;

	/* First, halt the DMA engine. */
	si->si_csr &= ~SI_CSR_DMA_EN;	/* VME only */

	if (si->si_csr & (SI_CSR_DMA_CONFLICT | SI_CSR_DMA_BUS_ERR)) {
		printf("si: DMA error, csr=0x%x, reset\n", si->si_csr);
		sr->sr_xs->error = XS_DRIVER_STUFFUP;
		ncr_sc->sc_state |= NCR_ABORTING;
		si_reset_adapter(ncr_sc);
	}

	/* Note that timeout may have set the error flag. */
	if (ncr_sc->sc_state & NCR_ABORTING)
		goto out;

	/*
	 * Now try to figure out how much actually transferred
	 *
	 * The fifo_count does not reflect how many bytes were
	 * actually transferred for VME.
	 *
	 * SCSI-3 VME interface is a little funny on writes:
	 * if we have a disconnect, the dma has overshot by
	 * one byte and the resid needs to be incremented.
	 * Only happens for partial transfers.
	 * (Thanks to Matt Jacob)
	 */

	resid = si->fifo_count & 0xFFFF;
	if (dh->dh_flags & SIDH_OUT)
		if ((resid > 0) && (resid < sc->sc_xlen))
			resid++;
	ntrans = sc->sc_xlen - resid;

#ifdef	DEBUG
	if (si_debug & 2) {
		printf("si_dma_stop: resid=0x%x ntrans=0x%x\n",
		    resid, ntrans);
	}
#endif

	if (ntrans < MIN_DMA_LEN) {
#ifdef DEBUG
		printf("si: fifo count: 0x%x\n", resid);
#endif
		ncr_sc->sc_state |= NCR_ABORTING;
		goto out;
	}

	if (ntrans > ncr_sc->sc_datalen)
		panic("si_dma_stop: excess transfer");

	/* Adjust data pointer */
	ncr_sc->sc_dataptr += ntrans;
	ncr_sc->sc_datalen -= ntrans;

#ifdef	DEBUG
	if (si_debug & 2) {
		printf("si_dma_stop: ntrans=0x%x\n", ntrans);
	}
#endif

	/*
	 * After a read, we may need to clean-up
	 * "Left-over bytes" (yuck!)
	 */
	if (((dh->dh_flags & SIDH_OUT) == 0) &&
		((si->si_csr & SI_CSR_LOB) != 0))
	{
		char *cp = ncr_sc->sc_dataptr;
#ifdef DEBUG
		printf("si: Got Left-over bytes!\n");
#endif
		if (si->si_csr & SI_CSR_BPCON) {
			/* have SI_CSR_BPCON */
			cp[-1] = (si->si_bprl & 0xff00) >> 8;
		} else {
			switch (si->si_csr & SI_CSR_LOB) {
			case SI_CSR_LOB_THREE:
				cp[-3] = (si->si_bprh & 0xff00) >> 8;
				cp[-2] = (si->si_bprh & 0x00ff);
				cp[-1] = (si->si_bprl & 0xff00) >> 8;
				break;
			case SI_CSR_LOB_TWO:
				cp[-2] = (si->si_bprh & 0xff00) >> 8;
				cp[-1] = (si->si_bprh & 0x00ff);
				break;
			case SI_CSR_LOB_ONE:
				cp[-1] = (si->si_bprh & 0xff00) >> 8;
				break;
			}
		}
	}

out:
	si->dma_addrh = 0;
	si->dma_addrl = 0;

	si->dma_counth = 0;
	si->dma_countl = 0;

	si->fifo_cnt_hi = 0;
	si->fifo_count  = 0;

	/* Put SBIC back in PIO mode. */
	*ncr_sc->sci_mode &= ~(SCI_MODE_DMA | SCI_MODE_DMA_IE);
	*ncr_sc->sci_icmd = 0;
}


/*****************************************************************
 * OBIO functions for DMA
 ****************************************************************/


/*
 * This is called when the bus is going idle,
 * so we want to enable the SBC interrupts.
 * That is controlled by the DMA enable!
 * Who would have guessed!
 * What a NASTY trick!
 *
 * XXX THIS MIGHT NOT WORK RIGHT!
 */
void
si_obio_intr_on(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct si_softc *sc = (struct si_softc *)ncr_sc;
	volatile struct si_regs *si = sc->sc_regs;

	si_obio_dma_setup(ncr_sc);
	si->sw_csr |= SI_CSR_DMA_EN;
}

/*
 * This is called when the bus is idle and we are
 * about to start playing with the SBC chip.
 *
 * XXX THIS MIGHT NOT WORK RIGHT!
 */
void
si_obio_intr_off(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct si_softc *sc = (struct si_softc *)ncr_sc;
	volatile struct si_regs *si = sc->sc_regs;

	si->sw_csr &= ~SI_CSR_DMA_EN;
}


/*
 * This function is called during the COMMAND or MSG_IN phase
 * that precedes a DATA_IN or DATA_OUT phase, in case we need
 * to setup the DMA engine before the bus enters a DATA phase.
 *
 * On the OBIO version we just clear the DMA count and address
 * here (to make sure it stays idle) and do the real setup
 * later, in dma_start.
 */
void
si_obio_dma_setup(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct si_softc *sc = (struct si_softc *)ncr_sc;
	volatile struct si_regs *si = sc->sc_regs;

	/* No FIFO to reset on "sw". */

	/* Set direction (assume recv here) */
	si->sw_csr &= ~SI_CSR_SEND;

	si->dma_addr = 0;
	si->dma_count = 0;
}


void
si_obio_dma_start(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct si_softc *sc = (struct si_softc *)ncr_sc;
	struct sci_req *sr = ncr_sc->sc_current;
	struct si_dma_handle *dh = sr->sr_dma_hand;
	volatile struct si_regs *si = sc->sc_regs;
	u_long data_pa;
	int xlen, adj, adjlen;

	/*
	 * Get the DVMA mapping for this segment.
	 * XXX - Should separate allocation and mapin.
	 */
	data_pa = (u_long)(dh->dh_dvma - DVMA_BASE);
	if (data_pa & 1)
		panic("si_dma_start: bad pa=0x%lx", data_pa);
	xlen = ncr_sc->sc_datalen;
	xlen &= ~1;
	sc->sc_xlen = xlen;	/* XXX: or less... */

#ifdef	DEBUG
	if (si_debug & 2) {
		printf("si_dma_start: dh=%p, pa=0x%lx, xlen=%d\n",
		    dh, data_pa, xlen);
	}
#endif

	/*
	 * Set up the DMA controller.
	 * Note that (dh->dh_len < sc_datalen)
	 */

	/* Set direction (send/recv) */
	if (dh->dh_flags & SIDH_OUT) {
		si->sw_csr |= SI_CSR_SEND;
	} else {
		si->sw_csr &= ~SI_CSR_SEND;
	}

	/*
	 * The "sw" needs longword aligned transfers.  We
	 * detect a shortword aligned transfer here, and adjust the
	 * DMA transfer by 2 bytes.  These two bytes are read/written
	 * in PIO mode just before the DMA is started.
	 */
	adj = 0;
	if (data_pa & 2) {
		adj = 2;
#ifdef DEBUG
		if (si_debug & 2)
			printf("si_dma_start: adjusted up %d bytes\n", adj);
#endif
	}

	/* We have to frob the address on the "sw". */
	dh->dh_startingpa = (data_pa | 0xF00000);
	si->dma_addr = (int)(dh->dh_startingpa + adj);
	si->dma_count = (xlen - adj);

	/*
	 * Acknowledge the phase change.  (After DMA setup!)
	 * Put the SBIC into DMA mode, and start the transfer.
	 */
	if (dh->dh_flags & SIDH_OUT) {
		*ncr_sc->sci_tcmd = PHASE_DATA_OUT;
		if (adj) {
			adjlen = ncr5380_pio_out(ncr_sc, PHASE_DATA_OUT,
			    adj, dh->dh_addr);
			if (adjlen != adj)
				printf("%s: bad outgoing adj, %d != %d\n",
				    ncr_sc->sc_dev.dv_xname, adjlen, adj);
		}
		SCI_CLR_INTR(ncr_sc);
		*ncr_sc->sci_icmd = SCI_ICMD_DATA;
		*ncr_sc->sci_mode |= (SCI_MODE_DMA | SCI_MODE_DMA_IE);
		*ncr_sc->sci_dma_send = 0;	/* start it */
	} else {
		*ncr_sc->sci_tcmd = PHASE_DATA_IN;
		if (adj) {
			adjlen = ncr5380_pio_in(ncr_sc, PHASE_DATA_IN,
			    adj, dh->dh_addr);
			if (adjlen != adj)
				printf("%s: bad incoming adj, %d != %d\n",
				    ncr_sc->sc_dev.dv_xname, adjlen, adj);
		}
		SCI_CLR_INTR(ncr_sc);
		*ncr_sc->sci_icmd = 0;
		*ncr_sc->sci_mode |= (SCI_MODE_DMA | SCI_MODE_DMA_IE);
		*ncr_sc->sci_irecv = 0;		/* start it */
	}

	/* Let'er rip! */
	si->sw_csr |= SI_CSR_DMA_EN;

	ncr_sc->sc_state |= NCR_DOINGDMA;

#ifdef	DEBUG
	if (si_debug & 2) {
		printf("si_dma_start: started, flags=0x%x\n",
		    ncr_sc->sc_state);
	}
#endif
}


#if (defined(DEBUG) || defined(DIAGNOSTIC)) && !defined(COUNT_SW_LEFTOVERS)
#define COUNT_SW_LEFTOVERS
#endif
#ifdef COUNT_SW_LEFTOVERS
/*
 * Let's find out how often these occur.  Read these with DDB from time
 * to time.
 */
int	sw_3_leftover = 0;
int	sw_2_leftover = 0;
int	sw_1_leftover = 0;
int	sw_0_leftover = 0;
#endif

void
si_obio_dma_stop(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct si_softc *sc = (struct si_softc *)ncr_sc;
	struct sci_req *sr = ncr_sc->sc_current;
	struct si_dma_handle *dh = sr->sr_dma_hand;
	volatile struct si_regs *si = sc->sc_regs;
	int ntrans = 0, Dma_addr;

	if ((ncr_sc->sc_state & NCR_DOINGDMA) == 0) {
#ifdef	DEBUG
		printf("si_dma_stop: dma not running\n");
#endif
		return;
	}
	ncr_sc->sc_state &= ~NCR_DOINGDMA;

	/* First, halt the DMA engine. */
	si->sw_csr &= ~SI_CSR_DMA_EN;

	/*
	 * XXX HARDWARE BUG!
	 * Apparently, some early 4/100 SCSI controllers had a hardware
	 * bug that caused the controller to do illegal memory access.
	 * We see this as SI_CSR_DMA_BUS_ERR (makes sense).  To work around
	 * this, we simply need to clean up after ourselves ... there will
	 * be as many as 3 bytes left over.  Since we clean up "left-over"
	 * bytes on every read anyway, we just continue to chug along
	 * if SI_CSR_DMA_BUS_ERR is asserted.  (This was probably worked
	 * around in hardware later with the "left-over byte" indicator
	 * in the VME controller.)
	 */
#if 0
	if (si->sw_csr & (SI_CSR_DMA_CONFLICT | SI_CSR_DMA_BUS_ERR)) {
#else
	if (si->sw_csr & (SI_CSR_DMA_CONFLICT)) {
#endif
		printf("sw: DMA error, csr=0x%x, reset\n", si->sw_csr);
		sr->sr_xs->error = XS_DRIVER_STUFFUP;
		ncr_sc->sc_state |= NCR_ABORTING;
		si_reset_adapter(ncr_sc);
	}

	/* Note that timeout may have set the error flag. */
	if (ncr_sc->sc_state & NCR_ABORTING)
		goto out;

	/*
	 * Now try to figure out how much actually transferred
	 *
	 * The "sw" doesn't have a FIFO or a bcr, so we've stored
	 * the starting PA of the transfer in the DMA handle,
	 * and subtract it from the ending PA left in the dma_addr
	 * register.
	 */
	Dma_addr = si->dma_addr;
	ntrans = (Dma_addr - dh->dh_startingpa);

#ifdef	DEBUG
	if (si_debug & 2) {
		printf("si_dma_stop: ntrans=0x%x\n", ntrans);
	}
#endif

	if (ntrans < MIN_DMA_LEN) {
		printf("sw: short transfer\n");
		ncr_sc->sc_state |= NCR_ABORTING;
		goto out;
	}

	if (ntrans > ncr_sc->sc_datalen)
		panic("si_dma_stop: excess transfer");

	/* Adjust data pointer */
	ncr_sc->sc_dataptr += ntrans;
	ncr_sc->sc_datalen -= ntrans;

	/*
	 * After a read, we may need to clean-up
	 * "Left-over bytes"  (yuck!)  The "sw" doesn't
	 * have a "left-over" indicator, so we have to so
	 * this no matter what.  Ick.
	 */
	if ((dh->dh_flags & SIDH_OUT) == 0) {
		char *cp = ncr_sc->sc_dataptr;

		switch (Dma_addr & 3) {
		case 3:
			cp[0] = (si->sw_bpr & 0xff000000) >> 24;
			cp[1] = (si->sw_bpr & 0x00ff0000) >> 16;
			cp[2] = (si->sw_bpr & 0x0000ff00) >> 8;
#ifdef COUNT_SW_LEFTOVERS
			++sw_3_leftover;
#endif
			break;

		case 2:
			cp[0] = (si->sw_bpr & 0xff000000) >> 24;
			cp[1] = (si->sw_bpr & 0x00ff0000) >> 16;
#ifdef COUNT_SW_LEFTOVERS
			++sw_2_leftover;
#endif
			break;

		case 1:
			cp[0] = (si->sw_bpr & 0xff000000) >> 24;
#ifdef COUNT_SW_LEFTOVERS
			++sw_1_leftover;
#endif
			break;

#ifdef COUNT_SW_LEFTOVERS
		default:
			++sw_0_leftover;
			break;
#endif
		}
	}

 out:
	si->dma_addr = 0;
	si->dma_count = 0;

	/* Put SBIC back in PIO mode. */
	*ncr_sc->sci_mode &= ~(SCI_MODE_DMA | SCI_MODE_DMA_IE);
	*ncr_sc->sci_icmd = 0;

#ifdef DEBUG
	if (si_debug & 2) {
		printf("si_dma_stop: ntrans=0x%x\n", ntrans);
	}
#endif
}
@


1.36
log
@lager -> larger (no beer involved)
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.35 2010/06/28 18:31:01 krw Exp $	*/
@


1.35
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.34 2010/06/27 05:52:01 beck Exp $	*/
d125 1
a125 1
 * Transfers lager than 65535 bytes need to be split-up.
@


1.34
log
@make sparc compile again after tag team viking/guenther breakage.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.33 2010/06/26 23:24:44 guenther Exp $	*/
a213 10
/* This is copied from julian's bt driver */
/* "so we have a default dev struct for our link struct." */
static struct scsi_device si_dev = {
	NULL,		/* Use default error handler.		*/
	NULL,		/* Use default start handler.		*/
	NULL,		/* Use default async handler.		*/
	NULL,		/* Use default "done" routine.		*/
};


a324 1
	ncr_sc->sc_link.device = &si_dev;
@


1.33
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.32 2009/02/16 21:19:06 miod Exp $	*/
d101 2
@


1.32
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.31 2009/01/04 16:51:44 miod Exp $	*/
a96 1
#include <sys/user.h>
@


1.31
log
@Be silent when deciding that the last chunk of a DMA transfer will be done
in PIO mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.30 2008/06/26 05:42:13 ray Exp $	*/
d186 1
a186 1
static void	si_minphys(struct buf *);
d487 1
a487 1
si_minphys(struct buf *bp)
d500 1
a500 1
	return (minphys(bp));
@


1.30
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.29 2007/12/29 03:04:19 dlg Exp $	*/
d1006 1
d1008 1
d1010 1
d1014 1
@


1.29
log
@fix comments after the members of scsi_adapter were changed.

prompted by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.28 2007/11/27 16:22:13 martynas Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.28
log
@typos;  ok jmc@@
sys/dev/pci/pciide.c from naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.27 2007/07/01 19:05:37 miod Exp $	*/
d214 4
a217 4
	ncr5380_scsi_cmd,		/* scsi_cmd()		*/
	si_minphys,			/* scsi_minphys()	*/
	NULL,				/* open_target_lu()	*/
	NULL,				/* close_target_lu()	*/
@


1.27
log
@Do not define DEBUG unconditionnaly.
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.26 2007/06/09 14:21:44 miod Exp $	*/
d88 1
a88 1
 * bahve the way the 5380 code expects.  For this reason, only
@


1.26
log
@Silence a debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.25 2006/12/13 21:12:58 miod Exp $	*/
a116 8
#ifndef DDB
#define	Debugger()
#endif

#ifndef DEBUG
#define DEBUG XXX
#endif

d500 1
d502 1
d551 1
d555 1
d918 1
d920 1
@


1.25
log
@Remove the dma_eop callback in the ncr5380 driver md attachment, it was always
doing nothing and the mi code does not use it anymore anyway. No functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.24 2006/12/10 16:15:03 miod Exp $	*/
d652 1
d654 1
@


1.24
log
@Delay two seconds after board reset before trying to probe scsi devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.23 2006/12/10 16:14:22 miod Exp $	*/
a208 1
void si_vme_dma_eop(struct ncr5380_softc *);
a215 1
void si_obio_dma_eop(struct ncr5380_softc *);
a379 1
			ncr_sc->sc_dma_eop   = si_vme_dma_stop;
a395 1
			ncr_sc->sc_dma_eop   = si_obio_dma_stop;
a956 9
si_vme_dma_eop(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{

	/* Not needed - DMA was stopped prior to examining sci_csr */
}


void
a1252 8

void
si_obio_dma_eop(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{

	/* Not needed - DMA was stopped prior to examining sci_csr */
}
@


1.23
log
@Allow ``flags 0'' to work to disable DMA for si(4) and sw(4) - it would get
ignored previously.
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.22 2006/11/28 23:59:45 dlg Exp $	*/
d484 1
@


1.22
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.21 2004/11/29 06:20:02 jsg Exp $	*/
d180 2
a181 2
 * Options.  By default, DMA is enabled and DMA completion interrupts
 * and reselect are disabled.  You may enable additional features
a183 4
 * Alternatively, you can patch your kernel with DDB or some other
 * mechanism.  The sc_options member of the softc is OR'd with
 * the value in si_options.
 *
d185 1
a185 3
 * disabled by default.  DMA is still a little dangerous, too.
 *
 * Note, there's a separate sw_options to make life easier.
d191 1
a192 2
int si_options = SI_ENABLE_DMA;
int sw_options = SI_ENABLE_DMA;
d338 2
a339 6
	if ((ncr_sc->sc_dev.dv_cfdata->cf_flags & SI_OPTIONS_MASK) != 0)
		sc->sc_options =
		    (ncr_sc->sc_dev.dv_cfdata->cf_flags & SI_OPTIONS_MASK);
	else
		sc->sc_options =
		    (ca->ca_bustype == BUS_OBIO) ? sw_options : si_options;
d371 5
a375 3
	ncr_sc->sc_dma_alloc = si_dma_alloc;
	ncr_sc->sc_dma_free  = si_dma_free;
	ncr_sc->sc_dma_poll  = si_dma_poll;
d379 13
a391 11
		ncr_sc->sc_dma_setup = si_vme_dma_setup;
		ncr_sc->sc_dma_start = si_vme_dma_start;
		ncr_sc->sc_dma_eop   = si_vme_dma_stop;
		ncr_sc->sc_dma_stop  = si_vme_dma_stop;
		if (sc->sc_options & SI_DO_RESELECT) {
			/*
			 * Need to enable interrupts (and DMA!)
			 * on this H/W for reselect to work.
			 */
			ncr_sc->sc_intr_on   = si_vme_intr_on;
			ncr_sc->sc_intr_off  = si_vme_intr_off;
d396 6
a401 4
		ncr_sc->sc_dma_setup = si_obio_dma_setup;
		ncr_sc->sc_dma_start = si_obio_dma_start;
		ncr_sc->sc_dma_eop   = si_obio_dma_stop;
		ncr_sc->sc_dma_stop  = si_obio_dma_stop;
d414 2
a415 1
	if ((sc->sc_options & SI_DMA_INTR) == 0)
d468 1
a472 1
#ifdef	DEBUG
@


1.21
log
@Spell precede correctly.
'looks fine' millert@@, krw@@. ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.20 2004/09/29 07:35:11 miod Exp $	*/
d334 1
d499 3
d503 1
a503 1
	config_found(self, &(ncr_sc->sc_link), scsiprint);
@


1.20
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.19 2003/11/14 19:05:36 miod Exp $	*/
d820 1
a820 1
 * that preceeds a DATA_IN or DATA_OUT phase, in case we need
d1135 1
a1135 1
 * that preceeds a DATA_IN or DATA_OUT phase, in case we need
@


1.19
log
@the the; rohee@@
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.18 2002/10/12 01:09:43 krw Exp $	*/
d451 2
a452 1
		intr_establish(ra->ra_intr[0].int_pri, &sc->sc_ih, IPL_BIO);
d460 2
a461 1
		    ra->ra_intr[0].int_pri, &sc->sc_ih, IPL_BIO);
@


1.18
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.17 2002/04/30 01:12:29 art Exp $	*/
d75 1
a75 1
 * the the 4/100 DMA code.
@


1.17
log
@Fix an ancient problem in how sparc interrupts are handled.

There are many interrupt handlers that assume that they don't need to do
any spl protection in their code because the interrupt of some level can't
be interrupted by an interrupt of the same level. The problem is that some
interrupt handlers have hardware levels that are lower then their "software"
levels.

Fix this by adding an additional field to struct intrhand that specifies which
"software" level an interrupt handler has and blocks that level while handling
the interrupt. This new field is initialized in intr_establish which gets
an additional argument (which can be -1 meaning that the interrupt handler
doesn't need to block any additional level).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.16 2002/03/14 03:15:59 millert Exp $	*/
d411 1
a411 1
		panic("\nsi_attach: impossible bus type 0x%x", ca->ca_bustype);
@


1.16
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.15 2002/03/14 01:26:43 millert Exp $	*/
d451 1
a451 1
		intr_establish(ra->ra_intr[0].int_pri, &sc->sc_ih);
d459 1
a459 1
		    ra->ra_intr[0].int_pri, &sc->sc_ih);
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.14 2000/09/21 17:45:12 mickey Exp $	*/
d672 1
a672 1
	dh->dh_addr = (u_char*) addr;
@


1.14
log
@initialize sc_link.openings to it's (currently) default value of 4
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.13 1999/07/09 21:34:45 art Exp $	*/
d204 22
a225 22
static int	si_match __P((struct device *, void *, void *));
static void	si_attach __P((struct device *, struct device *, void *));
static int	si_intr __P((void *));
static void	si_reset_adapter __P((struct ncr5380_softc *));
static void	si_minphys __P((struct buf *));

void si_dma_alloc __P((struct ncr5380_softc *));
void si_dma_free __P((struct ncr5380_softc *));
void si_dma_poll __P((struct ncr5380_softc *));

void si_vme_dma_setup __P((struct ncr5380_softc *));
void si_vme_dma_start __P((struct ncr5380_softc *));
void si_vme_dma_eop __P((struct ncr5380_softc *));
void si_vme_dma_stop __P((struct ncr5380_softc *));

void si_vme_intr_on  __P((struct ncr5380_softc *));
void si_vme_intr_off __P((struct ncr5380_softc *));

void si_obio_dma_setup __P((struct ncr5380_softc *));
void si_obio_dma_start __P((struct ncr5380_softc *));
void si_obio_dma_eop __P((struct ncr5380_softc *));
void si_obio_dma_stop __P((struct ncr5380_softc *));
d227 2
a228 2
void si_obio_intr_on __P((struct ncr5380_softc *));
void si_obio_intr_off __P((struct ncr5380_softc *));
@


1.14.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.14 2000/09/21 17:45:12 mickey Exp $	*/
d204 22
a225 22
static int	si_match(struct device *, void *, void *);
static void	si_attach(struct device *, struct device *, void *);
static int	si_intr(void *);
static void	si_reset_adapter(struct ncr5380_softc *);
static void	si_minphys(struct buf *);

void si_dma_alloc(struct ncr5380_softc *);
void si_dma_free(struct ncr5380_softc *);
void si_dma_poll(struct ncr5380_softc *);

void si_vme_dma_setup(struct ncr5380_softc *);
void si_vme_dma_start(struct ncr5380_softc *);
void si_vme_dma_eop(struct ncr5380_softc *);
void si_vme_dma_stop(struct ncr5380_softc *);

void si_vme_intr_on(struct ncr5380_softc *);
void si_vme_intr_off(struct ncr5380_softc *);

void si_obio_dma_setup(struct ncr5380_softc *);
void si_obio_dma_start(struct ncr5380_softc *);
void si_obio_dma_eop(struct ncr5380_softc *);
void si_obio_dma_stop(struct ncr5380_softc *);
d227 2
a228 2
void si_obio_intr_on(struct ncr5380_softc *);
void si_obio_intr_off(struct ncr5380_softc *);
d451 1
a451 1
		intr_establish(ra->ra_intr[0].int_pri, &sc->sc_ih, IPL_BIO);
d459 1
a459 1
		    ra->ra_intr[0].int_pri, &sc->sc_ih, IPL_BIO);
d672 1
a672 1
	dh->dh_addr = (u_char *) addr;
@


1.14.8.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.14.8.1 2002/06/11 03:38:16 art Exp $	*/
d411 1
a411 1
		panic("si_attach: impossible bus type 0x%x", ca->ca_bustype);
@


1.13
log
@vm_offset_t -> {v,p}addr_t and vm_size_t -> {v,p}size_t
remove "register" keywords
Various cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.12 1999/01/11 05:11:56 millert Exp $	*/
d362 1
@


1.13.4.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.14 2000/09/21 17:45:12 mickey Exp $	*/
a361 1
	ncr_sc->sc_link.openings = 4;
@


1.13.4.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d204 22
a225 22
static int	si_match(struct device *, void *, void *);
static void	si_attach(struct device *, struct device *, void *);
static int	si_intr(void *);
static void	si_reset_adapter(struct ncr5380_softc *);
static void	si_minphys(struct buf *);

void si_dma_alloc(struct ncr5380_softc *);
void si_dma_free(struct ncr5380_softc *);
void si_dma_poll(struct ncr5380_softc *);

void si_vme_dma_setup(struct ncr5380_softc *);
void si_vme_dma_start(struct ncr5380_softc *);
void si_vme_dma_eop(struct ncr5380_softc *);
void si_vme_dma_stop(struct ncr5380_softc *);

void si_vme_intr_on(struct ncr5380_softc *);
void si_vme_intr_off(struct ncr5380_softc *);

void si_obio_dma_setup(struct ncr5380_softc *);
void si_obio_dma_start(struct ncr5380_softc *);
void si_obio_dma_eop(struct ncr5380_softc *);
void si_obio_dma_stop(struct ncr5380_softc *);
d227 2
a228 2
void si_obio_intr_on(struct ncr5380_softc *);
void si_obio_intr_off(struct ncr5380_softc *);
d672 1
a672 1
	dh->dh_addr = (u_char *) addr;
@


1.13.4.3
log
@Sync the SMP branch with 3.3
@
text
@d411 1
a411 1
		panic("si_attach: impossible bus type 0x%x", ca->ca_bustype);
d451 1
a451 1
		intr_establish(ra->ra_intr[0].int_pri, &sc->sc_ih, IPL_BIO);
d459 1
a459 1
		    ra->ra_intr[0].int_pri, &sc->sc_ih, IPL_BIO);
@


1.13.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d75 1
a75 1
 * in the 4/100 DMA code.
@


1.12
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.11 1997/09/17 06:47:11 downsj Exp $	*/
d720 2
a721 2
		dvma_mapout((vm_offset_t)dh->dh_dvma,
		    (vm_offset_t)dh->dh_addr, dh->dh_maplen);
@


1.11
log
@NETBSD_CURRENT_970916.  Lot's just ID changes, since changes don't apply to
us.  Includes some pmap changes, for which I don't have the original commit
message(s) handy.
@
text
@d1 1
a1 1
/*	$OpenBSD: si.c,v 1.10 1997/08/08 08:25:29 downsj Exp $	*/
d434 1
a434 1
		panic("si: dma handle malloc failed\n");
d658 1
a658 1
		panic("si_dma_alloc: xlen=0x%x\n", xlen);
@


1.10
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: si.c,v 1.37 1997/07/29 09:58:13 fair Exp $	*/
@


1.9
log
@Turn off si driver's dma by default.  Unfortunately, DMA doesn't work.
@
text
@d1 2
a2 1
/*	$NetBSD: si.c,v 1.24 1996/05/13 01:53:45 thorpej Exp $	*/
d4 2
a5 4
/*
 * Copyright (c) 1995 Jason R. Thorpe
 * Copyright (c) 1995 David Jones, Gordon W. Ross
 * Copyright (c) 1994 Adam Glass
d8 3
d19 1
a19 3
 * 3. The name of the authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 * 4. All advertising materials mentioning features or use of this software
d21 17
a37 13
 *      This product includes software developed by
 *      Adam Glass, David Jones, Gordon Ross, and Jason R. Thorpe
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d115 1
d198 1
a198 1
int si_options = 0;		/* XXX SI_ENABLE_DMA when dma works */
a208 1
static int	si_print __P((void *, const char *));
d266 1
a266 11
si_print(aux, name)
	void *aux;
	const char *name;
{
	if (name != NULL)
		printf("%s: scsibus ", name);
	return UNCONF;
}

static int
si_match(parent, vcf, args)
d268 1
a268 1
	void		*vcf, *args;
d270 2
a271 2
	struct cfdata	*cf = vcf;
	struct confargs *ca = args;
d293 2
a294 1
		if (strcmp(ra->ra_name, "si") || cpumod == SUN4_100)
d300 2
a301 1
		if (strcmp(ra->ra_name, "sw") || cpumod != SUN4_100)
d340 7
a346 3
	/* Pull in the options flags. */
	if (ca->ca_bustype == BUS_OBIO)
		sc->sc_options = sw_options;
d348 2
a349 3
		sc->sc_options = si_options;
	sc->sc_options |=
	    (ncr_sc->sc_dev.dv_cfdata->cf_flags & SI_OPTIONS_MASK);
d352 2
a353 2
	regs = (struct si_regs *)mapiodev(ra->ra_reg, 0,
	    sizeof(struct si_regs), ca->ca_bustype);
d415 1
a415 1
	if (sc->sc_options & SI_DO_RESELECT)
d496 1
a496 1
	config_found(self, &(ncr_sc->sc_link), si_print);
d507 1
a507 1
			printf("si_minphys len = %x.\n", MAX_DMA_LEN);
a659 15
	/*
	 * XXX SUN4 doesn't have this limitation?
	 * Never attempt single transfers of more than 63k, because
	 * our count register may be only 16 bits (an OBIO adapter).
	 * This should never happen since already bounded by minphys().
	 * XXX - Should just segment these...
	 */
	if (xlen > MAX_DMA_LEN) {
		printf("si_dma_alloc: excessive xlen=0x%x\n", xlen);
#ifdef DEBUG
		Debugger();
#endif
		ncr_sc->sc_datalen = xlen = MAX_DMA_LEN;
	}

d688 1
a688 1
		printf("si_dma_alloc: can't remap %p/%x, doing PIO\n",
@


1.8
log
@added const to second parameter of cfprint_t routines
@
text
@d193 1
a193 1
int si_options = SI_ENABLE_DMA;
@


1.7
log
@netbsd port, now we merge our changes back in
@
text
@d204 1
a204 1
static int	si_print __P((void *, char *));
d264 1
a264 1
	char *name;
@


1.6
log
@from netbsd;
New generic disk framework.  Highlights:
New metrics handling.  Metrics are now kept in the new `struct disk'.
Busy time is now stored as a timeval, and transfer count in bytes.
Storage for disklabels is now dynamically allocated, so that the size
of the disk structure is not machine-dependent.
Several new functions for attaching and detaching disks, and handling
metrics calculation.
Old-style instrumentation is still supported in drivers that did it
before.  However, old-style instrumentation is being deprecated, and
will go away once the userland utilities are updated for the new
framework.
For usage and architectural details, see the forthcoming disk(9)
manual page.
@
text
@d1 1
a1 1
/*	$NetBSD: si.c,v 1.8 1996/01/01 22:40:56 thorpej Exp $	*/
d70 2
a71 1
 * for the sake of testing.
d120 2
a140 4
#ifndef DEBUG
#define DEBUG XXX
#endif

d182 5
d194 1
d204 1
d244 6
a249 3
struct cfdriver sicd = {
	NULL, "si", si_match, si_attach,
	DV_DULL, sizeof(struct si_softc), NULL, 0,
d253 6
a258 3
struct cfdriver swcd = {
	NULL, "sw", si_match, si_attach,
	DV_DULL, sizeof(struct si_softc), NULL, 0,
d278 1
a278 1
	struct romaux *ra = &ca->ca_ra; 
d285 1
a285 1
	if (cputyp != CPU_SUN4)
d298 3
d305 1
a305 1
		if (cpumod != SUN4_100)
d308 4
d345 6
a350 11
	if (ca->ca_bustype == BUS_OBIO) {
	/*
	 * XXX Interrupts and reselect don't work on the "sw".
		 * I don't know why (yet).  Disable DMA by default, too.
		 * It's still a little dangerous.
	 */
		sc->sc_options = ncr_sc->sc_dev.dv_cfdata->cf_flags &
		    SI_OPTIONS_MASK;
	} else
		sc->sc_options =
	 ((ncr_sc->sc_dev.dv_cfdata->cf_flags | si_options) & SI_OPTIONS_MASK);
d409 4
d463 4
d469 1
a469 1
	if (sc->sc_options)
d471 2
a472 2
		    sc->sc_options, SI_OPTIONS_BITS);

d475 1
a475 1
		printf("si: Set TheSoftC=%x TheRegs=%x\n", sc, regs);
d704 1
a704 1
		printf("si_dma_alloc: can't remap %x/%x, doing PIO\n",
a757 1
	struct si_dma_handle *dh = sr->sr_dma_hand;
d888 1
a888 1
		panic("si_dma_start: bad pa=0x%x", data_pa);
d895 1
a895 1
		printf("si_dma_start: dh=0x%x, pa=0x%x, xlen=%d\n",
d919 1
a919 1
	
d1021 3
a1023 3
	 * one byte and needs to be incremented.  This is
	 * true if we have not transferred either all data
	 * or no data.  XXX - from Matt Jacob
d1027 3
d1189 1
a1189 1
		panic("si_dma_start: bad pa=0x%x", data_pa);
d1196 1
a1196 1
		printf("si_dma_start: dh=0x%x, pa=0x%x, xlen=%d\n",
d1287 13
d1322 13
d1336 3
d1390 6
a1395 3
			cp[-3] = (si->sw_bpr & 0xff000000) >> 24;
			cp[-2] = (si->sw_bpr & 0x00ff0000) >> 16;
			cp[-1] = (si->sw_bpr & 0x0000ff00) >> 8;
d1399 5
a1403 2
			cp[-2] = (si->sw_bpr & 0xff000000) >> 24;
			cp[-1] = (si->sw_bpr & 0x00ff0000) >> 16;
d1407 9
a1415 1
			cp[-1] = (si->sw_bpr & 0xff000000) >> 24;
d1417 1
@


1.5
log
@from netbsd; = not ==
@
text
@d326 1
a326 3
	sc->sc_options =
	 ((ncr_sc->sc_dev.dv_cfdata->cf_flags | si_options) & SI_OPTIONS_MASK);

d329 2
a330 1
	 * I don't know why (yet).  -- thorpej
d332 5
a336 2
	if (ca->ca_bustype == BUS_OBIO)
		sc->sc_options &= ~(SI_DMA_INTR|SI_DO_RESELECT);
@


1.4
log
@mi 5380 driver
@
text
@d281 1
a281 1
		ra->ra_intr[0].int_pri == 3;
@


1.3
log
@new mapdev/()/mapiodev() calling convention uses "struct rom_reg *" to supply
base plus an offset
new dvma routines
@
text
@d1 1
a1 1
/*	$NetBSD: si.c,v 1.6 1995/09/14 20:38:56 pk Exp $	*/
d4 3
a6 4
 * Copyright (C) 1994 Adam Glass, Gordon W. Ross
 * Copyright (C) 1993	Allen K. Briggs, Chris P. Caputo,
 *			Michael L. Finch, Bradley A. Grantham, and
 *			Lawrence A. Kesteloot
d17 3
a19 1
 * 3. All advertising materials mentioning features or use of this software
d21 2
a22 4
 *	This product includes software developed by the Alice Group.
 * 4. The names of the Alice Group or any of its members may not be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
d24 1
a24 1
 * THIS SOFTWARE IS PROVIDED BY THE ALICE GROUP ``AS IS'' AND ANY EXPRESS OR
d27 1
a27 1
 * IN NO EVENT SHALL THE ALICE GROUP BE LIABLE FOR ANY DIRECT, INDIRECT,
d32 2
a33 2
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d36 36
a71 1
#define DEBUG 1
d73 16
a88 2
/* XXX - Need to add support for real DMA. -gwr */
/* #define PSEUDO_DMA 1 (broken) */
a90 1
#include <sys/malloc.h>
d93 2
d96 1
d100 4
a103 1
#include <sys/device.h>
d109 9
a117 3
#include <scsi/scsi_all.h>
#include <scsi/scsi_debug.h>
#include <scsi/scsiconf.h>
d121 1
d124 18
d143 2
a144 2
static int ncr5380_debug = 0;
static int si_flags = 0 /* | SDEV_DB2 */ ;
d147 47
a195 1
static int	si_print __P((void *, char *));
d197 2
a198 2
static void	si_dma_intr __P((struct ncr5380_softc *));
static int	reset_adapter __P((struct ncr5380_softc *));
d200 16
d217 2
a218 1
static char scsi_name[] = "si";
d220 1
a220 1
struct scsi_adapter	ncr5380_switch = {
d222 1
a222 1
	minphys,			/* scsi_minphys()	*/
d229 5
a233 5
struct scsi_device si_dev = {
	NULL,		/* Use default error handler. */
	NULL,		/* Use default start handler. */
	NULL,		/* Use default async handler. */
	NULL,		/* Use default "done" routine.*/
d236 2
d239 2
a240 2
	NULL, "si", si_match, si_attach, DV_DULL,
	sizeof(struct ncr5380_softc), NULL, 0,
d243 1
a243 6
/*
 * An `sw' is just an `si' behind a different DMA engine.
 * This driver doesn't currently do DMA, so we can more or less
 * handle it here.  (It's really not much different than the
 * Sun 3/50 SCSI controller, if I understand it right.)
 */
d245 2
a246 2
	NULL, "sw", si_match, si_attach, DV_DULL,
	sizeof(struct ncr5380_softc), NULL, 0,
d260 1
a260 1
si_match(parent, vcf, aux)
d262 1
a262 2
	void		*vcf;
	void		*aux;
d265 2
a266 2
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;
d276 7
d289 1
a289 1
		/* An `sw' can only exist on the 4/100 obio. */
a294 4
	/* Default interrupt priority always splbio == 2 */
	if (ra->ra_intr[0].int_pri == -1)
		ra->ra_intr[0].int_pri == 2;

d300 4
a303 5
	 * If we're looking for an `si', we have to determine whether
	 * it is an `sc' (Sun2) or `si' (Sun3) SCSI board.  This can be
	 * determined using the fact that the `sc' board occupies 4K bytes
	 * in VME space but the `si' board occupies 2K bytes.
	 * Note that the `si' board should NOT respond to this.
d313 1
a313 1
si_attach(parent, self, aux)
d315 1
a315 1
	void		*aux;
d317 2
a318 1
	struct ncr5380_softc *ncr5380 = (struct ncr5380_softc *) self;
d320 1
a320 1
	struct confargs *ca = aux;
d323 12
d340 82
d423 2
a424 2
	ncr5380->sc_ih.ih_fun = si_intr;
	ncr5380->sc_ih.ih_arg = ncr5380;
d427 1
a427 1
	case BUS_VME16:
d429 1
a429 1
		 * This will be an `si'.
d431 1
a431 4
		vmeintr_establish(ra->ra_intr[0].int_vec,
		    ra->ra_intr[0].int_pri, &ncr5380->sc_ih);
		ncr5380->sc_adapter_iv_am =
		    VME_SUPV_DATA_24 | (ra->ra_intr[0].int_vec & 0xFF);
d434 1
a434 1
	case BUS_OBIO:
d436 1
a436 1
		 * This will be an `sw'.
d438 4
a441 1
		intr_establish(ra->ra_intr[0].int_pri, &ncr5380->sc_ih);
d444 4
d449 5
a453 2
	ncr5380->sc_adapter_type = ca->ca_bustype;
	ncr5380->sc_regs = regs;
d456 1
a456 1
	 * fill in the prototype scsi_link.
d458 3
a460 12
	ncr5380->sc_link.adapter_softc = ncr5380;
	ncr5380->sc_link.adapter_target = 7;
	ncr5380->sc_link.adapter = &ncr5380_switch;
	ncr5380->sc_link.device = &si_dev;
	ncr5380->sc_link.openings = 2;
#ifdef	DEBUG
	ncr5380->sc_link.flags |= si_flags;
#endif

	printf(" pri %d\n", ra->ra_intr[0].int_pri);
	reset_adapter(ncr5380);
	ncr5380_reset_scsibus(ncr5380);
d469 1
a469 1
	    bp->val[0] == -1 && bp->val[1] == ncr5380->sc_dev.dv_unit)
d473 1
a473 1
	config_found(self, &(ncr5380->sc_link), si_print);
d479 1
a479 2
si_dma_intr(ncr5380)
	struct ncr5380_softc *ncr5380;
d481 6
a486 4
	volatile struct si_regs *regs = ncr5380->sc_regs;

#ifdef	DEBUG
	printf (" si_dma_intr\n");
d488 3
d493 3
d497 1
a497 2
si_intr(arg)
	void *arg;
d499 4
a502 3
	struct ncr5380_softc *ncr5380 = arg;
	volatile struct si_regs *si = ncr5380->sc_regs;
	int rv = 0;
d504 24
a527 15
	switch (ncr5380->sc_adapter_type) {
	case BUS_VME16:
		/* Interrupts not enabled?  Can not be for us. */
		if ((si->si_csr & SI_CSR_INTR_EN) == 0)
			return rv;

		if (si->si_csr & SI_CSR_DMA_IP) {
			si_dma_intr(ncr5380);
			rv++;
		}
		if (si->si_csr & SI_CSR_SBC_IP) {
			ncr5380_sbc_intr(ncr5380);
			rv++;
		}
		break;
d529 8
a536 8
	case BUS_OBIO:
		/* Interrupts not enabled?  Can not be for us. */
		if ((si->sw_csr & SI_CSR_INTR_EN) == 0)
			return rv;

		if (si->sw_csr & SI_CSR_DMA_IP) {
			si_dma_intr(ncr5380);
			rv++;
d538 1
a538 5
		if (si->sw_csr & SI_CSR_SBC_IP) {
			ncr5380_sbc_intr(ncr5380);
			rv++;
		}
		break;
d541 1
a541 1
	return rv;
d544 3
a546 3
static int
reset_adapter(sc)
	struct ncr5380_softc *sc;
d548 1
d552 2
a553 2
	if (ncr5380_debug) {
		printf("reset_adapter\n");
d557 6
a564 1
		/* The reset bits in the CSR are active low. */
d566 3
a568 2
		delay(20);
		si->si_csr = SI_CSR_FIFO_RES | SI_CSR_SCSI_RES;
d574 2
a575 1
		si->iv_am = sc->sc_adapter_iv_am;
d580 2
a581 2
		delay(20);
		si->sw_csr = SI_CSR_FIFO_RES | SI_CSR_SCSI_RES;
d584 2
d588 2
a591 1
#include <dev/ic/ncr5380.c>
d593 772
@


1.2
log
@remove a bunch of stupid 4/100 and bustype checks
@
text
@d185 1
a185 1
	regs = (struct si_regs *)mapiodev(ra->ra_paddr,
@


1.1
log
@Initial revision
@
text
@a141 3
		/* AFAIK, the `si' can only exist on the vmes. */
		if (strcmp(ra->ra_name, "si") || cpumod == SUN4_100)
			return (0);
d145 2
a146 2
		/* AFAIK, an `sw' can only exist on the obio. */
		if (strcmp(ra->ra_name, "sw") || cpumod != SUN4_100)
a148 4

	default:
		/* Don't know what we ended up with ... */
		return (0);
a208 4

	default:
		printf("\n");
		panic("si_attach: unknown bus type 0x%x", ca->ca_bustype);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
