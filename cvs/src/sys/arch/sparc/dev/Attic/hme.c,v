head	1.80;
access;
symbols
	OPENBSD_6_0:1.79.0.2
	OPENBSD_6_0_BASE:1.79
	OPENBSD_5_9:1.78.0.2
	OPENBSD_5_9_BASE:1.78
	OPENBSD_5_8:1.71.0.4
	OPENBSD_5_8_BASE:1.71
	OPENBSD_5_7:1.67.0.2
	OPENBSD_5_7_BASE:1.67
	OPENBSD_5_6:1.66.0.4
	OPENBSD_5_6_BASE:1.66
	OPENBSD_5_5:1.64.0.4
	OPENBSD_5_5_BASE:1.64
	OPENBSD_5_4:1.62.0.16
	OPENBSD_5_4_BASE:1.62
	OPENBSD_5_3:1.62.0.14
	OPENBSD_5_3_BASE:1.62
	OPENBSD_5_2:1.62.0.12
	OPENBSD_5_2_BASE:1.62
	OPENBSD_5_1_BASE:1.62
	OPENBSD_5_1:1.62.0.10
	OPENBSD_5_0:1.62.0.8
	OPENBSD_5_0_BASE:1.62
	OPENBSD_4_9:1.62.0.6
	OPENBSD_4_9_BASE:1.62
	OPENBSD_4_8:1.62.0.4
	OPENBSD_4_8_BASE:1.62
	OPENBSD_4_7:1.62.0.2
	OPENBSD_4_7_BASE:1.62
	OPENBSD_4_6:1.60.0.4
	OPENBSD_4_6_BASE:1.60
	OPENBSD_4_5:1.58.0.2
	OPENBSD_4_5_BASE:1.58
	OPENBSD_4_4:1.55.0.10
	OPENBSD_4_4_BASE:1.55
	OPENBSD_4_3:1.55.0.8
	OPENBSD_4_3_BASE:1.55
	OPENBSD_4_2:1.55.0.6
	OPENBSD_4_2_BASE:1.55
	OPENBSD_4_1:1.55.0.4
	OPENBSD_4_1_BASE:1.55
	OPENBSD_4_0:1.55.0.2
	OPENBSD_4_0_BASE:1.55
	OPENBSD_3_9:1.51.0.2
	OPENBSD_3_9_BASE:1.51
	OPENBSD_3_8:1.49.0.2
	OPENBSD_3_8_BASE:1.49
	OPENBSD_3_7:1.47.0.2
	OPENBSD_3_7_BASE:1.47
	OPENBSD_3_6:1.43.0.2
	OPENBSD_3_6_BASE:1.43
	SMP_SYNC_A:1.42
	SMP_SYNC_B:1.42
	OPENBSD_3_5:1.42.0.4
	OPENBSD_3_5_BASE:1.42
	OPENBSD_3_4:1.42.0.2
	OPENBSD_3_4_BASE:1.42
	UBC_SYNC_A:1.40
	OPENBSD_3_3:1.40.0.2
	OPENBSD_3_3_BASE:1.40
	OPENBSD_3_2:1.38.0.2
	OPENBSD_3_2_BASE:1.38
	OPENBSD_3_1:1.35.0.2
	OPENBSD_3_1_BASE:1.35
	UBC_SYNC_B:1.39
	UBC:1.34.0.4
	UBC_BASE:1.34
	OPENBSD_3_0:1.34.0.2
	OPENBSD_3_0_BASE:1.34
	OPENBSD_2_9_BASE:1.31
	OPENBSD_2_9:1.31.0.2
	OPENBSD_2_8:1.23.0.2
	OPENBSD_2_8_BASE:1.23
	OPENBSD_2_7:1.21.0.4
	OPENBSD_2_7_BASE:1.21
	SMP:1.21.0.2
	SMP_BASE:1.21
	kame_19991208:1.20
	OPENBSD_2_6:1.20.0.2
	OPENBSD_2_6_BASE:1.20
	OPENBSD_2_5:1.18.0.2
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12;
locks; strict;
comment	@ * @;


1.80
date	2016.09.01.09.23.42;	author tedu;	state dead;
branches;
next	1.79;
commitid	Q2PxaFNhqAe0Wmla;

1.79
date	2016.04.13.11.34.00;	author mpi;	state Exp;
branches;
next	1.78;
commitid	RI1iBTF6Zaycxppg;

1.78
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.77;
commitid	J9apD0jq2AjFmqZc;

1.77
date	2015.11.25.11.20.38;	author mpi;	state Exp;
branches;
next	1.76;
commitid	f4dx5ry1aOiKJw33;

1.76
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.75;
commitid	B0kwmVGiD5DVx4kv;

1.75
date	2015.11.24.17.11.38;	author mpi;	state Exp;
branches;
next	1.74;
commitid	5gdEnqVoJuTuwdTu;

1.74
date	2015.11.24.13.33.18;	author mpi;	state Exp;
branches;
next	1.73;
commitid	5DvsamK0GblTp8ww;

1.73
date	2015.11.14.17.26.40;	author mpi;	state Exp;
branches;
next	1.72;
commitid	BU9j1tIQLqhcXEX9;

1.72
date	2015.10.25.13.22.09;	author mpi;	state Exp;
branches;
next	1.71;
commitid	n8mxDftG1cK0Rpp7;

1.71
date	2015.07.08.07.21.49;	author mpi;	state Exp;
branches;
next	1.70;
commitid	9ERVupAoYqW4Iok9;

1.70
date	2015.06.24.09.40.53;	author mpi;	state Exp;
branches;
next	1.69;
commitid	MVWrtktB46JRxFWT;

1.69
date	2015.04.13.08.45.48;	author mpi;	state Exp;
branches;
next	1.68;
commitid	aiRvgNOa4qke9vft;

1.68
date	2015.04.08.10.07.47;	author mpi;	state Exp;
branches;
next	1.67;
commitid	hnmA6leYzflFI0c3;

1.67
date	2014.12.22.02.26.54;	author tedu;	state Exp;
branches;
next	1.66;
commitid	2Ez9mHW0jDzojG4V;

1.66
date	2014.07.22.10.35.35;	author mpi;	state Exp;
branches;
next	1.65;
commitid	EXpEDqO4x724IPl8;

1.65
date	2014.04.22.15.52.05;	author naddy;	state Exp;
branches;
next	1.64;

1.64
date	2013.09.05.20.55.58;	author bluhm;	state Exp;
branches;
next	1.63;

1.63
date	2013.08.21.05.21.42;	author dlg;	state Exp;
branches;
next	1.62;

1.62
date	2009.08.13.17.01.31;	author phessler;	state Exp;
branches;
next	1.61;

1.61
date	2009.07.16.07.18.47;	author sthen;	state Exp;
branches;
next	1.60;

1.60
date	2009.06.24.07.42.03;	author sthen;	state Exp;
branches;
next	1.59;

1.59
date	2009.06.20.09.40.29;	author sthen;	state Exp;
branches;
next	1.58;

1.58
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.57;

1.57
date	2008.10.14.18.01.53;	author naddy;	state Exp;
branches;
next	1.56;

1.56
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.55;

1.55
date	2006.06.25.21.53.44;	author brad;	state Exp;
branches;
next	1.54;

1.54
date	2006.06.02.20.00.54;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2006.05.27.23.59.07;	author jason;	state Exp;
branches;
next	1.52;

1.52
date	2006.03.25.22.41.41;	author djm;	state Exp;
branches;
next	1.51;

1.51
date	2006.01.12.15.06.12;	author brad;	state Exp;
branches;
next	1.50;

1.50
date	2005.11.09.06.14.50;	author brad;	state Exp;
branches;
next	1.49;

1.49
date	2005.06.08.17.03.02;	author henning;	state Exp;
branches;
next	1.48;

1.48
date	2005.04.25.17.55.50;	author brad;	state Exp;
branches;
next	1.47;

1.47
date	2005.02.22.20.44.26;	author brad;	state Exp;
branches;
next	1.46;

1.46
date	2005.01.15.05.24.10;	author brad;	state Exp;
branches;
next	1.45;

1.45
date	2004.09.29.07.35.11;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2004.09.28.00.21.23;	author brad;	state Exp;
branches;
next	1.43;

1.43
date	2004.08.08.19.01.20;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2003.06.18.19.11.49;	author jason;	state Exp;
branches;
next	1.41;

1.41
date	2003.06.02.18.40.59;	author jason;	state Exp;
branches;
next	1.40;

1.40
date	2002.11.09.22.22.35;	author fgsch;	state Exp;
branches;
next	1.39;

1.39
date	2002.10.05.21.19.35;	author fgsch;	state Exp;
branches;
next	1.38;

1.38
date	2002.07.17.02.46.52;	author jason;	state Exp;
branches;
next	1.37;

1.37
date	2002.06.07.23.34.54;	author jason;	state Exp;
branches;
next	1.36;

1.36
date	2002.04.30.01.12.29;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2002.03.14.01.26.43;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2001.08.24.05.14.05;	author jason;	state Exp;
branches
	1.34.4.1;
next	1.33;

1.33
date	2001.07.30.21.50.06;	author jason;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.26.21.58.48;	author fgsch;	state Exp;
branches;
next	1.31;

1.31
date	2001.02.20.19.39.34;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2001.01.30.07.19.52;	author jason;	state Exp;
branches;
next	1.29;

1.29
date	2001.01.30.04.46.25;	author jason;	state Exp;
branches;
next	1.28;

1.28
date	2001.01.23.16.47.47;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	2000.11.28.23.14.05;	author jason;	state Exp;
branches;
next	1.26;

1.26
date	2000.11.28.05.12.18;	author jason;	state Exp;
branches;
next	1.25;

1.25
date	2000.11.28.05.04.32;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2000.11.28.04.23.16;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2000.06.18.17.42.18;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2000.06.18.17.37.02;	author jason;	state Exp;
branches;
next	1.21;

1.21
date	99.12.10.03.03.56;	author jason;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	99.08.20.04.55.03;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	99.04.18.03.13.14;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	99.02.23.23.44.48;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	99.02.06.03.42.57;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	99.01.31.21.56.46;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	99.01.07.03.14.42;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	98.12.14.17.37.24;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	98.11.11.00.26.00;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	98.10.02.17.42.24;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	98.09.24.22.16.37;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	98.09.16.22.02.05;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	98.09.10.22.15.21;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	98.09.10.17.34.32;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	98.09.09.19.23.34;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	98.09.08.04.48.38;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	98.09.01.17.36.59;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	98.07.17.21.33.07;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	98.07.13.02.27.41;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	98.07.10.19.20.13;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	98.07.10.19.09.08;	author jason;	state Exp;
branches;
next	;

1.21.2.1
date	2001.05.14.21.37.05;	author niklas;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2001.07.04.10.23.23;	author niklas;	state Exp;
branches;
next	1.21.2.3;

1.21.2.3
date	2001.10.31.03.07.56;	author nate;	state Exp;
branches;
next	1.21.2.4;

1.21.2.4
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.21.2.5;

1.21.2.5
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.21.2.6;

1.21.2.6
date	2003.06.07.11.14.43;	author ho;	state Exp;
branches;
next	1.21.2.7;

1.21.2.7
date	2004.02.19.10.49.57;	author niklas;	state Exp;
branches;
next	;

1.34.4.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	1.34.4.2;

1.34.4.2
date	2002.10.29.00.28.09;	author art;	state Exp;
branches;
next	1.34.4.3;

1.34.4.3
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.80
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: hme.c,v 1.79 2016/04/13 11:34:00 mpi Exp $	*/

/*
 * Copyright (c) 1998 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Driver for the Happy Meal (hme) ethernet boards
 * Based on information gleaned from reading the
 *	S/Linux driver by David Miller
 *
 * Thanks go to the University of North Carolina at Greensboro, Systems
 * and Networks Department for some of the resources used to develop
 * this driver.
 */

#include "bpfilter.h"
#include "vlan.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/syslog.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/autoconf.h>
#include <sparc/cpu.h>
#include <sparc/sparc/cpuvar.h>
#include <sparc/dev/sbusvar.h>
#include <sparc/dev/dmareg.h>	/* for SBUS_BURST_* */
#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#include <sparc/dev/hmereg.h>
#include <sparc/dev/hmevar.h>

int	hmematch(struct device *, void *, void *);
void	hmeattach(struct device *, struct device *, void *);
void	hmewatchdog(struct ifnet *);
int	hmeintr(void *);
int	hmeioctl(struct ifnet *, u_long, caddr_t);
void	hmereset(struct hme_softc *);
void	hmestart(struct ifnet *);
void	hmestop(struct hme_softc *);
void	hmeinit(struct hme_softc *);
void	hme_meminit(struct hme_softc *);

void	hme_tick(void *);

void	hme_tcvr_bb_writeb(struct hme_softc *, int);
int	hme_tcvr_bb_readb(struct hme_softc *, int);

void	hme_poll_stop(struct hme_softc *sc);

int	hme_rint(struct hme_softc *);
int	hme_tint(struct hme_softc *);
int	hme_mint(struct hme_softc *, u_int32_t);
int	hme_eint(struct hme_softc *, u_int32_t);

void	hme_reset_rx(struct hme_softc *);
void	hme_reset_tx(struct hme_softc *);

void	hme_read(struct hme_softc *, int, int, u_int32_t);
int	hme_put(struct hme_softc *, int, struct mbuf *);

/*
 * ifmedia glue
 */
int	hme_mediachange(struct ifnet *);
void	hme_mediastatus(struct ifnet *, struct ifmediareq *);

/*
 * mii glue
 */
int	hme_mii_read(struct device *, int, int);
void	hme_mii_write(struct device *, int, int, int);
void	hme_mii_statchg(struct device *);

void	hme_iff(struct hme_softc *);

struct cfattach hme_ca = {
	sizeof (struct hme_softc), hmematch, hmeattach
};

struct cfdriver hme_cd = {
	NULL, "hme", DV_IFNET
};

int
hmematch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
	register struct romaux *ra = &ca->ca_ra;

	if (strcmp(cf->cf_driver->cd_name, ra->ra_name) &&
	    strcmp("SUNW,hme", ra->ra_name) &&
	    strcmp("SUNW,qfe", ra->ra_name)) {
		return (0);
	}
	if (!sbus_testdma((struct sbus_softc *)parent, ca))
		return(0);
	return (1);
}

void
hmeattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct confargs *ca = aux;
	struct hme_softc *sc = (struct hme_softc *)self;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int pri;
	struct bootpath *bp;
	/* XXX the following declaration should be elsewhere */
	extern void myetheraddr(u_char *);

	if (ca->ca_ra.ra_nintr != 1) {
		printf(": expected 1 interrupt, got %d\n",
			ca->ca_ra.ra_nintr);
		return;
	}
	pri = ca->ca_ra.ra_intr[0].int_pri;

	/* map registers */
	if (ca->ca_ra.ra_nreg != 5) {
		printf(": expected 5 registers, got %d\n", ca->ca_ra.ra_nreg);
		return;
	}
	sc->sc_gr = mapiodev(&(ca->ca_ra.ra_reg[0]), 0,
			ca->ca_ra.ra_reg[0].rr_len);
	sc->sc_txr = mapiodev(&(ca->ca_ra.ra_reg[1]), 0,
			ca->ca_ra.ra_reg[1].rr_len);
	sc->sc_rxr = mapiodev(&(ca->ca_ra.ra_reg[2]), 0,
			ca->ca_ra.ra_reg[2].rr_len);
	sc->sc_cr = mapiodev(&(ca->ca_ra.ra_reg[3]), 0,
			ca->ca_ra.ra_reg[3].rr_len);
	sc->sc_tcvr = mapiodev(&(ca->ca_ra.ra_reg[4]), 0,
			ca->ca_ra.ra_reg[4].rr_len);

	sc->sc_node = ca->ca_ra.ra_node;

	sc->sc_rev = getpropint(ca->ca_ra.ra_node, "hm-rev", -1);
	if (sc->sc_rev == 0xff)
		sc->sc_rev = 0xa0;
	if (sc->sc_rev == 0x20 || sc->sc_rev == 0x21)
		sc->sc_flags = HME_FLAG_20_21;
	else if (sc->sc_rev != 0xa0)
		sc->sc_flags = HME_FLAG_NOT_A0;

	sc->sc_burst = getpropint(ca->ca_ra.ra_node, "burst-sizes", -1);
	if (sc->sc_burst == -1)
		sc->sc_burst = ((struct sbus_softc *)parent)->sc_burst;

	/* Clamp at parent's burst sizes */
	sc->sc_burst &= ((struct sbus_softc *)parent)->sc_burst;

	hme_meminit(sc);

	sc->sc_ih.ih_fun = hmeintr;
	sc->sc_ih.ih_arg = sc;
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih, IPL_NET,
	    self->dv_xname);

	/*
	 * Get MAC address from card if 'local-mac-address' property exists.
	 * Otherwise, use the machine's builtin MAC.
	 */
	if (getprop(ca->ca_ra.ra_node, "local-mac-address",
	    sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN) <= 0) {
		myetheraddr(sc->sc_arpcom.ac_enaddr);
	}

	printf(" pri %d: address %s rev %d\n", pri,
	    ether_sprintf(sc->sc_arpcom.ac_enaddr), sc->sc_rev);

	sc->sc_mii.mii_ifp = ifp;
	sc->sc_mii.mii_readreg = hme_mii_read;
	sc->sc_mii.mii_writereg = hme_mii_write;
	sc->sc_mii.mii_statchg = hme_mii_statchg;
	ifmedia_init(&sc->sc_mii.mii_media, IFM_IMASK, hme_mediachange,
	    hme_mediastatus);
	mii_phy_probe(self, &sc->sc_mii, 0xffffffff);

	if (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER | IFM_NONE,
		    0, NULL);
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER | IFM_NONE);
	}
	else
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER | IFM_AUTO);

	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_start = hmestart;
	ifp->if_ioctl = hmeioctl;
	ifp->if_watchdog = hmewatchdog;
	ifp->if_flags =
		IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_capabilities = IFCAP_VLAN_MTU;
	IFQ_SET_MAXLEN(&ifp->if_snd, HME_TX_RING_SIZE);

	/* Attach the interface. */
	if_attach(ifp);
	ether_ifattach(ifp);

	bp = ca->ca_ra.ra_bp;
	if (bp != NULL && sc->sc_dev.dv_unit == bp->val[1] &&
	    ((strcmp(bp->name, hme_cd.cd_name) == 0) ||
	     (strcmp(bp->name, "qfe") == 0) ||
	     (strcmp(bp->name, "SUNW,hme") == 0)))
		bp->dev = &sc->sc_dev;

	timeout_set(&sc->sc_tick, hme_tick, sc);
}

/*
 * Start output on interface.
 * We make two assumptions here:
 *  1) that the current priority is set to splnet _before_ this code
 *     is called *and* is returned to the appropriate priority after
 *     return
 *  2) that the IFF_OACTIVE flag is checked before this code is called
 *     (i.e. that the output part of the interface is idle)
 */
void
hmestart(ifp)
	struct ifnet *ifp;
{
	struct hme_softc *sc = ifp->if_softc;
	struct mbuf *m;
	int bix, len;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	bix = sc->sc_last_td;

	for (;;) {
		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;
#if NBPFILTER > 0
		/*
		 * If BPF is listening on this interface, let it see the
		 * packet before we commit it to the wire.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

		/*
		 * Copy the mbuf chain into the transmit buffer.
		 */
		len = hme_put(sc, bix, m);

		/*
		 * Initialize transmit registers and start transmission.
		 */
		sc->sc_desc->hme_txd[bix].tx_flags =
		    HME_TXD_OWN | HME_TXD_SOP | HME_TXD_EOP |
		    (len & HME_TXD_SIZE);
		sc->sc_txr->tx_pnding = TXR_TP_DMAWAKEUP;

		if (++bix == HME_TX_RING_SIZE)
			bix = 0;

		if (++sc->sc_no_td == HME_TX_RING_SIZE) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}
	}

	sc->sc_last_td = bix;
}

#define MAX_STOP_TRIES	16

void
hmestop(sc)
	struct hme_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int tries = 0;

	timeout_del(&sc->sc_tick);

	/*
	 * Mark the interface down and cancel the watchdog timer.
	 */
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_timer = 0;

	mii_down(&sc->sc_mii);

	sc->sc_gr->reset = GR_RESET_ALL;
	while (sc->sc_gr->reset && (++tries != MAX_STOP_TRIES))
		DELAY(20);
	if (tries == MAX_STOP_TRIES)
		printf("%s: stop failed\n", sc->sc_dev.dv_xname);
}

/*
 * Reset interface.
 */
void
hmereset(sc)
	struct hme_softc *sc;
{
	int s;

	s = splnet();
	hmestop(sc);
	hmeinit(sc);
	splx(s);
}

void
hme_tick(void *arg)
{
	struct hme_softc *sc = arg;
	int s;

	s = splnet();
	mii_tick(&sc->sc_mii);
	splx(s);

	timeout_add_sec(&sc->sc_tick, 1);
}

/*
 * Device timeout/watchdog routine. Entered if the device neglects to generate
 * an interrupt after a transmit has been started on it.
 */
void
hmewatchdog(ifp)
	struct ifnet *ifp;
{
	struct hme_softc *sc = ifp->if_softc;

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	++sc->sc_arpcom.ac_if.if_oerrors;

	hmereset(sc);
}

int
hmeioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct hme_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			hmeinit(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				hmeinit(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				hmestop(sc);
		}
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr,  &sc->sc_mii.mii_media, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			hme_iff(sc);
		error = 0;
	}

	splx(s);
	return (error);
}

void
hme_meminit(sc)
	struct hme_softc *sc;
{
	struct hme_desc *desc;
	int i;

	if (sc->sc_desc_dva == NULL)
		sc->sc_desc_dva = (struct hme_desc *) dvma_malloc(
		    sizeof(struct hme_desc), &sc->sc_desc, M_NOWAIT);
	if (sc->sc_bufs_dva == NULL)
		sc->sc_bufs_dva = (struct hme_bufs *) dvma_malloc(
		    sizeof(struct hme_bufs), &sc->sc_bufs, M_NOWAIT);

	desc = sc->sc_desc;

	/*
	 * Setup TX descriptors
	 */
	sc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;
	for (i = 0; i < HME_TX_RING_SIZE; i++) {
		desc->hme_txd[i].tx_addr =
		    (u_int32_t)sc->sc_bufs_dva->tx_buf[i];
		desc->hme_txd[i].tx_flags = 0;
	}

	/*
	 * Setup RX descriptors
	 */
	sc->sc_last_rd = 0;
	for (i = 0; i < HME_RX_RING_SIZE; i++) {
		desc->hme_rxd[i].rx_addr =
		    (u_int32_t)sc->sc_bufs_dva->rx_buf[i];
		desc->hme_rxd[i].rx_flags = HME_RXD_OWN |
		    ((HME_RX_PKT_BUF_SZ - HME_RX_OFFSET) << 16);
	}
}

void
hmeinit(sc)
	struct hme_softc *sc;
{
	u_int32_t c;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct hme_tcvr *tcvr = sc->sc_tcvr;
	struct hme_cr *cr = sc->sc_cr;
	struct hme_gr *gr = sc->sc_gr;
	struct hme_txr *txr = sc->sc_txr;
	struct hme_rxr *rxr = sc->sc_rxr;

	hme_poll_stop(sc);
	hmestop(sc);

	hme_meminit(sc);

	tcvr->int_mask = 0xffff;

	c = tcvr->cfg;
	if (sc->sc_flags & HME_FLAG_FENABLE)
		tcvr->cfg = c & ~(TCVR_CFG_BENABLE);
	else
		tcvr->cfg = c | TCVR_CFG_BENABLE;

	hme_reset_tx(sc);
	hme_reset_rx(sc);

	cr->rand_seed = sc->sc_arpcom.ac_enaddr[5] |
	    ((sc->sc_arpcom.ac_enaddr[4] << 8) & 0x3f00);
	cr->mac_addr0 = (sc->sc_arpcom.ac_enaddr[0] << 8) |
			   sc->sc_arpcom.ac_enaddr[1];
	cr->mac_addr1 = (sc->sc_arpcom.ac_enaddr[2] << 8) |
			   sc->sc_arpcom.ac_enaddr[3];
	cr->mac_addr2 = (sc->sc_arpcom.ac_enaddr[4] << 8) |
			   sc->sc_arpcom.ac_enaddr[5];
	cr->tx_pkt_max = cr->rx_pkt_max = ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN;

	cr->jsize = HME_DEFAULT_JSIZE;
	cr->ipkt_gap1 = HME_DEFAULT_IPKT_GAP1;
	cr->ipkt_gap2 = HME_DEFAULT_IPKT_GAP2;

	rxr->rx_ring = (u_int32_t)sc->sc_desc_dva->hme_rxd;
	txr->tx_ring = (u_int32_t)sc->sc_desc_dva->hme_txd;

	if (sc->sc_burst & SBUS_BURST_64)
		gr->cfg = GR_CFG_BURST64;
	else if (sc->sc_burst & SBUS_BURST_32)
		gr->cfg = GR_CFG_BURST32;
	else if (sc->sc_burst & SBUS_BURST_16)
		gr->cfg = GR_CFG_BURST16;
	else {
		printf("%s: burst size unknown\n", sc->sc_dev.dv_xname);
		gr->cfg = 0;
	}

	gr->imask = GR_IMASK_SENTFRAME | GR_IMASK_TXPERR |
	              GR_IMASK_GOTFRAME | GR_IMASK_RCNTEXP;

	txr->tx_rsize = (HME_TX_RING_SIZE >> TXR_RSIZE_SHIFT) - 1;
	txr->cfg |= TXR_CFG_DMAENABLE;

	c = RXR_CFG_DMAENABLE | (HME_RX_OFFSET << 3);
#if HME_RX_RING_SIZE == 32
	c |= RXR_CFG_RINGSIZE32;
#elif HME_RX_RING_SIZE == 64
	c |= RXR_CFG_RINGSIZE64;
#elif HME_RX_RING_SIZE == 128
	c |= RXR_CFG_RINGSIZE128;
#elif HME_RX_RING_SIZE == 256
	c |= RXR_CFG_RINGSIZE256;
#else
#error "HME_RX_RING_SIZE must be 32, 64, 128, or 256."
#endif
	rxr->cfg = c;
	DELAY(20);
	if (c != rxr->cfg)	/* the receiver sometimes misses bits */
		printf("%s: setting rxreg->cfg failed.\n", sc->sc_dev.dv_xname);

	cr->rx_cfg = 0;
	hme_iff(sc);
	DELAY(10);

	cr->tx_cfg |= CR_TXCFG_DGIVEUP;

	c = CR_XCFG_ODENABLE;
	if (sc->sc_flags & HME_FLAG_LANCE)
		c |= (HME_DEFAULT_IPKT_GAP0 << 5) | CR_XCFG_LANCE;
	cr->xif_cfg = c;

	cr->tx_cfg |= CR_TXCFG_ENABLE;	/* enable tx */
	cr->rx_cfg |= CR_RXCFG_ENABLE;	/* enable rx */

	mii_mediachg(&sc->sc_mii);

	timeout_add_sec(&sc->sc_tick, 1);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
}

void
hme_poll_stop(sc)
	struct hme_softc *sc;
{
	struct hme_tcvr *tcvr = sc->sc_tcvr;

	/* if not polling, or polling not enabled, we're done. */
	if ((sc->sc_flags & (HME_FLAG_POLLENABLE | HME_FLAG_POLL)) != 
	    (HME_FLAG_POLLENABLE | HME_FLAG_POLL))
		return;

	/* Turn off MIF interrupts, and disable polling */
	tcvr->int_mask = 0xffff;
	tcvr->cfg &= ~(TCVR_CFG_PENABLE);
	sc->sc_flags &= ~(HME_FLAG_POLL);
	DELAY(200);
}

#define RESET_TRIES	32

void
hme_reset_tx(sc)
	struct hme_softc *sc;
{
	int tries = RESET_TRIES;
	struct hme_cr *cr = sc->sc_cr;

	cr->tx_swreset = 0;
	while (--tries && (cr->tx_swreset & 1))
		DELAY(20);

	if (!tries)
		printf("%s: reset tx failed\n", sc->sc_dev.dv_xname);
}

void
hme_reset_rx(sc)
	struct hme_softc *sc;
{
	int tries = RESET_TRIES;
	struct hme_cr *cr = sc->sc_cr;

	cr->rx_swreset = 0;
	while (--tries && (cr->rx_swreset & 1))
		DELAY(20);

	if (!tries)
		printf("%s: reset rx failed\n", sc->sc_dev.dv_xname);
}

/*
 * mif interrupt
 */
int
hme_mint(sc, why)
	struct hme_softc *sc;
	u_int32_t why;
{
	printf("%s: link status changed\n", sc->sc_dev.dv_xname);
	hme_poll_stop(sc);
	return (1);
}

/*
 * transmit interrupt
 */
int
hme_tint(sc)
	struct hme_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct hme_cr *cr = sc->sc_cr;
	int bix;
	struct hme_txd txd;

	/*
	 * Get collision counters
	 */
	ifp->if_collisions += cr->ex_ctr + cr->lt_ctr + cr->fc_ctr + cr->nc_ctr;
	cr->ex_ctr = 0;
	cr->lt_ctr = 0;
	cr->fc_ctr = 0;
	cr->nc_ctr = 0;

	bix = sc->sc_first_td;

	for (;;) {
		if (sc->sc_no_td <= 0)
			break;

		bcopy(&sc->sc_desc->hme_txd[bix], &txd, sizeof(txd));

		if (txd.tx_flags & HME_TXD_OWN)
			break;

		ifq_clr_oactive(&ifp->if_snd);
		ifp->if_opackets++;

		if (++bix == HME_TX_RING_SIZE)
			bix = 0;

		--sc->sc_no_td;
	}

	sc->sc_first_td = bix;

	hmestart(ifp);

	if (sc->sc_no_td == 0)
		ifp->if_timer = 0;

	return (1);
}

int
hme_rint(sc)
	struct hme_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int bix, len;
	struct hme_rxd rxd;

	bix = sc->sc_last_rd;

	for (;;) {
		bcopy(&sc->sc_desc->hme_rxd[bix], &rxd, sizeof(rxd));
		len = rxd.rx_flags >> 16;

		if (rxd.rx_flags & HME_RXD_OWN)
			break;

		if (rxd.rx_flags & HME_RXD_OVERFLOW)
			ifp->if_ierrors++;
		else
			hme_read(sc, bix, len, rxd.rx_flags);

		rxd.rx_flags = HME_RXD_OWN |
		    ((HME_RX_PKT_BUF_SZ - HME_RX_OFFSET) << 16);
		bcopy(&rxd, &sc->sc_desc->hme_rxd[bix], sizeof(rxd));

		if (++bix == HME_RX_RING_SIZE)
			bix = 0;
	}

	sc->sc_last_rd = bix;

	return (1);
}

/*
 * error interrupt
 */
int
hme_eint(sc, why)
	struct hme_softc *sc;
	u_int32_t why;
{
	if (why & GR_STAT_NORXD) {
		sc->sc_arpcom.ac_if.if_ierrors++;
		why &= ~GR_STAT_NORXD;
	}
	if (why & GR_STAT_DTIMEXP) {
		sc->sc_arpcom.ac_if.if_oerrors++;
		why &= ~GR_STAT_DTIMEXP;
	}

	if (why & GR_STAT_ALL_ERRORS) {
		printf("%s: stat=%b, resetting.\n", sc->sc_dev.dv_xname,
		    why, GR_STAT_BITS);
		hmereset(sc);
	}

	return (1);
}

/*
 * Interrupt handler
 */
int
hmeintr(v)
	void *v;
{
	struct hme_softc *sc = (struct hme_softc *)v;
	struct hme_gr *gr = sc->sc_gr;
	u_int32_t why;
	int r = 0;

	why = gr->stat;

	if (why & GR_STAT_ALL_ERRORS)
		r |= hme_eint(sc, why);

	if (why & GR_STAT_MIFIRQ)
		r |= hme_mint(sc, why);

	if (why & (GR_STAT_TXALL | GR_STAT_HOSTTOTX))
		r |= hme_tint(sc);

	if (why & GR_STAT_RXTOHOST)
		r |= hme_rint(sc);

	return (r);
}

int
hme_put(sc, idx, m)
	struct hme_softc *sc;
	int idx;
	struct mbuf *m;
{
	struct mbuf *n;
	u_int8_t *buf = sc->sc_bufs->tx_buf[idx];
	int len, tlen = 0;

	for (; m; m = n) {
		len = m->m_len;
		if (len == 0) {
			n = m_free(m);
			continue;
		}
		bcopy(mtod(m, caddr_t), buf, len);
		buf += len;
		tlen += len;
		n = m_free(m);
	}
	return (tlen);
}

void
hme_read(sc, idx, len, flags)
	struct hme_softc *sc;
	int idx, len;
	u_int32_t flags;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;

	if (len <= sizeof(struct ether_header) ||
	    len > ETHERMTU + sizeof(struct ether_header)) {
		printf("%s: invalid packet size %d; dropping\n",
		    ifp->if_xname, len);
		ifp->if_ierrors++;
		return;
	}

	/* Pull packet off interface. */
	m = m_devget(sc->sc_bufs->rx_buf[idx] + HME_RX_OFFSET, len,
	    HME_RX_OFFSET);
	if (m == NULL) {
		ifp->if_ierrors++;
		return;
	}

	ml_enqueue(&ml, m);
	if_input(ifp, &ml);
}

void
hme_iff(sc)
	struct hme_softc *sc;
{
	struct arpcom *ac = &sc->sc_arpcom;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct hme_cr *cr = sc->sc_cr;
	struct ether_multi *enm;
	struct ether_multistep step;
	u_int32_t rxcfg, crc;
	u_int32_t hash[4];

	rxcfg = cr->rx_cfg;
	rxcfg &= ~(CR_RXCFG_HENABLE | CR_RXCFG_PMISC);
	ifp->if_flags &= ~IFF_ALLMULTI;
	/* Clear hash table */
	hash[0] = hash[1] = hash[2] = hash[3] = 0;

	if (ifp->if_flags & IFF_PROMISC) {
		ifp->if_flags |= IFF_ALLMULTI;
		rxcfg |= CR_RXCFG_PMISC;
	} else if (ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		rxcfg |= CR_RXCFG_HENABLE;
		hash[0] = hash[1] = hash[2] = hash[3] = 0xffff;
	} else {
		rxcfg |= CR_RXCFG_HENABLE;

		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			crc = ether_crc32_le(enm->enm_addrlo,
			    ETHER_ADDR_LEN) >> 26; 

			/* Set the corresponding bit in the filter. */
			hash[crc >> 4] |= 1 << (crc & 0xf);

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	/* Now load the hash table into the chip */
	cr->htable0 = hash[0];
	cr->htable1 = hash[1];
	cr->htable2 = hash[2];
	cr->htable3 = hash[3];
	cr->rx_cfg = rxcfg;
}

/*
 * Writing to the serial BitBang, is a matter of putting the bit
 * into the data register, then strobing the clock.
 */
void
hme_tcvr_bb_writeb(sc, b)
	struct hme_softc *sc;
	int b;
{
	sc->sc_tcvr->bb_data = b & 0x1;
	sc->sc_tcvr->bb_clock = 0;
	sc->sc_tcvr->bb_clock = 1;
}

/*
 * Read a bit from a PHY, if the PHY is not our internal or external
 * phy addr, just return all zero's.
 */
int
hme_tcvr_bb_readb(sc, phy)
	struct hme_softc *sc;
	int phy;
{
	int ret;

	sc->sc_tcvr->bb_clock = 0;
	DELAY(10);

	if (phy == TCVR_PHYADDR_ITX)
		ret = sc->sc_tcvr->cfg & TCVR_CFG_MDIO0;
	else if (phy == TCVR_PHYADDR_ETX)
		ret = sc->sc_tcvr->cfg & TCVR_CFG_MDIO1;
	else
		ret = 0;

	sc->sc_tcvr->bb_clock = 1;

	return ((ret) ? 1 : 0);
}

void
hme_mii_write(self, phy, reg, val)
	struct device *self;
	int phy, reg, val;
{
	struct hme_softc *sc = (struct hme_softc *)self;
	struct hme_tcvr *tcvr = sc->sc_tcvr;
	int tries = 16, i;

	if (sc->sc_flags & HME_FLAG_FENABLE) {
		tcvr->frame = (FRAME_WRITE | phy << 23) |
		    ((reg & 0xff) << 18) | (val & 0xffff);
		while (!(tcvr->frame & 0x10000) && (tries != 0)) {
			tries--;
			DELAY(200);
		}
		if (!tries)
			printf("%s: mii_write failed\n", sc->sc_dev.dv_xname);
		return;
	}

	tcvr->bb_oenab = 1;

	for (i = 0; i < 32; i++)
		hme_tcvr_bb_writeb(sc, 1);

	hme_tcvr_bb_writeb(sc, (MII_COMMAND_START >> 1) & 1);
	hme_tcvr_bb_writeb(sc, MII_COMMAND_START & 1);
	hme_tcvr_bb_writeb(sc, (MII_COMMAND_WRITE >> 1) & 1);
	hme_tcvr_bb_writeb(sc, MII_COMMAND_WRITE & 1);

	for (i = 4; i >= 0; i--)
		hme_tcvr_bb_writeb(sc, (phy >> i) & 1);

	for (i = 4; i >= 0; i--)
		hme_tcvr_bb_writeb(sc, (reg >> i) & 1);

	for (i = 15; i >= 0; i--)
		hme_tcvr_bb_writeb(sc, (reg >> i) & 1);

	tcvr->bb_oenab = 0;
}

int
hme_mii_read(self, phy, reg)
	struct device *self;
	int phy, reg;
{
	struct hme_softc *sc = (struct hme_softc *)self;
	struct hme_tcvr *tcvr = sc->sc_tcvr;
	int tries = 16, i, ret = 0;

	/* Use the frame if possible */
	if (sc->sc_flags & HME_FLAG_FENABLE) {
		tcvr->frame = (FRAME_READ | phy << 23) |
		    ((reg & 0xff) << 18);
		while (!(tcvr->frame & 0x10000) && (tries != 0)) {
			tries--;
			DELAY(20);
		}
		if (!tries) {
			printf("%s: mii_read failed\n", sc->sc_dev.dv_xname);
			return (0);
		}
		return (tcvr->frame & 0xffff);
	}

	tcvr->bb_oenab = 1;

	for (i = 0; i < 32; i++)		/* make bitbang idle */
		hme_tcvr_bb_writeb(sc, 1);

	hme_tcvr_bb_writeb(sc, (MII_COMMAND_START >> 1) & 1);
	hme_tcvr_bb_writeb(sc, MII_COMMAND_START & 1);
	hme_tcvr_bb_writeb(sc, (MII_COMMAND_READ >> 1) & 1);
	hme_tcvr_bb_writeb(sc, MII_COMMAND_READ & 1);

	for (i = 4; i >= 0; i--)
		hme_tcvr_bb_writeb(sc, (phy >> i) & 1);

	for (i = 4; i >= 0; i--)
		hme_tcvr_bb_writeb(sc, (reg >> i) & 1);

	tcvr->bb_oenab = 0;			/* turn off bitbang intrs */

	hme_tcvr_bb_readb(sc, phy);		/* ignore... */

	for (i = 15; i >= 15; i--)		/* read value */
		ret |= hme_tcvr_bb_readb(sc, phy) << i;

	hme_tcvr_bb_readb(sc, phy);			/* ignore... */
	hme_tcvr_bb_readb(sc, phy);			/* ignore... */
	hme_tcvr_bb_readb(sc, phy);			/* ignore... */

	return (ret);
}

int
hme_mediachange(ifp)
	struct ifnet *ifp;
{
	if (ifp->if_flags & IFF_UP)
		hmeinit(ifp->if_softc);
	return (0);
}

void
hme_mediastatus(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
{
	struct hme_softc *sc = (struct hme_softc *)ifp->if_softc;

	mii_pollstat(&sc->sc_mii);
	ifmr->ifm_active = sc->sc_mii.mii_media_active;
	ifmr->ifm_status = sc->sc_mii.mii_media_status;
}

void
hme_mii_statchg(self)
	struct device *self;
{
	struct hme_softc *sc = (struct hme_softc *)self;
	struct hme_cr *cr = sc->sc_cr;

	/* Apparently the hme chip is SIMPLEX if working in full duplex mode,
	   but not otherwise. */
	if ((IFM_OPTIONS(sc->sc_mii.mii_media_active) & IFM_FDX) != 0) {
		cr->tx_cfg |= CR_TXCFG_FULLDPLX;
		sc->sc_arpcom.ac_if.if_flags |= IFF_SIMPLEX;
	} else {
		cr->tx_cfg &= ~CR_TXCFG_FULLDPLX;
		sc->sc_arpcom.ac_if.if_flags &= ~IFF_SIMPLEX;
	}
}
@


1.79
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.78 2015/12/08 13:34:22 tedu Exp $	*/
@


1.78
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.77 2015/11/25 11:20:38 mpi Exp $	*/
a240 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.77
log
@Network drivers should not include <net/route.h> or <net/netisr.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.76 2015/11/25 03:09:58 dlg Exp $	*/
d238 1
a238 1
		IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
@


1.76
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.75 2015/11/24 17:11:38 mpi Exp $	*/
a53 1
#include <net/netisr.h>
@


1.75
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.74 2015/11/24 13:33:18 mpi Exp $	*/
d275 1
a275 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d310 1
a310 1
			ifp->if_flags |= IFF_OACTIVE;
d332 2
a333 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d575 1
a575 1
	ifp->if_flags &= ~IFF_OACTIVE;
d673 1
a673 1
		ifp->if_flags &= ~IFF_OACTIVE;
@


1.74
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.73 2015/11/14 17:26:40 mpi Exp $	*/
a53 1
#include <net/if_dl.h>
@


1.73
log
@No need to include <net/bpfdesc.h>

Now that "struct bpf_d" depends on <sys/srp.h> this is one of the offender
for removing the header from <sys/param.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.72 2015/10/25 13:22:09 mpi Exp $	*/
a54 1
#include <net/if_types.h>
@


1.72
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.71 2015/07/08 07:21:49 mpi Exp $	*/
a63 1
#include <net/bpfdesc.h>
@


1.71
log
@MFREE(9) is dead, long live m_freem(9)!

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.70 2015/06/24 09:40:53 mpi Exp $	*/
a397 1
	struct ifaddr *ifa = (struct ifaddr *)data;
a407 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_arpcom, ifa);
@


1.70
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.69 2015/04/13 08:45:48 mpi Exp $	*/
d800 1
a800 1
			MFREE(m, n);
d806 1
a806 1
		MFREE(m, n);
@


1.69
log
@Now that if_input() set the receiving interface pointer on mbufs for us
there's no need to do it in m_devget(9).

Stop passing an ``ifp'' will help for upcoming interface pointer -> index
conversion.

While here remove unused ``ifp'' argument from m_clget(9) and kill two
birds^W layer violations in one commit.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.68 2015/04/08 10:07:47 mpi Exp $	*/
a835 2

	ifp->if_ipackets++;
@


1.68
log
@Convert to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.67 2014/12/22 02:26:54 tedu Exp $	*/
d831 1
a831 1
	    HME_RX_OFFSET, &sc->sc_arpcom.ac_if);
@


1.67
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.66 2014/07/22 10:35:35 mpi Exp $	*/
d818 1
d839 2
a840 10
#if NBPFILTER > 0
	/*
	 * Check if there's a BPF listener on this interface.
	 * If so, hand off the raw packet to BPF.
	 */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
	/* Pass the packet up. */
	ether_input_mbuf(ifp, m);
@


1.66
log
@<netinet/in_systm.h> is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.65 2014/04/22 15:52:05 naddy Exp $	*/
a408 1
#ifdef INET
a410 1
#endif
@


1.65
log
@Remove RX checksum offloading support.  The chip is too limited, and
examining higher protocol layers to adjust the checksum and calculate
the pseudo-header in the driver is too complex to be worthwhile.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.64 2013/09/05 20:55:58 bluhm Exp $	*/
a58 1
#ifdef INET
a59 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a60 3
#include <netinet/tcp.h>
#include <netinet/udp.h>
#endif
@


1.64
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Remove these include lines from mvme68k, mvme88k,
sparc drivers.
test and OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.63 2013/08/21 05:21:42 dlg Exp $	*/
a105 3
/* TCP/UDP checksum offload support */
void	hme_rxcksum(struct mbuf *, u_int32_t);

d494 1
a494 1
	u_int32_t c, n;
a552 4
	/* RX TCP/UDP cksum offset */
	n = (ETHER_HDR_LEN + sizeof(struct ip)) / 2;
	n = (n << RXR_CFG_CSUM_SHIFT) & RXR_CFG_CSUMSTART;
	c |= n;
a704 95
/*
 * XXX layering violation
 *
 * If we can have additional csum data member in 'struct pkthdr' for
 * these incomplete checksum offload capable hardware, things would be
 * much simpler. That member variable will carry partial checksum
 * data and it may be evaluated in TCP/UDP input handler after
 * computing pseudo header checksumming.
 */
void
hme_rxcksum(struct mbuf *m, u_int32_t flags)
{
	struct ether_header *eh;
	struct ip *ip;
	struct udphdr *uh;
	int32_t hlen, len, pktlen;
	u_int16_t cksum, *opts;
	u_int32_t temp32;
	union pseudoh {
		struct hdr {
			u_int16_t len;
			u_int8_t ttl;
			u_int8_t proto;
			u_int32_t src;
			u_int32_t dst;
		} h;
		u_int16_t w[6];
	} ph;

	pktlen = m->m_pkthdr.len;
	if (pktlen < sizeof(struct ether_header))
		return;
	eh = mtod(m, struct ether_header *);
	if (eh->ether_type != htons(ETHERTYPE_IP))
		return;
	ip = (struct ip *)(eh + 1);
	if (ip->ip_v != IPVERSION)
		return;

	hlen = ip->ip_hl << 2;
	pktlen -= sizeof(struct ether_header);
	if (hlen < sizeof(struct ip))
		return;
	if (ntohs(ip->ip_len) < hlen)
		return;
	if (ntohs(ip->ip_len) != pktlen) 
		return;
	if (ip->ip_off & htons(IP_MF | IP_OFFMASK))
		return;	/* can't handle fragmented packet */

	switch (ip->ip_p) {
	case IPPROTO_TCP:
		if (pktlen < (hlen + sizeof(struct tcphdr)))
			return;
		break;
	case IPPROTO_UDP:
		if (pktlen < (hlen + sizeof(struct udphdr)))
			return;
		uh = (struct udphdr *)((caddr_t)ip + hlen);
		if (uh->uh_sum == 0)
			return; /* no checksum */
		break;
	default:
		return;
	}

	cksum = htons(~(flags & HME_RXD_CSUM));
	/* cksum fixup for IP options */
	len = hlen - sizeof(struct ip);
	if (len > 0) {
		opts = (u_int16_t *)(ip + 1);
		for (; len > 0; len -= sizeof(u_int16_t), opts++) {
			temp32 = cksum - *opts;
			temp32 = (temp32 >> 16) + (temp32 & 65535);
			cksum = temp32 & 65535;
		}
	}
	/* cksum fixup for pseudo-header, replace with in_cksum_phdr()? */
	ph.h.len = htons(ntohs(ip->ip_len) - hlen);
	ph.h.ttl = 0;
	ph.h.proto = ip->ip_p;
	ph.h.src = ip->ip_src.s_addr;
	ph.h.dst = ip->ip_dst.s_addr;
	temp32 = cksum;
	opts = &ph.w[0];
	temp32 += opts[0] + opts[1] + opts[2] + opts[3] + opts[4] + opts[5];
	temp32 = (temp32 >> 16) + (temp32 & 65535);
	temp32 += (temp32 >> 16);
	cksum = ~temp32;
	if (cksum == 0) {
		m->m_pkthdr.csum_flags |=
			M_TCP_CSUM_IN_OK | M_UDP_CSUM_IN_OK;
	}
}

a844 1
	hme_rxcksum(m, flags);
@


1.63
log
@get rid of the copy argument in m_devget that let you provide an
alternative to bcopy since noone uses it.

while there use memcpy instead of bcopy because we know the memory cannot
overlap.

ok henning@@ matthew@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.62 2009/08/13 17:01:31 phessler Exp $	*/
a61 1
#include <netinet/in_var.h>
@


1.62
log
@rewrite the promisc mode / multicast handling code for the sparc hme(4)
driver and is based off of the MI hme(4) driver.

tested with ping6 -w and tcpdump

from brad

OK naddy@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.61 2009/07/16 07:18:47 sthen Exp $	*/
d941 1
a941 1
	    HME_RX_OFFSET, &sc->sc_arpcom.ac_if, NULL);
@


1.61
log
@- Add missing tick handler calling mii_tick().
- Stop hmestop() from fiddling with the flags directly and
  calls mii_down() instead.

From Brad, tested by nick@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.60 2009/06/24 07:42:03 sthen Exp $	*/
d129 1
a129 1
void	hme_mcreset(struct hme_softc *);
d448 1
a448 1
			hme_mcreset(sc);
d578 1
a578 1
	hme_mcreset(sc);
a961 3
/*
 * Program the multicast receive filter.
 */
d963 1
a963 1
hme_mcreset(sc)
a968 4
	u_int32_t crc;
	u_int16_t hash[4];
	u_int8_t octet;
	int i, j;
d971 8
d981 13
a993 14
		cr->rx_cfg |= CR_RXCFG_PMISC;
		return;
	}
	else
		cr->rx_cfg &= ~CR_RXCFG_PMISC;

	if (ifp->if_flags & IFF_ALLMULTI) {
		cr->htable3 = 0xffff;
		cr->htable2 = 0xffff;
		cr->htable1 = 0xffff;
		cr->htable0 = 0xffff;
		cr->rx_cfg |= CR_RXCFG_HENABLE;
		return;
	}
d995 2
a996 1
	hash[3] = hash[2] = hash[1] = hash[0] = 0;
d998 1
a998 20
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			/*
			 * We must listen to a range of multicast
			 * addresses.  For now, just accept all
			 * multicasts, rather than trying to set only
			 * those filter bits needed to match the range.
			 * (At this time, the only use of address
			 * ranges is for IP multicast routing, for
			 * which the range is big enough to require
			 * all bits set.)
			 */
			cr->htable3 = 0xffff;
			cr->htable2 = 0xffff;
			cr->htable1 = 0xffff;
			cr->htable0 = 0xffff;
			cr->rx_cfg |= CR_RXCFG_HENABLE;
			ifp->if_flags |= IFF_ALLMULTI;
			return;
d1000 1
d1002 4
a1005 20
		crc = 0xffffffff;

		for (i = 0; i < ETHER_ADDR_LEN; i++) {
			octet = enm->enm_addrlo[i];

			for (j = 0; j < 8; j++) {
				if ((crc & 1) ^ (octet & 1)) {
					crc >>= 1;
					crc ^= ETHER_CRC_POLY_LE;
				}
				else
					crc >>= 1;
				octet >>= 1;
			}
		}

		crc >>=26;
		hash[crc >> 4] |= 1 << (crc & 0xf);
		ETHER_NEXT_MULTI(step, enm);
	}
d1007 1
a1007 5
	cr->htable2 = hash[2];
	cr->htable1 = hash[1];
	cr->htable0 = hash[0];
	cr->rx_cfg |= CR_RXCFG_HENABLE;
	ifp->if_flags &= ~IFF_ALLMULTI;
@


1.60
log
@Simplify the ioctl handling code. From Brad.
Tested by nick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.59 2009/06/20 09:40:29 sthen Exp $	*/
d95 2
d267 2
d340 2
d348 2
a354 1
	sc->sc_mii.mii_media_status &= ~IFM_ACTIVE;
d372 13
d592 2
@


1.59
log
@Have hmestop() properly clear the RUNNING/OACTIVE flags and the interface
watchdog timer.

Copied over from MI hme(4).

Tested by nick@@. From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.58 2008/11/28 02:44:17 brad Exp $	*/
a250 1
	sc->sc_if_flags = ifp->if_flags;
d396 3
a398 1
		switch (ifa->ifa_addr->sa_family) {
d400 1
a400 7
		case AF_INET:
			if (ifp->if_flags & IFF_UP)
				hme_mcreset(sc);
			else {
				ifp->if_flags |= IFF_UP;
				hmeinit(sc);
			}
d402 1
a402 7
			break;
#endif /* INET */
		default:
			ifp->if_flags |= IFF_UP;
			hmeinit(sc);
			break;
		}
d406 3
a408 26
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running, then
			 * stop it.
			 */
			hmestop(sc);
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
			   (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped, then
			 * start it.
			 */
			hmeinit(sc);
		} else {
			/*
			 * If setting debug or promiscuous mode, do not reset
			 * the chip; for everything else, call hmeinit()
			 * which will trigger a reset.
			 */
#define RESETIGN (IFF_CANTCHANGE | IFF_DEBUG)
			if (ifp->if_flags == sc->sc_if_flags)
				break;
			if ((ifp->if_flags & (~RESETIGN))
			    == (sc->sc_if_flags & (~RESETIGN)))
				hme_mcreset(sc);
d411 3
a413 1
#undef RESETIGN
a431 1
	sc->sc_if_flags = ifp->if_flags;
a574 1
	sc->sc_if_flags = ifp->if_flags;
a1198 1
	sc->sc_if_flags = sc->sc_arpcom.ac_if.if_flags;
@


1.58
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.57 2008/10/14 18:01:53 naddy Exp $	*/
d334 1
d337 6
a423 1
			ifp->if_flags &= ~IFF_RUNNING;
a608 1
	ifp->if_timer = 0;
@


1.57
log
@Change m_devget()'s outdated and unused "offset" argument:  It is
now the offset into the first mbuf of the target chain before copying
the source data over.  From FreeBSD.

Convert drivers' use of m_devget().  Mostly from thib@@.

Update mbuf(9) man page.

ok claudio@@, thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.56 2008/10/02 20:21:13 brad Exp $	*/
a442 16
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
			ether_addmulti(ifr, &sc->sc_arpcom):
			ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				hme_mcreset(sc);
			error = 0;
		}
		break;
d447 1
d450 6
@


1.56
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.55 2006/06/25 21:53:44 brad Exp $	*/
d956 2
a957 2
	m = m_devget(sc->sc_bufs->rx_buf[idx], len + HME_RX_OFFSET, 0,
	    &sc->sc_arpcom.ac_if, NULL);
a961 1
	m_adj(m, HME_RX_OFFSET);
@


1.55
log
@fix a typo in a comment and add the comment to the sparc hme driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.54 2006/06/02 20:00:54 miod Exp $	*/
a387 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return (error);
	}

d464 1
a464 1
		error = ENOTTY;
@


1.54
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.53 2006/05/27 23:59:07 jason Exp $	*/
d1234 2
@


1.53
log
@unknown ioctl is ENOTTY not EINVAL
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.52 2006/03/25 22:41:41 djm Exp $	*/
a209 2

	sbus_establish(&sc->sc_sd, &sc->sc_dev);
@


1.52
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.51 2006/01/12 15:06:12 brad Exp $	*/
d471 1
a471 1
		error = EINVAL;
@


1.51
log
@- add a missing htons() to the receive checksum routine to fix
checksumming on little endian systems.
- only set the Ok flag in the checksum routine.

Checksumming fix from: Pyun YongHyeon <pyunyh at gmail dot com>
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.50 2005/11/09 06:14:50 brad Exp $	*/
d302 1
a302 1
			bpf_mtap(ifp->if_bpf, m);
d980 1
a980 1
		bpf_mtap(ifp->if_bpf, m);
@


1.50
log
@splimp -> splnet
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.49 2005/06/08 17:03:02 henning Exp $	*/
d105 1
a105 1
/* TCP/UDP checksum offloading support */
d752 1
a752 1
	u_int16_t cksum, flag_bad, flag_ok, *opts;
a789 2
		flag_ok = M_TCP_CSUM_IN_OK;
		flag_bad = M_TCP_CSUM_IN_BAD;
a796 2
		flag_ok = M_UDP_CSUM_IN_OK;
		flag_bad = M_UDP_CSUM_IN_BAD;
d802 1
a802 1
	cksum = ~(flags & HME_RXD_CSUM);
d825 4
a828 4
	if (cksum != 0)
		m->m_pkthdr.csum_flags |= flag_bad;
	else
		m->m_pkthdr.csum_flags |= flag_ok;
@


1.49
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.48 2005/04/25 17:55:50 brad Exp $	*/
d388 1
a388 1
	s = splimp();
@


1.48
log
@csum -> csum_flags

ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.47 2005/02/22 20:44:26 brad Exp $	*/
a408 18
#ifdef NS
		/* XXX - This code is probably wrong. */
		case AF_NS:
		    {
			struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host = 
				    *(union ns_host *)(sc->sc_arpcom.ac_enaddr);
			else
				bcopy(ina->x_host.c_host,
				    sc->sc_arpcom.ac_enaddr,
				    sizeof(sc->sc_arpcom.ac_enaddr));
			/* Set new address. */
			hmeinit(sc);
			break;
		    }
#endif /* NS */
@


1.47
log
@add hme(4) RX TCP/UDP checksum offload

Based on a diff posted to sparc@@ by Pyun YongHyeon
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.46 2005/01/15 05:24:10 brad Exp $	*/
d848 1
a848 1
		m->m_pkthdr.csum |= flag_bad;
d850 1
a850 1
		m->m_pkthdr.csum |= flag_ok;
@


1.46
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.45 2004/09/29 07:35:11 miod Exp $	*/
d65 2
d105 3
d111 2
a112 2
void		hme_read(struct hme_softc *, int, int);
int		hme_put(struct hme_softc *, int, struct mbuf *);
d539 1
a539 1
	u_int32_t c;
d597 5
a601 1
	c = RXR_CFG_DMAENABLE | (HME_RX_OFFSET << 3) | (HME_RX_CSUMLOC << 16);
d754 99
d873 1
a873 1
			hme_read(sc, bix, len);
d968 1
a968 1
hme_read(sc, idx, len)
d971 1
d994 1
@


1.45
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.44 2004/09/28 00:21:23 brad Exp $	*/
d474 2
a475 1
			hme_mcreset(sc);
@


1.44
log
@- Use ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN instead of HME_MTU
- Use ETHER_CRC_POLY_LE instead of MC_POLY_LE from hmereg.h
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.43 2004/08/08 19:01:20 brad Exp $	*/
d210 2
a211 1
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih, IPL_NET);
@


1.43
log
@do not reset the chip (and subsequently the phy) when unnecessary; that is,
for address changes, multicast filter changes, or adjusting promiscuous mode.
Fixes resetting the phy for things like start/stopping tcpdump.

From NetBSD
tested by me, miod@@, otto@@ and a few others.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.42 2003/06/18 19:11:49 jason Exp $	*/
a71 4
#if NVLAN > 0
#include <net/if_vlan_var.h>
#endif

d248 1
a248 1
	ifp->if_capabilities |= IFCAP_VLAN_MTU;
d564 1
a564 1
	cr->tx_pkt_max = cr->rx_pkt_max = HME_MTU;
d961 1
a961 1
					crc ^= MC_POLY_LE;
@


1.42
log
@configure the interface to properly support vlan frames
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.41 2003/06/02 18:40:59 jason Exp $	*/
d251 1
a394 1
		ifp->if_flags |= IFF_UP;
d398 6
a403 1
			hmeinit(sc);
d426 1
d450 3
a452 2
			 * Reset the interface to pick up changes in any other
			 * flags that affect hardware registers.
d454 9
a462 2
			hmestop(sc);
			hmeinit(sc);
d488 2
d629 1
d1157 1
@


1.41
log
@nuke my clause 3 & 4 (and a couple jointly (c) with Theo).
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.40 2002/11/09 22:22:35 fgsch Exp $	*/
d39 3
a66 1
#include "bpfilter.h"
d72 4
d251 1
d552 1
@


1.40
log
@- make IFF_SIMPLEX only set if the media is IFM_FDX (prevents ip6 from
seeing it's packets and thinking another machine with the same mac is
on the wire when running half-duplex); from NetBSD.

tested by matthieu, jason and him ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.39 2002/10/05 21:19:35 fgsch Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.39
log
@spelling.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.37 2002/06/07 23:34:54 jason Exp $	*/
d1130 1
a1130 1
	if (sc->sc_mii.mii_media_active & IFM_FDX)
d1132 2
a1133 1
	else
d1135 2
@


1.38
log
@DTIMEXP is not a fatal error, deal with it.
@
text
@d624 1
a624 1
	/* Turn off MIF interrupts, and diable polling */
@


1.37
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.36 2002/04/30 01:12:29 art Exp $	*/
d770 1
a770 1
	if (why & GR_STAT_NORXD)
d772 6
d779 1
a779 1
	if (why & (GR_STAT_ALL_ERRORS & (~GR_STAT_NORXD))) {
@


1.36
log
@Fix an ancient problem in how sparc interrupts are handled.

There are many interrupt handlers that assume that they don't need to do
any spl protection in their code because the interrupt of some level can't
be interrupted by an interrupt of the same level. The problem is that some
interrupt handlers have hardware levels that are lower then their "software"
levels.

Fix this by adding an additional field to struct intrhand that specifies which
"software" level an interrupt handler has and blocks that level while handling
the interrupt. This new field is initialized in intr_establish which gets
an additional argument (which can be -1 meaning that the interrupt handler
doesn't need to block any additional level).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.35 2002/03/14 01:26:43 millert Exp $	*/
d387 1
a387 1
		return error;
d473 1
a473 1
	return error;
d673 1
a673 1
	return 1;
d724 1
a724 1
	return 1;
d759 1
a759 1
	return 1;
d779 1
a779 1
	return 1;
d832 1
a832 1
	return tlen;
d1061 1
a1061 1
			return 0;
d1093 1
a1093 1
	return ret;
@


1.35
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.34 2001/08/24 05:14:05 jason Exp $	*/
d213 1
a213 1
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih);
@


1.34
log
@propagate bootpath
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.33 2001/07/30 21:50:06 jason Exp $	*/
d85 20
a104 20
int	hmematch	__P((struct device *, void *, void *));
void	hmeattach	__P((struct device *, struct device *, void *));
void	hmewatchdog	__P((struct ifnet *));
int	hmeintr		__P((void *));
int	hmeioctl	__P((struct ifnet *, u_long, caddr_t));
void	hmereset	__P((struct hme_softc *));
void	hmestart	__P((struct ifnet *));
void	hmestop		__P((struct hme_softc *));
void	hmeinit		__P((struct hme_softc *));
void	hme_meminit	__P((struct hme_softc *));

void	hme_tcvr_bb_writeb  __P((struct hme_softc *, int));
int	hme_tcvr_bb_readb   __P((struct hme_softc *, int));

void	hme_poll_stop	__P((struct hme_softc *sc));

int	hme_rint	__P((struct hme_softc *));
int	hme_tint	__P((struct hme_softc *));
int	hme_mint	__P((struct hme_softc *, u_int32_t));
int	hme_eint	__P((struct hme_softc *, u_int32_t));
d106 2
a107 2
void	hme_reset_rx	__P((struct hme_softc *));
void	hme_reset_tx	__P((struct hme_softc *));
d109 2
a110 2
void		hme_read __P((struct hme_softc *, int, int));
int		hme_put __P((struct hme_softc *, int, struct mbuf *));
d115 2
a116 2
int	hme_mediachange __P((struct ifnet *));
void	hme_mediastatus __P((struct ifnet *, struct ifmediareq *));
d121 3
a123 3
int	hme_mii_read __P((struct device *, int, int));
void	hme_mii_write __P((struct device *, int, int, int));
void	hme_mii_statchg __P((struct device *));
d125 1
a125 1
void	hme_mcreset __P((struct hme_softc *));
d165 1
a165 1
	extern void myetheraddr __P((u_char *));
@


1.34.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.34 2001/08/24 05:14:05 jason Exp $	*/
d85 20
a104 20
int	hmematch(struct device *, void *, void *);
void	hmeattach(struct device *, struct device *, void *);
void	hmewatchdog(struct ifnet *);
int	hmeintr(void *);
int	hmeioctl(struct ifnet *, u_long, caddr_t);
void	hmereset(struct hme_softc *);
void	hmestart(struct ifnet *);
void	hmestop(struct hme_softc *);
void	hmeinit(struct hme_softc *);
void	hme_meminit(struct hme_softc *);

void	hme_tcvr_bb_writeb(struct hme_softc *, int);
int	hme_tcvr_bb_readb(struct hme_softc *, int);

void	hme_poll_stop(struct hme_softc *sc);

int	hme_rint(struct hme_softc *);
int	hme_tint(struct hme_softc *);
int	hme_mint(struct hme_softc *, u_int32_t);
int	hme_eint(struct hme_softc *, u_int32_t);
d106 2
a107 2
void	hme_reset_rx(struct hme_softc *);
void	hme_reset_tx(struct hme_softc *);
d109 2
a110 2
void		hme_read(struct hme_softc *, int, int);
int		hme_put(struct hme_softc *, int, struct mbuf *);
d115 2
a116 2
int	hme_mediachange(struct ifnet *);
void	hme_mediastatus(struct ifnet *, struct ifmediareq *);
d121 3
a123 3
int	hme_mii_read(struct device *, int, int);
void	hme_mii_write(struct device *, int, int, int);
void	hme_mii_statchg(struct device *);
d125 1
a125 1
void	hme_mcreset(struct hme_softc *);
d165 1
a165 1
	extern void myetheraddr(u_char *);
d213 1
a213 1
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih, IPL_NET);
d387 1
a387 1
		return (error);
d473 1
a473 1
	return (error);
d673 1
a673 1
	return (1);
d724 1
a724 1
	return (1);
d759 1
a759 1
	return (1);
d779 1
a779 1
	return (1);
d832 1
a832 1
	return (tlen);
d1061 1
a1061 1
			return (0);
d1093 1
a1093 1
	return (ret);
@


1.34.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.34.4.1 2002/06/11 03:38:16 art Exp $	*/
d624 1
a624 1
	/* Turn off MIF interrupts, and disable polling */
d770 1
a770 1
	if (why & GR_STAT_NORXD) {
a771 6
		why &= ~GR_STAT_NORXD;
	}
	if (why & GR_STAT_DTIMEXP) {
		sc->sc_arpcom.ac_if.if_oerrors++;
		why &= ~GR_STAT_DTIMEXP;
	}
d773 1
a773 1
	if (why & GR_STAT_ALL_ERRORS) {
@


1.34.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1130 1
a1130 1
	if ((IFM_OPTIONS(sc->sc_mii.mii_media_active) & IFM_FDX) != 0) {
d1132 1
a1132 2
		sc->sc_arpcom.ac_if.if_flags |= IFF_SIMPLEX;
	} else {
a1133 2
		sc->sc_arpcom.ac_if.if_flags &= ~IFF_SIMPLEX;
	}
@


1.33
log
@convert to ALTQ style macros (these drivers appear to meet the criteria for
ALTQ, anyone more familiar with it wanna have a look?)
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.32 2001/06/26 21:58:48 fgsch Exp $	*/
d163 1
d256 7
@


1.32
log
@trivial ether_input_mbuf() conversions.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.31 2001/02/20 19:39:34 mickey Exp $	*/
d249 2
d280 1
a280 1
		IF_DEQUEUE(&ifp->if_snd, m);
@


1.31
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.30 2001/01/30 07:19:52 jason Exp $	*/
a830 1
	struct ether_header *eh;
a851 3
	/* We assume that the header fit entirely in one mbuf. */
	eh = mtod(m, struct ether_header *);

d860 2
a861 3
	/* Pass the packet up, with the ether header sort-of removed. */
	m_adj(m, sizeof(struct ether_header));
	ether_input(ifp, eh, m);
@


1.30
log
@- make hme_put() a little neater
- mostly style
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.29 2001/01/30 04:46:25 jason Exp $	*/
a252 4

#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
#endif
@


1.29
log
@borrow an idea from if_rl... take advantage of HME_RX_OFFSET and use
m_devget() to pull the packet out of hme's buffers
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.28 2001/01/23 16:47:47 jason Exp $	*/
d492 1
a492 1
		    (u_int32_t) &sc->sc_bufs_dva->tx_buf[i][0];
d502 1
a502 1
		    (u_int32_t) &sc->sc_bufs_dva->rx_buf[i][0];
d549 2
a550 2
	rxr->rx_ring = (u_int32_t)&sc->sc_desc_dva->hme_rxd[0];
	txr->tx_ring = (u_int32_t)&sc->sc_desc_dva->hme_txd[0];
d812 2
a813 1
	int len, tlen = 0, boff = 0;
d821 2
a822 2
		bcopy(mtod(m, caddr_t), &sc->sc_bufs->tx_buf[idx][boff], len);
		boff += len;
d847 1
a847 1
	m = m_devget(&sc->sc_bufs->rx_buf[idx][0], len + HME_RX_OFFSET, 0,
@


1.28
log
@three small bugs pointed out by Adam <vt@@ikp.pl>
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.27 2000/11/28 23:14:05 jason Exp $	*/
a108 1
struct mbuf *	hme_get __P((struct hme_softc *, int, int));
a804 53
struct mbuf *
hme_get(sc, idx, totlen)
	struct hme_softc *sc;
	int idx, totlen;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf *m;
	struct mbuf *top, **mp;
	int len, pad, boff = 0;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return NULL;
	m->m_pkthdr.rcvif = ifp;
	m->m_pkthdr.len = totlen;
	pad = ALIGN(sizeof(struct ether_header)) - sizeof(struct ether_header);
	len = MHLEN;
	if (totlen >= MINCLSIZE) {
		MCLGET(m, M_DONTWAIT);
		if (m->m_flags & M_EXT)
			len = MCLBYTES;
	}
	m->m_data += pad;
	len -= pad;
	top = NULL;
	mp = &top;

	while (totlen > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == NULL) {
				m_freem(top);
				return NULL;
			}
			len = MLEN;
		}
		if (top && totlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if (m->m_flags & M_EXT)
				len = MCLBYTES;
		}
		m->m_len = len = min(totlen, len);
		bcopy(&sc->sc_bufs->rx_buf[idx][boff + HME_RX_OFFSET],
		    mtod(m, caddr_t), len);
		boff += len;
		totlen -= len;
		*mp = m;
		mp = &m->m_next;
	}

	return top;
}

d846 2
a847 1
	m = hme_get(sc, idx, len);
d852 1
@


1.27
log
@How did this work?
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.26 2000/11/28 05:12:18 jason Exp $	*/
d329 1
a329 1
	while (sc->sc_gr->reset && (tries != MAX_STOP_TRIES))
d636 1
a636 1
	while (tries-- && (cr->tx_swreset & 1))
d651 1
a651 1
	while (tries-- && (cr->rx_swreset & 1))
@


1.26
log
@Repair: grrrrrr... brought in wrong changes -again-
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.24 2000/11/28 04:23:16 jason Exp $	*/
d1171 1
a1171 1
	struct hme_softc *sc = (struct hme_softc *)sc;
@


1.25
log
@oops, not yet
@
text
@a484 1
	
a509 23
hme_rxd_ref(m)
	struct mbuf *m;
{
	struct hme_softrxd *d = m->m_ext_handle;

	d->rxd_ref++;
}

void
hme_rxd_free(m)
	struct mbuf *m;
{
	struct hme_softrxd *d = m->m_ext_handle;

	if (d->rxd_ref <= 0)
		panic("hme_rxd_free: ref %d", d->rxd_ref);
	d->rxd_ref--;
	if (d->rxd_ref == 0) {
		dvma_free(
	}
}

void
d733 1
a733 1
		rxd->rx_flags = &sc->sc_desc->hme_rxd[bix];
@


1.24
log
@remove statics and knf
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.23 2000/06/18 17:42:18 jason Exp $	*/
d485 1
d511 23
d757 1
a757 1
		bcopy(&sc->sc_desc->hme_rxd[bix], &rxd, sizeof(rxd));
d872 1
a872 1
		bcopy(&sc->sc_bufs->rx_buf[idx][boff],
@


1.23
log
@don't reset the chip on NORXD, and certainly don't print a message about it
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.22 2000/06/18 17:37:02 jason Exp $	*/
d96 2
a97 2
static void	hme_tcvr_bb_writeb  __P((struct hme_softc *, int));
static int	hme_tcvr_bb_readb   __P((struct hme_softc *, int));
d99 1
a99 1
static void	hme_poll_stop	__P((struct hme_softc *sc));
d101 11
a111 11
static int	hme_rint	__P((struct hme_softc *));
static int	hme_tint	__P((struct hme_softc *));
static int	hme_mint	__P((struct hme_softc *, u_int32_t));
static int	hme_eint	__P((struct hme_softc *, u_int32_t));

static void	hme_reset_rx		__P((struct hme_softc *));
static void	hme_reset_tx		__P((struct hme_softc *));

static struct mbuf *	hme_get __P((struct hme_softc *, int, int));
static void		hme_read __P((struct hme_softc *, int, int));
static int		hme_put __P((struct hme_softc *, int, struct mbuf *));
d116 2
a117 2
static int	hme_mediachange __P((struct ifnet *));
static void	hme_mediastatus __P((struct ifnet *, struct ifmediareq *));
d122 3
a124 3
static int	hme_mii_read __P((struct device *, int, int));
static void	hme_mii_write __P((struct device *, int, int, int));
static void	hme_mii_statchg __P((struct device *));
d126 1
a126 1
static void	hme_mcreset __P((struct hme_softc *));
d155 1
a155 1
void    
d204 1
a204 1
        /* Clamp at parent's burst sizes */
d585 1
a585 1
	    printf("%s: setting rxreg->cfg failed.\n", sc->sc_dev.dv_xname);
d608 1
a608 1
static void
d621 1
a621 1
        tcvr->cfg &= ~(TCVR_CFG_PENABLE);
d628 1
a628 1
static void
d643 1
a643 1
static void
d661 1
a661 1
static int
d674 1
a674 1
static int
d722 1
a722 1
static int
d760 1
a760 1
static int
d806 1
a806 1
static struct mbuf *
d848 1
a848 1
		bcopy(&sc->sc_bufs->rx_buf[idx][boff + HME_RX_OFFSET],
d859 1
a859 1
static int
d882 1
a882 1
static void
d927 1
a927 1
static void
d1013 1
a1013 1
static void
d1027 1
a1027 1
static int
d1049 1
a1049 1
static void
d1060 1
a1060 2
			      ((reg & 0xff) << 18) |
			      (val & 0xffff);
d1092 1
a1092 1
static int
d1104 1
a1104 1
			      ((reg & 0xff) << 18);
d1132 1
a1132 1
	tcvr->bb_oenab = 0;	                /* turn off bitbang intrs */
d1146 1
a1146 1
static int
d1155 1
a1155 1
static void
d1167 1
a1167 1
static void
@


1.22
log
@hmm, you'd never know these started out as if_ie.c....
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.21 1999/12/10 03:03:56 jason Exp $	*/
d284 1
a284 1
		if (m == 0)
d765 4
a768 1
	if (why & GR_STAT_ALL_ERRORS) {
@


1.21
log
@fix rx mbuf allocation
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.20 1999/08/20 04:55:03 jason Exp $	*/
a442 6
#ifdef IEDEBUG   
		if (ifp->if_flags & IFF_DEBUG)
			sc->sc_debug = IED_ALL;
		else
			sc->sc_debug = 0;
#endif
@


1.21.2.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.31 2001/02/20 19:39:34 mickey Exp $	*/
d96 2
a97 2
void	hme_tcvr_bb_writeb  __P((struct hme_softc *, int));
int	hme_tcvr_bb_readb   __P((struct hme_softc *, int));
d99 1
a99 1
void	hme_poll_stop	__P((struct hme_softc *sc));
d101 11
a111 10
int	hme_rint	__P((struct hme_softc *));
int	hme_tint	__P((struct hme_softc *));
int	hme_mint	__P((struct hme_softc *, u_int32_t));
int	hme_eint	__P((struct hme_softc *, u_int32_t));

void	hme_reset_rx	__P((struct hme_softc *));
void	hme_reset_tx	__P((struct hme_softc *));

void		hme_read __P((struct hme_softc *, int, int));
int		hme_put __P((struct hme_softc *, int, struct mbuf *));
d116 2
a117 2
int	hme_mediachange __P((struct ifnet *));
void	hme_mediastatus __P((struct ifnet *, struct ifmediareq *));
d122 3
a124 3
int	hme_mii_read __P((struct device *, int, int));
void	hme_mii_write __P((struct device *, int, int, int));
void	hme_mii_statchg __P((struct device *));
d126 1
a126 1
void	hme_mcreset __P((struct hme_softc *));
d155 1
a155 1
void
d204 1
a204 1
	/* Clamp at parent's burst sizes */
d254 4
d284 1
a284 1
		if (m == NULL)
d329 1
a329 1
	while (sc->sc_gr->reset && (++tries != MAX_STOP_TRIES))
d443 6
d499 1
a499 1
		    (u_int32_t)sc->sc_bufs_dva->tx_buf[i];
d509 1
a509 1
		    (u_int32_t)sc->sc_bufs_dva->rx_buf[i];
d556 2
a557 2
	rxr->rx_ring = (u_int32_t)sc->sc_desc_dva->hme_rxd;
	txr->tx_ring = (u_int32_t)sc->sc_desc_dva->hme_txd;
d591 1
a591 1
		printf("%s: setting rxreg->cfg failed.\n", sc->sc_dev.dv_xname);
d614 1
a614 1
void
d627 1
a627 1
	tcvr->cfg &= ~(TCVR_CFG_PENABLE);
d634 1
a634 1
void
d642 1
a642 1
	while (--tries && (cr->tx_swreset & 1))
d649 1
a649 1
void
d657 1
a657 1
	while (--tries && (cr->rx_swreset & 1))
d667 1
a667 1
int
d680 1
a680 1
int
d728 1
a728 1
int
d766 1
a766 1
int
d771 1
a771 4
	if (why & GR_STAT_NORXD)
		sc->sc_arpcom.ac_if.if_ierrors++;

	if (why & (GR_STAT_ALL_ERRORS & (~GR_STAT_NORXD))) {
d809 54
a862 1
int
d869 1
a869 2
	u_int8_t *buf = sc->sc_bufs->tx_buf[idx];
	int len, tlen = 0;
d877 2
a878 2
		bcopy(mtod(m, caddr_t), buf, len);
		buf += len;
d885 1
a885 1
void
d903 1
a903 2
	m = m_devget(sc->sc_bufs->rx_buf[idx], len + HME_RX_OFFSET, 0,
	    &sc->sc_arpcom.ac_if, NULL);
a907 1
	m_adj(m, HME_RX_OFFSET);
d930 1
a930 1
void
d1016 1
a1016 1
void
d1030 1
a1030 1
int
d1052 1
a1052 1
void
d1063 2
a1064 1
		    ((reg & 0xff) << 18) | (val & 0xffff);
d1096 1
a1096 1
int
d1108 1
a1108 1
		    ((reg & 0xff) << 18);
d1136 1
a1136 1
	tcvr->bb_oenab = 0;			/* turn off bitbang intrs */
d1150 1
a1150 1
int
d1159 1
a1159 1
void
d1171 1
a1171 1
void
d1175 1
a1175 1
	struct hme_softc *sc = (struct hme_softc *)self;
@


1.21.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.21.2.1 2001/05/14 21:37:05 niklas Exp $	*/
d831 1
d853 3
d864 3
a866 2
	/* Pass the packet up. */
	ether_input_mbuf(ifp, m);
@


1.21.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.21.2.2 2001/07/04 10:23:23 niklas Exp $	*/
a162 1
	struct bootpath *bp;
a248 2
	IFQ_SET_MAXLEN(&ifp->if_snd, HME_TX_RING_SIZE);
	IFQ_SET_READY(&ifp->if_snd);
a252 7

	bp = ca->ca_ra.ra_bp;
	if (bp != NULL && sc->sc_dev.dv_unit == bp->val[1] &&
	    ((strcmp(bp->name, hme_cd.cd_name) == 0) ||
	     (strcmp(bp->name, "qfe") == 0) ||
	     (strcmp(bp->name, "SUNW,hme") == 0)))
		bp->dev = &sc->sc_dev;
d278 1
a278 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
@


1.21.2.4
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d85 20
a104 20
int	hmematch(struct device *, void *, void *);
void	hmeattach(struct device *, struct device *, void *);
void	hmewatchdog(struct ifnet *);
int	hmeintr(void *);
int	hmeioctl(struct ifnet *, u_long, caddr_t);
void	hmereset(struct hme_softc *);
void	hmestart(struct ifnet *);
void	hmestop(struct hme_softc *);
void	hmeinit(struct hme_softc *);
void	hme_meminit(struct hme_softc *);

void	hme_tcvr_bb_writeb(struct hme_softc *, int);
int	hme_tcvr_bb_readb(struct hme_softc *, int);

void	hme_poll_stop(struct hme_softc *sc);

int	hme_rint(struct hme_softc *);
int	hme_tint(struct hme_softc *);
int	hme_mint(struct hme_softc *, u_int32_t);
int	hme_eint(struct hme_softc *, u_int32_t);
d106 2
a107 2
void	hme_reset_rx(struct hme_softc *);
void	hme_reset_tx(struct hme_softc *);
d109 2
a110 2
void		hme_read(struct hme_softc *, int, int);
int		hme_put(struct hme_softc *, int, struct mbuf *);
d115 2
a116 2
int	hme_mediachange(struct ifnet *);
void	hme_mediastatus(struct ifnet *, struct ifmediareq *);
d121 3
a123 3
int	hme_mii_read(struct device *, int, int);
void	hme_mii_write(struct device *, int, int, int);
void	hme_mii_statchg(struct device *);
d125 1
a125 1
void	hme_mcreset(struct hme_softc *);
d165 1
a165 1
	extern void myetheraddr(u_char *);
@


1.21.2.5
log
@Sync the SMP branch with 3.3
@
text
@d213 1
a213 1
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih, IPL_NET);
d387 1
a387 1
		return (error);
d473 1
a473 1
	return (error);
d624 1
a624 1
	/* Turn off MIF interrupts, and disable polling */
d673 1
a673 1
	return (1);
d724 1
a724 1
	return (1);
d759 1
a759 1
	return (1);
d770 1
a770 1
	if (why & GR_STAT_NORXD) {
a771 6
		why &= ~GR_STAT_NORXD;
	}
	if (why & GR_STAT_DTIMEXP) {
		sc->sc_arpcom.ac_if.if_oerrors++;
		why &= ~GR_STAT_DTIMEXP;
	}
d773 1
a773 1
	if (why & GR_STAT_ALL_ERRORS) {
d779 1
a779 1
	return (1);
d832 1
a832 1
	return (tlen);
d1061 1
a1061 1
			return (0);
d1093 1
a1093 1
	return (ret);
d1124 1
a1124 1
	if ((IFM_OPTIONS(sc->sc_mii.mii_media_active) & IFM_FDX) != 0) {
d1126 1
a1126 2
		sc->sc_arpcom.ac_if.if_flags |= IFF_SIMPLEX;
	} else {
a1127 2
		sc->sc_arpcom.ac_if.if_flags &= ~IFF_SIMPLEX;
	}
@


1.21.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.21.2.5 2003/03/27 23:49:25 niklas Exp $	*/
d15 5
@


1.21.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a38 3
#include "bpfilter.h"
#include "vlan.h"

d64 1
a69 4
#if NVLAN > 0
#include <net/if_vlan_var.h>
#endif

a244 1
	ifp->if_capabilities |= IFCAP_VLAN_MTU;
a544 1
	cr->tx_pkt_max = cr->rx_pkt_max = HME_MTU;
@


1.20
log
@uninitialized variable; art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.19 1999/04/18 03:13:14 jason Exp $	*/
d825 6
d832 1
a832 1
	len = MHLEN - pad;
@


1.19
log
@KNF & typo in printf
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.18 1999/02/23 23:44:48 jason Exp $	*/
d1097 1
a1097 1
	int tries = 16, i, ret;
@


1.18
log
@better promisc and allmulti handling
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.17 1999/02/06 03:42:57 jason Exp $	*/
d220 1
a220 1
			sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN) <= 0) {
d225 1
a225 1
		ether_sprintf(sc->sc_arpcom.ac_enaddr), sc->sc_rev);
d1064 1
a1064 1
			printf("%s: mii_read failed\n", sc->sc_dev.dv_xname);
@


1.17
log
@match qfe's as hme's
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.16 1999/01/31 21:56:46 jason Exp $	*/
a419 1
		sc->sc_promisc = ifp->if_flags & IFF_PROMISC;
a555 5
	cr->htable3 = 0;
	cr->htable2 = 0;
	cr->htable1 = 0;
	cr->htable0 = 0;

d593 2
a594 1
	cr->rx_cfg = CR_RXCFG_HENABLE;
d938 7
d950 1
a950 5
		return;
	}

	if (ifp->if_flags & IFF_PROMISC) {
		cr->rx_cfg |= CR_RXCFG_PMISC;
d973 1
d1002 1
@


1.16
log
@Typo in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.15 1999/01/07 03:14:42 jason Exp $	*/
d146 2
a147 1
	    strcmp("SUNW,hme", ra->ra_name)) {
@


1.15
log
@Take advantage of kernel printf %b
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.14 1998/12/14 17:37:24 jason Exp $	*/
d39 1
a39 1
 * Thanks go to the Univeristy of North Carolina at Greensboro Systems
@


1.14
log
@Do clamping of dvma burst size like everything else
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.13 1998/11/11 00:26:00 jason Exp $	*/
d775 3
a777 62
	if (why &  GR_STAT_RFIFOVF) {	/* probably dma error */
		printf("%s: receive fifo overflow\n", sc->sc_dev.dv_xname);
		hmereset(sc);
	}

	if (why & GR_STAT_STSTERR) {
		printf("%s: SQE test failed: resetting\n", sc->sc_dev.dv_xname);
		hmereset(sc);
	}

	if (why & GR_STAT_TFIFO_UND) {	/* probably dma error */
		printf("%s: tx fifo underrun\n", sc->sc_dev.dv_xname);
		hmereset(sc);
	}

	if (why & GR_STAT_MAXPKTERR) {	/* driver bug */
		printf("%s: tx max packet size error\n", sc->sc_dev.dv_xname);
		hmereset(sc);
	}

	if (why & GR_STAT_NORXD) {	/* driver bug */
		printf("%s: out of receive descriptors\n", sc->sc_dev.dv_xname);
		hmereset(sc);
	}

	if (why & GR_STAT_EOPERR) {
		printf("%s: eop not set in tx descriptor\n",
		    sc->sc_dev.dv_xname);
		hmereset(sc);
	}

	if (why & (GR_STAT_RXERR | GR_STAT_RXPERR | GR_STAT_RXTERR)) {
		printf("%s: rx dma error < ", sc->sc_dev.dv_xname);
		if (why & GR_STAT_RXERR)
			printf("Generic ");
		if (why & GR_STAT_RXPERR);
			printf("Parity ");
		if (why & GR_STAT_RXTERR)
			printf("RxTag ");
		printf(" >\n");
		hmereset(sc);
	}

	if (why &
	    (GR_STAT_TXEACK|GR_STAT_TXLERR|GR_STAT_TXPERR|GR_STAT_TXTERR)) {
		printf("%s: rx dma error < ", sc->sc_dev.dv_xname);
		if (why & GR_STAT_TXEACK)
			printf("Generic ");
		if (why & GR_STAT_TXLERR);
			printf("Late ");
		if (why & GR_STAT_TXPERR)
			printf("Parity ");
		if (why & GR_STAT_TXTERR);
			printf("TxTag ");
		printf(" >\n");
		hmereset(sc);
	}

	if (why & (GR_STAT_SLVERR | GR_STAT_SLVPERR)) {
		printf("%s: sbus %s error accessing registers\n",
			sc->sc_dev.dv_xname,
			(why & GR_STAT_SLVPERR) ? "parity" : "generic");
@


1.13
log
@Detect cards that require dma that are in non-dma slots and don't allow
them to be attach'd.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.12 1998/10/02 17:42:24 jason Exp $	*/
d199 6
a204 1
	sc->sc_burst = ((struct sbus_softc *)parent)->sc_burst;
@


1.12
log
@Fixed multicast filter setup.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.11 1998/09/24 22:16:37 jason Exp $	*/
d149 2
@


1.11
log
@o If using the serial phy interface and an bad phy addr is requested, make
sure to return all zeros.
o updated acknowlegements
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.10 1998/09/16 22:02:05 jason Exp $	*/
d548 1
d590 1
a590 1
	
d987 4
a992 3
	u_int16_t hash[4];
	u_int32_t crc;
	int i, j;
d999 1
d1001 2
a1002 1
	else if (ifp->if_flags & IFF_PROMISC) {
d1004 1
a1005 4
	else {
		cr->htable3 = cr->htable2 = cr->htable1 = cr->htable0 = 0;
		hash[3] = hash[2] = hash[1] = hash[0] = 0;
		crc = 0xffffffffU;
d1007 22
a1028 2
		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
d1030 1
a1030 2
			for (i = 0; i < ETHER_ADDR_LEN; i++) {
				u_int8_t octet = enm->enm_addrlo[i];
d1032 2
a1033 2
				for (j = 0; j < 8; j++) {
					u_int8_t bit;
d1035 2
a1036 1
					bit = (octet << j) & 1;
d1038 1
a1038 2
					if ((bit ^ crc) & 1)
						crc = crc ^ MC_POLY_LE;
d1040 3
d1044 1
d1046 9
a1054 9
			crc >>=26;
			hash[crc >> 4] |= 1 << (crc & 0x0f);
			ETHER_NEXT_MULTI(step, enm);
		}
		cr->htable3 = hash[3];
		cr->htable2 = hash[2];
		cr->htable1 = hash[1];
		cr->htable0 = hash[0];
	}
@


1.10
log
@missed flags from mii layer merge
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.9 1998/09/10 22:15:21 jason Exp $	*/
d38 4
a627 31
/*
 * Writing to the serial BitBang, is a matter of putting the bit
 * into the data register, then strobing the clock.
 */
static void
hme_tcvr_bb_writeb(sc, b)
	struct hme_softc *sc;
	int b;
{
	sc->sc_tcvr->bb_data = b & 0x1;
	sc->sc_tcvr->bb_clock = 0;
	sc->sc_tcvr->bb_clock = 1;
}

static int
hme_tcvr_bb_readb(sc, phy)
	struct hme_softc *sc;
	int phy;
{
	int ret;

	sc->sc_tcvr->bb_clock = 0;
	DELAY(10);
	if (phy == TCVR_PHYADDR_ITX)
		ret = sc->sc_tcvr->cfg & TCVR_CFG_MDIO0;
	if (phy == TCVR_PHYADDR_ETX)
		ret = sc->sc_tcvr->cfg & TCVR_CFG_MDIO1;
	sc->sc_tcvr->bb_clock = 1;
	return ((ret) ? 1 : 0);
}

d1033 40
a1202 2

	/* XXX Update ifp->if_baudrate */
@


1.9
log
@default media type is auto if a phy is found, and none if not
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.8 1998/09/10 17:34:32 jason Exp $	*/
d509 1
d600 4
@


1.8
log
@Modified to use mii layer for hme
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.6 1998/09/08 04:48:38 jason Exp $	*/
d222 8
a229 1
	ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER | IFM_NONE);
@


1.7
log
@Better if_media support (actually works consistently now for non-autoneg)
@
text
@d76 2
d92 2
a93 10
static void	hme_tcvr_write	    __P((struct hme_softc *, int reg,
					u_short val));
static int	hme_tcvr_read	    __P((struct hme_softc *, int reg));
static void	hme_tcvr_bb_write   __P((struct hme_softc *, int reg,
					u_short val));
static int	hme_tcvr_bb_read    __P((struct hme_softc *, int reg));
static void	hme_tcvr_bb_writeb  __P((struct hme_softc *, int b));
static int	hme_tcvr_bb_readb   __P((struct hme_softc *));
static void	hme_tcvr_check	    __P((struct hme_softc *));
static int	hme_tcvr_reset	    __P((struct hme_softc *));
a101 5
static void	hme_auto_negotiate __P((struct hme_softc *));
static void	hme_negotiate_watchdog __P((void *));
static void	hme_print_link_mode __P((struct hme_softc *));
static void	hme_set_initial_advertisement	__P((struct hme_softc *));

d109 12
a120 2
static int	hme_ifmedia_upd __P((struct ifnet *));
static void	hme_ifmedia_sts __P((struct ifnet *, struct ifmediareq *));
a196 2
	hme_set_initial_advertisement(sc);

d212 12
a235 6
	sc->sc_an_state = HME_TIMER_DONE;
	sc->sc_an_ticks = 0;

	printf(" pri %d: address %s rev %d\n", pri,
		ether_sprintf(sc->sc_arpcom.ac_enaddr), sc->sc_rev);

d314 1
d450 1
a450 1
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_ifmedia, cmd);
a520 14
	hme_tcvr_check(sc);
	switch (sc->sc_tcvr_type) {
	case HME_TCVR_NONE:
		printf("%s: no transceiver type!\n", sc->sc_dev.dv_xname);
		return;
	case HME_TCVR_INTERNAL:
		cr->xif_cfg = 0;
		break;
	case HME_TCVR_EXTERNAL:
		cr->xif_cfg = CR_XCFG_MIIDISAB;
		break;
	}
	hme_tcvr_reset(sc);

d581 1
a581 4
	c = CR_TXCFG_DGIVEUP;
	if (sc->sc_flags & HME_FLAG_FULL)
		c |= CR_TXCFG_FULLDPLX;
	cr->tx_cfg = c;
a585 2
	if (sc->sc_tcvr_type == HME_TCVR_EXTERNAL)
		c |= CR_XCFG_MIIDISAB;
d591 1
a591 221
	hme_ifmedia_upd(&sc->sc_arpcom.ac_if);
}

static void
hme_set_initial_advertisement(sc)
	struct hme_softc *sc;
{
	hmestop(sc);
	sc->sc_tcvr->int_mask = 0xffff;
	if (sc->sc_flags & HME_FLAG_FENABLE)
		sc->sc_tcvr->cfg &= ~(TCVR_CFG_BENABLE);
	else
		sc->sc_tcvr->cfg |= TCVR_CFG_BENABLE;

	hme_tcvr_check(sc);
	switch (sc->sc_tcvr_type) {
	case HME_TCVR_NONE:
		return;
	case HME_TCVR_INTERNAL:
		sc->sc_cr->xif_cfg = 0;
		break;
	case HME_TCVR_EXTERNAL:
		sc->sc_cr->xif_cfg = CR_XCFG_MIIDISAB;
		break;
	}
	if (hme_tcvr_reset(sc))
		return;

	/* grab the supported modes and advertised modes */
	sc->sc_sw.bmsr = hme_tcvr_read(sc, DP83840_BMSR);
	sc->sc_sw.anar = hme_tcvr_read(sc, DP83840_ANAR);

	ifmedia_init(&sc->sc_ifmedia, 0, hme_ifmedia_upd, hme_ifmedia_sts);

	/* If 10BaseT Half duplex supported, advertise it, and so on... */
	if (sc->sc_sw.bmsr & BMSR_10BASET_HALF) {
		ifmedia_add(&sc->sc_ifmedia, IFM_ETHER | IFM_10_T, 0, NULL);
		ifmedia_add(&sc->sc_ifmedia,
		    IFM_ETHER | IFM_10_T | IFM_HDX, 0, NULL);
		sc->sc_ifmedia.ifm_media = IFM_ETHER | IFM_10_T | IFM_HDX;
		sc->sc_sw.anar |= ANAR_10;
	}
	else
		sc->sc_sw.anar &= ~(ANAR_10);

	if (sc->sc_sw.bmsr & BMSR_10BASET_FULL) {
		ifmedia_add(&sc->sc_ifmedia,
		    IFM_ETHER | IFM_10_T | IFM_FDX, 0, NULL);
		sc->sc_ifmedia.ifm_media = IFM_ETHER | IFM_10_T | IFM_FDX;
		sc->sc_sw.anar |= ANAR_10_FD;
	}
	else
		sc->sc_sw.anar &= ~(ANAR_10_FD);

	if (sc->sc_sw.bmsr & BMSR_100BASETX_HALF) {
		ifmedia_add(&sc->sc_ifmedia, IFM_ETHER | IFM_100_TX, 0, NULL);
		ifmedia_add(&sc->sc_ifmedia,
		    IFM_ETHER | IFM_100_TX | IFM_HDX, 0, NULL);
		sc->sc_ifmedia.ifm_media = IFM_ETHER | IFM_100_TX | IFM_HDX;
		sc->sc_sw.anar |= ANAR_TX;
	}
	else
		sc->sc_sw.anar &= ~(ANAR_TX);

	if (sc->sc_sw.bmsr & BMSR_100BASETX_FULL) {
		ifmedia_add(&sc->sc_ifmedia,
		    IFM_ETHER | IFM_100_TX | IFM_FDX, 0, NULL);
		sc->sc_ifmedia.ifm_media = IFM_ETHER | IFM_100_TX | IFM_FDX;
		sc->sc_sw.anar |= ANAR_TX_FD;
	}
	else
		sc->sc_sw.anar &= ~(ANAR_TX_FD);

	if (sc->sc_sw.bmsr & BMSR_ANC) {
		ifmedia_add(&sc->sc_ifmedia, IFM_ETHER | IFM_AUTO, 0, NULL);
		sc->sc_ifmedia.ifm_media = IFM_ETHER | IFM_AUTO;
	}

	ifmedia_set(&sc->sc_ifmedia, sc->sc_ifmedia.ifm_media);

	/* Inform card about what it should advertise */
	hme_tcvr_write(sc, DP83840_ANAR, sc->sc_sw.anar);
}

#define XCVR_RESET_TRIES	16
#define XCVR_UNISOLATE_TRIES	32

static int
hme_tcvr_reset(sc)
	struct hme_softc *sc;
{
	struct hme_tcvr *tcvr = sc->sc_tcvr;
	u_int32_t cfg;
	int result, tries = XCVR_RESET_TRIES;

	cfg = tcvr->cfg;
	if (sc->sc_tcvr_type == HME_TCVR_EXTERNAL) {
		tcvr->cfg = cfg & ~(TCVR_CFG_PSELECT);
		sc->sc_tcvr_type = HME_TCVR_INTERNAL;
		sc->sc_phyaddr = TCVR_PHYADDR_ITX;
		hme_tcvr_write(sc, DP83840_BMCR,
			(BMCR_LOOPBACK | BMCR_PDOWN | BMCR_ISOLATE));
		result = hme_tcvr_read(sc, DP83840_BMCR);
		if (result == TCVR_FAILURE) {
			printf("%s: tcvr_reset failed\n", sc->sc_dev.dv_xname);
			return -1;
		}
		tcvr->cfg = cfg | TCVR_CFG_PSELECT;
		sc->sc_tcvr_type = HME_TCVR_EXTERNAL;
		sc->sc_phyaddr = TCVR_PHYADDR_ETX;
	}
	else {
		if (cfg & TCVR_CFG_MDIO1) {
			tcvr->cfg = cfg | TCVR_CFG_PSELECT;
			hme_tcvr_write(sc, DP83840_BMCR,
				(BMCR_LOOPBACK | BMCR_PDOWN | BMCR_ISOLATE));
			result = hme_tcvr_read(sc, DP83840_BMCR);
			if (result == TCVR_FAILURE) {
				printf("%s: tcvr_reset failed\n",
					sc->sc_dev.dv_xname);
				return -1;
			}
			tcvr->cfg = cfg & ~(TCVR_CFG_PSELECT);
			sc->sc_tcvr_type = HME_TCVR_INTERNAL;
			sc->sc_phyaddr = TCVR_PHYADDR_ITX;
		}
	}

	hme_tcvr_write(sc, DP83840_BMCR, BMCR_RESET);

	while (--tries) {
		result = hme_tcvr_read(sc, DP83840_BMCR);
		if (result == TCVR_FAILURE)
			return -1;
		sc->sc_sw.bmcr = result;
		if (!(result & BMCR_RESET))
			break;
		DELAY(20);
	}
	if (!tries) {
		printf("%s: bmcr reset failed\n", sc->sc_dev.dv_xname);
		return -1;
	}

	sc->sc_sw.bmsr = hme_tcvr_read(sc, DP83840_BMSR);
	sc->sc_sw.phyidr1 = hme_tcvr_read(sc, DP83840_PHYIDR1);
	sc->sc_sw.phyidr2 = hme_tcvr_read(sc, DP83840_PHYIDR2);
	sc->sc_sw.anar = hme_tcvr_read(sc, DP83840_BMSR);

	sc->sc_sw.bmcr &= ~(BMCR_ISOLATE);
	hme_tcvr_write(sc, DP83840_BMCR, sc->sc_sw.bmcr);

	tries = XCVR_UNISOLATE_TRIES;
	while (--tries) {
		result = hme_tcvr_read(sc, DP83840_BMCR);
		if (result == TCVR_FAILURE)
			return -1;
		if (!(result & BMCR_ISOLATE))
			break;
		DELAY(20);
	}
	if (!tries) {
		printf("%s: bmcr unisolate failed\n", sc->sc_dev.dv_xname);
		return -1;
	}

	result = hme_tcvr_read(sc, DP83840_PCR);
	hme_tcvr_write(sc, DP83840_PCR, (result | PCR_CIM_DIS));
	return 0;
}


/*
 * We need to know whether we are using an internal or external transceiver.
 */
static void
hme_tcvr_check(sc)
	struct hme_softc *sc;
{
	struct hme_tcvr *tcvr = sc->sc_tcvr;
	u_int32_t cfg = tcvr->cfg;

	/* polling? */
	if (sc->sc_flags & HME_FLAG_POLL) {
		if (sc->sc_tcvr_type == HME_TCVR_INTERNAL) {
			hme_poll_stop(sc);
			sc->sc_phyaddr = TCVR_PHYADDR_ETX;
			sc->sc_tcvr_type = HME_TCVR_EXTERNAL;
			cfg &= ~(TCVR_CFG_PENABLE);
			cfg |= TCVR_CFG_PSELECT;
			tcvr->cfg = cfg;
		}
		else {
			if (!(tcvr->status >> 16)) {
				hme_poll_stop(sc);
				sc->sc_phyaddr = TCVR_PHYADDR_ITX;
				sc->sc_tcvr_type = HME_TCVR_INTERNAL;
				cfg &= ~(TCVR_CFG_PSELECT);
				tcvr->cfg = cfg;
			}
		}
	}
	else {
		u_int32_t cfg2 = tcvr->cfg;

		if (cfg2 & TCVR_CFG_MDIO1) {
			tcvr->cfg = cfg | TCVR_CFG_PSELECT;
			sc->sc_phyaddr = TCVR_PHYADDR_ETX;
			sc->sc_tcvr_type = HME_TCVR_EXTERNAL;
		}
		else {
			if (cfg2 & TCVR_CFG_MDIO0) {
				tcvr->cfg = cfg & ~(TCVR_CFG_PSELECT);
				sc->sc_phyaddr = TCVR_PHYADDR_ITX;
				sc->sc_tcvr_type = HME_TCVR_INTERNAL;
			}
			else {
				sc->sc_tcvr_type = HME_TCVR_NONE;
			}
		}
	}
d609 1
a609 63
	DELAY(20);
}

#define XCVR_WRITE_TRIES	16

static void
hme_tcvr_write(sc, reg, val)
	struct hme_softc *sc;
	int reg;
	u_short val;
{
	struct hme_tcvr *tcvr = sc->sc_tcvr;
	int tries = XCVR_WRITE_TRIES;

	/* Use the bitbang? */
	if (! (sc->sc_flags & HME_FLAG_FENABLE))
		return hme_tcvr_bb_write(sc, reg, val);

	/* No, good... we just write to the tcvr frame */
	tcvr->frame = (FRAME_WRITE | sc->sc_phyaddr << 23) |
		      ((reg & 0xff) << 18) |
		      (val & 0xffff);
	while (!(tcvr->frame & 0x10000) && (tries != 0)) {
		tries--;
		DELAY(20);
	}

	if (!tries)
		printf("%s: tcvr_write failed\n", sc->sc_dev.dv_xname);
}

#define XCVR_READ_TRIES	16

static int
hme_tcvr_read(sc, reg)
	struct hme_softc *sc;
	int reg;
{
	struct hme_tcvr *tcvr = sc->sc_tcvr;
	int tries = XCVR_READ_TRIES;

	if (sc->sc_tcvr_type == HME_TCVR_NONE) {
		printf("%s: no transceiver type\n", sc->sc_dev.dv_xname);
		return TCVR_FAILURE;
	}

	/* Use the bitbang? */
	if (! (sc->sc_flags & HME_FLAG_FENABLE))
		return hme_tcvr_bb_read(sc, reg);

	/* No, good... we just write/read to the tcvr frame */
	tcvr->frame = (FRAME_READ | sc->sc_phyaddr << 23) |
		      ((reg & 0xff) << 18);
	while (!(tcvr->frame & 0x10000) && (tries != 0)) {
		tries--;
		DELAY(20);
	}

	if (!tries) {
		printf("%s: tcvr_write failed\n", sc->sc_dev.dv_xname);
		return TCVR_FAILURE;
	}
	return (tcvr->frame & 0xffff);
d627 1
a627 1
hme_tcvr_bb_readb(sc)
d629 1
d635 1
a635 1
	if (sc->sc_tcvr_type == HME_TCVR_INTERNAL)
d637 1
a637 1
	else
a642 179
static void
hme_tcvr_bb_write(sc, reg, val)
	struct hme_softc *sc;
	int reg;
	u_short val;
{
	struct hme_tcvr *tcvr = sc->sc_tcvr;
	int i;

	tcvr->bb_oenab = 1;	                /* turn on bitbang intrs */

	for (i = 0; i < 32; i++)		/* make bitbang idle */
		hme_tcvr_bb_writeb(sc, 1);

	hme_tcvr_bb_writeb(sc, 0);		/* 0101 signals a write */
	hme_tcvr_bb_writeb(sc, 1);
	hme_tcvr_bb_writeb(sc, 0);
	hme_tcvr_bb_writeb(sc, 1);

	for (i = 4; i >= 0; i--)		/* send PHY addr */
		hme_tcvr_bb_writeb(sc, ((sc->sc_phyaddr & 0xff) >> i) & 0x1);

	for (i = 4; i >= 0; i--)		/* send register num */
		hme_tcvr_bb_writeb(sc, ((reg & 0xff) >> i) & 0x1);

	hme_tcvr_bb_writeb(sc, 1);		/* get ready for data */
	hme_tcvr_bb_writeb(sc, 0);

	for (i = 15; i >= 0; i--)		/* send new value */
		hme_tcvr_bb_writeb(sc, (val >> i) & 0x1);

	tcvr->bb_oenab = 0;	                /* turn off bitbang intrs */
}

static int
hme_tcvr_bb_read(sc, reg)
	struct hme_softc *sc;
	int reg;
{
	struct hme_tcvr *tcvr = sc->sc_tcvr;
	int ret = 0, i;

	tcvr->bb_oenab = 1;                	/* turn on bitbang intrs */

	for (i = 0; i < 32; i++)		/* make bitbang idle */
		hme_tcvr_bb_writeb(sc, 1);

	hme_tcvr_bb_writeb(sc, 0);		/* 0110 signals a read */
	hme_tcvr_bb_writeb(sc, 1);
	hme_tcvr_bb_writeb(sc, 1);
	hme_tcvr_bb_writeb(sc, 0);

	for (i = 4; i >= 0; i--)		/* send PHY addr */
		hme_tcvr_bb_writeb(sc, ((sc->sc_phyaddr & 0xff) >> i) & 0x1);

	for (i = 4; i >= 0; i--)		/* send register num */
		hme_tcvr_bb_writeb(sc, ((reg & 0xff) >> i) & 0x1);

	tcvr->bb_oenab = 0;	                /* turn off bitbang intrs */

	hme_tcvr_bb_readb(sc);			/* ignore... */

	for (i = 15; i >= 15; i--)		/* read value */
		ret |= hme_tcvr_bb_readb(sc) << i;

	hme_tcvr_bb_readb(sc);			/* ignore... */
	hme_tcvr_bb_readb(sc);			/* ignore... */
	hme_tcvr_bb_readb(sc);			/* ignore... */

	return ret;
}

static void
hme_auto_negotiate(sc)
	struct hme_softc *sc;
{
	int tries;

	/* grab all of the registers */
	sc->sc_sw.bmsr =	hme_tcvr_read(sc, DP83840_BMSR);
	sc->sc_sw.bmcr =	hme_tcvr_read(sc, DP83840_BMCR);
	sc->sc_sw.phyidr1 =	hme_tcvr_read(sc, DP83840_PHYIDR1);
	sc->sc_sw.phyidr2 =	hme_tcvr_read(sc, DP83840_PHYIDR2);
	sc->sc_sw.anar =	hme_tcvr_read(sc, DP83840_ANAR);

	/* can this board autonegotiate? No, die. */
	if (! (sc->sc_sw.bmsr & BMSR_ANC))
		return;

	/* Start autonegoiation */
	sc->sc_sw.bmcr |= BMCR_ANE;	/* enable auto-neg */
	hme_tcvr_write(sc, DP83840_BMCR, sc->sc_sw.bmcr);
	sc->sc_sw.bmcr |= BMCR_RAN;	/* force a restart */
	hme_tcvr_write(sc, DP83840_BMCR, sc->sc_sw.bmcr);

	/* BMCR_RAN clears itself when it has started negotiation... */
	tries = 64;
	while (--tries) {
		int r = hme_tcvr_read(sc, DP83840_BMCR);
		if (r == TCVR_FAILURE)
			return;
		sc->sc_sw.bmcr = r;
		if (! (sc->sc_sw.bmcr & BMCR_RAN))
			break;
		DELAY(100);
	}
	if (!tries) {
		printf("%s: failed to start auto-negotiation\n",
			sc->sc_dev.dv_xname);
		return;
	}
	sc->sc_an_state = HME_TIMER_AUTONEG;
	sc->sc_an_ticks = 0;
	timeout(hme_negotiate_watchdog, sc, (12 * hz)/10);
}

/*
 * If auto-negotiating, check to see if it has completed successfully.  If so,
 * wait for a link up.  If it completed unsucessfully, try the manual process.
 */
static void
hme_negotiate_watchdog(arg)
	void *arg;
{
	struct hme_softc *sc = (struct hme_softc *)arg;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	sc->sc_an_ticks++;
	switch (sc->sc_an_state) {
	    case HME_TIMER_DONE:
		return;
	    case HME_TIMER_AUTONEG:
		sc->sc_sw.bmsr = hme_tcvr_read(sc, DP83840_BMSR);
		if (sc->sc_sw.bmsr & BMSR_ANCOMPLETE) {
			sc->sc_an_state = HME_TIMER_LINKUP;
			sc->sc_an_ticks = 0;
			timeout(hme_negotiate_watchdog, sc, (12 * hz)/10);
			return;
		}
		if (sc->sc_an_ticks > 10) {
			printf("%s: auto-negotiation failed.\n",
				sc->sc_dev.dv_xname);
			hme_auto_negotiate(sc);
			return;
		}
		timeout(hme_negotiate_watchdog, sc, (12 * hz)/10);
		break;
	    case HME_TIMER_LINKUP:
		ifp->if_flags |= IFF_RUNNING;
		ifp->if_flags &= ~IFF_OACTIVE;
		ifp->if_timer = 0;
		hmestart(ifp);
		sc->sc_sw.bmsr = hme_tcvr_read(sc, DP83840_BMSR);
		if (sc->sc_sw.bmsr & BMSR_LINKSTATUS) {
			sc->sc_an_state = HME_TIMER_DONE;
			sc->sc_an_ticks = 0;
			hme_print_link_mode(sc);
			return;
		}
		if ((sc->sc_an_ticks % 10) == 0) {
			printf("%s: link down...\n", sc->sc_dev.dv_xname);
			timeout(hme_negotiate_watchdog, sc, (12 * hz)/10);
			return;
		}
	}
}

static void 
hme_print_link_mode(sc)
	struct hme_softc *sc;
{
	sc->sc_sw.bmcr = hme_tcvr_read(sc, DP83840_BMCR);
	printf("%s: %s transceiver up %dMb/s %s duplex\n",
	    sc->sc_dev.dv_xname,
	    (sc->sc_tcvr_type == HME_TCVR_EXTERNAL) ? "external" : "internal",
	    (sc->sc_sw.bmcr & BMCR_SPEED) ? 100 : 10,
	    (sc->sc_sw.bmcr & BMCR_DUPLEX) ? "full" : "half");
}

a682 3
	sc->sc_sw.bmcr = hme_tcvr_read(sc, DP83840_BMCR);
	sc->sc_sw.anlpar = hme_tcvr_read(sc, DP83840_ANLPAR);

a683 9
	if (sc->sc_sw.anlpar & ANLPAR_TX_FD) {
		sc->sc_sw.bmcr |= (BMCR_SPEED | BMCR_DUPLEX);
	} else if (sc->sc_sw.anlpar & ANLPAR_TX) {
		sc->sc_sw.bmcr |= BMCR_SPEED;
	} else if (sc->sc_sw.anlpar & ANLPAR_10_FD) {
		sc->sc_sw.bmcr |= BMCR_DUPLEX;
	} /* else 10Mb half duplex... */
	hme_tcvr_write(sc, DP83840_BMCR, sc->sc_sw.bmcr);
	hme_print_link_mode(sc);
a1047 3
/*
 * Get current media settings.
 */
d1049 3
a1051 3
hme_ifmedia_sts(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
d1053 29
a1081 1
	struct hme_softc *sc = ifp->if_softc;
d1083 2
a1084 2
	sc->sc_sw.bmcr = hme_tcvr_read(sc, DP83840_BMCR);
	sc->sc_sw.bmsr = hme_tcvr_read(sc, DP83840_BMSR);
d1086 2
a1087 14
	switch (sc->sc_sw.bmcr & (BMCR_SPEED | BMCR_DUPLEX)) {
	case (BMCR_SPEED | BMCR_DUPLEX):
		ifmr->ifm_active = IFM_ETHER | IFM_100_TX | IFM_FDX;
		break;
	case BMCR_SPEED:
		ifmr->ifm_active = IFM_ETHER | IFM_100_TX | IFM_HDX;
		break;
	case BMCR_DUPLEX:
		ifmr->ifm_active = IFM_ETHER | IFM_10_T | IFM_FDX;
		break;
	case 0:
		ifmr->ifm_active = IFM_ETHER | IFM_10_T | IFM_HDX;
		break;
	}
d1089 1
a1089 6
	if (sc->sc_sw.bmsr & BMSR_LINKSTATUS)
		ifmr->ifm_status |= IFM_AVALID | IFM_ACTIVE;
	else {
		ifmr->ifm_status |= IFM_AVALID;
		ifmr->ifm_status &= ~IFM_ACTIVE;
	}
d1093 3
a1095 2
hme_ifmedia_upd(ifp)
	struct ifnet *ifp;
d1097 20
a1116 2
	struct hme_softc *sc = ifp->if_softc;
	struct ifmedia *ifm = &sc->sc_ifmedia;
d1118 2
a1119 2
	if (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)
		return (EINVAL);
d1121 4
a1124 1
	sc->sc_sw.bmsr = hme_tcvr_read(sc, DP83840_BMSR);
d1126 2
a1127 8
	if (IFM_SUBTYPE(ifm->ifm_media) == IFM_AUTO &&
	    sc->sc_sw.bmsr & BMSR_ANC) {
		
		/* advertise -everything- supported */
		if (sc->sc_sw.bmsr & BMSR_10BASET_HALF)
			sc->sc_sw.anar |= ANAR_10;
		else
			sc->sc_sw.anar &= ~(ANAR_10);
d1129 2
a1130 4
		if (sc->sc_sw.bmsr & BMSR_10BASET_FULL)
			sc->sc_sw.anar |= ANAR_10_FD;
		else
			sc->sc_sw.anar &= ~(ANAR_10_FD);
d1132 1
a1132 4
		if (sc->sc_sw.bmsr & BMSR_100BASETX_HALF)
			sc->sc_sw.anar |= ANAR_TX;
		else
			sc->sc_sw.anar &= ~(ANAR_TX);
d1134 1
a1134 4
		if (sc->sc_sw.bmsr & BMSR_100BASETX_FULL)
			sc->sc_sw.anar |= ANAR_TX_FD;
		else
			sc->sc_sw.anar &= ~(ANAR_TX_FD);
d1136 2
a1137 6
		hme_tcvr_write(sc, DP83840_ANAR, sc->sc_sw.anar);
		hme_auto_negotiate(sc);
		return (0);
	}
	if (IFM_SUBTYPE(ifm->ifm_media) == IFM_AUTO)
		return (EINVAL);
d1139 3
a1141 10
	sc->sc_sw.anar = hme_tcvr_read(sc, DP83840_ANAR);
	sc->sc_sw.anar &= ~(ANAR_T4 | ANAR_TX_FD | ANAR_TX
	    | ANAR_10_FD | ANAR_10);

	if (IFM_SUBTYPE(ifm->ifm_media) == IFM_100_TX) {
		if ((ifm->ifm_media & IFM_GMASK) == IFM_FDX)
			sc->sc_sw.anar |= ANAR_TX_FD;
		else
			sc->sc_sw.anar |= ANAR_TX;
	}
d1143 2
a1144 6
	if (IFM_SUBTYPE(ifm->ifm_media) == IFM_10_T) {
		if ((ifm->ifm_media & IFM_GMASK) == IFM_FDX)
			sc->sc_sw.anar |= ANAR_10_FD;
		else
			sc->sc_sw.anar |= ANAR_10;
	}
d1146 6
a1151 2
	hme_tcvr_write(sc, DP83840_ANAR, sc->sc_sw.anar);
	hme_auto_negotiate(sc);
d1153 27
@


1.6
log
@o hme get ifmedia support
o nuked manual negotiatie that wasn't finished anyway in favor of if_media
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.5 1998/09/01 17:36:59 jason Exp $	*/
d743 1
a743 1
		DELAY(200);
d765 1
a765 1
		DELAY(200);
d844 1
a844 1
	DELAY(200);
d868 1
a868 1
		DELAY(200);
d899 1
a899 1
		DELAY(200);
a1027 23
	/* advertise -everything- supported */
	if (sc->sc_sw.bmsr & BMSR_10BASET_HALF)
		sc->sc_sw.anar |= ANAR_10;
	else
		sc->sc_sw.anar &= ~(ANAR_10);

	if (sc->sc_sw.bmsr & BMSR_10BASET_FULL)
		sc->sc_sw.anar |= ANAR_10_FD;
	else
		sc->sc_sw.anar &= ~(ANAR_10_FD);

	if (sc->sc_sw.bmsr & BMSR_100BASETX_HALF)
		sc->sc_sw.anar |= ANAR_TX;
	else
		sc->sc_sw.anar &= ~(ANAR_TX);

	if (sc->sc_sw.bmsr & BMSR_100BASETX_FULL)
		sc->sc_sw.anar |= ANAR_TX_FD;
	else
		sc->sc_sw.anar &= ~(ANAR_TX_FD);

	hme_tcvr_write(sc, DP83840_ANAR, sc->sc_sw.anar);

a1070 1
		printf("%s: tick: autoneg...\n", sc->sc_dev.dv_xname);
d1081 1
a1086 1
		printf("%s: tick: linkup..\n", sc->sc_dev.dv_xname);
d1110 1
a1110 1
	sc->sc_sw.anlpar = hme_tcvr_read(sc, DP83840_ANLPAR);
d1114 2
a1115 2
	    (sc->sc_sw.anlpar & (ANLPAR_TX_FD | ANLPAR_TX)) ? 100 : 10,
	    (sc->sc_sw.anlpar & (ANLPAR_TX_FD | ANLPAR_10_FD)) ? "full" : "half");
a1576 1
	int tries, result;
d1581 2
d1585 23
d1614 3
a1616 7
	hme_tcvr_write(sc, DP83840_BMCR,
	    (BMCR_LOOPBACK | BMCR_PDOWN | BMCR_ISOLATE));
	if (result == TCVR_FAILURE) {
		printf("%s: tcvr_reset failed\n", sc->sc_dev.dv_xname);
		return (EIO);
	}
	hme_tcvr_write(sc, DP83840_BMCR, BMCR_RESET);
d1618 5
a1622 13
	tries = 32;
	while (--tries) {
		result = hme_tcvr_read(sc, DP83840_BMCR);
		if (result == TCVR_FAILURE)
			return (EIO);
		sc->sc_sw.bmcr = result;
		if (!(result & BMCR_RESET))
			break;
		DELAY(200);
	}
	if (!tries) {
		printf("%s: bmcr reset failed\n", sc->sc_dev.dv_xname);
		return -1;
d1625 5
a1629 30
	sc->sc_sw.bmcr = hme_tcvr_read(sc, DP83840_BMCR);

	if (IFM_SUBTYPE(ifm->ifm_media) == IFM_100_T4) {
		sc->sc_sw.bmcr |= BMCR_SPEED;
		sc->sc_sw.bmcr &= ~BMCR_DUPLEX;
	}

	if (IFM_SUBTYPE(ifm->ifm_media) == IFM_100_TX)
		sc->sc_sw.bmcr |= BMCR_SPEED;

	if (IFM_SUBTYPE(ifm->ifm_media) == IFM_10_T)
		sc->sc_sw.bmcr &= ~BMCR_SPEED;

	if ((ifm->ifm_media & IFM_GMASK) == IFM_FDX)
		sc->sc_sw.bmcr |= BMCR_DUPLEX;
	else
		sc->sc_sw.bmcr &= ~BMCR_DUPLEX;

	sc->sc_sw.bmcr &= ~(BMCR_ISOLATE);
	hme_tcvr_write(sc, DP83840_BMCR, sc->sc_sw.bmcr);
	tries = 32;
	while (--tries) {
		sc->sc_sw.bmcr = hme_tcvr_read(sc, DP83840_BMCR);
		if ((sc->sc_sw.bmcr & BMCR_ISOLATE) == 0)
			break;
		DELAY(20);
	}
	if (!tries) {
		printf("%s: bmcr unisolate failed\n", sc->sc_dev.dv_xname);
		return (EIO);
d1632 2
@


1.5
log
@o Removed dependence on stp2002 (not sharable with qec+be)
o Added collision counters
o Should work on sun4c
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.4 1998/07/17 21:33:07 jason Exp $	*/
d55 1
a108 1
static void	hme_manual_negotiate __P((struct hme_softc *));
d120 4
a123 1
static void hme_mcreset __P((struct hme_softc *));
d444 4
d606 1
a606 1
	hme_auto_negotiate(sc);
d638 2
d641 5
a645 1
	if (sc->sc_sw.bmsr & BMSR_10BASET_HALF)
d647 1
d651 4
a654 1
	if (sc->sc_sw.bmsr & BMSR_10BASET_FULL)
d656 1
d660 5
a664 1
	if (sc->sc_sw.bmsr & BMSR_100BASETX_HALF)
d666 1
d670 4
a673 1
	if (sc->sc_sw.bmsr & BMSR_100BASETX_FULL)
d675 1
d679 7
d1024 1
a1024 1
	/* can this board autonegotiate? No, do it manually */
d1026 1
a1026 1
		hme_manual_negotiate(sc);
a1070 1
		hme_manual_negotiate(sc);
a1077 8
static void
hme_manual_negotiate(sc)
	struct hme_softc *sc;
{
	printf("%s: Starting manual negotiation... not yet!\n",
		sc->sc_dev.dv_xname);
}

d1557 113
@


1.4
log
@Moved most of the DMA functions to a chipset driver so that
'hme' and 'be' can share the same logic.
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.3 1998/07/13 02:27:41 jason Exp $	*/
a74 1
#include <sparc/dev/stp2002var.h>
d87 1
d102 2
d115 4
a118 1
static void	hme_tx_dmawakeup	__P((void *v));
d153 1
a153 1
	struct ifnet *ifp = &sc->sc_stp.stp_arpcom.ac_if;
d159 2
a160 1
		printf(": expected 1 interrupt, got %d\n", ca->ca_ra.ra_nintr);
d193 1
a193 2
	sc->sc_stp.stp_tx_dmawakeup = hme_tx_dmawakeup;
	stp2002_meminit(&sc->sc_stp);
d208 2
a209 2
			sc->sc_stp.stp_arpcom.ac_enaddr, ETHER_ADDR_LEN) <= 0) {
		myetheraddr(sc->sc_stp.stp_arpcom.ac_enaddr);
d228 1
a228 1
		ether_sprintf(sc->sc_stp.stp_arpcom.ac_enaddr), sc->sc_rev);
d248 6
a253 1
	struct hme_softc *sc = (struct hme_softc *)ifp->if_softc;
d255 30
a284 2
	stp2002_start(&sc->sc_stp);
}
d286 5
a290 5
void
hme_tx_dmawakeup(v)
	void *v;
{
	struct hme_softc *sc = (struct hme_softc *)v;
d292 1
a292 1
	sc->sc_txr->tx_pnding = TXR_TP_DMAWAKEUP;
d336 1
a336 1
	++sc->sc_stp.stp_arpcom.ac_if.if_oerrors;
d354 1
a354 1
	if ((error = ether_ioctl(ifp, &sc->sc_stp.stp_arpcom, cmd, data)) > 0) {
d366 1
a366 1
			arp_ifinit(&sc->sc_stp.stp_arpcom, ifa);
d377 1
a377 1
				    *(union ns_host *)(sc->sc_stp.stp_arpcom.ac_enaddr);
d380 2
a381 2
				    sc->sc_stp.stp_arpcom.ac_enaddr,
				    sizeof(sc->sc_stp.stp_arpcom.ac_enaddr));
d429 2
a430 2
			ether_addmulti(ifr, &sc->sc_stp.stp_arpcom):
			ether_delmulti(ifr, &sc->sc_stp.stp_arpcom);
d449 38
d500 1
a500 1
	stp2002_meminit(&sc->sc_stp);
d527 8
a534 8
	cr->rand_seed = sc->sc_stp.stp_arpcom.ac_enaddr[5] |
	    ((sc->sc_stp.stp_arpcom.ac_enaddr[4] << 8) & 0x3f00);
	cr->mac_addr0 = (sc->sc_stp.stp_arpcom.ac_enaddr[0] << 8) |
			   sc->sc_stp.stp_arpcom.ac_enaddr[1];
	cr->mac_addr1 = (sc->sc_stp.stp_arpcom.ac_enaddr[2] << 8) |
			   sc->sc_stp.stp_arpcom.ac_enaddr[3];
	cr->mac_addr2 = (sc->sc_stp.stp_arpcom.ac_enaddr[4] << 8) |
			   sc->sc_stp.stp_arpcom.ac_enaddr[5];
d544 2
a545 2
	rxr->rx_ring = sc->sc_stp.stp_rx_dvma;
	txr->tx_ring = sc->sc_stp.stp_tx_dvma;
d561 1
a561 1
	txr->tx_rsize = (STP_TX_RING_SIZE >> TXR_RSIZE_SHIFT) - 1;
d564 2
a565 2
	c = RXR_CFG_DMAENABLE | (STP_RX_OFFSET << 3) | (STP_RX_CSUMLOC << 16);
#if STP_RX_RING_SIZE == 32
d567 1
a567 1
#elif STP_RX_RING_SIZE == 64
d569 1
a569 1
#elif STP_RX_RING_SIZE == 128
d571 1
a571 1
#elif STP_RX_RING_SIZE == 256
d574 1
a574 1
#error "STP_RX_RING_SIZE must be 32, 64, 128, or 256."
d1062 1
a1062 1
	struct ifnet *ifp = &sc->sc_stp.stp_arpcom.ac_if;
d1175 86
d1357 1
a1357 1
		r |= stp2002_tint(&sc->sc_stp);
d1360 1
a1360 1
		r |= stp2002_rint(&sc->sc_stp);
d1365 112
d1484 2
a1485 2
	struct arpcom *ac = &sc->sc_stp.stp_arpcom;
	struct ifnet *ifp = &sc->sc_stp.stp_arpcom.ac_if;
@


1.3
log
@- Fix handling of 'local-mac-address' (use it if present, otherwise default
  to myetheraddr()
- Add multicast support
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.2 1998/07/10 19:20:13 jason Exp $	*/
d75 1
d84 1
a84 1
void	hmereset	__P((struct hme_softc *sc));
d86 2
a87 2
void	hmestop		__P((struct hme_softc *sc));
void	hmeinit		__P((struct hme_softc *sc));
d89 1
a89 1
static void	hme_tcvr_write	    __P((struct hme_softc *sc, int reg,
d91 2
a92 2
static int	hme_tcvr_read	    __P((struct hme_softc *sc, int reg));
static void	hme_tcvr_bb_write   __P((struct hme_softc *sc, int reg,
d94 5
a98 5
static int	hme_tcvr_bb_read    __P((struct hme_softc *sc, int reg));
static void	hme_tcvr_bb_writeb  __P((struct hme_softc *sc, int b));
static int	hme_tcvr_bb_readb   __P((struct hme_softc *sc));
static void	hme_tcvr_check	    __P((struct hme_softc *sc));
static int	hme_tcvr_reset	    __P((struct hme_softc *sc));
a102 2
static int	hme_tint	__P((struct hme_softc *, u_int32_t));
static int	hme_rint	__P((struct hme_softc *, u_int32_t));
d105 9
a113 13
static void	hme_auto_negotiate __P((struct hme_softc *sc));
static void	hme_manual_negotiate __P((struct hme_softc *sc));
static void	hme_negotiate_watchdog __P((void *arg));
static void	hme_print_link_mode __P((struct hme_softc *sc));
static void	hme_set_initial_advertisement	__P((struct hme_softc *sc));

static void	hme_reset_rx __P((struct hme_softc *sc));
static void	hme_reset_tx __P((struct hme_softc *sc));
static void	hme_meminit __P((struct hme_softc *sc));

static int	hme_put __P((struct hme_softc *sc, int idx, struct mbuf *m));
static struct mbuf *hme_get __P((struct hme_softc *sc, int idx, int len));
static void	hme_read __P((struct hme_softc *sc, int idx, int len));
d148 1
a148 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d187 2
a188 5
	sc->sc_desc_dva = (struct hme_desc *) dvma_malloc(
		sizeof(struct hme_desc), &(sc->sc_desc), M_NOWAIT);
	sc->sc_bufs_dva = (struct hme_bufs *) dvma_malloc(
		sizeof(struct hme_bufs) + RX_ALIGN_SIZE, &(sc->sc_bufs),
		M_NOWAIT); /* XXX must be aligned on 64 byte boundary */
d203 2
a204 2
			sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN) <= 0) {
		myetheraddr(sc->sc_arpcom.ac_enaddr);
d223 1
a223 1
		ether_sprintf(sc->sc_arpcom.ac_enaddr), sc->sc_rev);
d243 1
a243 3
	struct hme_softc *sc = ifp->if_softc;
	struct mbuf *m;
	int bix, len;
d245 2
a246 2
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
		return;
d248 5
a252 34
	bix = sc->sc_last_td;

	for (;;) {
		IF_DEQUEUE(&ifp->if_snd, m);
		if (m == 0)
			break;
#if NBPFILTER > 0
		/*
		 * If BPF is listening on this interface, let it see the
		 * packet before we commit it to the wire.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m);
#endif

		/*
		 * Copy the mbuf chain into the transmit buffer.
		 */
		len = hme_put(sc, bix, m);

		/*
		 * Initialize transmit registers and start transmission
		 */
		sc->sc_desc->hme_txd[bix].tx_addr = (u_long) sc->sc_bufs_dva +
			(((u_long) &(sc->sc_bufs->tx_buf[bix])) -
			((u_long) sc->sc_bufs));
		sc->sc_desc->hme_txd[bix].tx_flags =
			TXFLAG_OWN | TXFLAG_SOP | TXFLAG_EOP |
			(len & TXFLAG_SIZE);

		sc->sc_txr->tx_pnding = TXR_TP_DMAWAKEUP;

		if (++bix == TX_RING_SIZE)
			bix = 0;
d254 1
a254 7
		if (++sc->sc_no_td == TX_RING_SIZE) {
			ifp->if_flags |= IFF_OACTIVE;
			break;
		}
	}

	sc->sc_last_td = bix;
d298 1
a298 1
	++sc->sc_arpcom.ac_if.if_oerrors;
d316 1
a316 1
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
d328 1
a328 1
			arp_ifinit(&sc->sc_arpcom, ifa);
d339 1
a339 1
				    *(union ns_host *)(sc->sc_arpcom.ac_enaddr);
d342 2
a343 2
				    sc->sc_arpcom.ac_enaddr,
				    sizeof(sc->sc_arpcom.ac_enaddr));
d391 2
a392 2
			ether_addmulti(ifr, &sc->sc_arpcom):
			ether_delmulti(ifr, &sc->sc_arpcom);
d424 1
a424 1
	hme_meminit(sc);
d451 8
a458 8
	cr->rand_seed = sc->sc_arpcom.ac_enaddr[5] |
	    ((sc->sc_arpcom.ac_enaddr[4] << 8) & 0x3f00);
	cr->mac_addr0 = (sc->sc_arpcom.ac_enaddr[0] << 8) |
			   sc->sc_arpcom.ac_enaddr[1];
	cr->mac_addr1 = (sc->sc_arpcom.ac_enaddr[2] << 8) |
			   sc->sc_arpcom.ac_enaddr[3];
	cr->mac_addr2 = (sc->sc_arpcom.ac_enaddr[4] << 8) |
			   sc->sc_arpcom.ac_enaddr[5];
d468 2
a469 6
	rxr->rx_ring = (u_long) sc->sc_desc_dva +
		(((u_long) &sc->sc_desc->hme_rxd[0])
		 - ((u_long)sc->sc_desc));
	txr->tx_ring = (u_long) sc->sc_desc_dva +
		(((u_long) &sc->sc_desc->hme_txd[0])
		 - ((u_long)sc->sc_desc));
d485 1
a485 1
	txr->tx_rsize = (TX_RING_SIZE >> TXR_RSIZE_SHIFT) - 1;
d488 2
a489 2
	c = RXR_CFG_DMAENABLE | (RX_OFFSET << 3) | (RX_CSUMLOC << 16);
#if RX_RING_SIZE == 32
d491 1
a491 1
#elif RX_RING_SIZE == 64
d493 1
a493 1
#elif RX_RING_SIZE == 128
d495 1
a495 1
#elif RX_RING_SIZE == 256
d498 1
a498 1
#error "RX_RING_SIZE must be 32, 64, 128, or 256."
d986 1
a986 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
a1072 102
static void
hme_meminit(sc)
	struct hme_softc *sc;
{
	struct hme_desc *desc = sc->sc_desc;
	int i;

	/* setup tx descriptors */
	sc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;
	for (i = 0; i < TX_RING_SIZE; i++)
		desc->hme_txd[i].tx_flags = 0;

	/* setup rx descriptors */
	sc->sc_last_rd = 0;
	for (i = 0; i < RX_RING_SIZE; i++) {

		desc->hme_rxd[i].rx_addr = (u_long) sc->sc_bufs_dva +
			(((u_long) &(sc->sc_bufs->rx_buf[i])) -
			((u_long) sc->sc_bufs));

		desc->hme_rxd[i].rx_flags =
			RXFLAG_OWN | ((RX_PKT_BUF_SZ - RX_OFFSET) << 16);
	}

}

/*
 * Pull data off an interface.
 * Len is the length of data, with local net header stripped.
 * We copy the data into mbufs.  When full cluster sized units are present,
 * we copy into clusters.
 */
static struct mbuf *
hme_get(sc, idx, totlen)
	struct hme_softc *sc;
	int idx, totlen;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf *m;
	struct mbuf *top, **mp;
	int len, pad, boff = 0;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (NULL);
	m->m_pkthdr.rcvif = ifp;
	m->m_pkthdr.len = totlen;
	pad = ALIGN(sizeof(struct ether_header)) - sizeof(struct ether_header);
	m->m_data += pad;
	len = MHLEN - pad;
	top = NULL;
	mp = &top;

	while (totlen > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == NULL) {
				m_freem(top);
				return NULL;
			}
			len = MLEN;
		}
		if (top && totlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if (m->m_flags & M_EXT)
				len = MCLBYTES;
		}
		m->m_len = len = min(totlen, len);
		bcopy(&(sc->sc_bufs->rx_buf[idx][boff + RX_OFFSET]),
			mtod(m, caddr_t), len);
		boff += len;
		totlen -= len;
		*mp = m;
		mp = &m->m_next;
	}

	return (top);
}

static int
hme_put(sc, idx, m)
	struct hme_softc *sc;
	int idx;
	struct mbuf *m;
{
	struct mbuf *n;
	int len, tlen = 0, boff = 0;

	for (; m; m = n) {
		len = m->m_len;
		if (len == 0) {
			MFREE(m, n);
			continue;
		}
		bcopy(mtod(m, caddr_t), &(sc->sc_bufs->tx_buf[idx][boff]), len);
		boff += len;
		tlen += len;
		MFREE(m, n);
	}
	return tlen;
}

a1098 39
 * receive interrupt
 */
static int
hme_rint(sc, why)
	struct hme_softc *sc;
	u_int32_t why;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int bix, len;
	struct hme_rxd rxd;

	bix = sc->sc_last_rd;

	/* Process all buffers with valid data. */
	for (;;) {
		bcopy(&(sc->sc_desc->hme_rxd[bix]), &rxd, sizeof(rxd));
		len = rxd.rx_flags >> 16;

		if (rxd.rx_flags & RXFLAG_OWN)
			break;

		if (rxd.rx_flags & RXFLAG_OVERFLOW)
			ifp->if_ierrors++;
		else
			hme_read(sc, bix, len);

		rxd.rx_flags = RXFLAG_OWN|((RX_PKT_BUF_SZ - RX_OFFSET) << 16);
		bcopy(&rxd, &(sc->sc_desc->hme_rxd[bix]), sizeof(rxd));

		if (++bix == RX_RING_SIZE)
			bix = 0;
	}

	sc->sc_last_rd = bix;

	return 1;
}

/*
d1175 1
a1175 43
 * transmit interrupt
 */
static int
hme_tint(sc, why)
	struct hme_softc *sc;
	u_int32_t why;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int bix;
	struct hme_txd txd;

	bix = sc->sc_first_td;

	for (;;) {
		if (sc->sc_no_td <= 0)
			break;

		bcopy(&(sc->sc_desc->hme_txd[bix]), &txd, sizeof(txd));

		if (txd.tx_flags & TXFLAG_OWN)
			break;

		ifp->if_flags &= ~IFF_OACTIVE;
		ifp->if_opackets++;

		if (++bix == TX_RING_SIZE)
			bix = 0;

		--sc->sc_no_td;
	}

	sc->sc_first_td = bix;

	hmestart(ifp);

	if (sc->sc_no_td == 0)
		ifp->if_timer = 0;

        return 1;
}

/*
 * Interrup handler
d1195 1
a1195 1
		r |= hme_tint(sc, why);
d1198 1
a1198 1
		r |= hme_rint(sc, why);
a1202 44
static void
hme_read(sc, idx, len)
	struct hme_softc *sc;
	int idx, len;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct ether_header *eh;
	struct mbuf *m;

	if (len <= sizeof(struct ether_header) ||
	    len > ETHERMTU + sizeof(struct ether_header)) {

		printf("%s: invalid packet size %d; dropping\n",
		    sc->sc_dev.dv_xname, len);

		ifp->if_ierrors++;
		return;
	}

	/* Pull packet off interface. */
	m = hme_get(sc, idx, len);
	if (m == NULL) {
		ifp->if_ierrors++;
		return;
	}

	ifp->if_ipackets++;

	/* We assume that the header fit entirely in one mbuf. */
	eh = mtod(m, struct ether_header *);

#if NBPFILTER > 0
	/*
	 * Check if there's a BPF listener on this interface.
	 * If so, hand off the raw packet to BPF.
	 */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m);
#endif
	/* Pass the packet up, with the ether header sort-of removed. */
	m_adj(m, sizeof(struct ether_header));
	ether_input(ifp, eh, m);
}

d1210 2
a1211 2
	struct arpcom *ac = &sc->sc_arpcom;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
@


1.2
log
@Add build support for hme
@
text
@d1 1
a1 1
/*	$OpenBSD: hme.c,v 1.1 1998/07/10 19:09:08 jason Exp $	*/
a116 1

d120 2
a154 8

#if 0
	/*
	 * XXX We should check the prom env var 'local-mac-address?'
	 * XXX If true, use the MAC address specific to the board, and if
	 * XXX false, use the MAC address specific to the system.
	 */

a156 2
#endif

a205 1
#if 1
d207 2
a208 1
	 * XXX Below should only be used if 'local-mac-address?' == true
d210 4
a213 9
	getprop(ca->ca_ra.ra_node, "local-mac-address",
				sc->sc_arpcom.ac_enaddr,
				sizeof(sc->sc_arpcom.ac_enaddr));
#else
	/*
	 * XXX Below should only be used if 'local-mac-address?' == false
	 */
	myetheraddr(sc->sc_arpcom.ac_enaddr);
#endif
d401 1
a401 1
		sc->sc_promisc = ifp->if_flags & (IFF_PROMISC | IFF_ALLMULTI);
d444 1
a444 3
#if 0
			mc_reset(sc);
#endif
d1477 57
@


1.1
log
@hme (Happy Meal) ethernet driver.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 2
a37 1
 * Based on the driver from S/Linux by David Miller
@

