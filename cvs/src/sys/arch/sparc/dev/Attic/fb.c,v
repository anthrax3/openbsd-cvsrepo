head	1.58;
access;
symbols
	OPENBSD_6_0:1.57.0.2
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.56.0.2
	OPENBSD_5_9_BASE:1.56
	OPENBSD_5_8:1.55.0.6
	OPENBSD_5_8_BASE:1.55
	OPENBSD_5_7:1.55.0.2
	OPENBSD_5_7_BASE:1.55
	OPENBSD_5_6:1.54.0.6
	OPENBSD_5_6_BASE:1.54
	OPENBSD_5_5:1.54.0.4
	OPENBSD_5_5_BASE:1.54
	OPENBSD_5_4:1.52.0.14
	OPENBSD_5_4_BASE:1.52
	OPENBSD_5_3:1.52.0.12
	OPENBSD_5_3_BASE:1.52
	OPENBSD_5_2:1.52.0.10
	OPENBSD_5_2_BASE:1.52
	OPENBSD_5_1_BASE:1.52
	OPENBSD_5_1:1.52.0.8
	OPENBSD_5_0:1.52.0.6
	OPENBSD_5_0_BASE:1.52
	OPENBSD_4_9:1.52.0.4
	OPENBSD_4_9_BASE:1.52
	OPENBSD_4_8:1.52.0.2
	OPENBSD_4_8_BASE:1.52
	OPENBSD_4_7:1.49.0.2
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.49.0.4
	OPENBSD_4_6_BASE:1.49
	OPENBSD_4_5:1.47.0.2
	OPENBSD_4_5_BASE:1.47
	OPENBSD_4_4:1.43.0.8
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.43.0.6
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.43.0.4
	OPENBSD_4_2_BASE:1.43
	OPENBSD_4_1:1.43.0.2
	OPENBSD_4_1_BASE:1.43
	OPENBSD_4_0:1.39.0.2
	OPENBSD_4_0_BASE:1.39
	OPENBSD_3_9:1.34.0.4
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.34.0.2
	OPENBSD_3_8_BASE:1.34
	OPENBSD_3_7:1.33.0.2
	OPENBSD_3_7_BASE:1.33
	OPENBSD_3_6:1.28.0.4
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.28.0.2
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	UBC_SYNC_A:1.23
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.21
	UBC:1.17.0.2
	UBC_BASE:1.17
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.10
	OPENBSD_2_8:1.15.0.8
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.15.0.6
	OPENBSD_2_7_BASE:1.15
	SMP:1.15.0.4
	SMP_BASE:1.15
	kame_19991208:1.15
	OPENBSD_2_6:1.15.0.2
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.14.0.6
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.14.0.4
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.14.0.2
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.9.0.4
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.58
date	2016.09.01.09.23.41;	author tedu;	state dead;
branches;
next	1.57;
commitid	Q2PxaFNhqAe0Wmla;

1.57
date	2016.03.15.20.50.22;	author krw;	state Exp;
branches;
next	1.56;
commitid	JZR2bOwahEjnBJaG;

1.56
date	2015.09.12.08.42.47;	author miod;	state Exp;
branches;
next	1.55;
commitid	BcGg8jEyZj3mAr1T;

1.55
date	2015.02.07.23.29.29;	author miod;	state Exp;
branches;
next	1.54;
commitid	QbocNAE4ToC8aUn3;

1.54
date	2013.10.21.10.36.18;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2013.08.15.18.29.56;	author kettenis;	state Exp;
branches;
next	1.52;

1.52
date	2010.07.10.19.32.24;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2010.06.07.19.43.45;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2010.05.15.15.27.15;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2009.06.03.20.17.48;	author kettenis;	state Exp;
branches;
next	1.48;

1.48
date	2009.03.29.17.32.06;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2009.01.12.17.14.46;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2009.01.11.15.27.31;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2009.01.04.20.32.55;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2008.12.26.22.30.21;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2006.12.03.22.10.30;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2006.12.03.16.41.56;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2006.12.02.11.25.07;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2006.11.29.12.13.54;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2006.07.01.16.15.58;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2006.06.30.21.38.17;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2006.06.29.17.54.30;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.12.22.53.01;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.12.22.17.47;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2005.03.23.17.16.34;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2005.03.15.18.40.12;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2005.03.07.16.44.50;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2005.02.27.22.25.34;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2005.02.22.10.00.58;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2004.11.29.22.07.37;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.29.21.24.36;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2003.10.05.18.34.42;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.28.17.05.33;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.28.14.26.16;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.02.23.27.54;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.11.24.00.36.16;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2002.11.06.21.06.20;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2002.09.05.09.31.20;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.16.02.06.43;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.12.10.44.04;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.26.42;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.01.12.13.46;	author art;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.09.08.18.02.29;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	99.09.05.18.51.08;	author jason;	state Exp;
branches
	1.15.4.1;
next	1.14;

1.14
date	98.03.20.05.18.27;	author todd;	state Exp;
branches;
next	1.13;

1.13
date	97.11.11.13.04.22;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	97.11.11.12.49.21;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	97.11.11.11.49.12;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	97.08.08.08.25.04;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	96.08.13.08.05.25;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	96.08.11.05.34.17;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	95.12.18.17.02.22;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	95.12.17.09.30.02;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	95.12.15.13.56.22;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.11.09.21.34.12;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.10.19.13.04.37;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.19.12.51.52;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.39;	author deraadt;	state Exp;
branches;
next	;

1.15.4.1
date	2001.10.31.03.07.56;	author nate;	state Exp;
branches;
next	1.15.4.2;

1.15.4.2
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.15.4.3;

1.15.4.3
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.15.4.4;

1.15.4.4
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.15.4.5;

1.15.4.5
date	2003.06.07.11.14.42;	author ho;	state Exp;
branches;
next	1.15.4.6;

1.15.4.6
date	2004.02.19.10.49.57;	author niklas;	state Exp;
branches;
next	1.15.4.7;

1.15.4.7
date	2004.06.05.23.10.57;	author niklas;	state Exp;
branches;
next	;

1.17.2.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.10.29.00.28.09;	author art;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.58
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: fb.c,v 1.57 2016/03/15 20:50:22 krw Exp $	*/
/*	$NetBSD: fb.c,v 1.23 1997/07/07 23:30:22 pk Exp $ */

/*
 * Copyright (c) 2002, 2004, 2008  Miodrag Vallat.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)fb.c	8.1 (Berkeley) 6/11/93
 */

/*
 * Common wsdisplay framebuffer drivers helpers.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/proc.h>
#include <sys/conf.h>

#include <machine/autoconf.h>
#include <machine/conf.h>
#if defined(SUN4)
#include <machine/eeprom.h>
#include <sparc/dev/pfourreg.h>
#endif
#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
#include <machine/bsd_openprom.h>
#endif

#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

#include "wsdisplay.h"

/*
 * Sun specific color indexes.
 * Black is not really 7, but rather ~0; to fit within the 8 ANSI color
 * palette we are using on console, we pick (~0) & 0x07 instead.
 * This essentially swaps WSCOL_BLACK and WSCOL_WHITE.
 */
#define	WSCOL_SUN_WHITE		0
#define	WSCOL_SUN_BLACK		7

/*
 * emergency unblank code
 * XXX should be somewhat moved to wscons MI code
 */

void (*fb_burner)(void *, u_int, u_int);
void *fb_cookie;

void
fb_unblank()
{
	if (fb_burner != NULL)
		(*fb_burner)(fb_cookie, 1, 0);
}

#if NWSDISPLAY > 0

#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
static int a2int(char *, int);
#endif
int	fb_get_console_metrics(int *, int *, int *, int *);
void	fb_initwsd(struct sunfb *);
void	fb_updatecursor(struct rasops_info *);

int	fb_alloc_screen(void *, const struct wsscreen_descr *, void **,
	    int *, int *, long *);
void	fb_free_screen(void *, void *);
int	fb_show_screen(void *, void *, int, void (*)(void *, int, int),
	    void *);
int	fb_load_font(void *, void *, struct wsdisplay_font *);
int	fb_list_font(void *, struct wsdisplay_font *);

void
fb_setsize(struct sunfb *sf, int def_depth, int def_width, int def_height,
    int node, int bustype)
{
	int def_linebytes;

#if defined(SUN4M)
	/* 4m may have SBus-like framebuffer on obio */
	if (CPU_ISSUN4M && bustype == BUS_OBIO)
		bustype = BUS_SBUS;
#endif

	/* Set up some defaults. */
	sf->sf_width = def_width;
	sf->sf_height = def_height;
	sf->sf_depth = def_depth;

	switch (bustype) {
	case BUS_OBIO:
#if defined(SUN4)
		/*
		 * The EEPROM contains info about the built-in framebuffer.
		 */
		if (CPU_ISSUN4) {
			struct eeprom *eep = (struct eeprom *)eeprom_va;

			if (ISSET(sf->sf_flags, FB_PFOUR)) {
				volatile u_int32_t pfour;
				u_int size;

				pfour = *sf->sf_pfour;

				/*
				 * Use the pfour register to determine
				 * the size.  Note that the cgsix and
				 * cgeight don't use this size encoding.
				 * In this case, we have to settle
				 * for the defaults we were provided
				 * with.
				 */
				if ((PFOUR_ID(pfour) == PFOUR_ID_COLOR24) ||
				    (PFOUR_ID(pfour) == PFOUR_ID_FASTCOLOR))
					size = 0x00; /* invalid */
				else
					size = PFOUR_SIZE(pfour);

				switch (size) {
				case PFOUR_SIZE_1152X900:
					sf->sf_width = 1152;
					sf->sf_height = 900;
					break;
				case PFOUR_SIZE_1024X1024:
					sf->sf_width = 1024;
					sf->sf_height = 1024;
					break;
				case PFOUR_SIZE_1280X1024:
					sf->sf_width = 1280;
					sf->sf_height = 1024;
					break;
				case PFOUR_SIZE_1600X1280:
					sf->sf_width = 1600;
					sf->sf_height = 1280;
					break;
				case PFOUR_SIZE_1440X1440:
					sf->sf_width = 1440;
					sf->sf_height = 1440;
					break;
				case PFOUR_SIZE_640X480:
					sf->sf_width = 640;
					sf->sf_height = 480;
					break;
				}
			} else if (eep != NULL) {
				switch (eep->ee_diag.eed_scrsize) {
				case EED_SCR_1152X900:
					sf->sf_width = 1152;
					sf->sf_height = 900;
					break;
				case EED_SCR_1024X1024:
					sf->sf_width = 1024;
					sf->sf_height = 1024;
					break;
				case EED_SCR_1600X1280:
					sf->sf_width = 1600;
					sf->sf_height = 1280;
					break;
				case EED_SCR_1440X1440:
					sf->sf_width = 1440;
					sf->sf_height = 1440;
					break;
				case EED_SCR_640X480:
					sf->sf_width = 640;
					sf->sf_height = 480;
					break;
				case EED_SCR_1280X1024:
					sf->sf_width = 1280;
					sf->sf_height = 1024;
					break;
				}
			}
		}
#endif /* SUN4 */
		sf->sf_linebytes = (sf->sf_width * sf->sf_depth) / 8;
		break;

	case BUS_VME16:
	case BUS_VME32:
#if defined(SUN4M)
		if (CPU_ISSUN4M) {
			/* XXX: need code to find 4/600 vme screen size */
		}
#endif /* SUN4M */
		sf->sf_linebytes = (sf->sf_width * sf->sf_depth) / 8;
		break;

	case BUS_SBUS:
		sf->sf_depth = getpropint(node, "depth", def_depth);
		sf->sf_width = getpropint(node, "width", def_width);
		sf->sf_height = getpropint(node, "height", def_height);

		def_linebytes =
		    roundup(sf->sf_width, sf->sf_depth) * sf->sf_depth / 8;
		sf->sf_linebytes = getpropint(node, "linebytes", def_linebytes);

		/*
		 * XXX If we are configuring a board in a wider depth level
		 * than the mode it is currently operating in, the PROM will
		 * return a linebytes property tied to the current depth value,
		 * which is NOT what we are relying upon!
		 */
		if (sf->sf_linebytes < (sf->sf_width * sf->sf_depth) / 8)
			sf->sf_linebytes = def_linebytes;

		break;
	}

	sf->sf_fbsize = sf->sf_height * sf->sf_linebytes;
}

#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
static int
a2int(char *cp, int deflt)
{
	int i = 0;

	if (*cp == '\0')
		return (deflt);
	while (*cp != '\0')
		i = i * 10 + *cp++ - '0';
	return (i);
}
#endif

/* setup the embedded wsscreen_descr structure from rasops settings */
void
fb_initwsd(struct sunfb *sf)
{
	strlcpy(sf->sf_wsd.name, "std", sizeof(sf->sf_wsd.name));
	sf->sf_wsd.capabilities = sf->sf_ro.ri_caps;
	sf->sf_wsd.nrows = sf->sf_ro.ri_rows;
	sf->sf_wsd.ncols = sf->sf_ro.ri_cols;
	sf->sf_wsd.textops = &sf->sf_ro.ri_ops;
}

void
fb_updatecursor(struct rasops_info *ri)
{
	struct sunfb *sf = (struct sunfb *)ri->ri_hw;

	if (sf->sf_crowp != NULL)
		*sf->sf_crowp = ri->ri_crow;
	if (sf->sf_ccolp != NULL)
		*sf->sf_ccolp = ri->ri_ccol;
}

void
fbwscons_init(struct sunfb *sf, int isconsole)
{
	struct rasops_info *ri = &sf->sf_ro;
	int cols, rows;
#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	int fw, fh, wt, wl;
#endif

	/* ri_hw and ri_bits must have already been setup by caller */
	ri->ri_flg = RI_FULLCLEAR;
	if (!isconsole)
		ri->ri_flg |= RI_CLEAR;
	ri->ri_depth = sf->sf_depth;
	ri->ri_stride = sf->sf_linebytes;
	ri->ri_width = sf->sf_width;
	ri->ri_height = sf->sf_height;

#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	if (!CPU_ISSUN4) {
		rows = a2int(getpropstring(optionsnode, "screen-#rows"), 34);
		cols = a2int(getpropstring(optionsnode, "screen-#columns"), 80);
	}
#endif
#if defined(SUN4)
	if (CPU_ISSUN4) {
		struct eeprom *ep = (struct eeprom *)eeprom_va;

		if (ep != NULL) {
			rows = (u_short)ep->ee_diag.eed_rowsize;
			cols = (u_short)ep->ee_diag.eed_colsize;
			/* deal with broken nvram contents... */
			if (rows <= 0)
				rows = 34;
			if (cols <= 0)
				cols = 80;
		} else {
			rows = 34;
			cols = 80;
		}
	}
#endif

	/*
	 * If the framebuffer width is under 960 pixels, rasops will
	 * switch from the 12x22 font to the more adequate 8x16 font
	 * here.
	 * If we are the console device, we need to adjust two things:
	 * - the display row should be overrided from the current PROM
	 *   metrics, since it will not match the PROM reality anymore.
	 * - the screen needs to be cleared.
	 *
	 * However, to accommodate laptops with specific small fonts,
	 * it is necessary to compare the resolution with the actual
	 * font metrics.
	 *
	 * Note that, on sun4 systems, no frame buffer supports display
	 * resolutions requiring a font switch, so it is safe to bypass
	 * this chunk.
	 */

#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	if (!CPU_ISSUN4 && isconsole) {
		if (fb_get_console_metrics(&fw, &fh, &wt, &wl) != 0) {
			/*
			 * Assume a 12x22 prom font and a centered
			 * 80x34 console window.
			 */
			fw = 12; fh = 22;
			wt = wl = 0;
		} else {
			/*
			 * We have valid font metrics, but the
			 * window-top and window-left values might not
			 * be available.  Also, we have to make sure
			 * their values are consistent with the font
			 * metrics.
			 */
			if (wt <= 0 || wt > sf->sf_height - rows * fh ||
			    wl <= 0 || wl > sf->sf_width - cols * fw)
				wt = wl = 0;
		}
		if (wt == 0 /* || wl == 0 */) {
			ri->ri_flg |= RI_CENTER;

			/*
			 * Since the console window might not be
			 * centered (e.g. on a 1280x1024 vigra
			 * VS-12 frame buffer), have rasops
			 * clear the margins even if the screen is
			 * not cleared.
			 */
			ri->ri_flg |= RI_CLEARMARGINS;
		}

		if (ri->ri_wsfcookie != 0) {
			/* driver handles font issues. do nothing. */
		} else {
			/*
			 * If the PROM uses a different font than the
			 * one we are expecting it to use, or if the
			 * display is shorter than 960 pixels wide,
			 * we'll force a screen clear.
			 */
			if (fw != 12 || sf->sf_width < 12 * 80)
				ri->ri_flg |= RI_CLEAR | RI_CENTER;
		}
	} else
#endif
		ri->ri_flg |= RI_CENTER;

	rasops_init(ri, rows, cols);

#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	/*
	 * If this is the console display and there is no font change,
	 * adjust our terminal window to the position of the PROM
	 * window - in case it is not exactly centered.
	 */
	if ((ri->ri_flg & RI_CENTER) == 0) {
		/* code above made sure wt and wl are initialized */
		ri->ri_bits += wt * ri->ri_stride;
		if (ri->ri_depth >= 8)	/* for 15bpp to compute ok */
			ri->ri_bits += wl * ri->ri_pelbytes;
		else
			ri->ri_bits += (wl * ri->ri_depth) >> 3;

		ri->ri_xorigin = wl;
		ri->ri_yorigin = wt;
	}
#endif

	if (sf->sf_depth == 8) {
		/*
		 * If we are running with an indexed palette, compensate
		 * the swap of black and white through ri_devcmap.
		 */
		ri->ri_devcmap[WSCOL_SUN_BLACK] = 0;
		ri->ri_devcmap[WSCOL_SUN_WHITE] = 0xffffffff;
	} else if (sf->sf_depth > 8) {
		/*
		 * If we are running on a direct color frame buffer,
		 * make the ``normal'' white the same as the hilighted
		 * white.
		 */
		ri->ri_devcmap[WSCOL_WHITE] = ri->ri_devcmap[WSCOL_WHITE + 8];
	}
}

void
fbwscons_console_init(struct sunfb *sf, int row)
{
	struct rasops_info *ri = &sf->sf_ro;
	void *cookie;
	long defattr;

	if (CPU_ISSUN4 || romgetcursoraddr(&sf->sf_crowp, &sf->sf_ccolp))
		sf->sf_ccolp = sf->sf_crowp = NULL;
	if (sf->sf_ccolp != NULL)
		ri->ri_ccol = *sf->sf_ccolp;

	if (ri->ri_flg & RI_CLEAR) {
		/*
		 * If we have cleared the screen, this is because either
		 * we are not the console display, or the font has been
		 * changed.
		 * In this case, choose not to keep pointers to the PROM
		 * cursor position, as the values are likely to be inaccurate
		 * upon shutdown...
		 */
		sf->sf_crowp = sf->sf_ccolp = NULL;
		row = 0;
	}

	if (row < 0) /* no override */ {
		if (sf->sf_crowp != NULL)
			ri->ri_crow = *sf->sf_crowp;
		else
			/* assume last row */
			ri->ri_crow = ri->ri_rows - 1;
	} else {
		ri->ri_crow = row;
	}

	/*
	 * Scale back rows and columns if the font would not otherwise
	 * fit on this display. Without this we would panic later.
	 */
	if (ri->ri_crow >= ri->ri_rows)
		ri->ri_crow = ri->ri_rows - 1;
	if (ri->ri_ccol >= ri->ri_cols)
		ri->ri_ccol = ri->ri_cols - 1;

	/*
	 * Take care of updating the PROM cursor position as well if we can.
	 */
	if (ri->ri_updatecursor == NULL &&
	    (sf->sf_ccolp != NULL || sf->sf_crowp != NULL))
		ri->ri_updatecursor = fb_updatecursor;

	if (ri->ri_flg & RI_VCONS)
		cookie = ri->ri_active;
	else
		cookie = ri;

	if (ISSET(ri->ri_caps, WSSCREEN_WSCOLORS))
		ri->ri_ops.alloc_attr(cookie,
		    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, &defattr);
	else
		ri->ri_ops.alloc_attr(cookie, 0, 0, 0, &defattr);

	fb_initwsd(sf);
	wsdisplay_cnattach(&sf->sf_wsd, cookie,
	    ri->ri_ccol, ri->ri_crow, defattr);
}

void
fbwscons_setcolormap(struct sunfb *sf,
    void (*setcolor)(void *, u_int, u_int8_t, u_int8_t, u_int8_t))
{
	int i;
	const u_char *color;

	if (sf->sf_depth <= 8 && setcolor != NULL) {
		for (i = 0; i < 16; i++) {
			color = &rasops_cmap[i * 3];
			setcolor(sf, i, color[0], color[1], color[2]);
		}
		for (i = 240; i < 256; i++) {
			color = &rasops_cmap[i * 3];
			setcolor(sf, i, color[0], color[1], color[2]);
		}
		/*
		 * Compensate for BoW default hardware palette: existing
		 * output (which we do not want to affect) is black on
		 * white with color index 0 being white and 0xff being
		 * black.
		 */
		setcolor(sf, WSCOL_SUN_WHITE, 0xff, 0xff, 0xff);
		setcolor(sf, 0xff ^ WSCOL_SUN_WHITE, 0, 0, 0);
		setcolor(sf, WSCOL_SUN_BLACK, 0, 0, 0);
		setcolor(sf, 0xff ^ (WSCOL_SUN_BLACK), 0xff, 0xff, 0xff);
	}
}

void
fbwscons_attach(struct sunfb *sf, struct wsdisplay_accessops *op, int isconsole)
{
	struct wsemuldisplaydev_attach_args waa;

	if (isconsole == 0) {
		/* done in wsdisplay_cnattach() earlier if console */
		fb_initwsd(sf);
	} else {
		/* remember screen burner routine */
		fb_burner = op->burn_screen;
		fb_cookie = sf;
	}

	/* plug common wsdisplay_accessops if necessary */
	if (op->alloc_screen == NULL) {
		op->alloc_screen = fb_alloc_screen;
		op->free_screen = fb_free_screen;
		op->show_screen = fb_show_screen;
	}
	if (op->load_font == NULL) {
		op->load_font = fb_load_font;
		op->list_font = fb_list_font;
	}

	sf->sf_scrlist[0] = &sf->sf_wsd;
	sf->sf_wsl.nscreens = 1;
	sf->sf_wsl.screens = (const struct wsscreen_descr **)sf->sf_scrlist;

	waa.console = isconsole;
	waa.scrdata = &sf->sf_wsl;
	waa.accessops = op;
	waa.accesscookie = sf;
	waa.defaultscreens = 0;
	config_found(&sf->sf_dev, &waa, wsemuldisplaydevprint);
}

/*
 * Common wsdisplay_accessops routines.
 */
int
fb_alloc_screen(void *v, const struct wsscreen_descr *type,
    void **cookiep, int *curxp, int *curyp, long *attrp)
{
	struct sunfb *sf = v;
	struct rasops_info *ri = &sf->sf_ro;
	void *cookie;

	if (sf->sf_nscreens > 0)
		return (ENOMEM);

	if (ri->ri_flg & RI_VCONS)
		cookie = ri->ri_active;
	else
		cookie = ri;

	*cookiep = cookie;
	*curyp = 0;
	*curxp = 0;
	if (ISSET(ri->ri_caps, WSSCREEN_WSCOLORS))
		ri->ri_ops.alloc_attr(cookie,
		    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	else
		ri->ri_ops.alloc_attr(cookie, 0, 0, 0, attrp);
	sf->sf_nscreens++;
	return (0);
}

void
fb_free_screen(void *v, void *cookie)
{
	struct sunfb *sf = v;

	sf->sf_nscreens--;
}

int
fb_show_screen(void *v, void *cookie, int waitok, void (*cb)(void *, int, int),
    void *cbarg)
{
	return (0);
}

int
fb_load_font(void *v, void *emulcookie, struct wsdisplay_font *font)
{
	struct sunfb *sf = v;
	struct rasops_info *ri = &sf->sf_ro;

	return rasops_load_font(ri, emulcookie, font);
}

int
fb_list_font(void *v, struct wsdisplay_font *font)
{
	struct sunfb *sf = v;
	struct rasops_info *ri = &sf->sf_ro;

	return rasops_list_font(ri, font);
}

#if defined(SUN4)

/*
 * Support routines for P4 framebuffers.
 */

/*
 * Probe for a P4 framebuffer.  Return values:
 *	PFOUR_NOTPFOUR		framebuffer is not a P4 framebuffer
 *	otherwise returns P4 ID
 */
int
fb_pfour_id(volatile void *va)
{
	volatile u_int32_t val, save, *pfour = va;

	/* Read the pfour register. */
	save = *pfour;

	/*
	 * Try to modify the type code.  If it changes, put the
	 * original value back, and notify the caller that it's
	 * not a pfour framebuffer.
	 */
	val = save & ~PFOUR_REG_RESET;
	*pfour = (val ^ PFOUR_FBTYPE_MASK);
	if ((*pfour ^ val) & PFOUR_FBTYPE_MASK) {
		*pfour = save;
		return (PFOUR_NOTPFOUR);
	}

	return (PFOUR_ID(val));
}

/*
 * Screen burner routine for P4
 */
void
fb_pfour_burner(void *v, u_int enable, u_int flags)
{
	struct sunfb *sf = (struct sunfb *)v;
	volatile u_int32_t pfour;

	pfour = *sf->sf_pfour & ~(PFOUR_REG_INTCLR | PFOUR_REG_VIDEO);
	*sf->sf_pfour = pfour | (enable ? PFOUR_REG_VIDEO : 0);
}

#endif /* SUN4 */

#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
int
fb_get_console_metrics(int *fontwidth, int *fontheight, int *wtop, int *wleft)
{
	int *romwidth, *romheight, *windowtop, *windowleft;
	char buf[200];

	/*
	 * Get the PROM font metrics.
	 */

	/*
	 * char-height and char-width are global in older proms (rom vector
	 * < 2) and in some newer proms.  They are local in version 2.9.  The
	 * correct cutoff point is unknown, as yet; we use 2.9 here.
	 */
	if (promvec->pv_romvec_vers < 2 || promvec->pv_printrev < 0x00020009) {
		if (snprintf(buf, sizeof buf,
		    "' char-height >body >user %lx ! "
		    "' char-width >body >user %lx !",
		    (vaddr_t)&romheight, (vaddr_t)&romwidth) >= sizeof buf)
			return (1);
	} else {
		if (snprintf(buf, sizeof buf, "stdout @@ is my-self "
		    "addr char-height %lx ! addr char-width %lx !",
		    (vaddr_t)&romheight, (vaddr_t)&romwidth) >= sizeof buf)
			return (1);
	}

	romheight = romwidth = NULL;
	rominterpret(buf);

	if (romheight == NULL || romwidth == NULL ||
	    *romheight == 0 || *romwidth == 0)
		return (1);

	*fontwidth = *romwidth;
	*fontheight = *romheight;

	/*
	 * Get the PROM console window position, if possible.
	 */

	*wtop = *wleft = 0;	/* if no values available... */
	if (promvec->pv_romvec_vers < 2 || promvec->pv_printrev < 0x00020009)
		return (0);	/* not available */

	if (snprintf(buf, sizeof buf, "stdout @@ is my-self "
	    "addr window-top %lx ! addr window-left %lx !",
	    (vaddr_t)&windowtop, (vaddr_t)&windowleft) >= sizeof buf)
		return (0);	/* XXX shouldn't happen */

	windowtop = windowleft = NULL;
	rominterpret(buf);

	if (windowtop != NULL)
		*wtop = *windowtop;
	if (windowleft != NULL)
		*wleft = *windowleft;

	return (0);
}
#endif	/* SUN4C || SUN4D || SUN4E || SUN4M */

#endif	/* NWSDISPLAY */
@


1.57
log
@'accomodate' -> 'accommodate' in comments.

Started by diff from Mical Mazurek.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.56 2015/09/12 08:42:47 miod Exp $	*/
@


1.56
log
@Rework fb_setsize() logic to get rid of gotos.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.55 2015/02/07 23:29:29 miod Exp $	*/
d363 1
a363 1
	 * However, to accomodate laptops with specific small fonts,
@


1.55
log
@Misplaced #endif
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.54 2013/10/21 10:36:18 miod Exp $	*/
a141 4
	switch (bustype) {
	case BUS_VME16:
	case BUS_VME32:
	case BUS_OBIO:
d143 3
a145 4
		/* 4m may have SBus-like framebuffer on obio */
		if (CPU_ISSUN4M) {
			goto obpsize;
		}
a146 4
		/* Set up some defaults. */
		sf->sf_width = def_width;
		sf->sf_height = def_height;
		sf->sf_depth = def_depth;
d148 7
d157 1
a157 2
		 * This is not particularly useful on Sun 4 VME framebuffers.
		 * The EEPROM only contains info about the built-in.
d159 1
a159 1
		if (CPU_ISSUN4 && bustype == BUS_OBIO) {
d238 5
a247 1

a251 3
#if defined(SUN4M)
obpsize:
#endif
@


1.54
log
@Add load_font and list_font accessops to all rasops-based wsdisplay drivers.
Trivial except for tga(4) and gpx(4/vax) which need a bit more care setting
up a new font.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.53 2013/08/15 18:29:56 kettenis Exp $	*/
d420 2
a421 1
	} else {
a422 2
	}
#endif
@


1.53
log
@Add RI_VCONS support.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.52 2010/07/10 19:32:24 miod Exp $	*/
d133 2
d579 4
d640 18
@


1.52
log
@sun4e (i.e. SPARCengine 1e) support. This platform is a mix between sun4 and
sun4c, as it has a sun4c OpenPROM but a sun4 8KB pagesize. VME devices are
not supported yet.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.51 2010/06/07 19:43:45 miod Exp $	*/
d465 1
d512 5
d518 1
a518 1
		ri->ri_ops.alloc_attr(ri,
d521 1
a521 1
		ri->ri_ops.alloc_attr(ri, 0, 0, 0, &defattr);
d524 1
a524 1
	wsdisplay_cnattach(&sf->sf_wsd, ri,
d599 1
d604 6
a609 1
	*cookiep = ri;
d613 1
a613 1
		ri->ri_ops.alloc_attr(ri,
d616 1
a616 1
		ri->ri_ops.alloc_attr(ri, 0, 0, 0, attrp);
@


1.51
log
@Nuke old eeprom.h compatibility defines; ok todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.50 2010/05/15 15:27:15 miod Exp $	*/
d85 1
a85 1
#if defined(SUN4C) || defined(SUN4M)
d121 1
a121 1
#if defined(SUN4C) || defined(SUN4M)
d275 1
a275 1
#if defined(SUN4C) || defined(SUN4M)
d316 1
a316 1
#if defined(SUN4C) || defined(SUN4M)
d329 2
a330 2
#if defined(SUN4C) || defined(SUN4M)
	if (CPU_ISSUN4COR4M) {
d372 2
a373 2
#if defined(SUN4C) || defined(SUN4M)
	if (CPU_ISSUN4COR4M && isconsole) {
d425 1
a425 1
#if defined(SUN4C) || defined(SUN4M)
d673 1
a673 1
#if defined(SUN4C) || defined(SUN4M)
d735 1
a735 1
#endif	/* SUN4C || SUN4M */
@


1.50
log
@Make fb_pfour_id() take a volatile pointer as argument.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.49 2009/06/03 20:17:48 kettenis Exp $	*/
d210 2
a211 2
				switch (eep->eeScreenSize) {
				case EE_SCR_1152X900:
d215 1
a215 1
				case EE_SCR_1024X1024:
d219 1
a219 1
				case EE_SCR_1600X1280:
d223 1
a223 1
				case EE_SCR_1440X1440:
d227 8
d340 2
a341 2
			rows = (u_short)ep->eeTtyRows;
			cols = (u_short)ep->eeTtyCols;
@


1.49
log
@Fix check for window-top and window-left values.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.48 2009/03/29 17:32:06 miod Exp $	*/
d628 1
a628 1
fb_pfour_id(void *va)
@


1.48
log
@When trying to get the console font metrics and window position, we can
always retrieve the font metrics, even on older (< 2.9) prom, so do it.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.47 2009/01/12 17:14:46 miod Exp $	*/
d381 2
a382 2
			if (wt <= 0 || wt > sf->sf_width - cols * fw ||
			    wl <= 0 || wl > sf->sf_height - rows * fh)
@


1.47
log
@Be more strict when checking window-left and window-top values.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.46 2009/01/11 15:27:31 miod Exp $	*/
d375 5
a379 2
			 * Make sure window-top and window-left
			 * values are consistent with the font metrics.
d673 1
a673 2
	 * This code currently only works for PROM >= 2.9; see
	 * autoconf.c romgetcursoraddr() for details.
d675 24
a698 1
	if (promvec->pv_romvec_vers < 2 || promvec->pv_printrev < 0x00020009)
d701 3
d705 1
a705 1
	 * Get the PROM font metrics and address
d707 5
a712 1
	    "addr char-height %lx ! addr char-width %lx ! "
d714 4
a717 5
	    (vaddr_t)&romheight, (vaddr_t)&romwidth,
	    (vaddr_t)&windowtop, (vaddr_t)&windowleft) >=
	    sizeof buf)
		return (1);
	romheight = romwidth = windowtop = windowleft = NULL;
d720 4
a723 3
	if (romheight == NULL || romwidth == NULL || windowtop == NULL ||
	    windowleft == NULL || *romheight == 0 || *romwidth == 0)
		return (1);
a724 4
	*fontwidth = *romwidth;
	*fontheight = *romheight;
	*wtop = *windowtop;
	*wleft = *windowleft;
@


1.46
log
@Some frame buffer fcode do not fill window-top and window-left put
nevertheless provide them; cope with zero values.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.45 2009/01/04 20:32:55 miod Exp $	*/
d372 9
a380 1
			wt = 0; wl = 0;
d382 1
a382 1
		if (wt == 0 || wl == 0) {
@


1.45
log
@Make this compile for SUN4 only kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.44 2008/12/26 22:30:21 miod Exp $	*/
d372 3
@


1.44
log
@Move the logic responsible from deciding whether a frame buffer needs to be
cleared on attach, from the individual drivers to the common frame buffer code;
the latter will decide based on the prom font metrics and the prom console
window position, whenever possible.

This removes the need for the console window position to be hardcoded in
the p9100 driver, and will no longer require a screen clear on a vigra
VS-12 in high resolution mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.43 2006/12/03 22:10:30 miod Exp $	*/
d307 4
a310 1
	int cols, rows, fw, fh, wt, wl;
@


1.43
log
@In fb_setsize(), remove dead code in the SUN4 case.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.42 2006/12/03 16:41:56 miod Exp $	*/
d5 1
a5 1
 * Copyright (c) 2002, 2004  Miodrag Vallat.
d85 3
d124 4
a127 2
static void fb_initwsd(struct sunfb *);
static void fb_updatecursor(struct rasops_info *);
d282 1
a282 1
static void
d292 1
a292 1
static void
d304 1
a304 1
fbwscons_init(struct sunfb *sf, int flags)
d307 1
a307 1
	int cols, rows;
d310 3
a312 1
	ri->ri_flg = RI_CENTER | RI_FULLCLEAR | flags;
d343 55
d400 19
d447 14
a460 1
	if (row < 0) {
a466 8
		/*
		 * If we force the display row, this is because the screen
		 * has been cleared or the font has been changed.
		 * In this case, choose not to keep pointers to the PROM
		 * cursor position, as the values are likely to be inaccurate
		 * upon shutdown...
		 */
		sf->sf_crowp = sf->sf_ccolp = NULL;
d647 39
@


1.42
log
@Do the ri_devcmap reprogramming dance in fbwscons_init(), so that it applies
to non-console frame buffers as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.41 2006/12/02 11:25:07 miod Exp $	*/
d150 1
d155 1
a155 6
		if (CPU_ISSUN4 && (bustype == BUS_VME16 ||
		    bustype == BUS_VME32))
			goto donesize;

#if defined(SUN4)
		if (CPU_ISSUN4) {
d160 1
a160 12

				/*
				 * Some pfour framebuffers, e.g. the
				 * cgsix, don't encode resolution the
				 * same, so the driver handles that.
				 * The driver can let us know that it
				 * needs to do this by not mapping in
				 * the pfour register by the time this
				 * routine is called.
				 */
				if (sf->sf_pfour == NULL)
					goto donesize;
d174 3
a176 1
					goto donesize;
d178 1
a178 1
				switch (PFOUR_SIZE(pfour)) {
a182 1

a186 1

a190 1

a194 1

a198 1

a202 8

				default:
					/*
					 * XXX: Do nothing, I guess.
					 * Should we print a warning about
					 * an unknown value? --thorpej
					 */
					break;
a209 1

a213 1

a217 1

a221 8

				default:
					/*
					 * XXX: Do nothing, I guess.
					 * Should we print a warning about
					 * an unknown value? --thorpej
					 */
					break;
a231 1
donesize:
d246 1
d253 1
a253 1
		if (sf->sf_linebytes < (sf->sf_width * sf->sf_depth) / 8) {
d255 1
a255 1
		}
a256 4

	default:
		panic("fb_setsize: inappropriate bustype");
		/* NOTREACHED */
@


1.41
log
@Fix ri_devcmap[] to allow WSCOL_BLACK and WSCOL_WHITE to not have to be
different for sparc{,64} systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.40 2006/11/29 12:13:54 miod Exp $	*/
d378 16
a439 16

	if (sf->sf_depth == 8) {
		/*
		 * If we are running with an indexed palette, compensate
		 * the swap of black and white through ri_devcmap.
		 */
		ri->ri_devcmap[WSCOL_SUN_BLACK] = 0;
		ri->ri_devcmap[WSCOL_SUN_WHITE] = 0xffffffff;
	} else if (sf->sf_depth > 8) {
		/*
		 * If we are running on a direct color frame buffer,
		 * make the ``normal'' white the same as the hilighted
		 * white.
		 */
		ri->ri_devcmap[WSCOL_WHITE] = ri->ri_devcmap[WSCOL_WHITE + 8];
	}
@


1.40
log
@Add a new member to struct wsemuldisplaydev_attach_args, for a frame buffer
driver to be able to tell how many wscons screens to attach to it,
instead of WSDISPLAY_DEFAULTSCREENS which is a global setting.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.39 2006/07/01 16:15:58 miod Exp $	*/
d93 9
a122 1
int	fb_alloc_cattr(void *, int, int, int, long *);
a377 2
	if (ri->ri_caps & WSSCREEN_WSCOLORS)
		ri->ri_ops.alloc_attr = fb_alloc_cattr;
a383 1
	int32_t tmp;
d425 14
a438 8
	/*
	 * Select appropriate color settings to mimic a
	 * black on white Sun console.
	 */
	if (sf->sf_depth > 8) {
		tmp = ri->ri_devcmap[WSCOL_WHITE];
		ri->ri_devcmap[WSCOL_WHITE] = ri->ri_devcmap[WSCOL_BLACK];
		ri->ri_devcmap[WSCOL_BLACK] = tmp;
d457 1
a457 1
	u_char *color;
d461 1
a461 1
			color = (u_char *)&rasops_cmap[i * 3];
d465 1
a465 1
			color = (u_char *)&rasops_cmap[i * 3];
d468 10
a477 5
		/* compensate for BoW palette */
		setcolor(sf, WSCOL_BLACK, 0, 0, 0);
		setcolor(sf, 0xff ^ WSCOL_BLACK, 255, 255, 255);
		setcolor(sf, WSCOL_WHITE, 255, 255, 255);
		setcolor(sf, 0xff ^ WSCOL_WHITE, 0, 0, 0);
a550 42
	return (0);
}

/*
 * A variant of rasops_alloc_cattr() which handles the WSCOL_BLACK and
 * WSCOL_WHITE specific values wrt highlighting.
 */
int
fb_alloc_cattr(void *cookie, int fg, int bg, int flg, long *attrp)
{
	int swap;

	if ((flg & WSATTR_BLINK) != 0)
		return (EINVAL);

	if ((flg & WSATTR_WSCOLORS) == 0) {
		fg = WSCOL_WHITE;
		bg = WSCOL_BLACK;
	}

	if ((flg & WSATTR_REVERSE) != 0) {
		swap = fg;
		fg = bg;
		bg = swap;
	}

	if ((flg & WSATTR_HILIT) != 0) {
		if (fg == WSCOL_BLACK)
			fg = 8;	/* ``regular'' dark gray */
		else if (fg != WSCOL_WHITE) /* white is always highlighted */
			fg += 8;
	}

	flg = ((flg & WSATTR_UNDERLINE) ? 1 : 0);

	/* we're lucky we do not need a different isgray table... */
	if (rasops_isgray[fg])
		flg |= 2;
	if (rasops_isgray[bg])
		flg |= 4;

	*attrp = (bg << 16) | (fg << 24) | flg;
@


1.39
log
@Provide our own alloc_attr() routine for sun frame buffer, since the computation
of highlighted color indexes is slightly different due to different black and
white color code (and the fact that the default white is the highlighted white).
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.38 2006/06/30 21:38:17 miod Exp $	*/
d494 1
@


1.38
log
@For 32bit sun frame buffers, tweak ri_devcmap to get the BoW palette instead
of needing different WSCOL_{BLACK,WHITE} values than 8bit frame buffers.

This allows us to not special case the alloc_attr() invocations depending
on the color depth, and to make WSCOL_{BLACK,WHITE} constants again in the
wsemul_sun land.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.37 2006/06/29 17:54:30 miod Exp $	*/
d114 1
d334 1
d338 5
a342 5
	sf->sf_ro.ri_flg = RI_CENTER | RI_FULLCLEAR | flags;
	sf->sf_ro.ri_depth = sf->sf_depth;
	sf->sf_ro.ri_stride = sf->sf_linebytes;
	sf->sf_ro.ri_width = sf->sf_width;
	sf->sf_ro.ri_height = sf->sf_height;
d369 3
a371 1
	rasops_init(&sf->sf_ro, rows, cols);
d505 1
d510 1
a510 1
	*cookiep = &sf->sf_ro;
d513 2
a514 2
	if (sf->sf_depth == 8) {
		sf->sf_ro.ri_ops.alloc_attr(&sf->sf_ro,
d516 2
a517 4
	} else {
		sf->sf_ro.ri_ops.alloc_attr(&sf->sf_ro,
		    0, 0, 0, attrp);
	}
d534 42
@


1.37
log
@No need to keep specific variables for the kernel messages colors on sun
emulation, we can reuse the existing WSCOL_xxx codes, and WSCOL_BLACK and
WSCOL_WHITE will point to variables anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.36 2006/03/12 22:53:01 miod Exp $	*/
d373 2
d380 1
a380 1
		sf->sf_ro.ri_ccol = *sf->sf_ccolp;
d384 1
a384 1
			sf->sf_ro.ri_crow = *sf->sf_crowp;
d387 1
a387 1
			sf->sf_ro.ri_crow = sf->sf_ro.ri_rows - 1;
d397 1
a397 1
		sf->sf_ro.ri_crow = row;
d404 4
a407 4
	if (sf->sf_ro.ri_crow >= sf->sf_ro.ri_rows)
		sf->sf_ro.ri_crow = sf->sf_ro.ri_rows - 1;
	if (sf->sf_ro.ri_ccol >= sf->sf_ro.ri_cols)
		sf->sf_ro.ri_ccol = sf->sf_ro.ri_cols - 1;
d412 1
a412 1
	if (sf->sf_ro.ri_updatecursor == NULL &&
d414 1
a414 1
		sf->sf_ro.ri_updatecursor = fb_updatecursor;
d421 3
a423 2
		wscol_white = 0;
		wscol_black = 255;
d426 2
a427 3
	if (ISSET(sf->sf_ro.ri_caps, WSSCREEN_WSCOLORS) &&
	    sf->sf_depth == 8) {
		sf->sf_ro.ri_ops.alloc_attr(&sf->sf_ro,
d429 2
a430 3
	} else {
		sf->sf_ro.ri_ops.alloc_attr(&sf->sf_ro, 0, 0, 0, &defattr);
	}
d433 2
a434 2
	wsdisplay_cnattach(&sf->sf_wsd, &sf->sf_ro,
	    sf->sf_ro.ri_ccol, sf->sf_ro.ri_crow, defattr);
@


1.36
log
@Previous fix was half-done, move the wsscreen_list array into the softc
as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.34 2005/03/23 17:16:34 miod Exp $	*/
a420 2
		wskernel_bg = 0;
		wskernel_fg = 255;
@


1.35
log
@When attaching a wsdisplay, the wsscreen_list structure can not be on the
stack; found the hard way by Stefano <stefano@@merlinobbs.net>.
@
text
@a465 1
	struct wsscreen_descr *scrlist[1];
d483 1
a483 1
	scrlist[0] = &sf->sf_wsd;
d485 1
a485 1
	sf->sf_wsl.screens = (const struct wsscreen_descr **)scrlist;
@


1.34
log
@Move the alloc_screen, free_screen and show_screen wsdisplay accessops to
the common frame buffer code, rather than duplicating it in every driver.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.33 2005/03/15 18:40:12 miod Exp $	*/
a466 1
	struct wsscreen_list screenlist;
d485 2
a486 2
	screenlist.nscreens = 1;
	screenlist.screens = (const struct wsscreen_descr **)scrlist;
d489 1
a489 1
	waa.scrdata = &screenlist;
@


1.33
log
@Take care of updating the PROMs view of the cursor position in the common fb
code, rather than doing this in only a subset of the fb drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.32 2005/03/07 16:44:50 miod Exp $	*/
d114 5
d478 7
d496 41
d538 1
d540 1
a540 1
 * Support routines for pfour framebuffers.
d544 3
a546 6
 * Probe for a pfour framebuffer.  Return values:
 *
 *	PFOUR_NOTPFOUR		framebuffer is not a pfour
 *				framebuffer
 *
 *	otherwise returns pfour ID
a570 11

/*
 * Return the status of the video enable.
 */
int
fb_pfour_get_video(struct sunfb *sf)
{

	return ((*sf->sf_pfour & PFOUR_REG_VIDEO) != 0);
}

d572 1
a572 1
 * Enable or disable the framebuffer.
d575 1
a575 1
fb_pfour_set_video(struct sunfb *sf, int enable)
d577 1
@


1.32
log
@Do not bother passing the blanking routine to fbwscons_console_init(),
as fbwscons_attach() can find it on its own.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.31 2005/02/27 22:25:34 miod Exp $	*/
a86 1
#include <dev/wscons/wscons_raster.h>
d113 1
d314 11
d401 7
@


1.31
log
@Move wsdisplay-only prototypes declarations in the #if NWSDISPLAY > 0 block
so that kernels with no frame buffer drivers can compile; spotted by marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.30 2005/02/22 10:00:58 miod Exp $	*/
d355 1
a355 2
fbwscons_console_init(struct sunfb *sf, int row,
    void (*burner)(void *, u_int, u_int))
a412 4

	/* remember screen burner routine */
	fb_burner = burner;
	fb_cookie = sf;
d449 4
@


1.30
log
@Allow SUN4 kernels to compile; spotted by marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.29 2004/11/29 22:07:37 miod Exp $	*/
a92 5
#if defined(SUN4C) || defined(SUN4M)
static int a2int(char *, int);
#endif
static void fb_initwsd(struct sunfb *);

d109 5
@


1.29
log
@Move the struct wsscreen_descr from a per-driver global to a per-instance
field of the sunfb structure. This allows multiple instances of the same driver,
but with different resolutions (such as a couple of vigra or a TGX cgsix and
a TGX+ cgsix) to use distinct wsscreen_descr structures featuring different
resolution information.

Doing this allows more wsscreen_descr fiddling inside the sparc* fb api,
and results in some code shrinkage (about 4KB on sparc GENERIC).
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.28 2004/02/29 21:24:36 miod Exp $	*/
d93 1
d95 1
d289 1
d301 1
@


1.28
log
@More colormap games for 8-bit framebuffers to enjoy the inverted cursor too.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.27 2003/10/05 18:34:42 miod Exp $	*/
d5 1
a5 1
 * Copyright (c) 2002 Miodrag Vallat
d93 3
d287 1
a287 3
int a2int(char *, int);

int
d299 11
d351 1
a351 1
fbwscons_console_init(struct sunfb *sf, struct wsscreen_descr *wsc, int row,
d383 4
a386 4
	if (sf->sf_ro.ri_crow >= wsc->nrows)
		sf->sf_ro.ri_crow = wsc->nrows - 1;
	if (sf->sf_ro.ri_ccol >= wsc->ncols)
		sf->sf_ro.ri_ccol = wsc->ncols - 1;
d399 1
a399 1
	if (ISSET(wsc->capabilities, WSSCREEN_WSCOLORS) &&
d407 2
a408 1
	wsdisplay_cnattach(wsc, &sf->sf_ro,
d438 23
@


1.27
log
@If attaching a wsdisplay console causes a font switch, do not update the PROM
view of the cursor position, so that it comes back to a correct location when
the system is shut down.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.26 2003/06/28 17:05:33 miod Exp $	*/
d415 4
d421 1
a421 1
		setcolor(sf, 255, 0, 0, 0);	/* cursor */
d423 1
@


1.26
log
@Sync sparc fb API with the sparc64 changes (fbwscons_init takes flags, and
the sunfb structure keeps pointer to the prom cursor coordinates).
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.25 2003/06/28 14:26:16 miod Exp $	*/
d356 8
a364 2
		if (sf->sf_crowp != NULL)
			*sf->sf_crowp = row;
@


1.25
log
@Add RI_FULLCLEAR to the rasops flags. Accelerated drivers (cgsix, creator,
pnozz) benefit from this, and this does not hurt the other drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.24 2003/06/02 23:27:54 millert Exp $	*/
d111 2
a112 3
fb_setsize(sf, def_depth, def_width, def_height, node, bustype)
	struct sunfb *sf;
	int def_depth, def_width, def_height, node, bustype;
a115 4
	/*
	 * The defaults below match my screen, but are not guaranteed
	 * to be correct as defaults go...
	 */
d121 2
a122 1
		if (CPU_ISSUN4M) {   /* 4m has framebuffer on obio */
d287 1
a287 3
a2int(cp, deflt)
	char *cp;
	int deflt;
d299 1
a299 3
fbwscons_init(sf, isconsole)
	struct sunfb *sf;
	int isconsole;
d304 1
a304 3
	sf->sf_ro.ri_flg = RI_CENTER | RI_FULLCLEAR;
	if (!isconsole)
		sf->sf_ro.ri_flg |= RI_CLEAR;
d324 1
a324 1
			if (rows == 0)
d326 1
a326 1
			if (cols == 0)
d339 2
a340 5
fbwscons_console_init(sf, wsc, row, burner)
	struct sunfb *sf;
	struct wsscreen_descr *wsc;
	int row;
	void (*burner)(void *, u_int, u_int);
a342 1
	int *ccolp, *crowp;
d344 4
a347 4
	if (CPU_ISSUN4 || romgetcursoraddr(&crowp, &ccolp))
		ccolp = crowp = NULL;
	if (ccolp != NULL)
		sf->sf_ro.ri_ccol = *ccolp;
d350 2
a351 2
		if (crowp != NULL)
			sf->sf_ro.ri_crow = *crowp;
d355 1
a355 1
	} else
d357 3
d398 2
a399 3
fbwscons_setcolormap(sf, setcolor)
	struct sunfb *sf;
	void (*setcolor)(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
d430 1
a430 2
fb_pfour_id(va)
	void *va;
d457 1
a457 2
fb_pfour_get_video(sf)
	struct sunfb *sf;
d467 1
a467 3
fb_pfour_set_video(sf, enable)
	struct sunfb *sf;
	int enable;
@


1.24
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.23 2002/11/24 00:36:16 miod Exp $	*/
d312 1
a312 1
	sf->sf_ro.ri_flg = RI_CENTER;
@


1.23
log
@When initializing the colormap on low depth frame buffers, pick values
from rasops_cmap table, rather than providing our own, especially when
they are wrong.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.22 2002/11/06 21:06:20 miod Exp $	*/
d50 1
a50 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.22
log
@- always initialize colormaps, even if the frame buffer is non console; this
  helps if the ramdac does not get initialized (idea from jason@@)
- only register a shutdown hook for the frame buffers which need it, if this
  is the console frame buffer. Otherwise this is just a waste of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.21 2002/09/05 09:31:20 miod Exp $	*/
d417 3
d421 5
d427 1
a427 7
		setcolor(sf, 255, 0, 0, 0);
		setcolor(sf, WSCOL_RED, 255, 0, 0);
		setcolor(sf, WSCOL_GREEN, 0, 255, 0);
		setcolor(sf, WSCOL_BROWN, 154, 85, 46);
		setcolor(sf, WSCOL_BLUE, 0, 0, 255);
		setcolor(sf, WSCOL_MAGENTA, 255, 255, 0);
		setcolor(sf, WSCOL_CYAN, 0, 255, 255);
@


1.21
log
@Allow kernels with no display device configured to link. Found by marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.20 2002/08/16 02:06:43 millert Exp $	*/
d353 1
a353 1
fbwscons_console_init(sf, wsc, row, setcolor, burner)
a356 1
	void (*setcolor)(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
d389 1
a389 11
	if (sf->sf_depth == 8 && setcolor != NULL) {
		setcolor(sf, WSCOL_BLACK, 0, 0, 0);
		setcolor(sf, 255, 0, 0, 0);
		setcolor(sf, WSCOL_RED, 255, 0, 0);
		setcolor(sf, WSCOL_GREEN, 0, 255, 0);
		setcolor(sf, WSCOL_BROWN, 154, 85, 46);
		setcolor(sf, WSCOL_BLUE, 0, 0, 255);
		setcolor(sf, WSCOL_MAGENTA, 255, 255, 0);
		setcolor(sf, WSCOL_CYAN, 0, 255, 255);
		setcolor(sf, WSCOL_WHITE, 255, 255, 255);
	} else if (sf->sf_depth > 8) {
d410 18
@


1.20
log
@Scale back rows and columns if the font would not otherwise fit on the
display. Otherwise, we would panic in wsdisplay_cnattach().  miod@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.19 2002/08/12 10:44:04 miod Exp $	*/
d95 19
a307 15
/*
 * emergency unblank code
 * XXX should be somewhat moved to wscons MI code
 */

void (*fb_burner)(void *, u_int, u_int);
void *fb_cookie;

void
fb_unblank()
{
	if (fb_burner != NULL)
		(*fb_burner)(fb_cookie, 1, 0);
}

d488 1
@


1.19
log
@Convert sparc console code from rcons and pseudo-devices to rasops and wscons.
For most framebuffers it is faster.

Other changes include:
o 24 bit support in tcx(4) for the S24 framebuffer
o accelerated cgsix(4) text console
o new cgtwelve(4) driver for the GS framebuffer
o improved serial driver code
o better keyboard support

The following framebuffers have not been tested but should work: cgfour,
cgeight and cgfourteen

These changes will require XF4 changes, to use Xwsfb instead of Xsun*, to be
commited later today.

Most of the work by me during the LSM and the week after, with code borrowed
from jason@@, NetBSD (new serial code), and feedback from mickey@@. Work on
pnozz(4) done by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.18 2002/03/14 01:26:42 millert Exp $	*/
d372 9
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.17 2001/11/01 12:13:46 art Exp $	*/
d5 25
d74 1
a74 2
 * /dev/fb (indirect frame buffer driver).  This is gross; we should
 * just build cdevsw[] dynamically.
a83 3
#include <machine/fbio.h>
#include <machine/kbd.h>
#include <machine/fbvar.h>
d90 4
a93 12
#include "kbd.h"

static struct fbdevice *devfb;


void
fb_unblank()
{

	if (devfb)
		(*devfb->fb_driver->fbd_unblank)(devfb->fb_device);
}
d96 3
a98 118
fb_attach(fb, isconsole)
	struct fbdevice *fb;
	int isconsole;
{
	static int no_replace, seen_force;

	/*
	 * We've already had a framebuffer forced into /dev/fb.  Don't
	 * allow any more, even if this is the console.
	 */
	if (seen_force) {
		if (devfb) {	/* sanity */
			printf("%s: /dev/fb already full\n",
				fb->fb_device->dv_xname);
			return;
		} else
			seen_force = 0;
	}

	/*
	 * Check to see if we're being forced into /dev/fb.
	 */
	if (fb->fb_flags & FB_FORCE) {
		if (devfb)
			printf("%s: forcefully replacing %s\n",
				fb->fb_device->dv_xname,
				devfb->fb_device->dv_xname);
		devfb = fb;
		seen_force = no_replace = 1;
		goto attached;
	}

	/*
	 * Check to see if we're the console.  If we are, then replace
	 * any currently existing framebuffer.
	 */
	if (isconsole) {
		if (devfb)
			printf("%s: replacing %s\n", fb->fb_device->dv_xname,
				devfb->fb_device->dv_xname);
		devfb = fb;
		no_replace = 1;
		goto attached;
	}

	/*
	 * For the final case, we check to see if we can replace an
	 * existing framebuffer, if not, say so and return.
	 */
	if (no_replace) {
		if (devfb) {	/* sanity */
			printf("%s: /dev/fb already full\n",
				fb->fb_device->dv_xname);
			return;
		} else
			no_replace = 0;
	}

	if (devfb)
		printf("%s: replacing %s\n", fb->fb_device->dv_xname,
			devfb->fb_device->dv_xname);
	devfb = fb;

 attached:
	printf("%s: attached to /dev/fb\n", devfb->fb_device->dv_xname);
}

int
fbopen(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{

	if (devfb == NULL)
		return (ENXIO);
	return (devfb->fb_driver->fbd_open)(dev, flags, mode, p);
}

int
fbclose(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{

	return (devfb->fb_driver->fbd_close)(dev, flags, mode, p);
}

int
fbioctl(dev, cmd, data, flags, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
{

	return (devfb->fb_driver->fbd_ioctl)(dev, cmd, data, flags, p);
}

paddr_t
fbmmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
{
	paddr_t (*map)(dev_t, off_t, int) = devfb->fb_driver->fbd_mmap;

	if (map == NULL)
		return (-1);
	return (map(dev, off, prot));
}

void
fb_setsize(fb, depth, def_width, def_height, node, bustype)
	struct fbdevice *fb;
	int depth, def_width, def_height, node, bustype;
d100 1
d110 1
d112 1
a112 7
			fb->fb_type.fb_width = getpropint(node, "width",
							  def_width);
			fb->fb_type.fb_height = getpropint(node, "height",
							   def_height);
			fb->fb_linebytes = getpropint(node, "linebytes",
			    (fb->fb_type.fb_width * depth) / 8);
			break;
d114 1
d116 3
a118 2
		fb->fb_type.fb_width = def_width;
		fb->fb_type.fb_height = def_height;
d132 1
a132 1
			if (fb->fb_flags & FB_PFOUR) {
d144 1
a144 1
				if (fb->fb_pfour == NULL)
d147 1
a147 1
				pfour = *fb->fb_pfour;
d163 2
a164 2
					fb->fb_type.fb_width = 1152;
					fb->fb_type.fb_height = 900;
d168 2
a169 2
					fb->fb_type.fb_width = 1024;
					fb->fb_type.fb_height = 1024;
d173 2
a174 2
					fb->fb_type.fb_width = 1280;
					fb->fb_type.fb_height = 1024;
d178 2
a179 2
					fb->fb_type.fb_width = 1600;
					fb->fb_type.fb_height = 1280;
d183 2
a184 2
					fb->fb_type.fb_width = 1440;
					fb->fb_type.fb_height = 1440;
d188 2
a189 2
					fb->fb_type.fb_width = 640;
					fb->fb_type.fb_height = 480;
d203 2
a204 2
					fb->fb_type.fb_width = 1152;
					fb->fb_type.fb_height = 900;
d208 2
a209 2
					fb->fb_type.fb_width = 1024;
					fb->fb_type.fb_height = 1024;
d213 2
a214 2
					fb->fb_type.fb_width = 1600;
					fb->fb_type.fb_height = 1280;
d218 2
a219 2
					fb->fb_type.fb_width = 1440;
					fb->fb_type.fb_height = 1440;
d239 2
a240 2
 donesize:
		fb->fb_linebytes = (fb->fb_type.fb_width * depth) / 8;
d244 19
a262 4
		fb->fb_type.fb_width = getpropint(node, "width", def_width);
		fb->fb_type.fb_height = getpropint(node, "height", def_height);
		fb->fb_linebytes = getpropint(node, "linebytes",
		    (fb->fb_type.fb_width * depth) / 8);
d269 2
d273 1
d275 1
a275 9
#ifdef RASTERCONSOLE
#include <machine/kbd.h>

static void fb_bell(int);

#if !(defined(RASTERCONS_FULLSCREEN) || defined(RASTERCONS_SMALLFONT))
static int a2int(char *, int);

static int
d277 2
a278 2
	register char *cp;
	register int deflt;
d280 1
a280 1
	register int i = 0;
a287 1
#endif
d289 10
a298 3
static void
fb_bell(on)
	int on;
d300 2
a301 3
#if NKBD > 0
	(void)kbd_docmd(on?KBD_CMD_BELL:KBD_CMD_NOBELL, 0);
#endif
a303 2
#include <sparc/dev/rcons_font.h>

d305 3
a307 2
fbrcons_init(fb)
	struct fbdevice *fb;
d309 1
a309 1
	struct rconsole	*rc = &fb->fb_rcons;
d311 15
a325 18
	/*
	 * Common glue for rconsole initialization
	 * XXX - mostly duplicates values with fbdevice.
	 */
	rc->rc_linebytes = fb->fb_linebytes;
	rc->rc_pixels = fb->fb_pixels;
	rc->rc_width = fb->fb_type.fb_width;
	rc->rc_height = fb->fb_type.fb_height;
	rc->rc_depth = fb->fb_type.fb_depth;
	/* Setup the static font, use a small font if display is < 800x600 */
	if(rc->rc_height * rc->rc_width <= 800*600)
		rc->rc_font = &console_font_fixed;
	else
		rc->rc_font = &console_font;

	rc->rc_maxcol = rc->rc_width / rc->rc_font->width;
	rc->rc_maxrow = rc->rc_height / rc->rc_font->height;
#if !defined(RASTERCONS_FULLSCREEN) && !defined(RASTERCONS_SMALLFONT)
d328 1
a328 1
		struct eeprom *eep = (struct eeprom *)eeprom_va;
d330 12
a341 4
		rc->rc_maxcol = min(rc->rc_maxcol,
		    (eep && eep->eeTtyCols) ? eep->eeTtyCols : 80);
		rc->rc_maxrow = min(rc->rc_maxrow,
		    (eep && eep->eeTtyRows) ? eep->eeTtyRows : 34);
d343 29
a371 1
#endif /* SUN4 */
d373 19
a391 5
	if (!CPU_ISSUN4) {
		rc->rc_maxcol = min(rc->rc_maxcol,
		    a2int(getpropstring(optionsnode, "screen-#columns"), 80));
		rc->rc_maxrow = min(rc->rc_maxrow,
		    a2int(getpropstring(optionsnode, "screen-#rows"), 34));
a392 1
#endif /* !RASTERCONS_FULLSCREEN && !RASTERCONS_SMALLFONT */
d394 7
a400 6
#if !(defined(RASTERCONS_FULLSCREEN) || defined(RASTERCONS_SMALLFONT))
	/* Determine addresses of prom emulator row and column */
	if (CPU_ISSUN4 ||
	    romgetcursoraddr(&rc->rc_row, &rc->rc_col))
#endif
		rc->rc_row = rc->rc_col = NULL;
d402 2
a403 5
	rc->rc_bell = fb_bell;
	rcons_init(rc);
	/* Hook up virtual console */
	v_putc = rcons_cnputc;
}
d405 3
a407 4
int
fbrcons_rows()
{
	return (devfb ? devfb->fb_rcons.rc_maxrow : 0);
a409 7
int
fbrcons_cols()
{
	return (devfb ? devfb->fb_rcons.rc_maxcol : 0);
}
#endif /* RASTERCONSOLE */

d447 1
d452 2
a453 2
fb_pfour_get_video(fb)
	struct fbdevice *fb;
d456 1
a456 1
	return ((*fb->fb_pfour & PFOUR_REG_VIDEO) != 0);
d463 2
a464 2
fb_pfour_set_video(fb, enable)
	struct fbdevice *fb;
d469 2
a470 2
	pfour = *fb->fb_pfour & ~(PFOUR_REG_INTCLR|PFOUR_REG_VIDEO);
	*fb->fb_pfour = pfour | (enable ? PFOUR_REG_VIDEO : 0);
d472 1
d474 1
@


1.17
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.16 2001/09/08 18:02:29 jason Exp $	*/
d190 1
a190 1
	paddr_t (*map)__P((dev_t, off_t, int)) = devfb->fb_driver->fbd_mmap;
d364 1
a364 1
static void fb_bell __P((int));
d367 1
a367 1
static int a2int __P((char *, int));
@


1.17.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.17 2001/11/01 12:13:46 art Exp $	*/
d190 1
a190 1
	paddr_t (*map)(dev_t, off_t, int) = devfb->fb_driver->fbd_mmap;
d364 1
a364 1
static void fb_bell(int);
d367 1
a367 1
static int a2int(char *, int);
@


1.17.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.17.2.1 2002/06/11 03:38:16 art Exp $	*/
a4 25
 * Copyright (c) 2002 Miodrag Vallat
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *
d49 2
a50 1
 * Common wsdisplay framebuffer drivers helpers.
d60 3
d69 1
a69 4
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>
d71 1
a71 1
#include "wsdisplay.h"
a72 4
/*
 * emergency unblank code
 * XXX should be somewhat moved to wscons MI code
 */
d74 7
a80 2
void (*fb_burner)(void *, u_int, u_int);
void *fb_cookie;
d83 96
a178 1
fb_unblank()
d180 2
a181 2
	if (fb_burner != NULL)
		(*fb_burner)(fb_cookie, 1, 0);
d184 12
a195 1
#if NWSDISPLAY > 0
d198 3
a200 3
fb_setsize(sf, def_depth, def_width, def_height, node, bustype)
	struct sunfb *sf;
	int def_depth, def_width, def_height, node, bustype;
a201 1
	int def_linebytes;
a210 1
#if defined(SUN4M)
d212 7
a218 1
			goto obpsize;
a219 1
#endif
d221 2
a222 3
		sf->sf_width = def_width;
		sf->sf_height = def_height;
		sf->sf_depth = def_depth;
d236 1
a236 1
			if (ISSET(sf->sf_flags, FB_PFOUR)) {
d248 1
a248 1
				if (sf->sf_pfour == NULL)
d251 1
a251 1
				pfour = *sf->sf_pfour;
d267 2
a268 2
					sf->sf_width = 1152;
					sf->sf_height = 900;
d272 2
a273 2
					sf->sf_width = 1024;
					sf->sf_height = 1024;
d277 2
a278 2
					sf->sf_width = 1280;
					sf->sf_height = 1024;
d282 2
a283 2
					sf->sf_width = 1600;
					sf->sf_height = 1280;
d287 2
a288 2
					sf->sf_width = 1440;
					sf->sf_height = 1440;
d292 2
a293 2
					sf->sf_width = 640;
					sf->sf_height = 480;
d307 2
a308 2
					sf->sf_width = 1152;
					sf->sf_height = 900;
d312 2
a313 2
					sf->sf_width = 1024;
					sf->sf_height = 1024;
d317 2
a318 2
					sf->sf_width = 1600;
					sf->sf_height = 1280;
d322 2
a323 2
					sf->sf_width = 1440;
					sf->sf_height = 1440;
d343 2
a344 2
donesize:
		sf->sf_linebytes = (sf->sf_width * sf->sf_depth) / 8;
d348 4
a351 19
#if defined(SUN4M)
obpsize:
#endif
		sf->sf_depth = getpropint(node, "depth", def_depth);
		sf->sf_width = getpropint(node, "width", def_width);
		sf->sf_height = getpropint(node, "height", def_height);

		def_linebytes =
		    roundup(sf->sf_width, sf->sf_depth) * sf->sf_depth / 8;
		sf->sf_linebytes = getpropint(node, "linebytes", def_linebytes);
		/*
		 * XXX If we are configuring a board in a wider depth level
		 * than the mode it is currently operating in, the PROM will
		 * return a linebytes property tied to the current depth value,
		 * which is NOT what we are relying upon!
		 */
		if (sf->sf_linebytes < (sf->sf_width * sf->sf_depth) / 8) {
			sf->sf_linebytes = def_linebytes;
		}
d358 2
d361 4
a364 2
	sf->sf_fbsize = sf->sf_height * sf->sf_linebytes;
}
d366 2
a367 1
int a2int(char *, int);
d369 1
a369 1
int
d371 2
a372 2
	char *cp;
	int deflt;
d374 1
a374 1
	int i = 0;
d382 1
d384 3
a386 4
void
fbwscons_init(sf, isconsole)
	struct sunfb *sf;
	int isconsole;
d388 2
a389 16
	int cols, rows;

	/* ri_hw and ri_bits must have already been setup by caller */
	sf->sf_ro.ri_flg = RI_CENTER;
	if (!isconsole)
		sf->sf_ro.ri_flg |= RI_CLEAR;
	sf->sf_ro.ri_depth = sf->sf_depth;
	sf->sf_ro.ri_stride = sf->sf_linebytes;
	sf->sf_ro.ri_width = sf->sf_width;
	sf->sf_ro.ri_height = sf->sf_height;

#if defined(SUN4C) || defined(SUN4M)
	if (CPU_ISSUN4COR4M) {
		rows = a2int(getpropstring(optionsnode, "screen-#rows"), 34);
		cols = a2int(getpropstring(optionsnode, "screen-#columns"), 80);
	}
d391 1
a391 3
#if defined(SUN4)
	if (CPU_ISSUN4) {
		struct eeprom *ep = (struct eeprom *)eeprom_va;
d393 1
a393 17
		if (ep != NULL) {
			rows = (u_short)ep->eeTtyRows;
			cols = (u_short)ep->eeTtyCols;
			/* deal with broken nvram contents... */
			if (rows == 0)
				rows = 34;
			if (cols == 0)
				cols = 80;
		} else {
			rows = 34;
			cols = 80;
		}
	}
#endif

	rasops_init(&sf->sf_ro, rows, cols);
}
d396 4
a399 23
fbwscons_console_init(sf, wsc, row, setcolor, burner)
	struct sunfb *sf;
	struct wsscreen_descr *wsc;
	int row;
	void (*setcolor)(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
	void (*burner)(void *, u_int, u_int);
{
	long defattr;
	int *ccolp, *crowp;

	if (CPU_ISSUN4 || romgetcursoraddr(&crowp, &ccolp))
		ccolp = crowp = NULL;
	if (ccolp != NULL)
		sf->sf_ro.ri_ccol = *ccolp;

	if (row < 0) {
		if (crowp != NULL)
			sf->sf_ro.ri_crow = *crowp;
		else
			/* assume last row */
			sf->sf_ro.ri_crow = sf->sf_ro.ri_rows - 1;
	} else
		sf->sf_ro.ri_crow = row;
d402 2
a403 2
	 * Scale back rows and columns if the font would not otherwise
	 * fit on this display. Without this we would panic later.
d405 17
a421 4
	if (sf->sf_ro.ri_crow >= wsc->nrows)
		sf->sf_ro.ri_crow = wsc->nrows - 1;
	if (sf->sf_ro.ri_ccol >= wsc->ncols)
		sf->sf_ro.ri_ccol = wsc->ncols - 1;
d423 4
a426 19
	/*
	 * Select appropriate color settings to mimic a
	 * black on white Sun console.
	 */
	if (sf->sf_depth == 8 && setcolor != NULL) {
		setcolor(sf, WSCOL_BLACK, 0, 0, 0);
		setcolor(sf, 255, 0, 0, 0);
		setcolor(sf, WSCOL_RED, 255, 0, 0);
		setcolor(sf, WSCOL_GREEN, 0, 255, 0);
		setcolor(sf, WSCOL_BROWN, 154, 85, 46);
		setcolor(sf, WSCOL_BLUE, 0, 0, 255);
		setcolor(sf, WSCOL_MAGENTA, 255, 255, 0);
		setcolor(sf, WSCOL_CYAN, 0, 255, 255);
		setcolor(sf, WSCOL_WHITE, 255, 255, 255);
	} else if (sf->sf_depth > 8) {
		wscol_white = 0;
		wscol_black = 255;
		wskernel_bg = 0;
		wskernel_fg = 255;
d428 1
d430 5
a434 6
	if (ISSET(wsc->capabilities, WSSCREEN_WSCOLORS) &&
	    sf->sf_depth == 8) {
		sf->sf_ro.ri_ops.alloc_attr(&sf->sf_ro,
		    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, &defattr);
	} else {
		sf->sf_ro.ri_ops.alloc_attr(&sf->sf_ro, 0, 0, 0, &defattr);
d436 1
d438 18
a455 2
	wsdisplay_cnattach(wsc, &sf->sf_ro,
	    sf->sf_ro.ri_ccol, sf->sf_ro.ri_crow, defattr);
d457 4
a460 3
	/* remember screen burner routine */
	fb_burner = burner;
	fb_cookie = sf;
d462 1
a500 1

d505 2
a506 2
fb_pfour_get_video(sf)
	struct sunfb *sf;
d509 1
a509 1
	return ((*sf->sf_pfour & PFOUR_REG_VIDEO) != 0);
d516 2
a517 2
fb_pfour_set_video(sf, enable)
	struct sunfb *sf;
d522 2
a523 2
	pfour = *sf->sf_pfour & ~(PFOUR_REG_INTCLR | PFOUR_REG_VIDEO);
	*sf->sf_pfour = pfour | (enable ? PFOUR_REG_VIDEO : 0);
a524 1

a525 2

#endif	/* NWSDISPLAY */
@


1.17.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d353 1
a353 1
fbwscons_console_init(sf, wsc, row, burner)
d357 1
d390 11
a400 1
	if (sf->sf_depth > 8) {
a420 20
}

void
fbwscons_setcolormap(sf, setcolor)
	struct sunfb *sf;
	void (*setcolor)(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
{
	int i;
	u_char *color;

	if (sf->sf_depth <= 8 && setcolor != NULL) {
		for (i = 0; i < 16; i++) {
			color = (u_char *)&rasops_cmap[i * 3];
			setcolor(sf, i, color[0], color[1], color[2]);
		}
		/* compensate for BoW palette */
		setcolor(sf, WSCOL_BLACK, 0, 0, 0);
		setcolor(sf, 255, 0, 0, 0);	/* cursor */
		setcolor(sf, WSCOL_WHITE, 255, 255, 255);
	}
@


1.16
log
@Don't reference kbd_docmd() unless NKBD > 0; reported by Steven Siirila <sfs@@Siirila.org> (pr2052)
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.15 1999/09/05 18:51:08 jason Exp $	*/
d184 1
a184 1
int
d187 2
a188 1
	int off, prot;
d190 1
a190 1
	int (*map)__P((dev_t, int, int)) = devfb->fb_driver->fbd_mmap;
@


1.15
log
@use small font if size <= 800x600 (was if size < 800x600)
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.14 1998/03/20 05:18:27 todd Exp $	*/
d69 2
d387 1
d389 1
@


1.15.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.15 1999/09/05 18:51:08 jason Exp $	*/
a68 2
#include "kbd.h"

a384 1
#if NKBD > 0
a385 1
#endif
@


1.15.4.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d184 1
a184 1
paddr_t
d187 1
a187 2
	off_t off;
	int prot;
d189 1
a189 1
	paddr_t (*map)__P((dev_t, off_t, int)) = devfb->fb_driver->fbd_mmap;
@


1.15.4.3
log
@Merge in -current from about a week ago
@
text
@d190 1
a190 1
	paddr_t (*map)(dev_t, off_t, int) = devfb->fb_driver->fbd_mmap;
d364 1
a364 1
static void fb_bell(int);
d367 1
a367 1
static int a2int(char *, int);
@


1.15.4.4
log
@Sync the SMP branch with 3.3
@
text
@a4 25
 * Copyright (c) 2002 Miodrag Vallat
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *
d49 2
a50 1
 * Common wsdisplay framebuffer drivers helpers.
d60 3
d69 1
a69 4
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>
d71 1
a71 1
#include "wsdisplay.h"
a72 4
/*
 * emergency unblank code
 * XXX should be somewhat moved to wscons MI code
 */
d74 7
a80 2
void (*fb_burner)(void *, u_int, u_int);
void *fb_cookie;
d83 96
a178 1
fb_unblank()
d180 2
a181 2
	if (fb_burner != NULL)
		(*fb_burner)(fb_cookie, 1, 0);
d184 12
a195 1
#if NWSDISPLAY > 0
d198 3
a200 3
fb_setsize(sf, def_depth, def_width, def_height, node, bustype)
	struct sunfb *sf;
	int def_depth, def_width, def_height, node, bustype;
a201 1
	int def_linebytes;
a210 1
#if defined(SUN4M)
d212 7
a218 1
			goto obpsize;
a219 1
#endif
d221 2
a222 3
		sf->sf_width = def_width;
		sf->sf_height = def_height;
		sf->sf_depth = def_depth;
d236 1
a236 1
			if (ISSET(sf->sf_flags, FB_PFOUR)) {
d248 1
a248 1
				if (sf->sf_pfour == NULL)
d251 1
a251 1
				pfour = *sf->sf_pfour;
d267 2
a268 2
					sf->sf_width = 1152;
					sf->sf_height = 900;
d272 2
a273 2
					sf->sf_width = 1024;
					sf->sf_height = 1024;
d277 2
a278 2
					sf->sf_width = 1280;
					sf->sf_height = 1024;
d282 2
a283 2
					sf->sf_width = 1600;
					sf->sf_height = 1280;
d287 2
a288 2
					sf->sf_width = 1440;
					sf->sf_height = 1440;
d292 2
a293 2
					sf->sf_width = 640;
					sf->sf_height = 480;
d307 2
a308 2
					sf->sf_width = 1152;
					sf->sf_height = 900;
d312 2
a313 2
					sf->sf_width = 1024;
					sf->sf_height = 1024;
d317 2
a318 2
					sf->sf_width = 1600;
					sf->sf_height = 1280;
d322 2
a323 2
					sf->sf_width = 1440;
					sf->sf_height = 1440;
d343 2
a344 2
donesize:
		sf->sf_linebytes = (sf->sf_width * sf->sf_depth) / 8;
d348 4
a351 19
#if defined(SUN4M)
obpsize:
#endif
		sf->sf_depth = getpropint(node, "depth", def_depth);
		sf->sf_width = getpropint(node, "width", def_width);
		sf->sf_height = getpropint(node, "height", def_height);

		def_linebytes =
		    roundup(sf->sf_width, sf->sf_depth) * sf->sf_depth / 8;
		sf->sf_linebytes = getpropint(node, "linebytes", def_linebytes);
		/*
		 * XXX If we are configuring a board in a wider depth level
		 * than the mode it is currently operating in, the PROM will
		 * return a linebytes property tied to the current depth value,
		 * which is NOT what we are relying upon!
		 */
		if (sf->sf_linebytes < (sf->sf_width * sf->sf_depth) / 8) {
			sf->sf_linebytes = def_linebytes;
		}
d358 5
d364 1
a364 2
	sf->sf_fbsize = sf->sf_height * sf->sf_linebytes;
}
d366 2
a367 1
int a2int(char *, int);
d369 1
a369 1
int
d371 2
a372 2
	char *cp;
	int deflt;
d374 1
a374 1
	int i = 0;
d382 1
d384 3
a386 4
void
fbwscons_init(sf, isconsole)
	struct sunfb *sf;
	int isconsole;
d388 2
a389 16
	int cols, rows;

	/* ri_hw and ri_bits must have already been setup by caller */
	sf->sf_ro.ri_flg = RI_CENTER;
	if (!isconsole)
		sf->sf_ro.ri_flg |= RI_CLEAR;
	sf->sf_ro.ri_depth = sf->sf_depth;
	sf->sf_ro.ri_stride = sf->sf_linebytes;
	sf->sf_ro.ri_width = sf->sf_width;
	sf->sf_ro.ri_height = sf->sf_height;

#if defined(SUN4C) || defined(SUN4M)
	if (CPU_ISSUN4COR4M) {
		rows = a2int(getpropstring(optionsnode, "screen-#rows"), 34);
		cols = a2int(getpropstring(optionsnode, "screen-#columns"), 80);
	}
d391 1
a391 3
#if defined(SUN4)
	if (CPU_ISSUN4) {
		struct eeprom *ep = (struct eeprom *)eeprom_va;
d393 1
a393 17
		if (ep != NULL) {
			rows = (u_short)ep->eeTtyRows;
			cols = (u_short)ep->eeTtyCols;
			/* deal with broken nvram contents... */
			if (rows == 0)
				rows = 34;
			if (cols == 0)
				cols = 80;
		} else {
			rows = 34;
			cols = 80;
		}
	}
#endif

	rasops_init(&sf->sf_ro, rows, cols);
}
d396 4
a399 22
fbwscons_console_init(sf, wsc, row, burner)
	struct sunfb *sf;
	struct wsscreen_descr *wsc;
	int row;
	void (*burner)(void *, u_int, u_int);
{
	long defattr;
	int *ccolp, *crowp;

	if (CPU_ISSUN4 || romgetcursoraddr(&crowp, &ccolp))
		ccolp = crowp = NULL;
	if (ccolp != NULL)
		sf->sf_ro.ri_ccol = *ccolp;

	if (row < 0) {
		if (crowp != NULL)
			sf->sf_ro.ri_crow = *crowp;
		else
			/* assume last row */
			sf->sf_ro.ri_crow = sf->sf_ro.ri_rows - 1;
	} else
		sf->sf_ro.ri_crow = row;
d402 2
a403 2
	 * Scale back rows and columns if the font would not otherwise
	 * fit on this display. Without this we would panic later.
d405 17
a421 4
	if (sf->sf_ro.ri_crow >= wsc->nrows)
		sf->sf_ro.ri_crow = wsc->nrows - 1;
	if (sf->sf_ro.ri_ccol >= wsc->ncols)
		sf->sf_ro.ri_ccol = wsc->ncols - 1;
d423 4
a426 9
	/*
	 * Select appropriate color settings to mimic a
	 * black on white Sun console.
	 */
	if (sf->sf_depth > 8) {
		wscol_white = 0;
		wscol_black = 255;
		wskernel_bg = 0;
		wskernel_fg = 255;
d428 1
d430 5
a434 6
	if (ISSET(wsc->capabilities, WSSCREEN_WSCOLORS) &&
	    sf->sf_depth == 8) {
		sf->sf_ro.ri_ops.alloc_attr(&sf->sf_ro,
		    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, &defattr);
	} else {
		sf->sf_ro.ri_ops.alloc_attr(&sf->sf_ro, 0, 0, 0, &defattr);
d436 1
d438 6
a443 2
	wsdisplay_cnattach(wsc, &sf->sf_ro,
	    sf->sf_ro.ri_ccol, sf->sf_ro.ri_crow, defattr);
d445 4
a448 3
	/* remember screen burner routine */
	fb_burner = burner;
	fb_cookie = sf;
d451 10
a460 18
void
fbwscons_setcolormap(sf, setcolor)
	struct sunfb *sf;
	void (*setcolor)(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
{
	int i;
	u_char *color;

	if (sf->sf_depth <= 8 && setcolor != NULL) {
		for (i = 0; i < 16; i++) {
			color = (u_char *)&rasops_cmap[i * 3];
			setcolor(sf, i, color[0], color[1], color[2]);
		}
		/* compensate for BoW palette */
		setcolor(sf, WSCOL_BLACK, 0, 0, 0);
		setcolor(sf, 255, 0, 0, 0);	/* cursor */
		setcolor(sf, WSCOL_WHITE, 255, 255, 255);
	}
d462 1
a500 1

d505 2
a506 2
fb_pfour_get_video(sf)
	struct sunfb *sf;
d509 1
a509 1
	return ((*sf->sf_pfour & PFOUR_REG_VIDEO) != 0);
d516 2
a517 2
fb_pfour_set_video(sf, enable)
	struct sunfb *sf;
d522 2
a523 2
	pfour = *sf->sf_pfour & ~(PFOUR_REG_INTCLR | PFOUR_REG_VIDEO);
	*sf->sf_pfour = pfour | (enable ? PFOUR_REG_VIDEO : 0);
a524 1

a525 2

#endif	/* NWSDISPLAY */
@


1.15.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.15.4.4 2003/03/27 23:49:25 niklas Exp $	*/
d50 5
a54 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.15.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d111 3
a113 2
fb_setsize(struct sunfb *sf, int def_depth, int def_width, int def_height,
    int node, int bustype)
d117 4
d126 1
a126 2
		/* 4m may have SBus-like framebuffer on obio */
		if (CPU_ISSUN4M) {
d291 3
a293 1
a2int(char *cp, int deflt)
d305 3
a307 1
fbwscons_init(struct sunfb *sf, int flags)
d312 3
a314 1
	sf->sf_ro.ri_flg = RI_CENTER | RI_FULLCLEAR | flags;
d334 1
a334 1
			if (rows <= 0)
d336 1
a336 1
			if (cols <= 0)
d349 5
a353 2
fbwscons_console_init(struct sunfb *sf, struct wsscreen_descr *wsc, int row,
    void (*burner)(void *, u_int, u_int))
d356 1
d358 4
a361 4
	if (CPU_ISSUN4 || romgetcursoraddr(&sf->sf_crowp, &sf->sf_ccolp))
		sf->sf_ccolp = sf->sf_crowp = NULL;
	if (sf->sf_ccolp != NULL)
		sf->sf_ro.ri_ccol = *sf->sf_ccolp;
d364 2
a365 2
		if (sf->sf_crowp != NULL)
			sf->sf_ro.ri_crow = *sf->sf_crowp;
d369 1
a369 9
	} else {
		/*
		 * If we force the display row, this is because the screen
		 * has been cleared or the font has been changed.
		 * In this case, choose not to keep pointers to the PROM
		 * cursor position, as the values are likely to be inaccurate
		 * upon shutdown...
		 */
		sf->sf_crowp = sf->sf_ccolp = NULL;
a370 1
	}
d409 3
a411 2
fbwscons_setcolormap(struct sunfb *sf,
    void (*setcolor)(void *, u_int, u_int8_t, u_int8_t, u_int8_t))
d442 2
a443 1
fb_pfour_id(void *va)
d470 2
a471 1
fb_pfour_get_video(struct sunfb *sf)
d481 3
a483 1
fb_pfour_set_video(struct sunfb *sf, int enable)
@


1.15.4.7
log
@Merge with the trunk
@
text
@a414 4
		for (i = 240; i < 256; i++) {
			color = (u_char *)&rasops_cmap[i * 3];
			setcolor(sf, i, color[0], color[1], color[2]);
		}
d417 1
a417 1
		setcolor(sf, 0xff ^ WSCOL_BLACK, 255, 255, 255);
a418 1
		setcolor(sf, 0xff ^ WSCOL_WHITE, 0, 0, 0);
@


1.14
log
@small (aka 'fixed' from X) fonts for raster consoles < 800*600 in size
this changes the choice to be at run-time from compile time
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.13 1997/11/11 13:04:22 niklas Exp $	*/
d406 1
a406 1
	if(rc->rc_height * rc->rc_width < 800*600)
@


1.13
log
@blush!
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.10 1997/08/08 08:25:04 downsj Exp $	*/
d405 5
a409 2
	/* Setup the static font */
	rc->rc_font = &console_font;
@


1.12
log
@whoops typo in last commit + accept 0 in col/row values on sun4 mean full sz
@
text
@d417 1
a417 1
		rc->rc_maxcol = min(rc->rc_maxcol,
a418 1
		}
@


1.11
log
@Limit the console size by the frambuffer size.  My 4/100 seems
to lie about the console size
@
text
@d415 4
a418 6
		if (eep == NULL) {
			rc->rc_maxcol = max(rc->rc_maxcol, 80);
			rc->rc_maxrow = max(rc->rc_maxrow, 34);
		} else {
			rc->rc_maxcol = max(rc->rc_maxcol, eep->eeTtyCols);
			rc->rc_maxrow = max(rc->rc_maxrow, eep->eeTtyRows);
d424 1
a424 1
		rc->rc_maxcol = max(rc->rc_maxcol,
d426 1
a426 1
		rc->rc_maxrow = max(rc->rc_maxrow,
@


1.10
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a407 1
#if defined(RASTERCONS_FULLSCREEN) || defined(RASTERCONS_SMALLFONT)
d410 1
a410 1
#else
d416 2
a417 2
			rc->rc_maxcol = 80;
			rc->rc_maxrow = 34;
d419 2
a420 2
			rc->rc_maxcol = eep->eeTtyCols;
			rc->rc_maxrow = eep->eeTtyRows;
d426 4
a429 4
		rc->rc_maxcol =
		    a2int(getpropstring(optionsnode, "screen-#columns"), 80);
		rc->rc_maxrow =
		    a2int(getpropstring(optionsnode, "screen-#rows"), 34);
d431 1
a431 1
#endif /* RASTERCONS_FULLSCREEN || RASTERCONS_SMALLFONT */
@


1.9
log
@Revert back to Theo's eeprom.h.
@
text
@d2 1
a2 1
/*	$NetBSD: fb.c,v 1.18 1996/04/01 17:29:54 christos Exp $ */
d302 2
a303 2
				switch (eep->ee_diag.eed_scrsize) {
				case EED_SCR_1152X900:
d308 1
a308 1
				case EED_SCR_1024X1024:
d313 1
a313 1
				case EED_SCR_1600X1280:
d318 1
a318 1
				case EED_SCR_1440X1440:
d357 1
d361 3
a364 1
static void fb_bell __P((int));
d379 1
d420 2
a421 2
			rc->rc_maxcol = eep->ee_diag.eed_colsize;
			rc->rc_maxrow = eep->ee_diag.eed_rowsize;
d446 13
a458 1
#endif
@


1.8
log
@netbsd port, now we merge our changes back in
@
text
@d1 1
d302 2
a303 2
				switch (eep->eeScreenSize) {
				case EE_SCR_1152X900:
d308 1
a308 1
				case EE_SCR_1024X1024:
d313 1
a313 1
				case EE_SCR_1600X1280:
d318 1
a318 1
				case EE_SCR_1440X1440:
d416 2
a417 2
			rc->rc_maxcol = eep->eeTtyCols;
			rc->rc_maxrow = eep->eeTtyRows;
@


1.7
log
@fix fb_setsize() to set width/height for P4 frame buffers
now rconsole works on all P4 frame buffers
@
text
@d1 1
a1 1
/*	$NetBSD: fb.c,v 1.11 1995/10/08 01:39:19 pk Exp $ */
d53 1
a53 1
#include <sys/conf.h>
d56 1
d60 1
d62 1
d65 1
d70 1
d80 1
a80 1
fb_attach(fb)
d82 1
d84 53
d139 2
a140 1
		printf("warning: multiple /dev/fb declarers\n");
d142 3
a203 5
	case BUS_PFOUR:
		fb->fb_type.fb_width = def_width;
		fb->fb_type.fb_height = def_height;
		fb->fb_linebytes = (fb->fb_type.fb_width * depth) / 8;
		break;
d207 3
a209 4
#if defined(SUN4M)
		if (cputyp == CPU_SUN4M) {   /* 4m has framebuffer on obio */
		        fb->fb_type.fb_width = getpropint(node, "width",
			    def_width);
d211 1
a211 1
			    def_height);
a215 1
#endif
d224 1
a224 1
		if (cputyp == CPU_SUN4 && (bustype == BUS_VME16 ||
d229 1
a229 1
		if (cputyp==CPU_SUN4) {
d231 32
a262 3
			if (eep != NULL) {
				switch (eep->ee_diag.eed_scrsize) {
				case EED_SCR_1152X900:
d266 2
a267 1
				case EED_SCR_1024X1024:
d271 7
a277 1
				case EED_SCR_1600X1280:
d281 2
a282 1
				case EED_SCR_1440X1440:
d286 2
a287 1
				case EED_SCR_640X480:
d291 18
a308 2
				case EED_SCR_1280X1024:
					fb->fb_type.fb_width = 1280;
d311 11
d334 1
a334 1
		if (cputyp==CPU_SUN4M) {
d339 1
a339 1
donesize:
d342 1
d344 2
a345 2
		fb->fb_type.fb_width = getpropint(node, "width", 1152);
		fb->fb_type.fb_height = getpropint(node, "height", 900);
d349 1
d359 2
a360 1
extern int (*v_putc) __P((int));
d405 1
a405 1
	rc->rc_maxrow = rc->rc_height / rc->rc_font->height; 
d408 1
a408 1
	if (cputyp == CPU_SUN4) {
d415 2
a416 2
			rc->rc_maxcol = eep->ee_diag.eed_colsize;
			rc->rc_maxrow = eep->ee_diag.eed_rowsize;
d420 6
a425 6
#if defined(SUN4C) || defined(SUN4M)
	if (cputyp != CPU_SUN4) {
		rc->rc_maxcol = a2int(getpropstring(optionsnode,
		    "screen-#columns"), 80);
		rc->rc_maxrow = a2int(getpropstring(optionsnode,
		    "screen-#rows"), 34);
a426 1
#endif /* SUN4C || SUN4M */
d431 2
a432 1
	if (cputyp == CPU_SUN4 || romgetcursoraddr(&rc->rc_row, &rc->rc_col))
d439 1
a439 1
	v_putc = (int (*) __P((int)))rcons_cnputc;
d442 63
@


1.6
log
@add a missing \n
@
text
@d142 2
@


1.5
log
@new mapdev/()/mapiodev() calling convention uses "struct rom_reg *" to supply
base plus an offset
new dvma routines
@
text
@d80 1
a80 1
		printf("warning: multiple /dev/fb declarers");
@


1.4
log
@don't panic for multiple /dev/fb declarers
@
text
@d147 11
@


1.3
log
@fb_setsize() on pfour
@
text
@d80 1
a80 1
		panic("multiple /dev/fb declarers");
@


1.2
log
@use new eeprom.h
@
text
@d141 3
d205 1
a205 1
 donesize:
@


1.1
log
@Initial revision
@
text
@d79 2
a80 1
if (devfb) panic("multiple /dev/fb declarers");
d160 2
a161 2
				switch (eep->eeScreenSize) {
				case EE_SCR_1152X900:
d165 1
a165 2

				case EE_SCR_1024X1024:
d169 1
a169 2

				case EE_SCR_1600X1280:
d173 1
a173 2

				case EE_SCR_1440X1440:
d177 8
a184 1

a204 1

a210 1

d275 2
a276 2
			rc->rc_maxcol = eep->eeTtyCols;
			rc->rc_maxrow = eep->eeTtyRows;
d282 4
a285 4
		rc->rc_maxcol =
		    a2int(getpropstring(optionsnode, "screen-#columns"), 80);
		rc->rc_maxrow =
		    a2int(getpropstring(optionsnode, "screen-#rows"), 34);
d292 1
a292 2
	if (cputyp == CPU_SUN4 ||
	    romgetcursoraddr(&rc->rc_row, &rc->rc_col))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

