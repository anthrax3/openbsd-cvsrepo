head	1.29;
access;
symbols
	OPENBSD_6_0:1.28.0.2
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.4
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.19.0.12
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.10
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.8
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.6
	OPENBSD_5_0:1.19.0.4
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.17.0.14
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.16
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.12
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.10
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.8
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.12
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.10
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.8
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.6
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.6
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.15
	UBC:1.13.0.6
	UBC_BASE:1.13
	OPENBSD_3_0:1.13.0.4
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.12.0.8
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.6
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.4
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7;
locks; strict;
comment	@ * @;


1.29
date	2016.09.01.09.23.42;	author tedu;	state dead;
branches;
next	1.28;
commitid	Q2PxaFNhqAe0Wmla;

1.28
date	2016.03.07.00.11.11;	author mmcc;	state Exp;
branches;
next	1.27;
commitid	KnwV49RbphV1t01y;

1.27
date	2015.11.25.11.20.38;	author mpi;	state Exp;
branches;
next	1.26;
commitid	f4dx5ry1aOiKJw33;

1.26
date	2015.11.24.17.11.38;	author mpi;	state Exp;
branches;
next	1.25;
commitid	5gdEnqVoJuTuwdTu;

1.25
date	2015.11.24.13.33.18;	author mpi;	state Exp;
branches;
next	1.24;
commitid	5DvsamK0GblTp8ww;

1.24
date	2015.03.30.20.30.22;	author miod;	state Exp;
branches;
next	1.23;
commitid	f66FukLLgPJs9j5H;

1.23
date	2015.03.29.10.59.47;	author mpi;	state Exp;
branches;
next	1.22;
commitid	5gSSQiWXj4PXfvMR;

1.22
date	2015.03.22.12.45.59;	author miod;	state Exp;
branches;
next	1.21;
commitid	f2d98KGaubE7q4U1;

1.21
date	2014.07.22.10.35.35;	author mpi;	state Exp;
branches;
next	1.20;
commitid	EXpEDqO4x724IPl8;

1.20
date	2013.09.05.20.55.58;	author bluhm;	state Exp;
branches;
next	1.19;

1.19
date	2010.09.05.18.10.10;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.02.20.00.54;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.02.15.54.22;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.43;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.08.18.52.25;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.30.07.17.07;	author jason;	state Exp;
branches
	1.13.6.1;
next	1.12;

1.12
date	99.07.05.22.30.06;	author deraadt;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	99.07.05.21.55.09;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.11.16.06.20.36;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	98.11.11.00.26.00;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	98.11.02.05.50.59;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	98.10.21.04.12.10;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	98.10.19.05.41.20;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	98.08.26.00.57.04;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	98.07.05.09.24.22;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	98.07.05.06.50.00;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	98.07.04.07.07.21;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	98.07.04.01.27.55;	author deraadt;	state Exp;
branches;
next	;

1.12.4.1
date	2001.05.14.21.37.08;	author niklas;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2002.03.06.02.04.46;	author niklas;	state Exp;
branches;
next	1.12.4.3;

1.12.4.3
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.12.4.4;

1.12.4.4
date	2003.06.07.11.14.43;	author ho;	state Exp;
branches;
next	;

1.13.6.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: qec.c,v 1.28 2016/03/07 00:11:11 mmcc Exp $	*/

/*
 * Copyright (c) 1998 Theo de Raadt and Jason L. Wright.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/proc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>

#include <sparc/dev/sbusvar.h>
#include <sparc/dev/dmareg.h>
#include <sparc/dev/qecreg.h>
#include <sparc/dev/qecvar.h>

int	qecprint(void *, const char *);
int	qecmatch(struct device *, void *, void *);
void	qecattach(struct device *, struct device *, void *);
int	qec_fix_range(struct qec_softc *, struct sbus_softc *);
void	qec_translate(struct qec_softc *, struct confargs *);

struct cfattach qec_ca = {
	sizeof(struct qec_softc), qecmatch, qecattach
};

struct cfdriver qec_cd = {
	NULL, "qec", DV_DULL
};

int
qecprint(aux, name)
	void *aux;
	const char *name;
{
	register struct confargs *ca = aux;

	if (name)
		printf("%s at %s", ca->ca_ra.ra_name, name);
	printf(" offset 0x%x", ca->ca_offset);
	return (UNCONF);
}

/*
 * match a QEC device in a slot capable of DMA
 */
int
qecmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
		return (0);

	if (!sbus_testdma((struct sbus_softc *)parent, ca))
		return (0);

	return (1);
}

/*
 * Attach all the sub-devices we can find
 */
void
qecattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	register struct confargs *ca = aux;
	struct qec_softc *sc = (void *)self;
	int node;
	struct confargs oca;
	char *name;
	int sbusburst;

	/*
	 * The first i/o space is the qec global registers, and
	 * the second is a buffer used by the qec channels internally.
	 * (It's not necessary to map the second i/o space, but knowing
	 * its size is necessary).
	 */
	sc->sc_regs = mapiodev(&ca->ca_ra.ra_reg[0], 0,
	    sizeof(struct qecregs));
	sc->sc_bufsiz = ca->ca_ra.ra_reg[1].rr_len;
	sc->sc_paddr = ca->ca_ra.ra_reg[0].rr_paddr;

	/*
	 * On qec+qe, the qec has the interrupt priority, but we
	 * need to pass that down so that the qe's can handle them.
	 */
	if (ca->ca_ra.ra_nintr == 1)
		sc->sc_pri = ca->ca_ra.ra_intr[0].int_pri;

	node = sc->sc_node = ca->ca_ra.ra_node;

	if (qec_fix_range(sc, (struct sbus_softc *)parent) != 0)
		return;

	/*
	 * Get transfer burst size from PROM
	 */
	sbusburst = ((struct sbus_softc *)parent)->sc_burst;
	if (sbusburst == 0)
		sbusburst = SBUS_BURST_32 - 1; /* 1->16 */

	sc->sc_nchannels = getpropint(ca->ca_ra.ra_node, "#channels", -1);
	if (sc->sc_nchannels == -1) {
		printf(": no channels\n");
		return;
	}
	else if (sc->sc_nchannels < 1 || sc->sc_nchannels > 4) {
		printf(": invalid number of channels: %d\n", sc->sc_nchannels);
		return;
	}

	sc->sc_burst = getpropint(ca->ca_ra.ra_node, "burst-sizes", -1);
	if (sc->sc_burst == -1)
		/* take SBus burst sizes */
		sc->sc_burst = sbusburst;

	/* Clamp at parent's burst sizes */
	sc->sc_burst &= sbusburst;

	printf(": %dK memory %d channel%s",
	    sc->sc_bufsiz / 1024, sc->sc_nchannels,
	    (sc->sc_nchannels == 1) ? "" : "s");

	node = sc->sc_node = ca->ca_ra.ra_node;

	/* Propagate bootpath */
	if (ca->ca_ra.ra_bp != NULL)
		oca.ca_ra.ra_bp = ca->ca_ra.ra_bp + 1;
	else
		oca.ca_ra.ra_bp = NULL;

	printf("\n");

	qec_reset(sc);

	/* search through children */
	for (node = firstchild(node); node; node = nextsibling(node)) {
		name = getpropstring(node, "name");
		if (!romprop(&oca.ca_ra, name, node))
			continue;

		qec_translate(sc, &oca);
		oca.ca_bustype = BUS_SBUS;
		oca.ca_dmat = ca->ca_dmat;
		config_found(&sc->sc_dev, (void *)&oca, qecprint);
	}
}

int
qec_fix_range(sc, sbp)
	struct qec_softc *sc;
	struct sbus_softc *sbp;
{
	int rlen, i, j;

	rlen = getproplen(sc->sc_node, "ranges");
	sc->sc_range = malloc(rlen, M_DEVBUF, M_NOWAIT);
	if (sc->sc_range == NULL) {
		printf(": PROM ranges too large: %d\n", rlen);
		return EINVAL;
	}
	sc->sc_nrange = rlen / sizeof(struct rom_range);
	(void)getprop(sc->sc_node, "ranges", sc->sc_range, rlen);

	if (sbp->sc_nrange == 0) {
		/*
		 * Old-style SBus configuration: we need to compute the
		 * physical address of the board's base, in order to be
		 * able to compute proper physical addresses in
		 * qec_translate() below.
		 */
		struct rom_reg rr[RA_MAXREG];
		int reglen;

		reglen = getprop(sc->sc_node, "reg", rr, sizeof rr);
		/* shouldn't happen */
		if (reglen <= 0 || reglen % sizeof(struct rom_reg) != 0) {
			printf(": unexpected \"reg\" property layout\n");
			return EINVAL;
		}
		for (i = 0; i < sc->sc_nrange; i++) {
			sc->sc_range[i].poffset +=
			    sc->sc_paddr - rr[0].rr_paddr;
		}
	} else {
		for (i = 0; i < sc->sc_nrange; i++) {
			for (j = 0; j < sbp->sc_nrange; j++) {
				if (sc->sc_range[i].pspace ==
				    sbp->sc_range[j].cspace) {
					sc->sc_range[i].poffset +=
					    sbp->sc_range[j].poffset;
					sc->sc_range[i].pspace =
					    sbp->sc_range[j].pspace;
					break;
				}
			}
		}
	}

	return 0;
}

/*
 * Translate the register addresses of our children 
 */
void
qec_translate(sc, ca)
	struct qec_softc *sc;
	struct confargs *ca;
{
	register int i;

	ca->ca_slot = ca->ca_ra.ra_iospace;
	ca->ca_offset = sc->sc_range[ca->ca_slot].poffset - (long)sc->sc_paddr;

	/* Translate into parent address spaces */
	for (i = 0; i < ca->ca_ra.ra_nreg; i++) {
		int j, cspace = ca->ca_ra.ra_reg[i].rr_iospace;

		for (j = 0; j < sc->sc_nrange; j++) {
			if (sc->sc_range[j].cspace == cspace) {
				ca->ca_ra.ra_reg[i].rr_paddr +=
					sc->sc_range[j].poffset;
				ca->ca_ra.ra_reg[i].rr_iospace =
					sc->sc_range[j].pspace;
				break;
			}
		}
	}
}

/*
 * Reset the QEC and initialize its global registers.
 */
void
qec_reset(sc)
	struct qec_softc *sc;
{
	struct qecregs *qr = sc->sc_regs;
	int i = 200;

	qr->ctrl = QEC_CTRL_RESET;
	while (--i) {
		if ((qr->ctrl & QEC_CTRL_RESET) == 0)
			break;
		DELAY(20);
	}
	if (i == 0) {
		printf("%s: reset failed.\n", sc->sc_dev.dv_xname);
		return;
	}

	qr->msize = sc->sc_bufsiz / sc->sc_nchannels;
	sc->sc_msize = qr->msize;

	qr->rsize = sc->sc_bufsiz / (sc->sc_nchannels * 2);
	sc->sc_rsize = qr->rsize;

	qr->tsize = sc->sc_bufsiz / (sc->sc_nchannels * 2);

	qr->psize = QEC_PSIZE_2048;

        if (sc->sc_burst & SBUS_BURST_64)
		i = QEC_CTRL_B64;
	else if (sc->sc_burst & SBUS_BURST_32)
		i = QEC_CTRL_B32;
	else
		i = QEC_CTRL_B16;

	qr->ctrl = (qr->ctrl & QEC_CTRL_MODEMASK) | i;
}

/*
 * Routine to copy from mbuf chain to transmit buffer in
 * network buffer memory.
 */
int
qec_put(buf, m0)
	u_int8_t *buf;
	struct mbuf *m0;
{
	struct mbuf *m;
	int len, tlen = 0;

	for (m = m0; m != NULL; m = m->m_next) {
		len = m->m_len;
		bcopy(mtod(m, caddr_t), buf, len);
		buf += len;
		tlen += len;
	}
	m_freem(m0);
	return (tlen);
}

/*
 * Pull data off an interface.
 * Len is the length of data, with local net header stripped.
 * We copy the data into mbufs.  When full cluster sized units are present,
 * we copy into clusters.
 */
struct mbuf *
qec_get(buf, totlen)
	u_int8_t *buf;
	int totlen;
{
	struct mbuf *m, *top, **mp;
	int len, pad;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (NULL);
	m->m_pkthdr.len = totlen;
	pad = ALIGN(sizeof(struct ether_header)) - sizeof(struct ether_header);
	len = MHLEN;
	if (totlen >= MINCLSIZE) {
		MCLGET(m, M_DONTWAIT);
		if (m->m_flags & M_EXT)
			len = MCLBYTES;
	}
	m->m_data += pad;
	len -= pad;
	top = NULL;
	mp = &top;

	while (totlen > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == NULL) {
				m_freem(top);
				return NULL;
			}
			len = MLEN;
		}
		if (top && totlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if (m->m_flags & M_EXT)
				len = MCLBYTES;
		}
		m->m_len = len = min(totlen, len);
		bcopy(buf, mtod(m, caddr_t), len);
		buf += len;
		totlen -= len;
		*mp = m;
		mp = &m->m_next;
	}

	return (top);
}
@


1.28
log
@remove needless malloc cast
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.27 2015/11/25 11:20:38 mpi Exp $	*/
@


1.27
log
@Network drivers should not include <net/route.h> or <net/netisr.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.26 2015/11/24 17:11:38 mpi Exp $	*/
d203 1
a203 2
	sc->sc_range =
		(struct rom_range *)malloc(rlen, M_DEVBUF, M_NOWAIT);
@


1.26
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.25 2015/11/24 13:33:18 mpi Exp $	*/
a41 1
#include <net/netisr.h>
@


1.25
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.24 2015/03/30 20:30:22 miod Exp $	*/
a41 1
#include <net/if_dl.h>
@


1.24
log
@Add a bus_dma_tag_t for DVMA usage, suitable for use for devices not sitting
behind a sun4m iommu.

Move the existing dvma routines from vm_machdep.c to this new dvma.c; this
allows for a few declarations to be removed from public headers.

Extend the device attachment arguments (struct confargs) to pass a
bus_dma_tag_t. mainbus receives the dvma bus_dma_tag_t, and devices pass the
tag unchanged to their children, except for iommu(4) which replaces it with
its own.

Change the few sun4m-only drivers to pick the bus_dma_tag_t from confargs
rather than assume iommu; this allows qlw(4) to attach and work on sun4c.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.23 2015/03/29 10:59:47 mpi Exp $	*/
a42 1
#include <net/if_types.h>
@


1.23
log
@Convert qe(4) et be(4) to if_input().

Tested by miod@@, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.22 2015/03/22 12:45:59 miod Exp $	*/
d50 2
a51 2
#include <sparc/autoconf.h>
#include <sparc/cpu.h>
d193 2
a194 1
		(void) config_found(&sc->sc_dev, (void *)&oca, qecprint);
@


1.22
log
@Do the right thing in qec_fix_range() when connected to an sbus(4) without
`ranges' property, i.e. sun4c, so that child devices can attach correctly.
This makes be(4) work on sun4c.
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.21 2014/07/22 10:35:35 mpi Exp $	*/
d351 1
a351 2
qec_get(ifp, buf, totlen)
	struct ifnet *ifp;
a360 1
	m->m_pkthdr.rcvif = ifp;
@


1.21
log
@<netinet/in_systm.h> is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.20 2013/09/05 20:55:58 bluhm Exp $	*/
d61 1
a61 1
void	qec_fix_range(struct qec_softc *, struct sbus_softc *);
d141 2
a142 1
	qec_fix_range(sc, (struct sbus_softc *)parent);
d197 1
a197 1
void
d208 2
a209 3
		printf("%s: PROM ranges too large: %d\n",
				sc->sc_dev.dv_xname, rlen);
		return;
d214 31
a244 8
	for (i = 0; i < sc->sc_nrange; i++) {
		for (j = 0; j < sbp->sc_nrange; j++) {
			if (sc->sc_range[i].pspace == sbp->sc_range[j].cspace) {
				sc->sc_range[i].poffset +=
				    sbp->sc_range[j].poffset;
				sc->sc_range[i].pspace =
				    sbp->sc_range[j].pspace;
				break;
d248 2
@


1.20
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Remove these include lines from mvme68k, mvme88k,
sparc drivers.
test and OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.19 2010/09/05 18:10:10 kettenis Exp $	*/
a46 1
#ifdef INET
a47 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a48 1
#endif
@


1.19
log
@Remove bogus LHS casts.  makes gcc4 happy.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.18 2010/06/26 23:24:44 guenther Exp $	*/
a49 1
#include <netinet/in_var.h>
@


1.18
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.17 2006/06/02 20:00:54 miod Exp $	*/
d251 1
a251 1
				(int)ca->ca_ra.ra_reg[i].rr_paddr +=
d253 1
a253 1
				(int)ca->ca_ra.ra_reg[i].rr_iospace =
@


1.17
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.16 2003/06/02 15:54:22 deraadt Exp $	*/
a37 1
#include <sys/user.h>
@


1.16
log
@some license cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.15 2002/03/14 01:26:43 millert Exp $	*/
a178 3

	if (ca->ca_bustype == BUS_SBUS)
		sbus_establish(&sc->sc_sd, &sc->sc_dev);
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.14 2002/02/08 18:52:25 jason Exp $	*/
a14 2
 * 3. The name of the authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.14
log
@simplify qec_put a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.13 2001/01/30 07:17:07 jason Exp $	*/
d66 5
a70 5
int	qecprint	__P((void *, const char *));
int	qecmatch	__P((struct device *, void *, void *));
void	qecattach	__P((struct device *, struct device *, void *));
void	qec_fix_range	__P((struct qec_softc *, struct sbus_softc *));
void	qec_translate	__P((struct qec_softc *, struct confargs *));
@


1.13
log
@- take advantage of the fact that qe's and be's require qec's and move
some common functionality into qec's driver (rx and tx frame fetching)
- avoid modulus operations
- some style
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.12 1999/07/05 22:30:06 deraadt Exp $	*/
d313 1
a313 1
qec_put(buf, m)
d315 2
a317 2
{
	struct mbuf *n;
d320 1
a320 1
	for (; m != NULL; m = n) {
a321 4
		if (len == 0) {
			MFREE(m, n);
			continue;
		}
a324 1
		MFREE(m, n);
d326 2
a327 1
	return tlen;
@


1.13.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.13 2001/01/30 07:17:07 jason Exp $	*/
d66 5
a70 5
int	qecprint(void *, const char *);
int	qecmatch(struct device *, void *, void *);
void	qecattach(struct device *, struct device *, void *);
void	qec_fix_range(struct qec_softc *, struct sbus_softc *);
void	qec_translate(struct qec_softc *, struct confargs *);
d313 1
a313 1
qec_put(buf, m0)
d315 1
a315 1
	struct mbuf *m0;
d317 1
a317 1
	struct mbuf *m;
d320 1
a320 1
	for (m = m0; m != NULL; m = m->m_next) {
d322 4
d329 1
d331 1
a331 2
	m_freem(m0);
	return (tlen);
@


1.12
log
@but make it work for multiple cards... i think
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.11 1999/07/05 21:55:09 deraadt Exp $	*/
d41 16
d306 83
@


1.12.4.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.13 2001/01/30 07:17:07 jason Exp $	*/
a40 16
#include <sys/mbuf.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/netisr.h>
#include <net/if_media.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>
#endif
a289 83
}

/*
 * Routine to copy from mbuf chain to transmit buffer in
 * network buffer memory.
 */
int
qec_put(buf, m)
	u_int8_t *buf;
	struct mbuf *m;
{
	struct mbuf *n;
	int len, tlen = 0;

	for (; m != NULL; m = n) {
		len = m->m_len;
		if (len == 0) {
			MFREE(m, n);
			continue;
		}
		bcopy(mtod(m, caddr_t), buf, len);
		buf += len;
		tlen += len;
		MFREE(m, n);
	}
	return tlen;
}

/*
 * Pull data off an interface.
 * Len is the length of data, with local net header stripped.
 * We copy the data into mbufs.  When full cluster sized units are present,
 * we copy into clusters.
 */
struct mbuf *
qec_get(ifp, buf, totlen)
	struct ifnet *ifp;
	u_int8_t *buf;
	int totlen;
{
	struct mbuf *m, *top, **mp;
	int len, pad;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (NULL);
	m->m_pkthdr.rcvif = ifp;
	m->m_pkthdr.len = totlen;
	pad = ALIGN(sizeof(struct ether_header)) - sizeof(struct ether_header);
	len = MHLEN;
	if (totlen >= MINCLSIZE) {
		MCLGET(m, M_DONTWAIT);
		if (m->m_flags & M_EXT)
			len = MCLBYTES;
	}
	m->m_data += pad;
	len -= pad;
	top = NULL;
	mp = &top;

	while (totlen > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == NULL) {
				m_freem(top);
				return NULL;
			}
			len = MLEN;
		}
		if (top && totlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if (m->m_flags & M_EXT)
				len = MCLBYTES;
		}
		m->m_len = len = min(totlen, len);
		bcopy(buf, mtod(m, caddr_t), len);
		buf += len;
		totlen -= len;
		*mp = m;
		mp = &m->m_next;
	}

	return (top);
@


1.12.4.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d313 1
a313 1
qec_put(buf, m0)
d315 1
a315 1
	struct mbuf *m0;
d317 1
a317 1
	struct mbuf *m;
d320 1
a320 1
	for (m = m0; m != NULL; m = m->m_next) {
d322 4
d329 1
d331 1
a331 2
	m_freem(m0);
	return (tlen);
@


1.12.4.3
log
@Merge in -current from about a week ago
@
text
@d66 5
a70 5
int	qecprint(void *, const char *);
int	qecmatch(struct device *, void *, void *);
void	qecattach(struct device *, struct device *, void *);
void	qec_fix_range(struct qec_softc *, struct sbus_softc *);
void	qec_translate(struct qec_softc *, struct confargs *);
@


1.12.4.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.12.4.3 2002/03/28 10:57:10 niklas Exp $	*/
d15 2
@


1.11
log
@calculate ca_offset correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.10 1998/11/16 06:20:36 jason Exp $	*/
a229 1
	static int dev = 0;
d233 1
a233 1
	ca->ca_offset = sc->sc_range[dev++].poffset - (long)sc->sc_paddr;
@


1.10
log
@save a bit of space; theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.9 1998/11/11 00:26:00 jason Exp $	*/
d122 1
d230 1
d234 1
a234 1
	ca->ca_offset = (int)ca->ca_ra.ra_paddr;
@


1.9
log
@Detect cards that require dma that are in non-dma slots and don't allow
them to be attach'd.
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.8 1998/11/02 05:50:59 jason Exp $	*/
d159 1
a159 1
	printf(": %dK memory %d %s",
d161 1
a161 1
	    (sc->sc_nchannels == 1) ? "channel" : "channels");
@


1.8
log
@First step at unifying qe & be drivers:
o qe & be drivers now only access qec globals directly at interrupt time
o more initialization done in qec_reset
o qe & be drivers handle the qec internal buffer identically
o nuked unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.7 1998/10/21 04:12:10 jason Exp $	*/
d51 1
d57 1
a57 1
	sizeof(struct qec_softc), matchbyname, qecattach
d75 21
@


1.7
log
@The qec global reset should only be allowed to happen once per qec card, not
once per channel init.
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.6 1998/10/19 05:41:20 jason Exp $	*/
d92 4
a95 2
	 * The first IO space is the QEC registers, the second IO
	 * space is the QEC (64K we hope) ram buffer
a98 2
	sc->sc_buffer = mapiodev(&ca->ca_ra.ra_reg[1], 0,
	    ca->ca_ra.ra_reg[1].rr_len);
d229 1
a229 1
 * Reset the QEC
d235 1
d238 1
a238 1
	sc->sc_regs->ctrl = QEC_CTRL_RESET;
d240 1
a240 1
		if ((sc->sc_regs->ctrl & QEC_CTRL_RESET) == 0)
d248 19
@


1.6
log
@Support for the qec+qe (SBus QuadEthernet board)
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.5 1998/08/26 00:57:04 jason Exp $	*/
d153 2
@


1.5
log
@o Fix up address ranges
o Added qec_translate for translating addresses of prom children
o Added qec_reset to do a generic reset of the card
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.4 1998/07/05 09:24:22 deraadt Exp $	*/
d101 7
d119 10
d137 3
a139 1
	printf(": %dK memory", sc->sc_bufsiz / 1024);
@


1.4
log
@do not print fake slot numbers
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.3 1998/07/05 06:50:00 deraadt Exp $	*/
d4 2
a5 1
 * Copyright (c) 1998 Theo de Raadt.  All rights reserved.
d15 1
a15 1
 * 3. The name of the author may not be used to endorse or promote products
d18 1
a18 1
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
d21 1
a21 1
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
d50 4
a53 2
int	qecprint __P((void *, const char *));
void	qecattach __P((struct device *, struct device *, void *));
d101 4
d141 1
a141 1
		sbus_translate(parent, &oca);
d144 81
@


1.3
log
@map qec registers properly
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.2 1998/07/04 07:07:21 deraadt Exp $	*/
d69 1
a69 1
	printf(" slot 0x%x offset 0x%x", ca->ca_slot, ca->ca_offset);
@


1.2
log
@add qec register info
@
text
@d1 1
a1 1
/*	$OpenBSD: qec.c,v 1.1 1998/07/04 01:27:55 deraadt Exp $	*/
a80 1
#if defined(SUN4C) || defined(SUN4M)
a87 4
	if (ca->ca_ra.ra_vaddr == NULL || ca->ca_ra.ra_nvaddrs == 0)
		ca->ca_ra.ra_vaddr =
		    mapiodev(ca->ca_ra.ra_reg, 0, ca->ca_ra.ra_len);

d89 2
a90 3
	 * This device's "register space" is just a buffer where the
	 * Lance ring-buffers can be stored. Note the buffer's location
	 * and size, so the sub-drivers can pick them up.
d92 5
a96 2
	sc->sc_buffer = (caddr_t)ca->ca_ra.ra_vaddr;
	sc->sc_bufsiz = ca->ca_ra.ra_len;
d113 1
a113 1
	printf(": %dK memory\n", sc->sc_bufsiz / 1024);
d126 2
a137 1
#endif /* SUN4C || SUN4M */
@


1.1
log
@add support for qec; same basic thing as lebuffer
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
@

