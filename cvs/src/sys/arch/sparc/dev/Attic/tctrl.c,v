head	1.22;
access;
symbols
	OPENBSD_6_0:1.21.0.22
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.18
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.20
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.12
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.16
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.14
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.10
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.8
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.6
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.4
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.20.0.10
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.8
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.4
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.6
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.18.0.6
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.16.0.6
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.4
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.4
	UBC:1.2.0.14
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.12
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.10
	OPENBSD_2_8:1.2.0.8
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.6
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.4
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.22
date	2016.09.01.09.23.42;	author tedu;	state dead;
branches;
next	1.21;
commitid	Q2PxaFNhqAe0Wmla;

1.21
date	2011.07.02.22.20.07;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2009.02.26.17.19.47;	author oga;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.26.05.42.13;	author ray;	state Exp;
branches;
next	1.18;

1.18
date	2006.10.27.17.52.38;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.09.17.22.26.37;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.19.09.36.04;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.17.12.16.51;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.17.12.16.16;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.08.12.50.21;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.07.08.12.43.48;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.11.01.49.50;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.29.16.26.44;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.29.12.55.55;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.29.11.36.40;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.29.07.35.11;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.10.09.05.52;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.16.18.40.32;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.30.01.12.29;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.43;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.09.07.12.36.20;	author jason;	state Exp;
branches
	1.2.4.1
	1.2.14.1;
next	1.1;

1.1
date	99.09.07.02.58.50;	author jason;	state Exp;
branches;
next	;

1.2.4.1
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2003.06.07.11.14.43;	author ho;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2004.06.05.23.10.58;	author niklas;	state Exp;
branches;
next	;

1.2.14.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	1.2.14.2;

1.2.14.2
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: tctrl.c,v 1.21 2011/07/02 22:20:07 nicm Exp $	*/
/*	$NetBSD: tctrl.c,v 1.2 1999/08/11 00:46:06 matt Exp $	*/

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Matt Thomas.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * The /dev/apm{,ctl} interface code falls under the following license
 * terms:
 *
 * Copyright (c) 1998-2001 Michael Shalayeff. All rights reserved.
 * Copyright (c) 1995 John T. Kohl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/event.h>
#include <sys/fcntl.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/timeout.h>

#include <machine/apmvar.h>
#include <machine/autoconf.h>
#include <machine/conf.h>
#include <machine/cpu.h>

#include <sparc/sparc/auxioreg.h>

#include <sparc/dev/ts102reg.h>
#include <sparc/dev/tctrlvar.h>

/*
 * Flags to control kernel display
 *	SCFLAG_NOPRINT:		do not output APM power messages due to
 *				a power change event.
 *
 *	SCFLAG_PCTPRINT:	do not output APM power messages due to
 *				to a power change event unless the battery
 *				percentage changes.
 */

#define SCFLAG_NOPRINT	0x0008000
#define SCFLAG_PCTPRINT	0x0004000
#define SCFLAG_PRINT	(SCFLAG_NOPRINT|SCFLAG_PCTPRINT)

const char *tctrl_ext_status[16] = {
	"main power available",
	"internal battery attached",
	"external battery attached",
	"external VGA attached",
	"external keyboard attached",
	"external mouse attached",
	"lid down",
	"internal battery charging",
	"external battery charging",
	"internal battery discharging",
	"external battery discharging",
};

/* Request "packet" */
struct tctrl_req {
	u_int8_t	cmdbuf[16];
	u_int		cmdlen;
	u_int8_t	rspbuf[16];
	u_int		rsplen;
};

struct tctrl_softc {
	struct device sc_dev;
	struct uctrl_regs *sc_regs;
	struct intrhand sc_ih;
	u_int	sc_ext_status;
	u_int	sc_flags;
#define	TCTRL_SEND_REQUEST		0x0001
#define	TCTRL_ISXT			0x0002
	u_int	sc_wantdata;
	enum { TCTRL_IDLE, TCTRL_ARGS,
		TCTRL_ACK, TCTRL_DATA } sc_state;
	u_int8_t sc_cmdbuf[16];
	u_int8_t sc_rspbuf[16];
	u_int8_t sc_tft_on;
	u_int8_t sc_pcmcia_on;
	u_int8_t sc_brightness;
	u_int8_t sc_op;
	u_int	sc_cmdoff;
	u_int	sc_cmdlen;
	u_int	sc_rspoff;
	u_int	sc_rsplen;
	u_int	sc_rspack;
	u_int	sc_bellfreq;
	u_int	sc_bellvol;

	struct timeout sc_tmo;

	/* /dev/apm{,ctl} fields */
	struct klist sc_note;
	u_int	sc_apmflags;

	/* external video control callback */
	void (*sc_evcb)(void *, int);
	void *sc_evdata;
};

int	tctrl_match(struct device *, void *, void *);
void	tctrl_attach(struct device *, struct device *, void *);

void	tctrl_bell(struct tctrl_softc *, int, int);
void	tctrl_brightness(struct tctrl_softc *, int, int);
void	tctrl_init_lcd(struct tctrl_softc *);
int	tctrl_intr(void *);
void	tctrl_lcd(struct tctrl_softc *, int, int);
u_int8_t tctrl_read_data(struct tctrl_softc *);
void	tctrl_read_event_status(void *);
void	tctrl_read_ext_status(struct tctrl_softc *);
int	tctrl_request(struct tctrl_softc *, struct tctrl_req *);
void	tctrl_tft(struct tctrl_softc *);
void	tctrl_write_data(struct tctrl_softc *, u_int8_t);

int	apm_record_event(struct tctrl_softc *, u_int);

struct cfattach tctrl_ca = {
	sizeof(struct tctrl_softc), tctrl_match, tctrl_attach
};

struct cfdriver tctrl_cd = {
	NULL, "tctrl", DV_DULL
};

int
tctrl_match(parent, vcf, aux)
	struct device *parent;
	void *vcf;
	void *aux;
{
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

	/*
	 * Tadpole 3GX/3GS uses "uctrl" for the Tadpole Microcontroller
	 * (which is really part of the TS102 PCMCIA controller, but there
	 * exists a distinct OpenProm node for the microcontroller interface).
	 */
	if (strcmp("uctrl", ra->ra_name))
		return (0);

	return (1);
}

void
tctrl_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct confargs *ca = aux;
	struct tctrl_softc *sc = (void *)self;
	u_int i, v;
	int pri;

	if (ca->ca_ra.ra_nintr != 1) {
		printf(": expected 1 interrupt, got %d\n",
		    ca->ca_ra.ra_nintr);
		return;
	}
	pri = ca->ca_ra.ra_intr[0].int_pri;

	if (ca->ca_ra.ra_nreg != 1) {
		printf(": expected 1 register, got %d\n",
		    ca->ca_ra.ra_nreg);
		return;
	}
	sc->sc_regs = mapiodev(&(ca->ca_ra.ra_reg[0]), 0,
	    ca->ca_ra.ra_reg[0].rr_len);

	printf(" pri %d\n", pri);

	/*
	 * We need to check if we are running on the SPARCbook S3XT, which
	 * needs extra work to control the TFT power.
	 */
	sc->sc_flags = 0;
	if (strcmp(mainbus_model, "Tadpole_S3000XT") == 0)
		sc->sc_flags |= TCTRL_ISXT;
	sc->sc_tft_on = 1;

	/* clear any pending data */
	for (i = 0; i < 10000; i++) {
		if ((TS102_UCTRL_STS_RXNE_STA & sc->sc_regs->stat) == 0)
			break;
		v = sc->sc_regs->data;
		sc->sc_regs->stat = TS102_UCTRL_STS_RXNE_STA;
	}

	sc->sc_ih.ih_fun = tctrl_intr;
	sc->sc_ih.ih_arg = sc;
	intr_establish(pri, &sc->sc_ih, -1, self->dv_xname);

	timeout_set(&sc->sc_tmo, tctrl_read_event_status, sc);

	/* See what the external status is */
	tctrl_read_ext_status(sc);
	if (sc->sc_ext_status != 0) {
		const char *sep;
		u_int len;

		v = sc->sc_ext_status;
		len = 0;
		sep = "";
		for (i = 0; v != 0; i++, v >>= 1) {
			if ((v & 1) == 0)
				continue;
			/* wrap to next line if necessary */
			if (len != 0 && len + strlen(sep) +
			    strlen(tctrl_ext_status[i]) > 80) {
				printf("\n");
				len = 0;
			}
			if (len == 0) {
				printf("%s: ", sc->sc_dev.dv_xname);
				len = 2 + strlen(sc->sc_dev.dv_xname);
				sep = "";
			}
			printf("%s%s", sep, tctrl_ext_status[i]);
			len += strlen(sep) + strlen(tctrl_ext_status[i]);
			sep = ", ";
		}
		if (len != 0)
			printf("\n");
	}

	/* Get a few status values */
	tctrl_bell(sc, 0xff, 0);
	tctrl_brightness(sc, 0xff, 0);

	/* Blank video if lid is closed during boot */
	if (sc->sc_ext_status & TS102_EXT_STATUS_LID_DOWN)
		tctrl_tft(sc);

	sc->sc_regs->intr = TS102_UCTRL_INT_RXNE_REQ|TS102_UCTRL_INT_RXNE_MSK;

	sc->sc_wantdata = 0;

	/* Initialize the LCD icons */
	tctrl_init_lcd(sc);
}

int
tctrl_intr(void *arg)
{
	struct tctrl_softc *sc = arg;
	unsigned int v, d;
	int progress = 0;

again:
	/* find out the cause(s) of the interrupt */
	v = sc->sc_regs->stat & TS102_UCTRL_STS_MASK;

	/* clear the cause(s) of the interrupt */
	sc->sc_regs->stat = v;

	v &= ~(TS102_UCTRL_STS_RXO_STA|TS102_UCTRL_STS_TXE_STA);
	if (sc->sc_cmdoff >= sc->sc_cmdlen) {
		v &= ~TS102_UCTRL_STS_TXNF_STA;
		if (sc->sc_regs->intr & TS102_UCTRL_INT_TXNF_REQ) {
			sc->sc_regs->intr = 0;
			progress = 1;
		}
	}
	if (v == 0 && ((sc->sc_flags & TCTRL_SEND_REQUEST) == 0 ||
	    sc->sc_state != TCTRL_IDLE)) {
		return (progress);
	}

	progress = 1;
	if (v & TS102_UCTRL_STS_RXNE_STA) {
		d = tctrl_read_data(sc);
		switch (sc->sc_state) {
		case TCTRL_IDLE:
			if (d == TS102_UCTRL_INTR) {
				/* external event */
				timeout_add(&sc->sc_tmo, 1);
			} else {
				printf("%s: (op=0x%02x): unexpected data (0x%02x)\n",
					sc->sc_dev.dv_xname, sc->sc_op, d);
			}
			goto again;
		case TCTRL_ACK:
#ifdef TCTRLDEBUG
			printf(" ack=0x%02x", d);
#endif
			switch (d) {
			case TS102_UCTRL_ACK:
				sc->sc_rspack = 1;
				sc->sc_rsplen--;
				sc->sc_rspoff = 0;
				sc->sc_state =
				    sc->sc_rsplen ? TCTRL_DATA : TCTRL_IDLE;
				sc->sc_wantdata = sc->sc_rsplen ? 1 : 0;
#ifdef TCTRLDEBUG
				if (sc->sc_rsplen > 0) {
					printf(" [data(%u)]", sc->sc_rsplen);
				} else {
					printf(" [idle]\n");
				}
#endif
				goto again;
			default:
				printf("%s: (op=0x%02x): unexpected return value (0x%02x)\n",
					sc->sc_dev.dv_xname, sc->sc_op, d);
				/* FALLTHROUGH */
			case TS102_UCTRL_NACK:
				printf("%s: command %x failed\n",
				    sc->sc_dev.dv_xname, sc->sc_op);
				sc->sc_rspack = 0;
				sc->sc_wantdata = 0;
				sc->sc_state = TCTRL_IDLE;
				break;
			}
			break;
		case TCTRL_DATA:
			sc->sc_rspbuf[sc->sc_rspoff++] = d;
#ifdef TCTRLDEBUG
			printf(" [%d]=0x%02x", sc->sc_rspoff-1, d);
#endif
			if (sc->sc_rspoff == sc->sc_rsplen) {
#ifdef TCTRLDEBUG
				printf(" [idle]\n");
#endif
				sc->sc_state = TCTRL_IDLE;
				sc->sc_wantdata = 0;
			}
			goto again;
		default:
			printf("%s: (op=0x%02x): unexpected data (0x%02x) in state %d\n",
			       sc->sc_dev.dv_xname, sc->sc_op, d, sc->sc_state);
			goto again;
		}
	}
	if ((sc->sc_state == TCTRL_IDLE && sc->sc_wantdata == 0) ||
	    (sc->sc_flags & TCTRL_SEND_REQUEST)) {
		if (sc->sc_flags & TCTRL_SEND_REQUEST) {
			sc->sc_flags &= ~TCTRL_SEND_REQUEST;
			sc->sc_wantdata = 1;
		}
		if (sc->sc_cmdlen > 0) {
			sc->sc_regs->intr =
			    sc->sc_regs->intr | TS102_UCTRL_INT_TXNF_MSK
				|TS102_UCTRL_INT_TXNF_REQ;
			v = sc->sc_regs->stat;
		}
	}
	if ((sc->sc_cmdoff < sc->sc_cmdlen) && (v & TS102_UCTRL_STS_TXNF_STA)) {
		tctrl_write_data(sc, sc->sc_cmdbuf[sc->sc_cmdoff++]);
#ifdef TCTRLDEBUG
		if (sc->sc_cmdoff == 1) {
			printf("%s: op=0x%02x(l=%u)", sc->sc_dev.dv_xname,
				sc->sc_cmdbuf[0], sc->sc_rsplen);
		} else {
			printf(" [%d]=0x%02x", sc->sc_cmdoff-1,
				sc->sc_cmdbuf[sc->sc_cmdoff-1]);
		}
#endif
		if (sc->sc_cmdoff == sc->sc_cmdlen) {
			sc->sc_state = sc->sc_rsplen ? TCTRL_ACK : TCTRL_IDLE;
#ifdef TCTRLDEBUG
			printf(" %s", sc->sc_rsplen ? "[ack]" : "[idle]\n");
#endif
			if (sc->sc_cmdoff == 1) {
				sc->sc_op = sc->sc_cmdbuf[0];
			}
			sc->sc_regs->intr =
			    sc->sc_regs->intr & (~TS102_UCTRL_INT_TXNF_MSK
				   |TS102_UCTRL_INT_TXNF_REQ);
		} else if (sc->sc_state == TCTRL_IDLE) {
			sc->sc_op = sc->sc_cmdbuf[0];
			sc->sc_state = TCTRL_ARGS;
#ifdef TCTRLDEBUG
			printf(" [args]");
#endif
		}
	}
	goto again;
}

/*
 * The Tadpole microcontroller is not preprogrammed with icon
 * representations.  The machine boots with the DC-IN light as
 * a blank (all 0x00) and the other lights, as 4 rows of horizontal
 * bars.  The below code initializes the few icons the system will use
 * to sane values.
 *
 * Programming the icons is simple.  It is a 5x8 matrix, with each row a
 * bitfield in the order 0x10 0x08 0x04 0x02 0x01.
 */

static void tctrl_set_glyph(struct tctrl_softc *, u_int, const u_int8_t *);

static const u_int8_t
    tctrl_glyph_dc[] = { 0x00, 0x00, 0x1f, 0x00, 0x15, 0x00, 0x00, 0x00 },
#if 0
    tctrl_glyph_bs[] = { 0x00, 0x10, 0x08, 0x04, 0x02, 0x01, 0x00, 0x00 },
    tctrl_glyph_w1[] = { 0x0c, 0x16, 0x10, 0x15, 0x10, 0x16, 0x0c, 0x00 },
    tctrl_glyph_w2[] = { 0x0c, 0x0d, 0x01, 0x15, 0x01, 0x0d, 0x0c, 0x00 },
    tctrl_glyph_l1[] = { 0x00, 0x04, 0x08, 0x13, 0x08, 0x04, 0x00, 0x00 },
    tctrl_glyph_l2[] = { 0x00, 0x04, 0x02, 0x19, 0x02, 0x04, 0x00, 0x00 },
#endif
    tctrl_glyph_pc[] = { 0x00, 0x0e, 0x0e, 0x1f, 0x1f, 0x1f, 0x1f, 0x00 };

void
tctrl_init_lcd(struct tctrl_softc *sc)
{
	tctrl_set_glyph(sc, TS102_BLK_OFF_DEF_DC_GOOD, tctrl_glyph_dc);
#if 0
	tctrl_set_glyph(sc, TS102_BLK_OFF_DEF_BACKSLASH, tctrl_glyph_bs);
	tctrl_set_glyph(sc, TS102_BLK_OFF_DEF_WAN1, tctrl_glyph_w1);
	tctrl_set_glyph(sc, TS102_BLK_OFF_DEF_WAN2, tctrl_glyph_w2);
	tctrl_set_glyph(sc, TS102_BLK_OFF_DEF_LAN1, tctrl_glyph_l1);
	tctrl_set_glyph(sc, TS102_BLK_OFF_DEF_LAN2, tctrl_glyph_l2);
#endif
	tctrl_set_glyph(sc, TS102_BLK_OFF_DEF_PCMCIA, tctrl_glyph_pc);
}

static void
tctrl_set_glyph(struct tctrl_softc *sc, u_int glyph, const u_int8_t *data)
{
	struct tctrl_req req;

	req.cmdbuf[0] = TS102_OP_BLK_DEF_SPCL_CHAR;
	req.cmdbuf[1] = 8;
	req.cmdbuf[2] = glyph;
	bcopy(data, req.cmdbuf + 3, 8);
	req.cmdlen = 3 + 8;
	req.rsplen = 1;

	tctrl_request(sc, &req);
}

void
tctrl_read_event_status(void *arg)
{
	struct tctrl_softc *sc = (struct tctrl_softc *)arg;
	struct tctrl_req req;
	unsigned int v;

	req.cmdbuf[0] = TS102_OP_RD_EVENT_STATUS;
	req.cmdlen = 1;
	req.rsplen = 3;

	tctrl_request(sc, &req);

	v = req.rspbuf[0] * 256 + req.rspbuf[1];

	/*
	 * Read the new external status value if necessary
	 */
	if (v & (TS102_EVENT_STATUS_DC_STATUS_CHANGE |
	    TS102_EVENT_STATUS_LID_STATUS_CHANGE |
	    TS102_EVENT_STATUS_EXTERNAL_VGA_STATUS_CHANGE))
		tctrl_read_ext_status(sc);

	if (v & TS102_EVENT_STATUS_SHUTDOWN_REQUEST) {
		printf("%s: SHUTDOWN REQUEST!\n", sc->sc_dev.dv_xname);
	}
#ifdef TCTRLDEBUG
	/* Obviously status change */
	if (v & TS102_EVENT_STATUS_VERY_LOW_POWER_WARNING) {
		if (sc->sc_apmflags & SCFLAG_PCTPRINT)
			printf("%s: Battery level change\n",
			    sc->sc_dev.dv_xname);
	}
#endif
	if (v & TS102_EVENT_STATUS_LOW_POWER_WARNING) {
		if ((sc->sc_apmflags & SCFLAG_NOPRINT) == 0)
			printf("%s: LOW POWER WARNING!\n", sc->sc_dev.dv_xname);
		apm_record_event(sc, APM_BATTERY_LOW);
	}
	if (v & TS102_EVENT_STATUS_DC_STATUS_CHANGE) {
		if ((sc->sc_apmflags & SCFLAG_NOPRINT) == 0)
			printf("%s: main power %s\n", sc->sc_dev.dv_xname,
			    (sc->sc_ext_status & TS102_EXT_STATUS_MAIN_POWER_AVAILABLE) ?
			      "restored" : "removed");
		apm_record_event(sc, APM_POWER_CHANGE);
#if 0 /* automatically done for us */
		tctrl_lcd(sc, ~TS102_LCD_DC_OK,
		    sc->sc_ext_status & TS102_EXT_STATUS_MAIN_POWER_AVAILABLE ?
		      TS102_LCD_DC_OK : 0);
#endif
	}
	if (v & TS102_EVENT_STATUS_LID_STATUS_CHANGE) {
		/* blank or restore video if necessary */
		if (sc->sc_tft_on)
			tctrl_tft(sc);
#ifdef TCTRLDEBUG
		printf("%s: lid %s\n", sc->sc_dev.dv_xname,
		    (sc->sc_ext_status & TS102_EXT_STATUS_LID_DOWN) ?
		      "closed" : "opened");
#endif
	}
	if (v & TS102_EVENT_STATUS_EXTERNAL_VGA_STATUS_CHANGE) {
		printf("%s: external vga %s\n", sc->sc_dev.dv_xname,
		    sc->sc_ext_status & TS102_EXT_STATUS_EXTERNAL_VGA_ATTACHED ?
		      "attached" : "detached");
#ifdef TCTRLDEBUG
		req.cmdbuf[0] = TS102_OP_RD_EXT_VGA_PORT;
		req.cmdlen = 1;
		req.rsplen = 2;
		tctrl_request(sc, &req);
		printf("%s: vga status %x\n", sc->sc_dev.dv_xname,
		    req.rspbuf[0]);
#endif
		if (sc->sc_evcb != NULL)
			(*sc->sc_evcb)(sc->sc_evdata, sc->sc_ext_status &
			    TS102_EXT_STATUS_EXTERNAL_VGA_ATTACHED);
	}
}

void
tctrl_read_ext_status(struct tctrl_softc *sc)
{
	struct tctrl_req req;

	req.cmdbuf[0] = TS102_OP_RD_EXT_STATUS;
	req.cmdlen = 1;
	req.rsplen = 3;
#ifdef TCTRLDEBUG
	printf("tctrl_read_ext_status: before, ext_status = %x\n",
	    sc->sc_ext_status);
#endif

	tctrl_request(sc, &req);

	sc->sc_ext_status = req.rspbuf[0] * 256 + req.rspbuf[1];

#ifdef TCTRLDEBUG
	printf("tctrl_read_ext_status: after, ext_status = %x\n",
	    sc->sc_ext_status);
#endif
}

void
tctrl_bell(struct tctrl_softc *sc, int mask, int value)
{
	struct tctrl_req req;

	req.cmdbuf[0] = TS102_OP_CTL_SPEAKER_VOLUME;
	req.cmdbuf[1] = mask;
	req.cmdbuf[2] = value;
	req.cmdlen = 3;
	req.rsplen = 2;

	tctrl_request(sc, &req);

	/*
	 * Note that rspbuf[0] returns the previous value, before any
	 * adjustment happened.
	 */
	if (mask == 0)
		sc->sc_bellvol = value;
	else
		sc->sc_bellvol = req.rspbuf[0];
}

void
tctrl_brightness(struct tctrl_softc *sc, int mask, int value)
{
	struct tctrl_req req;

	req.cmdbuf[0] = TS102_OP_CTL_TFT_BRIGHTNESS;
	req.cmdbuf[1] = mask;
	req.cmdbuf[2] = value;
	req.cmdlen = 3;
	req.rsplen = 2;

	tctrl_request(sc, &req);

	/*
	 * Note that rspbuf[0] returns the previous value, before any
	 * adjustment happened.
	 */
	if (mask == 0)
		sc->sc_brightness = value;
	else
		sc->sc_brightness = req.rspbuf[0];
}

void
tctrl_tft(struct tctrl_softc *sc)
{
	struct tctrl_req req;
	int enable;

	enable = (sc->sc_ext_status & TS102_EXT_STATUS_LID_DOWN) == 0 &&
	    sc->sc_tft_on;

	req.cmdbuf[0] = TS102_OP_CTL_BITPORT;
	req.cmdbuf[1] = ~TS102_BITPORT_TFTPWR;
	req.cmdbuf[2] = enable ? 0 : TS102_BITPORT_TFTPWR;
	req.cmdlen = 3;
	req.rsplen = 2;

	if ((sc->sc_flags & TCTRL_ISXT) != 0 && enable) {
		sb_auxregbisc(0, AUXIO_TFT, 0);
		delay(100000);	/* XXX is such a long delay really necessary? */
	}

	tctrl_request(sc, &req);

	if ((sc->sc_flags & TCTRL_ISXT) != 0 && !enable) {
		delay(100000);	/* XXX is such a long delay really necessary? */
		sb_auxregbisc(0, 0, AUXIO_TFT);
	}
}

void
tctrl_lcd(struct tctrl_softc *sc, int mask, int value)
{
	struct tctrl_req req;

	req.cmdbuf[0] = TS102_OP_CTL_LCD;

	/*
	 * The mask setup for this particular command is *very* bizarre
	 * and totally undocumented.
	 * One would expect the cmdlen and rsplen to be 5 and 3,
	 * respectively, as well.  Though luck, they are not...
	 */

	req.cmdbuf[1] = mask & 0xff;
	req.cmdbuf[4] = (mask >> 8) & 0x01;

	req.cmdbuf[2] = value & 0xff;
	req.cmdbuf[3] = (value >> 8 & 0x01);

	req.cmdlen = 3;
	req.rsplen = 2;

	tctrl_request(sc, &req);
}

int
tctrl_request(struct tctrl_softc *sc, struct tctrl_req *req)
{
	int s, rv;

	while (sc->sc_wantdata != 0) {
		DELAY(1);
	}

	s = splhigh();
	sc->sc_flags |= TCTRL_SEND_REQUEST;
	bcopy(req->cmdbuf, sc->sc_cmdbuf, req->cmdlen);
	sc->sc_wantdata = 1;
	sc->sc_rsplen = req->rsplen;
	sc->sc_cmdlen = req->cmdlen;
	sc->sc_cmdoff = sc->sc_rspoff = 0;

	do {
		tctrl_intr(sc);
	} while (sc->sc_state != TCTRL_IDLE);

	sc->sc_wantdata = 0;	/* just in case... */

	rv = sc->sc_rspack;
	if (rv != 0)
		bcopy(sc->sc_rspbuf, req->rspbuf, sc->sc_rsplen);
	else
		bzero(req->rspbuf, req->rsplen);	/* safety */
	splx(s);

	return (rv);
}

void
tctrl_write_data(sc, v)
	struct tctrl_softc *sc;
	u_int8_t v;
{
	unsigned int i;

	for (i = 0; i < 100; i++)  {
		if (sc->sc_regs->stat & TS102_UCTRL_STS_TXNF_STA)
			break;
	}
	sc->sc_regs->data = v;
}

u_int8_t
tctrl_read_data(sc)
	struct tctrl_softc *sc;
{ 
	unsigned int i, v;

	for (i = 0; i < 100000; i++) {
		if (sc->sc_regs->stat & TS102_UCTRL_STS_RXNE_STA)
			break;
		DELAY(1);
	}

	v = sc->sc_regs->data;
	sc->sc_regs->stat = TS102_UCTRL_STS_RXNE_STA;
	return v;
}

/*
 * External interfaces, used by the display and pcmcia drivers, as well
 * as the powerdown code.
 */

void
tadpole_powerdown(void)
{
	struct tctrl_softc *sc;
	struct tctrl_req req;

	if (tctrl_cd.cd_ndevs == 0 || tctrl_cd.cd_devs[0] == NULL) {
		return;
	}

	sc = (struct tctrl_softc *)tctrl_cd.cd_devs[0];
	req.cmdbuf[0] = TS102_OP_ADMIN_POWER_OFF;
	req.cmdlen = 1;
	req.rsplen = 1;

	tctrl_request(sc, &req);
}

void
tadpole_set_brightness(int value)
{
	struct tctrl_softc *sc;

	if (tctrl_cd.cd_ndevs == 0 || tctrl_cd.cd_devs[0] == NULL) {
		return;
	}

	sc = (struct tctrl_softc *)tctrl_cd.cd_devs[0];
	if (value != sc->sc_brightness)
		tctrl_brightness(sc, 0, value);
}

int
tadpole_get_brightness()
{
	struct tctrl_softc *sc;

	if (tctrl_cd.cd_ndevs == 0 || tctrl_cd.cd_devs[0] == NULL) {
		return 0;
	}

	sc = (struct tctrl_softc *)tctrl_cd.cd_devs[0];
	return sc->sc_brightness;
}

void
tadpole_set_video(int enabled)
{
	struct tctrl_softc *sc;

	if (tctrl_cd.cd_ndevs == 0 || tctrl_cd.cd_devs[0] == NULL) {
		return;
	}

	sc = (struct tctrl_softc *)tctrl_cd.cd_devs[0];
	if (sc->sc_tft_on ^ enabled) {
		sc->sc_tft_on = enabled;
		/* nothing to do if the lid is down */
		if ((sc->sc_ext_status & TS102_EXT_STATUS_LID_DOWN) == 0)
			tctrl_tft(sc);
	}
}

u_int
tadpole_get_video()
{
	struct tctrl_softc *sc;
	unsigned int status;

	if (tctrl_cd.cd_ndevs == 0 || tctrl_cd.cd_devs[0] == NULL) {
		return 0;
	}

	sc = (struct tctrl_softc *)tctrl_cd.cd_devs[0];
	status = sc->sc_tft_on ? TV_ON : 0;

	return status;
}

void
tadpole_register_extvideo(void (*cb)(void *, int), void *data)
{
	struct tctrl_softc *sc;

	if (tctrl_cd.cd_ndevs == 0 || tctrl_cd.cd_devs[0] == NULL) {
		return;
	}

	sc = (struct tctrl_softc *)tctrl_cd.cd_devs[0];
	sc->sc_evcb = cb;
	sc->sc_evdata = data;

	(*cb)(data, sc->sc_ext_status & TS102_EXT_STATUS_EXTERNAL_VGA_ATTACHED);
}

void
tadpole_set_pcmcia(int slot, int enabled)
{
	struct tctrl_softc *sc;
	int mask;

	if (tctrl_cd.cd_ndevs == 0 || tctrl_cd.cd_devs[0] == NULL) {
		return;
	}

	sc = (struct tctrl_softc *)tctrl_cd.cd_devs[0];
	mask = 1 << slot;
	enabled = enabled ? mask : 0;
	if ((sc->sc_pcmcia_on ^ enabled) & mask) {
		sc->sc_pcmcia_on ^= mask;
		tctrl_lcd(sc, ~TS102_LCD_PCMCIA_ACTIVE,
		    sc->sc_pcmcia_on ? TS102_LCD_PCMCIA_ACTIVE : 0);
	}
}

int
tadpole_bell(u_int duration, u_int freq, u_int volume)
{
	struct tctrl_softc *sc;
	struct tctrl_req req;

	if (tctrl_cd.cd_ndevs == 0 || tctrl_cd.cd_devs[0] == NULL) {
		return (0);
	}

	sc = (struct tctrl_softc *)tctrl_cd.cd_devs[0];

	/* Adjust frequency if necessary (first time or frequence change) */
	if (freq > 0 && freq <= 0xffff && freq != sc->sc_bellfreq) {
		req.cmdbuf[0] = TS102_OP_CMD_SET_BELL_FREQ;
		req.cmdbuf[1] = (freq >> 8) & 0xff;
		req.cmdbuf[2] = freq & 0xff;
		req.cmdlen = 3;
		req.rsplen = 1;

		tctrl_request(sc, &req);

		sc->sc_bellfreq = freq;
	}

	/* Adjust volume if necessary */
	if (volume >= 0 && volume <= 100) {
		volume = (volume * 255) / 100;
		if (volume != sc->sc_bellvol)
			tctrl_bell(sc, 0, volume);

	}

	req.cmdbuf[0] = TS102_OP_CMD_RING_BELL;
	req.cmdbuf[1] = (duration >> 8) & 0xff;
	req.cmdbuf[2] = duration & 0xff;
	req.cmdlen = 3;
	req.rsplen = 1;

	tctrl_request(sc, &req);

	return (1);
}

/*
 * /dev/apm{,ctl} interface code
 */

#define	APMUNIT(dev)	(minor(dev)&0xf0)
#define	APMDEV(dev)	(minor(dev)&0x0f)
#define APMDEV_NORMAL	0
#define APMDEV_CTL	8

int	apmkqfilter(dev_t dev, struct knote *kn);
void	filt_apmrdetach(struct knote *kn);
int	filt_apmread(struct knote *kn, long hint);

struct filterops apmread_filtops =
	{ 1, NULL, filt_apmrdetach, filt_apmread};

#define	SCFLAG_OREAD 	(1 << 0)
#define	SCFLAG_OWRITE	(1 << 1)
#define	SCFLAG_OPEN	(SCFLAG_OREAD|SCFLAG_OWRITE)

int
apmopen(dev_t dev, int flag, int mode, struct proc *p)
{
	struct tctrl_softc *sc;
	int error = 0;

	if (tctrl_cd.cd_ndevs == 0 || tctrl_cd.cd_devs[0] == NULL) {
		return (ENXIO);
	}

	/* apm0 only */
	if (APMUNIT(dev) != 0)
		return (ENODEV);

	sc = (struct tctrl_softc *)tctrl_cd.cd_devs[0];

	switch (APMDEV(dev)) {
	case APMDEV_CTL:
		if (!(flag & FWRITE)) {
			error = EINVAL;
			break;
		}
		if (sc->sc_apmflags & SCFLAG_OWRITE) {
			error = EBUSY;
			break;
		}
		sc->sc_apmflags |= SCFLAG_OWRITE;
		break;
	case APMDEV_NORMAL:
		if (!(flag & FREAD) || (flag & FWRITE)) {
			error = EINVAL;
			break;
		}
		sc->sc_apmflags |= SCFLAG_OREAD;
		break;
	default:
		error = ENXIO;
		break;
	}
	return (error);
}

int
apmclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct tctrl_softc *sc;

	if (tctrl_cd.cd_ndevs == 0 || tctrl_cd.cd_devs[0] == NULL) {
		return (ENXIO);
	}

	/* apm0 only */
	if (APMUNIT(dev) != 0)
		return (ENODEV);

	sc = (struct tctrl_softc *)tctrl_cd.cd_devs[0];

	switch (APMDEV(dev)) {
	case APMDEV_CTL:
		sc->sc_apmflags &= ~SCFLAG_OWRITE;
		break;
	case APMDEV_NORMAL:
		sc->sc_apmflags &= ~SCFLAG_OREAD;
		break;
	}
	return (0);
}

int
apmioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct tctrl_softc *sc;
	struct tctrl_req req;
	struct apm_power_info *power;
	u_int8_t c;
	int error = 0;

	if (tctrl_cd.cd_ndevs == 0 || tctrl_cd.cd_devs[0] == NULL) {
		return (ENXIO);
	}

	/* apm0 only */
	if (APMUNIT(dev) != 0)
		return (ENODEV);

	sc = (struct tctrl_softc *)tctrl_cd.cd_devs[0];

	switch (cmd) {
		/* some ioctl names from linux */
	case APM_IOC_STANDBY:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		else
			error = EOPNOTSUPP;	/* XXX */
		break;
	case APM_IOC_SUSPEND:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		else
			error = EOPNOTSUPP;	/* XXX */
		break;
	case APM_IOC_PRN_CTL:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		else {
			int flag = *(int *)data;
			switch (flag) {
			case APM_PRINT_ON:	/* enable printing */
				sc->sc_apmflags &= ~SCFLAG_PRINT;
				break;
			case APM_PRINT_OFF: /* disable printing */
				sc->sc_apmflags &= ~SCFLAG_PRINT;
				sc->sc_apmflags |= SCFLAG_NOPRINT;
				break;
			case APM_PRINT_PCT: /* disable some printing */
				sc->sc_apmflags &= ~SCFLAG_PRINT;
				sc->sc_apmflags |= SCFLAG_PCTPRINT;
				break;
			default:
				error = EINVAL;
				break;
			}
		}
		break;
	case APM_IOC_GETPOWER:
	        power = (struct apm_power_info *)data;

		if (sc->sc_ext_status &
		    TS102_EXT_STATUS_INTERNAL_BATTERY_ATTACHED) {
			req.cmdbuf[0] = TS102_OP_RD_INT_CHARGE_RATE;
			req.cmdlen = 1;
			req.rsplen = 2;
			tctrl_request(sc, &req);
			if (req.rspbuf[0] != 0)
				power->battery_state = APM_BATT_CHARGING;
			else
				power->battery_state = APM_BATT_UNKNOWN;

			req.cmdbuf[0] = TS102_OP_RD_INT_CHARGE_LEVEL;
			req.cmdlen = 1;
			req.rsplen = 3;
			tctrl_request(sc, &req);

			c = req.rspbuf[0];
			if (c >= TS102_CHARGE_UNKNOWN)
				power->battery_life = 0;
			else {
				power->battery_life = c;
				if (power->battery_state != APM_BATT_CHARGING) {
					if (c < 0x20)
						power->battery_state =
						    APM_BATT_CRITICAL;
					else if (c < 0x40)
						power->battery_state =
						    APM_BATT_HIGH;
					else if (c < 0x66)
						power->battery_state =
						    APM_BATT_HIGH;
				}
			}
		} else {
			power->battery_state = APM_BATTERY_ABSENT;
			power->battery_life = 0;
		}
		power->minutes_left = (u_int)-1;	/* unknown */

		if (sc->sc_ext_status & TS102_EXT_STATUS_MAIN_POWER_AVAILABLE)
			power->ac_state = APM_AC_ON;
		else
			power->ac_state = APM_AC_OFF;
		break;
	case APM_IOC_STANDBY_REQ:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		else
			error = EOPNOTSUPP;	/* XXX */
		break;
	case APM_IOC_SUSPEND_REQ:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		else
			error = EOPNOTSUPP;	/* XXX */
		break;
	default:
		error = ENOTTY;
	}

	return (error);
}

int
apm_record_event(struct tctrl_softc *sc, u_int type)
{
	static int apm_evindex;

	/* skip if no user waiting */
	if ((sc->sc_apmflags & SCFLAG_OPEN) == 0)
		return (1);

	apm_evindex++;
	KNOTE(&sc->sc_note, APM_EVENT_COMPOSE(type, apm_evindex));

	return (0);
}

void
filt_apmrdetach(struct knote *kn)
{
	struct tctrl_softc *sc = (struct tctrl_softc *)kn->kn_hook;

	SLIST_REMOVE(&sc->sc_note, kn, knote, kn_selnext);
}

int
filt_apmread(struct knote *kn, long hint)
{
	/* XXX weird kqueue_scan() semantics */
	if (hint && !kn->kn_data)
		kn->kn_data = (int)hint;

	return (1);
}

int
apmkqfilter(dev_t dev, struct knote *kn)
{
	struct tctrl_softc *sc;

	if (tctrl_cd.cd_ndevs == 0 || tctrl_cd.cd_devs[0] == NULL) {
		return (ENXIO);
	}

	/* apm0 only */
	if (APMUNIT(dev) != 0)
		return (ENODEV);

	sc = (struct tctrl_softc *)tctrl_cd.cd_devs[0];

	switch (kn->kn_filter) {
	case EVFILT_READ:
		kn->kn_fop = &apmread_filtops;
		break;
	default:
		return (EINVAL);
	}

	kn->kn_hook = (caddr_t)sc;
	SLIST_INSERT_HEAD(&sc->sc_note, kn, kn_selnext);

	return (0);
}
@


1.21
log
@kqueue attach functions should return an errno or 0, not a plain 1. Fix
the obvious cases to return EINVAL and ENXIO.

ok tedu deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tctrl.c,v 1.20 2009/02/26 17:19:47 oga Exp $	*/
@


1.20
log
@Add a two new ioctls to the apm(4) interface.

APM_IOC_{SUSPEND,STANDBY}_REQ: This is to fix an issue with apm suspend
where a call to zzz suspended the machine immediately, not giving anyone
listening for apm events (other than apmd) a chance to deal with the
upcoming change. This hit X hard since the introduction of drm, since it
needs to have time to idle the 3d engine and otherwise get the device
into a recoverable state. Such things are needed until we support
modesetting in the kernel.

Now, instead of forcing a suspend, using ioctl sends out an event similar
to if you had put the lid down, giving all userland applications a
chance to reply.

tested by sthen@@ and beck@@, especial thanks to sthen for sitting there
while I tried to debug this remotely, I owe him beer.

Prompted by and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tctrl.c,v 1.19 2008/06/26 05:42:13 ray Exp $	*/
d1187 1
a1187 1
		return (1);
@


1.19
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tctrl.c,v 1.18 2006/10/27 17:52:38 miod Exp $	*/
d1115 12
a1126 1

@


1.18
log
@If the lid is closed during boot, blank screen immediately.
@
text
@d1 1
a1 1
/*	$OpenBSD: tctrl.c,v 1.17 2006/09/17 22:26:37 miod Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.17
log
@No need to check for both cd_devs != NULL && cd_ndevs != 0, since the latter
implies the former; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: tctrl.c,v 1.16 2005/07/19 09:36:04 miod Exp $	*/
d110 1
a110 1
const char *tctrl_ext_statuses[16] = {
d277 1
a277 1
			    strlen(tctrl_ext_statuses[i]) > 80) {
d286 2
a287 2
			printf("%s%s", sep, tctrl_ext_statuses[i]);
			len += strlen(sep) + strlen(tctrl_ext_statuses[i]);
d297 4
@


1.16
log
@On the SPARCbooks, allow tctrl(4) to control the external video output,
acting when the external display status changes, with the help of the
pnozz(4) driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: tctrl.c,v 1.15 2005/07/17 12:16:51 miod Exp $	*/
d774 1
a774 3
	if (tctrl_cd.cd_devs == NULL
	    || tctrl_cd.cd_ndevs == 0
	    || tctrl_cd.cd_devs[0] == NULL) {
d791 1
a791 3
	if (tctrl_cd.cd_devs == NULL
	    || tctrl_cd.cd_ndevs == 0
	    || tctrl_cd.cd_devs[0] == NULL) {
d805 1
a805 3
	if (tctrl_cd.cd_devs == NULL
	    || tctrl_cd.cd_ndevs == 0
	    || tctrl_cd.cd_devs[0] == NULL) {
d818 1
a818 3
	if (tctrl_cd.cd_devs == NULL
	    || tctrl_cd.cd_ndevs == 0
	    || tctrl_cd.cd_devs[0] == NULL) {
d837 1
a837 3
	if (tctrl_cd.cd_devs == NULL
	    || tctrl_cd.cd_ndevs == 0
	    || tctrl_cd.cd_devs[0] == NULL) {
d852 1
a852 3
	if (tctrl_cd.cd_devs == NULL
	    || tctrl_cd.cd_ndevs == 0
	    || tctrl_cd.cd_devs[0] == NULL) {
d869 1
a869 3
	if (tctrl_cd.cd_devs == NULL
	    || tctrl_cd.cd_ndevs == 0
	    || tctrl_cd.cd_devs[0] == NULL) {
d889 1
a889 3
	if (tctrl_cd.cd_devs == NULL
	    || tctrl_cd.cd_ndevs == 0
	    || tctrl_cd.cd_devs[0] == NULL) {
d953 1
a953 3
	if (tctrl_cd.cd_devs == NULL
	    || tctrl_cd.cd_ndevs == 0
	    || tctrl_cd.cd_devs[0] == NULL) {
d994 1
a994 3
	if (tctrl_cd.cd_devs == NULL
	    || tctrl_cd.cd_ndevs == 0
	    || tctrl_cd.cd_devs[0] == NULL) {
d1024 1
a1024 3
	if (tctrl_cd.cd_devs == NULL
	    || tctrl_cd.cd_ndevs == 0
	    || tctrl_cd.cd_devs[0] == NULL) {
d1164 1
a1164 3
	if (tctrl_cd.cd_devs == NULL
	    || tctrl_cd.cd_ndevs == 0
	    || tctrl_cd.cd_devs[0] == NULL) {
@


1.15
log
@If the internal battery is missing, report it as absent rather than in an
unknown state.
@
text
@d1 1
a1 1
/*	$OpenBSD: tctrl.c,v 1.14 2005/07/17 12:16:16 miod Exp $	*/
d162 4
d511 9
a536 1
		tctrl_read_ext_status(sc);
a548 1
		tctrl_read_ext_status(sc);
d558 16
d855 18
@


1.14
log
@Always turn off video when the lid is closed; this behaviour was lost in r1.8.
@
text
@d1 1
a1 1
/*	$OpenBSD: tctrl.c,v 1.13 2005/07/08 12:50:21 miod Exp $	*/
d1051 35
a1085 16
		req.cmdbuf[0] = TS102_OP_RD_INT_CHARGE_RATE;
		req.cmdlen = 1;
		req.rsplen = 2;
		tctrl_request(sc, &req);
		if (req.rspbuf[0] != 0)
			power->battery_state = APM_BATT_CHARGING;
		else
			power->battery_state = APM_BATT_UNKNOWN;

		req.cmdbuf[0] = TS102_OP_RD_INT_CHARGE_LEVEL;
		req.cmdlen = 1;
		req.rsplen = 3;
		tctrl_request(sc, &req);

		c = req.rspbuf[0];
		if (c >= TS102_CHARGE_UNKNOWN)
a1086 10
		else {
			power->battery_life = c;
			if (power->battery_state != APM_BATT_CHARGING) {
				if (c < 0x20)
					power->battery_state = APM_BATT_CRITICAL;
				else if (c < 0x40)
					power->battery_state = APM_BATT_HIGH;
				else if (c < 0x66)
					power->battery_state = APM_BATT_HIGH;
			}
a1089 3
#if 0
		tctrl_read_ext_status(sc);
#endif
@


1.13
log
@The Tadpole SPARCbook S3000XT apparently needs auxio bit frobbing, in addition
to a tctrl command, to turn the screen off (or back on), so deal with it.
(untested)
@
text
@d1 1
a1 1
/*	$OpenBSD: tctrl.c,v 1.12 2005/07/08 12:43:48 miod Exp $	*/
d538 2
a539 3
		/* restore video if necessary */
		if ((sc->sc_ext_status & TS102_EXT_STATUS_LID_DOWN) == 0 &&
		    sc->sc_tft_on)
@


1.12
log
@Do not report the battery status as critical but absent, when the battery
is missing.
@
text
@d1 1
a1 1
/*	$OpenBSD: tctrl.c,v 1.11 2005/04/11 01:49:50 miod Exp $	*/
d91 2
d139 1
d236 7
d623 4
a627 6
	if ((sc->sc_ext_status & TS102_EXT_STATUS_LID_DOWN)
	    || !sc->sc_tft_on) {
		req.cmdbuf[2] = TS102_BITPORT_TFTPWR;
	} else {
		req.cmdbuf[2] = 0;
	}
d630 1
d634 5
d640 5
@


1.11
log
@Handle commands failure correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: tctrl.c,v 1.10 2005/03/29 16:26:44 miod Exp $	*/
d1048 13
a1060 3
		if (c == TS102_CHARGE_UNKNOWN)
			c = 0;
		power->battery_life = c;
a1061 8
		if (power->battery_state != APM_BATT_CHARGING) {
			if (c < 0x20)
				power->battery_state = APM_BATT_CRITICAL;
			else if (c < 0x40)
				power->battery_state = APM_BATT_HIGH;
			else if (c < 0x66)
				power->battery_state = APM_BATT_HIGH;
		}
@


1.10
log
@Add an apm interface to the tctrl(4) device found on SPARCbooks; currently
limited to power change events and battery status retrieval.

ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tctrl.c,v 1.9 2005/03/29 12:55:55 miod Exp $	*/
d150 1
d172 1
a172 1
void	tctrl_request(struct tctrl_softc *, struct tctrl_req *);
d324 1
a324 1
			if (d == 0xfa) {
a332 4
			if (d != 0xfe) {
				printf("%s: (op=0x%02x): unexpected ack value (0x%02x)\n",
					sc->sc_dev.dv_xname, sc->sc_op, d);
			}
d336 27
a362 9
			sc->sc_rsplen--;
			sc->sc_rspoff = 0;
			sc->sc_state = sc->sc_rsplen ? TCTRL_DATA : TCTRL_IDLE;
			sc->sc_wantdata = sc->sc_rsplen ? 1 : 0;
#ifdef TCTRLDEBUG
			if (sc->sc_rsplen > 0) {
				printf(" [data(%u)]", sc->sc_rsplen);
			} else {
				printf(" [idle]\n");
d364 1
a364 2
#endif
			goto again;
d654 1
a654 1
void
d657 1
a657 1
	int s;
d676 6
a681 1
	bcopy(sc->sc_rspbuf, req->rspbuf, sc->sc_rsplen);
d683 2
@


1.9
log
@If a tctrl device is attached, run the keyboard bell through it, since the
keyboard on SPARCbooks lacks a speaker.
@
text
@d1 1
a1 1
/*	$OpenBSD: tctrl.c,v 1.8 2005/03/29 11:36:40 miod Exp $	*/
d39 35
d80 4
d86 1
d88 1
d94 14
d154 4
d175 2
d489 3
a491 1
		printf("%s: Battery level change\n", sc->sc_dev.dv_xname);
d495 3
a497 1
		printf("%s: LOW POWER WARNING!\n", sc->sc_dev.dv_xname);
d501 5
a505 3
		printf("%s: main power %s\n", sc->sc_dev.dv_xname,
		    (sc->sc_ext_status & TS102_EXT_STATUS_MAIN_POWER_AVAILABLE) ?
		      "restored" : "removed");
d857 261
@


1.8
log
@A few tctrl improvements, mostly adapted from NetBSD:
- use a better state machine, and define a simple internal interface to send
  commands to the microcontroller.
- program the 2nd line of the LCD screen; currently limited to the ``external
  power available'' and ``PCMCIA'' icons.
- fix races in the brightness adjustement and powerdown request.
- wrap initial dmesg output at 80 chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: tctrl.c,v 1.7 2004/09/29 07:35:11 miod Exp $	*/
d95 2
d104 1
d219 1
d483 23
d518 8
a525 1
	sc->sc_brightness = req.rspbuf[0];
d744 46
@


1.7
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tctrl.c,v 1.6 2004/05/10 09:05:52 miod Exp $	*/
a41 5
#include <sys/ioctl.h>
#include <sys/select.h>
#include <sys/tty.h>
#include <sys/proc.h>
#include <sys/user.h>
a42 2
#include <sys/file.h>
#include <sys/uio.h>
a43 2
#include <sys/syslog.h>
#include <sys/types.h>
d45 1
d67 8
d79 4
a82 12
	int sc_node;
	unsigned int sc_junk;
	unsigned int sc_ext_status;
	unsigned int sc_video_accel;
	unsigned int sc_pending;
#define	TCTRL_SEND_BITPORT		0x0001
#define	TCTRL_SEND_POWEROFF		0x0002
#define	TCTRL_SEND_RD_EXT_STATUS	0x0004
#define	TCTRL_SEND_RD_EVENT_STATUS	0x0008
#define	TCTRL_SEND_BITPORT_NOP		0x0010
#define	TCTRL_SEND_BRIGHTNESS		0x0020
#define	TCTRL_SEND_BRIGHTNESS_NOP	0x0040
a86 1
	u_int8_t sc_bitport;
d88 1
d91 6
a96 4
	u_int8_t sc_cmdoff;
	u_int8_t sc_cmdlen;
	u_int8_t sc_rspoff;
	u_int8_t sc_rsplen;
d99 2
a100 2
int tctrl_match(struct device *, void *, void *);
void tctrl_attach(struct device *, struct device *, void *);
d102 4
a105 1
void tctrl_write_data(struct tctrl_softc *, u_int8_t);
d107 5
a111 4
int tctrl_intr(void *);
void tctrl_setup_bitport(struct tctrl_softc *, int);
void tctrl_setup_brightness(struct tctrl_softc *, int, int);
void tctrl_process_response(struct tctrl_softc *);
d148 1
a149 1
	unsigned int i, v;
a150 4
	/*
	 * We're living on a sbus slot that looks like an obio that
	 * looks like an sbus slot.
	 */
a165 2
	sc->sc_node = ca->ca_ra.ra_node;

d170 1
a170 2
	/* clear any pending data.
	 */
d182 1
a182 6
	/* See what the external status is
	 */
	sc->sc_pending |= TCTRL_SEND_RD_EXT_STATUS;
	do {
		tctrl_intr(sc);
	} while (sc->sc_state != TCTRL_IDLE);
d184 2
d188 1
a189 1
		printf("%s: ", sc->sc_dev.dv_xname);
d191 10
a200 4
		for (i = 0, sep = ""; v != 0; i++, v >>= 1) {
			if (v & 1) {
				printf("%s%s", sep, tctrl_ext_statuses[i]);
				sep = ", ";
d202 8
d211 2
a212 1
		printf("\n");
d215 2
a216 13
	/*
	 * Get a few status values.
	 */
	sc->sc_video_accel =
	    sc->sc_ext_status & TS102_EXT_STATUS_MAIN_POWER_AVAILABLE;
	sc->sc_pending |= TCTRL_SEND_BITPORT_NOP;
	do {
		tctrl_intr(sc);
	} while (sc->sc_state != TCTRL_IDLE);
	sc->sc_pending |= TCTRL_SEND_BRIGHTNESS_NOP;
	do {
		tctrl_intr(sc);
	} while (sc->sc_state != TCTRL_IDLE);
d219 5
d233 1
a233 1
    again:
d235 1
a235 1
	v = sc->sc_regs->stat;
d243 4
d248 2
a249 1
	if ((v == 0) && (sc->sc_pending == 0 || sc->sc_state != TCTRL_IDLE)) {
d259 2
a260 1
				sc->sc_pending |= TCTRL_SEND_RD_EVENT_STATUS;
d271 1
a271 1
#if 0
d277 2
a278 1
#if 0
d288 1
a288 1
#if 0
d292 1
a292 1
#if 0
d296 1
a296 1
				tctrl_process_response(sc);
d305 6
a310 31
	if (sc->sc_state == TCTRL_IDLE) {
		sc->sc_cmdoff = 0;
		sc->sc_cmdlen = 0;
		if (sc->sc_pending & TCTRL_SEND_POWEROFF) {
			sc->sc_pending &= ~TCTRL_SEND_POWEROFF;
			sc->sc_cmdbuf[0] = TS102_OP_ADMIN_POWER_OFF;
			sc->sc_cmdlen = 1;
			sc->sc_rsplen = 0;
		} else if (sc->sc_pending & TCTRL_SEND_RD_EVENT_STATUS) {
			sc->sc_pending &= ~TCTRL_SEND_RD_EVENT_STATUS;
			sc->sc_cmdbuf[0] = TS102_OP_RD_EVENT_STATUS;
			sc->sc_cmdlen = 1;
			sc->sc_rsplen = 3;
		} else if (sc->sc_pending & TCTRL_SEND_RD_EXT_STATUS) {
			sc->sc_pending &= ~TCTRL_SEND_RD_EXT_STATUS;
			sc->sc_cmdbuf[0] = TS102_OP_RD_EXT_STATUS;
			sc->sc_cmdlen = 1;
			sc->sc_rsplen = 3;
		} else if (sc->sc_pending & TCTRL_SEND_BITPORT_NOP) {
			sc->sc_pending &= ~TCTRL_SEND_BITPORT_NOP;
			tctrl_setup_bitport(sc, 1);
		} else if (sc->sc_pending & TCTRL_SEND_BITPORT) {
			sc->sc_pending &= ~TCTRL_SEND_BITPORT;
			tctrl_setup_bitport(sc, 0);
		} else if (sc->sc_pending & TCTRL_SEND_BRIGHTNESS_NOP) {
			sc->sc_pending &= ~TCTRL_SEND_BRIGHTNESS_NOP;
			tctrl_setup_brightness(sc, 0xff, 0);
		} else if (sc->sc_pending & TCTRL_SEND_BRIGHTNESS) {
			sc->sc_pending &= ~TCTRL_SEND_BRIGHTNESS;
			tctrl_setup_brightness(sc, 0, sc->sc_brightness);
		} 
d320 1
a320 1
#if 0
d331 1
a331 1
#if 0
d343 1
a343 1
#if 0
d351 127
d479 1
a479 1
tctrl_setup_bitport(struct tctrl_softc *sc, int nop)
d481 21
a501 6
	if (nop) {
		sc->sc_cmdbuf[0] = TS102_OP_CTL_BITPORT;
		sc->sc_cmdbuf[1] = 0xff;
		sc->sc_cmdbuf[2] = 0;
		sc->sc_cmdlen = 3;
		sc->sc_rsplen = 2;
d503 1
a503 10
		if ((sc->sc_ext_status & TS102_EXT_STATUS_LID_DOWN)
		    || (!sc->sc_tft_on)) {
			sc->sc_cmdbuf[2] = TS102_BITPORT_TFTPWR;
		} else {
			sc->sc_cmdbuf[2] = 0;
		}
		sc->sc_cmdbuf[0] = TS102_OP_CTL_BITPORT;
		sc->sc_cmdbuf[1] = ~TS102_BITPORT_TFTPWR;
		sc->sc_cmdlen = 3;
		sc->sc_rsplen = 2;
d505 6
d514 1
a514 1
tctrl_setup_brightness(struct tctrl_softc *sc, int mask, int value)
d516 21
a536 5
	sc->sc_cmdbuf[0] = TS102_OP_CTL_TFT_BRIGHTNESS;
	sc->sc_cmdbuf[1] = mask;
	sc->sc_cmdbuf[2] = value;
	sc->sc_cmdlen = 3;
	sc->sc_rsplen = 2;
d540 1
a540 1
tctrl_process_response(struct tctrl_softc *sc)
d542 1
a542 9
	switch (sc->sc_op) {
	case TS102_OP_RD_EXT_STATUS: {
		unsigned int status = sc->sc_ext_status;
		sc->sc_ext_status = sc->sc_rspbuf[0] * 256 + sc->sc_rspbuf[1];
		status ^= sc->sc_ext_status;
		if (status & TS102_EXT_STATUS_MAIN_POWER_AVAILABLE) {
			printf("%s: main power %s\n", sc->sc_dev.dv_xname,
			    (sc->sc_ext_status & TS102_EXT_STATUS_MAIN_POWER_AVAILABLE) ?
			      "restored" : "removed");
d544 2
a545 11
			/* XXX reset video */
			sc->sc_video_accel = 0;
		}
#if 0
		if (status & TS102_EXT_STATUS_LID_DOWN) {
			printf("%s: lid %s\n", sc->sc_dev.dv_xname,
			    (sc->sc_ext_status & TS102_EXT_STATUS_LID_DOWN) ?
			      "closed" : "opened");
		}
#endif
		break;
d547 28
a574 22
	case TS102_OP_RD_EVENT_STATUS: {
		unsigned int v = sc->sc_rspbuf[0] * 256 + sc->sc_rspbuf[1];
		if (v & TS102_EVENT_STATUS_SHUTDOWN_REQUEST) {
			printf("%s: SHUTDOWN REQUEST!\n", sc->sc_dev.dv_xname);
		}
#if 0
/* Obviously status change */
		if (v & TS102_EVENT_STATUS_VERY_LOW_POWER_WARNING) {
			printf("%s: VERY LOW POWER WARNING!\n", sc->sc_dev.dv_xname);
		}
#endif
		if (v & TS102_EVENT_STATUS_LOW_POWER_WARNING) {
			printf("%s: LOW POWER WARNING!\n", sc->sc_dev.dv_xname);
		}
		if (v & TS102_EVENT_STATUS_DC_STATUS_CHANGE) {
			sc->sc_pending |= TCTRL_SEND_RD_EXT_STATUS;
		}
		if (v & TS102_EVENT_STATUS_LID_STATUS_CHANGE) {
			sc->sc_pending |= TCTRL_SEND_RD_EXT_STATUS;
			sc->sc_pending |= TCTRL_SEND_BITPORT;
		}
		break;
d576 13
a588 7
	case TS102_OP_CTL_BITPORT:
		sc->sc_bitport = (sc->sc_rspbuf[0] & sc->sc_cmdbuf[1]) ^ sc->sc_cmdbuf[2];
		break;
	case TS102_OP_CTL_TFT_BRIGHTNESS:
		sc->sc_brightness = sc->sc_rspbuf[0];
	default:
		break;
d590 4
d596 5
d605 1
a605 1
	int i, s;
d613 6
a618 8
	sc = (struct tctrl_softc *) tctrl_cd.cd_devs[0];
	s = splhigh();
	sc->sc_pending |= TCTRL_SEND_POWEROFF;
	for (i = 0; i < 10000; i++) {
		tctrl_intr(sc);
		DELAY(1);
	}
	splx(s);
a624 1
	int s;
d632 3
a634 8
	sc = (struct tctrl_softc *) tctrl_cd.cd_devs[0];
	s = splhigh();
	if (value != sc->sc_brightness) {
		sc->sc_brightness = value;
		sc->sc_pending |= TCTRL_SEND_BRIGHTNESS;
		tctrl_intr(sc);
	}
	splx(s);
d648 1
a648 1
	sc = (struct tctrl_softc *) tctrl_cd.cd_devs[0];
a655 1
	int s;
d663 1
a663 2
	sc = (struct tctrl_softc *) tctrl_cd.cd_devs[0];
	s = splhigh();
d666 3
a668 6
		if (sc->sc_ext_status & TS102_EXT_STATUS_LID_DOWN) {
			splx(s);
			return;
		}
		sc->sc_pending |= TCTRL_SEND_BITPORT;
		tctrl_intr(sc);
a669 1
	splx(s);
d672 1
a672 1
unsigned int
d684 2
a685 7
	sc = (struct tctrl_softc *) tctrl_cd.cd_devs[0];
	status = 0;

	if (sc->sc_tft_on)
		status |= TV_ON;
	if (sc->sc_video_accel)
		status |= TV_ACCEL;
d691 2
a692 1
tctrl_write_data(sc, v)
d694 1
a694 3
	u_int8_t v;
{
	unsigned int i;
d696 4
a699 3
	for (i = 0; i < 100; i++)  {
		if (sc->sc_regs->stat & TS102_UCTRL_STS_TXNF_STA)
			break;
a700 2
	sc->sc_regs->data = v;
}
d702 7
a708 10
u_int8_t
tctrl_read_data(sc)
	struct tctrl_softc *sc;
{ 
	unsigned int i, v;

	for (i = 0; i < 100000; i++) {
		if (sc->sc_regs->stat & TS102_UCTRL_STS_RXNE_STA)
			break;
		DELAY(1);
a709 4

	v = sc->sc_regs->data;
	sc->sc_regs->stat = TS102_UCTRL_STS_RXNE_STA;
	return v;
@


1.6
log
@When external power is not available, the tadpole video hardware gets
stuck in a weird mode, where not all acceleration functions are
available, and I could not figure out how to reset the chip strongly
enough to leave this mode.

Try to compensate by checking whether the external power has been removed,
when we set up the accelerated rasops (this will not cope with power being
removed after bootup, yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: tctrl.c,v 1.5 2003/05/16 18:40:32 miod Exp $	*/
a102 2

	struct evcnt sc_intrcnt;	/* interrupt counting */
d189 1
a189 2
	intr_establish(pri, &sc->sc_ih, -1);
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);
@


1.5
log
@Let the user control the brightness of the tadpole built-in display via
wsconsctl (wsconsctl -w display.brightness=xx).

Makes the lack of a physical knob almost supportable.
@
text
@d1 1
a1 1
/*	$OpenBSD: tctrl.c,v 1.4 2002/04/30 01:12:29 art Exp $	*/
d82 1
d218 2
d413 1
d415 16
d438 2
d443 1
a448 2
			printf("%s: main power %s\n", sc->sc_dev.dv_xname,
			       (sc->sc_ext_status & TS102_EXT_STATUS_MAIN_POWER_AVAILABLE) ? "removed" : "restored");
a452 4
#if 0
			printf("%s: lid %s\n", sc->sc_dev.dv_xname,
			       (sc->sc_ext_status & TS102_EXT_STATUS_LID_DOWN) ? "opened" : "closed");
#endif
d539 1
a539 1
	if ((sc->sc_tft_on && !enabled) || (!sc->sc_tft_on && enabled)) {
d551 1
a551 1
int
d555 1
d564 8
a571 1
	return sc->sc_tft_on;
@


1.4
log
@Fix an ancient problem in how sparc interrupts are handled.

There are many interrupt handlers that assume that they don't need to do
any spl protection in their code because the interrupt of some level can't
be interrupted by an interrupt of the same level. The problem is that some
interrupt handlers have hardware levels that are lower then their "software"
levels.

Fix this by adding an additional field to struct intrhand that specifies which
"software" level an interrupt handler has and blocks that level while handling
the interrupt. This new field is initialized in intr_establish which gets
an additional argument (which can be -1 meaning that the interrupt handler
doesn't need to block any additional level).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tctrl.c,v 1.3 2002/03/14 01:26:43 millert Exp $	*/
d88 2
d96 1
d113 1
d135 2
a136 2
	 * (who's interface is off the TS102 PCMCIA controller but there
	 * exists a OpenProm for microcontroller interface).
d214 2
a215 1
	/* Get a current of the control bitport;
d221 4
d325 6
d396 10
d442 2
d472 37
d532 15
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: tctrl.c,v 1.2 1999/09/07 12:36:20 jason Exp $	*/
d186 1
a186 1
	intr_establish(pri, &sc->sc_ih);
@


1.2
log
@print pri
@
text
@d1 1
a1 1
/*	$OpenBSD: tctrl.c,v 1.1 1999/09/07 02:58:50 jason Exp $	*/
d103 2
a104 2
int tctrl_match		__P((struct device *, void *, void *));
void tctrl_attach	__P((struct device *, struct device *, void *));
d106 5
a110 5
void tctrl_write_data		__P((struct tctrl_softc *, u_int8_t));
u_int8_t tctrl_read_data	__P((struct tctrl_softc *));
int tctrl_intr			__P((void *));
void tctrl_setup_bitport	__P((struct tctrl_softc *, int));
void tctrl_process_response	__P((struct tctrl_softc *));
@


1.2.14.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tctrl.c,v 1.2 1999/09/07 12:36:20 jason Exp $	*/
d103 2
a104 2
int tctrl_match(struct device *, void *, void *);
void tctrl_attach(struct device *, struct device *, void *);
d106 5
a110 5
void tctrl_write_data(struct tctrl_softc *, u_int8_t);
u_int8_t tctrl_read_data(struct tctrl_softc *);
int tctrl_intr(void *);
void tctrl_setup_bitport(struct tctrl_softc *, int);
void tctrl_process_response(struct tctrl_softc *);
d186 1
a186 1
	intr_establish(pri, &sc->sc_ih, -1);
@


1.2.14.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a87 2
#define	TCTRL_SEND_BRIGHTNESS		0x0020
#define	TCTRL_SEND_BRIGHTNESS_NOP	0x0040
a93 1
	u_int8_t sc_brightness;
a109 1
void tctrl_setup_brightness(struct tctrl_softc *, int, int);
d131 2
a132 2
	 * (which is really part of the TS102 PCMCIA controller, but there
	 * exists a distinct OpenProm node for the microcontroller interface).
d210 1
a210 2
	/*
	 * Get a few status values.
a215 4
	sc->sc_pending |= TCTRL_SEND_BRIGHTNESS_NOP;
	do {
		tctrl_intr(sc);
	} while (sc->sc_state != TCTRL_IDLE);
a315 6
		} else if (sc->sc_pending & TCTRL_SEND_BRIGHTNESS_NOP) {
			sc->sc_pending &= ~TCTRL_SEND_BRIGHTNESS_NOP;
			tctrl_setup_brightness(sc, 0xff, 0);
		} else if (sc->sc_pending & TCTRL_SEND_BRIGHTNESS) {
			sc->sc_pending &= ~TCTRL_SEND_BRIGHTNESS;
			tctrl_setup_brightness(sc, 0, sc->sc_brightness);
a380 10
tctrl_setup_brightness(struct tctrl_softc *sc, int mask, int value)
{
	sc->sc_cmdbuf[0] = TS102_OP_CTL_TFT_BRIGHTNESS;
	sc->sc_cmdbuf[1] = mask;
	sc->sc_cmdbuf[2] = value;
	sc->sc_cmdlen = 3;
	sc->sc_rsplen = 2;
}

void
a416 2
	case TS102_OP_CTL_TFT_BRIGHTNESS:
		sc->sc_brightness = sc->sc_rspbuf[0];
a444 37
tadpole_set_brightness(int value)
{
	struct tctrl_softc *sc;
	int s;

	if (tctrl_cd.cd_devs == NULL
	    || tctrl_cd.cd_ndevs == 0
	    || tctrl_cd.cd_devs[0] == NULL) {
		return;
	}

	sc = (struct tctrl_softc *) tctrl_cd.cd_devs[0];
	s = splhigh();
	if (value != sc->sc_brightness) {
		sc->sc_brightness = value;
		sc->sc_pending |= TCTRL_SEND_BRIGHTNESS;
		tctrl_intr(sc);
	}
	splx(s);
}

int
tadpole_get_brightness()
{
	struct tctrl_softc *sc;

	if (tctrl_cd.cd_devs == NULL
	    || tctrl_cd.cd_ndevs == 0
	    || tctrl_cd.cd_devs[0] == NULL) {
		return 0;
	}

	sc = (struct tctrl_softc *) tctrl_cd.cd_devs[0];
	return sc->sc_brightness;
}

void
a467 15
}

int
tadpole_get_video()
{
	struct tctrl_softc *sc;

	if (tctrl_cd.cd_devs == NULL
	    || tctrl_cd.cd_ndevs == 0
	    || tctrl_cd.cd_devs[0] == NULL) {
		return 0;
	}

	sc = (struct tctrl_softc *) tctrl_cd.cd_devs[0];
	return sc->sc_tft_on;
@


1.2.4.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d103 2
a104 2
int tctrl_match(struct device *, void *, void *);
void tctrl_attach(struct device *, struct device *, void *);
d106 5
a110 5
void tctrl_write_data(struct tctrl_softc *, u_int8_t);
u_int8_t tctrl_read_data(struct tctrl_softc *);
int tctrl_intr(void *);
void tctrl_setup_bitport(struct tctrl_softc *, int);
void tctrl_process_response(struct tctrl_softc *);
@


1.2.4.2
log
@Sync the SMP branch with 3.3
@
text
@d186 1
a186 1
	intr_establish(pri, &sc->sc_ih, -1);
@


1.2.4.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tctrl.c,v 1.2.4.2 2003/03/27 23:49:25 niklas Exp $	*/
a87 2
#define	TCTRL_SEND_BRIGHTNESS		0x0020
#define	TCTRL_SEND_BRIGHTNESS_NOP	0x0040
a93 1
	u_int8_t sc_brightness;
a109 1
void tctrl_setup_brightness(struct tctrl_softc *, int, int);
d131 2
a132 2
	 * (which is really part of the TS102 PCMCIA controller, but there
	 * exists a distinct OpenProm node for the microcontroller interface).
d210 1
a210 2
	/*
	 * Get a few status values.
a215 4
	sc->sc_pending |= TCTRL_SEND_BRIGHTNESS_NOP;
	do {
		tctrl_intr(sc);
	} while (sc->sc_state != TCTRL_IDLE);
a315 6
		} else if (sc->sc_pending & TCTRL_SEND_BRIGHTNESS_NOP) {
			sc->sc_pending &= ~TCTRL_SEND_BRIGHTNESS_NOP;
			tctrl_setup_brightness(sc, 0xff, 0);
		} else if (sc->sc_pending & TCTRL_SEND_BRIGHTNESS) {
			sc->sc_pending &= ~TCTRL_SEND_BRIGHTNESS;
			tctrl_setup_brightness(sc, 0, sc->sc_brightness);
a380 10
tctrl_setup_brightness(struct tctrl_softc *sc, int mask, int value)
{
	sc->sc_cmdbuf[0] = TS102_OP_CTL_TFT_BRIGHTNESS;
	sc->sc_cmdbuf[1] = mask;
	sc->sc_cmdbuf[2] = value;
	sc->sc_cmdlen = 3;
	sc->sc_rsplen = 2;
}

void
a416 2
	case TS102_OP_CTL_TFT_BRIGHTNESS:
		sc->sc_brightness = sc->sc_rspbuf[0];
a444 37
tadpole_set_brightness(int value)
{
	struct tctrl_softc *sc;
	int s;

	if (tctrl_cd.cd_devs == NULL
	    || tctrl_cd.cd_ndevs == 0
	    || tctrl_cd.cd_devs[0] == NULL) {
		return;
	}

	sc = (struct tctrl_softc *) tctrl_cd.cd_devs[0];
	s = splhigh();
	if (value != sc->sc_brightness) {
		sc->sc_brightness = value;
		sc->sc_pending |= TCTRL_SEND_BRIGHTNESS;
		tctrl_intr(sc);
	}
	splx(s);
}

int
tadpole_get_brightness()
{
	struct tctrl_softc *sc;

	if (tctrl_cd.cd_devs == NULL
	    || tctrl_cd.cd_ndevs == 0
	    || tctrl_cd.cd_devs[0] == NULL) {
		return 0;
	}

	sc = (struct tctrl_softc *) tctrl_cd.cd_devs[0];
	return sc->sc_brightness;
}

void
a467 15
}

int
tadpole_get_video()
{
	struct tctrl_softc *sc;

	if (tctrl_cd.cd_devs == NULL
	    || tctrl_cd.cd_ndevs == 0
	    || tctrl_cd.cd_devs[0] == NULL) {
		return 0;
	}

	sc = (struct tctrl_softc *) tctrl_cd.cd_devs[0];
	return sc->sc_tft_on;
@


1.2.4.4
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a81 1
	unsigned int sc_video_accel;
a216 2
	sc->sc_video_accel =
	    sc->sc_ext_status & TS102_EXT_STATUS_MAIN_POWER_AVAILABLE;
a409 1
		unsigned int status = sc->sc_ext_status;
a410 16
		status ^= sc->sc_ext_status;
		if (status & TS102_EXT_STATUS_MAIN_POWER_AVAILABLE) {
			printf("%s: main power %s\n", sc->sc_dev.dv_xname,
			    (sc->sc_ext_status & TS102_EXT_STATUS_MAIN_POWER_AVAILABLE) ?
			      "restored" : "removed");

			/* XXX reset video */
			sc->sc_video_accel = 0;
		}
#if 0
		if (status & TS102_EXT_STATUS_LID_DOWN) {
			printf("%s: lid %s\n", sc->sc_dev.dv_xname,
			    (sc->sc_ext_status & TS102_EXT_STATUS_LID_DOWN) ?
			      "closed" : "opened");
		}
#endif
a417 2
#if 0
/* Obviously status change */
a420 1
#endif
d426 2
d432 4
d522 1
a522 1
	if (sc->sc_tft_on ^ enabled) {
d534 1
a534 1
unsigned int
a537 1
	unsigned int status;
d546 1
a546 8
	status = 0;

	if (sc->sc_tft_on)
		status |= TV_ON;
	if (sc->sc_video_accel)
		status |= TV_ACCEL;

	return status;
@


1.1
log
@add tadpole microcontroller device driver; from NetBSD
power the tft down on screenblank
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d171 1
a171 1
	printf("\n");
@

