head	1.35;
access;
symbols
	OPENBSD_5_0:1.34.0.4
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.2
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.33.0.2
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.4
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.31.0.4
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.2
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.30.0.12
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.10
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.30.0.8
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.6
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.30.0.4
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.30.0.2
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.27.0.4
	OPENBSD_3_6_BASE:1.27
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.27.0.2
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	UBC_SYNC_A:1.23
	OPENBSD_3_3:1.22.0.4
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	UBC_SYNC_B:1.22
	UBC:1.18.0.14
	UBC_BASE:1.18
	OPENBSD_3_0:1.18.0.12
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_9:1.18.0.10
	OPENBSD_2_8:1.18.0.8
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.18.0.6
	OPENBSD_2_7_BASE:1.18
	SMP:1.18.0.4
	SMP_BASE:1.18
	kame_19991208:1.18
	OPENBSD_2_6:1.18.0.2
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.15.0.2
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.10.0.4
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.6.0.4
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.35
date	2011.09.03.20.04.02;	author miod;	state dead;
branches;
next	1.34;

1.34
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.32;

1.32
date	2009.04.10.20.53.51;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2008.04.21.00.32.42;	author jakemsr;	state Exp;
branches;
next	1.30;

1.30
date	2005.08.14.10.58.33;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2005.07.09.22.23.13;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2004.09.29.07.35.11;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2003.11.03.07.01.33;	author david;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.28.20.53.02;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.28.18.22.14;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.28.18.12.31;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2003.05.11.19.41.12;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.04.30.01.12.28;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2002.04.28.03.51.19;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.14.03.15.59;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.01.26.42;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	99.08.06.01.26.49;	author jason;	state Exp;
branches
	1.18.4.1
	1.18.14.1;
next	1.17;

1.17
date	99.05.28.21.33.55;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	99.04.18.03.16.46;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	99.01.02.00.02.49;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	98.11.03.21.22.36;	author downsj;	state Exp;
branches;
next	1.13;

1.13
date	98.07.14.05.38.58;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	98.05.14.10.19.12;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	98.04.30.06.13.00;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	97.09.17.06.47.06;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	97.08.08.08.24.37;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	97.07.13.21.48.42;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	97.06.20.10.33.37;	author grr;	state Exp;
branches;
next	1.6;

1.6
date	96.08.12.02.10.35;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.08.12.01.19.38;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.08.11.05.34.05;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.15.13.56.14;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.18.17.31.56;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.37;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.37;	author deraadt;	state Exp;
branches;
next	;

1.18.4.1
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.18.4.2;

1.18.4.2
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.18.4.3;

1.18.4.3
date	2003.05.13.19.41.08;	author ho;	state Exp;
branches;
next	1.18.4.4;

1.18.4.4
date	2004.02.19.10.49.57;	author niklas;	state Exp;
branches;
next	;

1.18.14.1
date	2002.06.11.03.38.15;	author art;	state Exp;
branches;
next	1.18.14.2;

1.18.14.2
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Switch the sparc audioamd(4) code to the MI driver; tested on SPARCclassic
with and without option AUDIO_C_HANDLER.
@
text
@/*	$OpenBSD: amd7930.c,v 1.34 2010/09/20 06:33:47 matthew Exp $	*/
/*	$NetBSD: amd7930.c,v 1.37 1998/03/30 14:23:40 pk Exp $	*/

/*
 * Copyright (c) 1995 Rolf Grossmann
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Rolf Grossmann.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/proc.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>

#include <sys/audioio.h>
#include <dev/audio_if.h>

#include <dev/ic/am7930reg.h>
#include <sparc/dev/amd7930var.h>

#define AUDIO_ROM_NAME "audio"

#ifdef AUDIO_DEBUG
int     amd7930debug = 0;
#define DPRINTF(x)      if (amd7930debug) printf x
#else
#define DPRINTF(x)
#endif

/*
 * Define AUDIO_C_HANDLER to force using non-fast trap routines.
 */
/* #define AUDIO_C_HANDLER */

/*
 * Software state, per AMD79C30 audio chip.
 */
struct amd7930_softc {
	struct	device sc_dev;		/* base device */

	int	sc_open;		/* single use device */
	int	sc_locked;		/* true when transferring data */
	struct	mapreg sc_map;		/* current contents of map registers */

	u_char	sc_rlevel;		/* record level */
	u_char	sc_plevel;		/* play level */
	u_char	sc_mlevel;		/* monitor level */
	u_char	sc_out_port;		/* output port */

	/* interfacing with the interrupt handlers */
	void	(*sc_rintr)(void *);	/* input completion intr handler */
	void	*sc_rarg;		/* arg for sc_rintr() */
	void	(*sc_pintr)(void *);	/* output completion intr handler */
	void	*sc_parg;		/* arg for sc_pintr() */

        /* sc_au is special in that the hardware interrupt handler uses it */
        struct  auio sc_au;		/* recv and xmit buffers, etc */
#define	sc_hwih	sc_au.au_ih		/* hardware interrupt vector */
#define	sc_swih	sc_au.au_swih		/* software interrupt cookie */
};

#ifndef AUDIO_C_HANDLER
struct auio *auiop;
#endif /* AUDIO_C_HANDLER */
int	amd7930hwintr(void *);
void	amd7930swintr(void *);

/* forward declarations */
void	audio_setmap(volatile struct amd7930 *, struct mapreg *);
static void init_amd(volatile struct amd7930 *);
int	amd7930_shareintr(void *);

/* autoconfiguration driver */
void	amd7930attach(struct device *, struct device *, void *);
int	amd7930match(struct device *, void *, void *);

struct cfattach audioamd_ca = {
	sizeof(struct amd7930_softc), amd7930match, amd7930attach
};

struct	cfdriver audioamd_cd = {
	NULL, "audioamd", DV_DULL
};

struct audio_device amd7930_device = {
	"amd7930",
	"x",
	"audioamd"
};

/* Write 16 bits of data from variable v to the data port of the audio chip */
#define	WAMD16(amd, v) ((amd)->dr = (v), (amd)->dr = (v) >> 8)

/* The following tables stolen from former (4.4Lite's) sys/sparc/bsd_audio.c */

/*
 * gx, gr & stg gains.  this table must contain 256 elements with
 * the 0th being "infinity" (the magic value 9008).  The remaining
 * elements match sun's gain curve (but with higher resolution):
 * -18 to 0dB in .16dB steps then 0 to 12dB in .08dB steps.
 */
static const u_short gx_coeff[256] = {
	0x9008, 0x8e7c, 0x8e51, 0x8e45, 0x8d42, 0x8d3b, 0x8c36, 0x8c33,
	0x8b32, 0x8b2a, 0x8b2b, 0x8b2c, 0x8b25, 0x8b23, 0x8b22, 0x8b22,
	0x9122, 0x8b1a, 0x8aa3, 0x8aa3, 0x8b1c, 0x8aa6, 0x912d, 0x912b,
	0x8aab, 0x8b12, 0x8aaa, 0x8ab2, 0x9132, 0x8ab4, 0x913c, 0x8abb,
	0x9142, 0x9144, 0x9151, 0x8ad5, 0x8aeb, 0x8a79, 0x8a5a, 0x8a4a,
	0x8b03, 0x91c2, 0x91bb, 0x8a3f, 0x8a33, 0x91b2, 0x9212, 0x9213,
	0x8a2c, 0x921d, 0x8a23, 0x921a, 0x9222, 0x9223, 0x922d, 0x9231,
	0x9234, 0x9242, 0x925b, 0x92dd, 0x92c1, 0x92b3, 0x92ab, 0x92a4,
	0x92a2, 0x932b, 0x9341, 0x93d3, 0x93b2, 0x93a2, 0x943c, 0x94b2,
	0x953a, 0x9653, 0x9782, 0x9e21, 0x9d23, 0x9cd2, 0x9c23, 0x9baa,
	0x9bde, 0x9b33, 0x9b22, 0x9b1d, 0x9ab2, 0xa142, 0xa1e5, 0x9a3b,
	0xa213, 0xa1a2, 0xa231, 0xa2eb, 0xa313, 0xa334, 0xa421, 0xa54b,
	0xada4, 0xac23, 0xab3b, 0xaaab, 0xaa5c, 0xb1a3, 0xb2ca, 0xb3bd,
	0xbe24, 0xbb2b, 0xba33, 0xc32b, 0xcb5a, 0xd2a2, 0xe31d, 0x0808,
	0x72ba, 0x62c2, 0x5c32, 0x52db, 0x513e, 0x4cce, 0x43b2, 0x4243,
	0x41b4, 0x3b12, 0x3bc3, 0x3df2, 0x34bd, 0x3334, 0x32c2, 0x3224,
	0x31aa, 0x2a7b, 0x2aaa, 0x2b23, 0x2bba, 0x2c42, 0x2e23, 0x25bb,
	0x242b, 0x240f, 0x231a, 0x22bb, 0x2241, 0x2223, 0x221f, 0x1a33,
	0x1a4a, 0x1acd, 0x2132, 0x1b1b, 0x1b2c, 0x1b62, 0x1c12, 0x1c32,
	0x1d1b, 0x1e71, 0x16b1, 0x1522, 0x1434, 0x1412, 0x1352, 0x1323,
	0x1315, 0x12bc, 0x127a, 0x1235, 0x1226, 0x11a2, 0x1216, 0x0a2a,
	0x11bc, 0x11d1, 0x1163, 0x0ac2, 0x0ab2, 0x0aab, 0x0b1b, 0x0b23,
	0x0b33, 0x0c0f, 0x0bb3, 0x0c1b, 0x0c3e, 0x0cb1, 0x0d4c, 0x0ec1,
	0x079a, 0x0614, 0x0521, 0x047c, 0x0422, 0x03b1, 0x03e3, 0x0333,
	0x0322, 0x031c, 0x02aa, 0x02ba, 0x02f2, 0x0242, 0x0232, 0x0227,
	0x0222, 0x021b, 0x01ad, 0x0212, 0x01b2, 0x01bb, 0x01cb, 0x01f6,
	0x0152, 0x013a, 0x0133, 0x0131, 0x012c, 0x0123, 0x0122, 0x00a2,
	0x011b, 0x011e, 0x0114, 0x00b1, 0x00aa, 0x00b3, 0x00bd, 0x00ba,
	0x00c5, 0x00d3, 0x00f3, 0x0062, 0x0051, 0x0042, 0x003b, 0x0033,
	0x0032, 0x002a, 0x002c, 0x0025, 0x0023, 0x0022, 0x001a, 0x0021,
	0x001b, 0x001b, 0x001d, 0x0015, 0x0013, 0x0013, 0x0012, 0x0012,
	0x000a, 0x000a, 0x0011, 0x0011, 0x000b, 0x000b, 0x000c, 0x000e,
};

/*
 * second stage play gain.
 */
static const u_short ger_coeff[] = {
	0x431f, /* 5. dB */
	0x331f, /* 5.5 dB */
	0x40dd, /* 6. dB */
	0x11dd, /* 6.5 dB */
	0x440f, /* 7. dB */
	0x411f, /* 7.5 dB */
	0x311f, /* 8. dB */
	0x5520, /* 8.5 dB */
	0x10dd, /* 9. dB */
	0x4211, /* 9.5 dB */
	0x410f, /* 10. dB */
	0x111f, /* 10.5 dB */
	0x600b, /* 11. dB */
	0x00dd, /* 11.5 dB */
	0x4210, /* 12. dB */
	0x110f, /* 13. dB */
	0x7200, /* 14. dB */
	0x2110, /* 15. dB */
	0x2200, /* 15.9 dB */
	0x000b, /* 16.9 dB */
	0x000f  /* 18. dB */
#define NGER (sizeof(ger_coeff) / sizeof(ger_coeff[0]))
};

/*
 * Define our interface to the higher level audio driver.
 */
int	amd7930_open(void *, int);
void	amd7930_close(void *);
int	amd7930_query_encoding(void *, struct audio_encoding *);
int	amd7930_set_params(void *, int, int, struct audio_params *, struct audio_params *);
int	amd7930_round_blocksize(void *, int);
int	amd7930_commit_settings(void *);
int	amd7930_start_output(void *, void *, int, void (*)(void *), void *);
int	amd7930_start_input(void *, void *, int, void (*)(void *), void *);
int	amd7930_halt_output(void *);
int	amd7930_halt_input(void *);
int	amd7930_getdev(void *, struct audio_device *);
int	amd7930_set_port(void *, mixer_ctrl_t *);
int	amd7930_get_port(void *, mixer_ctrl_t *);
int	amd7930_query_devinfo(void *, mixer_devinfo_t *);
int	amd7930_get_props(void *);

struct audio_hw_if sa_hw_if = {
	amd7930_open,
	amd7930_close,
	NULL,
	amd7930_query_encoding,
	amd7930_set_params,
	amd7930_round_blocksize,
	amd7930_commit_settings,
	NULL,
	NULL,
	amd7930_start_output,
	amd7930_start_input,
	amd7930_halt_output,
	amd7930_halt_input,
	NULL,
	amd7930_getdev,
	NULL,
	amd7930_set_port,
	amd7930_get_port,
	amd7930_query_devinfo,
	NULL,
	NULL,
	NULL,
	NULL,
	amd7930_get_props,
	NULL,
	NULL,
	NULL
};

/* autoconfig routines */

int
amd7930match(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	register struct confargs *ca = aux;
	register struct romaux *ra = &ca->ca_ra;

	if (CPU_ISSUN4)
		return (0);
	return (strcmp(AUDIO_ROM_NAME, ra->ra_name) == 0);
}

/*
 * Audio chip found.
 */
void
amd7930attach(parent, self, args)
	struct device *parent, *self;
	void *args;
{
	register struct amd7930_softc *sc = (struct amd7930_softc *)self;
	register struct confargs *ca = args;
	register struct romaux *ra = &ca->ca_ra;
	register volatile struct amd7930 *amd;
	register int pri;

	if (ra->ra_nintr != 1) {
		printf(": expected 1 interrupt, got %d\n", ra->ra_nintr);
		return;
	}
	pri = ra->ra_intr[0].int_pri;
	printf(" pri %d, softpri %d\n", pri, IPL_AUSOFT);
	amd = (volatile struct amd7930 *)(ra->ra_vaddr ?
		ra->ra_vaddr : mapiodev(ra->ra_reg, 0, sizeof (*amd)));

	sc->sc_map.mr_mmr1 = AMD_MMR1_GX | AMD_MMR1_GER |
			     AMD_MMR1_GR | AMD_MMR1_STG;
	sc->sc_au.au_amd = amd;
	/* set boot defaults */
	sc->sc_rlevel = 128;
	sc->sc_plevel = 128;
	sc->sc_mlevel = 0;
	sc->sc_out_port = SUNAUDIO_SPEAKER;

	init_amd(amd);

	/*
	 * Register interrupt handlers.  We'll prefer a fast trap (unless
	 * AUDIO_C_HANDLER is defined), with a sharing callback so that we
	 * can revert into a regular trap vector if necessary.
	 */
#ifndef AUDIO_C_HANDLER
	sc->sc_hwih.ih_vec = pri;
	if (intr_fasttrap(pri, amd7930_trap, amd7930_shareintr, sc) == 0) {
		auiop = &sc->sc_au;
		evcount_attach(&sc->sc_hwih.ih_count, sc->sc_dev.dv_xname,
		    &sc->sc_hwih.ih_vec);
	} else {
#ifdef AUDIO_DEBUG
		printf("%s: unable to register fast trap handler\n",
		    self->dv_xname);
#endif
#else
	{
#endif
		sc->sc_hwih.ih_fun = amd7930hwintr;
		sc->sc_hwih.ih_arg = &sc->sc_au;
		intr_establish(pri, &sc->sc_hwih, IPL_AUHARD,
		    sc->sc_dev.dv_xname);
	}
	sc->sc_swih = softintr_establish(IPL_AUSOFT, amd7930swintr, sc);

	audio_attach_mi(&sa_hw_if, sc, &sc->sc_dev);
	amd7930_commit_settings(sc);
}

static void
init_amd(amd)
	register volatile struct amd7930 *amd;
{
	/* disable interrupts */
	amd->cr = AMDR_INIT;
	amd->dr = AMD_INIT_PMS_ACTIVE | AMD_INIT_INT_DISABLE;

	/*
	 * Initialize the mux unit.  We use MCR3 to route audio (MAP)
	 * through channel Bb.  MCR1 and MCR2 are unused.
	 * Setting the INT enable bit in MCR4 will generate an interrupt
	 * on each converted audio sample.
	 */
	amd->cr = AMDR_MUX_1_4;
 	amd->dr = 0;
	amd->dr = 0;
	amd->dr = (AMD_MCRCHAN_BB << 4) | AMD_MCRCHAN_BA;
	amd->dr = AMD_MCR4_INT_ENABLE;
}

int
amd7930_open(addr, flags)
	void *addr;
	int flags;
{
	struct amd7930_softc *sc = addr;

	DPRINTF(("sa_open: unit %p\n", sc));

	if (sc->sc_open)
		return (EBUSY);
	sc->sc_open = 1;
	sc->sc_locked = 0;
	sc->sc_rintr = 0;
	sc->sc_rarg = 0;
	sc->sc_pintr = 0;
	sc->sc_parg = 0;

	sc->sc_au.au_rdata = 0;
	sc->sc_au.au_pdata = 0;

	DPRINTF(("saopen: ok -> sc=0x%x\n",sc));

	return (0);
}

void
amd7930_close(addr)
	void *addr;
{
	register struct amd7930_softc *sc = addr;

	DPRINTF(("sa_close: sc=0x%x\n", sc));
	/*
	 * halt i/o, clear open flag, and done.
	 */
	amd7930_halt_input(sc);
	amd7930_halt_output(sc);
	sc->sc_open = 0;

	DPRINTF(("sa_close: closed.\n"));
}

int
amd7930_set_params(addr, setmode, usemode, p, r)
	void *addr;
	int setmode, usemode;
	struct audio_params *p, *r;
{
	p->encoding = AUDIO_ENCODING_ULAW;
	p->precision = 8;
	p->bps = 1;
	p->msb = 1;
	p->channels = 1; 
	/* no other rates supported by amd chip */
	p->sample_rate = 8000;

	return (0);
}  

int
amd7930_query_encoding(addr, fp)
	void *addr;
	struct audio_encoding *fp;
{
	switch (fp->index) {
	case 0:
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULAW;
		fp->precision = 8;
		fp->bps = 1;
		fp->msb = 1;
		fp->flags = 0;
		break;
	default:
		return (EINVAL);
		/*NOTREACHED*/
	}
	return (0);
}

int
amd7930_round_blocksize(addr, blk)
	void *addr;
	int blk;
{
	return (blk);
}

int
amd7930_commit_settings(addr)
	void *addr;
{
	register struct amd7930_softc *sc = addr;
	register struct mapreg *map;
	register volatile struct amd7930 *amd;
	register int s, level;

	DPRINTF(("sa_commit.\n"));

	map = &sc->sc_map;
	amd = sc->sc_au.au_amd;

	map->mr_gx = gx_coeff[sc->sc_rlevel];
	map->mr_stgr = gx_coeff[sc->sc_mlevel];

	level = (sc->sc_plevel * (256 + NGER)) >> 8;
	if (level >= 256) {
		map->mr_ger = ger_coeff[level - 256];
		map->mr_gr = gx_coeff[255];
	} else {
		map->mr_ger = ger_coeff[0];
		map->mr_gr = gx_coeff[level];
	}

	if (sc->sc_out_port == SUNAUDIO_SPEAKER)
		map->mr_mmr2 |= AMD_MMR2_LS;
	else
		map->mr_mmr2 &= ~AMD_MMR2_LS;

	s = splaudio();

	amd->cr = AMDR_MAP_MMR1;
	amd->dr = map->mr_mmr1;
	amd->cr = AMDR_MAP_GX;
	WAMD16(amd, map->mr_gx);
	amd->cr = AMDR_MAP_STG;
	WAMD16(amd, map->mr_stgr);
	amd->cr = AMDR_MAP_GR;
	WAMD16(amd, map->mr_gr);
	amd->cr = AMDR_MAP_GER;
	WAMD16(amd, map->mr_ger);
	amd->cr = AMDR_MAP_MMR2;
	amd->dr = map->mr_mmr2;

	splx(s);
	return (0);
}

int
amd7930_start_output(addr, p, cc, intr, arg)
	void *addr;
	void *p;
	int cc;
	void (*intr)(void *);
	void *arg;
{
	register struct amd7930_softc *sc = addr;

#ifdef AUDIO_DEBUG
	if (amd7930debug > 1)
		printf("sa_start_output: cc=%d 0x%x (0x%x)\n", cc, intr, arg);
#endif

	if (!sc->sc_locked) {
		register volatile struct amd7930 *amd;

		amd = sc->sc_au.au_amd;
		amd->cr = AMDR_INIT;
		amd->dr = AMD_INIT_PMS_ACTIVE;
		sc->sc_locked = 1;
		DPRINTF(("sa_start_output: started intrs.\n"));
	}
	sc->sc_pintr = intr;
	sc->sc_parg = arg;
	sc->sc_au.au_pdata = p;
	sc->sc_au.au_pend = p + cc - 1;
	return (0);
}

/* ARGSUSED */
int
amd7930_start_input(addr, p, cc, intr, arg)
	void *addr;
	void *p;
	int cc;
	void (*intr)(void *);
	void *arg;
{
	register struct amd7930_softc *sc = addr;

#ifdef AUDIO_DEBUG
	if (amd7930debug > 1)
		printf("sa_start_input: cc=%d 0x%x (0x%x)\n", cc, intr, arg);
#endif

	if (!sc->sc_locked) {
		register volatile struct amd7930 *amd;

		amd = sc->sc_au.au_amd;
		amd->cr = AMDR_INIT;
		amd->dr = AMD_INIT_PMS_ACTIVE;
		sc->sc_locked = 1;
		DPRINTF(("sa_start_input: started intrs.\n"));
	}
	sc->sc_rintr = intr;
	sc->sc_rarg = arg;
	sc->sc_au.au_rdata = p;
	sc->sc_au.au_rend = p + cc -1;
	return (0);
}

int
amd7930_halt_output(addr)
	void *addr;
{
	register struct amd7930_softc *sc = addr;
	register volatile struct amd7930 *amd;

	/* XXX only halt, if input is also halted ?? */
	amd = sc->sc_au.au_amd;
	amd->cr = AMDR_INIT;
	amd->dr = AMD_INIT_PMS_ACTIVE | AMD_INIT_INT_DISABLE;
	sc->sc_locked = 0;

	return (0);
}

int
amd7930_halt_input(addr)
	void *addr;
{
	register struct amd7930_softc *sc = addr;
	register volatile struct amd7930 *amd;

	/* XXX only halt, if output is also halted ?? */
	amd = sc->sc_au.au_amd;
	amd->cr = AMDR_INIT;
	amd->dr = AMD_INIT_PMS_ACTIVE | AMD_INIT_INT_DISABLE;
	sc->sc_locked = 0;

	return (0);
}

int
amd7930_getdev(addr, retp)
        void *addr;
        struct audio_device *retp;
{
        *retp = amd7930_device;
        return (0);
}

int
amd7930_set_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
{
	register struct amd7930_softc *sc = addr;

	DPRINTF(("amd7930_set_port: port=%d type=%d\n", cp->dev, cp->type));

	if (cp->dev == SUNAUDIO_SOURCE || cp->dev == SUNAUDIO_OUTPUT) {
		if (cp->type != AUDIO_MIXER_ENUM)
			return (EINVAL);
	}
	else if (cp->type != AUDIO_MIXER_VALUE ||
	    cp->un.value.num_channels != 1)
		return (EINVAL);

	switch(cp->dev) {
	case SUNAUDIO_MIC_PORT:
		sc->sc_rlevel = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
		break;
	case SUNAUDIO_SPEAKER:
	case SUNAUDIO_HEADPHONES:
		sc->sc_plevel = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
		break;
	case SUNAUDIO_MONITOR:
		sc->sc_mlevel = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
		break;
	case SUNAUDIO_SOURCE:
		if (cp->un.ord != SUNAUDIO_MIC_PORT)
			return (EINVAL);
		break;
	case SUNAUDIO_OUTPUT:
		if (cp->un.ord != SUNAUDIO_SPEAKER &&
		    cp->un.ord != SUNAUDIO_HEADPHONES)
			return (EINVAL);
		sc->sc_out_port = cp->un.ord;
		break;
	default:
		return (EINVAL);
		/* NOTREACHED */
	}
	return (0);
}

int
amd7930_get_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
{
	register struct amd7930_softc *sc = addr;

	DPRINTF(("amd7930_get_port: port=%d type=%d\n", cp->dev, cp->type));

	if (cp->dev == SUNAUDIO_SOURCE || cp->dev == SUNAUDIO_OUTPUT) {
		if (cp->type != AUDIO_MIXER_ENUM)
			return (EINVAL);
	}
	else if (cp->type != AUDIO_MIXER_VALUE ||
	    cp->un.value.num_channels != 1)
		return (EINVAL);

	switch(cp->dev) {
	case SUNAUDIO_MIC_PORT:
		cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = sc->sc_rlevel;
		break;
	case SUNAUDIO_SPEAKER:
	case SUNAUDIO_HEADPHONES:
		cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = sc->sc_plevel;
		break;
	case SUNAUDIO_MONITOR:
		cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = sc->sc_mlevel;
		break;
	case SUNAUDIO_SOURCE:
		cp->un.ord = SUNAUDIO_MIC_PORT;
		break;
	case SUNAUDIO_OUTPUT:
		cp->un.ord = sc->sc_out_port;
		break;
	default:
		return (EINVAL);
		/* NOTREACHED */
	}
	return (0);
}

int
amd7930_get_props(addr)
	void *addr;
{
	return (AUDIO_PROP_FULLDUPLEX);
}       

int
amd7930_query_devinfo(addr, dip)
	void *addr;
	register mixer_devinfo_t *dip;
{
	switch(dip->index) {
	case SUNAUDIO_MIC_PORT:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = SUNAUDIO_INPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNmicrophone, sizeof dip->label.name);
		dip->un.v.num_channels = 1;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;
	case SUNAUDIO_SPEAKER:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = SUNAUDIO_OUTPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNspeaker, sizeof dip->label.name);
		dip->un.v.num_channels = 1;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;
	case SUNAUDIO_HEADPHONES:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = SUNAUDIO_OUTPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNheadphone, sizeof dip->label.name);
		dip->un.v.num_channels = 1;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->label.name);
		break;
	case SUNAUDIO_MONITOR:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = SUNAUDIO_OUTPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNmonitor, sizeof dip->label.name);
		dip->un.v.num_channels = 1;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->label.name);
		break;
	case SUNAUDIO_SOURCE:
		dip->type = AUDIO_MIXER_ENUM;
		dip->mixer_class = SUNAUDIO_RECORD_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
		dip->un.e.num_mem = 1;
		strlcpy(dip->un.e.member[0].label.name, AudioNmicrophone,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = SUNAUDIO_MIC_PORT;
		break;
	case SUNAUDIO_OUTPUT:
		dip->type = AUDIO_MIXER_ENUM;
		dip->mixer_class = SUNAUDIO_MONITOR_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, AudioNspeaker,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = SUNAUDIO_SPEAKER;
		strlcpy(dip->un.e.member[1].label.name, AudioNheadphone,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[1].ord = SUNAUDIO_HEADPHONES;
		break;
	case SUNAUDIO_INPUT_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = SUNAUDIO_INPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
		break;
	case SUNAUDIO_OUTPUT_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = SUNAUDIO_OUTPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
		break;
	case SUNAUDIO_RECORD_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = SUNAUDIO_RECORD_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
		break;
	case SUNAUDIO_MONITOR_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = SUNAUDIO_MONITOR_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCmonitor, sizeof dip->label.name);
		break;
	default:
		return (ENXIO);
		/*NOTREACHED*/
	}

	DPRINTF(("AUDIO_MIXER_DEVINFO: name=%s\n", dip->label.name));

	return (0);
}

int
amd7930hwintr(au0)
	void *au0;
{
	register struct auio *au = au0;
	register volatile struct amd7930 *amd = au->au_amd;
	register u_char *d, *e;
	register int k;

	k = amd->ir;		/* clear interrupt */

	/* receive incoming data */
	d = au->au_rdata;
	e = au->au_rend;
	if (d && d <= e) {
		*d = amd->bbrb;
		au->au_rdata++;
		if (d == e) {
#ifdef AUDIO_DEBUG
		        if (amd7930debug > 1)
                		printf("amd7930hwintr: swintr(r) requested");
#endif
			softintr_schedule(au->au_swih);
		}
	}

	/* send outgoing data */
	d = au->au_pdata;
	e = au->au_pend;
	if (d && d <= e) {
		amd->bbtb = *d;
		au->au_pdata++;
		if (d == e) {
#ifdef AUDIO_DEBUG
		        if (amd7930debug > 1)
                		printf("amd7930hwintr: swintr(p) requested");
#endif
			softintr_schedule(au->au_swih);
		}
	}

	return (-1);
}

void
amd7930swintr(sc0)
	void *sc0;
{
	struct amd7930_softc *sc = sc0;
	struct auio *au;
	int s;

#ifdef AUDIO_DEBUG
	if (amd7930debug > 1)
		printf("audiointr: sc=0x%x\n",sc);
#endif

	au = &sc->sc_au;
	s = splaudio();
	if (au->au_rdata > au->au_rend && sc->sc_rintr != NULL) {
		splx(s);
		(*sc->sc_rintr)(sc->sc_rarg);
		s = splaudio();
	}
	if (au->au_pdata > au->au_pend && sc->sc_pintr != NULL) {
		splx(s);
		(*sc->sc_pintr)(sc->sc_parg);
	} else
		splx(s);
}

#ifndef AUDIO_C_HANDLER
int
amd7930_shareintr(void *arg)
{
	struct amd7930_softc *sc = arg;

	/*
	 * We are invoked at splhigh(), so there is no need to prevent the chip
	 * from interrupting while we are messing with the handlers. We
	 * however need to properly untie the event counter from the chain,
	 * since it will be reused immediately by intr_establish()...
	 */

	intr_fastuntrap(sc->sc_hwih.ih_vec);
	evcount_detach(&sc->sc_hwih.ih_count);

	sc->sc_hwih.ih_fun = amd7930hwintr;
	sc->sc_hwih.ih_arg = &sc->sc_au;
	intr_establish(sc->sc_hwih.ih_vec, &sc->sc_hwih, IPL_AUHARD,
	    sc->sc_dev.dv_xname);

	return (0);
}
#endif
@


1.34
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.33 2010/07/15 03:43:11 jakemsr Exp $	*/
@


1.33
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.32 2009/04/10 20:53:51 miod Exp $	*/
d302 1
a302 1
		    &sc->sc_hwih.ih_vec, &evcount_intr);
@


1.32
log
@generic soft interrupts support for sparc. Soft interrupt handlers are now
kept in a separate intrhand array, with their own enable bits so that
soft interrupts sharing the same level only get invoked if really triggered.
Inspired by NetBSD with significant changes.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.31 2008/04/21 00:32:42 jakemsr Exp $	*/
d392 7
a398 6
	if (p->sample_rate < 7500 || p->sample_rate > 8500 ||
	    p->encoding != AUDIO_ENCODING_ULAW ||
	    p->precision != 8 ||
	    p->channels != 1) 
		return (EINVAL);
	p->sample_rate = 8000;	/* no other rates supported by amd chip */     
d413 2
@


1.31
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.30 2005/08/14 10:58:33 miod Exp $	*/
a68 1
	struct	intrhand sc_swih;	/* software interrupt vector */
d88 1
a90 12
/* interrupt interfaces */
#if defined(SUN4M)
#define AUDIO_SET_SWINTR do {		\
	if (CPU_ISSUN4M)		\
		raise(0, 4);		\
	else				\
		ienab_bis(IE_L4);	\
} while(0);
#else
#define AUDIO_SET_SWINTR ienab_bis(IE_L4)
#endif /* defined(SUN4M) */

d95 1
a95 1
int	amd7930swintr(void *);
d316 1
a316 4
	sc->sc_swih.ih_fun = amd7930swintr;
	sc->sc_swih.ih_arg = sc;
	intr_establish(IPL_AUSOFT, &sc->sc_swih, IPL_AUSOFT,
	    sc->sc_dev.dv_xname);
d797 1
a797 1
			AUDIO_SET_SWINTR;
d812 1
a812 1
			AUDIO_SET_SWINTR;
d819 1
a819 1
int
d823 3
a825 3
	register struct amd7930_softc *sc = sc0;
	register struct auio *au;
	register int s, ret = 0;
a835 1
		ret = 1;
a840 1
		ret = 1;
a843 1
	return (ret);
@


1.30
log
@Add more flexibility to the fast trap handlers mechanism:
- add the ability to deregister a fast trap handler.
- when registering a fast trap, provide an optional callback which will be
  invoked if we try to register a regular trap handler later; the callback
  will be responsible to replace the fast trap handler with a regular trap
  handler (and is allowed to fail).

Alter audioamd(4) to take advantage of this, so that it can share its
interrupt with stp(4) on SPARCclassic machines.

Problem found the hard way and fix tested by Jason George; discussed and
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.29 2005/07/09 22:23:13 miod Exp $	*/
d250 1
@


1.29
log
@Do not #include "foo.h" and keep the whole file between #if NFOO >0 ... #endif,
config(8) will not bring us into play unless NFOO > 0 anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.28 2004/09/29 07:35:11 miod Exp $	*/
d60 5
a91 2
#ifdef AUDIO_C_HANDLER
int	amd7930hwintr(void *);
d102 2
a103 1
#else
d106 1
d112 1
d303 5
a308 1
	auiop = &sc->sc_au;
d310 9
a318 3
	evcount_attach(&sc->sc_hwih.ih_count, sc->sc_dev.dv_xname,
	    &sc->sc_hwih.ih_vec, &evcount_intr);
	intr_fasttrap(pri, amd7930_trap);
d320 1
a320 3
	sc->sc_hwih.ih_fun = amd7930hwintr;
	sc->sc_hwih.ih_arg = &sc->sc_au;
	intr_establish(pri, &sc->sc_hwih, IPL_AUHARD, sc->sc_dev.dv_xname);
d322 5
a788 1
#ifdef AUDIO_C_HANDLER
a831 1
#endif /* AUDIO_C_HANDLER */
d862 25
@


1.28
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.27 2003/11/03 07:01:33 david Exp $	*/
a33 3
#include "audio.h"
#if NAUDIO > 0

a844 1
#endif /* NAUDIO > 0 */
@


1.27
log
@spelling fixes (in the comments)
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.26 2003/06/28 20:53:02 deraadt Exp $	*/
a66 1
	struct	intrhand sc_hwih;	/* hardware interrupt vector */
d86 1
a86 1
#define sc_intrcnt	sc_au.au_intrcnt	/* statistics */
d302 3
d309 1
a309 1
	intr_establish(pri, &sc->sc_hwih, IPL_AUHARD);
d313 2
a314 3
	intr_establish(IPL_AUSOFT, &sc->sc_swih, IPL_AUSOFT);

	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);
a814 1
	au->au_intrcnt.ev_count++;
@


1.26
log
@back out that which does not compile
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.23 2003/05/11 19:41:12 deraadt Exp $	*/
d71 1
a71 1
	int	sc_locked;		/* true when transfering data */
@


1.25
log
@grr... committed previous from the wrong tree... fixed version, which also
adds alaw:8 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.24 2003/06/28 18:12:31 jason Exp $	*/
a48 1
#include <dev/mulaw.h>
d390 3
a392 1
	    p->precision != 8 || p->channels != 1) 
d394 1
a395 24
	switch (p->encoding) {
	case AUDIO_ENCODING_ULAW:
		break;
	case AUDIO_ENCODING_SLINEAR:
	case AUDIO_ENCODING_SLINEAR_BE:
	case AUDIO_ENCODING_SLINEAR_LE:
		p->sw_code = slinear8_to_mulaw;
		r->sw_code = mulaw_to_slinear8;
		break;
	case AUDIO_ENCODING_ULINEAR:
	case AUDIO_ENCODING_ULINEAR_BE:
	case AUDIO_ENCODING_ULINEAR_LE:
		p->sw_code = ulinear8_to_mulaw;
		r->sw_code = mulaw_to_ulinear8;
		break;
	case AUDIO_ENCODING_ALAW:
		p->sw_code = alaw_to_mulaw;
		r->sw_code = mulaw_to_alaw;
		break;
	default:
		return (EINVAL);
	}

	p->sample_rate = 8000;	/* no other rates supported by amd chip */     
a409 18
		break;
	case 1:
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 2:
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 3:
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ALAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
@


1.24
log
@add emulations for slinear:8 and ulinear:8; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.23 2003/05/11 19:41:12 deraadt Exp $	*/
d398 2
d404 2
d409 4
d442 6
@


1.23
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.22 2002/04/30 01:12:28 art Exp $	*/
d49 1
d391 1
a391 3
	    p->encoding != AUDIO_ENCODING_ULAW ||
	    p->precision != 8 ||
	    p->channels != 1) 
d393 16
a409 1

d424 12
@


1.22
log
@Fix an ancient problem in how sparc interrupts are handled.

There are many interrupt handlers that assume that they don't need to do
any spl protection in their code because the interrupt of some level can't
be interrupted by an interrupt of the same level. The problem is that some
interrupt handlers have hardware levels that are lower then their "software"
levels.

Fix this by adding an additional field to struct intrhand that specifies which
"software" level an interrupt handler has and blocks that level while handling
the interrupt. This new field is initialized in intr_establish which gets
an additional argument (which can be -1 meaning that the interrupt handler
doesn't need to block any additional level).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.21 2002/04/28 03:51:19 art Exp $	*/
d406 1
a406 1
		strcpy(fp->name, AudioEmulaw);
d683 1
a683 1
		strcpy(dip->label.name, AudioNmicrophone);
d685 2
a686 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d692 1
a692 1
		strcpy(dip->label.name, AudioNspeaker);
d694 2
a695 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d701 1
a701 1
		strcpy(dip->label.name, AudioNheadphone);
d703 2
a704 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d710 1
a710 1
		strcpy(dip->label.name, AudioNmonitor);
d712 2
a713 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d719 1
a719 1
		strcpy(dip->label.name, AudioNsource);
d721 2
a722 1
		strcpy(dip->un.e.member[0].label.name, AudioNmicrophone);
d729 1
a729 1
		strcpy(dip->label.name, AudioNoutput);
d731 2
a732 1
		strcpy(dip->un.e.member[0].label.name, AudioNspeaker);
d734 2
a735 1
		strcpy(dip->un.e.member[1].label.name, AudioNheadphone);
d742 1
a742 1
		strcpy(dip->label.name, AudioCinputs);
d748 1
a748 1
		strcpy(dip->label.name, AudioCoutputs);
d754 1
a754 1
		strcpy(dip->label.name, AudioCrecord);
d760 1
a760 1
		strcpy(dip->label.name, AudioCmonitor);
@


1.21
log
@Rename all PIL_* constants to IPL_* to match other archs and make them
usable in MD code in the future.
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.20 2002/03/14 03:15:59 millert Exp $	*/
d307 1
a307 1
	intr_establish(pri, &sc->sc_hwih);
d311 1
a311 1
	intr_establish(IPL_AUSOFT, &sc->sc_swih);
@


1.20
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.19 2002/03/14 01:26:42 millert Exp $	*/
d286 1
a286 1
	printf(" pri %d, softpri %d\n", pri, PIL_AUSOFT);
d311 1
a311 1
	intr_establish(PIL_AUSOFT, &sc->sc_swih);
@


1.19
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.18 1999/08/06 01:26:49 jason Exp $	*/
d80 1
a80 1
	void	(*sc_rintr)(void*);	/* input completion intr handler */
d82 1
a82 1
	void	(*sc_pintr)(void*);	/* output completion intr handler */
d213 2
a214 4
int	amd7930_start_output __P((void *, void *, int, void (*)(void *),
				  void *));
int	amd7930_start_input __P((void *, void *, int, void (*)(void *),
				 void *));
@


1.18
log
@take advantage of new interrupt handler #ifdef AUDIO_C_HANDLER
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.17 1999/05/28 21:33:55 jason Exp $	*/
d92 1
a92 1
int	amd7930hwintr __P((void *));
d106 1
a106 1
int	amd7930swintr __P((void *));
d109 2
a110 2
void	audio_setmap __P((volatile struct amd7930 *, struct mapreg *));
static void init_amd __P((volatile struct amd7930 *));
d113 2
a114 2
void	amd7930attach __P((struct device *, struct device *, void *));
int	amd7930match __P((struct device *, void *, void *));
d207 6
a212 6
int	amd7930_open __P((void *, int));
void	amd7930_close __P((void *));
int	amd7930_query_encoding __P((void *, struct audio_encoding *));
int	amd7930_set_params __P((void *, int, int, struct audio_params *, struct audio_params *));
int	amd7930_round_blocksize __P((void *, int));
int	amd7930_commit_settings __P((void *));
d217 7
a223 7
int	amd7930_halt_output __P((void *));
int	amd7930_halt_input __P((void *));
int	amd7930_getdev __P((void *, struct audio_device *));
int	amd7930_set_port __P((void *, mixer_ctrl_t *));
int	amd7930_get_port __P((void *, mixer_ctrl_t *));
int	amd7930_query_devinfo __P((void *, mixer_devinfo_t *));
int	amd7930_get_props __P((void *));
d483 1
a483 1
	void (*intr) __P((void *));
d515 1
a515 1
	void (*intr) __P((void *));
@


1.18.14.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.18 1999/08/06 01:26:49 jason Exp $	*/
d80 1
a80 1
	void	(*sc_rintr)(void *);	/* input completion intr handler */
d82 1
a82 1
	void	(*sc_pintr)(void *);	/* output completion intr handler */
d92 1
a92 1
int	amd7930hwintr(void *);
d106 1
a106 1
int	amd7930swintr(void *);
d109 2
a110 2
void	audio_setmap(volatile struct amd7930 *, struct mapreg *);
static void init_amd(volatile struct amd7930 *);
d113 2
a114 2
void	amd7930attach(struct device *, struct device *, void *);
int	amd7930match(struct device *, void *, void *);
d207 17
a223 15
int	amd7930_open(void *, int);
void	amd7930_close(void *);
int	amd7930_query_encoding(void *, struct audio_encoding *);
int	amd7930_set_params(void *, int, int, struct audio_params *, struct audio_params *);
int	amd7930_round_blocksize(void *, int);
int	amd7930_commit_settings(void *);
int	amd7930_start_output(void *, void *, int, void (*)(void *), void *);
int	amd7930_start_input(void *, void *, int, void (*)(void *), void *);
int	amd7930_halt_output(void *);
int	amd7930_halt_input(void *);
int	amd7930_getdev(void *, struct audio_device *);
int	amd7930_set_port(void *, mixer_ctrl_t *);
int	amd7930_get_port(void *, mixer_ctrl_t *);
int	amd7930_query_devinfo(void *, mixer_devinfo_t *);
int	amd7930_get_props(void *);
d288 1
a288 1
	printf(" pri %d, softpri %d\n", pri, IPL_AUSOFT);
d309 1
a309 1
	intr_establish(pri, &sc->sc_hwih, IPL_AUHARD);
d313 1
a313 1
	intr_establish(IPL_AUSOFT, &sc->sc_swih, IPL_AUSOFT);
d483 1
a483 1
	void (*intr)(void *);
d515 1
a515 1
	void (*intr)(void *);
@


1.18.14.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d406 1
a406 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d683 1
a683 1
		strlcpy(dip->label.name, AudioNmicrophone, sizeof dip->label.name);
d685 1
a685 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d691 1
a691 1
		strlcpy(dip->label.name, AudioNspeaker, sizeof dip->label.name);
d693 1
a693 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d699 1
a699 1
		strlcpy(dip->label.name, AudioNheadphone, sizeof dip->label.name);
d701 1
a701 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->label.name);
d707 1
a707 1
		strlcpy(dip->label.name, AudioNmonitor, sizeof dip->label.name);
d709 1
a709 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->label.name);
d715 1
a715 1
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d717 1
a717 2
		strlcpy(dip->un.e.member[0].label.name, AudioNmicrophone,
		    sizeof dip->un.e.member[0].label.name);
d724 1
a724 1
		strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
d726 1
a726 2
		strlcpy(dip->un.e.member[0].label.name, AudioNspeaker,
		    sizeof dip->un.e.member[0].label.name);
d728 1
a728 2
		strlcpy(dip->un.e.member[1].label.name, AudioNheadphone,
		    sizeof dip->un.e.member[0].label.name);
d735 1
a735 1
		strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
d741 1
a741 1
		strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
d747 1
a747 1
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
d753 1
a753 1
		strlcpy(dip->label.name, AudioCmonitor, sizeof dip->label.name);
@


1.18.4.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d80 1
a80 1
	void	(*sc_rintr)(void *);	/* input completion intr handler */
d82 1
a82 1
	void	(*sc_pintr)(void *);	/* output completion intr handler */
d92 1
a92 1
int	amd7930hwintr(void *);
d106 1
a106 1
int	amd7930swintr(void *);
d109 2
a110 2
void	audio_setmap(volatile struct amd7930 *, struct mapreg *);
static void init_amd(volatile struct amd7930 *);
d113 2
a114 2
void	amd7930attach(struct device *, struct device *, void *);
int	amd7930match(struct device *, void *, void *);
d207 17
a223 15
int	amd7930_open(void *, int);
void	amd7930_close(void *);
int	amd7930_query_encoding(void *, struct audio_encoding *);
int	amd7930_set_params(void *, int, int, struct audio_params *, struct audio_params *);
int	amd7930_round_blocksize(void *, int);
int	amd7930_commit_settings(void *);
int	amd7930_start_output(void *, void *, int, void (*)(void *), void *);
int	amd7930_start_input(void *, void *, int, void (*)(void *), void *);
int	amd7930_halt_output(void *);
int	amd7930_halt_input(void *);
int	amd7930_getdev(void *, struct audio_device *);
int	amd7930_set_port(void *, mixer_ctrl_t *);
int	amd7930_get_port(void *, mixer_ctrl_t *);
int	amd7930_query_devinfo(void *, mixer_devinfo_t *);
int	amd7930_get_props(void *);
d483 1
a483 1
	void (*intr)(void *);
d515 1
a515 1
	void (*intr)(void *);
@


1.18.4.2
log
@Sync the SMP branch with 3.3
@
text
@d286 1
a286 1
	printf(" pri %d, softpri %d\n", pri, IPL_AUSOFT);
d307 1
a307 1
	intr_establish(pri, &sc->sc_hwih, IPL_AUHARD);
d311 1
a311 1
	intr_establish(IPL_AUSOFT, &sc->sc_swih, IPL_AUSOFT);
@


1.18.4.3
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.18.4.2 2003/03/27 23:49:25 niklas Exp $	*/
d406 1
a406 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d683 1
a683 1
		strlcpy(dip->label.name, AudioNmicrophone, sizeof dip->label.name);
d685 1
a685 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d691 1
a691 1
		strlcpy(dip->label.name, AudioNspeaker, sizeof dip->label.name);
d693 1
a693 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d699 1
a699 1
		strlcpy(dip->label.name, AudioNheadphone, sizeof dip->label.name);
d701 1
a701 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->label.name);
d707 1
a707 1
		strlcpy(dip->label.name, AudioNmonitor, sizeof dip->label.name);
d709 1
a709 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->label.name);
d715 1
a715 1
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d717 1
a717 2
		strlcpy(dip->un.e.member[0].label.name, AudioNmicrophone,
		    sizeof dip->un.e.member[0].label.name);
d724 1
a724 1
		strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
d726 1
a726 2
		strlcpy(dip->un.e.member[0].label.name, AudioNspeaker,
		    sizeof dip->un.e.member[0].label.name);
d728 1
a728 2
		strlcpy(dip->un.e.member[1].label.name, AudioNheadphone,
		    sizeof dip->un.e.member[0].label.name);
d735 1
a735 1
		strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
d741 1
a741 1
		strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
d747 1
a747 1
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
d753 1
a753 1
		strlcpy(dip->label.name, AudioCmonitor, sizeof dip->label.name);
@


1.18.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d71 1
a71 1
	int	sc_locked;		/* true when transferring data */
@


1.17
log
@fix up audio_if interfaces and debugging code (allows switching between
speaker/headphones again, etc).
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.16 1999/04/18 03:16:46 jason Exp $	*/
d810 1
a810 1
	return (1);
@


1.16
log
@make AUDIO_C_HANDLER compile again
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.15 1999/01/02 00:02:49 niklas Exp $	*/
a55 2
extern void Dprintf __P((const char *, ...));

d57 1
a57 1
#define DPRINTF(x)      if (amd7930debug) Dprintf x
d318 1
d490 1
a490 1
		Dprintf("sa_start_output: cc=%d 0x%x (0x%x)\n", cc, intr, arg);
d522 1
a522 1
		Dprintf("sa_start_input: cc=%d 0x%x (0x%x)\n", cc, intr, arg);
d589 1
a589 1
	DPRINTF(("amd7930_set_port: port=%d", cp->dev));
d591 6
a596 1
	if (cp->type != AUDIO_MIXER_VALUE || cp->un.value.num_channels != 1)
d610 10
d634 1
a634 1
	DPRINTF(("amd7930_get_port: port=%d", cp->dev));
d636 6
a641 1
	if (cp->type != AUDIO_MIXER_VALUE || cp->un.value.num_channels != 1)
d655 6
d713 20
d745 12
d788 1
a788 1
                		Dprintf("amd7930hwintr: swintr(r) requested");
d803 1
a803 1
                		Dprintf("amd7930hwintr: swintr(p) requested");
d824 1
a824 1
		Dprintf("audiointr: sc=0x%x\n",sc);
@


1.15
log
@Midi & sequencer support from NetBSD, mostly by Lennart Augustsson
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.14 1998/11/03 21:22:36 downsj Exp $	*/
d752 1
a752 1
	*(au->au_intrcnt)++;
@


1.14
log
@Update audio_hw_if.
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.13 1998/07/14 05:38:58 jason Exp $	*/
d319 1
a319 1
	audio_attach_mi(&sa_hw_if, 0, sc, &sc->sc_dev);
@


1.13
log
@Use AudioEmulaw string and set precision & flags
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.12 1998/05/14 10:19:12 niklas Exp $	*/
d230 1
a230 1
	0,
d235 2
a236 2
	0,
	0,
d241 1
a241 1
	0,
d243 1
a243 1
	0,
d247 4
a250 4
	0,
	0,
	0,
	0,
d252 2
@


1.12
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.11 1998/04/30 06:13:00 jason Exp $	*/
d405 1
a405 1
	switch (fp->index) {	/* ??? */
d407 1
a407 1
		strcpy(fp->name, "MU-Law");
d409 2
@


1.11
log
@Updated sparc audio
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.10 1997/09/17 06:47:06 downsj Exp $	*/
d214 1
a214 1
int	amd7930_commit_settings __P((void *t));
d348 1
a348 1
	DPRINTF(("sa_open: unit %d\n",sc));
d394 2
a395 3
		return EINVAL;
	p->sample_rate = 8000;	/* no other sampling rates supported by amd chip
 */     
d397 1
a397 1
	return 0;
d406 7
a412 7
	    case 0:
		    strcpy(fp->name, "MU-Law");
		    fp->encoding = AUDIO_ENCODING_ULAW;
		    break;
	    default:
		    return(EINVAL);
		    /*NOTREACHED*/
d414 1
a414 1
	return(0);
d422 1
a422 1
	return(blk);
d472 1
a472 1
	return(0);
d503 1
a503 1
	return(0);
d535 1
a535 1
	return(0);
d551 1
a551 1
	return(0);
d567 1
a567 1
	return(0);
d576 1
a576 1
        return 0;
d589 1
a589 1
		return(EINVAL);
d592 13
a604 13
	    case SUNAUDIO_MIC_PORT:
		    sc->sc_rlevel = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
		    break;
	    case SUNAUDIO_SPEAKER:
	    case SUNAUDIO_HEADPHONES:
		    sc->sc_plevel = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
		    break;
	    case SUNAUDIO_MONITOR:
		    sc->sc_mlevel = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
		    break;
	    default:
		    return(EINVAL);
		    /* NOTREACHED */
d606 1
a606 1
	return(0);
d619 1
a619 1
		return(EINVAL);
d622 13
a634 13
	    case SUNAUDIO_MIC_PORT:
		    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = sc->sc_rlevel;
		    break;
	    case SUNAUDIO_SPEAKER:
	    case SUNAUDIO_HEADPHONES:
		    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = sc->sc_plevel;
		    break;
	    case SUNAUDIO_MONITOR:
		    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = sc->sc_mlevel;
		    break;
	    default:
		    return(EINVAL);
		    /* NOTREACHED */
d636 1
a636 1
	return(0);
d643 1
a643 1
	return AUDIO_PROP_FULLDUPLEX;
d652 47
a698 47
	    case SUNAUDIO_MIC_PORT:
		    dip->type = AUDIO_MIXER_VALUE;
		    dip->mixer_class = SUNAUDIO_INPUT_CLASS;
		    dip->prev = dip->next = AUDIO_MIXER_LAST;
		    strcpy(dip->label.name, AudioNmicrophone);
		    dip->un.v.num_channels = 1;
		    strcpy(dip->un.v.units.name, AudioNvolume);
		    break;
	    case SUNAUDIO_SPEAKER:
		    dip->type = AUDIO_MIXER_VALUE;
		    dip->mixer_class = SUNAUDIO_OUTPUT_CLASS;
		    dip->prev = dip->next = AUDIO_MIXER_LAST;
		    strcpy(dip->label.name, AudioNspeaker);
		    dip->un.v.num_channels = 1;
		    strcpy(dip->un.v.units.name, AudioNvolume);
		    break;
	    case SUNAUDIO_HEADPHONES:
		    dip->type = AUDIO_MIXER_VALUE;
		    dip->mixer_class = SUNAUDIO_OUTPUT_CLASS;
		    dip->prev = dip->next = AUDIO_MIXER_LAST;
		    strcpy(dip->label.name, AudioNheadphone);
		    dip->un.v.num_channels = 1;
		    strcpy(dip->un.v.units.name, AudioNvolume);
		    break;
	    case SUNAUDIO_MONITOR:
		    dip->type = AUDIO_MIXER_VALUE;
		    dip->mixer_class = SUNAUDIO_OUTPUT_CLASS;
		    dip->next = dip->prev = AUDIO_MIXER_LAST;
		    strcpy(dip->label.name, AudioNmonitor);
		    dip->un.v.num_channels = 1;
		    strcpy(dip->un.v.units.name, AudioNvolume);
		    break;
	    case SUNAUDIO_INPUT_CLASS:
		    dip->type = AUDIO_MIXER_CLASS;
		    dip->mixer_class = SUNAUDIO_INPUT_CLASS;
		    dip->next = dip->prev = AUDIO_MIXER_LAST;
		    strcpy(dip->label.name, AudioCinputs);
		    break;
	    case SUNAUDIO_OUTPUT_CLASS:
		    dip->type = AUDIO_MIXER_CLASS;
		    dip->mixer_class = SUNAUDIO_OUTPUT_CLASS;
		    dip->next = dip->prev = AUDIO_MIXER_LAST;
		    strcpy(dip->label.name, AudioCoutputs);
		    break;
	    default:
		    return ENXIO;
		    /*NOTREACHED*/
d703 1
a703 1
	return(0);
@


1.10
log
@NETBSD_CURRENT_970916.  Lot's just ID changes, since changes don't apply to
us.  Includes some pmap changes, for which I don't have the original commit
message(s) handy.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: amd7930.c,v 1.30 1997/08/27 22:42:23 augustss Exp $	*/
d209 1
a209 1
int	amd7930_open __P((dev_t, int));
a210 4
int	amd7930_set_in_sr __P((void *, u_long));
u_long	amd7930_get_in_sr __P((void *));
int	amd7930_set_out_sr __P((void *, u_long));
u_long	amd7930_get_out_sr __P((void *));
d212 1
a212 5
int	amd7930_set_format __P((void *, u_int, u_int));
int	amd7930_get_encoding __P((void *));
int	amd7930_get_precision __P((void *));
int	amd7930_set_channels __P((void *, int));
int	amd7930_get_channels __P((void *));
d214 1
a214 6
int	amd7930_set_out_port __P((void *, int));
int	amd7930_get_out_port __P((void *));
int	amd7930_set_in_port __P((void *, int));
int	amd7930_get_in_port __P((void *));
int	amd7930_commit_settings __P((void *));
u_int	amd7930_get_silence __P((int));
a220 2
int	amd7930_cont_output __P((void *));
int	amd7930_cont_input __P((void *));
a221 1
int	amd7930_setfd __P((void *, int));
d225 1
a225 1

d230 1
a230 5
	NULL,
	amd7930_set_in_sr,
	amd7930_get_in_sr,
	amd7930_set_out_sr,
	amd7930_get_out_sr,
d232 1
a232 5
	amd7930_set_format,
	amd7930_get_encoding,
	amd7930_get_precision,
	amd7930_set_channels,
	amd7930_get_channels,
a233 4
	amd7930_set_out_port,
	amd7930_get_out_port,
	amd7930_set_in_port,
	amd7930_get_in_port,
d235 2
a236 2
	NULL,
	NULL,
d241 1
a241 3
	amd7930_cont_output,
	amd7930_cont_input,
	NULL,
d243 1
a243 1
	amd7930_setfd,
d247 5
a251 2
	1,
	0
d317 1
a317 2
	if (audio_hardware_attach(&sa_hw_if, sc) != 0)
		printf("audio: could not attach to audio pseudo-device driver\n");
d342 2
a343 2
amd7930_open(dev, flags)
	dev_t dev;
d346 1
a346 2
	register struct amd7930_softc *sc;
	int unit = AUDIOUNIT(dev);
d348 1
a348 1
	DPRINTF(("sa_open: unit %d\n",unit));
a349 4
	if (unit >= audioamd_cd.cd_ndevs)
		return (ENODEV);
	if ((sc = audioamd_cd.cd_devs[unit]) == NULL)
		return (ENXIO);
d385 1
a385 1
amd7930_set_in_sr(addr, sr)
d387 2
a388 1
	u_long sr;
d390 4
a393 1
	if (sr != 8000)
d395 2
d398 2
a399 27
	return(0);	/* no other sampling rates supported by amd chip */
}

u_long
amd7930_get_in_sr(addr)
	void *addr;
{
	return(8000);
}

int
amd7930_set_out_sr(addr, sr)
	void *addr;
	u_long sr;
{
	if (sr != 8000)
		return(EINVAL);

	return(0);	/* no other sampling rates supported by amd chip */
}

u_long
amd7930_get_out_sr(addr)
	void *addr;
{
	return(8000);
}
d409 1
a409 1
		    fp->format_id = AUDIO_ENCODING_ULAW;
a418 46
amd7930_set_format(addr, enc, precision)
	void *addr;
	u_int enc, precision;
{
	if (enc != AUDIO_ENCODING_ULAW)
		return(EINVAL);

	if (precision != 8)
		return(EINVAL);

	return(0);		/* no other encoding supported by amd chip */
}

int
amd7930_get_encoding(addr)
	void *addr;
{
	return(AUDIO_ENCODING_ULAW);
}

int
amd7930_get_precision(addr)
	void *addr;
{
	return(8);
}

int
amd7930_set_channels(addr, chans)
	void *addr;
	int chans;
{
	if (chans != 1)
		return(EINVAL);

	return(0);		/* only 1 channel supported by amd chip */
}

int
amd7930_get_channels(addr)
	void *addr;
{
	return(1);
}

int
a426 45
amd7930_set_out_port(addr, port)
	void *addr;
	int port;
{
	register struct amd7930_softc *sc = addr;

	switch(port) {
	    case SUNAUDIO_SPEAKER:
	    case SUNAUDIO_HEADPHONES:
		sc->sc_out_port = port;	/* set on commit */
		break;
	    default:
		return(EINVAL);
	}
	return(0);
}

int
amd7930_get_out_port(addr)
	void *addr;
{
	register struct amd7930_softc *sc = addr;

	return(sc->sc_out_port);
}

int
amd7930_set_in_port(addr, port)
	void *addr;
	int port;
{
	if (port != SUNAUDIO_MIC_PORT)
		return(EINVAL);

	return(0);	/* only microphone input supported by amd chip */
}

int
amd7930_get_in_port(addr)
	void *addr;
{
	return(SUNAUDIO_MIC_PORT);
}

int
a475 7
u_int
amd7930_get_silence(enc)
	int enc;
{
	return(0x7f);
}

a571 16
amd7930_cont_output(addr)
	void *addr;
{
	DPRINTF(("amd7930_cont_output: never called, what should it do?!\n"));
	return(0);
}

int
amd7930_cont_input(addr)
	void *addr;
{
	DPRINTF(("amd7930_cont_input: never called, what should it do?!\n"));
	return(0);
}

int
a580 9
amd7930_setfd(addr, flag)
        void *addr;
        int flag;
{
        /* Always full-duplex */
        return(0);
}

int
d641 7
d689 1
a689 1
		    strcpy(dip->label.name, AudioCInputs);
d695 1
a695 1
		    strcpy(dip->label.name, AudioCOutputs);
@


1.9
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 2
a2 2
/*	$OpenBSD: amd7930.c,v 1.8 1997/07/13 21:48:42 angelos Exp $	*/
/*	$NetBSD: amd7930.c,v 1.10 1996/03/31 22:38:29 pk Exp $	*/
d53 2
d89 1
a89 1
#define sc_intrcnt sc_au.au_intrcnt
d95 8
d104 1
d107 1
a107 1
#endif
d118 1
a118 1
struct cfattach audio_ca = {
d122 2
a123 2
struct	cfdriver audio_cd = {
	NULL, "audio", DV_DULL
d129 1
a129 1
	"audio"
d144 1
a144 1
	0x9008, 0x8b7c, 0x8b51, 0x8b45, 0x8b42, 0x8b3b, 0x8b36, 0x8b33,
a287 1
	struct cfdata *cf = vcf;
d293 1
a293 1
	return (strcmp(cf->cf_driver->cd_name, ra->ra_name) == 0);
d379 1
a379 1
	if (unit >= audio_cd.cd_ndevs)
d381 1
a381 1
	if ((sc = audio_cd.cd_devs[unit]) == NULL)
d917 1
a917 1
	(*au->au_intrcnt)++;
@


1.8
log
@Sync with the new audio changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.7 1997/06/20 10:33:37 grr Exp $	*/
d307 1
a307 2
		ra->ra_vaddr : mapiodev(ra->ra_reg, 0, sizeof (*amd),
					ca->ca_bustype));
@


1.7
log
@Fixes OpenBSD PR kernel/230: system kernel sparc, submitted by
russ@@madhaus.utcs.utoronto.ca (Russell P. Sutherland).

Kernel compile errors when AUDIO_C_HANDLER is defined, due to a
syntax error: *(foo->bar)++ is an odd bit of coding.
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.6 1996/08/12 02:10:35 downsj Exp $	*/
d205 1
a205 1
int	amd7930_set_encoding __P((void *, u_int));
a206 1
int	amd7930_set_precision __P((void *, u_int));
d241 1
a241 1
	amd7930_set_encoding,
a242 1
	amd7930_set_precision,
a251 1
	amd7930_get_silence,
d462 1
a462 1
amd7930_set_encoding(addr, enc)
d464 1
a464 1
	u_int enc;
d469 3
a479 11
}

int
amd7930_set_precision(addr, prec)
	void *addr;
	u_int prec;
{
	if (prec != 8)
		return(EINVAL);

	return(0);		/* no other precision supported by amd chip */
@


1.6
log
@Revert part of that last change; mapdev()/mapiodev() should be done all at
once.
@
text
@d1 1
a1 1
/*	$OpenBSD: amd7930.c,v 1.5 1996/08/12 01:19:38 downsj Exp $	*/
d919 1
a919 1
	*(au->au_intrcnt)++;
@


1.5
log
@Merge revs 1.2 through 1.3: counter, mapiodev.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d309 3
a311 2
	amd = (volatile struct amd7930 *)(ra->ra_vaddr ? ra->ra_vaddr :
		mapiodev(ra->ra_reg, 0, sizeof (*amd), ca->ca_bustype));
@


1.4
log
@netbsd port, now we merge our changes back in
@
text
@d1 1
d87 1
a87 1
#define sc_intrcnt	sc_au.au_intrcnt	/* statistics */
d309 2
a310 3
	amd = (volatile struct amd7930 *)(ra->ra_vaddr ?
		ra->ra_vaddr : mapiodev(ra->ra_reg, 0, sizeof (*amd),
					ca->ca_bustype));
d918 1
@


1.3
log
@new mapdev/()/mapiodev() calling convention uses "struct rom_reg *" to supply
base plus an offset
new dvma routines
@
text
@d1 1
a1 1
/*	$NetBSD: amd7930.c,v 1.2 1995/05/04 19:43:27 pk Exp $ */
d72 1
a72 1
    
d86 1
a86 1
#define sc_intrcnt sc_au.au_intrcnt
a94 1
extern void amd7930_trap();
d103 6
a108 2
void	amd9730attach __P((struct device *, struct device *, void *));
int	amd9730match __P((struct device *, void *, void *));
d110 2
a111 3
struct	cfdriver audiocd = {
	NULL, "audio", amd9730match, amd9730attach,
	DV_DULL, sizeof(struct amd7930_softc)
d217 4
a220 2
int	amd7930_start_output __P((void *, void *, int, void (*)(), void *));
int	amd7930_start_input __P((void *, void *, int, void (*)(), void *));
d275 1
a275 1
amd9730match(parent, vcf, aux)
d283 1
a283 1
	if (cputyp==CPU_SUN4)
d292 1
a292 1
amd9730attach(parent, self, args)
d308 3
a310 2
	amd = (volatile struct amd7930 *)(ra->ra_vaddr ? ra->ra_vaddr :
	    mapiodev(ra->ra_reg, 0, sizeof (*amd), ca->ca_bustype));
d320 1
a320 1
	
a367 1
	register volatile struct amd7930 *amd;
d372 1
a372 1
	if (unit >= audiocd.cd_ndevs)
d374 1
a374 1
	if ((sc = audiocd.cd_devs[unit]) == NULL)
d417 1
a417 1
    
d470 1
a470 1
    
d578 1
a578 1
	
d586 1
a586 1
	
d600 1
a600 1
	
d602 1
a602 1
	
d632 1
a632 1
	void (*intr)();
d664 1
a664 1
	void (*intr)();
d767 1
a767 1
	
d797 1
a797 1
	
a820 2
	register struct amd7930_softc *sc = addr;

d872 1
a872 1
    
a917 1
	*(au->au_intrcnt)++;
@


1.2
log
@irq counter
@
text
@d304 2
a305 3
	amd = (volatile struct amd7930 *)(ra->ra_vaddr ?
		ra->ra_vaddr : mapiodev(ra->ra_paddr, sizeof (*amd),
					ca->ca_bustype));
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: amd7930.c,v 1.4 1995/07/19 19:50:16 brezak Exp $	*/
d86 1
a86 1
#define sc_intrcnt	sc_au.au_intrcnt	/* statistics */
d917 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
