head	1.54;
access;
symbols
	OPENBSD_6_0:1.53.0.6
	OPENBSD_6_0_BASE:1.53
	OPENBSD_5_9:1.53.0.2
	OPENBSD_5_9_BASE:1.53
	OPENBSD_5_8:1.53.0.4
	OPENBSD_5_8_BASE:1.53
	OPENBSD_5_7:1.52.0.2
	OPENBSD_5_7_BASE:1.52
	OPENBSD_5_6:1.52.0.6
	OPENBSD_5_6_BASE:1.52
	OPENBSD_5_5:1.52.0.4
	OPENBSD_5_5_BASE:1.52
	OPENBSD_5_4:1.51.0.2
	OPENBSD_5_4_BASE:1.51
	OPENBSD_5_3:1.50.0.8
	OPENBSD_5_3_BASE:1.50
	OPENBSD_5_2:1.50.0.6
	OPENBSD_5_2_BASE:1.50
	OPENBSD_5_1_BASE:1.50
	OPENBSD_5_1:1.50.0.4
	OPENBSD_5_0:1.50.0.2
	OPENBSD_5_0_BASE:1.50
	OPENBSD_4_9:1.49.0.6
	OPENBSD_4_9_BASE:1.49
	OPENBSD_4_8:1.49.0.4
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.49.0.2
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.48.0.6
	OPENBSD_4_6_BASE:1.48
	OPENBSD_4_5:1.48.0.2
	OPENBSD_4_5_BASE:1.48
	OPENBSD_4_4:1.45.0.6
	OPENBSD_4_4_BASE:1.45
	OPENBSD_4_3:1.45.0.4
	OPENBSD_4_3_BASE:1.45
	OPENBSD_4_2:1.45.0.2
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.44.0.2
	OPENBSD_4_1_BASE:1.44
	OPENBSD_4_0:1.39.0.2
	OPENBSD_4_0_BASE:1.39
	OPENBSD_3_9:1.38.0.4
	OPENBSD_3_9_BASE:1.38
	OPENBSD_3_8:1.38.0.2
	OPENBSD_3_8_BASE:1.38
	OPENBSD_3_7:1.33.0.2
	OPENBSD_3_7_BASE:1.33
	OPENBSD_3_6:1.29.0.2
	OPENBSD_3_6_BASE:1.29
	SMP_SYNC_A:1.29
	SMP_SYNC_B:1.29
	OPENBSD_3_5:1.27.0.2
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.10
	UBC:1.6.0.2
	UBC_BASE:1.6
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.10
	OPENBSD_2_8:1.3.0.8
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.6
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.4
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.54
date	2016.09.01.09.23.42;	author tedu;	state dead;
branches;
next	1.53;
commitid	Q2PxaFNhqAe0Wmla;

1.53
date	2015.03.28.19.07.07;	author miod;	state Exp;
branches;
next	1.52;
commitid	nwbHy4sQv9NnJnmZ;

1.52
date	2013.10.20.20.07.26;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2013.05.31.22.07.49;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2011.05.31.17.40.19;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2009.09.05.14.09.35;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2008.12.26.23.46.19;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2008.12.26.22.30.21;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2008.12.26.00.42.19;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2007.07.13.19.18.18;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2007.02.25.18.14.48;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2007.02.18.18.40.35;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2006.12.27.18.54.04;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2006.12.02.11.24.02;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2006.11.29.19.08.22;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2006.06.02.20.00.54;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2005.07.19.09.36.04;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2005.07.09.22.22.12;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2005.03.26.15.16.14;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2005.03.23.17.16.34;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2005.03.23.17.15.44;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2005.03.07.16.44.50;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2005.01.05.23.04.25;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2004.11.29.22.07.37;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2004.09.29.07.35.11;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2004.05.12.16.26.11;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2004.05.10.09.05.52;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2004.03.09.22.59.09;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2004.02.27.22.32.20;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2003.11.07.10.16.45;	author jmc;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.28.17.05.33;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.17.21.21.32;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.13.23.40.12;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.13.21.04.45;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.13.19.02.13;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.13.06.44.55;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.12.19.09.43;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.06.19.42.47;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.05.22.32.09;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.18.40.59;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.17.03.54.34;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2003.05.16.18.40.32;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.12.18.57.14;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.06.21.06.20;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.23.18.13.38;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.09.22.15.16;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.12.10.44.04;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.43;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.11.01.12.13.46;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.17.13.52.29;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	99.09.07.02.58.49;	author jason;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	99.09.06.04.46.38;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	99.09.06.03.46.16;	author jason;	state Exp;
branches;
next	;

1.3.4.1
date	2001.10.31.03.07.56;	author nate;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2003.05.16.00.29.40;	author niklas;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2003.06.07.11.14.43;	author ho;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2004.02.19.10.49.58;	author niklas;	state Exp;
branches;
next	1.3.4.8;

1.3.4.8
date	2004.06.05.23.10.57;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2002.10.29.00.28.09;	author art;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.54
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: p9100.c,v 1.53 2015/03/28 19:07:07 miod Exp $	*/

/*
 * Copyright (c) 2003, 2005, 2006, 2008, Miodrag Vallat.
 * Copyright (c) 1999 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * color display (p9100) driver.
 * Initially based on cgthree.c and the NetBSD p9100 driver, then hacked
 * beyond recognition.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/mman.h>
#include <sys/tty.h>
#include <sys/conf.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/bsd_openprom.h>
#include <machine/pmap.h>
#include <machine/cpu.h>
#include <machine/conf.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>
#include <dev/wsfont/wsfont.h>
#include <machine/fbvar.h>

#include <sparc/dev/btreg.h>
#include <sparc/dev/btvar.h>

#include <dev/ic/ibm525reg.h>
#include <dev/ic/p9000.h>

#include "tctrl.h"
#if NTCTRL > 0
#include <sparc/dev/tctrlvar.h>
#endif

#undef	FIDDLE_WITH_PCI_REGISTERS

/*
 * SBus registers mappings
 */
#define	P9100_NREG		4
#define	P9100_REG_CTL		0
#define	P9100_REG_CMD		1
#define	P9100_REG_VRAM		2
#define	P9100_REG_CONFIG	3

#ifdef	FIDDLE_WITH_PCI_REGISTERS
/*
 * This structure, mapped at register address 0x9100, allows non-PCI
 * designs (such as the SPARCbook) to access the PCI configuration space.
 */
struct p9100_pci {
	volatile u_int32_t	address;	/* within configuration space */
	volatile u_int32_t	data;		/* _byte_ to read or write */
};
#endif

/* per-display variables */
struct p9100_softc {
	struct sunfb	sc_sunfb;	/* common base part */
	struct rom_reg	sc_phys[P9100_NREG - 1];
	volatile u_int8_t *sc_cmd;	/* command registers (dac, etc) */
	volatile u_int8_t *sc_ctl;	/* control registers (draw engine) */
#ifdef	FIDDLE_WITH_PCI_REGISTERS
	struct p9100_pci *sc_pci;	/* pci configuration space access */
#endif
	vsize_t		sc_vramsize;	/* total VRAM available */
	union bt_cmap	sc_cmap;	/* Brooktree color map */
	struct intrhand	sc_ih;
	int		sc_mapmode;
	u_int		sc_flags;
#define	SCF_INTERNAL		0x01	/* internal video enabled */
#define	SCF_EXTERNAL		0x02	/* external video enabled */
#if NTCTRL > 0
#define	SCF_MAPPEDSWITCH	0x04	/* switch mode when leaving emul */
	u_int		sc_mapwidth;	/* non-emul video mode parameters */
	u_int		sc_mapheight;
	u_int		sc_mapdepth;
#endif
	u_int		sc_lcdheight;	/* LCD panel geometry */
	u_int		sc_lcdwidth;

	u_int32_t	sc_junk;	/* throwaway value */
};

void	p9100_burner(void *, u_int, u_int);
void	p9100_external_video(void *, int);
void	p9100_initialize_ramdac(struct p9100_softc *, u_int, u_int);
int	p9100_intr(void *);
int	p9100_ioctl(void *, u_long, caddr_t, int, struct proc *);
static __inline__
void	p9100_loadcmap_deferred(struct p9100_softc *, u_int, u_int);
void	p9100_loadcmap_immediate(struct p9100_softc *, u_int, u_int);
paddr_t	p9100_mmap(void *, off_t, int);
void	p9100_pick_romfont(struct p9100_softc *);
void	p9100_prom(void *);
void	p9100_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
u_int	p9100_read_ramdac(struct p9100_softc *, u_int);
void	p9100_write_ramdac(struct p9100_softc *, u_int, u_int);

struct wsdisplay_accessops p9100_accessops = {
	.ioctl = p9100_ioctl,
	.mmap = p9100_mmap,
	.burn_screen = p9100_burner
};

int	p9100_ras_copycols(void *, int, int, int, int);
int	p9100_ras_copyrows(void *, int, int, int);
int	p9100_ras_do_cursor(struct rasops_info *);
int	p9100_ras_erasecols(void *, int, int, int, long int);
int	p9100_ras_eraserows(void *, int, int, long int);
void	p9100_ras_init(struct p9100_softc *);

int	p9100match(struct device *, void *, void *);
void	p9100attach(struct device *, struct device *, void *);
int	p9100activate(struct device *, int);

struct cfattach pnozz_ca = {
	sizeof (struct p9100_softc), p9100match, p9100attach,
	NULL, p9100activate
};

struct cfdriver pnozz_cd = {
	NULL, "pnozz", DV_DULL
};

/*
 * IBM RGB525 RAMDAC registers
 */

#define	IBM525_WRADDR			0	/* Palette write address */
#define	IBM525_DATA			1	/* Palette data */
#define	IBM525_PIXMASK			2	/* Pixel mask */
#define	IBM525_RDADDR			3	/* Read palette address */
#define	IBM525_IDXLOW			4	/* Register index low */
#define	IBM525_IDXHIGH			5	/* Register index high */
#define	IBM525_REGDATA			6	/* Register data */
#define	IBM525_IDXCONTROL		7	/* Index control */

/*
 * P9100 read/write macros
 */

#define	P9100_READ_CTL(sc,reg) \
	*(volatile u_int32_t *)((sc)->sc_ctl + (reg))
#define	P9100_READ_CMD(sc,reg) \
	*(volatile u_int32_t *)((sc)->sc_cmd + (reg))
#define	P9100_READ_RAMDAC(sc,reg) \
	(*(volatile u_int32_t *)((sc)->sc_ctl + P9100_RAMDAC_REGISTER(reg)) \
	    >> 16)

#define	P9100_WRITE_CTL(sc,reg,value) \
	*(volatile u_int32_t *)((sc)->sc_ctl + (reg)) = (value)
#define	P9100_WRITE_CMD(sc,reg,value) \
	*(volatile u_int32_t *)((sc)->sc_cmd + (reg)) = (value)
#define	P9100_WRITE_RAMDAC(sc,reg,value) \
	*(volatile u_int32_t *)((sc)->sc_ctl + P9100_RAMDAC_REGISTER(reg)) = \
	    ((value) << 16)

/*
 * On the Tadpole, the first write to a register group is ignored until
 * the proper group address is latched, which can be done by reading from the
 * register group first.
 *
 * Register groups are 0x80 bytes long (i.e. it is necessary to force a read
 * when writing to an address which upper 25 bit differ from the previous
 * read or write operation).
 *
 * This is specific to the Tadpole design, and not a limitation of the
 * Power 9100 hardware.
 */
#define	P9100_SELECT_SCR(sc) \
	(sc)->sc_junk = P9100_READ_CTL(sc, P9000_SYSTEM_CONFIG)
#define	P9100_SELECT_VCR(sc) \
	(sc)->sc_junk = P9100_READ_CTL(sc, P9000_HCR)
#define	P9100_SELECT_VRAM(sc) \
	(sc)->sc_junk = P9100_READ_CTL(sc, P9000_MCR)
#define	P9100_SELECT_DAC(sc) \
	(sc)->sc_junk = P9100_READ_CTL(sc, P9100_RAMDAC_REGISTER(0))
#define	P9100_SELECT_PE(sc) \
	(sc)->sc_junk = P9100_READ_CMD(sc, P9000_PE_STATUS)
#define	P9100_SELECT_DE_LOW(sc)	\
	(sc)->sc_junk = P9100_READ_CMD(sc, P9000_DE_FG_COLOR)
#define	P9100_SELECT_DE_HIGH(sc) \
	(sc)->sc_junk = P9100_READ_CMD(sc, P9000_DE_PATTERN(0))
#define	P9100_SELECT_COORD(sc,field) \
	(sc)->sc_junk = P9100_READ_CMD(sc, field)

/*
 * For some reason, every write to a DAC register needs to be followed by a
 * read from the ``free fifo number'' register, supposedly to have the write
 * take effect faster...
 */
#define	P9100_FLUSH_DAC(sc) \
	do { \
		P9100_SELECT_VRAM(sc); \
		(sc)->sc_junk = P9100_READ_CTL(sc, P9100_FREE_FIFO); \
	} while (0)

int
p9100match(struct device *parent, void *vcf, void *aux)
{
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

	if (strcmp("p9100", ra->ra_name))
		return (0);

#if NTCTRL == 0
	/*
	 * If this is not the console device, the frame buffer is
	 * not completely initialized, and access to some of its
	 * control registers will hang. We'll need to reprogram
	 * the RAMDAC, and currently this requires assistance
	 * from the tctrl code. Do not attach if it is not available
	 * and console is on serial.
	 */
	if (ra->ra_node != fbnode)
		return (0);
#endif

	return (1);
}

/*
 * Attach a display.
 */
void
p9100attach(struct device *parent, struct device *self, void *args)
{
	struct p9100_softc *sc = (struct p9100_softc *)self;
	struct rasops_info *ri = &sc->sc_sunfb.sf_ro;
	struct confargs *ca = args;
	struct romaux *ra = &ca->ca_ra;
	int node, pri, scr;
	int isconsole;

	pri = ca->ca_ra.ra_intr[0].int_pri;
	printf(" pri %d", pri);

#ifdef DIAGNOSTIC
	if (ra->ra_nreg < P9100_NREG) {
		printf(": expected %d registers, got only %d\n",
		    P9100_NREG, ra->ra_nreg);
		return;
	}
#endif

	sc->sc_flags = SCF_INTERNAL;
	sc->sc_mapmode = WSDISPLAYIO_MODE_EMUL;

	bcopy(ra->ra_reg, sc->sc_phys, sizeof(sc->sc_phys));

	sc->sc_ctl = mapiodev(&ra->ra_reg[P9100_REG_CTL], 0,
	    ra->ra_reg[P9100_REG_CTL].rr_len);
	sc->sc_cmd = mapiodev(&ra->ra_reg[P9100_REG_CMD], 0,
	    ra->ra_reg[P9100_REG_CMD].rr_len);
#ifdef	FIDDLE_WITH_PCI_REGISTERS
	sc->sc_pci = (struct p9100_pci *)
	    mapiodev(&ra->ra_reg[P9100_REG_CONFIG], 0,
	      ra->ra_reg[P9100_REG_CONFIG].rr_len);
#endif

	node = ra->ra_node;
	isconsole = node == fbnode;

	P9100_SELECT_SCR(sc);
	scr = P9100_READ_CTL(sc, P9000_SYSTEM_CONFIG);

	fb_setsize(&sc->sc_sunfb, 8, 800, 600, node, ca->ca_bustype);

	/*
	 * We expect the PROM to initialize us in the best 8 bit mode
	 * supported by the LCD (640x480 on 3XP, 800x600 on 3GS/3GX).
	 */
	sc->sc_lcdwidth = sc->sc_sunfb.sf_width;
	sc->sc_lcdheight = sc->sc_sunfb.sf_height;

#if NTCTRL > 0
	/*
	 * ... but it didn't if we are running on serial console.
	 * In this case, do it ourselves.
	 */
	if (!isconsole)
		p9100_initialize_ramdac(sc, sc->sc_lcdwidth, 8);
#endif

#if NTCTRL > 0
	/*
	 * We want to run the frame buffer in 8bpp mode for the emulation mode,
	 * and use a potentially better mode for the mapped (X11) mode.
	 * Eventually this will become runtime user-selectable.
	 */

	sc->sc_mapwidth = sc->sc_lcdwidth;
	sc->sc_mapheight = sc->sc_lcdheight;
	sc->sc_mapdepth = 8;

	if (sc->sc_mapwidth != sc->sc_sunfb.sf_width ||
	    sc->sc_mapdepth != sc->sc_sunfb.sf_depth)
		SET(sc->sc_flags, SCF_MAPPEDSWITCH);
#endif

	ri->ri_bits = mapiodev(&ra->ra_reg[P9100_REG_VRAM], 0,
	    sc->sc_vramsize = round_page(ra->ra_reg[P9100_REG_VRAM].rr_len));
	ri->ri_hw = sc;

	printf(": rev %x, %dx%d\n", scr & SCR_ID_MASK,
	    sc->sc_lcdwidth, sc->sc_lcdheight);

	/* Disable frame buffer interrupts */
	P9100_SELECT_SCR(sc);
	P9100_WRITE_CTL(sc, P9000_INTERRUPT_ENABLE, IER_MASTER_ENABLE | 0);

	sc->sc_ih.ih_fun = p9100_intr;
	sc->sc_ih.ih_arg = sc;
	intr_establish(pri, &sc->sc_ih, IPL_FB, self->dv_xname);

	/*
	 * Try to get a copy of the PROM font.
	 *
	 * If we can't, we'll clear the display and switch to the 8x16 font.
	 */
	if (isconsole)
		p9100_pick_romfont(sc);

	/*
	 * Register the external video control callback with tctrl; tctrl
	 * will invoke it immediately to set the appropriate behaviour.
	 * If tctrl is not configured, simply enable external video.
	 */
#if NTCTRL > 0
	tadpole_register_extvideo(p9100_external_video, sc);
#else
	p9100_external_video(sc, 1);
#endif

	fbwscons_init(&sc->sc_sunfb, isconsole);
	fbwscons_setcolormap(&sc->sc_sunfb, p9100_setcolor);

	/*
	 * Plug-in accelerated console operations.
	 */
	p9100_ras_init(sc);

	/* enable video */
	p9100_burner(sc, 1, 0);

	if (isconsole)
		fbwscons_console_init(&sc->sc_sunfb, -1);

	fbwscons_attach(&sc->sc_sunfb, &p9100_accessops, isconsole);
}

int
p9100activate(struct device *self, int act)
{
	int ret = 0;

	switch (act) {
	case DVACT_POWERDOWN:
#if NTCTRL > 0
		p9100_prom(self);
#endif
		break;
	}

	return (ret);
}

int
p9100_ioctl(void *v, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct p9100_softc *sc = v;
	struct wsdisplay_fbinfo *wdf;
	struct wsdisplay_cmap *cm;
#if NTCTRL > 0
	struct wsdisplay_param *dp;
#endif
	int error;

	switch (cmd) {

	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_SB_P9100;
		break;

	case WSDISPLAYIO_SMODE:
		sc->sc_mapmode = *(u_int *)data;
		switch (sc->sc_mapmode) {
		case WSDISPLAYIO_MODE_DUMBFB:
		case WSDISPLAYIO_MODE_MAPPED:
#if NTCTRL > 0
			if (ISSET(sc->sc_flags, SCF_MAPPEDSWITCH))
				p9100_initialize_ramdac(sc,
				    sc->sc_mapwidth, sc->sc_mapdepth);
#endif
			break;
		case WSDISPLAYIO_MODE_EMUL:
#if NTCTRL > 0
			if (ISSET(sc->sc_flags, SCF_MAPPEDSWITCH))
				p9100_initialize_ramdac(sc, sc->sc_lcdwidth, 8);
#endif
			fbwscons_setcolormap(&sc->sc_sunfb, p9100_setcolor);
			/* Restore proper acceleration state as well */
			p9100_ras_init(sc);
			break;
		}
		break;

	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
#if NTCTRL > 0
		if (ISSET(sc->sc_flags, SCF_MAPPEDSWITCH)) {
			wdf->width = sc->sc_mapwidth;
			wdf->height = sc->sc_mapheight;
			wdf->depth  = sc->sc_mapdepth;
			wdf->cmsize = sc->sc_mapdepth == 8 ? 256 : 0;
		} else
#endif
		{
			wdf->width  = sc->sc_lcdwidth;
			wdf->height = sc->sc_lcdheight;
			wdf->depth  = 8;
			wdf->cmsize = 256;
		}
		break;

	case WSDISPLAYIO_LINEBYTES:
#if NTCTRL > 0
		if (ISSET(sc->sc_flags, SCF_MAPPEDSWITCH))
			*(u_int *)data = sc->sc_mapwidth *
			    (sc->sc_mapdepth / 8);
		else
#endif
			*(u_int *)data = sc->sc_sunfb.sf_linebytes;
		break;

	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_getcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		break;

	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		p9100_loadcmap_deferred(sc, cm->index, cm->count);
		break;

#if NTCTRL > 0
	case WSDISPLAYIO_GETPARAM:
		dp = (struct wsdisplay_param *)data;

		switch (dp->param) {
		case WSDISPLAYIO_PARAM_BRIGHTNESS:
			dp->min = 0;
			dp->max = 255;
			dp->curval = tadpole_get_brightness();
			break;
		case WSDISPLAYIO_PARAM_BACKLIGHT:
			dp->min = 0;
			dp->max = 1;
			if (ISSET(sc->sc_flags, SCF_INTERNAL))
				dp->curval =
				    tadpole_get_video() & TV_ON ? 1 : 0;
			else
				dp->curval = 0;
			break;
		default:
			return (-1);
		}
		break;

	case WSDISPLAYIO_SETPARAM:
		dp = (struct wsdisplay_param *)data;

		switch (dp->param) {
		case WSDISPLAYIO_PARAM_BRIGHTNESS:
			tadpole_set_brightness(dp->curval);
			break;
		case WSDISPLAYIO_PARAM_BACKLIGHT:
			if (ISSET(sc->sc_flags, SCF_INTERNAL))
				tadpole_set_video(dp->curval);
			break;
		default:
			return (-1);
		}
		break;
#endif	/* NTCTRL > 0 */

	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
		break;

	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
	default:
		return (-1);	/* not supported yet */
	}

	return (0);
}

paddr_t
p9100_mmap(void *v, off_t offset, int prot)
{
	struct p9100_softc *sc = v;
	struct rom_reg *rr;

	if ((offset & PAGE_MASK) != 0)
		return (-1);

	switch (sc->sc_mapmode) {
	case WSDISPLAYIO_MODE_MAPPED:
		/*
		 * We provide the following mapping:
		 * 000000 - 0000ff  control registers
		 * 002000 - 003fff  command registers
		 * 800000 - 9fffff  vram
		 */
		rr = &sc->sc_phys[P9100_REG_CTL];
		if (offset >= 0 && offset < rr->rr_len)
			break;
		offset -= 0x2000;
		rr = &sc->sc_phys[P9100_REG_CMD];
		if (offset >= 0 && offset < rr->rr_len)
			break;
		offset -= (0x800000 - 0x2000);
		/* FALLTHROUGH */
	case WSDISPLAYIO_MODE_DUMBFB:
		rr = &sc->sc_phys[P9100_REG_VRAM];
		if (offset >= 0 && offset < sc->sc_vramsize)
			break;
		/* FALLTHROUGH */
	default:
		return (-1);
	}

	return (REG2PHYS(rr, offset) | PMAP_NC);
}

void
p9100_setcolor(void *v, u_int index, u_int8_t r, u_int8_t g, u_int8_t b)
{
	struct p9100_softc *sc = v;
	union bt_cmap *bcm = &sc->sc_cmap;

	bcm->cm_map[index][0] = r;
	bcm->cm_map[index][1] = g;
	bcm->cm_map[index][2] = b;
	p9100_loadcmap_immediate(sc, index, 1);
}

void
p9100_loadcmap_immediate(struct p9100_softc *sc, u_int start, u_int ncolors)
{
	u_char *p;

	P9100_SELECT_DAC(sc);
	P9100_WRITE_RAMDAC(sc, IBM525_WRADDR, start);
	P9100_FLUSH_DAC(sc);

	for (p = sc->sc_cmap.cm_map[start], ncolors *= 3; ncolors-- > 0; p++) {
		P9100_SELECT_DAC(sc);
		P9100_WRITE_RAMDAC(sc, IBM525_DATA, (*p));
		P9100_FLUSH_DAC(sc);
	}
}

static __inline__ void
p9100_loadcmap_deferred(struct p9100_softc *sc, u_int start, u_int ncolors)
{
	/* Schedule an interrupt for next retrace */
	P9100_SELECT_SCR(sc);
	P9100_WRITE_CTL(sc, P9000_INTERRUPT_ENABLE,
	    IER_MASTER_ENABLE | IER_MASTER_INTERRUPT |
	    IER_VBLANK_ENABLE | IER_VBLANK_INTERRUPT);
}

u_int
p9100_read_ramdac(struct p9100_softc *sc, u_int reg)
{
	P9100_SELECT_DAC(sc);

	P9100_WRITE_RAMDAC(sc, IBM525_IDXLOW, (reg & 0xff));
	P9100_FLUSH_DAC(sc);
	P9100_WRITE_RAMDAC(sc, IBM525_IDXHIGH, ((reg >> 8) & 0xff));
	P9100_FLUSH_DAC(sc);
	return (P9100_READ_RAMDAC(sc, IBM525_REGDATA));
}

void
p9100_write_ramdac(struct p9100_softc *sc, u_int reg, u_int value)
{
	P9100_SELECT_DAC(sc);

	P9100_WRITE_RAMDAC(sc, IBM525_IDXLOW, (reg & 0xff));
	P9100_FLUSH_DAC(sc);
	P9100_WRITE_RAMDAC(sc, IBM525_IDXHIGH, ((reg >> 8) & 0xff));
	P9100_FLUSH_DAC(sc);
	P9100_WRITE_RAMDAC(sc, IBM525_REGDATA, value);
	P9100_FLUSH_DAC(sc);
}

void
p9100_burner(void *v, u_int on, u_int flags)
{
	struct p9100_softc *sc = v;
	u_int32_t vcr;
	int s;

	s = splhigh();
	P9100_SELECT_VCR(sc);
	vcr = P9100_READ_CTL(sc, P9000_SRTC1);
	if (on)
		vcr |= SRTC1_VIDEN;
	else
		vcr &= ~SRTC1_VIDEN;
	P9100_WRITE_CTL(sc, P9000_SRTC1, vcr);
#if NTCTRL > 0
	if (ISSET(sc->sc_flags, SCF_INTERNAL))
		tadpole_set_video(on);
#endif
	splx(s);
}

int
p9100_intr(void *v)
{
	struct p9100_softc *sc = v;

	if (P9100_READ_CTL(sc, P9000_INTERRUPT) & IER_VBLANK_INTERRUPT) {
		p9100_loadcmap_immediate(sc, 0, 256);

		/* Disable further interrupts now */
		/* P9100_SELECT_SCR(sc); */
		P9100_WRITE_CTL(sc, P9000_INTERRUPT_ENABLE,
		    IER_MASTER_ENABLE | 0);

		/* Clear interrupt condition */
		P9100_WRITE_CTL(sc, P9000_INTERRUPT,
		    IER_VBLANK_ENABLE | 0);

		return (1);
	}

	return (0);
}

/*
 * Accelerated text console code
 */

static int p9100_drain(struct p9100_softc *);

static int
p9100_drain(struct p9100_softc *sc)
{
	u_int i;

	for (i = 10000; i !=0; i--) {
		if ((P9100_READ_CMD(sc, P9000_PE_STATUS) &
		    (STATUS_QUAD_BUSY | STATUS_BLIT_BUSY)) == 0)
			break;
	}

	return (i);
}

void
p9100_ras_init(struct p9100_softc *sc)
{

	if (p9100_drain(sc) == 0)
		return;

	sc->sc_sunfb.sf_ro.ri_ops.copycols = p9100_ras_copycols;
	sc->sc_sunfb.sf_ro.ri_ops.copyrows = p9100_ras_copyrows;
	sc->sc_sunfb.sf_ro.ri_ops.erasecols = p9100_ras_erasecols;
	sc->sc_sunfb.sf_ro.ri_ops.eraserows = p9100_ras_eraserows;
	sc->sc_sunfb.sf_ro.ri_do_cursor = p9100_ras_do_cursor;

	/*
	 * Setup safe defaults for the parameter and drawing engines, in
	 * order to minimize the operations to do for ri_ops.
	 */

	P9100_SELECT_DE_LOW(sc);
	P9100_WRITE_CMD(sc, P9000_DE_DRAWMODE,
	    DM_PICK_CONTROL | 0 | DM_BUFFER_CONTROL | DM_BUFFER_ENABLE0);

	P9100_WRITE_CMD(sc, P9000_DE_PATTERN_ORIGIN_X, 0);
	P9100_WRITE_CMD(sc, P9000_DE_PATTERN_ORIGIN_Y, 0);
	/* enable all planes */
	P9100_WRITE_CMD(sc, P9000_DE_PLANEMASK, 0xffffffff);

	/* Unclip */
	P9100_WRITE_CMD(sc, P9000_DE_WINMIN, 0);
	P9100_WRITE_CMD(sc, P9000_DE_WINMAX,
	    P9000_COORDS(sc->sc_sunfb.sf_width - 1, sc->sc_sunfb.sf_height - 1));

	P9100_SELECT_DE_HIGH(sc);
	P9100_WRITE_CMD(sc, P9100_DE_B_WINMIN, 0);
	P9100_WRITE_CMD(sc, P9100_DE_B_WINMAX,
	    P9000_COORDS(sc->sc_sunfb.sf_width - 1, sc->sc_sunfb.sf_height - 1));

	P9100_SELECT_PE(sc);
	P9100_WRITE_CMD(sc, P9000_PE_WINOFFSET, 0);
	P9100_WRITE_CMD(sc, P9000_PE_INDEX, 0);
	P9100_WRITE_CMD(sc, P9000_PE_WINMIN, 0);
	P9100_WRITE_CMD(sc, P9000_PE_WINMAX,
	    P9000_COORDS(sc->sc_sunfb.sf_width - 1, sc->sc_sunfb.sf_height - 1));
}

int
p9100_ras_copycols(void *v, int row, int src, int dst, int n)
{
	struct rasops_info *ri = v;
	struct p9100_softc *sc = ri->ri_hw;

	n *= ri->ri_font->fontwidth;
	n--;
	src *= ri->ri_font->fontwidth;
	src += ri->ri_xorigin;
	dst *= ri->ri_font->fontwidth;
	dst += ri->ri_xorigin;
	row *= ri->ri_font->fontheight;
	row += ri->ri_yorigin;

	p9100_drain(sc);
	P9100_SELECT_DE_LOW(sc);
	P9100_WRITE_CMD(sc, P9000_DE_RASTER,
	    P9100_RASTER_SRC & P9100_RASTER_MASK);

	P9100_SELECT_COORD(sc, P9000_DC_COORD(0));
	P9100_WRITE_CMD(sc, P9000_DC_COORD(0) + P9000_COORD_XY,
	    P9000_COORDS(src, row));
	P9100_WRITE_CMD(sc, P9000_DC_COORD(1) + P9000_COORD_XY,
	    P9000_COORDS(src + n, row + ri->ri_font->fontheight - 1));
	P9100_SELECT_COORD(sc, P9000_DC_COORD(2));
	P9100_WRITE_CMD(sc, P9000_DC_COORD(2) + P9000_COORD_XY,
	    P9000_COORDS(dst, row));
	P9100_WRITE_CMD(sc, P9000_DC_COORD(3) + P9000_COORD_XY,
	    P9000_COORDS(dst + n, row + ri->ri_font->fontheight - 1));

	sc->sc_junk = P9100_READ_CMD(sc, P9000_PE_BLIT);

	p9100_drain(sc);

	return 0;
}

int
p9100_ras_copyrows(void *v, int src, int dst, int n)
{
	struct rasops_info *ri = v;
	struct p9100_softc *sc = ri->ri_hw;

	n *= ri->ri_font->fontheight;
	n--;
	src *= ri->ri_font->fontheight;
	src += ri->ri_yorigin;
	dst *= ri->ri_font->fontheight;
	dst += ri->ri_yorigin;

	p9100_drain(sc);
	P9100_SELECT_DE_LOW(sc);
	P9100_WRITE_CMD(sc, P9000_DE_RASTER,
	    P9100_RASTER_SRC & P9100_RASTER_MASK);

	P9100_SELECT_COORD(sc, P9000_DC_COORD(0));
	P9100_WRITE_CMD(sc, P9000_DC_COORD(0) + P9000_COORD_XY,
	    P9000_COORDS(ri->ri_xorigin, src));
	P9100_WRITE_CMD(sc, P9000_DC_COORD(1) + P9000_COORD_XY,
	    P9000_COORDS(ri->ri_xorigin + ri->ri_emuwidth - 1, src + n));
	P9100_SELECT_COORD(sc, P9000_DC_COORD(2));
	P9100_WRITE_CMD(sc, P9000_DC_COORD(2) + P9000_COORD_XY,
	    P9000_COORDS(ri->ri_xorigin, dst));
	P9100_WRITE_CMD(sc, P9000_DC_COORD(3) + P9000_COORD_XY,
	    P9000_COORDS(ri->ri_xorigin + ri->ri_emuwidth - 1, dst + n));

	sc->sc_junk = P9100_READ_CMD(sc, P9000_PE_BLIT);

	p9100_drain(sc);

	return 0;
}

int
p9100_ras_erasecols(void *v, int row, int col, int n, long int attr)
{
	struct rasops_info *ri = v;
	struct p9100_softc *sc = ri->ri_hw;
	int fg, bg;

	ri->ri_ops.unpack_attr(v, attr, &fg, &bg, NULL);
	bg = ri->ri_devcmap[bg];

	n *= ri->ri_font->fontwidth;
	col *= ri->ri_font->fontwidth;
	col += ri->ri_xorigin;
	row *= ri->ri_font->fontheight;
	row += ri->ri_yorigin;

	p9100_drain(sc);
	P9100_SELECT_DE_LOW(sc);
	P9100_WRITE_CMD(sc, P9000_DE_RASTER,
	    P9100_RASTER_PATTERN & P9100_RASTER_MASK);
	P9100_WRITE_CMD(sc, P9100_DE_COLOR0, P9100_COLOR8(bg));

	P9100_SELECT_COORD(sc, P9000_LC_RECT);
	P9100_WRITE_CMD(sc, P9000_LC_RECT + P9000_COORD_XY,
	    P9000_COORDS(col, row));
	P9100_WRITE_CMD(sc, P9000_LC_RECT + P9000_COORD_XY,
	    P9000_COORDS(col + n, row + ri->ri_font->fontheight));

	sc->sc_junk = P9100_READ_CMD(sc, P9000_PE_QUAD);

	p9100_drain(sc);

	return 0;
}

int
p9100_ras_eraserows(void *v, int row, int n, long int attr)
{
	struct rasops_info *ri = v;
	struct p9100_softc *sc = ri->ri_hw;
	int fg, bg;

	ri->ri_ops.unpack_attr(v, attr, &fg, &bg, NULL);
	bg = ri->ri_devcmap[bg];

	p9100_drain(sc);
	P9100_SELECT_DE_LOW(sc);
	P9100_WRITE_CMD(sc, P9000_DE_RASTER,
	    P9100_RASTER_PATTERN & P9100_RASTER_MASK);
	P9100_WRITE_CMD(sc, P9100_DE_COLOR0, P9100_COLOR8(bg));

	P9100_SELECT_COORD(sc, P9000_LC_RECT);
	if (n == ri->ri_rows && ISSET(ri->ri_flg, RI_FULLCLEAR)) {
		P9100_WRITE_CMD(sc, P9000_LC_RECT + P9000_COORD_XY,
		    P9000_COORDS(0, 0));
		P9100_WRITE_CMD(sc, P9000_LC_RECT + P9000_COORD_XY,
		    P9000_COORDS(ri->ri_width, ri->ri_height));
	} else {
		n *= ri->ri_font->fontheight;
		row *= ri->ri_font->fontheight;
		row += ri->ri_yorigin;

		P9100_WRITE_CMD(sc, P9000_LC_RECT + P9000_COORD_XY,
		    P9000_COORDS(ri->ri_xorigin, row));
		P9100_WRITE_CMD(sc, P9000_LC_RECT + P9000_COORD_XY,
		    P9000_COORDS(ri->ri_xorigin + ri->ri_emuwidth, row + n));
	}

	sc->sc_junk = P9100_READ_CMD(sc, P9000_PE_QUAD);

	p9100_drain(sc);

	return 0;
}

int
p9100_ras_do_cursor(struct rasops_info *ri)
{
	struct p9100_softc *sc = ri->ri_hw;
	int row, col;

	row = ri->ri_crow * ri->ri_font->fontheight + ri->ri_yorigin;
	col = ri->ri_ccol * ri->ri_font->fontwidth + ri->ri_xorigin;

	p9100_drain(sc);

	P9100_SELECT_DE_LOW(sc);
	P9100_WRITE_CMD(sc, P9000_DE_RASTER,
	    (P9100_RASTER_PATTERN ^ P9100_RASTER_DST) & P9100_RASTER_MASK);
	P9100_WRITE_CMD(sc, P9100_DE_COLOR0,
	    P9100_COLOR8(ri->ri_devcmap[WSCOL_BLACK]));

	P9100_SELECT_COORD(sc, P9000_LC_RECT);
	P9100_WRITE_CMD(sc, P9000_LC_RECT + P9000_COORD_XY,
	    P9000_COORDS(col, row));
	P9100_WRITE_CMD(sc, P9000_LC_RECT + P9000_COORD_XY,
	    P9000_COORDS(col + ri->ri_font->fontwidth,
	        row + ri->ri_font->fontheight));

	sc->sc_junk = P9100_READ_CMD(sc, P9000_PE_QUAD);

	p9100_drain(sc);

	return 0;
}

/*
 * PROM font managment
 */

#define	ROMFONTNAME	"p9100_romfont"
struct wsdisplay_font p9100_romfont = {
	ROMFONTNAME,
	0,
	0, 256,
	WSDISPLAY_FONTENC_ISO,	/* should check the `character-set' property */
	0, 0, 0,
	WSDISPLAY_FONTORDER_L2R,
	WSDISPLAY_FONTORDER_L2R,
	NULL,
	NULL
};

void
p9100_pick_romfont(struct p9100_softc *sc)
{
	struct rasops_info *ri = &sc->sc_sunfb.sf_ro;
	int *fontwidth, *fontheight, *fontstride;
	u_int8_t **fontaddr;
	char buf[200];

	/*
	 * This code currently only works for PROM >= 2.9; see
	 * autoconf.c romgetcursoraddr() for details.
	 */
	if (promvec->pv_romvec_vers < 2 || promvec->pv_printrev < 0x00020009)
		return;

	/*
	 * Get the PROM font metrics and address
	 */
	if (snprintf(buf, sizeof buf, "stdout @@ is my-self "
	    "addr char-height %lx ! addr char-width %lx ! "
	    "addr font-base %lx ! addr fontbytes %lx !",
	    (vaddr_t)&fontheight, (vaddr_t)&fontwidth,
	    (vaddr_t)&fontaddr, (vaddr_t)&fontstride) >= sizeof buf)
		return;
	fontheight = fontwidth = fontstride = NULL;
	fontaddr = NULL;
	rominterpret(buf);

	if (fontheight == NULL || fontwidth == NULL || fontstride == NULL ||
	    fontaddr == NULL || *fontheight == 0 || *fontwidth == 0 ||
	    *fontstride < howmany(*fontwidth, NBBY) ||
	    *fontstride > 4 /* paranoia */)
		return;

	p9100_romfont.fontwidth = *fontwidth;
	p9100_romfont.fontheight = *fontheight;
	p9100_romfont.stride = *fontstride;
	p9100_romfont.data = *fontaddr;
	
#ifdef DEBUG
	printf("%s: PROM font %dx%d-%d @@%p",
	    sc->sc_sunfb.sf_dev.dv_xname, *fontwidth, *fontheight,
	    *fontstride, *fontaddr);
#endif

	/*
	 * Build and add a wsfont structure
	 */
	wsfont_init();	/* if not done before */
	if (wsfont_add(&p9100_romfont, 0) != 0)
		return;

	/*
	 * Select this very font in our rasops structure
	 */
	ri->ri_wsfcookie = wsfont_find(ROMFONTNAME, 0, 0, 0);
	if (wsfont_lock(ri->ri_wsfcookie, &ri->ri_font,
	    WSDISPLAY_FONTORDER_L2R, WSDISPLAY_FONTORDER_L2R) <= 0)
		ri->ri_wsfcookie = 0;
}

/*
 * External video control
 */

void
p9100_external_video(void *v, int on)
{
	struct p9100_softc *sc = v;
	int s;

	s = splhigh();

	if (on) {
		p9100_write_ramdac(sc, IBM525_POWER,
		    p9100_read_ramdac(sc, IBM525_POWER) & ~P_DAC_PWR_DISABLE);
		SET(sc->sc_flags, SCF_EXTERNAL);
	} else {
		p9100_write_ramdac(sc, IBM525_POWER,
		    p9100_read_ramdac(sc, IBM525_POWER) | P_DAC_PWR_DISABLE);
		CLR(sc->sc_flags, SCF_EXTERNAL);
	}

	splx(s);
}

/*
 * Video mode programming
 *
 * All magic values come from s3gxtrmb.pdf.
 */

#if NTCTRL > 0

/* IBM RGB525 registers and values */

static const u_int8_t p9100_dacreg[] = {
	IBM525_MISC1,
	IBM525_MISC2,
	IBM525_MISC3,
	IBM525_MISC4,
	IBM525_MISC_CLOCK,
	IBM525_SYNC,
	IBM525_HSYNC_POS,
	IBM525_POWER,
	IBM525_DAC_OP,
	IBM525_PALETTE,
	IBM525_PIXEL,
	IBM525_PF8,
	IBM525_PF16,
	IBM525_PF24,
	IBM525_PF32,
	IBM525_PLL1,
	IBM525_PLL2,
	IBM525_PLL_FIXED_REF,
	IBM525_SYSCLK,
	IBM525_PLL_REF_DIV,
	IBM525_PLL_VCO_DIV,
	0
};

static u_int8_t p9100_dacval[] = {
	M1_SENSE_DISABLE | M1_VRAM_64,
	M2_PCLK_PLL | M2_PALETTE_8 | M2_MODE_VRAM,
	0,
	0,				/* will be computed */
	MC_B24P_SCLK | MC_PLL_ENABLE,	/* will be modified */
	S_HSYN_NORMAL | S_VSYN_NORMAL,
	0,
	0,				/* will be computed */
	DO_FAST_SLEW,
	0,
	0,				/* will be computed */
	PF8_INDIRECT,
	PF16_DIRECT | PF16_LINEAR | PF16_565,
	PF24_DIRECT,
	PF32_DIRECT,
	P1_CLK_REF | P1_SRC_EXT_F | P1_SRC_DIRECT_F,
	0,	/* F0, will be set before */
	5,
	SC_ENABLE,
	5,
	MHZ_TO_PLL(50)
};

/* Power 9100 registers and values */

static const u_int32_t p9100_reg[] = {
	P9000_HTR,
	P9000_HSRE,
	P9000_HBRE,
	P9000_HBFE,
	P9000_HCP,
	P9000_VL,
	P9000_VSRE,
	P9000_VBRE,
	P9000_VBFE,
	P9000_VCP,
	0
};

static const u_int32_t p9100_val_800_32[] = {
	0x1f3, 0x023, 0x053, 0x1e3, 0x000, 0x271, 0x002, 0x016, 0x26e, 0x000
};
#if 0	/* No X server for this mode, yet */
static const u_int32_t p9100_val_800_24[] = {
	0x176, 0x01a, 0x03d, 0x169, 0x000, 0x271, 0x002, 0x016, 0x26e, 0x000
};
#endif
static const u_int32_t p9100_val_800_8[] = {
	0x07c, 0x008, 0x011, 0x075, 0x000, 0x271, 0x002, 0x016, 0x26e, 0x000
};
static const u_int32_t p9100_val_640_32[] = {
	0x18f, 0x02f, 0x043, 0x183, 0x000, 0x205, 0x003, 0x022, 0x202, 0x000
};
static const u_int32_t p9100_val_640_8[] = {
	0x063, 0x00b, 0x00d, 0x05d, 0x000, 0x205, 0x003, 0x022, 0x202, 0x000
};
static const u_int32_t p9100_val_1024_8[] = {
	0x0a7, 0x019, 0x022, 0x0a2, 0x000, 0x325, 0x003, 0x023, 0x323, 0x000
};

void
p9100_initialize_ramdac(struct p9100_softc *sc, u_int width, u_int depth)
{
	int s;
	const u_int8_t *dacregp, *dacvalp;
	const u_int32_t *p9regp, *p9valp;
	u_int8_t pllclk, dacval;
	u_int32_t scr;

	/*
	 * XXX Switching to a low-res 8bpp mode does not work correctly
	 * XXX unless coming from an high-res 8bpp mode, and I have
	 * XXX no idea why.
	 * XXX Of course, this mean that we can't reasonably use this
	 * XXX routine unless NTCTRL > 0.
	 */
	if (depth == 8 && width != 1024)
		p9100_initialize_ramdac(sc, 1024, 8);

	switch (width) {
	case 1024:
		p9valp = p9100_val_1024_8;
		pllclk = MHZ_TO_PLL(65);
		/* 1024 bytes scanline */
		scr = SCR_SC(0, 0, 0, 1) | SCR_PIXEL_8BPP;
		break;
	default:
		/* FALLTHROUGH */
	case 800:
		switch (depth) {
		case 32:
			p9valp = p9100_val_800_32;
			/* 3200 = 128 + 1024 + 2048 bytes scanline */
			scr = SCR_SC(3, 6, 7, 0) |
			    SCR_PIXEL_32BPP | SCR_SWAP_WORDS | SCR_SWAP_BYTES;
			break;
#if 0
		case 24:
			p9valp = p9100_val_800_24;
			/* 2400 = 32 + 64 + 256 + 2048 bytes scanline */
			scr = SCR_SC(1, 2, 4, 2) | SCR_PIXEL_24BPP;
			break;
#endif
		default:
		case 8:
			p9valp = p9100_val_800_8;
			/* 800 = 32 + 256 + 512 bytes scanline */
			scr = SCR_SC(1, 4, 5, 0) | SCR_PIXEL_8BPP;
			break;
		}
		pllclk = MHZ_TO_PLL(36);
		break;
	case 640:
		switch (depth) {
		case 32:
			p9valp = p9100_val_640_32;
			/* 2560 = 512 + 2048 bytes scanline */
			scr = SCR_SC(5, 7, 0, 0) |
			    SCR_PIXEL_32BPP | SCR_SWAP_WORDS | SCR_SWAP_BYTES;
			break;
		default:
		case 8:
			p9valp = p9100_val_640_8;
			/* 640 = 128 + 512 bytes scanline */
			scr = SCR_SC(3, 5, 0, 0) | SCR_PIXEL_8BPP;
			break;
		}
		pllclk = MHZ_TO_PLL(25);
		break;
	}
	dacvalp = p9100_dacval;

	s = splhigh();

#ifdef	FIDDLE_WITH_PCI_REGISTERS
	/*
	 * Magical initialization sequence, from s3gxtrmb.pdf.
	 * DANGER! Sometimes freezes the machine solid, cause unknown.
	 */
	sc->sc_pci->address = 0x13000000;
	sc->sc_pci->data = 0;
	sc->sc_pci->address = 0x30000000;
	sc->sc_pci->data = 0;
	sc->sc_pci->address = 0x41000000;
	sc->sc_pci->data = 0;	/* No register mapping at a0000 */
	sc->sc_pci->address = 0x04000000;
	sc->sc_pci->data = 0xa3000000;
#endif

	/*
	 * Initialize the RAMDAC
	 */
	P9100_SELECT_DAC(sc);
	P9100_WRITE_RAMDAC(sc, IBM525_PIXMASK, 0xff);
	P9100_FLUSH_DAC(sc);
	P9100_WRITE_RAMDAC(sc, IBM525_IDXCONTROL, 0x00);
	P9100_FLUSH_DAC(sc);

	p9100_write_ramdac(sc, IBM525_F(0), pllclk);
	for (dacregp = p9100_dacreg; *dacregp != 0; dacregp++, dacvalp++) {
		switch (*dacregp) {
		case IBM525_MISC4:
			dacval =  pllclk >= MHZ_TO_PLL(50) ?
			    M4_FAST : M4_INVERT_DCLK;
			break;
		case IBM525_MISC_CLOCK:
			dacval = *dacvalp & ~MC_DDOT_DIV_MASK;
			switch (depth) {
			case 32:
				dacval |= MC_DDOT_DIV_2;
				break;
			case 16:
				dacval |= MC_DDOT_DIV_4;
				break;
			default:
			case 24:
			case 8:
				dacval |= MC_DDOT_DIV_8;
				break;
			}
			break;
		case IBM525_POWER:
			if (depth == 24)
				dacval = 0;
			else
				dacval = P_SCLK_DISABLE;
			break;
		case IBM525_PIXEL:
			switch (depth) {
			case 32:
				dacval = PIX_32BPP;
				break;
			case 24:
				dacval = PIX_24BPP;
				break;
			case 16:
				dacval = PIX_16BPP;
				break;
			default:
			case 8:
				dacval = PIX_8BPP;
				break;
			}
			break;
		default:
			dacval = *dacvalp;
			break;
		}
		p9100_write_ramdac(sc, *dacregp, dacval);
	}

	/*
	 * Initialize the Power 9100
	 */

	P9100_SELECT_SCR(sc);
	P9100_WRITE_CTL(sc, P9000_SYSTEM_CONFIG, scr);
	P9100_SELECT_VCR(sc);
	P9100_WRITE_CTL(sc, P9000_SRTC1,
	    SRTC1_VSYNC_INTERNAL | SRTC1_HSYNC_INTERNAL | SRTC1_VIDEN | 0x03);
	P9100_WRITE_CTL(sc, P9000_SRTC2, 0x05);
	/* need to wait a bit before VRAM control registers are accessible */
	delay(3000);
	P9100_SELECT_VRAM(sc);
	P9100_WRITE_CTL(sc, P9000_MCR, 0xc808007d);
	delay(3000);

	P9100_SELECT_VCR(sc);
	for (p9regp = p9100_reg; *p9regp != 0; p9regp++, p9valp++)
		P9100_WRITE_CTL(sc, *p9regp, *p9valp);

	P9100_SELECT_VRAM(sc);
	P9100_WRITE_CTL(sc, P9000_REFRESH_PERIOD, 0x3ff);

	/* Disable frame buffer interrupts */
	P9100_SELECT_SCR(sc);
	P9100_WRITE_CTL(sc, P9000_INTERRUPT_ENABLE, IER_MASTER_ENABLE | 0);

	/*
	 * Enable internal video... (it's a kind of magic)
	 */
	p9100_write_ramdac(sc, IBM525_MISC4,
	    p9100_read_ramdac(sc, IBM525_MISC4) | 0xc0);

	/*
	 * ... unless it does not fit.
	 */
	if (width != sc->sc_lcdwidth) {
		CLR(sc->sc_flags, SCF_INTERNAL);
		tadpole_set_video(0);
	} else {
		SET(sc->sc_flags, SCF_INTERNAL);
		tadpole_set_video(1);
	}

	p9100_external_video(sc, ISSET(sc->sc_flags, SCF_EXTERNAL));

	splx(s);
}

void
p9100_prom(void *v)
{
	struct p9100_softc *sc = v;

	if (ISSET(sc->sc_flags, SCF_MAPPEDSWITCH) &&
	    sc->sc_mapmode != WSDISPLAYIO_MODE_EMUL) {
		p9100_initialize_ramdac(sc, sc->sc_lcdwidth, 8);
		fbwscons_setcolormap(&sc->sc_sunfb, p9100_setcolor);
		p9100_ras_init(sc);
	}
}
#endif	/* NTCTRL > 0 */
@


1.53
log
@Don't include sbusvar.h if you need neither sbus_translate() nor sbus_testdma().
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.52 2013/10/20 20:07:26 miod Exp $	*/
@


1.52
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.51 2013/05/31 22:07:49 deraadt Exp $	*/
a61 1
#include <sparc/dev/sbusvar.h>
@


1.51
log
@Replace shutdownhooks with activate functions, properly doing those
operations only if device is console
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.50 2011/05/31 17:40:19 miod Exp $	*/
d138 3
a140 10
	p9100_ioctl,
	p9100_mmap,
	NULL,	/* alloc_screen */
	NULL,	/* free_screen */
	NULL,	/* show_screen */
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	p9100_burner,
	NULL	/* pollc */
@


1.50
log
@The various cleanups of the last few years have fixed pnozz(4) acceleration
code operation in 640x480 mode (very likely p9100.c r1.47), so enable it
again by default.
Verified to work on a SPARCbook 3XP (with a 640x480 LCD panel), thanks
to Thibaud Bordier.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.49 2009/09/05 14:09:35 miod Exp $	*/
d159 1
d162 2
a163 1
	sizeof (struct p9100_softc), p9100match, p9100attach
d392 1
a392 1
	if (isconsole) {
d394 11
d406 1
a406 1
		shutdownhook_establish(p9100_prom, sc);
d408 1
d411 1
a411 1
	fbwscons_attach(&sc->sc_sunfb, &p9100_accessops, isconsole);
@


1.49
log
@Change the wsdisplay_emulops return types from void to int; emulops will now
return zero on success and nonzero on failure.
This commit only performs mechanical changes for the existing emulops to
always return zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.48 2008/12/26 23:46:19 miod Exp $	*/
d385 1
a385 3
	if (sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags != 0 ||
	    sc->sc_sunfb.sf_width == 800)
		p9100_ras_init(sc);
d435 1
a435 3
			if (sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags != 0 ||
			    sc->sc_sunfb.sf_width == 800)
				p9100_ras_init(sc);
d1339 1
a1339 3
		if (sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags != 0 ||
		    sc->sc_sunfb.sf_width == 800)
			p9100_ras_init(sc);
@


1.48
log
@Use the `fontbytes' display property as the font stride, instead of
computing it ourselves.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.47 2008/12/26 22:30:21 miod Exp $	*/
d150 5
a154 5
void	p9100_ras_copycols(void *, int, int, int, int);
void	p9100_ras_copyrows(void *, int, int, int);
void	p9100_ras_do_cursor(struct rasops_info *);
void	p9100_ras_erasecols(void *, int, int, int, long int);
void	p9100_ras_eraserows(void *, int, int, long int);
d755 1
a755 1
void
d789 2
d793 1
a793 1
void
d825 2
d829 1
a829 1
void
d860 2
d864 1
a864 1
void
d900 2
d904 1
a904 1
void
d931 2
@


1.47
log
@Move the logic responsible from deciding whether a frame buffer needs to be
cleared on attach, from the individual drivers to the common frame buffer code;
the latter will decide based on the prom font metrics and the prom console
window position, whenever possible.

This removes the need for the console window position to be hardcoded in
the p9100 driver, and will no longer require a screen clear on a vigra
VS-12 in high resolution mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.46 2008/12/26 00:42:19 miod Exp $	*/
d946 2
a947 2
	int *romwidth, *romheight;
	u_int8_t **romaddr;
d961 4
a964 3
	    "addr char-height %lx ! addr char-width %lx ! addr font-base %lx !",
	    (vaddr_t)&romheight, (vaddr_t)&romwidth, (vaddr_t)&romaddr) >=
	    sizeof buf)
d966 2
a967 1
	romheight = romwidth = NULL;
d970 4
a973 2
	if (romheight == NULL || romwidth == NULL || romaddr == NULL ||
	    *romheight == 0 || *romwidth == 0 || *romaddr == NULL)
d976 4
a979 4
	p9100_romfont.fontwidth = *romwidth;
	p9100_romfont.fontheight = *romheight;
	p9100_romfont.stride = howmany(*romwidth, NBBY);
	p9100_romfont.data = *romaddr;
d982 3
a984 2
	printf("%s: PROM font %dx%d @@%p",
	    sc->sc_sunfb.sf_dev.dv_xname, *romwidth, *romheight, *romaddr);
@


1.46
log
@When running on serial console, do not try to pick the prom font (this would
fail anyway since stdout is not a frame buffer), and force a complete
ramdac initialization - access to several of the control registers spin
otherwise.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.45 2007/07/13 19:18:18 miod Exp $	*/
d131 1
a131 1
int	p9100_pick_romfont(struct p9100_softc *);
d277 1
a277 1
	int isconsole, fontswitch = 0, clear = 0;
d363 1
a363 11
	 * If we can, we still need to adjust the visible portion of the
	 * display, as the PROM output is offset two chars to the left.
	 *
	 * If we can't, we'll switch to the 8x16 font, and we'll need to adjust
	 * two things:
	 * - the display row should be overrided from the current PROM metrics,
	 *   to prevent us from overwriting the last few lines of text.
	 * - if the 80x34 screen would make a large margin appear around it,
	 *   choose to clear the screen rather than keeping old prom output in
	 *   the margins.
	 * XXX there should be a rasops "clear margins" feature
d366 1
a366 1
		fontswitch = p9100_pick_romfont(sc);
d379 1
a379 7
	if (isconsole == 0 || fontswitch)
		clear = 1;
	fbwscons_init(&sc->sc_sunfb, clear ? RI_CLEAR : 0);
	if (clear == 0) {
		ri->ri_bits -= 2 * ri->ri_xscale;
		ri->ri_xorigin -= 2 * ri->ri_xscale;
	}
d393 1
a393 1
		fbwscons_console_init(&sc->sc_sunfb, clear ? 0 : -1);
d942 1
a942 1
int
d955 1
a955 1
		return (1);
d964 1
a964 1
		return (1);
d970 1
a970 1
		return (1);
d987 1
a987 1
		return (1);
d994 1
a994 1
	    WSDISPLAY_FONTORDER_L2R, WSDISPLAY_FONTORDER_L2R) <= 0) {
a995 4
		return (1);
	}
	
	return (0);
@


1.45
log
@Reenable accelerated text console primitives on pnozz if running with a
800x600 panel, and document the acceleration code as currently broken on
640x480 panels.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.44 2007/02/25 18:14:48 miod Exp $	*/
d4 1
a4 1
 * Copyright (c) 2003, 2005, 2006, Miodrag Vallat.
d250 13
d276 2
a277 2
	int node, pri, scr, force_reset;
	int isconsole, fontswitch, clear = 0;
a309 16
	switch (scr & SCR_PIXEL_MASK) {
	default:
#ifdef DIAGNOSTIC
		printf(": unknown color depth code 0x%x",
		    scr & SCR_PIXEL_MASK);
#endif
		/* FALLTHROUGH */
	case SCR_PIXEL_32BPP:
	case SCR_PIXEL_24BPP:
	case SCR_PIXEL_16BPP:
		force_reset = 1;
		break;
	case SCR_PIXEL_8BPP:
		force_reset = 0;
		break;
	}
d322 9
d375 2
a376 1
	fontswitch = p9100_pick_romfont(sc);
a1128 1
#if NTCTRL > 0
a1137 1
#endif
d1149 1
a1149 1
	 * XXX Switching to a low-res 8bpp mode causes kernel faults
d1152 2
d1300 2
@


1.44
log
@Disable acceleration by default; set device flags to a nonzero value to
enable.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.43 2007/02/18 18:40:35 miod Exp $	*/
a74 7
 * Built-in LCD panel geometry
 */

#define	LCD_WIDTH	800
#define	LCD_HEIGHT	600

/*
d116 2
d314 1
a314 2
	fb_setsize(&sc->sc_sunfb, 8, LCD_WIDTH, LCD_HEIGHT, node,
	    ca->ca_bustype);
a315 1
#if 0
d317 2
a318 2
	 * The PROM will initialize us in 800x600x8 mode anyway. If it
	 * does not, we'll force this mode right now.
d320 2
a321 13
	if (sc->sc_sunfb.sf_width != LCD_WIDTH || sc->sc_sunfb.sf_depth != 8 ||
	    sc->sc_sunfb.sf_height != LCD_HEIGHT || force_reset != 0) {
		sc->sc_sunfb.sf_width = LCD_WIDTH;
		sc->sc_sunfb.sf_height = LCD_HEIGHT;
		sc->sc_sunfb.sf_depth = 8;
		sc->sc_sunfb.sf_linebytes = LCD_WIDTH;

		printf("\n");
		p9100_initialize_ramdac(sc, LCD_WIDTH, 8);
		printf("%s", self->dv_xname);
		clear = 1;
	}
#endif
d330 2
a331 2
	sc->sc_mapwidth = LCD_WIDTH;
	sc->sc_mapheight = LCD_HEIGHT;
d343 2
a344 1
	printf(": rev %x, %dx%d\n", scr & SCR_ID_MASK, LCD_WIDTH, LCD_HEIGHT);
d394 2
a395 1
	if (sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags != 0)
d442 1
a442 1
				p9100_initialize_ramdac(sc, LCD_WIDTH, 8);
d446 2
a447 1
			if (sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags != 0)
d464 2
a465 2
			wdf->width  = LCD_WIDTH;
			wdf->height = LCD_HEIGHT;
d1317 1
a1317 1
	if (width != LCD_WIDTH) {
d1337 1
a1337 1
		p9100_initialize_ramdac(sc, LCD_WIDTH, 8);
d1339 2
a1340 1
		if (sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags != 0)
@


1.43
log
@Display the interrupt priority in dmesg, for frame buffers which register
interrupt handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.42 2006/12/27 18:54:04 miod Exp $	*/
d411 2
a412 1
	p9100_ras_init(sc);
d462 2
a463 1
			p9100_ras_init(sc);
d1354 2
a1355 1
		p9100_ras_init(sc);
@


1.42
log
@Add code to change video mode (resolution and color depth) on the fly for
pnozz(4), when switching between emulation (i.e. text console) and mapped
(i.e.  X11) modes.

Geometries different than 800x600 are only available on the external video
port, with the internal panel blanked.

Currently this mode is compiled in, until an interface allows the X server
and the kernel to settle on which one to use.

Due to the internal panel blanking requirements, all of this is only available
if tctrl(4) is configured in, which is the case for GENERIC but not for
installation media kernels (who runs X11 with installation media anyway?)

Most of this has been written 18 months ago, it was just lacking a final
touch...
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.41 2006/12/02 11:24:02 miod Exp $	*/
d268 1
a268 1
	int node, scr, force_reset;
d271 3
d369 1
a369 2
	intr_establish(ra->ra_intr[0].int_pri, &sc->sc_ih, IPL_FB,
	    self->dv_xname);
@


1.41
log
@Use ri_devcmap to get corrected color values, instead of directly using
WSCOL_xxxx values.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.40 2006/11/29 19:08:22 miod Exp $	*/
d4 1
a4 1
 * Copyright (c) 2003, 2005, Miodrag Vallat.
d72 9
d90 11
d104 1
a104 1
	struct rom_reg	sc_phys;
d107 4
d113 11
a123 2
	int		sc_flags;
#define	SCF_EXTERNAL		0x01	/* external video enabled */
d129 1
d137 1
d267 3
a269 2
	int node, scr, fb_depth;
	int isconsole, fontswitch, clear;
d272 1
a272 1
	if (ca->ca_ra.ra_nreg < P9100_NREG - 1) {
d274 1
a274 1
		    P9100_NREG, ca->ca_ra.ra_nreg);
d279 2
a280 1
	sc->sc_flags = 0;
d282 1
a282 1
	sc->sc_phys = ca->ca_ra.ra_reg[P9100_REG_VRAM];
d284 9
a292 4
	sc->sc_ctl = mapiodev(&ca->ca_ra.ra_reg[P9100_REG_CTL], 0,
	    ca->ca_ra.ra_reg[P9100_REG_CTL].rr_len);
	sc->sc_cmd = mapiodev(&ca->ca_ra.ra_reg[P9100_REG_CMD], 0,
	    ca->ca_ra.ra_reg[P9100_REG_CMD].rr_len);
d294 1
a294 1
	node = ca->ca_ra.ra_node;
d300 6
a306 2
		fb_depth = 32;
		break;
a307 2
		fb_depth = 24;
		break;
d309 1
a309 1
		fb_depth = 16;
a310 6
	default:
#ifdef DIAGNOSTIC
		printf(": unknown color depth code 0x%x, assuming 8\n%s",
		    scr & SCR_PIXEL_MASK, self->dv_xname);
#endif
		/* FALLTHROUGH */
d312 1
a312 1
		fb_depth = 8;
d316 2
a317 1
	fb_setsize(&sc->sc_sunfb, fb_depth, 800, 600, node, ca->ca_bustype);
d319 37
a355 2
	ri->ri_bits = mapiodev(&sc->sc_phys, 0,
	    round_page(sc->sc_sunfb.sf_fbsize));
d358 1
a358 3
	printf(": rev %x, %dx%d, depth %d\n", scr & SCR_ID_MASK,
	    sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height,
	    sc->sc_sunfb.sf_depth);
d366 1
a366 1
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih, IPL_FB,
d397 2
a398 1
	clear = !isconsole || fontswitch;
d400 1
a400 1
	if (!clear) {
d407 1
a407 1
	 * Plug-in accelerated console operations if we can.
d409 1
a409 2
	if (sc->sc_sunfb.sf_depth == 8)
		p9100_ras_init(sc);
d416 3
d442 17
a458 3
		/* Restore proper acceleration state upon leaving X11 */
		if (*(u_int *)data == WSDISPLAYIO_MODE_EMUL &&
		    sc->sc_sunfb.sf_depth == 8) {
d460 1
d466 14
a479 4
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
		wdf->cmsize = 256;
d483 7
a489 1
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
d520 5
a524 1
			dp->curval = tadpole_get_video() & TV_ON ? 1 : 0;
d539 2
a540 1
			tadpole_set_video(dp->curval);
d568 1
d573 24
a596 2
	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys, offset) | PMAP_NC);
d599 1
a599 1
	return (-1);
d681 2
a682 1
	tadpole_set_video(on);
d1025 1
d1037 1
a1037 1
		sc->sc_flags |= SCF_EXTERNAL;
d1041 1
a1041 1
		sc->sc_flags &= ~SCF_EXTERNAL;
d1046 308
@


1.40
log
@Add an unpack_attr function to struct wsdisplay_emulops, to match the
existing alloc_attr function. This allows rasops_unpack_attr to be kept
private to rasops, yet available to the screen drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.39 2006/06/02 20:00:54 miod Exp $	*/
d718 1
d751 1
d795 2
a796 1
	P9100_WRITE_CMD(sc, P9100_DE_COLOR0, P9100_COLOR8(WSCOL_BLACK));
@


1.39
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.38 2005/07/19 09:36:04 miod Exp $	*/
d717 1
a717 1
	rasops_unpack_attr(attr, &fg, &bg, NULL);
d749 1
a749 1
	rasops_unpack_attr(attr, &fg, &bg, NULL);
@


1.38
log
@On the SPARCbooks, allow tctrl(4) to control the external video output,
acting when the external display status changes, with the help of the
pnozz(4) driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.37 2005/07/09 22:22:12 miod Exp $	*/
a83 1
	struct sbusdev	sc_sd;		/* sbus device */
a337 2

	sbus_establish(&sc->sc_sd, &sc->sc_sunfb.sf_dev);
@


1.37
log
@In the interrupt handlers, clear the interrupt condition explicitely;
saves us a few unnecessary colormap updates.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.36 2005/03/26 15:16:14 miod Exp $	*/
d64 1
d72 9
d83 3
a85 3
	struct	sunfb sc_sunfb;		/* common base part */
	struct	sbusdev sc_sd;		/* sbus device */
	struct	rom_reg	sc_phys;	/* phys address description */
d88 4
a91 2
	union	bt_cmap sc_cmap;	/* Brooktree color map */
	struct	intrhand sc_ih;
d96 1
d105 2
a139 8
 * SBus registers mappings
 */
#define	P9100_NREG		3
#define	P9100_REG_CTL		0
#define	P9100_REG_CMD		1
#define	P9100_REG_VRAM		2

/*
d237 1
a237 1
	if (ca->ca_ra.ra_nreg < P9100_NREG) {
d244 2
d248 1
a248 1
	sc->sc_ctl = mapiodev(&(ca->ca_ra.ra_reg[P9100_REG_CTL]), 0,
d250 1
a250 1
	sc->sc_cmd = mapiodev(&(ca->ca_ra.ra_reg[P9100_REG_CMD]), 0,
d278 1
d280 1
d314 12
d461 1
a461 1
	if (offset & PGOFSET)
d509 25
d885 24
@


1.36
log
@Use the PROM font whenever possible, rather than switching to the
not-so-nice 8x16 font upon attach.

Also, shift the display two character cells to the left from its
centered position in this case, so as to keep our output properly
aligned with the PROM messages.

Tested on 3GS and 3GX.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.35 2005/03/23 17:16:34 miod Exp $	*/
d127 4
a130 4
#define	P9100_NREG	3
#define	P9100_REG_CTL	0
#define	P9100_REG_CMD	1
#define	P9100_REG_VRAM	2
d136 8
a143 16
/* Palette write address */
#define	IBM525_WRADDR			0
/* Palette data */
#define	IBM525_DATA			1
/* Pixel mask */
#define	IBM525_PIXMASK			2
/* Read palette address */
#define	IBM525_RDADDR			3
/* Register index low */
#define	IBM525_IDXLOW			4
/* Register index high */
#define	IBM525_IDXHIGH			5
/* Register data */
#define	IBM525_REGDATA			6
/* Index control */
#define	IBM525_IDXCONTROL		7
d154 2
a155 1
	*(volatile u_int32_t *)((sc)->sc_ctl + P9100_RAMDAC_REGISTER(reg))
d163 1
a163 1
	    (value)
d240 1
a240 1
	    ca->ca_ra.ra_reg[0].rr_len);
d242 1
a242 1
	    ca->ca_ra.ra_reg[1].rr_len);
d264 1
d278 4
a286 4
	/* Disable frame buffer interrupts */
	P9100_SELECT_SCR(sc);
	P9100_WRITE_CTL(sc, P9000_INTERRUPT_ENABLE, IER_MASTER_ENABLE | 0);

d466 1
a466 1
	P9100_WRITE_RAMDAC(sc, IBM525_WRADDR, start << 16);
d471 1
a471 1
		P9100_WRITE_RAMDAC(sc, IBM525_DATA, (*p) << 16);
d520 4
d797 1
a797 1
	snprintf(buf, sizeof buf, "stdout @@ is my-self "
d799 3
a801 1
	    (vaddr_t)&romheight, (vaddr_t)&romwidth, (vaddr_t)&romaddr);
@


1.35
log
@Move the alloc_screen, free_screen and show_screen wsdisplay accessops to
the common frame buffer code, rather than duplicating it in every driver.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.34 2005/03/23 17:15:44 miod Exp $	*/
d4 1
a4 1
 * Copyright (c) 2003, Miodrag Vallat.
d49 1
d57 1
d90 1
d231 1
d233 2
a234 2
	int node, row, scr;
	int isconsole, fb_depth;
d276 1
a276 1
	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(&sc->sc_phys, 0,
d278 1
a278 1
	sc->sc_sunfb.sf_ro.ri_hw = sc;
d294 7
a300 3
	 * If the framebuffer width is under 1024x768, we will switch from the
	 * PROM font to the more adequate 8x16 font here.
	 * However, we need to adjust two things in this case:
d308 7
a314 2
	fbwscons_init(&sc->sc_sunfb,
	    isconsole && (sc->sc_sunfb.sf_width >= 1024) ? 0 : RI_CLEAR);
d329 1
a329 6
		if (sc->sc_sunfb.sf_width < 1024)
			row = 0;	/* screen has been cleared above */
		else
			row = -1;

		fbwscons_console_init(&sc->sc_sunfb, row);
d762 75
@


1.34
log
@Do not set up accelerated operations if we fail to unbusy the blitter in
a reasonable amount of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.33 2005/03/07 16:44:50 miod Exp $	*/
a54 1
#include <dev/wscons/wscons_raster.h>
a77 1
	int	sc_nscreens;
d81 2
d84 3
a86 5
int	p9100_alloc_screen(void *, const struct wsscreen_descr *, void **,
	    int *, int *, long *);
void	p9100_free_screen(void *, void *);
int	p9100_show_screen(void *, void *, int, void (*cb)(void *, int, int),
	    void *);
a87 3
static __inline__ void p9100_loadcmap_deferred(struct p9100_softc *,
    u_int, u_int);
void	p9100_loadcmap_immediate(struct p9100_softc *, u_int, u_int);
a88 2
void	p9100_burner(void *, u_int, u_int);
int	p9100_intr(void *);
d93 3
a95 3
	p9100_alloc_screen,
	p9100_free_screen,
	p9100_show_screen,
d100 1
a102 1
void	p9100_ras_init(struct p9100_softc *);
d108 1
a430 42
int
p9100_alloc_screen(void *v, const struct wsscreen_descr *type, void **cookiep,
    int *curxp, int *curyp, long *attrp)
{
	struct p9100_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	if (sc->sc_sunfb.sf_depth == 8) {
		sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
		    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	} else {
		sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
		    0, 0, 0, attrp);
	}
	sc->sc_nscreens++;
	return (0);
}

void
p9100_free_screen(void *v, void *cookie)
{
	struct p9100_softc *sc = v;

	sc->sc_nscreens--;
}

int
p9100_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
{
	return (0);
}

/*
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
 */
@


1.33
log
@Do not bother passing the blanking routine to fbwscons_console_init(),
as fbwscons_attach() can find it on its own.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.32 2005/01/05 23:04:25 miod Exp $	*/
d398 1
a398 1
			dp->curval = tadpole_get_video() & TV_ON;
d576 1
a576 1
static __inline__ void p9100_drain(struct p9100_softc *);
d578 1
a578 1
static __inline__ void
d581 9
a589 2
	while (P9100_READ_CMD(sc, P9000_PE_STATUS) &
	    (STATUS_QUAD_BUSY | STATUS_BLIT_BUSY));
d595 4
d601 4
a604 7
#if NTCTRL > 0
	if (tadpole_get_video() & TV_ACCEL) {
		sc->sc_sunfb.sf_ro.ri_ops.erasecols = p9100_ras_erasecols;
		sc->sc_sunfb.sf_ro.ri_ops.eraserows = p9100_ras_eraserows;
		sc->sc_sunfb.sf_ro.ri_do_cursor = p9100_ras_do_cursor;
	}
#endif
@


1.32
log
@Let wsdisplay drivers return zero for WSDISPLAYIO_[GS]VIDEO ioctls - most
of the work is done in the upper layer, but they get to see the ioctl,
so don't always return an error.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.31 2004/11/29 22:07:37 miod Exp $	*/
d327 1
a327 1
		fbwscons_console_init(&sc->sc_sunfb, row, p9100_burner);
@


1.31
log
@Move the struct wsscreen_descr from a per-driver global to a per-instance
field of the sunfb structure. This allows multiple instances of the same driver,
but with different resolutions (such as a couple of vigra or a TGX cgsix and
a TGX+ cgsix) to use distinct wsscreen_descr structures featuring different
resolution information.

Doing this allows more wsscreen_descr fiddling inside the sparc* fb api,
and results in some code shrinkage (about 4KB on sparc GENERIC).
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.30 2004/09/29 07:35:11 miod Exp $	*/
d423 2
@


1.30
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.29 2004/05/12 16:26:11 deraadt Exp $	*/
a82 13
struct wsscreen_descr p9100_stdscreen = {
	"std",
};

const struct wsscreen_descr *p9100_scrlist[] = {
	&p9100_stdscreen,
};

struct wsscreen_list p9100_screenlist = {
	sizeof(p9100_scrlist) / sizeof(struct wsscreen_descr *),
	    p9100_scrlist
};

a234 1
	struct wsemuldisplaydev_attach_args waa;
a315 5
	p9100_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	p9100_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	p9100_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	p9100_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

d327 1
a327 2
		fbwscons_console_init(&sc->sc_sunfb, &p9100_stdscreen, row,
		    p9100_burner);
d330 1
a330 5
	waa.console = isconsole;
	waa.scrdata = &p9100_screenlist;
	waa.accessops = &p9100_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
@


1.29
log
@if tctrl not there, still let this compile; miod ok
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.28 2004/05/10 09:05:52 miod Exp $	*/
d302 2
a303 1
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih, IPL_FB);
@


1.28
log
@When external power is not available, the tadpole video hardware gets
stuck in a weird mode, where not all acceleration functions are
available, and I could not figure out how to reset the chip strongly
enough to leave this mode.

Try to compensate by checking whether the external power has been removed,
when we set up the accelerated rasops (this will not cope with power being
removed after bootup, yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.27 2004/03/09 22:59:09 miod Exp $	*/
d611 1
d617 1
a617 1

@


1.27
log
@Real, inverted, cursor.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.26 2004/02/27 22:32:20 miod Exp $	*/
d326 1
a326 6
	if (sc->sc_sunfb.sf_depth == 8) {
		sc->sc_sunfb.sf_ro.ri_ops.copycols = p9100_ras_copycols;
		sc->sc_sunfb.sf_ro.ri_ops.copyrows = p9100_ras_copyrows;
		sc->sc_sunfb.sf_ro.ri_ops.erasecols = p9100_ras_erasecols;
		sc->sc_sunfb.sf_ro.ri_ops.eraserows = p9100_ras_eraserows;
		sc->sc_sunfb.sf_ro.ri_do_cursor = p9100_ras_do_cursor;
a327 1
	}
d421 1
a421 1
			dp->curval = tadpole_get_video();
d609 8
@


1.26
log
@Typos
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.25 2003/11/07 10:16:45 jmc Exp $	*/
d641 4
d799 2
a800 1
	    (~P9100_RASTER_DST) & P9100_RASTER_MASK);
@


1.25
log
@adress -> address, and a few more; all from Jonathon Gray;

(mvme68k/mvme88k) vs.c and (vax) if_le.c ok miod@@
isakmpd ones ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.24 2003/06/28 17:05:33 miod Exp $	*/
d616 1
a616 1
	 * Setup safe defaults for the parameter and drawing engine, in
@


1.24
log
@Sync sparc fb API with the sparc64 changes (fbwscons_init takes flags, and
the sunfb structure keeps pointer to the prom cursor coordinates).
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.23 2003/06/17 21:21:32 miod Exp $	*/
d194 1
a194 1
 * when writing to an adress which upper 25 bit differ from the previous
@


1.23
log
@New driver and wsdisplay type for the Weitek Power9000 and Brooktree Bt445
combination, found on the Tadpole SPARCbook 3 only (later model use the
Power9100 and are already supported).

Untested for lack of hardware and volunteers, but carefully crafted; if it
does not work out of the box, this should be a good starting point.

"worth having in the tree" millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.22 2003/06/13 23:40:12 miod Exp $	*/
d320 1
a320 1
	    isconsole && (sc->sc_sunfb.sf_width >= 1024));
@


1.22
log
@eraserows() was missing a coordinate address latch.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.21 2003/06/13 21:04:45 miod Exp $	*/
d31 3
a33 2
 * color display (p9100) driver.  Based on cgthree.c and the NetBSD
 * p9100 driver.
d63 2
d75 2
a76 2
	struct	p9100_cmd *sc_cmd;	/* command registers (dac, etc) */
	struct	p9100_ctl *sc_ctl;	/* control registers (draw engine) */
d149 1
a149 2
 * System control and command registers
 * (IBM RGB528 RamDac, p9100, video coprocessor)
a150 73
struct p9100_ctl {
	/* System control registers: 0x0000 - 0x00ff */
	struct p9100_scr {
		volatile u_int32_t	:32;
		volatile u_int32_t	scr;		/* system config reg */
#define	SCR_ID_MASK		0x00000007
#define	SCR_PIXEL_MASK		0x1c000000
#define	SCR_PIXEL_8BPP		0x08000000
#define	SCR_PIXEL_16BPP		0x0c000000
#define	SCR_PIXEL_24BPP		0x1c000000
#define	SCR_PIXEL_32BPP		0x14000000
		volatile u_int32_t	ir;		/* interrupt reg */
		volatile u_int32_t	ier;		/* interrupt enable */
#define	IER_MASTER_ENABLE	0x00000080
#define	IER_MASTER_INTERRUPT	0x00000040
#define	IER_VBLANK_ENABLE	0x00000020
#define	IER_VBLANK_INTERRUPT	0x00000010
#define	IER_PICK_ENABLE		0x00000008
#define	IER_PICK_INTERRUPT	0x00000004
#define	IER_IDLE_ENABLE		0x00000002
#define	IER_IDLE_INTERRUPT	0x00000001
		volatile u_int32_t	arbr;		/* alt read bank reg */
		volatile u_int32_t	awbr;		/* alt write bank reg */
		volatile u_int32_t	unused1[58];
	} ctl_scr;

	/* Video control registers: 0x0100 - 0x017f */
	struct p9100_vcr {
		volatile u_int32_t	:32;
		volatile u_int32_t	hcr;		/* horizontal cntr */
		volatile u_int32_t	htr;		/* horizontal total */
		volatile u_int32_t	hsre;		/* horiz sync rising */
		volatile u_int32_t	hbre;		/* horiz blank rising */
		volatile u_int32_t	hbfe;		/* horiz blank fallng */
		volatile u_int32_t	hcp;		/* horiz cntr preload */
		volatile u_int32_t	vcr;		/* vertical cntr */
		volatile u_int32_t	vl;		/* vertical length */
		volatile u_int32_t	vsre;		/* vert sync rising */
		volatile u_int32_t	vbre;		/* vert blank rising */
		volatile u_int32_t	vbfe;		/* vert blank fallng */
		volatile u_int32_t	vcp;		/* vert cntr preload */
		volatile u_int32_t	sra;		/* scrn repaint addr */
		volatile u_int32_t	srtc1;		/* scrn rpnt time 1 */
#define	SRTC1_VIDEN	0x00000020
		volatile u_int32_t	qsf;		/* qsf counter */
		volatile u_int32_t	srtc2;		/* scrn rpnt time 2 */
		volatile u_int32_t	unused1[15];
	} ctl_vcr;

	/* VRAM control registers: 0x0180 - 0x1ff */
	struct p9100_vram {
		volatile u_int32_t	:32;
		volatile u_int32_t	mc;		/* memory config */
		volatile u_int32_t	rp;		/* refresh period */
		volatile u_int32_t	rc;		/* refresh count */
		volatile u_int32_t	rasmax;		/* ras low maximum */
		volatile u_int32_t	rascur;		/* ras low current */
		volatile u_int32_t	dacfifo;	/* free fifo */
		volatile u_int32_t	unused1[25];
	} ctl_vram;

	/* IBM RGB528 RAMDAC registers: 0x0200 - 0x3ff */
	struct p9100_dac {
		volatile u_int32_t	pwraddr;	/* wr palette address */
		volatile u_int32_t	paldata;	/* palette data */
		volatile u_int32_t	pixmask;	/* pixel mask */
		volatile u_int32_t	prdaddr;	/* rd palette address */
		volatile u_int32_t	idxlow;		/* reg index low */
		volatile u_int32_t	idxhigh;	/* reg index high */
		volatile u_int32_t	regdata;	/* register data */
		volatile u_int32_t	idxctrl;	/* index control */
		volatile u_int32_t	unused1[120];
	} ctl_dac;
d152 16
a167 3
	/* Video coprocessor interface: 0x0400 - 0x1fff */
	volatile u_int32_t	ctl_vci[768];
};
d170 1
a170 1
 * Power 9100 Drawing engine
d173 14
a186 115
struct p9100_coord {
	volatile u_int32_t	:32;
	volatile u_int32_t	:32;
	volatile u_int32_t	abs_x32;
	volatile u_int32_t	:32;
	volatile u_int32_t	abs_y32;
	volatile u_int32_t	:32;
	volatile u_int32_t	abs_x16y16;
	volatile u_int32_t	:32;
	volatile u_int32_t	:32;
	volatile u_int32_t	:32;
	volatile u_int32_t	rel_x32;
	volatile u_int32_t	:32;
	volatile u_int32_t	rel_y32;
	volatile u_int32_t	:32;
	volatile u_int32_t	rel_x16y16;
	volatile u_int32_t	:32;
};

/* How to encode a x16y16 value */
#define	P9100_COORDS(col,row)	((((col) & 0x0fff) << 16) | ((row) & 0x0fff))

struct p9100_cmd {
	/* Parameter engine 0x2000-0x217f */
	struct cmd_pe {
	volatile u_int32_t	status;		/* status register */
#define	STATUS_QUAD_BUSY	0x80000000
#define	STATUS_BLIT_BUSY	0x40000000
#define	STATUS_PICK_DETECTED	0x00000080
#define	STATUS_PIXEL_ERROR	0x00000040
#define	STATUS_BLIT_ERROR	0x00000020
#define	STATUS_QUAD_ERROR	0x00000010
#define	STATUS_QUAD_CONCAVE	0x00000008
#define	STATUS_QUAD_OUTSIDE	0x00000004
#define	STATUS_QUAD_INSIDE	0x00000002
#define	STATUS_QUAD_STRADDLE	0x00000001
	volatile u_int32_t	blit;		/* blit command */
	volatile u_int32_t	quad;		/* quad command */
	volatile u_int32_t	pixel8;		/* P9000 pixel8 command */
	volatile u_int32_t	:32;
	volatile u_int32_t	nextpixels;	/* next_pixels command */
	volatile u_int32_t	unused1[(0x80 - 0x18) / 4];
	volatile u_int32_t	pixel1[32];	/* pixel1 command */
	volatile u_int32_t	unused2[(0x180 - 0x100) / 4];

	/* Parameter engine registers 0x2180-0x21ff */
	volatile u_int32_t	:32;
	volatile u_int32_t	oor;		/* out of range register */
	volatile u_int32_t	:32;
	volatile u_int32_t	cindex;		/* index register */
	volatile u_int32_t	winoffset;	/* window offset (16+16) */
	volatile u_int32_t	winmin;		/* window minimum */
	volatile u_int32_t	winmax;		/* window maximum */
	volatile u_int32_t	:32;
	volatile u_int32_t	yclip;
	volatile u_int32_t	xclip;
	volatile u_int32_t	xedgeless;
	volatile u_int32_t	xedgegreater;
	volatile u_int32_t	yedgeless;
	volatile u_int32_t	yedgegreater;
	volatile u_int32_t	unused3[(0x200 - 0x1b8) / 4];
	} pe;

	/* Drawing engine 0x2200-0x2fff */
	struct cmd_de {
	volatile u_int32_t	color0;		/* fg color */
	volatile u_int32_t	color1;		/* bg color */
	volatile u_int32_t	planemask;	/* 8-bit plane mask */
	volatile u_int32_t	drawmode;	
#define	DM_PICK_CONTROL		0x00000008
#define	DM_PICK_ENABLE		0x00000004
#define	DM_BUFFER_CONTROL	0x00000002
#define	DM_BUFFER_ENABLE0	0x00000000
#define	DM_BUFFER_ENABLE1	0x00000001
	volatile u_int32_t	patternx;	/* Quad 16x16 pattern origin */
	volatile u_int32_t	patterny;	/* (4-bit) */
	volatile u_int32_t	raster;
	volatile u_int32_t	pixel8;		/* Pixel8 extra storage */
	volatile u_int32_t	winmin;		/* window min, same as above */
	volatile u_int32_t	winmax;		/* window max, same as above */
	volatile u_int32_t	unused1[(0x38 - 0x28) / 4];
	volatile u_int32_t	color2;
	volatile u_int32_t	color3;
	volatile u_int32_t	unused2[(0x80 - 0x40) / 4];
	volatile u_int32_t	pattern[4];	/* pattern for quad fill */
	volatile u_int32_t	user[4];	/* user defined registers */
	volatile u_int32_t	bwinmin;	/* byte window minimum */
	volatile u_int32_t	bwinmax;	/* byte window maximum */
	volatile u_int32_t	unused3[(0x3000 - 0x22a8) / 4];
	} de;

	/* Device coordinates 0x3000-0x31ff */
	struct cmd_dc {
	struct p9100_coord	coord[4];
	volatile u_int32_t	unused[(0x200 - 0x100) / 4];
	} dc;

	/* Load coordinates 0x3200-0x33ff */
	struct cmd_lc {
	struct p9100_coord	point;
	struct p9100_coord	line;
	struct p9100_coord	tri;
	struct p9100_coord	quad;
	struct p9100_coord	rect;
	} lc;
};

/* How to encode a color in 8 bit mode, for the drawing engine */
#define	P9100_COLOR8(col)		((col) | ((col) << 8) | ((col) << 16))

/* P9100 minterms for the raster register */
#define	P9100_RASTER_SRC	0x00cc
#define	P9100_RASTER_DST	0x00aa
#define	P9100_RASTER_PATTERN	0x00f0
#define	P9100_RASTER_MASK	0x00ff
d200 12
a211 6
#define	P9100_SELECT_SCR(sc)	((sc)->sc_junk = (sc)->sc_ctl->ctl_scr.scr)
#define	P9100_SELECT_VCR(sc)	((sc)->sc_junk = (sc)->sc_ctl->ctl_vcr.hcr)
#define	P9100_SELECT_VRAM(sc)	((sc)->sc_junk = (sc)->sc_ctl->ctl_vram.mc)
#define	P9100_SELECT_DAC(sc)	((sc)->sc_junk = (sc)->sc_ctl->ctl_dac.pwraddr)
#define	P9100_SELECT_VCI(sc)	((sc)->sc_junk = (sc)->sc_ctl->ctl_vci[0])
#define	P9100_SELECT_DE_LOW(sc)	((sc)->sc_junk = (sc)->sc_cmd->de.color0)
d213 1
a213 2
	((sc)->sc_junk = (sc)->sc_cmd->de.bwinmax)
#define	P9100_SELECT_PE(sc)	((sc)->sc_junk = (sc)->sc_cmd->pe.cindex)
d215 1
a215 1
	((sc)->sc_junk = (sc)->sc_cmd->##field##.abs_x32)
d225 1
a225 1
		(sc)->sc_junk = (sc)->sc_ctl->ctl_vram.dacfifo; \
d271 1
a271 1
	scr = sc->sc_ctl->ctl_scr.scr;
d306 1
a306 1
	sc->sc_ctl->ctl_scr.ier = IER_MASTER_ENABLE | 0;
d320 1
a320 1
	    isconsole && (sc->sc_sunfb.sf_width != 800));
d346 1
a346 1
		if (sc->sc_sunfb.sf_width == 800)
d539 1
a539 1
	sc->sc_ctl->ctl_dac.pwraddr = start << 16;
d544 1
a544 1
		sc->sc_ctl->ctl_dac.paldata = (*p) << 16;
a551 1

d554 3
a556 2
	sc->sc_ctl->ctl_scr.ier = IER_MASTER_ENABLE | IER_MASTER_INTERRUPT |
	    IER_VBLANK_ENABLE | IER_VBLANK_INTERRUPT;
d568 1
a568 1
	vcr = sc->sc_ctl->ctl_vcr.srtc1;
d573 1
a573 2
	/* XXX - what about WSDISPLAY_BURN_VBLANK? */
	sc->sc_ctl->ctl_vcr.srtc1 = vcr;
d585 1
a585 1
	if (sc->sc_ctl->ctl_scr.ir & IER_VBLANK_INTERRUPT) {
d590 2
a591 1
		sc->sc_ctl->ctl_scr.ier = IER_MASTER_ENABLE | 0;
d608 2
a609 1
	while (sc->sc_cmd->pe.status & (STATUS_QUAD_BUSY | STATUS_BLIT_BUSY));
a614 1

d621 2
a622 2
	sc->sc_cmd->de.drawmode = DM_PICK_CONTROL | 0 |
	    DM_BUFFER_CONTROL | DM_BUFFER_ENABLE0;
d624 4
a627 3
	sc->sc_cmd->de.patternx = 0;
	sc->sc_cmd->de.patterny = 0;
	sc->sc_cmd->de.planemask = 0xffffffff;	/* enable all planes */
d630 3
a632 3
	sc->sc_cmd->de.winmin = 0;
	sc->sc_cmd->de.winmax =
	    P9100_COORDS(sc->sc_sunfb.sf_width - 1, sc->sc_sunfb.sf_height - 1);
d635 3
a637 3
	sc->sc_cmd->de.bwinmin = 0;
	sc->sc_cmd->de.bwinmax =
	    P9100_COORDS(sc->sc_sunfb.sf_width - 1, sc->sc_sunfb.sf_height - 1);
d640 1
a640 1
	sc->sc_cmd->pe.winoffset = 0;
d660 2
a661 1
	sc->sc_cmd->de.raster = P9100_RASTER_SRC & P9100_RASTER_MASK;
d663 10
a672 8
	P9100_SELECT_COORD(sc,dc.coord[0]);
	sc->sc_cmd->dc.coord[0].abs_x16y16 = P9100_COORDS(src, row);
	sc->sc_cmd->dc.coord[1].abs_x16y16 =
	    P9100_COORDS(src + n, row + ri->ri_font->fontheight - 1);
	P9100_SELECT_COORD(sc,dc.coord[2]);
	sc->sc_cmd->dc.coord[2].abs_x16y16 = P9100_COORDS(dst, row);
	sc->sc_cmd->dc.coord[3].abs_x16y16 =
	    P9100_COORDS(dst + n, row + ri->ri_font->fontheight - 1);
d674 1
a674 1
	sc->sc_junk = sc->sc_cmd->pe.blit;
d694 2
a695 1
	sc->sc_cmd->de.raster = P9100_RASTER_SRC & P9100_RASTER_MASK;
d697 10
a706 8
	P9100_SELECT_COORD(sc,dc.coord[0]);
	sc->sc_cmd->dc.coord[0].abs_x16y16 = P9100_COORDS(ri->ri_xorigin, src);
	sc->sc_cmd->dc.coord[1].abs_x16y16 =
	    P9100_COORDS(ri->ri_xorigin + ri->ri_emuwidth - 1, src + n);
	P9100_SELECT_COORD(sc,dc.coord[2]);
	sc->sc_cmd->dc.coord[2].abs_x16y16 = P9100_COORDS(ri->ri_xorigin, dst);
	sc->sc_cmd->dc.coord[3].abs_x16y16 =
	    P9100_COORDS(ri->ri_xorigin + ri->ri_emuwidth - 1, dst + n);
d708 1
a708 1
	sc->sc_junk = sc->sc_cmd->pe.blit;
d730 9
a738 7
	sc->sc_cmd->de.raster = P9100_RASTER_PATTERN & P9100_RASTER_MASK;
	sc->sc_cmd->de.color0 = P9100_COLOR8(bg);

	P9100_SELECT_COORD(sc,lc.rect);
	sc->sc_cmd->lc.rect.abs_x16y16 = P9100_COORDS(col, row);
	sc->sc_cmd->lc.rect.abs_x16y16 =
	    P9100_COORDS(col + n, row + ri->ri_font->fontheight);
d740 1
a740 1
	sc->sc_junk = sc->sc_cmd->pe.quad;
d756 3
a758 2
	sc->sc_cmd->de.raster = P9100_RASTER_PATTERN & P9100_RASTER_MASK;
	sc->sc_cmd->de.color0 = P9100_COLOR8(bg);
d760 1
a760 1
	P9100_SELECT_COORD(sc,lc.rect);
d762 4
a765 3
		sc->sc_cmd->lc.rect.abs_x16y16 = P9100_COORDS(0, 0);
		sc->sc_cmd->lc.rect.abs_x16y16 =
		    P9100_COORDS(ri->ri_width, ri->ri_height);
d771 4
a774 4
		sc->sc_cmd->lc.rect.abs_x16y16 =
		    P9100_COORDS(ri->ri_xorigin, row);
		sc->sc_cmd->lc.rect.abs_x16y16 =
		    P9100_COORDS(ri->ri_xorigin + ri->ri_emuwidth, row + n);
d777 1
a777 1
	sc->sc_junk = sc->sc_cmd->pe.quad;
d794 2
a795 1
	sc->sc_cmd->de.raster = (~P9100_RASTER_DST) & P9100_RASTER_MASK;
d797 6
a802 5
	P9100_SELECT_COORD(sc,lc.rect);
	sc->sc_cmd->lc.rect.abs_x16y16 = P9100_COORDS(col, row);
	sc->sc_cmd->lc.rect.abs_x16y16 =
	    P9100_COORDS(col + ri->ri_font->fontwidth,
	        row + ri->ri_font->fontheight);
d804 1
a804 1
	sc->sc_junk = sc->sc_cmd->pe.quad;
@


1.21
log
@g/c an useless define.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.20 2003/06/13 19:02:13 miod Exp $	*/
d904 1
@


1.20
log
@Fix lower right edge bounds for quad operations.
(that's what you get for commiting before breakfast)
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.19 2003/06/13 06:44:55 miod Exp $	*/
a154 1
#define	SCR_PIXEL_ID_MASK	0x00000007
@


1.19
log
@Accelerated text console routines, using the Power 9100 drawing engine.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.18 2003/06/12 19:09:43 miod Exp $	*/
d349 1
a349 1
 * On the tadpole, the first write to a register group is ignored until
d786 1
a786 1
	    P9100_COORDS(sc->sc_sunfb.sf_width - 1, sc->sc_sunfb.sf_height);
d791 1
a791 1
	    P9100_COORDS(sc->sc_sunfb.sf_width - 1, sc->sc_sunfb.sf_height);
a870 1
	n--;
d884 1
a884 1
	    P9100_COORDS(col + n, row + ri->ri_font->fontheight - 1);
d908 1
a908 1
		    P9100_COORDS(ri->ri_width - 1, ri->ri_height - 1);
a910 1
		n--;
d917 1
a917 1
		    P9100_COORDS(ri->ri_xorigin + ri->ri_emuwidth - 1, row + n);
@


1.18
log
@Add an interrupt handler, and use it to defer colormap updates to the end
of the vertical retrace.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.17 2003/06/06 19:42:47 miod Exp $	*/
d4 1
d119 7
d152 1
a152 1
		volatile u_int32_t	unused0;
d178 1
a178 1
		volatile u_int32_t	unused0;
d193 1
d201 1
a201 1
		volatile u_int32_t	unused0;
d228 113
a340 1
#define	SRTC1_VIDEN	0x00000020
d342 5
d349 10
a358 3
 * Select the appropriate register group within the control registers
 * (must be done before any write to a register within the group, but
 * subsequent writes to the same group do not need to reselect).
d365 6
a382 7
/*
 * Drawing engine
 */
struct p9100_cmd {
	volatile u_int32_t	cmd_regs[0x800];
};

d384 1
a384 3
p9100match(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
d399 1
a399 3
p9100attach(parent, self, args)
	struct device *parent, *self;
	void *args;
d478 12
d518 1
a518 6
p9100_ioctl(v, cmd, data, flags, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
d534 8
d620 2
a621 6
p9100_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
d643 1
a643 3
p9100_free_screen(v, cookie)
	void *v;
	void *cookie;
d651 2
a652 6
p9100_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
d662 1
a662 4
p9100_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
d677 1
a677 4
p9100_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
	u_int8_t r, g, b;
d689 1
a689 3
p9100_loadcmap_immediate(sc, start, ncolors)
	struct p9100_softc *sc;
	u_int start, ncolors;
d715 1
a715 3
p9100_burner(v, on, flags)
	void *v;
	u_int on, flags;
d752 198
@


1.17
log
@Do not bother taking care of the frame buffer flags in the softc, if the
driver does not use any. Basically this changes all drivers but those that
can handle a P4 card.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.16 2003/06/05 22:32:09 miod Exp $	*/
a31 2
 *
 * Does not handle interrupts, even though they can occur.
d74 2
a76 1
	int	sc_nscreens;
d92 13
a104 10
int p9100_ioctl(void *, u_long, caddr_t, int, struct proc *);
int p9100_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void p9100_free_screen(void *, void *);
int p9100_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t p9100_mmap(void *, off_t, int);
void p9100_loadcmap(struct p9100_softc *, u_int, u_int);
void p9100_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
void p9100_burner(void *, u_int, u_int);
d155 8
d327 8
d423 1
a423 1
		p9100_loadcmap(sc, cm->index, cm->count);
d558 1
a558 1
	p9100_loadcmap(sc, index, 1);
d562 1
a562 1
p9100_loadcmap(sc, start, ncolors)
d579 10
d611 18
@


1.16
log
@Faster ramdac operation, by reducing the delay between register writes,
according to some Power9x00 documentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.15 2003/06/02 18:40:59 jason Exp $	*/
a245 1
	struct cfdata *cf = vcf;
a248 5
	/*
	 * Mask out invalid flags from the user.
	 */
	cf->cf_flags &= FB_USERMASK;

a276 1
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;
@


1.15
log
@nuke my clause 3 & 4 (and a couple jointly (c) with Theo).
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.14 2003/05/17 03:54:34 miod Exp $	*/
d188 2
a189 1
		volatile u_int32_t	unused1[26];
d224 11
a556 2
	P9100_SELECT_VRAM(sc);
	P9100_SELECT_VRAM(sc);
d559 1
a561 4
		/* These generate a short delay between ramdac writes */
		P9100_SELECT_VRAM(sc);
		P9100_SELECT_VRAM(sc);

d564 1
@


1.14
log
@No need to check for the 640x480 resolution case, since the minimal resolution
on the SPARCbook 3 series is 800x600 and is already small enough...
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.13 2003/05/16 18:40:32 miod Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.13
log
@Let the user control the brightness of the tadpole built-in display via
wsconsctl (wsconsctl -w display.brightness=xx).

Makes the lack of a physical knob almost supportable.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.12 2003/05/12 18:57:14 miod Exp $	*/
d219 1
a219 1
 * subsquent writes to the same group do not need to reselect).
d343 1
a343 5
		switch (sc->sc_sunfb.sf_width) {
		case 640:
			row = p9100_stdscreen.nrows - 1;
			break;
		case 800:
d345 1
a345 2
			break;
		default:
a346 2
			break;
		}
@


1.12
log
@Initial work to bring this driver in par with other sparc frame buffers:
- do not reprogram the colormap to black and white, after programming
  the rasops one (oops). This gives us back a black on white display
  with colour support.
- if the screen resolution would cause the switch from the prom font to
  a reasonably sized wsfont to leave text in the margins, clear the
  screen (cut and paste from similar code in vigra.c)
- try and use more symbolic constants rather than magical values all over
  the place.

Thanks to millert@@ for bringing a sparcbook here.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.11 2002/11/06 21:06:20 miod Exp $	*/
d377 3
d414 36
@


1.11
log
@- always initialize colormaps, even if the frame buffer is non console; this
  helps if the ramdac does not get initialized (idea from jason@@)
- only register a shutdown hook for the frame buffers which need it, if this
  is the console frame buffer. Otherwise this is just a waste of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.10 2002/09/23 18:13:38 miod Exp $	*/
d133 8
d149 7
d265 10
a274 3
	int node = 0, i;
	int isconsole, fb_depth, fb_cmsize;
	char *cp;
d277 1
a277 1
	sc->sc_phys = ca->ca_ra.ra_reg[2];
d279 1
a279 1
	sc->sc_ctl = mapiodev(&(ca->ca_ra.ra_reg[0]), 0,
d281 1
a281 1
	sc->sc_cmd = mapiodev(&(ca->ca_ra.ra_reg[1]), 0,
d288 3
a290 3
	i = sc->sc_ctl->ctl_scr.scr;
	switch ((i >> 26) & 7) {
	case 5:
d293 1
a293 1
	case 7:
d296 1
a296 1
	case 3:
a298 1
	case 2:
d300 5
d309 1
a309 1
	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(&(ca->ca_ra.ra_reg[2]), 0,
d312 18
a329 1
	fbwscons_init(&sc->sc_sunfb, isconsole);
a336 4
	printf(": rev %x, %dx%d, depth %d\n", i & 7,
	    sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height,
	    sc->sc_sunfb.sf_depth);

a338 8
	/* initialize color map */
	fb_cmsize = getpropint(node, "cmsize", 256);
	cp = &sc->sc_cmap.cm_map[0][0];
	cp[0] = cp[1] = cp[2] = 0;
	for (i = 1, cp = &sc->sc_cmap.cm_map[i][0]; i < fb_cmsize; cp += 3, i++)
		cp[0] = cp[1] = cp[2] = 0xff;
	p9100_loadcmap(sc, 0, 256);

d343 13
a355 1
		fbwscons_console_init(&sc->sc_sunfb, &p9100_stdscreen, -1,
d520 1
a520 1
	sc->sc_junk = sc->sc_ctl->ctl_dac.pwraddr;
d528 1
a528 1
		sc->sc_junk = sc->sc_ctl->ctl_dac.paldata;
@


1.10
log
@Get the wsdisplay capabilities from rasops, rather than attempting to
guess them at compile-time. Plus this makes cgtwelve a bit more clean.

ok fgs@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.9 2002/09/09 22:15:16 miod Exp $	*/
d287 1
d313 1
a313 1
		    p9100_setcolor, p9100_burner);
@


1.9
log
@Register more screen capabilities to work with the recent wsemul_sun changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.8 2002/08/12 10:44:04 miod Exp $	*/
a86 5
	0, 0,   /* will be filled in */
	0,
	0, 0,
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
	WSSCREEN_REVERSE | WSSCREEN_WSCOLORS
d288 1
@


1.8
log
@Convert sparc console code from rcons and pseudo-devices to rasops and wscons.
For most framebuffers it is faster.

Other changes include:
o 24 bit support in tcx(4) for the S24 framebuffer
o accelerated cgsix(4) text console
o new cgtwelve(4) driver for the GS framebuffer
o improved serial driver code
o better keyboard support

The following framebuffers have not been tested but should work: cgfour,
cgeight and cgfourteen

These changes will require XF4 changes, to use Xwsfb instead of Xsun*, to be
commited later today.

Most of the work by me during the LSM and the week after, with code borrowed
from jason@@, NetBSD (new serial code), and feedback from mickey@@. Work on
pnozz(4) done by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.7 2002/03/14 01:26:43 millert Exp $	*/
d90 1
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.6 2001/11/06 19:53:16 miod Exp $	*/
a52 1
#include <machine/fbio.h>
a54 1
#include <machine/fbvar.h>
d58 6
d75 1
a75 1
	struct	device sc_dev;		/* base device */
a76 1
	struct	fbdevice sc_fb;		/* frame buffer device */
d82 13
d97 29
a125 1
/* autoconfiguration driver */
a126 2
int	p9100match(struct device *, void *, void *);
void	p9100unblank(struct device *);
d129 1
a129 1
	sizeof(struct p9100_softc), p9100match, p9100attach
a135 12
/* frame buffer generic driver */
struct fbdriver p9100fbdriver = {
	p9100unblank, p9100open, p9100close, p9100ioctl, p9100mmap
};

extern int fbnode;
extern struct tty *fbconstty;

void p9100loadcmap(struct p9100_softc *, int, int);
void p9100_set_video(struct p9100_softc *, int);
int p9100_get_video(struct p9100_softc *);

d228 1
d230 6
a235 1
	register struct romaux *ra = &ca->ca_ra;
d239 1
d244 1
a244 1
 * Attach a display.  We need to notice if it is the console, too.
d253 1
d255 1
a255 1
	int isconsole;
d258 1
a258 5
	sc->sc_fb.fb_driver = &p9100fbdriver;
	sc->sc_fb.fb_device = &sc->sc_dev;
	sc->sc_fb.fb_flags = sc->sc_dev.dv_cfdata->cf_flags & FB_USERMASK;
	sc->sc_fb.fb_type.fb_type = FBTYPE_SUN3COLOR;

a265 6
	/*
	 * When the ROM has mapped in a p9100 display, the address
	 * maps only the video RAM, so in any case we have to map the
	 * registers ourselves.  We only need the video RAM if we are
	 * going to print characters via rconsole.
	 */
d267 1
a267 6
	isconsole = node == fbnode && fbconstty != NULL;
	if (ca->ca_ra.ra_nvaddrs > 0)
		sc->sc_fb.fb_pixels = ca->ca_ra.ra_vaddrs[0];
	if (isconsole && sc->sc_fb.fb_pixels == NULL)
		sc->sc_fb.fb_pixels = mapiodev(&(ca->ca_ra.ra_reg[2]), 0,
		    ca->ca_ra.ra_reg[2].rr_len);
d273 1
a273 1
		sc->sc_fb.fb_type.fb_depth = 32;
d276 1
a276 1
		sc->sc_fb.fb_type.fb_depth = 24;
d279 1
a279 1
		sc->sc_fb.fb_type.fb_depth = 16;
d283 1
a283 1
		sc->sc_fb.fb_type.fb_depth = 8;
d286 13
a298 4
	fb_setsize(&sc->sc_fb, sc->sc_fb.fb_type.fb_depth, 800, 600,
	    node, ca->ca_bustype);

	sbus_establish(&sc->sc_sd, &sc->sc_dev);
d300 1
a300 6
	sc->sc_fb.fb_type.fb_cmsize = getpropint(node, "cmsize", 256);
	sc->sc_fb.fb_type.fb_size =
	    sc->sc_fb.fb_type.fb_height * sc->sc_fb.fb_linebytes;
	printf(": rev %x, %d x %d, depth %d", i & 7,
	    sc->sc_fb.fb_type.fb_width, sc->sc_fb.fb_type.fb_height,
	    sc->sc_fb.fb_type.fb_depth);
d303 1
d306 1
a306 2
	for (i = 1, cp = &sc->sc_cmap.cm_map[i][0];
	     i < sc->sc_fb.fb_type.fb_cmsize; cp += 3, i++)
d308 1
a308 1
	p9100loadcmap(sc, 0, 256);
d310 2
a311 2
	/* make sure we are not blanked */
	p9100_set_video(sc, 1);
d314 3
a316 31
		printf(" (console)\n");
#ifdef RASTERCONSOLE
		for (i = 0 ; i < sc->sc_fb.fb_type.fb_size; i++) {
			if (sc->sc_fb.fb_pixels[i] == 0) {
				sc->sc_fb.fb_pixels[i] = 1;
			} else if (sc->sc_fb.fb_pixels[i] == (char) 255) {
				sc->sc_fb.fb_pixels[i] = 0;
			}
		}
		p9100loadcmap(sc, 255, 1);
		fbrcons_init(&sc->sc_fb);
#endif
	} else
		printf("\n");

	if (node == fbnode)
		fb_attach(&sc->sc_fb, isconsole);
}

int
p9100open(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	int unit = minor(dev);

	if (unit >= pnozz_cd.cd_ndevs || pnozz_cd.cd_devs[unit] == NULL)
		return (ENXIO);
	return (0);
}
d318 5
a322 7
int
p9100close(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	return (0);
d326 2
a327 2
p9100ioctl(dev, cmd, data, flags, p)
	dev_t dev;
d333 3
a335 2
	struct p9100_softc *sc = pnozz_cd.cd_devs[minor(dev)];
	struct fbgattr *fba;
d340 2
a341 2
	case FBIOGTYPE:
		*(struct fbtype *)data = sc->sc_fb.fb_type;
d344 6
a349 10
	case FBIOGATTR:
		fba = (struct fbgattr *)data;
		fba->real_type = sc->sc_fb.fb_type.fb_type;
		fba->owner = 0;		/* XXX ??? */
		fba->fbtype = sc->sc_fb.fb_type;
		fba->sattr.flags = 0;
		fba->sattr.emu_type = sc->sc_fb.fb_type.fb_type;
		fba->sattr.dev_specific[0] = -1;
		fba->emu_types[0] = sc->sc_fb.fb_type.fb_type;
		fba->emu_types[1] = -1;
d352 3
a354 2
	case FBIOGETCMAP:
		return (bt_getcmap((struct fbcmap *)data, &sc->sc_cmap, 256));
d356 3
a358 4
	case FBIOPUTCMAP:
		/* copy to software map */
#define p ((struct fbcmap *)data)
		error = bt_putcmap(p, &sc->sc_cmap, 256);
a360 4
		/* now blast them into the chip */
		/* XXX should use retrace interrupt */
		p9100loadcmap(sc, p->index, p->count);
#undef p
d363 6
a368 6
	case FBIOGVIDEO:
		*(int *)data = p9100_get_video(sc);
		break;

	case FBIOSVIDEO:
		p9100_set_video(sc, *(int *)data);
d371 7
d379 1
a379 1
		return (ENOTTY);
d381 1
d385 7
a391 6
/*
 * Undo the effect of an FBIOSVIDEO that turns the video off.
 */
void
p9100unblank(dev)
	struct device *dev;
d393 17
a409 1
	p9100_set_video((struct p9100_softc *)dev, 1);
d413 3
a415 3
p9100_set_video(sc, enable)
	struct p9100_softc *sc;
	int enable;
d417 1
a417 1
	u_int32_t v;
d419 1
a419 10
	P9100_SELECT_VCR(sc);
	v = sc->sc_ctl->ctl_vcr.srtc1;
	if (enable)
		v |= SRTC1_VIDEN;
	else
		v &= ~SRTC1_VIDEN;
	sc->sc_ctl->ctl_vcr.srtc1 = v;
#if NTCTRL > 0
	tadpole_set_video(enable);
#endif
d423 6
a428 2
p9100_get_video(sc)
	struct p9100_softc *sc;
d430 1
a430 1
	return ((sc->sc_ctl->ctl_vcr.srtc1 & SRTC1_VIDEN) != 0);
d434 2
a435 1
 * Load a subset of the current (new) colormap into the Brooktree DAC.
d437 33
d471 1
a471 1
p9100loadcmap(sc, start, ncolors)
d473 1
a473 1
	int start, ncolors;
d492 4
a495 9
/*
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
 */
paddr_t
p9100mmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
d497 3
a499 1
	struct p9100_softc *sc = pnozz_cd.cd_devs[minor(dev)];
d501 13
a513 16
	if (off & PGOFSET)
		panic("p9100mmap");

	if (off < 0)
		return (-1);
#define	CG3_MMAP_OFFSET 0x04000000
	/*
	 * Make Xsun think we are a CG3 (SUN3COLOR)
	 */
	if ((u_int)off >= CG3_MMAP_OFFSET &&
	    (u_int)off < CG3_MMAP_OFFSET + 0x00200000) {
		off -= CG3_MMAP_OFFSET;
		return (REG2PHYS(&sc->sc_phys, off | PMAP_NC));
	}

	return (-1);
@


1.6
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.5 2001/11/01 12:13:46 art Exp $	*/
d102 3
a104 3
void p9100loadcmap __P((struct p9100_softc *, int, int));
void p9100_set_video __P((struct p9100_softc *, int));
int p9100_get_video __P((struct p9100_softc *));
@


1.6.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.6 2001/11/06 19:53:16 miod Exp $	*/
d102 3
a104 3
void p9100loadcmap(struct p9100_softc *, int, int);
void p9100_set_video(struct p9100_softc *, int);
int p9100_get_video(struct p9100_softc *);
@


1.6.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.6.2.1 2002/06/11 03:38:16 art Exp $	*/
d53 1
d56 1
a59 6
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

d71 1
a71 1
	struct	sunfb sc_sunfb;		/* common base part */
d73 1
a78 1
	int	sc_nscreens;
d81 4
a84 3
struct wsscreen_descr p9100_stdscreen = {
	"std",
};
d86 2
a87 2
const struct wsscreen_descr *p9100_scrlist[] = {
	&p9100_stdscreen,
d90 2
a91 3
struct wsscreen_list p9100_screenlist = {
	sizeof(p9100_scrlist) / sizeof(struct wsscreen_descr *),
	    p9100_scrlist
d94 3
a96 21
int p9100_ioctl(void *, u_long, caddr_t, int, struct proc *);
int p9100_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void p9100_free_screen(void *, void *);
int p9100_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t p9100_mmap(void *, off_t, int);
void p9100_loadcmap(struct p9100_softc *, u_int, u_int);
void p9100_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
void p9100_burner(void *, u_int, u_int);

struct wsdisplay_accessops p9100_accessops = {
	p9100_ioctl,
	p9100_mmap,
	p9100_alloc_screen,
	p9100_free_screen,
	p9100_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	p9100_burner,
d99 2
a100 2
int	p9100match(struct device *, void *, void *);
void	p9100attach(struct device *, struct device *, void *);
d102 3
a104 7
struct cfattach pnozz_ca = {
	sizeof (struct p9100_softc), p9100match, p9100attach
};

struct cfdriver pnozz_cd = {
	NULL, "pnozz", DV_DULL
};
a197 1
	struct cfdata *cf = vcf;
d199 1
a199 6
	struct romaux *ra = &ca->ca_ra;

	/*
	 * Mask out invalid flags from the user.
	 */
	cf->cf_flags &= FB_USERMASK;
a202 1

d207 1
a207 1
 * Attach a display.
a215 1
	struct wsemuldisplaydev_attach_args waa;
d217 1
a217 1
	int isconsole, fb_depth, fb_cmsize;
d220 5
a224 1
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;
d232 6
d239 6
a244 1
	isconsole = node == fbnode;
d250 1
a250 1
		fb_depth = 32;
d253 1
a253 1
		fb_depth = 24;
d256 1
a256 1
		fb_depth = 16;
d260 1
a260 1
		fb_depth = 8;
d263 4
a266 14
	fb_setsize(&sc->sc_sunfb, fb_depth, 800, 600, node, ca->ca_bustype);
	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(&(ca->ca_ra.ra_reg[2]), 0,
	    round_page(sc->sc_sunfb.sf_fbsize));
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, isconsole);

	p9100_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	p9100_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	p9100_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	p9100_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

	printf(": rev %x, %dx%d, depth %d\n", i & 7,
	    sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height,
	    sc->sc_sunfb.sf_depth);
d268 6
a273 1
	sbus_establish(&sc->sc_sd, &sc->sc_sunfb.sf_dev);
a275 1
	fb_cmsize = getpropint(node, "cmsize", 256);
d278 2
a279 1
	for (i = 1, cp = &sc->sc_cmap.cm_map[i][0]; i < fb_cmsize; cp += 3, i++)
d281 1
a281 1
	p9100_loadcmap(sc, 0, 256);
d283 2
a284 2
	/* enable video */
	p9100_burner(sc, 1, 0);
d287 31
a317 3
		fbwscons_console_init(&sc->sc_sunfb, &p9100_stdscreen, -1,
		    p9100_setcolor, p9100_burner);
	}
d319 7
a325 5
	waa.console = isconsole;
	waa.scrdata = &p9100_screenlist;
	waa.accessops = &p9100_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
d329 2
a330 2
p9100_ioctl(v, cmd, data, flags, p)
	void *v;
d336 2
a337 3
	struct p9100_softc *sc = v;
	struct wsdisplay_fbinfo *wdf;
	struct wsdisplay_cmap *cm;
d342 2
a343 2
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_SB_P9100;
d346 10
a355 6
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
		wdf->cmsize = 256;
d358 2
a359 3
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
		break;
d361 4
a364 3
	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_getcmap(&sc->sc_cmap, cm);
d367 8
d377 2
a378 6
	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		p9100_loadcmap(sc, cm->index, cm->count);
a380 7
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
d382 1
a382 1
		return (-1);	/* not supported yet */
a383 1

d387 6
a392 7
int
p9100_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
d394 1
a394 17
	struct p9100_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	if (sc->sc_sunfb.sf_depth == 8) {
		sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
		    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	} else {
		sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
		    0, 0, 0, attrp);
	}
	sc->sc_nscreens++;
	return (0);
d398 3
a400 3
p9100_free_screen(v, cookie)
	void *v;
	void *cookie;
d402 1
a402 1
	struct p9100_softc *sc = v;
d404 10
a413 1
	sc->sc_nscreens--;
d417 2
a418 6
p9100_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
d420 1
a420 1
	return (0);
d424 1
a424 2
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
a425 33
paddr_t
p9100_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
{
	struct p9100_softc *sc = v;

	if (offset & PGOFSET)
		return (-1);

	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys, offset) | PMAP_NC);
	}

	return (-1);
}

void
p9100_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
	u_int8_t r, g, b;
{
	struct p9100_softc *sc = v;
	union bt_cmap *bcm = &sc->sc_cmap;

	bcm->cm_map[index][0] = r;
	bcm->cm_map[index][1] = g;
	bcm->cm_map[index][2] = b;
	p9100_loadcmap(sc, index, 1);
}

d427 1
a427 1
p9100_loadcmap(sc, start, ncolors)
d429 1
a429 1
	u_int start, ncolors;
d448 9
a456 4
void
p9100_burner(v, on, flags)
	void *v;
	u_int on, flags;
d458 16
a473 3
	struct p9100_softc *sc = v;
	u_int32_t vcr;
	int s;
d475 1
a475 13
	s = splhigh();
	P9100_SELECT_VCR(sc);
	vcr = sc->sc_ctl->ctl_vcr.srtc1;
	if (on)
		vcr |= SRTC1_VIDEN;
	else
		vcr &= ~SRTC1_VIDEN;
	/* XXX - what about WSDISPLAY_BURN_VBLANK? */
	sc->sc_ctl->ctl_vcr.srtc1 = vcr;
#if NTCTRL > 0
	tadpole_set_video(on);
#endif
	splx(s);
@


1.6.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a132 8
 * SBus registers mappings
 */
#define	P9100_NREG	3
#define	P9100_REG_CTL	0
#define	P9100_REG_CMD	1
#define	P9100_REG_VRAM	2

/*
a140 7
#define	SCR_ID_MASK		0x00000007
#define	SCR_PIXEL_ID_MASK	0x00000007
#define	SCR_PIXEL_MASK		0x1c000000
#define	SCR_PIXEL_8BPP		0x08000000
#define	SCR_PIXEL_16BPP		0x0c000000
#define	SCR_PIXEL_24BPP		0x1c000000
#define	SCR_PIXEL_32BPP		0x14000000
d204 1
a204 1
 * subsequent writes to the same group do not need to reselect).
d250 3
a252 10
	int node, row, scr;
	int isconsole, fb_depth;

#ifdef DIAGNOSTIC
	if (ca->ca_ra.ra_nreg < P9100_NREG) {
		printf(": expected %d registers, got only %d\n",
		    P9100_NREG, ca->ca_ra.ra_nreg);
		return;
	}
#endif
d255 1
a255 1
	sc->sc_phys = ca->ca_ra.ra_reg[P9100_REG_VRAM];
d257 1
a257 1
	sc->sc_ctl = mapiodev(&(ca->ca_ra.ra_reg[P9100_REG_CTL]), 0,
d259 1
a259 1
	sc->sc_cmd = mapiodev(&(ca->ca_ra.ra_reg[P9100_REG_CMD]), 0,
d266 3
a268 3
	scr = sc->sc_ctl->ctl_scr.scr;
	switch (scr & SCR_PIXEL_MASK) {
	case SCR_PIXEL_32BPP:
d271 1
a271 1
	case SCR_PIXEL_24BPP:
d274 1
a274 1
	case SCR_PIXEL_16BPP:
d277 1
a278 5
#ifdef DIAGNOSTIC
		printf(": unknown color depth code 0x%x, assuming 8\n%s",
		    scr & SCR_PIXEL_MASK, self->dv_xname);
#endif
	case SCR_PIXEL_8BPP:
d283 1
a283 1
	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(&sc->sc_phys, 0,
d286 1
a286 19

	printf(": rev %x, %dx%d, depth %d\n", scr & SCR_ID_MASK,
	    sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height,
	    sc->sc_sunfb.sf_depth);

	/*
	 * If the framebuffer width is under 1024x768, we will switch from the
	 * PROM font to the more adequate 8x16 font here.
	 * However, we need to adjust two things in this case:
	 * - the display row should be overrided from the current PROM metrics,
	 *   to prevent us from overwriting the last few lines of text.
	 * - if the 80x34 screen would make a large margin appear around it,
	 *   choose to clear the screen rather than keeping old prom output in
	 *   the margins.
	 * XXX there should be a rasops "clear margins" feature
	 */
	fbwscons_init(&sc->sc_sunfb,
	    isconsole && (sc->sc_sunfb.sf_width != 800));
	fbwscons_setcolormap(&sc->sc_sunfb, p9100_setcolor);
d293 4
d299 8
d311 2
a312 7
		if (sc->sc_sunfb.sf_width == 800)
			row = 0;	/* screen has been cleared above */
		else
			row = -1;

		fbwscons_console_init(&sc->sc_sunfb, &p9100_stdscreen, row,
		    p9100_burner);
a332 3
#if NTCTRL > 0
	struct wsdisplay_param *dp;
#endif
a367 36
#if NTCTRL > 0
	case WSDISPLAYIO_GETPARAM:
		dp = (struct wsdisplay_param *)data;

		switch (dp->param) {
		case WSDISPLAYIO_PARAM_BRIGHTNESS:
			dp->min = 0;
			dp->max = 255;
			dp->curval = tadpole_get_brightness();
			break;
		case WSDISPLAYIO_PARAM_BACKLIGHT:
			dp->min = 0;
			dp->max = 1;
			dp->curval = tadpole_get_video();
			break;
		default:
			return (-1);
		}
		break;

	case WSDISPLAYIO_SETPARAM:
		dp = (struct wsdisplay_param *)data;

		switch (dp->param) {
		case WSDISPLAYIO_PARAM_BRIGHTNESS:
			tadpole_set_brightness(dp->curval);
			break;
		case WSDISPLAYIO_PARAM_BACKLIGHT:
			tadpole_set_video(dp->curval);
			break;
		default:
			return (-1);
		}
		break;
#endif	/* NTCTRL > 0 */

d476 1
a476 1
	P9100_SELECT_DAC(sc);
d484 1
a484 1
		P9100_SELECT_DAC(sc);
@


1.5
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.4 2001/08/17 13:52:29 mickey Exp $	*/
d51 1
a51 1
#include <vm/vm.h>
@


1.4
log
@cdev_decl cleanup; jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.3 1999/09/07 02:58:49 jason Exp $	*/
d452 1
a452 1
int
d455 2
a456 1
	int off, prot;
@


1.3
log
@add tadpole microcontroller device driver; from NetBSD
power the tft down on screenblank
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.2 1999/09/06 04:46:38 jason Exp $	*/
a84 3

/* cdevsw prototypes */
cdev_decl(p9100);
@


1.3.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.3 1999/09/07 02:58:49 jason Exp $	*/
d85 3
@


1.3.4.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 1
a51 1
#include <uvm/uvm_extern.h>
d452 1
a452 1
paddr_t
d455 1
a455 2
	off_t off;
	int prot;
@


1.3.4.3
log
@Merge in -current from about a week ago
@
text
@d102 3
a104 3
void p9100loadcmap(struct p9100_softc *, int, int);
void p9100_set_video(struct p9100_softc *, int);
int p9100_get_video(struct p9100_softc *);
@


1.3.4.4
log
@Sync the SMP branch with 3.3
@
text
@d53 1
d56 1
a59 6
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

d71 1
a71 1
	struct	sunfb sc_sunfb;		/* common base part */
d73 1
a78 1
	int	sc_nscreens;
d81 4
a84 3
struct wsscreen_descr p9100_stdscreen = {
	"std",
};
d86 2
a87 2
const struct wsscreen_descr *p9100_scrlist[] = {
	&p9100_stdscreen,
d90 2
a91 3
struct wsscreen_list p9100_screenlist = {
	sizeof(p9100_scrlist) / sizeof(struct wsscreen_descr *),
	    p9100_scrlist
d94 3
a96 21
int p9100_ioctl(void *, u_long, caddr_t, int, struct proc *);
int p9100_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void p9100_free_screen(void *, void *);
int p9100_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t p9100_mmap(void *, off_t, int);
void p9100_loadcmap(struct p9100_softc *, u_int, u_int);
void p9100_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
void p9100_burner(void *, u_int, u_int);

struct wsdisplay_accessops p9100_accessops = {
	p9100_ioctl,
	p9100_mmap,
	p9100_alloc_screen,
	p9100_free_screen,
	p9100_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	p9100_burner,
d99 2
a100 2
int	p9100match(struct device *, void *, void *);
void	p9100attach(struct device *, struct device *, void *);
d102 3
a104 7
struct cfattach pnozz_ca = {
	sizeof (struct p9100_softc), p9100match, p9100attach
};

struct cfdriver pnozz_cd = {
	NULL, "pnozz", DV_DULL
};
a197 1
	struct cfdata *cf = vcf;
d199 1
a199 6
	struct romaux *ra = &ca->ca_ra;

	/*
	 * Mask out invalid flags from the user.
	 */
	cf->cf_flags &= FB_USERMASK;
a202 1

d207 1
a207 1
 * Attach a display.
a215 1
	struct wsemuldisplaydev_attach_args waa;
d217 1
a217 1
	int isconsole, fb_depth, fb_cmsize;
d220 5
a224 1
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;
d232 6
d239 6
a244 1
	isconsole = node == fbnode;
d250 1
a250 1
		fb_depth = 32;
d253 1
a253 1
		fb_depth = 24;
d256 1
a256 1
		fb_depth = 16;
d260 1
a260 1
		fb_depth = 8;
d263 4
a266 15
	fb_setsize(&sc->sc_sunfb, fb_depth, 800, 600, node, ca->ca_bustype);
	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(&(ca->ca_ra.ra_reg[2]), 0,
	    round_page(sc->sc_sunfb.sf_fbsize));
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, isconsole);
	fbwscons_setcolormap(&sc->sc_sunfb, p9100_setcolor);

	p9100_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	p9100_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	p9100_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	p9100_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

	printf(": rev %x, %dx%d, depth %d\n", i & 7,
	    sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height,
	    sc->sc_sunfb.sf_depth);
d268 6
a273 1
	sbus_establish(&sc->sc_sd, &sc->sc_sunfb.sf_dev);
a275 1
	fb_cmsize = getpropint(node, "cmsize", 256);
d278 2
a279 1
	for (i = 1, cp = &sc->sc_cmap.cm_map[i][0]; i < fb_cmsize; cp += 3, i++)
d281 1
a281 1
	p9100_loadcmap(sc, 0, 256);
d283 2
a284 2
	/* enable video */
	p9100_burner(sc, 1, 0);
d287 31
a317 3
		fbwscons_console_init(&sc->sc_sunfb, &p9100_stdscreen, -1,
		    p9100_burner);
	}
d319 7
a325 5
	waa.console = isconsole;
	waa.scrdata = &p9100_screenlist;
	waa.accessops = &p9100_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
d329 2
a330 2
p9100_ioctl(v, cmd, data, flags, p)
	void *v;
d336 2
a337 3
	struct p9100_softc *sc = v;
	struct wsdisplay_fbinfo *wdf;
	struct wsdisplay_cmap *cm;
d342 2
a343 2
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_SB_P9100;
d346 10
a355 6
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
		wdf->cmsize = 256;
d358 2
a359 3
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
		break;
d361 4
a364 3
	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_getcmap(&sc->sc_cmap, cm);
d367 8
d377 2
a378 6
	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		p9100_loadcmap(sc, cm->index, cm->count);
a380 7
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
d382 1
a382 1
		return (-1);	/* not supported yet */
a383 1

d387 6
a392 7
int
p9100_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
d394 1
a394 17
	struct p9100_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	if (sc->sc_sunfb.sf_depth == 8) {
		sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
		    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	} else {
		sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
		    0, 0, 0, attrp);
	}
	sc->sc_nscreens++;
	return (0);
d398 3
a400 3
p9100_free_screen(v, cookie)
	void *v;
	void *cookie;
d402 1
a402 1
	struct p9100_softc *sc = v;
d404 10
a413 1
	sc->sc_nscreens--;
d417 2
a418 6
p9100_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
d420 1
a420 1
	return (0);
d424 1
a424 2
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
a425 33
paddr_t
p9100_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
{
	struct p9100_softc *sc = v;

	if (offset & PGOFSET)
		return (-1);

	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys, offset) | PMAP_NC);
	}

	return (-1);
}

void
p9100_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
	u_int8_t r, g, b;
{
	struct p9100_softc *sc = v;
	union bt_cmap *bcm = &sc->sc_cmap;

	bcm->cm_map[index][0] = r;
	bcm->cm_map[index][1] = g;
	bcm->cm_map[index][2] = b;
	p9100_loadcmap(sc, index, 1);
}

d427 1
a427 1
p9100_loadcmap(sc, start, ncolors)
d429 1
a429 1
	u_int start, ncolors;
d448 9
a456 4
void
p9100_burner(v, on, flags)
	void *v;
	u_int on, flags;
d458 16
a473 3
	struct p9100_softc *sc = v;
	u_int32_t vcr;
	int s;
d475 1
a475 13
	s = splhigh();
	P9100_SELECT_VCR(sc);
	vcr = sc->sc_ctl->ctl_vcr.srtc1;
	if (on)
		vcr |= SRTC1_VIDEN;
	else
		vcr &= ~SRTC1_VIDEN;
	/* XXX - what about WSDISPLAY_BURN_VBLANK? */
	sc->sc_ctl->ctl_vcr.srtc1 = vcr;
#if NTCTRL > 0
	tadpole_set_video(on);
#endif
	splx(s);
@


1.3.4.5
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@a132 8
 * SBus registers mappings
 */
#define	P9100_NREG	3
#define	P9100_REG_CTL	0
#define	P9100_REG_CMD	1
#define	P9100_REG_VRAM	2

/*
a140 7
#define	SCR_ID_MASK		0x00000007
#define	SCR_PIXEL_ID_MASK	0x00000007
#define	SCR_PIXEL_MASK		0x1c000000
#define	SCR_PIXEL_8BPP		0x08000000
#define	SCR_PIXEL_16BPP		0x0c000000
#define	SCR_PIXEL_24BPP		0x1c000000
#define	SCR_PIXEL_32BPP		0x14000000
d250 3
a252 10
	int node, row, scr;
	int isconsole, fb_depth;

#ifdef DIAGNOSTIC
	if (ca->ca_ra.ra_nreg < P9100_NREG) {
		printf(": expected %d registers, got only %d\n",
		    P9100_NREG, ca->ca_ra.ra_nreg);
		return;
	}
#endif
d255 1
a255 1
	sc->sc_phys = ca->ca_ra.ra_reg[P9100_REG_VRAM];
d257 1
a257 1
	sc->sc_ctl = mapiodev(&(ca->ca_ra.ra_reg[P9100_REG_CTL]), 0,
d259 1
a259 1
	sc->sc_cmd = mapiodev(&(ca->ca_ra.ra_reg[P9100_REG_CMD]), 0,
d266 3
a268 3
	scr = sc->sc_ctl->ctl_scr.scr;
	switch (scr & SCR_PIXEL_MASK) {
	case SCR_PIXEL_32BPP:
d271 1
a271 1
	case SCR_PIXEL_24BPP:
d274 1
a274 1
	case SCR_PIXEL_16BPP:
d277 1
a278 5
#ifdef DIAGNOSTIC
		printf(": unknown color depth code 0x%x, assuming 8\n%s",
		    scr & SCR_PIXEL_MASK, self->dv_xname);
#endif
	case SCR_PIXEL_8BPP:
d283 1
a283 1
	sc->sc_sunfb.sf_ro.ri_bits = mapiodev(&sc->sc_phys, 0,
d286 1
a286 18

	printf(": rev %x, %dx%d, depth %d\n", scr & SCR_ID_MASK,
	    sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height,
	    sc->sc_sunfb.sf_depth);

	/*
	 * If the framebuffer width is under 1024x768, we will switch from the
	 * PROM font to the more adequate 8x16 font here.
	 * However, we need to adjust two things in this case:
	 * - the display row should be overrided from the current PROM metrics,
	 *   to prevent us from overwriting the last few lines of text.
	 * - if the 80x34 screen would make a large margin appear around it,
	 *   choose to clear the screen rather than keeping old prom output in
	 *   the margins.
	 * XXX there should be a rasops "clear margins" feature
	 */
	fbwscons_init(&sc->sc_sunfb,
	    isconsole && (sc->sc_sunfb.sf_width != 800));
d294 4
d300 8
d312 1
a312 13
		switch (sc->sc_sunfb.sf_width) {
		case 640:
			row = p9100_stdscreen.nrows - 1;
			break;
		case 800:
			row = 0;	/* screen has been cleared above */
			break;
		default:
			row = -1;
			break;
		}

		fbwscons_console_init(&sc->sc_sunfb, &p9100_stdscreen, row,
d477 1
a477 1
	P9100_SELECT_DAC(sc);
d485 1
a485 1
		P9100_SELECT_DAC(sc);
@


1.3.4.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.3.4.5 2003/05/16 00:29:40 niklas Exp $	*/
d15 5
d193 1
a193 2
		volatile u_int32_t	dacfifo;	/* free fifo */
		volatile u_int32_t	unused1[25];
d219 1
a219 1
 * subsequent writes to the same group do not need to reselect).
a227 11
 * For some reason, every write to a DAC register needs to be followed by a
 * read from the ``free fifo number'' register, supposedly to have the write
 * take effect faster...
 */
#define	P9100_FLUSH_DAC(sc) \
	do { \
		P9100_SELECT_VRAM(sc); \
		(sc)->sc_junk = (sc)->sc_ctl->ctl_vram.dacfifo; \
	} while (0)

/*
d239 1
d243 5
d276 1
d343 5
a347 1
		if (sc->sc_sunfb.sf_width == 800)
d349 2
a350 1
		else
d352 2
a376 3
#if NTCTRL > 0
	struct wsdisplay_param *dp;
#endif
a411 36
#if NTCTRL > 0
	case WSDISPLAYIO_GETPARAM:
		dp = (struct wsdisplay_param *)data;

		switch (dp->param) {
		case WSDISPLAYIO_PARAM_BRIGHTNESS:
			dp->min = 0;
			dp->max = 255;
			dp->curval = tadpole_get_brightness();
			break;
		case WSDISPLAYIO_PARAM_BACKLIGHT:
			dp->min = 0;
			dp->max = 1;
			dp->curval = tadpole_get_video();
			break;
		default:
			return (-1);
		}
		break;

	case WSDISPLAYIO_SETPARAM:
		dp = (struct wsdisplay_param *)data;

		switch (dp->param) {
		case WSDISPLAYIO_PARAM_BRIGHTNESS:
			tadpole_set_brightness(dp->curval);
			break;
		case WSDISPLAYIO_PARAM_BACKLIGHT:
			tadpole_set_video(dp->curval);
			break;
		default:
			return (-1);
		}
		break;
#endif	/* NTCTRL > 0 */

d518 2
a521 1
	P9100_FLUSH_DAC(sc);
d524 4
a529 1
		P9100_FLUSH_DAC(sc);
@


1.3.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a3 1
 * Copyright (c) 2003, Miodrag Vallat.
d30 4
a33 3
 * color display (p9100) driver.
 * Initially based on cgthree.c and the NetBSD p9100 driver, then hacked
 * beyond recognition.
a62 2
#include <dev/ic/p9000.h>

d73 2
a74 2
	volatile u_int8_t *sc_cmd;	/* command registers (dac, etc) */
	volatile u_int8_t *sc_ctl;	/* control registers (draw engine) */
d76 1
a76 1
	struct	intrhand sc_ih;
a77 1
	u_int32_t	sc_junk;	/* throwaway value */
d93 10
a102 13
int	p9100_ioctl(void *, u_long, caddr_t, int, struct proc *);
int	p9100_alloc_screen(void *, const struct wsscreen_descr *, void **,
	    int *, int *, long *);
void	p9100_free_screen(void *, void *);
int	p9100_show_screen(void *, void *, int, void (*cb)(void *, int, int),
	    void *);
paddr_t	p9100_mmap(void *, off_t, int);
static __inline__ void p9100_loadcmap_deferred(struct p9100_softc *,
    u_int, u_int);
void	p9100_loadcmap_immediate(struct p9100_softc *, u_int, u_int);
void	p9100_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
void	p9100_burner(void *, u_int, u_int);
int	p9100_intr(void *);
a115 7
void	p9100_ras_init(struct p9100_softc *);
void	p9100_ras_copycols(void *, int, int, int, int);
void	p9100_ras_copyrows(void *, int, int, int);
void	p9100_ras_do_cursor(struct rasops_info *);
void	p9100_ras_erasecols(void *, int, int, int, long int);
void	p9100_ras_eraserows(void *, int, int, long int);

d136 2
a137 1
 * IBM RGB525 RAMDAC registers
d139 65
d205 3
a207 16
/* Palette write address */
#define	IBM525_WRADDR			0
/* Palette data */
#define	IBM525_DATA			1
/* Pixel mask */
#define	IBM525_PIXMASK			2
/* Read palette address */
#define	IBM525_RDADDR			3
/* Register index low */
#define	IBM525_IDXLOW			4
/* Register index high */
#define	IBM525_IDXHIGH			5
/* Register data */
#define	IBM525_REGDATA			6
/* Index control */
#define	IBM525_IDXCONTROL		7
d209 1
a209 3
/*
 * P9100 read/write macros
 */
a210 14
#define	P9100_READ_CTL(sc,reg) \
	*(volatile u_int32_t *)((sc)->sc_ctl + (reg))
#define	P9100_READ_CMD(sc,reg) \
	*(volatile u_int32_t *)((sc)->sc_cmd + (reg))
#define	P9100_READ_RAMDAC(sc,reg) \
	*(volatile u_int32_t *)((sc)->sc_ctl + P9100_RAMDAC_REGISTER(reg))

#define	P9100_WRITE_CTL(sc,reg,value) \
	*(volatile u_int32_t *)((sc)->sc_ctl + (reg)) = (value)
#define	P9100_WRITE_CMD(sc,reg,value) \
	*(volatile u_int32_t *)((sc)->sc_cmd + (reg)) = (value)
#define	P9100_WRITE_RAMDAC(sc,reg,value) \
	*(volatile u_int32_t *)((sc)->sc_ctl + P9100_RAMDAC_REGISTER(reg)) = \
	    (value)
d213 3
a215 10
 * On the Tadpole, the first write to a register group is ignored until
 * the proper group address is latched, which can be done by reading from the
 * register group first.
 *
 * Register groups are 0x80 bytes long (i.e. it is necessary to force a read
 * when writing to an address which upper 25 bit differ from the previous
 * read or write operation).
 *
 * This is specific to the Tadpole design, and not a limitation of the
 * Power 9100 hardware.
d217 5
a221 16
#define	P9100_SELECT_SCR(sc) \
	(sc)->sc_junk = P9100_READ_CTL(sc, P9000_SYSTEM_CONFIG)
#define	P9100_SELECT_VCR(sc) \
	(sc)->sc_junk = P9100_READ_CTL(sc, P9000_HCR)
#define	P9100_SELECT_VRAM(sc) \
	(sc)->sc_junk = P9100_READ_CTL(sc, P9000_MCR)
#define	P9100_SELECT_DAC(sc) \
	(sc)->sc_junk = P9100_READ_CTL(sc, P9100_RAMDAC_REGISTER(0))
#define	P9100_SELECT_PE(sc) \
	(sc)->sc_junk = P9100_READ_CMD(sc, P9000_PE_STATUS)
#define	P9100_SELECT_DE_LOW(sc)	\
	(sc)->sc_junk = P9100_READ_CMD(sc, P9000_DE_FG_COLOR)
#define	P9100_SELECT_DE_HIGH(sc) \
	(sc)->sc_junk = P9100_READ_CMD(sc, P9000_DE_PATTERN(0))
#define	P9100_SELECT_COORD(sc,field) \
	(sc)->sc_junk = P9100_READ_CMD(sc, field)
d231 1
a231 1
		(sc)->sc_junk = P9100_READ_CTL(sc, P9100_FREE_FIFO); \
d234 7
d242 3
a244 1
p9100match(struct device *parent, void *vcf, void *aux)
d259 3
a261 1
p9100attach(struct device *parent, struct device *self, void *args)
d288 1
a288 1
	scr = P9100_READ_CTL(sc, P9000_SYSTEM_CONFIG);
a316 8
	sc->sc_ih.ih_fun = p9100_intr;
	sc->sc_ih.ih_arg = sc;
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih, IPL_FB);

	/* Disable frame buffer interrupts */
	P9100_SELECT_SCR(sc);
	P9100_WRITE_CTL(sc, P9000_INTERRUPT_ENABLE, IER_MASTER_ENABLE | 0);

d329 1
a329 1
	    isconsole && (sc->sc_sunfb.sf_width >= 1024) ? 0 : RI_CLEAR);
a331 12
	/*
	 * Plug-in accelerated console operations if we can.
	 */
	if (sc->sc_sunfb.sf_depth == 8) {
		sc->sc_sunfb.sf_ro.ri_ops.copycols = p9100_ras_copycols;
		sc->sc_sunfb.sf_ro.ri_ops.copyrows = p9100_ras_copyrows;
		sc->sc_sunfb.sf_ro.ri_ops.erasecols = p9100_ras_erasecols;
		sc->sc_sunfb.sf_ro.ri_ops.eraserows = p9100_ras_eraserows;
		sc->sc_sunfb.sf_ro.ri_do_cursor = p9100_ras_do_cursor;
		p9100_ras_init(sc);
	}

d343 1
a343 1
		if (sc->sc_sunfb.sf_width < 1024)
d360 6
a365 1
p9100_ioctl(void *v, u_long cmd, caddr_t data, int flags, struct proc *p)
a380 8
	case WSDISPLAYIO_SMODE:
		/* Restore proper acceleration state upon leaving X11 */
		if (*(u_int *)data == WSDISPLAYIO_MODE_EMUL &&
		    sc->sc_sunfb.sf_depth == 8) {
			p9100_ras_init(sc);
		}
		break;

d405 1
a405 1
		p9100_loadcmap_deferred(sc, cm->index, cm->count);
d459 6
a464 2
p9100_alloc_screen(void *v, const struct wsscreen_descr *type, void **cookiep,
    int *curxp, int *curyp, long *attrp)
d486 3
a488 1
p9100_free_screen(void *v, void *cookie)
d496 6
a501 2
p9100_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
d511 4
a514 1
p9100_mmap(void *v, off_t offset, int prot)
d529 4
a532 1
p9100_setcolor(void *v, u_int index, u_int8_t r, u_int8_t g, u_int8_t b)
d540 1
a540 1
	p9100_loadcmap_immediate(sc, index, 1);
d544 3
a546 1
p9100_loadcmap_immediate(struct p9100_softc *sc, u_int start, u_int ncolors)
d551 1
a551 1
	P9100_WRITE_RAMDAC(sc, IBM525_WRADDR, start << 16);
d556 1
a556 1
		P9100_WRITE_RAMDAC(sc, IBM525_DATA, (*p) << 16);
a560 10
static __inline__ void
p9100_loadcmap_deferred(struct p9100_softc *sc, u_int start, u_int ncolors)
{
	/* Schedule an interrupt for next retrace */
	P9100_SELECT_SCR(sc);
	P9100_WRITE_CTL(sc, P9000_INTERRUPT_ENABLE,
	    IER_MASTER_ENABLE | IER_MASTER_INTERRUPT |
	    IER_VBLANK_ENABLE | IER_VBLANK_INTERRUPT);
}

d562 3
a564 1
p9100_burner(void *v, u_int on, u_int flags)
d572 1
a572 1
	vcr = P9100_READ_CTL(sc, P9000_SRTC1);
d577 2
a578 1
	P9100_WRITE_CTL(sc, P9000_SRTC1, vcr);
a582 229
}

int
p9100_intr(void *v)
{
	struct p9100_softc *sc = v;

	if (P9100_READ_CTL(sc, P9000_INTERRUPT) & IER_VBLANK_INTERRUPT) {
		p9100_loadcmap_immediate(sc, 0, 256);

		/* Disable further interrupts now */
		/* P9100_SELECT_SCR(sc); */
		P9100_WRITE_CTL(sc, P9000_INTERRUPT_ENABLE,
		    IER_MASTER_ENABLE | 0);

		return (1);
	}

	return (0);
}

/*
 * Accelerated text console code
 */

static __inline__ void p9100_drain(struct p9100_softc *);

static __inline__ void
p9100_drain(struct p9100_softc *sc)
{
	while (P9100_READ_CMD(sc, P9000_PE_STATUS) &
	    (STATUS_QUAD_BUSY | STATUS_BLIT_BUSY));
}

void
p9100_ras_init(struct p9100_softc *sc)
{
	/*
	 * Setup safe defaults for the parameter and drawing engine, in
	 * order to minimize the operations to do for ri_ops.
	 */

	P9100_SELECT_DE_LOW(sc);
	P9100_WRITE_CMD(sc, P9000_DE_DRAWMODE,
	    DM_PICK_CONTROL | 0 | DM_BUFFER_CONTROL | DM_BUFFER_ENABLE0);

	P9100_WRITE_CMD(sc, P9000_DE_PATTERN_ORIGIN_X, 0);
	P9100_WRITE_CMD(sc, P9000_DE_PATTERN_ORIGIN_Y, 0);
	/* enable all planes */
	P9100_WRITE_CMD(sc, P9000_DE_PLANEMASK, 0xffffffff);

	/* Unclip */
	P9100_WRITE_CMD(sc, P9000_DE_WINMIN, 0);
	P9100_WRITE_CMD(sc, P9000_DE_WINMAX,
	    P9000_COORDS(sc->sc_sunfb.sf_width - 1, sc->sc_sunfb.sf_height - 1));

	P9100_SELECT_DE_HIGH(sc);
	P9100_WRITE_CMD(sc, P9100_DE_B_WINMIN, 0);
	P9100_WRITE_CMD(sc, P9100_DE_B_WINMAX,
	    P9000_COORDS(sc->sc_sunfb.sf_width - 1, sc->sc_sunfb.sf_height - 1));

	P9100_SELECT_PE(sc);
	P9100_WRITE_CMD(sc, P9000_PE_WINOFFSET, 0);
}

void
p9100_ras_copycols(void *v, int row, int src, int dst, int n)
{
	struct rasops_info *ri = v;
	struct p9100_softc *sc = ri->ri_hw;

	n *= ri->ri_font->fontwidth;
	n--;
	src *= ri->ri_font->fontwidth;
	src += ri->ri_xorigin;
	dst *= ri->ri_font->fontwidth;
	dst += ri->ri_xorigin;
	row *= ri->ri_font->fontheight;
	row += ri->ri_yorigin;

	p9100_drain(sc);
	P9100_SELECT_DE_LOW(sc);
	P9100_WRITE_CMD(sc, P9000_DE_RASTER,
	    P9100_RASTER_SRC & P9100_RASTER_MASK);

	P9100_SELECT_COORD(sc, P9000_DC_COORD(0));
	P9100_WRITE_CMD(sc, P9000_DC_COORD(0) + P9000_COORD_XY,
	    P9000_COORDS(src, row));
	P9100_WRITE_CMD(sc, P9000_DC_COORD(1) + P9000_COORD_XY,
	    P9000_COORDS(src + n, row + ri->ri_font->fontheight - 1));
	P9100_SELECT_COORD(sc, P9000_DC_COORD(2));
	P9100_WRITE_CMD(sc, P9000_DC_COORD(2) + P9000_COORD_XY,
	    P9000_COORDS(dst, row));
	P9100_WRITE_CMD(sc, P9000_DC_COORD(3) + P9000_COORD_XY,
	    P9000_COORDS(dst + n, row + ri->ri_font->fontheight - 1));

	sc->sc_junk = P9100_READ_CMD(sc, P9000_PE_BLIT);

	p9100_drain(sc);
}

void
p9100_ras_copyrows(void *v, int src, int dst, int n)
{
	struct rasops_info *ri = v;
	struct p9100_softc *sc = ri->ri_hw;

	n *= ri->ri_font->fontheight;
	n--;
	src *= ri->ri_font->fontheight;
	src += ri->ri_yorigin;
	dst *= ri->ri_font->fontheight;
	dst += ri->ri_yorigin;

	p9100_drain(sc);
	P9100_SELECT_DE_LOW(sc);
	P9100_WRITE_CMD(sc, P9000_DE_RASTER,
	    P9100_RASTER_SRC & P9100_RASTER_MASK);

	P9100_SELECT_COORD(sc, P9000_DC_COORD(0));
	P9100_WRITE_CMD(sc, P9000_DC_COORD(0) + P9000_COORD_XY,
	    P9000_COORDS(ri->ri_xorigin, src));
	P9100_WRITE_CMD(sc, P9000_DC_COORD(1) + P9000_COORD_XY,
	    P9000_COORDS(ri->ri_xorigin + ri->ri_emuwidth - 1, src + n));
	P9100_SELECT_COORD(sc, P9000_DC_COORD(2));
	P9100_WRITE_CMD(sc, P9000_DC_COORD(2) + P9000_COORD_XY,
	    P9000_COORDS(ri->ri_xorigin, dst));
	P9100_WRITE_CMD(sc, P9000_DC_COORD(3) + P9000_COORD_XY,
	    P9000_COORDS(ri->ri_xorigin + ri->ri_emuwidth - 1, dst + n));

	sc->sc_junk = P9100_READ_CMD(sc, P9000_PE_BLIT);

	p9100_drain(sc);
}

void
p9100_ras_erasecols(void *v, int row, int col, int n, long int attr)
{
	struct rasops_info *ri = v;
	struct p9100_softc *sc = ri->ri_hw;
	int fg, bg;

	rasops_unpack_attr(attr, &fg, &bg, NULL);

	n *= ri->ri_font->fontwidth;
	col *= ri->ri_font->fontwidth;
	col += ri->ri_xorigin;
	row *= ri->ri_font->fontheight;
	row += ri->ri_yorigin;

	p9100_drain(sc);
	P9100_SELECT_DE_LOW(sc);
	P9100_WRITE_CMD(sc, P9000_DE_RASTER,
	    P9100_RASTER_PATTERN & P9100_RASTER_MASK);
	P9100_WRITE_CMD(sc, P9100_DE_COLOR0, P9100_COLOR8(bg));

	P9100_SELECT_COORD(sc, P9000_LC_RECT);
	P9100_WRITE_CMD(sc, P9000_LC_RECT + P9000_COORD_XY,
	    P9000_COORDS(col, row));
	P9100_WRITE_CMD(sc, P9000_LC_RECT + P9000_COORD_XY,
	    P9000_COORDS(col + n, row + ri->ri_font->fontheight));

	sc->sc_junk = P9100_READ_CMD(sc, P9000_PE_QUAD);

	p9100_drain(sc);
}

void
p9100_ras_eraserows(void *v, int row, int n, long int attr)
{
	struct rasops_info *ri = v;
	struct p9100_softc *sc = ri->ri_hw;
	int fg, bg;

	rasops_unpack_attr(attr, &fg, &bg, NULL);

	p9100_drain(sc);
	P9100_SELECT_DE_LOW(sc);
	P9100_WRITE_CMD(sc, P9000_DE_RASTER,
	    P9100_RASTER_PATTERN & P9100_RASTER_MASK);
	P9100_WRITE_CMD(sc, P9100_DE_COLOR0, P9100_COLOR8(bg));

	P9100_SELECT_COORD(sc, P9000_LC_RECT);
	if (n == ri->ri_rows && ISSET(ri->ri_flg, RI_FULLCLEAR)) {
		P9100_WRITE_CMD(sc, P9000_LC_RECT + P9000_COORD_XY,
		    P9000_COORDS(0, 0));
		P9100_WRITE_CMD(sc, P9000_LC_RECT + P9000_COORD_XY,
		    P9000_COORDS(ri->ri_width, ri->ri_height));
	} else {
		n *= ri->ri_font->fontheight;
		row *= ri->ri_font->fontheight;
		row += ri->ri_yorigin;

		P9100_WRITE_CMD(sc, P9000_LC_RECT + P9000_COORD_XY,
		    P9000_COORDS(ri->ri_xorigin, row));
		P9100_WRITE_CMD(sc, P9000_LC_RECT + P9000_COORD_XY,
		    P9000_COORDS(ri->ri_xorigin + ri->ri_emuwidth, row + n));
	}

	sc->sc_junk = P9100_READ_CMD(sc, P9000_PE_QUAD);

	p9100_drain(sc);
}

void
p9100_ras_do_cursor(struct rasops_info *ri)
{
	struct p9100_softc *sc = ri->ri_hw;
	int row, col;

	row = ri->ri_crow * ri->ri_font->fontheight + ri->ri_yorigin;
	col = ri->ri_ccol * ri->ri_font->fontwidth + ri->ri_xorigin;

	p9100_drain(sc);

	P9100_SELECT_DE_LOW(sc);
	P9100_WRITE_CMD(sc, P9000_DE_RASTER,
	    (~P9100_RASTER_DST) & P9100_RASTER_MASK);

	P9100_SELECT_COORD(sc, P9000_LC_RECT);
	P9100_WRITE_CMD(sc, P9000_LC_RECT + P9000_COORD_XY,
	    P9000_COORDS(col, row));
	P9100_WRITE_CMD(sc, P9000_LC_RECT + P9000_COORD_XY,
	    P9000_COORDS(col + ri->ri_font->fontwidth,
	        row + ri->ri_font->fontheight));

	sc->sc_junk = P9100_READ_CMD(sc, P9000_PE_QUAD);

	p9100_drain(sc);
@


1.3.4.8
log
@Merge with the trunk
@
text
@d326 6
a331 1
	if (sc->sc_sunfb.sf_depth == 8)
d333 1
d427 1
a427 1
			dp->curval = tadpole_get_video() & TV_ON;
a614 9
	sc->sc_sunfb.sf_ro.ri_ops.copycols = p9100_ras_copycols;
	sc->sc_sunfb.sf_ro.ri_ops.copyrows = p9100_ras_copyrows;
#if NTCTRL > 0
	if (tadpole_get_video() & TV_ACCEL) {
		sc->sc_sunfb.sf_ro.ri_ops.erasecols = p9100_ras_erasecols;
		sc->sc_sunfb.sf_ro.ri_ops.eraserows = p9100_ras_eraserows;
		sc->sc_sunfb.sf_ro.ri_do_cursor = p9100_ras_do_cursor;
	}
#endif
d616 1
a616 1
	 * Setup safe defaults for the parameter and drawing engines, in
a640 4
	P9100_WRITE_CMD(sc, P9000_PE_INDEX, 0);
	P9100_WRITE_CMD(sc, P9000_PE_WINMIN, 0);
	P9100_WRITE_CMD(sc, P9000_PE_WINMAX,
	    P9000_COORDS(sc->sc_sunfb.sf_width - 1, sc->sc_sunfb.sf_height - 1));
d795 1
a795 2
	    (P9100_RASTER_PATTERN ^ P9100_RASTER_DST) & P9100_RASTER_MASK);
	P9100_WRITE_CMD(sc, P9100_DE_COLOR0, P9100_COLOR8(WSCOL_BLACK));
@


1.2
log
@remove debugging cruft
@
text
@d1 1
a1 1
/*	$OpenBSD: p9100.c,v 1.1 1999/09/06 03:46:16 jason Exp $	*/
d64 5
d414 3
a453 10
 *
 * The cg3 is mapped starting at 256KB, for pseudo-compatibility with
 * the cg4 (which had an overlay plane in the first 128K and an enable
 * plane in the next 128K).  X11 uses only 256k+ region but tries to
 * map the whole thing, so we repeatedly map the first 256K to the
 * first page of the color screen.  If someone tries to use the overlay
 * and enable regions, they will get a surprise....
 *
 * As well, mapping at an offset of 0x04000000 causes the cg3 to be
 * mapped in flat mode without the cg4 emulation.
a460 2
#define START		(128*1024 + 128*1024)
#define NOOVERLAY	(0x04000000)
@


1.1
log
@p9100 console driver for tadpole 3g[sx] (based on cgthree.c and netbsd's
driver).  Needs clean-up.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a245 1
	printf(":%08x", i);
d269 1
a269 1
	printf(": rev %x, %d x %d, depth %d", i,
@

