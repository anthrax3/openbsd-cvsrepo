head	1.27;
access;
symbols
	OPENBSD_6_0:1.26.0.6
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.26.0.4
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.25.0.4
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.25.0.8
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.6
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.2
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.23.0.8
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.8
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.4
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.13.0.4
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.2.0.12
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.10
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.8
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.6
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.4
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2
	UBC:1.1.0.4
	UBC_SYNC_A:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.27
date	2016.09.01.09.23.42;	author tedu;	state dead;
branches;
next	1.26;
commitid	Q2PxaFNhqAe0Wmla;

1.26
date	2015.03.28.19.07.07;	author miod;	state Exp;
branches;
next	1.25;
commitid	nwbHy4sQv9NnJnmZ;

1.25
date	2013.06.11.16.42.11;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2013.06.04.21.05.53;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2011.07.06.19.14.54;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	2011.07.06.04.49.35;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	2011.06.03.21.14.11;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	2010.09.22.06.40.25;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2010.09.22.01.18.57;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	2010.09.08.14.47.10;	author jsing;	state Exp;
branches;
next	1.17;

1.17
date	2010.08.28.20.23.22;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	2010.04.23.15.25.21;	author jsing;	state Exp;
branches;
next	1.15;

1.15
date	2009.09.05.00.48.39;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2008.06.15.00.36.40;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.20.18.15.47;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.15.02.28.49;	author todd;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.08.05.27.58;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.06.17.15.12;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2007.06.05.00.38.18;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.04.16.38.58;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2007.06.01.00.07.48;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2006.09.24.20.29.52;	author krw;	state Exp;
branches;
next	1.5;

1.5
date	2006.08.14.01.04.58;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2006.08.12.13.53.44;	author krw;	state Exp;
branches;
next	1.3;

1.3
date	2006.06.02.20.00.54;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.26.18.16.27;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2003.04.13.22.55.49;	author miod;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2003.05.12.19.58.48;	author ho;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.06.07.11.14.43;	author ho;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: presto.c,v 1.26 2015/03/28 19:07:07 miod Exp $	*/
/*
 * Copyright (c) 2003, Miodrag Vallat.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/conf.h>
#include <sys/disk.h>
#include <sys/disklabel.h>
#include <sys/dkio.h>
#include <sys/fcntl.h>
#include <sys/stat.h>

#include <machine/autoconf.h>
#include <machine/conf.h>

struct presto_softc {
	struct	device	sc_dev;
	struct	disk	sc_dk;

	vsize_t		sc_offset;	/* reserved memory offset */
	vsize_t		sc_memsize;	/* total NVRAM size */
	caddr_t		sc_mem;		/* NVRAM kva */
	caddr_t		sc_status;	/* status register kva (MBus) */
	char		sc_model[16];	/* Prestoserve model */
};

/*
 * The beginning of the NVRAM contains a few control and status values.
 * On SBus boards, there are two distinct four-bit status values;
 * On MBus boards, these are provided in the second register mapping.
 */

#define	PSERVE_BATTERYSTATUS	0x07
#define	PSBAT_CHARGING			0x10
#define	PSBAT_CONNECTED			0x20
#define	PSBAT_FAULT			0x40

#define	PSERVE_DATASTATUS	0x0b
#define	PSDATA_EMPTY			0x00
#define	PSDATA_SAVED			0x01

/*
 * Reserved area size on SBus flavours, needs to be rounded to a sector
 * size for i/o.
 */
#define	PSERVE_RESERVED		0x0010
#define	PSERVE_OFFSET		roundup(PSERVE_RESERVED, DEV_BSIZE)

void	prestostrategy(struct buf *);
void	presto_attach(struct device *, struct device *, void *);
void	presto_getdisklabel(dev_t, struct presto_softc *, struct disklabel *, int);
int	presto_match(struct device *, void *, void *);

struct cfattach presto_ca = {
	sizeof(struct presto_softc), presto_match, presto_attach
};

struct cfdriver presto_cd = {
	NULL, "presto", DV_DULL
};

#define prestolookup(unit) (struct presto_softc *)device_lookup(&presto_cd, (unit))

int
presto_match(struct device *parent, void *vcf, void *aux)
{
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

	if (strcmp(ra->ra_name, "MMI,prestoserve") != 0 &&
	    strcmp(ra->ra_name, "SUNW,nvone") != 0)
		return 0;

	if (ra->ra_nreg < 1)
		return 0;

	/* no usable memory ? */
	if (ra->ra_nreg == 1 && ra->ra_len < PSERVE_OFFSET)
		return 0;

	return 1;
}

void
presto_attach(struct device *parent, struct device *self, void *args)
{
	struct presto_softc *sc = (struct presto_softc *)self;
	struct confargs *ca = args;
	char *model, *submodel;
	u_int8_t status;

	/* Get card parameters */
	model = getpropstring(ca->ca_ra.ra_node, "model");
	if (*model == '\0')
		submodel = "fictitious";
	else {
		submodel = memchr(model, ',', strlen(model));
		if (submodel != NULL)
			submodel++;
		else
			submodel = model;
	}
	strncpy(sc->sc_model, submodel, 16);
	sc->sc_memsize = ca->ca_ra.ra_len;

	printf(": %s\n%s: %d MB NVRAM, ", model,
	    sc->sc_dev.dv_xname, sc->sc_memsize >> 20);

	/* Map memory */
	sc->sc_mem = (void *)mapiodev(ca->ca_ra.ra_reg, 0, sc->sc_memsize);
	if (ca->ca_ra.ra_nreg == 1) {
		sc->sc_status = NULL;
	} else {
		sc->sc_status = (void *)mapiodev(&ca->ca_ra.ra_reg[1], 0,
		    ca->ca_ra.ra_reg[1].rr_len);
	}

	/*
	 * Clear the ``disconnect battery'' bit.
	 */
	if (sc->sc_status == NULL)
		*(u_int8_t *)(sc->sc_mem + PSERVE_BATTERYSTATUS) = 0x00;
	else
		*(u_int8_t *)sc->sc_status &= 0x0f;

	/*
	 * Clear the ``unflushed data'' status. This way, if the card is
	 * reused under SunOS, the system will not try to flush whatever
	 * data the user put in the nvram...
	 */
	if (sc->sc_status == NULL)
		*(u_int8_t *)(sc->sc_mem + PSERVE_DATASTATUS) = 0x00;
	else
		*(u_int8_t *)sc->sc_status &= 0xf0;

	/*
	 * Decode battery status
	 */
	if (sc->sc_status == NULL)
		status = *(u_int8_t *)(sc->sc_mem + PSERVE_BATTERYSTATUS);
	else
		status = *(u_int8_t *)sc->sc_status;
	printf("battery status %02x ", status);
	if (ISSET(status, PSBAT_FAULT)) {
		printf("(non-working)");
	} else if (ISSET(status, PSBAT_CONNECTED)) {
		if (ISSET(status, PSBAT_CHARGING))
			printf("(charging)");
		else
			printf("(ok)");
	} else
		printf("(disabled)");
	printf("\n");

#ifdef DEBUG
	if (sc->sc_status == NULL) {
		printf("%s: status codes %02.2x, %02.2x, %02.2x, %02.2x\n",
		    sc->sc_dev.dv_xname,
		    *(u_int8_t *)(sc->sc_mem + 0x03),
		    *(u_int8_t *)(sc->sc_mem + 0x07),
		    *(u_int8_t *)(sc->sc_mem + 0x0b),
		    *(u_int8_t *)(sc->sc_mem + 0x0f));
	}
#endif

	sc->sc_dk.dk_name = sc->sc_dev.dv_xname;
	if (sc->sc_status == NULL)
		sc->sc_offset = PSERVE_OFFSET;
	else
		sc->sc_offset = 0;
	disk_attach(&sc->sc_dev, &sc->sc_dk);
}

/*
 * Block device i/o operations
 */

int
prestodump(dev_t dev, daddr_t blkno, caddr_t va, size_t size)
{
	/*
	 * A dump to nvram is theoretically possible, but its size is
	 * very likely to be WAY too small.
	 */
	return (ENXIO);
}

daddr_t
prestosize(dev_t dev)
{
	struct presto_softc *sc;
	daddr_t size;
	int part;

	sc = prestolookup(DISKUNIT(dev));
	if (sc == NULL)
		return (-1);

	part = DISKPART(dev);
	if (part >= sc->sc_dk.dk_label->d_npartitions)
		size = -1;
	else
		size = DL_SECTOBLK(sc->sc_dk.dk_label,
		    DL_GETPSIZE(&sc->sc_dk.dk_label->d_partitions[part]));

	device_unref(&sc->sc_dev);
	return (size);
}

int
prestoopen(dev_t dev, int flag, int fmt, struct proc *proc)
{
	struct presto_softc *sc;
	int error;

	sc = prestolookup(DISKUNIT(dev));
	if (sc == NULL)
		return (ENXIO);

	/* read the disk label */
	presto_getdisklabel(dev, sc, sc->sc_dk.dk_label, 0);

	/* only allow valid partitions */
	error = disk_openpart(&sc->sc_dk, DISKPART(dev), fmt, 1);

	device_unref(&sc->sc_dev);
	return (error);
}

int
prestoclose(dev_t dev, int flag, int fmt, struct proc *proc)
{
	struct presto_softc *sc;

	sc = prestolookup(DISKUNIT(dev));
	if (sc == NULL)
		return (ENXIO);

	disk_closepart(&sc->sc_dk, DISKPART(dev), fmt);

	device_unref(&sc->sc_dev);
	return (0);
}

int
prestoread(dev_t dev, struct uio *uio, int flags)
{
	return (physio(prestostrategy, dev, B_READ, minphys, uio));
}

int
prestowrite(dev_t dev, struct uio *uio, int flags)
{
	return (physio(prestostrategy, dev, B_WRITE, minphys, uio));
}

void
prestostrategy(struct buf *bp)
{
	struct presto_softc *sc;
	size_t offset, count;
	int s;

	sc = prestolookup(DISKUNIT(bp->b_dev));

	/* Sort rogue requests out */
	if (sc == NULL) {
		bp->b_error = EINVAL;
		goto bad;
	}

	/* Validate the request. */
	if (bounds_check_with_label(bp, sc->sc_dk.dk_label) == -1)
		goto done;

	/* Bound the request size, then move data between buf and nvram */
	offset = (bp->b_blkno << DEV_BSHIFT) + sc->sc_offset;
	count = bp->b_bcount;
	if (count > (sc->sc_memsize - offset))
		count = (sc->sc_memsize - offset);
	if (ISSET(bp->b_flags, B_READ))
		bcopy(sc->sc_mem + offset, bp->b_data, count);
	else
		bcopy(bp->b_data, sc->sc_mem + offset, count);
	bp->b_resid = bp->b_bcount - count;
	goto done;

 bad:
	bp->b_flags |= B_ERROR;
	bp->b_resid = bp->b_bcount;
 done:
	s = splbio();
	biodone(bp);
	splx(s);
	if (sc != NULL)
		device_unref(&sc->sc_dev);
}

int
prestoioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *proc)
{
	struct presto_softc *sc;
	int error = 0;

	sc = prestolookup(DISKUNIT(dev));

	switch (cmd) {
	case DIOCGPDINFO:
		presto_getdisklabel(dev, sc, (struct disklabel *)data, 1);
		break;

	case DIOCGDINFO:
		*(struct disklabel *)data = *sc->sc_dk.dk_label;
		break;

	case DIOCWDINFO:
	case DIOCSDINFO:
		if ((flag & FWRITE) == 0) {
			error = EBADF;
			break;
		}

		error = setdisklabel(sc->sc_dk.dk_label,
		    (struct disklabel *)data, sc->sc_dk.dk_openmask);
		if (error == 0) {
			if (cmd == DIOCWDINFO)
				error = writedisklabel(DISKLABELDEV(dev),
				    prestostrategy, sc->sc_dk.dk_label);
		}
		break;

	default:
		error = EINVAL;
		break;
	}

	device_unref(&sc->sc_dev);
	return (error);
}

/*
 * Read the disklabel. If none is present, use a fictitious one instead.
 */
void
presto_getdisklabel(dev_t dev, struct presto_softc *sc, struct disklabel *lp,
    int spoofonly)
{
	bzero(sc->sc_dk.dk_label, sizeof(struct disklabel));

	lp->d_secsize = DEV_BSIZE;
	lp->d_ntracks = 1;
	lp->d_nsectors = 32;
	DL_SETDSIZE(lp, (sc->sc_memsize - sc->sc_offset) >> DEV_BSHIFT);
	lp->d_ncylinders = DL_GETDSIZE(lp) / lp->d_nsectors;
	lp->d_secpercyl = lp->d_nsectors;

	strncpy(lp->d_typename, "Prestoserve", 16);
	lp->d_type = DTYPE_SCSI;	/* what better to put here? */
	strncpy(lp->d_packname, sc->sc_model, 16);
	lp->d_version = 1;

	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = dkcksum(lp);

	readdisklabel(DISKLABELDEV(dev), prestostrategy, lp, spoofonly);
}
@


1.26
log
@Don't include sbusvar.h if you need neither sbus_translate() nor sbus_testdma().
@
text
@d1 1
a1 1
/*	$OpenBSD: presto.c,v 1.25 2013/06/11 16:42:11 deraadt Exp $	*/
@


1.25
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: presto.c,v 1.24 2013/06/04 21:05:53 miod Exp $	*/
a42 2

#include <sparc/dev/sbusvar.h>
@


1.24
log
@Support for the SS10/SS20 NVSIMM as block devices; tested by nick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: presto.c,v 1.23 2011/07/06 19:14:54 matthew Exp $	*/
d209 1
a209 1
prestodump(dev_t dev, daddr64_t blkno, caddr_t va, size_t size)
d218 1
a218 1
daddr64_t
d222 1
a222 1
	daddr64_t size;
@


1.23
log
@Cleanup presto(4) like other disk drivers.

meh deraadt@@, miod@@; "haha, you're fixing presto!?" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: presto.c,v 1.22 2011/07/06 04:49:35 matthew Exp $	*/
d50 1
d53 1
d58 3
a60 1
 * The beginning of the NVRAM contains a few control and status values
d72 4
a75 1
/* reserved area size - needs to be rounded to a sector size for i/o */
d100 10
a109 5
	if (strcmp(ra->ra_name, "MMI,prestoserve") != 0)
		return (0);

	if (ra->ra_len < PSERVE_OFFSET)	/* no usable memory ? */
		return (0);
d111 1
a111 1
	return (1);
d141 6
d151 4
a154 1
	*(u_int8_t *)(sc->sc_mem + PSERVE_BATTERYSTATUS) = 0x00;
d161 4
a164 1
	*(u_int8_t *)(sc->sc_mem + PSERVE_DATASTATUS) = 0x00;
d169 5
a173 2
	status = *(u_int8_t *)(sc->sc_mem + PSERVE_BATTERYSTATUS);
	printf("battery status %x ", status);
d186 8
a193 4
	printf("%s: status codes %02.2x, %02.2x, %02.2x, %02.2x\n",
	    sc->sc_dev.dv_xname,
	    *(u_int8_t *)(sc->sc_mem + 0x03), *(u_int8_t *)(sc->sc_mem + 0x07),
	    *(u_int8_t *)(sc->sc_mem + 0x0b), *(u_int8_t *)(sc->sc_mem + 0x0f));
d197 4
d307 1
a307 1
	offset = (bp->b_blkno << DEV_BSHIFT) + PSERVE_OFFSET;
d376 1
a376 1
    int spoofonly);
d383 1
a383 1
	DL_SETDSIZE(lp, (sc->sc_memsize - PSERVE_OFFSET) >> DEV_BSHIFT);
@


1.22
log
@Eliminate redundant buf validation checks in xxstrategy() methods now
that they're implemented consistently in bounds_check_with_label().

Also, per krw's request, change bounds_check_with_label() to return 0
if the checks succeed, and change the drivers to test == -1 instead of
<= 0.  (Man page update to follow; intentionally omitting
arch/vax/mba/hp.c from this commit because it doesn't even build
currently and miod@@ promises to kill it soon.)

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: presto.c,v 1.21 2011/06/03 21:14:11 matthew Exp $	*/
d85 2
d187 2
a188 1
	int unit, part;
d190 1
a190 2
	unit = DISKUNIT(dev);
	sc = (struct presto_softc *)device_lookup(&presto_cd, unit);
d192 1
a192 1
		return (0);
d196 1
a196 1
		return (0);
d198 5
a202 2
		return (DL_GETPSIZE(&sc->sc_dk.dk_label->d_partitions[part]) *
		    (sc->sc_dk.dk_label->d_secsize / DEV_BSIZE));
a207 1
	int unit, part;
d209 1
d211 1
a211 2
	unit = DISKUNIT(dev);
	sc = (struct presto_softc *)device_lookup(&presto_cd, unit);
d219 1
a219 5
	part = DISKPART(dev);
	if (part != RAW_PART &&
	    (part >= sc->sc_dk.dk_label->d_npartitions ||
	    sc->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED))
		return (ENXIO);
d221 2
a222 12
	/* update open masks */
	switch (fmt) {
	case S_IFCHR:
		sc->sc_dk.dk_copenmask |= (1 << part);
		break;
	case S_IFBLK:
		sc->sc_dk.dk_bopenmask |= (1 << part);
		break;
	}
	sc->sc_dk.dk_openmask = sc->sc_dk.dk_copenmask | sc->sc_dk.dk_bopenmask;

	return (0);
a227 1
	int unit, part;
d230 3
a232 2
	unit = DISKUNIT(dev);
	sc = (struct presto_softc *)device_lookup(&presto_cd, unit);
d234 1
a234 11
	/* update open masks */
	part = DISKPART(dev);
	switch (fmt) {
	case S_IFCHR:
		sc->sc_dk.dk_copenmask &= ~(1 << part);
		break;
	case S_IFBLK:
		sc->sc_dk.dk_bopenmask &= ~(1 << part);
		break;
	}
	sc->sc_dk.dk_openmask = sc->sc_dk.dk_copenmask | sc->sc_dk.dk_bopenmask;
d236 1
a254 1
	int unit;
d259 1
a259 2
	unit = DISKUNIT(bp->b_dev);
	sc = (struct presto_softc *)device_lookup(&presto_cd, unit);
a271 1
	bp->b_resid = bp->b_bcount;
d280 1
a280 1
	bp->b_resid -= count;
d290 2
d298 1
a298 2
	int unit;
	int error;
d300 1
a300 2
	unit = DISKUNIT(dev);
	sc = (struct presto_softc *)device_lookup(&presto_cd, unit);
d308 2
a309 2
		bcopy(sc->sc_dk.dk_label, data, sizeof(struct disklabel));
		return (0);
d313 4
a316 2
		if ((flag & FWRITE) == 0)
			return (EBADF);
d319 1
a319 1
		    (struct disklabel *)data, /*sd->sc_dk.dk_openmask : */0);
d325 1
a325 1
		return (error);
d328 2
a329 1
		return (EINVAL);
d331 3
@


1.21
log
@Get rid of the wlabel argument to bounds_check_with_label().  It's
never done anything in OpenBSD and just clutters disk drivers with
silly flag handling.

More cleanup to follow.

ok deraadt@@, millert@@; no objections krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: presto.c,v 1.20 2010/09/22 06:40:25 krw Exp $	*/
d283 1
a283 2
	if (sc == NULL || bp->b_blkno < 0 ||
	    (bp->b_bcount % sc->sc_dk.dk_label->d_secsize) != 0) {
d288 3
a290 3
	/* Do not write on "no trespassing" areas... */
	if (bounds_check_with_label(bp, sc->sc_dk.dk_label) <= 0)
		goto bad;
d305 1
a305 1
bad:
d308 1
a308 2

done:
@


1.20
log
@Add DIOCGPDINFO to drivers that were lacking it. Where there
is no easily available physical information outside of the stored
disklabel just make it a synonym for DIOCGDINFO.

Commit on the theory it is unlikely to harm, and fallout can be
addressed in the mass re-compile that will follow j2k10.

Should allow auto-allocation of disks to work with all devices.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: presto.c,v 1.19 2010/09/22 01:18:57 matthew Exp $	*/
d290 1
a290 1
	if (bounds_check_with_label(bp, sc->sc_dk.dk_label, 1) <= 0)
@


1.19
log
@All users of physio(9) now pass NULL as the buf pointer argument, so
no point in keeping it around.

"i like this" thib@@ (a while back); ok krw@@ and oga@@; reminder to
update the man page and tweaks jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: presto.c,v 1.18 2010/09/08 14:47:10 jsing Exp $	*/
d74 1
a74 1
void	presto_getdisklabel(dev_t, struct presto_softc *);
d212 1
a212 1
	presto_getdisklabel(dev, sc);
d327 4
d358 2
a359 1
presto_getdisklabel(dev_t dev, struct presto_softc *sc)
a360 2
	struct disklabel *lp = sc->sc_dk.dk_label;

d379 1
a379 1
	readdisklabel(DISKLABELDEV(dev), prestostrategy, sc->sc_dk.dk_label, 0);
@


1.18
log
@Store a struct device pointer within struct disk and populate this when
disk_attach() is called by the device driver. We will be building on
this shortly.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: presto.c,v 1.16 2010/04/23 15:25:21 jsing Exp $	*/
d262 1
a262 1
	return (physio(prestostrategy, NULL, dev, B_READ, minphys, uio));
d268 1
a268 1
	return (physio(prestostrategy, NULL, dev, B_WRITE, minphys, uio));
@


1.17
log
@Garbage collect struct dkdriver.

ok miod@@; "please go ahead" jsing@@
@
text
@d164 1
a164 1
	disk_attach(&sc->sc_dk);
@


1.16
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: presto.c,v 1.14 2008/06/15 00:36:40 krw Exp $	*/
a84 4
struct dkdriver	presto_dk = {
	prestostrategy,
};

a162 1
	sc->sc_dk.dk_driver = &presto_dk;
@


1.15
log
@Make DIOCSDINFO code consistant everywhere.

ok miod@@ deraadt@@
@
text
@a374 2
	lp->d_rpm = 3600;
	lp->d_interleave = 1;
@


1.14
log
@Don't bypass partition bounds check for RAW_PART. We now guarantee that
RAW_PART will always be 0 -> disksize, so the bounds check will always
pass for i/o's to valid addresses. Now the i/o will be properly truncated
if it goes past the end of the device. This prevents various adverse
impacts of issuing i/o's for data past the end of the device.

Repeatedly requested by todd@@.

ok weingart@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: presto.c,v 1.13 2007/06/20 18:15:47 deraadt Exp $	*/
d336 1
a342 8
		return (error);

	case DIOCWDINFO:
		if ((flag & FWRITE) == 0)
			return (EBADF);

		error = setdisklabel(sc->sc_dk.dk_label,
		    (struct disklabel *)data, /*sd->sc_dk.dk_openmask : */0);
d344 3
a346 2
			error = writedisklabel(DISKLABELDEV(dev),
			    prestostrategy, sc->sc_dk.dk_label);
d348 1
a349 1
		return (error);
@


1.13
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: presto.c,v 1.12 2007/06/15 02:28:49 todd Exp $	*/
d279 1
a279 1
	int unit, part;
d295 1
a295 3
	part = DISKPART(bp->b_dev);
	if (part != RAW_PART &&
	    bounds_check_with_label(bp, sc->sc_dk.dk_label, 1) <= 0)
@


1.12
log
@permit this to compile again
looks right krw@@, Righto miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: presto.c,v 1.11 2007/06/08 05:27:58 deraadt Exp $	*/
d297 1
a297 2
	    bounds_check_with_label(bp, sc->sc_dk.dk_label,
	    sc->sc_dk.dk_cpulabel, 1) <= 0)
d343 1
a343 2
		    (struct disklabel *)data, /*sd->sc_dk.dk_openmask : */0,
		    sc->sc_dk.dk_cpulabel);
d351 1
a351 2
		    (struct disklabel *)data, /*sd->sc_dk.dk_openmask : */0,
		    sc->sc_dk.dk_cpulabel);
d354 1
a354 2
			    prestostrategy, sc->sc_dk.dk_label,
			    sc->sc_dk.dk_cpulabel);
a370 1
	bzero(sc->sc_dk.dk_cpulabel, sizeof(struct cpu_disklabel));
d391 1
a391 2
	readdisklabel(DISKLABELDEV(dev), prestostrategy, sc->sc_dk.dk_label,
	    sc->sc_dk.dk_cpulabel, 0);
@


1.11
log
@all drivers should spoof version 1 labels
@
text
@d1 1
a1 1
/*	$OpenBSD: presto.c,v 1.10 2007/06/06 17:15:12 deraadt Exp $	*/
d186 1
a186 1
int
@


1.10
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: presto.c,v 1.9 2007/06/05 00:38:18 deraadt Exp $	*/
d390 1
@


1.9
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: presto.c,v 1.8 2007/06/04 16:38:58 krw Exp $	*/
d177 1
a177 1
prestodump(dev_t dev, daddr_t blkno, caddr_t va, size_t size)
@


1.8
log
@Bring presto's readdisklabel() usage into line with other uses. i.e.
don't call it at attach but at open, so that the correct device can be
used in the DISKLABELDEV() invocation.

Commit and get into miod's test schedule.

'... commit your diff ...' miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: presto.c,v 1.7 2007/06/01 00:07:48 krw Exp $	*/
d201 1
a201 1
		return (sc->sc_dk.dk_label->d_partitions[part].p_size *
d381 2
a382 2
	lp->d_secperunit = (sc->sc_memsize - PSERVE_OFFSET) >> DEV_BSHIFT;
	lp->d_ncylinders = lp->d_secperunit / lp->d_nsectors;
@


1.7
log
@Don't initialize d_partitions[RAW_DISK] just before calling
readdisklabel(), since all readdisklabel()'s do that already.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: presto.c,v 1.6 2006/09/24 20:29:52 krw Exp $	*/
d74 1
a74 1
void	presto_getdisklabel(struct presto_softc *);
a169 3

	/* read the disk label immediately */
	presto_getdisklabel(sc);
d216 3
d371 1
a371 1
presto_getdisklabel(struct presto_softc *sc)
d395 2
a396 2
	readdisklabel(DISKLABELDEV(sc->sc_dev.dv_unit), prestostrategy,
	    sc->sc_dk.dk_label, sc->sc_dk.dk_cpulabel, 0);
@


1.6
log
@Eliminate D_CHAIN, D_ECC and D_RAMDISK flags from disklabel. They were
not being used in the tree for anything obviously useful. Get it done
early so we can find if there are non-obvious uses out there.

ok deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: presto.c,v 1.5 2006/08/14 01:04:58 krw Exp $	*/
a389 5

	lp->d_partitions[RAW_PART].p_offset = 0;
	lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
	lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;
	lp->d_npartitions = RAW_PART + 1;
@


1.5
log
@Now that DEV_BSIZE is universally defined as 1 << DEV_BSHIFT, use it to
set d_secsize instead of 1 << DEV_BSHIFT. Just for textual consistency in
setting d_secsize.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: presto.c,v 1.4 2006/08/12 13:53:44 krw Exp $	*/
a389 1
	lp->d_flags = D_RAMDISK;
@


1.4
log
@Setting d_secsize to DEV_BSIZE (or 1 << DEV_BSHIFT, or 512) and then
setting RAW_PART's p_size to d_secperunit * (d_secsize / DEV_BSIZE) is
a waste of a few ops. And p_size should be in sectors anyway.

Just set RAW_PART's p_size to d_secperunit to make usage consistant
across the tree.

Should be a no-op.
@
text
@d1 1
a1 1
/*	$OpenBSD: presto.c,v 1.3 2006/06/02 20:00:54 miod Exp $	*/
d378 1
a378 1
	lp->d_secsize = 1 << DEV_BSHIFT;
@


1.3
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: presto.c,v 1.2 2003/05/26 18:16:27 tedu Exp $	*/
d393 1
a393 2
	lp->d_partitions[RAW_PART].p_size =
	    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);
@


1.2
log
@fix some fictitious spellings.  ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: presto.c,v 1.1 2003/04/13 22:55:49 miod Exp $	*/
a47 1
	struct	sbusdev sc_sd;
a165 2

	sbus_establish(&sc->sc_sd, &sc->sc_dev);
@


1.1
log
@Add a simple driver for the SBus ``Prestoserve'' NVRAM cards.

The Legato Prestoserve NFS accelerator used to be very popular, back when
NFSv3 did not exist, and disks and network speeds were not as good as they
are now...

This driver does not attempt to play any game with filesystems, but will only
provide access to the cards NVRAM, as a block device.

If you have bright ideas on ``what to do with a few MB of battery-backed
memory'', I am interested in realistic suggestions!
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d116 1
a116 1
		submodel = "fictious";
d371 1
a371 1
 * Read the disklabel. If none is present, use a fictious one instead.
@


1.1.2.1
log
@Add new file to SMP branch
@
text
@@


1.1.2.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: presto.c,v 1.1.2.1 2003/05/12 19:58:48 ho Exp $	*/
d116 1
a116 1
		submodel = "fictitious";
d371 1
a371 1
 * Read the disklabel. If none is present, use a fictitious one instead.
@


