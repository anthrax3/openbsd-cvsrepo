head	1.34;
access;
symbols
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.33.0.4
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.31.0.10
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.31.0.8
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.6
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.4
	OPENBSD_5_0:1.31.0.2
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.29.0.4
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.28.0.4
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.25.0.4
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.24.0.14
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.12
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.10
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.24.0.8
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.24.0.6
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.24.0.4
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.24.0.2
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.23.0.8
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	OPENBSD_3_5:1.23.0.6
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.23.0.4
	OPENBSD_3_4_BASE:1.23
	UBC_SYNC_A:1.23
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	UBC_SYNC_B:1.23
	UBC:1.19.0.2
	UBC_BASE:1.19
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	SMP:1.10.0.2
	SMP_BASE:1.10
	kame_19991208:1.9
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.2.0.6
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.4
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2;
locks; strict;
comment	@ * @;


1.34
date	2015.06.19.11.12.24;	author jmatthew;	state dead;
branches;
next	1.33;
commitid	I5HMIEQiHPSVn0jd;

1.33
date	2014.07.08.17.42.50;	author miod;	state Exp;
branches;
next	1.32;
commitid	BNvdU32ZeEdxUmLG;

1.32
date	2014.02.10.22.41.27;	author jmatthew;	state Exp;
branches;
next	1.31;

1.31
date	2011.04.22.23.29.18;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2010.11.11.17.46.58;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2009.08.30.21.22.25;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2009.06.24.11.38.40;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2009.06.24.11.00.53;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.25;

1.25
date	2008.06.01.15.49.25;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2004.09.29.07.35.11;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2002.10.12.01.09.43;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.17.01.19.00;	author mjacob;	state Exp;
branches;
next	1.21;

1.21
date	2002.04.30.01.12.29;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.14.01.26.43;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.14.00.20.54;	author mjacob;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.09.01.07.16.39;	author mjacob;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.16.12.49.48;	author ho;	state Exp;
branches;
next	1.16;

1.16
date	2001.04.04.22.06.22;	author mjacob;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.12.23.22.02;	author mjacob;	state Exp;
branches;
next	1.14;

1.14
date	2000.10.16.22.45.02;	author mjacob;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.16.01.01.57;	author mjacob;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.06.05.25.15;	author mjacob;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.20.21.24.19;	author mjacob;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.09.22.43.18;	author mjacob;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	99.11.22.12.53.23;	author mjacob;	state Exp;
branches;
next	1.8;

1.8
date	99.07.09.21.34.45;	author art;	state Exp;
branches;
next	1.7;

1.7
date	99.03.25.22.58.37;	author mjacob;	state Exp;
branches;
next	1.6;

1.6
date	99.03.17.21.50.12;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.03.17.05.20.24;	author mjacob;	state Exp;
branches;
next	1.4;

1.4
date	99.01.11.05.11.56;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	98.11.11.00.50.31;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	97.09.17.06.47.10;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.08.08.08.25.15;	author downsj;	state Exp;
branches;
next	;

1.10.2.1
date	2000.02.21.22.29.02;	author niklas;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2001.05.14.21.37.07;	author niklas;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2001.07.04.10.23.26;	author niklas;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2001.10.31.03.07.56;	author nate;	state Exp;
branches;
next	1.10.2.5;

1.10.2.5
date	2002.03.06.02.04.46;	author niklas;	state Exp;
branches;
next	1.10.2.6;

1.10.2.6
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.10.2.7;

1.10.2.7
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	;

1.19.2.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2002.10.29.00.28.09;	author art;	state Exp;
branches;
next	;


desc
@@


1.34
log
@remove isp(4) now that the ql* family have replaced it
@
text
@/*	$OpenBSD: isp_sbus.c,v 1.33 2014/07/08 17:42:50 miod Exp $	*/
/*
 * SBus specific probe and attach routines for Qlogic ISP SCSI adapters.
 *
 * Copyright (c) 1997, 2000 by Matthew Jacob
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 *    documentation and/or other materials provided with the distribution.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/queue.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/param.h>
#include <machine/vmparam.h>
#include <sparc/sparc/cpuvar.h>

#include <uvm/uvm_extern.h>

#include <dev/ic/isp_openbsd.h>

#ifndef ISP_NOFIRMWARE
#define ISP_FIRMWARE_1000
#define ISP_FIRMWARE_2200
#endif

#if	defined(ISP_FIRMWARE_1000)
#include <dev/microcode/isp/asm_sbus.h>
#else
#define	ISP_1000_RISC_CODE	NULL
#endif

#if	defined(ISP_FIRMWARE_2200)
extern const u_int16_t isp_2200_risc_code[];
#define	ISP_2200_RISC_CODE	(u_int16_t *) isp_2200_risc_code
#else
#define	ISP_2200_RISC_CODE	NULL
#endif

#define ISP_SBUSIFY_ISPHDR(isp, hdrp)					\
	ISP_SWAP8((hdrp)->rqs_entry_count, (hdrp)->rqs_entry_type);	\
	ISP_SWAP8((hdrp)->rqs_flags, (hdrp)->rqs_seqno);

#define	ISP_SWIZZLE_REQUEST(a, b)				\
	ISP_SBUSIFY_ISPHDR(a, &(b)->req_header);		\
        ISP_SWAP8((b)->req_target, (b)->req_lun_trn)


static int
isp_sbus_rd_isr(struct ispsoftc *, u_int32_t *, u_int16_t *, u_int16_t *);
static int
isp_sbus_rd_isr_2200(struct ispsoftc *, u_int32_t *, u_int16_t *, u_int16_t *);
static u_int32_t isp_sbus_rd_reg(struct ispsoftc *, int);
static void isp_sbus_wr_reg(struct ispsoftc *, int, u_int32_t);
static u_int32_t isp_sbus_rd_reg_2200(struct ispsoftc *, int);
static void isp_sbus_wr_reg_2200(struct ispsoftc *, int, u_int32_t);
static int isp_sbus_mbxdma(struct ispsoftc *);
static int isp_sbus_dmasetup(struct ispsoftc *, struct scsi_xfer *,
	ispreq_t *, u_int32_t *, u_int32_t);
static void
isp_sbus_dmateardown(struct ispsoftc *, struct scsi_xfer *, u_int32_t);
static int isp_sbus_intr(void *);

static struct ispmdvec mdvec = {
	isp_sbus_rd_isr,
	isp_sbus_rd_reg,
	isp_sbus_wr_reg,
	isp_sbus_mbxdma,
	isp_sbus_dmasetup,
	isp_sbus_dmateardown,
	NULL,
	NULL,
	NULL,
	ISP_1000_RISC_CODE,
	BIU_BURST_ENABLE|BIU_SBUS_CONF1_FIFO_32
};

static struct ispmdvec mdvec_2200 = {
	isp_sbus_rd_isr_2200,
	isp_sbus_rd_reg_2200,
	isp_sbus_wr_reg_2200,
	isp_sbus_mbxdma,
	isp_sbus_dmasetup,
	isp_sbus_dmateardown,
	NULL,
	NULL,
	NULL,
	ISP_2200_RISC_CODE
};

struct isp_sbussoftc {
	struct ispsoftc	sbus_isp;
	sdparam		sbus_dev;
	struct intrhand sbus_ih;
	volatile u_int16_t *sbus_reg;
	int		sbus_node;
	int		sbus_pri;
	struct ispmdvec	sbus_mdvec;
	int16_t		sbus_poff[_NREG_BLKS];
	vaddr_t	 	*sbus_kdma_allocs;
};


static int isp_match(struct device *, void *, void *);
static void isp_sbus_attach(struct device *, struct device *, void *);
struct cfattach isp_sbus_ca = {
	sizeof (struct isp_sbussoftc), isp_match, isp_sbus_attach
};

static int
isp_match(struct device *parent, void *cfarg, void *aux)
{
	int rv;
	struct cfdata *cf = cfarg;
#ifdef DEBUG
	static int oneshot = 1;
#endif
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

	rv = (strcmp(cf->cf_driver->cd_name, ra->ra_name) == 0 ||
		strcmp("PTI,ptisp", ra->ra_name) == 0 ||
		strcmp("ptisp", ra->ra_name) == 0 ||
		strcmp("SUNW,isp", ra->ra_name) == 0 ||
		strcmp("SUNW,qlc", ra->ra_name) == 0 ||
		strcmp("QLGC,isp", ra->ra_name) == 0 ||
		strcmp("QLGC,qla", ra->ra_name) == 0);
	if (rv == 0)
		return (rv);
#ifdef DEBUG
	if (rv && oneshot) {
		oneshot = 0;
		printf("Qlogic ISP Driver, OpenBSD (sbus) Platform Version "
		    "%d.%d Core Version %d.%d\n",
		    ISP_PLATFORM_VERSION_MAJOR, ISP_PLATFORM_VERSION_MINOR,
		    ISP_CORE_VERSION_MAJOR, ISP_CORE_VERSION_MINOR);
	}
#endif
	if (ca->ca_bustype == BUS_SBUS)
		return (1);
	ra->ra_len = NBPG;
	return (probeget(ra->ra_vaddr, 1) != -1);
}

static void
isp_sbus_attach(struct device *parent, struct device *self, void *aux)
{
	int freq, storebp = 0;
	struct confargs *ca = aux;
	struct bootpath *bp;
	struct isp_sbussoftc *sbc = (struct isp_sbussoftc *) self;
	struct ispsoftc *isp = &sbc->sbus_isp;
	volatile u_int16_t *fpga_reg;

	if (ca->ca_ra.ra_nintr != 1) {
		printf(": expected 1 interrupt, got %d\n", ca->ca_ra.ra_nintr);
		return;
	}

	printf("\n");

	sbc->sbus_pri = ca->ca_ra.ra_intr[0].int_pri;
	sbc->sbus_mdvec = mdvec;

	if (ca->ca_ra.ra_vaddr) {
		sbc->sbus_reg = (volatile u_int16_t *) ca->ca_ra.ra_vaddr;
	} else {
		sbc->sbus_reg = (volatile u_int16_t *)
			mapiodev(ca->ca_ra.ra_reg, 0, ca->ca_ra.ra_len);
	}
	sbc->sbus_node = ca->ca_ra.ra_node;

	freq = getpropint(ca->ca_ra.ra_node, "clock-frequency", 0);
	if (freq) {
		/*
		 * Convert from HZ to MHz, rounding up.
		 */
		freq = (freq + 500000)/1000000;
#if	0
		printf("%s: %d MHz\n", self->dv_xname, freq);
#endif
	}
	sbc->sbus_mdvec.dv_clock = freq;

	DEFAULT_IID(isp) =
	    getpropint(ca->ca_ra.ra_node, "scsi-initiator-id", 7);

	if ((bp = ca->ca_ra.ra_bp) != NULL) {
		if (bp->val[0] == ca->ca_slot &&
		    bp->val[1] == ca->ca_offset) {
			if (strcmp("isp", bp->name) == 0 ||
			    strcmp("QLGC,isp", bp->name) == 0 ||
			    strcmp("PTI,isp", bp->name) == 0 ||
			    strcmp("ptisp", bp->name) == 0) {
				storebp = 1;
			}
		}
	}

	/*
	 * XXX: Now figure out what the proper burst sizes, etc., to use.
	 */
	sbc->sbus_mdvec.dv_conf1 |= BIU_SBUS_CONF1_FIFO_8;

	/*
	 * Some early versions of the PTI SBus adapter
	 * would fail in trying to download (via poking)
	 * FW. We give up on them.
	 */
	if (strcmp("PTI,ptisp", ca->ca_ra.ra_name) == 0 ||
	    strcmp("ptisp", ca->ca_ra.ra_name) == 0) {
		sbc->sbus_mdvec.dv_ispfw = NULL;
	}

	isp->isp_mdvec = &sbc->sbus_mdvec;
	isp->isp_bustype = ISP_BT_SBUS;
	isp->isp_type = ISP_HA_SCSI_UNKNOWN;
	isp->isp_param = &sbc->sbus_dev;
	bzero(isp->isp_param, sizeof (sdparam));

	sbc->sbus_poff[BIU_BLOCK >> _BLK_REG_SHFT] = BIU_REGS_OFF;
	sbc->sbus_poff[MBOX_BLOCK >> _BLK_REG_SHFT] = SBUS_MBOX_REGS_OFF;
	sbc->sbus_poff[SXP_BLOCK >> _BLK_REG_SHFT] = SBUS_SXP_REGS_OFF;
	sbc->sbus_poff[RISC_BLOCK >> _BLK_REG_SHFT] = SBUS_RISC_REGS_OFF;
	sbc->sbus_poff[DMA_BLOCK >> _BLK_REG_SHFT] = DMA_REGS_OFF;

	if (strcmp("SUNW,qlc", ca->ca_ra.ra_name) == 0 ||
	    strcmp("QLGC,qla", ca->ca_ra.ra_name) == 0) {
		isp->isp_mdvec = &mdvec_2200;
		isp->isp_bustype = ISP_BT_PCI;
		isp->isp_type = ISP_HA_FC_2200;
		isp->isp_param = malloc(sizeof(fcparam), M_DEVBUF,
		    M_NOWAIT | M_ZERO);
		if (isp->isp_param == NULL) {
			printf("%s: no mem for sdparam table\n",
			    self->dv_xname);
			return;
		}
		sbc->sbus_poff[BIU_BLOCK >> _BLK_REG_SHFT] =
		    0x100 + BIU_REGS_OFF;
		sbc->sbus_poff[MBOX_BLOCK >> _BLK_REG_SHFT] =
		    0x100 + PCI_MBOX_REGS2100_OFF;
		sbc->sbus_poff[SXP_BLOCK >> _BLK_REG_SHFT] =
		    0x100 + PCI_SXP_REGS_OFF;
		sbc->sbus_poff[RISC_BLOCK >> _BLK_REG_SHFT] =
		    0x100 + PCI_RISC_REGS_OFF;
		sbc->sbus_poff[DMA_BLOCK >> _BLK_REG_SHFT] =
		    0x100 + DMA_REGS_OFF;

		fpga_reg = mapiodev(&ca->ca_ra.ra_reg[1], 0,
		    ca->ca_ra.ra_reg[1].rr_len);
		fpga_reg[0x80] &= ~htole16(0x700);
		fpga_reg[0x80] |= htole16(0x300);
	}

	/* Establish interrupt channel */
	sbc->sbus_ih.ih_fun = (void *) isp_sbus_intr;
	sbc->sbus_ih.ih_arg = sbc;
	intr_establish(sbc->sbus_pri, &sbc->sbus_ih, IPL_BIO, self->dv_xname);

	/*
	 * Set up logging levels.
	 */
#ifdef	ISP_LOGDEFAULT
	isp->isp_dblev = ISP_LOGDEFAULT;
#else
	isp->isp_dblev = ISP_LOGWARN|ISP_LOGERR;
#if 0
	isp->isp_dblev |= ISP_LOGDEBUG1|ISP_LOGDEBUG2;
#endif
#ifdef	DEBUG
	isp->isp_dblev |= ISP_LOGDEBUG0|ISP_LOGCONFIG|ISP_LOGINFO;
#endif
#endif
	isp->isp_confopts = self->dv_cfdata->cf_flags;
	isp->isp_role = ISP_DEFAULT_ROLES;

	ISP_LOCK(isp);
	isp->isp_osinfo.no_mbox_ints = 1;
	isp_reset(isp);
	if (isp->isp_state != ISP_RESETSTATE) {
		ISP_UNLOCK(isp);
		return;
	}
	ISP_ENABLE_INTS(isp);
	isp_init(isp);
	if (isp->isp_state != ISP_INITSTATE) {
		isp_uninit(isp);
		ISP_UNLOCK(isp);
		return;
	}

	/*
	 * do generic attach.
	 */
	if (storebp) {
		/*
		 * We're the booting HBA.
		 *
		 * Override the bootpath name with our driver name
		 * so we will do the correct matching and and store
		 * the next component's boot path entry, also so a
		 * successful match will occur.
		 */
		bcopy("isp", bp->name, 4);
		bp++;
		bootpath_store(1, bp);
	}
	isp_attach(isp);
	if (isp->isp_state != ISP_RUNSTATE) {
		isp_uninit(isp);
	}
	if (storebp) {
		bootpath_store(1, NULL);
	}
	ISP_UNLOCK(isp);
}

#define	IspVirt2Off(a, x)	\
	(((struct isp_sbussoftc *)a)->sbus_poff[((x) & _BLK_REG_MASK) >> \
	_BLK_REG_SHFT] + ((x) & 0xff))

#define	BXR2(pcs, off)		(sbc->sbus_reg[off >> 1])

static int
isp_sbus_rd_isr(struct ispsoftc *isp, u_int32_t *isrp,
    u_int16_t *semap, u_int16_t *mbp)
{
	struct isp_sbussoftc *sbc = (struct isp_sbussoftc *) isp;
	volatile u_int16_t isr, sema;

	isr = BXR2(pcs, IspVirt2Off(isp, BIU_ISR));
	sema = BXR2(pcs, IspVirt2Off(isp, BIU_SEMA));
	isp_prt(isp, ISP_LOGDEBUG3, "ISR 0x%x SEMA 0x%x", isr, sema);
	isr &= INT_PENDING_MASK(isp);
	sema &= BIU_SEMA_LOCK;
	if (isr == 0 && sema == 0) {
		return (0);
	}
	*isrp = isr;
	if ((*semap = sema) != 0) {
		*mbp = BXR2(pcs, IspVirt2Off(isp, OUTMAILBOX0));
	}
	return (1);
}

static int
isp_sbus_rd_isr_2200(struct ispsoftc *isp, u_int32_t *isrp,
    u_int16_t *semap, u_int16_t *mbp)
{
	struct isp_sbussoftc *sbc = (struct isp_sbussoftc *) isp;
	volatile u_int16_t isr, sema;

	isr = letoh16(BXR2(pcs, IspVirt2Off(isp, BIU_ISR)));
	sema = letoh16(BXR2(pcs, IspVirt2Off(isp, BIU_SEMA)));
	isp_prt(isp, ISP_LOGDEBUG3, "ISR 0x%x SEMA 0x%x", isr, sema);
	isr &= INT_PENDING_MASK(isp);
	sema &= BIU_SEMA_LOCK;
	if (isr == 0 && sema == 0) {
		return (0);
	}
	*isrp = isr;
	if ((*semap = sema) != 0) {
		*mbp = letoh16(BXR2(pcs, IspVirt2Off(isp, OUTMAILBOX0)));
	}
	return (1);
}

static u_int32_t
isp_sbus_rd_reg(struct ispsoftc *isp, int regoff)
{
	struct isp_sbussoftc *sbc = (struct isp_sbussoftc *) isp;
	int offset = sbc->sbus_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];
	offset += (regoff & 0xff);
	return ((u_int16_t) sbc->sbus_reg[offset >> 1]);
}

static void
isp_sbus_wr_reg(struct ispsoftc *isp, int regoff, u_int32_t val)
{
	struct isp_sbussoftc *sbc = (struct isp_sbussoftc *) isp;
	int offset = sbc->sbus_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];
	offset += (regoff & 0xff);
	sbc->sbus_reg[offset >> 1] = val;
}

static u_int32_t
isp_sbus_rd_reg_2200(struct ispsoftc *isp, int regoff)
{
	struct isp_sbussoftc *sbc = (struct isp_sbussoftc *) isp;
	int offset = sbc->sbus_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];
	offset += (regoff & 0xff);
	return ((u_int16_t) letoh16(sbc->sbus_reg[offset >> 1]));
}

static void
isp_sbus_wr_reg_2200(struct ispsoftc *isp, int regoff, u_int32_t val)
{
	struct isp_sbussoftc *sbc = (struct isp_sbussoftc *) isp;
	int offset = sbc->sbus_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];
	offset += (regoff & 0xff);
	sbc->sbus_reg[offset >> 1] = htole16(val);
}

static int
isp_sbus_mbxdma(struct ispsoftc *isp)
{
	struct isp_sbussoftc *sbc = (struct isp_sbussoftc *) isp;
	size_t len;

	if (isp->isp_rquest_dma)	/* been here before? */
		return (0);

	/*
	 * NOTE: Since most Sun machines aren't I/O coherent,
	 * map the mailboxes through kdvma space to force them
	 * to be uncached.
	 */

	len = isp->isp_maxcmds * sizeof (XS_T);
	isp->isp_xflist = (XS_T **) malloc(len, M_DEVBUF, M_WAITOK | M_ZERO);
	len = isp->isp_maxcmds * sizeof (vaddr_t);
	sbc->sbus_kdma_allocs = (vaddr_t *) malloc(len, M_DEVBUF,
	    M_WAITOK | M_ZERO);

	/*
	 * Allocate and map the request queue.
	 */
	len = ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN(isp));
	isp->isp_rquest = (volatile caddr_t)malloc(len, M_DEVBUF, M_NOWAIT);
	if (isp->isp_rquest == 0) {
		printf("%s: cannot allocate request queue\n", isp->isp_name);
		return (1);
	}
	isp->isp_rquest_dma = (u_int32_t)
	    kdvma_mapin((caddr_t)isp->isp_rquest, len, 0);
	if (isp->isp_rquest_dma == 0) {
		printf("%s: can't mapin request queue\n", isp->isp_name);
		return (1);
	}

	/*
	 * Allocate and map the result queue.
	 */
	len = ISP_QUEUE_SIZE(RESULT_QUEUE_LEN(isp));
	isp->isp_result = (volatile caddr_t)malloc(len, M_DEVBUF, M_NOWAIT);
	if (isp->isp_result == 0) {
		printf("%s: cannot allocate result queue\n", isp->isp_name);
		return (1);
	}
	isp->isp_result_dma = (u_int32_t)
	    kdvma_mapin((caddr_t)isp->isp_result, len, 0);
	if (isp->isp_result_dma == 0) {
		printf("%s: can't mapin result queue\n", isp->isp_name);
		return (1);
	}

	if (IS_FC(isp)) {
		/*
		 * Allocate and map the FC scratch area.
		 */
		len = ISP2100_SCRLEN;
		FCPARAM(isp)->isp_scratch = malloc(len, M_DEVBUF, M_NOWAIT);
		if (FCPARAM(isp)->isp_scratch == 0) {
			printf("%s: cannot allocate FC scratch area\n",
			    isp->isp_name);
			return (1);
		}
		FCPARAM(isp)->isp_scdma = (u_int32_t)
		    kdvma_mapin((caddr_t)FCPARAM(isp)->isp_scratch, len, 0);
		if (FCPARAM(isp)->isp_scdma == 0) {
			printf("%s: can't mapin FC scratch area\n",
			    isp->isp_name);
			return (1);
		}
	}

	return (0);
}

/*
 * TODO: If kdvma_mapin fails, try using multiple smaller chunks..
 */

static int
isp_sbus_dmasetup(struct ispsoftc *isp, struct scsi_xfer *xs, ispreq_t *rq,
    u_int32_t *iptrp, u_int32_t optr)
{
	struct isp_sbussoftc *sbc = (struct isp_sbussoftc *) isp;
	ispreq_t *qe;
	ispcontreq_t *crq;
	vaddr_t kdvma;
	int dosleep = (xs->flags & SCSI_NOSLEEP) != 0;

	qe = (ispreq_t *) ISP_QUEUE_ENTRY(isp->isp_rquest, isp->isp_reqidx);
	if (xs->datalen == 0) {
		rq->req_seg_count = 1;
		goto mbxsync;
	}
	if (CPU_ISSUN4M) {
		kdvma = (vaddr_t)
			kdvma_mapin((caddr_t)xs->data, xs->datalen, dosleep);
		if (kdvma == (vaddr_t) 0) {
			XS_SETERR(xs, HBA_BOTCH);
			return (CMD_COMPLETE);
		}
	} else {
		kdvma = (vaddr_t) xs->data;
	}

	if (sbc->sbus_kdma_allocs[isp_handle_index(rq->req_handle)] != 0) {
		panic("%s: kdma handle already allocated", isp->isp_name);
		/* NOTREACHED */
	}
	if (XS_CDBLEN(xs) > 12) {
		crq = (ispcontreq_t *) ISP_QUEUE_ENTRY(isp->isp_rquest, *iptrp);
		*iptrp = ISP_NXT_QENTRY(*iptrp, RQUEST_QUEUE_LEN(isp));
		if (*iptrp == optr) {
			printf("%s: Request Queue Overflow++\n", isp->isp_name);
			if (CPU_ISSUN4M) {
				dvma_mapout(kdvma,
				    (vaddr_t) xs->data, xs->datalen);
			}
			XS_SETERR(xs, HBA_BOTCH);
			return (CMD_EAGAIN);
		}
	} else {
		crq = NULL;
	}
	sbc->sbus_kdma_allocs[isp_handle_index(rq->req_handle)] = kdvma;
	if (xs->flags & SCSI_DATA_IN) {
		rq->req_flags |= REQFLAG_DATA_IN;
	} else {
		rq->req_flags |= REQFLAG_DATA_OUT;
	}
	if (crq) {
		rq->req_seg_count = 2;
		rq->req_dataseg[0].ds_count = 0;
		rq->req_dataseg[0].ds_base =  0;
		bzero((void *)crq, sizeof (*crq));
		crq->req_header.rqs_entry_count = 1;
		crq->req_header.rqs_entry_type = RQSTYPE_DATASEG;  
		crq->req_dataseg[0].ds_count = xs->datalen;
		crq->req_dataseg[0].ds_base =  (u_int32_t) kdvma;
                ISP_SBUSIFY_ISPHDR(isp, &crq->req_header)
	} else {
		rq->req_dataseg[0].ds_count = xs->datalen;
		rq->req_dataseg[0].ds_base =  (u_int32_t) kdvma;
		rq->req_seg_count = 1;
	}

mbxsync:
	ISP_SWIZZLE_REQUEST(isp, rq);
	bcopy(rq, qe, sizeof (ispreq_t));
	return (CMD_QUEUED);
}

static void
isp_sbus_dmateardown(struct ispsoftc *isp, XS_T *xs, u_int32_t handle)
{
	struct isp_sbussoftc *sbc = (struct isp_sbussoftc *) isp;
	vaddr_t kdvma;

	if (xs->flags & SCSI_DATA_IN) {
		cpuinfo.cache_flush(xs->data, xs->datalen - xs->resid);
	}
	if (sbc->sbus_kdma_allocs[isp_handle_index(handle)] == (vaddr_t) 0) {
		panic("%s: kdma handle not already allocated", isp->isp_name);
		/* NOTREACHED */
	}
	kdvma = sbc->sbus_kdma_allocs[isp_handle_index(handle)];
	sbc->sbus_kdma_allocs[isp_handle_index(handle)] = (vaddr_t) 0;
	if (CPU_ISSUN4M) {
		dvma_mapout(kdvma, (vaddr_t) xs->data, xs->datalen);
	}
}

static int
isp_sbus_intr(void *arg)
{
	u_int32_t isr;
	u_int16_t sema, mbox;
	struct ispsoftc *isp = (struct ispsoftc *)arg;

	isp->isp_intcnt++;
	if (ISP_READ_ISR(isp, &isr, &sema, &mbox) == 0) {
		isp->isp_intbogus++;
		return (0);
	} else {
		isp->isp_osinfo.onintstack = 1;
		isp_intr(isp, isr, sema, mbox);
		isp->isp_osinfo.onintstack = 0;
		return (1);
	}
}
@


1.33
log
@Repair compilability after the recent uvmexp changes, especially for
not compile-time-known page size platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.32 2014/02/10 22:41:27 jmatthew Exp $	*/
@


1.32
log
@Build isp2xxx firmware into separate object files so we only include
one copy when both isp(4) and qla(4) are enabled.  This is a temporary
measure until qla(4) takes over completely.

looked at by miod@@ and kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.31 2011/04/22 23:29:18 deraadt Exp $	*/
d44 2
@


1.31
log
@Turning on SCSIDEBUG (for debugging other drivers, of course) should
not make these drivers spew millions of lines of output.
spotted as missing by miod
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.30 2010/11/11 17:46:58 miod Exp $	*/
d59 1
a60 1
#include <dev/microcode/isp/asm_2200.h>
@


1.30
log
@Pass a few more M_ZERO to malloc() or its wrappers, when useful; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.29 2009/08/30 21:22:25 kettenis Exp $	*/
d293 1
a293 1
#ifdef	SCSIDEBUG
@


1.29
log
@Add support for ISP2200 SBus FC cards.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.28 2009/06/24 11:38:40 deraadt Exp $	*/
d446 1
a446 2
	isp->isp_xflist = (XS_T **) malloc(len, M_DEVBUF, M_WAITOK);
	bzero(isp->isp_xflist, len);
d448 2
a449 2
	sbc->sbus_kdma_allocs = (vaddr_t *) malloc(len, M_DEVBUF, M_WAITOK);
	bzero(sbc->sbus_kdma_allocs, len);
@


1.28
log
@for the isp(4) driver, invert the meaning of the options which pull
firmwares into the smaller (and larger) media
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.26 2009/03/29 21:53:52 sthen Exp $	*/
d49 1
d58 7
d76 2
d80 2
d99 1
a99 1
	(u_int16_t *) ISP_1000_RISC_CODE,
d103 13
d150 3
a152 1
		strcmp("QLGC,isp", ra->ra_name) == 0);
d178 1
d252 29
d372 22
d412 17
d483 21
@


1.27
log
@Major update to isp driver, mostly from mjacob via FreeBSD.

Everything that worked before should still work so in it goes. Newer
boards (2300, 2400) may now work but are still a work in progress.
Thanks to many testers but especially kettenis@@ for finding a show
stopper bug and stomping it.

ok deraadt@@
@
text
@d46 6
a51 1
#if	defined(ISP_COMPILE_FW) || defined(ISP_COMPILE_1000_FW)
d53 2
a75 4

#ifndef	ISP_1000_RISC_CODE
#define	ISP_1000_RISC_CODE	NULL
#endif
@


1.26
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.25 2008/06/01 15:49:25 kettenis Exp $	*/
d60 3
a62 3
isp_sbus_rd_isr(struct ispsoftc *, u_int16_t *, u_int16_t *, u_int16_t *);
static u_int16_t isp_sbus_rd_reg(struct ispsoftc *, int);
static void isp_sbus_wr_reg(struct ispsoftc *, int, u_int16_t);
d65 1
a65 1
	ispreq_t *, u_int16_t *, u_int16_t);
d67 1
a67 1
isp_sbus_dmateardown(struct ispsoftc *, struct scsi_xfer *, u_int16_t);
d250 1
a250 1
	ENABLE_INTS(isp);
d291 1
a291 1
isp_sbus_rd_isr(struct ispsoftc *isp, u_int16_t *isrp,
d312 1
a312 1
static u_int16_t
d322 1
a322 1
isp_sbus_wr_reg(struct ispsoftc *isp, int regoff, u_int16_t val)
d393 1
a393 1
    u_int16_t *iptrp, u_int16_t optr)
d465 1
a465 1
isp_sbus_dmateardown(struct ispsoftc *isp, XS_T *xs, u_int16_t handle)
d487 2
a488 1
	u_int16_t isr, sema, mbox;
@


1.25
log
@Make SCSI isp(4) use the same SCSI initiator ID as the prom on sparc/sparc64.

ok marco@@, krw@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.24 2004/09/29 07:35:11 miod Exp $	*/
d365 1
a365 1
		printf("%s: could not mapin request queue\n", isp->isp_name);
d381 1
a381 1
		printf("%s: could not mapin result queue\n", isp->isp_name);
@


1.24
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.23 2002/10/12 01:09:43 krw Exp $	*/
d178 3
@


1.23
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.22 2002/05/17 01:19:00 mjacob Exp $	*/
d221 1
a221 1
	intr_establish(sbc->sbus_pri, &sbc->sbus_ih, IPL_BIO);
@


1.22
log
@Handle the removal of 'const' from structure definition.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.21 2002/04/30 01:12:29 art Exp $	*/
d415 1
a415 1
		panic("%s: kdma handle already allocated\n", isp->isp_name);
d471 1
a471 1
		panic("%s: kdma handle not already allocated\n", isp->isp_name);
@


1.21
log
@Fix an ancient problem in how sparc interrupts are handled.

There are many interrupt handlers that assume that they don't need to do
any spl protection in their code because the interrupt of some level can't
be interrupted by an interrupt of the same level. The problem is that some
interrupt handlers have hardware levels that are lower then their "software"
levels.

Fix this by adding an additional field to struct intrhand that specifies which
"software" level an interrupt handler has and blocks that level while handling
the interrupt. This new field is initialized in intr_establish which gets
an additional argument (which can be -1 meaning that the interrupt handler
doesn't need to block any additional level).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.20 2002/03/14 01:26:43 millert Exp $	*/
d84 1
a84 1
	ISP_1000_RISC_CODE,
@


1.20
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.19 2001/12/14 00:20:54 mjacob Exp $	*/
d221 1
a221 1
	intr_establish(sbc->sbus_pri, &sbc->sbus_ih);
@


1.19
log
@Major restructuring for swizzling to the request queue and unswizzling from
the response queue. Instead of the ad hoc ISP_SWIZZLE_REQUEST, we now have
a complete set of inline functions in isp_inline.h. Each platform is
responsible for providing just one of a set of ISP_IOX_{GET,PUT}{8,16,32}
macros.

The reason this needs to be done is that we need to have a single set of
functions that will work correctly on multiple architectures for both little
and big endian machines. It also needs to work correctly in the case that
we have the request or response queues in memory that has to be treated
specially (e.g., have ddi_dma_sync called on it for Solaris after we update
it or before we read from it).

One thing that falls out of this is that we no longer build requests in the
request queue itself. Instead, we build the request locally (e.g., on the
stack) and then as part of the swizzling operation, copy it to the request
queue entry we've allocated. I thought long and hard about whether this was
too expensive a change to make as it in a lot of cases requires an extra
copy. On balance, the flexbility is worth it. With any luck, the entry that
we build locally stays in a processor writeback cache (after all, it's only
64 bytes) so that the cost of actually flushing it to the memory area that is
the shared queue with the PCI device is not all that expensive. We may examine
this again and try to get clever in the future to try and avoid copies.

Another change that falls out of this is that MEMORYBARRIER should be taken
a lot more seriously. The macro ISP_ADD_REQUEST does a MEMORYBARRIER on the
entry being added. But there had been many other places this had been missing.
It's now very important that it be done.

For OpenSD, it does a ddi_dmamap_sync as appropriate. This gets us out of
the explicit ddi_dmamap_sync on the whole response queue that we did for SBus
cards at each interrupt. Now, because SBus/sparc doesn't use bus_dma, some
shenanigans were done to support this. But Jason was nice enough to test the
SBus/sparcv9 changes for me, and they did the right thing as well.

Set things up so that platforms that cannot have an SBus don't get a lot of
the SBus code checks (dead coded out).

Additional changes:

Fix a longstanding buglet of sorts. When we get an entry via isp_getrqentry,
the iptr value that gets returned is the value we intend to eventually plug
into the ISP registers as the entry *one past* the last one we've written-
*not* the current entry we're updating. All along we've been calling sync
functions on the wrong index value. Argh. The 'fix' here is to rename all
'iptr' variables as 'nxti' to remember that this is the 'next' pointer-
not the current pointer.

Devote a single bit to mboxbsy- and set aside bits for output mbox registers
that we need to pick up- we can have at least one command which does not
have any defined output registers (MBOX_EXECUTE_FIRMWARE).

Explicitly decode GetAllNext SNS Response back *as* a GetAllNext response.
Otherwise, we won't unswizzle it correctly.

Nuke some additional __P macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.18 2001/09/01 07:16:39 mjacob Exp $	*/
d101 2
a102 2
static int isp_match __P((struct device *, void *, void *));
static void isp_sbus_attach __P((struct device *, struct device *, void *));
@


1.19.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.19 2001/12/14 00:20:54 mjacob Exp $	*/
d84 1
a84 1
	(u_int16_t *) ISP_1000_RISC_CODE,
d101 2
a102 2
static int isp_match(struct device *, void *, void *);
static void isp_sbus_attach(struct device *, struct device *, void *);
d221 1
a221 1
	intr_establish(sbc->sbus_pri, &sbc->sbus_ih, IPL_BIO);
@


1.19.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.19.2.1 2002/06/11 03:38:16 art Exp $	*/
d415 1
a415 1
		panic("%s: kdma handle already allocated", isp->isp_name);
d471 1
a471 1
		panic("%s: kdma handle not already allocated", isp->isp_name);
@


1.18
log
@Catch up with mainline of code development.

Add support for 2 Gigabit cards (2300/2312). This necessitated a change
in how interrupts are down- the 23XX has not only a different place to check
for an interrupt, but unlike all other QLogic cards, you have to read the
status as a 32 bit word- not 16 bit words. Rather than have device specific
functions as called from the core module (in isp_intr), it makes more sense
to have the platform/bus modules do the gruntwork of splitting out the
isr, semaphore register and the first outgoing mailbox register (if needed)
*prior* to calling isp_intr (if calling isp_intr is necessary at all).

Rearchitect how regular SCSI parameters are stored or used.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.17 2001/05/16 12:49:48 ho Exp $	*/
d50 9
d92 1
a92 1
	volatile u_char *sbus_reg;
d160 1
a160 1
		sbc->sbus_reg = (volatile u_char *) ca->ca_ra.ra_vaddr;
d162 1
a162 1
		sbc->sbus_reg = (volatile u_char *)
d285 1
a285 2
#define	BXR2(pcs, off)		\
	(*((u_int16_t *) &sbc->sbus_reg[off]))
d292 1
a292 1
	u_int16_t isr, sema;
d315 1
a315 1
	return (*((u_int16_t *) &sbc->sbus_reg[offset]));
d324 1
a324 1
	*((u_int16_t *) &sbc->sbus_reg[offset]) = val;
d393 1
d398 1
d457 1
a491 5
#if	0
		struct iss_sbussoftc *s = (struct isp_sbussoftc *)isp;
		bus_dmamap_sync(s->pci_dmat, s->pci_result_dmap,
		    BUS_DMASYNC_POSTREAD);
#endif
@


1.17
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.16 2001/04/04 22:06:22 mjacob Exp $	*/
d50 2
d66 1
d272 29
d473 1
a473 1
	int r;
d475 6
d482 3
a484 3
	struct iss_sbussoftc *s = (struct isp_sbussoftc *)isp;

	bus_dmamap_sync(p->pci_dmat, p->pci_result_dmap, BUS_DMASYNC_POSTREAD);
d486 5
a490 5

	isp->isp_osinfo.onintstack = 1;
	r = isp_intr(arg);
	isp->isp_osinfo.onintstack = 0;
	return (r);
@


1.16
log
@Ansify source. Handles are now 16 bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.15 2001/02/12 23:22:02 mjacob Exp $	*/
a304 4
	if (isp->isp_xflist == NULL) {
		printf("%s: cannot malloc xflist array\n", isp->isp_name);
		return (1);
	}
a307 4
	if (sbc->sbus_kdma_allocs == NULL) {
		printf("%s: cannot malloc sbus_kdma_allocs\n", isp->isp_name);
		return (1);
	}
@


1.15
log
@set default adapter role, propage config flags
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.14 2000/10/16 22:45:02 mjacob Exp $	*/
d50 8
a57 8
static u_int16_t isp_sbus_rd_reg __P((struct ispsoftc *, int));
static void isp_sbus_wr_reg __P((struct ispsoftc *, int, u_int16_t));
static int isp_sbus_mbxdma __P((struct ispsoftc *));
static int isp_sbus_dmasetup __P((struct ispsoftc *, struct scsi_xfer *,
	ispreq_t *, u_int16_t *, u_int16_t));
static void isp_sbus_dmateardown __P((struct ispsoftc *, struct scsi_xfer *,
	u_int32_t));
static int isp_sbus_intr __P((void *));
d96 1
a96 4
isp_match(parent, cfarg, aux)
        struct device *parent;
	void *cfarg;
        void *aux;
d129 1
a129 3
isp_sbus_attach(parent, self, aux)
        struct device *parent, *self;
        void *aux;
d270 1
a270 3
isp_sbus_rd_reg(isp, regoff)
	struct ispsoftc *isp;
	int regoff;
d279 1
a279 4
isp_sbus_wr_reg (isp, regoff, val)
	struct ispsoftc *isp;
	int regoff;
	u_int16_t val;
d289 1
a289 2
isp_sbus_mbxdma(isp)
	struct ispsoftc *isp;
d357 2
a358 6
isp_sbus_dmasetup(isp, xs, rq, iptrp, optr)
	struct ispsoftc *isp;
	struct scsi_xfer *xs;
	ispreq_t *rq;
	u_int16_t *iptrp;
	u_int16_t optr;
d427 1
a427 4
isp_sbus_dmateardown(isp, xs, handle)
	struct ispsoftc *isp;
	struct scsi_xfer *xs;
	u_int32_t handle;
d447 1
a447 2
isp_sbus_intr(arg)
	void *arg;
@


1.14
log
@quiet these puppies down- this OpenBSD, not some callow system like NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.13 2000/10/16 01:01:57 mjacob Exp $	*/
d230 2
d233 1
a234 1
	ISP_LOCK(isp);
@


1.13
log
@Update OpenBSD with respect to Solaris/FreeBSD/NetBSD/Linux versions.

Major rewrite of a lot of internals- far too many to list. Cleaner
locking, more paramaterization, an isp_prt logging function that
handles debugging as well as error printouts. We also should no
longer hang if there is no Loop for Fibre Channel when booting.

The file ispvar.h now contains a list of all platform required macros
and explanation as to what they're for. This should make maintenance
easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.12 2000/07/06 05:25:15 mjacob Exp $	*/
d222 1
a222 1
	isp->isp_dblev = ISP_LOGCONFIG|ISP_LOGWARN|ISP_LOGERR;
d227 1
a227 4
	isp->isp_dblev |= ISP_LOGDEBUG0;
#endif
#ifdef	DIAGNOSTIC
	isp->isp_dblev |= ISP_LOGINFO;
@


1.12
log
@Use isp_handle_index functions. Reorder when things get
done (and return CMD_EAGAIN on request queue overflow
so we can retry).
@
text
@d1 1
a1 2
/*	$OpenBSD: isp_sbus.c,v 1.11 2000/02/20 21:24:19 mjacob Exp $	*/
/* release_03_25_99 */
d5 1
a5 2
 * Copyright (c) 1997 by Matthew Jacob
 * NASA AMES Research Center
a13 2
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
d15 1
a15 1
 * 3. The name of the author may not be used to endorse or promote products
d46 1
d48 1
d57 1
a61 3
#ifndef	ISP_CODE_ORG
#define	ISP_CODE_ORG	0x1000
#endif
d72 2
a73 2
	ISP_1000_RISC_CODE, 0, ISP_CODE_ORG, 0,
	BIU_BURST_ENABLE
a140 1
	ISP_LOCKVAL_DECL;
d212 1
a212 1
	sbc->sbus_ih.ih_fun = (void *) isp_intr;
d216 19
d241 1
a248 2
	ENABLE_INTS(isp);

d315 2
a316 2
	len = isp->isp_maxcmds * sizeof (ISP_SCSI_XFER_T);
	isp->isp_xflist = (ISP_SCSI_XFER_T **) malloc(len, M_DEVBUF, M_WAITOK);
d333 1
a333 1
	len = ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN);
d349 1
a349 1
	len = ISP_QUEUE_SIZE(RESULT_QUEUE_LEN);
d402 1
a402 1
		*iptrp = ISP_NXT_QENTRY(*iptrp, RQUEST_QUEUE_LEN);
d430 1
a430 1
		ISP_SWIZZLE_CONTINUATION(isp, crq);
d463 18
@


1.11
log
@Add support for CDBs > 12 bytes.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.10 2000/01/09 22:43:18 mjacob Exp $	*/
d233 3
a371 13
	if (XS_CDBLEN(xs) > 12) {
		crq = (ispcontreq_t *) ISP_QUEUE_ENTRY(isp->isp_rquest, *iptrp);
		*iptrp = (*iptrp + 1) & (RQUEST_QUEUE_LEN - 1);
		if (*iptrp == optr) {
			printf("%s: Request Queue Overflow++\n", isp->isp_name);
			XS_SETERR(xs, HBA_BOTCH);
			return (CMD_COMPLETE);
		}
	} else {
		crq = NULL;
	}
	assert(rq->req_handle != 0 && rq->req_handle <= isp->isp_maxcmds);

d383 1
a383 1
	if (sbc->sbus_kdma_allocs[rq->req_handle - 1] != (vaddr_t) 0) {
d387 16
a402 1
	sbc->sbus_kdma_allocs[rq->req_handle - 1] = kdvma;
d410 2
d441 1
a441 2
	assert(handle != 0 && handle <= isp->isp_maxcmds);
	if (sbc->sbus_kdma_allocs[handle - 1] == (vaddr_t) 0) {
d445 2
a446 2
	kdvma = sbc->sbus_kdma_allocs[handle - 1];
	sbc->sbus_kdma_allocs[handle - 1] = (vaddr_t) 0;
@


1.10
log
@Do the bootpath_store dance so we can boot off of a disk attached
to an isp controller. This involves rewriting the matched bootpath
component for the HBA with the generic 'isp' name so that matching
can be done correctly elsewhere.

Also use nulling the pointer to f/w to indicate not to load the
current f/w set (for older PTI cards) instead of f/w length.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.9 1999/11/22 12:53:23 mjacob Exp $	*/
d123 1
a123 1
		printf("Qlogic ISP Driver, NetBSD (sbus) Platform Version "
d361 1
d369 11
d403 13
a415 3
	rq->req_dataseg[0].ds_count = xs->datalen;
	rq->req_dataseg[0].ds_base =  (u_int32_t) kdvma;
	rq->req_seg_count = 1;
@


1.10.2.1
log
@sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.11 2000/02/20 21:24:19 mjacob Exp $	*/
d123 1
a123 1
		printf("Qlogic ISP Driver, OpenBSD (sbus) Platform Version "
a360 1
	ispcontreq_t *crq;
a367 11
	if (XS_CDBLEN(xs) > 12) {
		crq = (ispcontreq_t *) ISP_QUEUE_ENTRY(isp->isp_rquest, *iptrp);
		*iptrp = (*iptrp + 1) & (RQUEST_QUEUE_LEN - 1);
		if (*iptrp == optr) {
			printf("%s: Request Queue Overflow++\n", isp->isp_name);
			XS_SETERR(xs, HBA_BOTCH);
			return (CMD_COMPLETE);
		}
	} else {
		crq = NULL;
	}
d391 3
a393 13
	if (crq) {
		rq->req_seg_count = 2;
		bzero((void *)crq, sizeof (*crq));
		crq->req_header.rqs_entry_count = 1;
		crq->req_header.rqs_entry_type = RQSTYPE_DATASEG;  
		crq->req_dataseg[0].ds_count = xs->datalen;
		crq->req_dataseg[0].ds_base =  (u_int32_t) kdvma;
		ISP_SWIZZLE_CONTINUATION(isp, crq);
	} else {
		rq->req_dataseg[0].ds_count = xs->datalen;
		rq->req_dataseg[0].ds_base =  (u_int32_t) kdvma;
		rq->req_seg_count = 1;
	}
@


1.10.2.2
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 1
/*	$OpenBSD: isp_sbus.c,v 1.16 2001/04/04 22:06:22 mjacob Exp $	*/
d6 2
a7 1
 * Copyright (c) 1997, 2000 by Matthew Jacob
d16 2
d19 1
a19 1
 * 2. The name of the author may not be used to endorse or promote products
a49 1
#if	defined(ISP_COMPILE_FW) || defined(ISP_COMPILE_1000_FW)
a50 1
#endif
d52 7
a58 8
static u_int16_t isp_sbus_rd_reg(struct ispsoftc *, int);
static void isp_sbus_wr_reg(struct ispsoftc *, int, u_int16_t);
static int isp_sbus_mbxdma(struct ispsoftc *);
static int isp_sbus_dmasetup(struct ispsoftc *, struct scsi_xfer *,
	ispreq_t *, u_int16_t *, u_int16_t);
static void
isp_sbus_dmateardown(struct ispsoftc *, struct scsi_xfer *, u_int16_t);
static int isp_sbus_intr(void *);
d63 3
d76 2
a77 2
	ISP_1000_RISC_CODE,
	BIU_BURST_ENABLE|BIU_SBUS_CONF1_FIFO_32
d100 4
a103 1
isp_match(struct device *parent, void *cfarg, void *aux)
d136 3
a138 1
isp_sbus_attach(struct device *parent, struct device *self, void *aux)
d145 1
d217 1
a217 1
	sbc->sbus_ih.ih_fun = (void *) isp_sbus_intr;
a220 17
	/*
	 * Set up logging levels.
	 */
#ifdef	ISP_LOGDEFAULT
	isp->isp_dblev = ISP_LOGDEFAULT;
#else
	isp->isp_dblev = ISP_LOGWARN|ISP_LOGERR;
#ifdef	SCSIDEBUG
	isp->isp_dblev |= ISP_LOGDEBUG1|ISP_LOGDEBUG2;
#endif
#ifdef	DEBUG
	isp->isp_dblev |= ISP_LOGDEBUG0|ISP_LOGCONFIG|ISP_LOGINFO;
#endif
#endif
	isp->isp_confopts = self->dv_cfdata->cf_flags;
	isp->isp_role = ISP_DEFAULT_ROLES;

a221 1
	isp->isp_osinfo.no_mbox_ints = 1;
a226 1
	ENABLE_INTS(isp);
a232 1

d260 3
a262 1
isp_sbus_rd_reg(struct ispsoftc *isp, int regoff)
d271 4
a274 1
isp_sbus_wr_reg(struct ispsoftc *isp, int regoff, u_int16_t val)
d284 2
a285 1
isp_sbus_mbxdma(struct ispsoftc *isp)
d299 2
a300 2
	len = isp->isp_maxcmds * sizeof (XS_T);
	isp->isp_xflist = (XS_T **) malloc(len, M_DEVBUF, M_WAITOK);
d317 1
a317 1
	len = ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN(isp));
d333 1
a333 1
	len = ISP_QUEUE_SIZE(RESULT_QUEUE_LEN(isp));
d353 6
a358 2
isp_sbus_dmasetup(struct ispsoftc *isp, struct scsi_xfer *xs, ispreq_t *rq,
    u_int16_t *iptrp, u_int16_t optr)
d369 13
d393 1
a393 1
	if (sbc->sbus_kdma_allocs[isp_handle_index(rq->req_handle)] != 0) {
d397 1
a397 16
	if (XS_CDBLEN(xs) > 12) {
		crq = (ispcontreq_t *) ISP_QUEUE_ENTRY(isp->isp_rquest, *iptrp);
		*iptrp = ISP_NXT_QENTRY(*iptrp, RQUEST_QUEUE_LEN(isp));
		if (*iptrp == optr) {
			printf("%s: Request Queue Overflow++\n", isp->isp_name);
			if (CPU_ISSUN4M) {
				dvma_mapout(kdvma,
				    (vaddr_t) xs->data, xs->datalen);
			}
			XS_SETERR(xs, HBA_BOTCH);
			return (CMD_EAGAIN);
		}
	} else {
		crq = NULL;
	}
	sbc->sbus_kdma_allocs[isp_handle_index(rq->req_handle)] = kdvma;
a404 2
		rq->req_dataseg[0].ds_count = 0;
		rq->req_dataseg[0].ds_base =  0;
d410 1
a410 1
                ISP_SBUSIFY_ISPHDR(isp, &crq->req_header)
d423 4
a426 1
isp_sbus_dmateardown(struct ispsoftc *isp, XS_T *xs, u_int16_t handle)
d434 2
a435 1
	if (sbc->sbus_kdma_allocs[isp_handle_index(handle)] == (vaddr_t) 0) {
d439 2
a440 2
	kdvma = sbc->sbus_kdma_allocs[isp_handle_index(handle)];
	sbc->sbus_kdma_allocs[isp_handle_index(handle)] = (vaddr_t) 0;
a443 17
}

static int
isp_sbus_intr(void *arg)
{
	int r;
	struct ispsoftc *isp = (struct ispsoftc *)arg;
#if	0
	struct iss_sbussoftc *s = (struct isp_sbussoftc *)isp;

	bus_dmamap_sync(p->pci_dmat, p->pci_result_dmap, BUS_DMASYNC_POSTREAD);
#endif

	isp->isp_osinfo.onintstack = 1;
	r = isp_intr(arg);
	isp->isp_osinfo.onintstack = 0;
	return (r);
@


1.10.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.10.2.2 2001/05/14 21:37:07 niklas Exp $	*/
d305 4
d312 4
@


1.10.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.10.2.3 2001/07/04 10:23:26 niklas Exp $	*/
a49 2
static int
isp_sbus_rd_isr(struct ispsoftc *, u_int16_t *, u_int16_t *, u_int16_t *);
a63 1
	isp_sbus_rd_isr,
a268 29
#define	IspVirt2Off(a, x)	\
	(((struct isp_sbussoftc *)a)->sbus_poff[((x) & _BLK_REG_MASK) >> \
	_BLK_REG_SHFT] + ((x) & 0xff))

#define	BXR2(pcs, off)		\
	(*((u_int16_t *) &sbc->sbus_reg[off]))

static int
isp_sbus_rd_isr(struct ispsoftc *isp, u_int16_t *isrp,
    u_int16_t *semap, u_int16_t *mbp)
{
	struct isp_sbussoftc *sbc = (struct isp_sbussoftc *) isp;
	u_int16_t isr, sema;

	isr = BXR2(pcs, IspVirt2Off(isp, BIU_ISR));
	sema = BXR2(pcs, IspVirt2Off(isp, BIU_SEMA));
	isp_prt(isp, ISP_LOGDEBUG3, "ISR 0x%x SEMA 0x%x", isr, sema);
	isr &= INT_PENDING_MASK(isp);
	sema &= BIU_SEMA_LOCK;
	if (isr == 0 && sema == 0) {
		return (0);
	}
	*isrp = isr;
	if ((*semap = sema) != 0) {
		*mbp = BXR2(pcs, IspVirt2Off(isp, OUTMAILBOX0));
	}
	return (1);
}

d441 1
a441 1
	u_int16_t isr, sema, mbox;
d443 2
d446 1
a446 9
	isp->isp_intcnt++;
	if (ISP_READ_ISR(isp, &isr, &sema, &mbox) == 0) {
		isp->isp_intbogus++;
		return (0);
	} else {
#if	0
		struct iss_sbussoftc *s = (struct isp_sbussoftc *)isp;
		bus_dmamap_sync(s->pci_dmat, s->pci_result_dmap,
		    BUS_DMASYNC_POSTREAD);
d448 5
a452 5
		isp->isp_osinfo.onintstack = 1;
		isp_intr(isp, isr, sema, mbox);
		isp->isp_osinfo.onintstack = 0;
		return (1);
	}
@


1.10.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a49 9
#define ISP_SBUSIFY_ISPHDR(isp, hdrp)					\
	ISP_SWAP8((hdrp)->rqs_entry_count, (hdrp)->rqs_entry_type);	\
	ISP_SWAP8((hdrp)->rqs_flags, (hdrp)->rqs_seqno);

#define	ISP_SWIZZLE_REQUEST(a, b)				\
	ISP_SBUSIFY_ISPHDR(a, &(b)->req_header);		\
        ISP_SWAP8((b)->req_target, (b)->req_lun_trn)


d83 1
a83 1
	volatile u_int16_t *sbus_reg;
d151 1
a151 1
		sbc->sbus_reg = (volatile u_int16_t *) ca->ca_ra.ra_vaddr;
d153 1
a153 1
		sbc->sbus_reg = (volatile u_int16_t *)
d276 2
a277 1
#define	BXR2(pcs, off)		(sbc->sbus_reg[off >> 1])
d284 1
a284 1
	volatile u_int16_t isr, sema;
d307 1
a307 1
	return ((u_int16_t) sbc->sbus_reg[offset >> 1]);
d316 1
a316 1
	sbc->sbus_reg[offset >> 1] = val;
a384 1
	ispreq_t *qe;
a388 1
	qe = (ispreq_t *) ISP_QUEUE_ENTRY(isp->isp_rquest, isp->isp_reqidx);
a446 1
	bcopy(rq, qe, sizeof (ispreq_t));
d481 5
@


1.10.2.6
log
@Merge in -current from about a week ago
@
text
@d101 2
a102 2
static int isp_match(struct device *, void *, void *);
static void isp_sbus_attach(struct device *, struct device *, void *);
@


1.10.2.7
log
@Sync the SMP branch with 3.3
@
text
@d84 1
a84 1
	(u_int16_t *) ISP_1000_RISC_CODE,
d221 1
a221 1
	intr_establish(sbc->sbus_pri, &sbc->sbus_ih, IPL_BIO);
d415 1
a415 1
		panic("%s: kdma handle already allocated", isp->isp_name);
d471 1
a471 1
		panic("%s: kdma handle not already allocated", isp->isp_name);
@


1.9
log
@Far too many things to note- a complete new revision coming in.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.8 1999/07/09 21:34:45 art Exp $	*/
d140 1
a140 1
	int freq;
d142 1
d177 12
d201 1
a201 1
		sbc->sbus_mdvec.dv_fwlen = 0;
d236 13
d252 3
@


1.8
log
@vm_offset_t -> {v,p}addr_t and vm_size_t -> {v,p}size_t
remove "register" keywords
Various cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.7 1999/03/25 22:58:37 mjacob Exp $	*/
d56 1
a56 1
	ispreq_t *, u_int8_t *, u_int8_t));
d60 7
d76 2
a77 6
	ISP_RISC_CODE,
	ISP_CODE_LENGTH,
	ISP_CODE_ORG,
	ISP_CODE_VERSION,
	BIU_BURST_ENABLE,
	0
a87 1
	vaddr_t		sbus_kdma_allocs[MAXISPREQUEST];
d89 1
d258 1
d261 3
d270 15
d290 2
a291 1
	if (isp->isp_rquest == 0)
d293 5
a297 3
	isp->isp_rquest_dma = (u_int32_t)kdvma_mapin((caddr_t)isp->isp_rquest,
	    len, 0);
	if (isp->isp_rquest_dma == 0)
d299 1
d306 2
a307 1
	if (isp->isp_result == 0)
d309 5
a313 3
	isp->isp_result_dma = (u_int32_t)kdvma_mapin((caddr_t)isp->isp_result,
	    len, 0);
	if (isp->isp_result_dma == 0)
d315 1
a315 1

d328 2
a329 2
	u_int8_t *iptrp;
	u_int8_t optr;
d337 1
a337 1
		return (CMD_QUEUED);
d339 1
a340 6
	if (rq->req_handle > RQUEST_QUEUE_LEN ||
	    rq->req_handle < 1) {
		panic("%s: bad handle (%d) in isp_sbus_dmasetup\n",
			isp->isp_name, rq->req_handle);
		/* NOTREACHED */
	}
d365 3
d383 2
a384 6
	if (handle >= RQUEST_QUEUE_LEN) {
		panic("%s: bad handle (%d) in isp_sbus_dmateardown\n",
			isp->isp_name, handle);
		/* NOTREACHED */
	}
	if (sbc->sbus_kdma_allocs[handle] == (vaddr_t) 0) {
d388 2
a389 2
	kdvma = sbc->sbus_kdma_allocs[handle];
	sbc->sbus_kdma_allocs[handle] = (vaddr_t) 0;
@


1.7
log
@roll internal revision levels and enable 1080 support
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.6 1999/03/17 21:50:12 deraadt Exp $	*/
d85 1
a85 1
	vm_offset_t	sbus_kdma_allocs[MAXISPREQUEST];
d108 1
a108 1
	register struct romaux *ra = &ca->ca_ra;
d303 1
a303 1
	vm_offset_t kdvma;
d318 1
a318 1
		kdvma = (vm_offset_t)
d320 1
a320 1
		if (kdvma == (vm_offset_t) 0) {
d325 1
a325 1
		kdvma = (vm_offset_t) xs->data;
d328 1
a328 1
	if (sbc->sbus_kdma_allocs[rq->req_handle - 1] != (vm_offset_t) 0) {
d351 1
a351 1
	vm_offset_t kdvma;
d361 1
a361 1
	if (sbc->sbus_kdma_allocs[handle] == (vm_offset_t) 0) {
d366 1
a366 1
	sbc->sbus_kdma_allocs[handle] = (vm_offset_t) 0;
d368 1
a368 1
		dvma_mapout(kdvma, (vm_offset_t) xs->data, xs->datalen);
@


1.6
log
@proper formatting for dmesg
@
text
@d1 2
a2 2
/*	$OpenBSD: isp_sbus.c,v 1.5 1999/03/17 05:20:24 mjacob Exp $	*/
/* release_03_16_99A */
@


1.5
log
@Add in a real working isp_sbus.c
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.4 1999/01/11 05:11:56 millert Exp $	*/
d147 2
@


1.4
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 2
a2 3
/*	$OpenBSD: isp_sbus.c,v 1.3 1998/11/11 00:50:31 jason Exp $	*/
/*	$NetBSD: isp_sbus.c,v 1.8 1997/08/27 11:24:19 bouyer Exp $	*/

d6 1
a6 1
 * Copyright (c) 1997 by Matthew Jacob 
d33 1
d38 2
a40 1
#include <sys/kernel.h>
a41 3
#include <sys/device.h>
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
d44 3
a46 1
#include <sparc/cpu.h>
a47 1
#include <sparc/dev/sbusvar.h>
d49 1
a49 2
#include <dev/ic/ispreg.h>
#include <dev/ic/ispvar.h>
a50 3
#include <machine/param.h>
#include <machine/vmparam.h>

d55 1
a55 1
static int isp_sbus_dmasetup __P((struct ispsoftc *, struct scsipi_xfer *,
d57 1
a57 1
static void isp_sbus_dmateardown __P((struct ispsoftc *, struct scsipi_xfer *,
d73 1
a73 1
	0,
d78 2
a79 2
	struct ispsoftc sbus_isp;
	sdparam sbus_dev;
d82 5
a86 3
	int sbus_node;
	int sbus_pri;
	vm_offset_t sbus_kdma_allocs[MAXISPREQUEST];
d93 1
a93 1
        sizeof (struct isp_sbussoftc), isp_match, isp_sbus_attach
d97 1
a97 1
isp_match(parent, vcf, aux)
d99 2
a100 1
        void *vcf, *aux;
d102 25
a126 12
        struct cfdata *cf = vcf;
        struct confargs *ca = aux;
        register struct romaux *ra = &ca->ca_ra;

	if (strcmp(cf->cf_driver->cd_name, ra->ra_name) &&
	    strcmp("SUNW,isp", ra->ra_name) &&
	    strcmp("QLGC,isp", ra->ra_name)) {
		return (0);
	}
	if (ca->ca_bustype == BUS_SBUS) {
		if (!sbus_testdma((struct sbus_softc *)parent, ca))
			return (0);
a127 1
	}
d132 1
a132 1
static void    
d137 1
d140 2
d149 1
a149 1
	printf(" pri %d\n", sbc->sbus_pri);
d155 1
a155 1
		    mapiodev(ca->ca_ra.ra_reg, 0, ca->ca_ra.ra_len);
d159 9
a167 12
	sbc->sbus_isp.isp_mdvec = &mdvec;
	sbc->sbus_isp.isp_type = ISP_HA_SCSI_UNKNOWN;
	sbc->sbus_isp.isp_param = &sbc->sbus_dev;
	bzero(sbc->sbus_isp.isp_param, sizeof (sdparam));
	isp_reset(&sbc->sbus_isp);
	if (sbc->sbus_isp.isp_state != ISP_RESETSTATE) {
		return;
	}
	isp_init(&sbc->sbus_isp);
	if (sbc->sbus_isp.isp_state != ISP_INITSTATE) {
		isp_uninit(&sbc->sbus_isp);
		return;
d169 30
d203 12
d216 1
a216 1
	 * Do Generic attach now.
d218 3
a220 3
	isp_attach(&sbc->sbus_isp);
	if (sbc->sbus_isp.isp_state != ISP_RUNSTATE) {
		isp_uninit(&sbc->sbus_isp);
d222 1
a224 5
#define  SBUS_BIU_REGS_OFF		0x00
#define	 SBUS_MBOX_REGS_OFF		0x80
#define	 SBUS_SXP_REGS_OFF		0x200
#define	 SBUS_RISC_REGS_OFF		0x400

d231 2
a232 13

	int offset;
	if ((regoff & BIU_BLOCK) != 0) {
		offset = SBUS_BIU_REGS_OFF;
	} else if ((regoff & MBOX_BLOCK) != 0) {
		offset = SBUS_MBOX_REGS_OFF;
	} else if ((regoff & SXP_BLOCK) != 0) {
		offset = SBUS_SXP_REGS_OFF;
	} else {
		offset = SBUS_RISC_REGS_OFF;
	}
	regoff &= 0xff;
	offset += regoff;
d243 2
a244 13
	int offset;

	if ((regoff & BIU_BLOCK) != 0) {
		offset = SBUS_BIU_REGS_OFF;
	} else if ((regoff & MBOX_BLOCK) != 0) {
		offset = SBUS_MBOX_REGS_OFF;
	} else if ((regoff & SXP_BLOCK) != 0) {
		offset = SBUS_SXP_REGS_OFF;
	} else {
		offset = SBUS_RISC_REGS_OFF;
	}
	regoff &= 0xff;
	offset += regoff;
d248 1
d264 1
a264 1
	len = ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN(isp));
d276 1
a276 1
	len = ISP_QUEUE_SIZE(RESULT_QUEUE_LEN(isp));
d298 1
a298 1
	u_int8_t optr; 
d306 1
a306 1
		return (0);
d309 1
a309 1
	if (rq->req_handle > RQUEST_QUEUE_LEN(isp) ||
d311 1
a311 1
		panic("%s: bad handle (%d) in isp_sbus_dmasetup",
d319 2
a320 1
			return (1);
d327 1
a327 1
		panic("%s: kdma handle already allocated", isp->isp_name);
d339 1
a339 1
	return (0);
d354 2
a355 3

	if (handle >= RQUEST_QUEUE_LEN(isp)) {
		panic("%s: bad handle (%d) in isp_sbus_dmateardown",
d360 1
a360 1
		panic("%s: kdma handle not already allocated", isp->isp_name);
@


1.3
log
@A few more dma in non-dma slot checks
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.2 1997/09/17 06:47:10 downsj Exp $	*/
d284 1
a284 1
		panic("%s: bad handle (%d) in isp_sbus_dmasetup\n",
d299 1
a299 1
		panic("%s: kdma handle already allocated\n", isp->isp_name);
d328 1
a328 1
		panic("%s: bad handle (%d) in isp_sbus_dmateardown\n",
d333 1
a333 1
		panic("%s: kdma handle not already allocated\n", isp->isp_name);
@


1.2
log
@NETBSD_CURRENT_970916.  Lot's just ID changes, since changes don't apply to
us.  Includes some pmap changes, for which I don't have the original commit
message(s) handy.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.1 1997/08/08 08:25:15 downsj Exp $	*/
d108 1
a108 1
        if (strcmp(cf->cf_driver->cd_name, ra->ra_name) &&
d111 1
a111 1
                return (0);
d113 7
a119 4
        if (ca->ca_bustype == BUS_SBUS)
                return (1);
        ra->ra_len = NBPG;
        return (probeget(ra->ra_vaddr, 1) != -1);
@


1.1
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: isp_sbus.c,v 1.6 1997/06/08 06:35:45 thorpej Exp $	*/
d60 1
a60 1
static int isp_sbus_dmasetup __P((struct ispsoftc *, struct scsi_xfer *,
d62 1
a62 1
static void isp_sbus_dmateardown __P((struct ispsoftc *, struct scsi_xfer *,
d73 1
d77 2
d84 1
d89 1
a89 1
	vm_offset_t sbus_kdma_allocs[RQUEST_QUEUE_LEN];
d144 3
d234 1
a234 1
	len = ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN);
d246 1
a246 1
	len = ISP_QUEUE_SIZE(RESULT_QUEUE_LEN);
a275 1
		rq->req_flags |= REQFLAG_DATA_IN;
d279 2
a280 1
	if (rq->req_handle >= RQUEST_QUEUE_LEN) {
d295 1
a295 1
	if (sbc->sbus_kdma_allocs[rq->req_handle] != (vm_offset_t) 0) {
d299 1
a299 1
	sbc->sbus_kdma_allocs[rq->req_handle] = kdvma;
d324 1
a324 1
	if (handle >= RQUEST_QUEUE_LEN) {
@
