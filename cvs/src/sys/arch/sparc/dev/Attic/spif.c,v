head	1.29;
access;
symbols
	OPENBSD_6_0:1.28.0.6
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.4
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.27.0.16
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.27.0.20
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.27.0.18
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.14
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.12
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.10
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.8
	OPENBSD_5_0:1.27.0.6
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.4
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.21.0.4
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.20.0.12
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.10
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.8
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.6
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.4
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.19.0.6
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.4
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.2
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.18.0.4
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.12
	UBC:1.8.0.4
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.6
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.4
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4;
locks; strict;
comment	@ * @;


1.29
date	2016.09.01.09.23.42;	author tedu;	state dead;
branches;
next	1.28;
commitid	Q2PxaFNhqAe0Wmla;

1.28
date	2015.03.28.19.07.07;	author miod;	state Exp;
branches;
next	1.27;
commitid	nwbHy4sQv9NnJnmZ;

1.27
date	2010.07.02.17.27.01;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2010.06.28.14.13.30;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.31.12.00.07;	author fgsch;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.31.06.40.16;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2009.04.10.20.53.51;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.02.20.00.54;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.09.29.07.35.11;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.03.16.44.50;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2003.09.23.16.51.11;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.15.20.32.14;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.18.40.59;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.14.22.04.23;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.11.19.20.26;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2002.04.30.01.12.29;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.28.03.51.19;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.43;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.30.20.45.34;	author nordin;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.05.15.50.30;	author jason;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2000.06.02.15.53.22;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	99.04.22.12.33.18;	author jason;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	99.04.18.03.04.24;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	99.02.23.23.47.46;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	99.02.04.15.43.21;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	99.02.01.13.45.22;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	99.02.01.00.30.42;	author jason;	state Exp;
branches;
next	;

1.6.4.1
date	2001.05.14.21.37.10;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2001.10.31.03.07.56;	author nate;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2002.03.06.02.04.46;	author niklas;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.6.4.6;

1.6.4.6
date	2003.06.07.11.14.43;	author ho;	state Exp;
branches;
next	1.6.4.7;

1.6.4.7
date	2004.02.19.10.49.58;	author niklas;	state Exp;
branches;
next	;

1.8.4.1
date	2002.01.31.22.55.22;	author niklas;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	1.8.4.3;

1.8.4.3
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: spif.c,v 1.28 2015/03/28 19:07:07 miod Exp $	*/

/*
 * Copyright (c) 1999 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Driver for the SUNW,spif: 8 serial, 1 parallel sbus board
 * based heavily on Iain Hibbert's driver for the MAGMA cards
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/file.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/syslog.h>
#include <sys/malloc.h>
#include <sys/tty.h>
#include <sys/conf.h>

#include <machine/autoconf.h>
#include <sparc/cpu.h>
#include <sparc/sparc/cpuvar.h>
#include <sparc/dev/spifreg.h>
#include <sparc/dev/spifvar.h>

int	spifmatch(struct device *, void *, void *);
void	spifattach(struct device *, struct device *, void *);

int	sttymatch(struct device *, void *, void *);
void	sttyattach(struct device *, struct device *, void *);
int	sttyopen(dev_t, int, int, struct proc *);
int	sttyclose(dev_t, int, int, struct proc *);
int	sttyread(dev_t, struct uio *, int);
int	sttywrite(dev_t, struct uio *, int);
int	sttyioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	sttystop(struct tty *, int);

int	spifstcintr(void *);
int	spifstcintr_mx(struct spif_softc *, int *);
int	spifstcintr_tx(struct spif_softc *, int *);
int	spifstcintr_rx(struct spif_softc *, int *);
int	spifstcintr_rxexception(struct spif_softc *, int *);
void	spifsoftintr(void *);

int	stty_param(struct tty *, struct termios *);
struct tty *sttytty(dev_t);
int	stty_modem_control(struct stty_port *, int, int);
static __inline	void	stty_write_ccr(struct stcregs *, u_int8_t);
int	stty_compute_baud(speed_t, int, u_int8_t *, u_int8_t *);
void	stty_start(struct tty *);

int	sbppmatch(struct device *, void *, void *);
void	sbppattach(struct device *, struct device *, void *);
int	sbppopen(dev_t, int, int, struct proc *);
int	sbppclose(dev_t, int, int, struct proc *);
int	sbppread(dev_t, struct uio *, int);
int	sbppwrite(dev_t, struct uio *, int);
int	sbpp_rw(dev_t, struct uio *);
int	spifppcintr(void *);
int	sbpppoll(dev_t, int, struct proc *);
int	sbppioctl(dev_t, u_long, caddr_t, int, struct proc *);

struct cfattach spif_ca = {
	sizeof (struct spif_softc), spifmatch, spifattach
};

struct cfdriver spif_cd = {
	NULL, "spif", DV_DULL
};

struct cfattach stty_ca = {
	sizeof(struct stty_softc), sttymatch, sttyattach
};

struct cfdriver stty_cd = {
	NULL, "stty", DV_TTY
};

struct cfattach sbpp_ca = {
	sizeof(struct sbpp_softc), sbppmatch, sbppattach
};

struct cfdriver sbpp_cd = {
	NULL, "sbpp", DV_DULL
};

int
spifmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
	register struct romaux *ra = &ca->ca_ra;

	if (strcmp(cf->cf_driver->cd_name, ra->ra_name) &&
	    strcmp("SUNW,spif", ra->ra_name))
		return (0);
	return (1);
}

void    
spifattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct spif_softc *sc = (struct spif_softc *)self;
	struct confargs *ca = aux;
	int stcpri, ppcpri;

	if (ca->ca_ra.ra_nintr != 2) {
		printf(": expected 2 interrupts, got %d\n",
		    ca->ca_ra.ra_nintr);
		return;
	}
	stcpri = ca->ca_ra.ra_intr[SERIAL_INTR].int_pri;
	ppcpri = ca->ca_ra.ra_intr[PARALLEL_INTR].int_pri;

	if (ca->ca_ra.ra_nreg != 1) {
		printf(": expected %d registers, got %d\n",
		    1, ca->ca_ra.ra_nreg);
		return;
	}
	sc->sc_regs = mapiodev(ca->ca_ra.ra_reg, 0, ca->ca_ra.ra_len);

	sc->sc_node = ca->ca_ra.ra_node;

	sc->sc_rev = getpropint(sc->sc_node, "revlev", 0);

	sc->sc_osc = getpropint(sc->sc_node, "verosc", 0);
	switch (sc->sc_osc) {
	case SPIF_OSC10:
		sc->sc_osc = 10000000;
		break;
	case SPIF_OSC9:
	default:
		sc->sc_osc = 9830400;
		break;
	}

	sc->sc_nser = 8;
	sc->sc_npar = 1;

	sc->sc_rev2 = sc->sc_regs->stc.gfrcr;
	sc->sc_regs->stc.gsvr = 0;

	stty_write_ccr(&sc->sc_regs->stc,
	    CD180_CCR_CMD_RESET | CD180_CCR_RESETALL);
	while (sc->sc_regs->stc.gsvr != 0xff);
	while (sc->sc_regs->stc.gfrcr != sc->sc_rev2);

	sc->sc_regs->stc.pprh = CD180_PPRH;
	sc->sc_regs->stc.pprl = CD180_PPRL;
	sc->sc_regs->stc.msmr = SPIF_MSMR;
	sc->sc_regs->stc.tsmr = SPIF_TSMR;
	sc->sc_regs->stc.rsmr = SPIF_RSMR;
	sc->sc_regs->stc.gsvr = 0;
	sc->sc_regs->stc.gscr1 = 0;
	sc->sc_regs->stc.gscr2 = 0;
	sc->sc_regs->stc.gscr3 = 0;
	printf(": rev %x chiprev %x osc %sMHz stcpri %d ppcpri %d softpri %d\n",
	    sc->sc_rev, sc->sc_rev2, clockfreq(sc->sc_osc),
	    stcpri, ppcpri, IPL_TTY);

	(void)config_found(self, sttymatch, NULL);
	(void)config_found(self, sbppmatch, NULL);

	sc->sc_ppcih.ih_fun = spifppcintr;
	sc->sc_ppcih.ih_arg = sc;
	intr_establish(ppcpri, &sc->sc_ppcih, -1, self->dv_xname);

	sc->sc_stcih.ih_fun = spifstcintr;
	sc->sc_stcih.ih_arg = sc;
	intr_establish(stcpri, &sc->sc_stcih, -1, self->dv_xname);

	sc->sc_softih = softintr_establish(IPL_SOFTTTY, spifsoftintr, sc);
}

int
sttymatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct spif_softc *sc = (struct spif_softc *)parent;

	return (aux == sttymatch && sc->sc_ttys == NULL);
}

void
sttyattach(parent, dev, aux)
	struct device *parent, *dev;
	void *aux;
{
	struct spif_softc *sc = (struct spif_softc *)parent;
	struct stty_softc *ssc = (struct stty_softc *)dev;
	int port;

	sc->sc_ttys = ssc;

	for (port = 0; port < sc->sc_nser; port++) {
		struct stty_port *sp = &ssc->sc_port[port];
		struct tty *tp;

		sp->sp_dtr = 0;
		sc->sc_regs->dtrlatch[port] = 1;

		tp = ttymalloc(0);

		tp->t_oproc = stty_start;
		tp->t_param = stty_param;

		sp->sp_tty = tp;
		sp->sp_sc = sc;
		sp->sp_channel = port;

		sp->sp_rbuf = malloc(STTY_RBUF_SIZE, M_DEVBUF, M_NOWAIT);
		if(sp->sp_rbuf == NULL)
			break;

		sp->sp_rend = sp->sp_rbuf + STTY_RBUF_SIZE;
	}

	ssc->sc_nports = port;

	printf(": %d tty%s\n", port, port == 1 ? "" : "s");
}

int
sttyopen(dev, flags, mode, p)
	dev_t dev;
	int flags;
	int mode;
	struct proc *p;
{
	struct spif_softc *csc;
	struct stty_softc *sc;
	struct stty_port *sp;
	struct tty *tp;
	int card = SPIF_CARD(dev);
	int port = SPIF_PORT(dev);
	int s;

	if (card >= stty_cd.cd_ndevs || card >= spif_cd.cd_ndevs)
		return (ENXIO);

	sc = stty_cd.cd_devs[card];
	csc = spif_cd.cd_devs[card];
	if (sc == NULL)
		return (ENXIO);

	if (port >= sc->sc_nports)
		return (ENXIO);

	sp = &sc->sc_port[port];
	tp = sp->sp_tty;
	tp->t_dev = dev;

	if (!ISSET(tp->t_state, TS_ISOPEN)) {
		SET(tp->t_state, TS_WOPEN);

		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_cflag = TTYDEF_CFLAG;
		if (ISSET(sp->sp_openflags, TIOCFLAG_CLOCAL))
			SET(tp->t_cflag, CLOCAL);
		if (ISSET(sp->sp_openflags, TIOCFLAG_CRTSCTS))
			SET(tp->t_cflag, CRTSCTS);
		if (ISSET(sp->sp_openflags, TIOCFLAG_MDMBUF))
			SET(tp->t_cflag, MDMBUF);
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;

		sp->sp_rput = sp->sp_rget = sp->sp_rbuf;

		s = spltty();

		csc->sc_regs->stc.car = sp->sp_channel;
		stty_write_ccr(&csc->sc_regs->stc,
		    CD180_CCR_CMD_RESET | CD180_CCR_RESETCHAN);
		csc->sc_regs->stc.car = sp->sp_channel;

		stty_param(tp, &tp->t_termios);

		ttsetwater(tp);

		csc->sc_regs->stc.srer = CD180_SRER_CD | CD180_SRER_RXD;

		if (ISSET(sp->sp_openflags, TIOCFLAG_SOFTCAR) || sp->sp_carrier)
			SET(tp->t_state, TS_CARR_ON);
		else
			CLR(tp->t_state, TS_CARR_ON);
	}
	else if (ISSET(tp->t_state, TS_XCLUDE) && suser(p, 0) != 0) {
		return (EBUSY);
	} else {
		s = spltty();
	}

	if (!ISSET(flags, O_NONBLOCK)) {
		while (!ISSET(tp->t_cflag, CLOCAL) &&
		    !ISSET(tp->t_state, TS_CARR_ON)) {
			int error;

			SET(tp->t_state, TS_WOPEN);
			error = ttysleep(tp, &tp->t_rawq, TTIPRI | PCATCH,
			    "sttycd", 0);
			if (error != 0) {
				splx(s);
				CLR(tp->t_state, TS_WOPEN);
				return (error);
			}
		}
	}

	splx(s);

	return ((*linesw[tp->t_line].l_open)(dev, tp, p));
}

int
sttyclose(dev, flags, mode, p)
	dev_t dev;
	int flags;
	int mode;
	struct proc *p;
{
	struct stty_softc *sc = stty_cd.cd_devs[SPIF_CARD(dev)];
	struct stty_port *sp = &sc->sc_port[SPIF_PORT(dev)];
	struct spif_softc *csc = sp->sp_sc;
	struct tty *tp = sp->sp_tty;
	int port = SPIF_PORT(dev);
	int s;

	(*linesw[tp->t_line].l_close)(tp, flags, p);
	s = spltty();

	if (ISSET(tp->t_cflag, HUPCL) || !ISSET(tp->t_state, TS_ISOPEN)) {
		stty_modem_control(sp, 0, DMSET);
		csc->sc_regs->stc.car = port;
		csc->sc_regs->stc.ccr =
		    CD180_CCR_CMD_RESET | CD180_CCR_RESETCHAN;
	}

	splx(s);
	ttyclose(tp);
	return (0);
}

int
sttyioctl(dev, cmd, data, flags, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
{
	struct stty_softc *stc = stty_cd.cd_devs[SPIF_CARD(dev)];
	struct stty_port *sp = &stc->sc_port[SPIF_PORT(dev)];
	struct spif_softc *sc = sp->sp_sc;
	struct tty *tp = sp->sp_tty;
	int error;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flags, p);
	if (error >= 0)
		return (error);

	error = ttioctl(tp, cmd, data, flags, p);
	if (error >= 0)
		return (error);

	error = 0;

	switch (cmd) {
	case TIOCSBRK:
		SET(sp->sp_flags, STTYF_SET_BREAK);
		sc->sc_regs->stc.car = sp->sp_channel;
		sc->sc_regs->stc.srer |= CD180_SRER_TXD;
		break;
	case TIOCCBRK:
		SET(sp->sp_flags, STTYF_CLR_BREAK);
		sc->sc_regs->stc.car = sp->sp_channel;
		sc->sc_regs->stc.srer |= CD180_SRER_TXD;
		break;
	case TIOCSDTR:
		stty_modem_control(sp, TIOCM_DTR, DMBIS);
		break;
	case TIOCCDTR:
		stty_modem_control(sp, TIOCM_DTR, DMBIC);
		break;
	case TIOCMBIS:
		stty_modem_control(sp, *((int *)data), DMBIS);
		break;
	case TIOCMBIC:
		stty_modem_control(sp, *((int *)data), DMBIC);
		break;
	case TIOCMGET:
		*((int *)data) = stty_modem_control(sp, 0, DMGET);
		break;
	case TIOCMSET:
		stty_modem_control(sp, *((int *)data), DMSET);
		break;
	case TIOCGFLAGS:
		*((int *)data) = sp->sp_openflags;
		break;
	case TIOCSFLAGS:
		if (suser(p, 0))
			error = EPERM;
		else
			sp->sp_openflags = *((int *)data) &
			    (TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL |
			     TIOCFLAG_CRTSCTS | TIOCFLAG_MDMBUF);
		break;
	default:
		error = ENOTTY;
	}

	return (error);
}

int
stty_modem_control(sp, bits, how)
	struct stty_port *sp;
	int bits, how;
{
	struct spif_softc *csc = sp->sp_sc;
	struct tty *tp = sp->sp_tty;
	int s, msvr;

	s = spltty();
	csc->sc_regs->stc.car = sp->sp_channel;

	switch (how) {
	case DMGET:
		bits = TIOCM_LE;
		if (sp->sp_dtr)
			bits |= TIOCM_DTR;
		msvr = csc->sc_regs->stc.msvr;
		if (ISSET(msvr, CD180_MSVR_DSR))
			bits |= TIOCM_DSR;
		if (ISSET(msvr, CD180_MSVR_CD))
			bits |= TIOCM_CD;
		if (ISSET(msvr, CD180_MSVR_CTS))
			bits |= TIOCM_CTS;
		if (ISSET(msvr, CD180_MSVR_RTS))
			bits |= TIOCM_RTS;
		break;
	case DMSET:
		if (ISSET(bits, TIOCM_DTR)) {
			sp->sp_dtr = 1;
			csc->sc_regs->dtrlatch[sp->sp_channel] = 0;
		}
		else {
			sp->sp_dtr = 0;
			csc->sc_regs->dtrlatch[sp->sp_channel] = 1;
		}
		if (ISSET(bits, TIOCM_RTS))
			csc->sc_regs->stc.msvr &= ~CD180_MSVR_RTS;
		else
			csc->sc_regs->stc.msvr |= CD180_MSVR_RTS;
		break;
	case DMBIS:
		if (ISSET(bits, TIOCM_DTR)) {
			sp->sp_dtr = 1;
			csc->sc_regs->dtrlatch[sp->sp_channel] = 0;
		}
		if (ISSET(bits, TIOCM_RTS) && !ISSET(tp->t_cflag, CRTSCTS))
			csc->sc_regs->stc.msvr &= ~CD180_MSVR_RTS;
		break;
	case DMBIC:
		if (ISSET(bits, TIOCM_DTR)) {
			sp->sp_dtr = 0;
			csc->sc_regs->dtrlatch[sp->sp_channel] = 1;
		}
		if (ISSET(bits, TIOCM_RTS))
			csc->sc_regs->stc.msvr |= CD180_MSVR_RTS;
		break;
	}

	splx(s);
	return (bits);
}

int
stty_param(tp, t)
	struct tty *tp;
	struct termios *t;
{
	struct stty_softc *st = stty_cd.cd_devs[SPIF_CARD(tp->t_dev)];
	struct stty_port *sp = &st->sc_port[SPIF_PORT(tp->t_dev)];
	struct spif_softc *sc = sp->sp_sc;
	u_int8_t rbprl, rbprh, tbprl, tbprh;
	int s, opt;

	if (t->c_ospeed &&
	    stty_compute_baud(t->c_ospeed, sc->sc_osc, &tbprl, &tbprh))
		return (EINVAL);

	if (t->c_ispeed &&
	    stty_compute_baud(t->c_ispeed, sc->sc_osc, &rbprl, &rbprh))
		return (EINVAL);

	s = spltty();

	/* hang up line if ospeed is zero, otherwise raise DTR */
	stty_modem_control(sp, TIOCM_DTR,
	    (t->c_ospeed == 0 ? DMBIC : DMBIS));

	sc->sc_regs->stc.car = sp->sp_channel;

	opt = 0;
	if (ISSET(t->c_cflag, PARENB)) {
		opt |= CD180_COR1_PARMODE_NORMAL;
		opt |= (ISSET(t->c_cflag, PARODD) ?
				CD180_COR1_ODDPAR :
				CD180_COR1_EVENPAR);
	}
	else
		opt |= CD180_COR1_PARMODE_NO;

	if (!ISSET(t->c_iflag, INPCK))
		opt |= CD180_COR1_IGNPAR;

	if (ISSET(t->c_cflag, CSTOPB))
		opt |= CD180_COR1_STOP2;

	switch (t->c_cflag & CSIZE) {
	case CS5:
		opt |= CD180_COR1_CS5;
		break;
	case CS6:
		opt |= CD180_COR1_CS6;
		break;
	case CS7:
		opt |= CD180_COR1_CS7;
		break;
	default:
		opt |= CD180_COR1_CS8;
		break;
	}
	sc->sc_regs->stc.cor1 = opt;
	stty_write_ccr(&sc->sc_regs->stc, CD180_CCR_CMD_COR|CD180_CCR_CORCHG1);

	opt = CD180_COR2_ETC;
	if (ISSET(t->c_cflag, CRTSCTS))
		opt |= CD180_COR2_CTSAE;
	sc->sc_regs->stc.cor2 = opt;
	stty_write_ccr(&sc->sc_regs->stc, CD180_CCR_CMD_COR|CD180_CCR_CORCHG2);

	sc->sc_regs->stc.cor3 = STTY_RX_FIFO_THRESHOLD;
	stty_write_ccr(&sc->sc_regs->stc, CD180_CCR_CMD_COR|CD180_CCR_CORCHG3);

	sc->sc_regs->stc.schr1 = 0x11;
	sc->sc_regs->stc.schr2 = 0x13;
	sc->sc_regs->stc.schr3 = 0x11;
	sc->sc_regs->stc.schr4 = 0x13;
	sc->sc_regs->stc.rtpr = 0x12;

	sc->sc_regs->stc.mcor1 = CD180_MCOR1_CDZD | STTY_RX_DTR_THRESHOLD;
	sc->sc_regs->stc.mcor2 = CD180_MCOR2_CDOD;
	sc->sc_regs->stc.mcr = 0;

	if (t->c_ospeed) {
		sc->sc_regs->stc.tbprh = tbprh;
		sc->sc_regs->stc.tbprl = tbprl;
	}

	if (t->c_ispeed) {
		sc->sc_regs->stc.rbprh = rbprh;
		sc->sc_regs->stc.rbprl = rbprl;
	}

	stty_write_ccr(&sc->sc_regs->stc, CD180_CCR_CMD_CHAN |
	    CD180_CCR_CHAN_TXEN | CD180_CCR_CHAN_RXEN);

	sp->sp_carrier = sc->sc_regs->stc.msvr & CD180_MSVR_CD;

	splx(s);
	return (0);
}

int
sttyread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	struct stty_softc *sc = stty_cd.cd_devs[SPIF_CARD(dev)];
	struct stty_port *sp = &sc->sc_port[SPIF_PORT(dev)];
	struct tty *tp = sp->sp_tty;

	return ((*linesw[tp->t_line].l_read)(tp, uio, flags));
}

int
sttywrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	struct stty_softc *sc = stty_cd.cd_devs[SPIF_CARD(dev)];
	struct stty_port *sp = &sc->sc_port[SPIF_PORT(dev)];
	struct tty *tp = sp->sp_tty;

	return ((*linesw[tp->t_line].l_write)(tp, uio, flags));
}

struct tty *
sttytty(dev)
	dev_t dev;
{
	struct stty_softc *sc = stty_cd.cd_devs[SPIF_CARD(dev)];
	struct stty_port *sp = &sc->sc_port[SPIF_PORT(dev)];

	return (sp->sp_tty);
}

int
sttystop(tp, flags)
	struct tty *tp;
	int flags;
{
	struct stty_softc *sc = stty_cd.cd_devs[SPIF_CARD(tp->t_dev)];
	struct stty_port *sp = &sc->sc_port[SPIF_PORT(tp->t_dev)];
	int s;

	s = spltty();
	if (ISSET(tp->t_state, TS_BUSY)) {
		if (!ISSET(tp->t_state, TS_TTSTOP))
			SET(tp->t_state, TS_FLUSH);
		SET(sp->sp_flags, STTYF_STOP);
	}
	splx(s);
	return (0);
}

void
stty_start(tp)
	struct tty *tp;
{
	struct stty_softc *stc = stty_cd.cd_devs[SPIF_CARD(tp->t_dev)];
	struct stty_port *sp = &stc->sc_port[SPIF_PORT(tp->t_dev)];
	struct spif_softc *sc = sp->sp_sc;
	int s;

	s = spltty();

	if (!ISSET(tp->t_state, TS_TTSTOP | TS_TIMEOUT | TS_BUSY)) {
		ttwakeupwr(tp);
		if (tp->t_outq.c_cc) {
			sp->sp_txc = ndqb(&tp->t_outq, 0);
			sp->sp_txp = tp->t_outq.c_cf;
			SET(tp->t_state, TS_BUSY);
			sc->sc_regs->stc.car = sp->sp_channel;
			sc->sc_regs->stc.srer |= CD180_SRER_TXD;
		}
	}

	splx(s);
}

int
spifstcintr_rxexception(sc, needsoftp)
	struct spif_softc *sc;
	int *needsoftp;
{
	struct stty_port *sp;
	u_int8_t channel, *ptr;

	channel = CD180_GSCR_CHANNEL(sc->sc_regs->stc.gscr1);
	sp = &sc->sc_ttys->sc_port[channel];
	ptr = sp->sp_rput;
	*ptr++ = sc->sc_regs->stc.rcsr;
	*ptr++ = sc->sc_regs->stc.rdr;
	if (ptr == sp->sp_rend)
		ptr = sp->sp_rbuf;
	if (ptr == sp->sp_rget) {
		if (ptr == sp->sp_rbuf)
			ptr = sp->sp_rend;
		ptr -= 2;
		SET(sp->sp_flags, STTYF_RING_OVERFLOW);
	}
	sc->sc_regs->stc.eosrr = 0;
	*needsoftp = 1;
	sp->sp_rput = ptr;
	return (1);
}

int
spifstcintr_rx(sc, needsoftp)
	struct spif_softc *sc;
	int *needsoftp;
{
	struct stty_port *sp;
	u_int8_t channel, *ptr, cnt, rcsr;
	int i;

	channel = CD180_GSCR_CHANNEL(sc->sc_regs->stc.gscr1);
	sp = &sc->sc_ttys->sc_port[channel];
	ptr = sp->sp_rput;
	cnt = sc->sc_regs->stc.rdcr;
	for (i = 0; i < cnt; i++) {
		*ptr++ = 0;
		rcsr = sc->sc_regs->stc.rcsr;
		*ptr++ = sc->sc_regs->stc.rdr;
		if (ptr == sp->sp_rend)
			ptr = sp->sp_rbuf;
		if (ptr == sp->sp_rget) {
			if (ptr == sp->sp_rbuf)
				ptr = sp->sp_rend;
			ptr -= 2;
			SET(sp->sp_flags, STTYF_RING_OVERFLOW);
			break;
		}
	}
	sc->sc_regs->stc.eosrr = 0;
	if (cnt) {
		*needsoftp = 1;
		sp->sp_rput = ptr;
	}
	return (1);
}

int
spifstcintr_tx(sc, needsoftp)
	struct spif_softc *sc;
	int *needsoftp;
{
	struct stty_port *sp;
	u_int8_t channel, ch;
	int cnt = 0;

	channel = CD180_GSCR_CHANNEL(sc->sc_regs->stc.gscr1);
	sp = &sc->sc_ttys->sc_port[channel];
	if (!ISSET(sp->sp_flags, STTYF_STOP)) {
		if (ISSET(sp->sp_flags, STTYF_SET_BREAK)) {
			sc->sc_regs->stc.tdr = 0;
			sc->sc_regs->stc.tdr = 0x81;
			CLR(sp->sp_flags, STTYF_SET_BREAK);
			cnt += 2;
		}
		if (ISSET(sp->sp_flags, STTYF_CLR_BREAK)) {
			sc->sc_regs->stc.tdr = 0;
			sc->sc_regs->stc.tdr = 0x83;
			CLR(sp->sp_flags, STTYF_CLR_BREAK);
			cnt += 2;
		}

		while (sp->sp_txc > 0 && cnt < (CD180_TX_FIFO_SIZE-1)) {
			ch = *sp->sp_txp;
			sp->sp_txc--;
			sp->sp_txp++;

			if (ch == 0) {
				sc->sc_regs->stc.tdr = ch;
				cnt++;
			}
			sc->sc_regs->stc.tdr = ch;
			cnt++;
		}
	}

	if (sp->sp_txc == 0 ||
	    ISSET(sp->sp_flags, STTYF_STOP)) {
		sc->sc_regs->stc.srer &= ~CD180_SRER_TXD;
		CLR(sp->sp_flags, STTYF_STOP);
		SET(sp->sp_flags, STTYF_DONE);
		*needsoftp = 1;
	}

	sc->sc_regs->stc.eosrr = 0;

	return (1);
}

int
spifstcintr_mx(sc, needsoftp)
	struct spif_softc *sc;
	int *needsoftp;
{
	struct stty_port *sp;
	u_int8_t channel, mcr;

	channel = CD180_GSCR_CHANNEL(sc->sc_regs->stc.gscr1);
	sp = &sc->sc_ttys->sc_port[channel];
	mcr = sc->sc_regs->stc.mcr;
	if (mcr & CD180_MCR_CD) {
		SET(sp->sp_flags, STTYF_CDCHG);
		*needsoftp = 1;
	}
	sc->sc_regs->stc.mcr = 0;
	sc->sc_regs->stc.eosrr = 0;
	return (1);
}

int
spifstcintr(vsc)
	void *vsc;
{
	struct spif_softc *sc = (struct spif_softc *)vsc;
	int needsoft = 0, r = 0, i;
	u_int8_t ar;

	for (i = 0; i < 8; i++) {
		ar = sc->sc_regs->istc.rrar & CD180_GSVR_IMASK;
		if (ar == CD180_GSVR_RXGOOD)
			r |= spifstcintr_rx(sc, &needsoft);
		else if (ar == CD180_GSVR_RXEXCEPTION)
			r |= spifstcintr_rxexception(sc, &needsoft);
	}

	for (i = 0; i < 8; i++) {
		ar = sc->sc_regs->istc.trar & CD180_GSVR_IMASK;
		if (ar == CD180_GSVR_TXDATA)
			r |= spifstcintr_tx(sc, &needsoft);
	}

	for (i = 0; i < 8; i++) {
		ar = sc->sc_regs->istc.mrar & CD180_GSVR_IMASK;
		if (ar == CD180_GSVR_STATCHG)
			r |= spifstcintr_mx(sc, &needsoft);
	}

	if (needsoft)
		softintr_schedule(sc->sc_softih);
	return (r);
}

void
spifsoftintr(vsc)
	void *vsc;
{
	struct spif_softc *sc = (struct spif_softc *)vsc;
	struct stty_softc *stc = sc->sc_ttys;
	int i, data, s, flags;
	u_int8_t stat, msvr;
	struct stty_port *sp;
	struct tty *tp;

	if (stc != NULL) {
		for (i = 0; i < stc->sc_nports; i++) {
			sp = &stc->sc_port[i];
			tp = sp->sp_tty;

			if (!ISSET(tp->t_state, TS_ISOPEN))
				continue;

			while (sp->sp_rget != sp->sp_rput) {
				stat = sp->sp_rget[0];
				data = sp->sp_rget[1];
				sp->sp_rget += 2;
				if (sp->sp_rget == sp->sp_rend)
					sp->sp_rget = sp->sp_rbuf;

				if (stat & (CD180_RCSR_BE | CD180_RCSR_FE))
					data |= TTY_FE;

				if (stat & CD180_RCSR_PE)
					data |= TTY_PE;

				(*linesw[tp->t_line].l_rint)(data, tp);
			}

			s = splhigh();
			flags = sp->sp_flags;
			CLR(sp->sp_flags, STTYF_DONE | STTYF_CDCHG |
			    STTYF_RING_OVERFLOW);
			splx(s);

			if (ISSET(flags, STTYF_CDCHG)) {
				s = spltty();
				sc->sc_regs->stc.car = i;
				msvr = sc->sc_regs->stc.msvr;
				splx(s);

				sp->sp_carrier = msvr & CD180_MSVR_CD;
				(*linesw[tp->t_line].l_modem)(tp,
				    sp->sp_carrier);
			}

			if (ISSET(flags, STTYF_RING_OVERFLOW)) {
				log(LOG_WARNING, "%s-%x: ring overflow\n",
					stc->sc_dev.dv_xname, i);
			}

			if (ISSET(flags, STTYF_DONE)) {
				ndflush(&tp->t_outq,
				    sp->sp_txp - tp->t_outq.c_cf);
				CLR(tp->t_state, TS_BUSY);
				(*linesw[tp->t_line].l_start)(tp);
			}
		}
	}
}

static __inline	void
stty_write_ccr(stc, val)
	struct stcregs *stc;
	u_int8_t val;
{
	int tries = 100000;

	while (stc->ccr && tries--);
	if (tries == 0)
		printf("CCR: timeout\n");
	stc->ccr = val;
}

int
stty_compute_baud(speed, clock, bprlp, bprhp)
	speed_t speed;
	int clock;
	u_int8_t *bprlp, *bprhp;
{
	u_int32_t rate;

	rate = (2 * clock) / (16 * speed);
	if (rate & 1)
		rate = (rate >> 1) + 1;
	else
		rate = rate >> 1;

	if (rate > 0xffff || rate == 0)
		return (1);

	*bprlp = rate & 0xff;
	*bprhp = (rate >> 8) & 0xff;
	return (0);
}

int
sbppmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct spif_softc *sc = (struct spif_softc *)parent;

	return (aux == sbppmatch && sc->sc_bpps == NULL);
}

void
sbppattach(parent, dev, aux)
	struct device *parent, *dev;
	void *aux;
{
	struct spif_softc *sc = (struct spif_softc *)parent;
	struct sbpp_softc *psc = (struct sbpp_softc *)dev;
	int port;

	sc->sc_bpps = psc;

	for (port = 0; port < sc->sc_npar; port++) {
	}

	psc->sc_nports = port;
	printf(": %d port%s\n", port, port == 1 ? "" : "s");
}

int
sbppopen(dev, flags, mode, p)
	dev_t dev;
	int flags;
	int mode;
	struct proc *p;
{
	return (ENXIO);
}

int
sbppclose(dev, flags, mode, p)
	dev_t dev;
	int flags;
	int mode;
	struct proc *p;
{
	return (ENXIO);
}

int
spifppcintr(v)
	void *v;
{
	return (0);
}

int
sbppread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	return (sbpp_rw(dev, uio));
}

int
sbppwrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	return (sbpp_rw(dev, uio));
}

int
sbpp_rw(dev, uio)
	dev_t dev;
	struct uio *uio;
{
	return (ENXIO);
}

int
sbpppoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
{
	return (seltrue(dev, events, p));
}

int
sbppioctl(dev, cmd, data, flags, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
{
	int error;

	error = ENOTTY;

	return (error);
}
@


1.28
log
@Don't include sbusvar.h if you need neither sbus_translate() nor sbus_testdma().
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.27 2010/07/02 17:27:01 nicm Exp $	*/
@


1.27
log
@Move common code for waking up writers on a tty into a function.

ok deraadt matthew millert
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.26 2010/06/28 14:13:30 deraadt Exp $	*/
a51 1
#include <sparc/dev/sbusvar.h>
@


1.26
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.25 2010/04/12 12:57:52 tedu Exp $	*/
d679 1
a679 7
		if (tp->t_outq.c_cc <= tp->t_lowat) {
			if (ISSET(tp->t_state, TS_ASLEEP)) {
				CLR(tp->t_state, TS_ASLEEP);
				wakeup(&tp->t_outq);
			}
			selwakeup(&tp->t_wsel);
		}
@


1.25
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.24 2009/11/09 17:53:39 nicm Exp $	*/
d237 1
a237 1
		tp = ttymalloc();
@


1.24
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.23 2009/10/31 12:00:07 fgsch Exp $	*/
d348 1
a348 1
	return ((*linesw[tp->t_line].l_open)(dev, tp));
d365 1
a365 1
	(*linesw[tp->t_line].l_close)(tp, flags);
@


1.23
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.22 2009/10/31 06:40:16 deraadt Exp $	*/
a684 1
			KNOTE(&tp->t_wsel.si_note, 0);
@


1.22
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.21 2009/04/10 20:53:51 miod Exp $	*/
d324 1
a324 1
	else if (ISSET(tp->t_state, TS_XCLUDE) && p->p_ucred->cr_uid != 0) {
@


1.21
log
@generic soft interrupts support for sparc. Soft interrupt handlers are now
kept in a separate intrhand array, with their own enable bits so that
soft interrupts sharing the same level only get invoked if really triggered.
Inspired by NetBSD with significant changes.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.20 2006/06/02 20:00:54 miod Exp $	*/
d685 1
@


1.20
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.19 2004/09/29 07:35:11 miod Exp $	*/
a55 10
#if IPL_TTY == 1
# define IE_MSOFT IE_L1
#elif IPL_TTY == 4
# define IE_MSOFT IE_L4
#elif IPL_TTY == 6
# define IE_MSOFT IE_L6
#else
# error "no suitable software interrupt bit"
#endif

d73 1
a73 1
int	spifsoftintr(void *);
d206 1
a206 3
	sc->sc_softih.ih_fun = spifsoftintr;
	sc->sc_softih.ih_arg = sc;
	intr_establish(IPL_TTY, &sc->sc_softih, IPL_TTY, self->dv_xname);
d860 2
a861 8
	if (needsoft) {
#if defined(SUN4M)
		if (CPU_ISSUN4M)
			raise(0, IPL_TTY);
		else
#endif
			ienab_bis(IE_MSOFT);
	}
d865 1
a865 1
int
d871 1
a871 1
	int r = 0, i, data, s, flags;
a897 1
				r = 1;
a914 1
				r = 1;
a919 1
				r = 1;
a926 1
				r = 1;
a929 2

	return (r);
@


1.19
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.18 2003/10/03 16:44:50 miod Exp $	*/
a218 2

	sbus_establish(&sc->sc_sd, &sc->sc_dev);
@


1.18
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.17 2003/09/23 16:51:11 millert Exp $	*/
d210 1
a210 1
	intr_establish(ppcpri, &sc->sc_ppcih, -1);
d214 1
a214 1
	intr_establish(stcpri, &sc->sc_stcih, -1);
d218 1
a218 1
	intr_establish(IPL_TTY, &sc->sc_softih, IPL_TTY);
@


1.17
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.16 2003/08/15 20:32:14 tedu Exp $	*/
a251 3
		if (tp == NULL)
			break;
		tty_attach(tp);
@


1.16
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.15 2003/06/02 18:40:59 jason Exp $	*/
d100 1
a100 1
int	sbppselect(dev_t, int, struct proc *);
d1078 1
a1078 1
sbppselect(dev, rw, p)
d1080 1
a1080 1
	int rw;
d1083 1
a1083 1
	return (ENODEV);
@


1.15
log
@nuke my clause 3 & 4 (and a couple jointly (c) with Theo).
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.14 2003/02/14 22:04:23 jason Exp $	*/
d454 1
a454 1
		if (suser(p->p_ucred, &p->p_acflag))
@


1.14
log
@always need softintr after rxexception (avoids uninitialized variable); pointed out by henric
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.13 2003/02/11 19:20:26 mickey Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.13
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.12 2002/04/30 01:12:29 art Exp $	*/
a726 1
	int cnt;
d742 2
a743 4
	if (cnt) {
		*needsoftp = 1;
		sp->sp_rput = ptr;
	}
@


1.12
log
@Fix an ancient problem in how sparc interrupts are handled.

There are many interrupt handlers that assume that they don't need to do
any spl protection in their code because the interrupt of some level can't
be interrupted by an interrupt of the same level. The problem is that some
interrupt handlers have hardware levels that are lower then their "software"
levels.

Fix this by adding an additional field to struct intrhand that specifies which
"software" level an interrupt handler has and blocks that level while handling
the interrupt. This new field is initialized in intr_establish which gets
an additional argument (which can be -1 meaning that the interrupt handler
doesn't need to block any additional level).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.11 2002/04/28 03:51:19 art Exp $	*/
d206 1
a206 1
	printf(": rev %x chiprev %x osc %sMhz stcpri %d ppcpri %d softpri %d\n",
@


1.11
log
@Rename all PIL_* constants to IPL_* to match other archs and make them
usable in MD code in the future.
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.10 2002/03/14 01:26:43 millert Exp $	*/
d215 1
a215 1
	intr_establish(ppcpri, &sc->sc_ppcih);
d219 1
a219 1
	intr_establish(stcpri, &sc->sc_stcih);
d223 1
a223 1
	intr_establish(IPL_TTY, &sc->sc_softih);
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.9 2002/01/30 20:45:34 nordin Exp $	*/
d61 1
a61 1
#if PIL_TTY == 1
d63 1
a63 1
#elif PIL_TTY == 4
d65 1
a65 1
#elif PIL_TTY == 6
d208 1
a208 1
	    stcpri, ppcpri, PIL_TTY);
d223 1
a223 1
	intr_establish(PIL_TTY, &sc->sc_softih);
d888 1
a888 1
			raise(0, PIL_TTY);
@


1.9
log
@Move SET/CLR/ISSET macros to param.h. fgsch@@ and millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.8 2001/10/05 15:50:30 jason Exp $	*/
d71 2
a72 2
int	spifmatch	__P((struct device *, void *, void *));
void	spifattach	__P((struct device *, struct device *, void *));
d74 33
a106 33
int	sttymatch	__P((struct device *, void *, void *));
void	sttyattach	__P((struct device *, struct device *, void *));
int	sttyopen	__P((dev_t, int, int, struct proc *));
int	sttyclose	__P((dev_t, int, int, struct proc *));
int	sttyread	__P((dev_t, struct uio *, int));
int	sttywrite	__P((dev_t, struct uio *, int));
int	sttyioctl	__P((dev_t, u_long, caddr_t, int, struct proc *));
int	sttystop	__P((struct tty *, int));

int	spifstcintr		__P((void *));
int	spifstcintr_mx		__P((struct spif_softc *, int *));
int	spifstcintr_tx		__P((struct spif_softc *, int *));
int	spifstcintr_rx		__P((struct spif_softc *, int *));
int	spifstcintr_rxexception	__P((struct spif_softc *, int *));
int	spifsoftintr		__P((void *));

int	stty_param	__P((struct tty *, struct termios *));
struct tty *sttytty	__P((dev_t));
int	stty_modem_control __P((struct stty_port *, int, int));
static __inline	void	stty_write_ccr __P((struct stcregs *, u_int8_t));
int	stty_compute_baud __P((speed_t, int, u_int8_t *, u_int8_t *));
void	stty_start	__P((struct tty *));

int	sbppmatch	__P((struct device *, void *, void *));
void	sbppattach	__P((struct device *, struct device *, void *));
int	sbppopen	__P((dev_t, int, int, struct proc *));
int	sbppclose	__P((dev_t, int, int, struct proc *));
int	sbppread	__P((dev_t, struct uio *, int));
int	sbppwrite	__P((dev_t, struct uio *, int));
int	sbpp_rw	__P((dev_t, struct uio *));
int	spifppcintr	__P((void *));
int	sbppselect	__P((dev_t, int, struct proc *));
int	sbppioctl	__P((dev_t, u_long, caddr_t, int, struct proc *));
@


1.8
log
@oops, forgot to implement TIOCMSET
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.7 2000/06/02 15:53:22 jason Exp $	*/
a69 7

/*
 * useful macros
 */
#define	SET(t, f)	((t) |= (f))
#define	CLR(t, f)	((t) &= ~(f))
#define	ISSET(t, f)	((t) & (f))
@


1.8.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.9 2002/01/30 20:45:34 nordin Exp $	*/
d70 7
@


1.8.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.8.4.1 2002/01/31 22:55:22 niklas Exp $	*/
d61 1
a61 1
#if IPL_TTY == 1
d63 1
a63 1
#elif IPL_TTY == 4
d65 1
a65 1
#elif IPL_TTY == 6
d71 2
a72 2
int	spifmatch(struct device *, void *, void *);
void	spifattach(struct device *, struct device *, void *);
d74 33
a106 33
int	sttymatch(struct device *, void *, void *);
void	sttyattach(struct device *, struct device *, void *);
int	sttyopen(dev_t, int, int, struct proc *);
int	sttyclose(dev_t, int, int, struct proc *);
int	sttyread(dev_t, struct uio *, int);
int	sttywrite(dev_t, struct uio *, int);
int	sttyioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	sttystop(struct tty *, int);

int	spifstcintr(void *);
int	spifstcintr_mx(struct spif_softc *, int *);
int	spifstcintr_tx(struct spif_softc *, int *);
int	spifstcintr_rx(struct spif_softc *, int *);
int	spifstcintr_rxexception(struct spif_softc *, int *);
int	spifsoftintr(void *);

int	stty_param(struct tty *, struct termios *);
struct tty *sttytty(dev_t);
int	stty_modem_control(struct stty_port *, int, int);
static __inline	void	stty_write_ccr(struct stcregs *, u_int8_t);
int	stty_compute_baud(speed_t, int, u_int8_t *, u_int8_t *);
void	stty_start(struct tty *);

int	sbppmatch(struct device *, void *, void *);
void	sbppattach(struct device *, struct device *, void *);
int	sbppopen(dev_t, int, int, struct proc *);
int	sbppclose(dev_t, int, int, struct proc *);
int	sbppread(dev_t, struct uio *, int);
int	sbppwrite(dev_t, struct uio *, int);
int	sbpp_rw(dev_t, struct uio *);
int	spifppcintr(void *);
int	sbppselect(dev_t, int, struct proc *);
int	sbppioctl(dev_t, u_long, caddr_t, int, struct proc *);
d208 1
a208 1
	    stcpri, ppcpri, IPL_TTY);
d215 1
a215 1
	intr_establish(ppcpri, &sc->sc_ppcih, -1);
d219 1
a219 1
	intr_establish(stcpri, &sc->sc_stcih, -1);
d223 1
a223 1
	intr_establish(IPL_TTY, &sc->sc_softih, IPL_TTY);
d888 1
a888 1
			raise(0, IPL_TTY);
@


1.8.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d206 1
a206 1
	printf(": rev %x chiprev %x osc %sMHz stcpri %d ppcpri %d softpri %d\n",
d727 1
d743 4
a746 2
	*needsoftp = 1;
	sp->sp_rput = ptr;
@


1.7
log
@rework interrupt handling completely, and be more careful with the CD180
during channel configuration changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.6 1999/04/22 12:33:18 jason Exp $	*/
d458 3
@


1.6
log
@fix device selector, spif isn't an DV_NET, missing sbus_establish
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.5 1999/04/18 03:04:24 jason Exp $	*/
d89 8
a96 2
int	spifstcintr	__P((void *));
int	spifsoftintr	__P((void *));
d204 2
a205 1
	sc->sc_regs->stc.gsvr = 0;
d209 4
a212 3
	sc->sc_regs->stc.pprh = CD180_PPRH;
	sc->sc_regs->stc.pprl = CD180_PPRL;

d340 1
d598 1
d604 1
d607 1
a607 3

	stty_write_ccr(&sc->sc_regs->stc, CD180_CCR_CMD_COR |
	    CD180_CCR_CORCHG1 | CD180_CCR_CORCHG2 | CD180_CCR_CORCHG3);
d613 1
a613 1
	sc->sc_regs->stc.rtpr = 0x28;
d617 1
d725 3
a727 2
spifstcintr(vsc)
	void *vsc;
a728 1
	struct spif_softc *sc = (struct spif_softc *)vsc;
d730 2
a731 2
	u_int8_t channel, ar, *ptr;
	int needsoft = 0, r = 0, i;
d733 16
a748 25
	/*
	 * Receive data service request
	 * (also Receive error service request)
	 */
	ar = sc->sc_regs->istc.rrar & CD180_GSVR_IMASK;

	switch (ar) {
	case CD180_GSVR_RXGOOD:
		r = 1;
		channel = CD180_GSCR_CHANNEL(sc->sc_regs->stc.gscr1);
		sp = &sc->sc_ttys->sc_port[channel];
		ptr = sp->sp_rput;
		for (i = sc->sc_regs->stc.rdcr; i > 0; i--) {
			*ptr++ = 0;
			*ptr++ = sc->sc_regs->stc.rdr;
			if (ptr == sp->sp_rend)
				ptr = sp->sp_rbuf;
			if (ptr == sp->sp_rget) {
				if (ptr == sp->sp_rbuf)
					ptr = sp->sp_rend;
				ptr -= 2;
				SET(sp->sp_flags, STTYF_RING_OVERFLOW);
				break;
			}
		}
d750 20
a769 8
		needsoft = 1;
		break;
	case CD180_GSVR_RXEXCEPTION:
		r = 1;
		channel = CD180_GSCR_CHANNEL(sc->sc_regs->stc.gscr1);
		sp = &sc->sc_ttys->sc_port[channel];
		ptr = sp->sp_rput;
		*ptr++ = sc->sc_regs->stc.rcsr;
d780 4
a784 2
		needsoft = 1;
		break;
d786 2
a787 1
	sc->sc_regs->stc.eosrr = 0;
d789 8
a796 24
	/*
	 * Transmit service request
	 */
	ar = sc->sc_regs->istc.trar & CD180_GSVR_IMASK;
	if (ar == CD180_GSVR_TXDATA) {
		int cnt = 0;

		r = 1;
		channel = CD180_GSCR_CHANNEL(sc->sc_regs->stc.gscr1);
		sp = &sc->sc_ttys->sc_port[channel];

		if (!ISSET(sp->sp_flags, STTYF_STOP)) {
			if (ISSET(sp->sp_flags, STTYF_SET_BREAK)) {
				sc->sc_regs->stc.tdr = 0;
				sc->sc_regs->stc.tdr = 0x81;
				CLR(sp->sp_flags, STTYF_SET_BREAK);
				cnt += 2;
			}
			if (ISSET(sp->sp_flags, STTYF_CLR_BREAK)) {
				sc->sc_regs->stc.tdr = 0;
				sc->sc_regs->stc.tdr = 0x83;
				CLR(sp->sp_flags, STTYF_CLR_BREAK);
				cnt += 2;
			}
d798 20
a817 2
			while (sp->sp_txc > 0 && cnt < (CD180_TX_FIFO_SIZE-1)) {
				u_int8_t ch;
d819 1
a819 8
				ch = *sp->sp_txp;
				sp->sp_txc--;
				sp->sp_txp++;

				if (ch == 0) {
					sc->sc_regs->stc.tdr = ch;
					cnt++;
				}
d823 4
d828 6
a833 8
			if (sp->sp_txc == 0 ||
			    ISSET(sp->sp_flags, STTYF_STOP)) {
				sc->sc_regs->stc.srer &= ~CD180_SRER_TXD;
				CLR(sp->sp_flags, STTYF_STOP);
				SET(sp->sp_flags, STTYF_DONE);
				needsoft = 1;
			}
		}
d835 1
d838 10
a847 13
	/*
	 * Modem signal service request
	 */
	ar = sc->sc_regs->istc.mrar & CD180_GSVR_IMASK;
	if (ar == CD180_GSVR_STATCHG) {
		r = 1;
		channel = CD180_GSCR_CHANNEL(sc->sc_regs->stc.gscr1);
		sp = &sc->sc_ttys->sc_port[channel];
		ar = sc->sc_regs->stc.mcr;
		if (ar & CD180_MCR_CD) {
			SET(sp->sp_flags, STTYF_CDCHG);
			needsoft = 1;
		}
d849 6
a854 1
		sc->sc_regs->stc.mcr = 0;
d856 1
d858 30
d922 2
a923 1
				if ((sp->sp_rget + 2) == sp->sp_rend)
a924 2
				else
					sp->sp_rget = sp->sp_rget + 2;
a931 4
				if (stat & CD180_RCSR_OE)
					log(LOG_WARNING,
					    "%s-%x: fifo overflow\n",
					    stc->sc_dev.dv_xname, i);
@


1.6.4.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.7 2000/06/02 15:53:22 jason Exp $	*/
d89 2
a90 8

int	spifstcintr		__P((void *));
int	spifstcintr_mx		__P((struct spif_softc *, int *));
int	spifstcintr_tx		__P((struct spif_softc *, int *));
int	spifstcintr_rx		__P((struct spif_softc *, int *));
int	spifstcintr_rxexception	__P((struct spif_softc *, int *));
int	spifsoftintr		__P((void *));

d198 1
a198 2
	sc->sc_regs->stc.pprh = CD180_PPRH;
	sc->sc_regs->stc.pprl = CD180_PPRL;
d202 3
a204 4
	sc->sc_regs->stc.gsvr = 0;
	sc->sc_regs->stc.gscr1 = 0;
	sc->sc_regs->stc.gscr2 = 0;
	sc->sc_regs->stc.gscr3 = 0;
a331 1
		csc->sc_regs->stc.car = sp->sp_channel;
a588 1
	stty_write_ccr(&sc->sc_regs->stc, CD180_CCR_CMD_COR|CD180_CCR_CORCHG1);
a593 1
	stty_write_ccr(&sc->sc_regs->stc, CD180_CCR_CMD_COR|CD180_CCR_CORCHG2);
d596 3
a598 1
	stty_write_ccr(&sc->sc_regs->stc, CD180_CCR_CMD_COR|CD180_CCR_CORCHG3);
d604 1
a604 1
	sc->sc_regs->stc.rtpr = 0x12;
a607 1
	sc->sc_regs->stc.mcr = 0;
d715 2
a716 3
spifstcintr_rxexception(sc, needsoftp)
	struct spif_softc *sc;
	int *needsoftp;
d718 1
d720 2
a721 2
	u_int8_t channel, *ptr;
	int cnt;
d723 25
a747 16
	channel = CD180_GSCR_CHANNEL(sc->sc_regs->stc.gscr1);
	sp = &sc->sc_ttys->sc_port[channel];
	ptr = sp->sp_rput;
	*ptr++ = sc->sc_regs->stc.rcsr;
	*ptr++ = sc->sc_regs->stc.rdr;
	if (ptr == sp->sp_rend)
		ptr = sp->sp_rbuf;
	if (ptr == sp->sp_rget) {
		if (ptr == sp->sp_rbuf)
			ptr = sp->sp_rend;
		ptr -= 2;
		SET(sp->sp_flags, STTYF_RING_OVERFLOW);
	}
	sc->sc_regs->stc.eosrr = 0;
	if (cnt) {
		*needsoftp = 1;
d749 8
a756 20
	}
	return (1);
}

int
spifstcintr_rx(sc, needsoftp)
	struct spif_softc *sc;
	int *needsoftp;
{
	struct stty_port *sp;
	u_int8_t channel, *ptr, cnt, rcsr;
	int i;

	channel = CD180_GSCR_CHANNEL(sc->sc_regs->stc.gscr1);
	sp = &sc->sc_ttys->sc_port[channel];
	ptr = sp->sp_rput;
	cnt = sc->sc_regs->stc.rdcr;
	for (i = 0; i < cnt; i++) {
		*ptr++ = 0;
		rcsr = sc->sc_regs->stc.rcsr;
d767 3
a771 6
	if (cnt) {
		*needsoftp = 1;
		sp->sp_rput = ptr;
	}
	return (1);
}
d773 24
a796 8
int
spifstcintr_tx(sc, needsoftp)
	struct spif_softc *sc;
	int *needsoftp;
{
	struct stty_port *sp;
	u_int8_t channel, ch;
	int cnt = 0;
d798 2
a799 20
	channel = CD180_GSCR_CHANNEL(sc->sc_regs->stc.gscr1);
	sp = &sc->sc_ttys->sc_port[channel];
	if (!ISSET(sp->sp_flags, STTYF_STOP)) {
		if (ISSET(sp->sp_flags, STTYF_SET_BREAK)) {
			sc->sc_regs->stc.tdr = 0;
			sc->sc_regs->stc.tdr = 0x81;
			CLR(sp->sp_flags, STTYF_SET_BREAK);
			cnt += 2;
		}
		if (ISSET(sp->sp_flags, STTYF_CLR_BREAK)) {
			sc->sc_regs->stc.tdr = 0;
			sc->sc_regs->stc.tdr = 0x83;
			CLR(sp->sp_flags, STTYF_CLR_BREAK);
			cnt += 2;
		}

		while (sp->sp_txc > 0 && cnt < (CD180_TX_FIFO_SIZE-1)) {
			ch = *sp->sp_txp;
			sp->sp_txc--;
			sp->sp_txp++;
d801 8
a808 1
			if (ch == 0) {
d812 8
a819 2
			sc->sc_regs->stc.tdr = ch;
			cnt++;
a821 9

	if (sp->sp_txc == 0 ||
	    ISSET(sp->sp_flags, STTYF_STOP)) {
		sc->sc_regs->stc.srer &= ~CD180_SRER_TXD;
		CLR(sp->sp_flags, STTYF_STOP);
		SET(sp->sp_flags, STTYF_DONE);
		*needsoftp = 1;
	}

d824 13
a836 2
	return (1);
}
d838 1
a838 14
int
spifstcintr_mx(sc, needsoftp)
	struct spif_softc *sc;
	int *needsoftp;
{
	struct stty_port *sp;
	u_int8_t channel, mcr;

	channel = CD180_GSCR_CHANNEL(sc->sc_regs->stc.gscr1);
	sp = &sc->sc_ttys->sc_port[channel];
	mcr = sc->sc_regs->stc.mcr;
	if (mcr & CD180_MCR_CD) {
		SET(sp->sp_flags, STTYF_CDCHG);
		*needsoftp = 1;
a839 1
	sc->sc_regs->stc.mcr = 0;
a840 30
	return (1);
}

int
spifstcintr(vsc)
	void *vsc;
{
	struct spif_softc *sc = (struct spif_softc *)vsc;
	int needsoft = 0, r = 0, i;
	u_int8_t ar;

	for (i = 0; i < 8; i++) {
		ar = sc->sc_regs->istc.rrar & CD180_GSVR_IMASK;
		if (ar == CD180_GSVR_RXGOOD)
			r |= spifstcintr_rx(sc, &needsoft);
		else if (ar == CD180_GSVR_RXEXCEPTION)
			r |= spifstcintr_rxexception(sc, &needsoft);
	}

	for (i = 0; i < 8; i++) {
		ar = sc->sc_regs->istc.trar & CD180_GSVR_IMASK;
		if (ar == CD180_GSVR_TXDATA)
			r |= spifstcintr_tx(sc, &needsoft);
	}

	for (i = 0; i < 8; i++) {
		ar = sc->sc_regs->istc.mrar & CD180_GSVR_IMASK;
		if (ar == CD180_GSVR_STATCHG)
			r |= spifstcintr_mx(sc, &needsoft);
	}
d875 1
a875 2
				sp->sp_rget += 2;
				if (sp->sp_rget == sp->sp_rend)
d877 2
d886 4
@


1.6.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.6.4.1 2001/05/14 21:37:10 niklas Exp $	*/
a457 3
		break;
	case TIOCMSET:
		stty_modem_control(sp, *((int *)data), DMSET);
@


1.6.4.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d70 7
@


1.6.4.4
log
@Merge in -current from about a week ago
@
text
@d71 2
a72 2
int	spifmatch(struct device *, void *, void *);
void	spifattach(struct device *, struct device *, void *);
d74 8
a81 8
int	sttymatch(struct device *, void *, void *);
void	sttyattach(struct device *, struct device *, void *);
int	sttyopen(dev_t, int, int, struct proc *);
int	sttyclose(dev_t, int, int, struct proc *);
int	sttyread(dev_t, struct uio *, int);
int	sttywrite(dev_t, struct uio *, int);
int	sttyioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	sttystop(struct tty *, int);
d83 6
a88 6
int	spifstcintr(void *);
int	spifstcintr_mx(struct spif_softc *, int *);
int	spifstcintr_tx(struct spif_softc *, int *);
int	spifstcintr_rx(struct spif_softc *, int *);
int	spifstcintr_rxexception(struct spif_softc *, int *);
int	spifsoftintr(void *);
d90 6
a95 6
int	stty_param(struct tty *, struct termios *);
struct tty *sttytty(dev_t);
int	stty_modem_control(struct stty_port *, int, int);
static __inline	void	stty_write_ccr(struct stcregs *, u_int8_t);
int	stty_compute_baud(speed_t, int, u_int8_t *, u_int8_t *);
void	stty_start(struct tty *);
d97 10
a106 10
int	sbppmatch(struct device *, void *, void *);
void	sbppattach(struct device *, struct device *, void *);
int	sbppopen(dev_t, int, int, struct proc *);
int	sbppclose(dev_t, int, int, struct proc *);
int	sbppread(dev_t, struct uio *, int);
int	sbppwrite(dev_t, struct uio *, int);
int	sbpp_rw(dev_t, struct uio *);
int	spifppcintr(void *);
int	sbppselect(dev_t, int, struct proc *);
int	sbppioctl(dev_t, u_long, caddr_t, int, struct proc *);
@


1.6.4.5
log
@Sync the SMP branch with 3.3
@
text
@d61 1
a61 1
#if IPL_TTY == 1
d63 1
a63 1
#elif IPL_TTY == 4
d65 1
a65 1
#elif IPL_TTY == 6
d206 1
a206 1
	printf(": rev %x chiprev %x osc %sMHz stcpri %d ppcpri %d softpri %d\n",
d208 1
a208 1
	    stcpri, ppcpri, IPL_TTY);
d215 1
a215 1
	intr_establish(ppcpri, &sc->sc_ppcih, -1);
d219 1
a219 1
	intr_establish(stcpri, &sc->sc_stcih, -1);
d223 1
a223 1
	intr_establish(IPL_TTY, &sc->sc_softih, IPL_TTY);
d727 1
d743 4
a746 2
	*needsoftp = 1;
	sp->sp_rput = ptr;
d888 1
a888 1
			raise(0, IPL_TTY);
@


1.6.4.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.6.4.5 2003/03/27 23:49:25 niklas Exp $	*/
d15 5
@


1.6.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d100 1
a100 1
int	sbpppoll(dev_t, int, struct proc *);
d252 3
d454 1
a454 1
		if (suser(p, 0))
d1078 1
a1078 1
sbpppoll(dev, events, p)
d1080 1
a1080 1
	int events;
d1083 1
a1083 1
	return (seltrue(dev, events, p));
@


1.5
log
@simplify clock handling
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.4 1999/02/23 23:47:46 jason Exp $	*/
d114 1
a114 1
	NULL, "spif", DV_IFNET
d223 2
@


1.4
log
@Better register definitions and attach printing knit
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.3 1999/02/04 15:43:21 jason Exp $	*/
d179 1
a179 1
		sc->sc_osc = 10;
d183 1
a183 1
		sc->sc_osc = 9;
d205 3
a207 7
	printf(": rev %x chiprev %x osc %dMhz stcpri %d ppcpri %d softpri %d\n",
	    sc->sc_rev, sc->sc_rev2, sc->sc_osc, stcpri, ppcpri, PIL_TTY);

	if (sc->sc_osc == 10)
		sc->sc_osc = 10000000;
	else
		sc->sc_osc = 9830400;
@


1.3
log
@Code clean up, misc fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.2 1999/02/01 13:45:22 jason Exp $	*/
d202 2
a203 2
	sc->sc_regs->stc.pprh = SPIF_PPRH;
	sc->sc_regs->stc.pprl = SPIF_PPRL;
d205 1
a205 1
	printf(": rev %d chiprev %d osc %dMhz stcpri %d ppcpri %d softpri %d\n",
@


1.2
log
@modem signal fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.1 1999/02/01 00:30:42 jason Exp $	*/
d94 2
a95 2
static __inline	void	spif_write_ccr __P((struct stcregs *, u_int8_t));
int	spif_compute_baud __P((speed_t, int, u_int8_t *, u_int8_t *));
d193 2
a194 1
	spif_write_ccr(&sc->sc_regs->stc, CD180_CCR_RESET | CD180_CCR_RESETALL);
d254 3
d332 2
a333 2
		spif_write_ccr(&csc->sc_regs->stc,
		    CD180_CCR_RESET | CD180_CCR_RESETCHAN);
d393 2
a394 1
		csc->sc_regs->stc.ccr = CD180_CCR_RESET | CD180_CCR_RESETCHAN;
d545 1
a545 1
	    spif_compute_baud(t->c_ospeed, sc->sc_osc, &tbprl, &tbprh))
d549 1
a549 1
	    spif_compute_baud(t->c_ispeed, sc->sc_osc, &rbprl, &rbprh))
d599 1
a599 1
	spif_write_ccr(&sc->sc_regs->stc, CD180_CCR_CORCHG |
d621 1
a621 1
	spif_write_ccr(&sc->sc_regs->stc, CD180_CCR_CHANCTL |
d734 1
a734 1
		channel = (sc->sc_regs->stc.gscr1 >> 2) & CD180_GSCR_CMASK;
d755 1
a755 1
		channel = (sc->sc_regs->stc.gscr1 >> 2) & CD180_GSCR_CMASK;
d783 1
a783 1
		channel = (sc->sc_regs->stc.gscr1 >> 2) & CD180_GSCR_CMASK;
d832 1
a832 1
		channel = (sc->sc_regs->stc.gscr1 >> 2) & CD180_GSCR_CMASK;
d933 13
d947 1
a947 1
spif_compute_baud(speed, clock, bprlp, bprhp)
a1070 13
}

static __inline	void
spif_write_ccr(stc, val)
	struct stcregs *stc;
	u_int8_t val;
{
	int tries = 100000;

	while (stc->ccr && tries--);
	if (tries == 0)
		printf("CCR: timeout\n");
	stc->ccr = val;
@


1.1
log
@driver for the 8 serial 1 parallel SUNW,spif board:
o heavily based on magma driver
o no support for the parallel port yet
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 1
a36 1
 * based heavily on Iain Hibbert's driver for the MAGMA driver
d335 1
a335 1
		csc->sc_regs->stc.srer = CD180_SRER_DSR | CD180_SRER_RXD;
d387 1
d495 1
a495 1
			csc->sc_regs->dtrlatch[sp->sp_channel] = 1;
d499 1
a499 1
			csc->sc_regs->dtrlatch[sp->sp_channel] = 0;
d509 1
a509 1
			csc->sc_regs->dtrlatch[sp->sp_channel] = 1;
d517 1
a517 1
			csc->sc_regs->dtrlatch[sp->sp_channel] = 0;
d619 2
d724 1
a724 1
	ar = sc->sc_regs->istc.rrar & 7;
d729 1
a729 1
		channel = (sc->sc_regs->stc.gscr1 >> 2) & 7;
d750 1
a750 1
		channel = (sc->sc_regs->stc.gscr1 >> 2) & 7;
d773 2
a774 2
	ar = sc->sc_regs->istc.trar & 7;
	if (ar == 2) {
d778 1
a778 1
		channel = (sc->sc_regs->stc.gscr1 >> 2) & 7;
a820 1
#if 0
d824 13
a836 1
	ar = sc->sc_regs->istc.mrar & 7;
a837 1
#endif
d857 1
a857 1
	u_int8_t stat;
d885 2
a886 2
					    "%s%x: fifo overflow\n",
					    stc->sc_dev, i);
d898 6
d910 2
a911 2
				log(LOG_WARNING, "%s%x: ring overflow\n",
					stc->sc_dev, i);
@

