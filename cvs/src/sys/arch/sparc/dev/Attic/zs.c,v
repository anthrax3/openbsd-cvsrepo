head	1.59;
access;
symbols
	OPENBSD_6_0:1.58.0.4
	OPENBSD_6_0_BASE:1.58
	OPENBSD_5_9:1.58.0.2
	OPENBSD_5_9_BASE:1.58
	OPENBSD_5_8:1.57.0.4
	OPENBSD_5_8_BASE:1.57
	OPENBSD_5_7:1.56.0.2
	OPENBSD_5_7_BASE:1.56
	OPENBSD_5_6:1.54.0.6
	OPENBSD_5_6_BASE:1.54
	OPENBSD_5_5:1.54.0.4
	OPENBSD_5_5_BASE:1.54
	OPENBSD_5_4:1.51.0.2
	OPENBSD_5_4_BASE:1.51
	OPENBSD_5_3:1.49.0.4
	OPENBSD_5_3_BASE:1.49
	OPENBSD_5_2:1.49.0.2
	OPENBSD_5_2_BASE:1.49
	OPENBSD_5_1_BASE:1.48
	OPENBSD_5_1:1.48.0.8
	OPENBSD_5_0:1.48.0.6
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.48.0.4
	OPENBSD_4_9_BASE:1.48
	OPENBSD_4_8:1.48.0.2
	OPENBSD_4_8_BASE:1.48
	OPENBSD_4_7:1.47.0.2
	OPENBSD_4_7_BASE:1.47
	OPENBSD_4_6:1.47.0.4
	OPENBSD_4_6_BASE:1.47
	OPENBSD_4_5:1.46.0.4
	OPENBSD_4_5_BASE:1.46
	OPENBSD_4_4:1.46.0.2
	OPENBSD_4_4_BASE:1.46
	OPENBSD_4_3:1.45.0.2
	OPENBSD_4_3_BASE:1.45
	OPENBSD_4_2:1.43.0.8
	OPENBSD_4_2_BASE:1.43
	OPENBSD_4_1:1.43.0.6
	OPENBSD_4_1_BASE:1.43
	OPENBSD_4_0:1.43.0.4
	OPENBSD_4_0_BASE:1.43
	OPENBSD_3_9:1.43.0.2
	OPENBSD_3_9_BASE:1.43
	OPENBSD_3_8:1.42.0.2
	OPENBSD_3_8_BASE:1.42
	OPENBSD_3_7:1.40.0.2
	OPENBSD_3_7_BASE:1.40
	OPENBSD_3_6:1.39.0.8
	OPENBSD_3_6_BASE:1.39
	SMP_SYNC_A:1.39
	SMP_SYNC_B:1.39
	OPENBSD_3_5:1.39.0.6
	OPENBSD_3_5_BASE:1.39
	OPENBSD_3_4:1.39.0.4
	OPENBSD_3_4_BASE:1.39
	UBC_SYNC_A:1.39
	OPENBSD_3_3:1.39.0.2
	OPENBSD_3_3_BASE:1.39
	OPENBSD_3_2:1.37.0.2
	OPENBSD_3_2_BASE:1.37
	OPENBSD_3_1:1.33.0.2
	OPENBSD_3_1_BASE:1.33
	UBC_SYNC_B:1.37
	UBC:1.29.0.4
	UBC_BASE:1.29
	OPENBSD_3_0:1.29.0.2
	OPENBSD_3_0_BASE:1.29
	OPENBSD_2_9_BASE:1.27
	OPENBSD_2_9:1.27.0.2
	OPENBSD_2_8:1.26.0.2
	OPENBSD_2_8_BASE:1.26
	OPENBSD_2_7:1.22.0.6
	OPENBSD_2_7_BASE:1.22
	SMP:1.22.0.4
	SMP_BASE:1.22
	kame_19991208:1.22
	OPENBSD_2_6:1.22.0.2
	OPENBSD_2_6_BASE:1.22
	OPENBSD_2_5:1.21.0.4
	OPENBSD_2_5_BASE:1.21
	OPENBSD_2_4:1.21.0.2
	OPENBSD_2_4_BASE:1.21
	OPENBSD_2_3:1.20.0.2
	OPENBSD_2_3_BASE:1.20
	OPENBSD_2_2:1.17.0.2
	OPENBSD_2_2_BASE:1.17
	OPENBSD_2_1:1.13.0.4
	OPENBSD_2_1_BASE:1.13
	OPENBSD_2_0:1.13.0.2
	OPENBSD_2_0_BASE:1.13
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.59
date	2016.09.01.09.23.42;	author tedu;	state dead;
branches;
next	1.58;
commitid	Q2PxaFNhqAe0Wmla;

1.58
date	2015.12.10.19.48.04;	author mmcc;	state Exp;
branches;
next	1.57;
commitid	IegoPc6ss7aut6L1;

1.57
date	2015.03.18.19.49.14;	author miod;	state Exp;
branches;
next	1.56;
commitid	t7LuI5hiFgwd6xKc;

1.56
date	2015.02.28.17.54.54;	author miod;	state Exp;
branches;
next	1.55;
commitid	ODmF3EmhsYjCRUYN;

1.55
date	2015.02.05.12.04.58;	author miod;	state Exp;
branches;
next	1.54;
commitid	nfEz66YvzGXJsIIq;

1.54
date	2013.12.19.20.11.04;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2013.10.21.12.14.52;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2013.09.15.09.49.21;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2013.07.27.19.45.01;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2013.04.21.14.44.16;	author sebastia;	state Exp;
branches;
next	1.49;

1.49
date	2012.05.25.17.11.40;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2010.07.10.19.32.24;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2009.04.10.20.53.51;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2008.06.26.05.42.13;	author ray;	state Exp;
branches;
next	1.45;

1.45
date	2008.01.23.16.37.57;	author jsing;	state Exp;
branches;
next	1.44;

1.44
date	2007.10.22.14.46.46;	author jsing;	state Exp;
branches;
next	1.43;

1.43
date	2006.01.09.20.57.00;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2005.07.08.12.38.31;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2005.04.19.21.30.19;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2004.09.29.07.35.12;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2003.01.22.18.59.36;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2003.01.20.15.57.28;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2002.09.03.23.20.40;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2002.08.12.10.44.04;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2002.04.30.01.12.29;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2002.04.28.03.51.19;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.14.01.26.43;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.13.00.24.21;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2002.01.30.20.45.34;	author nordin;	state Exp;
branches;
next	1.30;

1.30
date	2002.01.10.00.06.17;	author nordin;	state Exp;
branches;
next	1.29;

1.29
date	2001.10.05.21.13.51;	author jason;	state Exp;
branches
	1.29.4.1;
next	1.28;

1.28
date	2001.10.05.05.03.59;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	2000.11.07.11.05.19;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2000.07.14.20.27.37;	author deraadt;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2000.07.11.15.00.12;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2000.07.07.11.51.24;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2000.06.28.20.22.14;	author mjacob;	state Exp;
branches;
next	1.22;

1.22
date	99.09.20.02.49.25;	author deraadt;	state Exp;
branches
	1.22.4.1
	1.22.6.1;
next	1.21;

1.21
date	98.07.21.22.33.42;	author marc;	state Exp;
branches;
next	1.20;

1.20
date	98.03.04.14.21.29;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	98.02.05.16.57.49;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	98.02.05.16.49.09;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.09.17.06.47.12;	author downsj;	state Exp;
branches;
next	1.16;

1.16
date	97.08.25.08.38.45;	author downsj;	state Exp;
branches;
next	1.15;

1.15
date	97.08.08.08.25.43;	author downsj;	state Exp;
branches;
next	1.14;

1.14
date	97.06.25.13.01.00;	author downsj;	state Exp;
branches;
next	1.13;

1.13
date	96.08.12.18.54.05;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.08.12.03.14.49;	author downsj;	state Exp;
branches;
next	1.11;

1.11
date	96.08.12.00.28.16;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	96.08.11.23.39.56;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	96.08.11.05.34.35;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.01.06.13.45.43;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.01.06.12.57.16;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	95.12.15.13.54.11;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	95.10.23.10.34.19;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.10.23.08.16.03;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.10.21.13.40.07;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.19.13.21.33;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.41;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.41;	author deraadt;	state Exp;
branches;
next	;

1.22.4.1
date	2001.05.14.21.37.11;	author niklas;	state Exp;
branches;
next	1.22.4.2;

1.22.4.2
date	2001.10.31.03.07.57;	author nate;	state Exp;
branches;
next	1.22.4.3;

1.22.4.3
date	2002.03.06.02.04.46;	author niklas;	state Exp;
branches;
next	1.22.4.4;

1.22.4.4
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.22.4.5;

1.22.4.5
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	;

1.22.6.1
date	2000.11.10.20.19.25;	author jason;	state Exp;
branches;
next	;

1.26.2.1
date	2000.11.10.20.18.41;	author jason;	state Exp;
branches;
next	;

1.29.4.1
date	2002.01.31.22.55.22;	author niklas;	state Exp;
branches;
next	1.29.4.2;

1.29.4.2
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	1.29.4.3;

1.29.4.3
date	2002.10.29.00.28.10;	author art;	state Exp;
branches;
next	;


desc
@@


1.59
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: zs.c,v 1.58 2015/12/10 19:48:04 mmcc Exp $	*/
/*	$NetBSD: zs.c,v 1.50 1997/10/18 00:00:40 gwr Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Gordon W. Ross.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Zilog Z8530 Dual UART driver (machine-dependent part)
 *
 * Runs two serial lines per chip using slave drivers.
 * Plain tty/async lines use the zstty slave.
 * Sun keyboard/mouse uses the zskbd/zsms slaves.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/tty.h>
#include <sys/time.h>
#include <sys/syslog.h>

#include <machine/autoconf.h>
#include <machine/bsd_openprom.h>
#include <machine/conf.h>
#include <machine/cpu.h>
#include <machine/eeprom.h>
#if defined(SUN4)
#include <machine/oldmon.h>
#endif
#include <machine/psl.h>
#include <machine/z8530var.h>

#include <dev/cons.h>
#include <dev/ic/z8530reg.h>

#include <sparc/sparc/vaddrs.h>
#include <sparc/sparc/auxioreg.h>
#include <sparc/dev/cons.h>

#include <uvm/uvm_extern.h>

#include "zskbd.h"
#include "zs.h"

/* Make life easier for the initialized arrays here. */
#if NZS < 3
#undef  NZS
#define NZS 3
#endif

/*
 * Some warts needed by z8530tty.c -
 * The default parity REALLY needs to be the same as the PROM uses,
 * or you can not see messages done with printf during boot-up...
 */
int zs_def_cflag = (CREAD | CS8 | HUPCL);
int zs_major = 12;

/*
 * The Sun provides a 4.9152 MHz clock to the ZS chips.
 */
#define PCLK	(9600 * 512)	/* PCLK pin input clock rate */

#define	ZS_DELAY()		(CPU_ISSUN4C ? (0) : delay(2))

/* The layout of this is hardware-dependent (padding, order). */
struct zschan {
	volatile u_char	zc_csr;		/* ctrl,status, and indirect access */
	u_char		zc_xxx0;
	volatile u_char	zc_data;	/* data */
	u_char		zc_xxx1;
};
struct zsdevice {
	/* Yes, they are backwards. */
	struct	zschan zs_chan_b;
	struct	zschan zs_chan_a;
};

/* Saved PROM mappings */
struct zsdevice *zsaddr[NZS];

/* Flags from cninit() */
int zs_hwflags[NZS][2];

/* Default speed for each channel */
int zs_defspeed[NZS][2] = {
	{ 9600, 	/* ttya */
	  9600 },	/* ttyb */
	{ 1200, 	/* keyboard */
	  1200 },	/* mouse */
	{ 9600, 	/* ttyc */
	  9600 },	/* ttyd */
};

u_char zs_init_reg[16] = {
	0,	/* 0: CMD (reset, etc.) */
	0,	/* 1: No interrupts yet. */
	0,	/* 2: IVECT */
	ZSWR3_RX_8 | ZSWR3_RX_ENABLE,
	ZSWR4_CLK_X16 | ZSWR4_ONESB,
	ZSWR5_TX_8 | ZSWR5_TX_ENABLE,
	0,	/* 6: TXSYNC/SYNCLO */
	0,	/* 7: RXSYNC/SYNCHI */
	0,	/* 8: alias for data port */
	ZSWR9_MASTER_IE | ZSWR9_NO_VECTOR,
	0,	/*10: Misc. TX/RX control bits */
	ZSWR11_TXCLK_BAUD | ZSWR11_RXCLK_BAUD,
	((PCLK/32)/9600)-2,	/*12: BAUDLO (default=9600) */
	0,			/*13: BAUDHI (default=9600) */
	ZSWR14_BAUD_ENA | ZSWR14_BAUD_FROM_PCLK,
	ZSWR15_BREAK_IE /* | ZSWR15_DCD_IE */,
};

struct zschan *
zs_get_chan_addr(zs_unit, channel)
	int zs_unit, channel;
{
	struct zsdevice *addr;
	struct zschan *zc;

	if (zs_unit >= NZS)
		return NULL;
	addr = zsaddr[zs_unit];
	if (addr == NULL)
		addr = zsaddr[zs_unit] = findzs(zs_unit);
	if (addr == NULL)
		return NULL;
	if (channel == 0) {
		zc = &addr->zs_chan_a;
	} else {
		zc = &addr->zs_chan_b;
	}
	return (zc);
}


/****************************************************************
 * Autoconfig
 ****************************************************************/

/* Definition of the driver for autoconfig. */
int	zs_match(struct device *, void *, void *);
void	zs_attach(struct device *, struct device *, void *);
int	zs_print(void *, const char *nam);

/* Power management hooks (for Tadpole SPARCbooks) */
void	zs_disable(struct zs_chanstate *);
int	zs_enable(struct zs_chanstate *);

struct cfattach zs_ca = {
	sizeof(struct zsc_softc), zs_match, zs_attach
};

struct cfdriver zs_cd = {
	NULL, "zs", DV_DULL
};

/* Interrupt handlers. */
int zshard(void *);
void zssoft(void *);
struct intrhand levelhard = { zshard };

int zs_get_speed(struct zs_chanstate *);


/*
 * Is the zs chip present?
 */
int
zs_match(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct cfdata *cf = (struct cfdata *)vcf;
	struct confargs *ca = (struct confargs *)aux;
	struct romaux *ra = &ca->ca_ra;

	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
		return (0);

	if ((ca->ca_bustype == BUS_MAIN && (CPU_ISSUN4C || CPU_ISSUN4E)) ||
	    (ca->ca_bustype == BUS_OBIO && CPU_ISSUN4M))
		return (getpropint(ra->ra_node, "slave", -2) == cf->cf_unit);
	ra->ra_len = NBPG;
	return (probeget(ra->ra_vaddr, 1) != -1);
}

/*
 * Attach a found zs.
 *
 * USE ROM PROPERTY keyboard FOR KEYBOARD/MOUSE?
 */
void
zs_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct zsc_softc *zsc = (void *) self;
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;
	struct zsc_attach_args zsc_args;
	volatile struct zschan *zc;
	struct zs_chanstate *cs;
	int pri, s, zs_unit, channel;
	static int didintr, prevpri;

	zs_unit = zsc->zsc_dev.dv_unit;

	/* Use the mapping setup by the Sun PROM. */
	if (zsaddr[zs_unit] == NULL)
		zsaddr[zs_unit] = findzs(zs_unit);

	if (ca->ca_bustype==BUS_MAIN)
		if ((void*)zsaddr[zs_unit] != ra->ra_vaddr)
			panic("zsattach");
	if (ra->ra_nintr != 1) {
		printf(": expected 1 interrupt, got %d\n", ra->ra_nintr);
		return;
	}
	pri = ra->ra_intr[0].int_pri;
	printf(" pri %d, softpri %d\n", pri, IPL_TTY);

	/*
	 * Initialize software state for each channel.
	 */
	for (channel = 0; channel < 2; channel++) {
		zsc_args.type = "serial";
		/* XXX hardcoded */
		if (zs_unit == 1) {
			if (channel == 0)
				zsc_args.type = "keyboard";
			if (channel == 1)
				zsc_args.type = "mouse";
		}

		zsc_args.channel = channel;
		zsc_args.hwflags = zs_hwflags[zs_unit][channel];

		if ((ca->ca_bustype == BUS_MAIN &&
		     (CPU_ISSUN4C || CPU_ISSUN4E)) ||
		    (ca->ca_bustype == BUS_OBIO && CPU_ISSUN4M)) {
			if (getproplen(ra->ra_node, channel == 0 ?
			    "port-a-ignore-cd" : "port-b-ignore-cd") == 0)
				zsc_args.hwflags |= ZS_HWFLAG_NO_DCD;
		}

		cs = zsc->zsc_cs[channel] = 
			(struct zs_chanstate *)&zsc->zsc_cs_store[channel];

		cs->cs_channel = channel;
		cs->cs_private = NULL;
		cs->cs_ops = &zsops_null;
		cs->cs_brg_clk = PCLK / 16;
		zc = zs_get_chan_addr(zs_unit, channel);

		cs->cs_reg_csr  = &zc->zc_csr;
		cs->cs_reg_data = &zc->zc_data;
		bcopy(zs_init_reg, cs->cs_creg, 16);
		bcopy(zs_init_reg, cs->cs_preg, 16);

		/* XXX: Get these from the PROM properties! */
		/* XXX: See the mvme167 code.  Better. */
		if (zsc_args.hwflags & ZS_HWFLAG_CONSOLE)
			cs->cs_defspeed = zs_get_speed(cs);
		else
			cs->cs_defspeed = zs_defspeed[zs_unit][channel];
		cs->cs_defcflag = zs_def_cflag;

		/* Make these correspond to cs_defcflag (-crtscts) */
		cs->cs_rr0_dcd = ZSRR0_DCD;
		cs->cs_rr0_cts = 0;
		cs->cs_wr5_dtr = ZSWR5_DTR | ZSWR5_RTS;
		cs->cs_wr5_rts = 0;

		/*
		 * Clear the master interrupt enable.
		 * The INTENA is common to both channels,
		 * so just do it on the A channel.
		 */
		if (channel == 0) {
			zs_write_reg(cs, 9, 0);
		}

		/*
		 * Look for a child driver for this channel.
		 * The child attach will setup the hardware.
		 */
		if (!config_found(self, (void *)&zsc_args, zs_print)) {
			/* No sub-driver.  Just reset it. */
			u_char reset = (channel == 0) ?
				ZSWR9_A_RESET : ZSWR9_B_RESET;
			s = splzs();
			zs_write_reg(cs,  9, reset);
			splx(s);
		}
	}

	/*
	 * Now safe to install interrupt handlers.  Note the arguments
	 * to the interrupt handlers aren't used.  Note, we only do this
	 * once since both SCCs interrupt at the same level and vector.
	 */
	if (!didintr) {
		didintr = 1;
		prevpri = pri;
		intr_establish(pri, &levelhard, IPL_ZS, self->dv_xname);
	} else if (pri != prevpri)
		panic("broken zs interrupt scheme");

	zsc->zsc_softih = softintr_establish(IPL_SOFTTTY, zssoft, zsc);

	/*
	 * Set the master interrupt enable and interrupt vector.
	 * (common to both channels, do it on A)
	 */
	cs = zsc->zsc_cs[0];
	s = splhigh();
	/* interrupt vector */
	zs_write_reg(cs, 2, zs_init_reg[2]);
	/* master interrupt control (enable) */
	zs_write_reg(cs, 9, zs_init_reg[9]);
	splx(s);

#ifdef SUN4M
	/* register power management routines if necessary */
	if (CPU_ISSUN4M) {
		if (getpropint(ra->ra_node, "pwr-on-auxio2", 0))
			for (channel = 0; channel < 2; channel++) {
				cs = zsc->zsc_cs[channel];
				cs->disable = zs_disable;
				cs->enable = zs_enable;
				cs->enabled = 0;
			}
	}
#endif

#if 0
	/*
	 * XXX: L1A hack - We would like to be able to break into
	 * the debugger during the rest of autoconfiguration, so
	 * lower interrupts just enough to let zs interrupts in.
	 * This is done after both zs devices are attached.
	 */
	if (zs_unit == 1) {
		printf("zs1: enabling zs interrupts\n");
		(void)splfd(); /* XXX: splzs - 1 */
	}
#endif
}

int
zs_print(aux, name)
	void *aux;
	const char *name;
{
	struct zsc_attach_args *args = aux;

	if (name != NULL)
		printf("%s:", name);

	if (args->channel != -1)
		printf(" channel %d", args->channel);

	return UNCONF;
}

/*
 * Our ZS chips all share a common, autovectored interrupt,
 * so we have to look at all of them on each interrupt.
 */
int
zshard(arg)
	void *arg;
{
	struct zsc_softc *zsc;
	int unit, rr3, rval, softreq;

	rval = softreq = 0;
	for (unit = 0; unit < zs_cd.cd_ndevs; unit++) {
		zsc = zs_cd.cd_devs[unit];
		if (zsc == NULL)
			continue;
		rr3 = zsc_intr_hard(zsc);
		/* Count up the interrupts. */
		if (rr3) {
			rval |= rr3;
		}
		if (zsc->zsc_cs[0]->cs_softreq || zsc->zsc_cs[1]->cs_softreq)
			softintr_schedule(zsc->zsc_softih);
	}

	return (rval);
}

/*
 * Similar scheme as for zshard (look at all of them)
 */
void
zssoft(arg)
	void *arg;
{
	struct zsc_softc *zsc = (struct zsc_softc *)arg;
	int s;

	/* Make sure we call the tty layer at spltty. */
	s = spltty();
	(void)zsc_intr_soft(zsc);
	splx(s);
}


/*
 * Compute the current baud rate given a ZS channel.
 */
int
zs_get_speed(cs)
	struct zs_chanstate *cs;
{
	int tconst;

	tconst = zs_read_reg(cs, 12);
	tconst |= zs_read_reg(cs, 13) << 8;
	return (TCONST_TO_BPS(cs->cs_brg_clk, tconst));
}

/*
 * MD functions for setting the baud rate and control modes.
 */
int
zs_set_speed(cs, bps)
	struct zs_chanstate *cs;
	int bps;	/* bits per second */
{
	int tconst, real_bps;

	if (bps == 0)
		return (0);

#ifdef	DIAGNOSTIC
	if (cs->cs_brg_clk == 0)
		panic("zs_set_speed");
#endif

	tconst = BPS_TO_TCONST(cs->cs_brg_clk, bps);
	if (tconst < 0)
		return (EINVAL);

	/* Convert back to make sure we can do it. */
	real_bps = TCONST_TO_BPS(cs->cs_brg_clk, tconst);

	/* XXX - Allow some tolerance here? */
	if (real_bps != bps)
		return (EINVAL);

	cs->cs_preg[12] = tconst;
	cs->cs_preg[13] = tconst >> 8;

	/* Caller will stuff the pending registers. */
	return (0);
}

int
zs_set_modes(cs, cflag)
	struct zs_chanstate *cs;
	int cflag;
{
	int s;

	/*
	 * Output hardware flow control on the chip is horrendous:
	 * if carrier detect drops, the receiver is disabled, and if
	 * CTS drops, the transmitter is stopped IN MID CHARACTER!
	 * Therefore, NEVER set the HFC bit, and instead use the
	 * status interrupt to detect CTS changes.
	 */
	s = splzs();
	cs->cs_rr0_pps = 0;
	if ((cflag & (CLOCAL | MDMBUF)) != 0) {
		cs->cs_rr0_dcd = 0;
		if ((cflag & MDMBUF) == 0)
			cs->cs_rr0_pps = ZSRR0_DCD;
	} else
		cs->cs_rr0_dcd = ZSRR0_DCD;
	if ((cflag & CRTSCTS) != 0) {
		cs->cs_wr5_dtr = ZSWR5_DTR;
		cs->cs_wr5_rts = ZSWR5_RTS;
		cs->cs_rr0_cts = ZSRR0_CTS;
#if 0 /* JLW */
	} else if ((cflag & CDTRCTS) != 0) {
		cs->cs_wr5_dtr = 0;
		cs->cs_wr5_rts = ZSWR5_DTR;
		cs->cs_rr0_cts = ZSRR0_CTS;
#endif
	} else if ((cflag & MDMBUF) != 0) {
		cs->cs_wr5_dtr = 0;
		cs->cs_wr5_rts = ZSWR5_DTR;
		cs->cs_rr0_cts = ZSRR0_DCD;
	} else {
		cs->cs_wr5_dtr = ZSWR5_DTR | ZSWR5_RTS;
		cs->cs_wr5_rts = 0;
		cs->cs_rr0_cts = 0;
	}
	splx(s);

	/* Caller will stuff the pending registers. */
	return (0);
}


/*
 * Read or write the chip with suitable delays.
 */

u_char
zs_read_reg(cs, reg)
	struct zs_chanstate *cs;
	u_char reg;
{
	u_char val;

	*cs->cs_reg_csr = reg;
	ZS_DELAY();
	val = *cs->cs_reg_csr;
	ZS_DELAY();
	return val;
}

void
zs_write_reg(cs, reg, val)
	struct zs_chanstate *cs;
	u_char reg, val;
{
	*cs->cs_reg_csr = reg;
	ZS_DELAY();
	*cs->cs_reg_csr = val;
	ZS_DELAY();
}

u_char
zs_read_csr(cs)
	struct zs_chanstate *cs;
{
	register u_char val;

	val = *cs->cs_reg_csr;
	ZS_DELAY();
	return val;
}

void
zs_write_csr(cs, val)
	struct zs_chanstate *cs;
	u_char val;
{
	*cs->cs_reg_csr = val;
	ZS_DELAY();
}

u_char
zs_read_data(cs)
	struct zs_chanstate *cs;
{
	register u_char val;

	val = *cs->cs_reg_data;
	ZS_DELAY();
	return val;
}

void
zs_write_data(cs, val)
	struct zs_chanstate *cs;
	u_char val;
{
	*cs->cs_reg_data = val;
	ZS_DELAY();
}

#ifdef SUN4M
/*
 * Power management hooks for zsopen() and zsclose().
 * We use them to power on/off the ports on the Tadpole SPARCbook machines
 * (on other sun4m machines, this is a no-op).
 */

/*
 * Since the serial power control is global, we need to remember which channels
 * have their ports open, so as not to power off when closing one channel if
 * both were open. Simply xor'ing the zs_chanstate pointers is enough to let us
 * know if the serial lines are used or not.
 */
static vaddr_t zs_sb_enable = 0;

int
zs_enable(struct zs_chanstate *cs)
{
	if (cs->enabled == 0) {
		if (zs_sb_enable == 0)
			sb_auxregbisc(1, AUXIO2_SERIAL, 0);
		zs_sb_enable ^= (vaddr_t)cs;
		cs->enabled = 1;
	}
	return (0);
}

void
zs_disable(struct zs_chanstate *cs)
{
	if (cs->enabled != 0) {
		cs->enabled = 0;
		zs_sb_enable ^= (vaddr_t)cs;
		if (zs_sb_enable == 0)
			sb_auxregbisc(1, 0, AUXIO2_SERIAL);
	}
}

#endif	/* SUN4M */

/****************************************************************
 * Console support functions (Sun specific!)
 * Note: this code is allowed to know about the layout of
 * the chip registers, and uses that to keep things simple.
 * XXX - I think I like the mvme167 code better. -gwr
 ****************************************************************/

extern void Debugger(void);
void *zs_conschan;

/*
 * Handle user request to enter kernel debugger.
 */
void
zs_abort(cs)
	struct zs_chanstate *cs;
{
	volatile struct zschan *zc = zs_conschan;
	int rr0;

	/* Wait for end of break to avoid PROM abort. */
	/* XXX - Limit the wait? */
	do {
		rr0 = zc->zc_csr;
		ZS_DELAY();
	} while (rr0 & ZSRR0_BREAK);

#if defined(KGDB)
	zskgdb(cs);
#elif defined(DDB)
	{
		extern int db_active;

		if (!db_active)
			Debugger();
		else
			/* Debugger is probably hosed */
			callrom();
	}
#else
	printf("stopping on keyboard abort\n");
	callrom();
#endif
}

/*
 * Polled input char.
 */
int
zs_getc(arg)
	void *arg;
{
	volatile struct zschan *zc = arg;
	int s, c, rr0;

	s = splhigh();
	/* Wait for a character to arrive. */
	do {
		rr0 = zc->zc_csr;
		ZS_DELAY();
	} while ((rr0 & ZSRR0_RX_READY) == 0);

	c = zc->zc_data;
	ZS_DELAY();
	splx(s);

	return (c);
}

/*
 * Polled output char.
 */
void
zs_putc(arg, c)
	void *arg;
	int c;
{
	volatile struct zschan *zc = arg;
	int s, rr0;

	s = splhigh();
	/* Wait for transmitter to become ready. */
	do {
		rr0 = zc->zc_csr;
		ZS_DELAY();
	} while ((rr0 & ZSRR0_TX_READY) == 0);

	/*
	 * Send the next character.
	 * Now you'd think that this could be followed by a ZS_DELAY()
	 * just like all the other chip accesses, but it turns out that
	 * the `transmit-ready' interrupt isn't de-asserted until
	 * some period of time after the register write completes
	 * (more than a couple instructions).  So to avoid stray
	 * interrupts we put in the 2us delay regardless of cpu model.
	 */
        zc->zc_data = c;
	delay(2);

	splx(s);
}

/*****************************************************************/

cons_decl(zs);

/*
 * Console table shared by ttya, ttyb
 */
struct consdev zscn = {
	zscnprobe,
	zscninit,
	zscngetc,
	zscnputc,
	zscnpollc,
};

extern int zstty_unit;	/* set in consinit() */

void
zscnprobe(cn)
	struct consdev *cn;
{
	cn->cn_dev = makedev(zs_major, zstty_unit);
	cn->cn_pri = CN_HIGHPRI;
}

void
zscninit(cn)
	struct consdev *cn;
{
}

/*
 * Polled console input putchar.
 */
int
zscngetc(dev)
	dev_t dev;
{
	return (zs_getc(zs_conschan));
}

/*
 * Polled console output putchar.
 */
void
zscnputc(dev, c)
	dev_t dev;
	int c;
{
	zs_putc(zs_conschan, c);
}

int swallow_zsintrs;

void
zscnpollc(dev, on)
	dev_t dev;
	int on;
{
	/*
	 * Need to tell zs driver to acknowledge all interrupts or we get
	 * annoying spurious interrupt messages.  This is because mucking
	 * with spl() levels during polling does not prevent interrupts from
	 * being generated.
	 */

	if (on) swallow_zsintrs++;
	else swallow_zsintrs--;
}
@


1.58
log
@Remove remaining Solbourne code.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.57 2015/03/18 19:49:14 miod Exp $	*/
@


1.57
log
@Revert 1.52, per the comment above the incorrectly changed line. Reduces the
number of spurious zs interrupts I am seeing on sun4c, albeit not completely.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.56 2015/02/28 17:54:54 miod Exp $	*/
a70 4
#ifdef solbourne
#include <machine/prom.h>
#endif

a98 1
#if !defined(solbourne)
a102 7
#endif
#if defined(solbourne)
	volatile u_char	zc_csr;		/* ctrl,status, and indirect access */
	u_char		zc_xxx0[7];
	volatile u_char	zc_data;	/* data */
	u_char		zc_xxx1[7];
#endif
a210 5

#ifdef solbourne
	if (CPU_ISKAP)
		return (ca->ca_bustype == BUS_OBIO);
#endif
@


1.56
log
@Move consinit() out of the bowels of the zs driver to its own file, in
preparation for systems which do not have console on a zs(4) device.
No functional change yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.55 2015/02/05 12:04:58 miod Exp $	*/
d765 1
a765 1
	ZS_DELAY();
@


1.55
log
@Do what the comments suggest and check for port-[ab]-ignore-cd properties,
and if so, force soft carrier mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.54 2013/12/19 20:11:04 miod Exp $	*/
d103 1
a103 1
#if defined(SUN4) || defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
d777 1
a777 1
struct consdev consdev_tty = {
d785 1
a785 1
int zstty_unit;	/* set in consinit() */
a837 340
}

/*****************************************************************/

#if defined(SUN4) || defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)

cons_decl(prom);

/*
 * The console is set to this one initially,
 * which lets us use the PROM until consinit()
 * is called to select a real console.
 */
struct consdev consdev_prom = {
	promcnprobe,
	promcninit,
	promcngetc,
	promcnputc,
	nullcnpollc,
};

/*
 * The console table pointer is statically initialized
 * to point to the PROM (output only) table, so that
 * early calls to printf will work.
 */
struct consdev *cn_tab = &consdev_prom;

void
promcnprobe(cn)
	struct consdev *cn;
{
	cn->cn_dev = makedev(0, 0);
	cn->cn_pri = CN_MIDPRI;
}

void
promcninit(cn)
	struct consdev *cn;
{
}

/*
 * PROM console input putchar.
 */
int
promcngetc(dev)
	dev_t dev;
{
	int s, c;

	if (promvec->pv_romvec_vers > 2) {
		int n = 0;
		unsigned char c0;

		s = splhigh();
		while (n <= 0) {
			n = (*promvec->pv_v2devops.v2_read)
			        (*promvec->pv_v2bootargs.v2_fd0, &c0, 1);
		}
		splx(s);

		c = c0;
	} else {
#if defined(SUN4)
		/* SUN4 PROM: must turn off local echo */
		extern struct om_vector *oldpvec;
		int saveecho = 0;
#endif
		s = splhigh();
#if defined(SUN4)
		if (CPU_ISSUN4) {
			saveecho = *(oldpvec->echo);
			*(oldpvec->echo) = 0;
		}
#endif
		c = (*promvec->pv_getchar)();
#if defined(SUN4)
		if (CPU_ISSUN4)
			*(oldpvec->echo) = saveecho;
#endif
		splx(s);
	}

	if (c == '\r')
		c = '\n';

	return (c);
}

/*
 * PROM console output putchar.
 */
void
promcnputc(dev, c)
	dev_t dev;
	int c;
{
	int s;
	char c0 = (c & 0x7f);

	s = splhigh();
	if (promvec->pv_romvec_vers > 2)
		(*promvec->pv_v2devops.v2_write)
			(*promvec->pv_v2bootargs.v2_fd1, &c0, 1);
	else
		(*promvec->pv_putchar)(c);
	splx(s);
}

#endif	/* SUN4 || SUN4C || SUN4D || SUN4E || SUN4M */

/*****************************************************************/

#if 0
extern struct consdev consdev_kd;
#endif

char *prom_inSrc_name[] = {
	"keyboard/display",
	"ttya", "ttyb",
	"ttyc", "ttyd" };

/*
 * This function replaces sys/dev/cninit.c
 * Determine which device is the console using
 * the PROM "input source" and "output sink".
 */
void
consinit()
{
	struct zschan *zc;
	struct consdev *console = cn_tab;
	int channel, zs_unit;
	int inSource, outSink;

#if defined(SUN4) || defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	if (promvec->pv_romvec_vers > 2) {
		/* We need to probe the PROM device tree */
		int node,fd;
		char buffer[128];
		struct nodeops *no;
		struct v2devops *op;
		char *cp;
		extern int fbnode;

		inSource = outSink = -1;
		no = promvec->pv_nodeops;
		op = &promvec->pv_v2devops;

		node = findroot();
		if (no->no_proplen(node, "stdin-path") >= sizeof(buffer)) {
			printf("consinit: increase buffer size and recompile\n");
			goto setup_output;
		}
		/* XXX: fix above */

		no->no_getprop(node, "stdin-path",buffer);

		/*
		 * Open an "instance" of this device.
		 * You'd think it would be appropriate to call v2_close()
		 * on the handle when we're done with it. But that seems
		 * to cause the device to shut down somehow; for the moment,
		 * we simply leave it open...
		 */
		if ((fd = op->v2_open(buffer)) == 0 ||
		     (node = op->v2_fd_phandle(fd)) == 0) {
			printf("consinit: bogus stdin path %s.\n",buffer);
			goto setup_output;
		}
		if (no->no_proplen(node,"keyboard") >= 0) {
			inSource = PROMDEV_KBD;
			goto setup_output;
		}
		if (strcmp(getpropstring(node,"device_type"),"serial") != 0) {
			/* not a serial, not keyboard. what is it?!? */
			inSource = -1;
			goto setup_output;
		}
		/*
		 * At this point we assume the device path is in the form
		 *   ....device@@x,y:a for ttya and ...device@@x,y:b for ttyb.
		 * If it isn't, we defer to the ROM
		 */
		cp = buffer;
		while (*cp)
		    cp++;
		cp -= 2;
#ifdef DEBUG
		if (cp < buffer)
		    panic("consinit: bad stdin path %s",buffer);
#endif
		/* XXX: only allows tty's a->z, assumes PROMDEV_TTYx contig */
		if (cp[0]==':' && cp[1] >= 'a' && cp[1] <= 'z')
		    inSource = PROMDEV_TTYA + (cp[1] - 'a');
		/* else use rom */
setup_output:
		node = findroot();
		if (no->no_proplen(node, "stdout-path") >= sizeof(buffer)) {
			printf("consinit: increase buffer size and recompile\n");
			goto setup_console;
		}
		/* XXX: fix above */

		no->no_getprop(node, "stdout-path", buffer);

		if ((fd = op->v2_open(buffer)) == 0 ||
		     (node = op->v2_fd_phandle(fd)) == 0) {
			printf("consinit: bogus stdout path %s.\n",buffer);
			goto setup_output;
		}
		if (strcmp(getpropstring(node,"device_type"),"display") == 0) {
			/* frame buffer output */
			outSink = PROMDEV_SCREEN;
			fbnode = node;
		} else if (strcmp(getpropstring(node,"device_type"), "serial")
			   != 0) {
			/* not screen, not serial. Whatzit? */
			outSink = -1;
		} else { /* serial console. which? */
			/*
			 * At this point we assume the device path is in the
			 * form:
			 * ....device@@x,y:a for ttya, etc.
			 * If it isn't, we defer to the ROM
			 */
			cp = buffer;
			while (*cp)
			    cp++;
			cp -= 2;
#ifdef DEBUG
			if (cp < buffer)
				panic("consinit: bad stdout path %s",buffer);
#endif
			/* XXX: only allows tty's a->z, assumes PROMDEV_TTYx contig */
			if (cp[0]==':' && cp[1] >= 'a' && cp[1] <= 'z')
			    outSink = PROMDEV_TTYA + (cp[1] - 'a');
			else outSink = -1;
		}
	} else {
		inSource = *promvec->pv_stdin;
		outSink  = *promvec->pv_stdout;
	}
#endif	/* SUN4 || SUN4C || SUN4D || SUN4E || SUN4M */
#ifdef solbourne
	if (CPU_ISKAP) {
		const char *dev;

		inSource = PROMDEV_TTYA;	/* default */
		dev = prom_getenv(ENV_INPUTDEVICE);
		if (dev != NULL) {
			if (strcmp(dev, "ttyb") == 0)
				inSource = PROMDEV_TTYB;
			if (strcmp(dev, "keyboard") == 0)
				inSource = PROMDEV_KBD;
		}

		outSink = PROMDEV_TTYA;	/* default */
		dev = prom_getenv(ENV_OUTPUTDEVICE);
		if (dev != NULL) {
			if (strcmp(dev, "ttyb") == 0)
				outSink = PROMDEV_TTYB;
			if (strcmp(dev, "screen") == 0)
				outSink = PROMDEV_SCREEN;
		}
	}
#endif

#if defined(SUN4) || defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
setup_console:
#endif

	if (inSource != outSink) {
		printf("cninit: mismatched PROM output selector\n");
		/*
		 * In case of mismatch, force the console to be on
		 * serial.
		 * There are three possible mismatches:
		 * - input and output on different serial lines:
		 *   use the output line.
		 * - input on keyboard, output on serial:
		 *   use the output line (this allows systems configured
		 *   for glass console, which frame buffers have been removed,
		 *   to still work if the keyboard is left plugged).
		 * - input on serial, output on video:
		 *   use the input line, since we don't know if a keyboard
		 *   is connected.
		 */
		if (outSink == PROMDEV_TTYA || outSink == PROMDEV_TTYB)
			inSource = outSink;
		else
			outSink = inSource;
	}

	switch (inSource) {
	default:
		printf("cninit: invalid inSource=%d\n", inSource);
		callrom();
		inSource = PROMDEV_KBD;
		/* FALLTHROUGH */

	case PROMDEV_KBD: /* keyboard/display */
#if NZSKBD > 0
		zs_unit = 1;
		channel = 0;
		break;
#else	/* NZSKBD */
		printf("cninit: kdb/display not configured\n");
		callrom();
		inSource = PROMDEV_TTYA;
		/* FALLTHROUGH */
#endif	/* NZSKBD */

	case PROMDEV_TTYA:
	case PROMDEV_TTYB:
		zstty_unit = inSource - PROMDEV_TTYA;
		zs_unit = 0;
		channel = zstty_unit & 1;
		console = &consdev_tty;
		break;

	}
	/* Now that inSource has been validated, print it. */
	printf("console is %s\n", prom_inSrc_name[inSource]);

	zc = zs_get_chan_addr(zs_unit, channel);
	if (zc == NULL) {
		printf("cninit: zs not mapped.\n");
		return;
	}
	zs_conschan = zc;
	zs_hwflags[zs_unit][channel] = ZS_HWFLAG_CONSOLE;
	/* switch to selected console */
	cn_tab = console;
	(*cn_tab->cn_probe)(cn_tab);
	(*cn_tab->cn_init)(cn_tab);
#ifdef	KGDB
	zs_kgdb_init();
#endif
@


1.54
log
@sun4e needs the same 1.6 usec ZS_DELAY() as sun4 does.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.53 2013/10/21 12:14:52 miod Exp $	*/
d143 1
a143 1
	ZSWR4_CLK_X16 | ZSWR4_ONESB | ZSWR4_EVENP,
d239 1
a239 2
 * USE ROM PROPERTIES port-a-ignore-cd AND port-b-ignore-cd FOR
 * SOFT CARRIER, AND keyboard PROPERTY FOR KEYBOARD/MOUSE?
d287 9
@


1.53
log
@Fix lies in comments, and apply some KNF and unused or duplicate prototype
removals.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.52 2013/09/15 09:49:21 miod Exp $	*/
d99 1
a99 1
#define	ZS_DELAY()		((CPU_ISSUN4C || CPU_ISSUN4E) ? (0) : delay(2))
@


1.52
log
@Replace a hardcoded delay() with ZS_DELAY() to make sun4c happier
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.51 2013/07/27 19:45:01 miod Exp $	*/
d37 2
a38 2
 * Plain tty/async lines use the zs_async slave.
 * Sun keyboard/mouse uses the zs_kbd/zs_ms slaves.
d506 1
a506 1
	int cflag;	/* bits per second */
d580 2
a581 1
u_char zs_read_csr(cs)
d591 2
a592 1
void  zs_write_csr(cs, val)
d600 2
a601 1
u_char zs_read_data(cs)
d611 2
a612 1
void  zs_write_data(cs, val)
@


1.51
log
@Revert wrong chunk introduced in 1.50, causing console keyboards not to attach
as console; fixes non-wsmux kernels such as bsd.rd; noticed by sebastia@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.50 2013/04/21 14:44:16 sebastia Exp $	*/
d753 1
a753 1
        delay(2);
@


1.50
log
@Unify the zs tty driver.

Most of the hard work by mpi@@, who provided the initial diff.
Fixes for sparc from myself. Tested on sgi and sparc myself.
Compiles and detects zstty on my powerbook, compile tested on
sparc64 by me. Real testing with zs device on sparc64 by miod@@
who also gave a lot of help and feedback.

ok miod@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.49 2012/05/25 17:11:40 miod Exp $	*/
d1158 1
a1158 5
	/* hardcoded: console is only on unit 0, 
	 * unit 1 is keyboard/mouse, see zs_attach
	 */
	if (zs_unit == 0)
	    zs_hwflags[zs_unit][channel] = ZS_HWFLAG_CONSOLE;
@


1.49
log
@Correctly handle the case of a system setup to use glass console, which
frame buffer has been removed, but which keyboard is left plugged in.
The PROM will select a `keyboard input, serial output' console, which was
being recognized as glass console by the kernel. The kernel would then
reset the serial chip at zstty attach time, while still using the PROM
output routines at this point, and hang.

Fix this by paying attention to split input/output setups and always falling
back to serial console in this case.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.48 2010/07/10 19:32:24 miod Exp $	*/
d65 1
a65 1
#include <sparc/dev/z8530reg.h>
d288 2
a289 1
		cs = &zsc->zsc_cs[channel];
a294 1

a298 1

d357 1
a357 1
	cs = &zsc->zsc_cs[0];
d370 1
a370 1
				cs = &zsc->zsc_cs[channel];
d429 1
a429 1
		if (zsc->zsc_cs[0].cs_softreq || zsc->zsc_cs[1].cs_softreq)
d1158 5
a1162 1
	zs_hwflags[zs_unit][channel] = ZS_HWFLAG_CONSOLE;
@


1.48
log
@sun4e (i.e. SPARCengine 1e) support. This platform is a mix between sun4 and
sun4c, as it has a sun4c OpenPROM but a sun4 8KB pagesize. VME devices are
not supported yet.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.47 2009/04/10 20:53:51 miod Exp $	*/
d1102 18
@


1.47
log
@generic soft interrupts support for sparc. Soft interrupt handlers are now
kept in a separate intrhand array, with their own enable bits so that
soft interrupts sharing the same level only get invoked if really triggered.
Inspired by NetBSD with significant changes.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.46 2008/06/26 05:42:13 ray Exp $	*/
d99 1
a99 1
#define	ZS_DELAY()		(CPU_ISSUN4C ? (0) : delay(2))
d103 1
a103 1
#if defined(SUN4) || defined(SUN4C) || defined(SUN4M)
d229 1
a229 1
	if ((ca->ca_bustype == BUS_MAIN && !CPU_ISSUN4) ||
d831 1
a831 1
#if defined(SUN4) || defined(SUN4C) || defined(SUN4M)
d937 1
a937 1
#endif	/* SUN4 || SUN4C || SUN4M */
d963 1
a963 1
#if defined(SUN4) || defined(SUN4C) || defined(SUN4M)
d1071 1
a1071 1
#endif	/* SUN4 || SUN4C || SUN4M */
d1096 1
a1096 1
#if defined(SUN4) || defined(SUN4C) || defined(SUN4M)
@


1.46
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.45 2008/01/23 16:37:57 jsing Exp $	*/
a98 13
/*
 * Select software interrupt bit based on TTY ipl.
 */
#if IPL_TTY == 1
# define IE_ZSSOFT IE_L1
#elif IPL_TTY == 4
# define IE_ZSSOFT IE_L4
#elif IPL_TTY == 6
# define IE_ZSSOFT IE_L6
#else
# error "no suitable software interrupt bit"
#endif

d203 1
a203 1
int zssoft(void *);
a204 1
struct intrhand levelsoft = { zssoft };
a348 1
		intr_establish(IPL_TTY, &levelsoft, IPL_TTY, self->dv_xname);
d352 2
a408 2
volatile int zssoftpending;

d430 2
a431 2
		softreq |= zsc->zsc_cs[0].cs_softreq;
		softreq |= zsc->zsc_cs[1].cs_softreq;
a433 10
	/* We are at splzs here, so no need to lock. */
	if (softreq && (zssoftpending == 0)) {
		zssoftpending = IE_ZSSOFT;
#if defined(SUN4M)
		if (CPU_ISSUN4M)
			raise(0, IPL_TTY);
		else
#endif
		ienab_bis(IE_ZSSOFT);
	}
d440 1
a440 1
int
d444 2
a445 15
	struct zsc_softc *zsc;
	int s, unit;

	/* This is not the only ISR on this IPL. */
	if (zssoftpending == 0)
		return (0);

	/*
	 * The soft intr. bit will be set by zshard only if
	 * the variable zssoftpending is zero.  The order of
	 * these next two statements prevents our clearing
	 * the soft intr bit just after zshard has set it.
	 */
	/* ienab_bic(IE_ZSSOFT); */
	zssoftpending = 0;
d449 1
a449 6
	for (unit = 0; unit < zs_cd.cd_ndevs; unit++) {
		zsc = zs_cd.cd_devs[unit];
		if (zsc == NULL)
			continue;
		(void)zsc_intr_soft(zsc);
	}
a450 1
	return (1);
@


1.45
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.44 2007/10/22 14:46:46 jsing Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.44
log
@stoped -> stopped

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.43 2006/01/09 20:57:00 miod Exp $	*/
d832 1
a832 1
	cn->cn_pri = CN_REMOTE;
d911 1
a911 1
	cn->cn_pri = CN_INTERNAL;
@


1.43
log
@Remove completely obsolete comment from the pre-wscons sparc days in
zs_getc().
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.42 2005/07/08 12:38:31 miod Exp $	*/
d565 1
a565 1
	 * CTS drops, the transmitter is stoped IN MID CHARACTER!
@


1.42
log
@Add power hooks to the zs devices on sun4m if they have a pwr-on-auxio2
property (as found on sparcbooks). If so, frob the appropriate auxio2 bit
to enable and disable the port as necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.41 2005/04/19 21:30:19 miod Exp $	*/
a773 4
	/*
	 * This is used by the kd driver to read scan codes,
	 * so don't translate '\r' ==> '\n' here...
	 */
@


1.41
log
@As a late birthday present, a preliminary port to the Solbourne IDT systems
(S3000, S4000 and S4000DX).

Currently limited to diskless and serial console, and userland has issues.
Things will get better in the near future.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.40 2004/09/29 07:35:12 miod Exp $	*/
d207 5
a211 1
int  zs_print(void *, const char *nam);
d386 13
d667 40
@


1.40
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.39 2003/01/22 18:59:36 miod Exp $	*/
d78 4
d123 1
d128 7
d240 6
d829 2
d935 2
d961 1
d1069 24
d1094 1
d1096 1
@


1.39
log
@Revert previous - it would prevent the second zs chip from being probed
on the Voyager, thus preventing keyboard support from working at all.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.38 2003/01/20 15:57:28 miod Exp $	*/
d347 2
a348 2
		intr_establish(pri, &levelhard, IPL_ZS);
		intr_establish(IPL_TTY, &levelsoft, IPL_TTY);
a350 1
	evcnt_attach(&zsc->zsc_dev, "intr", &zsc->zsc_intrcnt);
a415 1
			zsc->zsc_intrcnt.ev_count++;
@


1.38
log
@Put back the Voyager zs probe workaround that got lost in rev 1.36;
spotted by Takeshi Morimoto.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.37 2002/09/03 23:20:40 miod Exp $	*/
d229 2
a230 7
	    (ca->ca_bustype == BUS_OBIO && CPU_ISSUN4M)) {
		if (getpropint(ra->ra_node, "slave", -2) == cf->cf_unit &&
		    findzs(cf->cf_unit))
			return (1);
		return (0);
	}

@


1.37
log
@Old (rev 1) OpenPROM will always report as the "fb" node, the first
framebuffer found, even if the PROM environment is set to serial console.
Hence, make sure we won't consider this "fb" node as valid until we are
really using a graphics console.

Will makes drahn@@'s IPC happy, and ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.36 2002/08/12 10:44:04 miod Exp $	*/
d229 7
a235 2
	    (ca->ca_bustype == BUS_OBIO && CPU_ISSUN4M))
		return (getpropint(ra->ra_node, "slave", -2) == cf->cf_unit);
@


1.36
log
@Convert sparc console code from rcons and pseudo-devices to rasops and wscons.
For most framebuffers it is faster.

Other changes include:
o 24 bit support in tcx(4) for the S24 framebuffer
o accelerated cgsix(4) text console
o new cgtwelve(4) driver for the GS framebuffer
o improved serial driver code
o better keyboard support

The following framebuffers have not been tested but should work: cgfour,
cgeight and cgfourteen

These changes will require XF4 changes, to use Xwsfb instead of Xsun*, to be
commited later today.

Most of the work by me during the LSM and the week after, with code borrowed
from jason@@, NetBSD (new serial code), and feedback from mickey@@. Work on
pnozz(4) done by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1062 1
a1062 1
	case 0:	/* keyboard/display */
@


1.35
log
@Fix an ancient problem in how sparc interrupts are handled.

There are many interrupt handlers that assume that they don't need to do
any spl protection in their code because the interrupt of some level can't
be interrupted by an interrupt of the same level. The problem is that some
interrupt handlers have hardware levels that are lower then their "software"
levels.

Fix this by adding an additional field to struct intrhand that specifies which
"software" level an interrupt handler has and blocks that level while handling
the interrupt. This new field is initialized in intr_establish which gets
an additional argument (which can be -1 meaning that the interrupt handler
doesn't need to block any additional level).

ok deraadt@@
@
text
@d1 2
a2 2
/*	$OpenBSD: zs.c,v 1.34 2002/04/28 03:51:19 art Exp $	*/
/*	$NetBSD: zs.c,v 1.49 1997/08/31 21:26:37 pk Exp $ */
d4 3
a6 7
/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
d8 2
a9 4
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
d21 5
a25 5
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d27 11
a37 13
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)zs.c	8.1 (Berkeley) 7/19/93
d41 1
a41 5
 * Zilog Z8530 (ZSCC) driver.
 *
 * Runs two tty ports (ttya and ttyb) on zs0,
 * and runs a keyboard and mouse on zs1, and
 * possibly two more tty ports (ttyc and ttyd) on zs2.
d43 3
a45 1
 * This driver knows far too much about chip to usage mappings.
a46 2
#include "zs.h"
#include "kbd.h"
d50 1
a50 1
#include <sys/proc.h>
d54 2
a55 1
#include <sys/malloc.h>
a57 1
#include <sys/kernel.h>
a58 6
#include <sys/conf.h>
#ifdef DDB
#include <ddb/db_var.h>
#endif

#include <uvm/uvm_extern.h>
d61 1
d64 9
a72 1
#include <machine/kbd.h>
d76 1
a76 2
#include <dev/ic/z8530reg.h>
#include <sparc/dev/zsvar.h>
d78 1
a78 4
#ifdef KGDB
#include <sys/kgdb.h>
#include <machine/remote-sl.h>
#endif
d80 2
a81 2
#define DEVUNIT(x)      (minor(x) & 0x7f)
#define DEVCUA(x)       (minor(x) & 0x80)
d83 5
a87 1
#define	ZSMAJOR	12		/* XXX */
d89 7
a95 2
#define	ZS_KBD		2	/* XXX */
#define	ZS_MOUSE	3	/* XXX */
d97 4
a100 2
/* the magic number below was stolen from the Sprite source. */
#define PCLK	(19660800/4)	/* PCLK pin input clock rate */
d115 13
a127 8
/*
 * Software state per found chip.
 */
struct zs_softc {
	struct	device sc_dev;			/* base device */
	volatile struct zsdevice *sc_zs;	/* chip registers */
	struct	evcnt sc_intrcnt;		/* count interrupts */
	struct	zs_chanstate sc_cs[2];		/* chan A/B software state */
d130 5
a134 3
/* Definition of the driver for autoconfig. */
static int	zsmatch(struct device *, void *, void *);
static void	zsattach(struct device *, struct device *, void *);
d136 8
a143 2
struct cfattach zs_ca = {
	sizeof(struct zs_softc), zsmatch, zsattach
d146 17
a162 2
struct cfdriver zs_cd = {
	NULL, "zs", DV_TTY
d165 21
a185 41
/* Interrupt handlers. */
static int	zshard(void *);
static struct intrhand levelhard = { zshard };
static int	zssoft(void *);
static struct intrhand levelsoft = { zssoft };

struct zs_chanstate *zslist;

/* Routines called from other code. */
static void	zsiopen(struct tty *);
static void	zsiclose(struct tty *);
static void	zsstart(struct tty *);
static int	zsparam(struct tty *, struct termios *);

/* Routines purely local to this driver. */
static int	zs_getspeed(volatile struct zschan *);
#ifdef KGDB
static void	zs_reset(volatile struct zschan *, int, int);
#endif
static void	zs_modem(struct zs_chanstate *, int);
static void	zs_loadchannelregs(volatile struct zschan *, u_char *);
static void	tiocm_to_zs(struct zs_chanstate *, int how, int data);

/* Console stuff. */
static struct tty *zs_ctty;	/* console `struct tty *' */
static int zs_consin = -1, zs_consout = -1;
static struct zs_chanstate *zs_conscs = NULL; /*console channel state */
static void zscnputc(int);	/* console putc function */
static volatile struct zschan *zs_conschan;
static struct tty *zs_checkcons(struct zs_softc *, int,
    struct zs_chanstate *);

#ifdef KGDB
/* KGDB stuff.  Must reboot to change zs_kgdbunit. */
extern int kgdb_dev, kgdb_rate;
static int zs_kgdb_savedspeed;
static void zs_checkkgdb(int, struct zs_chanstate *, struct tty *);
void zskgdb(int);
static int zs_kgdb_getc(void *);
static void zs_kgdb_putc(void *, int);
#endif
a186 3
static int zsrint(struct zs_chanstate *, volatile struct zschan *);
static int zsxint(struct zs_chanstate *, volatile struct zschan *);
static int zssint(struct zs_chanstate *, volatile struct zschan *);
d188 3
a190 2
void zsabort(int);
static void zsoverrun(int, long *, char *);
d192 4
a195 1
static volatile struct zsdevice *zsaddr[NZS];	/* XXX, but saves work */
d197 3
a199 11
/*
 * Console keyboard L1-A processing is done in the hardware interrupt code,
 * so we need to duplicate some of the console keyboard decode state.  (We
 * must not use the regular state as the hardware code keeps ahead of the
 * software state: the software state tracks the most recent ring input but
 * the hardware state tracks the most recent ZSCC input.)  See also kbd.h.
 */
static struct conk_state {	/* console keyboard state */
	char	conk_id;	/* true => ID coming up (console only) */
	char	conk_l1;	/* true => L1 pressed (console only) */
} zsconk_state;
d201 3
a203 2
int zshardscope;
int zsshortcuts;		/* number of "shortcut" software interrupts */
d205 5
a209 10
#ifdef SUN4
static u_int zs_read(volatile struct zschan *, u_int reg);
static u_int zs_write(volatile struct zschan *, u_int, u_int);

static u_int
zs_read(zc, reg)
	volatile struct zschan *zc;
	u_int reg;
{
	u_char val;
d211 1
a211 6
	zc->zc_csr = reg;
	ZS_DELAY();
	val = zc->zc_csr;
	ZS_DELAY();
	return val;
}
a212 12
static u_int
zs_write(zc, reg, val)
	volatile struct zschan *zc;
	u_int reg, val;
{
	zc->zc_csr = reg;
	ZS_DELAY();
	zc->zc_csr = val;
	ZS_DELAY();
	return val;
}
#endif /* SUN4 */
d215 1
a215 2
 * Match slave number to zs unit number, so that misconfiguration will
 * not set up the keyboard as ttya, etc.
d217 2
a218 2
static int
zsmatch(parent, vcf, aux)
d222 2
a223 2
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
d229 2
a230 6
	    (ca->ca_bustype == BUS_OBIO && CPU_ISSUN4M)) {
		if (getpropint(ra->ra_node, "slave", -2) == cf->cf_unit &&
		    findzs(cf->cf_unit))
			return (1);
		return (0);
	}
d241 2
a242 2
static void
zsattach(parent, dev, aux)
d244 1
a244 1
	struct device *dev;
d247 7
a253 8
	register int zs = dev->dv_unit, unit;
	register struct zs_softc *sc;
	register struct zs_chanstate *cs;
	register volatile struct zsdevice *addr;
	register struct tty *tp, *ctp;
	register struct confargs *ca = aux;
	register struct romaux *ra = &ca->ca_ra;
	int pri;
a254 1
	int ringsize;
d256 6
a261 2
	if ((addr = zsaddr[zs]) == NULL)
		addr = zsaddr[zs] = (volatile struct zsdevice *)findzs(zs);
d263 1
a263 1
		if ((void *)addr != ra->ra_vaddr)
d271 73
d351 24
a374 46
	sc = (struct zs_softc *)dev;
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);
	sc->sc_zs = addr;
	unit = zs * 2;
	cs = sc->sc_cs;

	/* link into interrupt list with order (A,B) (B=A+1) */
	cs[0].cs_next = &cs[1];
	cs[0].cs_sc = sc;
	cs[1].cs_next = zslist;
	cs[1].cs_sc = sc;
	zslist = cs;

	cs->cs_unit = unit;
	cs->cs_speed = zs_getspeed(&addr->zs_chan[ZS_CHAN_A]);
	cs->cs_zc = &addr->zs_chan[ZS_CHAN_A];
	if ((ctp = zs_checkcons(sc, unit, cs)) != NULL)
		tp = ctp;
	else {
		tp = ttymalloc();
		tp->t_dev = makedev(ZSMAJOR, unit);
		tp->t_oproc = zsstart;
		tp->t_param = zsparam;
	}
	cs->cs_ttyp = tp;
#ifdef KGDB
	if (ctp == NULL)
		zs_checkkgdb(unit, cs, tp);
#endif
	if (unit == ZS_KBD) {
		/*
		 * Keyboard: tell /dev/kbd driver how to talk to us.
		 */
		tp->t_ispeed = tp->t_ospeed = cs->cs_speed;
		tp->t_cflag = CS8;
#if	NKBD > 0
		kbd_serial(tp, zsiopen, zsiclose);
#endif
		cs->cs_conk = 1;		/* do L1-A processing */
		ringsize = 128;
	} else {
		if (tp != ctp)
			tty_attach(tp);
		ringsize = 4096;
		if (unit == zs_consout)
			zs_conscs = cs;
a375 23
	cs->cs_ringmask = ringsize - 1;
	cs->cs_rbuf = malloc((u_long)ringsize * sizeof(*cs->cs_rbuf),
			      M_DEVBUF, M_NOWAIT);
	if (cs->cs_rbuf == NULL)
		panic("zsattach");

	unit++;
	cs++;
	cs->cs_unit = unit;
	cs->cs_speed = zs_getspeed(&addr->zs_chan[ZS_CHAN_B]);
	cs->cs_zc = &addr->zs_chan[ZS_CHAN_B];
	if ((ctp = zs_checkcons(sc, unit, cs)) != NULL)
		tp = ctp;
	else {
		tp = ttymalloc();
		tp->t_dev = makedev(ZSMAJOR, unit);
		tp->t_oproc = zsstart;
		tp->t_param = zsparam;
	}
	cs->cs_ttyp = tp;
#ifdef KGDB
	if (ctp == NULL)
		zs_checkkgdb(unit, cs, tp);
a376 20
	if (unit == ZS_MOUSE) {
		/*
		 * Mouse: tell /dev/mouse driver how to talk to us.
		 */
		tp->t_ispeed = tp->t_ospeed = B1200;
		tp->t_cflag = CS8;
		ms_serial(tp, zsiopen, zsiclose);
		ringsize = 128;
	} else {
		if (tp != ctp)
			tty_attach(tp);
		ringsize = 4096;
		if (unit == zs_consout)
			zs_conscs = cs;
	}
	cs->cs_ringmask = ringsize - 1;
	cs->cs_rbuf = malloc((u_long)ringsize * sizeof(*cs->cs_rbuf),
			      M_DEVBUF, M_NOWAIT);
	if (cs->cs_rbuf == NULL)
		panic("zsattach");
d379 4
a382 9
#ifdef KGDB
/*
 * Put a channel in a known state.  Interrupts may be left disabled
 * or enabled, as desired.
 */
static void
zs_reset(zc, inten, speed)
	volatile struct zschan *zc;
	int inten, speed;
d384 9
a392 25
	int tconst;
	static u_char reg[16] = {
		0,
		0,
		0,
		ZSWR3_RX_8 | ZSWR3_RX_ENABLE,
		ZSWR4_CLK_X16 | ZSWR4_ONESB | ZSWR4_EVENP,
		ZSWR5_TX_8 | ZSWR5_TX_ENABLE,
		0,
		0,
		0,
		0,
		ZSWR10_NRZ,
		ZSWR11_TXCLK_BAUD | ZSWR11_RXCLK_BAUD,
		0,
		0,
		ZSWR14_BAUD_FROM_PCLK | ZSWR14_BAUD_ENA,
		ZSWR15_BREAK_IE | ZSWR15_DCD_IE,
	};

	reg[9] = inten ? ZSWR9_MASTER_IE | ZSWR9_NO_VECTOR : ZSWR9_NO_VECTOR;
	tconst = BPS_TO_TCONST(PCLK / 16, speed);
	reg[12] = tconst;
	reg[13] = tconst >> 8;
	zs_loadchannelregs(zc, reg);
a393 1
#endif
d395 1
a395 35
/*
 * Declare the given tty (which is in fact &cons) as a console input
 * or output.  This happens before the zs chip is attached; the hookup
 * is finished later, in zs_setcons() below.
 *
 * This is used only for ports a and b.  The console keyboard is decoded
 * independently (we always send unit-2 input to /dev/kbd, which will
 * direct it to /dev/console if appropriate).
 */
void
zsconsole(tp, unit, out, fnstop)
	register struct tty *tp;
	register int unit;
	int out;
	int (**fnstop)(struct tty *, int);
{
	int zs;
	volatile struct zsdevice *addr;

	if (unit >= ZS_KBD)
		panic("zsconsole");
	if (out) {
		zs_consout = unit;
		zs = unit >> 1;
		if ((addr = zsaddr[zs]) == NULL)
			addr = zsaddr[zs] = (volatile struct zsdevice *)findzs(zs);
		zs_conschan = (unit & 1) == 0 ? &addr->zs_chan[ZS_CHAN_A] :
		    &addr->zs_chan[ZS_CHAN_B];
		v_putc = zscnputc;
	} else
		zs_consin = unit;
	if (fnstop)
		*fnstop = &zsstop;
	zs_ctty = tp;
}
d398 2
a399 1
 * Polled console output putchar.
d401 3
a403 3
static void
zscnputc(c)
	int c;
d405 2
a406 2
	volatile struct zschan *zc = zs_conschan;
	int s;
d408 14
a421 2
	if (c == '\n')
		zscnputc('\r');
d423 9
a431 20
	s = splzs();
	while ((zc->zc_csr & ZSRR0_TX_READY) == 0)
		ZS_DELAY();
	/*
	 * If transmitter was busy doing regular tty I/O (ZSWR1_TIE on),
	 * defer our output until the transmit interrupt runs. We still
	 * sync with TX_READY so we can get by with a single-char "queue".
	 */
	if (zs_conscs != NULL && (zs_conscs->cs_creg[1] & ZSWR1_TIE)) {
		/*
		 * If previous not yet done, send it now; zsxint()
		 * will field the interrupt for our char, but doesn't
		 * care. We're running at sufficiently high spl for
		 * this to work.
		 */
		if (zs_conscs->cs_deferred_cc != 0)
			zc->zc_data = zs_conscs->cs_deferred_cc;
		zs_conscs->cs_deferred_cc = c;
		splx(s);
		return;
d433 1
a433 3
	zc->zc_data = c;
	delay(2);
	splx(s);
d437 1
a437 2
 * Set up the given unit as console input, output, both, or neither, as
 * needed.  Return console tty if it is to receive console input.
d439 3
a441 5
static struct tty *
zs_checkcons(sc, unit, cs)
	struct zs_softc *sc;
	int unit;
	struct zs_chanstate *cs;
d443 2
a444 2
	register struct tty *tp;
	char *i, *o;
d446 2
a447 5
	if ((tp = zs_ctty) == NULL) /* XXX */
		return (0);
	i = zs_consin == unit ? "input" : NULL;
	o = zs_consout == unit ? "output" : NULL;
	if (i == NULL && o == NULL)
a449 3
	/* rewire the minor device (gack) */
	tp->t_dev = makedev(major(tp->t_dev), unit);

d451 4
a454 6
	 * Rewire input and/or output.  Note that baud rate reflects
	 * input settings, not output settings, but we can do no better
	 * if the console is split across two ports.
	 *
	 * XXX	split consoles don't work anyway -- this needs to be
	 *	thrown away and redone
d456 2
a457 28
	if (i) {
		tp->t_param = zsparam;
		tp->t_ispeed = tp->t_ospeed = cs->cs_speed;
		tp->t_cflag = CS8;
		ttsetwater(tp);
	}
	if (o) {
		tp->t_oproc = zsstart;
	}
	printf("%s%c: console %s\n",
	    sc->sc_dev.dv_xname, (unit & 1) + 'a', i ? (o ? "i/o" : i) : o);
	cs->cs_consio = 1;
	cs->cs_brkabort = 1;
	return (tp);
}

#ifdef KGDB
/*
 * The kgdb zs port, if any, was altered at boot time (see zs_kgdb_init).
 * Pick up the current speed and character size and restore the original
 * speed.
 */
static void
zs_checkkgdb(unit, cs, tp)
	int unit;
	struct zs_chanstate *cs;
	struct tty *tp;
{
d459 7
a465 6
	if (kgdb_dev == makedev(ZSMAJOR, unit)) {
		tp->t_ispeed = tp->t_ospeed = kgdb_rate;
		tp->t_cflag = CS8;
		cs->cs_kgdb = 1;
		cs->cs_speed = zs_kgdb_savedspeed;
		(void) zsparam(tp, &tp->t_termios);
d467 2
a468 15
}
#endif

/*
 * Compute the current baud rate given a ZSCC channel.
 */
static int
zs_getspeed(zc)
	register volatile struct zschan *zc;
{
	register int tconst;

	tconst = ZS_READ(zc, 12);
	tconst |= ZS_READ(zc, 13) << 8;
	return (TCONST_TO_BPS(PCLK / 16, tconst));
d473 1
a473 1
 * Do an internal open.
d475 3
a477 3
static void
zsiopen(tp)
	struct tty *tp;
d479 1
d481 3
a483 3
	(void) zsparam(tp, &tp->t_termios);
	ttsetwater(tp);
	tp->t_state = TS_ISOPEN | TS_CARR_ON;
d487 1
a487 2
 * Do an internal close.  Eventually we should shut off the chip when both
 * ports on it are closed.
d489 4
a492 3
static void
zsiclose(tp)
	struct tty *tp;
d494 1
d496 2
a497 4
	ttylclose(tp, 0);	/* ??? */
	ttyclose(tp);		/* ??? */
	tp->t_state = 0;
}
d499 4
d504 3
d508 2
a509 42
/*
 * Open a zs serial port.  This interface may not be used to open
 * the keyboard and mouse ports. (XXX)
 */
int
zsopen(dev, flags, mode, p)
	dev_t dev;
	int flags;
	int mode;
	struct proc *p;
{
	register struct tty *tp;
	register struct zs_chanstate *cs;
	struct zs_softc *sc;
	int unit = DEVUNIT(dev);
	int zs = unit >> 1, error, s;

	if (zs >= zs_cd.cd_ndevs || (sc = zs_cd.cd_devs[zs]) == NULL ||
	    unit == ZS_KBD || unit == ZS_MOUSE)
		return (ENXIO);
	cs = &sc->sc_cs[unit & 1];
	if (cs->cs_consio)
		return (ENXIO);		/* ??? */
	tp = cs->cs_ttyp;
	s = spltty();
	if ((tp->t_state & TS_ISOPEN) == 0) {
		ttychars(tp);
		if (tp->t_ispeed == 0) {
			tp->t_iflag = TTYDEF_IFLAG;
			tp->t_oflag = TTYDEF_OFLAG;
			tp->t_cflag = TTYDEF_CFLAG;
			tp->t_lflag = TTYDEF_LFLAG;
			tp->t_ispeed = tp->t_ospeed = cs->cs_speed;
		}
		(void) zsparam(tp, &tp->t_termios);
		ttsetwater(tp);
/* XXX start CUA mods */
		if (DEVCUA(dev)) 
                  SET(tp->t_state, TS_CARR_ON);
                else 
                  CLR(tp->t_state, TS_CARR_ON);
/* end CUA mods */
d511 3
a513 4
	} else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0) {
		splx(s);
		return (EBUSY);
	}
d515 2
a516 42
/* XXX start CUA mods */
        if (DEVCUA(dev)) {
                if (ISSET(tp->t_state, TS_ISOPEN)) {
                        /* Ah, but someone already is dialed in... */
                        splx(s);
                        return EBUSY;
                }
                cs->cs_cua = 1;         /* We go into CUA mode */
        }


        error = 0;
        /* wait for carrier if necessary */
        if (ISSET(flags, O_NONBLOCK)) {
                if (!DEVCUA(dev) && cs->cs_cua) {
                        /* Opening TTY non-blocking... but the CUA is busy */
                        splx(s);
                        return EBUSY;
                }
        } else {
	    while (cs->cs_cua ||
	      (!ISSET(tp->t_cflag, CLOCAL) &&
	      !ISSET(tp->t_state, TS_CARR_ON))) {
		register int rr0;

                error = 0;
		SET(tp->t_state, TS_WOPEN);


              if (!DEVCUA(dev) && !cs->cs_cua) {
		/* loop, turning on the device, until carrier present */
		zs_modem(cs, 1);
		/* May never get status intr if carrier already on. -gwr */
		rr0 = cs->cs_zc->zc_csr;
		ZS_DELAY();
		if ((rr0 & ZSRR0_DCD) || cs->cs_softcar)
			tp->t_state |= TS_CARR_ON;
              }

		if ((tp->t_cflag & CLOCAL || tp->t_state & TS_CARR_ON) && 
			!cs->cs_cua)
			break;
d518 3
a520 2
		error = ttysleep(tp, (caddr_t)&tp->t_rawq, TTIPRI | PCATCH,
				 ttopen, 0);
d522 6
a527 4
		if (!DEVCUA(dev) && cs->cs_cua && error == EINTR) {
			error=0;
			continue;
                }
d529 34
a562 17
		if (error) {
			if (!(tp->t_state & TS_ISOPEN)) {
				zs_modem(cs, 0);
				CLR(tp->t_state, TS_WOPEN);
				ttwakeup(tp);
			}
/* XXX ordering of this might be important?? */
                        if (DEVCUA(dev))
                                cs->cs_cua = 0;
			CLR(tp->t_state, TS_WOPEN);
			splx(s);
			return error;
		}
                if (!DEVCUA(dev) && cs->cs_cua)
                        continue;
	    }
        } 
a563 7
/* end CUA mods */
	if (error == 0)
		error = linesw[tp->t_line].l_open(dev, tp);
	if (error)
		zs_modem(cs, 0);
	return (error);
}
d565 1
a565 51
/*
 * Close a zs serial port.
 */
int
zsclose(dev, flags, mode, p)
	dev_t dev;
	int flags;
	int mode;
	struct proc *p;
{
	register struct zs_chanstate *cs;
	register struct tty *tp;
	struct zs_softc *sc;
	int unit = DEVUNIT(dev);
	int s, st;

	sc = zs_cd.cd_devs[unit >> 1];
	cs = &sc->sc_cs[unit & 1];
	tp = cs->cs_ttyp;
	linesw[tp->t_line].l_close(tp, flags);

/* XXX start CUA mods */
        st = spltty();
/* end CUA mods */
	if (tp->t_cflag & HUPCL || tp->t_state & TS_WOPEN ||
	    (tp->t_state & TS_ISOPEN) == 0) {
		zs_modem(cs, 0);
		/* hold low for 1 second */
		(void) tsleep((caddr_t)cs, TTIPRI, ttclos, hz);
	}
	if (cs->cs_creg[5] & ZSWR5_BREAK)
	{
		s = splzs();
		cs->cs_preg[5] &= ~ZSWR5_BREAK;
		cs->cs_creg[5] &= ~ZSWR5_BREAK;
		ZS_WRITE(cs->cs_zc, 5, cs->cs_creg[5]);
		splx(s);
	}
/* XXX start CUA mods */
        CLR(tp->t_state, TS_CARR_ON | TS_BUSY | TS_FLUSH);
        cs->cs_cua = 0;
	splx(st);
/* end CUA mods */
	ttyclose(tp);
#ifdef KGDB
	/* Reset the speed if we're doing kgdb on this port */
	if (cs->cs_kgdb) {
		tp->t_ispeed = tp->t_ospeed = kgdb_rate;
		(void) zsparam(tp, &tp->t_termios);
	}
#endif
d569 1
d571 1
a571 1
 * Read/write zs serial port.
d573 5
a577 5
int
zsread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d579 1
a579 8
	register struct zs_chanstate *cs;
	register struct zs_softc *sc;
	register struct tty *tp;
	int unit = DEVUNIT(dev);

	sc = zs_cd.cd_devs[unit >> 1];
	cs = &sc->sc_cs[unit & 1];
	tp = cs->cs_ttyp;
d581 6
a586 1
	return (linesw[tp->t_line].l_read(tp, uio, flags));
d588 9
d599 2
a600 5
int
zswrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d602 1
a602 4
	register struct zs_chanstate *cs;
	register struct zs_softc *sc;
	register struct tty *tp;
	int unit = DEVUNIT(dev);
d604 4
a607 3
	sc = zs_cd.cd_devs[unit >> 1];
	cs = &sc->sc_cs[unit & 1];
	tp = cs->cs_ttyp;
d609 6
a614 1
	return (linesw[tp->t_line].l_write(tp, uio, flags));
d617 2
a618 3
struct tty *
zstty(dev)
	dev_t dev;
d620 1
a620 3
	register struct zs_chanstate *cs;
	register struct zs_softc *sc;
	int unit = DEVUNIT(dev);
d622 4
a625 2
	sc = zs_cd.cd_devs[unit >> 1];
	cs = &sc->sc_cs[unit & 1];
d627 6
a632 1
	return (cs->cs_ttyp);
d635 9
a643 3
static int zsrint(struct zs_chanstate *, volatile struct zschan *);
static int zsxint(struct zs_chanstate *, volatile struct zschan *);
static int zssint(struct zs_chanstate *, volatile struct zschan *);
d646 1
a646 9
 * ZS hardware interrupt.  Scan all ZS channels.  NB: we know here that
 * channels are kept in (A,B) pairs.
 *
 * Do just a little, then get out; set a software interrupt if more
 * work is needed.
 *
 * We deliberately ignore the vectoring Zilog gives us, and match up
 * only the number of `reset interrupt under service' operations, not
 * the order.
d648 3
a650 4
/* ARGSUSED */
int
zshard(intrarg)
	void *intrarg;
d652 2
a653 4
	struct zs_chanstate *a;
#define	b (a + 1)
	volatile struct zschan *zc;
	int rr3, intflags = 0, v, i, ringmask;
d655 6
a660 51
#define ZSHARD_NEED_SOFTINTR	1
#define ZSHARD_WAS_SERVICED	2
#define ZSHARD_CHIP_GOTINTR	4

	for (a = zslist; a != NULL; a = b->cs_next) {
		ringmask = a->cs_ringmask;
		rr3 = ZS_READ(a->cs_zc, 3);
		if (rr3)
			intflags |= ZSHARD_WAS_SERVICED;
		if (rr3 & (ZSRR3_IP_A_RX|ZSRR3_IP_A_TX|ZSRR3_IP_A_STAT)) {
			intflags |= (ZSHARD_CHIP_GOTINTR|ZSHARD_WAS_SERVICED);
			zc = a->cs_zc;
			i = a->cs_rbput;
			if (rr3 & ZSRR3_IP_A_RX && (v = zsrint(a, zc)) != 0) {
				a->cs_rbuf[i++ & ringmask] = v;
				intflags |= ZSHARD_NEED_SOFTINTR;
			}
			if (rr3 & ZSRR3_IP_A_TX && (v = zsxint(a, zc)) != 0) {
				a->cs_rbuf[i++ & ringmask] = v;
				intflags |= ZSHARD_NEED_SOFTINTR;
			}
			if (rr3 & ZSRR3_IP_A_STAT && (v = zssint(a, zc)) != 0) {
				a->cs_rbuf[i++ & ringmask] = v;
				intflags |= ZSHARD_NEED_SOFTINTR;
			}
			a->cs_rbput = i;
		}
		if (rr3 & (ZSRR3_IP_B_RX|ZSRR3_IP_B_TX|ZSRR3_IP_B_STAT)) {
			intflags |= (ZSHARD_CHIP_GOTINTR|ZSHARD_WAS_SERVICED);
			zc = b->cs_zc;
			i = b->cs_rbput;
			if (rr3 & ZSRR3_IP_B_RX && (v = zsrint(b, zc)) != 0) {
				b->cs_rbuf[i++ & ringmask] = v;
				intflags |= ZSHARD_NEED_SOFTINTR;
			}
			if (rr3 & ZSRR3_IP_B_TX && (v = zsxint(b, zc)) != 0) {
				b->cs_rbuf[i++ & ringmask] = v;
				intflags |= ZSHARD_NEED_SOFTINTR;
			}
			if (rr3 & ZSRR3_IP_B_STAT && (v = zssint(b, zc)) != 0) {
				b->cs_rbuf[i++ & ringmask] = v;
				intflags |= ZSHARD_NEED_SOFTINTR;
			}
			b->cs_rbput = i;
		}
		if (intflags & ZSHARD_CHIP_GOTINTR) {
			a->cs_sc->sc_intrcnt.ev_count++;
			intflags &= ~ZSHARD_CHIP_GOTINTR;
		}
	}
#undef b
d662 5
a666 20
	if (intflags & ZSHARD_NEED_SOFTINTR) {
#if 0		/*
		 * seems to break things and will not work when spl* are
		 * converted to be only raising.
		 */
		if (CPU_ISSUN4COR4M) {
			/* XXX -- but this will go away when zshard moves to locore.s */
			struct clockframe *p = intrarg;

			if ((p->psr & PSR_PIL) < (IPL_TTY << 8)) {
				zsshortcuts++;
				(void) spltty();
				if (zshardscope) {
					LED_ON;
					LED_OFF;
				}
				return (zssoft(intrarg));
			}
		}
#endif
d668 2
a669 3
#if defined(SUN4M)
		if (CPU_ISSUN4M)
			raise(0, IPL_TTY);
d671 6
a677 3
		ienab_bis(IE_ZSSOFT);
	}
	return (intflags & ZSHARD_WAS_SERVICED) ? 1 : -1 /* XXX */;
d680 6
a685 4
static int
zsrint(cs, zc)
	register struct zs_chanstate *cs;
	register volatile struct zschan *zc;
d687 2
a688 1
	register u_int c = zc->zc_data;
d690 6
a695 3
	ZS_DELAY();
	if (cs->cs_conk) {
		register struct conk_state *conk = &zsconk_state;
d697 1
a697 35
		/*
		 * Check here for console abort function, so that we
		 * can abort even when interrupts are locking up the
		 * machine.
		 */
		if (c == KBD_RESET) {
			conk->conk_id = 1;	/* ignore next byte */
			conk->conk_l1 = 0;
		} else if (conk->conk_id)
			conk->conk_id = 0;	/* stop ignoring bytes */
		else if (c == KBD_L1)
			conk->conk_l1 = 1;	/* L1 went down */
		else if (c == (KBD_L1|KBD_UP))
			conk->conk_l1 = 0;	/* L1 went up */
		else if (c == KBD_A && conk->conk_l1) {
			zsabort(cs->cs_unit);
			conk->conk_l1 = 0;	/* we never see the up */
			goto clearit;		/* eat the A after L1-A */
		}
	}
#ifdef KGDB
	if (c == FRAME_START && cs->cs_kgdb &&
	    (cs->cs_ttyp->t_state & TS_ISOPEN) == 0) {
		zskgdb(cs->cs_unit);
		goto clearit;
	}
#endif
	/* compose receive character and status */
	c <<= 8;
	c |= ZS_READ(zc, 1);

	/* clear receive error & interrupt condition */
	zc->zc_csr = ZSWR0_RESET_ERRORS;
	ZS_DELAY();
	zc->zc_csr = ZSWR0_CLR_INTR;
d699 1
d701 6
a706 1
	return (ZRING_MAKE(ZRING_RINT, c));
d708 10
a717 7
clearit:
	zc->zc_csr = ZSWR0_RESET_ERRORS;
	ZS_DELAY();
	zc->zc_csr = ZSWR0_CLR_INTR;
	ZS_DELAY();
	return (0);
}
d719 4
a722 18
static int
zsxint(cs, zc)
	register struct zs_chanstate *cs;
	register volatile struct zschan *zc;
{
	register int i = cs->cs_tbc;

	if (cs->cs_deferred_cc != 0) {
		/* Handle deferred zscnputc() output first */
		zc->zc_data = cs->cs_deferred_cc;
		cs->cs_deferred_cc = 0;
		ZS_DELAY();
		zc->zc_csr = ZSWR0_CLR_INTR;
		ZS_DELAY();
		return (0);
	}
	if (i == 0) {
		zc->zc_csr = ZSWR0_RESET_TXINT;
d724 1
a724 18
		zc->zc_csr = ZSWR0_CLR_INTR;
		ZS_DELAY();
		return (ZRING_MAKE(ZRING_XINT, 0));
	}
	cs->cs_tbc = i - 1;
	zc->zc_data = *cs->cs_tba++;
	ZS_DELAY();
	zc->zc_csr = ZSWR0_CLR_INTR;
	ZS_DELAY();
	return (0);
}

static int
zssint(cs, zc)
	register struct zs_chanstate *cs;
	register volatile struct zschan *zc;
{
	register u_int rr0;
a725 6
	rr0 = zc->zc_csr;
	ZS_DELAY();
	zc->zc_csr = ZSWR0_RESET_STATUS;
	ZS_DELAY();
	zc->zc_csr = ZSWR0_CLR_INTR;
	ZS_DELAY();
d727 7
a733 5
	 * The chip's hardware flow control is, as noted in zsreg.h,
	 * busted---if the DCD line goes low the chip shuts off the
	 * receiver (!).  If we want hardware CTS flow control but do
	 * not have it, and carrier is now on, turn HFC on; if we have
	 * HFC now but carrier has gone low, turn it off.
d735 4
a738 25
	if (rr0 & ZSRR0_DCD) {
		if (cs->cs_ttyp->t_cflag & CCTS_OFLOW &&
		    (cs->cs_creg[3] & ZSWR3_HFC) == 0) {
			cs->cs_creg[3] |= ZSWR3_HFC;
			ZS_WRITE(zc, 3, cs->cs_creg[3]);
		}
	} else {
		if (cs->cs_creg[3] & ZSWR3_HFC) {
			cs->cs_creg[3] &= ~ZSWR3_HFC;
			ZS_WRITE(zc, 3, cs->cs_creg[3]);
		}
	}
	if ((rr0 & ZSRR0_BREAK) && cs->cs_brkabort) {
		/*
		 * XXX This might not be necessary. Test and
		 * delete if it isn't.
		 */
		if (CPU_ISSUN4) {
			while (zc->zc_csr & ZSRR0_BREAK)
				ZS_DELAY();
		}
		zsabort(cs->cs_unit);
		return (0);
	}
	return (ZRING_MAKE(ZRING_SINT, rr0));
d741 1
a741 4
void
zsabort(unit)
	int unit;
{
d743 1
a743 10
#if defined(KGDB)
	zskgdb(unit);
#elif defined(DDB)
	if (db_console)
		Debugger();
#else
	printf("stopping on keyboard abort\n");
	callrom();
#endif
}
a744 1
#ifdef KGDB
d746 1
a746 2
 * KGDB framing character received: enter kernel debugger.  This probably
 * should time out after a few seconds to avoid hanging on spurious input.
d748 10
d759 2
a760 2
zskgdb(unit)
	int unit;
d762 3
d766 4
a769 2
	printf("zs%d%c: kgdb interrupt\n", unit >> 1, (unit & 1) + 'a');
	kgdb_connect(1);
a770 1
#endif
d773 1
a773 1
 * Print out a ring or fifo overrun error message.
d775 3
a777 5
static void
zsoverrun(unit, ptime, what)
	int unit;
	long *ptime;
	char *what;
d779 1
a779 6

	if (*ptime != time.tv_sec) {
		*ptime = time.tv_sec;
		log(LOG_WARNING, "zs%d%c: %s overrun\n", unit >> 1,
		    (unit & 1) + 'a', what);
	}
d783 1
a783 1
 * ZS software interrupt.  Scan all channels for deferred interrupts.
d785 4
a788 3
int
zssoft(arg)
	void *arg;
d790 1
a790 123
	register struct zs_chanstate *cs;
	register volatile struct zschan *zc;
	register struct linesw *line;
	register struct tty *tp;
	register int get, n, c, cc, unit, s, ringmask, ringsize;
	int	retval = 0;

	for (cs = zslist; cs != NULL; cs = cs->cs_next) {
		ringmask = cs->cs_ringmask;
		get = cs->cs_rbget;
again:
		n = cs->cs_rbput;	/* atomic */
		if (get == n)		/* nothing more on this line */
			continue;
		retval = 1;
		unit = cs->cs_unit;	/* set up to handle interrupts */
		zc = cs->cs_zc;
		tp = cs->cs_ttyp;
		line = &linesw[tp->t_line];
		/*
		 * Compute the number of interrupts in the receive ring.
		 * If the count is overlarge, we lost some events, and
		 * must advance to the first valid one.  It may get
		 * overwritten if more data are arriving, but this is
		 * too expensive to check and gains nothing (we already
		 * lost out; all we can do at this point is trade one
		 * kind of loss for another).
		 */
		ringsize = ringmask + 1;
		n -= get;
		if (n > ringsize) {
			zsoverrun(unit, &cs->cs_rotime, "ring");
			get += n - ringsize;
			n = ringsize;
		}
		while (--n >= 0) {
			/* race to keep ahead of incoming interrupts */
			c = cs->cs_rbuf[get++ & ringmask];
			switch (ZRING_TYPE(c)) {

			case ZRING_RINT:
				c = ZRING_VALUE(c);
				if (c & ZSRR1_DO)
					zsoverrun(unit, &cs->cs_fotime, "fifo");
				cc = c >> 8;
				if (c & ZSRR1_FE)
					cc |= TTY_FE;
				if (c & ZSRR1_PE)
					cc |= TTY_PE;
				/*
				 * this should be done through
				 * bstreams	XXX gag choke
				 */
				if (unit == ZS_KBD)
#if	NKBD > 0
					kbd_rint(cc);
#else
					;
#endif
				else if (unit == ZS_MOUSE)
					ms_rint(cc);
				else
					line->l_rint(cc, tp);
				break;

			case ZRING_XINT:
				/*
				 * Transmit done: change registers and resume,
				 * or clear BUSY.
				 */
				if (cs->cs_heldchange) {
					s = splzs();
					c = zc->zc_csr;
					ZS_DELAY();
					if ((c & ZSRR0_DCD) == 0)
						cs->cs_preg[3] &= ~ZSWR3_HFC;
					bcopy((caddr_t)cs->cs_preg,
					    (caddr_t)cs->cs_creg, 16);
					zs_loadchannelregs(zc, cs->cs_creg);
					splx(s);
					cs->cs_heldchange = 0;
					if (cs->cs_heldtbc &&
					    (tp->t_state & TS_TTSTOP) == 0) {
						cs->cs_tbc = cs->cs_heldtbc - 1;
						zc->zc_data = *cs->cs_tba++;
						ZS_DELAY();
						goto again;
					}
				}
				tp->t_state &= ~TS_BUSY;
				if (tp->t_state & TS_FLUSH)
					tp->t_state &= ~TS_FLUSH;
				else
					ndflush(&tp->t_outq,
					 cs->cs_tba - (caddr_t)tp->t_outq.c_cf);
				line->l_start(tp);
				break;

			case ZRING_SINT:
				/*
				 * Status line change.  HFC bit is run in
				 * hardware interrupt, to avoid locking
				 * at splzs here.
				 */
				c = ZRING_VALUE(c);
				if ((c ^ cs->cs_rr0) & ZSRR0_DCD) {
					cc = (c & ZSRR0_DCD) != 0;
					if (line->l_modem(tp, cc) == 0)
						zs_modem(cs, cc);
				}
				cs->cs_rr0 = c;
				break;

			default:
				log(LOG_ERR, "zs%d%c: bad ZRING_TYPE (0x%x)\n",
				    unit >> 1, (unit & 1) + 'a', c);
				break;
			}
		}
		cs->cs_rbget = get;
		goto again;
	}
	return (retval);
d793 4
a796 2
int
zsioctl(dev, cmd, data, flag, p)
d798 8
a805 35
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int unit = DEVUNIT(dev);
	struct zs_softc *sc = zs_cd.cd_devs[unit >> 1];
	register struct zs_chanstate *cs = &sc->sc_cs[unit & 1];
	register struct tty *tp = cs->cs_ttyp;
	register int error, s;

	error = linesw[tp->t_line].l_ioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);
	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	switch (cmd) {
	case TIOCSBRK:
		s = splzs();
		cs->cs_preg[5] |= ZSWR5_BREAK;
		cs->cs_creg[5] |= ZSWR5_BREAK;
		ZS_WRITE(cs->cs_zc, 5, cs->cs_creg[5]);
		splx(s);
		break;
	case TIOCCBRK:
		s = splzs();
		cs->cs_preg[5] &= ~ZSWR5_BREAK;
		cs->cs_creg[5] &= ~ZSWR5_BREAK;
		ZS_WRITE(cs->cs_zc, 5, cs->cs_creg[5]);
		splx(s);
		break;
	case TIOCGFLAGS: {
		int bits = 0;
d807 3
a809 11
		if (cs->cs_softcar)
			bits |= TIOCFLAG_SOFTCAR;
		if (cs->cs_creg[15] & ZSWR15_DCD_IE)
			bits |= TIOCFLAG_CLOCAL;
		if (cs->cs_creg[3] & ZSWR3_HFC)
			bits |= TIOCFLAG_CRTSCTS;
		*(int *)data = bits;
		break;
	}
	case TIOCSFLAGS: {
		int userbits;
d811 1
a811 3
		error = suser(p->p_ucred, &p->p_acflag);
		if (error != 0)
			return (EPERM);
d813 1
a813 1
		userbits = *(int *)data;
d815 12
a826 81
		/*
		 * can have `local' or `softcar', and `rtscts' or `mdmbuf'
		 # defaulting to software flow control.
		 */
		if (userbits & TIOCFLAG_SOFTCAR && userbits & TIOCFLAG_CLOCAL)
			return(EINVAL);
		if (userbits & TIOCFLAG_MDMBUF)	/* don't support this (yet?) */
			return(ENXIO);

		s = splzs();
		if ((userbits & TIOCFLAG_SOFTCAR) || cs->cs_consio) {
			cs->cs_softcar = 1;	/* turn on softcar */
			cs->cs_preg[15] &= ~ZSWR15_DCD_IE; /* turn off dcd */
			cs->cs_creg[15] &= ~ZSWR15_DCD_IE;
			ZS_WRITE(cs->cs_zc, 15, cs->cs_creg[15]);
		} else if (userbits & TIOCFLAG_CLOCAL) {
			cs->cs_softcar = 0; 	/* turn off softcar */
			cs->cs_preg[15] |= ZSWR15_DCD_IE; /* turn on dcd */
			cs->cs_creg[15] |= ZSWR15_DCD_IE;
			ZS_WRITE(cs->cs_zc, 15, cs->cs_creg[15]);
			tp->t_termios.c_cflag |= CLOCAL;
		}
		if (userbits & TIOCFLAG_CRTSCTS) {
			cs->cs_preg[15] |= ZSWR15_CTS_IE;
			cs->cs_creg[15] |= ZSWR15_CTS_IE;
			ZS_WRITE(cs->cs_zc, 15, cs->cs_creg[15]);
			cs->cs_preg[3] |= ZSWR3_HFC;
			cs->cs_creg[3] |= ZSWR3_HFC;
			ZS_WRITE(cs->cs_zc, 3, cs->cs_creg[3]);
			tp->t_termios.c_cflag |= CRTSCTS;
		} else {
			/* no mdmbuf, so we must want software flow control */
			cs->cs_preg[15] &= ~ZSWR15_CTS_IE;
			cs->cs_creg[15] &= ~ZSWR15_CTS_IE;
			ZS_WRITE(cs->cs_zc, 15, cs->cs_creg[15]);
			cs->cs_preg[3] &= ~ZSWR3_HFC;
			cs->cs_creg[3] &= ~ZSWR3_HFC;
			ZS_WRITE(cs->cs_zc, 3, cs->cs_creg[3]);
			tp->t_termios.c_cflag &= ~CRTSCTS;
		}
		splx(s);
		break;
	}
	case TIOCSDTR:
		zs_modem(cs, 1);
		break;
	case TIOCCDTR:
		zs_modem(cs, 0);
		break;
	case TIOCMSET:
		tiocm_to_zs(cs, TIOCMSET, *(int *)data);
		break;
	case TIOCMBIS:
		tiocm_to_zs(cs, TIOCMBIS, *(int *)data);
		break;
	case TIOCMBIC:
		tiocm_to_zs(cs, TIOCMBIC, *(int *)data);
		break;
	case TIOCMGET: {
		int bits = 0;
		u_char m;

		m = cs->cs_preg[5];
		if (ISSET(m, ZSWR5_DTR))
			SET(bits, TIOCM_DTR);
		if (ISSET(m, ZSWR5_RTS))
			SET(bits, TIOCM_RTS);

		m = cs->cs_zc->zc_csr;
		if (m & ZSRR0_DCD)
			SET(bits, TIOCM_CD);
		if (m & ZSRR0_CTS)
			SET(bits, TIOCM_CTS);
		*(int *)data = bits;
		break;
	}
	default:
		return (ENOTTY);
	}
	return (0);
}
d829 3
a831 1
 * Start or restart transmission.
d833 1
a833 8
static void
zsstart(tp)
	register struct tty *tp;
{
	register struct zs_chanstate *cs;
	register int s, ss, nch;
	int unit = DEVUNIT(tp->t_dev);
	struct zs_softc *sc = zs_cd.cd_devs[unit >> 1];
d835 7
a841 2
	cs = &sc->sc_cs[unit & 1];
	s = spltty();
d843 4
a846 44
	/*
	 * If currently active or delaying, no need to do anything.
	 */
	if (tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP))
		goto out;

	/*
	 * If there are sleepers, and output has drained below low
	 * water mark, awaken.
	 */
	if (tp->t_outq.c_cc <= tp->t_lowat) {
		if (tp->t_state & TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
	}

	nch = ndqb(&tp->t_outq, 0);	/* XXX */
	ss = splzs();
	if (nch) {
		register char *p = tp->t_outq.c_cf;

		/* mark busy, enable tx done interrupts, & send first byte */
		tp->t_state |= TS_BUSY;
		cs->cs_preg[1] |= ZSWR1_TIE;
		cs->cs_creg[1] |= ZSWR1_TIE;
		ZS_WRITE(cs->cs_zc, 1, cs->cs_creg[1]);
		cs->cs_zc->zc_data = *p;
		ZS_DELAY();
		cs->cs_tba = p + 1;
		cs->cs_tbc = nch - 1;
	} else {
		/*
		 * Nothing to send, turn off transmit done interrupts.
		 * This is useful if something is doing polled output.
		 */
		cs->cs_preg[1] &= ~ZSWR1_TIE;
		cs->cs_creg[1] &= ~ZSWR1_TIE;
		ZS_WRITE(cs->cs_zc, 1, cs->cs_creg[1]);
	}
	splx(ss);
out:
	splx(s);
d850 1
a850 1
 * Stop output, e.g., for ^S or output flush.
d853 4
a856 7
zsstop(tp, flag)
	register struct tty *tp;
	int flag;
{
	register struct zs_chanstate *cs;
	register int s, unit = DEVUNIT(tp->t_dev);
	struct zs_softc *sc = zs_cd.cd_devs[unit >> 1];
d858 10
a867 13
	cs = &sc->sc_cs[unit & 1];
	s = splzs();
	if (tp->t_state & TS_BUSY) {
		/*
		 * Device is transmitting; must stop it.
		 */
		cs->cs_tbc = 0;
		if ((tp->t_state & TS_TTSTOP) == 0)
			tp->t_state |= TS_FLUSH;
	}
	splx(s);
	return 0;
}
d869 18
a886 35
/*
 * Set ZS tty parameters from termios.
 *
 * This routine makes use of the fact that only registers
 * 1, 3, 4, 5, 9, 10, 11, 12, 13, 14, and 15 are written.
 */
static int
zsparam(tp, t)
	register struct tty *tp;
	register struct termios *t;
{
	int unit = DEVUNIT(tp->t_dev);
	struct zs_softc *sc = zs_cd.cd_devs[unit >> 1];
	register struct zs_chanstate *cs = &sc->sc_cs[unit & 1];
	register int tmp, tmp5, cflag, s;

	/*
	 * Because PCLK is only run at 4.9 MHz, the fastest we
	 * can go is 51200 baud (this corresponds to TC=1).
	 * This is somewhat unfortunate as there is no real
	 * reason we should not be able to handle higher rates.
	 */
	tmp = t->c_ospeed;
	if (tmp < 0 || (t->c_ispeed && t->c_ispeed != tmp))
		return (EINVAL);
	if (tmp == 0) {
		/* stty 0 => drop DTR and RTS */
		zs_modem(cs, 0);
		return (0);
	}
	tmp = BPS_TO_TCONST(PCLK / 16, tmp);
#ifdef ALLOW_TC_EQUAL_ZERO
	if (tmp < 0)
#else
	if (tmp < 1)
d888 1
a888 44
		return (EINVAL);

	cflag = t->c_cflag;
	tp->t_ispeed = tp->t_ospeed = TCONST_TO_BPS(PCLK / 16, tmp);
	tp->t_cflag = cflag;

	/*
	 * Block interrupts so that state will not
	 * be altered until we are done setting it up.
	 */
	s = splzs();
	cs->cs_preg[12] = tmp;
	cs->cs_preg[13] = tmp >> 8;
	cs->cs_preg[1] = ZSWR1_RIE | ZSWR1_TIE | ZSWR1_SIE;
	switch (cflag & CSIZE) {
	case CS5:
		tmp = ZSWR3_RX_5;
		tmp5 = ZSWR5_TX_5;
		break;
	case CS6:
		tmp = ZSWR3_RX_6;
		tmp5 = ZSWR5_TX_6;
		break;
	case CS7:
		tmp = ZSWR3_RX_7;
		tmp5 = ZSWR5_TX_7;
		break;
	case CS8:
	default:
		tmp = ZSWR3_RX_8;
		tmp5 = ZSWR5_TX_8;
		break;
	}

	/*
	 * Output hardware flow control on the chip is horrendous: if
	 * carrier detect drops, the receiver is disabled.  Hence we
	 * can only do this when the carrier is on.
	 */
	tmp |= ZSWR3_RX_ENABLE;
	if (cflag & CCTS_OFLOW) {
		if (cs->cs_zc->zc_csr & ZSRR0_DCD)
			tmp |= ZSWR3_HFC;
		ZS_DELAY();
a889 2
	cs->cs_preg[3] = tmp;
	cs->cs_preg[5] = tmp5 | ZSWR5_TX_ENABLE | ZSWR5_DTR | ZSWR5_RTS;
d891 2
a892 11
	tmp = ZSWR4_CLK_X16 | (cflag & CSTOPB ? ZSWR4_TWOSB : ZSWR4_ONESB);
	if ((cflag & PARODD) == 0)
		tmp |= ZSWR4_EVENP;
	if (cflag & PARENB)
		tmp |= ZSWR4_PARENB;
	cs->cs_preg[4] = tmp;
	cs->cs_preg[9] = ZSWR9_MASTER_IE | ZSWR9_NO_VECTOR;
	cs->cs_preg[10] = ZSWR10_NRZ;
	cs->cs_preg[11] = ZSWR11_TXCLK_BAUD | ZSWR11_RXCLK_BAUD;
	cs->cs_preg[14] = ZSWR14_BAUD_FROM_PCLK | ZSWR14_BAUD_ENA;
	cs->cs_preg[15] = ZSWR15_BREAK_IE | ZSWR15_DCD_IE;
d894 1
a894 16
	/*
	 * If nothing is being transmitted, set up new current values,
	 * else mark them as pending.
	 */
	if (cs->cs_heldchange == 0) {
		if (cs->cs_ttyp->t_state & TS_BUSY) {
			cs->cs_heldtbc = cs->cs_tbc;
			cs->cs_tbc = 0;
			cs->cs_heldchange = 1;
		} else {
			bcopy((caddr_t)cs->cs_preg, (caddr_t)cs->cs_creg, 16);
			zs_loadchannelregs(cs->cs_zc, cs->cs_creg);
		}
	}
	splx(s);
	return (0);
d898 1
a898 2
 * Raise or lower modem control (DTR/RTS) signals.  If a character is
 * in transmission, the change is deferred.
d900 4
a903 4
static void
zs_modem(cs, onoff)
	struct zs_chanstate *cs;
	int onoff;
d905 2
a906 1
	int s, bis, and;
d908 6
a913 19
	if (onoff) {
		bis = ZSWR5_DTR | ZSWR5_RTS;
		and = ~0;
	} else {
		bis = 0;
		and = ~(ZSWR5_DTR | ZSWR5_RTS);
	}
	s = splzs();
	cs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;
	if (cs->cs_heldchange == 0) {
		if (cs->cs_ttyp->t_state & TS_BUSY) {
			cs->cs_heldtbc = cs->cs_tbc;
			cs->cs_tbc = 0;
			cs->cs_heldchange = 1;
		} else {
			cs->cs_creg[5] = (cs->cs_creg[5] | bis) & and;
			ZS_WRITE(cs->cs_zc, 5, cs->cs_creg[5]);
		}
	}
d917 11
d929 3
a931 3
 * Write the given register set to the given zs channel in the proper order.
 * The channel must not be transmitting at the time.  The receiver will
 * be disabled for the time it takes to write all the registers.
d933 2
a934 4
static void
zs_loadchannelregs(zc, reg)
	volatile struct zschan *zc;
	u_char *reg;
d936 24
a959 1
	int i;
d961 1
a961 22
	zc->zc_csr = ZSM_RESET_ERR;	/* reset error condition */
	ZS_DELAY();
	i = zc->zc_data;		/* drain fifo */
	ZS_DELAY();
	i = zc->zc_data;
	ZS_DELAY();
	i = zc->zc_data;
	ZS_DELAY();
	ZS_WRITE(zc, 4, reg[4]);
	ZS_WRITE(zc, 10, reg[10]);
	ZS_WRITE(zc, 3, reg[3] & ~ZSWR3_RX_ENABLE);
	ZS_WRITE(zc, 5, reg[5] & ~ZSWR5_TX_ENABLE);
	ZS_WRITE(zc, 1, reg[1]);
	ZS_WRITE(zc, 9, reg[9]);
	ZS_WRITE(zc, 11, reg[11]);
	ZS_WRITE(zc, 12, reg[12]);
	ZS_WRITE(zc, 13, reg[13]);
	ZS_WRITE(zc, 14, reg[14]);
	ZS_WRITE(zc, 15, reg[15]);
	ZS_WRITE(zc, 3, reg[3]);
	ZS_WRITE(zc, 5, reg[5]);
}
d963 45
a1007 7
static void
tiocm_to_zs(cs, how, val)
	struct zs_chanstate *cs;
	int how, val;
{
	int s;
	u_char bits = 0;
d1009 1
a1009 4
	if (ISSET(val,TIOCM_DTR))
		SET(bits, ZSWR5_DTR);
	if (ISSET(val,TIOCM_RTS))
		SET(bits, ZSWR5_RTS);
d1011 32
a1042 24
	s = splzs();
	switch (how) {
		case TIOCMBIC:
			CLR(cs->cs_preg[5], bits);
			break;

		case TIOCMBIS:
			SET(cs->cs_preg[5], bits);
			break;

		case TIOCMSET:
			CLR(cs->cs_preg[5], ZSWR5_RTS | ZSWR5_DTR);
			SET(cs->cs_preg[5], bits);
			break;
	}

	if (cs->cs_heldchange == 0) {
		if (cs->cs_ttyp->t_state & TS_BUSY) {
			cs->cs_heldtbc = cs->cs_tbc; 
			cs->cs_tbc = 0;
			cs->cs_heldchange = 1;
		} else {
			cs->cs_creg[5] = cs->cs_preg[5];
			ZS_WRITE(cs->cs_zc, 5, cs->cs_creg[5]);
d1044 3
a1047 1
	splx(s);
d1049 1
a1049 1
}
d1051 3
a1053 10
#ifdef KGDB
/*
 * Get a character from the given kgdb channel.  Called at splhigh().
 */
static int
zs_kgdb_getc(arg)
	void *arg;
{
	register volatile struct zschan *zc = (volatile struct zschan *)arg;
	u_char c;
d1055 26
a1080 6
	while ((zc->zc_csr & ZSRR0_RX_READY) == 0)
		ZS_DELAY();
	c = zc->zc_data;
	ZS_DELAY();
	return c;
}
d1082 3
a1084 26
/*
 * Put a character to the given kgdb channel.  Called at splhigh().
 */
static void
zs_kgdb_putc(arg, c)
	void *arg;
	int c;
{
	register volatile struct zschan *zc = (volatile struct zschan *)arg;

	while ((zc->zc_csr & ZSRR0_TX_READY) == 0)
		ZS_DELAY();
	zc->zc_data = c;
	ZS_DELAY();
}

/*
 * Set up for kgdb; called at boot time before configuration.
 * KGDB interrupts will be enabled later when zs0 is configured.
 */
void
zs_kgdb_init()
{
	volatile struct zsdevice *addr;
	volatile struct zschan *zc;
	int unit, zs;
d1086 3
a1088 8
	if (major(kgdb_dev) != ZSMAJOR)
		return;
	unit = DEVUNIT(kgdb_dev);
	/*
	 * Unit must be 0 or 1 (zs0).
	 */
	if ((unsigned)unit >= ZS_KBD) {
		printf("zs_kgdb_init: bad minor dev %d\n", unit);
d1091 9
a1099 10
	zs = unit >> 1;
	if ((addr = zsaddr[zs]) == NULL)
		addr = zsaddr[zs] = (volatile struct zsdevice *)findzs(zs);
	unit &= 1;
	zc = unit == 0 ? &addr->zs_chan[ZS_CHAN_A] : &addr->zs_chan[ZS_CHAN_B];
	zs_kgdb_savedspeed = zs_getspeed(zc);
	printf("zs_kgdb_init: attaching zs%d%c at %d baud\n",
	    zs, unit + 'a', kgdb_rate);
	zs_reset(zc, 1, kgdb_rate);
	kgdb_attach(zs_kgdb_getc, zs_kgdb_putc, (void *)zc);
a1100 1
#endif /* KGDB */
@


1.34
log
@Rename all PIL_* constants to IPL_* to match other archs and make them
usable in MD code in the future.
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.33 2002/03/14 01:26:43 millert Exp $	*/
d299 2
a300 2
		intr_establish(pri, &levelhard);
		intr_establish(IPL_TTY, &levelsoft);
@


1.33
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.32 2002/03/13 00:24:21 miod Exp $	*/
d107 1
a107 1
#if PIL_TTY == 1
d109 1
a109 1
#elif PIL_TTY == 4
d111 1
a111 1
#elif PIL_TTY == 6
d295 1
a295 1
	printf(" pri %d, softpri %d\n", pri, PIL_TTY);
d300 1
a300 1
		intr_establish(PIL_TTY, &levelsoft);
d942 1
a942 1
			if ((p->psr & PSR_PIL) < (PIL_TTY << 8)) {
d956 1
a956 1
			raise(0, PIL_TTY);
@


1.32
log
@On sparc, PAGE_SIZE and friends might not be a compile-time constant.
Instead of using a homegrown set of variables in this case, rely on uvmexp
fields once uvm has been initialized.

This requires a few #include <uvm/uvm_extern.h> here and there in the kernel
as well.

Idea from art@@, changes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.31 2002/01/30 20:45:34 nordin Exp $	*/
d128 2
a129 2
static int	zsmatch __P((struct device *, void *, void *));
static void	zsattach __P((struct device *, struct device *, void *));
d140 1
a140 1
static int	zshard __P((void *));
d142 1
a142 1
static int	zssoft __P((void *));
d148 4
a151 4
static void	zsiopen __P((struct tty *));
static void	zsiclose __P((struct tty *));
static void	zsstart __P((struct tty *));
static int	zsparam __P((struct tty *, struct termios *));
d154 1
a154 1
static int	zs_getspeed __P((volatile struct zschan *));
d156 1
a156 1
static void	zs_reset __P((volatile struct zschan *, int, int));
d158 3
a160 3
static void	zs_modem __P((struct zs_chanstate *, int));
static void	zs_loadchannelregs __P((volatile struct zschan *, u_char *));
static void	tiocm_to_zs __P((struct zs_chanstate *, int how, int data));
d166 1
a166 1
static void zscnputc __P((int));	/* console putc function */
d168 2
a169 2
static struct tty *zs_checkcons __P((struct zs_softc *, int,
    struct zs_chanstate *));
d175 4
a178 4
static void zs_checkkgdb __P((int, struct zs_chanstate *, struct tty *));
void zskgdb __P((int));
static int zs_kgdb_getc __P((void *));
static void zs_kgdb_putc __P((void *, int));
d181 3
a183 3
static int zsrint __P((struct zs_chanstate *, volatile struct zschan *));
static int zsxint __P((struct zs_chanstate *, volatile struct zschan *));
static int zssint __P((struct zs_chanstate *, volatile struct zschan *));
d185 2
a186 2
void zsabort __P((int));
static void zsoverrun __P((int, long *, char *));
d206 2
a207 2
static u_int zs_read __P((volatile struct zschan *, u_int reg));
static u_int zs_write __P((volatile struct zschan *, u_int, u_int));
d448 1
a448 1
	int (**fnstop) __P((struct tty *, int));
d856 3
a858 3
static int zsrint __P((struct zs_chanstate *, volatile struct zschan *));
static int zsxint __P((struct zs_chanstate *, volatile struct zschan *));
static int zssint __P((struct zs_chanstate *, volatile struct zschan *));
@


1.31
log
@Move SET/CLR/ISSET macros to param.h. fgsch@@ and millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.30 2002/01/10 00:06:17 nordin Exp $	*/
d75 2
@


1.30
log
@Check result from malloc(9) when using M_NOWAIT. jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.29 2001/10/05 21:13:51 jason Exp $	*/
a92 5

/* Macros to clear/set/test flags. */
#define SET(t, f)       (t) |= (f)
#define CLR(t, f)       (t) &= ~(f)
#define ISSET(t, f)     ((t) & (f))
@


1.29
log
@grr, I had this right to begin with... NOW X10 firecracker works.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.28 2001/10/05 05:03:59 jason Exp $	*/
d356 2
d395 2
@


1.29.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.31 2002/01/30 20:45:34 nordin Exp $	*/
d94 5
a355 2
	if (cs->cs_rbuf == NULL)
		panic("zsattach");
a392 2
	if (cs->cs_rbuf == NULL)
		panic("zsattach");
@


1.29.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.29.4.1 2002/01/31 22:55:22 niklas Exp $	*/
a75 2
#include <uvm/uvm_extern.h>

d105 1
a105 1
#if IPL_TTY == 1
d107 1
a107 1
#elif IPL_TTY == 4
d109 1
a109 1
#elif IPL_TTY == 6
d126 2
a127 2
static int	zsmatch(struct device *, void *, void *);
static void	zsattach(struct device *, struct device *, void *);
d138 1
a138 1
static int	zshard(void *);
d140 1
a140 1
static int	zssoft(void *);
d146 4
a149 4
static void	zsiopen(struct tty *);
static void	zsiclose(struct tty *);
static void	zsstart(struct tty *);
static int	zsparam(struct tty *, struct termios *);
d152 1
a152 1
static int	zs_getspeed(volatile struct zschan *);
d154 1
a154 1
static void	zs_reset(volatile struct zschan *, int, int);
d156 3
a158 3
static void	zs_modem(struct zs_chanstate *, int);
static void	zs_loadchannelregs(volatile struct zschan *, u_char *);
static void	tiocm_to_zs(struct zs_chanstate *, int how, int data);
d164 1
a164 1
static void zscnputc(int);	/* console putc function */
d166 2
a167 2
static struct tty *zs_checkcons(struct zs_softc *, int,
    struct zs_chanstate *);
d173 4
a176 4
static void zs_checkkgdb(int, struct zs_chanstate *, struct tty *);
void zskgdb(int);
static int zs_kgdb_getc(void *);
static void zs_kgdb_putc(void *, int);
d179 3
a181 3
static int zsrint(struct zs_chanstate *, volatile struct zschan *);
static int zsxint(struct zs_chanstate *, volatile struct zschan *);
static int zssint(struct zs_chanstate *, volatile struct zschan *);
d183 2
a184 2
void zsabort(int);
static void zsoverrun(int, long *, char *);
d204 2
a205 2
static u_int zs_read(volatile struct zschan *, u_int reg);
static u_int zs_write(volatile struct zschan *, u_int, u_int);
d293 1
a293 1
	printf(" pri %d, softpri %d\n", pri, IPL_TTY);
d297 2
a298 2
		intr_establish(pri, &levelhard, IPL_ZS);
		intr_establish(IPL_TTY, &levelsoft, IPL_TTY);
d446 1
a446 1
	int (**fnstop)(struct tty *, int);
d854 3
a856 3
static int zsrint(struct zs_chanstate *, volatile struct zschan *);
static int zsxint(struct zs_chanstate *, volatile struct zschan *);
static int zssint(struct zs_chanstate *, volatile struct zschan *);
d940 1
a940 1
			if ((p->psr & PSR_PIL) < (IPL_TTY << 8)) {
d954 1
a954 1
			raise(0, IPL_TTY);
@


1.29.4.3
log
@sync to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: zs.c,v 1.50 1997/10/18 00:00:40 gwr Exp $	*/
d4 7
a10 3
/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
d12 4
a15 2
 * This code is derived from software contributed to The NetBSD Foundation
 * by Gordon W. Ross.
d27 5
a31 5
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d33 13
a45 11
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
d49 5
a53 1
 * Zilog Z8530 Dual UART driver (machine-dependent part)
d55 1
a55 3
 * Runs two serial lines per chip using slave drivers.
 * Plain tty/async lines use the zs_async slave.
 * Sun keyboard/mouse uses the zs_kbd/zs_ms slaves.
d57 2
d62 1
a62 1
#include <sys/conf.h>
d66 1
a66 2
#include <sys/kernel.h>
#include <sys/proc.h>
d69 1
d71 6
a78 1
#include <machine/bsd_openprom.h>
d81 1
a81 9
#include <machine/eeprom.h>
#if defined(SUN4)
#include <machine/oldmon.h>
#endif
#include <machine/psl.h>
#include <machine/z8530var.h>

#include <dev/cons.h>
#include <sparc/dev/z8530reg.h>
d85 2
a86 1
#include <sparc/dev/cons.h>
d88 4
a91 1
#include <uvm/uvm_extern.h>
d93 2
a94 2
#include "zskbd.h"
#include "zs.h"
d96 1
a96 5
/* Make life easier for the initialized arrays here. */
#if NZS < 3
#undef  NZS
#define NZS 3
#endif
d98 2
a99 7
/*
 * Some warts needed by z8530tty.c -
 * The default parity REALLY needs to be the same as the PROM uses,
 * or you can not see messages done with printf during boot-up...
 */
int zs_def_cflag = (CREAD | CS8 | HUPCL);
int zs_major = 12;
d101 2
a102 4
/*
 * The Sun provides a 4.9152 MHz clock to the ZS chips.
 */
#define PCLK	(9600 * 512)	/* PCLK pin input clock rate */
d117 8
a124 13
#define	ZS_DELAY()		(CPU_ISSUN4C ? (0) : delay(2))

/* The layout of this is hardware-dependent (padding, order). */
struct zschan {
	volatile u_char	zc_csr;		/* ctrl,status, and indirect access */
	u_char		zc_xxx0;
	volatile u_char	zc_data;	/* data */
	u_char		zc_xxx1;
};
struct zsdevice {
	/* Yes, they are backwards. */
	struct	zschan zs_chan_b;
	struct	zschan zs_chan_a;
d127 3
a129 2
/* Saved PROM mappings */
struct zsdevice *zsaddr[NZS];
d131 3
a133 2
/* Flags from cninit() */
int zs_hwflags[NZS][2];
d135 2
a136 8
/* Default speed for each channel */
int zs_defspeed[NZS][2] = {
	{ 9600, 	/* ttya */
	  9600 },	/* ttyb */
	{ 1200, 	/* keyboard */
	  1200 },	/* mouse */
	{ 9600, 	/* ttyc */
	  9600 },	/* ttyd */
d139 41
a179 18
u_char zs_init_reg[16] = {
	0,	/* 0: CMD (reset, etc.) */
	0,	/* 1: No interrupts yet. */
	0,	/* 2: IVECT */
	ZSWR3_RX_8 | ZSWR3_RX_ENABLE,
	ZSWR4_CLK_X16 | ZSWR4_ONESB | ZSWR4_EVENP,
	ZSWR5_TX_8 | ZSWR5_TX_ENABLE,
	0,	/* 6: TXSYNC/SYNCLO */
	0,	/* 7: RXSYNC/SYNCHI */
	0,	/* 8: alias for data port */
	ZSWR9_MASTER_IE | ZSWR9_NO_VECTOR,
	0,	/*10: Misc. TX/RX control bits */
	ZSWR11_TXCLK_BAUD | ZSWR11_RXCLK_BAUD,
	((PCLK/32)/9600)-2,	/*12: BAUDLO (default=9600) */
	0,			/*13: BAUDHI (default=9600) */
	ZSWR14_BAUD_ENA | ZSWR14_BAUD_FROM_PCLK,
	ZSWR15_BREAK_IE /* | ZSWR15_DCD_IE */,
};
d181 3
a183 21
struct zschan *
zs_get_chan_addr(zs_unit, channel)
	int zs_unit, channel;
{
	struct zsdevice *addr;
	struct zschan *zc;

	if (zs_unit >= NZS)
		return NULL;
	addr = zsaddr[zs_unit];
	if (addr == NULL)
		addr = zsaddr[zs_unit] = findzs(zs_unit);
	if (addr == NULL)
		return NULL;
	if (channel == 0) {
		zc = &addr->zs_chan_a;
	} else {
		zc = &addr->zs_chan_b;
	}
	return (zc);
}
d185 2
d188 1
a188 3
/****************************************************************
 * Autoconfig
 ****************************************************************/
d190 11
a200 4
/* Definition of the driver for autoconfig. */
int	zs_match(struct device *, void *, void *);
void	zs_attach(struct device *, struct device *, void *);
int  zs_print(void *, const char *nam);
d202 2
a203 3
struct cfattach zs_ca = {
	sizeof(struct zsc_softc), zs_match, zs_attach
};
d205 3
a207 3
struct cfdriver zs_cd = {
	NULL, "zs", DV_DULL
};
d209 6
a214 5
/* Interrupt handlers. */
int zshard(void *);
int zssoft(void *);
struct intrhand levelhard = { zshard };
struct intrhand levelsoft = { zssoft };
d216 6
a221 1
int zs_get_speed(struct zs_chanstate *);
d223 12
d237 2
a238 1
 * Is the zs chip present?
d240 2
a241 2
int
zs_match(parent, vcf, aux)
d245 2
a246 2
	struct cfdata *cf = (struct cfdata *)vcf;
	struct confargs *ca = (struct confargs *)aux;
d252 6
a257 2
	    (ca->ca_bustype == BUS_OBIO && CPU_ISSUN4M))
		return (getpropint(ra->ra_node, "slave", -2) == cf->cf_unit);
d268 2
a269 2
void
zs_attach(parent, self, aux)
d271 1
a271 1
	struct device *self;
d274 8
a281 7
	struct zsc_softc *zsc = (void *) self;
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;
	struct zsc_attach_args zsc_args;
	volatile struct zschan *zc;
	struct zs_chanstate *cs;
	int pri, s, zs_unit, channel;
d283 1
d285 2
a286 6
	zs_unit = zsc->zsc_dev.dv_unit;

	/* Use the mapping setup by the Sun PROM. */
	if (zsaddr[zs_unit] == NULL)
		zsaddr[zs_unit] = findzs(zs_unit);

d288 1
a288 1
		if ((void*)zsaddr[zs_unit] != ra->ra_vaddr)
a295 73

	/*
	 * Initialize software state for each channel.
	 */
	for (channel = 0; channel < 2; channel++) {
		zsc_args.type = "serial";
		/* XXX hardcoded */
		if (zs_unit == 1) {
			if (channel == 0)
				zsc_args.type = "keyboard";
			if (channel == 1)
				zsc_args.type = "mouse";
		}

		zsc_args.channel = channel;
		zsc_args.hwflags = zs_hwflags[zs_unit][channel];
		cs = &zsc->zsc_cs[channel];

		cs->cs_channel = channel;
		cs->cs_private = NULL;
		cs->cs_ops = &zsops_null;
		cs->cs_brg_clk = PCLK / 16;

		zc = zs_get_chan_addr(zs_unit, channel);

		cs->cs_reg_csr  = &zc->zc_csr;
		cs->cs_reg_data = &zc->zc_data;

		bcopy(zs_init_reg, cs->cs_creg, 16);
		bcopy(zs_init_reg, cs->cs_preg, 16);

		/* XXX: Get these from the PROM properties! */
		/* XXX: See the mvme167 code.  Better. */
		if (zsc_args.hwflags & ZS_HWFLAG_CONSOLE)
			cs->cs_defspeed = zs_get_speed(cs);
		else
			cs->cs_defspeed = zs_defspeed[zs_unit][channel];
		cs->cs_defcflag = zs_def_cflag;

		/* Make these correspond to cs_defcflag (-crtscts) */
		cs->cs_rr0_dcd = ZSRR0_DCD;
		cs->cs_rr0_cts = 0;
		cs->cs_wr5_dtr = ZSWR5_DTR | ZSWR5_RTS;
		cs->cs_wr5_rts = 0;

		/*
		 * Clear the master interrupt enable.
		 * The INTENA is common to both channels,
		 * so just do it on the A channel.
		 */
		if (channel == 0) {
			zs_write_reg(cs, 9, 0);
		}

		/*
		 * Look for a child driver for this channel.
		 * The child attach will setup the hardware.
		 */
		if (!config_found(self, (void *)&zsc_args, zs_print)) {
			/* No sub-driver.  Just reset it. */
			u_char reset = (channel == 0) ?
				ZSWR9_A_RESET : ZSWR9_B_RESET;
			s = splzs();
			zs_write_reg(cs,  9, reset);
			splx(s);
		}
	}

	/*
	 * Now safe to install interrupt handlers.  Note the arguments
	 * to the interrupt handlers aren't used.  Note, we only do this
	 * once since both SCCs interrupt at the same level and vector.
	 */
d303 65
a367 24
	evcnt_attach(&zsc->zsc_dev, "intr", &zsc->zsc_intrcnt);

	/*
	 * Set the master interrupt enable and interrupt vector.
	 * (common to both channels, do it on A)
	 */
	cs = &zsc->zsc_cs[0];
	s = splhigh();
	/* interrupt vector */
	zs_write_reg(cs, 2, zs_init_reg[2]);
	/* master interrupt control (enable) */
	zs_write_reg(cs, 9, zs_init_reg[9]);
	splx(s);

#if 0
	/*
	 * XXX: L1A hack - We would like to be able to break into
	 * the debugger during the rest of autoconfiguration, so
	 * lower interrupts just enough to let zs interrupts in.
	 * This is done after both zs devices are attached.
	 */
	if (zs_unit == 1) {
		printf("zs1: enabling zs interrupts\n");
		(void)splfd(); /* XXX: splzs - 1 */
d369 4
d374 20
d396 9
a404 4
int
zs_print(aux, name)
	void *aux;
	const char *name;
d406 27
a432 1
	struct zsc_attach_args *args = aux;
d434 34
a467 7
	if (name != NULL)
		printf("%s:", name);

	if (args->channel != -1)
		printf(" channel %d", args->channel);

	return UNCONF;
a469 2
volatile int zssoftpending;

d471 1
a471 2
 * Our ZS chips all share a common, autovectored interrupt,
 * so we have to look at all of them on each interrupt.
d473 3
a475 3
int
zshard(arg)
	void *arg;
d477 2
a478 2
	struct zsc_softc *zsc;
	int unit, rr3, rval, softreq;
d480 2
a481 14
	rval = softreq = 0;
	for (unit = 0; unit < zs_cd.cd_ndevs; unit++) {
		zsc = zs_cd.cd_devs[unit];
		if (zsc == NULL)
			continue;
		rr3 = zsc_intr_hard(zsc);
		/* Count up the interrupts. */
		if (rr3) {
			rval |= rr3;
			zsc->zsc_intrcnt.ev_count++;
		}
		softreq |= zsc->zsc_cs[0].cs_softreq;
		softreq |= zsc->zsc_cs[1].cs_softreq;
	}
d483 20
a502 9
	/* We are at splzs here, so no need to lock. */
	if (softreq && (zssoftpending == 0)) {
		zssoftpending = IE_ZSSOFT;
#if defined(SUN4M)
		if (CPU_ISSUN4M)
			raise(0, IPL_TTY);
		else
#endif
		ienab_bis(IE_ZSSOFT);
d504 3
a506 1
	return (rval);
d510 2
a511 1
 * Similar scheme as for zshard (look at all of them)
d513 5
a517 3
int
zssoft(arg)
	void *arg;
d519 2
a520 2
	struct zsc_softc *zsc;
	int s, unit;
d522 5
a526 2
	/* This is not the only ISR on this IPL. */
	if (zssoftpending == 0)
d529 3
d533 6
a538 4
	 * The soft intr. bit will be set by zshard only if
	 * the variable zssoftpending is zero.  The order of
	 * these next two statements prevents our clearing
	 * the soft intr bit just after zshard has set it.
d540 28
a567 2
	/* ienab_bic(IE_ZSSOFT); */
	zssoftpending = 0;
d569 6
a574 7
	/* Make sure we call the tty layer at spltty. */
	s = spltty();
	for (unit = 0; unit < zs_cd.cd_ndevs; unit++) {
		zsc = zs_cd.cd_devs[unit];
		if (zsc == NULL)
			continue;
		(void)zsc_intr_soft(zsc);
d576 15
a590 2
	splx(s);
	return (1);
d595 1
a595 1
 * Compute the current baud rate given a ZS channel.
d597 3
a599 3
int
zs_get_speed(cs)
	struct zs_chanstate *cs;
a600 1
	int tconst;
d602 3
a604 3
	tconst = zs_read_reg(cs, 12);
	tconst |= zs_read_reg(cs, 13) << 8;
	return (TCONST_TO_BPS(cs->cs_brg_clk, tconst));
d608 2
a609 1
 * MD functions for setting the baud rate and control modes.
d611 3
a613 4
int
zs_set_speed(cs, bps)
	struct zs_chanstate *cs;
	int bps;	/* bits per second */
a614 1
	int tconst, real_bps;
d616 6
a621 2
	if (bps == 0)
		return (0);
d623 42
a664 4
#ifdef	DIAGNOSTIC
	if (cs->cs_brg_clk == 0)
		panic("zs_set_speed");
#endif
d666 4
a669 3
	tconst = BPS_TO_TCONST(cs->cs_brg_clk, bps);
	if (tconst < 0)
		return (EINVAL);
d671 42
a712 2
	/* Convert back to make sure we can do it. */
	real_bps = TCONST_TO_BPS(cs->cs_brg_clk, tconst);
d714 2
a715 3
	/* XXX - Allow some tolerance here? */
	if (real_bps != bps)
		return (EINVAL);
d717 4
a720 2
	cs->cs_preg[12] = tconst;
	cs->cs_preg[13] = tconst >> 8;
d722 24
a745 2
	/* Caller will stuff the pending registers. */
	return (0);
d748 3
d752 46
a797 30
zs_set_modes(cs, cflag)
	struct zs_chanstate *cs;
	int cflag;	/* bits per second */
{
	int s;

	/*
	 * Output hardware flow control on the chip is horrendous:
	 * if carrier detect drops, the receiver is disabled, and if
	 * CTS drops, the transmitter is stoped IN MID CHARACTER!
	 * Therefore, NEVER set the HFC bit, and instead use the
	 * status interrupt to detect CTS changes.
	 */
	s = splzs();
	cs->cs_rr0_pps = 0;
	if ((cflag & (CLOCAL | MDMBUF)) != 0) {
		cs->cs_rr0_dcd = 0;
		if ((cflag & MDMBUF) == 0)
			cs->cs_rr0_pps = ZSRR0_DCD;
	} else
		cs->cs_rr0_dcd = ZSRR0_DCD;
	if ((cflag & CRTSCTS) != 0) {
		cs->cs_wr5_dtr = ZSWR5_DTR;
		cs->cs_wr5_rts = ZSWR5_RTS;
		cs->cs_rr0_cts = ZSRR0_CTS;
#if 0 /* JLW */
	} else if ((cflag & CDTRCTS) != 0) {
		cs->cs_wr5_dtr = 0;
		cs->cs_wr5_rts = ZSWR5_DTR;
		cs->cs_rr0_cts = ZSRR0_CTS;
a798 12
	} else if ((cflag & MDMBUF) != 0) {
		cs->cs_wr5_dtr = 0;
		cs->cs_wr5_rts = ZSWR5_DTR;
		cs->cs_rr0_cts = ZSRR0_DCD;
	} else {
		cs->cs_wr5_dtr = ZSWR5_DTR | ZSWR5_RTS;
		cs->cs_wr5_rts = 0;
		cs->cs_rr0_cts = 0;
	}
	splx(s);

	/* Caller will stuff the pending registers. */
a801 1

d803 1
a803 1
 * Read or write the chip with suitable delays.
d805 5
a809 5

u_char
zs_read_reg(cs, reg)
	struct zs_chanstate *cs;
	u_char reg;
d811 8
a818 1
	u_char val;
d820 1
a820 6
	*cs->cs_reg_csr = reg;
	ZS_DELAY();
	val = *cs->cs_reg_csr;
	ZS_DELAY();
	return val;
}
a821 9
void
zs_write_reg(cs, reg, val)
	struct zs_chanstate *cs;
	u_char reg, val;
{
	*cs->cs_reg_csr = reg;
	ZS_DELAY();
	*cs->cs_reg_csr = val;
	ZS_DELAY();
d824 5
a828 2
u_char zs_read_csr(cs)
	struct zs_chanstate *cs;
d830 4
a833 1
	register u_char val;
d835 3
a837 4
	val = *cs->cs_reg_csr;
	ZS_DELAY();
	return val;
}
d839 1
a839 6
void  zs_write_csr(cs, val)
	struct zs_chanstate *cs;
	u_char val;
{
	*cs->cs_reg_csr = val;
	ZS_DELAY();
d842 3
a844 2
u_char zs_read_data(cs)
	struct zs_chanstate *cs;
d846 3
a848 1
	register u_char val;
d850 2
a851 4
	val = *cs->cs_reg_data;
	ZS_DELAY();
	return val;
}
d853 1
a853 6
void  zs_write_data(cs, val)
	struct zs_chanstate *cs;
	u_char val;
{
	*cs->cs_reg_data = val;
	ZS_DELAY();
d856 3
a858 9
/****************************************************************
 * Console support functions (Sun specific!)
 * Note: this code is allowed to know about the layout of
 * the chip registers, and uses that to keep things simple.
 * XXX - I think I like the mvme167 code better. -gwr
 ****************************************************************/

extern void Debugger(void);
void *zs_conschan;
d861 9
a869 1
 * Handle user request to enter kernel debugger.
d871 4
a874 3
void
zs_abort(cs)
	struct zs_chanstate *cs;
d876 4
a879 2
	volatile struct zschan *zc = zs_conschan;
	int rr0;
d881 51
a931 6
	/* Wait for end of break to avoid PROM abort. */
	/* XXX - Limit the wait? */
	do {
		rr0 = zc->zc_csr;
		ZS_DELAY();
	} while (rr0 & ZSRR0_BREAK);
d933 20
a952 5
#if defined(KGDB)
	zskgdb(cs);
#elif defined(DDB)
	{
		extern int db_active;
d954 3
a956 2
		if (!db_active)
			Debugger();
d958 2
a959 2
			/* Debugger is probably hosed */
			callrom();
d961 1
a961 4
#else
	printf("stopping on keyboard abort\n");
	callrom();
#endif
d964 4
a967 6
/*
 * Polled input char.
 */
int
zs_getc(arg)
	void *arg;
d969 42
a1010 2
	volatile struct zschan *zc = arg;
	int s, c, rr0;
d1012 1
a1012 6
	s = splhigh();
	/* Wait for a character to arrive. */
	do {
		rr0 = zc->zc_csr;
		ZS_DELAY();
	} while ((rr0 & ZSRR0_RX_READY) == 0);
d1014 4
a1017 1
	c = zc->zc_data;
d1019 2
a1020 1
	splx(s);
d1022 29
a1050 5
	/*
	 * This is used by the kd driver to read scan codes,
	 * so don't translate '\r' ==> '\n' here...
	 */
	return (c);
d1053 4
a1056 7
/*
 * Polled output char.
 */
void
zs_putc(arg, c)
	void *arg;
	int c;
d1058 1
a1058 9
	volatile struct zschan *zc = arg;
	int s, rr0;

	s = splhigh();
	/* Wait for transmitter to become ready. */
	do {
		rr0 = zc->zc_csr;
		ZS_DELAY();
	} while ((rr0 & ZSRR0_TX_READY) == 0);
d1060 6
d1067 5
a1071 7
	 * Send the next character.
	 * Now you'd think that this could be followed by a ZS_DELAY()
	 * just like all the other chip accesses, but it turns out that
	 * the `transmit-ready' interrupt isn't de-asserted until
	 * some period of time after the register write completes
	 * (more than a couple instructions).  So to avoid stray
	 * interrupts we put in the 2us delay regardless of cpu model.
d1073 25
a1097 4
        zc->zc_data = c;
        delay(2);

	splx(s);
d1100 4
a1103 1
/*****************************************************************/
d1105 10
a1114 1
cons_decl(zs);
d1116 1
d1118 2
a1119 1
 * Console table shared by ttya, ttyb
a1120 10
struct consdev consdev_tty = {
	zscnprobe,
	zscninit,
	zscngetc,
	zscnputc,
	zscnpollc,
};

int zstty_unit;	/* set in consinit() */

d1122 2
a1123 2
zscnprobe(cn)
	struct consdev *cn;
a1124 3
	cn->cn_dev = makedev(zs_major, zstty_unit);
	cn->cn_pri = CN_REMOTE;
}
d1126 2
a1127 4
void
zscninit(cn)
	struct consdev *cn;
{
d1129 1
d1132 1
a1132 1
 * Polled console input putchar.
d1134 5
a1138 3
int
zscngetc(dev)
	dev_t dev;
d1140 6
a1145 1
	return (zs_getc(zs_conschan));
d1149 1
a1149 1
 * Polled console output putchar.
d1151 3
a1153 4
void
zscnputc(dev, c)
	dev_t dev;
	int c;
d1155 123
a1277 1
	zs_putc(zs_conschan, c);
d1280 38
a1317 1
int swallow_zsintrs;
d1319 11
a1329 11
void
zscnpollc(dev, on)
	dev_t dev;
	int on;
{
	/*
	 * Need to tell zs driver to acknowledge all interrupts or we get
	 * annoying spurious interrupt messages.  This is because mucking
	 * with spl() levels during polling does not prevent interrupts from
	 * being generated.
	 */
d1331 3
a1333 3
	if (on) swallow_zsintrs++;
	else swallow_zsintrs--;
}
d1335 1
a1335 1
/*****************************************************************/
d1337 81
a1417 1
cons_decl(prom);
d1420 1
a1420 3
 * The console is set to this one initially,
 * which lets us use the PROM until consinit()
 * is called to select a real console.
d1422 11
a1432 7
struct consdev consdev_prom = {
	promcnprobe,
	promcninit,
	promcngetc,
	promcnputc,
	nullcnpollc,
};
d1434 5
a1438 6
/*
 * The console table pointer is statically initialized
 * to point to the PROM (output only) table, so that
 * early calls to printf will work.
 */
struct consdev *cn_tab = &consdev_prom;
d1440 11
a1450 7
void
promcnprobe(cn)
	struct consdev *cn;
{
	cn->cn_dev = makedev(0, 0);
	cn->cn_pri = CN_INTERNAL;
}
d1452 26
a1477 4
void
promcninit(cn)
	struct consdev *cn;
{
d1481 1
a1481 1
 * PROM console input putchar.
d1484 21
a1504 4
promcngetc(dev)
	dev_t dev;
{
	int s, c;
d1506 15
a1520 10
	if (promvec->pv_romvec_vers > 2) {
		int n = 0;
		unsigned char c0;

		s = splhigh();
		while (n <= 0) {
			n = (*promvec->pv_v2devops.v2_read)
			        (*promvec->pv_v2bootargs.v2_fd0, &c0, 1);
		}
		splx(s);
d1522 19
a1540 6
		c = c0;
	} else {
#if defined(SUN4)
		/* SUN4 PROM: must turn off local echo */
		extern struct om_vector *oldpvec;
		int saveecho = 0;
d1542 44
a1585 13
		s = splhigh();
#if defined(SUN4)
		if (CPU_ISSUN4) {
			saveecho = *(oldpvec->echo);
			*(oldpvec->echo) = 0;
		}
#endif
		c = (*promvec->pv_getchar)();
#if defined(SUN4)
		if (CPU_ISSUN4)
			*(oldpvec->echo) = saveecho;
#endif
		splx(s);
d1587 2
d1590 11
a1600 2
	if (c == '\r')
		c = '\n';
d1602 16
a1617 1
	return (c);
d1621 2
a1622 1
 * PROM console output putchar.
d1624 4
a1627 4
void
promcnputc(dev, c)
	dev_t dev;
	int c;
d1629 1
a1629 2
	int s;
	char c0 = (c & 0x7f);
d1631 19
a1649 6
	s = splhigh();
	if (promvec->pv_romvec_vers > 2)
		(*promvec->pv_v2devops.v2_write)
			(*promvec->pv_v2bootargs.v2_fd1, &c0, 1);
	else
		(*promvec->pv_putchar)(c);
a1652 11
/*****************************************************************/

#if 0
extern struct consdev consdev_kd;
#endif

char *prom_inSrc_name[] = {
	"keyboard/display",
	"ttya", "ttyb",
	"ttyc", "ttyd" };

d1654 3
a1656 3
 * This function replaces sys/dev/cninit.c
 * Determine which device is the console using
 * the PROM "input source" and "output sink".
d1658 4
a1661 2
void
consinit()
d1663 24
a1686 24
	struct zschan *zc;
	struct consdev *console = cn_tab;
	int channel, zs_unit;
	int inSource, outSink;

	if (promvec->pv_romvec_vers > 2) {
		/* We need to probe the PROM device tree */
		int node,fd;
		char buffer[128];
		struct nodeops *no;
		struct v2devops *op;
		char *cp;
		extern int fbnode;

		inSource = outSink = -1;
		no = promvec->pv_nodeops;
		op = &promvec->pv_v2devops;

		node = findroot();
		if (no->no_proplen(node, "stdin-path") >= sizeof(buffer)) {
			printf("consinit: increase buffer size and recompile\n");
			goto setup_output;
		}
		/* XXX: fix above */
d1688 7
a1694 1
		no->no_getprop(node, "stdin-path",buffer);
d1696 4
a1699 45
		/*
		 * Open an "instance" of this device.
		 * You'd think it would be appropriate to call v2_close()
		 * on the handle when we're done with it. But that seems
		 * to cause the device to shut down somehow; for the moment,
		 * we simply leave it open...
		 */
		if ((fd = op->v2_open(buffer)) == 0 ||
		     (node = op->v2_fd_phandle(fd)) == 0) {
			printf("consinit: bogus stdin path %s.\n",buffer);
			goto setup_output;
		}
		if (no->no_proplen(node,"keyboard") >= 0) {
			inSource = PROMDEV_KBD;
			goto setup_output;
		}
		if (strcmp(getpropstring(node,"device_type"),"serial") != 0) {
			/* not a serial, not keyboard. what is it?!? */
			inSource = -1;
			goto setup_output;
		}
		/*
		 * At this point we assume the device path is in the form
		 *   ....device@@x,y:a for ttya and ...device@@x,y:b for ttyb.
		 * If it isn't, we defer to the ROM
		 */
		cp = buffer;
		while (*cp)
		    cp++;
		cp -= 2;
#ifdef DEBUG
		if (cp < buffer)
		    panic("consinit: bad stdin path %s",buffer);
#endif
		/* XXX: only allows tty's a->z, assumes PROMDEV_TTYx contig */
		if (cp[0]==':' && cp[1] >= 'a' && cp[1] <= 'z')
		    inSource = PROMDEV_TTYA + (cp[1] - 'a');
		/* else use rom */
setup_output:
		node = findroot();
		if (no->no_proplen(node, "stdout-path") >= sizeof(buffer)) {
			printf("consinit: increase buffer size and recompile\n");
			goto setup_console;
		}
		/* XXX: fix above */
d1701 15
a1715 1
		no->no_getprop(node, "stdout-path", buffer);
d1717 8
a1724 32
		if ((fd = op->v2_open(buffer)) == 0 ||
		     (node = op->v2_fd_phandle(fd)) == 0) {
			printf("consinit: bogus stdout path %s.\n",buffer);
			goto setup_output;
		}
		if (strcmp(getpropstring(node,"device_type"),"display") == 0) {
			/* frame buffer output */
			outSink = PROMDEV_SCREEN;
			fbnode = node;
		} else if (strcmp(getpropstring(node,"device_type"), "serial")
			   != 0) {
			/* not screen, not serial. Whatzit? */
			outSink = -1;
		} else { /* serial console. which? */
			/*
			 * At this point we assume the device path is in the
			 * form:
			 * ....device@@x,y:a for ttya, etc.
			 * If it isn't, we defer to the ROM
			 */
			cp = buffer;
			while (*cp)
			    cp++;
			cp -= 2;
#ifdef DEBUG
			if (cp < buffer)
				panic("consinit: bad stdout path %s",buffer);
#endif
			/* XXX: only allows tty's a->z, assumes PROMDEV_TTYx contig */
			if (cp[0]==':' && cp[1] >= 'a' && cp[1] <= 'z')
			    outSink = PROMDEV_TTYA + (cp[1] - 'a');
			else outSink = -1;
a1725 3
	} else {
		inSource = *promvec->pv_stdin;
		outSink  = *promvec->pv_stdout;
d1727 14
d1742 6
a1747 1
setup_console:
d1749 9
a1757 3
	if (inSource != outSink) {
		printf("cninit: mismatched PROM output selector\n");
	}
d1759 5
a1763 26
	switch (inSource) {
	default:
		printf("cninit: invalid inSource=%d\n", inSource);
		callrom();
		inSource = PROMDEV_KBD;
		/* FALLTHROUGH */

	case PROMDEV_KBD: /* keyboard/display */
#if NZSKBD > 0
		zs_unit = 1;
		channel = 0;
		break;
#else	/* NZSKBD */
		printf("cninit: kdb/display not configured\n");
		callrom();
		inSource = PROMDEV_TTYA;
		/* FALLTHROUGH */
#endif	/* NZSKBD */

	case PROMDEV_TTYA:
	case PROMDEV_TTYB:
		zstty_unit = inSource - PROMDEV_TTYA;
		zs_unit = 0;
		channel = zstty_unit & 1;
		console = &consdev_tty;
		break;
d1765 10
a1774 3
	}
	/* Now that inSource has been validated, print it. */
	printf("console is %s\n", prom_inSrc_name[inSource]);
d1776 8
a1783 3
	zc = zs_get_chan_addr(zs_unit, channel);
	if (zc == NULL) {
		printf("cninit: zs not mapped.\n");
d1786 10
a1795 9
	zs_conschan = zc;
	zs_hwflags[zs_unit][channel] = ZS_HWFLAG_CONSOLE;
	/* switch to selected console */
	cn_tab = console;
	(*cn_tab->cn_probe)(cn_tab);
	(*cn_tab->cn_init)(cn_tab);
#ifdef	KGDB
	zs_kgdb_init();
#endif
d1797 1
@


1.28
log
@Be careful when updating register in TIOCM* operations (do operations on
temporary copy and write that copy when applying changes to avoid an
inconsistent window).  Should allow devices like X10 firecracker, which
uses either DTR or RTS as power, to operate properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.27 2000/11/07 11:05:19 art Exp $	*/
d1398 6
a1403 4
		if (cs->cs_preg[5] & ZSWR5_DTR)
			bits |= TIOCM_DTR;
		if (cs->cs_preg[5] & ZSWR5_RTS)
			bits |= TIOCM_RTS;
d1406 1
a1406 1
			bits |= TIOCM_CD;
d1408 1
a1408 1
			bits |= TIOCM_CTS;
d1693 1
a1693 1
	u_char bits = 0, v;
d1695 4
a1698 4
	if (val & TIOCM_DTR);
		bits |= ZSWR5_DTR;
	if (val & TIOCM_RTS)
		bits |= ZSWR5_RTS;
a1700 1
	v = cs->cs_preg[5];
d1703 1
a1703 1
			v &= ~bits;
d1705 1
d1707 1
a1707 1
			v |= bits;
d1709 1
d1711 2
a1712 2
			v &= ~(ZSWR5_RTS | ZSWR5_DTR);
			v |= bits;
a1714 1
	cs->cs_preg[5] = v;
@


1.27
log
@Race conditions make it hard for us to know if the interrupt was for us.
Return -1 instead of 0 if we did not service the interrupt.

XXX - this is a horrible kludge, but should fix the stray interrupt problem
       that so many people have seen.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.26 2000/07/14 20:27:37 deraadt Exp $	*/
d1690 2
a1691 1
	int bits = 0, s;
d1699 1
d1702 1
a1702 1
			cs->cs_preg[5] &= ~bits;
d1705 1
a1705 1
			cs->cs_preg[5] |= bits;
d1708 2
a1709 2
			cs->cs_preg[5] &= ~(ZSWR5_RTS | ZSWR5_DTR);
			cs->cs_preg[5] |= bits;
d1712 1
@


1.26
log
@on a SparcStation Voyager, the 2nd zs device does not exist.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.24 2000/07/07 11:51:24 art Exp $	*/
d960 1
a960 1
	return (intflags & ZSHARD_WAS_SERVICED) ? 1 : 0 /* -1 XXX */;
@


1.26.2.1
log
@Pull in patch from current:
Fix (art):
Race conditions make it hard for us to know if the interrupt was for us.
Return -1 instead of 0 if we did not service the interrupt.

XXX - this is a horrible kludge, but should fix the stray interrupt problem
	that so many people have seen.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.26 2000/07/14 20:27:37 deraadt Exp $	*/
d960 1
a960 1
	return (intflags & ZSHARD_WAS_SERVICED) ? 1 : -1 /* XXX */;
@


1.25
log
@NKDD?  no -- NKBD, bad mjacob
@
text
@d255 6
a260 2
	    (ca->ca_bustype == BUS_OBIO && CPU_ISSUN4M))
		return (getpropint(ra->ra_node, "slave", -2) == cf->cf_unit);
@


1.24
log
@Fix some spl handling.
Return 1 from zshard more often to reduce (not fix) the stray interrupt
problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.23 2000/06/28 20:22:14 mjacob Exp $	*/
d1204 1
a1204 1
#if	NKDD > 0
@


1.23
log
@look in kbd.h to see whether we have configured a keyboard
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.22 1999/09/20 02:49:25 deraadt Exp $	*/
d472 2
a473 2
	register volatile struct zschan *zc = zs_conschan;
	register int s;
d477 2
a478 7
	/*
	 * Must block output interrupts (i.e., raise to >= splzs) without
	 * lowering current ipl.  Need a better way.
	 */
	s = splhigh();
	if (CPU_ISSUN4C && s <= (12 << 8)) /* XXX */
		(void) splzs();
d871 1
a871 1
	register struct zs_chanstate *a;
d873 2
a874 2
	register volatile struct zschan *zc;
	register int rr3, intflags = 0, v, i, ringmask;
d883 2
d929 4
d947 1
d956 1
a956 1
	return (intflags & ZSHARD_WAS_SERVICED);
d1420 1
a1420 1
	register int s, nch;
d1446 1
a1451 1
		(void) splzs();
a1463 1
		(void) splzs();
d1468 1
@


1.22
log
@delay for longer after each zsputc
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.21 1998/07/21 22:33:42 marc Exp $	*/
d58 1
d337 1
d339 1
d1202 1
d1204 3
@


1.22.4.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.27 2000/11/07 11:05:19 art Exp $	*/
a57 1
#include "kbd.h"
d254 2
a255 6
	    (ca->ca_bustype == BUS_OBIO && CPU_ISSUN4M)) {
		if (getpropint(ra->ra_node, "slave", -2) == cf->cf_unit &&
		    findzs(cf->cf_unit))
			return (1);
		return (0);
	}
a335 1
#if	NKBD > 0
a336 1
#endif
d469 2
a470 2
	volatile struct zschan *zc = zs_conschan;
	int s;
d474 7
a480 2

	s = splzs();
d873 1
a873 1
	struct zs_chanstate *a;
d875 2
a876 2
	volatile struct zschan *zc;
	int rr3, intflags = 0, v, i, ringmask;
a884 2
		if (rr3)
			intflags |= ZSHARD_WAS_SERVICED;
a928 4
#if 0		/*
		 * seems to break things and will not work when spl* are
		 * converted to be only raising.
		 */
a942 1
#endif
d951 1
a951 1
	return (intflags & ZSHARD_WAS_SERVICED) ? 1 : -1 /* XXX */;
a1198 1
#if	NKBD > 0
a1199 3
#else
					;
#endif
d1411 1
a1411 1
	register int s, ss, nch;
a1436 1
	ss = splzs();
d1442 1
d1455 1
a1459 1
	splx(ss);
@


1.22.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.22.4.1 2001/05/14 21:37:11 niklas Exp $	*/
d1398 4
a1401 6
		m = cs->cs_preg[5];
		if (ISSET(m, ZSWR5_DTR))
			SET(bits, TIOCM_DTR);
		if (ISSET(m, ZSWR5_RTS))
			SET(bits, TIOCM_RTS);

d1404 1
a1404 1
			SET(bits, TIOCM_CD);
d1406 1
a1406 1
			SET(bits, TIOCM_CTS);
d1690 1
a1690 2
	int s;
	u_char bits = 0;
d1692 4
a1695 4
	if (ISSET(val,TIOCM_DTR))
		SET(bits, ZSWR5_DTR);
	if (ISSET(val,TIOCM_RTS))
		SET(bits, ZSWR5_RTS);
d1700 1
a1700 1
			CLR(cs->cs_preg[5], bits);
a1701 1

d1703 1
a1703 1
			SET(cs->cs_preg[5], bits);
a1704 1

d1706 2
a1707 2
			CLR(cs->cs_preg[5], ZSWR5_RTS | ZSWR5_DTR);
			SET(cs->cs_preg[5], bits);
@


1.22.4.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d94 5
a355 2
	if (cs->cs_rbuf == NULL)
		panic("zsattach");
a392 2
	if (cs->cs_rbuf == NULL)
		panic("zsattach");
@


1.22.4.4
log
@Merge in -current from about a week ago
@
text
@a75 2
#include <uvm/uvm_extern.h>

d126 2
a127 2
static int	zsmatch(struct device *, void *, void *);
static void	zsattach(struct device *, struct device *, void *);
d138 1
a138 1
static int	zshard(void *);
d140 1
a140 1
static int	zssoft(void *);
d146 4
a149 4
static void	zsiopen(struct tty *);
static void	zsiclose(struct tty *);
static void	zsstart(struct tty *);
static int	zsparam(struct tty *, struct termios *);
d152 1
a152 1
static int	zs_getspeed(volatile struct zschan *);
d154 1
a154 1
static void	zs_reset(volatile struct zschan *, int, int);
d156 3
a158 3
static void	zs_modem(struct zs_chanstate *, int);
static void	zs_loadchannelregs(volatile struct zschan *, u_char *);
static void	tiocm_to_zs(struct zs_chanstate *, int how, int data);
d164 1
a164 1
static void zscnputc(int);	/* console putc function */
d166 2
a167 2
static struct tty *zs_checkcons(struct zs_softc *, int,
    struct zs_chanstate *);
d173 4
a176 4
static void zs_checkkgdb(int, struct zs_chanstate *, struct tty *);
void zskgdb(int);
static int zs_kgdb_getc(void *);
static void zs_kgdb_putc(void *, int);
d179 3
a181 3
static int zsrint(struct zs_chanstate *, volatile struct zschan *);
static int zsxint(struct zs_chanstate *, volatile struct zschan *);
static int zssint(struct zs_chanstate *, volatile struct zschan *);
d183 2
a184 2
void zsabort(int);
static void zsoverrun(int, long *, char *);
d204 2
a205 2
static u_int zs_read(volatile struct zschan *, u_int reg);
static u_int zs_write(volatile struct zschan *, u_int, u_int);
d446 1
a446 1
	int (**fnstop)(struct tty *, int);
d854 3
a856 3
static int zsrint(struct zs_chanstate *, volatile struct zschan *);
static int zsxint(struct zs_chanstate *, volatile struct zschan *);
static int zssint(struct zs_chanstate *, volatile struct zschan *);
@


1.22.4.5
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: zs.c,v 1.50 1997/10/18 00:00:40 gwr Exp $	*/
d4 7
a10 3
/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
d12 4
a15 2
 * This code is derived from software contributed to The NetBSD Foundation
 * by Gordon W. Ross.
d27 5
a31 5
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d33 13
a45 11
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
d49 5
a53 1
 * Zilog Z8530 Dual UART driver (machine-dependent part)
d55 1
a55 3
 * Runs two serial lines per chip using slave drivers.
 * Plain tty/async lines use the zs_async slave.
 * Sun keyboard/mouse uses the zs_kbd/zs_ms slaves.
d57 2
d62 1
a62 1
#include <sys/conf.h>
d66 1
a66 2
#include <sys/kernel.h>
#include <sys/proc.h>
d69 1
d71 6
a78 1
#include <machine/bsd_openprom.h>
d81 1
a81 9
#include <machine/eeprom.h>
#if defined(SUN4)
#include <machine/oldmon.h>
#endif
#include <machine/psl.h>
#include <machine/z8530var.h>

#include <dev/cons.h>
#include <sparc/dev/z8530reg.h>
d85 2
a86 1
#include <sparc/dev/cons.h>
d88 4
a91 1
#include <uvm/uvm_extern.h>
d93 2
a94 2
#include "zskbd.h"
#include "zs.h"
d96 1
a96 5
/* Make life easier for the initialized arrays here. */
#if NZS < 3
#undef  NZS
#define NZS 3
#endif
d98 2
a99 7
/*
 * Some warts needed by z8530tty.c -
 * The default parity REALLY needs to be the same as the PROM uses,
 * or you can not see messages done with printf during boot-up...
 */
int zs_def_cflag = (CREAD | CS8 | HUPCL);
int zs_major = 12;
d101 2
a102 4
/*
 * The Sun provides a 4.9152 MHz clock to the ZS chips.
 */
#define PCLK	(9600 * 512)	/* PCLK pin input clock rate */
d107 1
a107 1
#if IPL_TTY == 1
d109 1
a109 1
#elif IPL_TTY == 4
d111 1
a111 1
#elif IPL_TTY == 6
d117 8
a124 13
#define	ZS_DELAY()		(CPU_ISSUN4C ? (0) : delay(2))

/* The layout of this is hardware-dependent (padding, order). */
struct zschan {
	volatile u_char	zc_csr;		/* ctrl,status, and indirect access */
	u_char		zc_xxx0;
	volatile u_char	zc_data;	/* data */
	u_char		zc_xxx1;
};
struct zsdevice {
	/* Yes, they are backwards. */
	struct	zschan zs_chan_b;
	struct	zschan zs_chan_a;
d127 3
a129 2
/* Saved PROM mappings */
struct zsdevice *zsaddr[NZS];
d131 3
a133 2
/* Flags from cninit() */
int zs_hwflags[NZS][2];
d135 2
a136 8
/* Default speed for each channel */
int zs_defspeed[NZS][2] = {
	{ 9600, 	/* ttya */
	  9600 },	/* ttyb */
	{ 1200, 	/* keyboard */
	  1200 },	/* mouse */
	{ 9600, 	/* ttyc */
	  9600 },	/* ttyd */
d139 41
a179 18
u_char zs_init_reg[16] = {
	0,	/* 0: CMD (reset, etc.) */
	0,	/* 1: No interrupts yet. */
	0,	/* 2: IVECT */
	ZSWR3_RX_8 | ZSWR3_RX_ENABLE,
	ZSWR4_CLK_X16 | ZSWR4_ONESB | ZSWR4_EVENP,
	ZSWR5_TX_8 | ZSWR5_TX_ENABLE,
	0,	/* 6: TXSYNC/SYNCLO */
	0,	/* 7: RXSYNC/SYNCHI */
	0,	/* 8: alias for data port */
	ZSWR9_MASTER_IE | ZSWR9_NO_VECTOR,
	0,	/*10: Misc. TX/RX control bits */
	ZSWR11_TXCLK_BAUD | ZSWR11_RXCLK_BAUD,
	((PCLK/32)/9600)-2,	/*12: BAUDLO (default=9600) */
	0,			/*13: BAUDHI (default=9600) */
	ZSWR14_BAUD_ENA | ZSWR14_BAUD_FROM_PCLK,
	ZSWR15_BREAK_IE /* | ZSWR15_DCD_IE */,
};
d181 3
a183 21
struct zschan *
zs_get_chan_addr(zs_unit, channel)
	int zs_unit, channel;
{
	struct zsdevice *addr;
	struct zschan *zc;

	if (zs_unit >= NZS)
		return NULL;
	addr = zsaddr[zs_unit];
	if (addr == NULL)
		addr = zsaddr[zs_unit] = findzs(zs_unit);
	if (addr == NULL)
		return NULL;
	if (channel == 0) {
		zc = &addr->zs_chan_a;
	} else {
		zc = &addr->zs_chan_b;
	}
	return (zc);
}
d185 2
d188 1
a188 3
/****************************************************************
 * Autoconfig
 ****************************************************************/
d190 11
a200 4
/* Definition of the driver for autoconfig. */
int	zs_match(struct device *, void *, void *);
void	zs_attach(struct device *, struct device *, void *);
int  zs_print(void *, const char *nam);
d202 2
a203 3
struct cfattach zs_ca = {
	sizeof(struct zsc_softc), zs_match, zs_attach
};
d205 3
a207 3
struct cfdriver zs_cd = {
	NULL, "zs", DV_DULL
};
d209 6
a214 5
/* Interrupt handlers. */
int zshard(void *);
int zssoft(void *);
struct intrhand levelhard = { zshard };
struct intrhand levelsoft = { zssoft };
d216 6
a221 1
int zs_get_speed(struct zs_chanstate *);
d223 12
d237 2
a238 1
 * Is the zs chip present?
d240 2
a241 2
int
zs_match(parent, vcf, aux)
d245 2
a246 2
	struct cfdata *cf = (struct cfdata *)vcf;
	struct confargs *ca = (struct confargs *)aux;
d252 6
a257 2
	    (ca->ca_bustype == BUS_OBIO && CPU_ISSUN4M))
		return (getpropint(ra->ra_node, "slave", -2) == cf->cf_unit);
d268 2
a269 2
void
zs_attach(parent, self, aux)
d271 1
a271 1
	struct device *self;
d274 8
a281 7
	struct zsc_softc *zsc = (void *) self;
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;
	struct zsc_attach_args zsc_args;
	volatile struct zschan *zc;
	struct zs_chanstate *cs;
	int pri, s, zs_unit, channel;
d283 1
d285 2
a286 6
	zs_unit = zsc->zsc_dev.dv_unit;

	/* Use the mapping setup by the Sun PROM. */
	if (zsaddr[zs_unit] == NULL)
		zsaddr[zs_unit] = findzs(zs_unit);

d288 1
a288 1
		if ((void*)zsaddr[zs_unit] != ra->ra_vaddr)
d295 1
a295 74
	printf(" pri %d, softpri %d\n", pri, IPL_TTY);

	/*
	 * Initialize software state for each channel.
	 */
	for (channel = 0; channel < 2; channel++) {
		zsc_args.type = "serial";
		/* XXX hardcoded */
		if (zs_unit == 1) {
			if (channel == 0)
				zsc_args.type = "keyboard";
			if (channel == 1)
				zsc_args.type = "mouse";
		}

		zsc_args.channel = channel;
		zsc_args.hwflags = zs_hwflags[zs_unit][channel];
		cs = &zsc->zsc_cs[channel];

		cs->cs_channel = channel;
		cs->cs_private = NULL;
		cs->cs_ops = &zsops_null;
		cs->cs_brg_clk = PCLK / 16;

		zc = zs_get_chan_addr(zs_unit, channel);

		cs->cs_reg_csr  = &zc->zc_csr;
		cs->cs_reg_data = &zc->zc_data;

		bcopy(zs_init_reg, cs->cs_creg, 16);
		bcopy(zs_init_reg, cs->cs_preg, 16);

		/* XXX: Get these from the PROM properties! */
		/* XXX: See the mvme167 code.  Better. */
		if (zsc_args.hwflags & ZS_HWFLAG_CONSOLE)
			cs->cs_defspeed = zs_get_speed(cs);
		else
			cs->cs_defspeed = zs_defspeed[zs_unit][channel];
		cs->cs_defcflag = zs_def_cflag;

		/* Make these correspond to cs_defcflag (-crtscts) */
		cs->cs_rr0_dcd = ZSRR0_DCD;
		cs->cs_rr0_cts = 0;
		cs->cs_wr5_dtr = ZSWR5_DTR | ZSWR5_RTS;
		cs->cs_wr5_rts = 0;

		/*
		 * Clear the master interrupt enable.
		 * The INTENA is common to both channels,
		 * so just do it on the A channel.
		 */
		if (channel == 0) {
			zs_write_reg(cs, 9, 0);
		}

		/*
		 * Look for a child driver for this channel.
		 * The child attach will setup the hardware.
		 */
		if (!config_found(self, (void *)&zsc_args, zs_print)) {
			/* No sub-driver.  Just reset it. */
			u_char reset = (channel == 0) ?
				ZSWR9_A_RESET : ZSWR9_B_RESET;
			s = splzs();
			zs_write_reg(cs,  9, reset);
			splx(s);
		}
	}

	/*
	 * Now safe to install interrupt handlers.  Note the arguments
	 * to the interrupt handlers aren't used.  Note, we only do this
	 * once since both SCCs interrupt at the same level and vector.
	 */
d299 2
a300 2
		intr_establish(pri, &levelhard, IPL_ZS);
		intr_establish(IPL_TTY, &levelsoft, IPL_TTY);
d303 65
a367 24
	evcnt_attach(&zsc->zsc_dev, "intr", &zsc->zsc_intrcnt);

	/*
	 * Set the master interrupt enable and interrupt vector.
	 * (common to both channels, do it on A)
	 */
	cs = &zsc->zsc_cs[0];
	s = splhigh();
	/* interrupt vector */
	zs_write_reg(cs, 2, zs_init_reg[2]);
	/* master interrupt control (enable) */
	zs_write_reg(cs, 9, zs_init_reg[9]);
	splx(s);

#if 0
	/*
	 * XXX: L1A hack - We would like to be able to break into
	 * the debugger during the rest of autoconfiguration, so
	 * lower interrupts just enough to let zs interrupts in.
	 * This is done after both zs devices are attached.
	 */
	if (zs_unit == 1) {
		printf("zs1: enabling zs interrupts\n");
		(void)splfd(); /* XXX: splzs - 1 */
d369 4
d374 20
d396 9
a404 4
int
zs_print(aux, name)
	void *aux;
	const char *name;
d406 27
a432 1
	struct zsc_attach_args *args = aux;
d434 34
a467 7
	if (name != NULL)
		printf("%s:", name);

	if (args->channel != -1)
		printf(" channel %d", args->channel);

	return UNCONF;
a469 2
volatile int zssoftpending;

d471 1
a471 2
 * Our ZS chips all share a common, autovectored interrupt,
 * so we have to look at all of them on each interrupt.
d473 3
a475 3
int
zshard(arg)
	void *arg;
d477 2
a478 2
	struct zsc_softc *zsc;
	int unit, rr3, rval, softreq;
d480 2
a481 14
	rval = softreq = 0;
	for (unit = 0; unit < zs_cd.cd_ndevs; unit++) {
		zsc = zs_cd.cd_devs[unit];
		if (zsc == NULL)
			continue;
		rr3 = zsc_intr_hard(zsc);
		/* Count up the interrupts. */
		if (rr3) {
			rval |= rr3;
			zsc->zsc_intrcnt.ev_count++;
		}
		softreq |= zsc->zsc_cs[0].cs_softreq;
		softreq |= zsc->zsc_cs[1].cs_softreq;
	}
d483 20
a502 9
	/* We are at splzs here, so no need to lock. */
	if (softreq && (zssoftpending == 0)) {
		zssoftpending = IE_ZSSOFT;
#if defined(SUN4M)
		if (CPU_ISSUN4M)
			raise(0, IPL_TTY);
		else
#endif
		ienab_bis(IE_ZSSOFT);
d504 3
a506 1
	return (rval);
d510 2
a511 1
 * Similar scheme as for zshard (look at all of them)
d513 5
a517 3
int
zssoft(arg)
	void *arg;
d519 2
a520 2
	struct zsc_softc *zsc;
	int s, unit;
d522 1
a522 2
	/* This is not the only ISR on this IPL. */
	if (zssoftpending == 0)
d524 7
d533 6
a538 4
	 * The soft intr. bit will be set by zshard only if
	 * the variable zssoftpending is zero.  The order of
	 * these next two statements prevents our clearing
	 * the soft intr bit just after zshard has set it.
d540 28
a567 2
	/* ienab_bic(IE_ZSSOFT); */
	zssoftpending = 0;
d569 6
a574 7
	/* Make sure we call the tty layer at spltty. */
	s = spltty();
	for (unit = 0; unit < zs_cd.cd_ndevs; unit++) {
		zsc = zs_cd.cd_devs[unit];
		if (zsc == NULL)
			continue;
		(void)zsc_intr_soft(zsc);
d576 15
a590 2
	splx(s);
	return (1);
d595 1
a595 1
 * Compute the current baud rate given a ZS channel.
d597 3
a599 3
int
zs_get_speed(cs)
	struct zs_chanstate *cs;
a600 1
	int tconst;
d602 3
a604 3
	tconst = zs_read_reg(cs, 12);
	tconst |= zs_read_reg(cs, 13) << 8;
	return (TCONST_TO_BPS(cs->cs_brg_clk, tconst));
d608 2
a609 1
 * MD functions for setting the baud rate and control modes.
d611 3
a613 4
int
zs_set_speed(cs, bps)
	struct zs_chanstate *cs;
	int bps;	/* bits per second */
a614 1
	int tconst, real_bps;
d616 6
a621 2
	if (bps == 0)
		return (0);
d623 42
a664 4
#ifdef	DIAGNOSTIC
	if (cs->cs_brg_clk == 0)
		panic("zs_set_speed");
#endif
d666 4
a669 3
	tconst = BPS_TO_TCONST(cs->cs_brg_clk, bps);
	if (tconst < 0)
		return (EINVAL);
d671 42
a712 2
	/* Convert back to make sure we can do it. */
	real_bps = TCONST_TO_BPS(cs->cs_brg_clk, tconst);
d714 2
a715 3
	/* XXX - Allow some tolerance here? */
	if (real_bps != bps)
		return (EINVAL);
d717 4
a720 2
	cs->cs_preg[12] = tconst;
	cs->cs_preg[13] = tconst >> 8;
d722 24
a745 2
	/* Caller will stuff the pending registers. */
	return (0);
d748 3
d752 46
a797 30
zs_set_modes(cs, cflag)
	struct zs_chanstate *cs;
	int cflag;	/* bits per second */
{
	int s;

	/*
	 * Output hardware flow control on the chip is horrendous:
	 * if carrier detect drops, the receiver is disabled, and if
	 * CTS drops, the transmitter is stoped IN MID CHARACTER!
	 * Therefore, NEVER set the HFC bit, and instead use the
	 * status interrupt to detect CTS changes.
	 */
	s = splzs();
	cs->cs_rr0_pps = 0;
	if ((cflag & (CLOCAL | MDMBUF)) != 0) {
		cs->cs_rr0_dcd = 0;
		if ((cflag & MDMBUF) == 0)
			cs->cs_rr0_pps = ZSRR0_DCD;
	} else
		cs->cs_rr0_dcd = ZSRR0_DCD;
	if ((cflag & CRTSCTS) != 0) {
		cs->cs_wr5_dtr = ZSWR5_DTR;
		cs->cs_wr5_rts = ZSWR5_RTS;
		cs->cs_rr0_cts = ZSRR0_CTS;
#if 0 /* JLW */
	} else if ((cflag & CDTRCTS) != 0) {
		cs->cs_wr5_dtr = 0;
		cs->cs_wr5_rts = ZSWR5_DTR;
		cs->cs_rr0_cts = ZSRR0_CTS;
a798 12
	} else if ((cflag & MDMBUF) != 0) {
		cs->cs_wr5_dtr = 0;
		cs->cs_wr5_rts = ZSWR5_DTR;
		cs->cs_rr0_cts = ZSRR0_DCD;
	} else {
		cs->cs_wr5_dtr = ZSWR5_DTR | ZSWR5_RTS;
		cs->cs_wr5_rts = 0;
		cs->cs_rr0_cts = 0;
	}
	splx(s);

	/* Caller will stuff the pending registers. */
a801 1

d803 1
a803 1
 * Read or write the chip with suitable delays.
d805 5
a809 5

u_char
zs_read_reg(cs, reg)
	struct zs_chanstate *cs;
	u_char reg;
d811 8
a818 1
	u_char val;
d820 1
a820 6
	*cs->cs_reg_csr = reg;
	ZS_DELAY();
	val = *cs->cs_reg_csr;
	ZS_DELAY();
	return val;
}
a821 9
void
zs_write_reg(cs, reg, val)
	struct zs_chanstate *cs;
	u_char reg, val;
{
	*cs->cs_reg_csr = reg;
	ZS_DELAY();
	*cs->cs_reg_csr = val;
	ZS_DELAY();
d824 5
a828 2
u_char zs_read_csr(cs)
	struct zs_chanstate *cs;
d830 4
a833 1
	register u_char val;
d835 3
a837 4
	val = *cs->cs_reg_csr;
	ZS_DELAY();
	return val;
}
d839 1
a839 6
void  zs_write_csr(cs, val)
	struct zs_chanstate *cs;
	u_char val;
{
	*cs->cs_reg_csr = val;
	ZS_DELAY();
d842 3
a844 2
u_char zs_read_data(cs)
	struct zs_chanstate *cs;
d846 3
a848 1
	register u_char val;
d850 2
a851 4
	val = *cs->cs_reg_data;
	ZS_DELAY();
	return val;
}
d853 1
a853 6
void  zs_write_data(cs, val)
	struct zs_chanstate *cs;
	u_char val;
{
	*cs->cs_reg_data = val;
	ZS_DELAY();
d856 3
a858 9
/****************************************************************
 * Console support functions (Sun specific!)
 * Note: this code is allowed to know about the layout of
 * the chip registers, and uses that to keep things simple.
 * XXX - I think I like the mvme167 code better. -gwr
 ****************************************************************/

extern void Debugger(void);
void *zs_conschan;
d861 9
a869 1
 * Handle user request to enter kernel debugger.
d871 4
a874 3
void
zs_abort(cs)
	struct zs_chanstate *cs;
d876 4
a879 2
	volatile struct zschan *zc = zs_conschan;
	int rr0;
d881 51
a931 6
	/* Wait for end of break to avoid PROM abort. */
	/* XXX - Limit the wait? */
	do {
		rr0 = zc->zc_csr;
		ZS_DELAY();
	} while (rr0 & ZSRR0_BREAK);
d933 20
a952 5
#if defined(KGDB)
	zskgdb(cs);
#elif defined(DDB)
	{
		extern int db_active;
d954 3
a956 2
		if (!db_active)
			Debugger();
d958 2
a959 2
			/* Debugger is probably hosed */
			callrom();
d961 1
a961 4
#else
	printf("stopping on keyboard abort\n");
	callrom();
#endif
d964 4
a967 6
/*
 * Polled input char.
 */
int
zs_getc(arg)
	void *arg;
d969 36
a1004 2
	volatile struct zschan *zc = arg;
	int s, c, rr0;
d1006 7
a1012 6
	s = splhigh();
	/* Wait for a character to arrive. */
	do {
		rr0 = zc->zc_csr;
		ZS_DELAY();
	} while ((rr0 & ZSRR0_RX_READY) == 0);
d1014 4
a1017 1
	c = zc->zc_data;
d1019 2
a1020 1
	splx(s);
d1022 29
a1050 5
	/*
	 * This is used by the kd driver to read scan codes,
	 * so don't translate '\r' ==> '\n' here...
	 */
	return (c);
d1053 4
a1056 7
/*
 * Polled output char.
 */
void
zs_putc(arg, c)
	void *arg;
	int c;
d1058 1
a1058 9
	volatile struct zschan *zc = arg;
	int s, rr0;

	s = splhigh();
	/* Wait for transmitter to become ready. */
	do {
		rr0 = zc->zc_csr;
		ZS_DELAY();
	} while ((rr0 & ZSRR0_TX_READY) == 0);
d1060 6
d1067 5
a1071 7
	 * Send the next character.
	 * Now you'd think that this could be followed by a ZS_DELAY()
	 * just like all the other chip accesses, but it turns out that
	 * the `transmit-ready' interrupt isn't de-asserted until
	 * some period of time after the register write completes
	 * (more than a couple instructions).  So to avoid stray
	 * interrupts we put in the 2us delay regardless of cpu model.
d1073 25
a1097 4
        zc->zc_data = c;
        delay(2);

	splx(s);
d1100 4
a1103 1
/*****************************************************************/
d1105 10
a1114 1
cons_decl(zs);
d1116 1
d1118 2
a1119 1
 * Console table shared by ttya, ttyb
a1120 10
struct consdev consdev_tty = {
	zscnprobe,
	zscninit,
	zscngetc,
	zscnputc,
	zscnpollc,
};

int zstty_unit;	/* set in consinit() */

d1122 2
a1123 2
zscnprobe(cn)
	struct consdev *cn;
a1124 3
	cn->cn_dev = makedev(zs_major, zstty_unit);
	cn->cn_pri = CN_REMOTE;
}
d1126 2
a1127 4
void
zscninit(cn)
	struct consdev *cn;
{
d1129 1
d1132 1
a1132 1
 * Polled console input putchar.
d1134 5
a1138 3
int
zscngetc(dev)
	dev_t dev;
d1140 6
a1145 1
	return (zs_getc(zs_conschan));
d1149 1
a1149 1
 * Polled console output putchar.
d1151 3
a1153 4
void
zscnputc(dev, c)
	dev_t dev;
	int c;
d1155 123
a1277 1
	zs_putc(zs_conschan, c);
d1280 2
a1281 4
int swallow_zsintrs;

void
zscnpollc(dev, on)
d1283 35
a1317 8
	int on;
{
	/*
	 * Need to tell zs driver to acknowledge all interrupts or we get
	 * annoying spurious interrupt messages.  This is because mucking
	 * with spl() levels during polling does not prevent interrupts from
	 * being generated.
	 */
d1319 11
a1329 3
	if (on) swallow_zsintrs++;
	else swallow_zsintrs--;
}
d1331 3
a1333 1
/*****************************************************************/
d1335 83
a1417 1
cons_decl(prom);
d1420 1
a1420 3
 * The console is set to this one initially,
 * which lets us use the PROM until consinit()
 * is called to select a real console.
d1422 11
a1432 7
struct consdev consdev_prom = {
	promcnprobe,
	promcninit,
	promcngetc,
	promcnputc,
	nullcnpollc,
};
d1434 5
a1438 6
/*
 * The console table pointer is statically initialized
 * to point to the PROM (output only) table, so that
 * early calls to printf will work.
 */
struct consdev *cn_tab = &consdev_prom;
d1440 11
a1450 7
void
promcnprobe(cn)
	struct consdev *cn;
{
	cn->cn_dev = makedev(0, 0);
	cn->cn_pri = CN_INTERNAL;
}
d1452 26
a1477 4
void
promcninit(cn)
	struct consdev *cn;
{
d1481 1
a1481 1
 * PROM console input putchar.
d1484 21
a1504 4
promcngetc(dev)
	dev_t dev;
{
	int s, c;
d1506 15
a1520 10
	if (promvec->pv_romvec_vers > 2) {
		int n = 0;
		unsigned char c0;

		s = splhigh();
		while (n <= 0) {
			n = (*promvec->pv_v2devops.v2_read)
			        (*promvec->pv_v2bootargs.v2_fd0, &c0, 1);
		}
		splx(s);
d1522 19
a1540 6
		c = c0;
	} else {
#if defined(SUN4)
		/* SUN4 PROM: must turn off local echo */
		extern struct om_vector *oldpvec;
		int saveecho = 0;
d1542 44
a1585 13
		s = splhigh();
#if defined(SUN4)
		if (CPU_ISSUN4) {
			saveecho = *(oldpvec->echo);
			*(oldpvec->echo) = 0;
		}
#endif
		c = (*promvec->pv_getchar)();
#if defined(SUN4)
		if (CPU_ISSUN4)
			*(oldpvec->echo) = saveecho;
#endif
		splx(s);
d1587 2
d1590 11
a1600 2
	if (c == '\r')
		c = '\n';
d1602 16
a1617 1
	return (c);
d1621 2
a1622 1
 * PROM console output putchar.
d1624 4
a1627 4
void
promcnputc(dev, c)
	dev_t dev;
	int c;
d1629 1
a1629 2
	int s;
	char c0 = (c & 0x7f);
d1631 19
a1649 6
	s = splhigh();
	if (promvec->pv_romvec_vers > 2)
		(*promvec->pv_v2devops.v2_write)
			(*promvec->pv_v2bootargs.v2_fd1, &c0, 1);
	else
		(*promvec->pv_putchar)(c);
a1652 11
/*****************************************************************/

#if 0
extern struct consdev consdev_kd;
#endif

char *prom_inSrc_name[] = {
	"keyboard/display",
	"ttya", "ttyb",
	"ttyc", "ttyd" };

d1654 3
a1656 3
 * This function replaces sys/dev/cninit.c
 * Determine which device is the console using
 * the PROM "input source" and "output sink".
d1658 4
a1661 2
void
consinit()
d1663 24
a1686 24
	struct zschan *zc;
	struct consdev *console = cn_tab;
	int channel, zs_unit;
	int inSource, outSink;

	if (promvec->pv_romvec_vers > 2) {
		/* We need to probe the PROM device tree */
		int node,fd;
		char buffer[128];
		struct nodeops *no;
		struct v2devops *op;
		char *cp;
		extern int fbnode;

		inSource = outSink = -1;
		no = promvec->pv_nodeops;
		op = &promvec->pv_v2devops;

		node = findroot();
		if (no->no_proplen(node, "stdin-path") >= sizeof(buffer)) {
			printf("consinit: increase buffer size and recompile\n");
			goto setup_output;
		}
		/* XXX: fix above */
d1688 7
a1694 1
		no->no_getprop(node, "stdin-path",buffer);
d1696 4
a1699 45
		/*
		 * Open an "instance" of this device.
		 * You'd think it would be appropriate to call v2_close()
		 * on the handle when we're done with it. But that seems
		 * to cause the device to shut down somehow; for the moment,
		 * we simply leave it open...
		 */
		if ((fd = op->v2_open(buffer)) == 0 ||
		     (node = op->v2_fd_phandle(fd)) == 0) {
			printf("consinit: bogus stdin path %s.\n",buffer);
			goto setup_output;
		}
		if (no->no_proplen(node,"keyboard") >= 0) {
			inSource = PROMDEV_KBD;
			goto setup_output;
		}
		if (strcmp(getpropstring(node,"device_type"),"serial") != 0) {
			/* not a serial, not keyboard. what is it?!? */
			inSource = -1;
			goto setup_output;
		}
		/*
		 * At this point we assume the device path is in the form
		 *   ....device@@x,y:a for ttya and ...device@@x,y:b for ttyb.
		 * If it isn't, we defer to the ROM
		 */
		cp = buffer;
		while (*cp)
		    cp++;
		cp -= 2;
#ifdef DEBUG
		if (cp < buffer)
		    panic("consinit: bad stdin path %s",buffer);
#endif
		/* XXX: only allows tty's a->z, assumes PROMDEV_TTYx contig */
		if (cp[0]==':' && cp[1] >= 'a' && cp[1] <= 'z')
		    inSource = PROMDEV_TTYA + (cp[1] - 'a');
		/* else use rom */
setup_output:
		node = findroot();
		if (no->no_proplen(node, "stdout-path") >= sizeof(buffer)) {
			printf("consinit: increase buffer size and recompile\n");
			goto setup_console;
		}
		/* XXX: fix above */
d1701 15
a1715 1
		no->no_getprop(node, "stdout-path", buffer);
d1717 8
a1724 32
		if ((fd = op->v2_open(buffer)) == 0 ||
		     (node = op->v2_fd_phandle(fd)) == 0) {
			printf("consinit: bogus stdout path %s.\n",buffer);
			goto setup_output;
		}
		if (strcmp(getpropstring(node,"device_type"),"display") == 0) {
			/* frame buffer output */
			outSink = PROMDEV_SCREEN;
			fbnode = node;
		} else if (strcmp(getpropstring(node,"device_type"), "serial")
			   != 0) {
			/* not screen, not serial. Whatzit? */
			outSink = -1;
		} else { /* serial console. which? */
			/*
			 * At this point we assume the device path is in the
			 * form:
			 * ....device@@x,y:a for ttya, etc.
			 * If it isn't, we defer to the ROM
			 */
			cp = buffer;
			while (*cp)
			    cp++;
			cp -= 2;
#ifdef DEBUG
			if (cp < buffer)
				panic("consinit: bad stdout path %s",buffer);
#endif
			/* XXX: only allows tty's a->z, assumes PROMDEV_TTYx contig */
			if (cp[0]==':' && cp[1] >= 'a' && cp[1] <= 'z')
			    outSink = PROMDEV_TTYA + (cp[1] - 'a');
			else outSink = -1;
a1725 3
	} else {
		inSource = *promvec->pv_stdin;
		outSink  = *promvec->pv_stdout;
d1727 14
d1742 6
a1747 1
setup_console:
d1749 9
a1757 3
	if (inSource != outSink) {
		printf("cninit: mismatched PROM output selector\n");
	}
d1759 5
a1763 26
	switch (inSource) {
	default:
		printf("cninit: invalid inSource=%d\n", inSource);
		callrom();
		inSource = PROMDEV_KBD;
		/* FALLTHROUGH */

	case PROMDEV_KBD: /* keyboard/display */
#if NZSKBD > 0
		zs_unit = 1;
		channel = 0;
		break;
#else	/* NZSKBD */
		printf("cninit: kdb/display not configured\n");
		callrom();
		inSource = PROMDEV_TTYA;
		/* FALLTHROUGH */
#endif	/* NZSKBD */

	case PROMDEV_TTYA:
	case PROMDEV_TTYB:
		zstty_unit = inSource - PROMDEV_TTYA;
		zs_unit = 0;
		channel = zstty_unit & 1;
		console = &consdev_tty;
		break;
d1765 10
a1774 3
	}
	/* Now that inSource has been validated, print it. */
	printf("console is %s\n", prom_inSrc_name[inSource]);
d1776 8
a1783 3
	zc = zs_get_chan_addr(zs_unit, channel);
	if (zc == NULL) {
		printf("cninit: zs not mapped.\n");
d1786 10
a1795 9
	zs_conschan = zc;
	zs_hwflags[zs_unit][channel] = ZS_HWFLAG_CONSOLE;
	/* switch to selected console */
	cn_tab = console;
	(*cn_tab->cn_probe)(cn_tab);
	(*cn_tab->cn_init)(cn_tab);
#ifdef	KGDB
	zs_kgdb_init();
#endif
d1797 1
@


1.22.6.1
log
@Pull in patch from current:
Fix (art):
Race conditions make it hard for us to know if the interrupt was for us.
Return -1 instead of 0 if we did not service the interrupt.

XXX - this is a horrible kludge, but should fix the stray interrupt problem
	that so many people have seen.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.22 1999/09/20 02:49:25 deraadt Exp $	*/
d951 1
a951 1
	return (intflags & ZSHARD_WAS_SERVICED) ? 1 : -1 /* XXX */;
@


1.21
log
@johns@@ mods to add cua devs to the sparc.
I've been using for 6+ months without probs, but have not done much
with combined input/output
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.20 1998/03/04 14:21:29 jason Exp $	*/
d502 1
a502 1
	ZS_DELAY();
@


1.20
log
@added support for the TIOCM* ioctl's
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.19 1998/02/05 16:57:49 deraadt Exp $	*/
d90 8
d619 1
d634 2
a635 1
	int unit = minor(dev), zs = unit >> 1, error, s;
d656 7
d667 24
a690 2
	error = 0;
	for (;;) {
d693 5
d705 4
a708 2
		if (flags & O_NONBLOCK || tp->t_cflag & CLOCAL ||
		    tp->t_state & TS_CARR_ON)
d710 1
a710 1
		tp->t_state |= TS_WOPEN;
d713 6
d722 1
a722 1
				tp->t_state &= ~TS_WOPEN;
d725 4
d732 4
a735 1
	}
d737 1
d758 2
a759 1
	int unit = minor(dev), s;
d765 4
d783 5
d811 1
a811 1
	int unit = minor(dev);
d830 1
a830 1
	int unit = minor(dev);
d845 1
a845 1
	int unit = minor(dev);
d1274 1
a1274 1
	int unit = minor(dev);
d1412 1
a1412 1
	int unit = minor(tp->t_dev);
d1473 1
a1473 1
	register int s, unit = minor(tp->t_dev);
d1501 1
a1501 1
	int unit = minor(tp->t_dev);
d1759 1
a1759 1
	unit = minor(kgdb_dev);
@


1.19
log
@oops, need include file
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.18 1998/02/05 16:49:09 deraadt Exp $	*/
d154 1
d1303 2
a1304 1
	case TIOCMGET:
d1306 2
d1309 18
d1600 40
@


1.18
log
@rename ddb.panic_ddb, and add ddb.console. Now you can stop console ddb entry
with a sysctl. There will be architectures and drivers that lack function,
and I trust the maintainers of those will forget to add the code..
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.17 1997/09/17 06:47:12 downsj Exp $	*/
d71 3
@


1.17
log
@NETBSD_CURRENT_970916.  Lot's just ID changes, since changes don't apply to
us.  Includes some pmap changes, for which I don't have the original commit
message(s) handy.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.16 1997/08/25 08:38:45 downsj Exp $	*/
d1024 2
a1025 1
	Debugger();
@


1.16
log
@Implement LED blinking as a run-time configurable option via the sysctl
machdep.led_blink.

Rename auxreg.h because we need config to generate one now.
@
text
@d1 2
a2 2
/*	$OpenBSD: zs.c,v 1.15 1997/08/08 08:25:43 downsj Exp $	*/
/*	$NetBSD: zs.c,v 1.48 1997/07/29 09:58:18 fair Exp $ */
d83 1
d175 1
a175 1
void zsabort __P((void));
d906 1
a906 1
			zsabort();
d1010 1
a1010 1
		zsabort();
d1017 2
a1018 1
zsabort()
d1021 3
a1023 1
#ifdef DDB
@


1.15
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d78 1
a78 1
#include <sparc/sparc/auxreg.h>
@


1.14
log
@remove unused variable
@
text
@d1 2
a2 2
/*	$OpenBSD: zs.c,v 1.13 1996/08/12 18:54:05 deraadt Exp $	*/
/*	$NetBSD: zs.c,v 1.37.4.1 1996/06/02 09:07:55 mrg Exp $ */
d75 1
a78 3


#include <machine/kbd.h>
a79 1

d86 1
a86 1
#define	ZSMAJOR		12	/* XXX */
d113 2
a114 2
	struct	evcnt sc_intrcnt;
	struct	zs_chanstate sc_cs[2];		/* channel A/B software state */
d154 1
d158 1
a158 1
				     struct zs_chanstate *));
a176 1
extern void *findzs __P((int));
d272 1
a272 1
	if (ca->ca_bustype == BUS_MAIN)
d311 2
d314 1
a316 2
	}
	cs->cs_ttyp = tp;
d330 2
a332 1

d336 1
a338 1

d349 2
d352 1
a354 2
	}
	cs->cs_ttyp = tp;
d367 2
d444 1
a444 1
	if(fnstop)
d470 18
d506 1
a506 1
	if ((tp = zs_ctty) == NULL)
d646 1
a646 1
	while (1) {
d743 1
d874 1
a874 1
			ienab_bis(IE_ZSSOFT);
d884 1
a884 1
	register u_int c;
a885 1
	c = zc->zc_data;
a886 1

d944 9
d1176 1
a1176 1
				log(LOG_ERR, "zs%d%c: bad ZRING_TYPE (%x)\n",
d1197 2
a1198 1
	register struct tty *tp = sc->sc_cs[unit & 1].cs_ttyp;
a1199 1
	register struct zs_chanstate *cs = &sc->sc_cs[unit & 1];
d1293 1
a1294 7
		/* XXX: fixme */
		*(int *)data = TIOCM_CAR | TIOCM_CTS | TIOCM_DTR | TIOCM_RTS;
		return (0);
	case TIOCMSET:
		/* XXX: fixme */
		zs_modem(cs, *(int *)data & (TIOCM_DTR|TIOCM_RTS));
		return (0);
d1421 5
a1425 1
	if (tmp < 2)
@


1.13
log
@one last fix
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.12 1996/08/12 03:14:49 downsj Exp $	*/
a777 1
	struct zs_softc *sc;
@


1.12
log
@Missed a couple things and blew something away by accident.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.11 1996/08/12 00:28:16 downsj Exp $	*/
d307 1
a307 1
	if ((ctp = zs_checkcons(zi, unit, cs)) != NULL)
d343 1
a343 1
	if ((ctp = zs_checkcons(zi, unit, cs)) != NULL)
@


1.11
log
@Merge the rest of our changes; mostly just softc changes in order to support
more devices, more cleanly.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.10 1996/08/11 23:39:56 downsj Exp $	*/
d263 1
a263 1
	register struct zs_softc *zi;
@


1.10
log
@Merge back rev 1.5: always set mouse to B1200.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 2
a53 1
 * and runs a keyboard and mouse on zs1.
d57 2
d111 1
a111 2
 * Software state per found chip.  This would be called `zs_softc',
 * but the previous driver had a rather different zs_softc....
d113 5
a117 4
struct zsinfo {
	struct	device zi_dev;		/* base device */
	volatile struct zsdevice *zi_zs;/* chip registers */
	struct	zs_chanstate zi_cs[2];	/* channel A and B software state */
d125 1
a125 1
	sizeof(struct zsinfo), zsmatch, zsattach
d159 2
a160 1
static struct tty *zs_checkcons __P((struct zsinfo *, int, struct zs_chanstate *));
d179 1
a179 1
#include "zs.h"	/* XXX: */
d263 1
a263 1
	register struct zsinfo *zi;
d274 2
a275 2
		addr = zsaddr[zs] = findzs(zs);
	if (ca->ca_bustype==BUS_MAIN)
d291 3
a293 2
	zi = (struct zsinfo *)dev;
	zi->zi_zs = addr;
d295 1
a295 1
	cs = zi->zi_cs;
d299 1
d301 1
d339 1
d436 1
a436 1
			addr = zsaddr[zs] = findzs(zs);
d478 2
a479 2
zs_checkcons(zi, unit, cs)
	struct zsinfo *zi;
d486 1
a486 1
	if ((tp = zs_ctty) == NULL) /* XXX */
d514 1
a514 1
	    zi->zi_dev.dv_xname, (unit & 1) + 'a', i ? (o ? "i/o" : i) : o);
d599 1
a599 1
	struct zsinfo *zi;
d602 1
a602 1
	if (zs >= zs_cd.cd_ndevs || (zi = zs_cd.cd_devs[zs]) == NULL ||
d605 1
a605 1
	cs = &zi->zi_cs[unit & 1];
d626 1
a626 1
	for (;;) {
d672 1
a672 1
	struct zsinfo *zi;
d675 2
a676 2
	zi = zs_cd.cd_devs[unit >> 1];
	cs = &zi->zi_cs[unit & 1];
d714 1
a714 1
	register struct zsinfo *zi;
d718 2
a719 2
	zi = zs_cd.cd_devs[unit >> 1];
	cs = &zi->zi_cs[unit & 1];
a722 1

d732 1
a732 1
	register struct zsinfo *zi;
d736 2
a737 2
	zi = zs_cd.cd_devs[unit >> 1];
	cs = &zi->zi_cs[unit & 1];
d748 1
a748 1
	register struct zsinfo *zi;
d751 2
a752 2
	zi = zs_cd.cd_devs[unit >> 1];
	cs = &zi->zi_cs[unit & 1];
d755 1
d757 3
a759 1
}
d778 1
d782 4
a785 3
	static int zsrint(struct zs_chanstate *, volatile struct zschan *);
	static int zsxint(struct zs_chanstate *, volatile struct zschan *);
	static int zssint(struct zs_chanstate *, volatile struct zschan *);
d791 1
a791 1
			intflags |= 2;
d796 1
a796 1
				intflags |= 1;
d800 1
a800 1
				intflags |= 1;
d804 1
a804 1
				intflags |= 1;
d809 1
a809 1
			intflags |= 2;
d814 1
a814 1
				intflags |= 1;
d818 1
a818 1
				intflags |= 1;
d822 1
a822 1
				intflags |= 1;
d826 4
d833 1
a833 1
	if (intflags & 1) {
d856 1
a856 1
	return (intflags & 2);
d864 1
a864 1
	register int c = zc->zc_data;
d866 1
d868 1
d946 1
a946 1
	register int rr0;
d1169 2
a1170 3
	struct zsinfo *zi = zs_cd.cd_devs[unit >> 1];
	register struct zs_chanstate *cs = &zi->zi_cs[unit & 1];
	register struct tty *tp = cs->cs_ttyp;
d1172 1
d1266 4
d1271 3
a1275 1
	case TIOCMGET:
d1292 1
a1292 1
	struct zsinfo *zi = zs_cd.cd_devs[unit >> 1];
d1294 1
a1294 1
	cs = &zi->zi_cs[unit & 1];
d1353 1
a1353 1
	struct zsinfo *zi = zs_cd.cd_devs[unit >> 1];
d1355 1
a1355 1
	cs = &zi->zi_cs[unit & 1];
d1381 2
a1382 2
	struct zsinfo *zi = zs_cd.cd_devs[unit >> 1];
	register struct zs_chanstate *cs = &zi->zi_cs[unit & 1];
d1556 1
d1560 3
a1562 1
	return (zc->zc_data);
d1604 1
a1604 1
		addr = zsaddr[zs] = findzs(zs);
@


1.9
log
@netbsd port, now we merge our changes back in
@
text
@d1 1
d86 1
a86 1
#define	ZSMAJOR	12		/* XXX */
d351 1
a351 1
		tp->t_ispeed = tp->t_ospeed = cs->cs_speed;
@


1.8
log
@one tests code before one commits it. initialize ttymalloc'd struct properly.
also with mrg: use B1200 instead of 1200.
@
text
@d1 1
a1 1
/*	$NetBSD: zs.c,v 1.28 1995/04/21 15:51:26 pk Exp $ */
d51 1
a51 2
 * and runs a keyboard and mouse on zs1, and
 * possibly two more tty ports (ttyc and ttyd) on zs2.
a54 2
#include "zs.h"

d56 1
a58 1
#include <sys/conf.h>
d66 1
d69 1
d75 1
d78 1
d85 1
a85 1
#define	ZSMAJOR		12	/* XXX */
d107 2
a108 1
 * Software state per found chip.
d110 4
a113 5
struct zs_softc {
	struct	device sc_dev;			/* base device */
	volatile struct zsdevice *sc_zs;	/* chip registers */
	struct	evcnt sc_intrcnt;
	struct	zs_chanstate sc_cs[2];		/* chan A/B software state */
d119 7
a125 2
struct cfdriver zscd = {
	NULL, "zs", zsmatch, zsattach, DV_TTY, sizeof(struct zs_softc)
a139 1
void		zsstop __P((struct tty *, int));
d144 1
d146 1
d153 1
a153 1
static int zscnputc __P((int));	/* console putc function */
d155 1
a155 2
static struct tty *zs_checkcons __P((struct zs_softc *, int,
    struct zs_chanstate *));
d162 3
d167 8
a174 1
extern void *findzs __P((int));
d193 4
a196 1
static u_char
d199 1
a199 1
	u_char reg;
d210 1
a210 1
static u_char
d213 1
a213 1
	u_char reg, val;
d238 2
a239 1
	if (ca->ca_bustype==BUS_MAIN && cputyp!=CPU_SUN4)
d258 1
a258 1
	register struct zs_softc *sc;
d269 1
a269 1
		addr = zsaddr[zs] = (volatile struct zsdevice *)findzs(zs);
d286 2
a287 3
	sc = (struct zs_softc *)dev;
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);
	sc->sc_zs = addr;
d289 1
a289 1
	cs = sc->sc_cs;
a292 1
	cs[0].cs_sc = sc;
a293 1
	cs[1].cs_sc = sc;
d299 1
a299 1
	if ((ctp = zs_checkcons(sc, unit, cs)) != NULL)
a305 2
	}
	cs->cs_ttyp = tp;
a306 1
	if (ctp == NULL)
d309 2
a310 1
	ringsize = 4096;
d320 4
d325 1
d328 1
a328 1
	    M_DEVBUF, M_NOWAIT);
a330 1

d334 1
a334 1
	if ((ctp = zs_checkcons(sc, unit, cs)) != NULL)
a340 3
	}
	cs->cs_ttyp = tp;

a341 1
	if (ctp == NULL)
d344 2
a345 1
	ringsize = 4096;
d350 1
a350 1
		tp->t_ispeed = tp->t_ospeed = B1200;
d354 4
d361 1
a361 1
	    M_DEVBUF, M_NOWAIT);
d364 1
d400 1
d416 1
a416 1
	void (**fnstop) __P((struct tty *, int));
a417 1
	extern int (*v_putc)();
d427 1
a427 1
			addr = zsaddr[zs] = (volatile struct zsdevice *)findzs(zs);
d441 1
a441 1
static int
d455 1
a455 2
#ifdef SUN4C		/* XXX */
	if (cputyp==CPU_SUN4C && s <= (12 << 8))
a456 1
#endif
d469 2
a470 2
zs_checkcons(sc, unit, cs)
	struct zs_softc *sc;
d477 1
a477 1
	if ((tp = zs_ctty) == NULL)
d505 1
a505 1
	    sc->sc_dev.dv_xname, (unit & 1) + 'a', i ? (o ? "i/o" : i) : o);
d590 1
a590 1
	struct zs_softc *sc;
d593 1
a593 1
	if (zs >= zscd.cd_ndevs || (sc = zscd.cd_devs[zs]) == NULL ||
d596 1
a596 1
	cs = &sc->sc_cs[unit & 1];
d617 1
a617 1
	while (1) {
d631 3
a633 2
		if (error = ttysleep(tp, (caddr_t)&tp->t_rawq, TTIPRI | PCATCH,
		    ttopen, 0)) {
d663 1
a663 1
	struct zs_softc *sc;
d666 2
a667 2
	sc = zscd.cd_devs[unit >> 1];
	cs = &sc->sc_cs[unit & 1];
d705 1
a705 1
	register struct zs_softc *sc;
d709 2
a710 2
	sc = zscd.cd_devs[unit >> 1];
	cs = &sc->sc_cs[unit & 1];
d714 1
d724 1
a724 1
	register struct zs_softc *sc;
d728 2
a729 2
	sc = zscd.cd_devs[unit >> 1];
	cs = &sc->sc_cs[unit & 1];
d740 1
a740 1
	register struct zs_softc *sc;
d743 2
a744 2
	sc = zscd.cd_devs[unit >> 1];
	cs = &sc->sc_cs[unit & 1];
d747 1
a749 4
static int zsrint __P((struct zs_chanstate *, volatile struct zschan *));
static int zsxint __P((struct zs_chanstate *, volatile struct zschan *));
static int zssint __P((struct zs_chanstate *, volatile struct zschan *));

a766 1
	struct zs_softc *sc;
d770 3
a772 4

#define ZSHARD_NEED_SOFTINTR	1
#define ZSHARD_WAS_SERVICED	2
#define ZSHARD_CHIP_GOTINTR	4
d778 1
a778 1
			intflags |= (ZSHARD_CHIP_GOTINTR|ZSHARD_WAS_SERVICED);
d783 1
a783 1
				intflags |= ZSHARD_NEED_SOFTINTR;
d787 1
a787 1
				intflags |= ZSHARD_NEED_SOFTINTR;
d791 1
a791 1
				intflags |= ZSHARD_NEED_SOFTINTR;
d796 1
a796 1
			intflags |= (ZSHARD_CHIP_GOTINTR|ZSHARD_WAS_SERVICED);
d801 1
a801 1
				intflags |= ZSHARD_NEED_SOFTINTR;
d805 1
a805 1
				intflags |= ZSHARD_NEED_SOFTINTR;
d809 1
a809 1
				intflags |= ZSHARD_NEED_SOFTINTR;
a812 4
		if (intflags & ZSHARD_CHIP_GOTINTR) {
			a->cs_sc->sc_intrcnt.ev_count++;
			intflags &= ~ZSHARD_CHIP_GOTINTR;
		}
d816 2
a817 3
	if (intflags & ZSHARD_NEED_SOFTINTR) {
#if defined(SUN4C) || defined(SUN4M)
		if (cputyp==CPU_SUN4M || cputyp==CPU_SUN4C) {
d831 5
d837 1
a837 1
		ienab_bis(IE_ZSSOFT);
d839 1
a839 1
	return (intflags & ZSHARD_WAS_SERVICED);
d847 1
a847 1
	register u_int c;
a848 1
	c = zc->zc_data;
a849 1
	
d874 1
a874 1
	if (c == FRAME_START && cs->cs_kgdb && 
d927 1
a927 1
	register u_int rr0;
a954 1
#ifdef SUN4
d959 1
a959 1
		if (cputyp==CPU_SUN4) {
a962 1
#endif
d969 1
d986 1
d1150 3
a1152 2
	struct zs_softc *sc = zscd.cd_devs[unit >> 1];
	register struct tty *tp = sc->sc_cs[unit & 1].cs_ttyp;
a1153 1
	register struct zs_chanstate *cs = &sc->sc_cs[unit & 1];
d1190 1
a1190 1
		int userbits, driverbits = 0;
a1246 4
	case TIOCMGET:
		/* XXX: fixme */
		*(int *)data = TIOCM_CAR | TIOCM_CTS | TIOCM_DTR | TIOCM_RTS;
		return (0);
a1247 3
		/* XXX: fixme */
		zs_modem(cs, *(int *)data & (TIOCM_DTR|TIOCM_RTS));
		return (0);
d1250 1
d1267 1
a1267 1
	struct zs_softc *sc = zscd.cd_devs[unit >> 1];
d1269 1
a1269 1
	cs = &sc->sc_cs[unit & 1];
d1321 1
a1321 1
void
d1328 1
a1328 1
	struct zs_softc *sc = zscd.cd_devs[unit >> 1];
d1330 1
a1330 1
	cs = &sc->sc_cs[unit & 1];
d1341 1
d1356 2
a1357 2
	struct zs_softc *sc = zscd.cd_devs[unit >> 1];
	register struct zs_chanstate *cs = &sc->sc_cs[unit & 1];
a1530 1
	u_char c;
d1534 1
a1534 3
	c = zc->zc_data;
	ZS_DELAY();
	return c;
d1576 1
a1576 1
		addr = zsaddr[zs] = (volatile struct zsdevice *)findzs(zs);
@


1.7
log
@by mrg and myself on irc: fix a ttymalloc() memory leak, TIOCM* botch
@
text
@a281 3
	tp->t_dev = makedev(ZSMAJOR, unit);
	tp->t_oproc = zsstart;
	tp->t_param = zsparam;
d284 1
a284 1
	else
d286 4
a314 3
	tp->t_dev = makedev(ZSMAJOR, unit);
	tp->t_oproc = zsstart;
	tp->t_param = zsparam;
d317 1
a317 1
	else
d319 4
d334 1
a334 1
		tp->t_ispeed = tp->t_ospeed = 1200;
@


1.6
log
@settable ring buffer sizes from pk
@
text
@a278 1
	cs->cs_ttyp = tp = ttymalloc();
d286 3
a288 1
		cs->cs_ttyp = tp = ctp;
d310 1
a310 1
	cs->cs_ttyp = tp = ttymalloc();
d318 5
a322 1
		cs->cs_ttyp = tp = ctp;
d829 1
a829 1
	register int c;
d911 1
a911 1
	register int rr0;
d1233 1
a1233 1
		zs_modem(cs, *(int *)data & (TIOCM_DTR|TIOCM_RTS));
d1237 1
a1237 1
		*(int *)data = TIOCM_CAR | TIOCM_CTS | TIOCM_DTR | TIOCM_RTS;
@


1.5
log
@unconditionally set mouse port to CS8/1200
@
text
@d64 1
d246 1
d293 1
d302 1
d304 3
d322 1
d330 1
d332 3
d745 1
a745 1
	register int rr3, intflags = 0, v, i;
d752 1
d759 1
a759 1
				a->cs_rbuf[i++ & ZLRB_RING_MASK] = v;
d763 1
a763 1
				a->cs_rbuf[i++ & ZLRB_RING_MASK] = v;
d767 1
a767 1
				a->cs_rbuf[i++ & ZLRB_RING_MASK] = v;
d777 1
a777 1
				b->cs_rbuf[i++ & ZLRB_RING_MASK] = v;
d781 1
a781 1
				b->cs_rbuf[i++ & ZLRB_RING_MASK] = v;
d785 1
a785 1
				b->cs_rbuf[i++ & ZLRB_RING_MASK] = v;
d1003 1
a1003 1
	register int get, n, c, cc, unit, s;
d1007 1
d1027 1
d1029 1
a1029 1
		if (n > ZLRB_RING_SIZE) {
d1031 2
a1032 2
			get += n - ZLRB_RING_SIZE;
			n = ZLRB_RING_SIZE;
d1036 1
a1036 1
			c = cs->cs_rbuf[get++ & ZLRB_RING_MASK];
@


1.4
log
@include file botch
@
text
@d83 1
a83 1
#define	ZSMAJOR	12		/* XXX */
d158 1
a158 1
volatile static struct zsdevice *zsaddr[NZS];	/* XXX, but saves work */
d319 2
d1500 1
a1500 1
	int c;
@


1.3
log
@volatile struct zschan
@
text
@d76 1
a76 1
#include <dev/ic/z8530.h>
@


1.2
log
@support more than 2 zs chips; rename softc; interrupt counters
add missing ZS_DELAY()'s; add (working?) TIOCMGET/TIOCMSET;
@
text
@d108 2
a109 2
	struct	device sc_dev;		/* base device */
	struct	zsdevice *sc_zs;	/* chip registers */
d111 1
a111 1
	struct	zs_chanstate sc_cs[2];	/* channel A and B software state */
d147 2
a148 1
static struct tty *zs_checkcons __P((struct zs_softc *, int, struct zs_chanstate *));
d157 2
a158 2
extern struct zsdevice *findzs(int);
static struct zsdevice *zsaddr[NZS];	/* XXX, but saves work */
d239 1
a239 1
	register struct zsdevice *addr;
d247 1
a247 1
		addr = zsaddr[zs] = findzs(zs);
d377 1
a377 1
	struct zsdevice *addr;
d385 1
a385 1
			addr = zsaddr[zs] = findzs(zs);
d707 4
a731 3
	static int zsrint __P((struct zs_chanstate *, volatile struct zschan *));
	static int zsxint __P((struct zs_chanstate *, volatile struct zschan *));
	static int zssint __P((struct zs_chanstate *, volatile struct zschan *));
d1530 1
a1530 1
	struct zsdevice *addr;
d1546 1
a1546 1
		addr = zsaddr[zs] = findzs(zs);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: zs.c,v 1.31 1995/06/28 04:31:21 cgd Exp $ */
d51 2
a52 1
 * and runs a keyboard and mouse on zs1.
d56 1
a56 1
#define	NZS	2		/* XXX */
d76 1
a76 1
#include <dev/ic/z8530reg.h>
d105 1
a105 2
 * Software state per found chip.  This would be called `zs_softc',
 * but the previous driver had a rather different zs_softc....
d107 5
a111 4
struct zsinfo {
	struct	device zi_dev;		/* base device */
	volatile struct zsdevice *zi_zs;/* chip registers */
	struct	zs_chanstate zi_cs[2];	/* channel A and B software state */
d117 3
a119 2
struct cfdriver zscd =
    { NULL, "zs", zsmatch, zsattach, DV_TTY, sizeof(struct zsinfo) };
d147 1
a147 1
static struct tty *zs_checkcons __P((struct zsinfo *, int, struct zs_chanstate *));
d156 2
a157 2
extern volatile struct zsdevice *findzs(int);
static volatile struct zsdevice *zsaddr[NZS];	/* XXX, but saves work */
d236 1
a236 1
	register struct zsinfo *zi;
d238 1
a238 1
	register volatile struct zsdevice *addr;
d263 3
a265 2
	zi = (struct zsinfo *)dev;
	zi->zi_zs = addr;
d267 1
a267 2
	cs = zi->zi_cs;
	cs->cs_ttyp = tp = ttymalloc();
d271 1
d273 1
d276 1
d283 1
a283 1
	if ((ctp = zs_checkcons(zi, unit, cs)) != NULL)
d285 1
d308 1
a308 1
	if ((ctp = zs_checkcons(zi, unit, cs)) != NULL)
a317 2
		tp->t_ispeed = tp->t_ospeed = cs->cs_speed;
		tp->t_cflag = CS8;
d376 1
a376 1
	volatile struct zsdevice *addr;
d428 2
a429 2
zs_checkcons(zi, unit, cs)
	struct zsinfo *zi;
d436 1
a436 1
	if ((tp = zs_ctty) == NULL) /* XXX */
d464 1
a464 1
	    zi->zi_dev.dv_xname, (unit & 1) + 'a', i ? (o ? "i/o" : i) : o);
d549 1
a549 1
	struct zsinfo *zi;
d552 1
a552 1
	if (zs >= zscd.cd_ndevs || (zi = zscd.cd_devs[zs]) == NULL ||
d555 1
a555 1
	cs = &zi->zi_cs[unit & 1];
d576 1
a576 1
	for (;;) {
d621 1
a621 1
	struct zsinfo *zi;
d624 2
a625 2
	zi = zscd.cd_devs[unit >> 1];
	cs = &zi->zi_cs[unit & 1];
d663 1
a663 1
	register struct zsinfo *zi;
d667 2
a668 2
	zi = zscd.cd_devs[unit >> 1];
	cs = &zi->zi_cs[unit & 1];
a671 1

d681 1
a681 1
	register struct zsinfo *zi;
d685 2
a686 2
	zi = zscd.cd_devs[unit >> 1];
	cs = &zi->zi_cs[unit & 1];
d697 1
a697 1
	register struct zsinfo *zi;
d700 2
a701 2
	zi = zscd.cd_devs[unit >> 1];
	cs = &zi->zi_cs[unit & 1];
a703 1

d723 1
d727 7
a733 3
	static int zsrint(struct zs_chanstate *, volatile struct zschan *);
	static int zsxint(struct zs_chanstate *, volatile struct zschan *);
	static int zssint(struct zs_chanstate *, volatile struct zschan *);
d738 1
a738 1
			intflags |= 2;
d743 1
a743 1
				intflags |= 1;
d747 1
a747 1
				intflags |= 1;
d751 1
a751 1
				intflags |= 1;
d756 1
a756 1
			intflags |= 2;
d761 1
a761 1
				intflags |= 1;
d765 1
a765 1
				intflags |= 1;
d769 1
a769 1
				intflags |= 1;
d773 4
d780 1
a780 1
	if (intflags & 1) {
d799 1
a799 1
	return (intflags & 2);
d807 1
a807 1
	register int c = zc->zc_data;
d809 1
d811 1
d1110 2
a1111 3
	struct zsinfo *zi = zscd.cd_devs[unit >> 1];
	register struct zs_chanstate *cs = &zi->zi_cs[unit & 1];
	register struct tty *tp = cs->cs_ttyp;
d1113 1
d1207 4
d1212 3
a1216 1
	case TIOCMGET:
d1233 1
a1233 1
	struct zsinfo *zi = zscd.cd_devs[unit >> 1];
d1235 1
a1235 1
	cs = &zi->zi_cs[unit & 1];
d1294 1
a1294 1
	struct zsinfo *zi = zscd.cd_devs[unit >> 1];
d1296 1
a1296 1
	cs = &zi->zi_cs[unit & 1];
d1321 2
a1322 2
	struct zsinfo *zi = zscd.cd_devs[unit >> 1];
	register struct zs_chanstate *cs = &zi->zi_cs[unit & 1];
d1496 1
d1500 3
a1502 1
	return (zc->zc_data);
d1528 1
a1528 1
	volatile struct zsdevice *addr;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

