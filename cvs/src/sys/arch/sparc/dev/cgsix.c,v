head	1.44;
access;
symbols
	OPENBSD_6_0:1.44.0.12
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.44.0.8
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.44.0.10
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.44.0.2
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.44.0.6
	OPENBSD_5_6_BASE:1.44
	OPENBSD_5_5:1.44.0.4
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.43.0.14
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.43.0.12
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.43.0.10
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.8
	OPENBSD_5_0:1.43.0.6
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.43.0.4
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.43.0.2
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.40.0.6
	OPENBSD_4_6_BASE:1.40
	OPENBSD_4_5:1.40.0.2
	OPENBSD_4_5_BASE:1.40
	OPENBSD_4_4:1.38.0.8
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3:1.38.0.6
	OPENBSD_4_3_BASE:1.38
	OPENBSD_4_2:1.38.0.4
	OPENBSD_4_2_BASE:1.38
	OPENBSD_4_1:1.38.0.2
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.35.0.2
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.33.0.4
	OPENBSD_3_9_BASE:1.33
	OPENBSD_3_8:1.33.0.2
	OPENBSD_3_8_BASE:1.33
	OPENBSD_3_7:1.32.0.2
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.28.0.6
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.28.0.4
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.21
	UBC:1.17.0.2
	UBC_BASE:1.17
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.4
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.6
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.4
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.10.0.6
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.4
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.7.0.4
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.44
date	2013.10.20.20.07.25;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2010.07.10.19.32.24;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2010.06.07.19.43.45;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2009.09.05.14.09.35;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2008.12.26.22.30.21;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2008.12.26.15.34.10;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2007.02.18.18.40.35;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2006.12.03.16.38.13;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2006.12.02.11.21.35;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2006.07.25.21.23.30;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2006.06.02.20.00.54;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2005.03.23.17.16.34;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2005.03.07.16.44.50;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2005.01.05.23.04.24;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2004.11.29.22.07.36;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2004.09.29.07.35.11;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.28.17.05.33;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.28.13.32.25;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.02.23.27.53;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.02.18.40.59;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.28.21.40.41;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2002.12.12.23.35.32;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2002.11.06.21.06.20;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2002.09.23.18.13.38;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2002.09.09.22.15.16;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.12.10.44.03;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.26.42;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.11.01.12.13.46;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.17.13.52.28;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.10.10.34.43;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.18.13.31.12;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	99.05.08.01.15.58;	author jason;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	99.04.22.16.52.47;	author art;	state Exp;
branches;
next	1.10;

1.10
date	97.12.23.21.43.19;	author chuck;	state Exp;
branches;
next	1.9;

1.9
date	97.09.17.06.47.07;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	97.08.08.08.24.51;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	96.08.13.08.05.22;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.08.11.05.34.10;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	95.12.15.13.56.17;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.11.09.21.34.46;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.10.22.11.29.54;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.19.13.12.53;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.38;	author deraadt;	state Exp;
branches;
next	;

1.12.4.1
date	2001.05.14.21.37.03;	author niklas;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2001.07.04.10.23.22;	author niklas;	state Exp;
branches;
next	1.12.4.3;

1.12.4.3
date	2001.10.31.03.07.56;	author nate;	state Exp;
branches;
next	1.12.4.4;

1.12.4.4
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.12.4.5;

1.12.4.5
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.12.4.6;

1.12.4.6
date	2003.03.27.23.49.25;	author niklas;	state Exp;
branches;
next	1.12.4.7;

1.12.4.7
date	2003.05.13.19.41.08;	author ho;	state Exp;
branches;
next	1.12.4.8;

1.12.4.8
date	2003.06.07.11.14.42;	author ho;	state Exp;
branches;
next	1.12.4.9;

1.12.4.9
date	2004.02.19.10.49.57;	author niklas;	state Exp;
branches;
next	;

1.17.2.1
date	2002.06.11.03.38.15;	author art;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.10.29.00.28.09;	author art;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@/*	$OpenBSD: cgsix.c,v 1.43 2010/07/10 19:32:24 miod Exp $	*/
/*	$NetBSD: cgsix.c,v 1.33 1997/08/07 19:12:30 pk Exp $ */

/*
 * Copyright (c) 2002 Miodrag Vallat.  All rights reserved.
 * Copyright (c) 2001 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 *
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)cgsix.c	8.4 (Berkeley) 1/21/94
 */

/*
 * color display (cgsix) driver.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/pmap.h>
#include <machine/cpu.h>
#if defined(SUN4)
#include <machine/eeprom.h>
#endif
#include <machine/conf.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

#include <sparc/dev/btreg.h>
#include <sparc/dev/btvar.h>
#include <sparc/dev/cgsixreg.h>
#include <dev/ic/bt458reg.h>

#if defined(SUN4)
#include <sparc/dev/pfourreg.h>
#endif

/* per-display variables */
struct cgsix_softc {
	struct	sunfb sc_sunfb;		/* common base part */
	struct	rom_reg sc_phys;	/* phys addr of h/w */
	volatile struct bt_regs *sc_bt;		/* Brooktree registers */
	volatile int *sc_fhc;			/* FHC register */
	volatile struct cgsix_thc *sc_thc;	/* THC registers */
	volatile struct cgsix_fbc *sc_fbc;	/* FBC registers */
	volatile struct cgsix_tec_xxx *sc_tec;	/* TEC registers */
	union	bt_cmap sc_cmap;	/* Brooktree color map */
	struct	intrhand sc_ih;
};

void	cgsix_burner(void *, u_int, u_int);
int	cgsix_intr(void *);
int	cgsix_ioctl(void *, u_long, caddr_t, int, struct proc *);
static __inline__
void	cgsix_loadcmap_deferred(struct cgsix_softc *, u_int, u_int);
paddr_t	cgsix_mmap(void *, off_t, int);
void	cgsix_reset(struct cgsix_softc *, u_int);
void	cgsix_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);

int	cgsix_ras_copyrows(void *, int, int, int);
int	cgsix_ras_copycols(void *, int, int, int, int);
int	cgsix_ras_do_cursor(struct rasops_info *);
int	cgsix_ras_erasecols(void *, int, int, int, long);
int	cgsix_ras_eraserows(void *, int, int, long);
void	cgsix_ras_init(struct cgsix_softc *);

struct wsdisplay_accessops cgsix_accessops = {
	.ioctl = cgsix_ioctl,
	.mmap = cgsix_mmap,
	.burn_screen = cgsix_burner
};

int	cgsixmatch(struct device *, void *, void *);
void	cgsixattach(struct device *, struct device *, void *);

struct cfattach cgsix_ca = {
	sizeof(struct cgsix_softc), cgsixmatch, cgsixattach
};

struct cfdriver cgsix_cd = {
	NULL, "cgsix", DV_DULL
};

int
cgsixmatch(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

	if (strcmp(ra->ra_name, cf->cf_driver->cd_name) &&
	    strcmp(ra->ra_name, "SUNW,cgsix"))
		return (0);

	switch (ca->ca_bustype) {
	case BUS_SBUS:
		return (1);
	case BUS_OBIO:
#if defined(SUN4)
		if (CPU_ISSUN4) {
			void *tmp;

			/*
			 * Check for a pfour framebuffer.  This is done
			 * somewhat differently on the cgsix than other
			 * pfour framebuffers.
			 */
			bus_untmp();
			tmp = (caddr_t)mapdev(ra->ra_reg, TMPMAP_VA,
			    CGSIX_FHC_OFFSET, NBPG);
			if (probeget(tmp, 4) == -1)
				return (0);

			if (fb_pfour_id(tmp) == PFOUR_ID_FASTCOLOR)
				return (1);
		}
#endif
		/* FALLTHROUGH */
	default:
		return (0);
	}
}

void
cgsixattach(struct device *parent, struct device *self, void *args)
{
	struct cgsix_softc *sc = (struct cgsix_softc *)self;
	struct confargs *ca = args;
	int node, pri;
	int isconsole = 0, sbus = 1;
	char *nam;
	u_int fhcrev;

	pri = ca->ca_ra.ra_intr[0].int_pri;
	printf(" pri %d: ", pri);

	/*
	 * Map just BT, FHC, FBC, THC, and video RAM.
	 */
	sc->sc_phys = ca->ca_ra.ra_reg[0];
	sc->sc_bt = (volatile struct bt_regs *)
	   mapiodev(ca->ca_ra.ra_reg, CGSIX_BT_OFFSET, CGSIX_BT_SIZE);
	sc->sc_fhc = (volatile int *)
	   mapiodev(ca->ca_ra.ra_reg, CGSIX_FHC_OFFSET, CGSIX_FHC_SIZE);
	sc->sc_thc = (volatile struct cgsix_thc *)
	   mapiodev(ca->ca_ra.ra_reg, CGSIX_THC_OFFSET, CGSIX_THC_SIZE);
	sc->sc_fbc = (volatile struct cgsix_fbc *)
	   mapiodev(ca->ca_ra.ra_reg, CGSIX_FBC_OFFSET, CGSIX_FBC_SIZE);
	sc->sc_tec = (volatile struct cgsix_tec_xxx *)
	   mapiodev(ca->ca_ra.ra_reg, CGSIX_TEC_OFFSET, CGSIX_TEC_SIZE);

	switch (ca->ca_bustype) {
	case BUS_OBIO:
		sbus = node = 0;
		SET(sc->sc_sunfb.sf_flags, FB_PFOUR);
		nam = "p4";
		break;
	case BUS_SBUS:
		node = ca->ca_ra.ra_node;
		nam = getpropstring(node, "model");
		break;
	}

	if (*nam != '\0')
		printf("%s, ", nam);

#if defined(SUN4)
	if (CPU_ISSUN4) {
		struct eeprom *eep = (struct eeprom *)eeprom_va;
		int constype = ISSET(sc->sc_sunfb.sf_flags, FB_PFOUR) ?
		    EED_CONS_P4 : EED_CONS_COLOR;
		/*
		 * Assume this is the console if there's no eeprom info
		 * to be found.
		 */
		if (eep == NULL || eep->ee_diag.eed_console == constype)
			isconsole = 1;
	}
#endif

	if (!CPU_ISSUN4)
		isconsole = node == fbnode;

	fhcrev = (*sc->sc_fhc >> FHC_REV_SHIFT) &
	    (FHC_REV_MASK >> FHC_REV_SHIFT);

	sc->sc_ih.ih_fun = cgsix_intr;
	sc->sc_ih.ih_arg = sc;
	intr_establish(pri, &sc->sc_ih, IPL_FB, self->dv_xname);

	/* reset cursor & frame buffer controls */
	cgsix_reset(sc, fhcrev);

	/* enable video */
	cgsix_burner(sc, 1, 0);

	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, ca->ca_bustype);
        sc->sc_sunfb.sf_ro.ri_bits = mapiodev(ca->ca_ra.ra_reg,
	    CGSIX_VID_OFFSET, round_page(sc->sc_sunfb.sf_fbsize));
	sc->sc_sunfb.sf_ro.ri_hw = sc;

	printf("%dx%d, rev %d\n", sc->sc_sunfb.sf_width,
	    sc->sc_sunfb.sf_height, fhcrev);

	fbwscons_init(&sc->sc_sunfb, isconsole);
	fbwscons_setcolormap(&sc->sc_sunfb, cgsix_setcolor);

	/*
	 * Old rev. cg6 cards do not like the current acceleration code.
	 *
	 * Some hints from Sun point out at timing and cache problems, which
	 * will be investigated later.
	 */
	if (fhcrev >= 5) {
		sc->sc_sunfb.sf_ro.ri_ops.copyrows = cgsix_ras_copyrows;
		sc->sc_sunfb.sf_ro.ri_ops.copycols = cgsix_ras_copycols;
		sc->sc_sunfb.sf_ro.ri_ops.eraserows = cgsix_ras_eraserows;
		sc->sc_sunfb.sf_ro.ri_ops.erasecols = cgsix_ras_erasecols;
		sc->sc_sunfb.sf_ro.ri_do_cursor = cgsix_ras_do_cursor;
		cgsix_ras_init(sc);
	}

	if (isconsole)
		fbwscons_console_init(&sc->sc_sunfb, -1);

	fbwscons_attach(&sc->sc_sunfb, &cgsix_accessops, isconsole);
}

int
cgsix_ioctl(void *dev, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct cgsix_softc *sc = dev;
	struct wsdisplay_cmap *cm;
	struct wsdisplay_fbinfo *wdf;
	int error;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG6;
		break;
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
		wdf->cmsize = 256;
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
		break;

	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_getcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		break;

	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		cgsix_loadcmap_deferred(sc, cm->index, cm->count);
		break;

	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
		break;

	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
	default:
		return (-1);	/* not supported yet */
	}

	return (0);
}

/*
 * Clean up hardware state (e.g., after bootup or after X crashes).
 */
void
cgsix_reset(struct cgsix_softc *sc, u_int fhcrev)
{
	volatile struct cgsix_tec_xxx *tec;
	int fhc;
	volatile struct bt_regs *bt;

	/* hide the cursor, just in case */
	sc->sc_thc->thc_cursxy = THC_CURSOFF;

	/* turn off frobs in transform engine (makes X11 work) */
	tec = sc->sc_tec;
	tec->tec_mv = 0;
	tec->tec_clip = 0;
	tec->tec_vdc = 0;

	/* take care of hardware bugs in old revisions */
	if (fhcrev < 5) {
		/*
		 * Keep current resolution; set cpu to 68020, set test
		 * window (size 1Kx1K), and for rev 1, disable dest cache.
		 */
		fhc = (*sc->sc_fhc & FHC_RES_MASK) | FHC_CPU_68020 |
		    FHC_TEST |
		    (11 << FHC_TESTX_SHIFT) | (11 << FHC_TESTY_SHIFT);
		if (fhcrev < 2)
			fhc |= FHC_DST_DISABLE;
		*sc->sc_fhc = fhc;
	}

	/* Enable cursor in Brooktree DAC. */
	bt = sc->sc_bt;
	bt->bt_addr = BT_CR << 24;
	bt->bt_ctrl |= (BTCR_DISPENA_OV1 | BTCR_DISPENA_OV0) << 24;
}

paddr_t
cgsix_mmap(void *v, off_t offset, int prot)
{
	struct cgsix_softc *sc = v;

	if (offset & PGOFSET)
		return (-1);

	/* Allow mapping as a dumb framebuffer from offset 0 */
	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys, offset + CGSIX_VID_OFFSET) |
		    PMAP_NC);
	}

	return (-1);
}

void
cgsix_setcolor(void *v, u_int index, u_int8_t r, u_int8_t g, u_int8_t b)
{
	struct cgsix_softc *sc = v;

	bt_setcolor(&sc->sc_cmap, sc->sc_bt, index, r, g, b, 1);
}

static __inline__ void
cgsix_loadcmap_deferred(struct cgsix_softc *sc, u_int start, u_int ncolors)
{
	u_int32_t thcm;

	thcm = sc->sc_thc->thc_misc;
	thcm &= ~THC_MISC_RESET;
	thcm |= THC_MISC_INTEN;
	sc->sc_thc->thc_misc = thcm;
}

void
cgsix_burner(void *v, u_int on, u_int flags)
{
	struct cgsix_softc *sc = v;
	int s;
	u_int32_t thcm;

	s = splhigh();
	thcm = sc->sc_thc->thc_misc;
	if (on)
		thcm |= THC_MISC_VIDEN | THC_MISC_SYNCEN;
	else {
		thcm &= ~THC_MISC_VIDEN;
		if (flags & WSDISPLAY_BURN_VBLANK)
			thcm &= ~THC_MISC_SYNCEN;
	}
	sc->sc_thc->thc_misc = thcm;
	splx(s);
}

int
cgsix_intr(void *v)
{
	struct cgsix_softc *sc = v;
	u_int32_t thcm;

	thcm = sc->sc_thc->thc_misc;
	if ((thcm & (THC_MISC_INTEN | THC_MISC_INTR)) !=
	    (THC_MISC_INTEN | THC_MISC_INTR)) {
		/* Not expecting an interrupt, it's not for us. */
		return (0);
	}

	/* Acknowledge the interrupt and disable it. */
	thcm &= ~(THC_MISC_RESET | THC_MISC_INTEN);
	thcm |= THC_MISC_INTR;
	sc->sc_thc->thc_misc = thcm;
	bt_loadcmap(&sc->sc_cmap, sc->sc_bt, 0, 256, 1);
	return (1);
}

/*
 * Specifics rasops handlers for accelerated console
 */

#define	CG6_BLIT_WAIT(fbc) \
	while (((fbc)->fbc_blit & (FBC_BLIT_UNKNOWN | FBC_BLIT_GXFULL)) == \
	    (FBC_BLIT_UNKNOWN | FBC_BLIT_GXFULL))
#define	CG6_DRAW_WAIT(fbc) \
	while (((fbc)->fbc_draw & (FBC_DRAW_UNKNOWN | FBC_DRAW_GXFULL)) == \
	    (FBC_DRAW_UNKNOWN | FBC_DRAW_GXFULL))
#define	CG6_DRAIN(fbc) \
	while ((fbc)->fbc_s & FBC_S_GXINPROGRESS)

void
cgsix_ras_init(struct cgsix_softc *sc)
{
	u_int32_t m;

	CG6_DRAIN(sc->sc_fbc);
	m = sc->sc_fbc->fbc_mode;
	m &= ~FBC_MODE_MASK;
	m |= FBC_MODE_VAL;
	sc->sc_fbc->fbc_mode = m;
}

int
cgsix_ras_copyrows(void *cookie, int src, int dst, int n)
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;
	volatile struct cgsix_fbc *fbc = sc->sc_fbc;

	if (dst == src)
		return 0;
	if (src < 0) {
		n += src;
		src = 0;
	}
	if (src + n > ri->ri_rows)
		n = ri->ri_rows - src;
	if (dst < 0) {
		n += dst;
		dst = 0;
	}
	if (dst + n > ri->ri_rows)
		n = ri->ri_rows - dst;
	if (n <= 0)
		return 0;
	n *= ri->ri_font->fontheight;
	src *= ri->ri_font->fontheight;
	dst *= ri->ri_font->fontheight;

	fbc->fbc_clip = 0;
	fbc->fbc_s = 0;
	fbc->fbc_offx = 0;
	fbc->fbc_offy = 0;
	fbc->fbc_clipminx = 0;
	fbc->fbc_clipminy = 0;
	fbc->fbc_clipmaxx = ri->ri_width - 1;
	fbc->fbc_clipmaxy = ri->ri_height - 1;
	fbc->fbc_alu = FBC_ALU_COPY;
	fbc->fbc_x0 = ri->ri_xorigin;
	fbc->fbc_y0 = ri->ri_yorigin + src;
	fbc->fbc_x1 = ri->ri_xorigin + ri->ri_emuwidth - 1;
	fbc->fbc_y1 = ri->ri_yorigin + src + n - 1;
	fbc->fbc_x2 = ri->ri_xorigin;
	fbc->fbc_y2 = ri->ri_yorigin + dst;
	fbc->fbc_x3 = ri->ri_xorigin + ri->ri_emuwidth - 1;
	fbc->fbc_y3 = ri->ri_yorigin + dst + n - 1;
	CG6_BLIT_WAIT(fbc);
	CG6_DRAIN(fbc);

	return 0;
}

int
cgsix_ras_copycols(void *cookie, int row, int src, int dst, int n)
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;
	volatile struct cgsix_fbc *fbc = sc->sc_fbc;

	if (dst == src)
		return 0;
	if ((row < 0) || (row >= ri->ri_rows))
		return 0;
	if (src < 0) {
		n += src;
		src = 0;
	}
	if (src + n > ri->ri_cols)
		n = ri->ri_cols - src;
	if (dst < 0) {
		n += dst;
		dst = 0;
	}
	if (dst + n > ri->ri_cols)
		n = ri->ri_cols - dst;
	if (n <= 0)
		return 0;
	n *= ri->ri_font->fontwidth;
	src *= ri->ri_font->fontwidth;
	dst *= ri->ri_font->fontwidth;
	row *= ri->ri_font->fontheight;

	fbc->fbc_clip = 0;
	fbc->fbc_s = 0;
	fbc->fbc_offx = 0;
	fbc->fbc_offy = 0;
	fbc->fbc_clipminx = 0;
	fbc->fbc_clipminy = 0;
	fbc->fbc_clipmaxx = ri->ri_width - 1;
	fbc->fbc_clipmaxy = ri->ri_height - 1;
	fbc->fbc_alu = FBC_ALU_COPY;
	fbc->fbc_x0 = ri->ri_xorigin + src;
	fbc->fbc_y0 = ri->ri_yorigin + row;
	fbc->fbc_x1 = ri->ri_xorigin + src + n - 1;
	fbc->fbc_y1 = ri->ri_yorigin + row + ri->ri_font->fontheight - 1;
	fbc->fbc_x2 = ri->ri_xorigin + dst;
	fbc->fbc_y2 = ri->ri_yorigin + row;
	fbc->fbc_x3 = ri->ri_xorigin + dst + n - 1;
	fbc->fbc_y3 = ri->ri_yorigin + row + ri->ri_font->fontheight - 1;
	CG6_BLIT_WAIT(fbc);
	CG6_DRAIN(fbc);

	return 0;
}

int
cgsix_ras_erasecols(void *cookie, int row, int col, int n, long attr)
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;
	volatile struct cgsix_fbc *fbc = sc->sc_fbc;
	int fg, bg;

	if ((row < 0) || (row >= ri->ri_rows))
		return 0;
	if (col < 0) {
		n += col;
		col = 0;
	}
	if (col + n > ri->ri_cols)
		n = ri->ri_cols - col;
	if (n <= 0)
		return 0;
	n *= ri->ri_font->fontwidth;
	col *= ri->ri_font->fontwidth;
	row *= ri->ri_font->fontheight;

	ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);

	fbc->fbc_clip = 0;
	fbc->fbc_s = 0;
	fbc->fbc_offx = 0;
	fbc->fbc_offy = 0;
	fbc->fbc_clipminx = 0;
	fbc->fbc_clipminy = 0;
	fbc->fbc_clipmaxx = ri->ri_width - 1;
	fbc->fbc_clipmaxy = ri->ri_height - 1;
	fbc->fbc_alu = FBC_ALU_FILL;
	fbc->fbc_fg = ri->ri_devcmap[bg];
	fbc->fbc_arecty = ri->ri_yorigin + row;
	fbc->fbc_arectx = ri->ri_xorigin + col;
	fbc->fbc_arecty = ri->ri_yorigin + row + ri->ri_font->fontheight - 1;
	fbc->fbc_arectx = ri->ri_xorigin + col + n - 1;
	CG6_DRAW_WAIT(fbc);
	CG6_DRAIN(fbc);

	return 0;
}

int
cgsix_ras_eraserows(void *cookie, int row, int n, long attr)
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;
	volatile struct cgsix_fbc *fbc = sc->sc_fbc;
	int fg, bg;

	if (row < 0) {
		n += row;
		row = 0;
	}
	if (row + n > ri->ri_rows)
		n = ri->ri_rows - row;
	if (n <= 0)
		return 0;

	ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);

	fbc->fbc_clip = 0;
	fbc->fbc_s = 0;
	fbc->fbc_offx = 0;
	fbc->fbc_offy = 0;
	fbc->fbc_clipminx = 0;
	fbc->fbc_clipminy = 0;
	fbc->fbc_clipmaxx = ri->ri_width - 1;
	fbc->fbc_clipmaxy = ri->ri_height - 1;
	fbc->fbc_alu = FBC_ALU_FILL;
	fbc->fbc_fg = ri->ri_devcmap[bg];
	if ((n == ri->ri_rows) && (ri->ri_flg & RI_FULLCLEAR)) {
		fbc->fbc_arecty = 0;
		fbc->fbc_arectx = 0;
		fbc->fbc_arecty = ri->ri_height - 1;
		fbc->fbc_arectx = ri->ri_width - 1;
	} else {
		row *= ri->ri_font->fontheight;
		fbc->fbc_arecty = ri->ri_yorigin + row;
		fbc->fbc_arectx = ri->ri_xorigin;
		fbc->fbc_arecty =
		    ri->ri_yorigin + row + (n * ri->ri_font->fontheight) - 1;
		fbc->fbc_arectx =
		    ri->ri_xorigin + ri->ri_emuwidth - 1;
	}
	CG6_DRAW_WAIT(fbc);
	CG6_DRAIN(fbc);

	return 0;
}

int
cgsix_ras_do_cursor(struct rasops_info *ri)
{
	struct cgsix_softc *sc = ri->ri_hw;
	int row, col;
	volatile struct cgsix_fbc *fbc = sc->sc_fbc;

	row = ri->ri_crow * ri->ri_font->fontheight;
	col = ri->ri_ccol * ri->ri_font->fontwidth;
	fbc->fbc_clip = 0;
	fbc->fbc_s = 0;
	fbc->fbc_offx = 0;
	fbc->fbc_offy = 0;
	fbc->fbc_clipminx = 0;
	fbc->fbc_clipminy = 0;
	fbc->fbc_clipmaxx = ri->ri_width - 1;
	fbc->fbc_clipmaxy = ri->ri_height - 1;
	fbc->fbc_alu = FBC_ALU_FLIP;
	fbc->fbc_arecty = ri->ri_yorigin + row;
	fbc->fbc_arectx = ri->ri_xorigin + col;
	fbc->fbc_arecty = ri->ri_yorigin + row + ri->ri_font->fontheight - 1;
	fbc->fbc_arectx = ri->ri_xorigin + col + ri->ri_font->fontwidth - 1;
	CG6_DRAW_WAIT(fbc);
	CG6_DRAIN(fbc);

	return 0;
}
@


1.43
log
@sun4e (i.e. SPARCengine 1e) support. This platform is a mix between sun4 and
sun4c, as it has a sun4c OpenPROM but a sun4 8KB pagesize. VME devices are
not supported yet.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.42 2010/06/07 19:43:45 miod Exp $	*/
d136 3
a138 10
	cgsix_ioctl,
	cgsix_mmap,
	NULL,	/* alloc_screen */
	NULL,	/* free_screen */
	NULL,	/* show_screen */
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	cgsix_burner,
	NULL	/* pollc */
@


1.42
log
@Nuke old eeprom.h compatibility defines; ok todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.41 2009/09/05 14:09:35 miod Exp $	*/
d256 1
a256 1
	if (CPU_ISSUN4COR4M)
@


1.41
log
@Change the wsdisplay_emulops return types from void to int; emulops will now
return zero on success and nonzero on failure.
This commit only performs mechanical changes for the existing emulops to
always return zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.40 2008/12/26 22:30:21 miod Exp $	*/
d246 1
a246 1
		    EE_CONS_P4OPT : EE_CONS_COLOR;
d251 1
a251 1
		if (eep == NULL || eep->eeConsole == constype)
@


1.40
log
@Move the logic responsible from deciding whether a frame buffer needs to be
cleared on attach, from the individual drivers to the common frame buffer code;
the latter will decide based on the prom font metrics and the prom console
window position, whenever possible.

This removes the need for the console window position to be hardcoded in
the p9100 driver, and will no longer require a screen clear on a vigra
VS-12 in high resolution mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.39 2008/12/26 15:34:10 miod Exp $	*/
d128 5
a132 5
void	cgsix_ras_copyrows(void *, int, int, int);
void	cgsix_ras_copycols(void *, int, int, int, int);
void	cgsix_ras_do_cursor(struct rasops_info *);
void	cgsix_ras_erasecols(void *, int, int, int, long);
void	cgsix_ras_eraserows(void *, int, int, long);
d499 1
a499 1
void
d507 1
a507 1
		return;
d521 1
a521 1
		return;
d545 2
d549 1
a549 1
void
d557 1
a557 1
		return;
d559 1
a559 1
		return;
d573 1
a573 1
		return;
d598 2
d602 1
a602 1
void
d611 1
a611 1
		return;
d619 1
a619 1
		return;
d642 2
d646 1
a646 1
void
d661 1
a661 1
		return;
d691 2
d695 1
a695 1
void
d719 2
@


1.39
log
@Use constants from bt458reg.h when frobbing ramdac registers.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.38 2007/02/18 18:40:35 miod Exp $	*/
d277 4
a280 13
	/*
	 * If the framebuffer width is under 1024x768, we will switch from the
	 * PROM font to the more adequate 8x16 font here.
	 * However, we need to adjust two things in this case:
	 * - the display row should be overrided from the current PROM metrics,
	 *   to prevent us from overwriting the last few lines of text.
	 * - if the 80x34 screen would make a large margin appear around it,
	 *   choose to clear the screen rather than keeping old prom output in
	 *   the margins.
	 * XXX there should be a rasops "clear margins" feature
	 */
	fbwscons_init(&sc->sc_sunfb, isconsole &&
	    (sc->sc_sunfb.sf_width >= 1024) ? 0 : RI_CLEAR);
d298 2
a299 7
	printf("%dx%d, rev %d\n", sc->sc_sunfb.sf_width,
	    sc->sc_sunfb.sf_height, fhcrev);

	if (isconsole) {
		fbwscons_console_init(&sc->sc_sunfb,
		    sc->sc_sunfb.sf_width >= 1024 ? -1 : 0);
	}
@


1.38
log
@Display the interrupt priority in dmesg, for frame buffers which register
interrupt handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.37 2006/12/03 16:38:13 miod Exp $	*/
a79 6
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/mman.h>
#include <sys/tty.h>
d100 2
a101 1
#include <sparc/dev/sbusvar.h>
d407 2
a408 2
	bt->bt_addr = 0x06 << 24;
	bt->bt_ctrl |= 0x03 << 24;
@


1.37
log
@Clean frame buffer attachment code:
- There is no need to check for buses config(8) will not let us attach to
- Better P4 bus logic, which does not need to abuse device flags
- Do not bother trying to print a meaningful device description when it is
  not connected to sbus.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.36 2006/12/02 11:21:35 miod Exp $	*/
d209 1
a209 1
	int node = 0;
d214 2
a215 1
	printf(": ");
d269 1
a269 2
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih, IPL_FB,
	    self->dv_xname);
@


1.36
log
@Use the unpack_attr emulops instead of doing an inline rasops_unpack_attr.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.35 2006/07/25 21:23:30 miod Exp $	*/
a170 5
	/*
	 * Mask out invalid flags from the user.
	 */
	cf->cf_flags &= FB_USERMASK;

d175 2
a176 1
	if (ca->ca_bustype == BUS_SBUS)
d178 4
d183 10
a192 3
#if defined(SUN4)
	if (CPU_ISSUN4 && (ca->ca_bustype == BUS_OBIO)) {
		void *tmp;
d194 2
a195 13
		/*
		 * Check for a pfour framebuffer.  This is done somewhat
		 * differently on the cgsix than other pfour framebuffers.
		 */
		bus_untmp();
		tmp = (caddr_t)mapdev(ra->ra_reg, TMPMAP_VA, CGSIX_FHC_OFFSET,
				      NBPG);
		if (probeget(tmp, 4) == -1)
			return (0);

		if (fb_pfour_id(tmp) == PFOUR_ID_FASTCOLOR) {
			cf->cf_flags |= FB_PFOUR;
			return (1);
d197 4
a201 3
#endif

	return (0);
d211 1
a211 1
	char *nam = NULL;
d214 1
a214 1
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;
d234 2
a235 18
		if (ISSET(sc->sc_sunfb.sf_flags, FB_PFOUR))
			nam = "cgsix/p4";
		else
			nam = "cgsix";

#if defined(SUN4M)
		if (CPU_ISSUN4M) {   /* 4m has framebuffer on obio */
			node = ca->ca_ra.ra_node;
			nam = getpropstring(node, "model");
			break;
		}
#endif
		break;

	case BUS_VME32:
	case BUS_VME16:
		sbus = node = 0;
		nam = "cgsix";
a236 1

a240 4

	case BUS_MAIN:
		printf("cgsix on mainbus?\n");
		return;
d243 2
a244 1
	printf(": %s", nam);
d312 1
a312 1
	printf(", %dx%d, rev %d\n", sc->sc_sunfb.sf_width,
@


1.35
log
@Do not bother reading the existing colormap on attach, since we will
override it with the rasops one.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.34 2006/06/02 20:00:54 miod Exp $	*/
d646 1
d662 2
d673 1
a673 1
	fbc->fbc_fg = ri->ri_devcmap[(attr >> 16) & 0xf];
d688 1
d699 2
d710 1
a710 1
	fbc->fbc_fg = ri->ri_devcmap[(attr >> 16) & 0xf];
@


1.34
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.33 2005/03/23 17:16:34 miod Exp $	*/
d212 1
a212 2
	int node = 0, i;
	volatile struct bt_regs *bt;
d223 1
a223 1
	sc->sc_bt = bt = (volatile struct bt_regs *)
a295 5

	/* grab initial (current) color map */
	bt->bt_addr = 0;
	for (i = 0; i < 256 * 3; i++)
		((char *)&sc->sc_cmap)[i] = bt->bt_cmap >> 24;
@


1.33
log
@Move the alloc_screen, free_screen and show_screen wsdisplay accessops to
the common frame buffer code, rather than duplicating it in every driver.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.32 2005/03/07 16:44:50 miod Exp $	*/
a113 1
	struct	sbusdev sc_sd;		/* sbus device */
a347 5

#if defined(SUN4C) || defined(SUN4M)
	if (sbus)
		sbus_establish(&sc->sc_sd, &sc->sc_sunfb.sf_dev);
#endif
@


1.32
log
@Do not bother passing the blanking routine to fbwscons_console_init(),
as fbwscons_attach() can find it on its own.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.31 2005/01/05 23:04:24 miod Exp $	*/
a99 1
#include <dev/wscons/wscons_raster.h>
a122 1
	int	sc_nscreens;
d125 15
a139 20
int cgsix_ioctl(void *, u_long, caddr_t, int, struct proc *);
int cgsix_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgsix_free_screen(void *, void *);
int cgsix_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t cgsix_mmap(void *, off_t, int);
void cgsix_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
static __inline__ void cgsix_loadcmap_deferred(struct cgsix_softc *,
    u_int, u_int);
void cgsix_reset(struct cgsix_softc *, u_int);
void cgsix_burner(void *, u_int, u_int);
int cgsix_intr(void *);

void cgsix_ras_init(struct cgsix_softc *);
void cgsix_ras_copyrows(void *, int, int, int);
void cgsix_ras_copycols(void *, int, int, int, int);
void cgsix_ras_erasecols(void *, int, int, int, long int);
void cgsix_ras_eraserows(void *, int, int, long int);
void cgsix_ras_do_cursor(struct rasops_info *);
d144 3
a146 3
	cgsix_alloc_screen,
	cgsix_free_screen,
	cgsix_show_screen,
d151 1
a164 3
/*
 * Match a cgsix.
 */
d166 1
a166 3
cgsixmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
a207 3
/*
 * Attach a display.
 */
d209 1
a209 3
cgsixattach(parent, self, args)
	struct device *parent, *self;
	void *args;
d359 1
a359 6
cgsix_ioctl(dev, cmd, data, flags, p)
	void *dev;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
a411 43
int
cgsix_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
{
	struct cgsix_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	sc->sc_nscreens++;
	return (0);
}

void
cgsix_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct cgsix_softc *sc = v;

	sc->sc_nscreens--;
}

int
cgsix_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
	return (0);
}

d416 1
a416 3
cgsix_reset(sc, fhcrev)
	struct cgsix_softc *sc;
	u_int fhcrev;
a450 4
/*
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
 */
d452 1
a452 4
cgsix_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
d465 1
a465 1
	return (-1);	/* not a user-map offset */
d469 1
a469 4
cgsix_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
	u_int8_t r, g, b;
d488 1
a488 3
cgsix_burner(v, on, flags)
	void *v;
	u_int on, flags;
d508 1
a508 2
cgsix_intr(v)
	void *v;
d542 1
a542 2
cgsix_ras_init(sc)
	struct cgsix_softc *sc;
d554 1
a554 3
cgsix_ras_copyrows(cookie, src, dst, n)
	void *cookie;
	int src, dst, n;
d602 1
a602 3
cgsix_ras_copycols(cookie, row, src, dst, n)
	void *cookie;
	int row, src, dst, n;
d653 1
a653 4
cgsix_ras_erasecols(cookie, row, col, n, attr)
	void *cookie;
	int row, col, n;
	long int attr;
d692 1
a692 4
cgsix_ras_eraserows(cookie, row, n, attr)
	void *cookie;
	int row, n;
	long int attr;
d736 1
a736 2
cgsix_ras_do_cursor(ri)
	struct rasops_info *ri;
@


1.31
log
@Let wsdisplay drivers return zero for WSDISPLAYIO_[GS]VIDEO ioctls - most
of the work is done in the upper layer, but they get to see the ioctl,
so don't always return an error.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.30 2004/11/29 22:07:36 miod Exp $	*/
d363 1
a363 1
		    sc->sc_sunfb.sf_width >= 1024 ? -1 : 0, cgsix_burner);
@


1.30
log
@Move the struct wsscreen_descr from a per-driver global to a per-instance
field of the sunfb structure. This allows multiple instances of the same driver,
but with different resolutions (such as a couple of vigra or a TGX cgsix and
a TGX+ cgsix) to use distinct wsscreen_descr structures featuring different
resolution information.

Doing this allows more wsscreen_descr fiddling inside the sparc* fb api,
and results in some code shrinkage (about 4KB on sparc GENERIC).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.29 2004/09/29 07:35:11 miod Exp $	*/
d419 2
@


1.29
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.28 2003/06/28 17:05:33 miod Exp $	*/
a126 12
struct wsscreen_descr cgsix_stdscreen = {
	"std",
};

const struct wsscreen_descr *cgsix_scrlist[] = {
	&cgsix_stdscreen,
};

struct wsscreen_list cgsix_screenlist = {
	sizeof(cgsix_scrlist) / sizeof(struct wsscreen_descr *), cgsix_scrlist
};

a228 1
	struct wsemuldisplaydev_attach_args waa;
a357 5
	cgsix_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgsix_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgsix_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgsix_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

d362 1
a362 1
		fbwscons_console_init(&sc->sc_sunfb, &cgsix_stdscreen,
d371 1
a371 5
	waa.console = isconsole;
	waa.scrdata = &cgsix_screenlist;
	waa.accessops = &cgsix_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
@


1.28
log
@Sync sparc fb API with the sparc64 changes (fbwscons_init takes flags, and
the sunfb structure keeps pointer to the prom cursor coordinates).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.27 2003/06/28 13:32:25 miod Exp $	*/
d322 2
a323 1
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih, IPL_FB);
@


1.27
log
@Clear screen after smitching to the wsfont, on low-resolution cgsix.
This is only necessary on the RDI Britelite laptops.

Reported by Paul Weissmann.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.26 2003/06/02 23:27:53 millert Exp $	*/
d352 1
a352 1
	    (sc->sc_sunfb.sf_width >= 1024));
@


1.26
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.25 2003/06/02 18:40:59 jason Exp $	*/
d339 14
a352 1
	fbwscons_init(&sc->sc_sunfb, isconsole);
d379 2
a380 2
		fbwscons_console_init(&sc->sc_sunfb, &cgsix_stdscreen, -1,
		    cgsix_burner);
@


1.25
log
@nuke my clause 3 & 4 (and a couple jointly (c) with Theo).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.24 2003/04/28 21:40:41 jason Exp $	*/
d55 1
a55 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.24
log
@use the new display types
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.23 2002/12/12 23:35:32 miod Exp $	*/
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.23
log
@Dvorak typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.22 2002/11/06 21:06:20 miod Exp $	*/
d406 1
a406 1
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
@


1.22
log
@- always initialize colormaps, even if the frame buffer is non console; this
  helps if the ramdac does not get initialized (idea from jason@@)
- only register a shutdown hook for the frame buffers which need it, if this
  is the console frame buffer. Otherwise this is just a waste of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.21 2002/09/23 18:13:38 miod Exp $	*/
d260 1
a260 1
	 * May just BT, FHC, FBC, THC, and video RAM.
@


1.21
log
@Get the wsdisplay capabilities from rasops, rather than attempting to
guess them at compile-time. Plus this makes cgtwelve a bit more clean.

ok fgs@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.20 2002/09/09 22:15:16 miod Exp $	*/
d349 1
d376 1
a376 1
		    cgsix_setcolor, cgsix_burner);
@


1.20
log
@Register more screen capabilities to work with the recent wsemul_sun changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.19 2002/08/12 10:44:03 miod Exp $	*/
a137 5
	0, 0,	/* will be filled in */
	0,
	0, 0,
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
	WSSCREEN_REVERSE | WSSCREEN_WSCOLORS
d365 1
@


1.19
log
@Convert sparc console code from rcons and pseudo-devices to rasops and wscons.
For most framebuffers it is faster.

Other changes include:
o 24 bit support in tcx(4) for the S24 framebuffer
o accelerated cgsix(4) text console
o new cgtwelve(4) driver for the GS framebuffer
o improved serial driver code
o better keyboard support

The following framebuffers have not been tested but should work: cgfour,
cgeight and cgfourteen

These changes will require XF4 changes, to use Xwsfb instead of Xsun*, to be
commited later today.

Most of the work by me during the LSM and the week after, with code borrowed
from jason@@, NetBSD (new serial code), and feedback from mickey@@. Work on
pnozz(4) done by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.18 2002/03/14 01:26:42 millert Exp $	*/
d141 1
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.17 2001/11/06 19:53:16 miod Exp $	*/
d5 35
a84 4
 *
 * Does not handle interrupts, even though they can occur.
 *
 * XXX should defer colormap updates to vertical retrace interrupts
a90 1
#include <machine/fbio.h>
a96 5
#ifdef DEBUG
#include <sys/proc.h>
#include <sys/syslog.h>
#endif

a100 1
#include <machine/fbvar.h>
d107 6
a120 16
extern int sparc_vsyncblank;

union cursor_cmap {		/* colormap, like bt_cmap, but tiny */
	u_char	cm_map[2][3];	/* 2 R/G/B entries */
	u_int	cm_chip[2];	/* 2 chip equivalents */
};

struct cg6_cursor {		/* cg6 hardware cursor status */
	short	cc_enable;		/* cursor is enabled */
	struct	fbcurpos cc_pos;	/* position */
	struct	fbcurpos cc_hot;	/* hot-spot */
	struct	fbcurpos cc_size;	/* size of mask & image fields */
	u_int	cc_bits[2][32];		/* space for mask & image bits */
	union	cursor_cmap cc_color;	/* cursor colormap */
};

d123 1
a123 1
	struct	device sc_dev;		/* base device */
d125 1
a125 3
	struct	fbdevice sc_fb;		/* frame buffer device */
	struct	rom_reg sc_physadr;	/* phys addr of h/w */
	int	sc_bustype;		/* type of bus we live on */
d128 3
a130 5
	volatile struct cg6_thc *sc_thc;	/* THC registers */
	volatile struct cg6_tec_xxx *sc_tec;	/* TEC registers */
	short	sc_fhcrev;		/* hardware rev */
	short	sc_blanked;		/* true if blanked */
	struct	cg6_cursor sc_cursor;	/* software cursor info */
d132 2
d136 7
a142 4
/* autoconfiguration driver */
static void	cgsixattach(struct device *, struct device *, void *);
static int	cgsixmatch(struct device *, void *, void *);
static void	cg6_unblank(struct device *);
d144 2
a145 2
struct cfattach cgsix_ca = {
	sizeof(struct cgsix_softc), cgsixmatch, cgsixattach
d148 2
a149 2
struct cfdriver cgsix_cd = {
	NULL, "cgsix", DV_DULL
d152 31
a182 3
/* frame buffer generic driver */
static struct fbdriver cg6_fbdriver = {
	cg6_unblank, cgsixopen, cgsixclose, cgsixioctl, cgsixmmap
d185 2
a186 11
/*
 * Unlike the bw2 and cg3 drivers, we do not need to provide an rconsole
 * interface, as the cg6 is fast enough.. but provide a knob to turn it
 * on anyway.
 * XXXCDC: rethink this.  the Sun PROM is buggy with some escape sequences
 * thus causing your display to get messed up.  raster console prevents 
 * this....
 */
#ifdef RASTERCONSOLE
int cgsix_use_rasterconsole = 1;
#endif
d188 3
a190 1
extern int fbnode;
d192 3
a194 5
static void cg6_reset(struct cgsix_softc *);
static void cg6_loadcmap(struct cgsix_softc *, int, int);
static void cg6_loadomap(struct cgsix_softc *);
static void cg6_setcursor(struct cgsix_softc *);/* set position */
static void cg6_loadcursor(struct cgsix_softc *);/* set shape */
a207 3
	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
		return (0);

d213 4
d252 5
a256 5
	register struct cgsix_softc *sc = (struct cgsix_softc *)self;
	register struct confargs *ca = args;
	register int node = 0, ramsize, i;
	register volatile struct bt_regs *bt;
	struct fbdevice *fb = &sc->sc_fb;
d259 1
a259 1
	extern struct tty *fbconstty;
d261 1
a261 4
	fb->fb_driver = &cg6_fbdriver;
	fb->fb_device = &sc->sc_dev;
	fb->fb_type.fb_type = FBTYPE_SUNFAST_COLOR;
	fb->fb_flags = sc->sc_dev.dv_cfdata->cf_flags;
d264 1
a264 3
	 * Dunno what the PROM has mapped, though obviously it must have
	 * the video RAM mapped.  Just map what we care about for ourselves
	 * (the FHC, THC, and Brooktree registers).
d266 1
a266 3
#define	O(memb) ((u_int)(&((struct cg6_layout *)0)->memb))
	sc->sc_physadr = ca->ca_ra.ra_reg[0];
	sc->sc_bustype = ca->ca_bustype;
d268 1
a268 1
	   mapiodev(ca->ca_ra.ra_reg, O(cg6_bt_un.un_btregs),sizeof *sc->sc_bt);
d270 7
a276 5
	   mapiodev(ca->ca_ra.ra_reg, O(cg6_fhc_un.un_fhc), sizeof *sc->sc_fhc);
	sc->sc_thc = (volatile struct cg6_thc *)
	   mapiodev(ca->ca_ra.ra_reg, O(cg6_thc_un.un_thc), sizeof *sc->sc_thc);
	sc->sc_tec = (volatile struct cg6_tec_xxx *)
	   mapiodev(ca->ca_ra.ra_reg, O(cg6_tec_un.un_tec), sizeof *sc->sc_tec);
d281 1
a281 1
		if (fb->fb_flags & FB_PFOUR)
d311 1
a311 12
	/* Don't have to map the pfour register on the cgsix. */
	fb->fb_pfour = NULL;

	fb->fb_type.fb_depth = 8;
	fb_setsize(fb, fb->fb_type.fb_depth, 1152, 900,
	    node, ca->ca_bustype);

	ramsize = fb->fb_type.fb_height * fb->fb_linebytes;
	fb->fb_type.fb_cmsize = 256;
	fb->fb_type.fb_size = ramsize;
	printf(": %s, %d x %d", nam, fb->fb_type.fb_width,
	    fb->fb_type.fb_height);
d316 2
a317 2
		int constype = (fb->fb_flags & FB_PFOUR) ? EE_CONS_P4OPT :
		    EE_CONS_COLOR;
d323 1
a323 3
			isconsole = (fbconstty != NULL);
		else
			isconsole = 0;
a326 1
#if defined(SUN4C) || defined(SUN4M)
d328 1
a328 2
		isconsole = node == fbnode && fbconstty != NULL;
#endif
d330 1
a330 1
	sc->sc_fhcrev = (*sc->sc_fhc >> FHC_REV_SHIFT) &
d332 4
a335 1
	printf(", rev %d", sc->sc_fhcrev);
d338 1
a338 1
	cg6_reset(sc);
d340 1
a340 1
	/* grab initial (current) color map (DOES THIS WORK?) */
d346 29
a374 1
	sc->sc_thc->thc_misc |= THC_MISC_VIDEN | THC_MISC_SYNCEN;
d377 4
a380 11
		printf(" (console)\n");
#ifdef RASTERCONSOLE
		if (cgsix_use_rasterconsole) {
			sc->sc_fb.fb_pixels = (caddr_t)
				mapiodev(ca->ca_ra.ra_reg,
					 O(cg6_ram[0]), ramsize);
			fbrcons_init(&sc->sc_fb);
		}
#endif
	} else
		printf("\n");
d383 1
a383 1
		sbus_establish(&sc->sc_sd, &sc->sc_dev);
a384 24
	if (CPU_ISSUN4 || (node == fbnode))
		fb_attach(&sc->sc_fb, isconsole);
}

int
cgsixopen(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	int unit = minor(dev);

	if (unit >= cgsix_cd.cd_ndevs || cgsix_cd.cd_devs[unit] == NULL)
		return (ENXIO);
	return (0);
}

int
cgsixclose(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	struct cgsix_softc *sc = cgsix_cd.cd_devs[minor(dev)];
d386 5
a390 2
	cg6_reset(sc);
	return (0);
d394 2
a395 2
cgsixioctl(dev, cmd, data, flags, p)
	dev_t dev;
d397 1
a397 1
	register caddr_t data;
d401 4
a404 4
	register struct cgsix_softc *sc = cgsix_cd.cd_devs[minor(dev)];
	u_int count;
	int v, error;
	union cursor_cmap tcm;
d407 2
a408 3

	case FBIOGTYPE:
		*(struct fbtype *)data = sc->sc_fb.fb_type;
d410 16
a425 12

	case FBIOGATTR:
#define fba ((struct fbgattr *)data)
		fba->real_type = sc->sc_fb.fb_type.fb_type;
		fba->owner = 0;		/* XXX ??? */
		fba->fbtype = sc->sc_fb.fb_type;
		fba->sattr.flags = 0;
		fba->sattr.emu_type = sc->sc_fb.fb_type.fb_type;
		fba->sattr.dev_specific[0] = -1;
		fba->emu_types[0] = sc->sc_fb.fb_type.fb_type;
		fba->emu_types[1] = -1;
#undef fba
d428 3
a430 7
	case FBIOGETCMAP:
		return (bt_getcmap((struct fbcmap *)data, &sc->sc_cmap, 256));

	case FBIOPUTCMAP:
		/* copy to software map */
#define	p ((struct fbcmap *)data)
		error = bt_putcmap(p, &sc->sc_cmap, 256);
d433 1
a433 4
		/* now blast them into the chip */
		/* XXX should use retrace interrupt */
		cg6_loadcmap(sc, p->index, p->count);
#undef p
d436 10
a445 3
	case FBIOGVIDEO:
		*(int *)data = sc->sc_blanked;
		break;
d447 2
a448 9
	case FBIOSVIDEO:
		if (*(int *)data)
			cg6_unblank(&sc->sc_dev);
		else if (!sc->sc_blanked) {
			sc->sc_blanked = 1;
			sc->sc_thc->thc_misc &= ~(THC_MISC_VIDEN |
			    (sparc_vsyncblank ? THC_MISC_SYNCEN : 0));
		}
		break;
d450 21
a470 35
/* these are for both FBIOSCURSOR and FBIOGCURSOR */
#define p ((struct fbcursor *)data)
#define cc (&sc->sc_cursor)

	case FBIOGCURSOR:
		/* do not quite want everything here... */
		p->set = FB_CUR_SETALL;	/* close enough, anyway */
		p->enable = cc->cc_enable;
		p->pos = cc->cc_pos;
		p->hot = cc->cc_hot;
		p->size = cc->cc_size;

		/* begin ugh ... can we lose some of this crap?? */
		if (p->image != NULL) {
			count = cc->cc_size.y * 32 / NBBY;
			error = copyout((caddr_t)cc->cc_bits[1],
			    (caddr_t)p->image, count);
			if (error)
				return (error);
			error = copyout((caddr_t)cc->cc_bits[0],
			    (caddr_t)p->mask, count);
			if (error)
				return (error);
		}
		if (p->cmap.red != NULL) {
			error = bt_getcmap(&p->cmap,
			    (union bt_cmap *)&cc->cc_color, 2);
			if (error)
				return (error);
		} else {
			p->cmap.index = 0;
			p->cmap.count = 2;
		}
		/* end ugh */
		break;
d472 6
a477 26
	case FBIOSCURSOR:
		/*
		 * For setcmap and setshape, verify parameters, so that
		 * we do not get halfway through an update and then crap
		 * out with the software state screwed up.
		 */
		v = p->set;
		if (v & FB_CUR_SETCMAP) {
			/*
			 * This use of a temporary copy of the cursor
			 * colormap is not terribly efficient, but these
			 * copies are small (8 bytes)...
			 */
			tcm = cc->cc_color;
			error = bt_putcmap(&p->cmap, (union bt_cmap *)&tcm, 2);
			if (error)
				return (error);
		}
		if (v & FB_CUR_SETSHAPE) {
			if ((u_int)p->size.x > 32 || (u_int)p->size.y > 32)
				return (EINVAL);
			count = p->size.y * 32 / NBBY;
			if (!uvm_useracc(p->image, count, B_READ) ||
			    !uvm_useracc(p->mask, count, B_READ))
				return (EFAULT);
		}
d479 2
a480 23
		/* parameters are OK; do it */
		if (v & (FB_CUR_SETCUR | FB_CUR_SETPOS | FB_CUR_SETHOT)) {
			if (v & FB_CUR_SETCUR)
				cc->cc_enable = p->enable;
			if (v & FB_CUR_SETPOS)
				cc->cc_pos = p->pos;
			if (v & FB_CUR_SETHOT)
				cc->cc_hot = p->hot;
			cg6_setcursor(sc);
		}
		if (v & FB_CUR_SETCMAP) {
			cc->cc_color = tcm;
			cg6_loadomap(sc); /* XXX defer to vertical retrace */
		}
		if (v & FB_CUR_SETSHAPE) {
			cc->cc_size = p->size;
			count = p->size.y * 32 / NBBY;
			bzero((caddr_t)cc->cc_bits, sizeof cc->cc_bits);
			bcopy(p->mask, (caddr_t)cc->cc_bits[0], count);
			bcopy(p->image, (caddr_t)cc->cc_bits[1], count);
			cg6_loadcursor(sc);
		}
		break;
d482 8
a489 25
#undef p
#undef cc

	case FBIOGCURPOS:
		*(struct fbcurpos *)data = sc->sc_cursor.cc_pos;
		break;

	case FBIOSCURPOS:
		sc->sc_cursor.cc_pos = *(struct fbcurpos *)data;
		cg6_setcursor(sc);
		break;

	case FBIOGCURMAX:
		/* max cursor size is 32x32 */
		((struct fbcurpos *)data)->x = 32;
		((struct fbcurpos *)data)->y = 32;
		break;

	default:
#ifdef DEBUG
		log(LOG_NOTICE, "cgsixioctl(0x%lx) (%s[%d])\n", cmd,
		    p->p_comm, p->p_pid);
#endif
		return (ENOTTY);
	}
d496 8
a503 7
static void
cg6_reset(sc)
	register struct cgsix_softc *sc;
{
	register volatile struct cg6_tec_xxx *tec;
	register int fhc;
	register volatile struct bt_regs *bt;
d506 1
a506 1
	sc->sc_thc->thc_cursxy = (THC_CURSOFF << 16) | THC_CURSOFF;
d515 1
a515 1
	if (sc->sc_fhcrev < 5) {
d523 1
a523 1
		if (sc->sc_fhcrev < 2)
d534 14
a547 20
static void
cg6_setcursor(sc)
	register struct cgsix_softc *sc;
{

	/* we need to subtract the hot-spot value here */
#define COORD(f) (sc->sc_cursor.cc_pos.f - sc->sc_cursor.cc_hot.f)
	sc->sc_thc->thc_cursxy = sc->sc_cursor.cc_enable ?
	    ((COORD(x) << 16) | (COORD(y) & 0xffff)) :
	    (THC_CURSOFF << 16) | THC_CURSOFF;
#undef COORD
}

static void
cg6_loadcursor(sc)
	register struct cgsix_softc *sc;
{
	register volatile struct cg6_thc *thc;
	register u_int edgemask, m;
	register int i;
d549 4
a552 16
	/*
	 * Keep the top size.x bits.  Here we *throw out* the top
	 * size.x bits from an all-one-bits word, introducing zeros in
	 * the top size.x bits, then invert all the bits to get what
	 * we really wanted as our mask.  But this fails if size.x is
	 * 32---a sparc uses only the low 5 bits of the shift count---
	 * so we have to special case that.
	 */
	edgemask = ~0;
	if (sc->sc_cursor.cc_size.x < 32)
		edgemask = ~(edgemask >> sc->sc_cursor.cc_size.x);
	thc = sc->sc_thc;
	for (i = 0; i < 32; i++) {
		m = sc->sc_cursor.cc_bits[0][i] & edgemask;
		thc->thc_cursmask[i] = m;
		thc->thc_cursbits[i] = m & sc->sc_cursor.cc_bits[1][i];
d554 2
d558 7
a564 11
/*
 * Load a subset of the current (new) colormap into the color DAC.
 */
static void
cg6_loadcmap(sc, start, ncolors)
	register struct cgsix_softc *sc;
	register int start, ncolors;
{
	register volatile struct bt_regs *bt;
	register u_int *ip, i;
	register int count;
d566 1
a566 12
	ip = &sc->sc_cmap.cm_chip[BT_D4M3(start)];	/* start/4 * 3 */
	count = BT_D4M3(start + ncolors - 1) - BT_D4M3(start) + 3;
	bt = sc->sc_bt;
	bt->bt_addr = BT_D4M4(start) << 24;
	while (--count >= 0) {
		i = *ip++;
		/* hardware that makes one want to pound boards with hammers */
		bt->bt_cmap = i;
		bt->bt_cmap = i << 8;
		bt->bt_cmap = i << 16;
		bt->bt_cmap = i << 24;
	}
d569 2
a570 6
/*
 * Load the cursor (overlay `foreground' and `background') colors.
 */
static void
cg6_loadomap(sc)
	register struct cgsix_softc *sc;
d572 1
a572 2
	register volatile struct bt_regs *bt;
	register u_int i;
d574 5
a578 6
	bt = sc->sc_bt;
	bt->bt_addr = 0x01 << 24;	/* set background color */
	i = sc->sc_cursor.cc_color.cm_chip[0];
	bt->bt_omap = i;		/* R */
	bt->bt_omap = i << 8;		/* G */
	bt->bt_omap = i << 16;		/* B */
d580 20
a599 5
	bt->bt_addr = 0x03 << 24;	/* set foreground color */
	bt->bt_omap = i << 24;		/* R */
	i = sc->sc_cursor.cc_color.cm_chip[1];
	bt->bt_omap = i;		/* G */
	bt->bt_omap = i << 8;		/* B */
d602 3
a604 3
static void
cg6_unblank(dev)
	struct device *dev;
d606 2
a607 1
	struct cgsix_softc *sc = (struct cgsix_softc *)dev;
d609 5
a613 3
	if (sc->sc_blanked) {
		sc->sc_blanked = 0;
		sc->sc_thc->thc_misc |= THC_MISC_VIDEN|THC_MISC_SYNCEN;
d615 7
a623 1
/* XXX the following should be moved to a "user interface" header */
d625 1
a625 4
 * Base addresses at which users can mmap() the various pieces of a cg6.
 * Note that although the Brooktree color registers do not occupy 8K,
 * the X server dies if we do not allow it to map 8K there (it just maps
 * from 0x70000000 forwards, as a contiguous chunk).
a626 14
#define	CG6_USER_FBC	0x70000000
#define	CG6_USER_TEC	0x70001000
#define	CG6_USER_BTREGS	0x70002000
#define	CG6_USER_FHC	0x70004000
#define	CG6_USER_THC	0x70005000
#define	CG6_USER_ROM	0x70006000
#define	CG6_USER_RAM	0x70016000
#define	CG6_USER_DHC	0x80000000

struct mmo {
	u_int	mo_uaddr;	/* user (virtual) address */
	u_int	mo_size;	/* size, or 0 for video ram size */
	u_int	mo_physoff;	/* offset from sc_physadr */
};
d628 12
a639 11
/*
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
 *
 * XXX	needs testing against `demanding' applications (e.g., aviator)
 */
paddr_t
cgsixmmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
d641 153
a793 17
	register struct cgsix_softc *sc = cgsix_cd.cd_devs[minor(dev)];
	register struct mmo *mo;
	register u_int u, sz;
#define	O(memb) ((u_int)(&((struct cg6_layout *)0)->memb))
	static struct mmo mmo[] = {
		{ CG6_USER_RAM, 0, O(cg6_ram) },

		/* do not actually know how big most of these are! */
		{ CG6_USER_FBC, 1, O(cg6_fbc_un) },
		{ CG6_USER_TEC, 1, O(cg6_tec_un) },
		{ CG6_USER_BTREGS, 8192 /* XXX */, O(cg6_bt_un) },
		{ CG6_USER_FHC, 1, O(cg6_fhc_un) },
		{ CG6_USER_THC, sizeof(struct cg6_thc), O(cg6_thc_un) },
		{ CG6_USER_ROM, 65536, O(cg6_rom_un) },
		{ CG6_USER_DHC, 1, O(cg6_dhc_un) },
	};
#define NMMO (sizeof mmo / sizeof *mmo)
d795 18
a812 2
	if (off & PGOFSET)
		panic("cgsixmmap");
d814 23
a836 21
	/*
	 * Entries with size 0 map video RAM (i.e., the size in fb data).
	 *
	 * Since we work in pages, the fact that the map offset table's
	 * sizes are sometimes bizarre (e.g., 1) is effectively ignored:
	 * one byte is as good as one page.
	 */
	for (mo = mmo; mo < &mmo[NMMO]; mo++) {
		if ((u_int)off < mo->mo_uaddr)
			continue;
		u = off - mo->mo_uaddr;
		sz = mo->mo_size ? mo->mo_size : sc->sc_fb.fb_type.fb_size;
		if (u < sz)
			return (REG2PHYS(&sc->sc_physadr, u + mo->mo_physoff) |
				PMAP_NC);
	}
#ifdef DEBUG
	{
	  register struct proc *p = curproc;	/* XXX */
	  log(LOG_NOTICE, "cgsixmmap(0x%x) (%s[%d])\n",
		off, p->p_comm, p->p_pid);
d838 29
a866 2
#endif
	return (-1);	/* not a user-map offset */
@


1.17
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.16 2001/11/01 12:13:46 art Exp $	*/
d125 3
a127 3
static void	cgsixattach __P((struct device *, struct device *, void *));
static int	cgsixmatch __P((struct device *, void *, void *));
static void	cg6_unblank __P((struct device *));
d156 5
a160 5
static void cg6_reset __P((struct cgsix_softc *));
static void cg6_loadcmap __P((struct cgsix_softc *, int, int));
static void cg6_loadomap __P((struct cgsix_softc *));
static void cg6_setcursor __P((struct cgsix_softc *));/* set position */
static void cg6_loadcursor __P((struct cgsix_softc *));/* set shape */
@


1.17.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.17 2001/11/06 19:53:16 miod Exp $	*/
d125 3
a127 3
static void	cgsixattach(struct device *, struct device *, void *);
static int	cgsixmatch(struct device *, void *, void *);
static void	cg6_unblank(struct device *);
d156 5
a160 5
static void cg6_reset(struct cgsix_softc *);
static void cg6_loadcmap(struct cgsix_softc *, int, int);
static void cg6_loadomap(struct cgsix_softc *);
static void cg6_setcursor(struct cgsix_softc *);/* set position */
static void cg6_loadcursor(struct cgsix_softc *);/* set shape */
@


1.17.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.17.2.1 2002/06/11 03:38:15 art Exp $	*/
a4 35
 * Copyright (c) 2002 Miodrag Vallat.  All rights reserved.
 * Copyright (c) 2001 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 *
d50 4
d60 1
d67 5
d76 1
a82 6
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

d91 16
d109 1
a109 1
	struct	sunfb sc_sunfb;		/* common base part */
d111 3
a113 1
	struct	rom_reg sc_phys;	/* phys addr of h/w */
d116 5
a120 3
	volatile struct cgsix_thc *sc_thc;	/* THC registers */
	volatile struct cgsix_fbc *sc_fbc;	/* FBC registers */
	volatile struct cgsix_tec_xxx *sc_tec;	/* TEC registers */
a121 2
	struct	intrhand sc_ih;
	int	sc_nscreens;
d124 4
a127 3
struct wsscreen_descr cgsix_stdscreen = {
	"std",
};
d129 2
a130 2
const struct wsscreen_descr *cgsix_scrlist[] = {
	&cgsix_stdscreen,
d133 2
a134 2
struct wsscreen_list cgsix_screenlist = {
	sizeof(cgsix_scrlist) / sizeof(struct wsscreen_descr *), cgsix_scrlist
d137 3
a139 31
int cgsix_ioctl(void *, u_long, caddr_t, int, struct proc *);
int cgsix_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgsix_free_screen(void *, void *);
int cgsix_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t cgsix_mmap(void *, off_t, int);
void cgsix_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
static __inline__ void cgsix_loadcmap_deferred(struct cgsix_softc *,
    u_int, u_int);
void cgsix_reset(struct cgsix_softc *, u_int);
void cgsix_burner(void *, u_int, u_int);
int cgsix_intr(void *);

void cgsix_ras_init(struct cgsix_softc *);
void cgsix_ras_copyrows(void *, int, int, int);
void cgsix_ras_copycols(void *, int, int, int, int);
void cgsix_ras_erasecols(void *, int, int, int, long int);
void cgsix_ras_eraserows(void *, int, int, long int);
void cgsix_ras_do_cursor(struct rasops_info *);

struct wsdisplay_accessops cgsix_accessops = {
	cgsix_ioctl,
	cgsix_mmap,
	cgsix_alloc_screen,
	cgsix_free_screen,
	cgsix_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	cgsix_burner,
d142 11
a152 2
int	cgsixmatch(struct device *, void *, void *);
void	cgsixattach(struct device *, struct device *, void *);
d154 1
a154 3
struct cfattach cgsix_ca = {
	sizeof(struct cgsix_softc), cgsixmatch, cgsixattach
};
d156 5
a160 3
struct cfdriver cgsix_cd = {
	NULL, "cgsix", DV_DULL
};
d174 3
a181 4
	if (strcmp(ra->ra_name, cf->cf_driver->cd_name) &&
	    strcmp(ra->ra_name, "SUNW,cgsix"))
		return (0);

d217 5
a221 5
	struct cgsix_softc *sc = (struct cgsix_softc *)self;
	struct confargs *ca = args;
	struct wsemuldisplaydev_attach_args waa;
	int node = 0, i;
	volatile struct bt_regs *bt;
d224 1
a224 1
	u_int fhcrev;
d226 4
a229 1
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;
d232 3
a234 1
	 * May just BT, FHC, FBC, THC, and video RAM.
d236 3
a238 1
	sc->sc_phys = ca->ca_ra.ra_reg[0];
d240 1
a240 1
	   mapiodev(ca->ca_ra.ra_reg, CGSIX_BT_OFFSET, CGSIX_BT_SIZE);
d242 5
a246 7
	   mapiodev(ca->ca_ra.ra_reg, CGSIX_FHC_OFFSET, CGSIX_FHC_SIZE);
	sc->sc_thc = (volatile struct cgsix_thc *)
	   mapiodev(ca->ca_ra.ra_reg, CGSIX_THC_OFFSET, CGSIX_THC_SIZE);
	sc->sc_fbc = (volatile struct cgsix_fbc *)
	   mapiodev(ca->ca_ra.ra_reg, CGSIX_FBC_OFFSET, CGSIX_FBC_SIZE);
	sc->sc_tec = (volatile struct cgsix_tec_xxx *)
	   mapiodev(ca->ca_ra.ra_reg, CGSIX_TEC_OFFSET, CGSIX_TEC_SIZE);
d251 1
a251 1
		if (ISSET(sc->sc_sunfb.sf_flags, FB_PFOUR))
d281 12
a292 1
	printf(": %s", nam);
d297 2
a298 2
		int constype = ISSET(sc->sc_sunfb.sf_flags, FB_PFOUR) ?
		    EE_CONS_P4OPT : EE_CONS_COLOR;
d304 3
a306 1
			isconsole = 1;
d310 1
d312 2
a313 1
		isconsole = node == fbnode;
d315 1
a315 1
	fhcrev = (*sc->sc_fhc >> FHC_REV_SHIFT) &
d317 1
a317 4

	sc->sc_ih.ih_fun = cgsix_intr;
	sc->sc_ih.ih_arg = sc;
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih, IPL_FB);
d320 1
a320 1
	cgsix_reset(sc, fhcrev);
d322 1
a322 1
	/* grab initial (current) color map */
d328 1
a328 30
	cgsix_burner(sc, 1, 0);

	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, ca->ca_bustype);
        sc->sc_sunfb.sf_ro.ri_bits = mapiodev(ca->ca_ra.ra_reg,
	    CGSIX_VID_OFFSET, round_page(sc->sc_sunfb.sf_fbsize));
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, isconsole);

	/*
	 * Old rev. cg6 cards do not like the current acceleration code.
	 *
	 * Some hints from Sun point out at timing and cache problems, which
	 * will be investigated later.
	 */
	if (fhcrev >= 5) {
		sc->sc_sunfb.sf_ro.ri_ops.copyrows = cgsix_ras_copyrows;
		sc->sc_sunfb.sf_ro.ri_ops.copycols = cgsix_ras_copycols;
		sc->sc_sunfb.sf_ro.ri_ops.eraserows = cgsix_ras_eraserows;
		sc->sc_sunfb.sf_ro.ri_ops.erasecols = cgsix_ras_erasecols;
		sc->sc_sunfb.sf_ro.ri_do_cursor = cgsix_ras_do_cursor;
		cgsix_ras_init(sc);
	}

	cgsix_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgsix_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgsix_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgsix_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

	printf(", %dx%d, rev %d\n", sc->sc_sunfb.sf_width,
	    sc->sc_sunfb.sf_height, fhcrev);
d331 11
a341 4
		fbwscons_console_init(&sc->sc_sunfb, &cgsix_stdscreen, -1,
		    cgsix_setcolor, cgsix_burner);
	}

d344 1
a344 1
		sbus_establish(&sc->sc_sd, &sc->sc_sunfb.sf_dev);
d346 24
d371 2
a372 5
	waa.console = isconsole;
	waa.scrdata = &cgsix_screenlist;
	waa.accessops = &cgsix_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
d376 2
a377 2
cgsix_ioctl(dev, cmd, data, flags, p)
	void *dev;
d379 1
a379 1
	caddr_t data;
d383 4
a386 4
	struct cgsix_softc *sc = dev;
	struct wsdisplay_cmap *cm;
	struct wsdisplay_fbinfo *wdf;
	int error;
d389 16
a404 2
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
d406 8
a413 14
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
		wdf->cmsize = 256;
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
		break;

	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_getcmap(&sc->sc_cmap, cm);
d416 18
d436 34
a469 6
	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		cgsix_loadcmap_deferred(sc, cm->index, cm->count);
d472 50
a521 10
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
	default:
		return (-1);	/* not supported yet */
	}
d523 2
a524 2
	return (0);
}
d526 3
a528 21
int
cgsix_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
{
	struct cgsix_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	sc->sc_nscreens++;
	return (0);
}
d530 4
a533 6
void
cgsix_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct cgsix_softc *sc = v;
d535 5
a539 2
	sc->sc_nscreens--;
}
d541 7
a547 8
int
cgsix_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
d554 7
a560 8
void
cgsix_reset(sc, fhcrev)
	struct cgsix_softc *sc;
	u_int fhcrev;
{
	volatile struct cgsix_tec_xxx *tec;
	int fhc;
	volatile struct bt_regs *bt;
d563 1
a563 1
	sc->sc_thc->thc_cursxy = THC_CURSOFF;
d572 1
a572 1
	if (fhcrev < 5) {
d580 1
a580 1
		if (fhcrev < 2)
d591 20
a610 14
/*
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
 */
paddr_t
cgsix_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
{
	struct cgsix_softc *sc = v;

	if (offset & PGOFSET)
		return (-1);
d612 16
a627 4
	/* Allow mapping as a dumb framebuffer from offset 0 */
	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys, offset + CGSIX_VID_OFFSET) |
		    PMAP_NC);
a628 2

	return (-1);	/* not a user-map offset */
d631 11
a641 7
void
cgsix_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
	u_int8_t r, g, b;
{
	struct cgsix_softc *sc = v;
d643 12
a654 1
	bt_setcolor(&sc->sc_cmap, sc->sc_bt, index, r, g, b, 1);
d657 6
a662 2
static __inline__ void
cgsix_loadcmap_deferred(struct cgsix_softc *sc, u_int start, u_int ncolors)
d664 2
a665 1
	u_int32_t thcm;
d667 6
a672 5
	thcm = sc->sc_thc->thc_misc;
	thcm &= ~THC_MISC_RESET;
	thcm |= THC_MISC_INTEN;
	sc->sc_thc->thc_misc = thcm;
}
d674 5
a678 20
void
cgsix_burner(v, on, flags)
	void *v;
	u_int on, flags;
{
	struct cgsix_softc *sc = v;
	int s;
	u_int32_t thcm;

	s = splhigh();
	thcm = sc->sc_thc->thc_misc;
	if (on)
		thcm |= THC_MISC_VIDEN | THC_MISC_SYNCEN;
	else {
		thcm &= ~THC_MISC_VIDEN;
		if (flags & WSDISPLAY_BURN_VBLANK)
			thcm &= ~THC_MISC_SYNCEN;
	}
	sc->sc_thc->thc_misc = thcm;
	splx(s);
d681 3
a683 3
int
cgsix_intr(v)
	void *v;
d685 1
a685 2
	struct cgsix_softc *sc = v;
	u_int32_t thcm;
d687 3
a689 5
	thcm = sc->sc_thc->thc_misc;
	if ((thcm & (THC_MISC_INTEN | THC_MISC_INTR)) !=
	    (THC_MISC_INTEN | THC_MISC_INTR)) {
		/* Not expecting an interrupt, it's not for us. */
		return (0);
a690 7

	/* Acknowledge the interrupt and disable it. */
	thcm &= ~(THC_MISC_RESET | THC_MISC_INTEN);
	thcm |= THC_MISC_INTR;
	sc->sc_thc->thc_misc = thcm;
	bt_loadcmap(&sc->sc_cmap, sc->sc_bt, 0, 256, 1);
	return (1);
d693 1
d695 4
a698 1
 * Specifics rasops handlers for accelerated console
d700 14
d715 11
a725 12
#define	CG6_BLIT_WAIT(fbc) \
	while (((fbc)->fbc_blit & (FBC_BLIT_UNKNOWN | FBC_BLIT_GXFULL)) == \
	    (FBC_BLIT_UNKNOWN | FBC_BLIT_GXFULL))
#define	CG6_DRAW_WAIT(fbc) \
	while (((fbc)->fbc_draw & (FBC_DRAW_UNKNOWN | FBC_DRAW_GXFULL)) == \
	    (FBC_DRAW_UNKNOWN | FBC_DRAW_GXFULL))
#define	CG6_DRAIN(fbc) \
	while ((fbc)->fbc_s & FBC_S_GXINPROGRESS)

void
cgsix_ras_init(sc)
	struct cgsix_softc *sc;
d727 17
a743 1
	u_int32_t m;
d745 2
a746 6
	CG6_DRAIN(sc->sc_fbc);
	m = sc->sc_fbc->fbc_mode;
	m &= ~FBC_MODE_MASK;
	m |= FBC_MODE_VAL;
	sc->sc_fbc->fbc_mode = m;
}
d748 21
a768 14
void
cgsix_ras_copyrows(cookie, src, dst, n)
	void *cookie;
	int src, dst, n;
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;
	volatile struct cgsix_fbc *fbc = sc->sc_fbc;

	if (dst == src)
		return;
	if (src < 0) {
		n += src;
		src = 0;
d770 2
a771 202
	if (src + n > ri->ri_rows)
		n = ri->ri_rows - src;
	if (dst < 0) {
		n += dst;
		dst = 0;
	}
	if (dst + n > ri->ri_rows)
		n = ri->ri_rows - dst;
	if (n <= 0)
		return;
	n *= ri->ri_font->fontheight;
	src *= ri->ri_font->fontheight;
	dst *= ri->ri_font->fontheight;

	fbc->fbc_clip = 0;
	fbc->fbc_s = 0;
	fbc->fbc_offx = 0;
	fbc->fbc_offy = 0;
	fbc->fbc_clipminx = 0;
	fbc->fbc_clipminy = 0;
	fbc->fbc_clipmaxx = ri->ri_width - 1;
	fbc->fbc_clipmaxy = ri->ri_height - 1;
	fbc->fbc_alu = FBC_ALU_COPY;
	fbc->fbc_x0 = ri->ri_xorigin;
	fbc->fbc_y0 = ri->ri_yorigin + src;
	fbc->fbc_x1 = ri->ri_xorigin + ri->ri_emuwidth - 1;
	fbc->fbc_y1 = ri->ri_yorigin + src + n - 1;
	fbc->fbc_x2 = ri->ri_xorigin;
	fbc->fbc_y2 = ri->ri_yorigin + dst;
	fbc->fbc_x3 = ri->ri_xorigin + ri->ri_emuwidth - 1;
	fbc->fbc_y3 = ri->ri_yorigin + dst + n - 1;
	CG6_BLIT_WAIT(fbc);
	CG6_DRAIN(fbc);
}

void
cgsix_ras_copycols(cookie, row, src, dst, n)
	void *cookie;
	int row, src, dst, n;
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;
	volatile struct cgsix_fbc *fbc = sc->sc_fbc;

	if (dst == src)
		return;
	if ((row < 0) || (row >= ri->ri_rows))
		return;
	if (src < 0) {
		n += src;
		src = 0;
	}
	if (src + n > ri->ri_cols)
		n = ri->ri_cols - src;
	if (dst < 0) {
		n += dst;
		dst = 0;
	}
	if (dst + n > ri->ri_cols)
		n = ri->ri_cols - dst;
	if (n <= 0)
		return;
	n *= ri->ri_font->fontwidth;
	src *= ri->ri_font->fontwidth;
	dst *= ri->ri_font->fontwidth;
	row *= ri->ri_font->fontheight;

	fbc->fbc_clip = 0;
	fbc->fbc_s = 0;
	fbc->fbc_offx = 0;
	fbc->fbc_offy = 0;
	fbc->fbc_clipminx = 0;
	fbc->fbc_clipminy = 0;
	fbc->fbc_clipmaxx = ri->ri_width - 1;
	fbc->fbc_clipmaxy = ri->ri_height - 1;
	fbc->fbc_alu = FBC_ALU_COPY;
	fbc->fbc_x0 = ri->ri_xorigin + src;
	fbc->fbc_y0 = ri->ri_yorigin + row;
	fbc->fbc_x1 = ri->ri_xorigin + src + n - 1;
	fbc->fbc_y1 = ri->ri_yorigin + row + ri->ri_font->fontheight - 1;
	fbc->fbc_x2 = ri->ri_xorigin + dst;
	fbc->fbc_y2 = ri->ri_yorigin + row;
	fbc->fbc_x3 = ri->ri_xorigin + dst + n - 1;
	fbc->fbc_y3 = ri->ri_yorigin + row + ri->ri_font->fontheight - 1;
	CG6_BLIT_WAIT(fbc);
	CG6_DRAIN(fbc);
}

void
cgsix_ras_erasecols(cookie, row, col, n, attr)
	void *cookie;
	int row, col, n;
	long int attr;
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;
	volatile struct cgsix_fbc *fbc = sc->sc_fbc;

	if ((row < 0) || (row >= ri->ri_rows))
		return;
	if (col < 0) {
		n += col;
		col = 0;
	}
	if (col + n > ri->ri_cols)
		n = ri->ri_cols - col;
	if (n <= 0)
		return;
	n *= ri->ri_font->fontwidth;
	col *= ri->ri_font->fontwidth;
	row *= ri->ri_font->fontheight;

	fbc->fbc_clip = 0;
	fbc->fbc_s = 0;
	fbc->fbc_offx = 0;
	fbc->fbc_offy = 0;
	fbc->fbc_clipminx = 0;
	fbc->fbc_clipminy = 0;
	fbc->fbc_clipmaxx = ri->ri_width - 1;
	fbc->fbc_clipmaxy = ri->ri_height - 1;
	fbc->fbc_alu = FBC_ALU_FILL;
	fbc->fbc_fg = ri->ri_devcmap[(attr >> 16) & 0xf];
	fbc->fbc_arecty = ri->ri_yorigin + row;
	fbc->fbc_arectx = ri->ri_xorigin + col;
	fbc->fbc_arecty = ri->ri_yorigin + row + ri->ri_font->fontheight - 1;
	fbc->fbc_arectx = ri->ri_xorigin + col + n - 1;
	CG6_DRAW_WAIT(fbc);
	CG6_DRAIN(fbc);
}

void
cgsix_ras_eraserows(cookie, row, n, attr)
	void *cookie;
	int row, n;
	long int attr;
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;
	volatile struct cgsix_fbc *fbc = sc->sc_fbc;

	if (row < 0) {
		n += row;
		row = 0;
	}
	if (row + n > ri->ri_rows)
		n = ri->ri_rows - row;
	if (n <= 0)
		return;

	fbc->fbc_clip = 0;
	fbc->fbc_s = 0;
	fbc->fbc_offx = 0;
	fbc->fbc_offy = 0;
	fbc->fbc_clipminx = 0;
	fbc->fbc_clipminy = 0;
	fbc->fbc_clipmaxx = ri->ri_width - 1;
	fbc->fbc_clipmaxy = ri->ri_height - 1;
	fbc->fbc_alu = FBC_ALU_FILL;
	fbc->fbc_fg = ri->ri_devcmap[(attr >> 16) & 0xf];
	if ((n == ri->ri_rows) && (ri->ri_flg & RI_FULLCLEAR)) {
		fbc->fbc_arecty = 0;
		fbc->fbc_arectx = 0;
		fbc->fbc_arecty = ri->ri_height - 1;
		fbc->fbc_arectx = ri->ri_width - 1;
	} else {
		row *= ri->ri_font->fontheight;
		fbc->fbc_arecty = ri->ri_yorigin + row;
		fbc->fbc_arectx = ri->ri_xorigin;
		fbc->fbc_arecty =
		    ri->ri_yorigin + row + (n * ri->ri_font->fontheight) - 1;
		fbc->fbc_arectx =
		    ri->ri_xorigin + ri->ri_emuwidth - 1;
	}
	CG6_DRAW_WAIT(fbc);
	CG6_DRAIN(fbc);
}

void
cgsix_ras_do_cursor(ri)
	struct rasops_info *ri;
{
	struct cgsix_softc *sc = ri->ri_hw;
	int row, col;
	volatile struct cgsix_fbc *fbc = sc->sc_fbc;

	row = ri->ri_crow * ri->ri_font->fontheight;
	col = ri->ri_ccol * ri->ri_font->fontwidth;
	fbc->fbc_clip = 0;
	fbc->fbc_s = 0;
	fbc->fbc_offx = 0;
	fbc->fbc_offy = 0;
	fbc->fbc_clipminx = 0;
	fbc->fbc_clipminy = 0;
	fbc->fbc_clipmaxx = ri->ri_width - 1;
	fbc->fbc_clipmaxy = ri->ri_height - 1;
	fbc->fbc_alu = FBC_ALU_FLIP;
	fbc->fbc_arecty = ri->ri_yorigin + row;
	fbc->fbc_arectx = ri->ri_xorigin + col;
	fbc->fbc_arecty = ri->ri_yorigin + row + ri->ri_font->fontheight - 1;
	fbc->fbc_arectx = ri->ri_xorigin + col + ri->ri_font->fontwidth - 1;
	CG6_DRAW_WAIT(fbc);
	CG6_DRAIN(fbc);
@


1.17.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d260 1
a260 1
	 * Map just BT, FHC, FBC, THC, and video RAM.
a348 1
	fbwscons_setcolormap(&sc->sc_sunfb, cgsix_setcolor);
d375 1
a375 1
		    cgsix_burner);
d405 1
a405 1
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG6;
@


1.16
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.15 2001/08/17 13:52:28 mickey Exp $	*/
d72 1
a72 1
#include <vm/vm.h>
@


1.15
log
@cdev_decl cleanup; jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.14 2001/05/10 10:34:43 art Exp $	*/
d721 1
a721 1
int
d724 2
a725 1
	int off, prot;
@


1.14
log
@UVM is no longer optional on sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.13 2000/05/18 13:31:12 jason Exp $	*/
a127 3

/* cdevsw prototypes */
cdev_decl(cgsix);
@


1.13
log
@add machdep.vsyncblank sysctl for controlling whether vsync is disabled
when the monitor is blanked.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.12 1999/05/08 01:15:58 jason Exp $	*/
a496 1
#if defined(UVM)
a499 5
#else
			if (!useracc(p->image, count, B_READ) ||
			    !useracc(p->mask, count, B_READ))
				return (EFAULT);
#endif
@


1.12
log
@Turn off sync when turning off video so that monitors will go into stand-by.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.11 1999/04/22 16:52:47 art Exp $	*/
d91 2
d434 2
a435 1
			sc->sc_thc->thc_misc &= ~(THC_MISC_VIDEN|THC_MISC_SYNCEN);
@


1.12.4.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.13 2000/05/18 13:31:12 jason Exp $	*/
a90 2
extern int sparc_vsyncblank;

d432 1
a432 2
			sc->sc_thc->thc_misc &= ~(THC_MISC_VIDEN |
			    (sparc_vsyncblank ? THC_MISC_SYNCEN : 0));
@


1.12.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.12.4.1 2001/05/14 21:37:03 niklas Exp $	*/
d497 1
d501 5
@


1.12.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.12.4.2 2001/07/04 10:23:22 niklas Exp $	*/
d128 3
@


1.12.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d72 1
a72 1
#include <uvm/uvm_extern.h>
d721 1
a721 1
paddr_t
d724 1
a724 2
	off_t off;
	int prot;
@


1.12.4.5
log
@Merge in -current from about a week ago
@
text
@d125 3
a127 3
static void	cgsixattach(struct device *, struct device *, void *);
static int	cgsixmatch(struct device *, void *, void *);
static void	cg6_unblank(struct device *);
d156 5
a160 5
static void cg6_reset(struct cgsix_softc *);
static void cg6_loadcmap(struct cgsix_softc *, int, int);
static void cg6_loadomap(struct cgsix_softc *);
static void cg6_setcursor(struct cgsix_softc *);/* set position */
static void cg6_loadcursor(struct cgsix_softc *);/* set shape */
@


1.12.4.6
log
@Sync the SMP branch with 3.3
@
text
@a4 35
 * Copyright (c) 2002 Miodrag Vallat.  All rights reserved.
 * Copyright (c) 2001 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 *
d50 4
d60 1
d67 5
d76 1
a82 6
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

d91 16
d109 1
a109 1
	struct	sunfb sc_sunfb;		/* common base part */
d111 3
a113 1
	struct	rom_reg sc_phys;	/* phys addr of h/w */
d116 5
a120 3
	volatile struct cgsix_thc *sc_thc;	/* THC registers */
	volatile struct cgsix_fbc *sc_fbc;	/* FBC registers */
	volatile struct cgsix_tec_xxx *sc_tec;	/* TEC registers */
a121 2
	struct	intrhand sc_ih;
	int	sc_nscreens;
d124 4
a127 3
struct wsscreen_descr cgsix_stdscreen = {
	"std",
};
d129 2
a130 2
const struct wsscreen_descr *cgsix_scrlist[] = {
	&cgsix_stdscreen,
d133 2
a134 2
struct wsscreen_list cgsix_screenlist = {
	sizeof(cgsix_scrlist) / sizeof(struct wsscreen_descr *), cgsix_scrlist
d137 3
a139 31
int cgsix_ioctl(void *, u_long, caddr_t, int, struct proc *);
int cgsix_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgsix_free_screen(void *, void *);
int cgsix_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t cgsix_mmap(void *, off_t, int);
void cgsix_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
static __inline__ void cgsix_loadcmap_deferred(struct cgsix_softc *,
    u_int, u_int);
void cgsix_reset(struct cgsix_softc *, u_int);
void cgsix_burner(void *, u_int, u_int);
int cgsix_intr(void *);

void cgsix_ras_init(struct cgsix_softc *);
void cgsix_ras_copyrows(void *, int, int, int);
void cgsix_ras_copycols(void *, int, int, int, int);
void cgsix_ras_erasecols(void *, int, int, int, long int);
void cgsix_ras_eraserows(void *, int, int, long int);
void cgsix_ras_do_cursor(struct rasops_info *);

struct wsdisplay_accessops cgsix_accessops = {
	cgsix_ioctl,
	cgsix_mmap,
	cgsix_alloc_screen,
	cgsix_free_screen,
	cgsix_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	cgsix_burner,
d142 11
a152 2
int	cgsixmatch(struct device *, void *, void *);
void	cgsixattach(struct device *, struct device *, void *);
d154 1
a154 3
struct cfattach cgsix_ca = {
	sizeof(struct cgsix_softc), cgsixmatch, cgsixattach
};
d156 5
a160 3
struct cfdriver cgsix_cd = {
	NULL, "cgsix", DV_DULL
};
d174 3
a181 4
	if (strcmp(ra->ra_name, cf->cf_driver->cd_name) &&
	    strcmp(ra->ra_name, "SUNW,cgsix"))
		return (0);

d217 5
a221 5
	struct cgsix_softc *sc = (struct cgsix_softc *)self;
	struct confargs *ca = args;
	struct wsemuldisplaydev_attach_args waa;
	int node = 0, i;
	volatile struct bt_regs *bt;
d224 1
a224 1
	u_int fhcrev;
d226 4
a229 1
	sc->sc_sunfb.sf_flags = self->dv_cfdata->cf_flags;
d232 3
a234 1
	 * Map just BT, FHC, FBC, THC, and video RAM.
d236 3
a238 1
	sc->sc_phys = ca->ca_ra.ra_reg[0];
d240 1
a240 1
	   mapiodev(ca->ca_ra.ra_reg, CGSIX_BT_OFFSET, CGSIX_BT_SIZE);
d242 5
a246 7
	   mapiodev(ca->ca_ra.ra_reg, CGSIX_FHC_OFFSET, CGSIX_FHC_SIZE);
	sc->sc_thc = (volatile struct cgsix_thc *)
	   mapiodev(ca->ca_ra.ra_reg, CGSIX_THC_OFFSET, CGSIX_THC_SIZE);
	sc->sc_fbc = (volatile struct cgsix_fbc *)
	   mapiodev(ca->ca_ra.ra_reg, CGSIX_FBC_OFFSET, CGSIX_FBC_SIZE);
	sc->sc_tec = (volatile struct cgsix_tec_xxx *)
	   mapiodev(ca->ca_ra.ra_reg, CGSIX_TEC_OFFSET, CGSIX_TEC_SIZE);
d251 1
a251 1
		if (ISSET(sc->sc_sunfb.sf_flags, FB_PFOUR))
d281 12
a292 1
	printf(": %s", nam);
d297 2
a298 2
		int constype = ISSET(sc->sc_sunfb.sf_flags, FB_PFOUR) ?
		    EE_CONS_P4OPT : EE_CONS_COLOR;
d304 3
a306 1
			isconsole = 1;
d310 1
d312 2
a313 1
		isconsole = node == fbnode;
d315 1
a315 1
	fhcrev = (*sc->sc_fhc >> FHC_REV_SHIFT) &
d317 1
a317 4

	sc->sc_ih.ih_fun = cgsix_intr;
	sc->sc_ih.ih_arg = sc;
	intr_establish(ca->ca_ra.ra_intr[0].int_pri, &sc->sc_ih, IPL_FB);
d320 1
a320 1
	cgsix_reset(sc, fhcrev);
d322 1
a322 1
	/* grab initial (current) color map */
d328 1
a328 31
	cgsix_burner(sc, 1, 0);

	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, ca->ca_bustype);
        sc->sc_sunfb.sf_ro.ri_bits = mapiodev(ca->ca_ra.ra_reg,
	    CGSIX_VID_OFFSET, round_page(sc->sc_sunfb.sf_fbsize));
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, isconsole);
	fbwscons_setcolormap(&sc->sc_sunfb, cgsix_setcolor);

	/*
	 * Old rev. cg6 cards do not like the current acceleration code.
	 *
	 * Some hints from Sun point out at timing and cache problems, which
	 * will be investigated later.
	 */
	if (fhcrev >= 5) {
		sc->sc_sunfb.sf_ro.ri_ops.copyrows = cgsix_ras_copyrows;
		sc->sc_sunfb.sf_ro.ri_ops.copycols = cgsix_ras_copycols;
		sc->sc_sunfb.sf_ro.ri_ops.eraserows = cgsix_ras_eraserows;
		sc->sc_sunfb.sf_ro.ri_ops.erasecols = cgsix_ras_erasecols;
		sc->sc_sunfb.sf_ro.ri_do_cursor = cgsix_ras_do_cursor;
		cgsix_ras_init(sc);
	}

	cgsix_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgsix_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgsix_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgsix_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

	printf(", %dx%d, rev %d\n", sc->sc_sunfb.sf_width,
	    sc->sc_sunfb.sf_height, fhcrev);
d331 11
a341 4
		fbwscons_console_init(&sc->sc_sunfb, &cgsix_stdscreen, -1,
		    cgsix_burner);
	}

d344 1
a344 1
		sbus_establish(&sc->sc_sd, &sc->sc_sunfb.sf_dev);
d346 24
d371 2
a372 5
	waa.console = isconsole;
	waa.scrdata = &cgsix_screenlist;
	waa.accessops = &cgsix_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
d376 2
a377 2
cgsix_ioctl(dev, cmd, data, flags, p)
	void *dev;
d379 1
a379 1
	caddr_t data;
d383 4
a386 4
	struct cgsix_softc *sc = dev;
	struct wsdisplay_cmap *cm;
	struct wsdisplay_fbinfo *wdf;
	int error;
d389 16
a404 2
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
d406 8
a413 14
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
		wdf->cmsize = 256;
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
		break;

	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_getcmap(&sc->sc_cmap, cm);
d416 18
d436 34
a469 6
	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		cgsix_loadcmap_deferred(sc, cm->index, cm->count);
d472 50
a521 10
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
	default:
		return (-1);	/* not supported yet */
	}
d523 2
a524 2
	return (0);
}
d526 3
a528 21
int
cgsix_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
{
	struct cgsix_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	sc->sc_nscreens++;
	return (0);
}
d530 4
a533 6
void
cgsix_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct cgsix_softc *sc = v;
d535 5
a539 2
	sc->sc_nscreens--;
}
d541 7
a547 8
int
cgsix_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
d554 7
a560 8
void
cgsix_reset(sc, fhcrev)
	struct cgsix_softc *sc;
	u_int fhcrev;
{
	volatile struct cgsix_tec_xxx *tec;
	int fhc;
	volatile struct bt_regs *bt;
d563 1
a563 1
	sc->sc_thc->thc_cursxy = THC_CURSOFF;
d572 1
a572 1
	if (fhcrev < 5) {
d580 1
a580 1
		if (fhcrev < 2)
d591 20
a610 14
/*
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
 */
paddr_t
cgsix_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
{
	struct cgsix_softc *sc = v;

	if (offset & PGOFSET)
		return (-1);
d612 16
a627 4
	/* Allow mapping as a dumb framebuffer from offset 0 */
	if (offset >= 0 && offset < sc->sc_sunfb.sf_fbsize) {
		return (REG2PHYS(&sc->sc_phys, offset + CGSIX_VID_OFFSET) |
		    PMAP_NC);
a628 2

	return (-1);	/* not a user-map offset */
d631 11
a641 7
void
cgsix_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
	u_int8_t r, g, b;
{
	struct cgsix_softc *sc = v;
d643 12
a654 1
	bt_setcolor(&sc->sc_cmap, sc->sc_bt, index, r, g, b, 1);
d657 6
a662 2
static __inline__ void
cgsix_loadcmap_deferred(struct cgsix_softc *sc, u_int start, u_int ncolors)
d664 2
a665 1
	u_int32_t thcm;
d667 6
a672 5
	thcm = sc->sc_thc->thc_misc;
	thcm &= ~THC_MISC_RESET;
	thcm |= THC_MISC_INTEN;
	sc->sc_thc->thc_misc = thcm;
}
d674 5
a678 20
void
cgsix_burner(v, on, flags)
	void *v;
	u_int on, flags;
{
	struct cgsix_softc *sc = v;
	int s;
	u_int32_t thcm;

	s = splhigh();
	thcm = sc->sc_thc->thc_misc;
	if (on)
		thcm |= THC_MISC_VIDEN | THC_MISC_SYNCEN;
	else {
		thcm &= ~THC_MISC_VIDEN;
		if (flags & WSDISPLAY_BURN_VBLANK)
			thcm &= ~THC_MISC_SYNCEN;
	}
	sc->sc_thc->thc_misc = thcm;
	splx(s);
d681 3
a683 3
int
cgsix_intr(v)
	void *v;
d685 1
a685 2
	struct cgsix_softc *sc = v;
	u_int32_t thcm;
d687 3
a689 5
	thcm = sc->sc_thc->thc_misc;
	if ((thcm & (THC_MISC_INTEN | THC_MISC_INTR)) !=
	    (THC_MISC_INTEN | THC_MISC_INTR)) {
		/* Not expecting an interrupt, it's not for us. */
		return (0);
a690 7

	/* Acknowledge the interrupt and disable it. */
	thcm &= ~(THC_MISC_RESET | THC_MISC_INTEN);
	thcm |= THC_MISC_INTR;
	sc->sc_thc->thc_misc = thcm;
	bt_loadcmap(&sc->sc_cmap, sc->sc_bt, 0, 256, 1);
	return (1);
d693 1
d695 4
a698 1
 * Specifics rasops handlers for accelerated console
d700 14
d715 11
a725 12
#define	CG6_BLIT_WAIT(fbc) \
	while (((fbc)->fbc_blit & (FBC_BLIT_UNKNOWN | FBC_BLIT_GXFULL)) == \
	    (FBC_BLIT_UNKNOWN | FBC_BLIT_GXFULL))
#define	CG6_DRAW_WAIT(fbc) \
	while (((fbc)->fbc_draw & (FBC_DRAW_UNKNOWN | FBC_DRAW_GXFULL)) == \
	    (FBC_DRAW_UNKNOWN | FBC_DRAW_GXFULL))
#define	CG6_DRAIN(fbc) \
	while ((fbc)->fbc_s & FBC_S_GXINPROGRESS)

void
cgsix_ras_init(sc)
	struct cgsix_softc *sc;
d727 17
a743 1
	u_int32_t m;
d745 2
a746 6
	CG6_DRAIN(sc->sc_fbc);
	m = sc->sc_fbc->fbc_mode;
	m &= ~FBC_MODE_MASK;
	m |= FBC_MODE_VAL;
	sc->sc_fbc->fbc_mode = m;
}
d748 21
a768 14
void
cgsix_ras_copyrows(cookie, src, dst, n)
	void *cookie;
	int src, dst, n;
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;
	volatile struct cgsix_fbc *fbc = sc->sc_fbc;

	if (dst == src)
		return;
	if (src < 0) {
		n += src;
		src = 0;
d770 2
a771 202
	if (src + n > ri->ri_rows)
		n = ri->ri_rows - src;
	if (dst < 0) {
		n += dst;
		dst = 0;
	}
	if (dst + n > ri->ri_rows)
		n = ri->ri_rows - dst;
	if (n <= 0)
		return;
	n *= ri->ri_font->fontheight;
	src *= ri->ri_font->fontheight;
	dst *= ri->ri_font->fontheight;

	fbc->fbc_clip = 0;
	fbc->fbc_s = 0;
	fbc->fbc_offx = 0;
	fbc->fbc_offy = 0;
	fbc->fbc_clipminx = 0;
	fbc->fbc_clipminy = 0;
	fbc->fbc_clipmaxx = ri->ri_width - 1;
	fbc->fbc_clipmaxy = ri->ri_height - 1;
	fbc->fbc_alu = FBC_ALU_COPY;
	fbc->fbc_x0 = ri->ri_xorigin;
	fbc->fbc_y0 = ri->ri_yorigin + src;
	fbc->fbc_x1 = ri->ri_xorigin + ri->ri_emuwidth - 1;
	fbc->fbc_y1 = ri->ri_yorigin + src + n - 1;
	fbc->fbc_x2 = ri->ri_xorigin;
	fbc->fbc_y2 = ri->ri_yorigin + dst;
	fbc->fbc_x3 = ri->ri_xorigin + ri->ri_emuwidth - 1;
	fbc->fbc_y3 = ri->ri_yorigin + dst + n - 1;
	CG6_BLIT_WAIT(fbc);
	CG6_DRAIN(fbc);
}

void
cgsix_ras_copycols(cookie, row, src, dst, n)
	void *cookie;
	int row, src, dst, n;
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;
	volatile struct cgsix_fbc *fbc = sc->sc_fbc;

	if (dst == src)
		return;
	if ((row < 0) || (row >= ri->ri_rows))
		return;
	if (src < 0) {
		n += src;
		src = 0;
	}
	if (src + n > ri->ri_cols)
		n = ri->ri_cols - src;
	if (dst < 0) {
		n += dst;
		dst = 0;
	}
	if (dst + n > ri->ri_cols)
		n = ri->ri_cols - dst;
	if (n <= 0)
		return;
	n *= ri->ri_font->fontwidth;
	src *= ri->ri_font->fontwidth;
	dst *= ri->ri_font->fontwidth;
	row *= ri->ri_font->fontheight;

	fbc->fbc_clip = 0;
	fbc->fbc_s = 0;
	fbc->fbc_offx = 0;
	fbc->fbc_offy = 0;
	fbc->fbc_clipminx = 0;
	fbc->fbc_clipminy = 0;
	fbc->fbc_clipmaxx = ri->ri_width - 1;
	fbc->fbc_clipmaxy = ri->ri_height - 1;
	fbc->fbc_alu = FBC_ALU_COPY;
	fbc->fbc_x0 = ri->ri_xorigin + src;
	fbc->fbc_y0 = ri->ri_yorigin + row;
	fbc->fbc_x1 = ri->ri_xorigin + src + n - 1;
	fbc->fbc_y1 = ri->ri_yorigin + row + ri->ri_font->fontheight - 1;
	fbc->fbc_x2 = ri->ri_xorigin + dst;
	fbc->fbc_y2 = ri->ri_yorigin + row;
	fbc->fbc_x3 = ri->ri_xorigin + dst + n - 1;
	fbc->fbc_y3 = ri->ri_yorigin + row + ri->ri_font->fontheight - 1;
	CG6_BLIT_WAIT(fbc);
	CG6_DRAIN(fbc);
}

void
cgsix_ras_erasecols(cookie, row, col, n, attr)
	void *cookie;
	int row, col, n;
	long int attr;
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;
	volatile struct cgsix_fbc *fbc = sc->sc_fbc;

	if ((row < 0) || (row >= ri->ri_rows))
		return;
	if (col < 0) {
		n += col;
		col = 0;
	}
	if (col + n > ri->ri_cols)
		n = ri->ri_cols - col;
	if (n <= 0)
		return;
	n *= ri->ri_font->fontwidth;
	col *= ri->ri_font->fontwidth;
	row *= ri->ri_font->fontheight;

	fbc->fbc_clip = 0;
	fbc->fbc_s = 0;
	fbc->fbc_offx = 0;
	fbc->fbc_offy = 0;
	fbc->fbc_clipminx = 0;
	fbc->fbc_clipminy = 0;
	fbc->fbc_clipmaxx = ri->ri_width - 1;
	fbc->fbc_clipmaxy = ri->ri_height - 1;
	fbc->fbc_alu = FBC_ALU_FILL;
	fbc->fbc_fg = ri->ri_devcmap[(attr >> 16) & 0xf];
	fbc->fbc_arecty = ri->ri_yorigin + row;
	fbc->fbc_arectx = ri->ri_xorigin + col;
	fbc->fbc_arecty = ri->ri_yorigin + row + ri->ri_font->fontheight - 1;
	fbc->fbc_arectx = ri->ri_xorigin + col + n - 1;
	CG6_DRAW_WAIT(fbc);
	CG6_DRAIN(fbc);
}

void
cgsix_ras_eraserows(cookie, row, n, attr)
	void *cookie;
	int row, n;
	long int attr;
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;
	volatile struct cgsix_fbc *fbc = sc->sc_fbc;

	if (row < 0) {
		n += row;
		row = 0;
	}
	if (row + n > ri->ri_rows)
		n = ri->ri_rows - row;
	if (n <= 0)
		return;

	fbc->fbc_clip = 0;
	fbc->fbc_s = 0;
	fbc->fbc_offx = 0;
	fbc->fbc_offy = 0;
	fbc->fbc_clipminx = 0;
	fbc->fbc_clipminy = 0;
	fbc->fbc_clipmaxx = ri->ri_width - 1;
	fbc->fbc_clipmaxy = ri->ri_height - 1;
	fbc->fbc_alu = FBC_ALU_FILL;
	fbc->fbc_fg = ri->ri_devcmap[(attr >> 16) & 0xf];
	if ((n == ri->ri_rows) && (ri->ri_flg & RI_FULLCLEAR)) {
		fbc->fbc_arecty = 0;
		fbc->fbc_arectx = 0;
		fbc->fbc_arecty = ri->ri_height - 1;
		fbc->fbc_arectx = ri->ri_width - 1;
	} else {
		row *= ri->ri_font->fontheight;
		fbc->fbc_arecty = ri->ri_yorigin + row;
		fbc->fbc_arectx = ri->ri_xorigin;
		fbc->fbc_arecty =
		    ri->ri_yorigin + row + (n * ri->ri_font->fontheight) - 1;
		fbc->fbc_arectx =
		    ri->ri_xorigin + ri->ri_emuwidth - 1;
	}
	CG6_DRAW_WAIT(fbc);
	CG6_DRAIN(fbc);
}

void
cgsix_ras_do_cursor(ri)
	struct rasops_info *ri;
{
	struct cgsix_softc *sc = ri->ri_hw;
	int row, col;
	volatile struct cgsix_fbc *fbc = sc->sc_fbc;

	row = ri->ri_crow * ri->ri_font->fontheight;
	col = ri->ri_ccol * ri->ri_font->fontwidth;
	fbc->fbc_clip = 0;
	fbc->fbc_s = 0;
	fbc->fbc_offx = 0;
	fbc->fbc_offy = 0;
	fbc->fbc_clipminx = 0;
	fbc->fbc_clipminy = 0;
	fbc->fbc_clipmaxx = ri->ri_width - 1;
	fbc->fbc_clipmaxy = ri->ri_height - 1;
	fbc->fbc_alu = FBC_ALU_FLIP;
	fbc->fbc_arecty = ri->ri_yorigin + row;
	fbc->fbc_arectx = ri->ri_xorigin + col;
	fbc->fbc_arecty = ri->ri_yorigin + row + ri->ri_font->fontheight - 1;
	fbc->fbc_arectx = ri->ri_xorigin + col + ri->ri_font->fontwidth - 1;
	CG6_DRAW_WAIT(fbc);
	CG6_DRAIN(fbc);
@


1.12.4.7
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.12.4.6 2003/03/27 23:49:25 niklas Exp $	*/
d406 1
a406 1
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG6;
@


1.12.4.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.12.4.7 2003/05/13 19:41:08 ho Exp $	*/
d17 5
d60 5
a64 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.12.4.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d339 1
a339 14

	/*
	 * If the framebuffer width is under 1024x768, we will switch from the
	 * PROM font to the more adequate 8x16 font here.
	 * However, we need to adjust two things in this case:
	 * - the display row should be overrided from the current PROM metrics,
	 *   to prevent us from overwriting the last few lines of text.
	 * - if the 80x34 screen would make a large margin appear around it,
	 *   choose to clear the screen rather than keeping old prom output in
	 *   the margins.
	 * XXX there should be a rasops "clear margins" feature
	 */
	fbwscons_init(&sc->sc_sunfb, isconsole &&
	    (sc->sc_sunfb.sf_width >= 1024) ? 0 : RI_CLEAR);
d366 2
a367 2
		fbwscons_console_init(&sc->sc_sunfb, &cgsix_stdscreen,
		    sc->sc_sunfb.sf_width >= 1024 ? -1 : 0, cgsix_burner);
@


1.11
log
@UVM fixes, just a few useracc -> uvm_useracc
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.10 1997/12/23 21:43:19 chuck Exp $	*/
d329 1
a329 1
	sc->sc_thc->thc_misc |= THC_MISC_VIDEN;
d432 1
a432 1
			sc->sc_thc->thc_misc &= ~THC_MISC_VIDEN;
d695 1
a695 1
		sc->sc_thc->thc_misc |= THC_MISC_VIDEN;
@


1.10
log
@use raster console by default since the sun prom is buggy.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.9 1997/09/17 06:47:07 downsj Exp $	*/
d494 5
d502 1
@


1.9
log
@NETBSD_CURRENT_970916.  Lot's just ID changes, since changes don't apply to
us.  Includes some pmap changes, for which I don't have the original commit
message(s) handy.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.8 1997/08/08 08:24:51 downsj Exp $	*/
d147 3
d152 1
a152 1
int cgsix_use_rasterconsole = 0;
@


1.8
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: cgsix.c,v 1.32 1997/07/29 09:58:04 fair Exp $ */
d145 2
a146 1
 * interface, as the cg6 is fast enough.
d148 3
d331 6
a336 3
		sc->sc_fb.fb_pixels = (caddr_t)
			mapiodev(ca->ca_ra.ra_reg, O(cg6_ram[0]), ramsize);
		fbrcons_init(&sc->sc_fb);
@


1.7
log
@Revert back to Theo's eeprom.h.
@
text
@d2 1
a2 1
/*	$NetBSD: cgsix.c,v 1.25 1996/04/01 17:30:00 christos Exp $ */
a124 4
int		cgsixopen __P((dev_t, int, int, struct proc *));
int		cgsixclose __P((dev_t, int, int, struct proc *));
int		cgsixioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int		cgsixmmap __P((dev_t, int, int));
d127 3
d188 2
a189 1
		tmp = bus_tmp(ra->ra_paddr + CGSIX_FHC_OFFSET, ca->ca_bustype);
d234 1
a234 2
	    mapiodev(ca->ca_ra.ra_reg, O(cg6_bt_un.un_btregs),
		     sizeof *sc->sc_bt, ca->ca_bustype);
d236 1
a236 2
	    mapiodev(ca->ca_ra.ra_reg, O(cg6_fhc_un.un_fhc),
		     sizeof *sc->sc_fhc, ca->ca_bustype);
d238 1
a238 2
	    mapiodev(ca->ca_ra.ra_reg, O(cg6_thc_un.un_thc),
		     sizeof *sc->sc_thc, ca->ca_bustype);
d240 1
a240 2
	    mapiodev(ca->ca_ra.ra_reg, O(cg6_tec_un.un_tec),
		     sizeof *sc->sc_tec, ca->ca_bustype);
d291 2
a292 2
		int constype = (fb->fb_flags & FB_PFOUR) ? EED_CONS_P4 :
		    EED_CONS_COLOR;
d297 1
a297 1
		if (eep == NULL || eep->ee_diag.eed_console == constype)
d328 1
a328 2
			mapiodev(ca->ca_ra.ra_reg, O(cg6_ram[0]),
				 ramsize, ca->ca_bustype);
d533 1
a533 1
		log(LOG_NOTICE, "cgsixioctl(%lx) (%s[%d])\n", cmd,
d750 2
a751 2
			return (REG2PHYS(&sc->sc_physadr, u + mo->mo_physoff,
					 sc->sc_bustype) | PMAP_NC);
d756 2
a757 1
	  log(LOG_NOTICE, "cgsixmmap(%x) (%s[%d])\n", off, p->p_comm, p->p_pid);
@


1.6
log
@netbsd port, now we merge our changes back in
@
text
@d1 1
d295 2
a296 2
		int constype = (fb->fb_flags & FB_PFOUR) ? EE_CONS_P4OPT :
		    EE_CONS_COLOR;
d301 1
a301 1
		if (eep == NULL || eep->eeConsole == constype)
@


1.5
log
@new mapdev/()/mapiodev() calling convention uses "struct rom_reg *" to supply
base plus an offset
new dvma routines
@
text
@d1 1
a1 1
/*	$NetBSD: cgsix.c,v 1.16 1995/10/08 01:39:16 pk Exp $ */
d56 1
d64 1
d76 5
d86 1
d88 1
d130 6
a135 3
struct cfdriver cgsixcd = {
	NULL, "cgsix", cgsixmatch, cgsixattach,
	DV_DULL, sizeof(struct cgsix_softc)
d170 6
a177 7
#ifdef SUN4
	if (ca->ca_bustype == BUS_PFOUR &&
	    PFOUR_ID(ra->ra_pfour) == PFOUR_ID_FASTCOLOR)
		return (1);
	if (ca->ca_bustype == BUS_OBIO) {
		struct cg6_layout *p = (struct cg6_layout *)ra->ra_paddr;
		void *tmp = bus_tmp(&p->cg6_fhc_un.un_fhc, ca->ca_bustype);
d179 18
a196 2
		return (probeget(tmp, 4) != 0);
	}		
d198 1
d212 1
a212 1
	register int node = ca->ca_ra.ra_node, ramsize, i, isconsole;
d214 3
a216 2
	register volatile struct cg6_layout *p;
	char *nam;
d219 25
a243 3
	sc->sc_fb.fb_driver = &cg6_fbdriver;
	sc->sc_fb.fb_device = &sc->sc_dev;
	sc->sc_fb.fb_type.fb_type = FBTYPE_SUNFAST_COLOR;
a245 22
#if defined(SUN4)
	case BUS_PFOUR:
		node = 0;
#if 0
		/*
		 * XXX cg6 reset routine is not good enough to
		 * rebuild state correctly!
		 */
		pfour_reset();
#endif
		/*
		 * XXX pfour register is confused?
		 */
		sc->sc_fb.fb_type.fb_width = 1152;
		sc->sc_fb.fb_type.fb_height = 900;
		nam = "cgsix";
		break;
	case BUS_VME32:
		node = 0;
		nam = "cgsix";
		break;
#endif /* SUN4 */
d247 6
d254 2
a255 1
		if (cputyp == CPU_SUN4M) {   /* 4m has framebuffer on obio */
d261 7
d269 1
d272 4
d278 28
a305 10
	sc->sc_fb.fb_type.fb_depth = 8;
	fb_setsize(&sc->sc_fb, sc->sc_fb.fb_type.fb_depth,
	    1152, 900, node, ca->ca_bustype);

	ramsize = sc->sc_fb.fb_type.fb_height * sc->sc_fb.fb_linebytes;
	sc->sc_fb.fb_type.fb_cmsize = 256;
	sc->sc_fb.fb_type.fb_size = ramsize;
	printf(": %s, %d x %d", nam,
	    sc->sc_fb.fb_type.fb_width, sc->sc_fb.fb_type.fb_height);
	isconsole = node == fbnode && fbconstty != NULL;
d307 4
a310 16
	/*
	 * Dunno what the PROM has mapped, though obviously it must have
	 * the video RAM mapped.  Just map what we care about for ourselves
	 * (the FHC, THC, and Brooktree registers).
	 */
#define	O(memb) ((u_int)(&((struct cg6_layout *)0)->memb))
	sc->sc_physadr = ca->ca_ra.ra_reg[0];
	sc->sc_bustype = ca->ca_bustype;
	sc->sc_bt = bt = (volatile struct bt_regs *)mapiodev(ca->ca_ra.ra_reg,
	    O(cg6_bt_un.un_btregs), sizeof *sc->sc_bt, ca->ca_bustype);
	sc->sc_fhc = (volatile int *)mapiodev(ca->ca_ra.ra_reg,
	    O(cg6_fhc_un.un_fhc), sizeof *sc->sc_fhc, ca->ca_bustype);
	sc->sc_thc = (volatile struct cg6_thc *)mapiodev(ca->ca_ra.ra_reg,
	    O(cg6_thc_un.un_thc), sizeof *sc->sc_thc, ca->ca_bustype);
	sc->sc_tec = (volatile struct cg6_tec_xxx *)mapiodev(ca->ca_ra.ra_reg,
	    O(cg6_tec_un.un_tec), sizeof *sc->sc_tec, ca->ca_bustype);
d330 3
a332 2
		sc->sc_fb.fb_pixels = (caddr_t)mapiodev(ca->ca_ra.ra_reg,
		    O(cg6_ram[0]), ramsize, ca->ca_bustype);
d338 1
a338 1
	if (ca->ca_bustype == BUS_SBUS)
d340 3
a342 4
#endif /* SUN4C || SUN4M */
	if ((node == fbnode && cputyp != CPU_SUN4) ||
	    (isconsole && cputyp == CPU_SUN4))
		fb_attach(&sc->sc_fb);
d353 1
a353 1
	if (unit >= cgsixcd.cd_ndevs || cgsixcd.cd_devs[unit] == NULL)
d364 1
a364 1
	struct cgsix_softc *sc = cgsixcd.cd_devs[minor(dev)];
d378 1
a378 1
	register struct cgsix_softc *sc = cgsixcd.cd_devs[minor(dev)];
d380 1
a380 1
	int i, v, error;
d537 1
a537 1
		log(LOG_NOTICE, "cgsixioctl(%x) (%s[%d])\n", cmd,
d720 1
a720 1
	register struct cgsix_softc *sc = cgsixcd.cd_devs[minor(dev)];
d755 1
a755 1
			    sc->sc_bustype) | PMAP_NC);
@


1.4
log
@correct sun4 calls to fb_attach()
@
text
@d100 2
a101 1
	volatile struct cg6_layout *sc_physadr;	/* phys addr of h/w */
d184 1
a184 1
	register int node, ramsize, i, isconsole;
d217 8
a225 1
		node = ca->ca_ra.ra_node;
d239 1
d246 11
a256 14
	isconsole = node == fbnode && fbconstty != NULL;
	sc->sc_physadr = p = (struct cg6_layout *)ca->ca_ra.ra_paddr;
	sc->sc_bt = bt = (volatile struct bt_regs *)
	    mapiodev((caddr_t)&p->cg6_bt_un.un_btregs, sizeof *sc->sc_bt,
	    ca->ca_bustype);
	sc->sc_fhc = (volatile int *)
	    mapiodev((caddr_t)&p->cg6_fhc_un.un_fhc, sizeof *sc->sc_fhc,
	    ca->ca_bustype);
	sc->sc_thc = (volatile struct cg6_thc *)
	    mapiodev((caddr_t)&p->cg6_thc_un.un_thc, sizeof *sc->sc_thc,
	    ca->ca_bustype);
	sc->sc_tec = (volatile struct cg6_tec_xxx *)
	    mapiodev((caddr_t)&p->cg6_tec_un.un_tec, sizeof *sc->sc_tec,
	    ca->ca_bustype);
d275 5
d700 2
a701 2
			return ((int)sc->sc_physadr + u + mo->mo_physoff +
			    PMAP_OBIO + PMAP_NC);
@


1.3
log
@cleanup
@
text
@d183 1
a183 1
	register int node, ramsize, i;
d237 1
d267 1
a267 1
	if (node == fbnode && fbconstty != NULL) {
d275 2
a276 1
	if (node == fbnode)
@


1.2
log
@no mainbus or vme16 cg6; add pfour support
@
text
@d120 4
a123 3
struct cfdriver cgsixcd =
    { NULL, "cgsix", cgsixmatch, cgsixattach,
      DV_DULL, sizeof(struct cgsix_softc) };
@


1.1
log
@Initial revision
@
text
@d79 1
a152 1
	struct cg6_layout *p = (struct cg6_layout *)ra->ra_vaddr;
d159 10
a168 4
	ra->ra_len = NBPG;
	bus_tmp(&p->cg6_fhc_un.un_fhc, ca->ca_bustype);
	return (probeget(&p->cg6_fhc_un.un_fhc, 4) != 0);
#else
a169 1
#endif
a184 1
	int sbus = 1;
d193 17
a209 1
	case BUS_OBIO:
d211 1
a211 2
	case BUS_VME16:
		sbus = node = 0;
d214 1
a214 1

a218 4

	case BUS_MAIN:
		printf("cgsix on mainbus?\n");
		return;
d269 2
a270 1
	if (sbus)
d272 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
