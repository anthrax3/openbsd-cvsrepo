head	1.15;
access;
symbols
	OPENBSD_6_0:1.15.0.26
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.22
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.24
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.16
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.20
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.18
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.14
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.12
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.10
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.8
	OPENBSD_5_0:1.15.0.6
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.4
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.14.0.10
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.12
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.8
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.6
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.4
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.13.0.8
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.6
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.8.0.8
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.6
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.14
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.12
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.10
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2010.07.10.19.32.24;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2007.07.01.19.07.46;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.08.12.36.38;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.17.18.47.50;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.27.55;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.13.22.25.33;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.19.15.31.26;	author art;	state Exp;
branches
	1.8.8.1;
next	1.7;

1.7
date	97.08.25.08.38.47;	author downsj;	state Exp;
branches
	1.7.12.1;
next	1.6;

1.6
date	97.08.08.08.27.02;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.06.24.09.50.59;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.08.11.05.35.02;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.01.31.04.54.43;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.15.13.56.45;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.45;	author deraadt;	state Exp;
branches;
next	;

1.7.12.1
date	2001.05.14.21.37.14;	author niklas;	state Exp;
branches;
next	1.7.12.2;

1.7.12.2
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.7.12.3;

1.7.12.3
date	2003.05.16.00.29.40;	author niklas;	state Exp;
branches;
next	1.7.12.4;

1.7.12.4
date	2003.06.07.11.14.44;	author ho;	state Exp;
branches;
next	;

1.8.8.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	1.8.8.2;

1.8.8.2
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.15
log
@sun4e (i.e. SPARCengine 1e) support. This platform is a mix between sun4 and
sun4c, as it has a sun4c OpenPROM but a sun4 8KB pagesize. VME devices are
not supported yet.
ok deraadt@@
@
text
@/*	$OpenBSD: auxreg.c,v 1.14 2007/07/01 19:07:46 miod Exp $	*/
/*	$NetBSD: auxreg.c,v 1.21 1997/05/24 20:15:59 pk Exp $ */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)auxreg.c	8.1 (Berkeley) 6/11/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/timeout.h>

#include <uvm/uvm_param.h>

#include <machine/autoconf.h>

#include <sparc/sparc/vaddrs.h>
#include <sparc/sparc/auxioreg.h>

static int auxregmatch(struct device *, void *, void *);
static void auxregattach(struct device *, struct device *, void *);

struct cfattach auxreg_ca = {
	sizeof(struct device), auxregmatch, auxregattach
};

struct cfdriver auxreg_cd = {
	0, "auxreg", DV_DULL
};

volatile u_char *auxio_reg;	/* Copy of AUXIO_REG */
u_char auxio_regval;

#ifdef SUN4M	/* Tadpole SPARCbook */
volatile u_char *sb_auxio_reg;
volatile u_char *sb_auxio2_reg;
#endif

extern int sparc_led_blink;	/* from machdep */
struct timeout sparc_led_to;

void
led_blink(zero)
	void *zero;
{
	int s;

	/* Don't do anything if there's no auxreg, ok? */
	if (auxio_reg == NULL)
		return;

	if (!sparc_led_blink) {
		/* If blink has been disabled, make sure it goes back on... */
		s = splhigh();
		LED_ON;
		splx(s);
	
		return;
	}

	s = splhigh();
	LED_FLIP;
	splx(s);
	/*
	 * Blink rate is:
	 *	full cycle every second if completely idle (loadav = 0)
	 *	full cycle every 2 seconds if loadav = 1
	 *	full cycle every 3 seconds if loadav = 2
	 * etc.
	 */
	s = (((averunnable.ldavg[0] + FSCALE) * hz) >> (FSHIFT + 1));

	timeout_add(&sparc_led_to, s);
}

/*
 * The OPENPROM calls this "auxiliary-io".
 * We also need to match the "auxio2" register on Tadpole SPARCbooks.
 */
static int
auxregmatch(struct device *parent, void *cf, void *aux)
{
	struct confargs *ca = aux;

	switch (cputyp) {
	case CPU_SUN4:
	default:
		return (0);
	case CPU_SUN4C:
	case CPU_SUN4E:
		return (strcmp("auxiliary-io", ca->ca_ra.ra_name) == 0);
	case CPU_SUN4M:
		return (strcmp("auxio", ca->ca_ra.ra_name) == 0 ||
			strcmp("auxio2", ca->ca_ra.ra_name) == 0);
	}
}

/* ARGSUSED */
static void
auxregattach(struct device *parent, struct device *self, void *aux)
{
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;
#ifdef SUN4M
	volatile u_char **regp;

	if (CPU_ISSUN4M && strncmp("Tadpole", mainbus_model, 7) == 0) {
		if (strcmp("auxio", ra->ra_name) == 0)
			regp = &sb_auxio_reg;
		else
			regp = &sb_auxio2_reg;
		if (*regp == NULL)
			*regp = mapiodev(ra->ra_reg, 0, sizeof(char));
	} else
#endif
	if (auxio_reg == NULL) {
		(void)mapdev(ra->ra_reg, AUXREG_VA, 0, sizeof(long));
		if (CPU_ISSUN4M) {
			auxio_reg = AUXIO4M_REG;
			auxio_regval = *AUXIO4M_REG | AUXIO4M_MB1;
		} else {
			auxio_reg = AUXIO4C_REG;
			auxio_regval = *AUXIO4C_REG | AUXIO4C_FEJ | AUXIO4C_MB1;
		}

		timeout_set(&sparc_led_to, led_blink, NULL);
		/* In case it's initialized to true... */
		if (sparc_led_blink)
			led_blink((caddr_t)0);
	}

	printf("\n");
}

unsigned int
auxregbisc(int bis, int bic)
{
	int s;

#ifdef DIAGNOSTIC
	if (auxio_reg == NULL)
		/*
		 * Not all machines have an `aux' register; devices that
		 * depend on it should not get configured if it's absent.
		 */
		panic("no aux register");
#endif

	s = splhigh();
	auxio_regval = (auxio_regval | bis) & ~bic;
	*auxio_reg = auxio_regval;
	splx(s);
	return (auxio_regval);
}

#ifdef SUN4M
unsigned int
sb_auxregbisc(int isreg2, int bis, int bic)
{
	int s;
	volatile u_char *auxreg;
	u_char aux;

	auxreg = isreg2 ? sb_auxio2_reg : sb_auxio_reg;
	if (auxreg == NULL)
		return (0);

	s = splhigh();
	aux = (*auxreg | bis) & ~bic;
	*auxreg = aux;
	splx(s);
	return (aux);
}
#endif
@


1.14
log
@Use mapiodev() instead of mapdev() when applicable. This is just syntactic
sugar.
@
text
@d1 1
a1 1
/*	$OpenBSD: auxreg.c,v 1.13 2005/07/08 12:36:38 miod Exp $	*/
d127 1
@


1.13
log
@Allow more than one auxio device to attach, and attach both SPARCbook auxio
registers. However, those are handled specifically since they do not have
the same meaning as the regular sun4c/sun4m auxio register.

A specific auxregbisc() function is provided for explicit sparcbook operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: auxreg.c,v 1.12 2005/04/17 18:47:50 miod Exp $	*/
d149 1
a149 1
			*regp = mapdev(ra->ra_reg, 0, 0, sizeof(char));
@


1.12
log
@Do not use KERNBASE when VM_MIN_KERNEL_ADDRESS or VM_MAXUSER_ADDRESS are
implied; this currently does not change anything (yet).

Also, define the I/O space range in <machine/vmparam.h> rather than in
<sparc/sparc/vaddrs.h>.

ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auxreg.c,v 1.11 2003/06/02 23:27:55 millert Exp $	*/
d70 6
d86 1
a86 1
	if (auxio_reg == 0)
d115 1
d118 1
a118 3
auxregmatch(parent, cf, aux)
	struct device *parent;
	void *cf, *aux;
d120 1
a120 1
	register struct confargs *ca = aux;
d123 2
a124 1
	    case CPU_SUN4:
d126 1
a126 1
	    case CPU_SUN4C:
d128 3
a130 4
	    case CPU_SUN4M:
		return (strcmp("auxio", ca->ca_ra.ra_name) == 0);
	    default:
		panic("auxregmatch");
d136 1
a136 3
auxregattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d140 2
d143 23
a165 7
	(void)mapdev(ra->ra_reg, AUXREG_VA, 0, sizeof(long));
	if (CPU_ISSUN4M) {
		auxio_reg = AUXIO4M_REG;
		auxio_regval = *AUXIO4M_REG | AUXIO4M_MB1;
	} else {
		auxio_reg = AUXIO4C_REG;
		auxio_regval = *AUXIO4C_REG | AUXIO4C_FEJ | AUXIO4C_MB1;
a168 5

	timeout_set(&sparc_led_to, led_blink, NULL);
	/* In case it's initialized to true... */
	if (sparc_led_blink)
		led_blink((caddr_t)0);
d172 1
a172 2
auxregbisc(bis, bic)
	int bis, bic;
d174 1
a174 1
	register int s;
d176 2
a177 1
	if (auxio_reg == 0)
d183 1
d191 20
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: auxreg.c,v 1.10 2003/05/13 22:25:33 miod Exp $	*/
d49 2
@


1.10
log
@Nuke a few simple commons.
@
text
@d1 1
a1 1
/*	$OpenBSD: auxreg.c,v 1.9 2002/03/14 01:26:44 millert Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: auxreg.c,v 1.8 2000/07/19 15:31:26 art Exp $	*/
d70 2
@


1.8
log
@Blink with new timeouts.
@
text
@d1 1
a1 1
/*	$OpenBSD: auxreg.c,v 1.7 1997/08/25 08:38:47 downsj Exp $	*/
d59 2
a60 2
static int auxregmatch __P((struct device *, void *, void *));
static void auxregattach __P((struct device *, struct device *, void *));
@


1.8.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: auxreg.c,v 1.8 2000/07/19 15:31:26 art Exp $	*/
d59 2
a60 2
static int auxregmatch(struct device *, void *, void *);
static void auxregattach(struct device *, struct device *, void *);
@


1.8.8.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a69 2
volatile u_char *auxio_reg;	/* Copy of AUXIO_REG */
u_char auxio_regval;
@


1.7
log
@Implement LED blinking as a run-time configurable option via the sysctl
machdep.led_blink.

Rename auxreg.h because we need config to generate one now.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 1
d71 1
d77 1
a77 1
	register int s;
d104 1
a104 1
	timeout(led_blink, (caddr_t)0, s);
d149 1
@


1.7.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: auxreg.c,v 1.8 2000/07/19 15:31:26 art Exp $	*/
a51 1
#include <sys/timeout.h>
a69 1
struct timeout sparc_led_to;
d75 1
a75 1
	int s;
d102 1
a102 1
	timeout_add(&sparc_led_to, s);
a146 1
	timeout_set(&sparc_led_to, led_blink, NULL);
@


1.7.12.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 2
a60 2
static int auxregmatch(struct device *, void *, void *);
static void auxregattach(struct device *, struct device *, void *);
@


1.7.12.3
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@a69 2
volatile u_char *auxio_reg;	/* Copy of AUXIO_REG */
u_char auxio_regval;
@


1.7.12.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: auxreg.c,v 1.7.12.3 2003/05/16 00:29:40 niklas Exp $	*/
d25 5
a29 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
d56 1
a56 1
#include <sparc/sparc/auxreg.h>
d69 1
a69 2
#ifdef BLINK
static void blink __P((void *zero));
d71 2
a72 2
static void
blink(zero)
d77 13
d101 2
a102 1
	timeout(blink, (caddr_t)0, s);
a103 1
#endif
d146 4
a149 3
#ifdef BLINK
	blink((caddr_t)0);
#endif
@


1.5
log
@New floppy and auxreg drivers, from NetBSD.  fd.c has many changes preserved,
and uses our fdformat interface (same code base as NetBSD, with differently
named ioctls, but we have always preserved the names of the original code's
authors, unlike NetBSD...)
@
text
@d123 1
a123 1
	(void)mapdev(ra->ra_reg, AUXREG_VA, 0, sizeof(long), ca->ca_bustype);
@


1.4
log
@netbsd port, now we merge our changes back in
@
text
@d1 1
a1 1
/*	$NetBSD: auxreg.c,v 1.14 1996/04/13 17:40:03 abrown Exp $ */
d96 1
a96 1
auxregmatch(parent, vcf, aux)
d98 1
a98 1
	void *aux, *vcf;
d124 8
a131 1
	auxio_reg = AUXIO_REG;
d142 1
a142 1
	register int v, s = splhigh();
d144 10
a153 2
	v = *AUXIO_REG;
	*AUXIO_REG = ((v | bis) & ~bic) | AUXIO_MB1;
d155 1
a155 1
	return v;
a156 1

@


1.3
log
@do not worry about mapdev retval
@
text
@d1 1
a1 1
/*	$NetBSD: auxreg.c,v 1.9 1995/12/11 12:45:16 pk Exp $ */
d48 1
d59 8
a66 2
struct cfdriver auxregcd =
    { 0, "auxreg", auxregmatch, auxregattach, DV_DULL, sizeof(struct device) };
d69 3
a71 1
static int
a75 1
	register fixpt_t lav;
d87 1
a87 1
	s = (((averunnable[0] + FSCALE) * hz) >> (FSHIFT + 1));
a100 1
	struct cfdata *cf = vcf;
d102 2
a103 1
	if (cputyp==CPU_SUN4)
d105 7
a111 1
	return (strcmp("auxiliary-io", ca->ca_ra.ra_name) == 0);
d133 1
@


1.2
log
@new mapdev/()/mapiodev() calling convention uses "struct rom_reg *" to supply
base plus an offset
new dvma routines
@
text
@d1 1
a1 1
/*	$NetBSD: auxreg.c,v 1.8 1995/02/22 21:13:01 pk Exp $ */
d109 2
a110 4
	auxio_reg = mapdev(ra->ra_reg, AUXREG_VA, 0, sizeof(long),
	    ca->ca_bustype);
	if ((u_long)auxio_reg != AUXREG_VA)
		panic("unable to map auxreg");
@


1.1
log
@Initial revision
@
text
@d109 4
a112 2
	(void)mapdev(ra->ra_paddr, AUXREG_VA, sizeof(long), ca->ca_bustype);
	auxio_reg = AUXIO_REG;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
