head	1.45;
access;
symbols
	OPENBSD_6_0:1.45.0.2
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.40.0.6
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.39.0.4
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.38.0.8
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.38.0.4
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.38.0.2
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.37.0.8
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.6
	OPENBSD_5_0:1.37.0.4
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.37.0.2
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.34.0.2
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.4
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.31.0.8
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.6
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.31.0.4
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.31.0.2
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.28.0.8
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.6
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.28.0.4
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.28.0.2
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.27.0.2
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.26.0.4
	OPENBSD_3_6_BASE:1.26
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	UBC_SYNC_A:1.23
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.22
	UBC:1.17.0.2
	UBC_BASE:1.17
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	SMP:1.12.0.2
	SMP_BASE:1.12
	kame_19991208:1.9
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.45
date	2016.06.22.06.34.35;	author dlg;	state Exp;
branches;
next	1.44;
commitid	ng8kTRDJrCUY7noA;

1.44
date	2016.06.20.11.02.33;	author dlg;	state Exp;
branches;
next	1.43;
commitid	9ZcVv11nnmonpmTs;

1.43
date	2015.12.10.19.48.04;	author mmcc;	state Exp;
branches;
next	1.42;
commitid	IegoPc6ss7aut6L1;

1.42
date	2015.11.02.16.55.31;	author mpi;	state Exp;
branches;
next	1.41;
commitid	Vu0jkheHA7bOsg6R;

1.41
date	2015.09.08.10.21.16;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	DGOx6p2gOlciIkZ2;

1.40
date	2014.11.22.22.48.38;	author miod;	state Exp;
branches;
next	1.39;
commitid	lw1qpLaP6fJz4gKy;

1.39
date	2014.07.12.18.44.43;	author tedu;	state Exp;
branches;
next	1.38;
commitid	uKVPYMN2MLxdZxzH;

1.38
date	2012.11.05.13.20.16;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2010.12.21.14.56.24;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2010.09.28.18.52.00;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	2010.07.10.19.32.25;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2010.07.06.20.40.01;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2009.04.10.20.53.54;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2007.05.29.18.10.43;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.29.09.53.57;	author sobrado;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.01.15.21.43;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2005.08.14.10.58.36;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2004.09.29.07.35.14;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2003.11.06.21.09.35;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.23.19.19.33;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.02.23.27.55;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.12.10.23.43.48;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2002.08.12.10.44.04;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.22.01.01.19;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.15.23.17.54;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2002.04.30.01.12.28;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.07.04.08.43.29;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	2000.11.08.13.58.19;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.04.12.34.05;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.21.17.08.36;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.09.06.01.16;	author itojun;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2000.01.27.20.14.11;	author art;	state Exp;
branches;
next	1.10;

1.10
date	99.12.17.23.46.53;	author art;	state Exp;
branches;
next	1.9;

1.9
date	99.12.08.06.50.16;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	99.07.09.21.30.02;	author art;	state Exp;
branches;
next	1.7;

1.7
date	99.05.24.23.09.08;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	99.01.07.23.16.08;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.08.08.08.27.17;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	97.07.26.17.09.33;	author denny;	state Exp;
branches;
next	1.3;

1.3
date	97.07.23.06.58.29;	author denny;	state Exp;
branches;
next	1.2;

1.2
date	96.08.11.05.35.12;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.46;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.46;	author deraadt;	state Exp;
branches;
next	;

1.12.2.1
date	2000.02.21.22.29.03;	author niklas;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2001.05.14.21.37.16;	author niklas;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2001.10.31.03.07.57;	author nate;	state Exp;
branches;
next	1.12.2.4;

1.12.2.4
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.12.2.5;

1.12.2.5
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.12.2.6;

1.12.2.6
date	2003.03.27.23.49.26;	author niklas;	state Exp;
branches;
next	1.12.2.7;

1.12.2.7
date	2003.06.07.11.14.44;	author ho;	state Exp;
branches;
next	1.12.2.8;

1.12.2.8
date	2004.02.19.10.49.58;	author niklas;	state Exp;
branches;
next	;

1.17.2.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.10.29.00.28.10;	author art;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.45
log
@dont need a traliing \ on a line in c code, it's not a macro definition.

from patrick keshishian
@
text
@/*	$OpenBSD: intr.c,v 1.44 2016/06/20 11:02:33 dlg Exp $ */
/*	$NetBSD: intr.c,v 1.20 1997/07/29 09:42:03 fair Exp $ */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)intr.c	8.3 (Berkeley) 11/11/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/malloc.h>

#include <uvm/uvm_extern.h>

#include <dev/cons.h>

#include <machine/atomic.h>
#include <machine/cpu.h>
#include <machine/ctlreg.h>
#include <machine/instr.h>
#include <machine/trap.h>

#include <sparc/sparc/cpuvar.h>

extern void raise(int, int);

void	ih_insert(struct intrhand **, struct intrhand *);
void	ih_remove(struct intrhand **, struct intrhand *);

void	strayintr(struct clockframe *);

/*
 * Stray interrupt handler.  Clear it if possible.
 * If not, and if we get 10 interrupts in 10 seconds, panic.
 */
void
strayintr(fp)
	struct clockframe *fp;
{
	static int nstray;
	static time_t straytime;
	time_t timesince;

	printf("stray interrupt ipl 0x%x pc=0x%x npc=0x%x psr=%b\n",
		fp->ipl, fp->pc, fp->npc, fp->psr, PSR_BITS);
	timesince = time_second - straytime;
	if (timesince <= 10) {
		if (++nstray > 9)
			panic("crazy interrupts");
	} else {
		straytime = time_second;
		nstray = 1;
	}
}

#if defined(SUN4M)
void	nmi_hard(void);

int	(*memerr_handler)(void);

void
nmi_hard()
{
	/*
         * A level 15 hard interrupt.
         */
	int fatal = 0;
	u_int32_t si;
	u_int afsr, afva;

	afsr = afva = 0;
	if ((*cpuinfo.get_asyncflt)(&afsr, &afva) == 0) {
		printf("Async registers (mid %d): afsr=%b; afva=0x%x%x\n",
		       cpuinfo.mid, afsr, AFSR_BITS,
		       (afsr & AFSR_AFA) >> AFSR_AFA_RSHIFT, afva);
	}

	if (cpuinfo.master == 0) {
		/*
		 * For now, just return.
		 * Should wait on damage analysis done by the master.
		 */
		return;
	}

	/*
	 * Examine pending system interrupts.
	 */
	si = *((u_int32_t *)ICR_SI_PEND);
	printf("NMI: system interrupts: %b\n", si, SINTR_BITS);

	if ((si & SINTR_M) != 0) {
		/* ECC memory error */
                if (memerr_handler != NULL)
                        fatal |= (*memerr_handler)();
        }
#ifdef notyet
        if ((si & SINTR_I) != 0) {
                /* MBus/SBus async error */
                if (sbuserr_handler != NULL)
                        fatal |= (*sbuserr_handler)();
        }
        if ((si & SINTR_V) != 0) {
                /* VME async error */
                if (vmeerr_handler != NULL)
                        fatal |= (*vmeerr_handler)();
        }
        if ((si & SINTR_ME) != 0) {
                /* Module async error */
                if (moduleerr_handler != NULL)
                        fatal |= (*moduleerr_handler)();
        }
#else
	fatal |= si & (SINTR_I | SINTR_V | SINTR_ME);
#endif

        if (fatal)
                panic("nmi");
}
#endif

/*
 * Level 15 interrupts are special, and not vectored here.
 * Only `prewired' interrupts appear here; boot-time configured devices
 * are attached via intr_establish() below.
 */
struct intrhand *intrhand[15] = {
	NULL,			/*  0 = error */
	NULL,			/*  1 = software level 1 + SBus */
	NULL,	 		/*  2 = SBus level 2 (4m: SBus L1) */
	NULL,			/*  3 = SCSI + DMA + SBus level 3 (4m: L2,lpt)*/
	NULL,			/*  4 = software level 4 (tty softint) (scsi) */
	NULL,			/*  5 = Ethernet + SBus level 4 (4m: SBus L3) */
	NULL,			/*  6 = software level 6 (not used) (4m: enet)*/
	NULL,			/*  7 = video + SBus level 5 */
	NULL,			/*  8 = SBus level 6 */
	NULL,			/*  9 = SBus level 7 */
	NULL,			/* 10 = counter 0 = clock */
	NULL,			/* 11 = floppy */
	NULL,			/* 12 = zs hardware interrupt */
	NULL,			/* 13 = audio chip */
	NULL,			/* 14 = counter 1 = profiling timer */
};

/*
 * Soft interrupts use a separate set of handler chains.
 * This is necessary since soft interrupt handlers do not return a value
 * and therefore can not be mixed with hardware interrupt handlers on a
 * shared handler chain.
 */
struct intrhand *sintrhand[15];

void
ih_insert(struct intrhand **head, struct intrhand *ih)
{
	struct intrhand **p, *q;

	/*
	 * This is O(N^2) for long chains, but chains are never long
	 * and we do want to preserve order.
	 */
	for (p = head; (q = *p) != NULL; p = &q->ih_next)
		continue;
	*p = ih;
	ih->ih_next = NULL;
}

void
ih_remove(struct intrhand **head, struct intrhand *ih)
{
	struct intrhand **p, *q;

	for (p = head; (q = *p) != ih; p = &q->ih_next)
		continue;
	if (q == NULL)
		panic("ih_remove: intrhand %p (fn %p arg %p) not found from %p",
		    ih, ih->ih_fun, ih->ih_arg, head);

	*p = q->ih_next;
	q->ih_next = NULL;
}

static int fastvec;		/* marks fast vectors (see below) */
static struct {
	int (*cb)(void *);
	void *data;
} fastvec_share[15];

extern int sparc_interrupt4m[];
extern int sparc_interrupt44c[];

/*
 * Attach an interrupt handler to the vector chain for the given level.
 * This may not be possible if it has been taken away as a fast vector.
 */
void
intr_establish(level, ih, ipl_block, name)
	int level;
	struct intrhand *ih;
	int ipl_block;
	const char *name;
{
#ifdef DIAGNOSTIC
	struct trapvec *tv;
	int displ;
#endif
	int s;

	if (ipl_block == -1)
		ipl_block = level;

#ifdef DIAGNOSTIC
	/*
	 * If the level we're supposed to block is lower than this interrupts
	 * level someone is doing something very wrong. Most likely it
	 * means that some IPL_ constant in machine/psl.h is preconfigured too
	 * low.
	 */
	if (ipl_block < level)
		panic("intr_establish: level (%d) > block (%d)", level,
		    ipl_block);
	if (ipl_block > 15)
		panic("intr_establish: strange block level: %d", ipl_block);
#endif

	/*
	 * We store the ipl pre-shifted so that we can avoid one instruction
	 * in the interrupt handlers.
	 */
	ih->ih_vec = ipl_block;
	ih->ih_ipl = (ipl_block << 8);
	if (name != NULL)
		evcount_attach(&ih->ih_count, name, &ih->ih_vec);

	s = splhigh();

	/*
	 * Check if this interrupt is already being handled by a fast trap.
	 * If so, attempt to change it back to a regular (thus) shareable
	 * trap.
	 */
	if (fastvec & (1 << level)) {
		if (fastvec_share[level].cb == NULL ||
		    (*fastvec_share[level].cb)(fastvec_share[level].data) != 0)
			panic("intr_establish: level %d interrupt tied to"
			    " unremovable fast vector", level);
	}

#ifdef DIAGNOSTIC
	/* double check for legal hardware interrupt */
	if ((level != 1 && level != 4 && level != 6) || CPU_ISSUN4M ) {
		tv = &trapbase[T_L1INT - 1 + level];
		displ = (CPU_ISSUN4M)
			? &sparc_interrupt4m[0] - &tv->tv_instr[1]
			: &sparc_interrupt44c[0] - &tv->tv_instr[1];

		/* has to be `mov level,%l3; ba _sparc_interrupt; rdpsr %l0' */
		if (tv->tv_instr[0] != I_MOVi(I_L3, level) ||
		    tv->tv_instr[1] != I_BA(0, displ) ||
		    tv->tv_instr[2] != I_RDPSR(I_L0))
			panic("intr_establish(%d, %p)\n0x%x 0x%x 0x%x != 0x%x 0x%x 0x%x",
			    level, ih,
			    tv->tv_instr[0], tv->tv_instr[1], tv->tv_instr[2],
			    I_MOVi(I_L3, level), I_BA(0, displ), I_RDPSR(I_L0));
	}
#endif
	ih_insert(&intrhand[level], ih);
	splx(s);
}

/*
 * Like intr_establish, but wires a fast trap vector.  Only one such fast
 * trap is legal for any interrupt, and it must be a hardware interrupt.
 * In case some other device wants to share the interrupt, we also register
 * a callback which will be able to revert this and register a slower, but
 * shareable trap vector if necessary (for example, to share int 13 between
 * audioamd and stp).
 */
int
intr_fasttrap(int level, void (*vec)(void), int (*share)(void *), void *cbdata)
{
	struct trapvec *tv;
	u_long hi22, lo10;
#ifdef DIAGNOSTIC
	int displ;	/* suspenders, belt, and buttons too */
#endif
	int s, i;
	int instr[3];
	char *instrp;
	char *tvp;

	tv = &trapbase[T_L1INT - 1 + level];
	hi22 = ((u_long)vec) >> 10;
	lo10 = ((u_long)vec) & 0x3ff;
	s = splhigh();

	/*
	 * If this interrupt is already being handled, or if it is also used
	 * for software interrupts, we fail; the caller will either panic or
	 * try to register a slow (shareable) trap.
	 */
	if ((fastvec & (1 << level)) != 0 ||
	    intrhand[level] != NULL || sintrhand[level] != NULL) {
		splx(s);
		return (EBUSY);
	}

#ifdef DIAGNOSTIC
	displ = (CPU_ISSUN4M)
		? &sparc_interrupt4m[0] - &tv->tv_instr[1]
		: &sparc_interrupt44c[0] - &tv->tv_instr[1];

	/* has to be `mov level,%l3; ba _sparc_interrupt; rdpsr %l0' */
	if (tv->tv_instr[0] != I_MOVi(I_L3, level) ||
	    tv->tv_instr[1] != I_BA(0, displ) ||
	    tv->tv_instr[2] != I_RDPSR(I_L0))
		panic("intr_fasttrap(%d, %p)\n0x%x 0x%x 0x%x != 0x%x 0x%x 0x%x",
		    level, vec,
		    tv->tv_instr[0], tv->tv_instr[1], tv->tv_instr[2],
		    I_MOVi(I_L3, level), I_BA(0, displ), I_RDPSR(I_L0));
#endif
	
	instr[0] = I_SETHI(I_L3, hi22);		/* sethi %hi(vec),%l3 */
	instr[1] = I_JMPLri(I_G0, I_L3, lo10);	/* jmpl %l3+%lo(vec),%g0 */
	instr[2] = I_RDPSR(I_L0);		/* mov %psr, %l0 */

	fastvec_share[level].cb = share;
	fastvec_share[level].data = cbdata;

	tvp = (char *)tv->tv_instr;
	instrp = (char *)instr;
	for (i = 0; i < sizeof(int) * 3; i++, instrp++, tvp++)
		pmap_writetext(tvp, *instrp);
	fastvec |= 1 << level;
	splx(s);

	return (0);
}

void
intr_fastuntrap(int level)
{
	struct trapvec *tv;
	int i, s;
	int displ;
	int instr[3];
	char *instrp;
	char *tvp;

	tv = &trapbase[T_L1INT - 1 + level];

	/* restore to `mov level,%l3; ba _sparc_interrupt; rdpsr %l0' */
	displ = (CPU_ISSUN4M)
		? &sparc_interrupt4m[0] - &tv->tv_instr[1]
		: &sparc_interrupt44c[0] - &tv->tv_instr[1];
	instr[0] = I_MOVi(I_L3, level);
	instr[1] = I_BA(0, displ);
	instr[2] = I_RDPSR(I_L0);

	s = splhigh();

#ifdef DIAGNOSTIC
	if ((fastvec & (1 << level)) == 0) {
		splx(s);
		return;
	}
#endif

	tvp = (char *)tv->tv_instr;
	instrp = (char *)instr;
	for (i = 0; i < sizeof(int) * 3; i++, instrp++, tvp++)
		pmap_writetext(tvp, *instrp);
	fastvec &= ~(1 << level);
	fastvec_share[level].cb = NULL;

	splx(s);
}

void
intr_barrier(void *cookie)
{
}

void
softintr_disestablish(void *arg)
{
	struct sintrhand *sih = (struct sintrhand *)arg;

	ih_remove(&sintrhand[sih->sih_ipl], &sih->sih_ih);
	free(sih, M_DEVBUF, sizeof *sih);
}

void *
softintr_establish(int level, void (*fn)(void *), void *arg)
{
	struct sintrhand *sih;
	struct intrhand *ih;
	int ipl, hw;
	int s;

	/*
	 * On a sun4m, the interrupt level is stored unmodified
	 * to be passed to raise().
	 * On a sun4 or sun4c, the appropriate bit to set
	 * in the interrupt enable register is stored, to be
	 * passed to intreg_set_44c().
	 */
	ipl = hw = level;
#if defined(SUN4) || defined(SUN4C) || defined(SUN4E)
	if (CPU_ISSUN4OR4COR4E) {
		/*
		 * Select the most suitable of the three available
		 * softintr levels.
		 */
		if (level < 4) {
			ipl = 1;
			hw = IE_L1;
		} else if (level < 6) {
			ipl = 4;
			hw = IE_L4;
		} else {
			ipl = 6;
			hw = IE_L6;
		}
	}
#endif

	sih = (struct sintrhand *)malloc(sizeof *sih, M_DEVBUF,
	    M_NOWAIT|M_ZERO);
	if (sih == NULL)
		return NULL;

	sih->sih_ipl = ipl;
	sih->sih_hw = hw;

	ih = &sih->sih_ih;
	ih->ih_fun = (int (*)(void *))fn;
	ih->ih_arg = arg;
	/*
	 * We store the ipl pre-shifted so that we can avoid one instruction
	 * in the interrupt handlers.
	 */
	ih->ih_ipl = level << 8;

	s = splhigh();

	/*
	 * Check if this interrupt is already being handled by a fast trap.
	 * If so, attempt to change it back to a regular (thus) shareable
	 * trap.
	 */
	if (fastvec & (1 << ipl)) {
		if (fastvec_share[ipl].cb == NULL ||
		    (*fastvec_share[ipl].cb)(fastvec_share[ipl].data) != 0)
			panic("softintr_establish: level %d interrupt tied to"
			    " unremovable fast vector", ipl);
	}

	ih_insert(&sintrhand[ipl], ih);
	splx(s);

	return sih;
}

void
softintr_schedule(void *arg)
{
	struct sintrhand *sih = (struct sintrhand *)arg;
	int s;

	s = splhigh();
	if (sih->sih_pending == 0) {
		sih->sih_pending++;

		switch (cputyp) {
		default:
#if defined(SUN4M)
		case CPU_SUN4M:
			raise(0, sih->sih_hw);
			break;
#endif
#if defined(SUN4) || defined(SUN4C) || defined(SUN4E)
		case CPU_SUN4:
		case CPU_SUN4E:
		case CPU_SUN4C:
			intreg_set_44c(sih->sih_hw);
			break;
#endif
		}
	}
	splx(s);
}

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	int oldipl = (getpsr() & PSR_PIL) >> 8;

	if (oldipl < wantipl) {
		splassert_fail(wantipl, oldipl, func);
		/*
		 * If the splassert_ctl is set to not panic, raise the ipl
		 * in a feeble attempt to reduce damage.
		 */
		setpsr((getpsr() & ~PSR_PIL) | wantipl << 8);
	}
}
#endif

int
spl0(void)
{
	int psr, oldipl;

	/*
	 * wrpsr xors two values: we choose old psr and old ipl here,
	 * which gives us the same value as the old psr but with all
	 * the old PIL bits turned off.
	 */
	__asm volatile("rd %%psr,%0" : "=r" (psr));
	oldipl = psr & PSR_PIL;
	__asm volatile("wr %0,%1,%%psr" : : "r" (psr), "r" (oldipl));

	/*
	 * Three instructions must execute before we can depend
	 * on the bits to be changed.
	 */
	__asm volatile("nop; nop; nop");
	return (oldipl);
}

int
splraise(int newipl)
{
	int psr, oldipl;

	newipl <<= 8;

	__asm volatile("rd %%psr,%0" : "=r" (psr));
	oldipl = psr & PSR_PIL;
	if (newipl <= oldipl)
		return oldipl;

	psr &= ~PSR_PIL;
	__asm volatile("wr %0,%1,%%psr" : : "r" (psr), "rn" (newipl));
	__asm volatile("nop; nop; nop");
	__asm volatile("":::"memory");	/* protect from reordering */

	return (oldipl);
}

int
splhigh(void)
{
	int psr, oldipl;

	__asm volatile("rd %%psr,%0" : "=r" (psr));
	__asm volatile("wr %0,0,%%psr" : : "r" (psr | PSR_PIL));
	__asm volatile("and %1,%2,%0; nop; nop" : "=r" (oldipl) :
	    "r" (psr), "n" (PSR_PIL));
	__asm volatile("":::"memory");	/* protect from reordering */
	return (oldipl);
}

void
splx(int newipl)
{
	int psr;

	__asm volatile("":::"memory");	/* protect from reordering */
	__asm volatile("rd %%psr,%0" : "=r" (psr));
	__asm volatile("wr %0,%1,%%psr" : :
	    "r" (psr & ~PSR_PIL), "rn" (newipl));
	__asm volatile("nop; nop; nop");
}
@


1.44
log
@rework the splfoo implementation so it can provide splraise.

sparc was like sparc64 (or more likely sparc64 was like sparc) in
that the spl api was build with macros that created inline functions
that the spl were implemented as. this rework provides an splraise
that the splfoo macros are defined to.

because the code sequences for spl0, splraise, and splx are relatively
long, ive turned them into functions.

tested by (and thanks go to) miod@@ tobiasu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.43 2015/12/10 19:48:04 mmcc Exp $ */
d585 1
a585 1
	__asm volatile("":::"memory");	/* protect from reordering */ \
@


1.43
log
@Remove remaining Solbourne code.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.42 2015/11/02 16:55:31 mpi Exp $ */
d547 67
@


1.42
log
@intr_barrier() stub.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.41 2015/09/08 10:21:16 deraadt Exp $ */
a523 5
			break;
#endif
#if defined(solbourne)
		case CPU_KAP:
			ienab_bis(sih->sih_hw);
@


1.41
log
@sizes for free(); ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.40 2014/11/22 22:48:38 miod Exp $ */
d414 5
@


1.40
log
@Driver for the ECC memory controller found on some sun4m (ss20), so that
recoverable memory errors no longer panic the kernel.
From NetBSD but the manual page.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.39 2014/07/12 18:44:43 tedu Exp $ */
d422 1
a422 1
	free(sih, M_DEVBUF, 0);
@


1.39
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.38 2012/11/05 13:20:16 miod Exp $ */
d95 3
a103 1
#ifdef noyet
a104 1
#endif
a128 1
#ifdef notyet
d134 1
d150 3
a154 1
#endif
@


1.38
log
@Switch sparc to timecounters. Heavily based on NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.37 2010/12/21 14:56:24 claudio Exp $ */
d419 1
a419 1
	free(sih, M_DEVBUF);
@


1.37
log
@Convert netisr to a normal soft interrupt instead of hanving MD code
for it. This makes the netisr a real C function which will help further
development. No noticable performance change on i386 and amd64.
With input from kettenis@@ and miod@@ additional OKs mikeb@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.36 2010/09/28 18:52:00 deraadt Exp $ */
d77 3
a79 2
	static int straytime, nstray;
	int timesince;
d83 1
a83 1
	timesince = time.tv_sec - straytime;
d88 1
a88 1
		straytime = time.tv_sec;
a92 3
static struct intrhand level10 = { clockintr, NULL, (IPL_CLOCK << 8) };
static struct intrhand level14 = { statintr, NULL, (IPL_STATCLOCK << 8) };

a155 9
void
intr_init()
{
	level10.ih_vec = level10.ih_ipl >> 8;
	evcount_attach(&level10.ih_count, "clock", &level10.ih_vec);
	level14.ih_vec = level14.ih_ipl >> 8;
	evcount_attach(&level14.ih_count, "prof", &level14.ih_vec);
}

d172 1
a172 1
	&level10,		/* 10 = counter 0 = clock */
d176 1
a176 1
	&level14,		/* 14 = counter 1 = profiling timer */
@


1.36
log
@malloc() without a WAIT flag
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.35 2010/09/20 06:33:47 matthew Exp $ */
a53 3
#include <net/netisr.h>
#include <net/if.h>

a61 14
#ifdef INET
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/ip_var.h>
#endif

#ifdef INET6
# ifndef INET
#  include <netinet/in.h>
# endif
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#endif

a66 1
void	softnet(void *);
a164 2

	softnet_ih = softintr_establish(IPL_SOFTNET, softnet, NULL);
a536 23
}

void *softnet_ih;
int netisr;

void
softnet(void *arg)
{
	int n;

	while ((n = netisr) != 0) {
		atomic_clearbits_int(&netisr, n);

#define DONETISR(bit, fn)						\
		do {							\
			if (n & (1 << bit))				\
				fn();					\
		} while (0)

#include <net/netisr_dispatch.h>

#undef DONETISR
	}
@


1.35
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.34 2010/07/10 19:32:25 miod Exp $ */
d488 2
a489 1
	sih = (struct sintrhand *)malloc(sizeof *sih, M_DEVBUF, M_ZERO);
@


1.34
log
@sun4e (i.e. SPARCengine 1e) support. This platform is a mix between sun4 and
sun4c, as it has a sun4c OpenPROM but a sun4 8KB pagesize. VME devices are
not supported yet.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.33 2010/07/06 20:40:01 miod Exp $ */
d180 1
a180 2
	evcount_attach(&level10.ih_count, "clock", &level10.ih_vec,
	    &evcount_intr);
d182 1
a182 2
	evcount_attach(&level14.ih_count, "prof", &level14.ih_vec,
	    &evcount_intr);
d298 1
a298 1
		evcount_attach(&ih->ih_count, name, &ih->ih_vec, &evcount_intr);
@


1.33
log
@Having common ienab_bic() and ienab_bis() entry points for sun4/4c and sun4m
is stupid, since the bits in the interrupt enable register are completely
different between 4/4c and 4m.

Instead, provide distinct, explicit function names to handle the interrupt
enable register.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.32 2009/04/10 20:53:54 miod Exp $ */
d471 2
a472 2
#if defined(SUN4) || defined(SUN4C)
	if (CPU_ISSUN4OR4C) {
d543 1
a543 1
#if defined(SUN4) || defined(SUN4C)
d545 1
@


1.32
log
@generic soft interrupts support for sparc. Soft interrupt handlers are now
kept in a separate intrhand array, with their own enable bits so that
soft interrupts sharing the same level only get invoked if really triggered.
Inspired by NetBSD with significant changes.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.31 2007/05/29 18:10:43 miod Exp $ */
d468 1
a468 1
	 * passed to ienab_bis().
d536 2
d539 1
a539 1
		if (CPU_ISSUN4M)
d541 1
d544 4
a547 2
		if (CPU_ISSUN4OR4C)
			ienab_bis(sih->sih_hw);
d550 1
a550 1
		if (CPU_ISKAP)
d552 1
d554 1
@


1.31
log
@Use atomic operations to operate on netisr, instead of clearing it at splhigh.
This changes nothing on legacy architectures, but is a bit faster (and simpler)
on the interesting ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.30 2007/05/29 09:53:57 sobrado Exp $ */
d48 1
d79 6
a85 1
int	soft01intr(void *);
a111 40
union sir sir;
int netisr;

/*
 * Level 1 software interrupt (could also be SBus level 1 interrupt).
 * Three possible reasons:
 *	ROM console input needed
 *	Network software interrupt
 *	Soft clock interrupt
 */
int
soft01intr(fp)
	void *fp;
{
	if (sir.sir_any) {
		if (sir.sir_which[SIR_NET]) {
			int n;

			sir.sir_which[SIR_NET] = 0;
			while ((n = netisr) != 0) {
				atomic_clearbits_int(&netisr, n);

#define DONETISR(bit, fn)						\
				do {					\
					if (n & (1 << bit))		\
						fn();			\
				} while (0)

#include <net/netisr_dispatch.h>

#undef DONETISR
			}
		}
		if (sir.sir_which[SIR_CLOCK]) {
			sir.sir_which[SIR_CLOCK] = 0;
			softclock();
		}
	}
	return (1);
}
a175 2
static struct intrhand level01 = { soft01intr, NULL, (IPL_SOFTINT << 8) };

a178 3
	level01.ih_vec = level01.ih_ipl >> 8;
	evcount_attach(&level01.ih_count, "softintr", &level01.ih_vec,
	    &evcount_intr);
d185 2
d196 1
a196 1
	&level01,		/*  1 = software level 1 + SBus */
d212 38
a269 1
	struct intrhand **p, *q;
d312 2
a313 2
			panic("intr_establish: level %d interrupt tied to fast vector",
			    level);
d334 1
a334 8
	/*
	 * This is O(N^2) for long chains, but chains are never long
	 * and we do want to preserve order.
	 */
	for (p = &intrhand[level]; (q = *p) != NULL; p = &q->ih_next)
		continue;
	*p = ih;
	ih->ih_next = NULL;
d365 3
a367 2
	 * If this interrupt is already being handled, fail; the caller will
	 * either panic or try to register a slow (shareable) trap.
d369 2
a370 1
	if ((fastvec & (1 << level)) != 0 || intrhand[level] != NULL) {
d446 129
a590 1

@


1.30
log
@use the right capitalization for `SBus'

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.29 2007/05/01 15:21:43 deraadt Exp $ */
d56 1
d122 1
a122 1
			int n, s;
a123 4
			s = splhigh();
			n = netisr;
			netisr = 0;
			splx(s);
d125 9
a133 5
#define DONETISR(bit, fn) \
	do { \
		if (n & (1 << bit)) \
			fn(); \
	} while (0)
d135 1
d137 1
@


1.29
log
@expose two things needed for non-DIAGNOSTIC kernels
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.28 2005/08/14 10:58:36 miod Exp $ */
d109 1
a109 1
 * Level 1 software interrupt (could also be Sbus level 1 interrupt).
d230 3
a232 3
	&level01,		/*  1 = software level 1 + Sbus */
	NULL,	 		/*  2 = Sbus level 2 (4m: Sbus L1) */
	NULL,			/*  3 = SCSI + DMA + Sbus level 3 (4m: L2,lpt)*/
d234 1
a234 1
	NULL,			/*  5 = Ethernet + Sbus level 4 (4m: Sbus L3) */
d236 3
a238 3
	NULL,			/*  7 = video + Sbus level 5 */
	NULL,			/*  8 = Sbus level 6 */
	NULL,			/*  9 = Sbus level 7 */
@


1.28
log
@Add more flexibility to the fast trap handlers mechanism:
- add the ability to deregister a fast trap handler.
- when registering a fast trap, provide an optional callback which will be
  invoked if we try to register a regular trap handler later; the callback
  will be responsible to replace the fast trap handler with a regular trap
  handler (and is allowed to fail).

Alter audioamd(4) to take advantage of this, so that it can share its
interrupt with stp(4) on SPARCclassic machines.

Problem found the hard way and fix tested by Jason George; discussed and
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.27 2004/09/29 07:35:14 miod Exp $ */
a251 1
#ifdef DIAGNOSTIC
a253 1
#endif
@


1.27
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.26 2003/11/06 21:09:35 mickey Exp $ */
d247 5
d259 1
a259 1
 * This is not possible if it has been taken away as a fast vector.
d302 13
a314 3
	if (fastvec & (1 << level))
		panic("intr_establish: level %d interrupt tied to fast vector",
		    level);
d347 4
d352 2
a353 4
void
intr_fasttrap(level, vec)
	int level;
	void (*vec)(void);
d369 10
a378 3
	if ((fastvec & (1 << level)) != 0 || intrhand[level] != NULL)
		panic("intr_fasttrap: already handling level %d interrupts",
		    level);
d398 3
d406 41
@


1.26
log
@move netisr definition into md code to allow arch provide suitable allocation; tested on most archs
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.25 2003/06/23 19:19:33 miod Exp $ */
d209 14
d257 1
a257 1
intr_establish(level, ih, ipl_block)
d261 1
d291 1
d293 2
@


1.25
log
@Properly account for fast interrupt vectors; this was accidentally broken
since r1.10
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.24 2003/06/02 23:27:55 millert Exp $ */
d106 2
@


1.24
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.23 2002/12/10 23:43:48 miod Exp $ */
d358 1
@


1.23
log
@No need to hardclock IPL_STATCLOCK value anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.22 2002/08/12 10:44:04 miod Exp $ */
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.22
log
@Convert sparc console code from rcons and pseudo-devices to rasops and wscons.
For most framebuffers it is faster.

Other changes include:
o 24 bit support in tcx(4) for the S24 framebuffer
o accelerated cgsix(4) text console
o new cgtwelve(4) driver for the GS framebuffer
o improved serial driver code
o better keyboard support

The following framebuffers have not been tested but should work: cgfour,
cgeight and cgfourteen

These changes will require XF4 changes, to use Xwsfb instead of Xsun*, to be
commited later today.

Most of the work by me during the LSM and the week after, with code borrowed
from jason@@, NetBSD (new serial code), and feedback from mickey@@. Work on
pnozz(4) done by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.21 2002/05/22 01:01:19 art Exp $ */
d108 1
a108 1
static struct intrhand level14 = { statintr, NULL, (14 << 8) /* XXX - IPL_STATCLOCK */ };
@


1.21
log
@splassert_check should be ifdef DIAGNOSTIC
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.20 2002/05/15 23:17:54 art Exp $ */
a120 4
	extern int rom_console_input;

	if (rom_console_input && cnrom())
		cnrint();
@


1.20
log
@Implement splassert() for sparc - a tool for finding problems related to
spl handling (already found 3 problems).

Man page in a few seconds.
deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.19 2002/04/30 01:12:28 art Exp $ */
d369 1
d384 2
@


1.19
log
@Fix an ancient problem in how sparc interrupts are handled.

There are many interrupt handlers that assume that they don't need to do
any spl protection in their code because the interrupt of some level can't
be interrupted by an interrupt of the same level. The problem is that some
interrupt handlers have hardware levels that are lower then their "software"
levels.

Fix this by adding an additional field to struct intrhand that specifies which
"software" level an interrupt handler has and blocks that level while handling
the interrupt. This new field is initialized in intr_establish which gets
an additional argument (which can be -1 meaning that the interrupt handler
doesn't need to block any additional level).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.18 2002/03/14 01:26:44 millert Exp $ */
d367 15
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.17 2001/11/06 19:53:16 miod Exp $ */
d107 2
a108 2
static struct intrhand level10 = { clockintr };
static struct intrhand level14 = { statintr };
d213 1
a213 1
static struct intrhand level01 = { soft01intr };
d249 1
a249 1
intr_establish(level, ih)
d252 1
d260 23
@


1.17
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.16 2001/07/04 08:43:29 niklas Exp $ */
d81 2
a82 2
void	strayintr __P((struct clockframe *));
int	soft01intr __P((void *));
d151 1
a151 1
void	nmi_hard __P((void));
d300 1
a300 1
	void (*vec) __P((void));
@


1.17.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.17 2001/11/06 19:53:16 miod Exp $ */
d81 2
a82 2
void	strayintr(struct clockframe *);
int	soft01intr(void *);
d107 2
a108 2
static struct intrhand level10 = { clockintr, NULL, (IPL_CLOCK << 8) };
static struct intrhand level14 = { statintr, NULL, (14 << 8) /* XXX - IPL_STATCLOCK */ };
d151 1
a151 1
void	nmi_hard(void);
d213 1
a213 1
static struct intrhand level01 = { soft01intr, NULL, (IPL_SOFTINT << 8) };
d249 1
a249 1
intr_establish(level, ih, ipl_block)
a251 1
	int ipl_block;
a259 23
	if (ipl_block == -1)
		ipl_block = level;

#ifdef DIAGNOSTIC
	/*
	 * If the level we're supposed to block is lower than this interrupts
	 * level someone is doing something very wrong. Most likely it
	 * means that some IPL_ constant in machine/psl.h is preconfigured too
	 * low.
	 */
	if (ipl_block < level)
		panic("intr_establish: level (%d) > block (%d)", level,
		    ipl_block);
	if (ipl_block > 15)
		panic("intr_establish: strange block level: %d", ipl_block);
#endif

	/*
	 * We store the ipl pre-shifted so that we can avoid one instruction
	 * in the interrupt handlers.
	 */
	ih->ih_ipl = (ipl_block << 8);

d300 1
a300 1
	void (*vec)(void);
a343 18

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	int oldipl = (getpsr() & PSR_PIL) >> 8;

	if (oldipl < wantipl) {
		splassert_fail(wantipl, oldipl, func);
		/*
		 * If the splassert_ctl is set to not panic, raise the ipl
		 * in a feeble attempt to reduce damage.
		 */
		setpsr((getpsr() & ~PSR_PIL) | wantipl << 8);
	}
}
#endif

@


1.17.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.17.2.1 2002/06/11 03:38:16 art Exp $ */
d121 4
@


1.17.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d108 1
a108 1
static struct intrhand level14 = { statintr, NULL, (IPL_STATCLOCK << 8) };
@


1.16
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.20 1997/07/29 09:42:03 fair Exp $ */
d53 1
a53 1
#include <vm/vm.h>
@


1.15
log
@Use netisr_dispatch.
@
text
@d1 1
@


1.14
log
@Add a missing splx in intr_fasttrap.
@
text
@a79 3
#include "ppp.h"
#include "bridge.h"

a124 5
		/*
		 * XXX	this is bogus: should just have a list of
		 *	routines to call, a la timeouts.  Mods to
		 *	netisr are not atomic and must be protected (gah).
		 */
d133 7
a139 34
#ifdef INET
			if (n & (1 << NETISR_ARP))
				arpintr();
			if (n & (1 << NETISR_IP))
				ipintr();
#endif
#ifdef INET6
			if (n & (1 << NETISR_IPV6))
				ip6intr();
#endif
#ifdef NETATALK
			if (n & (1 << NETISR_ATALK))
				atintr();
#endif
#ifdef NS
			if (n & (1 << NETISR_NS))
				nsintr();
#endif
#ifdef ISO
			if (n & (1 << NETISR_ISO))
				clnlintr();
#endif
#ifdef NATM
			if (n & (1 << NETISR_NATM))
				natmintr();
#endif
#if NPPP > 0
			if (n & (1 << NETISR_PPP))
				pppintr();
#endif
#if NBRIDGE > 0
			if (n & (1 << NETISR_BRIDGE))
				bridgeintr();
#endif
@


1.13
log
@The last pieces of hypersparc support.
 - Split get_faultstatus into get_syncflt and get_asyncflt.
 - Get the syncflt status before setting up the trap frame and put the
   results in cpuinfo.syncfltdump (related to the next change).
 - unlock the sfsr/sfva after reading from ASI_SRMMUFP (it gets locked if
   the translation fails).
 - + other interface changes and cleanups.
 (most work from NetBSD).
@
text
@d376 1
@


1.12
log
@don't include netinet6/ip6.h
@
text
@d64 2
d183 63
@


1.12.2.1
log
@sync with -current
@
text
@a63 2
#include <sparc/sparc/cpuvar.h>

a180 63

#if defined(SUN4M)
void	nmi_hard __P((void));
void
nmi_hard()
{
	/*
         * A level 15 hard interrupt.
         */
#ifdef noyet
	int fatal = 0;
#endif
	u_int32_t si;
	u_int afsr, afva;

	afsr = afva = 0;
	if ((*cpuinfo.get_asyncflt)(&afsr, &afva) == 0) {
		printf("Async registers (mid %d): afsr=%b; afva=0x%x%x\n",
		       cpuinfo.mid, afsr, AFSR_BITS,
		       (afsr & AFSR_AFA) >> AFSR_AFA_RSHIFT, afva);
	}

	if (cpuinfo.master == 0) {
		/*
		 * For now, just return.
		 * Should wait on damage analysis done by the master.
		 */
		return;
	}

	/*
	 * Examine pending system interrupts.
	 */
	si = *((u_int32_t *)ICR_SI_PEND);
	printf("NMI: system interrupts: %b\n", si, SINTR_BITS);

#ifdef notyet
	if ((si & SINTR_M) != 0) {
		/* ECC memory error */
                if (memerr_handler != NULL)
                        fatal |= (*memerr_handler)();
        }
        if ((si & SINTR_I) != 0) {
                /* MBus/SBus async error */
                if (sbuserr_handler != NULL)
                        fatal |= (*sbuserr_handler)();
        }
        if ((si & SINTR_V) != 0) {
                /* VME async error */
                if (vmeerr_handler != NULL)
                        fatal |= (*vmeerr_handler)();
        }
        if ((si & SINTR_ME) != 0) {
                /* Module async error */
                if (moduleerr_handler != NULL)
                        fatal |= (*moduleerr_handler)();
        }

        if (fatal)
#endif
                panic("nmi");
}
#endif
@


1.12.2.2
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d80 3
d128 5
d141 34
a174 7
#define DONETISR(bit, fn) \
	do { \
		if (n & (1 << bit)) \
			fn(); \
	} while (0)
#include <net/netisr_dispatch.h>
#undef DONETISR
a375 1
	splx(s);
@


1.12.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@a0 1
/*	$OpenBSD$ */
@


1.12.2.4
log
@Merge in -current
@
text
@d53 1
a53 1
#include <uvm/uvm_extern.h>
@


1.12.2.5
log
@Merge in -current from about a week ago
@
text
@d81 2
a82 2
void	strayintr(struct clockframe *);
int	soft01intr(void *);
d151 1
a151 1
void	nmi_hard(void);
d300 1
a300 1
	void (*vec)(void);
@


1.12.2.6
log
@Sync the SMP branch with 3.3
@
text
@d107 2
a108 2
static struct intrhand level10 = { clockintr, NULL, (IPL_CLOCK << 8) };
static struct intrhand level14 = { statintr, NULL, (IPL_STATCLOCK << 8) };
d121 4
d213 1
a213 1
static struct intrhand level01 = { soft01intr, NULL, (IPL_SOFTINT << 8) };
d249 1
a249 1
intr_establish(level, ih, ipl_block)
a251 1
	int ipl_block;
a259 23
	if (ipl_block == -1)
		ipl_block = level;

#ifdef DIAGNOSTIC
	/*
	 * If the level we're supposed to block is lower than this interrupts
	 * level someone is doing something very wrong. Most likely it
	 * means that some IPL_ constant in machine/psl.h is preconfigured too
	 * low.
	 */
	if (ipl_block < level)
		panic("intr_establish: level (%d) > block (%d)", level,
		    ipl_block);
	if (ipl_block > 15)
		panic("intr_establish: strange block level: %d", ipl_block);
#endif

	/*
	 * We store the ipl pre-shifted so that we can avoid one instruction
	 * in the interrupt handlers.
	 */
	ih->ih_ipl = (ipl_block << 8);

a343 18

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	int oldipl = (getpsr() & PSR_PIL) >> 8;

	if (oldipl < wantipl) {
		splassert_fail(wantipl, oldipl, func);
		/*
		 * If the splassert_ctl is set to not panic, raise the ipl
		 * in a feeble attempt to reduce damage.
		 */
		setpsr((getpsr() & ~PSR_PIL) | wantipl << 8);
	}
}
#endif

@


1.12.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.12.2.6 2003/03/27 23:49:26 niklas Exp $ */
d25 5
a29 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.12.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a105 2
int netisr;

a357 1
	fastvec |= 1 << level;
@


1.11
log
@reduce global symbol pollution
@
text
@d74 1
a74 1
#include <netinet6/ip6.h>
@


1.10
log
@Use pmap_writetext instead of manually fiddling with pmap_changeprot when
filling in the fastint vectors.
@
text
@d109 1
a109 1

@


1.9
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d276 4
a279 1
	int s;
d302 9
a310 9
	/* kernel text is write protected -- let us in for a moment */
	pmap_changeprot(pmap_kernel(), (vaddr_t)tv,
	    VM_PROT_READ|VM_PROT_WRITE, 1);
	tv->tv_instr[0] = I_SETHI(I_L3, hi22);	/* sethi %hi(vec),%l3 */
	tv->tv_instr[1] = I_JMPLri(I_G0, I_L3, lo10);/* jmpl %l3+%lo(vec),%g0 */
	tv->tv_instr[2] = I_RDPSR(I_L0);	/* mov %psr, %l0 */
	pmap_changeprot(pmap_kernel(), (vaddr_t)tv, VM_PROT_READ, 1);
	fastvec |= 1 << level;
	splx(s);
@


1.8
log
@vm_offset_t -> {v,p}addr_t and vm_size_t -> {v,p}size_t
remove "register" keywords
Various cleanups.
@
text
@d69 9
d147 1
a147 1
				ipv6intr();
@


1.7
log
@Only do basic work in the ethernet interrupt context, and queue packets to
be bridged.  Do the real work in a scheduled netisr.
@
text
@d213 1
a213 1
	register struct intrhand **p, *q;
d215 2
a216 2
	register struct trapvec *tv;
	register int displ;
d262 2
a263 2
	register struct trapvec *tv;
	register u_long hi22, lo10;
d265 1
a265 1
	register int displ;	/* suspenders, belt, and buttons too */
d291 1
a291 1
	pmap_changeprot(pmap_kernel(), (vm_offset_t)tv,
d296 1
a296 1
	pmap_changeprot(pmap_kernel(), (vm_offset_t)tv, VM_PROT_READ, 1);
@


1.6
log
@global decl for *intr() routines, plus add INET6
@
text
@d70 1
d159 4
@


1.5
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@a68 10
#ifdef NS
#include <netns/ns_var.h>
#endif
#ifdef ISO
#include <netiso/iso.h>
#include <netiso/clnp.h>
#endif
#ifdef NETATALK
#include <netatalk/at_extern.h>
#endif
a69 4
#if NPPP > 0
#include <net/ppp_defs.h>
#include <net/if_ppp.h>
#endif
d134 4
@


1.4
log
@Must include netatalk/at_extern to get atintr() prototype.
@
text
@d1 1
a1 1
/*	$NetBSD: intr.c,v 1.13 1996/03/31 23:35:20 pk Exp $ */
a46 2
#include "ppp.h"

a68 3
#ifdef NETATALK
#include <netatalk/at_extern.h>
#endif
d76 3
d99 1
a99 1
	printf("stray interrupt ipl %x pc=%x npc=%x psr=%b\n",
d161 4
d241 1
a241 1
			panic("intr_establish(%d, %p)\n%x %x %x != %x %x %x",
d290 1
a290 1
		panic("intr_fasttrap(%d, %p)\n%x %x %x != %x %x %x",
@


1.3
log
@Add AppleTalk netisr. Only tested (indeed, only compiled) on mac68k port.
Add options NETATALK to your config to try it out.
@
text
@d71 3
@


1.2
log
@netbsd port, now we merge our changes back in
@
text
@d148 4
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: intr.c,v 1.9 1995/07/04 12:34:37 paulus Exp $ */
d47 2
d50 1
d52 1
d56 2
d59 1
d66 20
d99 1
a99 1
	    fp->ipl, fp->pc, fp->npc, fp->psr, PSR_BITS);
a109 1
extern int clockintr();		/* level 10 (clock) interrupt code */
a110 2

extern int statintr();		/* level 14 (statclock) interrupt code */
a155 1
#include "ppp.h"
d163 1
a163 1
			softclock(fp);
d179 5
a183 5
	NULL,	 		/*  2 = Sbus level 2 */
	NULL,			/*  3 = SCSI + DMA + Sbus level 3 */
	NULL,			/*  4 = software level 4 (tty softint) */
	NULL,			/*  5 = Ethernet + Sbus level 4 */
	NULL,			/*  6 = software level 6 (not used) */
d196 2
a197 1
extern int sparc_interrupt[];
d222 1
a222 1
	if (level != 1 && level != 4 && level != 6) {
d224 4
a227 1
		displ = &sparc_interrupt[0] - &tv->tv_instr[1];
d232 1
a232 1
			panic("intr_establish(%d, %x)\n%x %x %x != %x %x %x",
d273 4
a276 1
	displ = &sparc_interrupt[0] - &tv->tv_instr[1];
d281 1
a281 1
		panic("intr_fasttrap(%d, %x)\n%x %x %x != %x %x %x",
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
