head	1.34;
access;
symbols
	OPENBSD_6_0:1.34.0.4
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.32.0.6
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.28.0.6
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.27.0.2
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.26.0.10
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.8
	OPENBSD_5_0:1.26.0.6
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.4
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.24.0.12
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.14
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.10
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.8
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.6
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.4
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.19.0.8
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.6
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.18.0.8
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.6
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.18.0.4
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.18
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.10
	OPENBSD_2_8:1.13.0.8
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.6
	OPENBSD_2_7_BASE:1.13
	SMP:1.13.0.4
	SMP_BASE:1.13
	kame_19991208:1.13
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.10.0.6
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.4
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.4
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2016.01.19.17.57.07;	author ajacoutot;	state Exp;
branches;
next	1.33;
commitid	TupmvdCYHECKXcM9;

1.33
date	2015.09.19.21.07.04;	author semarie;	state Exp;
branches;
next	1.32;
commitid	9KMPSlP02LD1SpJP;

1.32
date	2015.02.10.22.49.16;	author miod;	state Exp;
branches;
next	1.31;
commitid	xB9QjuqqfWdYVpHn;

1.31
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.30;
commitid	C5iGb36LQxjM60Q3;

1.30
date	2014.11.16.12.30.58;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	yv0ECmCdICvq576h;

1.29
date	2014.07.12.18.44.43;	author tedu;	state Exp;
branches;
next	1.28;
commitid	uKVPYMN2MLxdZxzH;

1.28
date	2013.07.05.20.30.56;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2012.11.05.13.20.16;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2010.07.10.19.32.24;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2010.07.06.20.40.01;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2006.12.10.16.12.41;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2006.06.26.20.21.02;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2006.06.23.19.54.30;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2006.06.19.15.13.35;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2006.04.16.22.24.44;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.04.08.01.11.21;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.12.10.44.04;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.03.16.00;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.05.16.12.49.48;	author ho;	state Exp;
branches;
next	1.13;

1.13
date	99.09.29.13.54.03;	author art;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	99.07.09.21.40.20;	author art;	state Exp;
branches;
next	1.11;

1.11
date	99.07.09.21.30.01;	author art;	state Exp;
branches;
next	1.10;

1.10
date	98.03.04.19.19.28;	author johns;	state Exp;
branches;
next	1.9;

1.9
date	97.11.11.10.03.03;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.08.08.08.27.05;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	96.08.11.05.35.05;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.02.03.19.35.58;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.01.31.04.54.44;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.12.15.13.56.46;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.10.19.11.23.57;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.18.18.18.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.46;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.46;	author deraadt;	state Exp;
branches;
next	;

1.13.4.1
date	2001.07.04.10.23.37;	author niklas;	state Exp;
branches;
next	1.13.4.2;

1.13.4.2
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.13.4.3;

1.13.4.3
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.13.4.4;

1.13.4.4
date	2003.03.27.23.49.26;	author niklas;	state Exp;
branches;
next	1.13.4.5;

1.13.4.5
date	2004.06.05.23.10.58;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.10.29.00.28.10;	author art;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Fix a race causing hardclock() to be sometimes invoked between the end
of cpu_configure() and initclocks().

from Miod
no objection deraadt@@
@
text
@/*	$OpenBSD: clock.c,v 1.33 2015/09/19 21:07:04 semarie Exp $	*/
/*	$NetBSD: clock.c,v 1.52 1997/05/24 20:16:05 pk Exp $ */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1994 Gordon W. Ross
 * Copyright (c) 1993 Adam Glass
 * Copyright (c) 1996 Paul Kranenburg
 * Copyright (c) 1996
 * 	The President and Fellows of Harvard College. All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by Harvard University.
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 *	This product includes software developed by Paul Kranenburg.
 *	This product includes software developed by Harvard University.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)clock.c	8.1 (Berkeley) 6/11/93
 *
 */

/*
 * Clock driver.  This is the id prom and eeprom driver as well
 * and includes the timer register functions too.
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/proc.h>
#include <sys/resourcevar.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#include <sys/timetc.h>
#ifdef GPROF
#include <sys/gmon.h>
#endif

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/eeprom.h>
#include <machine/cpu.h>

#include <sparc/sparc/vaddrs.h>
#include <sparc/sparc/cpuvar.h>
#include <sparc/sparc/clockreg.h>
#include <sparc/sparc/intreg.h>
#include <sparc/sparc/timerreg.h>

/*
 * Statistics clock interval and variance, in usec.  Variance must be a
 * power of two.  Since this gives us an even number, not an odd number,
 * we discard one case and compensate.  That is, a variance of 1024 would
 * give us offsets in [0..1023].  Instead, we take offsets in [1..1023].
 * This is symmetric about the point 512, or statvar/2, and thus averages
 * to that value (assuming uniform random numbers).
 */
/* XXX fix comment to match value */
int statvar = 8192;
int statmin;			/* statclock interval - 1/2*variance */
int timerok;

#include <dev/ic/intersil7170.h>

extern struct idprom idprom;

#define intersil_command(run, interrupt) \
    (run | interrupt | INTERSIL_CMD_FREQ_32K | INTERSIL_CMD_24HR_MODE | \
     INTERSIL_CMD_NORMAL_MODE)

#define intersil_disable(CLOCK) \
    CLOCK->clk_cmd_reg = \
    intersil_command(INTERSIL_CMD_RUN, INTERSIL_CMD_IDISABLE)

#define intersil_enable(CLOCK) \
    CLOCK->clk_cmd_reg = \
    intersil_command(INTERSIL_CMD_RUN, INTERSIL_CMD_IENABLE)

#define intersil_clear(CLOCK) CLOCK->clk_intr_reg

#if defined(SUN4)
/*
 * OCLOCK support: 4/100's and 4/200's have the old clock.
 */
static int oldclk = 0;
struct intersil7170 *i7;

long	oclk_get_secs(void);
void	oclk_get_dt(struct intersil_dt *);
void	oclk_set_dt(struct intersil_dt *);
void	oclk_set_secs(long);

int	oclockmatch(struct device *, void *, void *);
void	oclockattach(struct device *, struct device *, void *);

struct cfattach oclock_ca = {
	sizeof(struct device), oclockmatch, oclockattach
};

struct cfdriver oclock_cd = {
	NULL, "oclock", DV_DULL
};

u_int	oclock_get_timecount(struct timecounter *);
struct timecounter oclock_timecounter = {
	.tc_get_timecount = oclock_get_timecount,
	.tc_counter_mask = 0xffffffff,
	.tc_name = "oclock",
	.tc_quality = 0
};
#endif

/*
 * Sun 4 machines use the old-style (a'la Sun 3) EEPROM.  On the
 * 4/100's and 4/200's, this is at a separate obio space.  On the
 * 4/300's and 4/400's, however, it is the cl_nvram[] chunk of the
 * Mostek chip.  Therefore, eeprom_match will only return true on
 * the 100/200 models, and the eeprom will be attached separately.
 * On the 300/400 models, the eeprom will be dealt with when the clock is
 * attached.
 */
char		*eeprom_va = NULL;
#if defined(SUN4)
static int	eeprom_busy = 0;
static int	eeprom_wanted = 0;
static int	eeprom_nvram = 0;	/* non-zero if eeprom is on Mostek */
int	eeprom_take(void);
void	eeprom_give(void);
int	eeprom_update(char *, size_t, size_t);
#endif

int	eeprom_match(struct device *, void *, void *);
void	eeprom_attach(struct device *, struct device *, void *);

struct cfattach eeprom_ca = {
	sizeof(struct device), eeprom_match, eeprom_attach
};

struct	cfdriver eeprom_cd = {
	NULL, "eeprom", DV_DULL
};

int	clockmatch(struct device *, void *, void *);
void	clockattach(struct device *, struct device *, void *);

struct cfattach clock_ca = {
	sizeof(struct device), clockmatch, clockattach
};

struct cfdriver clock_cd = {
	NULL, "clock", DV_DULL
};

int	timermatch(struct device *, void *, void *);
void	timerattach(struct device *, struct device *, void *);

struct timer_4m	*timerreg_4m;	/* XXX - need more cleanup */
struct counter_4m	*counterreg_4m;
#define	timerreg4		((struct timerreg_4 *)TIMERREG_VA)

struct cfattach timer_ca = {
	sizeof(struct device), timermatch, timerattach
};

struct cfdriver timer_cd = {
	NULL, "timer", DV_DULL
};

/*
 * timecounter local state
 */
static struct counter {
	volatile u_int *cntreg;	/* counter register */
	u_int limit;		/* limit we count up to */
	u_int offset;		/* accumulated offset due to wraps */
	u_int shift;		/* scaling for valid bits */
} cntr;

u_int	timer_get_timecount(struct timecounter *);
struct timecounter timer_timecounter = {
	.tc_get_timecount = timer_get_timecount,
	.tc_counter_mask = 0xffffffff,
	.tc_name = "counter-timer",
	.tc_quality = 100,
	.tc_priv = &cntr
};

void clk_wenable(int);
void myetheraddr(u_char *);

int timerblurb = 10; /* Guess a value; used before clock is attached */

static struct intrhand level10 = { .ih_fun = clockintr, .ih_arg = NULL };
static struct intrhand level14 = { .ih_fun = statintr, .ih_arg = NULL };

#if defined(SUN4)
/*
 * old clock match routine
 */
int
oclockmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct confargs *ca = aux;

	/* Only these sun4s have oclock */
	if (!CPU_ISSUN4 ||
	    (cpuinfo.cpu_type != CPUTYP_4_100 &&
	     cpuinfo.cpu_type != CPUTYP_4_200))
		return (0);

	/* Check configuration name */
	if (strcmp(oclock_cd.cd_name, ca->ca_ra.ra_name) != 0)
		return (0);

	/* Make sure there is something there */
	if (probeget(ca->ca_ra.ra_vaddr, 1) == -1)
		return (0);

	return (1);
}

/* ARGSUSED */
void
oclockattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;
	struct idprom *idp;
	int h;

	oldclk = 1;  /* we've got an oldie! */

	i7 = (struct intersil7170 *) mapiodev(ra->ra_reg, 0, sizeof(*i7));

	idp = &idprom;
	h = idp->id_machine << 24;
	h |= idp->id_hostid[0] << 16;
	h |= idp->id_hostid[1] << 8;
	h |= idp->id_hostid[2];
	hostid = h;

	/* 
	 * calibrate delay() 
	 */
	intreg_clr_44c(IE_L14 | IE_L10);	/* disable all clock intrs */
	for (timerblurb = 1; ; timerblurb++) {
		volatile register char *ireg = &i7->clk_intr_reg;
		int ival;
		*ireg = INTERSIL_INTER_CSECONDS; /* 1/100 sec */
		intersil_enable(i7);		 /* enable clock */
		while ((*ireg & INTERSIL_INTER_PENDING) == 0)
			/* sync with interrupt */;
		while ((*ireg & INTERSIL_INTER_PENDING) == 0)
			/* XXX: do it again, seems to need it */;
		delay(10000);			/* Probe 1/100 sec delay */
		ival = *ireg;			/* clear, save value */
		intersil_disable(i7);		/* disable clock */
		if (ival & INTERSIL_INTER_PENDING) {
			printf(": delay constant %d%s\n", timerblurb,
				(timerblurb == 1) ? " [TOO SMALL?]" : "");
			break;
		}
		if (timerblurb > 10) {
			printf("\noclock: calibration failing; clamped at %d\n",
			       timerblurb);
			break;
		}
	}

	oclock_timecounter.tc_frequency = hz;
	tc_init(&oclock_timecounter);

	intr_establish(10, &level10, IPL_CLOCK, "clock");
	intr_establish(14, &level14, IPL_STATCLOCK, "prof");
}

u_int
oclock_get_timecount(struct timecounter *tc)
{
	return level10.ih_count.ec_count;
}
#endif /* SUN4 */

/*
 * Sun 4/100, 4/200 EEPROM match routine.
 */
int
eeprom_match(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;

	if (!CPU_ISSUN4)
		return (0);

	if (cf->cf_unit != 0)
		return (0);

	if (cpuinfo.cpu_type != CPUTYP_4_100 &&
	    cpuinfo.cpu_type != CPUTYP_4_200)
		return (0);

	if (strcmp(eeprom_cd.cd_name, ca->ca_ra.ra_name) != 0)
		return (0);

	/*
	 * Make sure there's something there...
	 * This is especially important if we want to
	 * use the same kernel on a 4/100 as a 4/200.
	 */
	if (probeget(ca->ca_ra.ra_vaddr, 1) == -1)
		return (0);

	/* Passed all tests */
	return (1);
}

void
eeprom_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
#if defined(SUN4)
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;

	printf("\n");

	eeprom_va = (char *)mapiodev(ra->ra_reg, 0, EEPROM_SIZE);

	eeprom_nvram = 0;
#endif /* SUN4 */
}

/*
 * The OPENPROM calls the clock the "eeprom", so we have to have our
 * own special match function to call it the "clock".
 */
int
clockmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct confargs *ca = aux;

	if (CPU_ISSUN4) {
		/* Only these sun4s have "clock" (others have "oclock") */
		if (cpuinfo.cpu_type != CPUTYP_4_300 &&
		    cpuinfo.cpu_type != CPUTYP_4_400)
			return (0);

		if (strcmp(clock_cd.cd_name, ca->ca_ra.ra_name) != 0)
			return (0);

		/* Make sure there is something there */
		if (probeget(ca->ca_ra.ra_vaddr, 1) == -1)
			return (0);

		return (1);
	}

	return (strcmp("eeprom", ca->ca_ra.ra_name) == 0);
}

/* ARGSUSED */
void
clockattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	int h;
	struct clockreg *cl;
	struct idprom *idp;
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;
	char *prop = NULL;

	if (CPU_ISSUN4)
		prop = "mk48t02";
	else if (!CPU_ISSUN4)
		prop = getpropstring(ra->ra_node, "model");

	printf(": %s (eeprom)\n", prop);

	/*
	 * We ignore any existing virtual address as we need to map
	 * this read-only and make it read-write only temporarily,
	 * whenever we read or write the clock chip.  The clock also
	 * contains the ID ``PROM'', and I have already had the pleasure
	 * of reloading the cpu type, Ethernet address, etc, by hand from
	 * the console FORTH interpreter.  I intend not to enjoy it again.
	 */
	if (strcmp(prop, "mk48t08") == 0) {
		/*
		 * the MK48T08 is 8K
		 */
		cl = (struct clockreg *)mapiodev(ra->ra_reg, 0, 8192);
		pmap_changeprot(pmap_kernel(), (vaddr_t)cl, PROT_READ, 1);
		pmap_changeprot(pmap_kernel(), (vaddr_t)cl + 4096,
				PROT_READ, 1);
		cl = (struct clockreg *)((int)cl + CLK_MK48T08_OFF);
	} else {
		/*
		 * the MK48T02 is 2K
		 */
		cl = (struct clockreg *)mapiodev(ra->ra_reg, 0,
						 sizeof *clockreg);
		pmap_changeprot(pmap_kernel(), (vaddr_t)cl, PROT_READ, 1);
	}
	idp = &cl->cl_idprom;

#if defined(SUN4)
	if (CPU_ISSUN4) {
		idp = &idprom;

		if (cpuinfo.cpu_type == CPUTYP_4_300 ||
		    cpuinfo.cpu_type == CPUTYP_4_400) {
			eeprom_va = (char *)cl->cl_nvram;
			eeprom_nvram = 1;
		}
	}
#endif

	h = idp->id_machine << 24;
	h |= idp->id_hostid[0] << 16;
	h |= idp->id_hostid[1] << 8;
	h |= idp->id_hostid[2];
	hostid = h;
	clockreg = cl;
}

/*
 * The OPENPROM calls the timer the "counter-timer".
 */
int
timermatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct confargs *ca = aux;

	if (CPU_ISSUN4) {
		if (cpuinfo.cpu_type != CPUTYP_4_300 &&
		    cpuinfo.cpu_type != CPUTYP_4_400)
			return (0);

		if (strcmp("timer", ca->ca_ra.ra_name) != 0)
			return (0);

		/* Make sure there is something there */
		if (probeget(ca->ca_ra.ra_vaddr, 4) == -1)
			return (0);

		return (1);
	}

	if (CPU_ISSUN4C || CPU_ISSUN4E) {
		return (strcmp("counter-timer", ca->ca_ra.ra_name) == 0);
	}

	if (CPU_ISSUN4M) {
		return (strcmp("counter", ca->ca_ra.ra_name) == 0);
	}

	return (0);
}

/* ARGSUSED */
void
timerattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct confargs *ca = aux;
	struct romaux *ra = &ca->ca_ra;
	volatile int *cnt = NULL, *lim = NULL;
		/* XXX: must init to NULL to avoid stupid gcc -Wall warning */
	u_int prec = 0, t0;

	if (CPU_ISSUN4M) {
		(void)mapdev(&ra->ra_reg[ra->ra_nreg-1], TIMERREG_VA, 0,
			     sizeof(struct timer_4m));
		(void)mapdev(&ra->ra_reg[0], COUNTERREG_VA, 0,
			     sizeof(struct counter_4m));
		timerreg_4m = (struct timer_4m *)TIMERREG_VA;
		counterreg_4m = (struct counter_4m *)COUNTERREG_VA;

		/* Put processor counter in "timer" mode */
		timerreg_4m->t_cfg = 0;

		cnt = &timerreg_4m->t_counter;
		lim = &timerreg_4m->t_limit;
	}

	if (CPU_ISSUN4OR4COR4E) {
		/*
		 * This time, we ignore any existing virtual address because
		 * we have a fixed virtual address for the timer, to make
		 * time counter operation faster (in SUN4/SUN4C/SUN4E kernel
		 * only).
		 */
		(void)mapdev(ra->ra_reg, TIMERREG_VA, 0,
			     sizeof(struct timerreg_4));

		cnt = &timerreg4->t_c10.t_counter;
		lim = &timerreg4->t_c10.t_limit;
	}

	timerok = 1;

	/*
	 * Calibrate delay() by tweaking the magic constant
	 * until a delay(100) actually reads (at least) 100 us on the clock.
	 * Note: sun4m clocks tick with 500ns periods.
	 */

	for (timerblurb = 1; ; timerblurb++) {
		volatile int discard;
		u_int t1;

		/* Reset counter register by writing some large limit value */
		discard = *lim;
		*lim = tmr_ustolim(TMR_MASK-1);

		t0 = *cnt;
		delay(100);
		t1 = *cnt;

		prec |= (t0 ^ t1) | (*cnt ^ *cnt);

		if (t1 & TMR_LIMIT)
			panic("delay calibration");

		t0 = (t0 >> TMR_SHIFT) & TMR_MASK;
		t1 = (t1 >> TMR_SHIFT) & TMR_MASK;

		if (t1 >= t0 + 100)
			break;

	}

	/* find lowest active bit */
	for (t0 = 0; t0 < TMR_SHIFT; t0++)
		if ((1 << t0) & prec)
			break;

	cntr.shift = t0;
	cntr.limit = tick << (TMR_SHIFT - cntr.shift);
	cntr.cntreg = cnt;
	timer_timecounter.tc_frequency = 1000000 << (TMR_SHIFT - cntr.shift);
	tc_init(&timer_timecounter);

	printf(": delay constant %d, frequency %llu Hz\n",
	    timerblurb, (unsigned long long)timer_timecounter.tc_frequency);

	intr_establish(10, &level10, IPL_CLOCK, "clock");
	intr_establish(14, &level14, IPL_STATCLOCK, "prof");
}

u_int
timer_get_timecount(struct timecounter *tc)
{
	struct counter *ctr = (struct counter *)tc->tc_priv;
	u_int carry, cnt, res;
	int s;

	s = splhigh();
	res = cnt = *ctr->cntreg;
	res &= ~TMR_LIMIT;
	if (cnt != res)
		carry = ctr->limit;	/* a clock interrupt is pending */
	else
		carry = 0;
	res >>= ctr->shift;
	res += carry + ctr->offset;
	splx(s);

	return res;
}

/*
 * Write en/dis-able clock registers.  We coordinate so that several
 * writers can run simultaneously.
 */
void
clk_wenable(onoff)
	int onoff;
{
	int s;
	vm_prot_t prot;/* nonzero => change prot */
	static int writers;

	s = splhigh();
	if (onoff)
		prot = writers++ == 0 ? PROT_READ | PROT_WRITE : 0;
	else
		prot = --writers == 0 ? PROT_READ : 0;
	splx(s);
	if (prot)
		pmap_changeprot(pmap_kernel(), (vaddr_t)clockreg & ~(NBPG-1),
				prot, 1);
}

/*
 * XXX this belongs elsewhere
 */
void
myetheraddr(cp)
	u_char *cp;
{
	struct clockreg *cl = clockreg;
	struct idprom *idp = &cl->cl_idprom;

#if defined(SUN4)
	if (CPU_ISSUN4)
		idp = &idprom;
#endif

	cp[0] = idp->id_ether[0];
	cp[1] = idp->id_ether[1];
	cp[2] = idp->id_ether[2];
	cp[3] = idp->id_ether[3];
	cp[4] = idp->id_ether[4];
	cp[5] = idp->id_ether[5];
}

/*
 * Set up the real-time and statistics clocks.  Leave stathz 0 only if
 * no alternative timer is available.
 *
 * The frequencies of these clocks must be an even number of microseconds.
 */
void
cpu_initclocks()
{
	int statint, minint;

#if defined(SUN4)
	if (oldclk) {
		int dummy;

		if (hz != 100) {
			printf("oclock0: cannot get %d Hz clock; using 100 Hz\n", hz);
		}

		profhz = hz = 100;
		tick = 1000000 / hz;

		i7->clk_intr_reg = INTERSIL_INTER_CSECONDS; /* 1/100 sec */

		intreg_clr_44c(IE_L14 | IE_L10);/* disable all clock intrs */
		intersil_disable(i7);		/* disable clock */
		dummy = intersil_clear(i7);	/* clear interrupts */
		intreg_set_44c(IE_L10);		/* enable l10 interrupt */
		intersil_enable(i7);		/* enable clock */

		return;
	}
#endif /* SUN4 */

	if (1000000 % hz) {
		printf("clock0: cannot get %d Hz clock; using 100 Hz\n", hz);
		hz = 100;
		tick = 1000000 / hz;
	}
	if (stathz == 0)
		stathz = hz;
	if (1000000 % stathz) {
		printf("clock0: cannot get %d Hz statclock; using 100 Hz\n", stathz);
		stathz = 100;
	}
	profhz = stathz;		/* always */

	statint = 1000000 / stathz;
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;

	if (CPU_ISSUN4M) {
		timerreg_4m->t_limit = tmr_ustolim4m(tick);
		counterreg_4m->t_limit = tmr_ustolim4m(statint);
	}

	if (CPU_ISSUN4OR4COR4E) {
		timerreg4->t_c10.t_limit = tmr_ustolim(tick);
		timerreg4->t_c14.t_limit = tmr_ustolim(statint);
	}

	statmin = statint - (statvar >> 1);

#if defined(SUN4M)
	if (CPU_ISSUN4M)
		intreg_clr_4m(SINTR_T);
#endif

#if defined(SUN4) || defined(SUN4C) || defined(SUN4E)
	if (CPU_ISSUN4OR4COR4E)
		intreg_set_44c(IE_L14 | IE_L10);
#endif
}

/*
 * Dummy setstatclockrate(), since we know profhz==hz.
 */
/* ARGSUSED */
void
setstatclockrate(newhz)
	int newhz;
{
	/* nothing */
}

/*
 * Level 10 (clock) interrupts.
 */
int
clockintr(cap)
	void *cap;
{
	volatile int discard;
	int s;

	/*
	 * Protect the clearing of the clock interrupt.  If we don't
	 * do this, and we're interrupted (by the zs, for example),
	 * the clock stops!
	 * XXX WHY DOES THIS HAPPEN?
	 */
	s = splhigh();

#if defined(SUN4)
	if (oldclk) {
		discard = intersil_clear(i7);
		intreg_clr_44c(IE_L10);	/* clear interrupt */
		intreg_set_44c(IE_L10);	/* enable interrupt */
		goto forward;
	}
#endif
#if defined(SUN4M)
	/* read the limit register to clear the interrupt */
	if (CPU_ISSUN4M) {
		discard = timerreg_4m->t_limit;
	}
#endif
#if defined(SUN4) || defined(SUN4C) || defined(SUN4E)
	if (CPU_ISSUN4OR4COR4E) {
		discard = timerreg4->t_c10.t_limit;
	}
#endif
#if defined(SUN4)
forward:
#endif
	cntr.offset += cntr.limit;
	splx(s);

	/*
	 * XXX Clock interrupts are enabled (and therefore serviceable)
	 * XXX before initclocks() has completed.
	 */
	if (profhz != 0)
		hardclock((struct clockframe *)cap);

	return (1);
}

/*
 * Level 14 (stat clock) interrupt handler.
 */
int
statintr(cap)
	void *cap;
{
	volatile int discard;
	u_long newint, r, var;

#if defined(SUN4)
	if (oldclk) {
		panic("oldclk statintr");
		return (1);
	}
#endif

	/* read the limit register to clear the interrupt */
	if (CPU_ISSUN4M) {
		discard = counterreg_4m->t_limit;
		if (timerok == 0) {
			/* Stop the clock */
			counterreg_4m->t_limit = 0;
			counterreg_4m->t_ss = 0;
			timerreg_4m->t_cfg = TMR_CFG_USER;
			return 1;
		}
	}

	if (CPU_ISSUN4OR4COR4E) {
		discard = timerreg4->t_c14.t_limit;
	}
	statclock((struct clockframe *)cap);

	/*
	 * Compute new randomized interval.  The intervals are uniformly
	 * distributed on [statint - statvar / 2, statint + statvar / 2],
	 * and therefore have mean statint, giving a stathz frequency clock.
	 */
	var = statvar;
	do {
		r = random() & (var - 1);
	} while (r == 0);
	newint = statmin + r;

	if (CPU_ISSUN4M) {
		counterreg_4m->t_limit = tmr_ustolim4m(newint);
	}

	if (CPU_ISSUN4OR4COR4E) {
		timerreg4->t_c14.t_limit = tmr_ustolim(newint);
	}
	return (1);
}

/*
 * Set up the system's time, given a `reasonable' time value.
 */
void
inittodr(base)
	time_t base;
{
	struct clockreg *cl = clockreg;
	struct clock_ymdhms dt;
	int badbase = 0, waszero = base == 0;
	char *bad = NULL;
	struct timespec ts;

	ts.tv_sec = ts.tv_nsec = 0;

	if (base < 5 * SECYR) {
		/*
		 * If base is 0, assume filesystem time is just unknown
		 * in stead of preposterous. Don't bark.
		 */
		if (base != 0)
			printf("WARNING: preposterous time in file system\n");
		/* not going to use it anyway, if the chip is readable */
		base = (2012 - 1970) * SECYR;
		badbase = 1;
	}
#if defined(SUN4)
	if (oldclk) {
		ts.tv_sec = oclk_get_secs();
		goto forward;
	}
#endif
	clk_wenable(1);
	cl->cl_csr |= CLK_READ;		/* enable read (stop time) */
	dt.dt_sec = FROMBCD(cl->cl_sec);
	dt.dt_min = FROMBCD(cl->cl_min);
	dt.dt_hour = FROMBCD(cl->cl_hour);
	dt.dt_day = FROMBCD(cl->cl_mday);
	dt.dt_mon = FROMBCD(cl->cl_month);
	dt.dt_year = FROMBCD(cl->cl_year) + CLOCK_BASE_YEAR;
	cl->cl_csr &= ~CLK_READ;	/* time wears on */
	clk_wenable(0);
	ts.tv_sec = clock_ymdhms_to_secs(&dt);

#if defined(SUN4)
forward:
#endif
	if (ts.tv_sec == 0) {
		/*
		 * Believe the time in the file system for lack of
		 * anything better, resetting the clock.
		 */
		bad = "WARNING: bad date in battery clock";
		ts.tv_sec = base;
		tc_setclock(&ts);
		if (!badbase)
			resettodr();
	} else {
		time_t deltat = ts.tv_sec - base;

		tc_setclock(&ts);
		if (deltat < 0)
			deltat = -deltat;
		if (waszero || deltat < 2 * SECDAY)
			return;
		
#ifndef SMALL_KERNEL
		printf("WARNING: clock %s %lld days",
		    ts.tv_sec < base ? "lost" : "gained",
		    (long long)(deltat / SECDAY));
		bad = "";
#endif
	}
	if (bad) {
		printf("%s", bad);
		printf(" -- CHECK AND RESET THE DATE!\n");
	}
}

/*
 * Reset the clock based on the current time.
 * Used when the current clock is preposterous, when the time is changed,
 * and when rebooting.  Do nothing if the time is not yet known, e.g.,
 * when crashing during autoconfig.
 */
void
resettodr()
{
	struct clockreg *cl;
	struct clock_ymdhms dt;

#if defined(SUN4)
	if (oldclk) {
		if (!time_second || i7 == NULL)
			return;
		oclk_set_secs(time_second);
		return;
	}
#endif

	if (!time_second || (cl = clockreg) == NULL)
		return;

	clock_secs_to_ymdhms(time_second, &dt);

	clk_wenable(1);
	cl->cl_csr |= CLK_WRITE;	/* enable write */
	cl->cl_sec = TOBCD(dt.dt_sec);
	cl->cl_min = TOBCD(dt.dt_min);
	cl->cl_hour = TOBCD(dt.dt_hour);
	cl->cl_wday = TOBCD(dt.dt_wday);
	cl->cl_mday = TOBCD(dt.dt_day);
	cl->cl_month = TOBCD(dt.dt_mon);
	cl->cl_year = TOBCD(dt.dt_year - CLOCK_BASE_YEAR);
	cl->cl_csr &= ~CLK_WRITE;	/* load them up */
	clk_wenable(0);
}

#if defined(SUN4)
/*
 * Now routines to get and set clock as POSIX time.
 */
long
oclk_get_secs()
{
        struct intersil_dt idt;
	struct clock_ymdhms dt;

        oclk_get_dt(&idt);
	dt.dt_sec = idt.dt_sec;
	dt.dt_min = idt.dt_min;
	dt.dt_hour = idt.dt_hour;
	dt.dt_day = idt.dt_day;
	dt.dt_mon = idt.dt_month;
	dt.dt_year = idt.dt_year + CLOCK_BASE_YEAR;
        return clock_ymdhms_to_secs(&dt);
}

void
oclk_set_secs(secs)
	long secs;
{
        struct intersil_dt idt;
	struct clock_ymdhms dt;

	clock_secs_to_ymdhms(secs, &dt);
	
	idt.dt_hour = dt.dt_hour;
	idt.dt_min = dt.dt_min;
	idt.dt_sec = dt.dt_sec;
	idt.dt_month = dt.dt_mon;
	idt.dt_day = dt.dt_day;
	idt.dt_year = dt.dt_year - CLOCK_BASE_YEAR;
	idt.dt_dow = dt.dt_wday;
        oclk_set_dt(&idt);
}

/*
 * Routine to copy state into and out of the clock.
 * The clock registers have to be read or written
 * in sequential order (or so it appears). -gwr
 */
void
oclk_get_dt(dt)
	struct intersil_dt *dt;
{
        int s;
        register volatile char *src, *dst;

        src = (char *) &i7->counters;

        s = splhigh();
        i7->clk_cmd_reg =
                intersil_command(INTERSIL_CMD_STOP, INTERSIL_CMD_IENABLE);

        dst = (char *) dt;
        dt++;   /* end marker */
        do {
                *dst++ = *src++;
        } while (dst < (char *)dt);

        i7->clk_cmd_reg =
                intersil_command(INTERSIL_CMD_RUN, INTERSIL_CMD_IENABLE);
        splx(s);
}

void
oclk_set_dt(dt)
	struct intersil_dt *dt;
{
        int s;
        register volatile char *src, *dst;

        dst = (char *) &i7->counters;

        s = splhigh();
        i7->clk_cmd_reg =
                intersil_command(INTERSIL_CMD_STOP, INTERSIL_CMD_IENABLE);

        src = (char *) dt;
        dt++;   /* end marker */
        do {
                *dst++ = *src++;
        } while (src < (char *)dt);

        i7->clk_cmd_reg =
                intersil_command(INTERSIL_CMD_RUN, INTERSIL_CMD_IENABLE);
        splx(s);
}
#endif /* SUN4 */

/*
 * XXX: these may actually belong somewhere else, but since the
 * EEPROM is so closely tied to the clock on some models, perhaps
 * it needs to stay here...
 */
int
eeprom_uio(uio)
	struct uio *uio;
{
#if defined(SUN4)
	int error;
	off_t off;
	size_t cnt, bcnt;
	caddr_t buf = NULL;

	if (!CPU_ISSUN4)
		return (ENODEV);

	off = uio->uio_offset;
	if (off < 0 || off > EEPROM_SIZE)
		return (EFAULT);

	cnt = uio->uio_resid;
	if (cnt > (EEPROM_SIZE - off))
		cnt = (EEPROM_SIZE - off);

	if ((error = eeprom_take()) != 0)
		return (error);

	if (eeprom_va == NULL) {
		error = ENXIO;
		goto out;
	}

	/*
	 * The EEPROM can only be accessed one byte at a time, yet
	 * uiomove() will attempt long-word access.  To circumvent
	 * this, we byte-by-byte copy the eeprom contents into a
	 * temporary buffer.
	 */
	buf = malloc(EEPROM_SIZE, M_DEVBUF, M_WAITOK);

	if (uio->uio_rw == UIO_READ)
		for (bcnt = 0; bcnt < EEPROM_SIZE; ++bcnt)
			*(char *)(buf + bcnt) = *(char *)(eeprom_va + bcnt);

	if ((error = uiomove(buf + off, cnt, uio)) != 0)
		goto out;

	if (uio->uio_rw != UIO_READ)
		error = eeprom_update(buf, (size_t)off, cnt);

 out:
	free(buf, M_DEVBUF, EEPROM_SIZE);
	eeprom_give();
	return (error);
#else /* ! SUN4 */
	return (ENODEV);
#endif /* SUN4 */
}

#if defined(SUN4)
/*
 * Update the EEPROM from the passed buf.
 */
int
eeprom_update(buf, off, cnt)
	char *buf;
	size_t off, cnt;
{
	int error = 0;
	volatile char *ep;
	char *bp;

	if (eeprom_va == NULL)
		return (ENXIO);

	ep = eeprom_va + off;
	bp = buf + off;

	if (eeprom_nvram)
		clk_wenable(1);

	while (cnt > 0) {
		/*
		 * DO NOT WRITE IT UNLESS WE HAVE TO because the
		 * EEPROM has a limited number of write cycles.
		 * After some number of writes it just fails!
		 */
		if (*ep != *bp) {
			*ep = *bp;
			/*
			 * We have written the EEPROM, so now we must
			 * sleep for at least 10 milliseconds while
			 * holding the lock to prevent all access to
			 * the EEPROM while it recovers.
			 */
			(void)tsleep(eeprom_va, PZERO - 1, "eeprom", hz/50);
		}
		/* Make sure the write worked. */
		if (*ep != *bp) {
			error = EIO;
			goto out;
		}
		++ep;
		++bp;
		--cnt;
	}
 out:
	if (eeprom_nvram)
		clk_wenable(0);

	return (error);
}

/* Take a lock on the eeprom. */
int
eeprom_take()
{
	int error = 0;

	while (eeprom_busy) {
		eeprom_wanted = 1;
		error = tsleep(&eeprom_busy, PZERO | PCATCH, "eeprom", 0);
		eeprom_wanted = 0;
		if (error)	/* interrupted */
			goto out;
	}
	eeprom_busy = 1;
 out:
	return (error);
}

/* Give a lock on the eeprom away. */
void
eeprom_give()
{

	eeprom_busy = 0;
	if (eeprom_wanted) {
		eeprom_wanted = 0;
		wakeup(&eeprom_busy);
	}
}
#endif /* SUN4 */
@


1.33
log
@trivial "if(x) free(x)" replacement by "free(x)"

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.32 2015/02/10 22:49:16 miod Exp $	*/
d803 1
a803 1
	if (cold == 0)
@


1.32
log
@Convert sun4 eeprom access to uiomove()
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.30 2014/11/16 12:30:58 deraadt Exp $	*/
d1128 1
a1128 2
	if (buf)
		free(buf, M_DEVBUF, 0);
@


1.31
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d166 1
a166 1
int	eeprom_update(char *, int, int);
d1086 2
a1087 2
	int off;	/* NOT off_t */
	u_int cnt, bcnt;
d1094 1
a1094 1
	if (off > EEPROM_SIZE)
d1121 1
a1121 1
	if ((error = uiomovei(buf + off, (int)cnt, uio)) != 0)
d1125 1
a1125 1
		error = eeprom_update(buf, off, cnt);
d1144 1
a1144 1
	int off, cnt;
@


1.30
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.29 2014/07/12 18:44:43 tedu Exp $	*/
d1121 1
a1121 1
	if ((error = uiomove(buf + off, (int)cnt, uio)) != 0)
@


1.29
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.28 2013/07/05 20:30:56 guenther Exp $	*/
d441 1
a441 1
		pmap_changeprot(pmap_kernel(), (vaddr_t)cl, VM_PROT_READ, 1);
d443 1
a443 1
				VM_PROT_READ, 1);
d451 1
a451 1
		pmap_changeprot(pmap_kernel(), (vaddr_t)cl, VM_PROT_READ, 1);
d638 1
a638 1
		prot = writers++ == 0 ? VM_PROT_READ|VM_PROT_WRITE : 0;
d640 1
a640 1
		prot = --writers == 0 ? VM_PROT_READ : 0;
@


1.28
log
@Avoid truncation when calculating clock gain/loss

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.27 2012/11/05 13:20:16 miod Exp $	*/
d1129 1
a1129 1
		free(buf, M_DEVBUF);
@


1.27
log
@Switch sparc to timecounters. Heavily based on NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.26 2010/07/10 19:32:24 miod Exp $	*/
d922 1
a922 1
		int deltat = ts.tv_sec - base;
d931 3
a933 2
		printf("WARNING: clock %s %d days",
		    ts.tv_sec < base ? "lost" : "gained", deltat / SECDAY);
@


1.26
log
@sun4e (i.e. SPARCengine 1e) support. This platform is a mix between sun4 and
sun4c, as it has a sun4c OpenPROM but a sun4 8KB pagesize. VME devices are
not supported yet.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.25 2010/07/06 20:40:01 miod Exp $	*/
d70 1
a128 1
#endif
d141 9
d206 19
d230 4
a266 1
#if defined(SUN4)
d300 1
a300 1
			printf(" delay constant %d%s\n", timerblurb,
d310 13
a323 1
}
d521 1
d534 2
a535 2
		cnt = &counterreg_4m->t_counter;
		lim = &counterreg_4m->t_limit;
d542 2
a543 1
		 * microtime() faster (in SUN4/SUN4C/SUN4E kernel only).
d548 2
a549 2
		cnt = &timerreg4->t_c14.t_counter;
		lim = &timerreg4->t_c14.t_limit;
d562 1
a562 1
		int t0, t1;
d572 2
d585 35
a619 1
	printf(" delay constant %d\n", timerblurb);
d621 1
a621 1
	/* should link interrupt handlers here, rather than compiled-in? */
d796 1
d799 6
a804 1
	hardclock((struct clockframe *)cap);
d875 3
d887 1
a887 1
		base = 21*SECYR + 186*SECDAY + SECDAY/2;
d892 1
a892 1
		time.tv_sec = oclk_get_secs();
d906 1
a906 1
	time.tv_sec = clock_ymdhms_to_secs(&dt);
d911 1
a911 1
	if (time.tv_sec == 0) {
d917 2
a918 1
		time.tv_sec = base;
d922 1
a922 1
		int deltat = time.tv_sec - base;
d924 1
d932 1
a932 1
		    time.tv_sec < base ? "lost" : "gained", deltat / SECDAY);
d956 1
a956 1
		if (!time.tv_sec || i7 == NULL)
d958 1
a958 1
		oclk_set_secs(time.tv_sec);
d963 1
a963 1
	if (!time.tv_sec || (cl = clockreg) == NULL)
d966 1
a966 1
	clock_secs_to_ymdhms(time.tv_sec, &dt);
a1070 35
}
#endif /* SUN4 */

#if defined(SUN4)
/*
 * Return the best possible estimate of the time in the timeval
 * to which tvp points.  We do this by returning the current time
 * plus the amount of time since the last clock interrupt.
 *
 * Check that this time is no less than any previously-reported time,
 * which could happen around the time of a clock adjustment.  Just for
 * fun, we guarantee that the time will be greater than the value
 * obtained by a previous call.
 */
void
microtime(tvp)
	struct timeval *tvp;
{
	int s;
	static struct timeval lasttime;
	static struct timeval oneusec = {0, 1};

	if (!oldclk) {
		lo_microtime(tvp);
		return;
	}

	s = splhigh();
	*tvp = time;
	splx(s);

	if (timercmp(tvp, &lasttime, <=))
		timeradd(&lasttime, &oneusec, tvp);

	lasttime = *tvp;
@


1.25
log
@Having common ienab_bic() and ienab_bis() entry points for sun4/4c and sun4m
is stupid, since the bits in the interrupt enable register are completely
different between 4/4c and 4m.

Instead, provide distinct, explicit function names to handle the interrupt
enable register.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.24 2006/12/10 16:12:41 miod Exp $	*/
d380 1
a380 2

	else if (CPU_ISSUN4COR4M)
d457 1
a457 1
	if (CPU_ISSUN4C) {
d494 1
a494 1
	if (CPU_ISSUN4OR4C) {
d498 1
a498 1
		 * microtime() faster (in SUN4/SUN4C kernel only).
d646 1
a646 1
	if (CPU_ISSUN4OR4C) {
d658 2
a659 2
#if defined(SUN4) || defined(SUN4C)
	if (CPU_ISSUN4OR4C)
d707 2
a708 2
#if defined(SUN4) || defined(SUN4C)
	if (CPU_ISSUN4OR4C) {
d751 1
a751 1
	if (CPU_ISSUN4OR4C) {
d771 1
a771 1
	if (CPU_ISSUN4OR4C) {
@


1.24
log
@Fix typo in intersil clock programming.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.23 2006/06/26 20:21:02 kettenis Exp $	*/
d255 1
a255 1
	ienab_bic(IE_L14 | IE_L10);	/* disable all clock intrs */
d614 1
a614 1
		ienab_bic(IE_L14 | IE_L10);	/* disable all clock intrs */
d617 1
a617 1
		ienab_bis(IE_L10);		/* enable l10 interrupt */
d656 1
a656 1
		ienab_bic(SINTR_T);
d659 1
d661 2
a662 2
		ienab_bis(IE_L14 | IE_L10);

d677 1
a677 3
 * Level 10 (clock) interrupts.  If we are using the FORTH PROM for
 * console input, we need to check for that here as well, and generate
 * a software interrupt to read it.
d697 2
a698 2
		ienab_bic(IE_L10);  /* clear interrupt */
		ienab_bis(IE_L10);  /* enable interrupt */
@


1.23
log
@Use MI clock conversion code for "old" clock.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.22 2006/06/23 19:54:30 kettenis Exp $	*/
d920 1
a920 1
	idt.dt_hour = dt.dt_sec;
@


1.22
log
@Use MI clock conversion code for "new" clock.
ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.21 2006/06/19 15:13:35 deraadt Exp $	*/
a125 1
void	dt_to_gmt(struct intersil_dt *, long *);
a127 1
void	gmt_to_dt(long *, struct intersil_dt *);
d898 2
a899 2
        struct intersil_dt dt;
        long gmt;
d901 8
a908 3
        oclk_get_dt(&dt);
        dt_to_gmt(&dt, &gmt);
        return (gmt);
d915 2
a916 2
        struct intersil_dt dt;
        long gmt;
d918 10
a927 3
        gmt = secs;
        gmt_to_dt(&gmt, &dt);
        oclk_set_dt(&dt);
a980 104
}


/* Traditional UNIX base year */
#define POSIX_BASE_YEAR 1970
#define FEBRUARY        2

#define leapyear(year)          ((year) % 4 == 0)
#define days_in_year(a)         (leapyear(a) ? 366 : 365)
#define days_in_month(a)        (month_days[(a) - 1])

static int month_days[12] = {
        31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};

void
gmt_to_dt(tp, dt)
	long *tp;
	struct intersil_dt *dt;
{
        int i;
        long days, secs;

        days = *tp / SECDAY;
        secs = *tp % SECDAY;

        /* Hours, minutes, seconds are easy */
        dt->dt_hour = secs / 3600;
        secs = secs % 3600;
        dt->dt_min  = secs / 60;
        secs = secs % 60;
        dt->dt_sec  = secs;

        /* Day of week (Note: 1/1/1970 was a Thursday) */
        dt->dt_dow = (days + 4) % 7;

        /* Number of years in days */
        i = POSIX_BASE_YEAR;
        while (days >= days_in_year(i)) {
                days -= days_in_year(i);
                i++;
        }
        dt->dt_year = i - CLOCK_BASE_YEAR;

        /* Number of months in days left */
        if (leapyear(i))
                days_in_month(FEBRUARY) = 29;
        for (i = 1; days >= days_in_month(i); i++)
                days -= days_in_month(i);
        days_in_month(FEBRUARY) = 28;
        dt->dt_month = i;

        /* Days are what is left over (+1) from all that. */
        dt->dt_day = days + 1;
}


void
dt_to_gmt(dt, tp)
	struct intersil_dt *dt;
	long *tp;
{
        int i;
        long tmp;
        int year;

        /*
         * Hours are different for some reason. Makes no sense really.
         */

        tmp = 0;

        if (dt->dt_hour >= 24) goto out;
        if (dt->dt_day  >  31) goto out;
        if (dt->dt_month > 12) goto out;

        year = dt->dt_year + CLOCK_BASE_YEAR;


        /*
         * Compute days since start of time
         * First from years, then from months.
         */
        for (i = POSIX_BASE_YEAR; i < year; i++)
                tmp += days_in_year(i);
        if (leapyear(year) && dt->dt_month > FEBRUARY)
                tmp++;

        /* Months */
        for (i = 1; i < dt->dt_month; i++)
                tmp += days_in_month(i);
        tmp += (dt->dt_day - 1);

        /* Now do hours */
        tmp = tmp * 24 + dt->dt_hour;

        /* Now do minutes */
        tmp = tmp * 60 + dt->dt_min;

        /* Now do seconds */
        tmp = tmp * 60 + dt->dt_sec;

out:
        *tp = tmp;
@


1.21
log
@move clock_subr.c to a better place, and now it is always in the kernel
so that things can use it; tested on all architectures; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.20 2006/04/16 22:24:44 miod Exp $	*/
a198 1
struct chiptime;
a200 2
int chiptotime(int, int, int, int, int, int);
void timetochip(struct chiptime *);
a781 103
 * BCD to decimal and decimal to BCD.
 */
#define	FROMBCD(x)	(((x) >> 4) * 10 + ((x) & 0xf))
#define	TOBCD(x)	(((x) / 10 * 16) + ((x) % 10))

#define	SECYR		(SECDAY * 365)
/*
 * should use something like
 * #define LEAPYEAR(y) ((((y) % 4) == 0 && ((y) % 100) != 0) || ((y) % 400) == 0)
 * but it's unlikely that we'll still be around in 2100.
 */
#define	LEAPYEAR(y)	(((y) & 3) == 0)

/*
 * This code is defunct after 2068.
 * Will Unix still be here then??
 */
const short dayyr[12] =
    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };

int
chiptotime(sec, min, hour, day, mon, year)
	int sec, min, hour, day, mon, year;
{
	int days, yr;

	sec = FROMBCD(sec);
	min = FROMBCD(min);
	hour = FROMBCD(hour);
	day = FROMBCD(day);
	mon = FROMBCD(mon);
	year = FROMBCD(year) + YEAR0;

	/* simple sanity checks */
	if (year < 70 || mon < 1 || mon > 12 || day < 1 || day > 31)
		return (0);
	days = 0;
	for (yr = 70; yr < year; yr++)
		days += LEAPYEAR(yr) ? 366 : 365;
	days += dayyr[mon - 1] + day - 1;
	if (LEAPYEAR(yr) && mon > 2)
		days++;
	/* now have days since Jan 1, 1970; the rest is easy... */
	return (days * SECDAY + hour * 3600 + min * 60 + sec);
}

struct chiptime {
	int	sec;
	int	min;
	int	hour;
	int	wday;
	int	day;
	int	mon;
	int	year;
};

void
timetochip(c)
	struct chiptime *c;
{
	int t, t2, t3, now = time.tv_sec;

	/* compute the year */
	t2 = now / SECDAY;
	t3 = (t2 + 2) % 7;	/* day of week */
	c->wday = TOBCD(t3 + 1);

	t = 69;
	while (t2 >= 0) {	/* whittle off years */
		t3 = t2;
		t++;
		t2 -= LEAPYEAR(t) ? 366 : 365;
	}
	c->year = t;

	/* t3 = month + day; separate */
	t = LEAPYEAR(t);
	for (t2 = 1; t2 < 12; t2++)
		if (t3 < dayyr[t2] + (t && t2 > 1))
			break;

	/* t2 is month */
	c->mon = t2;
	c->day = t3 - dayyr[t2 - 1] + 1;
	if (t && t2 > 2)
		c->day--;

	/* the rest is easy */
	t = now % SECDAY;
	c->hour = t / 3600;
	t %= 3600;
	c->min = t / 60;
	c->sec = t % 60;

	c->sec = TOBCD(c->sec);
	c->min = TOBCD(c->min);
	c->hour = TOBCD(c->hour);
	c->day = TOBCD(c->day);
	c->mon = TOBCD(c->mon);
	c->year = TOBCD(c->year - YEAR0);
}

/*
d789 1
a789 1
	int sec, min, hour, day, mon, year;
d812 6
a817 6
	sec = cl->cl_sec;
	min = cl->cl_min;
	hour = cl->cl_hour;
	day = cl->cl_mday;
	mon = cl->cl_month;
	year = cl->cl_year;
d820 1
a820 1
	time.tv_sec = chiptotime(sec, min, hour, day, mon, year);
d864 1
a864 1
	struct chiptime c;
d877 3
a879 1
	timetochip(&c);
d882 7
a888 7
	cl->cl_sec = c.sec;
	cl->cl_min = c.min;
	cl->cl_hour = c.hour;
	cl->cl_wday = c.wday;
	cl->cl_mday = c.day;
	cl->cl_month = c.mon;
	cl->cl_year = c.year;
a972 6

/*
 * Machine dependent base year:
 * Note: must be < 1970
 */
#define CLOCK_BASE_YEAR 1968
@


1.20
log
@Remove can't happen DIAGNOSTIC check.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.19 2004/04/08 01:11:21 deraadt Exp $	*/
a789 1
#define	SECDAY		(24 * 60 * 60)
@


1.19
log
@on RAMDISK kernels, do not compare / time against the system time
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.18 2002/08/12 10:44:04 miod Exp $	*/
d386 1
a386 1
	if (CPU_ISSUN4COR4M)
a388 4
#ifdef DIAGNOSTIC
	if (prop == NULL)
		panic("no prop");
#endif
@


1.18
log
@Convert sparc console code from rcons and pseudo-devices to rasops and wscons.
For most framebuffers it is faster.

Other changes include:
o 24 bit support in tcx(4) for the S24 framebuffer
o accelerated cgsix(4) text console
o new cgtwelve(4) driver for the GS framebuffer
o improved serial driver code
o better keyboard support

The following framebuffers have not been tested but should work: cgfour,
cgeight and cgfourteen

These changes will require XF4 changes, to use Xwsfb instead of Xsun*, to be
commited later today.

Most of the work by me during the LSM and the week after, with code borrowed
from jason@@, NetBSD (new serial code), and feedback from mickey@@. Work on
pnozz(4) done by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.17 2002/03/14 03:16:00 millert Exp $	*/
d902 1
a936 1
		printf("WARNING: bad date in battery clock");
d941 1
d952 2
d956 6
a962 1
	printf(" -- CHECK AND RESET THE DATE!\n");
@


1.17
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.16 2002/03/14 01:26:44 millert Exp $	*/
a694 1
	extern int rom_console_input;
a728 2
	if (rom_console_input && cnrom())
		setsoftint();
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.15 2001/11/06 19:53:16 miod Exp $	*/
d1046 1
a1046 1
        } while (dst < (char*)dt);
@


1.15
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.14 2001/05/16 12:49:48 ho Exp $	*/
d124 6
a129 6
long	oclk_get_secs __P((void));
void	oclk_get_dt __P((struct intersil_dt *));
void	dt_to_gmt __P((struct intersil_dt *, long *));
void	oclk_set_dt __P((struct intersil_dt *));
void	oclk_set_secs __P((long));
void	gmt_to_dt __P((long *, struct intersil_dt *));
d132 2
a133 2
int	oclockmatch __P((struct device *, void *, void *));
void	oclockattach __P((struct device *, struct device *, void *));
d157 3
a159 3
int	eeprom_take __P((void));
void	eeprom_give __P((void));
int	eeprom_update __P((char *, int, int));
d162 2
a163 2
int	eeprom_match __P((struct device *, void *, void *));
void	eeprom_attach __P((struct device *, struct device *, void *));
d173 2
a174 2
int	clockmatch __P((struct device *, void *, void *));
void	clockattach __P((struct device *, struct device *, void *));
d184 2
a185 2
int	timermatch __P((struct device *, void *, void *));
void	timerattach __P((struct device *, struct device *, void *));
d200 4
a203 4
void clk_wenable __P((int));
void myetheraddr __P((u_char *));
int chiptotime __P((int, int, int, int, int, int));
void timetochip __P((struct chiptime *));
@


1.15.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.15 2001/11/06 19:53:16 miod Exp $	*/
d124 6
a129 6
long	oclk_get_secs(void);
void	oclk_get_dt(struct intersil_dt *);
void	dt_to_gmt(struct intersil_dt *, long *);
void	oclk_set_dt(struct intersil_dt *);
void	oclk_set_secs(long);
void	gmt_to_dt(long *, struct intersil_dt *);
d132 2
a133 2
int	oclockmatch(struct device *, void *, void *);
void	oclockattach(struct device *, struct device *, void *);
d157 3
a159 3
int	eeprom_take(void);
void	eeprom_give(void);
int	eeprom_update(char *, int, int);
d162 2
a163 2
int	eeprom_match(struct device *, void *, void *);
void	eeprom_attach(struct device *, struct device *, void *);
d173 2
a174 2
int	clockmatch(struct device *, void *, void *);
void	clockattach(struct device *, struct device *, void *);
d184 2
a185 2
int	timermatch(struct device *, void *, void *);
void	timerattach(struct device *, struct device *, void *);
d200 4
a203 4
void clk_wenable(int);
void myetheraddr(u_char *);
int chiptotime(int, int, int, int, int, int);
void timetochip(struct chiptime *);
d1046 1
a1046 1
        } while (dst < (char *)dt);
@


1.15.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.15.2.1 2002/06/11 03:38:16 art Exp $	*/
d695 1
d730 2
@


1.14
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.13 1999/09/29 13:54:03 art Exp $	*/
d74 1
a74 1
#include <vm/vm.h>
@


1.13
log
@some SUN4* ifdefs
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.12 1999/07/09 21:40:20 art Exp $	*/
a1263 4
	if (buf == NULL) {
		error = EAGAIN;
		goto out;
	}
@


1.13.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.13 1999/09/29 13:54:03 art Exp $	*/
d1264 4
@


1.13.4.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 1
a74 1
#include <uvm/uvm_extern.h>
@


1.13.4.3
log
@Merge in -current from about a week ago
@
text
@d124 6
a129 6
long	oclk_get_secs(void);
void	oclk_get_dt(struct intersil_dt *);
void	dt_to_gmt(struct intersil_dt *, long *);
void	oclk_set_dt(struct intersil_dt *);
void	oclk_set_secs(long);
void	gmt_to_dt(long *, struct intersil_dt *);
d132 2
a133 2
int	oclockmatch(struct device *, void *, void *);
void	oclockattach(struct device *, struct device *, void *);
d157 3
a159 3
int	eeprom_take(void);
void	eeprom_give(void);
int	eeprom_update(char *, int, int);
d162 2
a163 2
int	eeprom_match(struct device *, void *, void *);
void	eeprom_attach(struct device *, struct device *, void *);
d173 2
a174 2
int	clockmatch(struct device *, void *, void *);
void	clockattach(struct device *, struct device *, void *);
d184 2
a185 2
int	timermatch(struct device *, void *, void *);
void	timerattach(struct device *, struct device *, void *);
d200 4
a203 4
void clk_wenable(int);
void myetheraddr(u_char *);
int chiptotime(int, int, int, int, int, int);
void timetochip(struct chiptime *);
d1046 1
a1046 1
        } while (dst < (char *)dt);
@


1.13.4.4
log
@Sync the SMP branch with 3.3
@
text
@d695 1
d730 2
@


1.13.4.5
log
@Merge with the trunk
@
text
@a901 1
	char *bad = NULL;
d936 1
a940 1
		bad = "WARNING: bad date in battery clock";
a950 2
		
#ifndef SMALL_KERNEL
a952 6
		bad = "";
#endif
	}
	if (bad) {
		printf("%s", bad);
		printf(" -- CHECK AND RESET THE DATE!\n");
d954 1
@


1.12
log
@oops. missed a few
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.10 1998/03/04 19:19:28 johns Exp $	*/
d713 1
d718 2
a719 1

d723 1
@


1.11
log
@vm_offset_t -> {v,p}addr_t and vm_size_t -> {v,p}size_t
remove "register" keywords
Various cleanups.
@
text
@d215 1
a215 1
	register struct confargs *ca = aux;
d244 1
a244 1
	register int h;
d263 1
a263 1
		register int ival;
d349 1
a349 1
	register struct confargs *ca = aux;
d376 3
a378 3
	register int h;
	register struct clockreg *cl;
	register struct idprom *idp;
d450 1
a450 1
	register struct confargs *ca = aux;
d485 1
a485 1
	register struct romaux *ra = &ca->ca_ra;
d527 1
a527 1
		register int t0, t1;
d561 2
a562 2
	register int s;
	register vm_prot_t prot;/* nonzero => change prot */
d583 2
a584 2
	register struct clockreg *cl = clockreg;
	register struct idprom *idp = &cl->cl_idprom;
d608 1
a608 1
	register int statint, minint;
d693 1
a693 1
	register volatile int discard;
d740 2
a741 2
	register volatile int discard;
	register u_long newint, r, var;
d812 1
a812 1
	register int sec, min, hour, day, mon, year;
d814 1
a814 1
	register int days, yr;
d848 1
a848 1
	register struct chiptime *c;
d850 1
a850 1
	register int t, t2, t3, now = time.tv_sec;
d899 1
a899 1
	register struct clockreg *cl = clockreg;
d966 1
a966 1
	register struct clockreg *cl;
d1098 2
a1099 2
        register int i;
        register long days, secs;
d1140 2
a1141 2
        register int i;
        register long tmp;
d1198 1
a1198 1
	register struct timeval *tvp;
@


1.10
log
@Improved error/warning messages for clock/statclock rate stuff, added
missing mesg for oclock on 4/100 and 4/200..
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.9 1997/11/11 10:03:03 niklas Exp $	*/
d408 2
a409 2
		pmap_changeprot(pmap_kernel(), (vm_offset_t)cl, VM_PROT_READ, 1);
		pmap_changeprot(pmap_kernel(), (vm_offset_t)cl + 4096,
d418 1
a418 1
		pmap_changeprot(pmap_kernel(), (vm_offset_t)cl, VM_PROT_READ, 1);
d572 1
a572 2
		pmap_changeprot(pmap_kernel(),
				(vm_offset_t)clockreg & ~(NBPG-1),
@


1.9
log
@Remove those static specifiers
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.8 1997/08/08 08:27:05 downsj Exp $	*/
d615 4
d635 1
a635 1
		printf("cannot get %d Hz clock; using 100 Hz\n", hz);
d642 1
a642 1
		printf("cannot get %d Hz statclock; using 100 Hz\n", stathz);
@


1.8
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d124 6
a129 6
static long oclk_get_secs __P((void));
static void oclk_get_dt __P((struct intersil_dt *));
static void dt_to_gmt __P((struct intersil_dt *, long *));
static void oclk_set_dt __P((struct intersil_dt *));
static void oclk_set_secs __P((long));
static void gmt_to_dt __P((long *, struct intersil_dt *));
d132 2
a133 2
static int oclockmatch __P((struct device *, void *, void *));
static void oclockattach __P((struct device *, struct device *, void *));
d157 3
a159 3
static int	eeprom_take __P((void));
static void	eeprom_give __P((void));
static int	eeprom_update __P((char *, int, int));
d162 2
a163 2
static int	eeprom_match __P((struct device *, void *, void *));
static void	eeprom_attach __P((struct device *, struct device *, void *));
d173 2
a174 2
static int	clockmatch __P((struct device *, void *, void *));
static void	clockattach __P((struct device *, struct device *, void *));
d184 2
a185 2
static int	timermatch __P((struct device *, void *, void *));
static void	timerattach __P((struct device *, struct device *, void *));
d210 1
a210 1
static int
d235 1
a235 1
static void
d290 1
a290 1
static int
d323 1
a323 1
static void
d344 1
a344 1
static int
d371 1
a371 1
static void
d445 1
a445 1
static int
d479 1
a479 1
static void
d995 1
a995 1
static long
d1006 1
a1006 1
static void
d1023 1
a1023 1
static void
d1047 1
a1047 1
static void
d1090 1
a1090 1
static void
d1132 1
a1132 1
static void
d1287 1
a1287 1
static int
d1338 1
a1338 1
static int
d1356 1
a1356 1
static void
@


1.7
log
@netbsd port, now we merge our changes back in
@
text
@d1 2
a2 1
/*	$NetBSD: clock.c,v 1.44 1996/05/16 15:57:12 abrown Exp $ */
d81 1
a84 1
#include <sparc/sparc/cache.h>
d99 2
a100 1
#include <sparc/sparc/intersil7170.h>
d125 3
a127 3
static void oclk_get_dt __P((struct date_time *));
static void dt_to_gmt __P((struct date_time *, long *));
static void oclk_set_dt __P((struct date_time *));
d129 1
a129 1
static void gmt_to_dt __P((long *, struct date_time *));
d213 1
a213 1
	void *aux, *vcf;
d218 3
a220 1
	if (!CPU_ISSUN4 || (cpumod != SUN4_100 && cpumod != SUN4_200))
d248 1
a248 2
	i7 = (struct intersil7170 *)
		mapiodev(ra->ra_reg, 0, sizeof(*i7), ca->ca_bustype);
d293 1
a293 1
	void *aux, *vcf;
d304 2
a305 1
	if (cpumod != SUN4_100 && cpumod != SUN4_200)
d334 1
a334 1
	eeprom_va = (char *)mapiodev(ra->ra_reg, 0, EEPROM_SIZE, ca->ca_bustype);
d347 1
a347 1
	void *aux, *vcf;
d353 2
a354 1
		if (cpumod != SUN4_300 && cpumod != SUN4_400)
d407 1
a407 2
		cl = (struct clockreg *)mapiodev(ra->ra_reg, 0, 8192,
						 ca->ca_bustype);
d417 1
a417 2
						 sizeof *clockreg,
						 ca->ca_bustype);
d426 2
a427 1
		if (cpumod == SUN4_300 || cpumod == SUN4_400) {
d448 1
a448 1
	void *aux, *vcf;
d453 2
a454 1
		if (cpumod != SUN4_300 && cpumod != SUN4_400)
d491 1
a491 1
			     sizeof(struct timer_4m), ca->ca_bustype);
d493 1
a493 1
			     sizeof(struct counter_4m), ca->ca_bustype);
d511 1
a511 1
			     sizeof(struct timerreg_4), ca->ca_bustype);
d649 2
a650 2
		timerreg_4m->t_limit = tmr_ustolim(tick);
		counterreg_4m->t_limit = tmr_ustolim(statint);
d776 1
a776 1
		counterreg_4m->t_limit = tmr_ustolim(newint);
d998 1
a998 1
        struct date_time dt;
d1010 1
a1010 1
        struct date_time dt;
d1025 1
a1025 1
	struct date_time *dt;
d1049 1
a1049 1
	struct date_time *dt;
d1093 1
a1093 1
	struct date_time *dt;
d1134 1
a1134 1
	struct date_time *dt;
@


1.6
log
@whoops, EEPROM_SIZE is not used anymore
@
text
@d1 1
a1 1
/*	$NetBSD: clock.c,v 1.26 1995/12/11 12:45:18 pk Exp $ */
d8 3
d18 1
d25 1
d35 2
d54 1
d68 1
d77 1
d79 1
a97 1
#if defined(SUN4)
a100 3
static int oldclk = 0;
volatile struct intersil7170 *i7;

d115 1
d117 1
a117 1
 * OCLOCK support: 4/100's and 4/200's have the old clock.  
d119 3
d128 1
a131 3
struct cfdriver oclockcd =
    { NULL, "oclock", oclockmatch, oclockattach, DV_DULL,
	sizeof(struct device) };
d133 7
a139 1
#endif /* SUN4 */
d151 1
d155 4
d162 3
a164 3
struct	cfdriver eepromcd = {
	NULL, "eeprom", eeprom_match, eeprom_attach,
	DV_DULL, sizeof(struct device)
d167 3
a169 5
#if defined(SUN4)
static int	eeprom_update __P((char *, int, int));
static int	eeprom_take __P((void));
static void	eeprom_give __P((void));
#endif
d173 7
a179 3
struct cfdriver clockcd = {
	NULL, "clock", clockmatch, clockattach,
	DV_DULL, sizeof(struct device)
d184 7
a190 3
struct cfdriver timercd = {
	NULL, "timer", timermatch, timerattach,
	DV_DULL, sizeof(struct device)
d193 11
a207 1

a212 1
	struct cfdata *cf = vcf;
d215 10
a224 4
#if defined(SUN4)
	if (cputyp==CPU_SUN4) {
		if (cpumod == SUN4_100 || cpumod == SUN4_200)
			return (strcmp(oclockcd.cd_name, ca->ca_ra.ra_name) == 0);
d226 2
a227 3
	}
#endif /* SUN4 */
	return (0); /* only sun4 has oclock */
a229 2
#if defined(SUN4)

d236 1
a242 1
	printf("\n");
d244 2
a245 2
	i7 = (volatile struct intersil7170 *) mapiodev(ra->ra_reg, 0,
	    sizeof(*i7), ca->ca_bustype);
d253 29
a282 1
#endif /* SUN4 */
a291 1
#if defined(SUN4)
d295 19
a313 3
	if (cputyp == CPU_SUN4) {
		if (cf->cf_unit != 0)
			return (0);
d315 2
a316 14
		if (cpumod == SUN4_100 || cpumod == SUN4_200) {
			if (strcmp(eepromcd.cd_name, ca->ca_ra.ra_name))
				return (0);
			/*
			 * Make sure there's something there...
			 * This is especially important if we want to
			 * use the same kernel on a 4/100 as a 4/200.
			 */
			if (probeget(ca->ca_ra.ra_vaddr, 1) != -1)
				return (1);
		}
	}
#endif /* SUN4 */
	return (0);
d330 1
a330 2
	eeprom_va = (char *)mapiodev(ra->ra_reg, 0,
	    sizeof(struct eeprom), ca->ca_bustype);
a344 1
	struct cfdata *cf = vcf;
d347 13
a359 6
#if defined(SUN4)
	if (cputyp==CPU_SUN4) {
		if (cpumod == SUN4_300 || cpumod == SUN4_400)
			return (strcmp(clockcd.cd_name,
			    ca->ca_ra.ra_name) == 0);
		return (0);
d361 1
a361 1
#endif /* SUN4 */
d376 1
a376 1
	char *prop;
d378 1
a378 2
#if defined(SUN4)
	if (cputyp == CPU_SUN4)
d380 2
a381 3
#endif
#if defined(SUN4C) || defined(SUN4M)
	if (cputyp == CPU_SUN4C || cputyp == CPU_SUN4M)
d383 4
d389 1
d402 5
a406 6
		cl = (struct clockreg *)mapiodev(ra->ra_reg, 0, 2 * NBPG,
		    ca->ca_bustype);
		pmap_changeprot(pmap_kernel(), (vm_offset_t)cl,
		    VM_PROT_READ, 1);
		pmap_changeprot(pmap_kernel(), (vm_offset_t)cl + NBPG,
		VM_PROT_READ, 1);
d412 3
a414 2
		cl = (struct clockreg *)mapiodev(ra->ra_reg, 0, sizeof *clockreg,
		    ca->ca_bustype);
a415 1
		idp = &cl->cl_idprom;
d417 1
d420 1
a420 1
	if (cputyp == CPU_SUN4) {
d429 1
a445 1
	struct cfdata *cf = vcf;
d448 20
a467 5
#if defined(SUN4)
	if (cputyp==CPU_SUN4) {
		if (cpumod == SUN4_300 || cpumod == SUN4_400)
			return (strcmp("timer", ca->ca_ra.ra_name) == 0);
		return (0);
d469 2
a470 2
#endif /* SUN4 */
	return (strcmp("counter-timer", ca->ca_ra.ra_name) == 0);
d481 32
a513 1
	printf("\n");
d515 3
a517 3
	 * This time, we ignore any existing virtual address because
	 * we have a fixed virtual address for the timer, to make
	 * microtime() faster.
d519 26
a544 3
	(void)mapdev(ra->ra_reg, TIMERREG_VA, 0, sizeof(struct timerreg),
	    ca->ca_bustype);
	timerok = 1;
d567 3
a569 1
		pmap_changeprot(pmap_kernel(), (vm_offset_t)clockreg, prot, 1);
d583 1
a583 1
	if (cputyp == CPU_SUN4)
d586 1
a595 45
 * This is easy to do on the machine with new-style clock chips
 * since we have freerunning microsecond timers -- no need to
 * guess at cpu speed factors.  We just wait for it to change
 * n times (if we calculated a limit, we might overshoot, and
 * precision is irrelevant here---we want less object code).
 * On machines with the old-style clocks, we've determined good
 * estimates.
 */
delay(n)
	register int n;
{
	register int c, t;

#if defined(SUN4)
	if (oldclk) {
		volatile register int lcv;

  		/*
		 * Two cases: 4/100 and 4/200.
		 */
		if (cpumod == SUN4_200)
			n = cacheinfo.c_enabled ? (n << 3) : (n << 1);
		else
			n = n << 1;
		while (--n >= 0)
			lcv = n;
		return (0);
	}
#endif /* SUN4 */

	if (timerok==0)
		return (0);

	if (timercd.cd_ndevs == 0)
		panic("delay");
	c = TIMERREG->t_c10.t_counter;
	while (--n >= 0) {
		while ((t = TIMERREG->t_c10.t_counter) == c)
			continue;
		c = t;
	}
	return (0);
}

/*
d601 1
d609 1
d615 5
a619 1
		ienab_bic(IE_L14 | IE_L10); /* disable all clock intrs */
d621 1
a621 9
		intersil_disable(i7);  /* disable clock */

		dummy = intersil_clear(i7);  /* clear interrupts */

		ienab_bis(IE_L10);  /* enable l10 interrupt */

		intersil_enable(i7);  /* enable clock */

		return (0);
d642 11
a652 2
	TIMERREG->t_c10.t_limit = tmr_ustolim(tick);
	TIMERREG->t_c14.t_limit = tmr_ustolim(statint);
d654 9
a662 1
	ienab_bis(IE_L14 | IE_L10);
d685 2
a686 1
	volatile register int discard;
d689 8
d706 8
a713 1
	discard = TIMERREG->t_c10.t_limit;
d715 3
d732 1
a732 1
	volatile register int discard;
d743 14
a756 1
	discard = TIMERREG->t_c14.t_limit;
d770 7
a776 1
	TIMERREG->t_c14.t_limit = tmr_ustolim(newint);
d788 5
d802 1
d838 1
d887 1
d924 1
d926 1
d955 1
d993 2
a994 2
	struct date_time dt;
	long gmt;
d996 3
a998 3
	oclk_get_dt(&dt);
	dt_to_gmt(&dt, &gmt);
	return (gmt);
d1005 2
a1006 2
	struct date_time dt;
	long gmt;
d1008 3
a1010 3
	gmt = secs;
	gmt_to_dt(&gmt, &dt);
	oclk_set_dt(&dt);
d1022 2
a1023 2
	int s;
	register volatile char *src, *dst;
d1025 1
a1025 5
	src = (char *) &i7->counters;

	s = splhigh();
	i7->clk_cmd_reg =
		intersil_command(INTERSIL_CMD_STOP, INTERSIL_CMD_IENABLE);
d1027 13
a1039 9
	dst = (char *) dt;
	dt++;   /* end marker */
	do {
		*dst++ = *src++;
	} while (dst < (char*)dt);

	i7->clk_cmd_reg =
		intersil_command(INTERSIL_CMD_RUN, INTERSIL_CMD_IENABLE);
	splx(s);
d1046 2
a1047 8
	int s;
	register volatile char *src, *dst;

	dst = (char *) &i7->counters;

	s = splhigh();
	i7->clk_cmd_reg =
		intersil_command(INTERSIL_CMD_STOP, INTERSIL_CMD_IENABLE);
d1049 1
a1049 5
	src = (char *) dt;
	dt++;   /* end marker */
	do {
		*dst++ = *src++;
	} while (src < (char *)dt);
d1051 13
a1063 3
	i7->clk_cmd_reg =
		intersil_command(INTERSIL_CMD_RUN, INTERSIL_CMD_IENABLE);
	splx(s);
d1075 1
a1075 1
#define FEBRUARY	2
d1077 3
a1079 3
#define leapyear(year)		((year) % 4 == 0)
#define days_in_year(a)		(leapyear(a) ? 366 : 365)
#define days_in_month(a)	(month_days[(a) - 1])
d1082 1
a1082 1
	31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
d1090 2
a1091 2
	register int i;
	register long days, secs;
d1093 2
a1094 2
	days = *tp / SECDAY;
	secs = *tp % SECDAY;
d1096 25
a1120 25
	/* Hours, minutes, seconds are easy */
	dt->dt_hour = secs / 3600;
	secs = secs % 3600;
	dt->dt_min  = secs / 60;
	secs = secs % 60;
	dt->dt_sec  = secs;

	/* Day of week (Note: 1/1/1970 was a Thursday) */
	dt->dt_dow = (days + 4) % 7;

	/* Number of years in days */
	i = POSIX_BASE_YEAR;
	while (days >= days_in_year(i)) {
		days -= days_in_year(i);
		i++;
	}
	dt->dt_year = i - CLOCK_BASE_YEAR;

	/* Number of months in days left */
	if (leapyear(i))
		days_in_month(FEBRUARY) = 29;
	for (i = 1; days >= days_in_month(i); i++)
		days -= days_in_month(i);
	days_in_month(FEBRUARY) = 28;
	dt->dt_month = i;
d1122 2
a1123 2
	/* Days are what is left over (+1) from all that. */
	dt->dt_day = days + 1;
d1126 1
d1132 7
a1138 3
	register int i;
	register long tmp;
	int year;
d1140 7
a1146 4
	/*
	 * Hours are different for some reason. Makes no sense really.
	 */
	tmp = 0;
a1147 6
	if (dt->dt_hour >= 24)
		goto out;
	if (dt->dt_day > 31)
		goto out;
	if (dt->dt_month > 12)
		goto out;
d1149 8
a1156 1
	year = dt->dt_year + CLOCK_BASE_YEAR;
d1158 4
a1161 13
	/*
	 * Compute days since start of time
	 * First from years, then from months.
	 */
	for (i = POSIX_BASE_YEAR; i < year; i++)
		tmp += days_in_year(i);
	if (leapyear(year) && dt->dt_month > FEBRUARY)
		tmp++;

	/* Months */
	for (i = 1; i < dt->dt_month; i++)
		tmp += days_in_month(i);
	tmp += (dt->dt_day - 1);
d1163 2
a1164 2
	/* Now do hours */
	tmp = tmp * 24 + dt->dt_hour;
d1166 2
a1167 2
	/* Now do minutes */
	tmp = tmp * 60 + dt->dt_min;
d1169 2
a1170 2
	/* Now do seconds */
	tmp = tmp * 60 + dt->dt_sec;
d1173 1
a1173 1
	*tp = tmp;
d1194 1
d1200 1
d1203 5
a1207 11
	tvp->tv_usec;
	while (tvp->tv_usec > 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
	if (tvp->tv_sec == lasttime.tv_sec &&
	    tvp->tv_usec <= lasttime.tv_usec &&
	    (tvp->tv_usec = lasttime.tv_usec + 1) > 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
a1208 1
	splx(s);
d1227 1
a1227 1
	if (cputyp != CPU_SUN4)
d1231 1
a1231 1
	if (off > sizeof(struct eeprom))
d1235 2
a1236 2
	if (cnt > sizeof(struct eeprom) - off)
		cnt = sizeof(struct eeprom) - off;
d1238 1
a1238 2
	error = eeprom_take();
	if (error != 0)
d1252 1
a1252 1
	buf = malloc(sizeof(struct eeprom), M_DEVBUF, M_WAITOK);
d1259 1
a1259 1
		for (bcnt = 0; bcnt < sizeof(struct eeprom); ++bcnt)
d1268 1
a1268 1
out:
a1296 4
	/*
	 * XXX: I'm not totally sure if this is necessary, and I don't
	 * know if there are any harmful side effects, either.
	 */
d1325 1
a1325 2
out:
	/* XXX: see above. */
d1346 1
a1346 1
out:
d1354 1
@


1.5
log
@do not worry about mapdev retval
@
text
@d261 2
a262 2
	eeprom_va = (char *)mapiodev(ra->ra_reg, 0, EEPROM_SIZE,
	    ca->ca_bustype);
@


1.4
log
@new mapdev/()/mapiodev() calling convention uses "struct rom_reg *" to supply
base plus an offset
new dvma routines
@
text
@d1 1
a1 1
/*	$NetBSD: clock.c,v 1.25 1995/10/08 11:44:59 pk Exp $ */
d207 1
a207 1
		sizeof(*i7), ca->ca_bustype);
d261 1
a261 1
	eeprom_va = (char *)mapiodev(ra->ra_reg, 0, sizeof(struct eeprom),
d327 4
a330 2
		pmap_changeprot(pmap_kernel(), (vm_offset_t)cl, VM_PROT_READ, 1);
		pmap_changeprot(pmap_kernel(), (vm_offset_t)cl + NBPG, VM_PROT_READ, 1);
d396 2
a397 3
	if ((int)mapdev(ra->ra_reg, TIMERREG_VA, 0, sizeof(struct timerreg),
	    ca->ca_bustype) != TIMERREG_VA)
		panic("unable to map timer");
@


1.3
log
@EEPROM_SIZE -> sizeof(struct eeprom)
@
text
@d206 1
a206 1
	i7 = (volatile struct intersil7170 *) mapiodev(ra->ra_paddr,
d261 1
a261 1
	eeprom_va = (char *)mapiodev(ra->ra_paddr, sizeof(struct eeprom),
d325 1
a325 1
		cl = (struct clockreg *)mapiodev(ra->ra_paddr, 2 * NBPG,
d334 1
a334 1
		cl = (struct clockreg *)mapiodev(ra->ra_paddr, sizeof *clockreg,
d394 3
a396 2
	(void)mapdev(ra->ra_paddr, TIMERREG_VA, sizeof(struct timerreg),
	    ca->ca_bustype);
@


1.2
log
@calibrate delay() on sun4; shrink non-sun4 kernels
@
text
@d1066 1
a1066 1
	if (off > EEPROM_SIZE)
d1070 2
a1071 2
	if (cnt > (EEPROM_SIZE - off))
		cnt = (EEPROM_SIZE - off);
d1073 2
a1074 1
	if ((error = eeprom_take()) != 0)
d1088 1
a1088 1
	buf = malloc(EEPROM_SIZE, M_DEVBUF, M_WAITOK);
d1095 1
a1095 1
		for (bcnt = 0; bcnt < EEPROM_SIZE; ++bcnt)
@


1.1
log
@Initial revision
@
text
@a141 3
static int	eeprom_update __P((char *, int, int));
static int	eeprom_take __P((void));
static void	eeprom_give __P((void));
d147 6
d261 2
a262 1
	eeprom_va = (char *)mapiodev(ra->ra_paddr, EEPROM_SIZE, ca->ca_bustype);
d284 1
a284 1
				       ca->ca_ra.ra_name) == 0);
d445 7
a451 6
 * Delay: wait for `about' n microseconds to pass.
 * This is easy to do on the SparcStation since we have
 * freerunning microsecond timers -- no need to guess at
 * cpu speed factors.  We just wait for it to change n times
 * (if we calculated a limit, we might overshoot, and precision
 * is irrelevant here---we want less object code).
d454 1
a454 1
	volatile register int n;
d462 2
a463 2
		/*
		 * feel free to improve this code
d465 2
a466 2
		if (cpumod == SUN4_100)
			t = 1; /* 4/100, untested */
d468 3
a470 6
			t = (cacheinfo.c_enabled) ? 3 : 1; /* 4/200 */

		while (--n >= 0) {
			for (lcv = 0 ; lcv < t ; lcv++)
				;
		}
d486 1
d823 2
a824 2
        struct date_time dt;
        long gmt;
d826 3
a828 3
        oclk_get_dt(&dt);
        dt_to_gmt(&dt, &gmt);
        return (gmt);
d835 2
a836 2
        struct date_time dt;
        long gmt;
d838 3
a840 3
        gmt = secs;
        gmt_to_dt(&gmt, &dt);
        oclk_set_dt(&dt);
d852 4
a855 2
        int s;
        register volatile char *src, *dst;
d857 3
a859 1
        src = (char *) &i7->counters;
d861 9
a869 13
        s = splhigh();
        i7->clk_cmd_reg =
                intersil_command(INTERSIL_CMD_STOP, INTERSIL_CMD_IENABLE);

        dst = (char *) dt;
        dt++;   /* end marker */
        do {
                *dst++ = *src++;
        } while (dst < (char*)dt);

        i7->clk_cmd_reg =
                intersil_command(INTERSIL_CMD_RUN, INTERSIL_CMD_IENABLE);
        splx(s);
d876 2
a877 2
        int s;
        register volatile char *src, *dst;
d879 1
a879 1
        dst = (char *) &i7->counters;
d881 13
a893 13
        s = splhigh();
        i7->clk_cmd_reg =
                intersil_command(INTERSIL_CMD_STOP, INTERSIL_CMD_IENABLE);

        src = (char *) dt;
        dt++;   /* end marker */
        do {
                *dst++ = *src++;
        } while (src < (char *)dt);

        i7->clk_cmd_reg =
                intersil_command(INTERSIL_CMD_RUN, INTERSIL_CMD_IENABLE);
        splx(s);
d905 1
a905 1
#define FEBRUARY        2
d907 3
a909 3
#define leapyear(year)          ((year) % 4 == 0)
#define days_in_year(a)         (leapyear(a) ? 366 : 365)
#define days_in_month(a)        (month_days[(a) - 1])
d912 1
a912 1
        31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
d920 2
a921 2
        register int i;
        register long days, secs;
d923 2
a924 2
        days = *tp / SECDAY;
        secs = *tp % SECDAY;
d926 25
a950 25
        /* Hours, minutes, seconds are easy */
        dt->dt_hour = secs / 3600;
        secs = secs % 3600;
        dt->dt_min  = secs / 60;
        secs = secs % 60;
        dt->dt_sec  = secs;

        /* Day of week (Note: 1/1/1970 was a Thursday) */
        dt->dt_dow = (days + 4) % 7;

        /* Number of years in days */
        i = POSIX_BASE_YEAR;
        while (days >= days_in_year(i)) {
                days -= days_in_year(i);
                i++;
        }
        dt->dt_year = i - CLOCK_BASE_YEAR;

        /* Number of months in days left */
        if (leapyear(i))
                days_in_month(FEBRUARY) = 29;
        for (i = 1; days >= days_in_month(i); i++)
                days -= days_in_month(i);
        days_in_month(FEBRUARY) = 28;
        dt->dt_month = i;
d952 2
a953 2
        /* Days are what is left over (+1) from all that. */
        dt->dt_day = days + 1;
a955 1

d961 3
a963 3
        register int i;
        register long tmp;
        int year;
d965 4
a968 3
        /*
         * Hours are different for some reason. Makes no sense really.
         */
d970 6
a975 1
        tmp = 0;
d977 1
a977 3
        if (dt->dt_hour >= 24) goto out;
        if (dt->dt_day  >  31) goto out;
        if (dt->dt_month > 12) goto out;
d979 13
a991 1
        year = dt->dt_year + CLOCK_BASE_YEAR;
d993 2
d996 2
a997 8
        /*
         * Compute days since start of time
         * First from years, then from months.
         */
        for (i = POSIX_BASE_YEAR; i < year; i++)
                tmp += days_in_year(i);
        if (leapyear(year) && dt->dt_month > FEBRUARY)
                tmp++;
d999 2
a1000 13
        /* Months */
        for (i = 1; i < dt->dt_month; i++)
                tmp += days_in_month(i);
        tmp += (dt->dt_day - 1);

        /* Now do hours */
        tmp = tmp * 24 + dt->dt_hour;

        /* Now do minutes */
        tmp = tmp * 60 + dt->dt_min;

        /* Now do seconds */
        tmp = tmp * 60 + dt->dt_sec;
d1003 1
a1003 1
        *tp = tmp;
d1103 1
a1103 1
 out:
d1113 1
a1121 1
#if defined(SUN4)
a1134 1
	 *	--thorpej
d1164 1
a1164 1
 out:
a1169 3
#else /* ! SUN4 */
	return (0);
#endif /* SUN4 */
a1175 1
#if defined(SUN4)
d1177 1
d1186 1
a1186 1
 out:
a1187 3
#else /* ! SUN4 */
	return (ENODEV);
#endif /* SUN4 */
a1193 1
#if defined(SUN4)
d1199 1
a1200 1
}
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

