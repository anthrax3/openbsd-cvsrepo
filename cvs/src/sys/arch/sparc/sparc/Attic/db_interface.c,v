head	1.17;
access;
symbols
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.4
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.13.0.18
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.14
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.12
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.10
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.8
	OPENBSD_5_0:1.13.0.6
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.4
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.12.0.18
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.20
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.16
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.14
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.12
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.10
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.8
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.6
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.10
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.8.0.10
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.8
	OPENBSD_2_8:1.8.0.6
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2016.09.01.09.23.42;	author tedu;	state dead;
branches;
next	1.16;
commitid	Q2PxaFNhqAe0Wmla;

1.16
date	2016.02.27.13.08.07;	author mpi;	state Exp;
branches;
next	1.15;
commitid	hnv9KfQtxhCytAnd;

1.15
date	2015.03.18.20.49.10;	author miod;	state Exp;
branches;
next	1.14;
commitid	rVfXNxAhtu3Za7Mc;

1.14
date	2014.07.13.12.11.01;	author jasper;	state Exp;
branches;
next	1.13;
commitid	XHZxhpAa5R1Ymp1z;

1.13
date	2010.06.29.21.28.11;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.19.21.30.20;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.13.22.25.33;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2000.01.01.19.44.24;	author deraadt;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	99.07.09.21.30.02;	author art;	state Exp;
branches;
next	1.6;

1.6
date	97.09.17.06.47.17;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.08.08.08.27.12;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	97.03.21.01.02.59;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.08.11.05.35.08;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.18.18.21.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.46;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.46;	author deraadt;	state Exp;
branches;
next	;

1.8.2.1
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2003.05.16.00.29.40;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: db_interface.c,v 1.16 2016/02/27 13:08:07 mpi Exp $	*/
/*	$NetBSD: db_interface.c,v 1.18 1997/09/01 00:16:31 pk Exp $ */

/*
 * Mach Operating System
 * Copyright (c) 1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 *
 *	From: db_interface.c,v 2.4 1991/02/05 17:11:13 mrt (CMU)
 */

/*
 * Interface to new debugger.
 */
#include <sys/param.h>
#include <sys/proc.h>
#include <sys/reboot.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>

#include <dev/cons.h>

#include <machine/autoconf.h>
#include <machine/db_machdep.h>

#include <ddb/db_access.h>
#include <ddb/db_var.h>

#if defined(DDB)
#include <ddb/db_command.h>
#include <ddb/db_sym.h>
#include <ddb/db_variables.h>
#include <ddb/db_extern.h>
#include <ddb/db_output.h>
#endif

#include <machine/bsd_openprom.h>
#include <machine/ctlreg.h>
#include <sparc/sparc/asm.h>

/*
 * Read bytes from kernel address space for debugger.
 */
void
db_read_bytes(addr, size, data)
	vaddr_t	addr;
	size_t	size;
	char	*data;
{
	char	*src;

	src = (char *)addr;
	while (size-- > 0)
		*data++ = *src++;
}

/*
 * Write bytes to kernel address space for debugger.
 */
void
db_write_bytes(addr, size, data)
	vaddr_t	addr;
	size_t	size;
	char	*data;
{
	extern char	__data_start[];
	char	*dst;

	dst = (char *)addr;
	while (size-- > 0) {
		if (dst >= (char *)KERNBASE && dst < __data_start)
			pmap_writetext(dst, *data);
		else
			*dst = *data;
		dst++, data++;
	}

}


#if defined(DDB)

/*
 * Data and functions used by DDB only.
 */
void
Debugger()
{
	asm("ta 0x81");
}

static int nil;

struct db_variable db_regs[] = {
	{ "psr", (long *)&DDB_TF->tf_psr, FCN_NULL, },
	{ "pc", (long *)&DDB_TF->tf_pc, FCN_NULL, },
	{ "npc", (long *)&DDB_TF->tf_npc, FCN_NULL, },
	{ "y", (long *)&DDB_TF->tf_y, FCN_NULL, },
	{ "wim", (long *)&DDB_TF->tf_global[0], FCN_NULL, }, /* see reg.h */
	{ "g0", (long *)&nil, FCN_NULL, },
	{ "g1", (long *)&DDB_TF->tf_global[1], FCN_NULL, },
	{ "g2", (long *)&DDB_TF->tf_global[2], FCN_NULL, },
	{ "g3", (long *)&DDB_TF->tf_global[3], FCN_NULL, },
	{ "g4", (long *)&DDB_TF->tf_global[4], FCN_NULL, },
	{ "g5", (long *)&DDB_TF->tf_global[5], FCN_NULL, },
	{ "g6", (long *)&DDB_TF->tf_global[6], FCN_NULL, },
	{ "g7", (long *)&DDB_TF->tf_global[7], FCN_NULL, },
	{ "o0", (long *)&DDB_TF->tf_out[0], FCN_NULL, },
	{ "o1", (long *)&DDB_TF->tf_out[1], FCN_NULL, },
	{ "o2", (long *)&DDB_TF->tf_out[2], FCN_NULL, },
	{ "o3", (long *)&DDB_TF->tf_out[3], FCN_NULL, },
	{ "o4", (long *)&DDB_TF->tf_out[4], FCN_NULL, },
	{ "o5", (long *)&DDB_TF->tf_out[5], FCN_NULL, },
	{ "o6", (long *)&DDB_TF->tf_out[6], FCN_NULL, },
	{ "o7", (long *)&DDB_TF->tf_out[7], FCN_NULL, },
	{ "l0", (long *)&DDB_FR->fr_local[0], FCN_NULL, },
	{ "l1", (long *)&DDB_FR->fr_local[1], FCN_NULL, },
	{ "l2", (long *)&DDB_FR->fr_local[2], FCN_NULL, },
	{ "l3", (long *)&DDB_FR->fr_local[3], FCN_NULL, },
	{ "l4", (long *)&DDB_FR->fr_local[4], FCN_NULL, },
	{ "l5", (long *)&DDB_FR->fr_local[5], FCN_NULL, },
	{ "l6", (long *)&DDB_FR->fr_local[6], FCN_NULL, },
	{ "l7", (long *)&DDB_FR->fr_local[7], FCN_NULL, },
	{ "i0", (long *)&DDB_FR->fr_arg[0], FCN_NULL, },
	{ "i1", (long *)&DDB_FR->fr_arg[1], FCN_NULL, },
	{ "i2", (long *)&DDB_FR->fr_arg[2], FCN_NULL, },
	{ "i3", (long *)&DDB_FR->fr_arg[3], FCN_NULL, },
	{ "i4", (long *)&DDB_FR->fr_arg[4], FCN_NULL, },
	{ "i5", (long *)&DDB_FR->fr_arg[5], FCN_NULL, },
	{ "i6", (long *)&DDB_FR->fr_arg[6], FCN_NULL, },
	{ "i7", (long *)&DDB_FR->fr_arg[7], FCN_NULL, },
};
struct db_variable *db_eregs = db_regs + nitems(db_regs);

extern label_t	*db_recover;

db_regs_t	ddb_regs;	/* register state */

int	db_active = 0;

extern char *trap_type[];

void kdb_kbd_trap(struct trapframe *);
void db_prom_cmd(db_expr_t, int, db_expr_t, char *);

/*
 * Received keyboard interrupt sequence.
 */
void
kdb_kbd_trap(tf)
	struct trapframe *tf;
{
	if (db_active == 0 && (boothowto & RB_KDB)) {
		printf("\n\nkernel: keyboard interrupt\n");
		db_ktrap(-1, tf);
	}
}

/*
 *  db_ktrap - field a TRACE or BPT trap
 */
int
db_ktrap(type, tf)
	int	type;
	struct trapframe *tf;
{

	fb_unblank();

	switch (type) {
	case T_BREAKPOINT:	/* breakpoint */
	case -1:		/* keyboard interrupt */
		break;
	default:
		if (!db_panic)
			return (0);

		printf("kernel: %s trap", trap_type[type & 0xff]);
		if (db_recover != 0) {
			db_error("Faulted in DDB; continuing...\n");
			/*NOTREACHED*/
		}
	}

	/* Should switch to kdb`s own stack here. */

	ddb_regs.db_tf = *tf;
	ddb_regs.db_fr = *(struct frame *)tf->tf_out[6];

	db_active++;
	cnpollc(TRUE);
	db_trap(type, 0/*code*/);
	cnpollc(FALSE);
	db_active--;

	*(struct frame *)tf->tf_out[6] = ddb_regs.db_fr;
	*tf = ddb_regs.db_tf;

	return (1);
}

void
db_prom_cmd(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	callrom();
}

struct db_command sparc_db_command_table[] = {
	{ "prom",	db_prom_cmd,	0,	0 },
	{ (char *)0, }
};

void
db_machine_init()
{
	db_machine_commands_install(sparc_db_command_table);
}
#endif /* DDB */
@


1.16
log
@Rename kdb_trap() into db_ktrap().

The goal is to include it in the list of functions that must not be
instrumented.  All ddb(8) functions should be in this list and have
their names start with 'db_'.

ok visa@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.15 2015/03/18 20:49:10 miod Exp $	*/
@


1.15
log
@Prefer KERNBASE to VM_MIN_KERNEL_ADDRESS when testing for an address within
the kernel image or not. No functional change (yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.14 2014/07/13 12:11:01 jasper Exp $	*/
d176 1
a176 1
		kdb_trap(-1, tf);
d181 1
a181 1
 *  kdb_trap - field a TRACE or BPT trap
d184 1
a184 1
kdb_trap(type, tf)
@


1.14
log
@use nitems() instead of handrolling something identical

ok mpi@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.13 2010/06/29 21:28:11 miod Exp $	*/
d92 1
a92 1
		if (dst >= (char *)VM_MIN_KERNEL_ADDRESS && dst < __data_start)
@


1.13
log
@During kernel bootstrap, stop assuming the kernel image has been loaded in
low physical memory, but instead figure out where it has been loaded from
the current MMU setup.

From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.12 2005/04/19 21:30:20 miod Exp $	*/
d154 1
a154 1
struct db_variable *db_eregs = db_regs + sizeof(db_regs)/sizeof(db_regs[0]);
@


1.12
log
@As a late birthday present, a preliminary port to the Solbourne IDT systems
(S3000, S4000 and S4000DX).

Currently limited to diskless and serial console, and userland has issues.
Things will get better in the near future.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.11 2003/05/13 22:25:33 miod Exp $	*/
d87 1
a87 1
	extern char	etext[];
d92 1
a92 1
		if ((dst >= (char *)VM_MIN_KERNEL_ADDRESS) && (dst < etext))
@


1.11
log
@Nuke a few simple commons.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.10 2002/03/14 01:26:44 millert Exp $	*/
d44 1
d230 1
a230 1
	promvec->pv_abort();
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.9 2001/11/06 19:53:16 miod Exp $	*/
a60 1

d156 2
@


1.9
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.8 2000/01/01 19:44:24 deraadt Exp $	*/
d162 2
a163 2
void kdb_kbd_trap __P((struct trapframe *));
void db_prom_cmd __P((db_expr_t, int, db_expr_t, char *));
@


1.9.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.9 2001/11/06 19:53:16 miod Exp $	*/
d162 2
a163 2
void kdb_kbd_trap(struct trapframe *);
void db_prom_cmd(db_expr_t, int, db_expr_t, char *);
@


1.9.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d61 1
a156 2

db_regs_t	ddb_regs;	/* register state */
@


1.8
log
@check db_panic in kdb_trap() as well; similar to i386 fix from assar
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.7 1999/07/09 21:30:02 art Exp $	*/
d40 1
a40 1
#include <vm/vm.h>
@


1.8.2.1
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d40 1
a40 1
#include <uvm/uvm_extern.h>
@


1.8.2.2
log
@Merge in -current from about a week ago
@
text
@d162 2
a163 2
void kdb_kbd_trap(struct trapframe *);
void db_prom_cmd(db_expr_t, int, db_expr_t, char *);
@


1.8.2.3
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d61 1
a156 2

db_regs_t	ddb_regs;	/* register state */
@


1.7
log
@vm_offset_t -> {v,p}addr_t and vm_size_t -> {v,p}size_t
remove "register" keywords
Various cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.6 1997/09/17 06:47:17 downsj Exp $	*/
d47 1
d194 3
@


1.6
log
@NETBSD_CURRENT_970916.  Lot's just ID changes, since changes don't apply to
us.  Includes some pmap changes, for which I don't have the original commit
message(s) handy.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.5 1997/08/08 08:27:12 downsj Exp $	*/
d66 3
a68 3
	vm_offset_t	addr;
	register size_t	size;
	register char	*data;
d70 1
a70 1
	register char	*src;
d82 3
a84 3
	vm_offset_t	addr;
	register size_t	size;
	register char	*data;
d87 1
a87 1
	register char	*dst;
d183 1
a183 1
	register struct trapframe *tf;
@


1.5
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: db_interface.c,v 1.15 1997/02/05 00:01:50 pk Exp $ */
d45 4
a52 1
#include <ddb/db_access.h>
d54 2
d60 52
a161 1
static void db_write_text __P((unsigned char *, int));
d202 2
a203 2
	ddb_regs.ddb_tf = *tf;
	ddb_regs.ddb_fr = *(struct frame *)tf->tf_out[6];
d211 2
a212 2
	*(struct frame *)tf->tf_out[6] = ddb_regs.ddb_fr;
	*tf = ddb_regs.ddb_tf;
a216 120
/*
 * Read bytes from kernel address space for debugger.
 */
void
db_read_bytes(addr, size, data)
	vm_offset_t	addr;
	register size_t	size;
	register char	*data;
{
	register char	*src;

	src = (char *)addr;
	while (size-- > 0)
		*data++ = *src++;
}


/*
 * XXX - stolen from pmap.c
 */
#if defined(SUN4M)
#define getpte4m(va)		lda((va & 0xFFFFF000) | ASI_SRMMUFP_L3, \
				    ASI_SRMMUFP)
void	setpte4m __P((vm_offset_t va, int pte));

#endif
#define	getpte4(va)		lda(va, ASI_PTE)
#define	setpte4(va, pte)	sta(va, ASI_PTE, pte)
#if defined(SUN4M) && !(defined(SUN4C) || defined(SUN4))
#define getpte			getpte4m
#define setpte 			setpte4m
#elif defined(SUN4M)
#define getpte(va) 		(cputyp==CPU_SUN4M ? getpte4m(va) : getpte4(va))
#define setpte(va, pte)		(cputyp==CPU_SUN4M ? setpte4m(va, pte) \
				    : setpte4(va,pte))
#else
#define getpte 			getpte4
#define setpte 			setpte4
#endif

#define	splpmap() splimp()

static void
db_write_text(dst, ch)
	unsigned char *dst;
	int ch;
{
	int s, pte0, pte;
	vm_offset_t va;

	s = splpmap();
	va = (unsigned long)dst & (~PGOFSET);
	pte0 = getpte(va);

#if defined(SUN4M)
#if defined(SUN4) || defined(SUN4C)
	if (cputyp == CPU_SUN4M) {
#endif
	if ((pte0 & SRMMU_TETYPE) != SRMMU_TEPTE) {
		db_printf(" address %p not a valid page\n", dst);
		splx(s);
		return;
	}

	pte = pte0 | PPROT_WRITE;
	setpte(va, pte);

#if defined(SUN4) || defined(SUN4C)
	} else {
#endif
#endif /* 4m */
#if defined(SUN4) || defined(SUN4C)
	if ((pte0 & PG_V) == 0) {
		db_printf(" address %p not a valid page\n", dst);
		splx(s);
		return;
	}

	pte = pte0 | PG_W;
	setpte(va, pte);
#if defined(SUN4M)
	}
#endif
#endif /* 4/4c */

	*dst = (unsigned char)ch;

	setpte(va, pte0);
	splx(s);
}

/*
 * Write bytes to kernel address space for debugger.
 */
void
db_write_bytes(addr, size, data)
	vm_offset_t	addr;
	register size_t	size;
	register char	*data;
{
	extern char	etext[];
	register char	*dst;

	dst = (char *)addr;
	while (size-- > 0) {
		if ((dst >= (char *)VM_MIN_KERNEL_ADDRESS) && (dst < etext))
			db_write_text(dst, *data);
		else
			*dst = *data;
		dst++, data++;
	}

}

void
Debugger()
{
	asm("ta 0x81");
}

d237 1
@


1.4
log
@Make ddb variables long
@
text
@d1 2
a2 1
/*	$NetBSD: db_interface.c,v 1.12 1996/05/18 12:27:45 mrg Exp $ */
@


1.3
log
@netbsd port, now we merge our changes back in
@
text
@d57 37
a93 37
	{ "psr", (int *)&DDB_TF->tf_psr, FCN_NULL, },
	{ "pc", (int *)&DDB_TF->tf_pc, FCN_NULL, },
	{ "npc", (int *)&DDB_TF->tf_npc, FCN_NULL, },
	{ "y", (int *)&DDB_TF->tf_y, FCN_NULL, },
	{ "wim", (int *)&DDB_TF->tf_global[0], FCN_NULL, }, /* see reg.h */
	{ "g0", (int *)&nil, FCN_NULL, },
	{ "g1", (int *)&DDB_TF->tf_global[1], FCN_NULL, },
	{ "g2", (int *)&DDB_TF->tf_global[2], FCN_NULL, },
	{ "g3", (int *)&DDB_TF->tf_global[3], FCN_NULL, },
	{ "g4", (int *)&DDB_TF->tf_global[4], FCN_NULL, },
	{ "g5", (int *)&DDB_TF->tf_global[5], FCN_NULL, },
	{ "g6", (int *)&DDB_TF->tf_global[6], FCN_NULL, },
	{ "g7", (int *)&DDB_TF->tf_global[7], FCN_NULL, },
	{ "o0", (int *)&DDB_TF->tf_out[0], FCN_NULL, },
	{ "o1", (int *)&DDB_TF->tf_out[1], FCN_NULL, },
	{ "o2", (int *)&DDB_TF->tf_out[2], FCN_NULL, },
	{ "o3", (int *)&DDB_TF->tf_out[3], FCN_NULL, },
	{ "o4", (int *)&DDB_TF->tf_out[4], FCN_NULL, },
	{ "o5", (int *)&DDB_TF->tf_out[5], FCN_NULL, },
	{ "o6", (int *)&DDB_TF->tf_out[6], FCN_NULL, },
	{ "o7", (int *)&DDB_TF->tf_out[7], FCN_NULL, },
	{ "l0", (int *)&DDB_FR->fr_local[0], FCN_NULL, },
	{ "l1", (int *)&DDB_FR->fr_local[1], FCN_NULL, },
	{ "l2", (int *)&DDB_FR->fr_local[2], FCN_NULL, },
	{ "l3", (int *)&DDB_FR->fr_local[3], FCN_NULL, },
	{ "l4", (int *)&DDB_FR->fr_local[4], FCN_NULL, },
	{ "l5", (int *)&DDB_FR->fr_local[5], FCN_NULL, },
	{ "l6", (int *)&DDB_FR->fr_local[6], FCN_NULL, },
	{ "l7", (int *)&DDB_FR->fr_local[7], FCN_NULL, },
	{ "i0", (int *)&DDB_FR->fr_arg[0], FCN_NULL, },
	{ "i1", (int *)&DDB_FR->fr_arg[1], FCN_NULL, },
	{ "i2", (int *)&DDB_FR->fr_arg[2], FCN_NULL, },
	{ "i3", (int *)&DDB_FR->fr_arg[3], FCN_NULL, },
	{ "i4", (int *)&DDB_FR->fr_arg[4], FCN_NULL, },
	{ "i5", (int *)&DDB_FR->fr_arg[5], FCN_NULL, },
	{ "i6", (int *)&DDB_FR->fr_arg[6], FCN_NULL, },
	{ "i7", (int *)&DDB_FR->fr_arg[7], FCN_NULL, },
@


1.2
log
@use pmap functions instead of getpte/setpte hacks
@
text
@d1 1
a1 1
/*	$NetBSD: db_interface.c,v 1.6 1995/04/09 11:51:10 pk Exp $ */
d3 1
a3 1
/* 
d7 1
a7 1
 * 
d13 2
a14 2
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS 
d17 1
a17 1
 * 
d19 1
a19 1
 * 
d24 1
a24 1
 * 
d37 1
a37 2
#include <sys/systm.h> /* just for boothowto --eichin */
#include <setjmp.h>
d41 2
d45 1
d47 3
d97 1
a97 1
extern jmp_buf	*db_recover;
d103 4
d110 1
d116 1
a116 1
		kdb_trap(-1, 0, tf);
d123 1
d166 1
a166 1
	register int	size;
d172 1
a172 1
	while (--size >= 0)
d177 23
d206 2
a207 1
{        
a208 1
	int s;
d212 1
d214 6
a219 2
	if (pmap_extract(pmap_kernel(), va) == 0) {
		db_printf(" address 0x%x not a valid page\n", dst);
d224 21
a244 1
	pmap_changeprot(pmap_kernel(), va, VM_PROT_ALL, 0);
a245 1
	pmap_protect(pmap_kernel(), va, va, VM_PROT_READ|VM_PROT_EXECUTE);
d247 1
d257 1
a257 1
	register int	size;
d264 1
a264 1
	while (--size >= 0) {
d274 1
a274 1
int
d281 5
a285 1
db_prom_cmd()
a286 1
	extern struct promvec *promvec;
@


1.1
log
@Initial revision
@
text
@a165 5
/*
 * XXX - stolen from pmap.c
 */
#define	getpte(va)		lda(va, ASI_PTE)
#define	setpte(va, pte)		sta(va, ASI_PTE, pte)
a172 1
	int s, pte0, pte;
d174 1
a177 1
	pte0 = getpte(va);
d179 1
a179 1
	if ((pte0 & PG_V) == 0) { 
d185 1
a185 3
	pte = pte0 | PG_W;
	setpte(va, pte);

d187 1
a188 1
	setpte(va, pte0);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
