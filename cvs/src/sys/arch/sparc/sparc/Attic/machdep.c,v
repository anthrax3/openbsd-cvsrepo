head	1.180;
access;
symbols
	OPENBSD_6_0:1.179.0.2
	OPENBSD_6_0_BASE:1.179
	OPENBSD_5_9:1.175.0.2
	OPENBSD_5_9_BASE:1.175
	OPENBSD_5_8:1.172.0.4
	OPENBSD_5_8_BASE:1.172
	OPENBSD_5_7:1.168.0.2
	OPENBSD_5_7_BASE:1.168
	OPENBSD_5_6:1.164.0.4
	OPENBSD_5_6_BASE:1.164
	OPENBSD_5_5:1.147.0.4
	OPENBSD_5_5_BASE:1.147
	OPENBSD_5_4:1.146.0.2
	OPENBSD_5_4_BASE:1.146
	OPENBSD_5_3:1.145.0.2
	OPENBSD_5_3_BASE:1.145
	OPENBSD_5_2:1.138.0.2
	OPENBSD_5_2_BASE:1.138
	OPENBSD_5_1_BASE:1.137
	OPENBSD_5_1:1.137.0.4
	OPENBSD_5_0:1.137.0.2
	OPENBSD_5_0_BASE:1.137
	OPENBSD_4_9:1.131.0.2
	OPENBSD_4_9_BASE:1.131
	OPENBSD_4_8:1.130.0.2
	OPENBSD_4_8_BASE:1.130
	OPENBSD_4_7:1.124.0.2
	OPENBSD_4_7_BASE:1.124
	OPENBSD_4_6:1.118.0.4
	OPENBSD_4_6_BASE:1.118
	OPENBSD_4_5:1.116.0.4
	OPENBSD_4_5_BASE:1.116
	OPENBSD_4_4:1.116.0.2
	OPENBSD_4_4_BASE:1.116
	OPENBSD_4_3:1.114.0.2
	OPENBSD_4_3_BASE:1.114
	OPENBSD_4_2:1.113.0.2
	OPENBSD_4_2_BASE:1.113
	OPENBSD_4_1:1.109.0.4
	OPENBSD_4_1_BASE:1.109
	OPENBSD_4_0:1.109.0.2
	OPENBSD_4_0_BASE:1.109
	OPENBSD_3_9:1.107.0.2
	OPENBSD_3_9_BASE:1.107
	OPENBSD_3_8:1.106.0.2
	OPENBSD_3_8_BASE:1.106
	OPENBSD_3_7:1.102.0.2
	OPENBSD_3_7_BASE:1.102
	OPENBSD_3_6:1.101.0.2
	OPENBSD_3_6_BASE:1.101
	SMP_SYNC_A:1.100
	SMP_SYNC_B:1.100
	OPENBSD_3_5:1.98.0.2
	OPENBSD_3_5_BASE:1.98
	OPENBSD_3_4:1.93.0.2
	OPENBSD_3_4_BASE:1.93
	UBC_SYNC_A:1.91
	OPENBSD_3_3:1.91.0.2
	OPENBSD_3_3_BASE:1.91
	OPENBSD_3_2:1.85.0.2
	OPENBSD_3_2_BASE:1.85
	OPENBSD_3_1:1.82.0.2
	OPENBSD_3_1_BASE:1.82
	UBC_SYNC_B:1.86
	UBC:1.74.0.2
	UBC_BASE:1.74
	OPENBSD_3_0:1.65.0.2
	OPENBSD_3_0_BASE:1.65
	OPENBSD_2_9_BASE:1.52
	OPENBSD_2_9:1.52.0.2
	OPENBSD_2_8:1.51.0.2
	OPENBSD_2_8_BASE:1.51
	OPENBSD_2_7:1.48.0.2
	OPENBSD_2_7_BASE:1.48
	SMP:1.43.0.2
	SMP_BASE:1.43
	kame_19991208:1.43
	OPENBSD_2_6:1.41.0.2
	OPENBSD_2_6_BASE:1.41
	OPENBSD_2_5:1.34.0.2
	OPENBSD_2_5_BASE:1.34
	OPENBSD_2_4:1.33.0.4
	OPENBSD_2_4_BASE:1.33
	OPENBSD_2_3:1.33.0.2
	OPENBSD_2_3_BASE:1.33
	OPENBSD_2_2:1.29.0.2
	OPENBSD_2_2_BASE:1.29
	OPENBSD_2_1:1.21.0.2
	OPENBSD_2_1_BASE:1.21
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.180
date	2016.09.01.09.23.42;	author tedu;	state dead;
branches;
next	1.179;
commitid	Q2PxaFNhqAe0Wmla;

1.179
date	2016.07.16.08.53.38;	author tom;	state Exp;
branches;
next	1.178;
commitid	k7UhQ5FCwMJC7iLG;

1.178
date	2016.05.21.00.56.44;	author deraadt;	state Exp;
branches;
next	1.177;
commitid	oWpLaBOdDMvIxei3;

1.177
date	2016.05.11.20.21.26;	author phessler;	state Exp;
branches;
next	1.176;
commitid	xXtUNnLBMPtTMIWM;

1.176
date	2016.05.10.18.39.48;	author deraadt;	state Exp;
branches;
next	1.175;
commitid	qfOifNidEGDB2jL1;

1.175
date	2015.10.21.07.59.18;	author mpi;	state Exp;
branches;
next	1.174;
commitid	XglPgGQ8qaiL0M4l;

1.174
date	2015.09.18.12.50.28;	author miod;	state Exp;
branches;
next	1.173;
commitid	aBaVLnMs8wxyaAGJ;

1.173
date	2015.09.08.10.21.16;	author deraadt;	state Exp;
branches;
next	1.172;
commitid	DGOx6p2gOlciIkZ2;

1.172
date	2015.06.02.04.31.53;	author miod;	state Exp;
branches;
next	1.171;
commitid	PhNpsU2zqVxSFdZa;

1.171
date	2015.03.30.20.30.22;	author miod;	state Exp;
branches;
next	1.170;
commitid	f66FukLLgPJs9j5H;

1.170
date	2015.03.27.20.25.39;	author miod;	state Exp;
branches;
next	1.169;
commitid	DNjbblqLgBZmk6yi;

1.169
date	2015.03.18.20.56.40;	author miod;	state Exp;
branches;
next	1.168;
commitid	1t8JWNihm6Vc4kyS;

1.168
date	2015.02.09.11.52.47;	author miod;	state Exp;
branches;
next	1.167;
commitid	3LyovzkL8t513Pbn;

1.167
date	2014.12.10.15.29.53;	author mikeb;	state Exp;
branches;
next	1.166;
commitid	qHQiR2HLROzvZr7B;

1.166
date	2014.11.16.12.30.58;	author deraadt;	state Exp;
branches;
next	1.165;
commitid	yv0ECmCdICvq576h;

1.165
date	2014.09.20.09.28.24;	author kettenis;	state Exp;
branches;
next	1.164;
commitid	IFRB8AkvBMXMTAKW;

1.164
date	2014.07.21.17.25.47;	author uebayasi;	state Exp;
branches;
next	1.163;
commitid	7QO4UJr3EKVAMc8t;

1.163
date	2014.07.13.22.53.39;	author uebayasi;	state Exp;
branches;
next	1.162;
commitid	wsdp3qtXGjMj98oD;

1.162
date	2014.07.13.22.13.07;	author uebayasi;	state Exp;
branches;
next	1.161;
commitid	qYPOd6Qi4aRBKldK;

1.161
date	2014.07.12.18.44.43;	author tedu;	state Exp;
branches;
next	1.160;
commitid	uKVPYMN2MLxdZxzH;

1.160
date	2014.07.11.22.28.06;	author uebayasi;	state Exp;
branches;
next	1.159;
commitid	fOXKrBuMmlMGQdd4;

1.159
date	2014.07.11.09.36.26;	author mpi;	state Exp;
branches;
next	1.158;
commitid	vsYjSRfS3Y783BvW;

1.158
date	2014.07.10.21.46.03;	author mpi;	state Exp;
branches;
next	1.157;
commitid	iYq3Z1ZWDKR3sS9G;

1.157
date	2014.07.10.20.15.27;	author uebayasi;	state Exp;
branches;
next	1.156;
commitid	YzvTa4t6mddz7Mh4;

1.156
date	2014.07.10.13.34.32;	author uebayasi;	state Exp;
branches;
next	1.155;
commitid	xpsLTYRIkonFtkr1;

1.155
date	2014.07.10.12.13.49;	author uebayasi;	state Exp;
branches;
next	1.154;
commitid	aofvn6ceiucgjg4N;

1.154
date	2014.05.31.15.49.28;	author mpi;	state Exp;
branches;
next	1.153;
commitid	eA4Y0YE1IUzj6hpW;

1.153
date	2014.05.30.13.46.16;	author mpi;	state Exp;
branches;
next	1.152;

1.152
date	2014.05.25.13.57.48;	author deraadt;	state Exp;
branches;
next	1.151;

1.151
date	2014.05.09.20.15.06;	author miod;	state Exp;
branches;
next	1.150;

1.150
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.149;

1.149
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.148;

1.148
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.147;

1.147
date	2013.09.28.12.40.32;	author miod;	state Exp;
branches;
next	1.146;

1.146
date	2013.06.11.16.42.11;	author deraadt;	state Exp;
branches;
next	1.145;

1.145
date	2013.02.17.17.36.49;	author kettenis;	state Exp;
branches;
next	1.144;

1.144
date	2012.12.02.07.03.31;	author guenther;	state Exp;
branches;
next	1.143;

1.143
date	2012.11.05.13.20.16;	author miod;	state Exp;
branches;
next	1.142;

1.142
date	2012.10.22.17.28.27;	author kettenis;	state Exp;
branches;
next	1.141;

1.141
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.140;

1.140
date	2012.08.22.13.33.32;	author okan;	state Exp;
branches;
next	1.139;

1.139
date	2012.08.21.14.44.24;	author jsg;	state Exp;
branches;
next	1.138;

1.138
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.137;

1.137
date	2011.07.05.04.48.02;	author guenther;	state Exp;
branches;
next	1.136;

1.136
date	2011.06.26.22.40.00;	author deraadt;	state Exp;
branches;
next	1.135;

1.135
date	2011.06.05.19.41.08;	author deraadt;	state Exp;
branches;
next	1.134;

1.134
date	2011.04.18.21.44.55;	author guenther;	state Exp;
branches;
next	1.133;

1.133
date	2011.04.15.04.52.40;	author guenther;	state Exp;
branches;
next	1.132;

1.132
date	2011.04.07.15.30.16;	author miod;	state Exp;
branches;
next	1.131;

1.131
date	2010.11.27.19.41.48;	author miod;	state Exp;
branches;
next	1.130;

1.130
date	2010.07.02.19.57.15;	author tedu;	state Exp;
branches;
next	1.129;

1.129
date	2010.07.02.04.14.19;	author miod;	state Exp;
branches;
next	1.128;

1.128
date	2010.06.29.21.28.11;	author miod;	state Exp;
branches;
next	1.127;

1.127
date	2010.06.29.21.26.12;	author miod;	state Exp;
branches;
next	1.126;

1.126
date	2010.06.27.13.28.47;	author miod;	state Exp;
branches;
next	1.125;

1.125
date	2010.06.27.03.03.48;	author thib;	state Exp;
branches;
next	1.124;

1.124
date	2009.08.29.15.27.33;	author kettenis;	state Exp;
branches;
next	1.123;

1.123
date	2009.08.11.19.17.17;	author miod;	state Exp;
branches;
next	1.122;

1.122
date	2009.08.11.18.46.32;	author miod;	state Exp;
branches;
next	1.121;

1.121
date	2009.08.09.10.40.18;	author blambert;	state Exp;
branches;
next	1.120;

1.120
date	2009.08.02.16.28.39;	author beck;	state Exp;
branches;
next	1.119;

1.119
date	2009.07.13.19.50.00;	author kettenis;	state Exp;
branches;
next	1.118;

1.118
date	2009.06.15.17.01.26;	author beck;	state Exp;
branches;
next	1.117;

1.117
date	2009.06.03.21.30.20;	author beck;	state Exp;
branches;
next	1.116;

1.116
date	2008.06.27.17.22.15;	author miod;	state Exp;
branches;
next	1.115;

1.115
date	2008.04.09.16.58.10;	author deraadt;	state Exp;
branches;
next	1.114;

1.114
date	2007.11.28.16.33.20;	author martin;	state Exp;
branches;
next	1.113;

1.113
date	2007.06.06.17.15.12;	author deraadt;	state Exp;
branches;
next	1.112;

1.112
date	2007.05.29.20.36.48;	author deraadt;	state Exp;
branches;
next	1.111;

1.111
date	2007.05.26.20.26.51;	author pedro;	state Exp;
branches;
next	1.110;

1.110
date	2007.05.23.20.33.47;	author pvalchev;	state Exp;
branches;
next	1.109;

1.109
date	2006.06.29.17.53.35;	author miod;	state Exp;
branches;
next	1.108;

1.108
date	2006.06.09.06.41.44;	author miod;	state Exp;
branches;
next	1.107;

1.107
date	2005.09.25.20.04.03;	author miod;	state Exp;
branches;
next	1.106;

1.106
date	2005.08.18.18.40.51;	author kettenis;	state Exp;
branches;
next	1.105;

1.105
date	2005.04.11.15.13.01;	author deraadt;	state Exp;
branches;
next	1.104;

1.104
date	2005.03.23.17.14.46;	author miod;	state Exp;
branches;
next	1.103;

1.103
date	2005.03.23.17.12.26;	author miod;	state Exp;
branches;
next	1.102;

1.102
date	2004.09.29.07.35.14;	author miod;	state Exp;
branches;
next	1.101;

1.101
date	2004.07.06.21.05.36;	author deraadt;	state Exp;
branches;
next	1.100;

1.100
date	2004.05.30.21.52.49;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	2004.05.23.02.59.05;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	2004.03.10.23.02.54;	author tom;	state Exp;
branches;
next	1.97;

1.97
date	2004.02.19.18.46.18;	author miod;	state Exp;
branches;
next	1.96;

1.96
date	2003.12.20.00.49.46;	author miod;	state Exp;
branches;
next	1.95;

1.95
date	2003.12.18.23.38.46;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2003.12.17.22.05.09;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2003.06.02.23.27.55;	author millert;	state Exp;
branches;
next	1.92;

1.92
date	2003.06.02.00.01.27;	author art;	state Exp;
branches;
next	1.91;

1.91
date	2003.01.09.22.27.10;	author miod;	state Exp;
branches;
next	1.90;

1.90
date	2002.12.17.23.11.32;	author millert;	state Exp;
branches;
next	1.89;

1.89
date	2002.11.22.23.08.49;	author deraadt;	state Exp;
branches;
next	1.88;

1.88
date	2002.11.10.21.23.09;	author miod;	state Exp;
branches;
next	1.87;

1.87
date	2002.11.07.04.39.14;	author art;	state Exp;
branches;
next	1.86;

1.86
date	2002.10.24.19.37.00;	author fgsch;	state Exp;
branches;
next	1.85;

1.85
date	2002.08.12.16.35.40;	author miod;	state Exp;
branches;
next	1.84;

1.84
date	2002.07.20.19.24.56;	author art;	state Exp;
branches;
next	1.83;

1.83
date	2002.06.14.04.16.06;	author art;	state Exp;
branches;
next	1.82;

1.82
date	2002.03.23.13.28.34;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.80;

1.80
date	2002.02.20.22.28.23;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2002.02.17.22.59.53;	author maja;	state Exp;
branches;
next	1.78;

1.78
date	2002.01.23.17.51.52;	author art;	state Exp;
branches;
next	1.77;

1.77
date	2002.01.23.17.35.56;	author art;	state Exp;
branches;
next	1.76;

1.76
date	2002.01.16.20.50.17;	author miod;	state Exp;
branches;
next	1.75;

1.75
date	2001.12.19.08.58.05;	author art;	state Exp;
branches;
next	1.74;

1.74
date	2001.12.08.02.24.07;	author art;	state Exp;
branches
	1.74.2.1;
next	1.73;

1.73
date	2001.11.28.16.13.29;	author art;	state Exp;
branches;
next	1.72;

1.72
date	2001.11.28.13.47.39;	author art;	state Exp;
branches;
next	1.71;

1.71
date	2001.11.24.17.53.41;	author miod;	state Exp;
branches;
next	1.70;

1.70
date	2001.11.22.09.49.43;	author art;	state Exp;
branches;
next	1.69;

1.69
date	2001.11.22.09.23.51;	author art;	state Exp;
branches;
next	1.68;

1.68
date	2001.11.09.15.25.55;	author art;	state Exp;
branches;
next	1.67;

1.67
date	2001.11.07.01.18.00;	author art;	state Exp;
branches;
next	1.66;

1.66
date	2001.11.06.02.49.22;	author art;	state Exp;
branches;
next	1.65;

1.65
date	2001.09.19.20.50.57;	author mickey;	state Exp;
branches;
next	1.64;

1.64
date	2001.09.17.15.18.16;	author art;	state Exp;
branches;
next	1.63;

1.63
date	2001.09.12.00.23.34;	author art;	state Exp;
branches;
next	1.62;

1.62
date	2001.08.23.14.01.03;	author art;	state Exp;
branches;
next	1.61;

1.61
date	2001.08.23.12.02.05;	author art;	state Exp;
branches;
next	1.60;

1.60
date	2001.07.25.13.25.33;	author art;	state Exp;
branches;
next	1.59;

1.59
date	2001.06.25.00.43.16;	author mickey;	state Exp;
branches;
next	1.58;

1.58
date	2001.05.17.18.41.50;	author provos;	state Exp;
branches;
next	1.57;

1.57
date	2001.05.10.10.34.47;	author art;	state Exp;
branches;
next	1.56;

1.56
date	2001.05.05.22.34.19;	author art;	state Exp;
branches;
next	1.55;

1.55
date	2001.05.05.21.26.41;	author art;	state Exp;
branches;
next	1.54;

1.54
date	2001.05.05.20.56.52;	author art;	state Exp;
branches;
next	1.53;

1.53
date	2001.04.30.16.42.26;	author art;	state Exp;
branches;
next	1.52;

1.52
date	2000.11.07.11.25.24;	author art;	state Exp;
branches;
next	1.51;

1.51
date	2000.10.27.00.16.20;	author mickey;	state Exp;
branches;
next	1.50;

1.50
date	2000.06.23.00.55.55;	author fgsch;	state Exp;
branches;
next	1.49;

1.49
date	2000.05.18.13.31.12;	author jason;	state Exp;
branches;
next	1.48;

1.48
date	2000.03.23.09.59.56;	author art;	state Exp;
branches;
next	1.47;

1.47
date	2000.03.16.22.11.02;	author art;	state Exp;
branches;
next	1.46;

1.46
date	2000.02.22.19.28.01;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2000.02.21.21.05.59;	author art;	state Exp;
branches;
next	1.44;

1.44
date	2000.02.15.16.32.41;	author art;	state Exp;
branches;
next	1.43;

1.43
date	99.11.26.16.21.01;	author art;	state Exp;
branches
	1.43.2.1;
next	1.42;

1.42
date	99.10.29.14.36.02;	author art;	state Exp;
branches;
next	1.41;

1.41
date	99.09.07.03.42.48;	author jason;	state Exp;
branches;
next	1.40;

1.40
date	99.09.03.18.01.58;	author art;	state Exp;
branches;
next	1.39;

1.39
date	99.08.24.09.54.55;	author art;	state Exp;
branches;
next	1.38;

1.38
date	99.07.23.19.11.28;	author jason;	state Exp;
branches;
next	1.37;

1.37
date	99.07.09.21.30.02;	author art;	state Exp;
branches;
next	1.36;

1.36
date	99.05.22.21.22.30;	author weingart;	state Exp;
branches;
next	1.35;

1.35
date	99.04.22.18.51.49;	author art;	state Exp;
branches;
next	1.34;

1.34
date	99.03.01.04.56.05;	author jason;	state Exp;
branches;
next	1.33;

1.33
date	98.03.25.07.54.59;	author jason;	state Exp;
branches;
next	1.32;

1.32
date	98.03.01.09.24.28;	author johns;	state Exp;
branches;
next	1.31;

1.31
date	98.02.26.10.39.04;	author johns;	state Exp;
branches;
next	1.30;

1.30
date	98.02.26.08.00.19;	author jason;	state Exp;
branches;
next	1.29;

1.29
date	97.09.17.06.47.20;	author downsj;	state Exp;
branches;
next	1.28;

1.28
date	97.08.25.08.38.48;	author downsj;	state Exp;
branches;
next	1.27;

1.27
date	97.08.08.08.27.30;	author downsj;	state Exp;
branches;
next	1.26;

1.26
date	97.07.01.21.32.02;	author grr;	state Exp;
branches;
next	1.25;

1.25
date	97.06.25.13.22.25;	author downsj;	state Exp;
branches;
next	1.24;

1.24
date	97.06.22.23.54.24;	author downsj;	state Exp;
branches;
next	1.23;

1.23
date	97.06.22.22.33.53;	author downsj;	state Exp;
branches;
next	1.22;

1.22
date	97.06.11.10.32.11;	author grr;	state Exp;
branches;
next	1.21;

1.21
date	97.03.26.22.14.41;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	97.02.23.20.47.25;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.02.05.14.28.57;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.02.04.17.23.40;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.02.03.15.05.13;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.02.03.12.49.03;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.02.01.23.05.07;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.02.01.11.02.11;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.01.27.22.48.24;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.01.17.05.53.40;	author kstailey;	state Exp;
branches;
next	1.11;

1.11
date	96.12.20.15.59.12;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.12.14.15.37.16;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.08.11.05.35.18;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.01.13.03.12.12;	author chuck;	state Exp;
branches;
next	1.7;

1.7
date	96.01.12.21.21.54;	author chuck;	state Exp;
branches;
next	1.6;

1.6
date	96.01.05.16.18.15;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	95.12.15.13.56.47;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.11.14.13.24.58;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.10.21.13.36.41;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.18.16.54.12;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.47;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.47;	author deraadt;	state Exp;
branches;
next	;

1.43.2.1
date	2000.02.20.11.56.54;	author niklas;	state Exp;
branches;
next	1.43.2.2;

1.43.2.2
date	2000.02.21.22.29.04;	author niklas;	state Exp;
branches;
next	1.43.2.3;

1.43.2.3
date	2000.03.02.07.04.34;	author niklas;	state Exp;
branches;
next	1.43.2.4;

1.43.2.4
date	2000.03.24.09.08.50;	author niklas;	state Exp;
branches;
next	1.43.2.5;

1.43.2.5
date	2001.05.14.21.37.17;	author niklas;	state Exp;
branches;
next	1.43.2.6;

1.43.2.6
date	2001.07.04.10.23.45;	author niklas;	state Exp;
branches;
next	1.43.2.7;

1.43.2.7
date	2001.10.31.03.07.57;	author nate;	state Exp;
branches;
next	1.43.2.8;

1.43.2.8
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.43.2.9;

1.43.2.9
date	2001.12.05.00.39.13;	author niklas;	state Exp;
branches;
next	1.43.2.10;

1.43.2.10
date	2002.03.06.02.04.46;	author niklas;	state Exp;
branches;
next	1.43.2.11;

1.43.2.11
date	2002.03.28.10.57.11;	author niklas;	state Exp;
branches;
next	1.43.2.12;

1.43.2.12
date	2003.03.27.23.49.26;	author niklas;	state Exp;
branches;
next	1.43.2.13;

1.43.2.13
date	2003.06.07.11.14.44;	author ho;	state Exp;
branches;
next	1.43.2.14;

1.43.2.14
date	2004.02.19.10.49.58;	author niklas;	state Exp;
branches;
next	1.43.2.15;

1.43.2.15
date	2004.06.05.23.10.58;	author niklas;	state Exp;
branches;
next	;

1.74.2.1
date	2002.01.31.22.55.23;	author niklas;	state Exp;
branches;
next	1.74.2.2;

1.74.2.2
date	2002.06.11.03.38.17;	author art;	state Exp;
branches;
next	1.74.2.3;

1.74.2.3
date	2002.10.29.00.28.10;	author art;	state Exp;
branches;
next	1.74.2.4;

1.74.2.4
date	2003.05.19.21.46.33;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.180
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: machdep.c,v 1.179 2016/07/16 08:53:38 tom Exp $	*/
/*	$NetBSD: machdep.c,v 1.85 1997/09/12 08:55:02 pk Exp $ */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)machdep.c	8.6 (Berkeley) 1/14/94
 */

#include <sys/param.h>
#include <sys/signal.h>
#include <sys/signalvar.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/reboot.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/timeout.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/mount.h>
#include <sys/msgbuf.h>
#include <sys/syscallargs.h>
#include <sys/exec.h>
#include <sys/sysctl.h>
#include <sys/extent.h>

#include <net/if.h>
#include <uvm/uvm.h>

#include <dev/rndvar.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/frame.h>
#include <machine/cpu.h>
#include <machine/pmap.h>
#include <machine/vmparam.h>
#include <machine/oldmon.h>
#include <machine/bsd_openprom.h>

#include <sparc/sparc/asm.h>
#include <sparc/sparc/cache.h>
#include <sparc/sparc/vaddrs.h>
#include <sparc/sparc/cpuvar.h>

#ifdef SUN4M
#include "power.h"
#if NPOWER > 0
#include <sparc/dev/power.h>
#endif
#include "scf.h"
#include "tctrl.h"
#if NTCTRL > 0
#include <sparc/dev/tctrlvar.h>
#endif
#endif

#include "auxreg.h"

#ifdef SUN4
#include <sparc/dev/led.h>
#include "led.h"
#endif

vaddr_t vm_pie_max_addr = 0;

struct vm_map *exec_map = NULL;

struct uvm_constraint_range  dma_constraint = { 0x0, (paddr_t)-1 }; 
struct uvm_constraint_range *uvm_md_constraints[] = { NULL };

int	physmem;

/* sysctl settable */
int	sparc_led_blink = 1;

/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int	safepri = 0;

void	dumpsys(void);
void	stackdump(void);

/*
 * Machine-dependent startup code
 */
void
cpu_startup()
{
#ifdef DEBUG
	extern int pmapdebug;
	int opmapdebug = pmapdebug;
#endif
	vaddr_t minaddr, maxaddr;
	paddr_t msgbufpa;
	extern struct user *proc0paddr;

#ifdef DEBUG
	pmapdebug = 0;
#endif

	if (CPU_ISSUN4M)
		stackgap_random = STACKGAP_RANDOM_SUN4M;

	/*
	 * Re-map the message buffer from its temporary address
	 * at KERNBASE to MSGBUF_VA.
	 */

	/* Get physical address of the message buffer */
	pmap_extract(pmap_kernel(), (vaddr_t)KERNBASE, &msgbufpa);

	/* Invalidate the current mapping at KERNBASE. */
	pmap_kremove((vaddr_t)KERNBASE, PAGE_SIZE);
	pmap_update(pmap_kernel());

	/* Enter the new mapping */
	pmap_map(MSGBUF_VA, msgbufpa, msgbufpa + PAGE_SIZE,
	    PROT_READ | PROT_WRITE);

	/* Re-initialize the message buffer. */
	initmsgbuf((caddr_t)(MSGBUF_VA + (CPU_ISSUN4 ? 4096 : 0)), MSGBUFSIZE);

	proc0.p_addr = proc0paddr;

	/*
	 * Good {morning,afternoon,evening,night}.
	 */
	printf(version);
	/*identifycpu();*/
	printf("real mem = %lu (%luMB)\n", ptoa(physmem),
	    ptoa(physmem)/1024/1024);

	/*
	 * uvm_km_init() has allocated all the virtual memory below the
	 * end of the kernel image. If VM_MIN_KERNEL_ADDRESS is below
	 * KERNBASE, we need to reclaim that range.
	 */
	if (vm_min_kernel_address < (vaddr_t)KERNBASE) {
		uvm_unmap(kernel_map, vm_min_kernel_address, (vaddr_t)KERNBASE);
	}

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	minaddr = vm_map_min(kernel_map);
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				 16*NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);

	/*
	 * Set up userland PIE limits. PIE is disabled on sun4/4c/4e due
	 * to the limited address space.
	 */
	if (CPU_ISSUN4M) {
		vm_pie_max_addr = VM_MAXUSER_ADDRESS / 4;
	}

	dvma_init();

#ifdef DEBUG
	pmapdebug = opmapdebug;
#endif
	printf("avail mem = %lu (%luMB)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free)/1024/1024);

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();
}

/*
 * Set up registers on exec.
 *
 * XXX this entire mess must be fixed
 */
/* ARGSUSED */
void
setregs(p, pack, stack, retval)
	struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
{
	struct trapframe *tf = p->p_md.md_tf;
	struct fpstate *fs;
	int psr;

	/*
	 * Setup the process StackGhost cookie which will be XORed into
	 * the return pointer as register windows are over/underflowed
	 */
	p->p_addr->u_pcb.pcb_wcookie = arc4random();

	/* The cookie needs to guarantee invalid alignment after the XOR */
	switch (p->p_addr->u_pcb.pcb_wcookie % 3) {
	case 0: /* Two lsb's already both set except if the cookie is 0 */
		p->p_addr->u_pcb.pcb_wcookie |= 0x3;
		break;
	case 1: /* Set the lsb */
		p->p_addr->u_pcb.pcb_wcookie = 1 |
			(p->p_addr->u_pcb.pcb_wcookie & ~0x3);
		break;
	case 2: /* Set the second most lsb */
		p->p_addr->u_pcb.pcb_wcookie = 2 |
			(p->p_addr->u_pcb.pcb_wcookie & ~0x3);
		break;
	}

	/*
	 * The syscall will ``return'' to npc or %g7 or %g2; set them all.
	 * Set the rest of the registers to 0 except for %o6 (stack pointer,
	 * built in exec()) and psr (retain CWP and PSR_S bits).
	 */
	psr = tf->tf_psr & (PSR_S | PSR_CWP);
	if ((fs = p->p_md.md_fpstate) != NULL) {
		/*
		 * We hold an FPU state.  If we own *the* FPU chip state
		 * we must get rid of it, and the only way to do that is
		 * to save it.  In any case, get rid of our FPU state.
		 */
		if (p == cpuinfo.fpproc) {
			savefpstate(fs);
			cpuinfo.fpproc = NULL;
		}
		free(fs, M_SUBPROC, sizeof *fs);
		p->p_md.md_fpstate = NULL;
	}
	bzero((caddr_t)tf, sizeof *tf);
	tf->tf_psr = psr;
	tf->tf_npc = pack->ep_entry & ~3;
	tf->tf_global[2] = tf->tf_npc;
	/* XXX exec of init(8) returns via proc_trampoline() */
	if (p->p_pid == 1) {
		tf->tf_pc = tf->tf_npc;
		tf->tf_npc += 4;
	}
	stack -= sizeof(struct rwindow);
	tf->tf_out[6] = stack;
	retval[1] = 0;
}

#ifdef DEBUG
int sigdebug = 0;
pid_t sigpid = 0;
#define SDB_FOLLOW	0x01
#define SDB_KSTACK	0x02
#define SDB_FPSTATE	0x04
#endif

struct sigframe {
	int	sf_signo;		/* signal number */
	siginfo_t *sf_sip;		/* points to siginfo_t */
	int	sf_xxx;			/* placeholder */
	caddr_t	sf_addr;		/* SunOS compat */
	struct	sigcontext sf_sc;	/* actual sigcontext */
	siginfo_t sf_si;
};

/*
 * machine dependent system variables.
 */
int
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
{
#if (NLED > 0) || (NAUXREG > 0) || (NSCF > 0)
	int oldval;
#endif
	int ret;
	extern int v8mul;

	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return (ENOTDIR);	/* overloaded */

	switch (name[0]) {
	case CPU_LED_BLINK:
#if (NLED > 0) || (NAUXREG > 0) || (NSCF > 0)
		oldval = sparc_led_blink;
		ret = sysctl_int(oldp, oldlenp, newp, newlen,
		    &sparc_led_blink);

		/*
		 * If we were false and are now true, call led_blink().
		 * led_blink() itself will catch the other case.
		 */
		if (!oldval && sparc_led_blink > oldval) {
#if NAUXREG > 0
			led_blink((caddr_t *)0);
#endif
#if NLED > 0
			led_cycle((caddr_t *)led_sc);
#endif
#if NSCF > 0
			scfblink((caddr_t *)0);
#endif
		}

		return (ret);
#else
		return (EOPNOTSUPP);
#endif
	case CPU_CPUTYPE:
		return (sysctl_rdint(oldp, oldlenp, newp, cputyp));
	case CPU_V8MUL:
		return (sysctl_rdint(oldp, oldlenp, newp, v8mul));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

/*
 * Send an interrupt to process.
 */
void
sendsig(sig_t catcher, int sig, int mask, u_long code, int type,
    union sigval val)
{
	struct proc *p = curproc;
	struct sigacts *psp = p->p_p->ps_sigacts;
	struct sigframe *fp;
	struct trapframe *tf;
	int caddr, oldsp, newsp;
	struct sigframe sf;

	tf = p->p_md.md_tf;
	oldsp = tf->tf_out[6];

	/*
	 * Compute new user stack addresses, subtract off
	 * one signal frame, and align.
	 */
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 &&
	    !sigonstack(oldsp) && (psp->ps_sigonstack & sigmask(sig)))
		fp = (struct sigframe *)(p->p_sigstk.ss_sp +
					 p->p_sigstk.ss_size);
	else
		fp = (struct sigframe *)oldsp;
	fp = (struct sigframe *)((int)(fp - 1) & ~7);

	/*
	 * Now set up the signal frame.  We build it in kernel space
	 * and then copy it out.  We probably ought to just build it
	 * directly in user space....
	 */
	bzero(&sf, sizeof(sf));
	sf.sf_signo = sig;
	sf.sf_sip = NULL;

	/*
	 * Build the signal context to be used by sigreturn.
	 */
	sf.sf_sc.sc_mask = mask;
	sf.sf_sc.sc_sp = oldsp;
	sf.sf_sc.sc_pc = tf->tf_pc;
	sf.sf_sc.sc_npc = tf->tf_npc;
	sf.sf_sc.sc_psr = tf->tf_psr;
	sf.sf_sc.sc_g1 = tf->tf_global[1];
	sf.sf_sc.sc_o0 = tf->tf_out[0];

	if (psp->ps_siginfo & sigmask(sig)) {
		sf.sf_sip = &fp->sf_si;
		initsiginfo(&sf.sf_si, sig, code, type, val);
	}

	/*
	 * Put the stack in a consistent state before we whack away
	 * at it.  Note that write_user_windows may just dump the
	 * registers into the pcb; we need them in the process's memory.
	 * We also need to make sure that when we start the signal handler,
	 * its %i6 (%fp), which is loaded from the newly allocated stack area,
	 * joins seamlessly with the frame it was in when the signal occurred,
	 * so that the debugger and _longjmp code can back up through it.
	 */
	newsp = (int)fp - sizeof(struct rwindow);
	write_user_windows();
	sf.sf_sc.sc_cookie = (long)&fp->sf_sc ^ p->p_p->ps_sigcookie;
	if (rwindow_save(p) || copyout((caddr_t)&sf, (caddr_t)fp, sizeof sf) ||
	    copyout(&oldsp, &((struct rwindow *)newsp)->rw_in[6],
	      sizeof(register_t)) != 0) {
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		sigexit(p, SIGILL);
		/* NOTREACHED */
	}

	/*
	 * Arrange to continue execution at the code copied out in exec().
	 * It needs the function to call in %g1, and a new stack pointer.
	 */
	caddr = p->p_p->ps_sigcode;
	tf->tf_global[1] = (int)catcher;
	tf->tf_pc = caddr;
	tf->tf_npc = caddr + 4;
	tf->tf_out[6] = newsp;
}

/*
 * System call to cleanup state after a signal
 * has been taken.  Reset signal mask and
 * stack state from context left by sendsig (above),
 * and return to the given trap frame (if there is one).
 * Check carefully to make sure that the user has not
 * modified the state to gain improper privileges or to cause
 * a machine fault.
 */
/* ARGSUSED */
int
sys_sigreturn(struct proc *p, void *v, register_t *retval)
{
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	struct sigcontext ksc, *scp = SCARG(uap, sigcntxp);
	struct trapframe *tf;
	int error;

	/* First ensure consistent stack state (see sendsig). */
	write_user_windows();
	if (rwindow_save(p))
		sigexit(p, SIGILL);

	if (PROC_PC(p) != p->p_p->ps_sigcoderet) {
		sigexit(p, SIGILL);
		return (EPERM);
	}

	if ((error = copyin(scp, &ksc, sizeof(ksc))) != 0)
		return (error);

	if (ksc.sc_cookie != ((long)scp ^ p->p_p->ps_sigcookie)) {
		sigexit(p, SIGILL);
		return (EFAULT);
	}

	/* Prevent reuse of the sigcontext cookie */
	ksc.sc_cookie = 0;
	(void)copyout(&ksc.sc_cookie, (caddr_t)scp +
	    offsetof(struct sigcontext, sc_cookie), sizeof (ksc.sc_cookie));

	tf = p->p_md.md_tf;
	/*
	 * Only the icc bits in the psr are used, so it need not be
	 * verified.  pc and npc must be multiples of 4.  This is all
	 * that is required; if it holds, just do it.
	 */
	if (((ksc.sc_pc | ksc.sc_npc) & 3) != 0)
		return (EINVAL);
	/* take only psr ICC field */
	tf->tf_psr = (tf->tf_psr & ~PSR_ICC) | (ksc.sc_psr & PSR_ICC);
	tf->tf_pc = ksc.sc_pc;
	tf->tf_npc = ksc.sc_npc;
	tf->tf_global[1] = ksc.sc_g1;
	tf->tf_out[0] = ksc.sc_o0;
	tf->tf_out[6] = ksc.sc_sp;
	p->p_sigmask = ksc.sc_mask & ~sigcantmask;
	return (EJUSTRETURN);
}

int	waittime = -1;

__dead void
boot(int howto)
{
	int i;
	static char str[4];	/* room for "-sd\0" */

	if (cold) {
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
		goto haltsys;
	}

	fb_unblank();
	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0 && waittime < 0) {
		waittime = 0;
		vfs_shutdown();

		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
	}
	if_downall();

	uvm_shutdown();
	splhigh();
	cold = 1;

	if ((howto & RB_DUMP) != 0)
		dumpsys();

haltsys:
	config_suspend_all(DVACT_POWERDOWN);

	if ((howto & RB_HALT) != 0 || (howto & RB_POWERDOWN) != 0) {
#if defined(SUN4M)
		if ((howto & RB_POWERDOWN) != 0) {
			printf("attempting to power down...\n");
#if NTCTRL > 0
			tadpole_powerdown();
#endif
#if NPOWER > 0
			auxio_powerdown();
#endif
			rominterpret("power-off");
			printf("WARNING: powerdown failed!\n");
		}
#endif /* SUN4M */
		printf("halted\n\n");
		romhalt();
	}

	printf("rebooting\n\n");
	i = 1;
	if ((howto & RB_SINGLE) != 0)
		str[i++] = 's';
	if ((howto & RB_KDB) != 0)
		str[i++] = 'd';
	if (i > 1) {
		str[0] = '-';
		str[i] = 0;
	} else
		str[0] = 0;
	romboot(str);
	for (;;) ;
	/* NOTREACHED */
}

/* XXX - dumpmag not eplicitly used, savecore may search for it to get here */
u_long	dumpmag = 0x8fca0101;	/* magic number for savecore */
int	dumpsize = 0;		/* also for savecore */
long	dumplo = 0;

void
dumpconf(void)
{
	int nblks, dumpblks;

	if (dumpdev == NODEV ||
	    (nblks = (bdevsw[major(dumpdev)].d_psize)(dumpdev)) == 0)
		return;
	if (nblks <= ctod(1))
		return;

	dumpblks = ctod(physmem) + ctod(pmap_dumpsize());
	if (dumpblks > (nblks - ctod(1)))
		/*
		 * dump size is too big for the partition.
		 * Note, we safeguard a click at the front for a
		 * possible disk label.
		 */
		return;

	/* Put the dump at the end of the partition */
	dumplo = nblks - dumpblks;

	/*
	 * savecore(8) expects dumpsize to be the number of pages
	 * of actual core dumped (i.e. excluding the MMU stuff).
	 */
	dumpsize = physmem;
}

#define	BYTES_PER_DUMP	(32 * 1024)	/* must be a multiple of pagesize */
static vaddr_t dumpspace;

/*
 * Allocate the dump i/o buffer area during kernel memory allocation
 */
caddr_t
reserve_dumppages(p)
	caddr_t p;
{

	dumpspace = (vaddr_t)p;
	return (p + BYTES_PER_DUMP);
}

/*
 * Write a crash dump.
 */
void
dumpsys()
{
	int psize;
	daddr_t blkno;
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
	int error = 0;
	struct memarr *mp;
	int nmem;
	extern struct memarr *pmemarr;
	extern int npmemarr;

	/* copy registers to memory */
	snapshot(cpcb);
	stackdump();

	if (dumpdev == NODEV)
		return;

	/*
	 * For dumps during autoconfiguration,
	 * if dump device has already configured...
	 */
	if (dumpsize == 0)
		dumpconf();
	if (dumplo <= 0)
		return;
	printf("\ndumping to dev(%d,%d), at offset %ld blocks\n",
	    major(dumpdev), minor(dumpdev), dumplo);

	psize = (*bdevsw[major(dumpdev)].d_psize)(dumpdev);
	printf("dump ");
	if (psize == -1) {
		printf("area unavailable\n");
		return;
	}
	blkno = dumplo;
	dump = bdevsw[major(dumpdev)].d_dump;

	printf("mmu ");
	error = pmap_dumpmmu(dump, blkno);
	blkno += ctod(pmap_dumpsize());

	printf("memory ");
	for (mp = pmemarr, nmem = npmemarr; --nmem >= 0 && error == 0; mp++) {
		unsigned i = 0, n;
		unsigned maddr = mp->addr_lo;

		/* XXX - what's so special about PA 0 that we can't dump it? */
		if (maddr == 0) {
			/* Skip first page at physical address 0 */
			maddr += NBPG;
			i += NBPG;
			blkno += btodb(NBPG);
		}

		printf("@@0x%x:", maddr);

		for (; i < mp->len; i += n) {
			n = mp->len - i;
			if (n > BYTES_PER_DUMP)
				 n = BYTES_PER_DUMP;

			/* print out which MBs we are dumping */
			if (i % (1024*1024) <= NBPG)
				printf("%d ", i / (1024*1024));

			(void) pmap_map(dumpspace, maddr, maddr + n,
					PROT_READ);
			error = (*dump)(dumpdev, blkno,
					(caddr_t)dumpspace, (int)n);
			pmap_remove(pmap_kernel(), dumpspace, dumpspace + n);
			if (error)
				break;
			maddr += n;
			blkno += btodb(n);
		}
	}

	switch (error) {

	case ENXIO:
		printf("device bad\n");
		break;

	case EFAULT:
		printf("device not ready\n");
		break;

	case EINVAL:
		printf("area improper\n");
		break;

	case EIO:
		printf("i/o error\n");
		break;

	case 0:
		printf("succeeded\n");
		break;

	default:
		printf("error %d\n", error);
		break;
	}
}

/*
 * get the fp and dump the stack as best we can.  don't leave the
 * current stack page
 */
void
stackdump()
{
	struct frame *fp = getfp(), *sfp;

	sfp = fp;
	printf("Frame pointer is at %p\n", fp);
	printf("Call traceback:\n");
	while (fp && ((u_long)fp >> PGSHIFT) == ((u_long)sfp >> PGSHIFT)) {
		printf("  pc = 0x%x  args = (0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x) fp = %p\n",
		    fp->fr_pc, fp->fr_arg[0], fp->fr_arg[1], fp->fr_arg[2],
		    fp->fr_arg[3], fp->fr_arg[4], fp->fr_arg[5], fp->fr_fp);
		fp = fp->fr_fp;
	}
}

/*
 * Map an I/O device given physical address and size in bytes, e.g.,
 *
 *	mydev = (struct mydev *)mapdev(myioaddr, 0,
 *				       0, sizeof(struct mydev));
 *
 * See also machine/autoconf.h.
 *
 * XXXART - verify types (too tired now).
 */
void *
mapdev(phys, virt, offset, size)
	struct rom_reg *phys;
	int offset, virt, size;
{
	vaddr_t va;
	paddr_t pa, base;
	void *ret;
	static vaddr_t iobase;
	unsigned int pmtype;

	if (iobase == 0)
		iobase = IODEV_BASE;

	base = (paddr_t)phys->rr_paddr + offset;
	if (virt != 0) {
		va = trunc_page(virt);
		size = round_page(virt + size) - va;
	} else {
		size = round_page(base + size) - trunc_page(base);
		va = iobase;
		iobase += size;
		if (iobase > IODEV_END)	/* unlikely */
			panic("mapiodev");
	}
	if (size == 0)
		panic("mapdev: zero size");

	ret = (void *)(va | (base & PGOFSET));
			/* note: preserve page offset */

	pa = trunc_page(base);
	pmtype = PMAP_IOENC(phys->rr_iospace);

	do {
		pmap_kenter_pa(va, pa | pmtype | PMAP_NC,
		    PROT_READ | PROT_WRITE);
		va += PAGE_SIZE;
		pa += PAGE_SIZE;
	} while ((size -= PAGE_SIZE) > 0);
	pmap_update(pmap_kernel());
	return (ret);
}

#ifdef SUN4
void
oldmon_w_trace(va)
	u_long va;
{
	u_long stop;
	struct frame *fp;

	if (curproc)
		printf("curproc = %p, pid %d\n", curproc, curproc->p_pid);
	else
		printf("no curproc\n");
	printf("uvm: swtch %d, trap %d, sys %d, intr %d, soft %d, faults %d\n",
	       uvmexp.swtch, uvmexp.traps, uvmexp.syscalls, uvmexp.intrs,
	       uvmexp.softs, uvmexp.faults);
	write_user_windows();

	printf("\nstack trace with sp = 0x%lx\n", va);
	stop = round_page(va);
	printf("stop at 0x%lx\n", stop);
	fp = (struct frame *) va;
	while (round_page((u_long) fp) == stop) {
		printf("  0x%x(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x) fp %p\n", fp->fr_pc,
		    fp->fr_arg[0], fp->fr_arg[1], fp->fr_arg[2], fp->fr_arg[3],
		    fp->fr_arg[4], fp->fr_arg[5], fp->fr_fp);
		fp = fp->fr_fp;
		if (fp == NULL)
			break;
	}
	printf("end of stack trace\n");
}

void
oldmon_w_cmd(va, ar)
	u_long va;
	char *ar;
{
	switch (*ar) {
	case '\0':
		switch (va) {
		case 0:
			panic("g0 panic");
		case 4:
			printf("w: case 4\n");
			break;
		default:
			printf("w: unknown case %ld\n", va);
			break;
		}
		break;
	case 't':
		oldmon_w_trace(va);
		break;
	default:
		printf("w: arg not allowed\n");
	}
}

int
ldcontrolb(addr)
caddr_t addr;
{
	struct pcb *xpcb;
	extern struct user *proc0paddr;
	u_long saveonfault;
	int res;
	int s;

	s = splhigh();
	if (curproc == NULL)
		xpcb = (struct pcb *)proc0paddr;
	else
		xpcb = &curproc->p_addr->u_pcb;

	saveonfault = (u_long)xpcb->pcb_onfault;
        res = xldcontrolb(addr, xpcb);
	xpcb->pcb_onfault = (caddr_t)saveonfault;

	splx(s);
	return (res);
}
#endif /* SUN4 */

/*
 * Common function for DMA map creation.  May be called by bus-specific
 * DMA map creation functions.
 */
int
_bus_dmamap_create(bus_dma_tag_t t, bus_size_t size, int nsegments,
		   bus_size_t maxsegsz, bus_size_t boundary, int flags,
		   bus_dmamap_t *dmamp)
{
	struct sparc_bus_dmamap *map;
	void *mapstore;
	size_t mapsize;

	/*
	 * Allocate and initialize the DMA map.  The end of the map
	 * is a variable-sized array of segments, so we allocate enough
	 * room for them in one shot.
	 *
	 * Note we don't preserve the WAITOK or NOWAIT flags.  Preservation
	 * of ALLOCNOW notifies others that we've reserved these resources,
	 * and they are not to be freed.
	 *
	 * The bus_dmamap_t includes one bus_dma_segment_t, hence
	 * the (nsegments - 1).
	 */
	mapsize = sizeof(struct sparc_bus_dmamap) +
	    (sizeof(bus_dma_segment_t) * (nsegments - 1));
	if ((mapstore = malloc(mapsize, M_DEVBUF, (flags & BUS_DMA_NOWAIT) ?
	    (M_NOWAIT | M_ZERO) : (M_WAITOK | M_ZERO))) == NULL)
		return (ENOMEM);

	map = (struct sparc_bus_dmamap *)mapstore;
	map->_dm_size = size;
	map->_dm_segcnt = nsegments;
	map->_dm_maxmaxsegsz = maxsegsz;
	map->_dm_boundary = boundary;
	map->_dm_align = PAGE_SIZE;
	map->_dm_flags = flags & ~(BUS_DMA_WAITOK|BUS_DMA_NOWAIT);
	map->dm_maxsegsz = maxsegsz;
	map->dm_mapsize = 0;		/* no valid mappings */
	map->dm_nsegs = 0;

	*dmamp = map;
	return (0);
}

/*
 * Common function for DMA map destruction.  May be called by bus-specific
 * DMA map destruction functions.
 */
void
_bus_dmamap_destroy(bus_dma_tag_t t, bus_dmamap_t map)
{
	free(map, M_DEVBUF, 0);
}

/*
 * Like _bus_dmamap_load(), but for mbufs.
 */
int
_bus_dmamap_load_mbuf(bus_dma_tag_t t, bus_dmamap_t map,
		      struct mbuf *m, int flags)
{
	panic("_bus_dmamap_load_mbuf: not implemented");
}

/*
 * Like _bus_dmamap_load(), but for uios.
 */
int
_bus_dmamap_load_uio(bus_dma_tag_t t, bus_dmamap_t map,
		     struct uio *uio, int flags)
{
	panic("_bus_dmamap_load_uio: not implemented");
}

/*
 * Like _bus_dmamap_load(), but for raw memory allocated with
 * bus_dmamem_alloc().
 */
int
_bus_dmamap_load_raw(bus_dma_tag_t t, bus_dmamap_t map,
		     bus_dma_segment_t *segs, int nsegs, bus_size_t size,
		     int flags)
{
	panic("_bus_dmamap_load_raw: not implemented");
}

/*
 * Common function for DMA map synchronization.  May be called
 * by bus-specific DMA map synchronization functions.
 */
void
_bus_dmamap_sync(bus_dma_tag_t t, bus_dmamap_t map,
		 bus_addr_t offset, bus_size_t len, int ops)
{
}

/*
 * Common function for DMA-safe memory allocation.  May be called
 * by bus-specific DMA memory allocation functions.
 */
int
_bus_dmamem_alloc(bus_dma_tag_t t, bus_size_t size,
		  bus_size_t alignment, bus_size_t boundary,
		  bus_dma_segment_t *segs, int nsegs, int *rsegs,
		  int flags)
{
	struct pglist *mlist;
	int error, plaflag;

	/* Always round the size. */
	size = round_page(size);

	if ((mlist = malloc(sizeof(*mlist), M_DEVBUF,
	    (flags & BUS_DMA_NOWAIT) ? M_NOWAIT : M_WAITOK)) == NULL)
		return (ENOMEM);

	/*
	 * Allocate pages from the VM system.
	 */
	plaflag = flags & BUS_DMA_NOWAIT ? UVM_PLA_NOWAIT : UVM_PLA_WAITOK;
	if (flags & BUS_DMA_ZERO)
		plaflag |= UVM_PLA_ZERO;

	TAILQ_INIT(mlist);
	error = uvm_pglistalloc(size, (paddr_t)0, (paddr_t)-1, 0, 0,
	    mlist, nsegs, plaflag);
	if (error)
		return (error);

	/*
	 * Simply keep a pointer around to the linked list, so
	 * bus_dmamap_free() can return it.
	 *
	 * NOBODY SHOULD TOUCH THE pageq FIELDS WHILE THESE PAGES
	 * ARE IN OUR CUSTODY.
	 */
	segs[0]._ds_mlist = mlist;

	/*
	 * We now have physical pages, but no DVMA addresses yet. These
	 * will be allocated in bus_dmamap_load*() routines. Hence we
	 * save any alignment and boundary requirements in this DMA
	 * segment.
	 */
	segs[0].ds_addr = 0;
	segs[0].ds_len = 0;
	segs[0]._ds_va = 0;
	*rsegs = 1;
	return (0);
}

/*
 * Common function for freeing DMA-safe memory.  May be called by
 * bus-specific DMA memory free functions.
 */
void
_bus_dmamem_free(bus_dma_tag_t t, bus_dma_segment_t *segs, int nsegs)
{
	if (nsegs != 1)
		panic("bus_dmamem_free: nsegs = %d", nsegs);

	/*
	 * Return the list of pages back to the VM system.
	 */
	uvm_pglistfree(segs[0]._ds_mlist);
	free(segs[0]._ds_mlist, M_DEVBUF, 0);
}

/*
 * Common function for unmapping DMA-safe memory.  May be called by
 * bus-specific DMA memory unmapping functions.
 */
void
_bus_dmamem_unmap(bus_dma_tag_t t, void *kva, size_t size)
{

#ifdef DIAGNOSTIC
	if ((u_long)kva & PAGE_MASK)
		panic("_bus_dmamem_unmap");
#endif

	km_free(kva, round_page(size), &kv_any, &kp_none);
}

/*
 * Common functin for mmap(2)'ing DMA-safe memory.  May be called by
 * bus-specific DMA mmap(2)'ing functions.
 */
paddr_t
_bus_dmamem_mmap(bus_dma_tag_t t, bus_dma_segment_t *segs, int nsegs,
		 off_t off, int prot, int flags)
{
	panic("_bus_dmamem_mmap: not implemented");
}
@


1.179
log
@Fix typo in comment in three machdep.c files:

s/names are this level/names at this level/

from aalm@@ - thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.178 2016/05/21 00:56:44 deraadt Exp $	*/
@


1.178
log
@hand-massage sendsig() and sys_sigreturn() to be much more similar.
ok guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.177 2016/05/11 20:21:26 phessler Exp $	*/
d320 1
a320 1
	/* all sysctl names are this level are terminal */
@


1.177
log
@fix compile issues in MD sigreturn(2)

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.176 2016/05/10 18:39:48 deraadt Exp $	*/
d365 2
a366 6
sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
a389 5
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig: %s[%d] sig %d newusp %p scp %p\n",
		    p->p_comm, p->p_pid, sig, fp, &fp->sf_sc);
#endif
a433 4
#ifdef DEBUG
		if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
			printf("sendsig: window save or copyout error\n");
#endif
d437 1
a437 5
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sendsig: %s[%d] sig %d scp %p\n",
		       p->p_comm, p->p_pid, sig, &fp->sf_sc);
#endif
a446 4
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig: about to return to catcher\n");
#endif
d460 1
a460 4
sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d465 1
a465 1
	struct sigcontext ksc, *sc = SCARG(uap, sigcntxp);
d473 1
a473 5
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn: %s[%d], sigcntxp %p\n",
		    p->p_comm, p->p_pid, SCARG(uap, sigcntxp));
#endif
a474 2
		printf("%s(%d): sigreturn not from tramp [pc 0x%x 0x%lx]\n",
		    p->p_comm, p->p_pid, PROC_PC(p), p->p_p->ps_sigcoderet);
d479 1
a479 1
	if ((error = copyin(sc, &ksc, sizeof(ksc))) != 0)
d482 1
a482 4
	if (ksc.sc_cookie != ((long)sc ^ p->p_p->ps_sigcookie)) {
		printf("%s(%d): cookie %lx should have been %lx\n",
		    p->p_comm, p->p_pid, ksc.sc_cookie,
		    (long)sc ^ p->p_p->ps_sigcookie);
d489 2
a490 3
	(void)copyout(&ksc.sc_cookie, (caddr_t)sc +
	    offsetof(struct sigcontext, sc_cookie),
	    sizeof (ksc.sc_cookie));
@


1.176
log
@SROP mitigation.  sendsig() stores a (per-process ^ &sigcontext) cookie
inside the sigcontext.  sigreturn(2) checks syscall entry was from the
exact PC addr in the (per-process ASLR) sigtramp, verifies the cookie,
and clears it to prevent sigcontext reuse.
not yet tested on landisk, sparc, *88k, socppc.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.175 2015/10/21 07:59:18 mpi Exp $	*/
d435 1
a435 1
	sf.sf_sc.sc_cookie = (long)fp ^ p->p_p->ps_sigcookie;
d503 1
a503 1
		printf("%s(%d): sigreturn not from tramp [pc 0x%lx 0x%lx]\n",
d512 1
a512 1
	if (ksc.sc_cookie != ((long)scp ^ p->p_p->ps_sigcookie)) {
d515 1
a515 1
		    (long)scp ^ p->p_p->ps_sigcookie);
d522 1
a522 1
	(void)copyout(&ksc.sc_cookie, (caddr_t)scp +
@


1.175
log
@Do not call uvm_swap_finicrypt_all() a second time in dumpsys().

ok tedu@@, deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.174 2015/09/18 12:50:28 miod Exp $	*/
d435 1
a435 1
	/* XXX do not copyout siginfo if not needed */
d489 1
a489 1
	struct sigcontext ksc;
d502 8
a509 1
	if ((error = copyin(SCARG(uap, sigcntxp), &ksc, sizeof(ksc))) != 0)
d511 15
@


1.174
log
@Drop the workarounds allowing SMALL_KERNEL (i.e. installation media) to be
booted from old (< 2.10) bootblocks.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.173 2015/09/08 10:21:16 deraadt Exp $	*/
a676 4

#ifdef UVM_SWAP_ENCRYPT
	uvm_swap_finicrypt_all();
#endif
@


1.173
log
@sizes for free(); ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.172 2015/06/02 04:31:53 miod Exp $	*/
a173 1
#if !defined(SMALL_KERNEL)
a181 1
#endif
@


1.172
log
@Override pie range constants (well, only VM_PIE_MAX_ADDR) with a variable
which value is decided at runtime, in order to only enable PIE on sun4m
which has a large enough address space.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.171 2015/03/30 20:30:22 miod Exp $	*/
d269 1
a269 1
		free((void *)fs, M_SUBPROC, 0);
@


1.171
log
@Add a bus_dma_tag_t for DVMA usage, suitable for use for devices not sitting
behind a sun4m iommu.

Move the existing dvma routines from vm_machdep.c to this new dvma.c; this
allows for a few declarations to be removed from public headers.

Extend the device attachment arguments (struct confargs) to pass a
bus_dma_tag_t. mainbus receives the dvma bus_dma_tag_t, and devices pass the
tag unchanged to their children, except for iommu(4) which replaces it with
its own.

Change the few sun4m-only drivers to pick the bus_dma_tag_t from confargs
rather than assume iommu; this allows qlw(4) to attach and work on sun4c.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.170 2015/03/27 20:25:39 miod Exp $	*/
d103 2
d192 8
@


1.170
log
@Lower VM_MIN_KERNEL_ADDRESS by 128MB on non-SRMMU systems (sun4/4c/4e) as well,
in order to give these systems a more reasonable amount of kva, yet still
providing .75GB to userland processes.

Although there is no dependency upon a recent boot loader on non-SRMMU systems,
SMALL_KERNEL will nevertheless stick to the legacy kvm layout, for the time
being.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.169 2015/03/18 20:56:40 miod Exp $	*/
a118 6
/*
 * dvmamap_extent is used to manage DVMA memory.
 */
vaddr_t dvma_base, dvma_end;
struct extent *dvmamap_extent;

d191 1
a191 11
	/*
	 * Allocate a map for physio.  Others use a submap of the kernel
	 * map, but we want one completely separate, even though it uses
	 * the same pmap.
	 */
	dvma_base = CPU_ISSUN4M ? DVMA4M_BASE : DVMA_BASE;
	dvma_end = CPU_ISSUN4M ? DVMA4M_END : DVMA_END;
	dvmamap_extent = extent_create("dvmamap", dvma_base, dvma_end,
				       M_DEVBUF, NULL, 0, EX_NOWAIT);
	if (dvmamap_extent == NULL)
		panic("unable to allocate extent for dvma");
@


1.169
log
@Rework the virtual memory layout on SRMMU systems (sun4d/sun4m) to use a much
lower VM_MIN_KERNEL_ADDRESS, since these systems are not crippled by the
Sun-4 MMU hole and have the real 4GB of address space.

Kernels running on Sun-4 MMU are not affected and will still be restricted
to the existing 128MB of kernel space, with 1GB - 128MB of user space.

Kernels running on SRMMU will now provide the low 3GB of address space to
userland, and use the top 1GB for the kernel, except when compiled with
option SMALL_KERNEL, in which case they will keep Sun-4 style the layout
(this is temporary to allow for people to boot bsd.rd to upgrade even when
not running 2.10 boot blocks, and will be removed eventually)

A consequence of this is that the top of the userland stack is no longer at
0xf0000000. But since nothing in userland uses USRSTACK anymore, this should
not be an issue.

Tested on sun4c and various sun4m, with physical memory sizes ranging from 32
to 448MB.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.168 2015/02/09 11:52:47 miod Exp $	*/
d178 1
a178 1
#if (defined(SUN4D) || defined(SUN4M)) && !defined(SMALL_KERNEL)
@


1.168
log
@Change the way stackgap_random is applied. Instead of applying it within the
fixed stack area of the exec'd image, and risking hitting process limits,
should we want to increase stackgap_random, the randomness is applied to the
stack region in the process' vmspace.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.167 2014/12/10 15:29:53 mikeb Exp $	*/
d177 11
@


1.167
log
@retire shutdown hooks; ok deraadt, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.166 2014/11/16 12:30:58 deraadt Exp $	*/
d146 1
a146 3
	if (CPU_ISSUN4M) {
		extern int stackgap_random;

a147 1
	}
@


1.166
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.165 2014/09/20 09:28:24 kettenis Exp $	*/
a558 1
	doshutdownhooks();
@


1.165
log
@Use config_suspend_all(9).

ok mpi@@, uebayasi@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.164 2014/07/21 17:25:47 uebayasi Exp $	*/
d166 1
a166 1
	    VM_PROT_READ | VM_PROT_WRITE);
d721 1
a721 1
					VM_PROT_READ);
d826 1
a826 1
		    VM_PROT_READ | VM_PROT_WRITE);
@


1.164
log
@boot(9): Reduce annoying style diffs

- Always use either: ((x & RB_XXX) != 0) or ((x & RB_XXX) == 0) in boolean
  context (mostly if (x), or x ? y : z)
  - prom_halt() in alpha is confirmed to take int as boolean

Converted by coccinelle.  No functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a529 1
	struct device *mainbus;
d560 1
a560 3
	mainbus = device_mainbus();
	if (mainbus != NULL)
		config_suspend(mainbus, DVACT_POWERDOWN);
@


1.163
log
@boot(9): Cosmetic changes to improve diff'ability.
@
text
@d556 1
a556 1
	if (howto & RB_DUMP)
d565 1
a565 1
	if ((howto & RB_HALT) || (howto & RB_POWERDOWN)) {
d567 1
a567 1
		if (howto & RB_POWERDOWN) {
d585 1
a585 1
	if (howto & RB_SINGLE)
d587 1
a587 1
	if (howto & RB_KDB)
@


1.162
log
@Cosmetic changes to reduce diffs.
@
text
@d595 2
a596 1
	/*NOTREACHED*/
@


1.161
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.160 2014/07/11 22:28:06 uebayasi Exp $	*/
d553 1
a553 1
	splhigh();		/* Disable interrupts. */
@


1.160
log
@boot(9): Undo curproc-overriding hacks

Some (not all) boot(9) implementations have ancient hacks which overrides if
(curproc == NULL).  This was probably made in a hope to forcibly proceed
various clean-shutdown related code, including VFS shutdown.  Let's clarify
that clean-shutdown needs process context; it is impossible to cleanly shutdown
VFS from within e.g. a panic in SPL_HIGH.

OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d267 1
a267 1
		free((void *)fs, M_SUBPROC);
d972 1
a972 1
	free(map, M_DEVBUF);
d1086 1
a1086 1
	free(segs[0]._ds_mlist, M_DEVBUF);
@


1.159
log
@Convert bus_dmamem_map(9) to km_alloc(9) in order to make it fail and
not sleep if the allocator cannot obtain a lock when BUS_DMA_NOWAIT is
specified.

idea and inputs from kettenis@@, ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.158 2014/07/10 21:46:03 mpi Exp $	*/
a540 5
		extern struct proc proc0;

		/* make sure there's a process to charge for I/O in sync() */
		if (curproc == NULL)
			curproc = &proc0;
@


1.158
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.157 2014/07/10 20:15:27 uebayasi Exp $	*/
d1107 1
a1107 2
	size = round_page(size);
	uvm_km_free(kernel_map, (vaddr_t)kva, (vaddr_t)size + size);
@


1.157
log
@boot(9): Remove comments about RB_*, "cold", and savectx()

Again remove slightly different comments to reduce diffs.  These will be
re-added once boot() become MI and its specification is clearly re-defined.

OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d558 2
a559 1
	(void) splhigh();		/* ??? */
@


1.156
log
@boot(): Remove comments about RB_TIMEBAD to reduce diffs

RB_TIMEBAD is documented well enough that the comment is not needed.  sparc64
does slightly different and its comment is left with XXX.

OK deraadt@@ miod@@
@
text
@a531 1
	/* If system is cold, just halt. */
a532 1
		/* (Unless the user explicitly asked for reboot.) */
@


1.155
log
@boot(): Unify declarations

OK deraadt@@
@
text
@a550 5
		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
		 */
@


1.154
log
@Revert previous diff setting cold to 1 on shutdown because it breaks machine
with softraid(4) disks.

softraid(4) is the last real consumer of the doshutdownhooks(9) API and it is
not trivial to convert its hook to a DVACT_POWERDOWN handler since the latter
does not allow to sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.153 2014/05/30 13:46:16 mpi Exp $	*/
d525 2
a526 3
void
boot(howto)
	int howto;
@


1.153
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.152 2014/05/25 13:57:48 deraadt Exp $	*/
d566 1
a566 2
	splhigh();		/* Disable interrupts. */
	cold = 1;
@


1.152
log
@Turn on blinky things by default, very useful here
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.151 2014/05/09 20:15:06 miod Exp $	*/
d566 2
a567 1
	(void) splhigh();		/* ??? */
@


1.151
log
@format string fixes and removal of -Wno-format for sparc kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.150 2014/03/26 05:23:42 guenther Exp $	*/
d111 1
a111 1
int	sparc_led_blink = 0;
@


1.150
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.149 2014/03/22 06:05:45 guenther Exp $	*/
d178 1
a178 1
	printf("real mem = %u (%uMB)\n", ptoa(physmem),
@


1.149
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.148 2014/03/13 03:52:55 dlg Exp $	*/
d459 1
a459 1
	caddr = p->p_sigcode;
@


1.148
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.147 2013/09/28 12:40:32 miod Exp $	*/
d373 1
a373 1
	struct sigacts *psp = p->p_sigacts;
@


1.147
log
@In boot(), do not iterate over alldevs if it's empty (i.e. halting from ddb
with ddb entered early with boot -d or from UKC).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.146 2013/06/11 16:42:11 deraadt Exp $	*/
d531 1
d573 3
a575 2
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.146
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.145 2013/02/17 17:36:49 kettenis Exp $	*/
d572 2
a573 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.145
log
@We deprecated returning to %g7 after a successful system call long ago.
These days we use it as a thread register and want to have it initialized to
zero for future thread local storage (TLS) support.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.144 2012/12/02 07:03:31 guenther Exp $	*/
d664 2
a665 2
	daddr64_t blkno;
	int (*dump)(dev_t, daddr64_t, caddr_t, size_t);
@


1.144
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.143 2012/11/05 13:20:16 miod Exp $	*/
d273 1
a273 1
	tf->tf_global[2] = tf->tf_global[7] = tf->tf_npc;
@


1.143
log
@Switch sparc to timecounters. Heavily based on NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.142 2012/10/22 17:28:27 kettenis Exp $	*/
d376 1
a376 1
	int caddr, oonstack, oldsp, newsp;
d381 1
a381 1
	oonstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d386 2
a387 2
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 && !oonstack &&
	    (psp->ps_sigonstack & sigmask(sig))) {
d390 1
a390 2
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	} else
d404 1
a410 1
	sf.sf_sc.sc_onstack = oonstack;
a518 4
	if (ksc.sc_onstack & 1)
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.142
log
@Stop passing around PS_STRINGS in %g1.  The ELF ABI reserves this register
for passing around a pointer to a cleanup function and we'd like to use it
for that purpose in the near future.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.141 2012/10/08 21:47:50 deraadt Exp $	*/
a210 3

	/* Early interrupt handlers initialization */
	intr_init();
@


1.141
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.140 2012/08/22 13:33:32 okan Exp $	*/
a275 1
	tf->tf_global[1] = (int)PS_STRINGS;
@


1.140
log
@sigpid should be of type pid_t (only visable with DEBUG).

ok miod@@ (who found others to fix as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.139 2012/08/21 14:44:24 jsg Exp $	*/
a579 1
	/* Run any shutdown hooks */
d581 1
@


1.139
log
@don't read past the end of an array when dumping the stack.
spotted by clang

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.138 2012/03/23 15:51:26 guenther Exp $	*/
d290 1
a290 1
int sigpid = 0;
@


1.138
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.137 2011/07/05 04:48:02 guenther Exp $	*/
d793 1
a793 1
		printf("  pc = 0x%x  args = (0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x) fp = %p\n",
d795 1
a795 2
		    fp->fr_arg[3], fp->fr_arg[4], fp->fr_arg[5], fp->fr_arg[6],
		    fp->fr_fp);
d876 1
a876 1
		printf("  0x%x(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x) fp %p\n", fp->fr_pc,
d878 1
a878 1
		    fp->fr_arg[4], fp->fr_arg[5], fp->fr_arg[6], fp->fr_fp);
@


1.137
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.136 2011/06/26 22:40:00 deraadt Exp $	*/
d554 1
a554 1
		/* XXX protect against curproc->p_stats.foo refs in sync() */
@


1.136
log
@if_downall() cannot be done MI in sys_reboot() because vfs_shutdown()
might need network (ie. nfs).  Move the call to the MD boot() routines.
This cause for boot hangs diagnosed by kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.135 2011/06/05 19:41:08 deraadt Exp $	*/
d385 1
a385 1
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d390 1
a390 1
	if ((psp->ps_flags & SAS_ALTSTACK) && !oonstack &&
d392 3
a394 3
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
					 psp->ps_sigstk.ss_size);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d525 1
a525 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d527 1
a527 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.135
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.134 2011/04/18 21:44:55 guenther Exp $	*/
d65 1
d571 1
@


1.134
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.132 2011/04/07 15:30:16 miod Exp $	*/
a102 14

/*
 * Declare these as initialized data so we can patch them.
 */
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

#ifdef	BUFPAGES
int	bufpages = BUFPAGES;
#else
int	bufpages = 0;
#endif
int	bufcachepercent = BUFCACHEPERCENT;
@


1.133
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d398 1
a398 1
	oonstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d403 1
a403 1
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 && !oonstack &&
d405 3
a407 3
		fp = (struct sigframe *)(p->p_sigstk.ss_sp +
					 p->p_sigstk.ss_size);
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d538 1
a538 1
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d540 1
a540 1
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.132
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.131 2010/11/27 19:41:48 miod Exp $	*/
d398 1
a398 1
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d403 1
a403 1
	if ((psp->ps_flags & SAS_ALTSTACK) && !oonstack &&
d405 3
a407 3
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
					 psp->ps_sigstk.ss_size);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d538 1
a538 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d540 1
a540 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.131
log
@Misaligned load/store recovery code in the kernel, enabled by T_FIXALIGN
userland traps on a per-process basis, were necessary for *some* SunOS
binaries on sparc, which had to compiled with explicit misaligned access code
generation (i.e. for vendors to release a working SunOS/sparc version of their
code until they could fix their bogus code).

There is no reason to keep this code on sparc64, and now that we don't provide
COMPAT_SUNOS anymore, there is no reason to keep this code on sparc.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.130 2010/07/02 19:57:15 tedu Exp $	*/
d834 1
a834 1
	if (iobase == NULL)
@


1.130
log
@remove support for compat_sunos (and m68k4k).  ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.129 2010/07/02 04:14:19 miod Exp $	*/
a265 3

	/* Don't allow misaligned code by default */
	p->p_md.md_flags &= ~MDP_FIXALIGN;
@


1.129
log
@gremlin crept in by accident
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.128 2010/06/29 21:28:11 miod Exp $	*/
a314 3
#ifdef COMPAT_SUNOS
	struct	sigcontext *sf_scp;	/* points to user addr of sigcontext */
#else
a315 1
#endif
a397 3
#ifdef COMPAT_SUNOS
	extern struct emul emul_sunos;
#endif
a426 7
#ifdef COMPAT_SUNOS
	if (p->p_emul == &emul_sunos) {
		sf.sf_sip = (void *)code;	/* SunOS has "int code" */
		sf.sf_scp = &fp->sf_sc;
		sf.sf_addr = val.sival_ptr;
	}
#endif
d480 2
a481 9
#ifdef COMPAT_SUNOS
	if (psp->ps_usertramp & sigmask(sig)) {
		caddr = (int)catcher;	/* user does his own trampolining */
	} else
#endif
	{
		caddr = p->p_sigcode;
		tf->tf_global[1] = (int)catcher;
	}
a868 15

#ifdef COMPAT_SUNOS
int
cpu_exec_aout_makecmds(p, epp)
	struct proc *p;
	struct exec_package *epp;
{
	int error = ENOEXEC;

	extern int sunos_exec_aout_makecmds(struct proc *, struct exec_package *);
	if ((error = sunos_exec_aout_makecmds(p, epp)) == 0)
		return 0;
	return error;
}
#endif
@


1.128
log
@During kernel bootstrap, stop assuming the kernel image has been loaded in
low physical memory, but instead figure out where it has been loaded from
the current MMU setup.

From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.127 2010/06/29 21:26:12 miod Exp $	*/
d207 2
a208 2
	dvma_base = CPU_ISSUN4DOR4M ? DVMA4M_BASE : DVMA_BASE;
	dvma_end = CPU_ISSUN4DOR4M ? DVMA4M_END : DVMA_END;
@


1.127
log
@There is absolutely no need to double map DVMA addresses into the kernel address
space on SRMMU systems (i.e. sun4m), so don't do it anymore and update
misleading comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.126 2010/06/27 13:28:47 miod Exp $	*/
d152 1
d166 2
a167 1
	 * fix message buffer mapping, note phys addr of msgbuf is 0
d169 13
a181 1
	pmap_map(MSGBUF_VA, 0, MSGBUFSIZE, VM_PROT_READ|VM_PROT_WRITE);
d714 1
a714 1
	extern struct memarr pmemarr[];
d755 1
a755 1
		unsigned maddr = mp->addr;
@


1.126
log
@If you include <uvm/uvm.h>, you do not need to include any other <uvm/uvm_foo.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.125 2010/06/27 03:03:48 thib Exp $	*/
a102 1
struct vm_map *phys_map = NULL;
d130 1
a130 1
int   safepri = 0;
d133 1
a133 2
 * dvmamap is used to manage DVMA memory. Note: this coincides with
 * the memory range in `phys_map' (which is mostly a place-holder).
d193 2
a194 29
	dvma_base = CPU_ISSUN4M ? DVMA4M_BASE : DVMA_BASE;
	dvma_end = CPU_ISSUN4M ? DVMA4M_END : DVMA_END;
#if defined(SUN4M)
	if (CPU_ISSUN4M) {
		/*
		 * The DVMA space we want partially overrides kernel_map.
		 * Allocate it in kernel_map as well to prevent it from being
		 * used for other things.
		 */
		if (uvm_map(kernel_map, &dvma_base,
		    vm_map_max(kernel_map) - dvma_base,
                    NULL, UVM_UNKNOWN_OFFSET, 0,
                    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
                                UVM_ADV_NORMAL, UVM_FLAG_FIXED)))
			panic("startup: can not steal dvma map");
	}
#endif
	phys_map = uvm_map_create(pmap_kernel(), dvma_base, dvma_end,
	    VM_MAP_INTRSAFE);
	if (phys_map == NULL)
		panic("unable to create DVMA map");

	/*
	 * Allocate DVMA space and dump into a privately managed
	 * resource map for double mappings which is usable from
	 * interrupt contexts.
	 */
	if (uvm_km_valloc_wait(phys_map, (dvma_end-dvma_base)) != dvma_base)
		panic("unable to allocate from DVMA map");
d197 1
a197 1
	if (dvmamap_extent == 0)
@


1.125
log
@uvm constraints. Add two mandatory MD symbols, uvm_md_constraints
which contains the constraints for DMA/memory allocation for each
architecture, and dma_constraints which contains the range of addresses
that are dma accessable by the system.

This is based on ariane@@'s physcontig diff, with lots of bugfixes and
additions the following additions by my self:

Introduce a new function pool_set_constraints() which sets the address
range for which we allocate pages for the pool from, this is now used
for the mbuf/mbuf cluster pools to keep them dma accessible.

The !direct archs no longer stuff pages into the kernel object in
uvm_km_getpage_pla but rather do a pmap_extract() in uvm_km_putpages.

Tested heavily by my self on i386, amd64 and sparc64. Some tests on
alpha and SGI.

"commit it" beck, art, oga, deraadt
"i like the diff" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.123 2009/08/11 19:17:17 miod Exp $	*/
d65 1
a65 2
#include <uvm/uvm_extern.h>
#include <uvm/uvm_swap.h>
a81 2

#include <uvm/uvm.h>
@


1.124
log
@The intention is to map the dvma map at a fixed address, so specify
UVM_FLAG_FIXED.  Makes sparc boot with option KVA_GUARDPAGES.

ok miod@@, tested by deraadt@@
@
text
@d122 3
@


1.123
log
@Do not bother initializing bufpages in the md code if the computation is
exactly the same the mi could will use if bufinit() is invoked with
bufpages == 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.122 2009/08/11 18:46:32 miod Exp $	*/
d208 1
a208 1
                                UVM_ADV_NORMAL, 0)))
@


1.122
log
@With the SysV memory allocation changes, allocsys() doesn't do anything
anymore. Get rid of it completely.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.121 2009/08/09 10:40:18 blambert Exp $	*/
a180 7

	/*
	 * Determine how many buffers to allocate.
	 * We allocate bufcachepercent% of memory for buffer space.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
@


1.121
log
@Rototill system V message queues.

No longer allocate a static amount of memory for messages in MD
boot path; message queues, message metadata, and message data now
all use dynamic memory, which means that runtime sysctls should now
be trivial to implement.

Since I'm going to be around all week to fix any breakage, this should
probably just go in now.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.120 2009/08/02 16:28:39 beck Exp $	*/
a139 1
caddr_t allocsys(caddr_t);
a148 2
	caddr_t v;
	int sz;
a182 12
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addresses.
	 */
	sz = (int)allocsys((caddr_t)0);

	if ((v = (caddr_t)uvm_km_alloc(kernel_map, round_page(sz))) == 0)
		panic("startup: no room for tables");

	if (allocsys(v) - v != sz)
		panic("startup: table size inconsistency");

	/*
a248 20
}

/*
 * Allocate space for system data structures.  We are given
 * a starting virtual address and we return a final virtual
 * address; along the way we set each data structure pointer.
 *
 * You call allocsys() with 0 to find out how much space we want,
 * allocate that much and fill it with zeroes, and then call
 * allocsys() again with the correct base virtual address.
 */
caddr_t
allocsys(v)
	caddr_t v;
{

#define	valloc(name, type, num) \
	    v = (caddr_t)(((name) = (type *)v) + (num))

	return (v);
@


1.120
log
@
Dynamic buffer cache support - a re-commit of what was backed out
after c2k9

allows buffer cache to be extended and grow/shrink dynamically

tested by many, ok oga@@, "why not just commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.119 2009/07/13 19:50:00 kettenis Exp $	*/
a60 3
#ifdef SYSVMSG
#include <sys/msg.h>
#endif
a281 6
#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
@


1.119
log
@Add a somewhat minimal bus_dma(9) implementation.  Only fully implemented for
the sun4m iommu.  Bits and pieces from NetBSD, with some additional tweaks
and a bus_dmamap_load_mbuf() implementation from myself.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.118 2009/06/15 17:01:26 beck Exp $	*/
a205 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.118
log
@Back out all the buffer cache changes I committed during c2k9. This reverts three
commits:

1) The sysctl allowing bufcachepercent to be changed at boot time.
2) The change moving the buffer cache hash chains to a red-black tree
3) The dynamic buffer cache (Which depended on the earlier too).

ok on the backout from marco and todd
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.117 2009/06/03 21:30:20 beck Exp $	*/
d74 1
d1060 198
@


1.117
log
@add kern.bufcachepercent sysctl to allow adjusting the buffer cache
size on a running system.
ok art@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.116 2008/06/27 17:22:15 miod Exp $	*/
d205 6
@


1.116
log
@Clear swap encryption keys before dumping a kernel image.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.115 2008/04/09 16:58:10 deraadt Exp $	*/
a204 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.115
log
@Add new stub uvm_shutdown() and call it from the right place in MD boot()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.115 2008/04/09 16:50:29 deraadt Exp $	*/
d69 1
d805 4
@


1.114
log
@ctob/btoc -> ptoa/atop

from Rodolfo Gouveia
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.113 2007/06/06 17:15:12 deraadt Exp $	*/
d678 2
@


1.113
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.112 2007/05/29 20:36:48 deraadt Exp $	*/
d183 2
a184 2
	printf("real mem = %u (%uMB)\n", ctob(physmem),
	    ctob(physmem)/1024/1024);
@


1.112
log
@start of dumpconf() unification, which one day we can pray will be MI
(and part of setroot); ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.111 2007/05/26 20:26:51 pedro Exp $	*/
d777 2
a778 2
	daddr_t blkno;
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
@


1.111
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.110 2007/05/23 20:33:47 pvalchev Exp $	*/
d726 1
a726 1
dumpconf()
d730 4
a733 2
	if (dumpdev == NODEV || bdevsw[major(dumpdev)].d_psize == 0)
		/* No usable dump device */
a734 2

	nblks = (*bdevsw[major(dumpdev)].d_psize)(dumpdev);
@


1.110
log
@Print real/available memory in MB as well as bytes in dmesg, and unify
architectures to print it the same way.
ok henning, miod; i386 part from tom
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.109 2006/06/29 17:53:35 miod Exp $	*/
a111 6
#ifdef	NBUF
int	nbuf = NBUF;
#else
int	nbuf = 0;
#endif

a150 1
	unsigned i;
a152 1
	int base, residual;
a157 1
	vsize_t size;
d198 6
a203 11
        /*
         * allocate virtual and physical memory for the buffers.
         */
        size = MAXBSIZE * nbuf;         /* # bytes for buffers */

        /* allocate VM for buffers... area is not managed by VM system */
        if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(size),
                    NULL, UVM_UNKNOWN_OFFSET, 0,
                    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
                                UVM_ADV_NORMAL, 0)))
        	panic("cpu_startup: cannot allocate VM for buffers");
d205 5
a209 34
        minaddr = (vaddr_t) buffers;
        if ((bufpages / nbuf) >= btoc(MAXBSIZE)) {
        	bufpages = btoc(MAXBSIZE) * nbuf; /* do not overallocate RAM */
        }
        base = bufpages / nbuf;
        residual = bufpages % nbuf;

        /* now allocate RAM for buffers */
	for (i = 0 ; i < nbuf ; i++) {
		vaddr_t curbuf;
		vsize_t curbufsize;
		struct vm_page *pg;

		/*
		 * each buffer has MAXBSIZE bytes of VM space allocated.  of
		 * that MAXBSIZE space we allocate and map (base+1) pages
		 * for the first "residual" buffers, and then we allocate
		 * "base" pages for the rest.
		 */
		curbuf = (vaddr_t) buffers + (i * MAXBSIZE);
		curbufsize = PAGE_SIZE * ((i < residual) ? (base+1) : base);

		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: "
				    "not enough RAM for buffer cache");
			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
				VM_PROT_READ|VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
	}
	pmap_update(pmap_kernel());
a262 2
	printf("using %d buffers containing %d bytes of memory\n",
		nbuf, bufpages * PAGE_SIZE);
a295 25
	/*
	 * Determine how many buffers to allocate (enough to
	 * hold 5% of total physical memory, but at least 16).
	 * Allocate 1/2 as many swap buffer headers as file i/o buffers.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}
	if (nbuf > 200)
		nbuf = 200;	/* or we run out of PMEGS */
	/* Restrict to at most 70% filled kvm */
	if (nbuf * MAXBSIZE >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) * 7 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 7 / 10;

	/* More buffer pages than fits into the buffers is senseless.  */
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;

	valloc(buf, struct buf, nbuf);
@


1.109
log
@If invoking mapdev() with a non-aligned pa, make sure we allocate enough pages
if we cross a page boundary; really only necessary for some sun4 tricky
attachments, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.108 2006/06/09 06:41:44 miod Exp $	*/
d192 2
a193 1
	printf("real mem = %d\n", ctob(physmem));
d304 2
a305 1
	printf("avail mem = %ld\n", ptoa(uvmexp.free));
@


1.108
log
@{x,}ldcontrolb() codepath is SUN4-only, so don't bother checking for Lfsbail
in mem_access_fault4m.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.107 2005/09/25 20:04:03 miod Exp $	*/
d985 1
a985 1
	paddr_t pa;
d993 2
a994 5
	size = round_page(size);
	if (size == 0)
		panic("mapdev: zero size");

	if (virt)
d996 3
a998 1
	else {
d1004 4
a1007 1
	ret = (void *)(va | (((u_long)phys->rr_paddr + offset) & PGOFSET));
d1010 1
a1010 1
	pa = trunc_page((vaddr_t)phys->rr_paddr + offset);
@


1.107
log
@On Sun4m, be sure to steal the overlapping part of the iommu dvma space
and kernel_map from the latter. Otherwise, very bad things happen when
kernel_map usage grows.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.106 2005/08/18 18:40:51 kettenis Exp $	*/
a1092 1
#endif /* SUN4 */
a1103 5
	if (CPU_ISSUN4M) {
		printf("warning: ldcontrolb called in sun4m\n");
		return 0;
	}

d1117 1
@


1.106
log
@Skip (trap) instruction in cpu_fork() instead of proc_trampoline().
Add special handling for init(8) in setregs().
Fixes returning from fork(2) in the child with a pending signal.
ok deraadt@@, art@@ (screaming in agony)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.105 2005/04/11 15:13:01 deraadt Exp $	*/
d268 15
d287 1
@


1.105
log
@use MD #define to choose stackgap size per-architecture.  on sparc, special
case sun4c/sun4 -- because address space is more constrained
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.104 2005/03/23 17:14:46 miod Exp $	*/
d416 5
@


1.104
log
@Move wzero() and wcopy() from machdep.c to where they are really used.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.103 2005/03/23 17:12:26 miod Exp $	*/
d76 1
d172 6
@


1.103
log
@Match power on the SPARCbook's auxio2, but prefer tctrl poweroff if
both power0 and tctrl0 are configured.

This allows installation media to poweroff quickly on SPARCbooks.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.102 2004/09/29 07:35:14 miod Exp $	*/
a1093 70
}

void
wzero(vb, l)
	void *vb;
	u_int l;
{
	u_char *b = vb;
	u_char *be = b + l;
	u_short *sp;

	if (l == 0)
		return;

	/* front, */
	if ((u_long)b & 1)
		*b++ = 0;

	/* back, */
	if (b != be && ((u_long)be & 1) != 0) {
		be--;
		*be = 0;
	}

	/* and middle. */
	sp = (u_short *)b;
	while (sp != (u_short *)be)
		*sp++ = 0;
}

void
wcopy(vb1, vb2, l)
	const void *vb1;
	void *vb2;
	u_int l;
{
	const u_char *b1e, *b1 = vb1;
	u_char *b2 = vb2;
	u_short *sp;
	int bstore = 0;

	if (l == 0)
		return;

	/* front, */
	if ((u_long)b1 & 1) {
		*b2++ = *b1++;
		l--;
	}

	/* middle, */
	sp = (u_short *)b1;
	b1e = b1 + l;
	if (l & 1)
		b1e--;
	bstore = (u_long)b2 & 1;

	while (sp < (u_short *)b1e) {
		if (bstore) {
			b2[1] = *sp & 0xff;
			b2[0] = *sp >> 8;
		} else
			*((short *)b2) = *sp;
		sp++;
		b2 += 2;
	}

	/* and back. */
	if (l & 1)
		*b2 = *b1e;
@


1.102
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.101 2004/07/06 21:05:36 deraadt Exp $	*/
d87 2
d90 1
a90 1
#include "power.h"
d448 1
a448 1
#if (NAUXREG > 0) || (NLED > 0)
a729 1
#if NPOWER > 0 || NTCTRL >0
a730 3
#if NPOWER > 0
			powerdown();
#endif
d734 3
a736 1
#endif /* NPOWER || MTCTRL */
@


1.101
log
@only pull in a.out stuff if COMPAT_SUNOS
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.100 2004/05/30 21:52:49 deraadt Exp $	*/
d286 3
@


1.100
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.99 2004/05/23 02:59:05 deraadt Exp $	*/
d990 1
a997 1
#ifdef COMPAT_SUNOS
a1000 1
#endif
d1003 1
@


1.99
log
@Three years ago, Mike Frantzen invented StackGhost -- a simple tweak
to the register window spill/fill routines which made buffer overflows
much more difficult to exploit.  This code was integrated (and optimized)
into OpenBSD/sparc, but could not be enabled because the interface changes
affected gdb deeply.  Mike and I (independently) failed to write gdb
support, so StackGhost was left disabled. Until today, two years later..
because Mark Kettenis has written the neccessary code!  Here comes the 1
line diff that enables StackGhost!  Thanks Mark!
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.98 2004/03/10 23:02:54 tom Exp $	*/
d356 2
a357 1
	/* Setup the process StackGhost cookie which will be XORed into
a375 1

@


1.98
log
@Ensure that we obey a user's ddb> boot reboot command even if the system
is cold (during startup).

This adds RB_USERREQ to sys/reboot.h, uses it in the ddb commands, and
ensures that */*/machdep.c:boot() won't set RB_HALT when cold if this
flag is set.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.97 2004/02/19 18:46:18 miod Exp $	*/
d359 1
a359 1
	p->p_addr->u_pcb.pcb_wcookie = 0;	/* XXX later arc4random(); */
@


1.97
log
@Kill <sys/clist.h> - nothing uses it since years.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.96 2003/12/20 00:49:46 miod Exp $	*/
d685 3
a687 1
		howto |= RB_HALT;
@


1.96
log
@Pass -Wformat.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.95 2003/12/18 23:38:46 deraadt Exp $	*/
a54 1
#include <sys/clist.h>
@


1.95
log
@oops; pointed out by bruno
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.94 2003/12/17 22:05:09 deraadt Exp $	*/
d865 1
a865 1
		printf("@@%p:",maddr);
@


1.94
log
@attempt to power down voyager (untested); miod ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.93 2003/06/02 23:27:55 millert Exp $	*/
d733 1
a733 1
			prom_interpret("power-off");
@


1.93
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.92 2003/06/02 00:01:27 art Exp $	*/
d732 2
a734 1
#endif /* NPOWER || MTCTRL */
@


1.92
log
@Initialize the hint for uvm_km_suballoc.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.91 2003/01/09 22:27:10 miod Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.91
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.90 2002/12/17 23:11:32 millert Exp $	*/
d253 1
@


1.90
log
@Make SysV-style shared memory and semaphore limits sysctl'able.
Instead of allocating a static amount of memory for the data
structures via valloc() in allocsys(), allocate things dynamically
using pool(9) when possible and malloc(9) when not.  The various
members of struct seminfo and struct shminfo are in kern.seminfo
and kern.shminfo respectively (not all members of kern.seminfo are
changable).

The data structures used still leave something to be desired but
things are not made worse in that respect by this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.89 2002/11/22 23:08:49 deraadt Exp $	*/
d581 2
a582 1
	    suword(&((struct rwindow *)newsp)->rw_in[6], oldsp)) {
@


1.89
log
@new sysctl: machdep.v8mul says whether the kernel replaced the mul/div/rem
stubs, so that userland can do the same.  we cannot just determine based
on sun4m, because cypress (at least) is a sun4m cpu without the instructions
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.88 2002/11/10 21:23:09 miod Exp $	*/
a68 6
#ifdef SYSVSEM
#include <sys/sem.h>
#endif
#ifdef SYSVSHM
#include <sys/shm.h>
#endif
a307 12
#ifdef SYSVSHM
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
	valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
#endif
#ifdef SYSVSEM
	valloc(sema, struct semid_ds, seminfo.semmni);
	valloc(sem, struct sem, seminfo.semmns);
	/* This is pretty disgusting! */
	valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
#endif
@


1.88
log
@Use appropriate VM_MAP constants rather than hardcoded values in
uvm_map_create() and uvm_km_suballoc().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.87 2002/11/07 04:39:14 art Exp $	*/
d469 1
d504 2
@


1.87
log
@Don't uvm_useracc the user sigcontext in sys_sigreturn and then access
the user addresses directly from the kernel. copyin is faster and can
correctly deal properly with mappings that uvm_useracc thinks are
correct but will fault anyway (to figure out how to generate such
mappings is left as en excercise for the reader).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.86 2002/10/24 19:37:00 fgsch Exp $	*/
d269 2
a270 1
	phys_map = uvm_map_create(pmap_kernel(), dvma_base, dvma_end, 1);
@


1.86
log
@Add missing pmap_update(9) after pmap_kenter_pa(9); art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.84 2002/07/20 19:24:56 art Exp $	*/
d653 1
a653 1
	struct sigcontext *scp;
d655 1
d666 2
a667 3
	scp = SCARG(uap, sigcntxp);
	if ((int)scp & 3 || uvm_useracc((caddr_t)scp, sizeof *scp, B_WRITE) == 0)
		return (EINVAL);
d674 1
a674 1
	if (((scp->sc_pc | scp->sc_npc) & 3) != 0)
d677 7
a683 7
	tf->tf_psr = (tf->tf_psr & ~PSR_ICC) | (scp->sc_psr & PSR_ICC);
	tf->tf_pc = scp->sc_pc;
	tf->tf_npc = scp->sc_npc;
	tf->tf_global[1] = scp->sc_g1;
	tf->tf_out[0] = scp->sc_o0;
	tf->tf_out[6] = scp->sc_sp;
	if (scp->sc_onstack & 1)
d687 1
a687 1
	p->p_sigmask = scp->sc_mask & ~sigcantmask;
@


1.85
log
@Neuter the machdep.vsyncblank sysctl, as this setting is now controlled
by wsconsctl.
ok art@@
@
text
@d253 2
d1000 1
@


1.84
log
@Instead of copying out the signal trampoline on top of the stack, create
an uvm aobj, copy out the signal trampoline into it and share that page
among all processes for the same emulation.

This also requires us to actually be able to tell signal code where the
trampoline is located, so introduce a new field in struct proc - p_sigcode
that is a pointer to sigcode. This allows us to remove all the ugly
calculations of the signal trampoline address done in every sendsig
function in the tree (that's why so many files are changed).

Tested by various people. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.83 2002/06/14 04:16:06 art Exp $	*/
a140 1
int	sparc_vsyncblank = 0;
a471 4
	case CPU_VSYNCBLANK:
		ret = sysctl_int(oldp, oldlenp, newp, newlen,
		    &sparc_vsyncblank);
		return (ret);
@


1.83
log
@sysctl for getting the cputype.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.82 2002/03/23 13:28:34 espie Exp $	*/
a527 2
	extern char sigcode[], esigcode[];
#define	szsigcode	(esigcode - sigcode)
d625 1
a625 1
		caddr = (int)PS_STRINGS - szsigcode;
@


1.82
log
@Add variables for config(8) -e time tweak of systemV shared memory
parameters.

Ok millert@@, miod@@, maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.81 2002/03/14 01:26:44 millert Exp $	*/
d503 2
@


1.81
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.80 2002/02/20 22:28:23 deraadt Exp $	*/
d313 3
@


1.80
log
@frantzen's stackghost code.  wcookie is set at 0 right now, until debugger
support added (i mean, written)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.79 2002/02/17 22:59:53 maja Exp $	*/
d156 3
a158 3
caddr_t allocsys __P((caddr_t));
void	dumpsys __P((void));
void	stackdump __P((void));
d829 1
a829 1
	int (*dump)	__P((dev_t, daddr_t, caddr_t, size_t));
d1011 1
a1011 1
	extern int sunos_exec_aout_makecmds __P((struct proc *, struct exec_package *));
@


1.79
log
@Patch from Daniel Lucq <daniel@@lucq.org>

The patch allows you to change the value of NMBCLUSTERS, BUFCACHEPERCENT
and NKMEMPAGES using the config command, instead of recompiling the kernel.

This is the kernel part of the patch. I have compiled it on i386, sparc64,
alpha and macppc. -moj ok art@@ maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.78 2002/01/23 17:51:52 art Exp $	*/
d81 2
d372 21
@


1.78
log
@move mb_map allocation to mbinit()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.77 2002/01/23 17:35:56 art Exp $	*/
d123 5
d133 1
a325 3
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif
d332 1
a332 1
		bufpages = physmem * BUFCACHEPERCENT / 100;
@


1.77
log
@move definition of mb_map from zillions of machdep.c to uipc_mbuf.c
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.76 2002/01/16 20:50:17 miod Exp $	*/
a274 2
	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				 VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
@


1.76
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.75 2001/12/19 08:58:05 art Exp $	*/
a112 1
struct vm_map *mb_map = NULL;
@


1.75
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.74 2001/12/08 02:24:07 art Exp $	*/
a52 1
#include <sys/map.h>
@


1.74
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.73 2001/11/28 16:13:29 art Exp $	*/
a247 1
	pmap_update(pmap_kernel());
a870 1
			pmap_update(pmap_kernel());
a873 1
			pmap_update(pmap_kernel());
a977 1
	pmap_update(pmap_kernel());
@


1.74.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.78 2002/01/23 17:51:52 art Exp $	*/
d53 1
d114 1
d278 2
@


1.74.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.74.2.1 2002/01/31 22:55:23 niklas Exp $	*/
a80 2
#include <dev/rndvar.h>

a122 5

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

a127 1
int	bufcachepercent = BUFCACHEPERCENT;
d148 3
a150 3
caddr_t allocsys(caddr_t);
void	dumpsys(void);
void	stackdump(void);
a305 3
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
d321 3
d330 1
a330 1
		bufpages = physmem * bufcachepercent / 100;
a368 21
	/* Setup the process StackGhost cookie which will be XORed into
	 * the return pointer as register windows are over/underflowed
	 */
	p->p_addr->u_pcb.pcb_wcookie = 0;	/* XXX later arc4random(); */

	/* The cookie needs to guarantee invalid alignment after the XOR */
	switch (p->p_addr->u_pcb.pcb_wcookie % 3) {
	case 0: /* Two lsb's already both set except if the cookie is 0 */
		p->p_addr->u_pcb.pcb_wcookie |= 0x3;
		break;
	case 1: /* Set the lsb */
		p->p_addr->u_pcb.pcb_wcookie = 1 |
			(p->p_addr->u_pcb.pcb_wcookie & ~0x3);
		break;
	case 2: /* Set the second most lsb */
		p->p_addr->u_pcb.pcb_wcookie = 2 |
			(p->p_addr->u_pcb.pcb_wcookie & ~0x3);
		break;
	}


d804 1
a804 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d989 1
a989 1
	extern int sunos_exec_aout_makecmds(struct proc *, struct exec_package *);
@


1.74.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.74.2.2 2002/06/11 03:38:17 art Exp $	*/
d141 1
a254 1

d474 4
a503 2
	case CPU_CPUTYPE:
		return (sysctl_rdint(oldp, oldlenp, newp, cputyp));
d527 2
d626 1
a626 1
		caddr = p->p_sigcode;
@


1.74.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d69 6
d269 1
a269 2
	phys_map = uvm_map_create(pmap_kernel(), dvma_base, dvma_end,
	    VM_MAP_INTRSAFE);
d313 12
a467 1
	extern int v8mul;
a501 2
	case CPU_V8MUL:
		return (sysctl_rdint(oldp, oldlenp, newp, v8mul));
d595 1
a595 2
	    copyout(&oldsp, &((struct rwindow *)newsp)->rw_in[6],
	      sizeof(register_t)) != 0) {
d653 1
a653 1
	struct sigcontext ksc;
a654 1
	int error;
d665 3
a667 2
	if ((error = copyin(SCARG(uap, sigcntxp), &ksc, sizeof(ksc))) != 0)
		return (error);
d674 1
a674 1
	if (((ksc.sc_pc | ksc.sc_npc) & 3) != 0)
d677 7
a683 7
	tf->tf_psr = (tf->tf_psr & ~PSR_ICC) | (ksc.sc_psr & PSR_ICC);
	tf->tf_pc = ksc.sc_pc;
	tf->tf_npc = ksc.sc_npc;
	tf->tf_global[1] = ksc.sc_g1;
	tf->tf_out[0] = ksc.sc_o0;
	tf->tf_out[6] = ksc.sc_sp;
	if (ksc.sc_onstack & 1)
d687 1
a687 1
	p->p_sigmask = ksc.sc_mask & ~sigcantmask;
@


1.73
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.72 2001/11/28 13:47:39 art Exp $	*/
d248 1
d872 1
d876 1
d981 1
@


1.72
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.71 2001/11/24 17:53:41 miod Exp $	*/
d113 3
a115 3
vm_map_t exec_map = NULL;
vm_map_t mb_map = NULL;
vm_map_t phys_map = NULL;
@


1.71
log
@Harmonize boot() logic across arches:
- ensure RB_DUMP | RB_HALT will cause a dump
- or RB_HALT if (cold)
While there, honor RB_TIMEBAD on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.70 2001/11/22 09:49:43 art Exp $	*/
d212 1
a212 1
                                UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
@


1.70
log
@more pmap_enter vs. pmap_kenter.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.69 2001/11/22 09:23:51 art Exp $	*/
d678 1
d680 2
a681 2
		printf("halted\n\n");
		romhalt();
d707 8
a715 1
		doshutdownhooks();
a732 2
	if (howto & RB_DUMP)
		dumpsys();
a733 1
	doshutdownhooks();
@


1.69
log
@Use pmap_map to map the msg buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.68 2001/11/09 15:25:55 art Exp $	*/
d940 1
a940 1
	vaddr_t v;
d954 1
a954 1
		v = trunc_page(virt);
d956 1
a956 1
		v = iobase;
d961 1
a961 1
	ret = (void *)(v | (((u_long)phys->rr_paddr + offset) & PGOFSET));
d968 3
a970 3
		pmap_enter(pmap_kernel(), v, pa | pmtype | PMAP_NC,
			   VM_PROT_READ | VM_PROT_WRITE, PMAP_WIRED);
		v += PAGE_SIZE;
@


1.68
log
@nswbuf hasn't been used for ages. gc.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.67 2001/11/07 01:18:00 art Exp $	*/
d179 1
a179 2
	pmap_enter(pmap_kernel(), MSGBUF_VA, 0x0, VM_PROT_READ|VM_PROT_WRITE,
	    VM_PROT_READ | VM_PROT_WRITE | PMAP_WIRED);
@


1.67
log
@Add an alignment argument to uvm_map that specifies an alignment hint
for the virtual address.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.66 2001/11/06 02:49:22 art Exp $	*/
a119 1
int	nswbuf = 0;
a351 5
	if (nswbuf == 0) {
		nswbuf = (nbuf / 2) &~ 1;	/* force even */
		if (nswbuf > 256)
			nswbuf = 256;		/* sanity */
	}
@


1.66
log
@remove the last uses of vm/vm_page.h
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.65 2001/09/19 20:50:57 mickey Exp $	*/
d212 1
a212 1
                    NULL, UVM_UNKNOWN_OFFSET,
@


1.65
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.64 2001/09/17 15:18:16 art Exp $	*/
d80 1
a80 2
#include <vm/vm.h>
#include <vm/vm_page.h>
@


1.64
log
@Use pmap_k* to map the buffer cache.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.63 2001/09/12 00:23:34 art Exp $	*/
a80 1
#include <vm/vm_kern.h>
@


1.63
log
@mbutl no more
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.62 2001/08/23 14:01:03 art Exp $	*/
d246 2
a247 3
			pmap_enter(kernel_map->pmap, curbuf,
			    VM_PAGE_TO_PHYS(pg), VM_PROT_READ | VM_PROT_WRITE,
			    VM_PROT_READ | VM_PROT_WRITE | PMAP_WIRED);
@


1.62
log
@We can now move timeout_init into main().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.61 2001/08/23 12:02:05 art Exp $	*/
d282 1
a282 1
	mb_map = uvm_km_suballoc(kernel_map, (vaddr_t *)&mbutl, &maxaddr,
@


1.61
log
@Remove even more old timeout tentacles.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.60 2001/07/25 13:25:33 art Exp $	*/
a283 5
	/*
	 * Initialize timeouts
	 */
	timeout_init();

@


1.60
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.59 2001/06/25 00:43:16 mickey Exp $	*/
a317 1
	valloc(timeouts, struct timeout, ntimeout);
@


1.59
log
@cold is in systm now
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.58 2001/05/17 18:41:50 provos Exp $	*/
d183 1
a183 1
	    TRUE, VM_PROT_READ | VM_PROT_WRITE);
d248 1
a248 1
			    TRUE, VM_PROT_READ | VM_PROT_WRITE);
d985 1
a985 1
			   VM_PROT_READ | VM_PROT_WRITE, 1, 0);
@


1.58
log
@convert mbuf and cluster allocation to pool, mostly from NetBSD
okay art@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.57 2001/05/10 10:34:47 art Exp $	*/
a692 1
	extern int cold;
@


1.57
log
@UVM is no longer optional on sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.56 2001/05/05 22:34:19 art Exp $	*/
a281 7
	/*
	 * Finally, allocate mbuf pool.  Since mclrefcnt is an off-size
	 * we use the more space efficient malloc in place of kmem_alloc.
	 */
	mclrefcnt = (char *)malloc(NMBCLUSTERS+PAGE_SIZE/MCLBYTES,
				   M_MBUF, M_NOWAIT);
	bzero(mclrefcnt, NMBCLUSTERS+PAGE_SIZE/MCLBYTES);
@


1.56
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.55 2001/05/05 21:26:41 art Exp $	*/
a95 1
#if defined(UVM)
a96 1
#endif
a114 1
#if defined(UVM)
a117 3
#else
vm_map_t buffer_map;
#endif
a200 1
#if defined(UVM)
a201 3
#else
	if ((v = (caddr_t)kmem_alloc(kernel_map, round_page(sz))) == 0)
#endif
a206 1
#if defined(UVM)
a252 35
#else
	/*
	 * Now allocate buffers proper.  They are different than the above
	 * in that they usually occupy more virtual memory than physical.
	 */
	size = MAXBSIZE * nbuf;

	buffer_map = kmem_suballoc(kernel_map, (vaddr_t *)&buffers,
	    &maxaddr, size, TRUE);

	minaddr = (vaddr_t)buffers;
	if (vm_map_find(buffer_map, vm_object_allocate(size), (vaddr_t)0,
			&minaddr, size, FALSE) != KERN_SUCCESS)
		panic("startup: cannot allocate buffers");

	base = bufpages / nbuf;
	residual = bufpages % nbuf;

	for (i = 0; i < nbuf; i++) {
		vsize_t curbufsize;
		vaddr_t curbuf;

		/*
		 * First <residual> buffers get (base+1) physical pages
		 * allocated for them.  The rest get (base) physical pages.
		 *
		 * The rest of each buffer occupies virtual space,
		 * but has no physical memory allocated for it.
		 */
		curbuf = (vaddr_t)buffers + i * MAXBSIZE;
		curbufsize = PAGE_SIZE * (i < residual ? base+1 : base);
		vm_map_pageable(buffer_map, curbuf, curbuf+curbufsize, FALSE);
		vm_map_simplify(buffer_map, curbuf);
	}
#endif
a256 1
#if defined(UVM)
a258 4
#else
	exec_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
				 16*NCARGS, TRUE);
#endif
a266 1
#if defined(UVM)
a267 3
#else
	phys_map = vm_map_create(pmap_kernel(), dvma_base, dvma_end, 1);
#endif
a274 1
#if defined(UVM)
a276 4
#else
	if (kmem_alloc_wait(phys_map, (dvma_end-dvma_base)) != dvma_base)
		panic("unable to allocate from DVMA map");
#endif
a288 1
#if defined(UVM)
a290 4
#else
	mb_map = kmem_suballoc(kernel_map, (vaddr_t *)&mbutl, &maxaddr,
			       VM_MBUF_SIZE, FALSE);
#endif
a298 1
#if defined(UVM)
a299 3
#else
	printf("avail mem = %ld\n", ptoa(cnt.v_free_count));
#endif
a373 3
#if !defined(UVM)
	valloc(swbuf, struct buf, nswbuf);
#endif
a666 1
#if defined(UVM)
a668 4
#else
	if ((int)scp & 3 || useracc((caddr_t)scp, sizeof *scp, B_WRITE) == 0)
		return (EINVAL);
#endif
a1026 1
#if defined(UVM)
a1029 5
#else
	printf("cnt: swtch %d, trap %d, sys %d, intr %d, soft %d, faults %d\n",
	    cnt.v_swtch, cnt.v_trap, cnt.v_syscall, cnt.v_intr, cnt.v_soft,
	    cnt.v_faults);
#endif
@


1.55
log
@Remove the (vaddr_t) casts inside the round_page and trunc_page macros.
We might want to use them on types that are bigger than vaddr_t.

Fix all callers that pass pointers without casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.54 2001/05/05 20:56:52 art Exp $	*/
a375 5

	/*
	 * Configure the system.  The cpu code will turn on the cache.
	 */
	configure();
@


1.54
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.53 2001/04/30 16:42:26 art Exp $	*/
d1070 1
a1070 1
	pa = trunc_page(phys->rr_paddr + offset);
@


1.53
log
@Move the zeroing of proc0 u area from cpu_startup to configure.
XXX - is this still necessary?
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.52 2000/11/07 11:25:24 art Exp $	*/
d250 1
a250 1
		curbufsize = CLBYTES * ((i < residual) ? (base+1) : base);
d294 1
a294 1
		curbufsize = CLBYTES * (i < residual ? base+1 : base);
d346 1
a346 1
	mclrefcnt = (char *)malloc(NMBCLUSTERS+CLBYTES/MCLBYTES,
d348 1
a348 1
	bzero(mclrefcnt, NMBCLUSTERS+CLBYTES/MCLBYTES);
d370 1
a370 1
		nbuf, bufpages * CLBYTES);
d425 1
a425 1
		bufpages = physmem * BUFCACHEPERCENT / (100 * CLSIZE);
d440 2
a441 2
	if (bufpages > nbuf * MAXBSIZE / CLBYTES)
		bufpages = nbuf * MAXBSIZE / CLBYTES;
@


1.52
log
@Cleanup some ifdefs in the powerdown code.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.51 2000/10/27 00:16:20 mickey Exp $	*/
a380 10

	/*
	 * Re-zero proc0's user area, to nullify the effect of the
	 * stack running into it during auto-configuration.
	 * XXX - should fix stack usage.
	 * XXX - there's a race here, as interrupts are enabled
	 */
	bzero(proc0paddr, sizeof(struct user));

	pmap_redzone();
@


1.51
log
@more precise BUFCACHEPERCENT calculations.
from gluk@@ptci.ru; deraadt@@ and niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.50 2000/06/23 00:55:55 fgsch Exp $	*/
a827 1
#endif
a833 1
#if NPOWER > 0 || NTCTRL >0
d835 1
a835 1
#endif
d837 1
a837 1
#endif
@


1.50
log
@ret should be there, wether auxreg/led is defined or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.49 2000/05/18 13:31:12 jason Exp $	*/
d435 1
a435 1
		bufpages = (physmem / ((100/BUFCACHEPERCENT) / CLSIZE));
@


1.49
log
@add machdep.vsyncblank sysctl for controlling whether vsync is disabled
when the monitor is blanked.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.48 2000/03/23 09:59:56 art Exp $	*/
d549 1
a549 1
	int ret, oldval;
d551 1
@


1.48
log
@New API for timeouts. Replaces the old timeout()/untimeout() API and
makes it the callers responsibility to allocate resources for the
timeouts.

This is a KISS implementation and does _not_ solve the problems of slow
handling of a large number of pending timeouts (this will be solved in
future work) (although hardclock is now guarateed to take constant time
for handling of timeouts).

Old timeout() and untimeout() are implemented as wrappers around the new
API and kept for compatibility. They will be removed as soon as all
subsystems are converted to use the new API.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.47 2000/03/16 22:11:02 art Exp $	*/
d144 1
d557 4
@


1.47
log
@Bring in some new UVM code from NetBSD (not current).

 - Introduce a new type of map that are interrupt safe and never allow faults
   in them. mb_map and kmem_map are made intrsafe.
 - Add "access protection" to uvm_vslock (to be passed down to uvm_fault and
   later to pmap_enter).
 - madvise(2) now works.
 - various cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.46 2000/02/22 19:28:01 deraadt Exp $	*/
d61 1
a61 1
#include <sys/callout.h>
d356 1
a356 1
	 * Initialize callouts
d358 1
a358 4
	callfree = callout;
	for (i = 1; i < ncallout; i++)
		callout[i-1].c_next = &callout[i];
	callout[i-1].c_next = NULL;
d408 1
a408 1
	valloc(callout, struct callout, ncallout);
@


1.46
log
@enlarge msgbuf, somewhat line netbsd did
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.45 2000/02/21 21:05:59 art Exp $	*/
d304 1
a304 1
				 16*NCARGS, TRUE, FALSE, NULL);
d350 1
a350 1
				 VM_MBUF_SIZE, FALSE, FALSE, NULL);
@


1.45
log
@move fpproc into the cpuinfo structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.44 2000/02/15 16:32:41 art Exp $	*/
a141 4
extern struct msgbuf msgbuf;
struct	msgbuf *msgbufp = &msgbuf;
int	msgbufmapped = 0;	/* not mapped until pmap_bootstrap */

d184 7
a391 10
	/*
	 * fix message buffer mapping, note phys addr of msgbuf is 0
	 */

	pmap_enter(pmap_kernel(), MSGBUF_VA, 0x0, VM_PROT_READ|VM_PROT_WRITE,
		   TRUE, VM_PROT_READ | VM_PROT_WRITE);
	if (CPU_ISSUN4)
		msgbufp = (struct msgbuf *)(MSGBUF_VA + 4096);
	else
		msgbufp = (struct msgbuf *)MSGBUF_VA;
@


1.44
log
@Use extents instead of rmaps to handle dvma space.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43 1999/11/26 16:21:01 art Exp $	*/
d94 1
d506 1
a506 1
		if (p == fpproc) {
d508 1
a508 1
			fpproc = NULL;
@


1.43
log
@Use round_page instead of some home-made macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.42 1999/10/29 14:36:02 art Exp $	*/
d78 1
d159 1
a159 2
struct map *dvmamap;
static int ndvmamap;	/* # of entries in dvmamap */
d332 4
a335 2
	rminit(dvmamap, btoc((dvma_end-dvma_base)),
		vtorc(dvma_base), "dvmamap", ndvmamap);
a469 5
	/*
	 * Allocate DVMA slots for 1/4 of the number of i/o buffers
	 * and one for each process too (PHYSIO).
	 */
	valloc(dvmamap, struct map, ndvmamap = maxproc + ((nbuf / 4) &~ 1));
@


1.43.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.44 2000/02/15 16:32:41 art Exp $	*/
a77 1
#include <sys/extent.h>
d158 2
a159 1
struct extent *dvmamap_extent;
d332 2
a333 4
	dvmamap_extent = extent_create("dvmamap", dvma_base, dvma_end,
				       M_DEVBUF, NULL, 0, EX_NOWAIT);
	if (dvmamap_extent == 0)
		panic("unable to allocate extent for dvma");
d468 5
@


1.43.2.2
log
@sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.45 2000/02/21 21:05:59 art Exp $	*/
a93 1
#include <sparc/sparc/cpuvar.h>
d505 1
a505 1
		if (p == cpuinfo.fpproc) {
d507 1
a507 1
			cpuinfo.fpproc = NULL;
@


1.43.2.3
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d142 4
a187 7
	/*
	 * fix message buffer mapping, note phys addr of msgbuf is 0
	 */
	pmap_enter(pmap_kernel(), MSGBUF_VA, 0x0, VM_PROT_READ|VM_PROT_WRITE,
	    TRUE, VM_PROT_READ | VM_PROT_WRITE);
	initmsgbuf((caddr_t)(MSGBUF_VA + (CPU_ISSUN4 ? 4096 : 0)), MSGBUFSIZE);

d389 10
@


1.43.2.4
log
@Sync with -current
@
text
@d61 1
a61 1
#include <sys/timeout.h>
d304 1
a304 1
				 16*NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);
d350 1
a350 1
				 VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
d356 1
a356 1
	 * Initialize timeouts
d358 4
a361 1
	timeout_init();
d411 1
a411 1
	valloc(timeouts, struct timeout, ntimeout);
@


1.43.2.5
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.52 2000/11/07 11:25:24 art Exp $	*/
a143 1
int	sparc_vsyncblank = 0;
d434 1
a434 1
		bufpages = physmem * BUFCACHEPERCENT / (100 * CLSIZE);
d548 1
a548 1
	int oldval;
a549 1
	int ret;
a555 4
	case CPU_VSYNCBLANK:
		ret = sysctl_int(oldp, oldlenp, newp, newlen,
		    &sparc_vsyncblank);
		return (ret);
d822 1
d829 1
d831 1
a831 1
#endif /* NPOWER || MTCTRL */
d833 1
a833 1
#endif /* SUN4M */
@


1.43.2.6
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43.2.5 2001/05/14 21:37:17 niklas Exp $	*/
d96 1
d98 1
d117 1
d121 3
d207 1
d209 3
d217 1
d250 1
a250 1
		curbufsize = PAGE_SIZE * ((i < residual) ? (base+1) : base);
d264 35
d303 1
d306 4
d318 1
d320 3
d330 1
d333 4
d342 8
d352 4
d364 1
d366 3
d370 1
a370 1
		nbuf, bufpages * PAGE_SIZE);
d376 15
d435 1
a435 1
		bufpages = physmem * BUFCACHEPERCENT / 100;
d450 2
a451 2
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;
d458 3
d754 1
d757 4
d792 1
d1080 1
a1080 1
	pa = trunc_page((vaddr_t)phys->rr_paddr + offset);
d1119 1
d1123 5
@


1.43.2.7
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43.2.6 2001/07/04 10:23:45 niklas Exp $	*/
d81 1
d183 1
a183 1
	    VM_PROT_READ | VM_PROT_WRITE | PMAP_WIRED);
d246 3
a248 2
			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
				VM_PROT_READ|VM_PROT_WRITE);
d282 1
a282 1
	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
d284 5
d318 1
d985 1
a985 1
			   VM_PROT_READ | VM_PROT_WRITE, PMAP_WIRED);
@


1.43.2.8
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d80 2
a81 1
#include <uvm/uvm_extern.h>
d121 1
d213 1
a213 1
                    NULL, UVM_UNKNOWN_OFFSET, 0,
d354 5
@


1.43.2.9
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43.2.8 2001/11/13 21:04:17 niklas Exp $	*/
d113 3
a115 3
struct vm_map *exec_map = NULL;
struct vm_map *mb_map = NULL;
struct vm_map *phys_map = NULL;
d179 2
a180 1
	pmap_map(MSGBUF_VA, 0, MSGBUFSIZE, VM_PROT_READ|VM_PROT_WRITE);
d213 1
a213 1
                                UVM_ADV_NORMAL, 0)))
a678 1
	/* If system is cold, just halt. */
d680 2
a681 2
		howto |= RB_HALT;
		goto haltsys;
a706 8

	if (howto & RB_DUMP)
		dumpsys();

haltsys:
	/* Run any shutdown hooks */
	doshutdownhooks();

d708 1
d726 2
d729 1
d941 1
a941 1
	vaddr_t va;
d955 1
a955 1
		va = trunc_page(virt);
d957 1
a957 1
		va = iobase;
d962 1
a962 1
	ret = (void *)(va | (((u_long)phys->rr_paddr + offset) & PGOFSET));
d969 3
a971 3
		pmap_kenter_pa(va, pa | pmtype | PMAP_NC,
		    VM_PROT_READ | VM_PROT_WRITE);
		va += PAGE_SIZE;
@


1.43.2.10
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 1
a81 2
#include <dev/rndvar.h>

d114 1
a124 5

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

a129 1
int	bufcachepercent = BUFCACHEPERCENT;
d277 2
d324 3
d333 1
a333 1
		bufpages = physmem * bufcachepercent / 100;
a370 21

	/* Setup the process StackGhost cookie which will be XORed into
	 * the return pointer as register windows are over/underflowed
	 */
	p->p_addr->u_pcb.pcb_wcookie = 0;	/* XXX later arc4random(); */

	/* The cookie needs to guarantee invalid alignment after the XOR */
	switch (p->p_addr->u_pcb.pcb_wcookie % 3) {
	case 0: /* Two lsb's already both set except if the cookie is 0 */
		p->p_addr->u_pcb.pcb_wcookie |= 0x3;
		break;
	case 1: /* Set the lsb */
		p->p_addr->u_pcb.pcb_wcookie = 1 |
			(p->p_addr->u_pcb.pcb_wcookie & ~0x3);
		break;
	case 2: /* Set the second most lsb */
		p->p_addr->u_pcb.pcb_wcookie = 2 |
			(p->p_addr->u_pcb.pcb_wcookie & ~0x3);
		break;
	}

@


1.43.2.11
log
@Merge in -current from about a week ago
@
text
@d156 3
a158 3
caddr_t allocsys(caddr_t);
void	dumpsys(void);
void	stackdump(void);
d829 1
a829 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d1011 1
a1011 1
	extern int sunos_exec_aout_makecmds(struct proc *, struct exec_package *);
@


1.43.2.12
log
@Sync the SMP branch with 3.3
@
text
@d69 6
d141 1
a253 2
	pmap_update(pmap_kernel());

d268 1
a268 2
	phys_map = uvm_map_create(pmap_kernel(), dvma_base, dvma_end,
	    VM_MAP_INTRSAFE);
d312 9
a463 1
	extern int v8mul;
d470 4
a499 4
	case CPU_CPUTYPE:
		return (sysctl_rdint(oldp, oldlenp, newp, cputyp));
	case CPU_V8MUL:
		return (sysctl_rdint(oldp, oldlenp, newp, v8mul));
d523 2
d595 1
a595 2
	    copyout(&oldsp, &((struct rwindow *)newsp)->rw_in[6],
	      sizeof(register_t)) != 0) {
d622 1
a622 1
		caddr = p->p_sigcode;
d653 1
a653 1
	struct sigcontext ksc;
a654 1
	int error;
d665 3
a667 2
	if ((error = copyin(SCARG(uap, sigcntxp), &ksc, sizeof(ksc))) != 0)
		return (error);
d674 1
a674 1
	if (((ksc.sc_pc | ksc.sc_npc) & 3) != 0)
d677 7
a683 7
	tf->tf_psr = (tf->tf_psr & ~PSR_ICC) | (ksc.sc_psr & PSR_ICC);
	tf->tf_pc = ksc.sc_pc;
	tf->tf_npc = ksc.sc_npc;
	tf->tf_global[1] = ksc.sc_g1;
	tf->tf_out[0] = ksc.sc_o0;
	tf->tf_out[6] = ksc.sc_sp;
	if (ksc.sc_onstack & 1)
d687 1
a687 1
	p->p_sigmask = ksc.sc_mask & ~sigcantmask;
a999 1
	pmap_update(pmap_kernel());
@


1.43.2.13
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43.2.12 2003/03/27 23:49:26 niklas Exp $	*/
d25 5
a29 1
 * 3. Neither the name of the University nor the names of its contributors
a252 1
	minaddr = vm_map_min(kernel_map);
@


1.43.2.14
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d732 1
a733 2
			rominterpret("power-off");
			printf("WARNING: powerdown failed!\n");
d864 1
a864 1
		printf("@@0x%x:", maddr);
@


1.43.2.15
log
@Merge with the trunk
@
text
@d55 1
d357 1
a357 2
	/*
	 * Setup the process StackGhost cookie which will be XORed into
d360 1
a360 1
	p->p_addr->u_pcb.pcb_wcookie = arc4random();
d377 1
d686 1
a686 3
		/* (Unless the user explicitly asked for reboot.) */
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
@


1.42
log
@Remove dead code.
!MACHINE_NONCONTIG && !MACHINE_NEW_NONCONTIG will not work anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.41 1999/09/07 03:42:48 jason Exp $	*/
a1137 2
#define round_up(x) (( (x) + (NBPG-1) ) & (~(NBPG-1)) )

d1139 1
a1139 1
	stop = round_up(va);
d1142 1
a1142 1
	while (round_up((u_long) fp) == stop) {
@


1.41
log
@allow powerdown via tctrl driver for tadpole; from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.40 1999/09/03 18:01:58 art Exp $	*/
a121 1
extern vaddr_t avail_end;
a193 3
#if !defined(MACHINE_NONCONTIG) && !defined(MACHINE_NEW_NONCONTIG)
	physmem = btoc(avail_end);
#endif
@


1.40
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.39 1999/08/24 09:54:55 art Exp $	*/
d102 4
d836 3
a839 1
			printf("attempting to power down...\n");
d841 6
a846 2
#else
			printf("WARNING: power not configured!\n");
@


1.39
log
@Opps. forgot this in the last uvm update
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38 1999/07/23 19:11:28 jason Exp $	*/
d253 2
a254 1
			    VM_PAGE_TO_PHYS(pg), VM_PROT_ALL, TRUE);
d390 2
a391 1
	pmap_enter(pmap_kernel(), MSGBUF_VA, 0x0, VM_PROT_READ|VM_PROT_WRITE, 1);
d1087 1
a1087 1
			   VM_PROT_READ | VM_PROT_WRITE, 1);
@


1.38
log
@Drivers for the FORCE CPU-5V:
o fga5000 vme-sbus bridge
o system config registers
o flash memory
and daadio VME board driver
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.37 1999/07/09 21:30:02 art Exp $	*/
d248 1
a248 1
			pg = uvm_pagealloc(NULL, 0, NULL);
@


1.37
log
@vm_offset_t -> {v,p}addr_t and vm_size_t -> {v,p}size_t
remove "register" keywords
Various cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.36 1999/05/22 21:22:30 weingart Exp $	*/
d101 1
d567 1
a567 1
#if (NLED > 0) || (NAUXREG > 0)
d582 3
@


1.36
log
@Add new vm_swap code for dynamic swap.  From netbsd, munged some by me, and
others.   syscall commit pending.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35 1999/04/22 18:51:49 art Exp $	*/
d117 1
a117 1
extern vm_offset_t avail_end;
d153 1
a153 1
vm_offset_t dvma_base, dvma_end;
d167 3
a169 3
	register unsigned i;
	register caddr_t v;
	register int sz;
d175 2
a176 2
	vm_offset_t minaddr, maxaddr;
	vm_size_t size;
d264 1
a264 1
	buffer_map = kmem_suballoc(kernel_map, (vm_offset_t *)&buffers,
d267 2
a268 2
	minaddr = (vm_offset_t)buffers;
	if (vm_map_find(buffer_map, vm_object_allocate(size), (vm_offset_t)0,
d276 2
a277 2
		vm_size_t curbufsize;
		vm_offset_t curbuf;
d286 1
a286 1
		curbuf = (vm_offset_t)buffers + i * MAXBSIZE;
d341 1
a341 1
	mb_map = uvm_km_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
d344 1
a344 1
	mb_map = kmem_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
d407 1
a407 1
	register caddr_t v;
d486 3
a488 3
	register struct trapframe *tf = p->p_md.md_tf;
	register struct fpstate *fs;
	register int psr;
d605 5
a609 5
	register struct proc *p = curproc;
	register struct sigacts *psp = p->p_sigacts;
	register struct sigframe *fp;
	register struct trapframe *tf;
	register int caddr, oonstack, oldsp, newsp;
d734 1
a734 1
	register struct proc *p;
d741 2
a742 2
	register struct sigcontext *scp;
	register struct trapframe *tf;
d788 1
a788 1
	register int howto;
d864 1
a864 1
	register int nblks, dumpblks;
d892 1
a892 1
static vm_offset_t dumpspace;
d902 1
a902 1
	dumpspace = (vm_offset_t)p;
d912 1
a912 1
	register int psize;
d914 1
a914 1
	register int (*dump)	__P((dev_t, daddr_t, caddr_t, size_t));
d916 2
a917 2
	register struct memarr *mp;
	register int nmem;
d954 2
a955 2
		register unsigned i = 0, n;
		register unsigned maddr = mp->addr;
d1044 2
d1049 2
a1050 2
	register struct rom_reg *phys;
	register int offset, virt, size;
d1052 4
a1055 4
	register vm_offset_t v;
	register vm_offset_t pa;
	register void *ret;
	static vm_offset_t iobase;
d1062 2
a1063 1
	if (size == 0) panic("mapdev: zero size");
@


1.35
log
@UVM fixes. Mostly changed function names.
New buffer allocation from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.34 1999/03/01 04:56:05 jason Exp $	*/
a412 1
	valloc(swapmap, struct map, nswapmap = maxproc * 2);
@


1.34
log
@led driver support for 4/[1236]00 machines
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.33 1998/03/25 07:54:59 jason Exp $	*/
d94 4
d110 5
d116 1
d190 1
a190 1
#ifndef MACHINE_NONCONTIG
d201 3
d205 1
d211 47
d291 1
a291 1

d296 4
d302 1
d311 3
d315 1
d323 4
d329 1
d340 4
d346 1
d358 3
d362 1
d462 1
d464 1
d755 4
d761 1
d1113 5
a1117 1

d1121 1
@


1.33
log
@Driver for the 8 leds on the back of sun4 machines.
@
text
@d495 1
a495 1
			led_sun4_cycle((caddr_t *)0);
@


1.32
log
@Changed declaration of maddr in the dumpsys() so it is an unsigned int,
old code semantics let it default to an int.  AFter careful inspection
of the surrounding code, it would appear that maddr has to be unsigned,
and that the original code was a bug.

Also added correct return type for sunos_exec_aout_makecmds() declaration.

Both fixes are required for building on gcc 2.8...
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 1998/02/26 10:39:04 johns Exp $	*/
d101 5
d471 1
a471 1
#if NAUXREG > 0
d481 1
a481 1
#if NAUXREG > 0
d490 2
a491 1
		if (!oldval && sparc_led_blink > oldval)
d493 5
@


1.31
log
@Backout of Jason's cpu init changes, causes an immediate panic on sun4m
machines..
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.29 1997/09/17 06:47:20 downsj Exp $	*/
d854 1
a854 1
		register maddr = mp->addr;
d992 1
a992 1
	extern sunos_exec_aout_makecmds __P((struct proc *, struct exec_package *));
@


1.30
log
@Change order of cpu initialization to force the correct dmesg output.
@
text
@a144 1
void	identifycpu __P((void));
d174 1
a174 1
	identifycpu();
@


1.29
log
@NETBSD_CURRENT_970916.  Lot's just ID changes, since changes don't apply to
us.  Includes some pmap changes, for which I don't have the original commit
message(s) handy.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 1997/08/25 08:38:48 downsj Exp $	*/
d145 1
d175 1
a175 1
	/*identifycpu();*/
@


1.28
log
@Implement LED blinking as a run-time configurable option via the sysctl
machdep.led_blink.

Rename auxreg.h because we need config to generate one now.
@
text
@d1 2
a2 2
/*	$OpenBSD: machdep.c,v 1.27 1997/08/08 08:27:30 downsj Exp $	*/
/*	$NetBSD: machdep.c,v 1.83 1997/07/29 10:04:44 fair Exp $ */
@


1.27
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d99 2
d125 3
d466 3
d475 17
@


1.26
log
@make powerdown conditional
@
text
@d1 2
a2 2
/*	$OpenBSD: machdep.c,v 1.25 1997/06/25 13:22:25 downsj Exp $ */
/*	$NetBSD: machdep.c,v 1.64 1996/05/19 04:12:56 mrg Exp $ */
d283 8
d395 3
a675 1
#if 1
d678 1
a678 1
		/* protect against curproc->p_stats.foo refs in sync()   XXX */
a680 1
#endif
d744 1
a744 1
		nblks = (*bdevsw[major(dumpdev)].d_psize)(dumpdev);
d758 1
a758 1
		/*
d811 1
a811 1
		major(dumpdev), minor(dumpdev), dumplo);
d903 1
a903 1
		printf("  pc = %x  args = (%x, %x, %x, %x, %x, %x, %x) fp = %p\n",
a910 8
int bt2pmt[] = {
	PMAP_OBIO,
	PMAP_OBIO,
	PMAP_VME16,
	PMAP_VME32,
	PMAP_OBIO
};

d915 1
a915 1
 *				       0, sizeof(struct mydev), pmtype);
d920 1
a920 1
mapdev(phys, virt, offset, size, bustype)
a922 1
	register int bustype;
d948 1
a948 3
	pmtype = (CPU_ISSUN4M)
			? (phys->rr_iospace << PMAP_SHFT4M)
			: bt2pmt[bustype];
d994 1
a994 1
	printf("\nstack trace with sp = %lx\n", va);
d996 1
a996 1
	printf("stop at %lx\n", stop);
d999 1
a999 1
		printf("  %x(%x, %x, %x, %x, %x, %x, %x) fp %p\n", fp->fr_pc,
@


1.25
log
@Add power.h for powerdown() proto.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 1997/06/22 23:54:24 downsj Exp $ */
d96 1
d691 1
d694 3
@


1.24
log
@Only call powerdown() if SUN4M is defined.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.23 1997/06/22 22:33:53 downsj Exp $ */
d93 4
@


1.23
log
@Support RB_POWERDOWN (calls powerdown(), then romhalt().  If powerdown() is
supported on that machine, it just turns off...)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.22 1997/06/11 10:32:11 grr Exp $ */
d684 1
d689 1
@


1.22
log
@import some cleanup for libkvm/kvm.c from netbsd, udpate libkvm so that sparc can use libkvm vs. libkvm.old and update sparc pmap.c and machdep.c to make dumps compatible with the new libkvm's notions.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21 1997/03/26 22:14:41 niklas Exp $ */
d682 1
a682 1
	if (howto & RB_HALT) {
d684 4
@


1.21
log
@Add OpenBSD tag.  Remove redundant test.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.64 1996/05/19 04:12:56 mrg Exp $ */
d706 1
d714 1
a714 4
	register int nblks, nmem;
	register struct memarr *mp;
	extern struct memarr pmemarr[];	/* XXX */
	extern int npmemarr;		/* XXX */
d716 3
a718 3
	dumpsize = 0;
	for (mp = pmemarr, nmem = npmemarr; --nmem >= 0; mp++)
		dumpsize += btoc(mp->len);
a719 8
	/*
	 * savecore views the image in units of pages (i.e., dumpsize is in
	 * pages) so we round the two mmu entities into page-sized chunks.
	 * The PMEGs (32kB) and the segment table (512 bytes plus padding)
	 * are appending to the end of the crash dump.
	 */
	dumpsize += pmap_dumpsize();
	if (dumpdev != NODEV && bdevsw[major(dumpdev)].d_psize) {
d721 3
d725 3
a727 2
		 * Don't dump on the first CLBYTES (why CLBYTES?)
		 * in case the dump device includes a disk label.
d729 4
a732 2
		if (dumplo < btodb(CLBYTES))
			dumplo = btodb(CLBYTES);
d735 4
a738 9
		 * If dumpsize is too big for the partition, truncate it.
		 * Otherwise, put the dump at the end of the partition
		 * by making dumplo as large as possible.
		 */
		if (dumpsize > btoc(dbtob(nblks - dumplo)))
			dumpsize = btoc(dbtob(nblks - dumplo));
		else if (dumplo + ctod(dumpsize) > nblks)
			dumplo = nblks - ctod(dumpsize);
	}
d744 3
d763 1
a763 1
	register daddr_t blkno;
d784 1
a784 1
	if (dumplo < 0)
d786 2
a787 1
	printf("\ndumping to dev %x, offset %ld\n", dumpdev, dumplo);
d798 6
a803 1
	for (mp = pmemarr, nmem = npmemarr; --nmem >= 0; mp++) {
d807 1
d815 2
d822 2
a823 2
			/* print out how many MBs we have dumped */
			if (i && (i % (1024*1024)) == 0)
a836 2
	if (!error)
		error = pmap_dumpmmu(dump, blkno);
@


1.20
log
@constrain nbuf until we find a better fix
@
text
@d1 1
a197 5
	if (base >= MAXBSIZE / CLBYTES) {
		/* don't want to alloc more physical mem than needed */
		base = MAXBSIZE / CLBYTES;
		residual = 0;
	}
@


1.19
log
@mv comment to proper place
@
text
@d342 2
@


1.18
log
@an important comment
@
text
@a336 1
	/* Restrict to at most 70% filled kvm */
d342 1
@


1.17
log
@More siginfo implementations (alpha and mips might even work)
move "siginfo_t *" to 2nd arg of signal handler as 1003.1b requires.
I really wish I had 1003.1b documentation.
@
text
@d546 1
@


1.16
log
@repair confusion over kv/uv addr for siginfo_t storage
@
text
@d423 1
a423 1
	int	sf_code;		/* code */
d429 1
a429 4
	union {
		caddr_t	sfu_addr;	/* SunOS compat */
		siginfo_t *sfu_sip;	/* native */
	} sf_u;
d509 1
a509 2
	sf.sf_code = code;
	sf.sf_u.sfu_sip = NULL;
d512 1
d514 1
a514 1
		sf.sf_u.sfu_addr = val.sival_ptr;
d531 1
a531 1
		sf.sf_u.sfu_sip = &fp->sf_si;
@


1.15
log
@trapsignal/sendsig type/sigval changes
@
text
@d535 1
a535 1
		initsiginfo(sf.sf_u.sfu_sip, sig, code, type, val);
@


1.14
log
@Allow bufpages/nbuf larger than 1 (still max out at all buffers
be MAXBSIZE).  Remove faulty limit test of buffer pages allocation.  The
check is now done at the bufpages+nbuf calculations.
@
text
@d430 1
a430 1
		int	sfu_addr;	/* SunOS compat */
d466 1
a466 1
sendsig(catcher, sig, mask, code, addr)
d470 2
a471 1
	caddr_t addr;
d517 1
a517 1
		sf.sf_u.sfu_addr = (u_int)addr;
d535 1
a535 11
		initsiginfo(sf.sf_u.sfu_sip, sig);
		fixsiginfo(sf.sf_u.sfu_sip, sig, code, addr);
#if 0
		if (sig == SIGSEGV) {
			/* try to be more specific about read or write */
			if (tf->tf_err & PGEX_W)
				sf.sf_si.si_code = SEGV_ACCERR;
			else
				sf.sf_si.si_code = SEGV_MAPERR;
		}
#endif
a643 71
}

void
fixsiginfo(si, sig, code, addr)
	siginfo_t *si;
	int sig;
	u_long code;
	caddr_t addr;
{
	si->si_addr = addr;

#if 0
	switch (code) {
	case T_PRIVINFLT:
		si->si_code = ILL_PRVOPC;
		si->si_trapno = T_PRIVINFLT;
		break;
	case T_BPTFLT:
		si->si_code = TRAP_BRKPT;
		si->si_trapno = T_BPTFLT;
		break;
	case T_ARITHTRAP:
		si->si_code = FPE_INTOVF;
		si->si_trapno = T_DIVIDE;
		break;
	case T_PROTFLT:
		si->si_code = SEGV_ACCERR;
		si->si_trapno = T_PROTFLT;
		break;
	case T_TRCTRAP:
		si->si_code = TRAP_TRACE;
		si->si_trapno = T_TRCTRAP;
		break;
	case T_PAGEFLT:
		si->si_code = SEGV_ACCERR;
		si->si_trapno = T_PAGEFLT;
		break;
	case T_ALIGNFLT:
		si->si_code = BUS_ADRALN;
		si->si_trapno = T_ALIGNFLT;
		break;
	case T_DIVIDE:
		si->si_code = FPE_FLTDIV;
		si->si_trapno = T_DIVIDE;
		break;
	case T_OFLOW:
		si->si_code = FPE_FLTOVF;
		si->si_trapno = T_DIVIDE;
		break;
	case T_BOUND:
		si->si_code = FPE_FLTSUB;
		si->si_trapno = T_BOUND;
		break;
	case T_DNA:
		si->si_code = FPE_FLTINV;
		si->si_trapno = T_DNA;
		break;
	case T_FPOPFLT:
		si->si_code = FPE_FLTINV;
		si->si_trapno = T_FPOPFLT;
		break;
	case T_SEGNPFLT:
		si->si_code = SEGV_MAPERR;
		si->si_trapno = T_SEGNPFLT;
		break;
	case T_STKFLT:
		si->si_code = ILL_BADSTK;
		si->si_trapno = T_STKFLT;
		break;
	}
#endif
@


1.13
log
@add another parameter to trapsignal() and sendsig() -- fault addr to be
delivered with in the siginfo information
@
text
@d197 1
a197 1
	if (base >= MAXBSIZE) {
d199 1
a199 1
		base = MAXBSIZE;
a337 4
	if (bufpages * MAXBSIZE >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) * 7 / 10)
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 7 / 10;
d343 9
a351 2
	if (nbuf > 200)		/* XXX Sorry, our kvm space is too small */
		nbuf = 200;
@


1.12
log
@don't update battery backed up clock if system time is wrong from begin
in ddb.
@
text
@d426 4
a429 1
	int	sf_addr;		/* SunOS compat, always 0 for now */
d431 1
d463 1
a463 1
sendsig(catcher, sig, mask, code)
d467 1
d473 1
a473 1
	register int addr, oonstack, oldsp, newsp;
d477 3
d509 1
d511 4
a514 1
	sf.sf_scp = &fp->sf_sc;
a515 1
	sf.sf_addr = 0;			/* XXX */
d529 15
d579 1
a579 1
		addr = (int)catcher;	/* user does his own trampolining */
d583 1
a583 1
		addr = (int)PS_STRINGS - szsigcode;
d586 2
a587 2
	tf->tf_pc = addr;
	tf->tf_npc = addr + 4;
d650 71
@


1.11
log
@constrain bufcache on sun4m too
@
text
@d656 2
a657 1
		 * will be out of synch; adjust it now.
d659 5
a663 1
		resettodr();
@


1.10
log
@clamp kvm useage
@
text
@d347 1
a347 2
#if defined(SUN4C) || defined(SUN4)
	if ((CPU_ISSUN4C || CPU_ISSUN4) && nbuf > 200)
a348 1
#endif
@


1.9
log
@netbsd port, now we merge our changes back in
@
text
@d327 3
d336 6
a341 1
		bufpages = (physmem / 20) / CLSIZE;
d347 4
@


1.8
log
@have mapdev() panic if size == 0 to be safe (catches config errors)
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.45 1995/05/16 21:16:37 mycroft Exp $ */
d78 4
a81 1
#include <machine/bsd_openprom.h>
d85 3
a87 3

#include <vm/vm_kern.h>
#include <vm/vm_page.h>
d115 1
a115 1
int	msgbufmapped = 0;	/* maps late; so that printf works early */
d131 3
a133 1
caddr_t allocsys();
d174 1
d177 1
d186 1
d189 1
d194 1
d202 1
d225 1
a225 1
	    16*NCARGS, TRUE);
d232 2
a233 10
#if defined(SUN4M) && 0
	if (cputyp == CPU_SUN4M) {
		dvma_base = DVMA4M_BASE;
		dvma_end = (vm_offset_t)(0 - NBPG); /* want 4BG, but cant express */
	} else
#endif
	{
		dvma_base = DVMA_BASE;
		dvma_end = DVMA_END;
	}
d267 1
a267 1
	printf("avail mem = %d\n", ptoa(cnt.v_free_count));
d286 1
a286 1
	if (cputyp == CPU_SUN4)
d326 1
a326 1
	
d392 1
a392 1
	tf->tf_pc = pack->ep_entry & ~3;
d394 1
a394 1
	tf->tf_global[2] = tf->tf_global[7] = tf->tf_npc = tf->tf_pc+4;
d423 1
d481 1
a481 1
		printf("sendsig: %s[%d] sig %d newusp %x scp %x\n",
d484 1
a484 1
	/* 
d534 1
a534 1
		printf("sendsig: %s[%d] sig %d scp %x\n",
d587 1
a587 1
		printf("sigreturn: %s[%d], sigcntxp %x\n",
d624 6
a629 3
	extern volatile void romhalt(void);
	extern volatile void romboot(char *);
	extern	struct promvec *promvec;
a650 1

d652 1
a653 4
#if defined(SUN4M) || defined(SUN4C)
		if (cputyp==CPU_SUN4M || cputyp==CPU_SUN4C)
			*promvec->pv_synchook = NULL;
#endif
d658 2
a670 4
#if defined(SUN4M) || defined(SUN4C)
	if (cputyp==CPU_SUN4M || cputyp==CPU_SUN4C)
		*promvec->pv_synchook = NULL;
#endif
d679 1
d734 1
d761 1
a761 1
	printf("\ndumping to dev %x, offset %d\n", dumpdev, dumplo);
d773 1
a773 1
		register unsigned i, n;
d776 8
a783 1
		for (i = 0; i < mp->len; i += n) {
d838 1
d841 1
a841 1
	struct frame *fp = (struct frame *)getfp(), *sfp;
d844 1
a844 1
	printf("Frame pointer is at 0x%x\n", fp);
d847 1
a847 1
		printf("  pc = %x  args = (%x, %x, %x, %x, %x, %x) fp = %x\n",
a859 1
	PMAP_OBIO,
d866 3
a868 3
 *	mydev = (struct mydev *)mapdev(myioaddr, 0, 0,
 *          sizeof(struct mydev), pmtype);
 * 
d872 2
a873 2
mapdev(rr, virt, offset, size, bustype)
	register struct rom_reg *rr;
d877 2
a878 1
	register vm_offset_t v, pa;
d881 1
a881 1
	int pmtype;
d897 1
a897 1
	ret = (void *)(v | (((u_long)rr->rr_paddr + offset) & PGOFSET));
d899 4
a902 4
	pa = trunc_page(rr->rr_paddr + offset);
#ifdef notyet
	pmtype = (cputyp == CPU_SUN4M)
			? (rr->rr_iospace << PMAP_SHFT4M)
d904 1
a904 3
#else
	pmtype = bt2pmt[bustype];
#endif
d907 1
a907 1
		    VM_PROT_READ | VM_PROT_WRITE, 1);
a934 2
	extern u_long *par_err_reg;
	volatile u_long *memreg = (u_long *) par_err_reg;
d938 1
a938 1
		printf("curproc = %x, pid %d\n", curproc, curproc->p_pid);
d949 1
a949 1
	printf("\nstack trace with sp = %x\n", va);
d951 1
a951 1
	printf("stop at %x\n", stop);
d954 2
a955 2
		printf("  %x(%x, %x, %x, %x, %x, %x) fp %x\n", fp->fr_pc, 
		    fp->fr_arg[0], fp->fr_arg[1], fp->fr_arg[2], fp->fr_arg[3], 
d961 1
a961 1
	printf("end of stack trace\n"); 
d978 1
a978 1
			printf("w: unknown case %d\n", va);
d991 1
a991 1
u_int
d997 2
a998 1
	u_long saveonfault, res;
d1001 5
d1013 1
a1013 1
	res = xldcontrolb(addr, xpcb);
@


1.7
log
@change mapdev() so that it includes the offset from the start of the
page in the virtual address it returns.
@
text
@d876 2
@


1.6
log
@ss_sp is correct, ss_base is not. noticed by agc@@sde.uts.amdahl.com; netbsd pr#1784
@
text
@d884 2
a885 1
	ret = (void *)v;
@


1.5
log
@new mapdev/()/mapiodev() calling convention uses "struct rom_reg *" to supply
base plus an offset
new dvma routines
@
text
@d468 1
a468 1
		fp = (struct sigframe *)(psp->ps_sigstk.ss_base +
@


1.4
log
@clear pv_synchook if we halt; thus prom "sync" command will not do the wrong thing
@
text
@d124 1
a125 1
vm_offset_t dvmabase;
d221 11
a231 1
	phys_map = vm_map_create(pmap_kernel(), DVMA_BASE, DVMA_END, 1);
d235 8
a242 6
	 * For now, allocate half of DVMA space for a (privately managed)
	 * pool of addresses for double mappings.
	 */
	dvmabase = kmem_alloc_wait(phys_map, (DVMA_END-DVMA_BASE)/2);
	rminit(dvmamap, btoc((DVMA_END-DVMA_BASE)/2),
	    vtorc(dvmabase), "dvmamap", ndvmamap);
d856 3
a858 2
 *	mydev = (struct mydev *)mapdev(myioaddr, 0, sizeof(struct mydev), pmtype);
 *
d862 3
a864 3
mapdev(phys, virt, size, bustype)
	register void *phys;
	register int virt, size;
d867 1
a867 1
	register vm_offset_t v;
d870 1
a870 1
	int pmtype = bt2pmt[bustype];
d885 8
a892 1
	phys = (void *)trunc_page(phys);
d894 1
a894 2
		pmap_enter(pmap_kernel(), v,
		    (vm_offset_t)phys | pmtype | PMAP_NC,
d897 1
a897 1
		phys += PAGE_SIZE;
@


1.3
log
@map msgbuf late
@
text
@d78 1
d610 1
d632 1
d635 4
d654 4
@


1.2
log
@pfour support, some prettying up
@
text
@d111 1
a111 1
int	msgbufmapped = 1;	/* message buffer is always mapped */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.50 1995/10/07 06:26:06 mycroft Exp $ */
d229 1
a229 1
		vtorc(dvmabase), "dvmamap", ndvmamap);
a376 1
	tf->tf_npc = tf->tf_pc + 4;
d378 1
a378 1
	tf->tf_global[2] = tf->tf_global[7] = tf->tf_npc;
d826 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

