head	1.12;
access;
symbols
	OPENBSD_6_0:1.11.0.54
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.50
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.52
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.44
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.48
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.46
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.42
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.40
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.38
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.36
	OPENBSD_5_0:1.11.0.34
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.32
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.30
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.26
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.28
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.24
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.22
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.20
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.18
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.16
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.14
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.12
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.10
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.10
	UBC:1.9.0.10
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.8
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.6
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.8
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.6
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.09.01.09.23.43;	author tedu;	state dead;
branches;
next	1.11;
commitid	Q2PxaFNhqAe0Wmla;

1.11
date	2003.05.13.22.25.33;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.21.17.08.37;	author art;	state Exp;
branches
	1.9.10.1;
next	1.8;

1.8
date	2000.01.31.16.06.59;	author art;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	97.11.11.10.53.12;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	97.11.11.10.47.23;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.08.08.08.27.32;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.08.11.05.35.19;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.01.07.15.18.10;	author davem;	state Exp;
branches;
next	1.2;

1.2
date	95.12.15.13.56.48;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.47;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.47;	author deraadt;	state Exp;
branches;
next	;

1.8.2.1
date	2000.02.21.22.29.04;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2002.03.28.10.57.11;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2003.05.16.00.29.40;	author niklas;	state Exp;
branches;
next	;

1.9.10.1
date	2002.06.11.03.38.17;	author art;	state Exp;
branches;
next	1.9.10.2;

1.9.10.2
date	2003.05.19.21.46.33;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: memreg.c,v 1.11 2003/05/13 22:25:33 miod Exp $	*/
/*	$NetBSD: memreg.c,v 1.21 1997/07/29 09:42:08 fair Exp $ */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *	This product includes software developed by Harvard University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 *	This product includes software developed by Harvard University.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)memreg.c	8.1 (Berkeley) 6/11/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <machine/autoconf.h>
#include <machine/ctlreg.h>

#include <sparc/sparc/memreg.h>
#include <sparc/sparc/vaddrs.h>
#include <sparc/sparc/asm.h>
#include <sparc/sparc/cpuvar.h>

#include <machine/reg.h>	/* for trapframe */
#include <machine/trap.h>	/* for trap types */

int memregmatch(struct device *, void *, void *);
void memregattach(struct device *, struct device *, void *);

struct cfattach memreg_ca = {
	sizeof(struct device), memregmatch, memregattach
};

struct cfdriver memreg_cd = {
	0, "memreg", DV_DULL
};

#if defined(SUN4M)
void hardmemerr4m(unsigned int, u_int, u_int, u_int, u_int);
#endif

/*
 * The OPENPROM calls this "memory-error".
 */
int
memregmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	register struct cfdata *cf = vcf;
	register struct confargs *ca = aux;

	if (CPU_ISSUN4) {
		if (ca->ca_bustype == BUS_OBIO)
			return (strcmp(cf->cf_driver->cd_name,
			    ca->ca_ra.ra_name) == 0);
		return (0);
	}
	return (strcmp("memory-error", ca->ca_ra.ra_name) == 0);
}

/* ARGSUSED */
void
memregattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	register struct confargs *ca = aux;
	register struct romaux *ra = &ca->ca_ra;

	if (CPU_ISSUN4) {
		if (par_err_reg == NULL)
			panic("memregattach");
		ra->ra_vaddr = (caddr_t)par_err_reg;
	} else {
		par_err_reg = ra->ra_vaddr ? (volatile u_int *)ra->ra_vaddr :
		    (volatile u_int *)mapiodev(ra->ra_reg, 0, sizeof(int));
	}
	printf("\n");
}

/*
 * Synchronous and asynchronous memory error handler.
 * (This is the level 15 interrupt, which is not vectored.)
 * Should kill the process that got its bits clobbered,
 * and take the page out of the page pool, but for now...
 */

volatile u_int	*par_err_reg;	/* virtual address; NULL if not yet mapped */

void
memerr4_4c(issync, ser, sva, aer, ava, tf)
	unsigned int issync;
	u_int ser, sva, aer, ava;
	struct trapframe *tf;   /* XXX - unused/invalid */
{
	printf("%ssync mem err: ser=%b sva=0x%x ",
	       issync ? "" : "a", ser, SER_BITS, sva);
	printf("aer=%b ava=0x%x\n", aer & 0xff, AER_BITS, ava);
	if (par_err_reg)
		printf("parity error register = %b\n",
		       *par_err_reg, PER_BITS);
	panic("memory error");		/* XXX */
}

#if defined(SUN4M)
/*
 * hardmemerr4m: called upon fatal memory error. Print a message and panic.
 */

void
hardmemerr4m(type, sfsr, sfva, afsr, afva)
	unsigned int type;
	u_int sfsr, sfva, afsr, afva;
{
	printf("memory error:");
	printf("sfsr=%b sfva=0x%x", sfsr, SFSR_BITS, sfva);
	printf("afsr=%b afva=0x%x", afsr, AFSR_BITS, afva);

	if ((sfsr & SFSR_FT) == SFSR_FT_NONE  && (afsr & AFSR_AFO) == 0)
		return;

	panic("hard memory error");
}

/*
 * Memerr4m: handle a non-trivial memory fault. These include HyperSPARC
 * asynchronous faults, SuperSPARC store-buffer copyback failures, and
 * data faults without a valid faulting VA. We try to retry the operation
 * once, and then fail if we get called again.
 */

static int addrold = (int)0xdeadbeef; /* We pick an unlikely address */
static int addroldtop = (int)0xdeadbeef;
static int oldtype = -1;

void
hypersparc_memerr(type, sfsr, sfva, tf)
	unsigned int type;
	u_int sfsr;
	u_int sfva;
	struct trapframe *tf;
{
	u_int afsr;
	u_int afva;

	(*cpuinfo.get_asyncflt)(&afsr, &afva);
	if ((afsr & AFSR_AFO) != 0) {	/* HS async fault! */

		printf("HyperSPARC async cache memory failure at phys 0x%x%x\n",
		       (afsr & AFSR_AFA) >> AFSR_AFA_RSHIFT, afva);

		if (afva == addrold && (afsr & AFSR_AFA) == addroldtop)
			goto hard;

		oldtype = -1;
		addrold = afva;
		addroldtop = afsr & AFSR_AFA;
		return;
	}
hard:
	hardmemerr4m(type, sfsr, sfva, afsr, afva);
}

void
viking_memerr(type, sfsr, sfva, tf)
	unsigned int type;
	u_int sfsr;
	u_int sfva;
	struct trapframe *tf;
{
	u_int afsr = 0;
	u_int afva = 0;

	if (type == T_STOREBUFFAULT) {
		/*
		 * On Supersparc, we try to reenable the store buffers
		 * to force a retry.
		 */
		printf("store buffer copy-back failure at 0x%x. Retrying...\n",
		       sfva);

		if (oldtype == T_STOREBUFFAULT || addrold == sfva)
			goto hard;

		oldtype = T_STOREBUFFAULT;
		addrold = sfva;

		/* reenable store buffer */
		sta(SRMMU_PCR, ASI_SRMMU,
		    lda(SRMMU_PCR, ASI_SRMMU) | VIKING_PCR_SB);

	} else if (type == T_DATAFAULT && (sfsr & SFSR_FAV) == 0) {
		/*
		 * bizarre.
		 * XXX: Should handle better. See SuperSPARC manual pg. 9-35
		 */
		printf("warning: got data fault with no faulting address."
		       " Ignoring.\n");

		if (oldtype == T_DATAFAULT)
			goto hard;
		oldtype = T_DATAFAULT;
		return;
	}
hard:
	hardmemerr4m(type, sfsr, sfva, afsr, afva);
}

void
memerr4m(type, sfsr, sfva, tf)
	unsigned int type;
	u_int sfsr;
	u_int sfva;
	struct trapframe *tf;
{
	u_int afsr;
	u_int afva;

	/*
	 * No known special cases.
	 * Just get async registers, if any, and report the unhandled case.
	 */
	if ((*cpuinfo.get_asyncflt)(&afsr, &afva) != 0)
		afsr = afva = 0;

	hardmemerr4m(type, sfsr, sfva, afsr, afva);
}
#endif /* 4m */
@


1.11
log
@Nuke a few simple commons.
@
text
@d1 1
a1 1
/*	$OpenBSD: memreg.c,v 1.10 2002/03/14 01:26:44 millert Exp $	*/
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: memreg.c,v 1.9 2000/02/21 17:08:37 art Exp $	*/
d126 2
@


1.9
log
@The last pieces of hypersparc support.
 - Split get_faultstatus into get_syncflt and get_asyncflt.
 - Get the syncflt status before setting up the trap frame and put the
   results in cpuinfo.syncfltdump (related to the next change).
 - unlock the sfsr/sfva after reading from ASI_SRMMUFP (it gets locked if
   the translation fails).
 - + other interface changes and cleanups.
 (most work from NetBSD).
@
text
@d1 1
a1 1
/*	$OpenBSD: memreg.c,v 1.8 2000/01/31 16:06:59 art Exp $	*/
d65 2
a66 2
int memregmatch __P((struct device *, void *, void *));
void memregattach __P((struct device *, struct device *, void *));
d77 1
a77 1
void hardmemerr4m __P((unsigned int, u_int, u_int, u_int, u_int));
@


1.9.10.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: memreg.c,v 1.9 2000/02/21 17:08:37 art Exp $	*/
d65 2
a66 2
int memregmatch(struct device *, void *, void *);
void memregattach(struct device *, struct device *, void *);
d77 1
a77 1
void hardmemerr4m(unsigned int, u_int, u_int, u_int, u_int);
@


1.9.10.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a125 2

volatile u_int	*par_err_reg;	/* virtual address; NULL if not yet mapped */
@


1.8
log
@Clean up memerr*. (from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: memreg.c,v 1.7 1997/11/11 10:53:12 niklas Exp $	*/
d77 1
a77 1
void hardmemerr4m __P((u_int, u_int, u_int, u_int));
a144 5
 * Note that issync is not really an indicator of whether or not the error
 * was synchronous; if it is set, it means that the fsr/faddr pair correspond
 * to the MMU's fault status register; if clear, they correspond to the
 * HyperSPARC asynchronous error register. If issync==2, then both decodings
 * of the error register are printed.
d148 2
a149 1
hardmemerr4m(sfsr, sfva, afsr, afva)
d155 1
d158 1
d174 1
a174 1
hypersparc_memerr(type, sfsr, sfva, afsr, afva, tf)
d178 2
d182 2
a183 2
	struct trapframe *tf;
{
d186 2
a187 3
		printf("HyperSPARC async cache memory failure at phys 0x%x%x. "
		       "Ignoring.\n", (afsr & AFSR_AFA) >> AFSR_AFA_RSHIFT,
		       afva);
d190 1
a190 1
			hardmemerr4m(sfsr, sfva, afsr, afva);
d197 2
a198 1
	memerr4m(type, sfsr, sfva, afsr, afva, tf);
d202 1
a202 1
viking_memerr(type, sfsr, sfva, afsr, afva, tf)
a205 2
	u_int afsr;
	u_int afva;
d208 3
d220 1
a220 2
			hardmemerr4m(sfsr, sfva, afsr, afva);
			/* NOTREACHED */
d229 11
a239 1
	} else if (type == T_DATAFAULT && !(sfsr & SFSR_FAV)) {
d242 2
a243 1
	memerr4m(type, sfsr, sfva, afsr, afva, tf);
d247 1
a247 1
memerr4m(type, sfsr, sfva, afsr, afva, tf)
d251 2
a254 10
	struct trapframe *tf;
{
	if (type == T_DATAFAULT && !(sfsr & SFSR_FAV)) { /* bizarre */
		/* XXX: Should handle better. See SuperSPARC manual pg. 9-35 */
                printf("warning: got data fault with no faulting address."
                       " Ignoring.\n");

		if (oldtype == T_DATAFAULT)
			hardmemerr4m(sfsr, sfva, afsr, afva);
                oldtype = T_DATAFAULT;
d256 6
a261 14
	} else if (type == 0) {	/* NMI */
		printf("ERROR: got NMI with sfsr=0x%b, sfva=0x%x, ",
		       sfsr, SFSR_BITS, sfva);
		printf("afsr=0x%b, afaddr=0x%x. Retrying...\n",
		       afsr, AFSR_BITS, afva);
		if (oldtype == 0 || addrold == sfva)
			hardmemerr4m(sfsr, sfva, afsr, afva);

		oldtype = 0;
		addrold = sfva;
	} else 	{
		/* something we don't know about?!? */
		hardmemerr4m(sfsr, sfva, afsr, afva);
	}
d263 1
a263 1
	return;
@


1.8.2.1
log
@sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD: memreg.c,v 1.9 2000/02/21 17:08:37 art Exp $	*/
d77 1
a77 1
void hardmemerr4m __P((unsigned int, u_int, u_int, u_int, u_int));
d145 5
d153 1
a153 2
hardmemerr4m(type, sfsr, sfva, afsr, afva)
	unsigned int type;
a158 1

a160 1

d176 1
a176 1
hypersparc_memerr(type, sfsr, sfva, tf)
d180 2
a183 4
	u_int afsr;
	u_int afva;

	(*cpuinfo.get_asyncflt)(&afsr, &afva);
d186 3
a188 2
		printf("HyperSPARC async cache memory failure at phys 0x%x%x\n",
		       (afsr & AFSR_AFA) >> AFSR_AFA_RSHIFT, afva);
d191 1
a191 1
			goto hard;
d198 1
a198 2
hard:
	hardmemerr4m(type, sfsr, sfva, afsr, afva);
d202 1
a202 1
viking_memerr(type, sfsr, sfva, tf)
d206 2
a209 3
	u_int afsr = 0;
	u_int afva = 0;

d219 2
a220 1
			goto hard;
d229 1
a229 11
	} else if (type == T_DATAFAULT && (sfsr & SFSR_FAV) == 0) {
		/*
		 * bizarre.
		 * XXX: Should handle better. See SuperSPARC manual pg. 9-35
		 */
		printf("warning: got data fault with no faulting address."
		       " Ignoring.\n");

		if (oldtype == T_DATAFAULT)
			goto hard;
		oldtype = T_DATAFAULT;
d232 1
a232 2
hard:
	hardmemerr4m(type, sfsr, sfva, afsr, afva);
d236 1
a236 1
memerr4m(type, sfsr, sfva, tf)
d240 2
d244 16
a259 2
	u_int afsr;
	u_int afva;
d261 6
a266 6
	/*
	 * No known special cases.
	 * Just get async registers, if any, and report the unhandled case.
	 */
	if ((*cpuinfo.get_asyncflt)(&afsr, &afva) != 0)
		afsr = afva = 0;
d268 1
a268 1
	hardmemerr4m(type, sfsr, sfva, afsr, afva);
@


1.8.2.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d65 2
a66 2
int memregmatch(struct device *, void *, void *);
void memregattach(struct device *, struct device *, void *);
d77 1
a77 1
void hardmemerr4m(unsigned int, u_int, u_int, u_int, u_int);
@


1.8.2.3
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@a126 2
volatile u_int	*par_err_reg;	/* virtual address; NULL if not yet mapped */

@


1.7
log
@A vital variable was not initialized!  Thanks DDB, and you...
remember to kill those static specifiers.
@
text
@d1 1
a1 1
/*	$OpenBSD: memreg.c,v 1.5 1997/08/08 08:27:32 downsj Exp $	*/
a75 1
void memerr __P((int, u_int, u_int, u_int, u_int));
d77 1
a77 1
void hardmemerr4m __P((int, u_int, u_int));
d128 2
a129 2
memerr(issync, ser, sva, aer, ava)
	int issync;
d131 1
d133 7
a139 45
	/* XXX Ugh! Clean up this switch and all the ifdefs! */
	switch (cputyp) {
#if defined(SUN4)
	case CPU_SUN4:
		if (par_err_reg) {
			printf("mem err: ser=%b sva=0x%x\n",
				ser, SER_BITS, sva);
			printf("parity error register = %b\n",
				*par_err_reg, PER_BITS);
		} else {
			printf("mem err: ser=? sva=?\n");
			printf("parity error register not mapped yet!\n"); /* XXX */
		}
#ifdef DEBUG
		callrom();
#else
		panic("memory error");		/* XXX */
#endif
		break;
#endif /* Sun4 */

#if defined(SUN4C)
	case CPU_SUN4C:
		printf("%ssync mem arr: ser=%b sva=0x%x ",
		    issync ? "" : "a", ser, SER_BITS, sva);
		printf("aer=%b ava=0x%x\n", aer & 0xff, AER_BITS, ava);
		if (par_err_reg)
			printf("parity error register = %b\n",
			    *par_err_reg, PER_BITS);
#ifdef DEBUG
		callrom();
#else
		panic("memory error");		/* XXX */
#endif
		break;
#endif /* Sun4C */

#if defined(SUN4M)
	case CPU_SUN4M:
		hardmemerr4m(2, ser, sva);
		break;
#endif /* Sun4M */
	    default:
		break;
	}
a141 1

d153 2
a154 3
hardmemerr4m(issync, fsr, faddr)
	int issync;
	u_int fsr, faddr;
d156 5
a160 21
	switch (issync) {
	    case 1:
		if ((fsr & SFSR_FT) == SFSR_FT_NONE)
		    return;
		printf("mem err: sfsr=%b sfaddr=0x%x\n", fsr, SFSR_BITS, faddr);
		break;
	    case 0:
		if (!(fsr & AFSR_AFO))
		    return;
		printf("async (HS) mem err: afsr=%b afaddr=0x%x physaddr=0x%x%x\n",
		       fsr, AFSR_BITS, faddr,
		       (fsr & AFSR_AFA) >> AFSR_AFA_RSHIFT, faddr);
		break;
	    default:	/* unknown; print both decodings*/
		printf("unknown mem err: if sync, fsr=%b fva=0x%x; ",
		       fsr, SFSR_BITS, faddr);
		printf("if async, fsr=%b fa=0x%x pa=0x%x%x", fsr,
		       AFSR_BITS, faddr, (fsr & AFSR_AFA) >> AFSR_AFA_RSHIFT,
		       faddr);
		break;
	}
d176 7
a182 7
memerr4m(type, sfsr, sfva, afsr, afva, tf)
	register unsigned type;
	register u_int sfsr;
	register u_int sfva;
	register u_int afsr;
	register u_int afva;
	register struct trapframe *tf;
d191 1
a191 2
			hardmemerr4m(0, afsr, afva);
			/* NOTREACHED */
d196 4
d201 10
a210 2
	} else if (type == T_STOREBUFFAULT && cpuinfo.cpu_vers == 4) {

d219 1
a219 1
			hardmemerr4m(1, sfsr, sfva);
d229 16
a244 1
	} else if (type == T_DATAFAULT && !(sfsr & SFSR_FAV)) { /* bizarre */
d246 2
a247 3

		printf("warning: got data fault with no faulting address."
		       " Ignoring.\n");
d250 2
a251 2
			hardmemerr4m(1, sfsr, sfva);
			/* NOTREACHED */
a252 1
		oldtype = T_DATAFAULT;
d259 1
a259 2
			hardmemerr4m(1, sfsr, sfva);	/* XXX: async? */
			/* NOTREACHED */
d263 3
a265 5
	} else 	/* something we don't know about?!? */ {
		printf("unknown fatal memory error, type=%d, sfsr=%b, sfva=0x%x",
		       type, sfsr, SFSR_BITS, sfva);
		printf(", afsr=%b, afaddr=0x%x\n", afsr, AFSR_BITS, afva);
		panic("memerr4m");
@


1.6
log
@I might as well say it here: please do not make functions in the
kernel static, unless they are also inline.  Debugging in DDB becomes a
nightmare when the symbols are not there.  Instead use good non-clashing
names, maybe prefixed by the devicename, subsystemname or similar.
@
text
@d89 1
a89 1
	register struct cfdata *cf;
d95 1
a95 1
				       ca->ca_ra.ra_name) == 0);
@


1.5
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d65 2
a66 2
static int memregmatch __P((struct device *, void *, void *));
static void memregattach __P((struct device *, struct device *, void *));
d78 1
a78 1
static void hardmemerr4m __P((int, u_int, u_int));
d84 1
a84 1
static int
d102 1
a102 1
static void
d191 1
a191 1
static void
d227 2
a228 2
static int addrold = (int) 0xdeadbeef; /* We pick an unlikely address */
static int addroldtop = (int) 0xdeadbeef;
@


1.4
log
@netbsd port, now we merge our changes back in
@
text
@d1 2
a2 1
/*	$NetBSD: memreg.c,v 1.13 1996/03/31 22:52:08 pk Exp $ */
d60 1
d87 1
a87 1
	void *aux, *vcf;
d89 1
a89 1
	struct cfdata *cf = vcf;
d116 1
a116 2
		    (volatile u_int *)mapiodev(ra->ra_reg, 0, sizeof(int),
					     ca->ca_bustype);
a132 1

d138 2
a139 1
			printf("mem err: ser=%b sva=%x\n", ser, SER_BITS, sva);
d156 3
a158 3
		printf("%ssync mem err: ser=%b sva=%x aer=%b ava=%x\n",
		       issync ? "" : "a", ser, SER_BITS,
		       sva, aer & 0xff, AER_BITS, ava);
d161 1
a161 1
				*par_err_reg, PER_BITS);
d200 1
a200 1
		panic("mem err: sfsr=%b sfaddr=%x", fsr, SFSR_BITS, faddr);
d205 1
a205 1
		panic("async (HS) mem err: afsr=%b afaddr=%x physaddr=%x%x",
d210 5
a214 4
		panic("Unknown mem err: if sync, fsr=%b fva=%x; if async, fsr"
		      "=%b fa=%x pa=%x%x", fsr, SFSR_BITS, faddr, fsr,
		      AFSR_BITS, faddr, (fsr & AFSR_AFA) >> AFSR_AFA_RSHIFT,
		      faddr);
d217 1
d254 1
a254 2
	} else if (type == T_STOREBUFFAULT) {
		/* We try to reenable the store buffers to force a retry */
d256 4
d270 3
a272 2
		sta(SRMMU_PCR, ASI_SRMMU, lda(SRMMU_PCR, ASI_SRMMU) |
			SRMMU_PCR_SB);	/* reenable store buffer */
d286 4
a289 3
		printf("ERROR: got NMI with sfsr=0x%b, sfva=0x%x, afsr=0x%b, "
		       "afaddr=0x%x. Retrying...\n",
			sfsr,SFSR_BITS,sfva,afsr, AFSR_BITS,afva);
d297 4
a300 3
		panic("memerr4m: unknown fatal memory error. type=%d, sfsr=%b,"
		      " sfva=%x, afsr=%b, afaddr=%x",
		      type, sfsr, SFSR_BITS, sfva, afsr, AFSR_BITS, afva);
@


1.3
log
@When servicing a memory error on the sun4/sun4c make
sure the store buffers on the chip are completely flushed to ensure
proper handler completion.
@
text
@d1 1
a1 1
/*	$NetBSD: memreg.c,v 1.7 1995/02/01 12:37:53 pk Exp $ */
d15 1
d29 1
d50 1
d58 4
d65 13
a77 2
struct cfdriver memregcd =
    { 0, "memreg", memregmatch, memregattach, DV_DULL, sizeof(struct device) };
d90 1
a90 1
	if (cputyp == CPU_SUN4) {
d108 1
a108 1
	if (cputyp == CPU_SUN4) {
d113 3
a115 3
		par_err_reg = ra->ra_vaddr ? (volatile int *)ra->ra_vaddr :
		    (volatile int *)mapiodev(ra->ra_reg, 0, sizeof(int),
		    ca->ca_bustype);
a126 2
extern void sun4c_sun4_storebuf_flush(void);

d129 2
a130 1
	int issync, ser, sva, aer, ava;
d132 5
a136 2
	sun4c_sun4_storebuf_flush(); /* prevent loops... */
	if (cputyp == CPU_SUN4) {
d145 10
a154 1
	} else {
d156 2
a157 2
		    issync ? "" : "a", ser, SER_BITS, sva, aer & 0xff,
		    AER_BITS, ava);
a160 1
	}
d162 1
a162 1
	callrom();
d164 1
a164 1
	panic("memory error");		/* XXX */
d166 129
d296 1
@


1.2
log
@new mapdev/()/mapiodev() calling convention uses "struct rom_reg *" to supply
base plus an offset
new dvma routines
@
text
@d108 3
d115 1
a115 1

@


1.1
log
@Initial revision
@
text
@d96 1
a96 1
		    (volatile int *)mapiodev(ra->ra_paddr, sizeof(int),
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
