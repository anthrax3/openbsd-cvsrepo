head	1.14;
access;
symbols
	OPENBSD_6_0:1.13.0.24
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.20
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.22
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.14
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.18
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.16
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.12
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.12.0.6
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.4
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.11.0.18
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.16
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.14
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.12
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.10
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.8
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.6
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.6.0.6
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.8
	UBC:1.6.0.4
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.10
	OPENBSD_2_8:1.5.0.8
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.6
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.4
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.14
date	2016.09.01.09.23.42;	author tedu;	state dead;
branches;
next	1.13;
commitid	Q2PxaFNhqAe0Wmla;

1.13
date	2010.08.17.20.05.08;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2009.04.10.20.53.54;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.09.29.07.35.13;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.22.22.12.59;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.06.22.49.36;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.11.12.14.39;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.28.03.51.19;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.10.10.34.45;	author art;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	99.04.22.18.43.51;	author art;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	97.08.25.08.38.47;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	97.06.24.09.51.00;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.08.11.05.35.03;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.45;	author deraadt;	state Exp;
branches;
next	;

1.5.4.1
date	2001.07.04.10.23.36;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2003.03.27.23.49.26;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2003.05.13.19.41.08;	author ho;	state Exp;
branches;
next	;

1.6.4.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2002.10.29.00.28.10;	author art;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: bsd_fdintr.s,v 1.13 2010/08/17 20:05:08 miod Exp $	*/
/*	$NetBSD: bsd_fdintr.s,v 1.11 1997/04/07 21:00:36 pk Exp $ */

/*
 * Copyright (c) 1995 Paul Kranenburg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Paul Kranenburg.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#ifndef FDC_C_HANDLER
#include "assym.h"
#include <machine/param.h>
#include <machine/psl.h>
#include <machine/asm.h>
#include <sparc/sparc/intreg.h>
#include <sparc/sparc/auxioreg.h>
#include <sparc/sparc/vaddrs.h>
#include <sparc/dev/fdreg.h>
#include <sparc/dev/fdvar.h>

/*
 * Note the following code hardcodes soft interrupt level 4, instead of
 * picking the actual bits from the softintr cookie. We don't have enough
 * free registers to be able to pick it easily, anyway; it's just not
 * worth doing.
 */

#define FD_SET_SWINTR_4C				\
	sethi	%hi(INTRREG_VA), %l5;			\
	ldub	[%l5 + %lo(INTRREG_VA)], %l6;		\
	or	%l6, IE_L4, %l6;			\
	stb	%l6, [%l5 + %lo(INTRREG_VA)]

! raise(0,IPL_FDSOFT)	! NOTE: CPU#0 and IPL_FDSOFT=4
#define FD_SET_SWINTR_4M				\
	sethi	%hi(1 << (16 + 4)), %l5;		\
	set	ICR_PI_SET, %l6;			\
	st	%l5, [%l6]

/* set software interrupt */
#if (defined(SUN4) || defined(SUN4C)) && !defined(SUN4M)
#define FD_SET_SWINTR	FD_SET_SWINTR_4C
#elif !(defined(SUN4) || defined(SUN4C)) && defined(SUN4M)
#define FD_SET_SWINTR	FD_SET_SWINTR_4M
#else
#define FD_SET_SWINTR					\
	sethi	%hi(_C_LABEL(cputyp)), %l5;		\
	ld	[%l5 + %lo(_C_LABEL(cputyp))], %l5;	\
	cmp	%l5, CPU_SUN4M;				\
	be	8f;					\
	FD_SET_SWINTR_4C;				\
	ba,a	9f;					\
8:							\
	FD_SET_SWINTR_4M;				\
9:
#endif

! flip TC bit in auxreg
! assumes %l6 remains unchanged between ASSERT and DEASSERT
#define FD_ASSERT_TC_4C					\
	sethi	%hi(AUXREG_VA), %l6;			\
	ldub	[%l6 + %lo(AUXREG_VA) + 3], %l7;	\
	or	%l7, AUXIO4C_MB1|AUXIO4C_FTC, %l7;	\
	stb	%l7, [%l6 + %lo(AUXREG_VA) + 3];

#define FD_DEASSERT_TC_4C				\
	ldub	[%l6 + %lo(AUXREG_VA) + 3], %l7;	\
	andn	%l7, AUXIO4C_FTC, %l7;			\
	or	%l7, AUXIO4C_MB1, %l7;			\
	stb	%l7, [%l6 + %lo(AUXREG_VA) + 3];

! flip TC bit in auxreg
#define FD_ASSERT_TC_4M					\
	sethi	%hi(AUXREG_VA), %l6;			\
	ldub	[%l6 + %lo(AUXREG_VA) + 3], %l7;	\
	or	%l7, AUXIO4M_MB1|AUXIO4M_FTC, %l7;	\
	stb	%l7, [%l6 + %lo(AUXREG_VA) + 3];

#define FD_DEASSERT_TC_4M

/*
 * flip TC bit in auxreg
 * assumes %l5 remains unchanged between ASSERT and DEASSERT
 */
#if (defined(SUN4) || defined(SUN4C)) && !defined(SUN4M)
#define FD_ASSERT_TC		FD_ASSERT_TC_4C
#define FD_DEASSERT_TC		FD_DEASSERT_TC_4C
#elif !(defined(SUN4) || defined(SUN4C)) && defined(SUN4M)
#define FD_ASSERT_TC		FD_ASSERT_TC_4M
#define FD_DEASSERT_TC		FD_DEASSERT_TC_4M
#else
#define FD_ASSERT_TC					\
	sethi	%hi(_C_LABEL(cputyp)), %l5;		\
	ld	[%l5 + %lo(_C_LABEL(cputyp))], %l5;	\
	cmp	%l5, CPU_SUN4M;				\
	be	8f;					\
	 nop;						\
	FD_ASSERT_TC_4C;				\
	ba,a	9f;					\
8:							\
	FD_ASSERT_TC_4M;				\
9:
#define FD_DEASSERT_TC					\
	cmp	%l5, CPU_SUN4M;				\
	be	8f;					\
	 nop;						\
	FD_DEASSERT_TC_4C;				\
	ba,a	9f;					\
8:							\
	FD_DEASSERT_TC_4M;				\
9:
#endif


/* Timeout waiting for chip ready */
#define POLL_TIMO	100000

/*
 * register mnemonics. note overlapping assignments.
 */
#define R_fdc	%l0
#define R_msr	%l1
#define R_fifo	%l2
#define R_buf	%l3
#define R_tc	%l4
#define R_stat	%l3
#define R_nstat	%l4
#define R_stcnt	%l5
/* use %l6 and %l7 as short term temporaries */


	.seg	"data"
	.align	8
	.global _C_LABEL(fdciop)
/* A save haven for three precious registers */
save_l:
	.word	0
	.word	0
	.word	0
/* Pointer to a `struct fdcio', set in fd.c */
_C_LABEL(fdciop):
	.word	0

	.seg	"text"
	.align	4
	.global _C_LABEL(fdchwintr)

_C_LABEL(fdchwintr):
	set	save_l, %l7
	std	%l0, [%l7]
	st	%l2, [%l7 + 8]

	! tally interrupt
	sethi	%hi(_C_LABEL(uvmexp)+V_INTR), %l7
	ld	[%l7 + %lo(_C_LABEL(uvmexp)+V_INTR)], %l6
	inc	%l6
	st	%l6, [%l7 + %lo(_C_LABEL(uvmexp)+V_INTR)]

	! load fdc, if it's NULL there's nothing to do: schedule soft interrupt
	sethi	%hi(_C_LABEL(fdciop)), %l7
	ld	[%l7 + %lo(_C_LABEL(fdciop))], R_fdc

	! tally interrupt
	ldd	[R_fdc + FDC_COUNT], %l4
	inccc	%l5
	addx	%l4, 0, %l4
	std	%l4, [R_fdc + FDC_COUNT]

	! load chips register addresses
	ld	[R_fdc + FDC_REG_MSR], R_msr	! get chip MSR reg addr
	ld	[R_fdc + FDC_REG_FIFO], R_fifo	! get chip FIFO reg addr
	!!ld	[R_fdc + FDC_REG_DOR], R_dor	! get chip DOR reg addr

	! find out what we are supposed to do
	ld	[R_fdc + FDC_ITASK], %l7	! get task from fdc
	cmp	%l7, FDC_ITASK_SENSEI
	be	sensei
	 !nop
	cmp	%l7, FDC_ITASK_RESULT
	be	resultphase
	 !nop
	cmp	%l7, FDC_ITASK_DMA
	bne,a	ssi				! a spurious interrupt
	 mov	FDC_ISTATUS_SPURIOUS, %l7	! set status and post sw intr

	! pseudo DMA
	ld	[R_fdc + FDC_TC], R_tc		! residual count
	ld	[R_fdc + FDC_DATA], R_buf	! IO buffer

	ldub	[R_msr], %l7			! get MSR value
nextc:
	btst	NE7_RQM, %l7			! room in fifo?
	bnz,a	0f
	 btst	NE7_NDM, %l7			! overrun?

	! we filled/emptied the FIFO; update fdc->sc_buf & fdc->sc_tc
	st	R_tc, [R_fdc + FDC_TC]
	b	x
	st	R_buf, [R_fdc + FDC_DATA]

0:
	bz	resultphase			! overrun/underrun
	btst	NE7_DIO, %l7			! IO direction
	bz	1f
	 deccc	R_tc
	ldub	[R_fifo], %l7			! reading:
	b	2f
	stb	%l7, [R_buf]			!    *fdc->sc_bufp = *reg_fifo

1:
	ldub	[R_buf], %l7			! writing:
	stb	%l7, [R_fifo]			!    *reg_fifo = *fdc->sc_bufp
2:
	inc	R_buf				! fdc->sc_bufp++
	bne,a	nextc				! if (--fdc->sc_tc) goto ...
	 ldub	[R_msr], %l7			! get MSR value

	! xfer done: update fdc->sc_buf & fdc->sc_tc, mark istate DONE
	st	R_tc, [R_fdc + FDC_TC]
	st	R_buf, [R_fdc + FDC_DATA]

	! flip TC bit in auxreg
	FD_ASSERT_TC

	! we have some time to kill; anticipate on upcoming
	! result phase.
	add	R_fdc, FDC_STATUS, R_stat	! &fdc->sc_status[0]
	mov	-1, %l7
	st	%l7, [R_fdc + FDC_NSTAT]	! fdc->sc_nstat = -1;

	FD_DEASSERT_TC
	b,a	resultphase1

sensei:
	ldub	[R_msr], %l7
	set	POLL_TIMO, %l6
1:	deccc	%l6				! timeout?
	be,a	ssi				! if so, set status
	 mov	FDC_ISTATUS_ERROR, %l7		! and post sw interrupt
	and	%l7, (NE7_RQM | NE7_DIO | NE7_CB), %l7
	cmp	%l7, NE7_RQM
	bne,a	1b				! loop till chip ready
	 ldub	[R_msr], %l7
	mov	NE7CMD_SENSEI, %l7
	stb	%l7, [R_fifo]

resultphase:
	! prepare for result phase
	add	R_fdc, FDC_STATUS, R_stat	! &fdc->sc_status[0]
	mov	-1, %l7
	st	%l7, [R_fdc + FDC_NSTAT]	! fdc->sc_nstat = -1;

resultphase1:
	clr	R_stcnt
	ldub	[R_msr], %l7
	set	POLL_TIMO, %l6
1:	deccc	%l6				! timeout?
	be,a	ssi				! if so, set status
	 mov	FDC_ISTATUS_ERROR, %l7		! and post sw interrupt
	and	%l7, (NE7_RQM | NE7_DIO | NE7_CB), %l7
	cmp	%l7, NE7_RQM
	be	3f				! done
	cmp	%l7, (NE7_RQM | NE7_DIO | NE7_CB)
	bne,a	1b				! loop till chip ready
	 ldub	[R_msr], %l7

	cmp	R_stcnt, FDC_NSTATUS		! status overrun?
	bge	2f				! if so, load but dont store
	ldub	[R_fifo], %l7			! load the status byte
	stb	%l7, [R_stat]
	inc	R_stat
	inc	R_stcnt
2:	b	1b
	 ldub	[R_msr], %l7

3:
	! got status, update sc_nstat and mark istate DONE
	st	R_stcnt, [R_fdc + FDC_NSTAT]
	mov	FDC_ISTATUS_DONE, %l7

ssi:
	! set software interrupt
	! enter here with status in %l7
	st	%l7, [R_fdc + FDC_ISTATUS]
	ld	[R_fdc + FDC_SIH], %l6
	mov	1, %l7
	st	%l7, [%l6 + SIH_PENDING]
	FD_SET_SWINTR

x:
	/*
	 * Restore psr -- note: psr delay honored by pc restore loads.
	 */
	set	save_l, %l7
	ldd	[%l7], %l0
	mov	%l0, %psr
	 nop
	ld	[%l7 + 8], %l2
	jmp	%l1
	rett	%l2
#endif
@


1.13
log
@Make sure fast trap handlers correctly invoke soft interrupts by marking
them explicitely pending before triggering the softintr; I am ashamed I did
not notice this when changing the soft interrupt code 18 months ago.
Noticed by claudio@@ and beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bsd_fdintr.s,v 1.12 2009/04/10 20:53:54 miod Exp $	*/
@


1.12
log
@generic soft interrupts support for sparc. Soft interrupt handlers are now
kept in a separate intrhand array, with their own enable bits so that
soft interrupts sharing the same level only get invoked if really triggered.
Inspired by NetBSD with significant changes.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bsd_fdintr.s,v 1.11 2004/09/29 07:35:13 miod Exp $	*/
d190 1
a190 1
	inccc	%l4
d310 3
@


1.11
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bsd_fdintr.s,v 1.10 2004/09/22 22:12:59 miod Exp $	*/
d45 7
@


1.10
log
@Bring some enhancements and fixes to fdc(4) from NetBSD:
- better state machine, will prevent "eject fd0" with an empty drive to
  spin.
- will not attach fd children to fdc if no floppy drive is present (though
  the PROM usually finds this for us).
- use biowait() in fdformat() instead of rolling our own.
- drop 5"1/4 formats table.
- cope with non 512 bytes per sector formats.
@
text
@d1 1
a1 1
/*	$OpenBSD: bsd_fdintr.s,v 1.9 2003/04/06 22:49:36 miod Exp $	*/
d182 4
a185 3
	ld	[R_fdc + FDC_EVCNT], %l6
	inc	%l6
	st	%l6, [R_fdc + FDC_EVCNT]
@


1.9
log
@IPL_FDSOFT not IPL_AUSOFT (in comments)
@
text
@d1 1
a1 1
/*	$OpenBSD: bsd_fdintr.s,v 1.8 2002/08/11 12:14:39 art Exp $	*/
d192 2
a193 2
	ld	[R_fdc + FDC_ISTATE], %l7	! examine flags
	cmp	%l7, ISTATE_SENSEI
d195 7
a201 4
	 nop
	cmp	%l7, ISTATE_DMA
	bne	spurious
	 nop
a250 5
spurious:
	mov	ISTATE_SPURIOUS, %l7
	st	%l7, [R_fdc + FDC_ISTATE]
	b,a	ssi

d255 2
a256 1
	be	ssi
d275 2
a276 1
	be	ssi
d296 1
a296 2
	mov	ISTATE_DONE, %l7
	st	%l7, [R_fdc + FDC_ISTATE]
d300 2
@


1.8
log
@Use _C_LABEL for c labels.
@
text
@d1 1
a1 1
/*	$OpenBSD: bsd_fdintr.s,v 1.7 2002/04/28 03:51:19 art Exp $	*/
d52 1
a52 1
! raise(0,IPL_AUSOFT)	! NOTE: CPU#0 and IPL_AUSOFT=4
@


1.7
log
@Rename all PIL_* constants to IPL_* to match other archs and make them
usable in MD code in the future.
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bsd_fdintr.s,v 1.6 2001/05/10 10:34:45 art Exp $	*/
d39 1
d65 2
a66 2
	sethi	%hi(_cputyp), %l5;			\
	ld	[%l5 + %lo(_cputyp)], %l5;		\
d111 2
a112 2
	sethi	%hi(_cputyp), %l5;			\
	ld	[%l5 + %lo(_cputyp)], %l5;		\
d152 1
a152 1
	.global _fdciop
d159 1
a159 1
_fdciop:
d164 1
a164 1
	.global _fdchwintr
d166 1
a166 1
_fdchwintr:
d172 2
a173 2
	sethi	%hi(_uvmexp+V_INTR), %l7
	ld	[%l7 + %lo(_uvmexp+V_INTR)], %l6
d175 1
a175 1
	st	%l6, [%l7 + %lo(_uvmexp+V_INTR)]
d178 2
a179 2
	sethi	%hi(_fdciop), %l7
	ld	[%l7 + %lo(_fdciop)], R_fdc
@


1.6
log
@UVM is no longer optional on sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: bsd_fdintr.s,v 1.5 1999/04/22 18:43:51 art Exp $	*/
d51 1
a51 1
! raise(0,PIL_AUSOFT)	! NOTE: CPU#0 and PIL_AUSOFT=4
@


1.6.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bsd_fdintr.s,v 1.6 2001/05/10 10:34:45 art Exp $	*/
d51 1
a51 1
! raise(0,IPL_AUSOFT)	! NOTE: CPU#0 and IPL_AUSOFT=4
@


1.6.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bsd_fdintr.s,v 1.6.4.1 2002/06/11 03:38:16 art Exp $	*/
a38 1
#include <machine/asm.h>
d64 2
a65 2
	sethi	%hi(_C_LABEL(cputyp)), %l5;		\
	ld	[%l5 + %lo(_C_LABEL(cputyp))], %l5;	\
d110 2
a111 2
	sethi	%hi(_C_LABEL(cputyp)), %l5;		\
	ld	[%l5 + %lo(_C_LABEL(cputyp))], %l5;	\
d151 1
a151 1
	.global _C_LABEL(fdciop)
d158 1
a158 1
_C_LABEL(fdciop):
d163 1
a163 1
	.global _C_LABEL(fdchwintr)
d165 1
a165 1
_C_LABEL(fdchwintr):
d171 2
a172 2
	sethi	%hi(_C_LABEL(uvmexp)+V_INTR), %l7
	ld	[%l7 + %lo(_C_LABEL(uvmexp)+V_INTR)], %l6
d174 1
a174 1
	st	%l6, [%l7 + %lo(_C_LABEL(uvmexp)+V_INTR)]
d177 2
a178 2
	sethi	%hi(_C_LABEL(fdciop)), %l7
	ld	[%l7 + %lo(_C_LABEL(fdciop))], R_fdc
@


1.6.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 1
a52 1
! raise(0,IPL_FDSOFT)	! NOTE: CPU#0 and IPL_FDSOFT=4
@


1.5
log
@UVM fixes, cnt -> uvmexp
@
text
@d1 1
a1 1
/*	$OpenBSD: bsd_fdintr.s,v 1.4 1997/08/25 08:38:47 downsj Exp $	*/
a170 1
#if defined(UVM)
a174 6
#else
	sethi	%hi(_cnt+V_INTR), %l7
	ld	[%l7 + %lo(_cnt+V_INTR)], %l6
	inc	%l6
	st	%l6, [%l7 + %lo(_cnt+V_INTR)]
#endif
@


1.5.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: bsd_fdintr.s,v 1.5 1999/04/22 18:43:51 art Exp $	*/
d171 1
d176 6
@


1.5.4.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a38 1
#include <machine/asm.h>
d51 1
a51 1
! raise(0,IPL_AUSOFT)	! NOTE: CPU#0 and IPL_AUSOFT=4
d64 2
a65 2
	sethi	%hi(_C_LABEL(cputyp)), %l5;		\
	ld	[%l5 + %lo(_C_LABEL(cputyp))], %l5;	\
d110 2
a111 2
	sethi	%hi(_C_LABEL(cputyp)), %l5;		\
	ld	[%l5 + %lo(_C_LABEL(cputyp))], %l5;	\
d151 1
a151 1
	.global _C_LABEL(fdciop)
d158 1
a158 1
_C_LABEL(fdciop):
d163 1
a163 1
	.global _C_LABEL(fdchwintr)
d165 1
a165 1
_C_LABEL(fdchwintr):
d171 2
a172 2
	sethi	%hi(_C_LABEL(uvmexp)+V_INTR), %l7
	ld	[%l7 + %lo(_C_LABEL(uvmexp)+V_INTR)], %l6
d174 1
a174 1
	st	%l6, [%l7 + %lo(_C_LABEL(uvmexp)+V_INTR)]
d177 2
a178 2
	sethi	%hi(_C_LABEL(fdciop)), %l7
	ld	[%l7 + %lo(_C_LABEL(fdciop))], R_fdc
@


1.5.4.3
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: bsd_fdintr.s,v 1.5.4.2 2003/03/27 23:49:26 niklas Exp $	*/
d52 1
a52 1
! raise(0,IPL_FDSOFT)	! NOTE: CPU#0 and IPL_FDSOFT=4
@


1.4
log
@Implement LED blinking as a run-time configurable option via the sysctl
machdep.led_blink.

Rename auxreg.h because we need config to generate one now.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d171 6
d181 1
@


1.3
log
@New floppy and auxreg drivers, from NetBSD.  fd.c has many changes preserved,
and uses our fdformat interface (same code base as NetBSD, with differently
named ioctls, but we have always preserved the names of the original code's
authors, unlike NetBSD...)
@
text
@d1 1
d40 1
a40 1
#include <sparc/sparc/auxreg.h>
@


1.2
log
@netbsd port, now we merge our changes back in
@
text
@d1 1
a1 1
/*	$NetBSD: bsd_fdintr.s,v 1.8 1996/03/31 23:45:00 pk Exp $ */
d36 2
d43 87
a129 2
/* XXX this goes in a header file -- currently, it's hidden in locore.s */
#define INTREG_ADDR 0xf8002000
d230 1
a230 1
	! xfer done: update fdc->sc_buf & fdc->sc_tc, mark istate IDLE
d235 1
a235 5
	sethi	%hi(_auxio_reg), %l6
	ld	[%l6 + %lo(_auxio_reg)], %l6
	ldub	[%l6], %l7
	or	%l7, AUXIO_MB1|AUXIO_FTC, %l7
	stb	%l7, [%l6]
d243 2
a244 6
	ldub	[%l6], %l7
	andn	%l7, AUXIO_FTC, %l7
	or	%l7, AUXIO_MB1, %l7
	stb	%l7, [%l6]
	b	resultphase1
	 nop
d292 1
a292 1
	! got status, update sc_nstat and mark istate IDLE
d294 1
a294 1
	mov	ISTATE_IDLE, %l7
d299 1
a299 4
	sethi	%hi(INTREG_ADDR), %l7
	ldsb	[%l7 + %lo(INTREG_ADDR)], %l6
	or	%l6, IE_L4, %l6
	stb	%l6, [%l7 + %lo(INTREG_ADDR)]
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: bsd_fdintr.s,v 1.4 1995/04/25 20:01:23 pk Exp $ */
d35 1
a35 4
#ifndef LOCORE
#define LOCORE
#endif
#include "assym.s"
d103 1
a103 1
	ld	[R_fdc + FDC_ISTATE], %l7	! examine flags 
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
