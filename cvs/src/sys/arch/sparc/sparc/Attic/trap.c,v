head	1.74;
access;
symbols
	OPENBSD_6_0:1.73.0.2
	OPENBSD_6_0_BASE:1.73
	OPENBSD_5_9:1.72.0.2
	OPENBSD_5_9_BASE:1.72
	OPENBSD_5_8:1.71.0.4
	OPENBSD_5_8_BASE:1.71
	OPENBSD_5_7:1.69.0.2
	OPENBSD_5_7_BASE:1.69
	OPENBSD_5_6:1.68.0.4
	OPENBSD_5_6_BASE:1.68
	OPENBSD_5_5:1.63.0.6
	OPENBSD_5_5_BASE:1.63
	OPENBSD_5_4:1.63.0.2
	OPENBSD_5_4_BASE:1.63
	OPENBSD_5_3:1.62.0.2
	OPENBSD_5_3_BASE:1.62
	OPENBSD_5_2:1.59.0.2
	OPENBSD_5_2_BASE:1.59
	OPENBSD_5_1_BASE:1.58
	OPENBSD_5_1:1.58.0.2
	OPENBSD_5_0:1.57.0.2
	OPENBSD_5_0_BASE:1.57
	OPENBSD_4_9:1.55.0.2
	OPENBSD_4_9_BASE:1.55
	OPENBSD_4_8:1.54.0.2
	OPENBSD_4_8_BASE:1.54
	OPENBSD_4_7:1.53.0.8
	OPENBSD_4_7_BASE:1.53
	OPENBSD_4_6:1.53.0.10
	OPENBSD_4_6_BASE:1.53
	OPENBSD_4_5:1.53.0.6
	OPENBSD_4_5_BASE:1.53
	OPENBSD_4_4:1.53.0.4
	OPENBSD_4_4_BASE:1.53
	OPENBSD_4_3:1.53.0.2
	OPENBSD_4_3_BASE:1.53
	OPENBSD_4_2:1.52.0.2
	OPENBSD_4_2_BASE:1.52
	OPENBSD_4_1:1.50.0.2
	OPENBSD_4_1_BASE:1.50
	OPENBSD_4_0:1.48.0.2
	OPENBSD_4_0_BASE:1.48
	OPENBSD_3_9:1.47.0.2
	OPENBSD_3_9_BASE:1.47
	OPENBSD_3_8:1.44.0.2
	OPENBSD_3_8_BASE:1.44
	OPENBSD_3_7:1.42.0.2
	OPENBSD_3_7_BASE:1.42
	OPENBSD_3_6:1.41.0.2
	OPENBSD_3_6_BASE:1.41
	SMP_SYNC_A:1.40
	SMP_SYNC_B:1.40
	OPENBSD_3_5:1.40.0.4
	OPENBSD_3_5_BASE:1.40
	OPENBSD_3_4:1.40.0.2
	OPENBSD_3_4_BASE:1.40
	UBC_SYNC_A:1.40
	OPENBSD_3_3:1.39.0.4
	OPENBSD_3_3_BASE:1.39
	OPENBSD_3_2:1.39.0.2
	OPENBSD_3_2_BASE:1.39
	OPENBSD_3_1:1.37.0.2
	OPENBSD_3_1_BASE:1.37
	UBC_SYNC_B:1.39
	UBC:1.35.0.2
	UBC_BASE:1.35
	OPENBSD_3_0:1.32.0.2
	OPENBSD_3_0_BASE:1.32
	OPENBSD_2_9_BASE:1.27
	OPENBSD_2_9:1.27.0.2
	OPENBSD_2_8:1.25.0.2
	OPENBSD_2_8_BASE:1.25
	OPENBSD_2_7:1.23.0.2
	OPENBSD_2_7_BASE:1.23
	SMP:1.21.0.2
	SMP_BASE:1.21
	kame_19991208:1.19
	OPENBSD_2_6:1.19.0.2
	OPENBSD_2_6_BASE:1.19
	OPENBSD_2_5:1.14.0.4
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.14.0.2
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.74
date	2016.09.01.09.23.43;	author tedu;	state dead;
branches;
next	1.73;
commitid	Q2PxaFNhqAe0Wmla;

1.73
date	2016.02.27.13.08.07;	author mpi;	state Exp;
branches;
next	1.72;
commitid	hnv9KfQtxhCytAnd;

1.72
date	2015.11.06.06.33.26;	author guenther;	state Exp;
branches;
next	1.71;
commitid	wzHEHv1WzrJZbX9A;

1.71
date	2015.03.27.20.25.39;	author miod;	state Exp;
branches;
next	1.70;
commitid	DNjbblqLgBZmk6yi;

1.70
date	2015.03.18.20.56.40;	author miod;	state Exp;
branches;
next	1.69;
commitid	1t8JWNihm6Vc4kyS;

1.69
date	2014.11.16.12.30.59;	author deraadt;	state Exp;
branches;
next	1.68;
commitid	yv0ECmCdICvq576h;

1.68
date	2014.05.11.00.12.44;	author guenther;	state Exp;
branches;
next	1.67;

1.67
date	2014.05.10.05.33.00;	author guenther;	state Exp;
branches;
next	1.66;

1.66
date	2014.04.30.04.20.31;	author miod;	state Exp;
branches;
next	1.65;

1.65
date	2014.04.18.11.51.17;	author guenther;	state Exp;
branches;
next	1.64;

1.64
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.63;

1.63
date	2013.06.03.18.46.02;	author kettenis;	state Exp;
branches;
next	1.62;

1.62
date	2012.12.31.06.46.14;	author guenther;	state Exp;
branches;
next	1.61;

1.61
date	2012.08.08.04.46.25;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2012.08.07.05.16.54;	author guenther;	state Exp;
branches;
next	1.59;

1.59
date	2012.04.11.14.38.55;	author mikeb;	state Exp;
branches;
next	1.58;

1.58
date	2011.11.16.20.50.19;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2011.07.04.22.53.53;	author tedu;	state Exp;
branches;
next	1.56;

1.56
date	2011.04.03.14.56.28;	author guenther;	state Exp;
branches;
next	1.55;

1.55
date	2010.11.27.19.41.48;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2010.07.10.19.32.25;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2008.01.06.21.15.58;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2007.05.08.07.23.18;	author art;	state Exp;
branches;
next	1.51;

1.51
date	2007.03.15.10.22.30;	author art;	state Exp;
branches;
next	1.50;

1.50
date	2006.12.24.20.30.35;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2006.12.24.20.29.19;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2006.06.09.06.41.44;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2006.01.30.21.26.19;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2005.12.25.00.22.47;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2005.09.15.21.09.29;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2005.04.21.04.39.35;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	2005.04.17.18.47.51;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2004.12.06.20.12.25;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2004.08.06.22.39.14;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2003.05.12.04.42.58;	author jason;	state Exp;
branches;
next	1.39;

1.39
date	2002.07.24.00.55.52;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2002.05.16.21.11.18;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2002.03.26.01.00.30;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2001.11.28.13.47.39;	author art;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2001.11.06.21.33.53;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2001.09.19.20.50.57;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2001.09.14.09.39.53;	author art;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.25.00.43.17;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2001.05.10.10.34.49;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2001.05.05.20.56.53;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2001.04.06.04.42.06;	author csapuntz;	state Exp;
branches;
next	1.26;

1.26
date	2000.11.10.18.15.42;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2000.07.04.10.52.28;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.08.22.25.22;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	2000.02.21.21.05.59;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2000.02.21.17.08.37;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2000.01.31.16.06.59;	author art;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2000.01.27.20.14.11;	author art;	state Exp;
branches;
next	1.19;

1.19
date	99.08.17.16.09.21;	author art;	state Exp;
branches;
next	1.18;

1.18
date	99.07.09.21.30.03;	author art;	state Exp;
branches;
next	1.17;

1.17
date	99.06.17.18.17.10;	author art;	state Exp;
branches;
next	1.16;

1.16
date	99.04.22.19.02.49;	author art;	state Exp;
branches;
next	1.15;

1.15
date	99.04.22.18.43.53;	author art;	state Exp;
branches;
next	1.14;

1.14
date	98.05.11.05.42.31;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.03.01.10.14.13;	author johns;	state Exp;
branches;
next	1.12;

1.12
date	97.09.17.06.47.22;	author downsj;	state Exp;
branches;
next	1.11;

1.11
date	97.08.08.08.27.46;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	97.07.01.23.35.55;	author grr;	state Exp;
branches;
next	1.9;

1.9
date	97.02.04.17.23.51;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.02.04.12.23.16;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.02.03.18.04.48;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.02.01.23.05.09;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.01.27.22.48.26;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.08.11.05.35.27;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.01.14.00.39.18;	author davem;	state Exp;
branches;
next	1.2;

1.2
date	95.10.18.18.17.47;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.48;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.48;	author deraadt;	state Exp;
branches;
next	;

1.21.2.1
date	2000.02.21.22.29.04;	author niklas;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2001.05.14.21.37.19;	author niklas;	state Exp;
branches;
next	1.21.2.3;

1.21.2.3
date	2001.07.04.10.23.48;	author niklas;	state Exp;
branches;
next	1.21.2.4;

1.21.2.4
date	2001.10.31.03.07.57;	author nate;	state Exp;
branches;
next	1.21.2.5;

1.21.2.5
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.21.2.6;

1.21.2.6
date	2001.12.05.00.39.13;	author niklas;	state Exp;
branches;
next	1.21.2.7;

1.21.2.7
date	2002.03.28.10.57.11;	author niklas;	state Exp;
branches;
next	1.21.2.8;

1.21.2.8
date	2003.03.27.23.49.26;	author niklas;	state Exp;
branches;
next	1.21.2.9;

1.21.2.9
date	2003.05.13.19.41.09;	author ho;	state Exp;
branches;
next	;

1.35.2.1
date	2002.06.11.03.38.17;	author art;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2002.10.29.00.28.11;	author art;	state Exp;
branches;
next	1.35.2.3;

1.35.2.3
date	2003.05.19.21.46.33;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.74
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: trap.c,v 1.73 2016/02/27 13:08:07 mpi Exp $	*/
/*	$NetBSD: trap.c,v 1.58 1997/09/12 08:55:01 pk Exp $ */

/*
 * Copyright (c) 1996
 *	The President and Fellows of Harvard College. All rights reserved.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *	This product includes software developed by Harvard University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 *	This product includes software developed by Harvard University.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)trap.c	8.4 (Berkeley) 9/23/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/user.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/resource.h>
#include <sys/signal.h>
#include <sys/wait.h>
#include <sys/syscall.h>
#include <sys/syscall_mi.h>
#include <sys/syslog.h>

#include <uvm/uvm_extern.h>

#include <sparc/sparc/asm.h>
#include <machine/cpu.h>
#include <machine/ctlreg.h>
#include <machine/trap.h>
#include <machine/instr.h>
#include <machine/pmap.h>

#ifdef DDB
#include <machine/db_machdep.h>
#else
#include <machine/frame.h>
#endif

#include <sparc/fpu/fpu_extern.h>
#include <sparc/sparc/memreg.h>
#include <sparc/sparc/cpuvar.h>

#ifdef DEBUG
int	rwindow_debug = 0;
#endif

/*
 * Initial FPU state is all registers == all 1s, everything else == all 0s.
 * This makes every floating point register a signalling NaN, with sign bit
 * set, no matter how it is interpreted.  Appendix N of the Sparc V8 document
 * seems to imply that we should do this, and it does make sense.
 */
struct	fpstate initfpstate = {
	{ ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0,
	  ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0 }
};

/*
 * There are more than 100 trap types, but most are unused.
 *
 * Trap type 0 is taken over as an `Asynchronous System Trap'.
 * This is left-over Vax emulation crap that should be fixed.
 *
 * Note that some of the Sparc v8 traps are actually handled by
 * the corresponding v7 routine, but listed here for completeness.
 * The Fujitsu Turbo-Sparc Guide also alludes to several more
 * unimplemented trap types, but doesn't give the nominal coding.
 */
static const char T[] = "trap";
const char *trap_type[] = {
	/* non-user vectors */
	"ast",			/* 0 */
	"text fault",		/* 1 */
	"illegal instruction",	/* 2 */
	"privileged instruction",/*3 */
	"fp disabled",		/* 4 */
	"window overflow",	/* 5 */
	"window underflow",	/* 6 */
	"alignment fault",	/* 7 */
	"fp exception",		/* 8 */
	"data fault",		/* 9 */
	"tag overflow",		/* 0a */
	"watchpoint",		/* 0b */
	T, T, T, T, T,		/* 0c..10 */
	"level 1 int",		/* 11 */
	"level 2 int",		/* 12 */
	"level 3 int",		/* 13 */
	"level 4 int",		/* 14 */
	"level 5 int",		/* 15 */
	"level 6 int",		/* 16 */
	"level 7 int",		/* 17 */
	"level 8 int",		/* 18 */
	"level 9 int",		/* 19 */
	"level 10 int",		/* 1a */
	"level 11 int",		/* 1b */
	"level 12 int",		/* 1c */
	"level 13 int",		/* 1d */
	"level 14 int",		/* 1e */
	"level 15 int",		/* 1f */
	"v8 r-reg error",	/* 20 */
	"v8 text error",	/* 21 */
	T, T,			/* 22..23 */
	"v8 cp disabled",	/* 24 */
	"v8 unimp flush",	/* 25 */
	T, T,			/* 26..27 */
	"v8 cp exception",	/* 28 */
	"v8 data error",	/* 29 */
	"v8 idiv by zero",	/* 2a */
	"v8 store error",	/* 2b */
	"v8 data access MMU miss",/* 2c */
	T, T, T,		/* 2d..2f */
	T, T, T, T, T, T, T, T,	/* 30..37 */
	T, T, T, T,		/* 38..3b */
	"v8 insn access MMU miss",/* 3c */
	T, T, T,	/* 3d..3f */
	T, T, T, T, T, T, T, T,	/* 40..48 */
	T, T, T, T, T, T, T, T,	/* 48..4f */
	T, T, T, T, T, T, T, T,	/* 50..57 */
	T, T, T, T, T, T, T, T,	/* 58..5f */
	T, T, T, T, T, T, T, T,	/* 60..67 */
	T, T, T, T, T, T, T, T,	/* 68..6f */
	T, T, T, T, T, T, T, T,	/* 70..77 */
	T, T, T, T, T, T, T, T,	/* 78..7f */

	/* user (software trap) vectors */
	"syscall",		/* 80 */
	"breakpoint",		/* 81 */
	"zero divide",		/* 82 */
	"flush windows",	/* 83 */
	"clean windows",	/* 84 */
	"range check",		/* 85 */
	"fix align",		/* 86 */
	"integer overflow",	/* 87 */
	"svr4 syscall",		/* 88 */
	"4.4 syscall",		/* 89 */
	"kgdb exec",		/* 8a */
	T, T, T, T, T,		/* 8b..8f */
	T, T, T, T, T, T, T, T,	/* 9a..97 */
	T, T, T, T, T, T, T, T,	/* 98..9f */
	"svr4 getcc",		/* a0 */
	"svr4 setcc",		/* a1 */
	"svr4 getpsr",		/* a2 */
	"svr4 setpsr",		/* a3 */
	"svr4 gethrtime",	/* a4 */
	"svr4 gethrvtime",	/* a5 */
	T,			/* a6 */
	"svr4 gethrestime",	/* a7 */
};

#define	N_TRAP_TYPES	(sizeof trap_type / sizeof *trap_type)

void trap(unsigned, int, int, struct trapframe *);
static __inline void share_fpu(struct proc *, struct trapframe *);
void mem_access_fault(unsigned, int, u_int, int, int, struct trapframe *);
void mem_access_fault4m(unsigned, u_int, u_int, struct trapframe *);
void syscall(register_t, struct trapframe *, register_t);

int ignore_bogus_traps = 0;

int want_ast = 0;

/*
 * If someone stole the FPU while we were away, do not enable it
 * on return.  This is not done in userret() above as it must follow
 * the ktrsysret() in syscall().  Actually, it is likely that the
 * ktrsysret should occur before the call to userret.
 */
static __inline void share_fpu(p, tf)
	struct proc *p;
	struct trapframe *tf;
{
	if ((tf->tf_psr & PSR_EF) != 0 && cpuinfo.fpproc != p)
		tf->tf_psr &= ~PSR_EF;
}

/*
 * Called from locore.s trap handling, for non-MMU-related traps.
 * (MMU-related traps go through mem_access_fault, below.)
 */
void
trap(type, psr, pc, tf)
	unsigned type;
	int psr, pc;
	struct trapframe *tf;
{
	struct proc *p;
	struct pcb *pcb;
	int n;
	union sigval sv;

        sv.sival_int = pc; /* XXX fix for parm five of trapsignal() */

	/* This steps the PC over the trap. */
#define	ADVANCE (n = tf->tf_npc, tf->tf_pc = n, tf->tf_npc = n + 4)

	uvmexp.traps++;
	/*
	 * Generally, kernel traps cause a panic.  Any exceptions are
	 * handled early here.
	 */
	if (psr & PSR_PS) {
#ifdef DDB
		if (type == T_BREAKPOINT) {
			write_all_windows();
			if (db_ktrap(type, tf)) {
				return;
			}
		}
#endif
#ifdef DIAGNOSTIC
		/*
		 * Currently, we allow DIAGNOSTIC kernel code to
		 * flush the windows to record stack traces.
		 */
		if (type == T_FLUSHWIN) {
			write_all_windows();
			ADVANCE;
			return;
		}
#endif
		/*
		 * Storing %fsr in cpu_attach will cause this trap
		 * even though the fpu has been enabled, if and only
		 * if there is no FPU.
		 */
		if (type == T_FPDISABLED && cold) {
			ADVANCE;
			return;
		}
	dopanic:
		printf("trap type 0x%x: pc=0x%x npc=0x%x psr=%b\n",
		       type, pc, tf->tf_npc, psr, PSR_BITS);
		panic(type < N_TRAP_TYPES ? trap_type[type] : T);
		/* NOTREACHED */
	}
	if ((p = curproc) == NULL)
		p = &proc0;
	pcb = &p->p_addr->u_pcb;
	p->p_md.md_tf = tf;	/* for ptrace/signals */
	refreshcreds(p);

	switch (type) {

	default:
		if (type < 0x80) {
			if (!ignore_bogus_traps)
				goto dopanic;
			printf("trap type 0x%x: pc=0x%x npc=0x%x psr=%b\n",
			       type, pc, tf->tf_npc, psr, PSR_BITS);
			trapsignal(p, SIGILL, type, ILL_ILLOPC, sv);
			break;
		}
		/* the following message is gratuitous */
		/* ... but leave it in until we find anything */
		printf("%s[%d]: unimplemented software trap 0x%x\n",
			p->p_comm, p->p_pid, type);
		trapsignal(p, SIGILL, type, ILL_ILLOPC, sv);
		break;

	case T_AST:
		want_ast = 0;
		uvmexp.softs++;
		mi_ast(p, want_resched);
		break;

	case T_ILLINST:
		if ((n = emulinstr(pc, tf)) == 0) {
			ADVANCE;
			break;
		}
		trapsignal(p, SIGILL, 0, ILL_ILLOPC, sv);
		break;

	case T_PRIVINST:
		trapsignal(p, SIGILL, 0, ILL_PRVOPC, sv);
		break;

	case T_FPDISABLED: {
		struct fpstate *fs = p->p_md.md_fpstate;

		if (fs == NULL) {
			fs = malloc(sizeof *fs, M_SUBPROC, M_WAITOK);
			*fs = initfpstate;
			p->p_md.md_fpstate = fs;
		}
		/*
		 * If we have not found an FPU, we have to emulate it.
		 */
		if (!foundfpu) {
#ifdef notyet
			fpu_emulate(p, tf, fs);
			break;
#else
			trapsignal(p, SIGFPE, 0, FPE_FLTINV, sv);
			break;
#endif
		}
		/*
		 * We may have more FPEs stored up and/or ops queued.
		 * If they exist, handle them and get out.  Otherwise,
		 * resolve the FPU state, turn it on, and try again.
		 */
		if (fs->fs_qsize) {
			fpu_cleanup(p, fs);
			break;
		}
		if (cpuinfo.fpproc != p) {	/* we do not have it */
			if (cpuinfo.fpproc != NULL) /* someone else had it */
				savefpstate(cpuinfo.fpproc->p_md.md_fpstate);
			loadfpstate(fs);
			cpuinfo.fpproc = p;	/* now we do have it */
			uvmexp.fpswtch++;
		}
		tf->tf_psr |= PSR_EF;
		break;
	}

	case T_WINOF:
		if (rwindow_save(p))
			sigexit(p, SIGILL);
		break;

#define read_rw(src, dst) \
	copyin((caddr_t)(src), (caddr_t)(dst), sizeof(struct rwindow))

	case T_RWRET:
		/*
		 * T_RWRET is a window load needed in order to rett.
		 * It simply needs the window to which tf->tf_out[6]
		 * (%sp) points.  There are no user or saved windows now.
		 * Copy the one from %sp into pcb->pcb_rw[0] and set
		 * nsaved to -1.  If we decide to deliver a signal on
		 * our way out, we will clear nsaved.
		 */
		if (pcb->pcb_uw || pcb->pcb_nsaved)
			panic("trap T_RWRET 1");
#ifdef DEBUG
		if (rwindow_debug)
			printf("%s[%d]: rwindow: pcb<-stack: 0x%x\n",
				p->p_comm, p->p_pid, tf->tf_out[6]);
#endif
		if (read_rw(tf->tf_out[6], &pcb->pcb_rw[0]))
			sigexit(p, SIGILL);
		if (pcb->pcb_nsaved)
			panic("trap T_RWRET 2");
		pcb->pcb_nsaved = -1;		/* mark success */
		break;

	case T_WINUF:
		/*
		 * T_WINUF is a real window underflow, from a restore
		 * instruction.  It needs to have the contents of two
		 * windows---the one belonging to the restore instruction
		 * itself, which is at its %sp, and the one belonging to
		 * the window above, which is at its %fp or %i6---both
		 * in the pcb.  The restore's window may still be in
		 * the cpu; we need to force it out to the stack.
		 */
#ifdef DEBUG
		if (rwindow_debug)
			printf("%s[%d]: rwindow: T_WINUF 0: pcb<-stack: 0x%x\n",
				p->p_comm, p->p_pid, tf->tf_out[6]);
#endif
		write_user_windows();
		if (rwindow_save(p) || read_rw(tf->tf_out[6], &pcb->pcb_rw[0]))
			sigexit(p, SIGILL);
#ifdef DEBUG
		if (rwindow_debug)
			printf("%s[%d]: rwindow: T_WINUF 1: pcb<-stack: 0x%x\n",
				p->p_comm, p->p_pid, pcb->pcb_rw[0].rw_in[6]);
#endif
		if (read_rw(pcb->pcb_rw[0].rw_in[6], &pcb->pcb_rw[1]))
			sigexit(p, SIGILL);
		if (pcb->pcb_nsaved)
			panic("trap T_WINUF");
		pcb->pcb_nsaved = -1;		/* mark success */
		break;

	case T_ALIGN:
		trapsignal(p, SIGBUS, 0, BUS_ADRALN, sv);
		break;

	case T_FPE:
		/*
		 * Clean up after a floating point exception.
		 * fpu_cleanup can (and usually does) modify the
		 * state we save here, so we must `give up' the FPU
		 * chip context.  (The software and hardware states
		 * will not match once fpu_cleanup does its job, so
		 * we must not save again later.)
		 */
		if (p != cpuinfo.fpproc)
			panic("fpe without being the FP user");
		savefpstate(p->p_md.md_fpstate);
		cpuinfo.fpproc = NULL;
		/* tf->tf_psr &= ~PSR_EF; */	/* share_fpu will do this */
		fpu_cleanup(p, p->p_md.md_fpstate);
		/* fpu_cleanup posts signals if needed */
#if 0		/* ??? really never??? */
		ADVANCE;
#endif
		break;

	case T_TAGOF:
		trapsignal(p, SIGEMT, 0, EMT_TAGOVF, sv);
		break;

	case T_CPDISABLED:
		uprintf("coprocessor instruction\n");	/* XXX */
		trapsignal(p, SIGILL, 0, ILL_COPROC, sv);
		break;

	case T_BREAKPOINT:
		trapsignal(p, SIGTRAP, 0, TRAP_BRKPT, sv);
		break;

	case T_DIV0:
	case T_IDIV0:
		ADVANCE;
		trapsignal(p, SIGFPE, 0, FPE_INTDIV, sv);
		break;

	case T_FLUSHWIN:
		write_user_windows();
#ifdef probably_slower_since_this_is_usually_false
		if (pcb->pcb_nsaved && rwindow_save(p))
			sigexit(p, SIGILL);
#endif
		ADVANCE;
		break;

	case T_CLEANWIN:
		uprintf("T_CLEANWIN\n");	/* XXX */
		ADVANCE;
		break;

	case T_RANGECHECK:
		uprintf("T_RANGECHECK\n");	/* XXX */
		ADVANCE;
		trapsignal(p, SIGILL, 0, ILL_ILLOPN, sv);
		break;

	case T_FIXALIGN:
		uprintf("T_FIXALIGN\n");
		ADVANCE;
		trapsignal(p, SIGILL, 0, ILL_ILLOPN, sv);
		break;

	case T_INTOF:
		uprintf("T_INTOF\n");		/* XXX */
		ADVANCE;
		trapsignal(p, SIGFPE, FPE_INTOVF_TRAP, FPE_INTOVF, sv);
		break;
	}
	userret(p);
	share_fpu(p, tf);
#undef ADVANCE
}

/*
 * Save windows from PCB into user stack, and return 0.  This is used on
 * window overflow pseudo-traps (from locore.s, just before returning to
 * user mode) and when ptrace or sendsig needs a consistent state.
 * As a side effect, rwindow_save() always sets pcb_nsaved to 0,
 * clobbering the `underflow restore' indicator if it was -1.
 *
 * If the windows cannot be saved, pcb_nsaved is restored and we return -1.
 */
int
rwindow_save(p)
	struct proc *p;
{
	struct pcb *pcb = &p->p_addr->u_pcb;
	struct rwindow *rw = &pcb->pcb_rw[0];
	int i;

	i = pcb->pcb_nsaved;
	if (i < 0) {
		pcb->pcb_nsaved = 0;
		return (0);
	}
	if (i == 0)
		return (0);
#ifdef DEBUG
	if (rwindow_debug)
		printf("%s[%d]: rwindow: pcb->stack:", p->p_comm, p->p_pid);
#endif
	do {
#ifdef DEBUG
		if (rwindow_debug)
			printf(" 0x%x", rw[1].rw_in[6]);
#endif
		if (copyout((caddr_t)rw, (caddr_t)rw[1].rw_in[6],
		    sizeof *rw))
			return (-1);
		rw++;
	} while (--i > 0);
#ifdef DEBUG
	if (rwindow_debug)
		printf("\n");
#endif
	pcb->pcb_nsaved = 0;
	return (0);
}

/*
 * Kill user windows (before exec) by writing back to stack or pcb
 * and then erasing any pcb tracks.  Otherwise we might try to write
 * the registers into the new process after the exec.
 */
void
pmap_unuse_final(p)
	struct proc *p;
{

	write_user_windows();
	p->p_addr->u_pcb.pcb_nsaved = 0;
}

/*
 * Called from locore.s trap handling, for synchronous memory faults.
 *
 * This duplicates a lot of logic in trap() and perhaps should be
 * moved there; but the bus-error-register parameters are unique to
 * this routine.
 *
 * Since synchronous errors accumulate during prefetch, we can have
 * more than one `cause'.  But we do not care what the cause, here;
 * we just want to page in the page and try again.
 */
void
mem_access_fault(type, ser, v, pc, psr, tf)
	unsigned type;
	int ser;
	u_int v;
	int pc, psr;
	struct trapframe *tf;
{
#if defined(SUN4) || defined(SUN4C) || defined(SUN4E)
	struct proc *p;
	struct vmspace *vm;
	vaddr_t va;
	int rv;
	vm_prot_t ftype;
	int onfault;
	union sigval sv;

	uvmexp.traps++;
	if ((p = curproc) == NULL)	/* safety check */
		p = &proc0;

	/*
	 * Figure out what to pass the VM code, and ignore the sva register
	 * value in v on text faults (text faults are always at pc).
	 * Kernel faults are somewhat different: text faults are always
	 * illegal, and data faults are extra complex.  User faults must
	 * set p->p_md.md_tf, in case we decide to deliver a signal.  Check
	 * for illegal virtual addresses early since those can induce more
	 * faults.
	 */
	if (type == T_TEXTFAULT)
		v = pc;
	if (VA_INHOLE(v))
		goto fault;
	ftype = ser & SER_WRITE ? PROT_WRITE : PROT_READ;
	va = trunc_page(v);
	if (psr & PSR_PS) {
#if defined(SUN4)
		extern char Lfsbail[];
#endif
		if (type == T_TEXTFAULT) {
			(void) splhigh();
			printf("text fault: pc=0x%x ser=%b\n", pc,
			       ser, SER_BITS);
			panic("kernel fault");
			/* NOTREACHED */
		}
#if defined(SUN4)
		/*
		 * If this was an access that we shouldn't try to page in,
		 * resume at the fault handler without any action.
		 */
		if (p->p_addr && p->p_addr->u_pcb.pcb_onfault == Lfsbail)
			goto kfault;
#endif

		/*
		 * During autoconfiguration, faults are never OK unless
		 * pcb_onfault is set.  Once running normally we must allow
		 * exec() to cause copy-on-write faults to kernel addresses.
		 */
		if (cold)
			goto kfault;
		if (va >= vm_min_kernel_address) {
			if (uvm_fault(kernel_map, va, 0, ftype) == 0)
				return;
			goto kfault;
		}
	} else
		p->p_md.md_tf = tf;

	/*
	 * mmu_pagein returns -1 if the page is already valid, in which
	 * case we have a hard fault; it returns 1 if it loads a segment
	 * that got bumped out via LRU replacement.
	 */
	vm = p->p_vmspace;
	rv = mmu_pagein(vm->vm_map.pmap, va,
			ser & SER_WRITE ? PROT_WRITE : PROT_READ);
	if (rv < 0)
		goto fault;
	if (rv > 0)
		goto out;

	/* alas! must call the horrible vm code */
	rv = uvm_fault(&vm->vm_map, (vaddr_t)va, 0, ftype);

	/*
	 * If this was a stack access we keep track of the maximum
	 * accessed stack size.  Also, if vm_fault gets a protection
	 * failure it is due to accessing the stack region outside
	 * the current limit and we need to reflect that as an access
	 * error.
	 */
	if ((caddr_t)va >= vm->vm_maxsaddr) {
		if (rv == 0)
			uvm_grow(p, va);
		else if (rv == EACCES)
			rv = EFAULT;
	}
	if (rv == 0) {
		/*
		 * pmap_enter() does not enter all requests made from
		 * vm_fault into the MMU (as that causes unnecessary
		 * entries for `wired' pages).  Instead, we call
		 * mmu_pagein here to make sure the new PTE gets installed.
		 */
		(void) mmu_pagein(vm->vm_map.pmap, va, PROT_NONE);
	} else {
		/*
		 * Pagein failed.  If doing copyin/out, return to onfault
		 * address.  Any other page fault in kernel, die; if user
		 * fault, deliver SIGSEGV.
		 */
fault:
		if (psr & PSR_PS) {
kfault:
			onfault = p->p_addr ?
			    (int)p->p_addr->u_pcb.pcb_onfault : 0;
			if (!onfault) {
				(void) splhigh();
				printf("data fault: pc=0x%x addr=0x%x ser=%b\n",
				       pc, v, ser, SER_BITS);
				panic("kernel fault");
				/* NOTREACHED */
			}
			tf->tf_pc = onfault;
			tf->tf_npc = onfault + 4;
			return;
		}
		
		sv.sival_int = v;
		trapsignal(p, SIGSEGV, (ser & SER_WRITE) ? PROT_WRITE :
		    PROT_READ, SEGV_MAPERR, sv);
	}
out:
	if ((psr & PSR_PS) == 0) {
		userret(p);
		share_fpu(p, tf);
	}
#endif /* SUN4 || SUN4C || SUN4E */
}

#if defined(SUN4M)	/* 4m version of mem_access_fault() follows */

static int tfaultaddr = (int) 0xdeadbeef;

#ifdef DEBUG
int dfdebug = 0;
#endif

void
mem_access_fault4m(type, sfsr, sfva, tf)
	unsigned type;
	u_int sfsr;
	u_int sfva;
	struct trapframe *tf;
{
	int pc, psr;
	struct proc *p;
	struct vmspace *vm;
	vaddr_t va;
	int rv;
	vm_prot_t ftype;
	int onfault;
	union sigval sv;

	uvmexp.traps++;
	if ((p = curproc) == NULL)	/* safety check */
		p = &proc0;

	pc = tf->tf_pc;			/* These are needed below */
	psr = tf->tf_psr;

	/*
	 * Our first priority is handling serious faults, such as
	 * parity errors or async faults that might have come through here.
	 * If afsr & AFSR_AFO != 0, then we're on a HyperSPARC and we
	 * got an async fault. We pass it on to memerr4m. Similarly, if
	 * the trap was T_STOREBUFFAULT, we pass it on to memerr4m.
	 * If we have a data fault, but SFSR_FAV is not set in the sfsr,
	 * then things are really bizarre, and we treat it as a hard
	 * error and pass it on to memerr4m. See pg. 9-35 in the SuperSPARC
	 * user's guide for more info, and for a possible solution which we
	 * don't implement here.
	 */
	if (type == T_STOREBUFFAULT ||
	    (type == T_DATAFAULT && !(sfsr & SFSR_FAV))) {
		(*cpuinfo.memerr)(type, sfsr, sfva, tf);
		/*
		 * If we get here, exit the trap handler and wait for the
		 * trap to re-occur.
		 */
		goto out;
	}

	/*
	 * Figure out what to pass the VM code. We cannot ignore the sfva
	 * register on text faults, since this might be a trap on an
	 * alternate-ASI access to code space. However, if we're on a
	 * supersparc, we can't help using PC, since we don't get a VA in
	 * sfva.
	 * Kernel faults are somewhat different: text faults are always
	 * illegal, and data faults are extra complex.  User faults must
	 * set p->p_md.md_tf, in case we decide to deliver a signal.  Check
	 * for illegal virtual addresses early since those can induce more
	 * faults.
	 * All translation faults are illegal, and result in a SIGSEGV
	 * being delivered to the running process (or a kernel panic, for
	 * a kernel fault). We check the translation first to make sure
	 * it is not spurious.
	 * Also, note that in the case where we have an overwritten
	 * text fault (OW==1, AT==2,3), we attempt to service the
	 * second (overwriting) fault, then restart the instruction
	 * (which is from the first fault) and allow the first trap
	 * to reappear. XXX is this right? It will probably change...
	 */
	if ((sfsr & SFSR_FT) == SFSR_FT_NONE)
		goto out;	/* No fault. Why were we called? */

	if ((sfsr & SFSR_AT_STORE)) {
		/* stores are never text faults. */
		ftype = PROT_WRITE;
	} else {
		ftype = PROT_READ;
		if ((sfsr & SFSR_AT_TEXT) || (type == T_TEXTFAULT)) {
			ftype |= PROT_EXEC;
		}
	}

	/*
	 * NOTE: the per-CPU fault status register readers (in locore)
	 * may already have decided to pass `pc' in `sfva', so we avoid
	 * testing CPU types here.
	 * Q: test SFSR_FAV in the locore stubs too?
	 */
	if ((sfsr & SFSR_FAV) == 0) {
		if (type == T_TEXTFAULT)
			sfva = pc;
		else
			goto fault;
	}

	if ((sfsr & SFSR_FT) == SFSR_FT_TRANSERR) {
		/* Translation errors are always fatal, as they indicate
		 * a corrupt translation (page) table hierarchy.
		 */
		if (tfaultaddr == sfva)	/* Prevent infinite loops w/a static */
			goto fault;
		tfaultaddr = sfva;
		if ((lda((sfva & 0xFFFFF000) | ASI_SRMMUFP_LN, ASI_SRMMUFP) &
		    SRMMU_TETYPE) != SRMMU_TEPTE)
			goto fault;	/* Translation bad */
		lda(SRMMU_SFSR, ASI_SRMMU);
		goto out;	/* Translation OK, retry operation */
	}

	va = trunc_page(sfva);

	if (((sfsr & SFSR_AT_TEXT) || type == T_TEXTFAULT) &&
	    !(sfsr & SFSR_AT_STORE) && (sfsr & SFSR_OW)) {
		if (psr & PSR_PS)	/* never allow in kernel */
			goto kfault;
#if 0
		/*
		 * Double text fault. The evil "case 5" from the HS manual...
		 * Attempt to handle early fault. Ignores ASI 8,9 issue...may
		 * do a useless VM read.
		 * XXX: Is this really necessary?
		 */
		if (mmumod == SUN4M_MMU_HS) { /* On HS, we have va for both */
			if (vm_fault(kernel_map, trunc_page(pc),
				     PROT_READ, 0))
#ifdef DEBUG
				printf("mem_access_fault: "
					"can't pagein 1st text fault.\n")
#endif
				;
		}
#endif
	}

	/* Now munch on protections... */

	if (psr & PSR_PS) {
		if (sfsr & SFSR_AT_TEXT || type == T_TEXTFAULT) {
			(void) splhigh();
			printf("text fault: pc=0x%x sfsr=%b sfva=0x%x\n", pc,
			       sfsr, SFSR_BITS, sfva);
			panic("kernel fault");
			/* NOTREACHED */
		}

		/*
		 * During autoconfiguration, faults are never OK unless
		 * pcb_onfault is set.  Once running normally we must allow
		 * exec() to cause copy-on-write faults to kernel addresses.
		 */
		if (cold)
			goto kfault;
		if (va >= vm_min_kernel_address) {
			if (uvm_fault(kernel_map, va, 0, ftype) == 0)
				return;
			goto kfault;
		}
	} else
		p->p_md.md_tf = tf;

	vm = p->p_vmspace;

	/* alas! must call the horrible vm code */
	rv = uvm_fault(&vm->vm_map, (vaddr_t)va, 0, ftype);
	/*
	 * If this was a stack access we keep track of the maximum
	 * accessed stack size.  Also, if vm_fault gets a protection
	 * failure it is due to accessing the stack region outside
	 * the current limit and we need to reflect that as an access
	 * error.
	 */
	if ((caddr_t)va >= vm->vm_maxsaddr) {
		if (rv == 0)
			uvm_grow(p, va);
		else if (rv == EACCES)
			rv = EFAULT;
	}
	if (rv != 0) {
		/*
		 * Pagein failed.  If doing copyin/out, return to onfault
		 * address.  Any other page fault in kernel, die; if user
		 * fault, deliver SIGSEGV.
		 */
fault:
		if (psr & PSR_PS) {
kfault:
			onfault = p->p_addr ?
			    (int)p->p_addr->u_pcb.pcb_onfault : 0;
			if (!onfault) {
				(void) splhigh();
				printf("data fault: pc=0x%x sfva=0x%x sfsr=%b\n",
				       pc, sfva, sfsr, SFSR_BITS);
				panic("kernel fault");
				/* NOTREACHED */
			}
			tf->tf_pc = onfault;
			tf->tf_npc = onfault + 4;
			return;
		}

		sv.sival_int = sfva;
		trapsignal(p, SIGSEGV, ftype, SEGV_MAPERR, sv);
	}
out:
	if ((psr & PSR_PS) == 0) {
		userret(p);
		share_fpu(p, tf);
	}
}
#endif

/*
 * System calls.  `pc' is just a copy of tf->tf_pc.
 *
 * Note that the things labelled `out' registers in the trapframe were the
 * `in' registers within the syscall trap code (because of the automatic
 * `save' effect of each trap).  They are, however, the %o registers of the
 * thing that made the system call, and are named that way here.
 */
void
syscall(code, tf, pc)
	register_t code;
	struct trapframe *tf;
	register_t pc;
{
	int i, nsys, *ap, nap;
	struct sysent *callp;
	struct proc *p;
	int error, new;
	struct args {
		register_t i[8];
	} args __aligned(8);
	register_t rval[2] __aligned(8);
#ifdef DIAGNOSTIC
	extern struct pcb *cpcb;
#endif

	uvmexp.syscalls++;
	p = curproc;
#ifdef DIAGNOSTIC
	if (tf->tf_psr & PSR_PS)
		panic("syscall");
	if (cpcb != &p->p_addr->u_pcb)
		panic("syscall cpcb/ppcb");
	if (tf != (struct trapframe *)((caddr_t)cpcb + USPACE) - 1)
		panic("syscall trapframe");
#endif
	p->p_md.md_tf = tf;
	new = code & SYSCALL_G2RFLAG;
	code &= ~SYSCALL_G2RFLAG;

	callp = p->p_p->ps_emul->e_sysent;
	nsys = p->p_p->ps_emul->e_nsysent;

	/*
	 * The first six system call arguments are in the six %o registers.
	 * Any arguments beyond that are in the `argument extension' area
	 * of the user's stack frame (see <machine/frame.h>).
	 *
	 * Check for ``special'' codes that alter this, namely syscall and
	 * __syscall.  The latter takes a quad syscall number, so that other
	 * arguments are at their natural alignments.  Adjust the number
	 * of ``easy'' arguments as appropriate; we will copy the hard
	 * ones later as needed.
	 */
	ap = &tf->tf_out[0];
	nap = 6;

	switch (code) {
	case SYS_syscall:
		code = *ap++;
		nap--;
		break;
	case SYS___syscall:
		if (callp != sysent)
			break;
		code = ap[_QUAD_LOWWORD];
		ap += 2;
		nap -= 2;
		break;
	}

	if (code < 0 || code >= nsys)
		callp += p->p_p->ps_emul->e_nosys;
	else {
		callp += code;
		i = callp->sy_argsize / sizeof(register_t);
		if (i > nap) {	/* usually false */
			if (i > 8)
				panic("syscall nargs");
			if ((error = copyin((caddr_t)tf->tf_out[6] +
			    offsetof(struct frame, fr_argx),
			    &args.i[nap], (i - nap) * sizeof(register_t))))
				goto bad;
			i = nap;
		}
		copywords(ap, args.i, i * sizeof(register_t));
	}

	rval[0] = 0;
	rval[1] = tf->tf_out[1];

	error = mi_syscall(p, code, callp, args.i, rval);

	switch (error) {
	case 0:
		/* Note: fork() does not return here in the child */
		tf->tf_out[0] = rval[0];
		tf->tf_out[1] = rval[1];
		if (new) {
			/* jmp %g2 on success */
			i = tf->tf_global[2];
			if (i & 3) {
				error = EINVAL;
				goto bad;
			}
		} else {
			/* old system call convention: clear C on success */
			tf->tf_psr &= ~PSR_C;	/* success */
			i = tf->tf_npc;
		}
		tf->tf_pc = i;
		tf->tf_npc = i + 4;
		break;

	case ERESTART:
	case EJUSTRETURN:
		/* nothing to do */
		break;

	default:
	bad:
		tf->tf_out[0] = error;
		tf->tf_psr |= PSR_C;	/* fail */
		i = tf->tf_npc;
		tf->tf_pc = i;
		tf->tf_npc = i + 4;
		break;
	}

	mi_syscall_return(p, code, error, rval);
	share_fpu(p, tf);
}

/*
 * Process the tail end of a fork() for the child.
 */
void
child_return(void *arg)
{
	struct proc *p = arg;
	struct trapframe *tf = p->p_md.md_tf;
	vaddr_t dest;

	/* Duplicate efforts of syscall(), but slightly differently */
	if (tf->tf_global[1] & SYSCALL_G2RFLAG) {
		/* jmp %g2 on success */
		dest = tf->tf_global[2];
	} else {
		/*
		 * old system call convention: clear C on success
		 * note: proc_trampoline() sets a fresh psr when
		 * returning to user mode.
		 */
		dest = tf->tf_npc;
		tf->tf_psr &= ~PSR_C;
	}

	/* Skip trap instruction. */
	tf->tf_pc = dest;
	tf->tf_npc = dest + 4;

	/*
	 * Return values in the frame set by cpu_fork().
	 */
	tf->tf_out[0] = 0;
	tf->tf_out[1] = 0;

	mi_child_return(p);
}
@


1.73
log
@Rename kdb_trap() into db_ktrap().

The goal is to include it in the list of functions that must not be
instrumented.  All ddb(8) functions should be in this list and have
their names start with 'db_'.

ok visa@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.72 2015/11/06 06:33:26 guenther Exp $	*/
@


1.72
log
@Move the logic for adjusting userspace registers in the child after fork
from cpu_fork() to child_return(), putting all the SYSCALL_G2RFLAG logic
in trap.c

sparc testing by sebastia@@ and miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.71 2015/03/27 20:25:39 miod Exp $	*/
d247 1
a247 1
			if (kdb_trap(type, tf)) {
@


1.71
log
@Lower VM_MIN_KERNEL_ADDRESS by 128MB on non-SRMMU systems (sun4/4c/4e) as well,
in order to give these systems a more reasonable amount of kva, yet still
providing .75GB to userland processes.

Although there is no dependency upon a recent boot loader on non-SRMMU systems,
SMALL_KERNEL will nevertheless stick to the legacy kvm layout, for the time
being.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.70 2015/03/18 20:56:40 miod Exp $	*/
d1069 1
a1069 2
child_return(arg)
	void *arg;
d1073 19
a1097 1
	tf->tf_psr &= ~PSR_C;
@


1.70
log
@Rework the virtual memory layout on SRMMU systems (sun4d/sun4m) to use a much
lower VM_MIN_KERNEL_ADDRESS, since these systems are not crippled by the
Sun-4 MMU hole and have the real 4GB of address space.

Kernels running on Sun-4 MMU are not affected and will still be restricted
to the existing 128MB of kernel space, with 1GB - 128MB of user space.

Kernels running on SRMMU will now provide the low 3GB of address space to
userland, and use the top 1GB for the kernel, except when compiled with
option SMALL_KERNEL, in which case they will keep Sun-4 style the layout
(this is temporary to allow for people to boot bsd.rd to upgrade even when
not running 2.10 boot blocks, and will be removed eventually)

A consequence of this is that the top of the userland stack is no longer at
0xf0000000. But since nothing in userland uses USRSTACK anymore, this should
not be an issue.

Tested on sun4c and various sun4m, with physical memory sizes ranging from 32
to 448MB.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.69 2014/11/16 12:30:59 deraadt Exp $	*/
d636 1
a636 1
		if (va >= VM_MIN_KERNEL_ADDRESS_OLD) {
@


1.69
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.68 2014/05/11 00:12:44 guenther Exp $	*/
d636 1
a636 1
		if (va >= VM_MIN_KERNEL_ADDRESS) {
d873 1
a873 1
		if (va >= VM_MIN_KERNEL_ADDRESS) {
@


1.68
log
@Move the increment of uvmexp.softs back to the caller of mi_ast():
it needs to be done atomicly on some MP archs and we don't have
atomic_add_int() everywhere yet.  Also, mi_ast() was meant to be inline.

noted by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.67 2014/05/10 05:33:00 guenther Exp $	*/
d607 1
a607 1
	ftype = ser & SER_WRITE ? VM_PROT_WRITE : VM_PROT_READ;
d651 1
a651 1
			ser & SER_WRITE ? VM_PROT_WRITE : VM_PROT_READ);
d680 1
a680 1
		(void) mmu_pagein(vm->vm_map.pmap, va, VM_PROT_NONE);
d705 2
a706 2
		trapsignal(p, SIGSEGV, (ser & SER_WRITE) ? VM_PROT_WRITE :
		    VM_PROT_READ, SEGV_MAPERR, sv);
d795 1
a795 1
		ftype = VM_PROT_WRITE;
d797 1
a797 1
		ftype = VM_PROT_READ;
d799 1
a799 1
			ftype |= VM_PROT_EXECUTE;
d845 1
a845 1
				     VM_PROT_READ, 0))
@


1.67
log
@Factor out the common ast bits into mi_ast()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.66 2014/04/30 04:20:31 miod Exp $	*/
d304 1
@


1.66
log
@Enforce proper alignment of stack variables which may get accessed with
double-word load and store instructions. This used to work by chance, but
recent compiler changes no longer put us in the lucky situation.

tweaks kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.65 2014/04/18 11:51:17 guenther Exp $	*/
d304 1
a304 5
		if (p->p_flag & P_OWEUPC) {
			ADDUPROF(p);
		}
		if (want_resched)
			preempt(NULL);
@


1.65
log
@Have each thread keeps its own (counted!) reference to the process's ucreds
to avoid possible use-after-free references when swapping ids in threaded
processes.  "Do I have the right creds?" checks are always made with the
threads creds.

Inspired by FreeBSD and NetBSD
"right time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.64 2014/03/26 05:23:42 guenther Exp $	*/
d955 2
a956 2
	} args;
	register_t rval[2];
@


1.64
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.63 2013/06/03 18:46:02 kettenis Exp $	*/
d282 1
@


1.63
log
@Get rid of SYSCALL_G7RFLAG.  It's been deprecated for a long time already,
and we've started using %g7 as a per-thread register now.  If you have any
binaries left that use this flag they'll probably crash and burn!

tested by & ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.62 2012/12/31 06:46:14 guenther Exp $	*/
d974 2
a975 2
	callp = p->p_emul->e_sysent;
	nsys = p->p_emul->e_nsysent;
d1006 1
a1006 1
		callp += p->p_emul->e_nosys;
@


1.62
log
@Remove emulation errno mapping code from platforms that no longer have
non-native emulations.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.61 2012/08/08 04:46:25 miod Exp $	*/
d971 2
a972 2
	new = code & (SYSCALL_G7RFLAG | SYSCALL_G2RFLAG);
	code &= ~(SYSCALL_G7RFLAG | SYSCALL_G2RFLAG);
d1033 2
a1034 2
			/* jmp %g2 (or %g7, deprecated) on success */
			i = tf->tf_global[new & SYSCALL_G2RFLAG ? 2 : 7];
@


1.61
log
@Do not depend upon an initialized variable in the common case; gives init(8)
a chance to run...
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.60 2012/08/07 05:16:54 guenther Exp $	*/
a1054 2
		if (p->p_emul->e_errno)
			error = p->p_emul->e_errno[error];
@


1.60
log
@Move the common bits of syscall invocation and return handling into
an MI file, <sys/syscall_mi.h>, correcting inconsistencies and the
handling when copyin() of arguments fails.

Tested on i386, amd64, sparc64, and alpha (thanks naddy@@)
Any issues with other platforms will be fixed in tree.

header name from millert@@; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.59 2012/04/11 14:38:55 mikeb Exp $	*/
d1019 1
a1019 2
		if (error == 0)
			copywords(ap, args.i, i * sizeof(register_t));
@


1.59
log
@The first ktrace record for a newly spawned thread is a return
from a fork syscall done by the parent.  Use __tfork, not rfork
here to match the ktrace records for the parent (CALL __tfork,
RET __tfork).  ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.58 2011/11/16 20:50:19 deraadt Exp $	*/
d63 1
a64 6
#ifdef KTRACE
#include <sys/ktrace.h>
#endif

#include "systrace.h"
#include <dev/systrace.h>
d1013 1
a1013 1
			error = copyin((caddr_t)tf->tf_out[6] +
d1015 1
a1015 7
			    (caddr_t)&args.i[nap], (i - nap) * sizeof(register_t));
			if (error) {
#ifdef KTRACE
				if (KTRPOINT(p, KTR_SYSCALL))
					ktrsyscall(p, code,
					    callp->sy_argsize, args.i);
#endif
a1016 1
			}
d1019 2
a1020 1
		copywords(ap, args.i, i * sizeof(register_t));
d1022 1
a1022 4
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSCALL))
		ktrsyscall(p, code, callp->sy_argsize, args.i);
#endif
d1025 2
a1026 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, &args, rval);
	else
#endif
		error = (*callp->sy_call)(p, &args, rval);
d1066 1
a1066 5
	userret(p);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, code, error, rval[0]);
#endif
d1087 1
a1087 8
	userret(p);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p,
		    (p->p_flag & P_THREAD) ? SYS___tfork :
		    (p->p_p->ps_flags & PS_PPWAIT) ? SYS_vfork : SYS_fork,
		    0, 0);
#endif
@


1.58
log
@Make userret() MI.  On architectures which jammed stuff into it in the
past, pull that code out seperately.
ok guenther miod
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.57 2011/07/04 22:53:53 tedu Exp $	*/
d1113 1
a1113 1
		    (p->p_flag & P_THREAD) ? SYS_rfork :
@


1.57
log
@remove compat_svr4 support.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.56 2011/04/03 14:56:28 guenther Exp $	*/
a198 1
static __inline void userret(struct proc *);
a207 15
/*
 * Define the code needed before returning to user mode, for
 * trap, mem_access_fault, and syscall.
 */
static __inline void
userret(struct proc *p)
{
	int sig;

	/* take pending signals */
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);

	p->p_cpu->ci_schedstate.spc_curpriority = p->p_priority = p->p_usrpri;
}
@


1.56
log
@Move PPWAIT flag from struct proc to process, so that rthreads in
a vforked child behave correctly.  Have the parent in a vfork()
wait on a (different) flag in *its* process instead of the child
to prevent a possible use-after-free.  When ktracing the child
return from a fork, call it rfork if an rthread was created.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.55 2010/11/27 19:41:48 miod Exp $	*/
a84 3
#ifdef COMPAT_SVR4
#include <machine/svr4_machdep.h>
#endif
a314 3
#if defined(COMPAT_SVR4)
badtrap:
#endif
a320 13

#ifdef COMPAT_SVR4
	case T_SVR4_GETCC:
	case T_SVR4_SETCC:
	case T_SVR4_GETPSR:
	case T_SVR4_SETPSR:
	case T_SVR4_GETHRTIME:
	case T_SVR4_GETHRVTIME:
	case T_SVR4_GETHRESTIME:
		if (!svr4_trap(type, p))
			goto badtrap;
		break;
#endif
@


1.55
log
@Misaligned load/store recovery code in the kernel, enabled by T_FIXALIGN
userland traps on a per-process basis, were necessary for *some* SunOS
binaries on sparc, which had to compiled with explicit misaligned access code
generation (i.e. for vendors to release a working SunOS/sparc version of their
code until they could fix their bogus code).

There is no reason to keep this code on sparc64, and now that we don't provide
COMPAT_SUNOS anymore, there is no reason to keep this code on sparc.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.54 2010/07/10 19:32:25 miod Exp $	*/
d1148 3
a1150 1
		    (p->p_flag & P_PPWAIT) ? SYS_vfork : SYS_fork, 0, 0);
@


1.54
log
@sun4e (i.e. SPARCengine 1e) support. This platform is a mix between sun4 and
sun4c, as it has a sun4c OpenPROM but a sun4 8KB pagesize. VME devices are
not supported yet.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.53 2008/01/06 21:15:58 miod Exp $	*/
a463 5
		if ((p->p_md.md_flags & MDP_FIXALIGN) != 0 && 
		    fixalign(p, tf) == 0) {
			ADVANCE;
			break;
		}
a527 1
#ifdef DEBUG_ALIGN
a528 3
#endif
		/* User wants us to fix alignment faults */
		p->p_md.md_flags |= MDP_FIXALIGN;
d530 1
@


1.53
log
@Enclose some SUN4-specific code within preprocessor directives, this lets SUN4C
kernel compile again.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.52 2007/05/08 07:23:18 art Exp $	*/
d631 1
a631 1
#if defined(SUN4) || defined(SUN4C)
d763 1
a763 1
#endif /* Sun4/Sun4C */
@


1.52
log
@Switch sparc to __HAVE_CPUINFO.

miod@@ tested (since I hacked it up blindly) and ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.51 2007/03/15 10:22:30 art Exp $	*/
d660 1
d662 1
d670 1
d677 1
@


1.51
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.50 2006/12/24 20:30:35 miod Exp $	*/
d225 1
a225 1
	curpriority = p->p_priority = p->p_usrpri;
@


1.50
log
@Define PROC_PC. Then, since profiling information is being reported in
statclock(), do not bother doing this in userret() anymore. As a result,
userret() does not need its pc and ticks arguments, simplify.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.49 2006/12/24 20:29:19 miod Exp $	*/
a343 1
			p->p_flag &= ~P_OWEUPC;
@


1.49
log
@Check for want_resched when processing AST and nowhere else. But then, when
doing so, do not check for signals - userret() will do this.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.48 2006/06/09 06:41:44 miod Exp $	*/
d202 1
a202 1
static __inline void userret(struct proc *, int,  u_quad_t);
d217 1
a217 4
userret(p, pc, oticks)
	struct proc *p;
	int pc;
	u_quad_t oticks;
a223 25
	p->p_priority = p->p_usrpri;
	if (want_ast) {
		want_ast = 0;
		if (p->p_flag & P_OWEUPC) {
			p->p_flag &= ~P_OWEUPC;
			ADDUPROF(p);
		}
	}
	if (want_resched) {
		/*
		 * We're being preempted.
		 */
		preempt(NULL);
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
	}

	/*
	 * If profiling, charge recent system time to the trapped pc.
	 */
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, pc, (int)(p->p_sticks - oticks) * psratio);
	}
d225 1
a225 1
	curpriority = p->p_priority;
a254 1
	u_quad_t sticks;
a303 1
	sticks = p->p_sticks;
d548 1
a548 1
	userret(p, pc, sticks);
a638 1
	u_quad_t sticks;
a643 1
	sticks = p->p_sticks;
d757 1
a757 1
		userret(p, pc, sticks);
a784 1
	u_quad_t sticks;
a789 1
	sticks = p->p_sticks;
d973 1
a973 1
		userret(p, pc, sticks);
a1000 1
	u_quad_t sticks;
a1014 1
	sticks = p->p_sticks;
d1124 1
a1124 1
	userret(p, pc, sticks);
d1149 1
a1149 1
	userret(p, tf->tf_pc, 0);
@


1.48
log
@{x,}ldcontrolb() codepath is SUN4-only, so don't bother checking for Lfsbail
in mem_access_fault4m.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.47 2006/01/30 21:26:19 miod Exp $	*/
d372 8
a379 1
		break;	/* the work is all in userret() */
@


1.47
log
@When delivering SIGFOO, make sure the siginfo code is a FOO_xxx constant;
also deliver SIGILL/ILL_COPROC rather than SIGFPE/FPE_FLTINV for disabled
or missing floating point support.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.46 2005/12/25 00:22:47 miod Exp $	*/
a931 1
		extern char Lfsbail[];
a938 6
		/*
		 * If this was an access that we shouldn't try to page in,
		 * resume at the fault handler without any action.
		 */
		if (p->p_addr && p->p_addr->u_pcb.pcb_onfault == Lfsbail)
			goto kfault;
@


1.46
log
@Ensure child_return() leaves registers the same way a successfull system
call would.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.45 2005/09/15 21:09:29 miod Exp $	*/
d523 1
a523 1
		trapsignal(p, SIGILL, 0, FPE_FLTINV, sv);
@


1.45
log
@Change child_return() to record a proper ktrace record for vfork child
processes.

ok art@@ uwe@@ (some time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.44 2005/04/21 04:39:35 mickey Exp $	*/
d1176 1
d1181 5
a1185 1
	userret(p, p->p_md.md_tf->tf_pc, 0);
@


1.44
log
@count fpu lazy context switches; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.43 2005/04/17 18:47:51 miod Exp $	*/
d1184 1
a1184 1
			  (p->p_flag & P_PPWAIT) ? SYS_vfork : SYS_fork, 0, 0);
@


1.43
log
@Do not use KERNBASE when VM_MIN_KERNEL_ADDRESS or VM_MAXUSER_ADDRESS are
implied; this currently does not change anything (yet).

Also, define the I/O space range in <machine/vmparam.h> rather than in
<sparc/sparc/vaddrs.h>.

ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.42 2004/12/06 20:12:25 miod Exp $	*/
d420 1
@


1.42
log
@Use uvm_grow() to account for stack growth, rather than home-grown code
or nothing.
Inspired by a similar recent change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.41 2004/08/06 22:39:14 deraadt Exp $	*/
d707 1
a707 1
		if (va >= KERNBASE) {
d953 1
a953 1
		if (va >= KERNBASE) {
@


1.41
log
@rename sparc kill_user_windows() to pmap_unuse_final().  provide empty stubs
on all other architectures.  remove last architecture dependent #ifdef from
uvm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.40 2003/05/12 04:42:58 jason Exp $	*/
d739 3
a741 5
		if (rv == 0) {
			unsigned nss = btoc(USRSTACK - va);
			if (nss > vm->vm_ssize)
				vm->vm_ssize = nss;
		} else if (rv == EACCES)
d973 3
a975 5
		if (rv == 0) {
			unsigned nss = btoc(USRSTACK - va);
			if (nss > vm->vm_ssize)
				vm->vm_ssize = nss;
		} else if (rv == EACCES)
@


1.40
log
@add a few more trap types
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.39 2002/07/24 00:55:52 art Exp $	*/
d627 1
a627 1
kill_user_windows(p)
@


1.39
log
@Support for non-exec mappings on sun4m.

 - support exec traps and deal with them correctly.
 - Instead of pretending that the pte permissions are a bit-mask, just
   make two stupid 8-entry tables (one for kernel, one for userland) that
   provides translation between VM_PROT* masks and pte permissions.

This gives sun4m a non-exec stack.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.38 2002/05/16 21:11:18 miod Exp $	*/
d133 2
a134 1
	T, T, T, T, T, T,	/* 0b..10 */
d160 2
a161 1
	T, T, T, T,		/* 2c..2f */
d163 3
a165 1
	T, T, T, T, T, T, T, T,	/* 38..3f */
@


1.38
log
@Add systrace support to all the remaining architectures.

Tested by various people on various platforms, I'm willing to fix any
breakage this causes.

ok niels@@ deraadt@@ and mickey@@ (after his comments were applied)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.37 2002/03/26 01:00:30 miod Exp $	*/
d864 9
a872 1
	ftype = sfsr & SFSR_AT_STORE ? VM_PROT_WRITE : VM_PROT_READ;
@


1.37
log
@Honor psratio for addupc_task(), as other arches do.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.36 2002/03/14 01:26:44 millert Exp $	*/
d68 3
d1106 6
a1111 1
	error = (*callp->sy_call)(p, &args, rval);
@


1.36
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.35 2001/11/28 13:47:39 art Exp $	*/
d240 5
a244 2
	if (p->p_flag & P_PROFIL)
		addupc_task(p, pc, (int)(p->p_sticks - oticks));
@


1.35
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.34 2001/11/06 21:33:53 mickey Exp $	*/
d195 6
a200 6
static __inline void userret __P((struct proc *, int,  u_quad_t));
void trap __P((unsigned, int, int, struct trapframe *));
static __inline void share_fpu __P((struct proc *, struct trapframe *));
void mem_access_fault __P((unsigned, int, u_int, int, int, struct trapframe *));
void mem_access_fault4m __P((unsigned, u_int, u_int, struct trapframe *));
void syscall __P((register_t, struct trapframe *, register_t));
@


1.35.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.35 2001/11/28 13:47:39 art Exp $	*/
a67 3
#include "systrace.h"
#include <dev/systrace.h>

d195 6
a200 6
static __inline void userret(struct proc *, int,  u_quad_t);
void trap(unsigned, int, int, struct trapframe *);
static __inline void share_fpu(struct proc *, struct trapframe *);
void mem_access_fault(unsigned, int, u_int, int, int, struct trapframe *);
void mem_access_fault4m(unsigned, u_int, u_int, struct trapframe *);
void syscall(register_t, struct trapframe *, register_t);
d240 2
a241 5
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, pc, (int)(p->p_sticks - oticks) * psratio);
	}
d1100 1
a1100 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, &args, rval);
	else
#endif
		error = (*callp->sy_call)(p, &args, rval);
@


1.35.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.35.2.1 2002/06/11 03:38:17 art Exp $	*/
d864 1
a864 9
	if ((sfsr & SFSR_AT_STORE)) {
		/* stores are never text faults. */
		ftype = VM_PROT_WRITE;
	} else {
		ftype = VM_PROT_READ;
		if ((sfsr & SFSR_AT_TEXT) || (type == T_TEXTFAULT)) {
			ftype |= VM_PROT_EXECUTE;
		}
	}
@


1.35.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d133 1
a133 2
	"watchpoint",		/* 0b */
	T, T, T, T, T,		/* 0c..10 */
d159 1
a159 2
	"v8 data access MMU miss",/* 2c */
	T, T, T,		/* 2d..2f */
d161 1
a161 3
	T, T, T, T,		/* 38..3b */
	"v8 insn access MMU miss",/* 3c */
	T, T, T,	/* 3d..3f */
@


1.34
log
@child_return unscrewart
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.33 2001/11/06 19:53:16 miod Exp $	*/
d698 1
a698 1
			if (uvm_fault(kernel_map, va, 0, ftype) == KERN_SUCCESS)
d729 1
a729 1
		if (rv == KERN_SUCCESS) {
d733 2
a734 2
		} else if (rv == KERN_PROTECTION_FAILURE)
			rv = KERN_INVALID_ADDRESS;
d736 1
a736 1
	if (rv == KERN_SUCCESS) {
d902 1
a902 1
				     VM_PROT_READ, 0) != KERN_SUCCESS)
d938 1
a938 1
			if (uvm_fault(kernel_map, va, 0, ftype) == KERN_SUCCESS)
d957 1
a957 1
		if (rv == KERN_SUCCESS) {
d961 2
a962 2
		} else if (rv == KERN_PROTECTION_FAILURE)
			rv = KERN_INVALID_ADDRESS;
d964 1
a964 1
	if (rv != KERN_SUCCESS) {
@


1.33
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.32 2001/09/19 20:50:57 mickey Exp $	*/
d1152 2
a1153 2
child_return(p)
	struct proc *p;
d1155 1
@


1.32
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31 2001/09/14 09:39:53 art Exp $	*/
a67 1
#include <vm/vm.h>
@


1.31
log
@Simplify userret.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.30 2001/06/25 00:43:17 mickey Exp $	*/
d69 1
a69 1
#include <vm/vm_kern.h>
@


1.30
log
@cold is in systm now
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.29 2001/05/10 10:34:49 art Exp $	*/
d216 1
a216 1
	int sig, s;
d231 1
a231 6
		 * Since we are curproc, clock will normally just change
		 * our priority without moving us from one queue to another
		 * (since the running process is not on a queue.)
		 * If that happened after we put ourselves on the run queue
		 * but before we switched, we might not be on the queue
		 * indicated by our priority.
d233 1
a233 5
		s = splstatclock();
		setrunqueue(p);
		p->p_stats->p_ru.ru_nivcsw++;
		mi_switch();
		splx(s);
@


1.29
log
@UVM is no longer optional on sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.28 2001/05/05 20:56:53 art Exp $	*/
a89 2

extern int cold;
@


1.28
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.27 2001/04/06 04:42:06 csapuntz Exp $	*/
a292 1
#if defined(UVM)
a293 3
#else
	cnt.v_trap++;
#endif
a665 1
#if defined(UVM)
a666 3
#else
	cnt.v_trap++;
#endif
a709 1
#if defined(UVM)
a711 4
#else
			if (vm_fault(kernel_map, va, ftype, 0) == KERN_SUCCESS)
				return;
#endif
a730 1
#if defined(UVM)
a731 3
#else
	rv = vm_fault(&vm->vm_map, (vaddr_t)va, ftype, FALSE);
#endif
a815 1
#if defined(UVM)
a816 3
#else
	cnt.v_trap++;
#endif
a949 1
#if defined(UVM)
a951 4
#else
			if (vm_fault(kernel_map, va, ftype, 0) == KERN_SUCCESS)
				return;
#endif
a959 1
#if defined(UVM)
a960 3
#else
	rv = vm_fault(&vm->vm_map, (vaddr_t)va, ftype, FALSE);
#endif
a1036 1
#if defined(UVM)
a1037 3
#else
	cnt.v_syscall++;
#endif
@


1.27
log
@

Move offsetof define into sys/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.26 2000/11/10 18:15:42 art Exp $	*/
d759 1
a759 1
			unsigned nss = clrnd(btoc(USRSTACK - va));
d1000 1
a1000 1
			unsigned nss = clrnd(btoc(USRSTACK - va));
@


1.26
log
@Change the ktrace interface functions from taking the trace vnode to taking the
traced proc. The vnode is in the proc and all functions need the proc.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.25 2000/07/04 10:52:28 art Exp $	*/
a89 2

#define	offsetof(s, f) ((int)&((s *)0)->f)
@


1.25
log
@Cleaner spl handling in userret.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.24 2000/06/08 22:25:22 niklas Exp $	*/
d1133 1
a1133 1
					ktrsyscall(p->p_tracep, code,
d1144 1
a1144 1
		ktrsyscall(p->p_tracep, code, callp->sy_argsize, args.i);
d1191 1
a1191 1
		ktrsysret(p->p_tracep, code, error, rval[0]);
d1210 1
a1210 1
		ktrsysret(p->p_tracep,
@


1.24
log
@Add explicit inclusions of signalvar.h to files actually using syms defined
there but relying on an indirect inclusion
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.24 2000/06/08 21:12:07 niklas Exp $	*/
d220 1
a220 1
	int sig;
d242 1
a242 1
		(void) splstatclock();
d246 1
a246 1
		(void) spl0();
@


1.23
log
@move fpproc into the cpuinfo structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.22 2000/02/21 17:08:37 art Exp $	*/
d55 1
@


1.22
log
@The last pieces of hypersparc support.
 - Split get_faultstatus into get_syncflt and get_asyncflt.
 - Get the syncflt status before setting up the trap frame and put the
   results in cpuinfo.syncfltdump (related to the next change).
 - unlock the sfsr/sfva after reading from ASI_SRMMUFP (it gets locked if
   the translation fails).
 - + other interface changes and cleanups.
 (most work from NetBSD).
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.21 2000/01/31 16:06:59 art Exp $	*/
d269 1
a269 1
	if ((tf->tf_psr & PSR_EF) != 0 && fpproc != p)
d422 3
a424 3
		if (fpproc != p) {		/* we do not have it */
			if (fpproc != NULL)	/* someone else had it */
				savefpstate(fpproc->p_md.md_fpstate);
d426 1
a426 1
			fpproc = p;		/* now we do have it */
d511 1
a511 1
		if (p != fpproc)
d514 1
a514 1
		fpproc = NULL;
@


1.21
log
@Clean up memerr*. (from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20 2000/01/27 20:14:11 art Exp $	*/
d203 1
a203 1
void mem_access_fault4m __P((unsigned, u_int, u_int, u_int, u_int, struct trapframe *));
d818 1
a818 1
mem_access_fault4m(type, sfsr, sfva, afsr, afva, tf)
a821 2
	u_int afsr;
	u_int afva;
d858 1
a858 1
	if ((afsr & AFSR_AFO) != 0 || type == T_STOREBUFFAULT ||
d860 1
a860 1
		(*cpuinfo.memerr)(type, sfsr, sfva, afsr, afva, tf);
d917 2
a918 1
		else goto out;	/* Translation OK, retry operation */
d1020 1
a1020 1
				printf("data fault: pc=0x%x addr=0x%x sfsr=%b\n",
@


1.21.2.1
log
@sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23 2000/02/21 21:05:59 art Exp $	*/
d203 1
a203 1
void mem_access_fault4m __P((unsigned, u_int, u_int, struct trapframe *));
d269 1
a269 1
	if ((tf->tf_psr & PSR_EF) != 0 && cpuinfo.fpproc != p)
d422 3
a424 3
		if (cpuinfo.fpproc != p) {	/* we do not have it */
			if (cpuinfo.fpproc != NULL) /* someone else had it */
				savefpstate(cpuinfo.fpproc->p_md.md_fpstate);
d426 1
a426 1
			cpuinfo.fpproc = p;	/* now we do have it */
d511 1
a511 1
		if (p != cpuinfo.fpproc)
d514 1
a514 1
		cpuinfo.fpproc = NULL;
d818 1
a818 1
mem_access_fault4m(type, sfsr, sfva, tf)
d822 2
d860 1
a860 1
	if (type == T_STOREBUFFAULT ||
d862 1
a862 1
		(*cpuinfo.memerr)(type, sfsr, sfva, tf);
d919 1
a919 2
		lda(SRMMU_SFSR, ASI_SRMMU);
		goto out;	/* Translation OK, retry operation */
d1021 1
a1021 1
				printf("data fault: pc=0x%x sfva=0x%x sfsr=%b\n",
@


1.21.2.2
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.27 2001/04/06 04:42:06 csapuntz Exp $	*/
a54 1
#include <sys/signalvar.h>
d90 2
d219 1
a219 1
	int sig, s;
d241 1
a241 1
		s = splstatclock();
d245 1
a245 1
		splx(s);
d1132 1
a1132 1
					ktrsyscall(p, code,
d1143 1
a1143 1
		ktrsyscall(p, code, callp->sy_argsize, args.i);
d1190 1
a1190 1
		ktrsysret(p, code, error, rval[0]);
d1209 1
a1209 1
		ktrsysret(p,
@


1.21.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.21.2.2 2001/05/14 21:37:19 niklas Exp $	*/
d91 2
d293 1
d295 3
d670 1
d672 3
d718 1
d721 4
d744 1
d746 3
d759 1
a759 1
			unsigned nss = btoc(USRSTACK - va);
d833 1
d835 3
d971 1
d974 4
d986 1
d988 3
d1000 1
a1000 1
			unsigned nss = btoc(USRSTACK - va);
d1067 1
d1069 3
@


1.21.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.21.2.3 2001/07/04 10:23:48 niklas Exp $	*/
d69 1
a69 1
#include <uvm/uvm_extern.h>
d216 1
a216 1
	int sig;
d231 6
a236 1
		 * We're being preempted.
d238 5
a242 1
		preempt(NULL);
@


1.21.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d68 1
d1153 2
a1154 2
child_return(arg)
	void *arg;
a1155 1
	struct proc *p = arg;
@


1.21.2.6
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.21.2.5 2001/11/13 21:04:17 niklas Exp $	*/
d698 1
a698 1
			if (uvm_fault(kernel_map, va, 0, ftype) == 0)
d729 1
a729 1
		if (rv == 0) {
d733 2
a734 2
		} else if (rv == EACCES)
			rv = EFAULT;
d736 1
a736 1
	if (rv == 0) {
d902 1
a902 1
				     VM_PROT_READ, 0))
d938 1
a938 1
			if (uvm_fault(kernel_map, va, 0, ftype) == 0)
d957 1
a957 1
		if (rv == 0) {
d961 2
a962 2
		} else if (rv == EACCES)
			rv = EFAULT;
d964 1
a964 1
	if (rv != 0) {
@


1.21.2.7
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d195 6
a200 6
static __inline void userret(struct proc *, int,  u_quad_t);
void trap(unsigned, int, int, struct trapframe *);
static __inline void share_fpu(struct proc *, struct trapframe *);
void mem_access_fault(unsigned, int, u_int, int, int, struct trapframe *);
void mem_access_fault4m(unsigned, u_int, u_int, struct trapframe *);
void syscall(register_t, struct trapframe *, register_t);
@


1.21.2.8
log
@Sync the SMP branch with 3.3
@
text
@a67 3
#include "systrace.h"
#include <dev/systrace.h>

d240 2
a241 5
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, pc, (int)(p->p_sticks - oticks) * psratio);
	}
d858 1
a858 9
	if ((sfsr & SFSR_AT_STORE)) {
		/* stores are never text faults. */
		ftype = VM_PROT_WRITE;
	} else {
		ftype = VM_PROT_READ;
		if ((sfsr & SFSR_AT_TEXT) || (type == T_TEXTFAULT)) {
			ftype |= VM_PROT_EXECUTE;
		}
	}
d1100 1
a1100 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, &args, rval);
	else
#endif
		error = (*callp->sy_call)(p, &args, rval);
@


1.21.2.9
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.21.2.8 2003/03/27 23:49:26 niklas Exp $	*/
d133 1
a133 2
	"watchpoint",		/* 0b */
	T, T, T, T, T,		/* 0c..10 */
d159 1
a159 2
	"v8 data access MMU miss",/* 2c */
	T, T, T,		/* 2d..2f */
d161 1
a161 3
	T, T, T, T,		/* 38..3b */
	"v8 insn access MMU miss",/* 3c */
	T, T, T,	/* 3d..3f */
@


1.20
log
@reduce global symbol pollution
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19 1999/08/17 16:09:21 art Exp $	*/
d862 1
a862 1
		memerr4m(type, sfsr, sfva, afsr, afva, tf);
@


1.19
log
@mem_access_fault4m: init ftype earlier to avoid passing junk to trapsignal
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.18 1999/07/09 21:30:03 art Exp $	*/
d208 1
@


1.18
log
@vm_offset_t -> {v,p}addr_t and vm_size_t -> {v,p}size_t
remove "register" keywords
Various cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17 1999/06/17 18:17:10 art Exp $	*/
d893 2
a947 1
	ftype = sfsr & SFSR_AT_STORE ? VM_PROT_WRITE : VM_PROT_READ;
@


1.17
log
@fix continuing from breakpoints on sparc
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16 1999/04/22 19:02:49 art Exp $	*/
d278 3
a280 3
	register unsigned type;
	register int psr, pc;
	register struct trapframe *tf;
d282 3
a284 3
	register struct proc *p;
	register struct pcb *pcb;
	register int n;
d286 1
a286 1
	register union sigval sv;
d393 1
a393 1
		register struct fpstate *fs = p->p_md.md_fpstate;
d592 1
a592 1
	register struct proc *p;
d594 3
a596 3
	register struct pcb *pcb = &p->p_addr->u_pcb;
	register struct rwindow *rw = &pcb->pcb_rw[0];
	register int i;
d654 5
a658 5
	register unsigned type;
	register int ser;
	register u_int v;
	register int pc, psr;
	register struct trapframe *tf;
d661 4
a664 4
	register struct proc *p;
	register struct vmspace *vm;
	register vm_offset_t va;
	register int rv;
d747 1
a747 1
	rv = vm_fault(&vm->vm_map, (vm_offset_t)va, ftype, FALSE);
d818 6
a823 6
	register unsigned type;
	register u_int sfsr;
	register u_int sfva;
	register u_int afsr;
	register u_int afva;
	register struct trapframe *tf;
d825 5
a829 5
	register int pc, psr;
	register struct proc *p;
	register struct vmspace *vm;
	register vm_offset_t va;
	register int rv;
d989 1
a989 1
	rv = vm_fault(&vm->vm_map, (vm_offset_t)va, ftype, FALSE);
d1051 1
a1051 1
	register struct trapframe *tf;
d1054 3
a1056 3
	register int i, nsys, *ap, nap;
	register struct sysent *callp;
	register struct proc *p;
@


1.16
log
@UVM stuff. vm_fault -> uvm_fault
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.15 1999/04/22 18:43:53 art Exp $	*/
a306 1
				ADVANCE;
@


1.15
log
@UVM fixes, cnt -> uvmexp
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.14 1998/05/11 05:42:31 deraadt Exp $	*/
d719 4
d725 1
d745 3
d749 1
d972 4
d978 1
d987 3
d991 1
a991 1

@


1.14
log
@do not convert write faults into vm system read+write faults
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.13 1998/03/01 10:14:13 johns Exp $	*/
d293 3
d297 1
d671 3
d675 1
d827 3
d831 1
d1051 3
d1055 1
@


1.13
log
@Fixes required for gcc 2.8, trapsignal() takes a union sigval as its
fifth parameter, gcc 2.8 will not allow us to pass in an integer anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.12 1997/09/17 06:47:22 downsj Exp $	*/
d685 1
a685 1
	ftype = ser & SER_WRITE ? VM_PROT_READ|VM_PROT_WRITE : VM_PROT_READ;
d814 1
a814 1
	vm_prot_t ftype, vftype;
d926 1
a926 2
	ftype = sfsr & SFSR_AT_STORE ? VM_PROT_READ|VM_PROT_WRITE:VM_PROT_READ;
	vftype = sfsr & SFSR_AT_STORE ? VM_PROT_WRITE:VM_PROT_READ;
d1002 1
a1002 1
		trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR, sv);
@


1.12
log
@NETBSD_CURRENT_970916.  Lot's just ID changes, since changes don't apply to
us.  Includes some pmap changes, for which I don't have the original commit
message(s) handy.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11 1997/08/08 08:27:46 downsj Exp $	*/
d286 3
d348 1
a348 1
			trapsignal(p, SIGILL, type, ILL_ILLOPC, (caddr_t)pc);
d358 1
a358 1
		trapsignal(p, SIGILL, type, ILL_ILLOPC, (caddr_t)pc);
d382 1
a382 1
		trapsignal(p, SIGILL, 0, ILL_ILLOPC, (caddr_t)pc);
d386 1
a386 1
		trapsignal(p, SIGILL, 0, ILL_PRVOPC, (caddr_t)pc);
d405 1
a405 1
			trapsignal(p, SIGFPE, 0, FPE_FLTINV, (caddr_t)pc);
d495 1
a495 1
		trapsignal(p, SIGBUS, 0, BUS_ADRALN, (caddr_t)pc);
d520 1
a520 1
		trapsignal(p, SIGEMT, 0, EMT_TAGOVF, (caddr_t)pc);
d525 1
a525 1
		trapsignal(p, SIGILL, 0, FPE_FLTINV, (caddr_t)pc);
d529 1
a529 1
		trapsignal(p, SIGTRAP, 0, TRAP_BRKPT, (caddr_t)pc);
d535 1
a535 1
		trapsignal(p, SIGFPE, 0, FPE_INTDIV, (caddr_t)pc);
d555 1
a555 1
		trapsignal(p, SIGILL, 0, ILL_ILLOPN, (caddr_t)pc);
d570 1
a570 1
		trapsignal(p, SIGFPE, FPE_INTOVF_TRAP, FPE_INTOVF, (caddr_t)pc);
d665 1
d779 2
d782 1
a782 1
		    VM_PROT_READ, SEGV_MAPERR, (caddr_t)v);
d817 1
d1001 3
a1003 1
		trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR, (caddr_t)sfva);
@


1.11
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: trap.c,v 1.57 1997/07/29 09:42:15 fair Exp $ */
d1107 3
a1109 1
	if (error == 0) {
d1127 9
a1135 2
	} else if (error > 0 /*error != ERESTART && error != EJUSTRETURN*/) {
bad:
d1143 1
a1144 2
	/* else if (error == ERESTART || error == EJUSTRETURN) */
		/* nothing to do */
@


1.10
log
@gestures in the direction of TurboSpPARC compatibility
@
text
@d1 2
a2 1
/*	$NetBSD: trap.c,v 1.42.4.2 1996/07/03 00:06:40 jtc Exp $ */
d88 1
d206 2
d325 5
a329 1
		goto dopanic;
a339 5
#if defined(SUN4M)
		if (type == 0x29)
			/* Mysterious trap 29.. for now print&signal process */
			goto badtrap;
#endif
d341 3
a343 2
dopanic:
			printf("trap type 0x%x: pc=%x npc=%x psr=%b\n",
d345 2
a346 2
			panic(type < N_TRAP_TYPES ? trap_type[type] : T);
			/* NOTREACHED */
d348 1
a348 1
#if defined(COMPAT_SVR4) || defined(SUN4M)
d354 1
a354 1
		    p->p_comm, p->p_pid, type);
d375 4
d446 1
a446 1
			printf("%s[%d]: rwindow: pcb<-stack: %x\n",
d468 1
a468 1
			printf("%s[%d]: rwindow: T_WINUF 0: pcb<-stack: %x\n",
d476 1
a476 1
			printf("%s[%d]: rwindow: T_WINUF 1: pcb<-stack: %x\n",
d487 5
d530 1
d556 5
a560 1
		uprintf("T_FIXALIGN\n");	/* XXX */
d606 1
a606 1
			printf(" %x", rw[1].rw_in[6]);
d687 2
a688 2
			printf("text fault: pc=%x ser=%b\n", pc,
				ser, SER_BITS);
d720 1
a720 1
	rv = mmu_pagein(&vm->vm_pmap, va,
d752 1
a752 1
		(void) mmu_pagein(&vm->vm_pmap, va, VM_PROT_NONE);
d766 2
a767 2
				printf("data fault: pc=%x addr=%x ser=%b\n",
					pc, v, ser, SER_BITS);
a810 3
#if DEBUG
static int lastdouble;
#endif
d837 1
a837 1
		 * trap to reoccur
d867 4
a870 5
	 * This next section is a mess since some chips use sfva, and others
	 * don't on text faults. We want to use sfva where possible, since
	 * we _could_ be dealing with an ASI 0x8,0x9 data access to text space,
	 * which would trap as a text fault, at least on a HyperSPARC. Ugh.
	 * XXX: Find out about MicroSPARCs.
d872 1
a872 14

	if (type == T_TEXTFAULT && mmumod == SUN4M_MMU_SS &&
	    (cpumod & 0xf0) == (SUN4M_SS) && (sfsr & SFSR_FAV)) {
		sfva = pc;	/* can't trust fav on supersparc/text fault */
	} else if (type == T_TEXTFAULT && mmumod != SUN4M_MMU_HS) {
		sfva = pc;
	} else if (!(sfsr & SFSR_FAV)) {
#ifdef DEBUG
		if (type != T_TEXTFAULT)
		    printf("mem_access_fault: got fault without valid SFVA\n");
		if (mmumod == SUN4M_MMU_HS)
		    printf("mem_access_fault: got fault without valid SFVA on "
			   "HyperSPARC!\n");
#endif
d881 1
a881 1
		 * a corrupt translation (page) table heirarchy.
a893 12
#ifdef DEBUG
	if (lastdouble) {
		printf("stacked tfault @@ %x (pc %x); sfsr %x", sfva, pc, sfsr);
		lastdouble = 0;
		if (curproc == NULL)
			printf("NULL proc\n");
		else
			printf("pid %d(%s); sigmask %x, sigcatch %x\n",
				curproc->p_pid, curproc->p_comm,
				curproc->p_sigmask, curproc->p_sigcatch);
	}
#endif
d898 1
a904 13
#ifdef DEBUG
		if (dfdebug) {
			lastdouble = 1;
			printf("mem_access_fault: double text fault @@ %x (pc %x); sfsr %x",
				sfva, pc, sfsr);
			if (curproc == NULL)
				printf("NULL proc\n");
			else
				printf(" pid %d(%s); sigmask %x, sigcatch %x\n",
					curproc->p_pid, curproc->p_comm,
					curproc->p_sigmask, curproc->p_sigcatch);
		}
#endif
d914 1
d925 1
a925 1
			printf("text fault: pc=%x sfsr=%b sfva=%x\n", pc,
a952 15
#ifdef DEBUG
	/*
	 * mmu_pagein returns -1 if the page is already valid, in which
	 * case we have a hard fault.. now why would *that* happen?
	 * But it happens sporadically, and vm_fault() seems to clear it..
	 */
	rv = mmu_pagein4m(&vm->vm_pmap, va,
			sfsr & SFSR_AT_STORE ? VM_PROT_WRITE : VM_PROT_READ);
	if (rv < 0)
		printf(" sfsr=%x(FT=%x,AT=%x,LVL=%x), sfva=%x, pc=%x, psr=%x\n",
		       sfsr, (sfsr >> 2) & 7, (sfsr >> 5) & 7, (sfsr >> 8) & 3,
		       sfva, pc, psr);
	if (rv > 0)
		panic("mmu_pagein4m returns %d", rv);
#endif
d985 2
a986 2
				printf("data fault: pc=%x addr=%x sfsr=%b\n",
				    pc, sfva, sfsr, SFSR_BITS);
@


1.9
log
@do not accidentally pass VM_PROT_WRITE|VM_PROT_READ
@
text
@d112 5
d148 12
a159 5
	T, T, T, T, T, T, T, T,	/* 20..27 */
	T, T, T, T, T, T, T, T,	/* 28..2f */
	T, T, T, T, T, T,	/* 30..35 */
	"cp disabled",		/* 36 */
	T,			/* 37 */
d161 1
a161 2
	"cp exception",		/* 40 */
	T, T, T, T, T, T, T,	/* 41..47 */
@


1.8
log
@pass VM_PROT_READ/VM_PROT_WRITE as si_trapno for SIGSEGV
@
text
@d779 1
a779 1
	vm_prot_t ftype;
d931 1
d1020 1
a1020 1
		trapsignal(p, SIGSEGV, ftype, SEGV_MAPERR, (caddr_t)sfva);
@


1.7
log
@fix a fpe trapsignal to provide proper type
@
text
@d746 2
a747 1
		trapsignal(p, SIGSEGV, (u_int)v, SEGV_MAPERR, (caddr_t)v);
d1019 1
a1019 1
		trapsignal(p, SIGSEGV, (u_int)sfva, SEGV_MAPERR, (caddr_t)sfva);
@


1.6
log
@trapsignal/sendsig type/sigval changes
@
text
@d507 1
a507 1
		trapsignal(p, SIGFPE, 0, FPE_INTDIV_TRAP, (caddr_t)pc);
@


1.5
log
@add another parameter to trapsignal() and sendsig() -- fault addr to be
delivered with in the siginfo information
@
text
@d340 1
a340 1
		trapsignal(p, SIGILL, type, (caddr_t)pc);
d360 1
a360 1
		trapsignal(p, SIGILL, 0, (caddr_t)pc);	/* XXX code?? */
d364 1
a364 1
		trapsignal(p, SIGILL, 0, (caddr_t)pc);	/* XXX code?? */
d383 1
a383 1
			trapsignal(p, SIGFPE, 0, (caddr_t)pc);	/* XXX code?? */
d468 1
a468 1
		trapsignal(p, SIGBUS, 0, (caddr_t)pc);	/* XXX code?? */
d493 1
a493 1
		trapsignal(p, SIGEMT, 0, (caddr_t)pc);	/* XXX code?? */
d498 1
a498 1
		trapsignal(p, SIGILL, 0, (caddr_t)pc);	/* XXX code?? */
d502 1
a502 1
		trapsignal(p, SIGTRAP, 0, (caddr_t)pc);
d507 1
a507 1
		trapsignal(p, SIGFPE, FPE_INTDIV_TRAP, (caddr_t)pc);
d527 1
a527 1
		trapsignal(p, SIGILL, 0, (caddr_t)pc);	/* XXX code?? */
d538 1
a538 1
		trapsignal(p, SIGFPE, FPE_INTOVF_TRAP, (caddr_t)pc);
d746 1
a746 1
		trapsignal(p, SIGSEGV, (u_int)v, (caddr_t)v);
d1018 1
a1018 1
		trapsignal(p, SIGSEGV, (u_int)sfva, (caddr_t)sfva);
@


1.4
log
@netbsd port, now we merge our changes back in
@
text
@d340 1
a340 1
		trapsignal(p, SIGILL, type);
d360 1
a360 1
		trapsignal(p, SIGILL, 0);	/* XXX code?? */
d364 1
a364 1
		trapsignal(p, SIGILL, 0);	/* XXX code?? */
d383 1
a383 1
			trapsignal(p, SIGFPE, 0);	/* XXX code?? */
d468 1
a468 1
		trapsignal(p, SIGBUS, 0);	/* XXX code?? */
d493 1
a493 1
		trapsignal(p, SIGEMT, 0);	/* XXX code?? */
d498 1
a498 1
		trapsignal(p, SIGILL, 0);	/* XXX code?? */
d502 1
a502 1
		trapsignal(p, SIGTRAP, 0);
d507 1
a507 1
		trapsignal(p, SIGFPE, FPE_INTDIV_TRAP);
d527 1
a527 1
		trapsignal(p, SIGILL, 0);	/* XXX code?? */
d538 1
a538 1
		trapsignal(p, SIGFPE, FPE_INTOVF_TRAP);
d746 1
a746 1
		trapsignal(p, SIGSEGV, (u_int)v);
d1018 1
a1018 1
		trapsignal(p, SIGSEGV, (u_int)sfva);
@


1.3
log
@The sun mmu is very broken, and we all can thank crashme for
helping me find this bug.  On execution of an atomic load/store instruction
the chip will only say that a read fault is happening, we then load up a
readonly translation to the accessed page, and we get the fault again still
showing a read-fault.  We end up faulting in a loop forever and the process
appears to be completely stuck.  The algorithm to fix this problem goes like
this.  If we get a non-text fault, and the fault type is VM_PROT_READ, and
the SER_PROT bit is set in the syncronous fault error register, we take
a peek at the instruction at pc.  If this instruction is indeed an ldstub
or a swap variant we or in VM_PROT_WRITE to the fault type.
@
text
@d1 1
a1 1
/*	$NetBSD: trap.c,v 1.33 1995/07/04 22:57:35 christos Exp $ */
d4 2
d17 1
d31 1
d66 1
d69 1
d72 7
d80 7
a86 1
#include <machine/trap.h>
d92 1
d94 1
d186 7
d197 5
a201 2
static inline void
userret(struct proc *p, int pc, u_quad_t oticks)
d249 4
a252 1
static inline void share_fpu(struct proc *p, struct trapframe *tf) {
d261 1
d290 11
d321 5
d329 1
a329 1
			    type, pc, tf->tf_npc, psr, PSR_BITS);
d333 1
d335 1
a422 1
#ifdef DIAGNOSTIC
d425 1
d428 2
a429 2
			    p->p_comm, p->p_pid, tf->tf_out[6]);
#endif /* DIAGNOSTIC */
a431 1
#ifdef DIAGNOSTIC
a433 1
#endif /* DIAGNOSTIC */
d447 1
a447 1
#ifdef DIAGNOSTIC
d450 2
a451 2
			    p->p_comm, p->p_pid, tf->tf_out[6]);
#endif /* DIAGNOSTIC */
d455 1
a455 1
#ifdef DIAGNOSTIC
d458 2
a459 2
			    p->p_comm, p->p_pid, pcb->pcb_rw[0].rw_in[6]);
#endif /* DIAGNOSTIC */
a461 1
#ifdef DIAGNOSTIC
a463 1
#endif /* DIAGNOSTIC */
d570 2
a571 2
#ifdef DIAGNOSTIC
	if(rwindow_debug)
d573 1
a573 1
#endif /* DIAGNOSTIC */
d575 2
a576 2
#ifdef DIAGNOSTIC
		if(rwindow_debug)
d578 1
a578 1
#endif /* DIAGNOSTIC */
d584 2
a585 2
#ifdef DIAGNOSTIC
	if(rwindow_debug)
d587 1
a587 1
#endif /* DIAGNOSTIC */
d597 1
d617 1
d625 1
d631 1
a631 1
	int onfault, mmucode;
a652 16
	if(ftype == VM_PROT_READ && (ser & SER_PROT) && type != T_TEXTFAULT) {
		/* If this is an ldstub or swap instruction
		 * then we are about to fault in a loop forever
		 * as only the read part of the fault will be
		 * reported by the mmu.
		 */
		int error, insn;

		error = copyin((caddr_t) pc, &insn, sizeof(int));
		if(!error) {
			insn = (insn >> 16); /* high word */
			insn &= 0xc168;
			if(insn == 0xc068)
				ftype |= VM_PROT_WRITE;
		}
	}
d658 2
a659 1
			printf("text fault: pc=%x ser=%b\n", pc, ser, SER_BITS);
d691 2
a692 1
	rv = mmu_pagein(&vm->vm_pmap, va, ftype);
d738 1
a738 1
				    pc, v, ser, SER_BITS);
d753 272
d1026 1
d1036 1
d1038 1
a1038 1
	register_t code, pc;
d1040 1
d1051 1
d1053 1
d1101 1
a1101 1
	if (code < 0 || code >= nsys) 
d1132 1
a1132 12
		/*
		 * If fork succeeded and we are the child, our stack
		 * has moved and the pointer tf is no longer valid,
		 * and p is wrong.  Compute the new trapframe pointer.
		 * (The trap frame invariably resides at the
		 * tippity-top of the u. area.)
		 */
		p = curproc;
		tf = (struct trapframe *)
		    ((caddr_t)p->p_addr + USPACE - sizeof(*tf));
/* this is done earlier: */
/*		p->p_md.md_tf = tf; */
d1168 19
@


1.2
log
@#ifdef DIAGNOSTIC messages; mmu_pagein call speedup
@
text
@d601 16
@


1.1
log
@Initial revision
@
text
@d370 7
a376 3
if (pcb->pcb_uw || pcb->pcb_nsaved) panic("trap T_RWRET 1");
if (rwindow_debug)
printf("%s[%d]: rwindow: pcb<-stack: %x\n", p->p_comm, p->p_pid, tf->tf_out[6]);
d379 4
a382 1
if (pcb->pcb_nsaved) panic("trap T_RWRET 2");
d396 5
a400 3
if (rwindow_debug)
printf("%s[%d]: rwindow: T_WINUF 0: pcb<-stack: %x\n",
p->p_comm, p->p_pid, tf->tf_out[6]);
d404 5
a408 3
if (rwindow_debug)
printf("%s[%d]: rwindow: T_WINUF 1: pcb<-stack: %x\n",
p->p_comm, p->p_pid, pcb->pcb_rw[0].rw_in[6]);
d411 4
a414 1
if (pcb->pcb_nsaved) panic("trap T_WINUF");
d521 4
a524 2
if(rwindow_debug)
printf("%s[%d]: rwindow: pcb->stack:", p->p_comm, p->p_pid);
d526 4
a529 2
if(rwindow_debug)
printf(" %x", rw[1].rw_in[6]);
d535 4
a538 2
if(rwindow_debug)
printf("\n");
d638 1
a638 2
	rv = mmu_pagein(&vm->vm_pmap, va,
			ser & SER_WRITE ? VM_PROT_WRITE : VM_PROT_READ);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

