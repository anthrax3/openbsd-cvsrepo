head	1.52;
access;
symbols
	OPENBSD_6_0:1.51.0.4
	OPENBSD_6_0_BASE:1.51
	OPENBSD_5_9:1.51.0.2
	OPENBSD_5_9_BASE:1.51
	OPENBSD_5_8:1.50.0.8
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.50.0.2
	OPENBSD_5_7_BASE:1.50
	OPENBSD_5_6:1.50.0.4
	OPENBSD_5_6_BASE:1.50
	OPENBSD_5_5:1.49.0.8
	OPENBSD_5_5_BASE:1.49
	OPENBSD_5_4:1.49.0.4
	OPENBSD_5_4_BASE:1.49
	OPENBSD_5_3:1.49.0.2
	OPENBSD_5_3_BASE:1.49
	OPENBSD_5_2:1.48.0.8
	OPENBSD_5_2_BASE:1.48
	OPENBSD_5_1_BASE:1.48
	OPENBSD_5_1:1.48.0.6
	OPENBSD_5_0:1.48.0.4
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.48.0.2
	OPENBSD_4_9_BASE:1.48
	OPENBSD_4_8:1.47.0.2
	OPENBSD_4_8_BASE:1.47
	OPENBSD_4_7:1.44.0.6
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.44.0.8
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.44.0.4
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.44.0.2
	OPENBSD_4_4_BASE:1.44
	OPENBSD_4_3:1.43.0.4
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.43.0.2
	OPENBSD_4_2_BASE:1.43
	OPENBSD_4_1:1.41.0.8
	OPENBSD_4_1_BASE:1.41
	OPENBSD_4_0:1.41.0.6
	OPENBSD_4_0_BASE:1.41
	OPENBSD_3_9:1.41.0.4
	OPENBSD_3_9_BASE:1.41
	OPENBSD_3_8:1.41.0.2
	OPENBSD_3_8_BASE:1.41
	OPENBSD_3_7:1.39.0.8
	OPENBSD_3_7_BASE:1.39
	OPENBSD_3_6:1.39.0.6
	OPENBSD_3_6_BASE:1.39
	SMP_SYNC_A:1.39
	SMP_SYNC_B:1.39
	OPENBSD_3_5:1.39.0.4
	OPENBSD_3_5_BASE:1.39
	OPENBSD_3_4:1.39.0.2
	OPENBSD_3_4_BASE:1.39
	UBC_SYNC_A:1.39
	OPENBSD_3_3:1.38.0.2
	OPENBSD_3_3_BASE:1.38
	OPENBSD_3_2:1.37.0.4
	OPENBSD_3_2_BASE:1.37
	OPENBSD_3_1:1.37.0.2
	OPENBSD_3_1_BASE:1.37
	UBC_SYNC_B:1.37
	UBC:1.35.0.2
	UBC_BASE:1.35
	OPENBSD_3_0:1.32.0.4
	OPENBSD_3_0_BASE:1.32
	OPENBSD_2_9_BASE:1.32
	OPENBSD_2_9:1.32.0.2
	OPENBSD_2_8:1.31.0.4
	OPENBSD_2_8_BASE:1.31
	OPENBSD_2_7:1.31.0.2
	OPENBSD_2_7_BASE:1.31
	SMP:1.22.0.2
	SMP_BASE:1.22
	kame_19991208:1.18
	OPENBSD_2_6:1.18.0.2
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.17.0.2
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.16.0.2
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.14.0.2
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.6.0.4
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.52
date	2016.09.01.09.23.42;	author tedu;	state dead;
branches;
next	1.51;
commitid	Q2PxaFNhqAe0Wmla;

1.51
date	2015.12.10.19.48.04;	author mmcc;	state Exp;
branches;
next	1.50;
commitid	IegoPc6ss7aut6L1;

1.50
date	2014.04.30.04.20.31;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2012.11.25.13.34.17;	author jsg;	state Exp;
branches;
next	1.48;

1.48
date	2010.11.11.17.58.23;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2010.07.10.19.32.24;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2010.06.07.19.54.33;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2010.06.07.19.44.54;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2008.06.29.01.27.42;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.10.18.06.01;	author art;	state Exp;
branches;
next	1.42;

1.42
date	2007.05.08.07.23.18;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2005.08.06.14.26.52;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2005.04.19.21.30.20;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2003.05.10.21.11.14;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2002.11.22.23.08.49;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2001.12.19.08.58.05;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2001.12.07.10.44.52;	author art;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2001.12.05.14.40.48;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2000.11.22.16.01.37;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2000.02.23.16.43.41;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2000.02.21.21.05.59;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2000.02.21.17.08.36;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2000.02.21.14.58.17;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2000.02.21.14.57.04;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2000.02.21.14.56.04;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2000.02.19.22.04.23;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2000.02.19.21.45.56;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2000.02.18.18.57.14;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2000.01.31.16.06.58;	author art;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2000.01.27.20.14.11;	author art;	state Exp;
branches;
next	1.20;

1.20
date	99.12.09.21.35.29;	author art;	state Exp;
branches;
next	1.19;

1.19
date	99.12.08.23.49.07;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	99.07.14.23.15.49;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	99.03.03.21.58.28;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	98.10.09.13.12.43;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	98.10.09.13.10.46;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	98.04.17.18.18.04;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.03.09.09.15.32;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.02.26.10.39.01;	author johns;	state Exp;
branches;
next	1.11;

1.11
date	98.02.26.08.00.17;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	97.11.11.10.43.57;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.09.17.06.47.16;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	97.09.11.20.31.33;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.08.08.08.27.10;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.08.12.00.52.05;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.11.05.35.07;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.10.23.08.56.02;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.10.23.06.10.29;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.19.02.54.48;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.46;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.46;	author deraadt;	state Exp;
branches;
next	;

1.22.2.1
date	2000.02.20.11.56.51;	author niklas;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2000.02.21.22.29.02;	author niklas;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2000.03.02.07.04.33;	author niklas;	state Exp;
branches;
next	1.22.2.4;

1.22.2.4
date	2001.05.14.21.37.15;	author niklas;	state Exp;
branches;
next	1.22.2.5;

1.22.2.5
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.22.2.6;

1.22.2.6
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.22.2.7;

1.22.2.7
date	2003.03.27.23.49.26;	author niklas;	state Exp;
branches;
next	1.22.2.8;

1.22.2.8
date	2003.05.13.19.41.08;	author ho;	state Exp;
branches;
next	;

1.35.2.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.52
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: cpu.c,v 1.51 2015/12/10 19:48:04 mmcc Exp $	*/
/*	$NetBSD: cpu.c,v 1.56 1997/09/15 20:52:36 pk Exp $ */

/*
 * Copyright (c) 1996
 *	The President and Fellows of Harvard College. All rights reserved.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by Harvard University.
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Aaron Brown and
 *	Harvard University.
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)cpu.c	8.5 (Berkeley) 11/23/93
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/reg.h>
#include <machine/ctlreg.h>
#include <machine/trap.h>
#include <machine/pmap.h>

#include <machine/oldmon.h>
#include <machine/idprom.h>

#include <sparc/sparc/cache.h>
#include <sparc/sparc/asm.h>
#include <sparc/sparc/cpuvar.h>
#include <sparc/sparc/memreg.h>

/* The following are used externally (sysctl_hw). */
char	machine[] = MACHINE;		/* from <machine/param.h> */
char	*cpu_class = "sun4";
char	cpu_model[130];
char	cpu_hotfix[40];
extern char mainbus_model[];		/* from autoconf.c */

int	foundfpu;			/* from machine/cpu.h */

/* The CPU configuration driver. */
void cpu_attach(struct device *, struct device *, void *);
int  cpu_match(struct device *, void *, void *);

struct cfattach cpu_ca = {
	sizeof(struct cpu_softc), cpu_match, cpu_attach
};

struct cfdriver cpu_cd = {
	NULL, "cpu", DV_CPU
};

char *fsrtoname(int, int, int, char *, size_t);
void cache_print(struct cpu_softc *);
void cpu_spinup(struct cpu_softc *);
void fpu_init(struct cpu_softc *);
void replacemul(void);

#define	IU_IMPL(psr)	((u_int)(psr) >> 28)
#define	IU_VERS(psr)	(((psr) >> 24) & 0xf)

#define SRMMU_IMPL(mmusr)	((u_int)(mmusr) >> 28)
#define SRMMU_VERS(mmusr)	(((mmusr) >> 24) & 0xf)


#ifdef notdef
/*
 * IU implementations are parceled out to vendors (with some slight
 * glitches).  Printing these is cute but takes too much space.
 */
static char *iu_vendor[16] = {
	"Fujitsu",	/* and also LSI Logic */
	"ROSS",		/* ROSS (ex-Cypress) */
	"BIT",
	"LSIL",		/* LSI Logic finally got their own */
	"TI",		/* Texas Instruments */
	"Matsushita",
	"Philips",
	"Harvest",	/* Harvest VLSI Design Center */
	"SPEC",		/* Systems and Processes Engineering Corporation */
	"Weitek",
	"vendor#10",
	"vendor#11",
	"vendor#12",
	"vendor#13",
	"vendor#14",
	"vendor#15"
};
#endif

int
cpu_match(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	register struct cfdata *cf = vcf;
	register struct confargs *ca = aux;

	return (strcmp(cf->cf_driver->cd_name, ca->ca_ra.ra_name) == 0);
}

/*
 * Attach the CPU.
 * Discover interesting goop about the virtual address cache
 * (slightly funny place to do it, but this is where it is to be found).
 */
void
cpu_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct cpu_softc *sc = (struct cpu_softc *)self;
	register int node;
	register char *fpuname;
	struct confargs *ca = aux;
	char fpbuf[40];
	char model[100];

	sc->node = node = ca->ca_ra.ra_node;

	/*
	 * First, find out if we're attaching the boot CPU.
	 */
	if (node == 0)
		sc->master = 1;
	else {
		sc->mid = getpropint(node, "mid", 0);
		if (sc->mid == 0 || sc->mid == getmid() + 8 /*XXX*/)
			sc->master = 1;
	}

	if (sc->master) {
		/*
		 * Gross, but some things in cpuinfo may already have
		 * been setup by early routines like pmap_bootstrap().
		 */
		bcopy(&sc->dv, &cpuinfo, sizeof(sc->dv));
		bcopy(&cpuinfo, sc, sizeof(cpuinfo));
	}

#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	switch (cputyp) {
#if defined(SUN4C)
	case CPU_SUN4C:
		cpu_class = "sun4c";
		break;
#endif /* defined(SUN4C) */
#if defined(SUN4D)
	case CPU_SUN4D:
		cpu_class = "sun4d";
		break;
#endif /* defined(SUN4D) */
#if defined(SUN4E)
	case CPU_SUN4E:
		cpu_class = "sun4e";
		break;
#endif /* defined(SUN4E) */
#if defined(SUN4M)
	case CPU_SUN4M:
		cpu_class = "sun4m";
		break;
#endif /* defined(SUN4M) */
	}
#endif /* SUN4C || SUN4D || SUN4E || SUN4M */

	getcpuinfo(sc, node);

	fpuname = "no";
	if (sc->master) {
		if (sc->hotfix)
			sc->hotfix(sc);

		fpu_init(sc);
		if (foundfpu)
			fpuname = fsrtoname(sc->cpu_impl, sc->cpu_vers,
			    sc->fpuvers, fpbuf, sizeof fpbuf);
	}
	/* XXX - multi-processor: take care of `cpu_model' and `foundfpu' */

	snprintf(model, sizeof model, "%s @@ %s MHz, %s FPU", sc->cpu_name,
	    clockfreq(sc->hz), fpuname);
	printf(": %s", model);
	snprintf(cpu_model, sizeof cpu_model, "%s, %s", mainbus_model, model);

	if (cpu_hotfix[0])
		printf("; %s", cpu_hotfix);
	printf("\n");

	if (sc->cacheinfo.c_totalsize != 0)
		cache_print(sc);

	sc->ci.ci_softc = sc;

	if (sc->master) {
		int s;

		bcopy(sc, &cpuinfo, sizeof(cpuinfo));
		/*
		 * Enable the cache
		 *
		 * Disable all interrupts because we don't want anything
		 * nasty to happen to the pagetables while the cache is
		 * enabled and we haven't uncached them yet.
		 */
		if (sc->cacheinfo.c_totalsize != 0) {
			s = splhigh();
			sc->cache_enable();
			pmap_cache_enable();
			splx(s);
		}
		return;
	}

	/* Now start this CPU */
}

#if 0
void
cpu_(sc)
	struct cpu_softc *sc;
{
	if (sc->hotfix)
		sc->hotfix(sc);

	/* Initialize FPU */
	fpu_init(sc);

	/* Enable the cache */
	sc->cache_enable();
}
#endif

void
cpu_spinup(sc)
	struct cpu_softc *sc;
{
#if 0
	pmap_cpusetup();
#endif
}

void
fpu_init(sc)
	struct cpu_softc *sc;
{
	struct fpstate fpstate __aligned(8);

	/*
	 * Get the FSR and clear any exceptions.  If we do not unload
	 * the queue here and it is left over from a previous crash, we
	 * will panic in the first loadfpstate(), due to a sequence
	 * error, so we need to dump the whole state anyway.
	 *
	 * If there is no FPU, trap.c will advance over all the stores,
	 * so we initialize fs_fsr here.
	 */

	/* 7 is reserved for "none" */
	fpstate.fs_fsr = 7 << FSR_VER_SHIFT;
	savefpstate(&fpstate);
	sc->fpuvers =
	    (fpstate.fs_fsr >> FSR_VER_SHIFT) & (FSR_VER >> FSR_VER_SHIFT);

	if (sc->fpuvers != 7)
		foundfpu = 1;
}

void
cache_print(sc)
	struct cpu_softc *sc;
{
	struct cacheinfo *ci = &sc->cacheinfo;
	char *sep = "";

	printf("%s: ", sc->dv.dv_xname);

	if (ci->c_split) {
		printf("%s", (ci->c_physical ? "physical " : ""));
		if (ci->ic_totalsize > 0) {
			printf("%s%dK instruction (%d b/l)", sep,
			    ci->ic_totalsize/1024, ci->ic_linesize);
			sep = ", ";
		}
		if (ci->dc_totalsize > 0) {
			printf("%s%dK data (%d b/l)", sep,
			    ci->dc_totalsize/1024, ci->dc_linesize);
			sep = ", ";
		}
	} else if (ci->c_physical) {
		/* combined, physical */
		printf("physical %dK combined cache (%d bytes/line)",
		    ci->c_totalsize/1024, ci->c_linesize);
		sep = ", ";
	} else {
		/* combined, virtual */
		printf("%dK byte write-%s, %d bytes/line, %cw flush",
		    ci->c_totalsize/1024,
		    (ci->c_vactype == VAC_WRITETHROUGH) ? "through" : "back",
		    ci->c_linesize, ci->c_hwflush ? 'h' : 's');
		sep = ", ";
	}

	if (ci->ec_totalsize > 0) {
		printf("%s%dK external (%d b/l)", sep,
		    ci->ec_totalsize/1024, ci->ec_linesize);
	}
	if (sep)	/* printed at least one field.. */
		printf(" ");
}


/*------------*/


void cpumatch_unknown(struct cpu_softc *, struct module_info *, int);
void cpumatch_sun4(struct cpu_softc *, struct module_info *, int);
void cpumatch_sun4c(struct cpu_softc *, struct module_info *, int);
void cpumatch_ms(struct cpu_softc *, struct module_info *, int);
void cpumatch_viking(struct cpu_softc *, struct module_info *, int);
void cpumatch_hypersparc(struct cpu_softc *, struct module_info *, int);
void cpumatch_turbosparc(struct cpu_softc *, struct module_info *, int);
void cpumatch_kap(struct cpu_softc *, struct module_info *, int);

void getcacheinfo_sun4(struct cpu_softc *, int node);
void getcacheinfo_sun4c(struct cpu_softc *, int node);
void getcacheinfo_obp(struct cpu_softc *, int node);
void getcacheinfo_kap(struct cpu_softc *, int node);

void sun4_hotfix(struct cpu_softc *);
void viking_hotfix(struct cpu_softc *);
void turbosparc_hotfix(struct cpu_softc *);
void swift_hotfix(struct cpu_softc *);

void ms1_mmu_enable(void);
void viking_mmu_enable(void);
void swift_mmu_enable(void);
void hypersparc_mmu_enable(void);

void srmmu_get_syncflt(void);
void ms1_get_syncflt(void);
void viking_get_syncflt(void);
void swift_get_syncflt(void);
void turbosparc_get_syncflt(void);
void hypersparc_get_syncflt(void);
void cypress_get_syncflt(void);

int srmmu_get_asyncflt(u_int *, u_int *);
int hypersparc_get_asyncflt(u_int *, u_int *);
int cypress_get_asyncflt(u_int *, u_int *);
int no_asyncflt_regs(u_int *, u_int *);

struct module_info module_unknown = {
	CPUTYP_UNKNOWN,
	VAC_UNKNOWN,
	cpumatch_unknown
};


void
cpumatch_unknown(sc, mp, node)
	struct cpu_softc *sc;
	struct module_info *mp;
	int	node;
{
	panic("Unknown CPU type: "
	      "cpu: impl %d, vers %d; mmu: impl %d, vers %d",
		sc->cpu_impl, sc->cpu_vers,
		sc->mmu_impl, sc->mmu_vers);
}

#if defined(SUN4)
struct module_info module_sun4 = {
	CPUTYP_UNKNOWN,
	VAC_WRITETHROUGH,
	cpumatch_sun4,
	getcacheinfo_sun4,
	sun4_hotfix,
	0,
	sun4_cache_enable,
	0,			/* ncontext set in `match' function */
	0,			/* get_syncflt(); unused in sun4 */
	0,			/* get_asyncflt(); unused in sun4 */
	sun4_cache_flush,
	sun4_vcache_flush_page,
	sun4_vcache_flush_segment,
	sun4_vcache_flush_region,
	sun4_vcache_flush_context,
	noop_pcache_flush_line,
	noop_pure_vcache_flush,
	noop_cache_flush_all,
	0
};

void
getcacheinfo_sun4(sc, node)
	struct cpu_softc *sc;
	int	node;
{
	struct cacheinfo *ci = &sc->cacheinfo;

	switch (sc->cpu_type) {
	case CPUTYP_4_100:
		ci->c_vactype = VAC_NONE;
		ci->c_totalsize = 0;
		ci->c_hwflush = 0;
		ci->c_linesize = 0;
		ci->c_l2linesize = 0;
		ci->c_split = 0;
		ci->c_nlines = 0;

		/* Override cache flush functions */
		sc->cache_flush = noop_cache_flush;
		sc->vcache_flush_page = noop_vcache_flush_page;
		sc->vcache_flush_segment = noop_vcache_flush_segment;
		sc->vcache_flush_region = noop_vcache_flush_region;
		sc->vcache_flush_context = noop_vcache_flush_context;
		break;
	case CPUTYP_4_200:
		ci->c_vactype = VAC_WRITEBACK;
		ci->c_totalsize = 128*1024;
		ci->c_hwflush = 0;
		ci->c_linesize = 16;
		ci->c_l2linesize = 4;
		ci->c_split = 0;
		ci->c_nlines = ci->c_totalsize << ci->c_l2linesize;
		break;
	case CPUTYP_4_300:
		ci->c_vactype = VAC_WRITEBACK;
		ci->c_totalsize = 128*1024;
		ci->c_hwflush = 0;
		ci->c_linesize = 16;
		ci->c_l2linesize = 4;
		ci->c_split = 0;
		ci->c_nlines = ci->c_totalsize << ci->c_l2linesize;
		sc->flags |= CPUFLG_SUN4CACHEBUG;
		break;
	case CPUTYP_4_400:
		ci->c_vactype = VAC_WRITEBACK;
		ci->c_totalsize = 128 * 1024;
		ci->c_hwflush = 0;
		ci->c_linesize = 32;
		ci->c_l2linesize = 5;
		ci->c_split = 0;
		ci->c_nlines = ci->c_totalsize << ci->c_l2linesize;
		break;
	}
}

struct	idprom idprom;
void	getidprom(struct idprom *, int size);

void
cpumatch_sun4(sc, mp, node)
	struct cpu_softc *sc;
	struct module_info *mp;
	int	node;
{

	getidprom(&idprom, sizeof(idprom));
	switch (idprom.id_machine) {
	/* XXX: don't know about Sun4 types */
	case ID_SUN4_100:
		sc->cpu_type = CPUTYP_4_100;
		sc->classlvl = 100;
		sc->mmu_ncontext = 8;
		sc->mmu_nsegment = 256;
/*XXX*/		sc->hz = 14280000;
		break;
	case ID_SUN4_200:
		sc->cpu_type = CPUTYP_4_200;
		sc->classlvl = 200;
		sc->mmu_nsegment = 512;
		sc->mmu_ncontext = 16;
/*XXX*/		sc->hz = 16670000;
		break;
	case ID_SUN4_300:
		sc->cpu_type = CPUTYP_4_300;
		sc->classlvl = 300;
		sc->mmu_nsegment = 256;
		sc->mmu_ncontext = 16;
/*XXX*/		sc->hz = 25000000;
		break;
	case ID_SUN4_400:
		sc->cpu_type = CPUTYP_4_400;
		sc->classlvl = 400;
		sc->mmu_nsegment = 1024;
		sc->mmu_ncontext = 64;
		sc->mmu_nregion = 256;
/*XXX*/		sc->hz = 33000000;
		sc->sun4_mmu3l = 1;
		break;
	}

}
#endif /* SUN4 */

#if defined(SUN4C) || defined(SUN4E)
struct module_info module_sun4c = {
	CPUTYP_UNKNOWN,
	VAC_WRITETHROUGH,
	cpumatch_sun4c,
	getcacheinfo_sun4c,
	sun4_hotfix,
	0,
	sun4_cache_enable,
	0,			/* ncontext set in `match' function */
	0,			/* get_syncflt(); unused in sun4c */
	0,			/* get_asyncflt(); unused in sun4c */
	sun4_cache_flush,
	sun4_vcache_flush_page,
	sun4_vcache_flush_segment,
	sun4_vcache_flush_region,
	sun4_vcache_flush_context,
	noop_pcache_flush_line,
	noop_pure_vcache_flush,
	noop_cache_flush_all,
	0
};

void
cpumatch_sun4c(sc, mp, node)
	struct cpu_softc *sc;
	struct module_info *mp;
	int	node;
{
	int	rnode;

	rnode = findroot();
	sc->mmu_npmeg = sc->mmu_nsegment =
		getpropint(rnode, "mmu-npmg", CPU_ISSUN4E ? 256 : 128);
	sc->mmu_ncontext = getpropint(rnode, "mmu-nctx", 8);
                              
	/* Get clock frequency */ 
	sc->hz = getpropint(rnode, "clock-frequency", 0);
}

void
getcacheinfo_sun4c(sc, node)
	struct cpu_softc *sc;
	int node;
{
	struct cacheinfo *ci = &sc->cacheinfo;
	int i, l;

	if (node == 0)
		/* Bootstrapping */
		return;

	/* Sun4c's have only virtually-addressed caches */
	ci->c_physical = 0; 
	ci->c_totalsize = getpropint(node, "vac-size", 65536);
	/*
	 * Note: vac-hwflush is spelled with an underscore
	 * on the 4/75s.
	 */
	ci->c_hwflush =
		getpropint(node, "vac_hwflush", 0) |
		getpropint(node, "vac-hwflush", 0);

	ci->c_linesize = l = getpropint(node, "vac-linesize", 16);
	for (i = 0; (1 << i) < l; i++)
		/* void */;
	if ((1 << i) != l)
		panic("bad cache line size %d", l);
	ci->c_l2linesize = i;
	ci->c_associativity = 1;
	ci->c_nlines = ci->c_totalsize << i;

	ci->c_vactype = VAC_WRITETHROUGH;

	/*
	 * Machines with "buserr-type" 1 have a bug in the cache
	 * chip that affects traps.  (I wish I knew more about this
	 * mysterious buserr-type variable....)
	 */
	if (getpropint(node, "buserr-type", 0) == 1)
		sc->flags |= CPUFLG_SUN4CACHEBUG;
}
#endif /* SUN4C || SUN4E */

void
sun4_hotfix(sc)
	struct cpu_softc *sc;
{
	if ((sc->flags & CPUFLG_SUN4CACHEBUG) != 0) {
		kvm_uncache((caddr_t)trapbase, 1);
		strlcpy(cpu_hotfix, "cache chip bug - trap page uncached",
		    sizeof cpu_hotfix);
	}

}

#if defined(SUN4M)
void
getcacheinfo_obp(sc, node)
	struct	cpu_softc *sc;
	int	node;
{
	struct cacheinfo *ci = &sc->cacheinfo;
	int i, l;

	if (node == 0)
		/* Bootstrapping */
		return;

	/*
	 * Determine the Sun4m cache organization.
	 */
	ci->c_physical = node_has_property(node, "cache-physical?");

	if (getpropint(node, "ncaches", 1) == 2)
		ci->c_split = 1;
	else
		ci->c_split = 0;

	/* hwflush is used only by sun4/4c code */
	ci->c_hwflush = 0; 

	if (node_has_property(node, "icache-nlines") &&
	    node_has_property(node, "dcache-nlines") &&
	    ci->c_split) {
		/* Harvard architecture: get I and D cache sizes */
		ci->ic_nlines = getpropint(node, "icache-nlines", 0);
		ci->ic_linesize = l =
			getpropint(node, "icache-line-size", 0);
		for (i = 0; (1 << i) < l && l; i++)
			/* void */;
		if ((1 << i) != l && l)
			panic("bad icache line size %d", l);
		ci->ic_l2linesize = i;
		ci->ic_associativity =
			getpropint(node, "icache-associativity", 1);
		ci->ic_totalsize = l * ci->ic_nlines * ci->ic_associativity;
	
		ci->dc_nlines = getpropint(node, "dcache-nlines", 0);
		ci->dc_linesize = l =
			getpropint(node, "dcache-line-size",0);
		for (i = 0; (1 << i) < l && l; i++)
			/* void */;
		if ((1 << i) != l && l)
			panic("bad dcache line size %d", l);
		ci->dc_l2linesize = i;
		ci->dc_associativity =
			getpropint(node, "dcache-associativity", 1);
		ci->dc_totalsize = l * ci->dc_nlines * ci->dc_associativity;

		ci->c_l2linesize = min(ci->ic_l2linesize, ci->dc_l2linesize);
		ci->c_linesize = min(ci->ic_linesize, ci->dc_linesize);
		ci->c_totalsize = ci->ic_totalsize + ci->dc_totalsize;
	} else {
		/* unified I/D cache */
		ci->c_nlines = getpropint(node, "cache-nlines", 128);
		ci->c_linesize = l = 
			getpropint(node, "cache-line-size", 0);
		for (i = 0; (1 << i) < l && l; i++)
			/* void */;
		if ((1 << i) != l && l)
			panic("bad cache line size %d", l);
		ci->c_l2linesize = i;
		ci->c_totalsize = l *
			ci->c_nlines *
			getpropint(node, "cache-associativity", 1);
	}
	
	if (node_has_property(node, "ecache-nlines")) {
		/* we have a L2 "e"xternal cache */
		ci->ec_nlines = getpropint(node, "ecache-nlines", 32768);
		ci->ec_linesize = l = getpropint(node, "ecache-line-size", 0);
		for (i = 0; (1 << i) < l && l; i++)
			/* void */;
		if ((1 << i) != l && l)
			panic("bad ecache line size %d", l);
		ci->ec_l2linesize = i;
		ci->ec_associativity =
			getpropint(node, "ecache-associativity", 1);
		ci->ec_totalsize = l * ci->ec_nlines * ci->ec_associativity;
	}
	if (ci->c_totalsize == 0)
		printf("warning: couldn't identify cache\n");
}

/*
 * We use the max. number of contexts on the micro and
 * hyper SPARCs. The SuperSPARC would let us use up to 65536
 * contexts (by powers of 2), but we keep it at 4096 since
 * the table must be aligned to #context*4. With 4K contexts,
 * we waste at most 16K of memory. Note that the context
 * table is *always* page-aligned, so there can always be
 * 1024 contexts without sacrificing memory space (given
 * that the chip supports 1024 contexts).
 *
 * Currently known limits: MS1=64, MS2=256, HS=4096, SS=65536
 * 	some old SS's=4096
 */

/* TI Microsparc I */
struct module_info module_ms1 = {
	CPUTYP_MS1,
	VAC_NONE,
	cpumatch_ms,
	getcacheinfo_obp,
	0,
	ms1_mmu_enable,
	ms1_cache_enable,
	64,
	ms1_get_syncflt,
	no_asyncflt_regs,
	ms1_cache_flush,
	noop_vcache_flush_page,
	noop_vcache_flush_segment,
	noop_vcache_flush_region,
	noop_vcache_flush_context,
	noop_pcache_flush_line,
	noop_pure_vcache_flush,
	ms1_cache_flush_all,
	memerr4m
};

void
ms1_mmu_enable()
{
}

/* TI Microsparc II */
struct module_info module_ms2 = {
	CPUTYP_MS2,
	VAC_WRITETHROUGH,
	cpumatch_ms,
	getcacheinfo_obp,
	0, /* was swift_hotfix, */
	0,
	swift_cache_enable,
	256,
	srmmu_get_syncflt,
	srmmu_get_asyncflt,
	srmmu_cache_flush,
	srmmu_vcache_flush_page,
	srmmu_vcache_flush_segment,
	srmmu_vcache_flush_region,
	srmmu_vcache_flush_context,
	noop_pcache_flush_line,
	noop_pure_vcache_flush,
	srmmu_cache_flush_all,
	memerr4m
};


struct module_info module_swift = {
	CPUTYP_MS2,
	VAC_WRITETHROUGH,
	cpumatch_ms,
	getcacheinfo_obp,
	swift_hotfix,
	0,
	swift_cache_enable,
	256,
	swift_get_syncflt,
	no_asyncflt_regs,
	srmmu_cache_flush,
	srmmu_vcache_flush_page,
	srmmu_vcache_flush_segment,
	srmmu_vcache_flush_region,
	srmmu_vcache_flush_context,
	srmmu_pcache_flush_line,
	noop_pure_vcache_flush,
	srmmu_cache_flush_all,
	memerr4m
};

void
cpumatch_ms(sc, mp, node)
	struct cpu_softc *sc;
	struct module_info *mp;
	int	node;
{
	replacemul();
}

void
swift_hotfix(sc)
	struct cpu_softc *sc;
{
	int pcr = lda(SRMMU_PCR, ASI_SRMMU);

	/* Turn on branch prediction */
	pcr |= SWIFT_PCR_BF;
	sta(SRMMU_PCR, ASI_SRMMU, pcr);
}

void
swift_mmu_enable()
{
}

struct module_info module_viking = {
	CPUTYP_UNKNOWN,		/* set in cpumatch() */
	VAC_NONE,
	cpumatch_viking,
	getcacheinfo_obp,
	viking_hotfix,
	viking_mmu_enable,
	viking_cache_enable,
	4096,
	viking_get_syncflt,
	no_asyncflt_regs,
	/* supersparcs use cached DVMA, no need to flush */
	noop_cache_flush,
	noop_vcache_flush_page,
	noop_vcache_flush_segment,
	noop_vcache_flush_region,
	noop_vcache_flush_context,
	viking_pcache_flush_line,
	noop_pure_vcache_flush,
	noop_cache_flush_all,
	viking_memerr
};

void
cpumatch_viking(sc, mp, node)
	struct cpu_softc *sc;
	struct module_info *mp;
	int	node;
{
	replacemul();

	if (node == 0)
		viking_hotfix(sc);
}

void
viking_hotfix(sc)
	struct cpu_softc *sc;
{
	int pcr = lda(SRMMU_PCR, ASI_SRMMU);

	/* Test if we're directly on the MBus */
	if ((pcr & VIKING_PCR_MB) == 0) {
		sc->mxcc = 1;
		sc->flags |= CPUFLG_CACHE_MANDATORY;
		/*
		 * Ok to cache PTEs; set the flag here, so we don't
		 * uncache in pmap_bootstrap().
		 */
		if ((pcr & VIKING_PCR_TC) == 0)
			printf("[viking: PCR_TC is off]");
		else
			sc->flags |= CPUFLG_CACHEPAGETABLES;
	} else {
		sc->cache_flush = viking_cache_flush;
		sc->pcache_flush_line = viking_pcache_flush_line;
	}

	/* XXX! */
	if (sc->mxcc)
		sc->cpu_type = CPUTYP_SS1_MBUS_MXCC;
	else
		sc->cpu_type = CPUTYP_SS1_MBUS_NOMXCC;
}

void
viking_mmu_enable()
{
	int pcr;

	pcr = lda(SRMMU_PCR, ASI_SRMMU);

	if (cpuinfo.mxcc) {
		if ((pcr & VIKING_PCR_TC) == 0) {
			printf("[viking: turn on PCR_TC]");
		}
		pcr |= VIKING_PCR_TC;
	} else
		pcr &= ~VIKING_PCR_TC;
	sta(SRMMU_PCR, ASI_SRMMU, pcr);
}


/* ROSS Hypersparc */
struct module_info module_hypersparc = {
	CPUTYP_UNKNOWN,
	VAC_WRITEBACK,
	cpumatch_hypersparc,
	getcacheinfo_obp,
	0,
	hypersparc_mmu_enable,
	hypersparc_cache_enable,
	4096,
	hypersparc_get_syncflt,
	hypersparc_get_asyncflt,
	srmmu_cache_flush,
	srmmu_vcache_flush_page,
	srmmu_vcache_flush_segment,
	srmmu_vcache_flush_region,
	srmmu_vcache_flush_context,
	srmmu_pcache_flush_line,
	hypersparc_pure_vcache_flush,
	hypersparc_cache_flush_all,
	hypersparc_memerr
};

void
cpumatch_hypersparc(sc, mp, node)
	struct cpu_softc *sc;
	struct module_info *mp;
	int	node;
{
	sc->cpu_type = CPUTYP_HS_MBUS;/*XXX*/

	if (node == 0)
		sta(0, ASI_HICACHECLR, 0);

	replacemul();
}

void
hypersparc_mmu_enable()
{
#if 0
	int pcr;

	pcr = lda(SRMMU_PCR, ASI_SRMMU);
	pcr |= HYPERSPARC_PCR_C;
	pcr &= ~HYPERSPARC_PCR_CE;

	sta(SRMMU_PCR, ASI_SRMMU, pcr);
#endif
}

/* Cypress 605 */
struct module_info module_cypress = {
	CPUTYP_CYPRESS,
	VAC_WRITEBACK,
	0,
	getcacheinfo_obp,
	0,
	0,
	cypress_cache_enable,
	4096,
	cypress_get_syncflt,
	cypress_get_asyncflt,
	srmmu_cache_flush,
	srmmu_vcache_flush_page,
	srmmu_vcache_flush_segment,
	srmmu_vcache_flush_region,
	srmmu_vcache_flush_context,
	srmmu_pcache_flush_line,
	noop_pure_vcache_flush,
	cypress_cache_flush_all,
	memerr4m
};

/* Fujitsu Turbosparc */
struct module_info module_turbosparc = {	/* UNTESTED */
	CPUTYP_MS2,
	VAC_WRITEBACK,
	cpumatch_turbosparc,
	getcacheinfo_obp,
	turbosparc_hotfix,
	0,
	turbosparc_cache_enable,
	256,
	turbosparc_get_syncflt,
	no_asyncflt_regs,
	srmmu_cache_flush,
	srmmu_vcache_flush_page,
	srmmu_vcache_flush_segment,
	srmmu_vcache_flush_region,
	srmmu_vcache_flush_context,
	srmmu_pcache_flush_line,
	noop_pure_vcache_flush,
	srmmu_cache_flush_all,
	memerr4m
};

void
cpumatch_turbosparc(sc, mp, node)
	struct cpu_softc *sc;
	struct module_info *mp;
	int	node;
{
	int i;

	if (node == 0 || sc->master == 0)
		return;

	i = getpsr();
	if (sc->cpu_vers == IU_VERS(i))
		return;

	/*
	 * A cloaked Turbosparc: clear any items in cpuinfo that
	 * might have been set to uS2 versions during bootstrap.
	 */
	sc->cpu_name = 0;
	sc->mmu_ncontext = 0;
	sc->cpu_type = 0;
	sc->cacheinfo.c_vactype = 0;
	sc->hotfix = 0;
	sc->mmu_enable = 0;
	sc->cache_enable = 0;
	sc->get_syncflt = 0;
	sc->cache_flush = 0;
	sc->vcache_flush_page = 0;
	sc->vcache_flush_segment = 0;
	sc->vcache_flush_region = 0;
	sc->vcache_flush_context = 0;
	sc->pcache_flush_line = 0;

	replacemul();
}

void
turbosparc_hotfix(sc)
	struct cpu_softc *sc;
{
	int pcf;

	pcf = lda(SRMMU_PCFG, ASI_SRMMU);
	if (pcf & TURBOSPARC_PCFG_US2) {
		/* Turn off uS2 emulation bit */
		pcf &= ~TURBOSPARC_PCFG_US2;
		sta(SRMMU_PCFG, ASI_SRMMU, pcf);
	}
}
#endif /* SUN4M */


#define	ANY	-1	/* match any version */

struct cpu_conf {
	int	arch;
	int	cpu_impl;
	int	cpu_vers;
	int	mmu_impl;
	int	mmu_vers;
	char	*name;
	struct	module_info *minfo;
} cpu_conf[] = {
#if defined(SUN4)
	{ CPU_SUN4, 0, 0, ANY, ANY, "MB86900/1A or L64801", &module_sun4 },
	{ CPU_SUN4, 1, 0, ANY, ANY, "L64811", &module_sun4 },
	{ CPU_SUN4, 1, 1, ANY, ANY, "CY7C601", &module_sun4 },
#endif

#if defined(SUN4C)
	{ CPU_SUN4C, 0, 0, ANY, ANY, "MB86900/1A or L64801", &module_sun4c },
	{ CPU_SUN4C, 1, 0, ANY, ANY, "L64811", &module_sun4c },
	{ CPU_SUN4C, 1, 1, ANY, ANY, "CY7C601", &module_sun4c },
	{ CPU_SUN4C, 9, 0, ANY, ANY, "W8601/8701 or MB86903", &module_sun4c },
#endif

#if defined(SUN4E)
	{ CPU_SUN4E, 0, 0, ANY, ANY, "MB86900/1A or L64801", &module_sun4c },
#endif

#if defined(SUN4M)
	{ CPU_SUN4M, 0, 4, 0, 4, "MB86904", &module_swift },
	{ CPU_SUN4M, 0, 5, 0, 5, "MB86907", &module_turbosparc },
	{ CPU_SUN4M, 1, 1, 1, 0, "CY7C601/604", &module_cypress },
	{ CPU_SUN4M, 1, 1, 1, 0xb, "CY7C601/605 (v.b)", &module_cypress },
	{ CPU_SUN4M, 1, 1, 1, 0xc, "CY7C601/605 (v.c)", &module_cypress },
	{ CPU_SUN4M, 1, 1, 1, 0xf, "CY7C601/605 (v.f)", &module_cypress },
	{ CPU_SUN4M, 1, 3, 1, ANY, "CY7C611", &module_cypress },
	{ CPU_SUN4M, 1, 0xe, 1, 7, "RT620/625", &module_hypersparc },
	{ CPU_SUN4M, 1, 0xf, 1, 7, "RT620/625", &module_hypersparc },
	{ CPU_SUN4M, 4, 0, 0, ANY, "TMS390Z50 v0 or TMS390Z55", &module_viking },
	{ CPU_SUN4M, 4, 1, 0, ANY, "TMS390Z50 v1", &module_viking },
	{ CPU_SUN4M, 4, 1, 4, ANY, "TMS390S10", &module_ms1 },
	{ CPU_SUN4M, 4, 2, 0, ANY, "TI_MS2", &module_ms2 },
	{ CPU_SUN4M, 4, 3, ANY, ANY, "TI_4_3", &module_viking },
	{ CPU_SUN4M, 4, 4, ANY, ANY, "TI_4_4", &module_viking },
#endif

	{ ANY, ANY, ANY, ANY, ANY, "Unknown", &module_unknown }
};

void
getcpuinfo(sc, node)
	struct cpu_softc *sc;
	int	node;
{
	struct cpu_conf *mp;
	int i;
	int cpu_impl, cpu_vers;
	int mmu_impl, mmu_vers;

	/*
	 * Set up main criteria for selection from the CPU configuration
	 * table: the CPU implementation/version fields from the PSR
	 * register, and -- on sun4m machines -- the MMU
	 * implementation/version from the SCR register.
	 */
	if (sc->master) {
		i = getpsr();
		if (node == 0 ||
		    (cpu_impl =
		     getpropint(node, "psr-implementation", -1)) == -1)
			cpu_impl = IU_IMPL(i);

		if (node == 0 ||
		    (cpu_vers = getpropint(node, "psr-version", -1)) == -1)
			cpu_vers = IU_VERS(i);

		if (CPU_ISSUN4M) {
			i = lda(SRMMU_PCR, ASI_SRMMU);
			if (node == 0 ||
			    (mmu_impl =
			     getpropint(node, "implementation", -1)) == -1)
				mmu_impl = SRMMU_IMPL(i);

			if (node == 0 ||
			    (mmu_vers = getpropint(node, "version", -1)) == -1)
				mmu_vers = SRMMU_VERS(i);
		} else {
			mmu_impl = ANY;
			mmu_vers = ANY;
		}
	} else {
		/*
		 * Get CPU version/implementation from ROM. If not
		 * available, assume same as boot CPU.
		 */
		cpu_impl = getpropint(node, "psr-implementation", -1);
		if (cpu_impl == -1)
			cpu_impl = cpuinfo.cpu_impl;
		cpu_vers = getpropint(node, "psr-version", -1);
		if (cpu_vers == -1)
			cpu_vers = cpuinfo.cpu_vers;

		/* Get MMU version/implementation from ROM always */
		mmu_impl = getpropint(node, "implementation", -1);
		mmu_vers = getpropint(node, "version", -1);
	}

	for (mp = cpu_conf; ; mp++) {
		if (mp->arch != cputyp && mp->arch != ANY)
			continue;

#define MATCH(x)	(mp->x == x || mp->x == ANY)
		if (!MATCH(cpu_impl) ||
		    !MATCH(cpu_vers) ||
		    !MATCH(mmu_impl) ||
		    !MATCH(mmu_vers))
			continue;
#undef MATCH

		/*
		 * Got CPU type.
		 */
		sc->cpu_impl = cpu_impl;
		sc->cpu_vers = cpu_vers;
		sc->mmu_impl = mmu_impl;
		sc->mmu_vers = mmu_vers;

		if (mp->minfo->cpu_match) {
			/* Additional fixups */
			mp->minfo->cpu_match(sc, mp->minfo, node);
		}
		if (sc->cpu_name == 0)
			sc->cpu_name = mp->name;

		if (sc->mmu_ncontext == 0)
			sc->mmu_ncontext = mp->minfo->ncontext;

		if (sc->cpu_type == 0)
			sc->cpu_type = mp->minfo->cpu_type;

		if (sc->cacheinfo.c_vactype == VAC_UNKNOWN)
			sc->cacheinfo.c_vactype = mp->minfo->vactype;

		mp->minfo->getcacheinfo(sc, node);

		if (node && sc->hz == 0 && !CPU_ISSUN4/*XXX*/) {
			sc->hz = getpropint(node, "clock-frequency", 0);
			if (sc->hz == 0) {
				/*
				 * Try to find it in the OpenPROM root...
				 */     
				sc->hz = getpropint(findroot(),
						    "clock-frequency", 0);
			}
		}

		/*
		 * Copy CPU/MMU/Cache specific routines into cpu_softc.
		 */
#define MPCOPY(x)	if (sc->x == 0) sc->x = mp->minfo->x;
		MPCOPY(hotfix);
		MPCOPY(mmu_enable);
		MPCOPY(cache_enable);
		MPCOPY(get_syncflt);
		MPCOPY(get_asyncflt);
		MPCOPY(cache_flush);
		MPCOPY(vcache_flush_page);
		MPCOPY(vcache_flush_segment);
		MPCOPY(vcache_flush_region);
		MPCOPY(vcache_flush_context);
		MPCOPY(pcache_flush_line);
		MPCOPY(pure_vcache_flush);
		MPCOPY(cache_flush_all);
		MPCOPY(memerr);
#undef MPCOPY
		return;
	}
	panic("Out of CPUs");
}

/*
 * The following tables convert <IU impl, IU version, FPU version> triples
 * into names for the CPU and FPU chip.  In most cases we do not need to
 * inspect the FPU version to name the IU chip, but there is one exception
 * (for Tsunami), and this makes the tables the same.
 *
 * The table contents (and much of the structure here) are from Guy Harris.
 *
 */
struct info {
	int	valid;
	int	iu_impl;
	int	iu_vers;
	int	fpu_vers;
	char	*name;
};

/* NB: table order matters here; specific numbers must appear before ANY. */
static struct info fpu_types[] = {
	/*
	 * Vendor 0, IU Fujitsu0.
	 */
	{ 1, 0x0, ANY, 0, "MB86910 or WTL1164/5" },
	{ 1, 0x0, ANY, 1, "MB86911 or WTL1164/5" },
	{ 1, 0x0, ANY, 2, "L64802 or ACT8847" },
	{ 1, 0x0, ANY, 3, "WTL3170/2" },
	{ 1, 0x0, 4,   4, "on-chip" },		/* Swift */
	{ 1, 0x0, 5,   5, "on-chip" },		/* TurboSparc */
	{ 1, 0x0, ANY, 4, "L64804" },

	/*
	 * Vendor 1, IU ROSS0/1 or Pinnacle.
	 */
	{ 1, 0x1, 0xf, 0, "on-chip" },		/* Pinnacle */
	{ 1, 0x1, 0xe, 0, "on-chip" },		/* Hypersparc RT 625/626 */
	{ 1, 0x1, ANY, 0, "L64812 or ACT8847" },
	{ 1, 0x1, ANY, 1, "L64814" },
	{ 1, 0x1, ANY, 2, "TMS390C602A" },
	{ 1, 0x1, ANY, 3, "RT602 or WTL3171" },

	/*
	 * Vendor 2, IU BIT0.
	 */
	{ 1, 0x2, ANY, 0, "B5010 or B5110/20 or B5210" },

	/*
	 * Vendor 4, Texas Instruments.
	 */
	{ 1, 0x4, ANY, 0, "on-chip" },		/* Viking */
	{ 1, 0x4, ANY, 4, "on-chip" },		/* Tsunami */

	/*
	 * Vendor 5, IU Matsushita0.
	 */
	{ 1, 0x5, ANY, 0, "on-chip" },

	/*
	 * Vendor 9, Weitek.
	 */
	{ 1, 0x9, ANY, 3, "on-chip" },

	{ 0 }
};

char *
fsrtoname(impl, vers, fver, buf, buflen)
	register int impl, vers, fver;
	char *buf;
	size_t buflen;
{
	register struct info *p;

	for (p = fpu_types; p->valid; p++)
		if (p->iu_impl == impl &&
		    (p->iu_vers == vers || p->iu_vers == ANY) &&
		    (p->fpu_vers == fver))
			return (p->name);
	snprintf(buf, buflen, "version 0x%x", fver);
	return (buf);
}

/*
 * Whack the slow sun4/sun4c {,u}{mul,div,rem} functions with
 * fast V8 ones
 * We are called once before pmap_bootstrap and once after. We only do stuff
 * in the "before" case. We happen to know that the kernel text is not
 * write-protected then.
 * XXX - investigate cache flushing, right now we can't do it because the
 *       flushes try to do va -> pa conversions.
 */
extern int _mulreplace, _mulreplace_end, _mul;
extern int _umulreplace, _umulreplace_end, _umul;
extern int _divreplace, _divreplace_end, _div;
extern int _udivreplace, _udivreplace_end, _udiv;
extern int _remreplace, _remreplace_end, _rem;
extern int _uremreplace, _uremreplace_end, _urem;
int	v8mul;	/* flag whether cpu has hardware mul, div, and rem */

static const struct replace {
	void *from, *frome, *to;
} ireplace[] = {
	{ &_mulreplace, &_mulreplace_end, &_mul },
	{ &_umulreplace, &_umulreplace_end, &_umul },
	{ &_divreplace, &_divreplace_end, &_div },
	{ &_udivreplace, &_udivreplace_end, &_udiv },
	{ &_remreplace, &_remreplace_end, &_rem },
 	{ &_uremreplace, &_uremreplace_end, &_urem },
};

void
replacemul()
{
	static int replacedone = 0;
	int i, s;

	if (replacedone)
		return;
	replacedone = 1;

	s = splhigh();
	for (i = 0; i < sizeof(ireplace)/sizeof(ireplace[0]); i++)
		bcopy(ireplace[i].from, ireplace[i].to,
		    ireplace[i].frome - ireplace[i].from);
	splx(s);
	v8mul = 1;
}
@


1.51
log
@Remove remaining Solbourne code.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.50 2014/04/30 04:20:31 miod Exp $	*/
@


1.50
log
@Enforce proper alignment of stack variables which may get accessed with
double-word load and store instructions. This used to work by chance, but
recent compiler changes no longer put us in the lucky situation.

tweaks kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.49 2012/11/25 13:34:17 jsg Exp $	*/
a75 6
#ifdef solbourne
#include <machine/idt.h>
#include <machine/kap.h>
#include <machine/prom.h>
#endif

a625 106
#if defined(solbourne)
struct module_info module_kap = {
	CPUTYP_UNKNOWN,
	VAC_WRITEBACK,
	cpumatch_kap,
	getcacheinfo_kap,
	NULL,
	0,				/* mmu_enable */
	kap_cache_enable,
	0,				/* ncontext is irrelevant here */
	0,
	0,
	kap_cache_flush,
	kap_vcache_flush_page,
	noop_vcache_flush_segment,	/* unused */
	noop_vcache_flush_region,	/* unused */
	kap_vcache_flush_context,
	noop_pcache_flush_line,
	noop_pure_vcache_flush,
	noop_cache_flush_all,
	0
};

void
cpumatch_kap(sc, mp, node)
	struct cpu_softc *sc;
	struct module_info *mp;
	int	node;
{
	extern int timerblurb;

	sc->mmu_npmeg = sc->mmu_ncontext = 0;	/* do not matter for idt */

	/*
	 * Check for the clock speed in the board diagnostic register.
	 * While there, knowing that there are only two possible values,
	 * fill the delay constant.
	 */
	if ((lda(GLU_DIAG, ASI_PHYS_IO) >> 24) & GD_36MHZ) {
		sc->hz = 36000000;
		timerblurb = 14;	/* about 14.40 */
	} else {
		sc->hz = 33000000;
		timerblurb = 13;	/* about 13.20 */
	}

	if (node != 0) {
		sysmodel = getpropint(node, "cpu", 0);
		switch (sysmodel) {
		case SYS_S4000:
			break;
		case SYS_S4100:
			/* XXX do something about the L2 cache */
			break;
		default:
			panic("cpumatch_kap: unrecognized sysmodel %x",
			    sysmodel);
		}
	}
}

void
getcacheinfo_kap(sc, node)
	struct cpu_softc *sc;
	int node;
{
	struct cacheinfo *ci = &sc->cacheinfo;

	/*
	 * The KAP processor has 3KB icache and 2KB dcache.
	 * It is divided in 3 (icache) or 2 (dcache) banks
	 * of 256 lines, each line being 4 bytes.
	 * Both caches are virtually addressed.
	 */

	ci->ic_linesize = 12;
	ci->ic_l2linesize = 3;	/* XXX */
	ci->ic_nlines = DCACHE_LINES;
	ci->ic_associativity = 1;
	ci->ic_totalsize =
	    ci->ic_nlines * ci->ic_linesize * ci->ic_associativity;
	
	ci->dc_enabled = 1;
	ci->dc_linesize = 8;
	ci->dc_l2linesize = 3;
	ci->dc_nlines = DCACHE_LINES;
	ci->dc_associativity = 1;
	ci->dc_totalsize =
	    ci->dc_nlines * ci->dc_linesize * ci->dc_associativity;

	ci->c_totalsize = ci->ic_totalsize + ci->dc_totalsize;
	/* ci->c_enabled */
	ci->c_hwflush = 0;
	ci->c_linesize = 8;	/* min */
	ci->c_l2linesize = 3;	/* min */
	ci->c_nlines = DCACHE_LINES;
	ci->c_physical = 0;
	ci->c_associativity = 1;
	ci->c_split = 1;

	/* no L2 cache (except on 4100 but we don't handle it yet) */
	
	ci->c_vactype = VAC_WRITEBACK;
}
#endif

a1116 4
#endif

#if defined(solbourne)
	{ CPU_KAP, 5, 0, ANY, ANY, "KAP", &module_kap },
@


1.49
log
@Make the instruction replace struct static const so it will end
up in the .rodata section.  Suggested by and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.48 2010/11/11 17:58:23 miod Exp $	*/
d297 1
a297 1
	struct fpstate fpstate;
@


1.48
log
@Replace snprintf(foo, sizeof foo, "%s", ...) with strlcpy. ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.47 2010/07/10 19:32:24 miod Exp $	*/
d1467 1
a1467 1
struct replace {
@


1.47
log
@sun4e (i.e. SPARCengine 1e) support. This platform is a mix between sun4 and
sun4c, as it has a sun4c OpenPROM but a sun4 8KB pagesize. VME devices are
not supported yet.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.46 2010/06/07 19:54:33 miod Exp $	*/
d744 2
a745 2
		snprintf(cpu_hotfix, sizeof cpu_hotfix,
		    "cache chip bug - trap page uncached");
@


1.46
log
@Rework the way onboard devices attach on Sun 4/110 systems (which only have a
28 bit address bus) by reusing the regular sun4 configuration stanzas (with
the upper four bits set in the device addresses), and clearing them when
searching for a PROM mapping.
This makes the obio autoconf code simpler, and all knowledge of the 4/110
specifics is now contained in a single file (dev/obio.c).

ok todd@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.45 2010/06/07 19:44:54 miod Exp $	*/
d192 1
a192 1
#if defined(SUN4C) || defined(SUN4M)
d199 10
d215 1
a215 1
#endif /* defined(SUN4C) || defined(SUN4M) */
d548 1
a548 1
#if defined(SUN4C)
d581 1
a581 1
		getpropint(rnode, "mmu-npmg", 128);
d630 1
a630 1
#endif /* SUN4C */
d1207 4
@


1.45
log
@Do not invoke cache_enable() if there is no cache; prevents a spurious (and
bogus) `cache enabled' line in dmesg on 4/110.
ok todd@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.44 2008/06/29 01:27:42 miod Exp $	*/
a139 14

/*
 * 4/110 comment: the 4/110 chops off the top 4 bits of an OBIO address.
 *	this confuses autoconf.  for example, if you try and map
 *	0xfe000000 in obio space on a 4/110 it actually maps 0x0e000000.
 *	this is easy to verify with the PROM.   this causes problems
 *	with devices like "esp0 at obio0 addr 0xfa000000" because the
 *	4/110 treats it as esp0 at obio0 addr 0x0a000000" which is the
 *	address of the 4/110's "sw0" scsi chip.   the same thing happens
 *	between zs1 and zs2.    since the sun4 line is "closed" and
 *	we know all the "obio" devices that will ever be on it we just
 *	put in some special case "if"'s in the match routines of esp,
 *	dma, and zs.
 */
@


1.44
log
@Revert 1.8, and reenable branch prediction on swift cpus. Ten years of trap.c
and locore.s changes have fixed the condition incorrectly blamed on branch
prediction, and these processors run fine with it enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.43 2007/05/10 18:06:01 art Exp $	*/
d260 6
a265 4
		s = splhigh();
		sc->cache_enable();
		pmap_cache_enable();
		splx(s);
@


1.43
log
@Don't zero out the cpu_info in cpu_attach. We've already set a field in
it (curproc) and it's allocated from zeroed memory anyway.

deraadt@@ ok and test.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.42 2007/05/08 07:23:18 art Exp $	*/
d944 2
a945 2
	/* Turn off branch prediction */
	pcr &= ~SWIFT_PCR_BF;
@


1.42
log
@Switch sparc to __HAVE_CPUINFO.

miod@@ tested (since I hacked it up blindly) and ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.41 2005/08/06 14:26:52 miod Exp $	*/
a246 1
	memset(&sc->ci, 0, sizeof(sc->ci));
@


1.41
log
@We do not need a char machine_arch[] constant.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.40 2005/04/19 21:30:20 miod Exp $	*/
d246 3
@


1.40
log
@As a late birthday present, a preliminary port to the Solbourne IDT systems
(S3000, S4000 and S4000DX).

Currently limited to diskless and serial console, and userland has issues.
Things will get better in the near future.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.39 2003/05/10 21:11:14 deraadt Exp $	*/
a83 1
char	machine_arch[] = MACHINE_ARCH;	/* from <machine/param.h> */
@


1.39
log
@string cleaning; ok beck dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.38 2002/11/22 23:08:49 deraadt Exp $	*/
d76 6
d374 1
d379 1
d633 106
d1226 4
@


1.38
log
@new sysctl: machdep.v8mul says whether the kernel replaced the mul/div/rem
stubs, so that userland can do the same.  we cannot just determine based
on sun4m, because cypress (at least) is a sun4m cpu without the instructions
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.37 2002/03/14 01:26:44 millert Exp $	*/
d98 1
a98 1
char *fsrtoname(int, int, int, char *);
d226 1
a226 1
			    sc->fpuvers, fpbuf);
d230 1
a230 1
	sprintf(model, "%s @@ %s MHz, %s FPU", sc->cpu_name,
d233 1
a233 1
	sprintf(cpu_model, "%s, %s", mainbus_model, model);
d631 2
a632 1
		sprintf(cpu_hotfix, "cache chip bug - trap page uncached");
d1313 1
a1313 1
fsrtoname(impl, vers, fver, buf)
d1316 1
d1325 1
a1325 1
	sprintf(buf, "version 0x%x", fver);
@


1.37
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.36 2001/12/19 08:58:05 art Exp $	*/
d1342 1
d1370 1
@


1.36
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.33 2001/11/06 19:53:16 miod Exp $	*/
d87 2
a88 2
void cpu_attach __P((struct device *, struct device *, void *));
int  cpu_match __P((struct device *, void *, void *));
d98 5
a102 5
char *fsrtoname __P((int, int, int, char *));
void cache_print __P((struct cpu_softc *));
void cpu_spinup __P((struct cpu_softc *));
void fpu_init __P((struct cpu_softc *));
void replacemul __P((void));
d361 34
a394 34
void cpumatch_unknown __P((struct cpu_softc *, struct module_info *, int));
void cpumatch_sun4 __P((struct cpu_softc *, struct module_info *, int));
void cpumatch_sun4c __P((struct cpu_softc *, struct module_info *, int));
void cpumatch_ms __P((struct cpu_softc *, struct module_info *, int));
void cpumatch_viking __P((struct cpu_softc *, struct module_info *, int));
void cpumatch_hypersparc __P((struct cpu_softc *, struct module_info *, int));
void cpumatch_turbosparc __P((struct cpu_softc *, struct module_info *, int));

void getcacheinfo_sun4 __P((struct cpu_softc *, int node));
void getcacheinfo_sun4c __P((struct cpu_softc *, int node));
void getcacheinfo_obp __P((struct cpu_softc *, int node));

void sun4_hotfix __P((struct cpu_softc *));
void viking_hotfix __P((struct cpu_softc *));
void turbosparc_hotfix __P((struct cpu_softc *));
void swift_hotfix __P((struct cpu_softc *));

void ms1_mmu_enable __P((void));
void viking_mmu_enable __P((void));
void swift_mmu_enable __P((void));
void hypersparc_mmu_enable __P((void));

void srmmu_get_syncflt __P((void));
void ms1_get_syncflt __P((void));
void viking_get_syncflt __P((void));
void swift_get_syncflt __P((void));
void turbosparc_get_syncflt __P((void));
void hypersparc_get_syncflt __P((void));
void cypress_get_syncflt __P((void));

int srmmu_get_asyncflt __P((u_int *, u_int *));
int hypersparc_get_asyncflt __P((u_int *, u_int *));
int cypress_get_asyncflt __P((u_int *, u_int *));
int no_asyncflt_regs __P((u_int *, u_int *));
d494 1
a494 1
void	getidprom __P((struct idprom *, int size));
@


1.35
log
@Remove pmap_cache_enable. it was a mistake.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.34 2001/12/05 14:40:48 art Exp $	*/
d255 1
d432 1
a432 1
	noop_pcache_flush_page,
d558 1
a558 1
	noop_pcache_flush_page,
d756 1
a756 1
	noop_pcache_flush_page,
d784 1
a784 1
	noop_pcache_flush_page,
d807 1
a807 1
	noop_pcache_flush_page,
d855 1
a855 1
	viking_pcache_flush_page,
d893 1
a893 1
		sc->pcache_flush_page = viking_pcache_flush_page;
d938 1
a938 1
	noop_pcache_flush_page,
d989 1
a989 1
	noop_pcache_flush_page,
d1012 1
a1012 1
	noop_pcache_flush_page,
d1050 1
a1050 1
	sc->pcache_flush_page = 0;
d1237 1
a1237 1
		MPCOPY(pcache_flush_page);
@


1.35.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.35 2001/12/07 10:44:52 art Exp $	*/
d87 2
a88 2
void cpu_attach(struct device *, struct device *, void *);
int  cpu_match(struct device *, void *, void *);
d98 5
a102 5
char *fsrtoname(int, int, int, char *);
void cache_print(struct cpu_softc *);
void cpu_spinup(struct cpu_softc *);
void fpu_init(struct cpu_softc *);
void replacemul(void);
d360 34
a393 34
void cpumatch_unknown(struct cpu_softc *, struct module_info *, int);
void cpumatch_sun4(struct cpu_softc *, struct module_info *, int);
void cpumatch_sun4c(struct cpu_softc *, struct module_info *, int);
void cpumatch_ms(struct cpu_softc *, struct module_info *, int);
void cpumatch_viking(struct cpu_softc *, struct module_info *, int);
void cpumatch_hypersparc(struct cpu_softc *, struct module_info *, int);
void cpumatch_turbosparc(struct cpu_softc *, struct module_info *, int);

void getcacheinfo_sun4(struct cpu_softc *, int node);
void getcacheinfo_sun4c(struct cpu_softc *, int node);
void getcacheinfo_obp(struct cpu_softc *, int node);

void sun4_hotfix(struct cpu_softc *);
void viking_hotfix(struct cpu_softc *);
void turbosparc_hotfix(struct cpu_softc *);
void swift_hotfix(struct cpu_softc *);

void ms1_mmu_enable(void);
void viking_mmu_enable(void);
void swift_mmu_enable(void);
void hypersparc_mmu_enable(void);

void srmmu_get_syncflt(void);
void ms1_get_syncflt(void);
void viking_get_syncflt(void);
void swift_get_syncflt(void);
void turbosparc_get_syncflt(void);
void hypersparc_get_syncflt(void);
void cypress_get_syncflt(void);

int srmmu_get_asyncflt(u_int *, u_int *);
int hypersparc_get_asyncflt(u_int *, u_int *);
int cypress_get_asyncflt(u_int *, u_int *);
int no_asyncflt_regs(u_int *, u_int *);
d493 1
a493 1
void	getidprom(struct idprom *, int size);
@


1.35.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d98 1
a98 1
char *fsrtoname(int, int, int, char *, size_t);
d226 1
a226 1
			    sc->fpuvers, fpbuf, sizeof fpbuf);
d230 1
a230 1
	snprintf(model, sizeof model, "%s @@ %s MHz, %s FPU", sc->cpu_name,
d233 1
a233 1
	snprintf(cpu_model, sizeof cpu_model, "%s, %s", mainbus_model, model);
d630 1
a630 2
		snprintf(cpu_hotfix, sizeof cpu_hotfix,
		    "cache chip bug - trap page uncached");
d1311 1
a1311 1
fsrtoname(impl, vers, fver, buf, buflen)
a1313 1
	size_t buflen;
d1322 1
a1322 1
	snprintf(buf, buflen, "version 0x%x", fver);
a1340 1
int	v8mul;	/* flag whether cpu has hardware mul, div, and rem */
a1367 1
	v8mul = 1;
@


1.34
log
@Change pcache_flush_line to pcache_flush_page since this is the only way
we use the function.
At the same time fix the pte pool backend functions to allocate and map
the memory themselves.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.33 2001/11/06 19:53:16 miod Exp $	*/
a254 1
		pmap_cache_enable();
@


1.33
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.32 2000/11/22 16:01:37 art Exp $	*/
d432 1
a432 1
	noop_pcache_flush_line,
d558 1
a558 1
	noop_pcache_flush_line,
d756 1
a756 1
	noop_pcache_flush_line,
d784 1
a784 1
	noop_pcache_flush_line,
d807 1
a807 1
	srmmu_pcache_flush_line,
d855 1
a855 1
	viking_pcache_flush_line,
d893 1
a893 1
		sc->pcache_flush_line = viking_pcache_flush_line;
d938 1
a938 1
	srmmu_pcache_flush_line,
d989 1
a989 1
	srmmu_pcache_flush_line,
d1012 1
a1012 1
	srmmu_pcache_flush_line,
d1050 1
a1050 1
	sc->pcache_flush_line = 0;
d1237 1
a1237 1
		MPCOPY(pcache_flush_line);
@


1.32
log
@Remove UNTESTED comments on cpus that I know work.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.31 2000/02/23 16:43:41 deraadt Exp $	*/
d59 1
a59 1
#include <vm/vm.h>
@


1.31
log
@if we discover we are on a v8 cpu, and thus have the multiply and divide
instructions, replace the .{u,}{mul,div,rem} functions at runtime with
(much smaller and faster) blocks using the actual hardware instructions.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.30 2000/02/21 21:05:59 art Exp $	*/
d768 1
a768 1
struct module_info module_ms2 = {		/* UNTESTED */
d791 1
a791 1
struct module_info module_swift = {		/* UNTESTED */
d838 1
a838 1
struct module_info module_viking = {		/* UNTESTED */
d922 1
a922 1
struct module_info module_hypersparc = {		/* UNTESTED */
d973 1
a973 1
struct module_info module_cypress = {		/* UNTESTED */
@


1.30
log
@move fpproc into the cpuinfo structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.29 2000/02/21 17:08:36 art Exp $	*/
d1327 27
d1357 2
a1358 4
	extern char *_umulreplace, *_umulreplace_end;
	extern char *_mulreplace, *_mulreplace_end;
	extern char *_mul, *_umul;
	int i, j, s;
d1360 3
a1362 1
	return;
a1363 4
	/*
	 * Whack the slow sun4/sun4c umul/mul functions with
	 * fast V8 ones
	 */
d1365 3
a1367 10
	cpuinfo.cache_flush_all();
	for (i = 0; i < _umulreplace_end - _umulreplace; i++) {
		j = _umulreplace[i];
		pmap_writetext(&_umul[i], j);
	}
	for (i = 0; i < _mulreplace_end - _mulreplace; i++) {
		j = _mulreplace[i];
		pmap_writetext(&_mul[i], j);
	}
	cpuinfo.cache_flush_all();
@


1.29
log
@The last pieces of hypersparc support.
 - Split get_faultstatus into get_syncflt and get_asyncflt.
 - Get the syncflt status before setting up the trap frame and put the
   results in cpuinfo.syncfltdump (related to the next change).
 - unlock the sfsr/sfva after reading from ASI_SRMMUFP (it gets locked if
   the translation fails).
 - + other interface changes and cleanups.
 (most work from NetBSD).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.28 2000/02/21 14:58:17 art Exp $	*/
a84 1
struct proc *fpproc;			/* XXX - should be in cpuinfo */
d1330 2
a1331 3
#ifdef notyet
	extern void *_umulreplace, *_umulreplace_end;
	extern void *_mulreplace, *_mulreplace_end;
d1335 2
d1342 4
a1345 3
	for (i = 0; i < _umulreplace_end - _umulreplace; i += 4) {
		j = ((int *)_umulreplace)[i];
		pmap_writetext(_umul + (i<<2), j);
d1347 3
a1349 3
	for (i = 0; i < _mulreplace_end - _mulreplace; i += 4) {
		j = ((int *)_mulreplace)[i];
		pmap_writetext(_mul + (i<<2), j);
d1351 1
a1352 1
#endif
@


1.28
log
@In cpumatch_hypersparc - zap the instruction cache if we are the main cpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.27 2000/02/21 14:57:04 art Exp $	*/
d384 12
a395 7
void srmmu_get_fltstatus __P((void));
void ms1_get_fltstatus __P((void));
void viking_get_fltstatus __P((void));
void swift_get_fltstatus __P((void));
void turbosparc_get_fltstatus __P((void));
void hypersparc_get_fltstatus __P((void));
void cypress_get_fltstatus __P((void));
d426 2
a427 1
	0,			/* get fault regs: unused */
d552 2
a553 1
	0,
d750 2
a751 1
	ms1_get_fltstatus,
d778 2
a779 1
	srmmu_get_fltstatus,
d801 2
a802 1
	swift_get_fltstatus,
d848 2
a849 1
	viking_get_fltstatus,
d932 2
a933 1
	hypersparc_get_fltstatus,
d983 2
a984 1
	cypress_get_fltstatus,
d1006 2
a1007 1
	turbosparc_get_fltstatus,
d1045 1
a1045 1
	sc->get_faultstatus = 0;
d1231 2
a1232 1
		MPCOPY(get_faultstatus);
@


1.27
log
@remove the annoying "hypersparc support still under construction" warning.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.26 2000/02/21 14:56:04 art Exp $	*/
d940 3
@


1.26
log
@hypersparc has a writeback cache
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.25 2000/02/19 22:04:23 art Exp $	*/
a939 1
	printf("warning: hypersparc support still under construction\n");
@


1.25
log
@replacemul has been broken all the time. comment it out for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.24 2000/02/19 21:45:56 art Exp $	*/
d914 1
a914 1
	VAC_NONE,
@


1.24
log
@Add two new cache operations.
cache_flush_all - (pretty obvious).
pure_vcache_flush - flush all VIVT caches (needed on context switch).
(From NetBSD).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.23 2000/02/18 18:57:14 art Exp $	*/
d1314 1
d1334 1
@


1.23
log
@No need to call memerr4_4c through a pointer. We know when we are a 4/4c.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.22 2000/01/31 16:06:58 art Exp $	*/
d428 2
d553 2
d750 2
d777 2
d799 2
d846 2
d928 2
d976 2
d998 2
d1222 2
@


1.22
log
@Clean up memerr*. (from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.21 2000/01/27 20:14:11 art Exp $	*/
d428 1
a428 1
	memerr4_4c
d551 1
a551 1
	memerr4_4c
@


1.22.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.25 2000/02/19 22:04:23 art Exp $	*/
d428 1
a428 3
	noop_pure_vcache_flush,
	noop_cache_flush_all,
	0
d551 1
a551 3
	noop_pure_vcache_flush,
	noop_cache_flush_all,
	0
a745 2
	noop_pure_vcache_flush,
	ms1_cache_flush_all,
a770 2
	noop_pure_vcache_flush,
	srmmu_cache_flush_all,
a790 2
	noop_pure_vcache_flush,
	srmmu_cache_flush_all,
a835 2
	noop_pure_vcache_flush,
	noop_cache_flush_all,
a915 2
	hypersparc_pure_vcache_flush,
	hypersparc_cache_flush_all,
a961 2
	noop_pure_vcache_flush,
	cypress_cache_flush_all,
a981 2
	noop_pure_vcache_flush,
	srmmu_cache_flush_all,
a1203 2
		MPCOPY(pure_vcache_flush);
		MPCOPY(cache_flush_all);
a1293 1
#ifdef notyet
a1312 1
#endif
@


1.22.2.2
log
@sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.30 2000/02/21 21:05:59 art Exp $	*/
d85 1
d384 7
a390 12
void srmmu_get_syncflt __P((void));
void ms1_get_syncflt __P((void));
void viking_get_syncflt __P((void));
void swift_get_syncflt __P((void));
void turbosparc_get_syncflt __P((void));
void hypersparc_get_syncflt __P((void));
void cypress_get_syncflt __P((void));

int srmmu_get_asyncflt __P((u_int *, u_int *));
int hypersparc_get_asyncflt __P((u_int *, u_int *));
int cypress_get_asyncflt __P((u_int *, u_int *));
int no_asyncflt_regs __P((u_int *, u_int *));
d421 1
a421 2
	0,			/* get_syncflt(); unused in sun4 */
	0,			/* get_asyncflt(); unused in sun4 */
d546 1
a546 2
	0,			/* get_syncflt(); unused in sun4c */
	0,			/* get_asyncflt(); unused in sun4c */
d743 1
a743 2
	ms1_get_syncflt,
	no_asyncflt_regs,
d770 1
a770 2
	srmmu_get_syncflt,
	srmmu_get_asyncflt,
d792 1
a792 2
	swift_get_syncflt,
	no_asyncflt_regs,
d838 1
a838 2
	viking_get_syncflt,
	no_asyncflt_regs,
d914 1
a914 1
	VAC_WRITEBACK,
d921 1
a921 2
	hypersparc_get_syncflt,
	hypersparc_get_asyncflt,
d940 1
a940 3

	if (node == 0)
		sta(0, ASI_HICACHECLR, 0);
d969 1
a969 2
	cypress_get_syncflt,
	cypress_get_asyncflt,
d991 1
a991 2
	turbosparc_get_syncflt,
	no_asyncflt_regs,
d1029 1
a1029 1
	sc->get_syncflt = 0;
d1215 1
a1215 2
		MPCOPY(get_syncflt);
		MPCOPY(get_asyncflt);
d1314 3
a1316 2
	extern char *_umulreplace, *_umulreplace_end;
	extern char *_mulreplace, *_mulreplace_end;
a1319 2
	return;

d1325 3
a1327 4
	cpuinfo.cache_flush_all();
	for (i = 0; i < _umulreplace_end - _umulreplace; i++) {
		j = _umulreplace[i];
		pmap_writetext(&_umul[i], j);
d1329 3
a1331 3
	for (i = 0; i < _mulreplace_end - _mulreplace; i++) {
		j = _mulreplace[i];
		pmap_writetext(&_mul[i], j);
a1332 1
	cpuinfo.cache_flush_all();
d1334 1
@


1.22.2.3
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a1326 27
/*
 * Whack the slow sun4/sun4c {,u}{mul,div,rem} functions with
 * fast V8 ones
 * We are called once before pmap_bootstrap and once after. We only do stuff
 * in the "before" case. We happen to know that the kernel text is not
 * write-protected then.
 * XXX - investigate cache flushing, right now we can't do it because the
 *       flushes try to do va -> pa conversions.
 */
extern int _mulreplace, _mulreplace_end, _mul;
extern int _umulreplace, _umulreplace_end, _umul;
extern int _divreplace, _divreplace_end, _div;
extern int _udivreplace, _udivreplace_end, _udiv;
extern int _remreplace, _remreplace_end, _rem;
extern int _uremreplace, _uremreplace_end, _urem;

struct replace {
	void *from, *frome, *to;
} ireplace[] = {
	{ &_mulreplace, &_mulreplace_end, &_mul },
	{ &_umulreplace, &_umulreplace_end, &_umul },
	{ &_divreplace, &_divreplace_end, &_div },
	{ &_udivreplace, &_udivreplace_end, &_udiv },
	{ &_remreplace, &_remreplace_end, &_rem },
 	{ &_uremreplace, &_uremreplace_end, &_urem },
};

d1330 4
a1333 2
	static int replacedone = 0;
	int i, s;
d1335 1
a1335 3
	if (replacedone)
		return;
	replacedone = 1;
d1337 4
d1342 10
a1351 3
	for (i = 0; i < sizeof(ireplace)/sizeof(ireplace[0]); i++)
		bcopy(ireplace[i].from, ireplace[i].to,
		    ireplace[i].frome - ireplace[i].from);
@


1.22.2.4
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.32 2000/11/22 16:01:37 art Exp $	*/
d768 1
a768 1
struct module_info module_ms2 = {
d791 1
a791 1
struct module_info module_swift = {
d838 1
a838 1
struct module_info module_viking = {
d922 1
a922 1
struct module_info module_hypersparc = {
d973 1
a973 1
struct module_info module_cypress = {
@


1.22.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 1
a59 1
#include <uvm/uvm_extern.h>
@


1.22.2.6
log
@Merge in -current from about a week ago
@
text
@d87 2
a88 2
void cpu_attach(struct device *, struct device *, void *);
int  cpu_match(struct device *, void *, void *);
d98 5
a102 5
char *fsrtoname(int, int, int, char *);
void cache_print(struct cpu_softc *);
void cpu_spinup(struct cpu_softc *);
void fpu_init(struct cpu_softc *);
void replacemul(void);
d361 34
a394 34
void cpumatch_unknown(struct cpu_softc *, struct module_info *, int);
void cpumatch_sun4(struct cpu_softc *, struct module_info *, int);
void cpumatch_sun4c(struct cpu_softc *, struct module_info *, int);
void cpumatch_ms(struct cpu_softc *, struct module_info *, int);
void cpumatch_viking(struct cpu_softc *, struct module_info *, int);
void cpumatch_hypersparc(struct cpu_softc *, struct module_info *, int);
void cpumatch_turbosparc(struct cpu_softc *, struct module_info *, int);

void getcacheinfo_sun4(struct cpu_softc *, int node);
void getcacheinfo_sun4c(struct cpu_softc *, int node);
void getcacheinfo_obp(struct cpu_softc *, int node);

void sun4_hotfix(struct cpu_softc *);
void viking_hotfix(struct cpu_softc *);
void turbosparc_hotfix(struct cpu_softc *);
void swift_hotfix(struct cpu_softc *);

void ms1_mmu_enable(void);
void viking_mmu_enable(void);
void swift_mmu_enable(void);
void hypersparc_mmu_enable(void);

void srmmu_get_syncflt(void);
void ms1_get_syncflt(void);
void viking_get_syncflt(void);
void swift_get_syncflt(void);
void turbosparc_get_syncflt(void);
void hypersparc_get_syncflt(void);
void cypress_get_syncflt(void);

int srmmu_get_asyncflt(u_int *, u_int *);
int hypersparc_get_asyncflt(u_int *, u_int *);
int cypress_get_asyncflt(u_int *, u_int *);
int no_asyncflt_regs(u_int *, u_int *);
d494 1
a494 1
void	getidprom(struct idprom *, int size);
@


1.22.2.7
log
@Sync the SMP branch with 3.3
@
text
@a1341 1
int	v8mul;	/* flag whether cpu has hardware mul, div, and rem */
a1368 1
	v8mul = 1;
@


1.22.2.8
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.22.2.7 2003/03/27 23:49:26 niklas Exp $	*/
d98 1
a98 1
char *fsrtoname(int, int, int, char *, size_t);
d226 1
a226 1
			    sc->fpuvers, fpbuf, sizeof fpbuf);
d230 1
a230 1
	snprintf(model, sizeof model, "%s @@ %s MHz, %s FPU", sc->cpu_name,
d233 1
a233 1
	snprintf(cpu_model, sizeof cpu_model, "%s, %s", mainbus_model, model);
d631 1
a631 2
		snprintf(cpu_hotfix, sizeof cpu_hotfix,
		    "cache chip bug - trap page uncached");
d1312 1
a1312 1
fsrtoname(impl, vers, fver, buf, buflen)
a1314 1
	size_t buflen;
d1323 1
a1323 1
	snprintf(buf, buflen, "version 0x%x", fver);
@


1.21
log
@reduce global symbol pollution
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.20 1999/12/09 21:35:29 art Exp $	*/
d74 1
d427 2
a428 1
	noop_pcache_flush_line
d550 2
a551 1
	noop_pcache_flush_line
d745 2
a746 1
	noop_pcache_flush_line
d770 2
a771 1
	noop_pcache_flush_line
d790 2
a791 1
	srmmu_pcache_flush_line
d835 2
a836 1
	viking_pcache_flush_line
d915 2
a916 1
	srmmu_pcache_flush_line
d961 2
a962 1
	srmmu_pcache_flush_line
d981 2
a982 1
	srmmu_pcache_flush_line
d1204 1
@


1.20
log
@Fix a bug we've had for ages.
On some sun4m the pagetables must be uncached. This is indicated by the
CPUFLG_CACHEPAGETABLES in cpuinfo.flags. This was done in pmap_bootstrap4m.
The problem is that the CPUFLG_CACHEPAGETABLES is not set until after
pmap_bootstrap4m, so even the machines that could cache the pagetables
had them uncached, reducing performance.
Fix this by creating pmap_cache_enable that is called just after the
cache has been switched on (XXX - actually, we should call it before, but
CPUFLG_CACHEPAGETABLES can be set in the code that enables the cache).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.19 1999/12/08 23:49:07 deraadt Exp $	*/
d82 3
@


1.19
log
@only replace .mul/.umul on v8 cpus
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.18 1999/07/14 23:15:49 deraadt Exp $	*/
d240 2
d243 8
a250 1
		/* Enable the cache */
d252 2
@


1.18
log
@put sub-class of architecture in SVR4_SI_PLATFORM
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.17 1999/03/03 21:58:28 jason Exp $	*/
d99 1
d350 1
d716 1
a716 1
	0,
d740 1
a740 1
	0,
d759 1
a759 1
	0,
d775 9
d824 2
d905 2
d994 2
d1264 24
@


1.17
log
@pull in some viking stuff from NetBSD; delay use of CPUFLG_CACHEPAGETABLES
if VIKING_PCR_TC isn't set.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.16 1998/10/09 13:12:43 deraadt Exp $	*/
d78 1
d196 15
@


1.16
log
@slight further tweak
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.15 1998/10/09 13:10:46 deraadt Exp $	*/
d788 1
a788 1
	noop_pcache_flush_line
d805 2
d808 1
a808 1
	if (!(lda(SRMMU_PCR, ASI_SRMMU) & VIKING_PCR_MB)) {
d815 4
a818 1
		sc->flags |= CPUFLG_CACHEPAGETABLES;
d838 4
a841 1
	if (cpuinfo.mxcc)
d843 1
a843 1
	else
@


1.15
log
@tweak spacing of cache information printing
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.14 1998/04/17 18:18:04 deraadt Exp $	*/
d322 2
a323 1
	printf(" ");
@


1.14
log
@put arch type into hw.model, sun4 installboot now works; jason
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.13 1998/03/09 09:15:32 deraadt Exp $	*/
d288 1
a288 1
	char *sep;
d290 1
a290 1
	printf("%s:", sc->dv.dv_xname);
a291 1
	sep = " ";
d293 1
a293 1
		printf("%s", (ci->c_physical ? " physical" : ""));
a303 1
		printf(" ");
d306 1
a306 1
		printf(" physical %dK combined cache (%d bytes/line) ",
d308 1
d311 1
a311 1
		printf(" %dK byte write-%s, %d bytes/line, %cw flush ",
d315 1
d319 1
a319 1
		printf(", %dK external (%d b/l)",
d322 1
@


1.13
log
@print hotfix info at end of cpu attach line
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.12 1998/02/26 10:39:01 johns Exp $	*/
d78 1
a78 1
char	cpu_model[100];
d80 1
d172 1
d210 1
a210 1
	sprintf(cpu_model, "%s @@ %s MHz, %s FPU", sc->cpu_name,
d212 3
a214 1
	printf(": %s", cpu_model);
@


1.12
log
@Backout of Jason's cpu init changes, causes an immediate panic on sun4m
machines..
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.10 1997/11/11 10:43:57 niklas Exp $	*/
d79 1
d210 4
a213 1
	printf(": %s\n", cpu_model);
d580 1
a580 1
		printf(": cache chip bug; trap page uncached");
@


1.11
log
@Change order of cpu initialization to force the correct dmesg output.
@
text
@a95 1
void identifycpu __P((void));
a153 12
void
identifycpu()
{
	struct cpu_softc sc;
	struct confargs ca;

	sc.node = 0;
	ca.ca_ra.ra_node = 0;
	strcpy(sc.dv.dv_xname, "cpu0");
	cpu_attach(NULL, (struct device *)&sc, &ca);
}

a184 1
		printf("%s", sc->dv.dv_xname);
@


1.10
log
@Remove thos evil statics, some KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.9 1997/09/17 06:47:16 downsj Exp $	*/
d96 1
d155 12
d198 1
@


1.9
log
@NETBSD_CURRENT_970916.  Lot's just ID changes, since changes don't apply to
us.  Includes some pmap changes, for which I don't have the original commit
message(s) handy.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.8 1997/09/11 20:31:33 deraadt Exp $	*/
d81 1
a81 1
static void cpu_attach __P((struct device *, struct device *, void *));
d92 1
a92 1
static char *fsrtoname __P((int, int, int, char *));
d159 1
a159 1
static void
d203 1
a203 1
					    sc->fpuvers, fpbuf);
d207 2
a208 3
	sprintf(cpu_model, "%s @@ %s MHz, %s FPU",
		sc->cpu_name,
		clockfreq(sc->hz), fpuname);
d269 1
a269 1
		(fpstate.fs_fsr >> FSR_VER_SHIFT) & (FSR_VER >> FSR_VER_SHIFT);
d289 1
a289 1
			       ci->ic_totalsize/1024, ci->ic_linesize);
d294 1
a294 1
			       ci->dc_totalsize/1024, ci->dc_linesize);
d301 1
a301 1
		       ci->c_totalsize/1024, ci->c_linesize);
d305 3
a307 4
		       ci->c_totalsize/1024,
		       (ci->c_vactype == VAC_WRITETHROUGH) ? "through" : "back",
		       ci->c_linesize,
		       ci->c_hwflush ? 'h' : 's');
d312 1
a312 1
		       ci->ec_totalsize/1024, ci->ec_linesize);
d1199 1
a1199 1
static char *
@


1.8
log
@Turn off "branch folding" in microsparc II processors. This seems to
avoid strange panics happening. Patch suggested by Chris Torek.
@
text
@d1 2
a2 2
/*	$OpenBSD: cpu.c,v 1.7 1997/08/08 08:27:10 downsj Exp $	*/
/*	$NetBSD: cpu.c,v 1.52 1997/07/29 09:41:58 fair Exp $ */
d305 2
a306 2
		printf(" %d byte write-%s, %d bytes/line, %cw flush ",
		       ci->c_totalsize,
d462 1
a462 1
/*XXX*/		sc->hz = 0;
d469 1
a469 1
/*XXX*/		sc->hz = 0;
d476 1
a476 1
/*XXX*/		sc->hz = 0;
d484 1
a484 1
/*XXX*/		sc->hz = 0;
d578 1
a578 1
		printf("cache chip bug; trap page uncached ");
d716 1
a716 1
	0,
d849 1
a849 1
	noop_pcache_flush_line
d859 1
d865 1
d873 1
d997 2
a998 1
	{ CPU_SUN4M, 1, 0xf, 1, 1, "RT620/625", &module_hypersparc },
d1171 1
@


1.7
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d336 1
d735 1
a735 1
	0,
d747 11
@


1.6
log
@from 1.2-4, vac is writethrough
@
text
@d1 2
a2 1
/*	$NetBSD: cpu.c,v 1.22.4.1 1996/06/12 20:39:45 pk Exp $ */
d68 3
d73 1
a73 3

/* This is declared here so that you must include a CPU for the cache code. */
struct cacheinfo cacheinfo;
d76 2
a77 1
char	machine[] = "sparc";
d85 1
a85 1
	sizeof(struct device), cpu_match, cpu_attach
a91 3
#if defined(SUN4C) || defined(SUN4M)
static char *psrtoname __P((int, int, int, char *));
#endif
d93 3
d99 1
a99 1
#if defined(SUN4M)
d102 1
a102 1
#endif
d146 1
a146 1
	void *aux, *vcf;
d148 1
a148 1
	struct cfdata *cf = vcf;
d160 1
a160 1
cpu_attach(parent, dev, aux)
d162 1
a162 1
	struct device *dev;
d165 2
a166 2
	register int node, clk, bug = 0, i;
	register int impl, vers, fver;
a168 2
	struct fpstate fpstate;
	char *sep;
d170 77
a246 3
#if defined(SUN4C) || defined(SUN4M)
	register int l;
	char iubuf[40];
d248 7
d259 2
a260 2
	 * will panic in the first loadfpstate(), due to a sequence error,
	 * so we need to dump the whole state anyway.
d265 3
a267 1
	fpstate.fs_fsr = 7 << FSR_VER_SHIFT;	/* 7 is reserved for "none" */
d269 4
a272 5
	fver = (fpstate.fs_fsr >> FSR_VER_SHIFT) & (FSR_VER >> FSR_VER_SHIFT);
	i = getpsr();
	impl = IU_IMPL(i);
	vers = IU_VERS(i);
	if (fver != 7) {
d274 18
a291 43
		fpuname = fsrtoname(impl, vers, fver, fpbuf);
	} else
		fpuname = "no";

	/* tell them what we have */
	node = ca->ca_ra.ra_node;

#ifdef SUN4
	if (CPU_ISSUN4) {
		clk = 0;
		vactype = VAC_WRITEBACK;
		switch (cpumod) {
		case SUN4_100:
			sprintf(cpu_model, "SUN-4/100 series (%s FPU)", fpuname);
			vactype = VAC_NONE;
			cacheinfo.c_totalsize = 0;
			cacheinfo.c_hwflush = 0;
			cacheinfo.c_linesize = 0;
			cacheinfo.c_l2linesize = 0;
			break;
		case SUN4_200:
			sprintf(cpu_model, "SUN-4/200 series (%s FPU)", fpuname);
	        	cacheinfo.c_totalsize = 128*1024;
			cacheinfo.c_hwflush = 0;
			cacheinfo.c_linesize = 16;
			cacheinfo.c_l2linesize = 4;
			break;
		case SUN4_300:
			sprintf(cpu_model, "SUN-4/300 series (%s FPU)", fpuname);
			bug = 1;
			vactype = VAC_WRITETHROUGH;
			cacheinfo.c_totalsize = 128*1024;
			cacheinfo.c_hwflush = 0;
			cacheinfo.c_linesize = 16;
			cacheinfo.c_l2linesize = 4;
			break;
		case SUN4_400:
			sprintf(cpu_model, "SUN-4/400 series (%s FPU)", fpuname);
			cacheinfo.c_totalsize = 128 * 1024;
			cacheinfo.c_hwflush = 0;
			cacheinfo.c_linesize = 32;
			cacheinfo.c_l2linesize = 5;
			break;
d293 147
a439 1
		printf(": %s\n", cpu_model);
d441 48
d491 289
a779 20
#if defined(SUN4C) || defined(SUN4M)
	if (CPU_ISSUN4C || CPU_ISSUN4M) {
		clk = getpropint(node, "clock-frequency", 0);
		if (clk == 0) {
			/*
			 * Try to find it in the OpenPROM root...
			 */
			clk = getpropint(findroot(), "clock-frequency", 0);
		}
		if (CPU_ISSUN4C)
			sprintf(cpu_model, "%s (%s @@ %s MHz, %s FPU)",
				getpropstring(node, "name"),
				psrtoname(impl, vers, fver, iubuf),
				clockfreq(clk), fpuname);
		else
			/* On sun4m, the "name" property identifies CPU */
			sprintf(cpu_model, "%s @@ %s MHz, %s FPU",
				getpropstring(node, "name"),
				clockfreq(clk), fpuname);
		printf(": %s\n", cpu_model);
d781 8
d790 2
a791 2
		 * Fill in the cache info.  Note, vac-hwflush is spelled
		 * with an underscore on 4/75s.
d793 181
a973 1
		/*bzero(&cacheinfo, sizeof(cacheinfo));*/
d975 46
d1022 56
a1077 46
			cacheinfo.c_physical = 1;
			vactype = node_has_property(node, "cache-physical?")
				? VAC_NONE
				: VAC_WRITETHROUGH; /* ??? */
			/*
			 * Sun4m physical caches are nice since we never
			 * have to flush them. Unfortunately it is a pain
			 * to determine what size they are, since they may
			 * be split...
			 */
			switch (mmumod) {
			case SUN4M_MMU_SS:
			case SUN4M_MMU_MS1:
				cacheinfo.c_split = 1;
				cacheinfo.ic_linesize = l =
					getpropint(node, "icache-line-size", 0);
				for (i = 0; (1 << i) < l && l; i++)
					/* void */;
				if ((1 << i) != l && l)
					panic("bad icache line size %d", l);
				cacheinfo.ic_l2linesize = i;
				cacheinfo.ic_totalsize = l *
				    getpropint(node, "icache-nlines", 64) *
				    getpropint(node, "icache-associativity", 1);

				cacheinfo.dc_linesize = l =
					getpropint(node, "dcache-line-size",0);
				for (i = 0; (1 << i) < l && l; i++)
					/* void */;
				if ((1 << i) != l && l)
					panic("bad dcache line size %d", l);
				cacheinfo.dc_l2linesize = i;
				cacheinfo.dc_totalsize = l *
				    getpropint(node, "dcache-nlines", 128) *
				    getpropint(node, "dcache-associativity", 1);

				cacheinfo.ec_linesize = l =
				    getpropint(node, "ecache-line-size", 0);
				for (i = 0; (1 << i) < l && l; i++)
					/* void */;
				if ((1 << i) != l && l)
					panic("bad ecache line size %d", l);
				cacheinfo.ec_l2linesize = i;
				cacheinfo.ec_totalsize = l *
				    getpropint(node, "ecache-nlines", 32768) *
				    getpropint(node, "ecache-associativity", 1);
d1079 14
d1094 4
a1097 33
				 * XXX - The following will have to do until
				 * we have per-cpu cache handling.
				 */
				cacheinfo.c_l2linesize =
					min(cacheinfo.ic_l2linesize,
					    cacheinfo.dc_l2linesize);
				cacheinfo.c_linesize =
					min(cacheinfo.ic_linesize,
					    cacheinfo.dc_linesize);
				cacheinfo.c_totalsize =
					cacheinfo.ic_totalsize +
					cacheinfo.dc_totalsize;
				break;
			case SUN4M_MMU_HS:
				printf("Warning, guessing on HyperSPARC cache...\n");
				cacheinfo.c_split = 0;
				i = lda(SRMMU_PCR, ASI_SRMMU);
				if (i & SRMMU_PCR_CS)
					cacheinfo.c_totalsize = 256 * 1024;
				else
					cacheinfo.c_totalsize = 128 * 1024;
				/* manual says it has 4096 lines */
				cacheinfo.c_linesize = l =
					cacheinfo.c_totalsize / 4096;
				for (i = 0; (1 << i) < l; i++)
					/* void */;
				if ((1 << i) != l)
					panic("bad cache line size %d", l);
				cacheinfo.c_l2linesize = i;
				break;
			default:
				printf("warning: couldn't identify cache\n");
				cacheinfo.c_totalsize = 0;
a1098 17
		} else
#endif	/* SUN4M */
		{
			cacheinfo.c_physical = 0;
			cacheinfo.c_totalsize =
			    getpropint(node, "vac-size", 65536);
			cacheinfo.c_hwflush =
			    getpropint(node, "vac_hwflush", 0) |
				getpropint(node, "vac-hwflush", 0);
			cacheinfo.c_linesize = l =
			    getpropint(node, "vac-linesize", 16);
			for (i = 0; (1 << i) < l; i++)
			    /* void */;
			if ((1 << i) != l)
				panic("bad cache line size %d", l);
			cacheinfo.c_l2linesize = i;
			vactype = VAC_WRITETHROUGH;
d1102 1
a1102 3
		 * Machines with "buserr-type" 1 have a bug in the cache
		 * chip that affects traps.  (I wish I knew more about this
		 * mysterious buserr-type variable....)
d1104 12
a1115 11
		bug = (getpropint(node, "buserr-type", 0) == 1);
	}
#endif /* SUN4C || SUN4M */

	if (bug) {
		kvm_uncache((caddr_t)trapbase, 1);
		printf("%s: cache chip bug; trap page uncached\n",
		    dev->dv_xname);
	}

	if (cacheinfo.c_totalsize == 0)
a1116 36

	if (!cacheinfo.c_physical) {
		printf("%s: %d byte write-%s, %d bytes/line, %cw flush ",
		    dev->dv_xname, cacheinfo.c_totalsize,
		    (vactype == VAC_WRITETHROUGH) ? "through" : "back",
		    cacheinfo.c_linesize,
		    cacheinfo.c_hwflush ? 'h' : 's');
		cache_enable();
	} else {
		sep = " ";
		if (cacheinfo.c_split) {
			printf("%s: physical", dev->dv_xname);
			if (cacheinfo.ic_totalsize > 0) {
				printf("%s%dK instruction (%d b/l)", sep,
				    cacheinfo.ic_totalsize/1024,
				    cacheinfo.ic_linesize);
				    sep = ", ";
			}
			if (cacheinfo.dc_totalsize > 0) {
				printf("%s%dK data (%d b/l)", sep,
				    cacheinfo.dc_totalsize/1024,
				    cacheinfo.dc_linesize);
				    sep = ", ";
			}
			if (cacheinfo.ec_totalsize > 0) {
				printf("%s%dK external (%d b/l)", sep,
				    cacheinfo.ec_totalsize/1024,
				    cacheinfo.ec_linesize);
			}
			printf(" ");
		} else
			printf("%s: physical %dK combined cache (%d bytes/"
				"line) ", dev->dv_xname,
				cacheinfo.c_totalsize/1024,
				cacheinfo.c_linesize);
		cache_enable();
d1118 1
d1131 4
a1134 4
	u_char	valid;
	u_char	iu_impl;
	u_char	iu_vers;
	u_char	fpu_vers;
a1137 37
#define	ANY	0xff	/* match any FPU version (or, later, IU version) */

#if defined(SUN4C) || defined(SUN4M)
static struct info iu_types[] = {
	{ 1, 0x0, 0x4, 4,   "MB86904" },
	{ 1, 0x0, 0x0, ANY, "MB86900/1A or L64801" },
	{ 1, 0x1, 0x0, ANY, "RT601 or L64811 v1" },
	{ 1, 0x1, 0x1, ANY, "RT601 or L64811 v2" },
	{ 1, 0x1, 0x3, ANY, "RT611" },
	{ 1, 0x1, 0xf, ANY, "RT620" },
	{ 1, 0x2, 0x0, ANY, "B5010" },
	{ 1, 0x4, 0x0,   0, "TMS390Z50 v0 or TMS390Z55" },
	{ 1, 0x4, 0x1,   0, "TMS390Z50 v1" },
	{ 1, 0x4, 0x1,   4, "TMS390S10" },
	{ 1, 0x5, 0x0, ANY, "MN10501" },
	{ 1, 0x9, 0x0, ANY, "W8601/8701 or MB86903" },
	{ 0 }
};

static char *
psrtoname(impl, vers, fver, buf)
	register int impl, vers, fver;
	char *buf;
{
	register struct info *p;

	for (p = iu_types; p->valid; p++)
		if (p->iu_impl == impl && p->iu_vers == vers &&
		    (p->fpu_vers == fver || p->fpu_vers == ANY))
			return (p->name);

	/* Not found. */
	sprintf(buf, "IU impl 0x%x vers 0x%x", impl, vers);
	return (buf);
}
#endif /* SUN4C || SUN4M */

d1148 1
d1196 1
a1196 1
	sprintf(buf, "version %x", fver);
@


1.5
log
@netbsd port, now we merge our changes back in
@
text
@d221 2
a222 1
	        	cacheinfo.c_totalsize = 128*1024;
@


1.4
log
@4/300 cache really is write through but has a slight bug.
@
text
@d1 1
a1 1
/*	$NetBSD: cpu.c,v 1.14 1995/02/01 12:37:52 pk Exp $ */
d4 2
d15 1
d22 1
d30 2
d51 1
d55 1
d58 2
d63 1
d65 1
d68 1
d81 7
a87 2
struct cfdriver cpucd =
    { NULL, "cpu", cpu_match, cpu_attach, DV_CPU, sizeof(struct device) };
d89 1
d91 1
d96 4
d128 1
a128 1
 *	this confuses autoconf.  for example, if you try and map 
d162 1
a162 1
	register int node, clk, bug = 0, i, l;
d167 6
a172 1
	char iubuf[40], fpbuf[40];
d197 1
d199 1
a199 1
	if (cputyp == CPU_SUN4) {
a220 1
			vactype = VAC_WRITETHROUGH;
d236 2
a237 1
#endif
d239 1
a239 1
	if (cputyp == CPU_SUN4C || cputyp == CPU_SUN4M) {
d241 16
a256 3
		sprintf(cpu_model, "%s (%s @@ %s MHz, %s FPU)",
		    getpropstring(node, "name"),
		    psrtoname(impl, vers, fver, iubuf), clockfreq(clk), fpuname);
d263 103
a365 10
		cacheinfo.c_totalsize = getpropint(node, "vac-size", 65536);
		cacheinfo.c_hwflush = getpropint(node, "vac_hwflush", 0) |
		    getpropint(node, "vac-hwflush", 0);
		cacheinfo.c_linesize = l = getpropint(node, "vac-linesize", 16);
		for (i = 0; (1 << i) < l; i++)
			/* void */;
		if ((1 << i) != l)
			panic("bad cache line size %d", l);
		cacheinfo.c_l2linesize = i;
		vactype = VAC_WRITETHROUGH;
d375 1
d382 4
a385 1
	if (cacheinfo.c_totalsize) {
d392 28
a430 2
 * NOTE: we have Sun-4m cpu types here, even though this only runs on the
 * Sun-4c (yet)...
d442 1
d444 1
d451 1
a451 1
	{ 1, 0x4, 0x0,   0, "TMS390Z50 v0" },
d475 1
d486 1
d531 2
a532 2
		    (p->iu_vers == vers || p->iu_vers == ANY) &
		    p->fpu_vers == fver)
@


1.3
log
@XXX is 4/300 really write-through?
@
text
@d191 1
@


1.2
log
@4/300 cache is writethrough; but... it fails to update pte's in the cache
problem reported by chuck cranor
@
text
@a190 1
			vactype = VAC_WRITETHROUGH;
@


1.1
log
@Initial revision
@
text
@d191 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

