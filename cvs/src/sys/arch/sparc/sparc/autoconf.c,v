head	1.102;
access;
symbols
	OPENBSD_6_0:1.102.0.2
	OPENBSD_6_0_BASE:1.102
	OPENBSD_5_9:1.101.0.2
	OPENBSD_5_9_BASE:1.101
	OPENBSD_5_8:1.100.0.4
	OPENBSD_5_8_BASE:1.100
	OPENBSD_5_7:1.97.0.2
	OPENBSD_5_7_BASE:1.97
	OPENBSD_5_6:1.95.0.4
	OPENBSD_5_6_BASE:1.95
	OPENBSD_5_5:1.93.0.16
	OPENBSD_5_5_BASE:1.93
	OPENBSD_5_4:1.93.0.12
	OPENBSD_5_4_BASE:1.93
	OPENBSD_5_3:1.93.0.10
	OPENBSD_5_3_BASE:1.93
	OPENBSD_5_2:1.93.0.8
	OPENBSD_5_2_BASE:1.93
	OPENBSD_5_1_BASE:1.93
	OPENBSD_5_1:1.93.0.6
	OPENBSD_5_0:1.93.0.4
	OPENBSD_5_0_BASE:1.93
	OPENBSD_4_9:1.93.0.2
	OPENBSD_4_9_BASE:1.93
	OPENBSD_4_8:1.92.0.2
	OPENBSD_4_8_BASE:1.92
	OPENBSD_4_7:1.83.0.2
	OPENBSD_4_7_BASE:1.83
	OPENBSD_4_6:1.82.0.8
	OPENBSD_4_6_BASE:1.82
	OPENBSD_4_5:1.82.0.4
	OPENBSD_4_5_BASE:1.82
	OPENBSD_4_4:1.82.0.2
	OPENBSD_4_4_BASE:1.82
	OPENBSD_4_3:1.80.0.4
	OPENBSD_4_3_BASE:1.80
	OPENBSD_4_2:1.80.0.2
	OPENBSD_4_2_BASE:1.80
	OPENBSD_4_1:1.74.0.2
	OPENBSD_4_1_BASE:1.74
	OPENBSD_4_0:1.73.0.2
	OPENBSD_4_0_BASE:1.73
	OPENBSD_3_9:1.71.0.2
	OPENBSD_3_9_BASE:1.71
	OPENBSD_3_8:1.67.0.2
	OPENBSD_3_8_BASE:1.67
	OPENBSD_3_7:1.62.0.2
	OPENBSD_3_7_BASE:1.62
	OPENBSD_3_6:1.59.0.6
	OPENBSD_3_6_BASE:1.59
	SMP_SYNC_A:1.59
	SMP_SYNC_B:1.59
	OPENBSD_3_5:1.59.0.4
	OPENBSD_3_5_BASE:1.59
	OPENBSD_3_4:1.59.0.2
	OPENBSD_3_4_BASE:1.59
	UBC_SYNC_A:1.57
	OPENBSD_3_3:1.55.0.2
	OPENBSD_3_3_BASE:1.55
	OPENBSD_3_2:1.54.0.2
	OPENBSD_3_2_BASE:1.54
	OPENBSD_3_1:1.51.0.2
	OPENBSD_3_1_BASE:1.51
	UBC_SYNC_B:1.54
	UBC:1.46.0.2
	UBC_BASE:1.46
	OPENBSD_3_0:1.41.0.2
	OPENBSD_3_0_BASE:1.41
	OPENBSD_2_9_BASE:1.37
	OPENBSD_2_9:1.37.0.2
	OPENBSD_2_8:1.36.0.2
	OPENBSD_2_8_BASE:1.36
	OPENBSD_2_7:1.34.0.2
	OPENBSD_2_7_BASE:1.34
	SMP:1.33.0.2
	SMP_BASE:1.33
	kame_19991208:1.32
	OPENBSD_2_6:1.31.0.2
	OPENBSD_2_6_BASE:1.31
	OPENBSD_2_5:1.30.0.2
	OPENBSD_2_5_BASE:1.30
	OPENBSD_2_4:1.28.0.4
	OPENBSD_2_4_BASE:1.28
	OPENBSD_2_3:1.28.0.2
	OPENBSD_2_3_BASE:1.28
	OPENBSD_2_2:1.22.0.2
	OPENBSD_2_2_BASE:1.22
	OPENBSD_2_1:1.20.0.2
	OPENBSD_2_1_BASE:1.20
	OPENBSD_2_0:1.13.0.2
	OPENBSD_2_0_BASE:1.13
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.102
date	2016.06.08.17.24.44;	author tedu;	state Exp;
branches;
next	1.101;
commitid	oK6mhkiIMNMJ6OsK;

1.101
date	2015.09.18.12.50.28;	author miod;	state Exp;
branches;
next	1.100;
commitid	aBaVLnMs8wxyaAGJ;

1.100
date	2015.03.30.20.30.22;	author miod;	state Exp;
branches;
next	1.99;
commitid	f66FukLLgPJs9j5H;

1.99
date	2015.03.27.20.25.39;	author miod;	state Exp;
branches;
next	1.98;
commitid	DNjbblqLgBZmk6yi;

1.98
date	2015.03.18.20.56.40;	author miod;	state Exp;
branches;
next	1.97;
commitid	1t8JWNihm6Vc4kyS;

1.97
date	2014.11.22.22.48.38;	author miod;	state Exp;
branches;
next	1.96;
commitid	lw1qpLaP6fJz4gKy;

1.96
date	2014.11.16.12.30.58;	author deraadt;	state Exp;
branches;
next	1.95;
commitid	yv0ECmCdICvq576h;

1.95
date	2014.07.12.18.44.43;	author tedu;	state Exp;
branches;
next	1.94;
commitid	uKVPYMN2MLxdZxzH;

1.94
date	2014.05.09.20.15.06;	author miod;	state Exp;
branches;
next	1.93;

1.93
date	2010.11.18.21.13.19;	author miod;	state Exp;
branches;
next	1.92;

1.92
date	2010.07.10.19.32.24;	author miod;	state Exp;
branches;
next	1.91;

1.91
date	2010.07.06.20.40.01;	author miod;	state Exp;
branches;
next	1.90;

1.90
date	2010.07.01.03.20.38;	author matthew;	state Exp;
branches;
next	1.89;

1.89
date	2010.06.29.21.28.10;	author miod;	state Exp;
branches;
next	1.88;

1.88
date	2010.06.27.05.52.01;	author beck;	state Exp;
branches;
next	1.87;

1.87
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.86;

1.86
date	2010.06.22.16.27.45;	author miod;	state Exp;
branches;
next	1.85;

1.85
date	2010.06.07.19.54.33;	author miod;	state Exp;
branches;
next	1.84;

1.84
date	2010.04.21.03.03.26;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	2009.10.26.20.17.27;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2008.07.21.04.35.54;	author todd;	state Exp;
branches;
next	1.81;

1.81
date	2008.03.23.17.05.41;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2007.06.01.19.25.10;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2007.05.29.09.53.54;	author sobrado;	state Exp;
branches;
next	1.78;

1.78
date	2007.05.04.19.30.55;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2007.05.04.03.44.44;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2007.04.30.18.37.00;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2007.04.30.18.11.03;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.73;

1.73
date	2006.07.24.18.27.36;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2006.03.15.20.07.28;	author miod;	state Exp;
branches;
next	1.71;

1.71
date	2006.02.06.17.19.31;	author jmc;	state Exp;
branches;
next	1.70;

1.70
date	2005.12.27.18.31.10;	author miod;	state Exp;
branches;
next	1.69;

1.69
date	2005.09.25.20.05.37;	author miod;	state Exp;
branches;
next	1.68;

1.68
date	2005.09.12.23.05.05;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2005.05.01.18.15.46;	author miod;	state Exp;
branches;
next	1.66;

1.66
date	2005.04.21.00.15.43;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2005.04.11.01.50.07;	author miod;	state Exp;
branches;
next	1.64;

1.64
date	2005.03.23.17.10.24;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2005.03.21.22.41.30;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2005.03.15.18.47.44;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2005.03.15.18.46.37;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2004.12.25.23.02.25;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2003.06.23.09.23.31;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.02.23.27.55;	author millert;	state Exp;
branches;
next	1.57;

1.57
date	2003.05.13.22.25.33;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2003.04.06.18.54.19;	author ho;	state Exp;
branches;
next	1.55;

1.55
date	2003.01.22.19.01.19;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2002.09.03.23.20.42;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2002.08.12.10.44.04;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2002.04.26.17.08.36;	author art;	state Exp;
branches;
next	1.51;

1.51
date	2002.04.11.05.40.51;	author jason;	state Exp;
branches;
next	1.50;

1.50
date	2002.03.14.03.16.00;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2002.02.15.20.45.30;	author nordin;	state Exp;
branches;
next	1.47;

1.47
date	2002.01.16.20.50.17;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2001.12.10.00.58.04;	author miod;	state Exp;
branches
	1.46.2.1;
next	1.45;

1.45
date	2001.12.08.02.24.07;	author art;	state Exp;
branches;
next	1.44;

1.44
date	2001.12.05.23.58.41;	author tdeval;	state Exp;
branches;
next	1.43;

1.43
date	2001.11.22.09.45.42;	author art;	state Exp;
branches;
next	1.42;

1.42
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2001.09.19.21.32.19;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2001.07.25.13.25.33;	author art;	state Exp;
branches;
next	1.39;

1.39
date	2001.05.05.22.34.18;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2001.04.30.16.42.25;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2001.01.29.03.59.05;	author jason;	state Exp;
branches;
next	1.36;

1.36
date	2000.07.25.18.03.03;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2000.07.14.20.27.32;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2000.02.22.19.27.59;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	99.12.08.23.49.07;	author deraadt;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	99.12.07.00.49.07;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	99.09.03.18.01.57;	author art;	state Exp;
branches;
next	1.30;

1.30
date	99.03.17.22.56.24;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	99.01.11.05.11.58;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	98.04.17.18.18.02;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	98.03.25.07.54.57;	author jason;	state Exp;
branches;
next	1.26;

1.26
date	98.03.09.09.15.28;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	98.02.26.10.38.58;	author johns;	state Exp;
branches;
next	1.24;

1.24
date	98.02.26.08.00.14;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	97.11.11.10.24.07;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	97.08.08.08.27.01;	author downsj;	state Exp;
branches;
next	1.21;

1.21
date	97.05.30.08.27.55;	author grr;	state Exp;
branches;
next	1.20;

1.20
date	97.05.22.07.30.57;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.05.14.22.05.56;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.05.14.01.23.58;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.04.20.09.02.18;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.04.01.21.00.21;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	96.11.23.21.46.20;	author kstailey;	state Exp;
branches;
next	1.14;

1.14
date	96.11.06.01.37.40;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.08.11.05.35.01;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	95.12.30.09.24.32;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	95.12.15.13.49.18;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	95.11.18.01.05.45;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	95.11.14.13.28.13;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	95.11.14.13.26.25;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	95.11.13.03.50.45;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	95.10.27.21.27.42;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	95.10.27.15.24.34;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.10.22.06.52.27;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.10.21.14.09.35;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.21.13.38.32;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.45;	author deraadt;	state Exp;
branches;
next	;

1.33.2.1
date	2000.03.02.07.04.33;	author niklas;	state Exp;
branches;
next	1.33.2.2;

1.33.2.2
date	2001.05.14.21.37.14;	author niklas;	state Exp;
branches;
next	1.33.2.3;

1.33.2.3
date	2001.07.04.10.23.35;	author niklas;	state Exp;
branches;
next	1.33.2.4;

1.33.2.4
date	2001.10.31.03.07.57;	author nate;	state Exp;
branches;
next	1.33.2.5;

1.33.2.5
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.33.2.6;

1.33.2.6
date	2001.12.05.00.39.13;	author niklas;	state Exp;
branches;
next	1.33.2.7;

1.33.2.7
date	2002.03.06.02.04.46;	author niklas;	state Exp;
branches;
next	1.33.2.8;

1.33.2.8
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.33.2.9;

1.33.2.9
date	2003.03.27.23.49.26;	author niklas;	state Exp;
branches;
next	1.33.2.10;

1.33.2.10
date	2003.05.13.19.41.08;	author ho;	state Exp;
branches;
next	1.33.2.11;

1.33.2.11
date	2003.05.16.00.29.40;	author niklas;	state Exp;
branches;
next	1.33.2.12;

1.33.2.12
date	2003.06.07.11.14.44;	author ho;	state Exp;
branches;
next	1.33.2.13;

1.33.2.13
date	2004.02.19.10.49.58;	author niklas;	state Exp;
branches;
next	;

1.46.2.1
date	2002.01.31.22.55.22;	author niklas;	state Exp;
branches;
next	1.46.2.2;

1.46.2.2
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	1.46.2.3;

1.46.2.3
date	2002.10.29.00.28.10;	author art;	state Exp;
branches;
next	1.46.2.4;

1.46.2.4
date	2003.05.19.21.46.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.102
log
@remove obsolete raid from namtoblk tables. from Artturi Alm
@
text
@/*	$OpenBSD: autoconf.c,v 1.101 2015/09/18 12:50:28 miod Exp $	*/
/*	$NetBSD: autoconf.c,v 1.73 1997/07/29 09:41:53 fair Exp $ */

/*
 * Copyright (c) 1996
 *    The President and Fellows of Harvard College. All rights reserved.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by Harvard University.
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)autoconf.c	8.4 (Berkeley) 10/1/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/disklabel.h>
#include <sys/device.h>
#include <sys/disk.h>
#include <sys/conf.h>
#include <sys/reboot.h>
#include <sys/socket.h>
#include <sys/malloc.h>
#include <sys/queue.h>
#include <sys/proc.h>
#include <sys/user.h>

#include <net/if.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/cons.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/bsd_openprom.h>
#ifdef SUN4
#include <machine/oldmon.h>
#include <machine/idprom.h>
#include <sparc/sparc/memreg.h>
#endif
#include <machine/cpu.h>
#include <machine/ctlreg.h>
#include <machine/pmap.h>
#include <sparc/sparc/asm.h>
#include <sparc/sparc/cpuvar.h>
#include <sparc/sparc/timerreg.h>

#ifdef DDB
#include <machine/db_machdep.h>
#include <ddb/db_sym.h>
#include <ddb/db_extern.h>
#endif


/*
 * The following several variables are related to
 * the configuration process, and are used in initializing
 * the machine.
 */
int	fbnode;		/* node ID of ROM's console frame buffer */
int	optionsnode;	/* node ID of ROM's options */
int	mmu_3l;		/* SUN4_400 models have a 3-level MMU */

#ifdef KGDB
extern	int kgdb_debug_panic;
#endif

static	int rootnode;
static	char *str2hex(char *, int *);
static	int mbprint(void *, const char *);
static	void crazymap(char *, int *);
void	sync_crash(void);
int	mainbus_match(struct device *, void *, void *);
static	void mainbus_attach(struct device *, struct device *, void *);

struct	bootpath bootpath[8];
int	nbootpath;
static	void bootpath_build(void);
static	void bootpath_fake(struct bootpath *, char *);
static	void bootpath_print(struct bootpath *);
int	search_prom(int, char *);
char	mainbus_model[30];

/* Translate SBus interrupt level to processor IPL */
int	intr_sbus2ipl_4c[] = {
	0, 1, 2, 3, 5, 7, 8, 9
};
int	intr_sbus2ipl_4m[] = {
	0, 2, 3, 5, 7, 9, 11, 13
};

/*
 * Convert hex ASCII string to a value.  Returns updated pointer.
 * Depends on ASCII order (this *is* machine-dependent code, you know).
 */
static char *
str2hex(str, vp)
	register char *str;
	register int *vp;
{
	register int v, c;

	for (v = 0;; v = v * 16 + c, str++) {
		c = *(u_char *)str;
		if (c <= '9') {
			if ((c -= '0') < 0)
				break;
		} else if (c <= 'F') {
			if ((c -= 'A' - 10) < 10)
				break;
		} else if (c <= 'f') {
			if ((c -= 'a' - 10) < 10)
				break;
		} else
			break;
	}
	*vp = v;
	return (str);
}

#ifdef SUN4
struct promvec promvecdat;
struct om_vector *oldpvec = (struct om_vector *)PROM_BASE;
#endif

#if (defined(SUN4) || defined(SUN4C) || defined(SUN4E)) && \
    (defined(SUN4D) || defined(SUN4M))
vaddr_t vm_kernel_space_size;
#endif

/*
 * locore.s code calls bootstrap() just before calling main(), after double
 * mapping the kernel to high memory and setting up the trap base register.
 * We must finish mapping the kernel properly and glean any bootstrap info.
 */
void
bootstrap()
{
#if defined(SUN4C) || defined(SUN4E)
	/*
	 * If we are running on a sun4e system, we need to differentiate it
	 * from sun4c now. Note that we can't use CPU_ISSUN4C here because
	 * it might have been optimized depending upon the kernel
	 * configuration.
	 */
	if (cputyp == CPU_SUN4C) {
		char tmpstr[24];
		u_long pgsiz;

		pgsiz = 0;
		snprintf(tmpstr, sizeof tmpstr, "pagesize %lx l!",
		    (u_long)&pgsiz);
		rominterpret(tmpstr);
		if (pgsiz == 1 << SUN4_PGSHIFT) {
#if defined(SUN4E)
			extern int nbpg, pgofset;

			cputyp = CPU_SUN4E;
			nbpg = 1 << SUN4_PGSHIFT;
			pgofset = nbpg - 1;
#else
			printf("OpenBSD/sparc: this kernel does not support the sun4e\n");
			romhalt();
#endif
		} else {
#if defined(SUN4C)
			/* cputyp, nbpg and pgofset already set in locore */
#else
			printf("OpenBSD/sparc: this kernel does not support the sun4c\n");
			romhalt();
#endif
		}
	}
#endif

#if defined(SUN4)
	if (CPU_ISSUN4) {
		extern void oldmon_w_cmd(u_long, char *);

		/*
		 * XXX:
		 * The promvec is bogus. We need to build a
		 * fake one from scratch as soon as possible.
		 */
		bzero(&promvecdat, sizeof promvecdat);
		promvec = &promvecdat;

		promvec->pv_stdin = oldpvec->inSource;
		promvec->pv_stdout = oldpvec->outSink;
		promvec->pv_putchar = oldpvec->putChar;
		promvec->pv_putstr = oldpvec->fbWriteStr;
		promvec->pv_nbgetchar = oldpvec->mayGet;
		promvec->pv_getchar = oldpvec->getChar;
		promvec->pv_romvec_vers = 0;		/* eek! */
		promvec->pv_reboot = oldpvec->reBoot;
		promvec->pv_abort = oldpvec->abortEntry;
		promvec->pv_setctxt = oldpvec->setcxsegmap;
		promvec->pv_v0bootargs = (struct v0bootargs **)(oldpvec->bootParam);
		promvec->pv_halt = oldpvec->exitToMon;

		/*
		 * Discover parts of the machine memory organization
		 * that we need this early.
		 */
		if (oldpvec->romvecVersion >= 2)
			*oldpvec->vector_cmd = oldmon_w_cmd;
	}
#endif /* SUN4 */

	/*
	 * Decide upon which address space partition to use if it could not
	 * be decided at compile-time (i.e. for GENERIC kernels supporting
	 * both the old Sun MMU and the SRMMU).
	 */
#if (defined(SUN4) || defined(SUN4C) || defined(SUN4E)) && \
    (defined(SUN4D) || defined(SUN4M))
	if (CPU_ISSUN4OR4COR4E)
		vm_min_kernel_address = VM_MIN_KERNEL_ADDRESS_SUN4;
	else
		vm_min_kernel_address = VM_MIN_KERNEL_ADDRESS_SRMMU;
	vm_kernel_space_size = VM_MAX_KERNEL_ADDRESS - vm_min_kernel_address;
#endif

	bzero(&cpuinfo, sizeof(struct cpu_softc));
	cpuinfo.master = 1;
	getcpuinfo(&cpuinfo, 0);

	pmap_bootstrap(cpuinfo.mmu_ncontext,
		       cpuinfo.mmu_nregion,
		       cpuinfo.mmu_nsegment);
	/* Moved zs_kgdb_init() to zs.c:consinit() */
#ifdef DDB
	db_machine_init();
	ddb_init();
#endif

	/*
	 * On sun4ms we have to do some nasty stuff here. We need to map
	 * in the interrupt registers (since we need to find out where
	 * they are from the PROM, since they aren't in a fixed place), and
	 * disable all interrupts. We can't do this easily from locore
	 * since the PROM is ugly to use from assembly. We also need to map
	 * in the counter registers because we can't disable the level 14
	 * (statclock) interrupt, so we need a handler early on (ugh).
	 *
	 * NOTE: We *demand* the psl to stay at splhigh() at least until
	 * we get here. The system _cannot_ take interrupts until we map
	 * the interrupt registers.
	 */

#if defined(SUN4M)
#define getpte4m(va)	lda(((va) & 0xFFFFF000) | ASI_SRMMUFP_L3, ASI_SRMMUFP)

	/* First we'll do the interrupt registers */
	if (CPU_ISSUN4M) {
		register int node;
		struct romaux ra;
		register u_int pte;
		register int i;
		extern void setpte4m(u_int, u_int);
		extern struct timer_4m *timerreg_4m;
		extern struct counter_4m *counterreg_4m;

		if ((node = opennode("/obio/interrupt")) == 0)
		    if ((node=search_prom(findroot(),"interrupt"))==0)
			panic("bootstrap: could not get interrupt "
			      "node from prom");

		if (!romprop(&ra, "interrupt", node))
		    panic("bootstrap: could not get interrupt properties");
		if (ra.ra_nvaddrs < 2)
		    panic("bootstrap: less than 2 interrupt regs. available");
		if (ra.ra_nvaddrs > 5)
		    panic("bootstrap: cannot support capability of > 4 CPUs");

		for (i = 0; i < ra.ra_nvaddrs - 1; i++) {

			pte = getpte4m((u_int)ra.ra_vaddrs[i]);
			if ((pte & SRMMU_TETYPE) != SRMMU_TEPTE)
			    panic("bootstrap: PROM has invalid mapping for "
				  "processor interrupt register %d",i);
			pte |= PPROT_S;

			/* Duplicate existing mapping */

			setpte4m(PI_INTR_VA + (_MAXNBPG * i), pte);
		}

		/*
		 * That was the processor register...now get system register;
		 * it is the last returned by the PROM
		 */
		pte = getpte4m((u_int)ra.ra_vaddrs[i]);
		if ((pte & SRMMU_TETYPE) != SRMMU_TEPTE)
		    panic("bootstrap: PROM has invalid mapping for system "
			  "interrupt register");
		pte |= PPROT_S;

		setpte4m(SI_INTR_VA, pte);

		/* Now disable interrupts */
		intreg_set_4m(SINTR_MA);

		/* Send all interrupts to primary processor */
		*((u_int *)ICR_ITR) = 0;

#ifdef DEBUG
/*		printf("SINTR: mask: 0x%x, pend: 0x%x\n", *(int *)ICR_SI_MASK,
		       *(int *)ICR_SI_PEND);
*/
#endif

		/*
		 * Now map in the counters
		 * (XXX: fix for multiple CPUs! We assume 1)
		 * The processor register is the first; the system is the last.
		 * See also timerattach() in clock.c.
		 * This shouldn't be necessary; we ought to keep interrupts off
		 * and/or disable the (level 14) counter...
		 */

		if ((node = opennode("/obio/counter")) == 0)
		    if ((node=search_prom(findroot(),"counter"))==0)
			panic("bootstrap: could not find counter in OPENPROM");

		if (!romprop(&ra, "counter", node))
			panic("bootstrap: could not find counter properties");

		counterreg_4m = (struct counter_4m *)ra.ra_vaddrs[0];
		timerreg_4m = (struct timer_4m *)ra.ra_vaddrs[ra.ra_nvaddrs-1];
	}
#endif /* SUN4M */

#if defined(SUN4) || defined(SUN4C) || defined(SUN4E)
	if (CPU_ISSUN4OR4COR4E) {
		/* Map Interrupt Enable Register */
		/*
		 * XXX on non-Sun4, we ought to get the address from
		 * XXX the `interrupt-enable' node.
		 */
		pmap_kenter_pa(INTRREG_VA, PMAP_NC | PMAP_OBIO |
		    (CPU_ISSUN4E ? INT_ENABLE_REG_PHYSADR_4E :
		     INT_ENABLE_REG_PHYSADR_44C), PROT_READ | PROT_WRITE);
		pmap_update(pmap_kernel());
		/* Disable all interrupts */
		*((unsigned char *)INTRREG_VA) = 0;
	}
#endif
}

/*
 * bootpath_build: build a bootpath. Used when booting a generic
 * kernel to find our root device.  Newer proms give us a bootpath,
 * for older proms we have to create one.  An element in a bootpath
 * has 4 fields: name (device name), val[0], val[1], and val[2]. Note that:
 * Interpretation of val[] is device-dependent. Some examples:
 *
 * if (val[0] == -1) {
 *	val[1] is a unit number    (happens most often with old proms)
 * } else {
 *	[sbus device] val[0] is a sbus slot, and val[1] is an sbus offset
 *	[scsi disk] val[0] is target, val[1] is lun, val[2] is partition
 *	[scsi tape] val[0] is target, val[1] is lun, val[2] is file #
 * }
 *
 */

static void
bootpath_build()
{
	register char *cp, *pp;
	register struct bootpath *bp;

	/*
	 * On SS1s, promvec->pv_v0bootargs->ba_argv[1] contains the flags
	 * that were given after the boot command.  On SS2s, pv_v0bootargs
	 * is NULL but *promvec->pv_v2bootargs.v2_bootargs points to
	 * "vmunix -s" or whatever.
	 * XXX	DO THIS BEFORE pmap_bootstrap?
	 */
	bzero(bootpath, sizeof(bootpath));
	bp = bootpath;
	if (promvec->pv_romvec_vers < 2) {
		/*
		 * Grab boot device name and values.  build fake bootpath.
		 */
		cp = (*promvec->pv_v0bootargs)->ba_argv[0];

		if (cp != NULL)
			bootpath_fake(bp, cp);

		/* Setup pointer to boot flags */
		cp = (*promvec->pv_v0bootargs)->ba_argv[1];
		if (cp == NULL || *cp != '-')
			return;
	} else {
		/*
		 * Grab boot path from PROM
		 */
		cp = *promvec->pv_v2bootargs.v2_bootpath;
		while (cp != NULL && *cp == '/') {
			/* Step over '/' */
			++cp;
			/* Extract name */
			pp = bp->name;
			while (*cp != '@@' && *cp != '/' && *cp != '\0')
				*pp++ = *cp++;
			*pp = '\0';
			if (*cp == '@@') {
				cp = str2hex(++cp, &bp->val[0]);
				if (*cp == ',')
					cp = str2hex(++cp, &bp->val[1]);
				if (*cp == ':') {
					/*
					 * We only store one character here,
					 * as we will only use this field
					 * to compute a partition index
					 * for block devices.  However, it
					 * might be an ethernet media
					 * specification, so be sure to
					 * skip all letters.
					 */
					bp->val[2] = *++cp - 'a';
					while (*cp != '\0' && *cp != '/')
						cp++;
				}
			} else {
				bp->val[0] = -1; /* no #'s: assume unit 0, no
							sbus offset/address */
			}
			++bp;
			++nbootpath;
		}
		bp->name[0] = 0;

		/* Setup pointer to boot flags */
		cp = *promvec->pv_v2bootargs.v2_bootargs;
		if (cp == NULL)
			return;
		while (*cp != '-')
			if (*cp++ == '\0')
				return;
	}
	for (;;) {
		switch (*++cp) {

		case '\0':
			return;

		case 'a':
			boothowto |= RB_ASKNAME;
			break;

		case 'c':
			boothowto |= RB_CONFIG;
			break;

		case 'd':	/* kgdb - always on zs	XXX */
#ifdef KGDB
			boothowto |= RB_KDB;	/* XXX unused */
			kgdb_debug_panic = 1;
			kgdb_connect(1);
#elif DDB
			Debugger();
#else
			printf("kernel has no debugger\n");
#endif
			break;

		case 's':
			boothowto |= RB_SINGLE;
			break;
		}
	}
}

/*
 * Fake a ROM generated bootpath.
 * The argument `cp' points to a string such as "xd(0,0,0)bsd"
 */

static void
bootpath_fake(bp, cp)
	struct bootpath *bp;
	char *cp;
{
	register char *pp;
	int v0val[3];

#define BP_APPEND(BP,N,V0,V1,V2) { \
	strlcpy((BP)->name, N, sizeof (BP)->name); \
	(BP)->val[0] = (V0); \
	(BP)->val[1] = (V1); \
	(BP)->val[2] = (V2); \
	(BP)++; \
	nbootpath++; \
}

	pp = cp + 2;
	v0val[0] = v0val[1] = v0val[2] = 0;
	if (*pp == '(' 					/* for vi: ) */
 	    && *(pp = str2hex(++pp, &v0val[0])) == ','
	    && *(pp = str2hex(++pp, &v0val[1])) == ',')
		(void)str2hex(++pp, &v0val[2]);

#if defined(SUN4)
	if (CPU_ISSUN4) {
		char tmpname[8];

		/*
		 *  xylogics VME dev: xd, xy, xt
		 *  fake looks like: /vmel0/xdc0/xd@@1,0
		 */
		if (cp[0] == 'x') {
			if (cp[1] == 'd') {/* xd? */
				BP_APPEND(bp, "vmel", -1, 0, 0);
			} else {
				BP_APPEND(bp, "vmes", -1, 0, 0);
			}
			snprintf(tmpname,sizeof tmpname,"x%cc", cp[1]); /* e.g. xdc */
			BP_APPEND(bp, tmpname,-1, v0val[0], 0);
			snprintf(tmpname,sizeof tmpname,"%c%c", cp[0], cp[1]);
			BP_APPEND(bp, tmpname,v0val[1], v0val[2], 0); /* e.g. xd */
			return;
		}

		/*
		 * ethernet: ie, le (rom supports only obio?)
		 * fake looks like: /obio0/le0
		 */
		if ((cp[0] == 'i' || cp[0] == 'l') && cp[1] == 'e')  {
			BP_APPEND(bp, "obio", -1, 0, 0);
			snprintf(tmpname,sizeof tmpname,"%c%c", cp[0], cp[1]);
			BP_APPEND(bp, tmpname, -1, 0, 0);
			return;
		}

		/*
		 * scsi: sd, st, sr
		 * assume: 4/100 = sw: /obio0/sw0/sd@@0,0:a
		 * 4/200 & 4/400 = si/sc: /vmes0/si0/sd@@0,0:a
 		 * 4/300 = esp: /obio0/esp0/sd@@0,0:a
		 * (note we expect sc to mimic an si...)
		 */
		if (cp[0] == 's' &&
			(cp[1] == 'd' || cp[1] == 't' || cp[1] == 'r')) {

			int  target, lun;

			switch (cpuinfo.cpu_type) {
			case CPUTYP_4_200:
			case CPUTYP_4_400:
				BP_APPEND(bp, "vmes", -1, 0, 0);
				BP_APPEND(bp, "si", -1, v0val[0], 0);
				break;
			case CPUTYP_4_100:
				BP_APPEND(bp, "obio", -1, 0, 0);
				BP_APPEND(bp, "sw", -1, v0val[0], 0);
				break;
			case CPUTYP_4_300:
				BP_APPEND(bp, "obio", -1, 0, 0);
				BP_APPEND(bp, "esp", -1, v0val[0], 0);
				break;
			default:
				panic("bootpath_fake: unknown system type %d",
				      cpuinfo.cpu_type);
			}
			/*
			 * Deal with target/lun encodings.
			 * Note: more special casing in device_register().
			 */
			if (oldpvec->monId[0] > '1') {
				target = v0val[1] >> 3; /* new format */
				lun    = v0val[1] & 0x7;
			} else {
				target = v0val[1] >> 2; /* old format */
				lun    = v0val[1] & 0x3;
			}
			snprintf(tmpname, sizeof tmpname, "%c%c", cp[0], cp[1]);
			BP_APPEND(bp, tmpname, target, lun, v0val[2]);
			return;
		}

		return; /* didn't grok bootpath, no change */
	}
#endif /* SUN4 */

#if defined(SUN4C) || defined(SUN4E)
	/*
	 * sun4c stuff
	 */

	/*
	 * floppy: fd
	 * fake looks like: /fd@@0,0:a
	 */
	if (cp[0] == 'f' && cp[1] == 'd') {
		/*
		 * Assume `fd(c,u,p)' means:
		 * partition `p' on floppy drive `u' on controller `c'
		 */
		BP_APPEND(bp, "fd", v0val[0], v0val[1], v0val[2]);
		return;
	}

	/*
	 * ethernet: le
	 * fake looks like: /sbus0/le0
	 */
	if (cp[0] == 'l' && cp[1] == 'e') {
		BP_APPEND(bp, "sbus", -1, 0, 0);
		BP_APPEND(bp, "le", -1, v0val[0], 0);
		return;
	}

	/*
	 * scsi: sd, st, sr
	 * fake looks like: /sbus0/esp0/sd@@3,0:a
	 */
	if (cp[0] == 's' && (cp[1] == 'd' || cp[1] == 't' || cp[1] == 'r')) {
		char tmpname[8];
		int  target, lun;

		BP_APPEND(bp, "sbus", -1, 0, 0);
		BP_APPEND(bp, "esp", -1, v0val[0], 0);
		if (cp[1] == 'r')
			snprintf(tmpname, sizeof tmpname, "cd"); /* OpenBSD uses 'cd', not 'sr'*/
		else
			snprintf(tmpname, sizeof tmpname, "%c%c", cp[0], cp[1]);
		/* XXX - is TARGET/LUN encoded in v0val[1]? */
		target = v0val[1];
		lun = 0;
		BP_APPEND(bp, tmpname, target, lun, v0val[2]);
		return;
	}
#endif /* SUN4C || SUN4E */


	/*
	 * unknown; return
	 */

#undef BP_APPEND
}

/*
 * print out the bootpath
 * the %x isn't 0x%x because the Sun EPROMs do it this way, and
 * consistency with the EPROMs is probably better here.
 */

static void
bootpath_print(bp)
	struct bootpath *bp;
{
	printf("bootpath: ");
	while (bp->name[0]) {
		if (bp->val[0] == -1)
			printf("/%s%x", bp->name, bp->val[1]);
		else
			printf("/%s@@%x,%x", bp->name, bp->val[0], bp->val[1]);
		if (bp->val[2] != 0)
			printf(":%c", bp->val[2] + 'a');
		bp++;
	}
	printf("\n");
}


/*
 * save or read a bootpath pointer from the boothpath store.
 *
 * XXX. required because of SCSI... we don't have control over the "sd"
 * device, so we can't set boot device there.   we patch in with
 * device_register(), and use this to recover the bootpath.
 */

struct bootpath *
bootpath_store(storep, bp)
	int storep;
	struct bootpath *bp;
{
	static struct bootpath *save;
	struct bootpath *retval;

	retval = save;
	if (storep)
		save = bp;

	return (retval);
}

/*
 * Set up the sd target mappings for non SUN4 PROMs.
 * Find out about the real SCSI target, given the PROM's idea of the
 * target of the (boot) device (i.e., the value in bp->v0val[0]).
 */
static void
crazymap(prop, map)
	char *prop;
	int *map;
{
	int i;
	char *propval;

	if (!CPU_ISSUN4 && promvec->pv_romvec_vers < 2) {
		/*
		 * Machines with real v0 proms have an `s[dt]-targets' property
		 * which contains the mapping for us to use. v2 proms donot
		 * require remapping.
		 */
		propval = getpropstring(optionsnode, prop);
		if (propval == NULL || strlen(propval) != 8) {
 build_default_map:
			printf("WARNING: %s map is bogus, using default\n",
				prop);
			for (i = 0; i < 8; ++i)
				map[i] = i;
			i = map[0];
			map[0] = map[3];
			map[3] = i;
			return;
		}
		for (i = 0; i < 8; ++i) {
			map[i] = propval[i] - '0';
			if (map[i] < 0 ||
			    map[i] >= 8)
				goto build_default_map;
		}
	} else {
		/*
		 * Set up the identity mapping for old sun4 monitors
		 * and v[2-] OpenPROMs. Note: device_register() does the
		 * SCSI-target juggling for sun4 monitors.
		 */
		for (i = 0; i < 8; ++i)
			map[i] = i;
	}
}

int
sd_crazymap(n)
	int	n;
{
	static int prom_sd_crazymap[8]; /* static: compute only once! */
	static int init = 0;

	if (init == 0) {
		crazymap("sd-targets", prom_sd_crazymap);
		init = 1;
	}
	return prom_sd_crazymap[n];
}

/*
 * Determine mass storage and memory configuration for a machine.
 * We get the PROM's root device and make sure we understand it, then
 * attach it as `mainbus0'.  We also set up to handle the PROM `sync'
 * command.
 */
void
cpu_configure()
{
	struct confargs oca;
	register int node = 0;
	register char *cp;
	int s;
	extern struct user *proc0paddr;
	extern struct sparc_bus_dma_tag dvma_dmatag;

	/* build the bootpath */
	bootpath_build();

	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}

#if defined(SUN4)
	if (CPU_ISSUN4) {
		extern struct cfdata cfdata[];
		extern struct cfdriver memreg_cd, obio_cd;
		struct cfdata *cf, *memregcf = NULL;
		register short *p;
		struct rom_reg rr;

		for (cf = cfdata; memregcf==NULL && cf->cf_driver; cf++) {
			if (cf->cf_driver != &memreg_cd ||
				cf->cf_loc[0] == -1) /* avoid sun4m memreg0 */
				continue;
			for (p = cf->cf_parents; memregcf==NULL && *p >= 0; p++)
				if (cfdata[*p].cf_driver == &obio_cd)
					memregcf = cf;
		}
		if (memregcf == NULL)
			panic("cpu_configure: no memreg found!");

		rr.rr_iospace = PMAP_OBIO;
		rr.rr_paddr = (void *)memregcf->cf_loc[0];
		rr.rr_len = NBPG;
		par_err_reg = (u_int *)bus_map(&rr, NBPG);
		if (par_err_reg == NULL)
			panic("cpu_configure: ROM hasn't mapped memreg!");
	}
#endif
#if defined(SUN4C) || defined(SUN4E)
	if (CPU_ISSUN4C || CPU_ISSUN4E) {
		node = findroot();
		cp = getpropstring(node, "device_type");
		if (strcmp(cp, "cpu") != 0)
			panic("PROM root device type = %s (need CPU)", cp);
	}
#endif
#if defined(SUN4M)
	if (CPU_ISSUN4M)
		node = findroot();
#endif

	if (!CPU_ISSUN4)
		*promvec->pv_synchook = sync_crash;

	oca.ca_ra.ra_node = node;
	oca.ca_ra.ra_name = cp = "mainbus";
	oca.ca_dmat = &dvma_dmatag;
	if (config_rootfound(cp, (void *)&oca) == NULL)
		panic("mainbus not configured");

	/* Enable device interrupts */
#if defined(SUN4M)
	if (CPU_ISSUN4M)
		intreg_clr_4m(SINTR_MA);
#endif
#if defined(SUN4) || defined(SUN4C) || defined(SUN4E)
	if (CPU_ISSUN4OR4COR4E)
		intreg_set_44c(IE_ALLIE);
#endif
	(void)spl0();

	/*
	 * Re-zero proc0's user area, to nullify the effect of the
	 * stack running into it during auto-configuration.
	 * XXX - should fix stack usage.
	 */
	s = splhigh();
	bzero(proc0paddr, sizeof(struct user));

	pmap_redzone();
	splx(s);
	cold = 0;
}

void
diskconf(void)
{
	struct bootpath *bp;
	struct device *bootdv;

	/*
	 * Configure swap area and related system
	 * parameter based on device(s) used.
	 */
	bootpath_print(bootpath);

	bp = nbootpath == 0 ? NULL : &bootpath[nbootpath-1];
	bootdv = (bp == NULL) ? NULL : bp->dev;

	setroot(bootdv, bp->val[2], RB_USERREQ | RB_HALT);
	dumpconf();
}

/*
 * Console `sync' command.  SunOS just does a `panic: zero' so I guess
 * no one really wants anything fancy...
 */
void
sync_crash()
{

	panic("PROM sync command");
}

char *
clockfreq(freq)
	register int freq;
{
	register char *p;
	static char buf[10];

	freq /= 1000;
	snprintf(buf, sizeof buf, "%d", freq / 1000);
	freq %= 1000;
	if (freq) {
		freq += 1000;	/* now in 1000..1999 */
		p = buf + strlen(buf);
		snprintf(p, buf + sizeof buf - p, "%d", freq);
		*p = '.';	/* now buf = %d.%3d */
	}
	return (buf);
}

/* ARGSUSED */
static int
mbprint(aux, name)
	void *aux;
	const char *name;
{
	register struct confargs *ca = aux;

	if (name)
		printf("%s at %s", ca->ca_ra.ra_name, name);
	if (ca->ca_ra.ra_paddr)
		printf(" %saddr 0x%x", ca->ca_ra.ra_iospace ? "io" : "",
		    (int)ca->ca_ra.ra_paddr);
	return (UNCONF);
}

int
findroot()
{
	register int node;

	if ((node = rootnode) == 0 && (node = nextsibling(0)) == 0)
		panic("no PROM root device");
	rootnode = node;
	return (node);
}

/*
 * Given a `first child' node number, locate the node with the given name.
 * Return the node number, or 0 if not found.
 */
int
findnode(first, name)
	int first;
	register const char *name;
{
	register int node;

	for (node = first; node; node = nextsibling(node))
		if (strcmp(getpropstring(node, "name"), name) == 0)
			return (node);
	return (0);
}

/*
 * Fill in a romaux.  Returns 1 on success, 0 if the register property
 * was not the right size.
 */
int
romprop(rp, cp, node)
	register struct romaux *rp;
	const char *cp;
	register int node;
{
	int len, n, intr;
	union { char regbuf[256]; struct rom_reg rr[RA_MAXREG]; } u;
	static const char pl[] = "property length";

	bzero(u.regbuf, sizeof u);
	len = getprop(node, "reg", (void *)u.regbuf, sizeof(u.regbuf));
	if (len == -1 &&
	    node_has_property(node, "device_type") &&
	    strcmp(getpropstring(node, "device_type"), "hierarchical") == 0)
		len = 0;
	if (len % sizeof(struct rom_reg)) {
		printf("%s \"reg\" %s = %d (need multiple of %zu)\n",
			cp, pl, len, sizeof(struct rom_reg));
		return (0);
	}
	if (len > RA_MAXREG * sizeof(struct rom_reg))
		printf("warning: %s \"reg\" %s %d > %zu, excess ignored\n",
		    cp, pl, len, RA_MAXREG * sizeof(struct rom_reg));
	rp->ra_node = node;
	rp->ra_name = cp;
	rp->ra_nreg = len / sizeof(struct rom_reg);
	bcopy(u.rr, rp->ra_reg, len);

	len = getprop(node, "address", (void *)rp->ra_vaddrs,
		      sizeof(rp->ra_vaddrs));
	if (len == -1) {
		rp->ra_vaddr = 0;	/* XXX - driver compat */
		len = 0;
	}
	if (len & 3) {
		printf("%s \"address\" %s = %d (need multiple of 4)\n",
		    cp, pl, len);
		len = 0;
	}
	rp->ra_nvaddrs = len >> 2;

	len = getprop(node, "intr", (void *)&rp->ra_intr, sizeof rp->ra_intr);
	if (len == -1)
		len = 0;

	/*
	 * Some SBus cards only provide an "interrupts" properly, listing
	 * SBus levels. But since obio devices will usually also provide
	 * both properties, only check for "interrupts" last.
	 */
	if (len == 0) {
		u_int32_t *interrupts;
		len = getproplen(node, "interrupts");
		if (len > 0 &&
		    (interrupts = malloc(len, M_TEMP, M_NOWAIT)) != NULL) {
			/* Build rom_intr structures from the list */
			getprop(node, "interrupts", interrupts, len);
			len /= sizeof(u_int32_t);
			for (n = 0; n < len; n++) {
				intr = interrupts[n];
				/*
				 * Non-SBus devices (such as the cgfourteen,
				 * which attaches on obio) do not need their
				 * interrupt level translated.
				 */
				if (intr < 8) {
					intr = CPU_ISSUN4M ?
					    intr_sbus2ipl_4m[intr] :
					    intr_sbus2ipl_4c[intr];
				}
				rp->ra_intr[n].int_pri = intr;
				rp->ra_intr[n].int_vec = 0;
			};
			len *= sizeof(struct rom_intr);
			free(interrupts, M_TEMP, 0);
		} else
			len = 0;
	}

	if (len & 7) {
		printf("%s \"intr\" %s = %d (need multiple of 8)\n",
		    cp, pl, len);
		len = 0;
	}
	rp->ra_nintr = len >>= 3;
	/* SPARCstation interrupts are not hardware-vectored */
	while (--len >= 0) {
		if (rp->ra_intr[len].int_vec) {
			printf("WARNING: %s interrupt %d has nonzero vector\n",
			    cp, len);
			break;
		}
#if defined(SUN4M)
		if (CPU_ISSUN4M) {
			/* What's in these high bits anyway? */
			rp->ra_intr[len].int_pri &= 0xf;
		}
#endif

	}
	return (1);
}

int
mainbus_match(parent, self, aux)
	struct device *parent;
	void *self;
	void *aux;
{
	struct cfdata *cf = self;
	register struct confargs *ca = aux;
	register struct romaux *ra = &ca->ca_ra;

	return (strcmp(cf->cf_driver->cd_name, ra->ra_name) == 0);
}

int autoconf_nzs = 0;	/* must be global so obio.c can see it */

/*
 * Attach the mainbus.
 *
 * Our main job is to attach the CPU (the root node we got in cpu_configure())
 * and iterate down the list of `mainbus devices' (children of that node).
 * We also record the `node id' of the default frame buffer, if any.
 */
static void
mainbus_attach(parent, dev, aux)
	struct device *parent, *dev;
	void *aux;
{
	struct confargs oca;
	register const char *const *ssp, *sp = NULL;
	struct confargs *ca = aux;
#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	register int node0, node;
	const char *const *openboot_special;
#define L1A_HACK		/* XXX hack to allow L1-A during autoconf */
#ifdef L1A_HACK
	int audio = 0;
#endif
#endif
#if defined(SUN4)
	static const char *const oldmon_special[] = {
		"vmel",
		"vmes",
		"led",
		NULL
	};
#endif /* SUN4 */

#if defined(SUN4C)
	static const char *const openboot_special4c[] = {
		/* find these first (end with empty string) */
		"memory-error",	/* as early as convenient, in case of error */
		"eeprom",
		"counter-timer",
		"auxiliary-io",
		"",

		/* ignore these (end with NULL) */
		"aliases",
		"interrupt-enable",
		"memory",
		"openprom",
		"options",
		"packages",
		"virtual-memory",
		NULL
	};
#endif
#if defined(SUN4E)
	static const char *const openboot_special4e[] = {
		/* find these first (end with empty string) */
		"memory-error",	/* as early as convenient, in case of error */
		"eeprom",
		"counter-timer",
		"auxiliary-io",
		"",

		/* ignore these (end with NULL) */
		"interrupt-enable",
		"options",
		"p2bus",	/* memory bus, has `eccmem' child */
		NULL
	};
#endif
#if defined(SUN4M)
	static const char *const openboot_special4m[] = {
		/* find these first */
		"obio",		/* smart enough to get eeprom/etc mapped */
		"",

		/* ignore these (end with NULL) */
		/*
		 * These are _root_ devices to ignore. Others must be handled
		 * elsewhere.
		 */
		"SUNW,sx",		/* XXX: no driver for SX yet */
		"virtual-memory",
		"aliases",
		"memory",
		"openprom",
		"options",
		"packages",
		/* we also skip any nodes with device_type == "cpu" */
		NULL
	};
#endif

	if (CPU_ISSUN4)
		snprintf(mainbus_model, sizeof mainbus_model,
			"SUN-4/%d series", cpuinfo.classlvl);
	else
		strlcat(mainbus_model, getpropstring(ca->ca_ra.ra_node,"name"),
			sizeof mainbus_model);
	printf(": %s\n", mainbus_model);

	/*
	 * Locate and configure the ``early'' devices.  These must be
	 * configured before we can do the rest.  For instance, the
	 * EEPROM contains the Ethernet address for the LANCE chip.
	 * If the device cannot be located or configured, panic.
	 */

#if defined(SUN4)
	if (CPU_ISSUN4) {
		/* Configure the CPU. */
		bzero(&oca, sizeof(oca));
		oca.ca_ra.ra_name = "cpu";
		oca.ca_dmat = ca->ca_dmat;
		config_found(dev, (void *)&oca, mbprint);

		/* Start at the beginning of the bootpath */
		bzero(&oca, sizeof(oca));
		oca.ca_ra.ra_bp = bootpath;
		oca.ca_dmat = ca->ca_dmat;

		oca.ca_bustype = BUS_MAIN;
		oca.ca_ra.ra_name = "obio";
		if (config_found(dev, (void *)&oca, mbprint) == NULL)
			panic("obio missing");

		for (ssp = oldmon_special; (sp = *ssp) != NULL; ssp++) {
			oca.ca_bustype = BUS_MAIN;
			oca.ca_ra.ra_name = sp;
			config_found(dev, (void *)&oca, mbprint);
		}
		return;
	}
#endif

/*
 * The rest of this routine is for OBP machines exclusively.
 */
#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)

	switch (cputyp) {
#ifdef SUN4C
	case CPU_SUN4C:
		openboot_special = openboot_special4c;
		break;
#endif
#ifdef SUN4E
	case CPU_SUN4E:
		openboot_special = openboot_special4e;
		break;
#endif
#ifdef SUN4M
	case CPU_SUN4M:
		openboot_special = openboot_special4m;
		break;
#endif
	default:
		/* panic("can't happen"); */
		openboot_special = NULL;
		break;
	}

	node = ca->ca_ra.ra_node;	/* i.e., the root node */

	/* the first early device to be configured is the cpu */
	if (CPU_ISSUN4M) {
		/* XXX - what to do on multiprocessor machines? */
		register const char *cp;

		for (node = firstchild(node); node; node = nextsibling(node)) {
			cp = getpropstring(node, "device_type");
			if (strcmp(cp, "cpu") == 0) {
				bzero(&oca, sizeof(oca));
				oca.ca_ra.ra_node = node;
				oca.ca_ra.ra_name = "cpu";
				oca.ca_ra.ra_paddr = 0;
				oca.ca_ra.ra_nreg = 0;
				oca.ca_dmat = ca->ca_dmat;
				config_found(dev, (void *)&oca, mbprint);
			}
		}
	} else if (CPU_ISSUN4C || CPU_ISSUN4E) {
		bzero(&oca, sizeof(oca));
		oca.ca_ra.ra_node = node;
		oca.ca_ra.ra_name = "cpu";
		oca.ca_ra.ra_paddr = 0;
		oca.ca_ra.ra_nreg = 0;
		oca.ca_dmat = ca->ca_dmat;
		config_found(dev, (void *)&oca, mbprint);
	}

	node = ca->ca_ra.ra_node;	/* re-init root node */

	if (promvec->pv_romvec_vers <= 2) {
		/*
		 * Revision 1 prom will always return a framebuffer device
		 * node if a framebuffer is installed, even if console is
		 * set to serial.
		 */
		if (*promvec->pv_stdout != PROMDEV_SCREEN ||
		    *promvec->pv_stdin != PROMDEV_KBD)
			fbnode = 0;
		else {
			/* remember which frame buffer is the console */
			fbnode = getpropint(node, "fb", 0);
		}
	} else {
		/* fbnode already initialized in consinit() */
	}

	/* Find the "options" node */
	node0 = firstchild(node);
	optionsnode = findnode(node0, "options");
	if (optionsnode == 0)
		panic("no options in OPENPROM");

	/* Start at the beginning of the bootpath */
	oca.ca_ra.ra_bp = bootpath;

	for (ssp = openboot_special; *(sp = *ssp) != 0; ssp++) {
		if ((node = findnode(node0, sp)) == 0) {
			printf("could not find %s in OPENPROM\n", sp);
			panic(sp);
		}
		oca.ca_bustype = BUS_MAIN;
		if (!romprop(&oca.ca_ra, sp, node) ||
		    (config_found(dev, (void *)&oca, mbprint) == NULL))
			panic(sp);
	}

	/*
	 * Configure the rest of the devices, in PROM order.  Skip
	 * PROM entries that are not for devices, or which must be
	 * done before we get here.
	 */
	for (node = node0; node; node = nextsibling(node)) {
		register const char *cp;

#if defined(SUN4D) || defined(SUN4M)
		if (CPU_ISSUN4DOR4M) /* skip the CPUs */
			if (node_has_property(node, "device_type") &&
			    !strcmp(getpropstring(node, "device_type"), "cpu"))
				continue;
#endif
		cp = getpropstring(node, "name");
		for (ssp = openboot_special; (sp = *ssp) != NULL; ssp++)
			if (strcmp(cp, sp) == 0)
				break;
		if (sp == NULL && romprop(&oca.ca_ra, cp, node)) {
#ifdef L1A_HACK
			if (strcmp(cp, "audio") == 0)
				audio = 1;
			if (strcmp(cp, "zs") == 0)
				autoconf_nzs++;
			if (/*audio &&*/ autoconf_nzs >= 2)	/*XXX*/
				splx(11 << 8);		/*XXX*/
#endif
			oca.ca_bustype = BUS_MAIN;
			config_found(dev, (void *)&oca, mbprint);
		}
	}

#if defined(SUN4E)
	if (CPU_ISSUN4E) {
		/*
		 * Attach the leds.
		 * XXX This is not a natural attachment, but since there
		 * XXX is more than one led, this does not fit in the usual
		 * XXX auxio blink framework.
		 */
		bzero(&oca, sizeof(oca));
		oca.ca_bustype = BUS_MAIN;
		oca.ca_ra.ra_name = "led";
		oca.ca_dmat = ca->ca_dmat;
		config_found(dev, (void *)&oca, mbprint);
	}
#endif
#endif /* SUN4C || SUN4D || SUN4E || SUN4M */
}

struct cfattach mainbus_ca = {
	sizeof(struct device), mainbus_match, mainbus_attach
};

struct cfdriver mainbus_cd = {
	NULL, "mainbus", DV_DULL
};

/*
 * findzs() is called from the zs driver (which is, at least in theory,
 * generic to any machine with a Zilog ZSCC chip).  It should return the
 * address of the corresponding zs channel.  It may not fail, and it
 * may be called before the VM code can be used.  Here we count on the
 * FORTH PROM to map in the required zs chips.
 */
void *
findzs(zs)
	int zs;
{

#if defined(SUN4)
#define ZS0_PHYS	0xf1000000
#define ZS1_PHYS	0xf0000000
#define ZS2_PHYS	0xe0000000

	if (CPU_ISSUN4) {
		struct rom_reg rr;
		register void *vaddr;

		switch (zs) {
		case 0:
			rr.rr_paddr = (void *)ZS0_PHYS;
			break;
		case 1:
			rr.rr_paddr = (void *)ZS1_PHYS;
			break;
		case 2:
			rr.rr_paddr = (void *)ZS2_PHYS;
			break;
		default:
			panic("findzs: unknown zs device %d", zs);
		}

		rr.rr_iospace = PMAP_OBIO;
		rr.rr_len = NBPG;
		vaddr = bus_map(&rr, NBPG);
		if (vaddr)
			return (vaddr);
	}
#endif

#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	if (!CPU_ISSUN4) {
		int node;

		node = firstchild(findroot());
		if (CPU_ISSUN4M) { /* zs is in "obio" tree on Sun4M */
			node = findnode(node, "obio");
			if (!node)
				panic("findzs: no obio node");
			node = firstchild(node);
		}
		while ((node = findnode(node, "zs")) != 0) {
			int vaddrs[10];

			if (getpropint(node, "slave", -1) != zs) {
				node = nextsibling(node);
				continue;
			}

			/*
			 * On some machines (e.g. the Voyager), the zs
			 * device has multi-valued register properties.
			 */
			if (getprop(node, "address",
			    (void *)vaddrs, sizeof(vaddrs)) != 0)
				return ((void *)vaddrs[0]);
		}
		return (NULL);
	}
#endif
	panic("findzs: cannot find zs%d", zs);
	/* NOTREACHED */
}

int
makememarr(struct memarr *ap, u_int xmax, int which)
{
#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	struct v0mlist *mp;
	int node, n;
	char *prop;
#endif

#ifdef DIAGNOSTIC
	if (which != MEMARR_AVAILPHYS && which != MEMARR_TOTALPHYS)
		panic("makememarr");
#endif

#ifdef DIAGNOSTIC
	if (which != MEMARR_AVAILPHYS && which != MEMARR_TOTALPHYS)
		panic("makememarr");
#endif

#if defined(SUN4)
	if (CPU_ISSUN4) {
		if (ap != NULL && xmax != 0) {
			ap[0].addr_hi = 0;
			ap[0].addr_lo = 0;
			ap[0].len = which == MEMARR_AVAILPHYS ?
			    *oldpvec->memoryAvail : *oldpvec->memorySize;
		}
		return 1;
	}
#endif
#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	switch (n = promvec->pv_romvec_vers) {
	case 0:
		/*
		 * Version 0 PROMs use a linked list to describe these
		 * guys.
		 */
		mp = which == MEMARR_AVAILPHYS ?
		    *promvec->pv_v0mem.v0_physavail :
		    *promvec->pv_v0mem.v0_phystot;

		for (n = 0; mp != NULL; mp = mp->next, n++) {
			if (ap == NULL || n >= xmax)
				continue;
			ap->addr_hi = 0;
			ap->addr_lo = (uint32_t)mp->addr;
			ap->len = mp->nbytes;
			ap++;
		}
		break;
	default:
		printf("makememarr: hope version %d PROM is like version 2\n",
		    n);
		/* FALLTHROUGH */
	case 3:
	case 2:
		/*
		 * Version 2 PROMs use a property array to describe them.
		 */
		if ((node = findnode(firstchild(findroot()), "memory")) == 0)
			panic("makememarr: cannot find \"memory\" node");
		prop = which == MEMARR_AVAILPHYS ? "available" : "reg";
		n = getproplen(node, prop) / sizeof(struct memarr);
		if (ap != NULL) {
			if (getprop(node, prop, ap,
			    xmax * sizeof(struct memarr)) <= 0)
				panic("makememarr: cannot get property");
		}
		break;
	}

	if (n <= 0)
		panic("makememarr: no memory found");
	return (n);
#endif	/* SUN4C || SUN4D || SUN4E || SUN4M */
}

/*
 * Internal form of getprop().  Returns the actual length.
 */
int
getprop(node, name, buf, bufsiz)
	int node;
	char *name;
	void *buf;
	register int bufsiz;
{
#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	register struct nodeops *no;
	register int len;
#endif

#if defined(SUN4)
	if (CPU_ISSUN4) {
		printf("WARNING: getprop not valid on sun4! %s\n", name);
		return (0);
	}
#endif

#if defined(SUN4C) || defined(SUN4D) || defined(SUN4E) || defined(SUN4M)
	no = promvec->pv_nodeops;
	len = no->no_proplen(node, name);
	if (len > bufsiz) {
		printf("node 0x%x property %s length %d > %d\n",
		    node, name, len, bufsiz);
#ifdef DEBUG
		panic("getprop");
#else
		return (0);
#endif
	}
	no->no_getprop(node, name, buf);
	return (len);
#endif
}

/*
 * Internal form of proplen().  Returns the property length.
 */
int
getproplen(node, name)
	int node;
	char *name;
{
	register struct nodeops *no = promvec->pv_nodeops;

	return (no->no_proplen(node, name));
}

/*
 * Return a string property.  There is a (small) limit on the length;
 * the string is fetched into a static buffer which is overwritten on
 * subsequent calls.
 */
char *
getpropstring(node, name)
	int node;
	char *name;
{
	register int len;
	static char stringbuf[32];

	len = getprop(node, name, (void *)stringbuf, sizeof stringbuf - 1);
	if (len == -1)
		len = 0;
	stringbuf[len] = '\0';	/* usually unnecessary */
	return (stringbuf);
}

/*
 * Fetch an integer (or pointer) property.
 * The return value is the property, or the default if there was none.
 */
int
getpropint(node, name, deflt)
	int node;
	char *name;
	int deflt;
{
	register int len;
	char intbuf[16];

	len = getprop(node, name, (void *)intbuf, sizeof intbuf);
	if (len != 4)
		return (deflt);
	return (*(int *)intbuf);
}

/*
 * OPENPROM functions.  These are here mainly to hide the OPENPROM interface
 * from the rest of the kernel.
 */
int
firstchild(node)
	int node;
{

	return (promvec->pv_nodeops->no_child(node));
}

int
nextsibling(node)
	int node;
{

	return (promvec->pv_nodeops->no_nextnode(node));
}

/* The following recursively searches a PROM tree for a given node */
int
search_prom(rootnode, name)
        register int rootnode;
        register char *name;
{
        register int rtnnode;
        register int node = rootnode;

        if (node == findroot() || !strcmp("hierarchical",
                                          getpropstring(node, "device_type")))
            node = firstchild(node);

        if (!node)
            panic("search_prom: null node");

        do {
                if (strcmp(getpropstring(node, "name"),name) == 0)
                    return node;

                if (node_has_property(node,"device_type") &&
                    (!strcmp(getpropstring(node, "device_type"),"hierarchical")
                     || !strcmp(getpropstring(node, "name"),"iommu"))
                    && (rtnnode = search_prom(node, name)) != 0)
                        return rtnnode;

        } while ((node = nextsibling(node)));

        return 0;
}

/* The following are used primarily in consinit() */

int
opennode(path)		/* translate phys. device path to node */
	register char *path;
{
	register int fd;

	if (promvec->pv_romvec_vers < 2) {
		printf("WARNING: opennode not valid on sun4! %s\n", path);
		return (0);
	}
	fd = promvec->pv_v2devops.v2_open(path);
	if (fd == 0)
		return 0;
	return promvec->pv_v2devops.v2_fd_phandle(fd);
}

int
node_has_property(node, prop)	/* returns 1 if node has given property */
	register int node;
	register const char *prop;
{

	return ((*promvec->pv_nodeops->no_proplen)(node, (caddr_t)prop) != -1);
}

/* Pass a string to the FORTH PROM to be interpreted */
void
rominterpret(s)
	register char *s;
{

	if (promvec->pv_romvec_vers < 2)
		promvec->pv_fortheval.v0_eval(strlen(s), s);
	else
		promvec->pv_fortheval.v2_eval(s);
}

/*
 * Try to figure out where the PROM stores the cursor row & column
 * variables.  Returns nonzero on error.
 */
int
romgetcursoraddr(rowp, colp)
	register int **rowp, **colp;
{
	char buf[100];

	/*
	 * line# and column# are global in older proms (rom vector < 2)
	 * and in some newer proms.  They are local in version 2.9.  The
	 * correct cutoff point is unknown, as yet; we use 2.9 here.
	 */
	if (promvec->pv_romvec_vers < 2 || promvec->pv_printrev < 0x00020009)
		snprintf(buf, sizeof buf,
		    "' line# >body >user %lx ! ' column# >body >user %lx !",
		    (u_long)rowp, (u_long)colp);
	else
		snprintf(buf, sizeof buf,
		    "stdout @@ is my-self addr line# %lx ! addr column# %lx !",
		    (u_long)rowp, (u_long)colp);
	*rowp = *colp = NULL;
	rominterpret(buf);
	return (*rowp == NULL || *colp == NULL);
}

void
romhalt()
{
	if (!CPU_ISSUN4)
		*promvec->pv_synchook = NULL;

	promvec->pv_halt();
	panic("PROM exit failed");
}

void
romboot(str)
	char *str;
{
	if (!CPU_ISSUN4)
		*promvec->pv_synchook = NULL;

	promvec->pv_reboot(str);
	panic("PROM boot failed");
}

void
callrom()
{

#if 0			/* sun4c FORTH PROMs do this for us */
	if (CPU_ISSUN4)
		fb_unblank();
#endif
	promvec->pv_abort();
}

/*
 * find the boot device (if it was a disk).   we must check to see if
 * unit info in saved bootpath structure matches unit info in our softc.
 * note that knowing the device name (e.g. "xd0") is not useful... we
 * must check the drive number (or target/lun, in the case of SCSI).
 * (XXX is it worth ifdef'ing this?)
 */

void
device_register(struct device *dev, void *aux)
{
	struct bootpath *bp = bootpath_store(0, NULL); /* restore bootpath! */

	if (bp == NULL)
		return;

	/*
	 * scsi: sd,cd
	 */
	if (strcmp("sd", dev->dv_cfdata->cf_driver->cd_name) == 0 ||
	    strcmp("cd", dev->dv_cfdata->cf_driver->cd_name) == 0) {
		struct scsi_attach_args *sa = aux;
		struct scsibus_softc *sbsc;
		int target, lun;

		sbsc = (struct scsibus_softc *)dev->dv_parent;

		target = bp->val[0];
		lun = bp->val[1];

#if defined(SUN4)
		if (CPU_ISSUN4 && dev->dv_xname[0] == 's' &&
		    target == 0 && scsi_get_link(sbsc, 0, 0) == NULL) {
			/*
			 * disk unit 0 is magic: if there is actually no
			 * target 0 scsi device, the PROM will call
			 * target 3 `sd0'.
			 * XXX - what if someone puts a tape at target 0?
			 */
			/* Note that sbsc:0:0 will be NULL when we are
			 * invoked to match the device for target 0, if it
			 * exists. But then the attachment args will have
			 * its own target set to zero. It this case, skip
			 * the remapping.
			 */
			if (sa->sa_sc_link->target != 0) {
				target = 3;	/* remap to 3 */
				lun = 0;
			}
		}
#endif

#if defined(SUN4C) || defined(SUN4E)
		if ((CPU_ISSUN4C || CPU_ISSUN4E) && dev->dv_xname[0] == 's')
			target = sd_crazymap(target);
#endif

		if (sa->sa_sc_link->target == target &&
		    sa->sa_sc_link->lun == lun) {
			bp->dev = dev;	/* got it! */
			return;
		}
	}
}

/*
 * find a device matching "name" and unit number
 */
struct device *
getdevunit(name, unit)
	char *name;
	int unit;
{
	struct device *dev = TAILQ_FIRST(&alldevs);
	char num[10], fullname[16];
	int lunit;

	/* compute length of name and decimal expansion of unit number */
	snprintf(num, sizeof num, "%d", unit);
	lunit = strlen(num);
	if (strlen(name) + lunit >= sizeof(fullname) - 1)
		panic("config_attach: device name too long");

	strlcpy(fullname, name, sizeof fullname);
	strlcat(fullname, num, sizeof fullname);

	while (strcmp(dev->dv_xname, fullname) != 0) {
		if ((dev = TAILQ_NEXT(dev, dv_list)) == NULL)
			return NULL;
	}
	return dev;
}

struct nam2blk nam2blk[] = {
	{ "xy",		 3 },
	{ "sd",		 7 },
	{ "xd",		10 },
	{ "st",		11 },
	{ "fd",		16 },
	{ "rd",		17 },
	{ "cd",		18 },
	{ "vnd",	8 },
	{ NULL,		-1 }
};
@


1.101
log
@Drop the workarounds allowing SMALL_KERNEL (i.e. installation media) to be
booted from old (< 2.10) bootblocks.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.100 2015/03/30 20:30:22 miod Exp $	*/
a1888 1
	{ "raid",	25 },
@


1.100
log
@Add a bus_dma_tag_t for DVMA usage, suitable for use for devices not sitting
behind a sun4m iommu.

Move the existing dvma routines from vm_machdep.c to this new dvma.c; this
allows for a few declarations to be removed from public headers.

Extend the device attachment arguments (struct confargs) to pass a
bus_dma_tag_t. mainbus receives the dvma bus_dma_tag_t, and devices pass the
tag unchanged to their children, except for iommu(4) which replaces it with
its own.

Change the few sun4m-only drivers to pick the bus_dma_tag_t from confargs
rather than assume iommu; this allows qlw(4) to attach and work on sun4c.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.99 2015/03/27 20:25:39 miod Exp $	*/
d163 1
a163 1
    (defined(SUN4D) || defined(SUN4M)) && !defined(SMALL_KERNEL)
d252 1
a252 1
    (defined(SUN4D) || defined(SUN4M)) && !defined(SMALL_KERNEL)
@


1.99
log
@Lower VM_MIN_KERNEL_ADDRESS by 128MB on non-SRMMU systems (sun4/4c/4e) as well,
in order to give these systems a more reasonable amount of kva, yet still
providing .75GB to userland processes.

Although there is no dependency upon a recent boot loader on non-SRMMU systems,
SMALL_KERNEL will nevertheless stick to the legacy kvm layout, for the time
being.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.98 2015/03/18 20:56:40 miod Exp $	*/
d805 1
d863 1
d1218 2
a1219 1
		(void)config_found(dev, (void *)&oca, mbprint);
d1224 1
d1234 1
a1234 1
			(void)config_found(dev, (void *)&oca, mbprint);
d1282 1
d1292 1
d1363 1
a1363 1
			(void) config_found(dev, (void *)&oca, mbprint);
d1378 1
@


1.98
log
@Rework the virtual memory layout on SRMMU systems (sun4d/sun4m) to use a much
lower VM_MIN_KERNEL_ADDRESS, since these systems are not crippled by the
Sun-4 MMU hole and have the real 4GB of address space.

Kernels running on Sun-4 MMU are not affected and will still be restricted
to the existing 128MB of kernel space, with 1GB - 128MB of user space.

Kernels running on SRMMU will now provide the low 3GB of address space to
userland, and use the top 1GB for the kernel, except when compiled with
option SMALL_KERNEL, in which case they will keep Sun-4 style the layout
(this is temporary to allow for people to boot bsd.rd to upgrade even when
not running 2.10 boot blocks, and will be removed eventually)

A consequence of this is that the top of the userland stack is no longer at
0xf0000000. But since nothing in userland uses USRSTACK anymore, this should
not be an issue.

Tested on sun4c and various sun4m, with physical memory sizes ranging from 32
to 448MB.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.97 2014/11/22 22:48:38 miod Exp $	*/
d254 1
a254 1
		vm_min_kernel_address = VM_MIN_KERNEL_ADDRESS_OLD;
@


1.97
log
@Driver for the ECC memory controller found on some sun4m (ss20), so that
recoverable memory errors no longer panic the kernel.
From NetBSD but the manual page.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.96 2014/11/16 12:30:58 deraadt Exp $	*/
d162 5
d245 14
@


1.96
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.95 2014/07/12 18:44:43 tedu Exp $	*/
a1165 1
		"eccmemctl",
@


1.95
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.94 2014/05/09 20:15:06 miod Exp $	*/
d360 1
a360 1
		     INT_ENABLE_REG_PHYSADR_44C), VM_PROT_READ | VM_PROT_WRITE);
@


1.94
log
@format string fixes and removal of -Wno-format for sparc kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.93 2010/11/18 21:13:19 miod Exp $	*/
d1042 1
a1042 1
			free(interrupts, M_TEMP);
@


1.93
log
@Do not #include <sys/dkstat.h> if you don't need anything from it.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.92 2010/07/10 19:32:24 miod Exp $	*/
d182 1
a182 1
		snprintf(tmpstr, sizeof tmpstr, "pagesize %x l!",
d984 1
a984 1
		printf("%s \"reg\" %s = %d (need multiple of %d)\n",
d989 1
a989 1
		printf("warning: %s \"reg\" %s %d > %d, excess ignored\n",
@


1.92
log
@sun4e (i.e. SPARCengine 1e) support. This platform is a mix between sun4 and
sun4c, as it has a sun4c OpenPROM but a sun4 8KB pagesize. VME devices are
not supported yet.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.91 2010/07/06 20:40:01 miod Exp $	*/
a52 1
#include <sys/dkstat.h>
@


1.91
log
@Having common ienab_bic() and ienab_bis() entry points for sun4/4c and sun4m
is stupid, since the bits in the interrupt enable register are completely
different between 4/4c and 4m.

Instead, provide distinct, explicit function names to handle the interrupt
enable register.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.90 2010/07/01 03:20:38 matthew Exp $	*/
d171 37
d352 2
a353 2
#if defined(SUN4) || defined(SUN4C)
	if (CPU_ISSUN4OR4C) {
d359 3
a361 3
		pmap_kenter_pa(INTRREG_VA,
			   INT_ENABLE_REG_PHYSADR | PMAP_NC | PMAP_OBIO,
			   VM_PROT_READ | VM_PROT_WRITE);
a516 7
#if defined(SUN4)
	if (CPU_ISSUN4M) {
		printf("twas brillig..\n");
		return;
	}
#endif

d606 1
a606 1
#if defined(SUN4C)
d654 1
a654 1
#endif /* SUN4C */
d826 2
a827 2
#if defined(SUN4C)
	if (CPU_ISSUN4C) {
d852 2
a853 2
#if defined(SUN4) || defined(SUN4C)
	if (CPU_ISSUN4OR4C)
d1102 1
a1102 1
#if defined(SUN4C) || defined(SUN4M)
d1138 16
a1153 2
#else
#define openboot_special4c	((void *)0)
a1176 2
#else
#define openboot_special4m	((void *)0)
d1222 1
a1222 1
#if defined(SUN4C) || defined(SUN4M)
d1224 21
a1244 3
	openboot_special = CPU_ISSUN4M
				? openboot_special4m
				: openboot_special4c;
d1264 1
a1264 1
	} else if (CPU_ISSUN4C) {
d1320 2
a1321 2
#if defined(SUN4M)
		if (CPU_ISSUN4M) /* skip the CPUs */
d1343 16
a1358 1
#endif /* SUN4C || SUN4M */
d1412 2
a1413 2
#if defined(SUN4C) || defined(SUN4M)
	if (CPU_ISSUN4COR4M) {
d1449 1
a1449 1
#if defined(SUN4C) || defined(SUN4M)
d1460 5
d1476 1
a1476 1
#if defined(SUN4C) || defined(SUN4M)
d1520 1
a1520 1
#endif	/* SUN4C || SUN4M */
d1533 1
a1533 1
#if defined(SUN4C) || defined(SUN4M)
d1545 1
a1545 1
#if defined(SUN4C) || defined(SUN4M)
d1735 1
a1735 1
	if (CPU_ISSUN4COR4M)
d1746 1
a1746 1
	if (CPU_ISSUN4COR4M)
d1816 2
a1817 2
#if defined(SUN4C)
		if (CPU_ISSUN4C && dev->dv_xname[0] == 's')
@


1.90
log
@Change scsibus(4)'s scsi_link array to an SLIST to save memory on
sparsely populated buses.

ok dlg@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.89 2010/06/29 21:28:10 miod Exp $	*/
d283 1
a283 1
		ienab_bis(SINTR_MA);
d315 1
d318 4
d329 1
d820 1
a820 1
		ienab_bic(SINTR_MA);
d824 1
a824 1
		ienab_bis(IE_ALLIE);
@


1.89
log
@During kernel bootstrap, stop assuming the kernel image has been loaded in
low physical memory, but instead figure out where it has been loaded from
the current MMU setup.

From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.88 2010/06/27 05:52:01 beck Exp $	*/
d1710 1
a1710 1
		    target == 0 && sbsc->sc_link[0][0] == NULL) {
d1717 1
a1717 1
			/* Note that sc_link[0][0] will be NULL when we are
@


1.88
log
@make sparc compile again after tag team viking/guenther breakage.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.87 2010/06/26 23:24:44 guenther Exp $	*/
d803 2
a804 1
	*promvec->pv_synchook = sync_crash;
a1364 8
#if defined(SUN4C) || defined(SUN4M)
struct v2rmi {
	int	zero;
	int	addr;
	int	len;
} v2rmi[200];		/* version 2 rom meminfo layout */
#endif

d1366 1
a1366 3
makememarr(ap, max, which)
	register struct memarr *ap;
	int max, which;
d1369 2
a1370 3
#define	MAXMEMINFO (sizeof(v2rmi) / sizeof(*v2rmi))
	register struct v0mlist *mp;
	register int i, node, len;
d1374 5
d1381 5
a1385 12
		switch (which) {
		case MEMARR_AVAILPHYS:
			ap[0].addr = 0;
			ap[0].len = *oldpvec->memoryAvail;
			break;
		case MEMARR_TOTALPHYS:
			ap[0].addr = 0;
			ap[0].len = *oldpvec->memorySize;
			break;
		default:
			printf("pre_panic: makememarr");
			break;
d1387 1
a1387 1
		return (1);
d1391 1
a1391 2
	switch (i = promvec->pv_romvec_vers) {

d1397 3
a1399 1
		switch (which) {
d1401 5
a1405 15
		case MEMARR_AVAILPHYS:
			mp = *promvec->pv_v0mem.v0_physavail;
			break;

		case MEMARR_TOTALPHYS:
			mp = *promvec->pv_v0mem.v0_phystot;
			break;

		default:
			panic("makememarr");
		}
		for (i = 0; mp != NULL; mp = mp->next, i++) {
			if (i >= max)
				goto overflow;
			ap->addr = (u_int)mp->addr;
a1409 1

d1412 1
a1412 1
		    i);
d1414 1
a1414 2

        case 3:
a1418 4
		if (max > MAXMEMINFO) {
			printf("makememarr: limited to %d\n", MAXMEMINFO);
			max = MAXMEMINFO;
		}
d1421 6
a1426 21
		switch (which) {

		case MEMARR_AVAILPHYS:
			prop = "available";
			break;

		case MEMARR_TOTALPHYS:
			prop = "reg";
			break;

		default:
			panic("makememarr");
		}
		len = getprop(node, prop, (void *)v2rmi, sizeof v2rmi) /
		    sizeof(struct v2rmi);
		for (i = 0; i < len; i++) {
			if (i >= max)
				goto overflow;
			ap->addr = v2rmi[i].addr;
			ap->len = v2rmi[i].len;
			ap++;
d1431 1
a1431 4
	/*
	 * Success!  (Hooray)
	 */
	if (i == 0)
d1433 2
a1434 10
	return (i);

overflow:
	/*
	 * Oops, there are more things in the PROM than our caller
	 * provided space for.  Truncate any extras.
	 */
	printf("makememarr: WARNING: lost some memory\n");
	return (i);
#endif
@


1.87
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.86 2010/06/22 16:27:45 miod Exp $	*/
d60 1
@


1.86
log
@Some early 2.x sun4c PROM will default to serial input but glass output if no
keyboard is connected but a framebuffer exists in the machine; the current
kernel console code will complain and switch to full serial, but later on
the framebuffer would incorrectly take over the console.

Correctly detect this situation and reset the `fbnode' variable. This is
an improvement of the fix which went in rev 1.54 of this file.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.85 2010/06/07 19:54:33 miod Exp $	*/
a59 1
#include <sys/user.h>
@


1.85
log
@Rework the way onboard devices attach on Sun 4/110 systems (which only have a
28 bit address bus) by reusing the regular sun4 configuration stanzas (with
the upper four bits set in the device addresses), and clearing them when
searching for a PROM mapping.
This makes the obio autoconf code simpler, and all knowledge of the 4/110
specifics is now contained in a single file (dev/obio.c).

ok todd@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.84 2010/04/21 03:03:26 deraadt Exp $	*/
d1214 2
a1215 1
		if (*promvec->pv_stdout != PROMDEV_SCREEN)
d1221 2
@


1.84
log
@more cleanup to cope with the change that tries to make proc.h not act
like it is everything.h
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.83 2009/10/26 20:17:27 deraadt Exp $	*/
a773 14
				continue;
			/*
			 * On the 4/100 obio addresses must be mapped at
			 * 0x0YYYYYYY, but alias higher up (we avoid the
			 * alias condition because it causes pmap difficulties)
			 * XXX: We also assume that 4/[23]00 obio addresses
			 * must be 0xZYYYYYYY, where (Z != 0)
			 * make sure we get the correct memreg cfdriver!
			 */
			if (cpuinfo.cpu_type == CPUTYP_4_100 &&
			    (cf->cf_loc[0] & 0xf0000000))
				continue;
			if (cpuinfo.cpu_type != CPUTYP_4_100 &&
			    !(cf->cf_loc[0] & 0xf0000000))
@


1.83
log
@Do not do strncmp comparisons on dv_xname because longer device names which
look similar could arrive in the future.  Instead, compare directly against
dv_cfdata->cf_driver->cd_name
Issue originally spotted by miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.82 2008/07/21 04:35:54 todd Exp $	*/
d59 1
@


1.82
log
@nam2blk[] needs a "vnd" entry for some things (like softraid)
ok marco@@ no objection miod@@ need this for regress djm@@ no objection krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.81 2008/03/23 17:05:41 deraadt Exp $	*/
d1760 2
a1761 2
	if (strncmp("sd", dev->dv_xname, 2) == 0 ||
	    strncmp("cd", dev->dv_xname, 2) == 0) {
@


1.81
log
@setroot() is supposed to be safe in all cases, so kill the special cases
for RB_DFLTROOT; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.80 2007/06/01 19:25:10 deraadt Exp $	*/
d1843 1
@


1.80
log
@some architectures called setroot() from cpu_configure(), *way* before some
subsystems were enabled.  others used a *md_diskconf -> diskconf() method to
make sure init_main could "do late setroot".  Change all architectures to
have diskconf(), use it directly & late.  tested by todd and myself on most
architectures, ok miod too
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.80 2007/06/01 19:20:47 deraadt Exp $	*/
a425 4
			break;

		case 'b':
			boothowto |= RB_DFLTROOT;
@


1.79
log
@use the right capitalization for `SBus'

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.78 2007/05/04 19:30:55 deraadt Exp $	*/
a751 2
	struct bootpath *bp;
	struct device *bootdv;
d839 19
a867 12
	cold = 0;

	/*
	 * Re-zero proc0's user area, to nullify the effect of the
	 * stack running into it during auto-configuration.
	 * XXX - should fix stack usage.
	 */
	s = splhigh();
	bzero(proc0paddr, sizeof(struct user));

	pmap_redzone();
	splx(s);
@


1.78
log
@make findblkmajor() and findblkname() MI; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.77 2007/05/04 03:44:44 deraadt Exp $	*/
d1005 1
a1005 1
				 * Non-Sbus devices (such as the cgfourteen,
@


1.77
log
@setroot() was a ugly mix of MI and MD code, with different bugs on different
machines.  Instead -- build one solid clean MI version, and thenchange all
the architectures to use it.  ok various people, tested on almost all cases.
(it is a 10094 line diff..)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.76 2007/04/30 18:37:00 deraadt Exp $	*/
d1833 1
a1833 4
static struct {
	char	*name;
	int	maj;
} nam2blk[] = {
d1841 2
a1842 1
	{ "raid",	25 }
a1843 23

int
findblkmajor(struct device *dv)
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (!strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)))
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(int maj)
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	return (NULL);
}
@


1.76
log
@check for exit string earlier
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.75 2007/04/30 18:11:03 deraadt Exp $	*/
a104 1
void	setroot(void);
a105 4
static	int getstr(char *, int);
int	findblkmajor(struct device *);
char	*findblkname(int);
static	struct device *getdisk(char *, int, int, dev_t *);
a119 4
#ifdef RAMDISK_HOOKS
static struct device fakerdrootdev = { DV_DISK, {}, NULL, 0, "rd0", NULL };
#endif

a365 2
		bootpath_print(bootpath);

a409 2
		bootpath_print(bootpath);

d752 2
d844 6
a849 1
	setroot();
a1739 417
#if 0 /* Unused */
dev_t	bootdev;
#endif

struct nam2blk {
	char *name;
	int maj;
} nam2blk[] = {
	{ "xy",		 3 },
	{ "sd",		 7 },
	{ "xd",		10 },
	{ "st",		11 },
	{ "fd",		16 },
	{ "rd",		17 },
	{ "cd",		18 },
	{ "raid",	25 },
};

int
findblkmajor(dv)
	struct device *dv;
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)) == 0)
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(maj)
	int maj;
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	return (NULL);
}

static struct device *
getdisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	register struct device *dv;

	if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
		printf("use one of: exit");
#ifdef RAMDISK_HOOKS
		printf(" %s[a-p]", fakerdrootdev.dv_xname);
#endif
		TAILQ_FOREACH(dv, &alldevs, dv_list) {
			if (dv->dv_class == DV_DISK)
				printf(" %s[a-p]", dv->dv_xname);
#ifdef NFSCLIENT
			if (dv->dv_class == DV_IFNET)
				printf(" %s", dv->dv_xname);
#endif
		}
		printf("\n");
	}
	return (dv);
}

struct device *
parsedisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	register struct device *dv;
	register char *cp, c;
	int majdev, unit, part;

	if (len == 0)
		return (NULL);
	cp = str + len - 1;
	c = *cp;
	if (c >= 'a' && (c - 'a') < MAXPARTITIONS) {
		part = c - 'a';
		*cp = '\0';
	} else
		part = defpart;

#ifdef RAMDISK_HOOKS
	if (strcmp(str, fakerdrootdev.dv_xname) == 0) {
		dv = &fakerdrootdev;
		goto gotdisk;
	}
#endif

	TAILQ_FOREACH(dv, &alldevs, dv_list) {
		if (dv->dv_class == DV_DISK &&
		    strcmp(str, dv->dv_xname) == 0) {
#ifdef RAMDISK_HOOKS
gotdisk:
#endif
			majdev = findblkmajor(dv);
			unit = dv->dv_unit;
			if (majdev < 0)
				panic("parsedisk");
			*devp = MAKEDISKDEV(majdev, unit, part);
			break;
		}
#ifdef NFSCLIENT
		if (dv->dv_class == DV_IFNET &&
		    strcmp(str, dv->dv_xname) == 0) {
			*devp = NODEV;
			break;
		}
#endif
	}

	*cp = c;
	return (dv);
}

/*
 * Attempt to find the device from which we were booted.
 * If we can do so, and not instructed not to do so,
 * change rootdev to correspond to the load device.
 *
 * XXX Actually, swap and root must be on the same type of device,
 * (ie. DV_DISK or DV_IFNET) because of how (*mountroot) is written.
 * That should be fixed.
 */
void
setroot()
{
	register struct swdevt *swp;
	register struct device *dv;
	register int len, majdev, unit, part;
	dev_t nrootdev, nswapdev = NODEV;
	char buf[128];
	dev_t temp;
	struct device *bootdv;
	struct bootpath *bp;
#if defined(NFSCLIENT)
	extern char *nfsbootdevname;
#endif

	bp = nbootpath == 0 ? NULL : &bootpath[nbootpath-1];
#ifdef RAMDISK_HOOKS
	bootdv = &fakerdrootdev;
#else
	bootdv = (bp == NULL) ? NULL : bp->dev;
#endif

	/*
	 * (raid) device auto-configuration could have returned
	 * the root device's id in rootdev.  Check this case.
	 */
	if (rootdev != NODEV) {
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);

		len = snprintf(buf, sizeof buf, "%s%d", findblkname(majdev),
			unit);
		if (len == -1 || len >= sizeof(buf))
			panic("setroot: device name too long");

		if (len == 4 && strncmp(buf, "exit", 4) == 0)
			boot(RB_USERREQ | RB_HALT);
		bootdv = getdisk(buf, len, part, &rootdev);
	}

	/*
	 * If `swap generic' and we couldn't determine boot device,
	 * ask the user.
	 */
	if (mountroot == NULL && bootdv == NULL)
		boothowto |= RB_ASKNAME;

	if (boothowto & RB_ASKNAME) {
		for (;;) {
			printf("root device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK
						? bp->val[2]+'a' : ' ');
			printf(": ");
			len = getstr(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
				len = strlen(buf);
			}
			if (len == 4 && strncmp(buf, "exit", 4) == 0)
				boot(RB_USERREQ | RB_HALT);
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				dv = getdisk(buf, len, 1, &nrootdev);
				if (dv != NULL) {
					bootdv = dv;
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			dv = getdisk(buf, len, bp?bp->val[2]:0, &nrootdev);
			if (dv != NULL) {
				bootdv = dv;
				break;
			}
		}

		/*
		 * because swap must be on same device as root, for
		 * network devices this is easy.
		 */
		if (bootdv->dv_class == DV_IFNET) {
			goto gotswap;
		}
		for (;;) {
			printf("swap device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK?'b':' ');
			printf(": ");
			len = getstr(buf, sizeof(buf));
			if (len == 4 && strncmp(buf, "exit", 4) == 0)
				boot(RB_USERREQ | RB_HALT);
			if (len == 0 && bootdv != NULL) {
				switch (bootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
					break;
				case DV_TAPE:
				case DV_TTY:
				case DV_DULL:
				case DV_CPU:
					break;
				}
				break;
			}
			dv = getdisk(buf, len, 1, &nswapdev);
			if (dv) {
				if (dv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				break;
			}
		}
gotswap:
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		/* swdevt[1].sw_dev = NODEV; */

	} else if (mountroot == NULL) {

		/*
		 * `swap generic': Use the device the ROM told us to use.
		 */
		majdev = findblkmajor(bootdv);
		if (majdev >= 0) {
			/*
			 * Root and swap are on a disk.
			 * val[2] of the boot device is the partition number.
			 * Assume swap is on partition b.
			 */
			part = bp->val[2];
			unit = bootdv->dv_unit;
			rootdev = MAKEDISKDEV(majdev, unit, part);
			nswapdev = dumpdev = MAKEDISKDEV(major(rootdev),
			    DISKUNIT(rootdev), 1);
		} else {
			/*
			 * Root and swap are on a net.
			 */
			nswapdev = dumpdev = NODEV;
		}
		swdevt[0].sw_dev = nswapdev;
		/* swdevt[1].sw_dev = NODEV; */

	} else {

		/*
		 * `root DEV swap DEV': honour rootdev/swdevt.
		 * rootdev/swdevt/mountroot already properly set.
		 */
		if (bootdv->dv_class == DV_DISK)
			printf("root on %s%c\n", bootdv->dv_xname,
			    part + 'a');
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);
		return;
	}

	switch (bootdv->dv_class) {
#if defined(NFSCLIENT)
	case DV_IFNET:
		mountroot = nfs_mountroot;
		nfsbootdevname = bootdv->dv_xname;
		return;
#endif
	case DV_DISK:
		mountroot = dk_mountroot;
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);
		printf("root on %s%c\n", bootdv->dv_xname,
		    part + 'a');
		break;
	default:
		printf("can't figure root, hope your kernel is right\n");
		return;
	}

	/*
	 * Make the swap partition on the root drive the primary swap.
	 */
	temp = NODEV;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    unit == DISKUNIT(swp->sw_dev)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev != NODEV) {
		/*
		 * If dumpdev was the same as the old primary swap device,
		 * move it to the new primary swap device.
		 */
		if (temp == dumpdev)
			dumpdev = swdevt[0].sw_dev;
	}
}

static int
getstr(cp, size)
	register char *cp;
	register int size;
{
	register char *lp;
	register int c;
	register int len;

	lp = cp;
	len = 0;
	for (;;) {
		c = cngetc();
		switch (c) {
		case '\n':
		case '\r':
			printf("\n");
			*lp++ = '\0';
			return (len);
		case '\b':
		case '\177':
		case '#':
			if (len) {
				--len;
				--lp;
				printf("\b \b");
			}
			continue;
		case '@@':
		case 'u'&037:
			len = 0;
			lp = cp;
			printf("\n");
			continue;
		default:
			if (len + 1 >= size || c < ' ') {
				printf("\007");
				continue;
			}
			printf("%c", c);
			++len;
			*lp++ = c;
		}
	}
}


/*
 * find a device matching "name" and unit number
 */
struct device *
getdevunit(name, unit)
	char *name;
	int unit;
{
	struct device *dev = TAILQ_FIRST(&alldevs);
	char num[10], fullname[16];
	int lunit;

	/* compute length of name and decimal expansion of unit number */
	snprintf(num, sizeof num, "%d", unit);
	lunit = strlen(num);
	if (strlen(name) + lunit >= sizeof(fullname) - 1)
		panic("config_attach: device name too long");

	strlcpy(fullname, name, sizeof fullname);
	strlcat(fullname, num, sizeof fullname);

	while (strcmp(dev->dv_xname, fullname) != 0) {
		if ((dev = TAILQ_NEXT(dev, dv_list)) == NULL)
			return NULL;
	}
	return dev;
}

d1803 65
@


1.75
log
@support "exit" like sparc64 does; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.74 2006/11/28 16:56:50 dlg Exp $	*/
d1939 2
a1949 2
			if (len == 4 && strncmp(buf, "exit", 4) == 0)
				boot(RB_USERREQ | RB_HALT);
d1972 2
a1990 2
			if (len == 4 && strncmp(buf, "exit", 4) == 0)
				boot(RB_USERREQ | RB_HALT);
@


1.74
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.73 2006/07/24 18:27:36 deraadt Exp $	*/
d1798 1
a1798 1
		printf("use one of:");
d1913 2
d1948 2
d1989 2
@


1.73
log
@move large local array out of a "called once, only at boot" function
into being a global,  to reduce stack size; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.72 2006/03/15 20:07:28 miod Exp $	*/
d2178 1
a2178 1
		struct scsibus_attach_args *sa = aux;
@


1.72
log
@Switch sparc to device_register() to find out its boot device (when it's a
disk).
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.71 2006/02/06 17:19:31 jmc Exp $	*/
d1379 8
a1392 5
	struct v2rmi {
		int	zero;
		int	addr;
		int	len;
	} v2rmi[200];		/* version 2 rom meminfo layout */
@


1.71
log
@typos from alexey dobriyan;
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.70 2005/12/27 18:31:10 miod Exp $	*/
d63 3
d568 1
a568 1
			 * Note: more special casing in dk_establish().
d673 1
a673 1
 * dk_establish(), and use this to recover the bootpath.
d731 1
a731 1
		 * and v[2-] OpenPROMs. Note: dkestablish() does the
d2152 65
@


1.70
log
@Remove unused sw_nblks field of struct swdevt. Then, remove swapconf()
which duplicates work done by uvm_swap_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.69 2005/09/25 20:05:37 miod Exp $	*/
d411 1
a411 1
							sbus offset/adddress */
@


1.69
log
@Do not try increasing NKMEMPAGE_MAX on sun4m at all, until we make
kernel_map larger.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.68 2005/09/12 23:05:05 miod Exp $	*/
a109 1
void	swapconf(void);
d853 1
a853 1
	swapconf();
a1737 21
}

/*
 * Configure swap space and related parameters.
 */
void
swapconf()
{
	register struct swdevt *swp;
	register int nblks;

	for (swp = swdevt; swp->sw_dev != NODEV; swp++)
		if (bdevsw[major(swp->sw_dev)].d_psize) {
			nblks =
			  (*bdevsw[major(swp->sw_dev)].d_psize)(swp->sw_dev);
			if (nblks != -1 &&
			    (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
			swp->sw_nblks = ctod(dtoc(swp->sw_nblks));
		}
	dumpconf();
@


1.68
log
@Change the NKMEMPAGES range to 4-64MB for 32bit arches, and 8-128MB for 64bit
arches; except on sparc where the range is 4-8 for !sun4m and 4-64 for sun4m,
selected at runtime.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.67 2005/05/01 18:15:46 miod Exp $	*/
a221 11
#endif

#if defined(SUN4M)
	/*
	 * Allow a larger kernel malloc space on sun4m.
	 */
	if (CPU_ISSUN4M) {
		extern u_int nkmempages_max;

		nkmempages_max = NKMEMPAGES_MAX_DEFAULT_SUN4M;
	}
@


1.67
log
@When parsing the bootpath, correctly handle ":foo" modifiers if they are
more than one-letter wrong; fixes boot device determination with
  /.../ledma:tpe/le...
strings (PR #4192)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.66 2005/04/21 00:15:43 deraadt Exp $	*/
d222 11
@


1.66
log
@correct idiom for snprintf failure handling; ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.65 2005/04/11 01:50:07 miod Exp $	*/
d396 14
a409 3
				if (*cp == ':')
					/* XXX - we handle just one char */
					bp->val[2] = *++cp - 'a', ++cp;
@


1.65
log
@Kill unused hexatoi()
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.64 2005/03/23 17:10:24 miod Exp $	*/
d1915 1
a1915 1
		if (len >= sizeof(buf))
@


1.64
log
@Kill the sparc-specific mountroot hooks (which are run before the root
filesystem is mounted, unlike the MI mountroot hooks). They were only
used to allow root on floppy in the long dead two-floppies installation
method.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.63 2005/03/21 22:41:30 miod Exp $	*/
a1599 2
u_int      hexatoi(const char *);

a2159 9
}

u_int
hexatoi(nptr)			/* atoi assuming hex, no 0x */
	const char *nptr;
{
	u_int retval;
	str2hex((char *)nptr, &retval);
	return retval;
@


1.63
log
@Remove unused st_crazymap().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.62 2005/03/15 18:47:44 miod Exp $	*/
a122 12
/*
 * The mountroot_hook is provided as a mechanism for devices to perform
 * a special function if they're the root device, such as the floppy
 * drive ejecting the current disk and prompting for a filesystem floppy.
 */
struct mountroot_hook {
	LIST_ENTRY(mountroot_hook) mr_link;
	struct	device *mr_device;
	void	(*mr_func)(struct device *);
};
LIST_HEAD(, mountroot_hook) mrh_list;

a754 3
	/* Initialize the mountroot_hook list. */
	LIST_INIT(&mrh_list);

a1874 18
void
mountroot_hook_establish(func, dev)
	void (*func)(struct device *);
	struct device *dev;
{
	struct mountroot_hook *mrhp;

	mrhp = (struct mountroot_hook *)malloc(sizeof(struct mountroot_hook),
	    M_DEVBUF, M_NOWAIT);
	if (mrhp == NULL)
		panic("no memory for mountroot_hook");

	bzero(mrhp, sizeof(struct mountroot_hook));
	mrhp->mr_device = dev;
	mrhp->mr_func = func;
	LIST_INSERT_HEAD(&mrh_list, mrhp, mr_link);
}

a1892 1
	struct mountroot_hook *mrhp;
d2043 1
a2043 1
		goto gotroot;
a2086 14

gotroot:
	/*
	 * Find mountroot hook and execute.
	 */
	LIST_FOREACH(mrhp, &mrh_list, mr_link)
		if (mrhp->mr_device == bootdv) {
			if (findblkmajor(mrhp->mr_device) == major(rootdev)) 
				(*mrhp->mr_func)(bootdv);
			else
				(*mrhp->mr_func)(NULL);
			break;
		}

@


1.62
log
@If no "intr" property exists, correctly handle the "interrupts" property for
non-SBus devices, such as cgfourteen@@obio.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.61 2005/03/15 18:46:37 miod Exp $	*/
a109 1
int	st_crazymap(int);
d469 1
a469 1
 * The argument `cp' points to a string such as "xd(0,0,0)netbsd"
d624 1
a624 1
			snprintf(tmpname, sizeof tmpname, "cd"); /* netbsd uses 'cd', not 'sr'*/
a749 14
}

int
st_crazymap(n)
	int	n;
{
	static int prom_st_crazymap[8]; /* static: compute only once! */
	static int init = 0;

	if (init == 0) {
		crazymap("st-targets", prom_st_crazymap);
		init = 1;
	}
	return prom_st_crazymap[n];
@


1.61
log
@Nuke matchbyname(), which isn't used anymore.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.60 2004/12/25 23:02:25 miod Exp $	*/
d972 1
a972 1
	int len, n;
d1026 12
a1037 3
				rp->ra_intr[n].int_pri = CPU_ISSUN4M ?
				    intr_sbus2ipl_4m[interrupts[n]] :
				    intr_sbus2ipl_4c[interrupts[n]];
@


1.60
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.59 2003/06/23 09:23:31 miod Exp $	*/
a146 20

/*
 * Most configuration on the SPARC is done by matching OPENPROM Forth
 * device names with our internal names.
 */
int
matchbyname(parent, vcf, aux)
	struct device *parent;
	void *aux, *vcf;
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;

	if (CPU_ISSUN4) {
		printf("WARNING: matchbyname not valid on sun4!");
		printf("%s\n", cf->cf_driver->cd_name);
		return (0);
	}
	return (strcmp(cf->cf_driver->cd_name, ca->ca_ra.ra_name) == 0);
}
@


1.59
log
@Handle SBus cards with an "interrupts" property but no "intr" property.
Adapted from NetBSD in a quite ugly way, but it works...

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.58 2003/06/02 23:27:55 millert Exp $	*/
d1850 1
a1850 2
		for (dv = alldevs.tqh_first; dv != NULL;
		    dv = dv->dv_list.tqe_next) {
d1890 1
a1890 1
	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
d2152 1
a2152 2
	for (mrhp = mrh_list.lh_first; mrhp != NULL;
	     mrhp = mrhp->mr_link.le_next)
d2218 1
a2218 1
	struct device *dev = alldevs.tqh_first;
d2232 1
a2232 1
		if ((dev = dev->dv_list.tqe_next) == NULL)
@


1.58
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.57 2003/05/13 22:25:33 miod Exp $	*/
d140 8
d992 1
a992 1
	register int len;
d1031 26
a1073 1
			/* Look at "interrupts" property too? */
@


1.57
log
@Nuke a few simple commons.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.56 2003/04/06 18:54:19 ho Exp $	*/
d28 1
a28 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.56
log
@strcat/strcpy/sprintf cleanup. krw@@, anil@@ ok. art@@ tested sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.55 2003/01/22 19:01:19 miod Exp $	*/
a96 1
int	cold;		/* if 1, still working on cold-start */
@


1.55
log
@Correctly handle the case where the "address" property of a zs node is
multivalued, as on the Voyager. This makes the zs probe work correctly on
these machines, and do not change behaviour on others.

Adapted from a similar fix in NetBSD.

Tested on Voyager by Takeshi Morimoto.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.54 2002/09/03 23:20:42 miod Exp $	*/
d499 1
a499 1
	strcpy((BP)->name, N); \
d535 1
a535 1
			sprintf(tmpname,"x%cc", cp[1]); /* e.g. xdc */
d537 1
a537 1
			sprintf(tmpname,"%c%c", cp[0], cp[1]);
d548 1
a548 1
			sprintf(tmpname,"%c%c", cp[0], cp[1]);
d594 1
a594 1
			sprintf(tmpname, "%c%c", cp[0], cp[1]);
d642 1
a642 1
			sprintf(tmpname, "cd"); /* netbsd uses 'cd', not 'sr'*/
d644 1
a644 1
			sprintf(tmpname,"%c%c", cp[0], cp[1]);
d924 1
a924 1
	sprintf(buf, "%d", freq / 1000);
d929 1
a929 1
		sprintf(p, "%d", freq);
d1149 2
a1150 1
		sprintf(mainbus_model, "SUN-4/%d series", cpuinfo.classlvl);
d1152 2
a1153 1
		strcat(mainbus_model, getpropstring(ca->ca_ra.ra_node, "name"));
d1701 1
a1701 1
		sprintf(buf,
d1705 1
a1705 1
		sprintf(buf,
d1948 2
a1949 1
		len = sprintf(buf, "%s%d", findblkname(majdev), unit);
d1974 1
a1974 1
				strcpy(buf, bootdv->dv_xname);
d2197 1
a2197 1
	sprintf(num, "%d", unit);
d2202 2
a2203 2
	strcpy(fullname, name);
	strcat(fullname, num);
@


1.54
log
@Old (rev 1) OpenPROM will always report as the "fb" node, the first
framebuffer found, even if the PROM environment is set to serial console.
Hence, make sure we won't consider this "fb" node as valid until we are
really using a graphics console.

Will makes drahn@@'s IPC happy, and ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.53 2002/08/12 10:44:04 miod Exp $	*/
d1345 1
a1345 1
		register int node;
d1355 14
a1368 3
			if (getpropint(node, "slave", -1) == zs)
				return ((void *)getpropint(node, "address", 0));
			node = nextsibling(node);
@


1.53
log
@Convert sparc console code from rcons and pseudo-devices to rasops and wscons.
For most framebuffers it is faster.

Other changes include:
o 24 bit support in tcx(4) for the S24 framebuffer
o accelerated cgsix(4) text console
o new cgtwelve(4) driver for the GS framebuffer
o improved serial driver code
o better keyboard support

The following framebuffers have not been tested but should work: cgfour,
cgeight and cgfourteen

These changes will require XF4 changes, to use Xwsfb instead of Xsun*, to be
commited later today.

Most of the work by me during the LSM and the week after, with code borrowed
from jason@@, NetBSD (new serial code), and feedback from mickey@@. Work on
pnozz(4) done by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.52 2002/04/26 17:08:36 art Exp $	*/
d1224 13
a1236 3
	if (promvec->pv_romvec_vers <= 2)
		/* remember which frame buffer, if any, is to be /dev/fb */
		fbnode = getpropint(node, "fb", 0);
@


1.52
log
@Fix spelling in comment and some whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.51 2002/04/11 05:40:51 jason Exp $	*/
d248 1
a248 3
#ifdef KGDB
	zs_kgdb_init();		/* XXX */
#endif
d474 1
a474 1
			printf("kernel not compiled with KGDB\n");
a1649 1
#ifdef RASTERCONSOLE
a1688 1
#endif
@


1.51
log
@Make sure this always prints the 'root on' line.  Also, treat ramdisks
as disks in a few other places so that autoconf doesn't complain:
'use one of: ...' when rd0 is wired as root.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.50 2002/03/14 03:16:00 millert Exp $	*/
d392 1
a392 1
	 * XXX	DO THIS BEFORE pmap_boostrap?
a893 1

@


1.50
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.49 2002/03/14 01:26:44 millert Exp $	*/
d141 4
d1801 3
d1838 7
d1848 3
d1915 3
d1919 1
d2051 3
@


1.49
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.48 2002/02/15 20:45:30 nordin Exp $	*/
d323 2
a324 2
/*		printf("SINTR: mask: 0x%x, pend: 0x%x\n", *(int*)ICR_SI_MASK,
		       *(int*)ICR_SI_PEND);
@


1.48
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.47 2002/01/16 20:50:17 miod Exp $	*/
d107 13
a119 13
void	setroot __P((void));
static	char *str2hex __P((char *, int *));
static	int getstr __P((char *, int));
int	findblkmajor __P((struct device *));
char	*findblkname __P((int));
static	struct device *getdisk __P((char *, int, int, dev_t *));
static	int mbprint __P((void *, const char *));
static	void crazymap __P((char *, int *));
int	st_crazymap __P((int));
void	swapconf __P((void));
void	sync_crash __P((void));
int	mainbus_match __P((struct device *, void *, void *));
static	void mainbus_attach __P((struct device *, struct device *, void *));
d123 4
a126 4
static	void bootpath_build __P((void));
static	void bootpath_fake __P((struct bootpath *, char *));
static	void bootpath_print __P((struct bootpath *));
int	search_prom __P((int, char *));
d137 1
a137 1
	void	(*mr_func) __P((struct device *));
d205 1
a205 1
		extern void oldmon_w_cmd __P((u_long, char *));
d275 1
a275 1
		extern void setpte4m __P((u_int, u_int));
d1589 1
a1589 1
u_int      hexatoi __P((const char *));
d1856 1
a1856 1
	void (*func) __P((struct device *));
@


1.47
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.46 2001/12/10 00:58:04 miod Exp $	*/
d1272 1
a1272 1
				(void) splx(11 << 8);		/*XXX*/
@


1.46
log
@No need to include <sys/dmap.h> and define related variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.45 2001/12/08 02:24:07 art Exp $	*/
a52 1
#include <sys/map.h>
@


1.46.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.47 2002/01/16 20:50:17 miod Exp $	*/
d53 1
@


1.46.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.46.2.1 2002/01/31 22:55:22 niklas Exp $	*/
d107 13
a119 13
void	setroot(void);
static	char *str2hex(char *, int *);
static	int getstr(char *, int);
int	findblkmajor(struct device *);
char	*findblkname(int);
static	struct device *getdisk(char *, int, int, dev_t *);
static	int mbprint(void *, const char *);
static	void crazymap(char *, int *);
int	st_crazymap(int);
void	swapconf(void);
void	sync_crash(void);
int	mainbus_match(struct device *, void *, void *);
static	void mainbus_attach(struct device *, struct device *, void *);
d123 4
a126 4
static	void bootpath_build(void);
static	void bootpath_fake(struct bootpath *, char *);
static	void bootpath_print(struct bootpath *);
int	search_prom(int, char *);
d137 1
a137 1
	void	(*mr_func)(struct device *);
a140 4
#ifdef RAMDISK_HOOKS
static struct device fakerdrootdev = { DV_DISK, {}, NULL, 0, "rd0", NULL };
#endif

d205 1
a205 1
		extern void oldmon_w_cmd(u_long, char *);
d275 1
a275 1
		extern void setpte4m(u_int, u_int);
d323 2
a324 2
/*		printf("SINTR: mask: 0x%x, pend: 0x%x\n", *(int *)ICR_SI_MASK,
		       *(int *)ICR_SI_PEND);
d388 1
a388 1
	 * XXX	DO THIS BEFORE pmap_bootstrap?
d891 1
d1272 1
a1272 1
				splx(11 << 8);		/*XXX*/
d1589 1
a1589 1
u_int      hexatoi(const char *);
a1796 3
#ifdef RAMDISK_HOOKS
		printf(" %s[a-p]", fakerdrootdev.dv_xname);
#endif
a1830 7
#ifdef RAMDISK_HOOKS
	if (strcmp(str, fakerdrootdev.dv_xname) == 0) {
		dv = &fakerdrootdev;
		goto gotdisk;
	}
#endif

a1833 3
#ifdef RAMDISK_HOOKS
gotdisk:
#endif
d1856 1
a1856 1
	void (*func)(struct device *);
a1897 3
#ifdef RAMDISK_HOOKS
	bootdv = &fakerdrootdev;
#else
a1898 1
#endif
a2029 3
		if (bootdv->dv_class == DV_DISK)
			printf("root on %s%c\n", bootdv->dv_xname,
			    part + 'a');
@


1.46.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.46.2.2 2002/06/11 03:38:16 art Exp $	*/
d248 3
a250 1
	/* Moved zs_kgdb_init() to zs.c:consinit() */
d476 1
a476 1
			printf("kernel has no debugger\n");
d1226 3
a1228 13
	if (promvec->pv_romvec_vers <= 2) {
		/*
		 * Revision 1 prom will always return a framebuffer device
		 * node if a framebuffer is installed, even if console is
		 * set to serial.
		 */
		if (*promvec->pv_stdout != PROMDEV_SCREEN)
			fbnode = 0;
		else {
			/* remember which frame buffer is the console */
			fbnode = getpropint(node, "fb", 0);
		}
	}
d1652 1
d1692 1
@


1.46.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d97 1
d499 1
a499 1
	strlcpy((BP)->name, N, sizeof (BP)->name); \
d535 1
a535 1
			snprintf(tmpname,sizeof tmpname,"x%cc", cp[1]); /* e.g. xdc */
d537 1
a537 1
			snprintf(tmpname,sizeof tmpname,"%c%c", cp[0], cp[1]);
d548 1
a548 1
			snprintf(tmpname,sizeof tmpname,"%c%c", cp[0], cp[1]);
d594 1
a594 1
			snprintf(tmpname, sizeof tmpname, "%c%c", cp[0], cp[1]);
d642 1
a642 1
			snprintf(tmpname, sizeof tmpname, "cd"); /* netbsd uses 'cd', not 'sr'*/
d644 1
a644 1
			snprintf(tmpname, sizeof tmpname, "%c%c", cp[0], cp[1]);
d924 1
a924 1
	snprintf(buf, sizeof buf, "%d", freq / 1000);
d929 1
a929 1
		snprintf(p, buf + sizeof buf - p, "%d", freq);
d1149 1
a1149 2
		snprintf(mainbus_model, sizeof mainbus_model,
			"SUN-4/%d series", cpuinfo.classlvl);
d1151 1
a1151 2
		strlcat(mainbus_model, getpropstring(ca->ca_ra.ra_node,"name"),
			sizeof mainbus_model);
d1345 1
a1345 1
		int node;
d1355 3
a1357 14
			int vaddrs[10];

			if (getpropint(node, "slave", -1) != zs) {
				node = nextsibling(node);
				continue;
			}

			/*
			 * On some machines (e.g. the Voyager), the zs
			 * device has multi-valued register properties.
			 */
			if (getprop(node, "address",
			    (void *)vaddrs, sizeof(vaddrs)) != 0)
				return ((void *)vaddrs[0]);
d1688 1
a1688 1
		snprintf(buf, sizeof buf,
d1692 1
a1692 1
		snprintf(buf, sizeof buf,
d1935 1
a1935 2
		len = snprintf(buf, sizeof buf, "%s%d", findblkname(majdev),
			unit);
d1960 1
a1960 1
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
d2183 1
a2183 1
	snprintf(num, sizeof num, "%d", unit);
d2188 2
a2189 2
	strlcpy(fullname, name, sizeof fullname);
	strlcat(fullname, num, sizeof fullname);
@


1.45
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.44 2001/12/05 23:58:41 tdeval Exp $	*/
a59 1
#include <sys/dmap.h>
@


1.44
log
@Enable rootdev auto-configuration by device drivers during boot.
Add support for "raid" devices (prepare future raidframe changes).

OK deraadt@@, Reviewed by drahn@@, jason@@, mickey@@ and miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.43 2001/11/22 09:45:42 art Exp $	*/
d356 1
@


1.43
log
@Map the interrupt enable register with pmap_kenter
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.42 2001/11/06 19:53:16 miod Exp $	*/
d112 2
a113 1
static	int findblkmajor __P((struct device *));
d1753 2
a1754 2
	{ "xy",		3 },
	{ "sd",		7 },
d1760 1
d1763 1
a1763 1
static int
d1768 1
a1768 1
	register int i;
d1771 1
a1771 1
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[0].name)) == 0)
d1776 12
d1900 16
@


1.42
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.41 2001/09/19 21:32:19 miod Exp $	*/
d352 1
a352 1
		pmap_enter(pmap_kernel(), INTRREG_VA,
d354 1
a354 2
			   VM_PROT_READ | VM_PROT_WRITE,
			   VM_PROT_READ | VM_PROT_WRITE | PMAP_WIRED);
@


1.41
log
@Now is a good time to commit this cosmetic maxpartition-related change...
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.40 2001/07/25 13:25:33 art Exp $	*/
d71 1
a71 1
#include <vm/vm.h>
@


1.40
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.39 2001/05/05 22:34:18 art Exp $	*/
d1788 1
a1788 1
				printf(" %s[a-h]", dv->dv_xname);
@


1.39
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.38 2001/04/30 16:42:25 art Exp $	*/
d354 2
a355 2
			   VM_PROT_READ | VM_PROT_WRITE, 1,
			   VM_PROT_READ | VM_PROT_WRITE);
@


1.38
log
@Move the zeroing of proc0 u area from cpu_startup to configure.
XXX - is this still necessary?
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.37 2001/01/29 03:59:05 jason Exp $	*/
d790 1
a790 1
configure()
d843 1
a843 1
			panic("configure: no memreg found!");
d850 1
a850 1
			panic("configure: ROM hasn't mapped memreg!");
d1071 1
a1071 1
 * Our main job is to attach the CPU (the root node we got in configure())
@


1.37
log
@bring sparc into the 20th century, add support for 'boot -c' (BOOT_CONFIG)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.36 2000/07/25 18:03:03 deraadt Exp $	*/
d65 1
d795 2
d891 12
@


1.36
log
@remove debugging stuff i commited by accident
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.35 2000/07/14 20:27:32 deraadt Exp $	*/
d460 4
d800 8
@


1.35
log
@on a SparcStation Voyager, the 2nd zs device does not exist.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.34 2000/02/22 19:27:59 deraadt Exp $	*/
a1316 1
		printf("[zs%d]", zs);
a1321 1
		printf("huh");
@


1.34
log
@enlarge msgbuf, somewhat line netbsd did
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.33 1999/12/08 23:49:07 deraadt Exp $	*/
d1308 1
a1308 1
		register int node, addr;
d1314 1
a1314 1
			    panic("findzs: no obio node");
d1317 1
d1319 2
a1320 5
			if (getpropint(node, "slave", -1) == zs) {
				if ((addr = getpropint(node, "address", 0)) == 0)
					panic("findzs: zs%d not mapped by PROM", zs);
				return ((void *)addr);
			}
d1323 2
@


1.33
log
@only replace .mul/.umul on v8 cpus
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.32 1999/12/07 00:49:07 deraadt Exp $	*/
a202 2
	extern int msgbufmapped;

a205 8
		extern struct msgbuf *msgbufp;
		/*
		 * XXX
		 * Some boot programs mess up physical page 0, which
		 * is where we want to put the msgbuf. There's some
		 * room, so shift it over half a page.
		 */
		msgbufp = (struct msgbuf *)((caddr_t) msgbufp + 4096);
a243 1
	msgbufmapped = 1;	/* enable message buffer */
@


1.33.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d203 2
d208 8
d254 1
@


1.33.2.2
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.37 2001/01/29 03:59:05 jason Exp $	*/
a459 4
		case 'c':
			boothowto |= RB_CONFIG;
			break;

a796 8
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}

d1308 1
a1308 1
		register int node;
d1314 1
a1314 1
				panic("findzs: no obio node");
d1318 5
a1322 2
			if (getpropint(node, "slave", -1) == zs)
				return ((void *)getpropint(node, "address", 0));
a1324 1
		return (NULL);
@


1.33.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.33.2.2 2001/05/14 21:37:14 niklas Exp $	*/
a64 1
#include <sys/user.h>
d789 1
a789 1
cpu_configure()
a793 2
	int s;
	extern struct user *proc0paddr;
d840 1
a840 1
			panic("cpu_configure: no memreg found!");
d847 1
a847 1
			panic("cpu_configure: ROM hasn't mapped memreg!");
a887 12


	/*
	 * Re-zero proc0's user area, to nullify the effect of the
	 * stack running into it during auto-configuration.
	 * XXX - should fix stack usage.
	 */
	s = splhigh();
	bzero(proc0paddr, sizeof(struct user));

	pmap_redzone();
	splx(s);
d1056 1
a1056 1
 * Our main job is to attach the CPU (the root node we got in cpu_configure())
@


1.33.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.33.2.3 2001/07/04 10:23:35 niklas Exp $	*/
d354 2
a355 2
			   VM_PROT_READ | VM_PROT_WRITE,
			   VM_PROT_READ | VM_PROT_WRITE | PMAP_WIRED);
d1788 1
a1788 1
				printf(" %s[a-p]", dv->dv_xname);
@


1.33.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d71 1
a71 1
#include <uvm/uvm_extern.h>
@


1.33.2.6
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.33.2.5 2001/11/13 21:04:17 niklas Exp $	*/
d352 1
a352 1
		pmap_kenter_pa(INTRREG_VA,
d354 2
a355 1
			   VM_PROT_READ | VM_PROT_WRITE);
@


1.33.2.7
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 1
d60 1
d112 1
a112 2
int	findblkmajor __P((struct device *));
char	*findblkname __P((int));
a354 1
		pmap_update(pmap_kernel());
d1272 1
a1272 1
				splx(11 << 8);		/*XXX*/
d1752 2
a1753 2
	{ "xy",		 3 },
	{ "sd",		 7 },
a1758 1
	{ "raid",	25 },
d1761 1
a1761 1
int
d1766 1
a1766 1
	int i;
d1769 1
a1769 1
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)) == 0)
a1773 12
char *
findblkname(maj)
	int maj;
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	return (NULL);
}

a1885 16

	/*
	 * (raid) device auto-configuration could have returned
	 * the root device's id in rootdev.  Check this case.
	 */
	if (rootdev != NODEV) {
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);

		len = sprintf(buf, "%s%d", findblkname(majdev), unit);
		if (len >= sizeof(buf))
			panic("setroot: device name too long");

		bootdv = getdisk(buf, len, part, &rootdev);
	}
@


1.33.2.8
log
@Merge in -current from about a week ago
@
text
@d107 13
a119 13
void	setroot(void);
static	char *str2hex(char *, int *);
static	int getstr(char *, int);
int	findblkmajor(struct device *);
char	*findblkname(int);
static	struct device *getdisk(char *, int, int, dev_t *);
static	int mbprint(void *, const char *);
static	void crazymap(char *, int *);
int	st_crazymap(int);
void	swapconf(void);
void	sync_crash(void);
int	mainbus_match(struct device *, void *, void *);
static	void mainbus_attach(struct device *, struct device *, void *);
d123 4
a126 4
static	void bootpath_build(void);
static	void bootpath_fake(struct bootpath *, char *);
static	void bootpath_print(struct bootpath *);
int	search_prom(int, char *);
d137 1
a137 1
	void	(*mr_func)(struct device *);
d205 1
a205 1
		extern void oldmon_w_cmd(u_long, char *);
d275 1
a275 1
		extern void setpte4m(u_int, u_int);
d323 2
a324 2
/*		printf("SINTR: mask: 0x%x, pend: 0x%x\n", *(int *)ICR_SI_MASK,
		       *(int *)ICR_SI_PEND);
d1589 1
a1589 1
u_int      hexatoi(const char *);
d1856 1
a1856 1
	void (*func)(struct device *);
@


1.33.2.9
log
@Sync the SMP branch with 3.3
@
text
@a140 4
#ifdef RAMDISK_HOOKS
static struct device fakerdrootdev = { DV_DISK, {}, NULL, 0, "rd0", NULL };
#endif

d244 3
a246 1
	/* Moved zs_kgdb_init() to zs.c:consinit() */
d388 1
a388 1
	 * XXX	DO THIS BEFORE pmap_bootstrap?
d472 1
a472 1
			printf("kernel has no debugger\n");
d891 1
d1223 3
a1225 13
	if (promvec->pv_romvec_vers <= 2) {
		/*
		 * Revision 1 prom will always return a framebuffer device
		 * node if a framebuffer is installed, even if console is
		 * set to serial.
		 */
		if (*promvec->pv_stdout != PROMDEV_SCREEN)
			fbnode = 0;
		else {
			/* remember which frame buffer is the console */
			fbnode = getpropint(node, "fb", 0);
		}
	}
d1334 1
a1334 1
		int node;
d1344 3
a1346 14
			int vaddrs[10];

			if (getpropint(node, "slave", -1) != zs) {
				node = nextsibling(node);
				continue;
			}

			/*
			 * On some machines (e.g. the Voyager), the zs
			 * device has multi-valued register properties.
			 */
			if (getprop(node, "address",
			    (void *)vaddrs, sizeof(vaddrs)) != 0)
				return ((void *)vaddrs[0]);
d1649 1
d1689 1
a1796 3
#ifdef RAMDISK_HOOKS
		printf(" %s[a-p]", fakerdrootdev.dv_xname);
#endif
a1830 7
#ifdef RAMDISK_HOOKS
	if (strcmp(str, fakerdrootdev.dv_xname) == 0) {
		dv = &fakerdrootdev;
		goto gotdisk;
	}
#endif

a1833 3
#ifdef RAMDISK_HOOKS
gotdisk:
#endif
a1897 3
#ifdef RAMDISK_HOOKS
	bootdv = &fakerdrootdev;
#else
a1898 1
#endif
a2029 3
		if (bootdv->dv_class == DV_DISK)
			printf("root on %s%c\n", bootdv->dv_xname,
			    part + 'a');
@


1.33.2.10
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.33.2.9 2003/03/27 23:49:26 niklas Exp $	*/
d499 1
a499 1
	strlcpy((BP)->name, N, sizeof (BP)->name); \
d535 1
a535 1
			snprintf(tmpname,sizeof tmpname,"x%cc", cp[1]); /* e.g. xdc */
d537 1
a537 1
			snprintf(tmpname,sizeof tmpname,"%c%c", cp[0], cp[1]);
d548 1
a548 1
			snprintf(tmpname,sizeof tmpname,"%c%c", cp[0], cp[1]);
d594 1
a594 1
			snprintf(tmpname, sizeof tmpname, "%c%c", cp[0], cp[1]);
d642 1
a642 1
			snprintf(tmpname, sizeof tmpname, "cd"); /* netbsd uses 'cd', not 'sr'*/
d644 1
a644 1
			snprintf(tmpname, sizeof tmpname, "%c%c", cp[0], cp[1]);
d924 1
a924 1
	snprintf(buf, sizeof buf, "%d", freq / 1000);
d929 1
a929 1
		snprintf(p, buf + sizeof buf - p, "%d", freq);
d1149 1
a1149 2
		snprintf(mainbus_model, sizeof mainbus_model,
			"SUN-4/%d series", cpuinfo.classlvl);
d1151 1
a1151 2
		strlcat(mainbus_model, getpropstring(ca->ca_ra.ra_node,"name"),
			sizeof mainbus_model);
d1699 1
a1699 1
		snprintf(buf, sizeof buf,
d1703 1
a1703 1
		snprintf(buf, sizeof buf,
d1946 1
a1946 2
		len = snprintf(buf, sizeof buf, "%s%d", findblkname(majdev),
			unit);
d1971 1
a1971 1
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
d2194 1
a2194 1
	snprintf(num, sizeof num, "%d", unit);
d2199 2
a2200 2
	strlcpy(fullname, name, sizeof fullname);
	strlcat(fullname, num, sizeof fullname);
@


1.33.2.11
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d97 1
@


1.33.2.12
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.33.2.11 2003/05/16 00:29:40 niklas Exp $	*/
d28 5
a32 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.33.2.13
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a139 8
/* Translate SBus interrupt level to processor IPL */
int	intr_sbus2ipl_4c[] = {
	0, 1, 2, 3, 5, 7, 8, 9
};
int	intr_sbus2ipl_4m[] = {
	0, 2, 3, 5, 7, 9, 11, 13
};

d984 1
a984 1
	int len, n;
a1022 26

	/*
	 * Some SBus cards only provide an "interrupts" properly, listing
	 * SBus levels. But since obio devices will usually also provide
	 * both properties, only check for "interrupts" last.
	 */
	if (len == 0) {
		u_int32_t *interrupts;
		len = getproplen(node, "interrupts");
		if (len > 0 &&
		    (interrupts = malloc(len, M_TEMP, M_NOWAIT)) != NULL) {
			/* Build rom_intr structures from the list */
			getprop(node, "interrupts", interrupts, len);
			len /= sizeof(u_int32_t);
			for (n = 0; n < len; n++) {
				rp->ra_intr[n].int_pri = CPU_ISSUN4M ?
				    intr_sbus2ipl_4m[interrupts[n]] :
				    intr_sbus2ipl_4c[interrupts[n]];
				rp->ra_intr[n].int_vec = 0;
			};
			len *= sizeof(struct rom_intr);
			free(interrupts, M_TEMP);
		} else
			len = 0;
	}

d1040 1
@


1.32
log
@move .mul and .umul into the kernel.  if v8 sparc is detected, replace with
the equivelant 2-instruction sequence.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.31 1999/09/03 18:01:57 art Exp $	*/
a288 9
		extern void *_umulreplace, *_umul, *_umulreplace_end;
		extern void *_mulreplace, *_mul, *_mulreplace_end;

		/*
		 * Whack the slow sun4/sun4c umul/mul functions with
		 * fast V8 ones
		 */
		bcopy(_umulreplace, _umul, _umulreplace_end-_umulreplace);
		bcopy(_mulreplace, _mul, _mulreplace_end-_mulreplace);
@


1.31
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.30 1999/03/17 22:56:24 deraadt Exp $	*/
d289 9
@


1.30
log
@do not toast later swdevt[] entries
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.29 1999/01/11 05:11:58 millert Exp $	*/
d364 2
a365 1
			   VM_PROT_READ | VM_PROT_WRITE, 1);
@


1.29
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.28 1998/04/17 18:18:02 deraadt Exp $	*/
d1953 1
a1953 1
		swdevt[1].sw_dev = NODEV;
d1979 1
a1979 1
		swdevt[1].sw_dev = NODEV;
@


1.28
log
@put arch type into hw.model, sun4 installboot now works; jason
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.27 1998/03/25 07:54:57 jason Exp $	*/
d853 1
a853 1
			panic("PROM root device type = %s (need CPU)\n", cp);
@


1.27
log
@Driver for the 8 leds on the back of sun4 machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.26 1998/03/09 09:15:28 deraadt Exp $	*/
d127 1
d1132 1
a1132 1
		printf(": SUN-4/%d series\n", cpuinfo.classlvl);
d1134 2
a1135 1
		printf(": %s\n", getpropstring(ca->ca_ra.ra_node, "name"));
@


1.26
log
@print hotfix info at end of cpu attach line
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.25 1998/02/26 10:38:58 johns Exp $	*/
d1077 1
@


1.25
log
@Backout of Jason's cpu init changes, causes an immediate panic on sun4m
machines..
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.23 1997/11/11 10:24:07 niklas Exp $	*/
d1064 1
a1065 1
	struct confargs *ca = aux;
a1128 1
#if defined(SUN4M)
a1132 2
#endif
	printf("\n");
@


1.24
log
@Change order of cpu initialization to force the correct dmesg output.
@
text
@d1146 5
d1179 27
@


1.23
log
@unused variable under certain conditions
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.22 1997/08/08 08:27:01 downsj Exp $	*/
a1145 5
		/* Configure the CPU. */
		bzero(&oca, sizeof(oca));
		oca.ca_ra.ra_name = "cpu";
		(void)config_found(dev, (void *)&oca, mbprint);

a1173 27

	/* the first early device to be configured is the cpu */
	if (CPU_ISSUN4M) {
		/* XXX - what to do on multiprocessor machines? */
		register const char *cp;

		for (node = firstchild(node); node; node = nextsibling(node)) {
			cp = getpropstring(node, "device_type");
			if (strcmp(cp, "cpu") == 0) {
				bzero(&oca, sizeof(oca));
				oca.ca_ra.ra_node = node;
				oca.ca_ra.ra_name = "cpu";
				oca.ca_ra.ra_paddr = 0;
				oca.ca_ra.ra_nreg = 0;
				config_found(dev, (void *)&oca, mbprint);
			}
		}
	} else if (CPU_ISSUN4C) {
		bzero(&oca, sizeof(oca));
		oca.ca_ra.ra_node = node;
		oca.ca_ra.ra_name = "cpu";
		oca.ca_ra.ra_paddr = 0;
		oca.ca_ra.ra_nreg = 0;
		config_found(dev, (void *)&oca, mbprint);
	}

	node = ca->ca_ra.ra_node;	/* re-init root node */
@


1.22
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d474 2
d1064 1
a1065 1
#if defined(SUN4C) || defined(SUN4M)
@


1.21
log
@Inhbit the silly "Insert fileystem floppy" message when booting from floppy
and root isn't really going to be mounted on the floppy, i.e. ramdisk...
@
text
@d1 2
a2 1
/*	$NetBSD: autoconf.c,v 1.58.2.2 1996/07/02 23:49:54 jtc Exp $ */
d83 1
a191 3

struct idprom idprom;
void	getidprom __P((struct idprom *, int size));
a201 1
	int nregion = 0, nsegment = 0, ncontext = 0;
a242 25
		getidprom(&idprom, sizeof(idprom));
		switch (cpumod = idprom.id_machine) {
		case SUN4_100:
			nsegment = 256;
			ncontext = 8;
			break;
		case SUN4_200:
			nsegment = 512;
			ncontext = 16;
			break;
		case SUN4_300:
			nsegment = 256;
			ncontext = 16;
			break;
		case SUN4_400:
			nsegment = 1024;
			ncontext = 64;
			nregion = 256;
			mmu_3l = 1;
			break;
		default:
			printf("bootstrap: sun4 machine type %2x unknown!\n",
			    idprom.id_machine);
			callrom();
		}
d246 7
a252 43
#if defined(SUN4C)
	if (CPU_ISSUN4C) {
		register int node = findroot();
		nsegment = getpropint(node, "mmu-npmg", 128);
		ncontext = getpropint(node, "mmu-nctx", 8);
	}
#endif /* SUN4C */

#if defined (SUN4M)
	if (CPU_ISSUN4M) {
		nsegment = 0;
		cpumod = (u_int) getpsr() >> 24;
		mmumod = (u_int) lda(SRMMU_PCR, ASI_SRMMU) >> 28;
		/*
		 * We use the max. number of contexts on the micro and
		 * hyper SPARCs. The SuperSPARC would let us use up to 65536
		 * contexts (by powers of 2), but we keep it at 4096 since
		 * the table must be aligned to #context*4. With 4K contexts,
		 * we waste at most 16K of memory. Note that the context
		 * table is *always* page-aligned, so there can always be
		 * 1024 contexts without sacrificing memory space (given
		 * that the chip supports 1024 contexts).
		 *
		 * Currently known limits: MS2=256, HS=4096, SS=65536
		 * 	some old SS's=4096
		 *
		 * XXX Should this be a tuneable parameter?
		 */
		switch (mmumod) {
		case SUN4M_MMU_MS1:
			ncontext = 64;
			break;
		case SUN4M_MMU_MS:
			ncontext = 256;
			break;
		default:
			ncontext = 4096;
			break;
		}
	}
#endif /* SUN4M */

	pmap_bootstrap(ncontext, nregion, nsegment);
d358 9
d566 3
a568 3
			switch (cpumod) {
			case SUN4_200:
			case SUN4_400:
d572 1
a572 1
			case SUN4_100:
d576 1
a576 1
			case SUN4_300:
d581 2
a582 2
				panic("bootpath_fake: unknown cpumod %d",
				      cpumod);
d664 2
d824 2
a825 1
			if (cpumod==SUN4_100 && (cf->cf_loc[0] & 0xf0000000))
d827 2
a828 1
			if (cpumod!=SUN4_100 && !(cf->cf_loc[0] & 0xf0000000))
d834 1
a834 1
		if (memregcf==NULL)
d837 1
a837 1
		rr.rr_iospace = BUS_OBIO;
d840 1
a840 1
		par_err_reg = (u_int *)bus_map(&rr, NBPG, BUS_OBIO);
d864 10
a1029 11
#if defined(SUN4M)
	if (CPU_ISSUN4M) {
		len = getprop(node, "ranges", (void *)&rp->ra_range,
			      sizeof rp->ra_range);
		if (len == -1)
			len = 0;
		rp->ra_nrange = len / sizeof(struct rom_range);
	} else
#endif
		rp->ra_nrange = 0;

d1062 1
a1063 1
	struct confargs *ca = aux;
d1128 4
a1131 2
	if (CPU_ISSUN4M)
		printf(": %s", getpropstring(ca->ca_ra.ra_node, "name"));
a1178 1
#if defined(SUN4M)
d1185 8
a1192 2
			if (strcmp(cp, "cpu") == 0)
				break;
d1194 7
a1200 2
		if (node == 0)
			panic("None of the CPUs found\n");
a1201 7
#endif

	oca.ca_ra.ra_node = node;
	oca.ca_ra.ra_name = "cpu";
	oca.ca_ra.ra_paddr = 0;
	oca.ca_ra.ra_nreg = 0;
	config_found(dev, (void *)&oca, mbprint);
a1259 6
#if defined(SUN4M)
	if (CPU_ISSUN4M) {
		/* Enable device interrupts */
		ienab_bic(SINTR_MA);
	}
#endif
d1306 1
a1306 1
		rr.rr_iospace = BUS_OBIO;
d1308 1
a1308 1
		vaddr = bus_map(&rr, NBPG, BUS_OBIO);
d1488 1
a1488 1
		printf("node %x property %s length %d > %d\n",
d1502 13
a1572 1
char    *strchr __P((const char *, int));
d1661 1
a1661 1
	if (promvec->pv_romvec_vers < 2 || promvec->pv_printrev < 0x00020007)
a1670 2
	if (*rowp == *colp && *rowp != NULL)
		panic("romgetcursor prom version");
a2123 19

/*
 * The $#!@@$&%# kernel library doesn't have strchr or atoi. Ugh. We duplicate
 * here.
 */

char *
strchr(p, ch)			/* cribbed from libc */
	register const char *p, ch;
{
	for (;; ++p) {
		if (*p == ch)
			return((char *)p);
		if (!*p)
			return((char *)NULL);
	}
	/* NOTREACHED */
}

a2131 1

@


1.20
log
@1.18 was wrong; vm_swap miniroot recovery fixed
@
text
@d1911 1
a1911 1
	bootdv = bp == NULL ? NULL : bp->dev;
d2082 4
a2085 1
			(*mrhp->mr_func)(bootdv);
@


1.19
log
@add rd to boot -a
@
text
@a2017 2
		if (nswapdev == rootdev)
			nswapdev = NODEV;
@


1.18
log
@if generic miniroot, kill swap entry
@
text
@d1783 1
@


1.17
log
@line#/column# changed at 2.7, not 2.9; grr
@
text
@d2017 2
@


1.16
log
@fix MAXPARTITIONS problems, PR#138, grr@@shandakor.tharsis.com
@
text
@d1701 1
a1701 1
	if (promvec->pv_romvec_vers < 2 || promvec->pv_printrev < 0x00020009)
d1711 2
@


1.15
log
@added const to second parameter of cfprint_t routines
@
text
@a1771 3
#define	PARTITIONMASK	0x7
#define	PARTITIONSHIFT	3

d1829 1
a1829 1
	int majdev, mindev, part;
d1835 1
a1835 1
	if (c >= 'a' && c <= 'h') {
d1845 1
d1848 1
a1848 2
			mindev = (dv->dv_unit << PARTITIONSHIFT) + part;
			*devp = makedev(majdev, mindev);
d1896 1
a1896 1
	register int len, majdev, mindev;
d1968 2
a1969 2
					nswapdev = makedev(major(nrootdev),
					    (minor(nrootdev) & ~ PARTITIONMASK) | 1);
d2004 5
a2008 5
			int part = bp->val[2];
			mindev = (bootdv->dv_unit << PARTITIONSHIFT) + part;
			rootdev = makedev(majdev, mindev);
			nswapdev = dumpdev = makedev(major(rootdev),
			    (minor(rootdev) & ~ PARTITIONMASK) | 1);
d2025 2
a2026 1
		mindev = minor(rootdev);
d2040 2
a2041 1
		mindev = minor(rootdev);
d2043 1
a2043 1
		    (mindev & PARTITIONMASK) + 'a');
a2052 1
	mindev &= ~PARTITIONMASK;
d2056 1
a2056 1
		    mindev == (minor(swp->sw_dev) & ~PARTITIONMASK)) {
@


1.14
log
@use dk_mountroot
@
text
@d111 1
a111 1
static	int mbprint __P((void *, char *));
d959 1
a959 1
	char *name;
@


1.13
log
@netbsd port, now we merge our changes back in
@
text
@a1901 1
	extern int (*mountroot) __P((void *));
a1907 4
	extern int nfs_mountroot __P((void *));
#endif
#if defined(FFS)
	extern int ffs_mountroot __P((void *));
a2038 1
#if defined(FFS)
d2040 1
a2040 1
		mountroot = ffs_mountroot;
a2045 1
#endif
@


1.12
log
@from netbsd:
Move the old-style disk instrumentation "structures" to a central
location (sys/kern/subr_disk.c) and note that they should/will be
deprecated.
@
text
@d1 1
a1 1
/*	$NetBSD: autoconf.c,v 1.38 1995/10/09 22:34:03 pk Exp $ */
d4 2
a5 29
 * Copyright (c) 1995 Theo de Raadt
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
d15 1
d51 1
d62 4
a65 1
#include <sys/systm.h>
d67 1
a67 5
#include "fd.h"
#if NFD > 0
#include <sys/ioctl.h>
#include <sys/mtio.h>
#endif /* NFD */
d69 1
a69 1
#include <net/if.h>
d79 11
a98 1
int	cpumod;		/* CPU model, valid only if cputyp==CPU_SUN4 */
a100 2
extern	struct promvec *promvec;

d102 1
a102 1
extern int kgdb_debug_panic;
a105 1
int	findroot __P((void));
d107 1
d111 7
d120 1
d124 13
d150 1
a150 2
#if defined(SUN4)
	if (cputyp == CPU_SUN4) {
a154 1
#endif
d203 1
a203 1
	int nregion, nsegment, ncontext, node;
d207 3
a209 4
	extern void oldmon_w_cmd();
	extern struct msgbuf *msgbufp;

	if (cputyp == CPU_SUN4) {
d272 4
a275 3
#if defined(SUN4C) || defined(SUN4M)
	if (cputyp == CPU_SUN4C || cputyp == CPU_SUN4M) {
		node = findroot();
d279 36
a314 1
#endif /* SUN4C || SUN4M */
d316 1
a316 1
	msgbufmapped = 1;
d318 1
a318 1
	zs_kgdb_init();			/* XXX */
d324 97
a422 1

d427 2
a428 1
 * has 3 fields: name (device name), val[0], and val[1]. Note that:
d430 1
a430 1
 * if (val[0] == -1) { 
d433 3
a435 1
 *	val[0] is a sbus slot, and val[1] is an sbus offset [if sbus]
d437 1
d439 2
a440 1
static void 
a444 1
	int v0val[3];
d451 1
a451 1
	 * ###	DO THIS BEFORE pmap_boostrap?
d471 1
a471 1
		/* 
d487 3
a493 4
#ifdef notyet
			if (strcmp(bp->name, "iommu") == 0)
				continue;
#endif
d495 1
d542 1
a542 1
 * The argument `cp' points to a string such as "xd(0,0,0)bsd"
d544 1
a551 1
	char tmpname[8];
d553 1
a553 1
#define BP_APPEND(BP,N,V0,V1) { \
d557 4
a560 1
	(BP)++; }
d562 6
d571 2
a572 2
	if (*pp == '(' 					/* for vi: ) */ 
 	    && *(pp = str2hex(++pp, &v0val[0])) == ',' 
d576 3
a578 2
#ifdef SUN4
	if (cputyp == CPU_SUN4) {
d581 1
a581 1
		 *  xylogics VME dev: xd, xy, xt 
d584 1
a584 1
		if (cp[0] == 'x') { 
d586 1
a586 1
				BP_APPEND(bp,"vmel",-1,0);
d588 1
a588 1
				BP_APPEND(bp,"vmes",-1,0);
d591 1
a591 1
			BP_APPEND(bp,tmpname,-1,v0val[0]);
d593 1
a593 1
			BP_APPEND(bp,tmpname,v0val[1], v0val[2]); /* e.g. xd */
d602 1
a602 1
			BP_APPEND(bp,"obio",-1,0);
d604 1
a604 1
			BP_APPEND(bp,tmpname,-1,0);
d610 3
a612 3
		 * assume: 4/100 = sw: /obio0/sw0/sd@@0,0
		 * 4/200 & 4/400 = si/sc: /vmes0/si0/sd@@0,0
 		 * 4/300 = esp: /obio0/esp0/sd@@0,0
d615 1
a615 1
		if (cp[0] == 's' && 
d617 3
a619 1
			
d623 3
a625 5
				BP_APPEND(bp,"vmes",-1,0);
				BP_APPEND(bp,"si",-1,v0val[0]);
				sprintf(tmpname,"%c%c", cp[0], cp[1]);
				BP_APPEND(bp,tmpname,v0val[1],v0val[2]);
				return;
d627 3
a629 10
				if (v0val[0] == 0) {
					BP_APPEND(bp,"obio",-1,0);
					BP_APPEND(bp,"sw",-1,v0val[0]);
				} else {
					BP_APPEND(bp,"obio",-1,0);
					BP_APPEND(bp,"si",-1,v0val[0]-1);
				}
				sprintf(tmpname,"%c%c", cp[0], cp[1]);
				BP_APPEND(bp,tmpname,v0val[1],v0val[2]);
				return;
d631 17
a647 5
				BP_APPEND(bp,"obio",-1,0);
				BP_APPEND(bp,"esp",-1,v0val[0]);
				sprintf(tmpname,"%c%c", cp[0], cp[1]);
				BP_APPEND(bp,tmpname,v0val[1],v0val[2]);
				return;
d649 3
a651 1
			panic("bootpath_fake: unknown cpumod?");
d657 2
a658 2
		
#ifdef SUN4C
d665 1
a665 1
	 * fake looks like: /fd@@0,0
d668 5
a672 1
		BP_APPEND(bp,"fd",v0val[1],v0val[2]);
d677 1
a677 1
	 * ethenet: le
d681 2
a682 2
		BP_APPEND(bp,"sbus",-1,0);
		BP_APPEND(bp,"le",-1,v0val[0]);
d688 10
a697 8
	 * fake looks like: /sbus0/esp0/sd@@3,0
	 */		
	if (cp[0] == 's' &&
	    (cp[1] == 'd' || cp[1] == 't' || cp[1] == 'r')) {
		BP_APPEND(bp,"sbus",-1,0);
		BP_APPEND(bp,"esp",-1,v0val[0]);
		if (cp[1] == 'r') 
			sprintf(tmpname, "cd"); /* use 'cd', not 'sr'*/
d700 4
a703 1
		BP_APPEND(bp,tmpname,v0val[1], v0val[2]);
d712 1
a712 1
		
d719 2
a720 1
static void 
d730 2
d737 1
d742 1
a742 1
 * device, so we can't set boot device there.   we patch in with 
d745 1
d761 1
a761 1
/* 
a772 1
	struct nodeops *no;
d774 1
a774 1
	if (cputyp != CPU_SUN4 && promvec->pv_romvec_vers < 2) {
d782 1
a782 1
build_default_map:
d809 1
a809 1
int 
d823 1
a823 1
int 
d843 1
d849 3
a851 1
	void sync_crash();
d857 1
a857 1
	if (cputyp == CPU_SUN4) {
d859 1
a859 1
		extern struct cfdriver memregcd, obiocd;
d862 1
a863 8
		/*
		 * On the 4/100 obio addresses must be mapped at
		 * 0x0YYYYYYY, but alias higher up (we avoid the
		 * alias condition because it causes pmap difficulties)
		 * XXX: We also assume that 4/[23]00 obio addresses
		 * must be 0xZYYYYYYY, where (Z != 0)
		 * make sure we get the correct memreg cfdriver!
		 */
d865 2
a866 1
			if (cf->cf_driver != &memregcd)
d868 8
d881 1
a881 1
				if (cfdata[*p].cf_driver == &obiocd)
d886 5
a890 2
		par_err_reg = (int *)bus_map((void *)memregcf->cf_loc[0],
		    NBPG, BUS_OBIO);
d895 2
a896 2
#if defined(SUN4C) || defined(SUN4M)
	if (cputyp == CPU_SUN4C || cputyp == CPU_SUN4M) {
a900 1
		*promvec->pv_synchook = sync_crash;
d903 6
d912 1
a912 1
	if (!config_rootfound(cp, (void *)&oca))
d989 1
a989 1
	register char *name;
d1010 1
a1010 1
	union { char regbuf[128]; struct rom_reg rr[RA_MAXREG]; } u;
d1014 5
a1018 1
	len = getprop(node, "reg", (void *)u.regbuf, sizeof u.regbuf);
a1031 1
	rp->ra_vaddr = (caddr_t)getpropint(node, "address", 0);
d1034 2
a1035 1
	if (len == -1)
d1037 1
d1061 8
d1070 11
d1085 1
a1085 1
mainbus_match(parent, cf, aux)
d1087 1
a1087 1
	struct cfdata *cf;
d1090 1
d1097 2
d1111 4
a1114 1
	struct confargs oca, *ca = aux;
d1116 1
a1116 1
	register const char *cp, *const *ssp, *sp;
d1119 2
a1120 1
	int nzs = 0, audio = 0;
d1130 2
a1131 2
#if defined(SUN4C) || defined(SUN4M)
	static const char *const openboot_special[] = {
d1149 28
a1176 1
#endif /* SUN4C || SUN4M */
d1178 4
a1183 8
	/* configure the cpu */
	node = ca->ca_ra.ra_node;
	oca.ca_ra.ra_node = node;
	oca.ca_ra.ra_name = cp = "cpu";
	oca.ca_ra.ra_paddr = 0;
	oca.ca_ra.ra_nreg = 0;
	config_found(dev, (void *)&oca, mbprint);

d1190 1
d1192 5
a1196 1
	if (cputyp == CPU_SUN4) {
d1199 1
d1204 2
a1205 2
		if (!config_found(dev, (void *)&oca, mbprint))
			panic(sp);
d1212 1
d1215 4
a1219 1
	if (cputyp == CPU_SUN4C || cputyp == CPU_SUN4M) {
d1221 31
d1255 19
a1273 5
		/* Find the "options" node */
		node0 = firstchild(node);
		optionsnode = findnode(node0, "options");
		if (optionsnode == 0)
			panic("no options in OPENPROM");
d1275 7
a1281 2
		/* Start at the beginning of the bootpath */
		oca.ca_ra.ra_bp = bootpath;
d1283 11
a1293 22
		for (ssp = openboot_special; *(sp = *ssp) != 0; ssp++) {
			if ((node = findnode(node0, sp)) == 0) {
				printf("could not find %s in OPENPROM\n", sp);
				panic(sp);
			}
			oca.ca_bustype = BUS_MAIN;
			if (!romprop(&oca.ca_ra, sp, node) ||
			    !config_found(dev, (void *)&oca, mbprint))
				panic(sp);
		}

		/*
		 * Configure the rest of the devices, in PROM order.  Skip
		 * PROM entries that are not for devices, or which must be
		 * done before we get here.
		 */
		for (node = node0; node; node = nextsibling(node)) {
			cp = getpropstring(node, "name");
			for (ssp = openboot_special; (sp = *ssp) != NULL; ssp++)
				if (strcmp(cp, sp) == 0)
					break;
			if (sp == NULL && romprop(&oca.ca_ra, cp, node)) {
d1295 6
a1300 6
				if (strcmp(cp, "audio") == 0)
					audio = 1;
				if (strcmp(cp, "zs") == 0)
					nzs++;
				if (audio && nzs >= 2)
					(void) splx(11 << 8);	/* XXX */
d1302 2
a1303 3
				oca.ca_bustype = BUS_MAIN;
				(void) config_found(dev, (void *)&oca, mbprint);
			}
d1306 6
d1315 7
a1321 3
struct cfdriver mainbuscd =
    { NULL, "mainbus", mainbus_match, mainbus_attach,
      DV_DULL, sizeof(struct device) };
a1333 1
	register int node, addr;
d1335 1
a1335 1
#ifdef SUN4
d1340 3
a1342 2
	if (cputyp == CPU_SUN4) {
		void *paddr;
d1346 1
a1346 1
			paddr = (void *)ZS0_PHYS;
d1349 1
a1349 1
			paddr = (void *)ZS1_PHYS;
d1352 1
a1352 1
			paddr = (void *)ZS2_PHYS;
d1358 5
a1362 3
		addr = (int)bus_map(paddr, NBPG, BUS_OBIO);
		if (addr)
			return ((void *)addr);
d1365 1
d1367 3
a1369 1
	if (cputyp == CPU_SUN4C || cputyp == CPU_SUN4M) {
d1371 6
a1386 1
bail:
d1409 1
a1409 1
	if (cputyp == CPU_SUN4) {
d1461 1
d1524 1
d1527 1
d1530 1
a1530 1
	if (cputyp==CPU_SUN4) {
d1535 1
d1567 2
d1612 61
d1703 2
a1704 2
		    "' line# >body >user %x ! ' column# >body >user %x !",
		    rowp, colp);
d1707 2
a1708 2
		    "stdout @@ is my-self addr line# %x ! addr column# %x !",
		    rowp, colp);
d1715 1
a1715 1
volatile void
d1718 2
d1725 1
a1725 1
volatile void
d1729 2
d1736 1
d1741 1
a1741 1
	if (cputyp == CPU_SUN4)
d1750 1
d1810 2
a1811 1
		for (dv = alldevs; dv != NULL; dv = dv->dv_next) {
a1818 4
#if NFD > 0
		if (defpart == 0)
			printf(" fdeject");
#endif /* NFD */
d1844 1
a1844 1
	for (dv = alldevs; dv != NULL; dv = dv->dv_next) {
d1867 18
d1889 1
a1889 1
 * 
d1902 1
a1902 1
	extern int (*mountroot)();
d1904 3
d1909 1
a1909 1
	extern int nfs_mountroot();
d1912 1
a1912 1
	extern int ffs_mountroot();
d1915 10
d1929 4
a1932 2
				printf("(default %s%s)", bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK?"a":"");
a1934 13
#if NFD > 0
			/*
			 * I will go punish myself now.
			 */
			if (len > 0 && strcmp(buf, "fdeject")==0) {
				struct mtop mtop;

				bzero(&mtop, sizeof mtop);
				mtop.mt_op = MTOFFL;
				(void) fdioctl(0, MTIOCTOP, &mtop, 0);
				continue;
			}
#endif /* NFD */
d1948 1
a1948 1
			dv = getdisk(buf, len, 0, &nrootdev);
a1957 1
		 * XXX: IS THIS STILL TRUE?
d1965 3
a1967 2
				printf("(default %s%s)", bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK?"b":"");
d1979 5
d1999 1
d2001 1
d2009 2
a2010 2
			 * Assume that we are supposed to put root on
			 * partition a, and swap on partition b.
d2012 2
a2013 1
			mindev = (bootdv->dv_unit << PARTITIONSHIFT) + 0;
d2032 3
a2034 1
		return;
d2036 1
a2036 2
	if (bootdv == NULL)
		panic("boot device not known");
d2057 35
d2141 1
a2141 1
/* 
d2149 1
a2149 1
	struct device *dev = alldevs;
d2163 1
a2163 1
		if ((dev = dev->dv_next) == NULL)
d2168 29
@


1.11
log
@delete archaic chuck of code relating to dumpdev
@
text
@a111 1
int	dkn;		/* number of iostat dk numbers assigned so far */
@


1.10
log
@4/100: let the scsi controller number be N. if N=0, we are on swN, else
we are on siN-1
@
text
@a1657 26

#if 0
	/*
	 * XXX: What is this doing?
	 */
	mindev &= ~PARTITIONMASK;
	temp = NODEV;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    mindev == (minor(swp->sw_dev) & ~PARTITIONMASK)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev == NODEV)
		return;

	/*
	 * If dumpdev was the same as the old primary swap device, move
	 * it to the new primary swap device.
	 */
	if (temp == dumpdev)
		dumpdev = swdevt[0].sw_dev;
#endif
@


1.9
log
@morons tend to commit before compiling
@
text
@d482 7
a488 2
				BP_APPEND(bp,"obio",-1,0);
				BP_APPEND(bp,"sw",-1,v0val[0]);
@


1.8
log
@show "fdeject" as a valid root filesystem choice
@
text
@d1441 1
a1441 1
		if (devpart == 0)
@


1.7
log
@correct some copyrights
@
text
@d1440 4
d1523 2
a1524 3
				printf("(default %s%c)",
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK?'a':' ');
d1571 2
a1572 3
				printf("(default %s%c)",
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK?'b':' ');
@


1.6
log
@handle fdeject on root line, not swap line...
@
text
@d4 29
@


1.5
log
@move msgbufmapped out of #ifdef SUN4
@
text
@d1495 13
a1543 13
#if NFD > 0
			/*
			 * I will go punish myself now.
			 */
			if (len > 0 && strcmp(buf, "fdeject")==0) {
				struct mtop mtop;

				bzero(&mtop, sizeof mtop);
				mtop.mt_op = MTOFFL;
				(void) fdioctl(0, MTIOCTOP, &mtop, 0);
				continue;
			}
#endif /* NFD */
@


1.4
log
@kernel name is /bsd
@
text
@d175 1
a179 1
	extern int msgbufmapped;
@


1.3
log
@globalize kgdb_debug_panic extern
@
text
@d378 1
a378 1
 * The argument `cp' points to a string such as "xd(0,0,0)netbsd"
d505 1
a505 1
			sprintf(tmpname, "cd"); /* netbsd uses 'cd', not 'sr'*/
@


1.2
log
@map msgbuf late; fdeject command
@
text
@d91 4
a174 3
#ifdef KGDB
	extern int kgdb_debug_panic;
#endif
@


1.1
log
@Initial revision
@
text
@d60 6
d86 1
a86 3
int	cpumod;		/* CPU model,
			 * XXX currently valid only if cputyp == CPU_SUN4
			 */
d178 1
d251 1
a272 1
 *
a273 1

a378 1

a522 1

a537 1

a544 1

d582 1
a582 1
 build_default_map:
d660 8
a670 8
			/*
			 * On the 4/100 obio addresses must be mapped at
			 * 0x0YYYYYYY, but alias higher up (we avoid the
			 * alias condition because it causes pmap difficulties)
			 * XXX: We also assume that 4/[23]00 obio addresses
			 * must be 0xZYYYYYYY, where (Z != 0)
			 * make sure we get the correct memreg cfdriver!
			 */
d681 2
a682 1
		par_err_reg = (int *)bus_map(memregcf->cf_loc[0], NBPG, BUS_OBIO);
a727 1
int n;
d878 1
d884 1
d886 1
d905 1
d939 1
a939 1
	} else
d941 2
a942 1
	{
d991 1
d1033 1
a1033 1
		addr = bus_map(paddr, NBPG, BUS_OBIO);
d1517 1
d1530 13
a1566 1

a1567 1

a1570 3
		if (bootdv == NULL)
			panic("boot device not known");

d1599 2
a1600 1

d1622 1
d1646 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

