head	1.20;
access;
symbols
	OPENBSD_6_0:1.20.0.10
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.6
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.8
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.19.0.16
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.12
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.10
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.8
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.6
	OPENBSD_5_0:1.19.0.4
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.11.0.4
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.9.0.14
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.12
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.10
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.8
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.8
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.6.0.2
	UBC_BASE:1.6
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.2.0.2
	SMP_BASE:1.2
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.10
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.8
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.6
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.4
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.2
	OPENBSD_2_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.20
date	2014.07.11.10.53.07;	author uebayasi;	state Exp;
branches;
next	1.19;
commitid	CaCLs5fTSVpJlqFi;

1.19
date	2010.09.28.20.27.55;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2010.07.06.20.37.33;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2009.03.15.11.26.38;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2008.10.15.23.23.50;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2008.10.10.08.36.28;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2008.10.10.08.05.45;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2008.10.09.08.43.43;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.26.05.42.13;	author ray;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.31.19.53.14;	author sobrado;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.08.07.23.18;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.03.07.01.33;	author david;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.12.19.08.58.05;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.12.07.10.39.47;	author art;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.12.05.14.40.48;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.21.17.08.36;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.19.21.45.56;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2000.01.31.16.06.58;	author art;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	97.08.08.08.40.15;	author downsj;	state Exp;
branches;
next	;

1.2.2.1
date	2000.02.20.11.56.52;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2000.02.21.22.29.03;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2004.02.19.10.49.58;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@CPU_BUSY_CYCLE(): A new MI statement for busy loop power reduction

The new CPU_BUSY_CYCLE() may be put in a busy loop body so that CPU can reduce
power consumption, as Linux's cpu_relax() and FreeBSD's cpu_spinwait().  To
start minimally, use PAUSE on i386/amd64 and empty on others.  The name is
chosen following the existing cpu_idle_*() functions.  Naming and API may be
polished later.

OK kettenis@@
@
text
@/*	$OpenBSD$	*/
/*	$NetBSD: cpuvar.h,v 1.4 1997/07/06 21:14:25 pk Exp $ */

/*
 *  Copyright (c) 1996 The NetBSD Foundation, Inc.
 *  All rights reserved.
 *
 *  This code is derived from software contributed to The NetBSD Foundation
 *  by Paul Kranenburg.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 *  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 *  PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _SPARC_CPUVAR_H
#define _SPARC_CPUVAR_H

#include <sys/device.h>
#include <sys/sched.h>

#include <sparc/sparc/cache.h>	/* for cacheinfo */

/*
 * CPU/MMU module information.
 * There is one of these for each "mainline" CPU module we support.
 * The information contained in the structure is used only during
 * auto-configuration of the CPUs; some fields are copied into the
 * per-cpu data structure (cpu_softc) for easy access during normal
 * operation.
 */
struct cpu_softc;
struct module_info {
	int  cpu_type;
	enum vactype vactype;
	void (*cpu_match)(struct cpu_softc *, struct module_info *, int);
	void (*getcacheinfo)(struct cpu_softc *sc, int node);
	void (*hotfix)(struct cpu_softc *);
	void (*mmu_enable)(void);
	void (*cache_enable)(void);
	int  ncontext;			/* max. # of contexts (we use) */

	void (*get_syncflt)(void);
	int  (*get_asyncflt)(u_int *, u_int *);
	void (*cache_flush)(caddr_t, u_int);
	void (*vcache_flush_page)(int);
	void (*vcache_flush_segment)(int, int);
	void (*vcache_flush_region)(int);
	void (*vcache_flush_context)(void);
	void (*pcache_flush_line)(int, int);
	void (*pure_vcache_flush)(void);
	void (*cache_flush_all)(void);
	void (*memerr)(unsigned, u_int, u_int, struct trapframe *);
};


struct cpu_softc;
struct cpu_info {
	struct cpu_softc *ci_softc;

	struct proc *ci_curproc;
	struct cpu_info *ci_next;

	struct schedstate_percpu ci_schedstate;
	u_int32_t 		ci_randseed;

#ifdef DIAGNOSTIC
	int	ci_mutex_level;
#endif
};

#define curcpu() (&cpuinfo.ci)
#define cpu_number() (cpuinfo.mid)
#define CPU_IS_PRIMARY(ci)	((ci)->ci_softc->master)
#define CPU_INFO_ITERATOR	int
#define CPU_INFO_FOREACH(cii, ci) \
	for (cii = 0, ci = curcpu(); ci != NULL; ci = ci->ci_next)
#define CPU_INFO_UNIT(ci) ((ci)->ci_softc ? (ci)->ci_softc->dv.dv_unit : 0)
#define MAXCPUS	1
#define cpu_unidle(ci)

#define CPU_BUSY_CYCLE()	do {} while (0)

/*
 * The cpu_softc structure. This structure maintains information about one
 * currently installed CPU (there may be several of these if the machine
 * supports multiple CPUs, as on some Sun4m architectures). The information
 * in this structure supersedes the old "cpumod", "mmumod", and similar
 * fields.
 */

struct cpu_softc {
	struct device	dv;		/* generic device info */

	struct cpu_info ci;

	int		node;		/* PROM node for this CPU */

	/* CPU information */
	char		*cpu_name;	/* CPU model */
	int		cpu_impl;	/* CPU implementation code */
	int		cpu_vers;	/* CPU version code */
	int		mmu_impl;	/* MMU implementation code */
	int		mmu_vers;	/* MMU version code */
	int		master;		/* 1 if this is bootup CPU */

	int		mid;		/* Module ID for MP systems */
	int		mbus;		/* 1 if CPU is on MBus */
	int		mxcc;		/* 1 if a MBus-level MXCC is present */

	caddr_t		mailbox;	/* VA of CPU's mailbox */


	int		mmu_ncontext;	/* Number of contexts supported */
	int		mmu_nregion; 	/* Number of regions supported */
	int		mmu_nsegment;	/* [4/4c] Segments */
	int		mmu_npmeg;	/* [4/4c] Pmegs */
	int		sun4_mmu3l;	/* [4]: 3-level MMU present */
#if defined(SUN4_MMU3L)
#define HASSUN4_MMU3L	(cpuinfo.sun4_mmu3l)
#else
#define HASSUN4_MMU3L	(0)
#endif

	/* Context administration */
	int		*ctx_tbl;	/* [4m] SRMMU-edible context table */
	union ctxinfo	*ctxinfo;
	union ctxinfo	*ctx_freelist;  /* context free list */
	int		ctx_kick;	/* allocation rover when none free */
	int		ctx_kickdir;	/* ctx_kick roves both directions */

	/* MMU tables that map `cpuinfo'' on each CPU */
	int		*L1_ptps;	/* XXX */

/* XXX - of these, we currently use only cpu_type */
	int		arch;		/* Architecture: CPU_SUN4x */
	int		class;		/* Class: SuperSPARC, microSPARC... */
	int		classlvl;	/* Iteration in class: 1, 2, etc. */
	int		classsublvl;	/* stepping in class (version) */
	int		cpu_type;	/* Type: see CPUTYP_xxx below */

	int		hz;		/* Clock speed */

	/* Cache information */
	struct cacheinfo	cacheinfo;	/* see cache.h */

	/* FPU information */
	int		fpupresent;	/* true if FPU is present */
	int		fpuvers;	/* FPU revision */

	/* various flags to workaround anomalies in chips */
	int		flags;		/* see CPUFLG_xxx, below */

	/*
	 * The following pointers point to processes that are somehow
	 * associated with this CPU--running on it, using its FPU,
	 * etc.
	 *
	 * XXXMP: much more needs to go here
	 */
	struct	proc 	*fpproc;		/* FPU owner */

	/*
	 * The following are function pointers to do interesting CPU-dependent
	 * things without having to do type-tests all the time
	 */

	/* bootup things: access to physical memory */
	u_int	(*read_physmem)(u_int addr, int space);
	void	(*write_physmem)(u_int addr, u_int data);
	void	(*cache_tablewalks)(void);
	void	(*mmu_enable)(void);
	void	(*hotfix)(struct cpu_softc *);

	/* locore defined: */
	void	(*get_syncflt)(void);		/* Not C-callable */
	int	(*get_asyncflt)(u_int *, u_int *);

       	/* Synchronous Fault Status; temporary storage */
       	struct {
		int     sfsr;
		int     sfva;
	} syncfltdump;

	/* Cache handling functions */
	void	(*cache_enable)(void);
	void	(*cache_flush)(caddr_t, u_int);
	void	(*vcache_flush_page)(int);
	void	(*vcache_flush_segment)(int, int);
	void	(*vcache_flush_region)(int);
	void	(*vcache_flush_context)(void);
	void	(*pcache_flush_line)(int, int);
	void	(*pure_vcache_flush)(void);
	void	(*cache_flush_all)(void);

#ifdef SUN4M
	/* hardware-assisted block operation routines */
	void		(*hwbcopy)(const void *from, void *to, size_t len);
	void		(*hwbzero)(void *buf, size_t len);

	/* routine to clear mbus-sbus buffers */
	void		(*mbusflush)(void);
#endif

	/*
	 * Memory error handler; parity errors, unhandled NMIs and other
	 * unrecoverable faults end up here.
	 */
	void    (*memerr)(unsigned, u_int, u_int, struct trapframe *);
	/* XXX: Add more here! */
};

/*
 * CPU types. When nonzero, these enable system-specific behaviour.
 * The general form is
 * 	CPUTYP_proctype_bustype_cachetype_etc_etc
 */
#define CPUTYP_UNKNOWN		0

/* sun4 models */
#define CPUTYP_4_100		1 	/* Sun4/100 */
#define CPUTYP_4_200		2	/* Sun4/200 */
#define CPUTYP_4_300		3	/* Sun4/300 */
#define CPUTYP_4_400		4	/* Sun4/400 */

/* rough sun4m families; not really used */
#define CPUTYP_SS1_MBUS_MXCC	21	/* SuperSPARC-I, MBus, MXCC (SS10) */
#define CPUTYP_SS1_MBUS_NOMXCC	23	/* SuperSPARC-I, on MBus w/o MXCC */
#define CPUTYP_MS2		24	/* MicroSPARC-2 */
#define CPUTYP_MS1		25 	/* MicroSPARC-1 */
#define CPUTYP_HS_MBUS		26	/* MBus-based HyperSPARC */
#define CPUTYP_CYPRESS		27	/* MBus-based Cypress */

/*
 * CPU flags
 */
#define CPUFLG_CACHEPAGETABLES	0x1	/* caching pagetables OK on Sun4m */
#define CPUFLG_CACHEIOMMUTABLES	0x2	/* caching IOMMU translations OK */
#define CPUFLG_CACHEDVMA	0x4	/* DVMA goes through cache */
#define CPUFLG_SUN4CACHEBUG	0x8	/* trap page can't be cached */
#define CPUFLG_CACHE_MANDATORY	0x10	/* if cache is on, don't use
					   uncached access */

/*
 * Related function prototypes
 */
void getcpuinfo(struct cpu_softc *sc, int node);
void mmu_install_tables(struct cpu_softc *);
void pmap_alloc_cpu(struct cpu_softc *);

#define cpuinfo	(*(struct cpu_softc *)CPUINFO_VA)
#endif	/* _SPARC_CPUVAR_H */
@


1.19
log
@Implement a per-cpu held mutex counter if DIAGNOSTIC on all non-x86 platforms,
to complete matthew@@'s commit of a few days ago, and drop __HAVE_CPU_MUTEX_LEVEL
define. With help from, and ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.18 2010/07/06 20:37:33 miod Exp $	*/
d98 2
@


1.18
log
@Remove unused CPUARCH_xxx and CPUCLS_xxx defines, as well as all the unused
CPUTYP_xxx defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.17 2009/03/15 11:26:38 miod Exp $	*/
d83 4
@


1.17
log
@Allow CPU_INFO_UNIT() to be used before cpu0 attaches.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.16 2008/10/15 23:23:50 deraadt Exp $	*/
d225 2
a226 32
 * CPU architectures
 */
#define CPUARCH_UNKNOWN		0
#define CPUARCH_SUN4		1
#define CPUARCH_SUN4C		2
#define CPUARCH_SUN4M		3
#define	CPUARCH_SUN4D		4
#define CPUARCH_SUN4U		5

/*
 * CPU classes
 */
#define CPUCLS_UNKNOWN		0

#if defined(SUN4)
#define CPUCLS_SUN4		1
#endif

#if defined(SUN4C)
#define CPUCLS_SUN4C		5
#endif

#if defined(SUN4M)
#define CPUCLS_MICROSPARC	10	/* MicroSPARC-II */
#define CPUCLS_SUPERSPARC	11	/* Generic SuperSPARC */
#define CPUCLS_HYPERSPARC	12	/* Ross HyperSPARC RT620 */
#endif

/*
 * CPU types. Each of these should uniquely identify one platform/type of
 * system, i.e. "MBus-based 75 MHz SuperSPARC-II with ECache" is
 * CPUTYP_SS2_MBUS_MXCC. The general form is
a227 3
 *
 * XXX: This is far from complete/comprehensive
 * XXX: ADD SUN4, SUN4C TYPES
d231 1
d237 1
a237 10
#define CPUTYP_SLC		10	/* SPARCstation SLC */
#define CPUTYP_ELC		11	/* SPARCstation ELC */
#define CPUTYP_IPX		12	/* SPARCstation IPX */
#define CPUTYP_IPC		13	/* SPARCstation IPC */
#define CPUTYP_1		14	/* SPARCstation 1 */
#define CPUTYP_1P		15	/* SPARCstation 1+ */
#define CPUTYP_2		16	/* SPARCstation 2 */

/* We classify the Sun4m's by feature, not by model (XXX: do same for 4/4c) */
#define	CPUTYP_SS2_MBUS_MXCC	20 	/* SuperSPARC-II, MBus, MXCC (SS20) */
a238 1
#define CPUTYP_SS2_MBUS_NOMXCC	22	/* SuperSPARC-II, on MBus w/o MXCC */
@


1.16
log
@make random(9) return per-cpu values (by saving the seed in the cpuinfo),
which are uniform for the profclock on each cpu in a SMP system (but using
a different seed for each cpu).  on all cpus, avoid seeding with a value out
of the [0, 2^31-1] range (since that is not stable)
ok kettenis drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.15 2008/10/10 08:36:28 art Exp $	*/
d91 1
a91 1
#define CPU_INFO_UNIT(ci)	((ci)->ci_softc->dv.dv_unit)
@


1.15
log
@Add empty cpu_unidle() macros for architectures that currently don't do
anything special to prod a cpu to leave the idle loop in signotify.
powerpc, i386, amd64 and sparc64 will follow soon so that everyone has
the same interface to wake an idling cpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.14 2008/10/10 08:05:45 art Exp $	*/
d82 1
@


1.14
log
@Define MAXCPUS on all architectures.
For now, sparc64 is arbitrarily set to 256 (only architecture that didn't have
a practical limit in the code on the number of cpus).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.13 2008/10/09 08:43:43 art Exp $	*/
d92 1
@


1.13
log
@Implement CPU_INFO_UNIT for everyone, not just MP kernels.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.12 2008/06/26 05:42:13 ray Exp $	*/
d91 1
@


1.12
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.11 2007/05/31 19:53:14 sobrado Exp $	*/
d90 1
@


1.11
log
@use the right capitalization for `MBus'

ok'd some days ago by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.10 2007/05/08 07:23:18 art Exp $	*/
a18 7
 *  3. All advertising materials mentioning features or use of this software
 *     must display the following acknowledgement:
 *         This product includes software developed by the NetBSD
 *         Foundation, Inc. and its contributors.
 *  4. Neither the name of The NetBSD Foundation nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
@


1.10
log
@Switch sparc to __HAVE_CPUINFO.

miod@@ tested (since I hacked it up blindly) and ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.9 2003/11/03 07:01:33 david Exp $	*/
d281 2
a282 2
#define	CPUTYP_SS2_MBUS_MXCC	20 	/* SuperSPARC-II, Mbus, MXCC (SS20) */
#define CPUTYP_SS1_MBUS_MXCC	21	/* SuperSPARC-I, Mbus, MXCC (SS10) */
@


1.9
log
@spelling fixes (in the comments)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.8 2002/03/14 01:26:44 millert Exp $	*/
d44 1
d81 17
d108 2
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.7 2001/12/19 08:58:05 art Exp $	*/
d84 1
a84 1
 * in this structure supercedes the old "cpumod", "mmumod", and similar
@


1.7
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.4 2000/02/21 17:08:36 art Exp $	*/
d59 5
a63 5
	void (*cpu_match) __P((struct cpu_softc *, struct module_info *, int));
	void (*getcacheinfo) __P((struct cpu_softc *sc, int node));
	void (*hotfix) __P((struct cpu_softc *));
	void (*mmu_enable) __P((void));
	void (*cache_enable) __P((void));
d66 11
a76 11
	void (*get_syncflt) __P((void));
	int  (*get_asyncflt) __P((u_int *, u_int *));
	void (*cache_flush) __P((caddr_t, u_int));
	void (*vcache_flush_page) __P((int));
	void (*vcache_flush_segment) __P((int, int));
	void (*vcache_flush_region) __P((int));
	void (*vcache_flush_context) __P((void));
	void (*pcache_flush_line) __P((int, int));
	void (*pure_vcache_flush) __P((void));
	void (*cache_flush_all)__P((void));
	void (*memerr) __P((unsigned, u_int, u_int, struct trapframe *));
d163 5
a167 5
	u_int	(*read_physmem) __P((u_int addr, int space));
	void	(*write_physmem) __P((u_int addr, u_int data));
	void	(*cache_tablewalks) __P((void));
	void	(*mmu_enable) __P((void));
	void	(*hotfix) __P((struct cpu_softc *));
d170 2
a171 2
	void	(*get_syncflt) __P((void));		/* Not C-callable */
	int	(*get_asyncflt) __P((u_int *, u_int *));
d180 9
a188 9
	void	(*cache_enable) __P((void));
	void	(*cache_flush)__P((caddr_t, u_int));
	void	(*vcache_flush_page)__P((int));
	void	(*vcache_flush_segment)__P((int, int));
	void	(*vcache_flush_region)__P((int));
	void	(*vcache_flush_context)__P((void));
	void	(*pcache_flush_line)__P((int, int));
	void	(*pure_vcache_flush) __P((void));
	void	(*cache_flush_all)__P((void));
d192 2
a193 3
	void		(*hwbcopy)
				__P((const void *from, void *to, size_t len));
	void		(*hwbzero) __P((void *buf, size_t len));
d196 1
a196 1
	void		(*mbusflush) __P((void));
d203 1
a203 1
	void    (*memerr)__P((unsigned, u_int, u_int, struct trapframe *));
d283 3
a285 3
void getcpuinfo __P((struct cpu_softc *sc, int node));
void mmu_install_tables __P((struct cpu_softc *));
void pmap_alloc_cpu __P((struct cpu_softc *));
@


1.6
log
@Zap pmap_alloc_cpu. this is not how we want to do this.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.5 2001/12/05 14:40:48 art Exp $	*/
d73 1
a73 1
	void (*pcache_flush_page) __P((paddr_t, int));
d186 1
a186 1
	void	(*pcache_flush_page)__P((paddr_t, int));
d286 1
@


1.6.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.6 2001/12/07 10:39:47 art Exp $	*/
d59 5
a63 5
	void (*cpu_match)(struct cpu_softc *, struct module_info *, int);
	void (*getcacheinfo)(struct cpu_softc *sc, int node);
	void (*hotfix)(struct cpu_softc *);
	void (*mmu_enable)(void);
	void (*cache_enable)(void);
d66 11
a76 11
	void (*get_syncflt)(void);
	int  (*get_asyncflt)(u_int *, u_int *);
	void (*cache_flush)(caddr_t, u_int);
	void (*vcache_flush_page)(int);
	void (*vcache_flush_segment)(int, int);
	void (*vcache_flush_region)(int);
	void (*vcache_flush_context)(void);
	void (*pcache_flush_page)(paddr_t, int);
	void (*pure_vcache_flush)(void);
	void (*cache_flush_all)(void);
	void (*memerr)(unsigned, u_int, u_int, struct trapframe *);
d163 5
a167 5
	u_int	(*read_physmem)(u_int addr, int space);
	void	(*write_physmem)(u_int addr, u_int data);
	void	(*cache_tablewalks)(void);
	void	(*mmu_enable)(void);
	void	(*hotfix)(struct cpu_softc *);
d170 2
a171 2
	void	(*get_syncflt)(void);		/* Not C-callable */
	int	(*get_asyncflt)(u_int *, u_int *);
d180 9
a188 9
	void	(*cache_enable)(void);
	void	(*cache_flush)(caddr_t, u_int);
	void	(*vcache_flush_page)(int);
	void	(*vcache_flush_segment)(int, int);
	void	(*vcache_flush_region)(int);
	void	(*vcache_flush_context)(void);
	void	(*pcache_flush_page)(paddr_t, int);
	void	(*pure_vcache_flush)(void);
	void	(*cache_flush_all)(void);
d192 3
a194 2
	void		(*hwbcopy)(const void *from, void *to, size_t len);
	void		(*hwbzero)(void *buf, size_t len);
d197 1
a197 1
	void		(*mbusflush)(void);
d204 1
a204 1
	void    (*memerr)(unsigned, u_int, u_int, struct trapframe *);
d284 2
a285 2
void getcpuinfo(struct cpu_softc *sc, int node);
void mmu_install_tables(struct cpu_softc *);
@


1.5
log
@Change pcache_flush_line to pcache_flush_page since this is the only way
we use the function.
At the same time fix the pte pool backend functions to allocate and map
the memory themselves.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.4 2000/02/21 17:08:36 art Exp $	*/
a285 1
void pmap_alloc_cpu __P((struct cpu_softc *));
@


1.4
log
@The last pieces of hypersparc support.
 - Split get_faultstatus into get_syncflt and get_asyncflt.
 - Get the syncflt status before setting up the trap frame and put the
   results in cpuinfo.syncfltdump (related to the next change).
 - unlock the sfsr/sfva after reading from ASI_SRMMUFP (it gets locked if
   the translation fails).
 - + other interface changes and cleanups.
 (most work from NetBSD).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.3 2000/02/19 21:45:56 art Exp $	*/
d73 1
a73 1
	void (*pcache_flush_line) __P((int, int));
d186 1
a186 1
	void	(*pcache_flush_line)__P((int, int));
@


1.3
log
@Add two new cache operations.
cache_flush_all - (pretty obvious).
pure_vcache_flush - flush all VIVT caches (needed on context switch).
(From NetBSD).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.2 2000/01/31 16:06:58 art Exp $	*/
d66 2
a67 1
	void (*get_faultstatus) __P((void));
d76 1
a76 2
	void (*memerr) __P((unsigned, u_int, u_int, u_int, u_int,
			   struct trapframe *));
d170 8
a177 1
	void	(*get_faultstatus) __P((void));
d204 1
a204 2
	void    (*memerr)__P((unsigned, u_int, u_int, u_int, u_int,
			      struct trapframe *));
@


1.2
log
@Clean up memerr*. (from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.1 1997/08/08 08:40:15 downsj Exp $	*/
d73 2
d180 2
@


1.2.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.3 2000/02/19 21:45:56 art Exp $	*/
a72 2
	void (*pure_vcache_flush) __P((void));
	void (*cache_flush_all)__P((void));
a177 2
	void	(*pure_vcache_flush) __P((void));
	void	(*cache_flush_all)__P((void));
@


1.2.2.2
log
@sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.4 2000/02/21 17:08:36 art Exp $	*/
d66 1
a66 2
	void (*get_syncflt) __P((void));
	int  (*get_asyncflt) __P((u_int *, u_int *));
d75 2
a76 1
	void (*memerr) __P((unsigned, u_int, u_int, struct trapframe *));
d170 1
a170 8
	void	(*get_syncflt) __P((void));		/* Not C-callable */
	int	(*get_asyncflt) __P((u_int *, u_int *));

       	/* Synchronous Fault Status; temporary storage */
       	struct {
		int     sfsr;
		int     sfva;
	} syncfltdump;
d197 2
a198 1
	void    (*memerr)__P((unsigned, u_int, u_int, struct trapframe *));
@


1.2.2.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 5
a63 5
	void (*cpu_match)(struct cpu_softc *, struct module_info *, int);
	void (*getcacheinfo)(struct cpu_softc *sc, int node);
	void (*hotfix)(struct cpu_softc *);
	void (*mmu_enable)(void);
	void (*cache_enable)(void);
d66 11
a76 11
	void (*get_syncflt)(void);
	int  (*get_asyncflt)(u_int *, u_int *);
	void (*cache_flush)(caddr_t, u_int);
	void (*vcache_flush_page)(int);
	void (*vcache_flush_segment)(int, int);
	void (*vcache_flush_region)(int);
	void (*vcache_flush_context)(void);
	void (*pcache_flush_line)(int, int);
	void (*pure_vcache_flush)(void);
	void (*cache_flush_all)(void);
	void (*memerr)(unsigned, u_int, u_int, struct trapframe *);
d163 5
a167 5
	u_int	(*read_physmem)(u_int addr, int space);
	void	(*write_physmem)(u_int addr, u_int data);
	void	(*cache_tablewalks)(void);
	void	(*mmu_enable)(void);
	void	(*hotfix)(struct cpu_softc *);
d170 2
a171 2
	void	(*get_syncflt)(void);		/* Not C-callable */
	int	(*get_asyncflt)(u_int *, u_int *);
d180 9
a188 9
	void	(*cache_enable)(void);
	void	(*cache_flush)(caddr_t, u_int);
	void	(*vcache_flush_page)(int);
	void	(*vcache_flush_segment)(int, int);
	void	(*vcache_flush_region)(int);
	void	(*vcache_flush_context)(void);
	void	(*pcache_flush_line)(int, int);
	void	(*pure_vcache_flush)(void);
	void	(*cache_flush_all)(void);
d192 3
a194 2
	void		(*hwbcopy)(const void *from, void *to, size_t len);
	void		(*hwbzero)(void *buf, size_t len);
d197 1
a197 1
	void		(*mbusflush)(void);
d204 1
a204 1
	void    (*memerr)(unsigned, u_int, u_int, struct trapframe *);
d284 3
a286 3
void getcpuinfo(struct cpu_softc *sc, int node);
void mmu_install_tables(struct cpu_softc *);
void pmap_alloc_cpu(struct cpu_softc *);
@


1.2.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d84 1
a84 1
 * in this structure supersedes the old "cpumod", "mmumod", and similar
@


1.1
log
@Missed these...
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 2
a60 2
	void (*cpu_match)__P((struct cpu_softc *, struct module_info *, int));
	void (*getcacheinfo)__P((struct cpu_softc *sc, int node));
d62 2
a63 2
	void (*mmu_enable)__P((void));
	void (*cache_enable)__P((void));
d66 9
a74 7
	void (*get_faultstatus)__P((void));
	void (*cache_flush)__P((caddr_t, u_int));
	void (*vcache_flush_page)__P((int));
	void (*vcache_flush_segment)__P((int, int));
	void (*vcache_flush_region)__P((int));
	void (*vcache_flush_context)__P((void));
	void (*pcache_flush_line)__P((int, int));
d189 6
@

