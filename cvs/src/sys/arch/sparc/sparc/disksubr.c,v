head	1.95;
access;
symbols
	OPENBSD_6_0:1.95.0.4
	OPENBSD_6_0_BASE:1.95
	OPENBSD_5_9:1.95.0.2
	OPENBSD_5_9_BASE:1.95
	OPENBSD_5_8:1.93.0.6
	OPENBSD_5_8_BASE:1.93
	OPENBSD_5_7:1.93.0.2
	OPENBSD_5_7_BASE:1.93
	OPENBSD_5_6:1.92.0.6
	OPENBSD_5_6_BASE:1.92
	OPENBSD_5_5:1.92.0.4
	OPENBSD_5_5_BASE:1.92
	OPENBSD_5_4:1.91.0.2
	OPENBSD_5_4_BASE:1.91
	OPENBSD_5_3:1.90.0.8
	OPENBSD_5_3_BASE:1.90
	OPENBSD_5_2:1.90.0.6
	OPENBSD_5_2_BASE:1.90
	OPENBSD_5_1_BASE:1.90
	OPENBSD_5_1:1.90.0.4
	OPENBSD_5_0:1.90.0.2
	OPENBSD_5_0_BASE:1.90
	OPENBSD_4_9:1.87.0.2
	OPENBSD_4_9_BASE:1.87
	OPENBSD_4_8:1.86.0.2
	OPENBSD_4_8_BASE:1.86
	OPENBSD_4_7:1.83.0.2
	OPENBSD_4_7_BASE:1.83
	OPENBSD_4_6:1.81.0.4
	OPENBSD_4_6_BASE:1.81
	OPENBSD_4_5:1.77.0.2
	OPENBSD_4_5_BASE:1.77
	OPENBSD_4_4:1.76.0.2
	OPENBSD_4_4_BASE:1.76
	OPENBSD_4_3:1.72.0.2
	OPENBSD_4_3_BASE:1.72
	OPENBSD_4_2:1.70.0.2
	OPENBSD_4_2_BASE:1.70
	OPENBSD_4_1:1.42.0.2
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.41.0.2
	OPENBSD_4_0_BASE:1.41
	OPENBSD_3_9:1.37.0.2
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.32.0.2
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.30.0.6
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.30.0.4
	OPENBSD_3_6_BASE:1.30
	SMP_SYNC_A:1.30
	SMP_SYNC_B:1.30
	OPENBSD_3_5:1.30.0.2
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	UBC_SYNC_A:1.27
	OPENBSD_3_3:1.27.0.6
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.27.0.4
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.27.0.2
	OPENBSD_3_1_BASE:1.27
	UBC_SYNC_B:1.27
	UBC:1.26.0.4
	UBC_BASE:1.26
	OPENBSD_3_0:1.26.0.2
	OPENBSD_3_0_BASE:1.26
	OPENBSD_2_9_BASE:1.24
	OPENBSD_2_9:1.24.0.4
	OPENBSD_2_8:1.24.0.2
	OPENBSD_2_8_BASE:1.24
	OPENBSD_2_7:1.23.0.8
	OPENBSD_2_7_BASE:1.23
	SMP:1.23.0.6
	SMP_BASE:1.23
	kame_19991208:1.23
	OPENBSD_2_6:1.23.0.4
	OPENBSD_2_6_BASE:1.23
	OPENBSD_2_5:1.23.0.2
	OPENBSD_2_5_BASE:1.23
	OPENBSD_2_4:1.21.0.2
	OPENBSD_2_4_BASE:1.21
	OPENBSD_2_3:1.19.0.2
	OPENBSD_2_3_BASE:1.19
	OPENBSD_2_2:1.18.0.2
	OPENBSD_2_2_BASE:1.18
	OPENBSD_2_1:1.14.0.2
	OPENBSD_2_1_BASE:1.14
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.95
date	2015.09.28.15.36.10;	author krw;	state Exp;
branches;
next	1.94;
commitid	IeCgn52tZIiNsEXs;

1.94
date	2015.09.27.22.34.27;	author krw;	state Exp;
branches;
next	1.93;
commitid	6I9GceOSjHo9mTgF;

1.93
date	2015.01.16.20.17.05;	author miod;	state Exp;
branches;
next	1.92;
commitid	qvf9KkZ1B5C1I4hl;

1.92
date	2013.10.20.10.11.16;	author krw;	state Exp;
branches;
next	1.91;

1.91
date	2013.06.11.16.42.11;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2011.04.16.03.21.15;	author krw;	state Exp;
branches;
next	1.89;

1.89
date	2011.04.15.14.57.29;	author krw;	state Exp;
branches;
next	1.88;

1.88
date	2011.04.06.13.46.50;	author miod;	state Exp;
branches;
next	1.87;

1.87
date	2011.02.26.13.07.48;	author krw;	state Exp;
branches;
next	1.86;

1.86
date	2010.04.25.06.15.17;	author deraadt;	state Exp;
branches;
next	1.85;

1.85
date	2010.04.24.20.12.22;	author miod;	state Exp;
branches;
next	1.84;

1.84
date	2010.04.23.15.25.21;	author jsing;	state Exp;
branches;
next	1.83;

1.83
date	2010.02.26.23.11.57;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2009.08.13.15.23.11;	author deraadt;	state Exp;
branches;
next	1.81;

1.81
date	2009.06.04.21.13.02;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2009.05.13.01.31.58;	author krw;	state Exp;
branches;
next	1.79;

1.79
date	2009.04.10.06.32.47;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2009.04.07.03.11.59;	author krw;	state Exp;
branches;
next	1.77;

1.77
date	2009.01.22.01.06.28;	author krw;	state Exp;
branches;
next	1.76;

1.76
date	2008.06.29.20.05.22;	author krw;	state Exp;
branches;
next	1.75;

1.75
date	2008.06.12.06.58.37;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2008.06.11.12.35.43;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2008.06.10.20.50.23;	author beck;	state Exp;
branches;
next	1.72;

1.72
date	2007.10.02.03.26.59;	author krw;	state Exp;
branches;
next	1.71;

1.71
date	2007.09.19.23.47.50;	author tsi;	state Exp;
branches;
next	1.70;

1.70
date	2007.07.01.19.06.58;	author miod;	state Exp;
branches;
next	1.69;

1.69
date	2007.06.24.16.52.05;	author miod;	state Exp;
branches;
next	1.68;

1.68
date	2007.06.20.18.15.46;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2007.06.18.05.30.54;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2007.06.18.05.28.54;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2007.06.18.02.14.17;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2007.06.17.00.27.29;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2007.06.14.03.41.22;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2007.06.14.03.37.23;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2007.06.14.03.35.30;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2007.06.14.03.29.34;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2007.06.12.20.57.43;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2007.06.09.23.06.46;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2007.06.09.18.06.50;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2007.06.09.04.08.39;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2007.06.08.04.59.06;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2007.06.07.03.41.52;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2007.06.07.00.28.17;	author krw;	state Exp;
branches;
next	1.52;

1.52
date	2007.06.06.22.14.31;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2007.06.06.16.42.06;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2007.06.05.02.38.37;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.05.00.38.18;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2007.06.02.02.35.27;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2007.05.31.19.57.44;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2007.05.31.02.57.53;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.31.00.30.08;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2007.05.29.06.28.15;	author otto;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.29.05.08.20;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2006.10.21.16.01.54;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2006.08.17.10.34.14;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2006.08.11.21.32.40;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2006.03.15.20.20.41;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2006.03.15.20.07.28;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2006.01.27.23.03.12;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2006.01.22.00.40.02;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2006.01.20.23.27.25;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2006.01.20.00.20.38;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2005.12.22.02.51.25;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2005.04.19.21.30.20;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2005.03.30.07.52.32;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.17.14.16.04;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2003.07.16.18.06.34;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.02.18.47.58;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2001.10.15.04.03.45;	author jason;	state Exp;
branches
	1.26.4.1;
next	1.25;

1.25
date	2001.06.26.22.31.47;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.18.21.00.40;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	99.01.08.04.29.10;	author millert;	state Exp;
branches
	1.23.6.1;
next	1.22;

1.22
date	99.01.05.04.29.03;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	98.10.03.21.18.56;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	98.05.02.03.57.51;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	98.03.01.10.17.54;	author johns;	state Exp;
branches;
next	1.18;

1.18
date	97.10.01.22.54.20;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.08.08.21.46.52;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	97.06.25.14.43.27;	author downsj;	state Exp;
branches;
next	1.15;

1.15
date	97.05.28.21.38.34;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.05.13.08.51.19;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.04.06.06.09.25;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.04.02.18.28.09;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.01.02.06.28.43;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.12.11.13.36.12;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.12.07.12.20.40;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.12.06.00.12.21;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.12.05.13.22.10;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.09.12.04.33.29;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.08.11.05.35.09;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.01.12.20.21.01;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.15.13.51.45;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.21.13.37.07;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.46;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.46;	author deraadt;	state Exp;
branches;
next	;

1.23.6.1
date	2001.05.14.21.37.15;	author niklas;	state Exp;
branches;
next	1.23.6.2;

1.23.6.2
date	2001.07.04.10.23.39;	author niklas;	state Exp;
branches;
next	1.23.6.3;

1.23.6.3
date	2001.10.31.03.07.57;	author nate;	state Exp;
branches;
next	1.23.6.4;

1.23.6.4
date	2002.03.28.10.57.10;	author niklas;	state Exp;
branches;
next	1.23.6.5;

1.23.6.5
date	2003.06.07.11.14.44;	author ho;	state Exp;
branches;
next	1.23.6.6;

1.23.6.6
date	2004.02.19.10.49.58;	author niklas;	state Exp;
branches;
next	1.23.6.7;

1.23.6.7
date	2004.06.05.23.10.58;	author niklas;	state Exp;
branches;
next	;

1.26.4.1
date	2002.06.11.03.38.16;	author art;	state Exp;
branches;
next	;


desc
@@


1.95
log
@Keep sparc/disksubr.c and sparc64/disksubr.c as close as possible.

Some whitespace/comment tweaks, fix a memcpy() parameter, use the
sparc64 idiom when invoking [iso|udf]_disklabelspoof() functions.

ok deraadt@@
@
text
@/*	$OpenBSD: disksubr.c,v 1.94 2015/09/27 22:34:27 krw Exp $	*/
/*	$NetBSD: disksubr.c,v 1.16 1996/04/28 20:25:59 thorpej Exp $ */

/*
 * Copyright (c) 1994, 1995 Gordon W. Ross
 * Copyright (c) 1994 Theo de Raadt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/ioccom.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/disk.h>
#include <sys/dkbad.h>

#include <machine/cpu.h>
#include <machine/autoconf.h>
#include <dev/sun/disklabel.h>

#if defined(SUN4)
#include <machine/oldmon.h>
#endif

#include "cd.h"

static	int disklabel_sun_to_bsd(struct sun_disklabel *, struct disklabel *);
static	int disklabel_bsd_to_sun(struct disklabel *, struct sun_disklabel *);
static __inline u_int sun_extended_sum(struct sun_disklabel *, void *);

#if NCD > 0
extern void cdstrategy(struct buf *);
#endif

/*
 * Attempt to read a disk label from a device
 * using the indicated strategy routine.
 * The label must be partly set up before this:
 * secpercyl, secsize and anything required for a block i/o read
 * operation in the driver's strategy/start routines
 * must be filled in before calling us.
 */
int
readdisklabel(dev_t dev, void (*strat)(struct buf *),
    struct disklabel *lp, int spoofonly)
{
	struct sun_disklabel *slp;
	struct buf *bp = NULL;
	int error;

	if ((error = initdisklabel(lp)))
		goto done;
	lp->d_flags |= D_VENDOR;

	/*
	 * On sparc64 we check for a CD label first, because our
	 * CD install media contains both sparc & sparc64 labels.
	 * We want the sparc64 machine to find the "CD label", not
	 * the SunOS label, for loading its kernel.
	 */
#if NCD > 0
	if (strat == cdstrategy) {
#if defined(CD9660)
		if (iso_disklabelspoof(dev, strat, lp) == 0)
			goto done;
#endif
#if defined(UDF)
		if (udf_disklabelspoof(dev, strat, lp) == 0)
			goto done;
#endif
	}
#endif /* NCD > 0 */

	/* get buffer and initialize it */
	bp = geteblk((int)lp->d_secsize);
	bp->b_dev = dev;

	if (spoofonly)
		goto doslabel;

	error = readdisksector(bp, strat, lp, DL_BLKTOSEC(lp, LABELSECTOR));
	if (error)
		goto done;

	slp = (struct sun_disklabel *)bp->b_data;
	if (slp->sl_magic == SUN_DKMAGIC) {
		error = disklabel_sun_to_bsd(slp, lp);
		goto done;
	}

	error = checkdisklabel(bp->b_data + LABELOFFSET, lp, 0, DL_GETDSIZE(lp));
	if (error == 0)
		goto done;

doslabel:
	error = readdoslabel(bp, strat, lp, NULL, spoofonly);
	if (error == 0)
		goto done;

	/* A CD9660/UDF label may be on a non-CD drive, so recheck */
#if defined(CD9660)
	error = iso_disklabelspoof(dev, strat, lp);
	if (error == 0)
		goto done;
#endif
#if defined(UDF)
	error = udf_disklabelspoof(dev, strat, lp);
	if (error == 0)
		goto done;
#endif

done:
	if (bp) {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
	disk_change = 1;
	return (error);
}

/*
 * Write disk label back to device after modification.
 */
int
writedisklabel(dev_t dev, void (*strat)(struct buf *), struct disklabel *lp)
{
	struct buf *bp = NULL;
	int error;

	/* get buffer and initialize it */
	bp = geteblk((int)lp->d_secsize);
	bp->b_dev = dev;

	error = disklabel_bsd_to_sun(lp, (struct sun_disklabel *)bp->b_data);
	if (error)
		goto done;

	/* Write out the updated label. */
	bp->b_blkno = LABELSECTOR;
	bp->b_bcount = lp->d_secsize;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_WRITE | B_RAW);
	(*strat)(bp);
	error = biowait(bp);

done:
	if (bp) {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
	disk_change = 1;
	return (error);
}

/************************************************************************
 *
 * The rest of this was taken from arch/sparc/scsi/sun_disklabel.c
 * and then substantially rewritten by Gordon W. Ross
 *
 ************************************************************************/

/* What partition types to assume for Sun disklabels: */
static u_char
sun_fstypes[16] = {
	FS_BSDFFS,	/* a */
	FS_SWAP,	/* b */
	FS_UNUSED,	/* c - whole disk */
	FS_BSDFFS,	/* d */
	FS_BSDFFS,	/* e */
	FS_BSDFFS,	/* f */
	FS_BSDFFS,	/* g */
	FS_BSDFFS,	/* h */
	FS_BSDFFS,	/* i */
	FS_BSDFFS,	/* j */
	FS_BSDFFS,	/* k */
	FS_BSDFFS,	/* l */
	FS_BSDFFS,	/* m */
	FS_BSDFFS,	/* n */
	FS_BSDFFS,	/* o */
	FS_BSDFFS	/* p */
};

/*
 * Given a struct sun_disklabel, assume it has an extended partition
 * table and compute the correct value for sl_xpsum.
 */
static __inline u_int
sun_extended_sum(struct sun_disklabel *sl, void *end)
{
	u_int sum, *xp, *ep;

	xp = (u_int *)&sl->sl_xpmag;
	ep = (u_int *)end;

	sum = 0;
	for (; xp < ep; xp++)
		sum += *xp;
	return (sum);
}

/*
 * Given a SunOS disk label, set lp to a BSD disk label.
 * The BSD label is cleared out before this is called.
 */
static int
disklabel_sun_to_bsd(struct sun_disklabel *sl, struct disklabel *lp)
{
	struct sun_preamble *preamble = (struct sun_preamble *)sl;
	struct sun_partinfo *ppp;
	struct sun_dkpart *spp;
	struct partition *npp;
	u_short cksum = 0, *sp1, *sp2;
	int i, secpercyl;

	/* Verify the XOR check. */
	sp1 = (u_short *)sl;
	sp2 = (u_short *)(sl + 1);
	while (sp1 < sp2)
		cksum ^= *sp1++;
	if (cksum != 0)
		return (EINVAL);	/* SunOS disk label, bad checksum */

	/* Format conversion. */
	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_flags = D_VENDOR;
	memcpy(lp->d_packname, sl->sl_text, sizeof(lp->d_packname));

	lp->d_secsize = DEV_BSIZE;
	lp->d_nsectors = sl->sl_nsectors;
	lp->d_ntracks = sl->sl_ntracks;
	lp->d_ncylinders = sl->sl_ncylinders;

	secpercyl = sl->sl_nsectors * sl->sl_ntracks;
	lp->d_secpercyl = secpercyl;
	/* If unset or initialized as full disk, permit refinement */
	if (DL_GETDSIZE(lp) == 0 || DL_GETDSIZE(lp) == MAXDISKSIZE)
		DL_SETDSIZE(lp, (u_int64_t)secpercyl * sl->sl_ncylinders);
	lp->d_version = 1;

	memcpy(&lp->d_uid, &sl->sl_uid, sizeof(lp->d_uid));

	lp->d_acylinders = sl->sl_acylinders;

	lp->d_npartitions = MAXPARTITIONS;
	/* These are as defined in <ufs/ffs/fs.h> */
	lp->d_bbsize = 8192;	/* XXX */
	lp->d_sbsize = 8192;	/* XXX */

	for (i = 0; i < 8; i++) {
		spp = &sl->sl_part[i];
		npp = &lp->d_partitions[i];
		DL_SETPOFFSET(npp, spp->sdkp_cyloffset * secpercyl);
		DL_SETPSIZE(npp, spp->sdkp_nsectors);
		if (DL_GETPSIZE(npp) == 0) {
			npp->p_fstype = FS_UNUSED;
		} else {
			npp->p_fstype = sun_fstypes[i];
			if (npp->p_fstype == FS_BSDFFS) {
				/*
				 * The sun label does not store the FFS fields,
				 * so just set them with default values here.
				 */
				npp->p_fragblock =
				    DISKLABELV1_FFS_FRAGBLOCK(2048, 8);
				npp->p_cpg = 16;
			}
		}
	}

	/* Clear "extended" partition info, tentatively */
	for (i = 0; i < SUNXPART; i++) {
		npp = &lp->d_partitions[i+8];
		DL_SETPOFFSET(npp, 0);
		DL_SETPSIZE(npp, 0);
		npp->p_fstype = FS_UNUSED;
	}

	/* Check to see if there's an "extended" partition table
	 * SL_XPMAG partitions had checksums up to just before the
	 * (new) sl_types variable, while SL_XPMAGTYP partitions have
	 * checksums up to the just before the (new) sl_xxx1 variable.
	 */
	if ((sl->sl_xpmag == SL_XPMAG &&
	    sun_extended_sum(sl, &sl->sl_types) == sl->sl_xpsum) ||
	    (sl->sl_xpmag == SL_XPMAGTYP &&
	    sun_extended_sum(sl, &sl->sl_xxx1) == sl->sl_xpsum)) {
		/*
		 * There is.  Copy over the "extended" partitions.
		 * This code parallels the loop for partitions a-h.
		 */
		for (i = 0; i < SUNXPART; i++) {
			spp = &sl->sl_xpart[i];
			npp = &lp->d_partitions[i+8];
			DL_SETPOFFSET(npp, spp->sdkp_cyloffset * secpercyl);
			DL_SETPSIZE(npp, spp->sdkp_nsectors);
			if (DL_GETPSIZE(npp) == 0) {
				npp->p_fstype = FS_UNUSED;
				continue;
			}
			npp->p_fstype = sun_fstypes[i+8];
			if (npp->p_fstype == FS_BSDFFS) {
				npp->p_fragblock =
				    DISKLABELV1_FFS_FRAGBLOCK(2048, 8);
				npp->p_cpg = 16;
			}
		}
		if (sl->sl_xpmag == SL_XPMAGTYP) {
			for (i = 0; i < MAXPARTITIONS; i++) {
				npp = &lp->d_partitions[i];
				npp->p_fstype = sl->sl_types[i];
				npp->p_fragblock = sl->sl_fragblock[i];
				npp->p_cpg = sl->sl_cpg[i];
			}
		}
	} else if (preamble->sl_nparts <= 8) {
		/*
		 * A more traditional Sun label.  Recognise certain filesystem
		 * types from it, if they are available.
		 */
		i = preamble->sl_nparts;
		if (i == 0)
			i = 8;

		npp = &lp->d_partitions[i-1];
		ppp = &preamble->sl_part[i-1];
		for (; i > 0; i--, npp--, ppp--) {
			if (npp->p_size == 0)
				continue;
			if ((ppp->spi_tag == 0) && (ppp->spi_flag == 0))
				continue;

			switch (ppp->spi_tag) {
			case SPTAG_SUNOS_ROOT:
			case SPTAG_SUNOS_USR:
			case SPTAG_SUNOS_VAR:
			case SPTAG_SUNOS_HOME:
				npp->p_fstype = FS_BSDFFS;
				npp->p_fragblock =
				    DISKLABELV1_FFS_FRAGBLOCK(2048, 8);
				npp->p_cpg = 16;
				break;
			case SPTAG_LINUX_EXT2:
				npp->p_fstype = FS_EXT2FS;
				break;
			default:
				/* FS_SWAP for _SUNOS_SWAP and _LINUX_SWAP? */
				npp->p_fstype = FS_UNUSED;
				break;
			}
		}
	}

	lp->d_checksum = 0;
	lp->d_checksum = dkcksum(lp);
	return (checkdisklabel(lp, lp, 0, DL_GETDSIZE(lp)));
}

/*
 * Given a BSD disk label, update the Sun disklabel
 * pointed to by cp with the new info.  Note that the
 * Sun disklabel may have other info we need to keep.
 */
static int
disklabel_bsd_to_sun(struct disklabel *lp, struct sun_disklabel *sl)
{
	struct partition *npp;
	struct sun_dkpart *spp;
	int i, secpercyl;
	u_short cksum, *sp1, *sp2;

	/* Enforce preconditions */
	if (lp->d_secsize != DEV_BSIZE || lp->d_nsectors == 0 ||
	    lp->d_ntracks == 0)
		return (EINVAL);

	/* Format conversion. */
	bzero(sl, sizeof(*sl));
	memcpy(sl->sl_text, lp->d_packname, sizeof(lp->d_packname));
	sl->sl_pcylinders = lp->d_ncylinders + lp->d_acylinders; /* XXX */
	sl->sl_ncylinders = lp->d_ncylinders;
	sl->sl_acylinders = lp->d_acylinders;
	sl->sl_ntracks = lp->d_ntracks;
	sl->sl_nsectors = lp->d_nsectors;

	memcpy(&sl->sl_uid, &lp->d_uid, sizeof(lp->d_uid));

	secpercyl = sl->sl_nsectors * sl->sl_ntracks;
	for (i = 0; i < 8; i++) {
		spp = &sl->sl_part[i];
		npp = &lp->d_partitions[i];
		spp->sdkp_cyloffset = 0;
		spp->sdkp_nsectors = 0;
		if (DL_GETPSIZE(npp)) {
			if (DL_GETPOFFSET(npp) % secpercyl)
				return (EINVAL);
			spp->sdkp_cyloffset = DL_GETPOFFSET(npp) / secpercyl;
			spp->sdkp_nsectors = DL_GETPSIZE(npp);
		}
	}
	sl->sl_magic = SUN_DKMAGIC;

	for (i = 0; i < SUNXPART; i++) {
		spp = &sl->sl_xpart[i];
		npp = &lp->d_partitions[i+8];
		spp->sdkp_cyloffset = 0;
		spp->sdkp_nsectors = 0;
		if (DL_GETPSIZE(npp)) {
			if (DL_GETPOFFSET(npp) % secpercyl)
				return (EINVAL);
			spp->sdkp_cyloffset = DL_GETPOFFSET(npp) / secpercyl;
			spp->sdkp_nsectors = DL_GETPSIZE(npp);
		}
	}
	for (i = 0; i < MAXPARTITIONS; i++) {
		npp = &lp->d_partitions[i];
		sl->sl_types[i] = npp->p_fstype;
		sl->sl_fragblock[i] = npp->p_fragblock;
		sl->sl_cpg[i] = npp->p_cpg;
	}
	sl->sl_xpmag = SL_XPMAGTYP;
	sl->sl_xpsum = sun_extended_sum(sl, &sl->sl_xxx1);

	/* Correct the XOR check. */
	sp1 = (u_short *)sl;
	sp2 = (u_short *)(sl + 1);
	sl->sl_cksum = cksum = 0;
	while (sp1 < sp2)
		cksum ^= *sp1++;
	sl->sl_cksum = cksum;
	return (0);
}

/*
 * Search the bad sector table looking for the specified sector.
 * Return index if found.
 * Return -1 if not found.
 */
int
isbad(struct dkbad *bt, int cyl, int trk, int sec)
{
	int i;
	long blk, bblk;

	blk = ((long)cyl << 16) + (trk << 8) + sec;
	for (i = 0; i < NBT_BAD; i++) {
		bblk = ((long)bt->bt_bad[i].bt_cyl << 16) +
			bt->bt_bad[i].bt_trksec;
		if (blk == bblk)
			return (i);
		if (blk < bblk || bblk < 0)
			break;
	}
	return (-1);
}
@


1.94
log
@Use readdisksector() instead of manual buf initialization. sparc64
compiles and boots, so the identical sparc code must too!

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.93 2015/01/16 20:17:05 miod Exp $	*/
d86 1
a86 1
		if ((error = iso_disklabelspoof(dev, strat, lp)) == 0)
d90 1
a90 1
		if ((error = udf_disklabelspoof(dev, strat, lp)) == 0)
a224 1
 *
d243 1
a243 1
		return (EINVAL); /* SunOS disk label, bad checksum */
d263 1
a263 1
	memcpy(&lp->d_uid, &sl->sl_uid, sizeof(sl->sl_uid));
@


1.93
log
@disklabel_sun_to_bsd() will nicely set the disk size if it is zero, but it is
usually invoked after initdisklabel() which proactively changes a zero disk
size to MAXDISKSIZE, causing this test to fail.

Allow for MAXDISKSIZE too in that test. This makes spoofed disklabels of SMD
disks have a proper `c' slice size.

luna88k disklabel_om_to_bsd() is modified accordingly, to keep diffability,
even though luna88k can't - to the best of my knowledge - sport SMD disk
controllers.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.92 2013/10/20 10:11:16 krw Exp $	*/
d103 2
a104 7
	bp->b_blkno = LABELSECTOR;
	bp->b_bcount = lp->d_secsize;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
	(*strat)(bp);
	if (biowait(bp)) {
		error = bp->b_error;
a105 1
	}
@


1.92
log
@(daddr_t) -> (u_int64_t) when multiplying ncylinders * secpercyl to
get disk size, since DL_SETDSIZE() takes disk sector values, not
512-byte block values.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.91 2013/06/11 16:42:11 deraadt Exp $	*/
d265 2
a266 1
	if (DL_GETDSIZE(lp) == 0)
@


1.91
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.90 2011/04/16 03:21:15 krw Exp $	*/
d266 1
a266 1
		DL_SETDSIZE(lp, (daddr_t)secpercyl * sl->sl_ncylinders);
@


1.90
log
@Use 'CLR(<buf>->b_flags, B_READ | B_WRITE | B_DONE)' regardless of
what the previous IO was. Less chance of copy and paste errors.
Suggested by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.89 2011/04/15 14:57:29 krw Exp $	*/
d266 1
a266 1
		DL_SETDSIZE(lp, (daddr64_t)secpercyl * sl->sl_ncylinders);
@


1.89
log
@In days of yore one could arbitrarily whack buffer flags. Those days
are past. Use CLR() and SET() to modify necessary flags while leaving
the flags used by the buffer cache in peace.

Should make bufcache code much less confused about the state of the
bufs used in reading/writing disklabels. Other such flag abuses no
doubt await a visit.

Errors in original diff found by miod@@.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.88 2011/04/06 13:46:50 miod Exp $	*/
d105 1
a105 1
	CLR(bp->b_flags, B_WRITE | B_DONE);
d169 1
a169 1
	CLR(bp->b_flags, B_READ | B_DONE);
@


1.88
log
@The various read*label() have stopped returning error strings for quite
some time, and return errnos instead. Fix or remove out-of-date comments
mentioning the error strings, and make their callers check the return value
against zero, not NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.87 2011/02/26 13:07:48 krw Exp $	*/
d105 2
a106 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d169 2
a170 1
	bp->b_flags = B_BUSY | B_WRITE | B_RAW;
@


1.87
log
@Force the DUID cache used to generate hw.disknames to be updated
after every disklabel read or write. This keeps the DUID cache more
in sync with the physical world. De-syncing noted by drahn@@ while
zapping disklabels with dd.

ok jsing@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.86 2010/04/25 06:15:17 deraadt Exp $	*/
a63 4
 *
 * Return buffer for use in signalling errors if requested.
 *
 * Returns null on success and an error string on failure.
a228 1
 * Returns NULL on success, else an error string.
a388 1
 * Returns zero or error code.
@


1.86
log
@introducing a 64-bit type to the disklabel structure leads some architectures
to pad-align the size of the structure; it grows, the disklabel ioctl's are
break ABI.  Change the uid to a character array.  this also simplifies some
other stuff
ok jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.85 2010/04/24 20:12:22 miod Exp $	*/
d148 1
d181 1
@


1.85
log
@grammar in comments
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.84 2010/04/23 15:25:21 jsing Exp $	*/
d270 1
a270 1
	lp->d_label_uid = sl->sl_label_uid;
d416 1
a416 1
	sl->sl_label_uid = lp->d_label_uid;
@


1.84
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.82 2009/08/13 15:23:11 deraadt Exp $	*/
d85 1
a85 1
	 * the SunOS label, for loading it's kernel.
@


1.83
log
@when we build a vendor label for writing, clear the memory supplied by the
buffer cache first, so that all sorts of gibble doesn't end up on the disk.
ok kettenis (for the sparc/sparc64 ones, at least)
@
text
@d270 2
a271 1
	lp->d_sparespercyl = sl->sl_sparespercyl;
a272 2
	lp->d_rpm = sl->sl_rpm;
	lp->d_interleave = sl->sl_interleave;
a409 1
	sl->sl_rpm = lp->d_rpm;
a410 2
	sl->sl_sparespercyl = lp->d_sparespercyl;
	sl->sl_interleave = lp->d_interleave;
d415 2
@


1.82
log
@Replace the error strings that were being passed around with much simpler
errnos.  Note that the error strings are being ignored, since we long ago
decided to not spam the console, and there is no other nice way to use the
errors (without changing the ioctls to pass it back)
The errno is now useful, since we can pass b_error from failing IO up, and
the drive can decide how to use that
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.81 2009/06/04 21:13:02 deraadt Exp $	*/
d409 1
@


1.81
log
@Recycle four ancient fields in the disklabel structure, replacing them with
bounds information, ie. the zone of the disk that OpenBSD can use.  Have each
pre-disklabel parser (MBR, DPME, or per-arch MD disklabel parsers) figure out
this area and pass it up to userland.  Then, delete all the same disk parsing
code from disklabel(8) since the kernel passes it up.  Lots and lots of - signs
in the disklabel(8) code.
Tested on as many platforms as possible, the fallout will be repaired as time
goes on.  To test, use disklabel -d <drive> and validate that the bounds do not
overlap any boot blocks.  This same information is used by disklabel -A...
OK for the concept from krw, miod, and drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.80 2009/05/13 01:31:58 krw Exp $	*/
d49 1
a49 1
static	char *disklabel_sun_to_bsd(struct sun_disklabel *, struct disklabel *);
d69 1
a69 1
char *
d75 1
a75 1
	char *msg;
d77 1
a77 1
	if ((msg = initdisklabel(lp)))
d90 1
a90 1
		if (iso_disklabelspoof(dev, strat, lp) == 0)
d94 1
a94 1
		if (udf_disklabelspoof(dev, strat, lp) == 0)
d112 1
a112 1
		msg = "disk label read error";
d118 1
a118 1
		msg = disklabel_sun_to_bsd(slp, lp);
d122 2
a123 2
	msg = checkdisklabel(bp->b_data + LABELOFFSET, lp, 0, DL_GETDSIZE(lp));
	if (msg == NULL)
d127 2
a128 2
	msg = readdoslabel(bp, strat, lp, NULL, spoofonly);
	if (msg == NULL)
d133 2
a134 2
	if (iso_disklabelspoof(dev, strat, lp) == 0) {
		msg = NULL;
a135 1
	}
d138 2
a139 2
	if (udf_disklabelspoof(dev, strat, lp) == 0) {
		msg = NULL;
a140 1
	}
d148 1
a148 1
	return (msg);
d235 1
a235 1
static char *
d251 1
a251 1
		return ("SunOS disk label, bad checksum");
a461 1

@


1.80
log
@Set D_VENDOR when spoofing a label on archs that use D_VENDOR when
reading the native disklabel. This ensures cylinder alignment.

Fix disklabel to do cylinder alignment arithmetic correctly in -A
mode. Worked by accident before, since the code was protected by
D_VENDOR, which wasn't being set.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.79 2009/04/10 06:32:47 deraadt Exp $	*/
d100 1
a100 1
	/* get a buffer and initialize it */
d122 1
a122 1
	msg = checkdisklabel(bp->b_data + LABELOFFSET, lp);
d162 1
a162 1
	/* get a buffer and initialize it */
d237 1
a237 1
char *
d388 1
a388 1
	return (checkdisklabel(lp, lp));
@


1.79
log
@fix typos introduced
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.78 2009/04/07 03:11:59 krw Exp $	*/
d79 1
@


1.78
log
@Eliminate useless loop over partitions and ignore zero length
partitions in bsd_to_sun(), even if their offsets are nonsense.
Theo says if sparc64 compiles so will sparc. Fixes some useless
disklabel warning messages.

ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.77 2009/01/22 01:06:28 krw Exp $	*/
d286 1
a286 1
		if (DL_GETPSIZE(npp) == 0)) {
d328 1
a328 1
			if (DL_GETPSIZE(npp) == 0)) {
d426 1
a426 1
		if (DL_GETPSIZE(npp) {
d440 1
a440 1
		if (DL_GETPSIZE(npp) {
@


1.77
log
@Call checkdisklabel() for labels built from native info. This will
ensure 'c' always has the correct size as the rest of the kernel
assumes. Thus prevent dd'ing causing a SCSI out-of-bounds error.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.76 2008/06/29 20:05:22 krw Exp $	*/
d286 1
a286 1
		if (DL_GETPSIZE(npp) == 0) {
d328 1
a328 1
			if (DL_GETPSIZE(npp) == 0) {
d424 8
a431 5

		if (DL_GETPOFFSET(npp) % secpercyl)
			return (EINVAL);
		spp->sdkp_cyloffset = DL_GETPOFFSET(npp) / secpercyl;
		spp->sdkp_nsectors = DL_GETPSIZE(npp);
a435 5
		if (DL_GETPOFFSET(&lp->d_partitions[i+8]) ||
		    DL_GETPSIZE(&lp->d_partitions[i+8]))
			break;
	}
	for (i = 0; i < SUNXPART; i++) {
d438 8
a445 5
		if (DL_GETPOFFSET(npp) % secpercyl)
			return (EINVAL);
		sl->sl_xpart[i].sdkp_cyloffset =
		    DL_GETPOFFSET(npp) / secpercyl;
		sl->sl_xpart[i].sdkp_nsectors = DL_GETPSIZE(npp);
@


1.76
log
@Use DEV_BSIZE (defined as 512) instead of 512 when initializing the
disklabel's d_secsize.

ok millert@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.75 2008/06/12 06:58:37 deraadt Exp $	*/
d387 1
a387 1
	return (NULL);
@


1.75
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.73 2008/06/10 20:50:23 beck Exp $	*/
d260 1
a260 1
	lp->d_secsize = 512;
d405 2
a406 1
	if (lp->d_secsize != 512 || lp->d_nsectors == 0 || lp->d_ntracks == 0)
@


1.74
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.72 2007/10/02 03:26:59 krw Exp $	*/
d108 1
a108 1
	bp->b_flags = B_BUSY | B_READ;
d172 1
a172 1
	bp->b_flags = B_BUSY | B_WRITE;
@


1.73
log
@Fix buffer cache pending read statistics by ensuring we can identify
biowait() reads that do *not* come from the buffer cache - we use the
B_RAW flag to identify these at art's suggestion - since it makes sense
and the flag was not being used. this just flags all these buffers with
B_RAW - biodone already ignores returned buffers marked B_RAW.
ok art@@
@
text
@d108 1
a108 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d172 1
a172 1
	bp->b_flags = B_BUSY | B_WRITE | B_RAW;
@


1.72
log
@Fiddle Sun traditional disklabel recognition to eliminate union and
associated field access defines. This reverts most changes to
dev/sun/disklabel.h without eliminating new functionality. Fix
comments to line up and fit on 80 column line, making both tsi@@ and I
feel better.

Simplify logic in disksubr.c. No semantic change.

Tested & ok tsi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.71 2007/09/19 23:47:50 tsi Exp $	*/
d108 1
a108 1
	bp->b_flags = B_BUSY | B_READ;
d172 1
a172 1
	bp->b_flags = B_BUSY | B_WRITE;
@


1.71
log
@On sparc & sparc64, change `mount -a` to recognise Linux ext2 partitions
by interpreting more fields out of a standard Sun disk label.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.70tsi Exp $	*/
d239 3
d243 1
a243 2
	struct sun_dkpart *spp;
	struct sun_partinfo *ppp;
a244 1
	u_short cksum = 0, *sp1, *sp2;
d347 1
a347 1
	} else if (sl->sl_nparts <= 8) {
d352 7
a358 17
		if ((i = sl->sl_nparts) == 0) {
			for (i = 8;  i-- > 0; ) {
				npp = &lp->d_partitions[i];
				if (npp->p_size == 0)
					continue;

				ppp = &sl->sl_ipart[i];
				if ((ppp->spi_tag == 0) && (ppp->spi_flag == 0))
					continue;

				i = 8;
				break;
			}
		}

		while (i-- > 0) {
			npp = &lp->d_partitions[i];
d361 2
a363 1
			ppp = &sl->sl_ipart[i];
a364 9
			case SPTAG_EMPTY:
			case SPTAG_BOOT:
			case SPTAG_WHOLE_DISK:
				npp->p_fstype = FS_UNUSED;
				break;
			case SPTAG_SUNOS_SWAP:
			case SPTAG_LINUX_SWAP:
				npp->p_fstype = FS_UNUSED;	/* FS_SWAP? */
				break;
d378 1
@


1.70
log
@Perform minimal disklabel setup without needing to do the disklabel_to_sun()
dance, so that we do not depend on its behaviour. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.69 2007/06/24 16:52:05 miod Exp $	*/
d241 1
d338 1
a338 1
		if (sl->sl_xpmag == SL_XPMAGTYP)
d345 54
@


1.69
log
@Fix xd and xy disklabel handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.68 2007/06/20 18:15:46 deraadt Exp $	*/
d49 1
a49 1
	char *disklabel_sun_to_bsd(struct sun_disklabel *, struct disklabel *);
@


1.68
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.67 2007/06/18 05:30:54 deraadt Exp $	*/
d49 1
a49 1
static	char *disklabel_sun_to_bsd(struct sun_disklabel *, struct disklabel *);
a114 5
#if NOTANYMORE
	/* XXX because xd(4) & xy(4) still need it */
	bcopy(bp->b_data, osdep->cd_block, sizeof(osdep->cd_block));
#endif

d236 1
a236 1
static char *
@


1.67
log
@more comments that are different
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.66 2007/06/18 05:28:54 deraadt Exp $	*/
d71 1
a71 1
    struct disklabel *lp, struct cpu_disklabel *osdep, int spoofonly)
a106 1
	bp->b_cylinder = 0;
d115 1
d118 1
d131 1
a131 1
	msg = readdoslabel(bp, strat, lp, osdep, NULL, NULL, spoofonly);
d161 1
a161 2
writedisklabel(dev_t dev, void (*strat)(struct buf *),
    struct disklabel *lp, struct cpu_disklabel *osdep)
a175 1
	bp->b_cylinder = 0;
@


1.66
log
@using same words in similar code sequences is good
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.65 2007/06/18 02:14:17 deraadt Exp $	*/
d99 1
a99 1
	/* get buffer and initialize it */
d166 1
a166 1
	/* get buffer and initialize it */
@


1.65
log
@msg is already gauranteed to be NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.64 2007/06/17 00:27:29 deraadt Exp $	*/
d99 1
a99 1
	/* obtain buffer and initialize it */
d166 1
a166 1
	/* obtain buffer and initialize it */
@


1.64
log
@significantly simplified disklabel infrastructure.  MBR handling becomes MI
to support hotplug media on most architectures.  disklabel setup and
verification done using new helper functions.  Disklabels must *always*
have a correct checksum now.  Same code paths are used to learn on-disk
location disklabels, to avoid new errors sneaking in.  Tested on almost all
cases, testing help from todd, kettenis, krw, otto, dlg, robert, gwk, drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.63 2007/06/14 03:41:22 deraadt Exp $	*/
d89 1
a89 2
		if (iso_disklabelspoof(dev, strat, lp) == 0) {
			msg = NULL;
a90 1
		}
d93 1
a93 2
		if (udf_disklabelspoof(dev, strat, lp) == 0) {
			msg = NULL;
a94 1
		}
@


1.63
log
@some spaces in the way
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.62 2007/06/14 03:37:23 deraadt Exp $	*/
d49 2
a50 2
static	char *disklabel_sun_to_bsd(char *, struct disklabel *);
static	int disklabel_bsd_to_sun(struct disklabel *, char *);
d71 1
a71 1
    struct disklabel *lp, struct cpu_disklabel *clp, int spoofonly)
d73 1
d75 1
a75 4
	struct disklabel *dlp;
	struct sun_disklabel *slp;
	char *msg = NULL;
	int error, i;
d77 1
a77 23
	/* minimal requirements for archetypal disk label */
	if (lp->d_secsize < DEV_BSIZE)
		lp->d_secsize = DEV_BSIZE;
	if (DL_GETDSIZE(lp) == 0)
		DL_SETDSIZE(lp, MAXDISKSIZE);
	if (lp->d_secpercyl == 0) {
		msg = "invalid geometry";
		goto done;
	}
	lp->d_npartitions = RAW_PART+1;
	for (i = 0; i < RAW_PART; i++) {
		DL_SETPSIZE(&lp->d_partitions[i], 0);
		DL_SETPOFFSET(&lp->d_partitions[i], 0);
	}
	if (DL_GETPSIZE(&lp->d_partitions[RAW_PART]) == 0)
		DL_SETPSIZE(&lp->d_partitions[RAW_PART], DL_GETDSIZE(lp));
	DL_SETPOFFSET(&lp->d_partitions[RAW_PART], 0);
	lp->d_version = 1;
	lp->d_bbsize = 8192;
	lp->d_sbsize = 64*1024;		/* XXX ? */

	/* don't read the on-disk label if we are in spoofed-only mode */
	if (spoofonly)
d80 6
d103 1
a103 1
	/* obtain buffer to probe drive with */
d105 4
a109 2
	/* next, dig out disk label */
	bp->b_dev = dev;
d115 1
a115 8

	/* if successful, locate disk label within block and validate */
	error = biowait(bp);
	if (error == 0) {
		/* Save the whole block in case it has info we need. */
		bcopy(bp->b_data, clp->cd_block, sizeof(clp->cd_block));
	}
	if (error) {
d120 4
a123 1
	slp = (struct sun_disklabel *)clp->cd_block;
d125 1
a125 1
		msg = disklabel_sun_to_bsd(clp->cd_block, lp);
d129 7
a135 10
	/* Check for a native disk label (PROM can not boot it). */
	dlp = (struct disklabel *)(clp->cd_block + LABELOFFSET);
	if (dlp->d_magic == DISKMAGIC) {
		if (dkcksum(dlp)) {
			msg = "disk label corrupted";
			goto done;
		}
		DL_SETDSIZE(dlp, DL_GETDSIZE(lp));
		*lp = *dlp;	/* struct assignment */
		msg = NULL;
a136 1
	}
d138 1
a150 2
	bzero(clp->cd_block, sizeof(clp->cd_block));
	msg = "no disk label";
a156 1
	disklabeltokernlabel(lp);
a161 1
 * Current label is already in clp->cd_block[]
d165 1
a165 1
    struct disklabel *lp, struct cpu_disklabel *clp)
d170 5
a174 1
	error = disklabel_bsd_to_sun(lp, clp->cd_block);
a177 4
	/* Get a buffer and copy the new label into it. */
	bp = geteblk((int)lp->d_secsize);
	bcopy(clp->cd_block, bp->b_data, sizeof(clp->cd_block));

a178 1
	bp->b_dev = dev;
d247 1
a247 1
disklabel_sun_to_bsd(char *cp, struct disklabel *lp)
a248 1
	struct sun_disklabel *sl;
d252 1
a252 3
	u_short cksum, *sp1, *sp2;

	sl = (struct sun_disklabel *)cp;
a256 1
	cksum = 0;
d265 1
d277 1
a277 1
	lp->d_version = 1;	/* 48 bit addressing */
d368 1
a368 1
disklabel_bsd_to_sun(struct disklabel *lp, char *cp)
a369 1
	struct sun_disklabel *sl;
a377 2

	sl = (struct sun_disklabel *)cp;
@


1.62
log
@excessive blank lines making the versions different
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.61 2007/06/14 03:35:30 deraadt Exp $	*/
d300 2
a301 2
	lp->d_nsectors   = sl->sl_nsectors;
	lp->d_ntracks    = sl->sl_ntracks;
d305 1
a305 1
	lp->d_secpercyl  = secpercyl;
d311 3
a313 3
	lp->d_acylinders   = sl->sl_acylinders;
	lp->d_rpm          = sl->sl_rpm;
	lp->d_interleave   = sl->sl_interleave;
d416 1
a416 1
	sl->sl_pcylinders   = lp->d_ncylinders + lp->d_acylinders; /* XXX */
d418 5
a422 5
	sl->sl_interleave   = lp->d_interleave;
	sl->sl_ncylinders   = lp->d_ncylinders;
	sl->sl_acylinders   = lp->d_acylinders;
	sl->sl_ntracks      = lp->d_ntracks;
	sl->sl_nsectors     = lp->d_nsectors;
@


1.61
log
@set the prototype disklabel to version 1
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.60 2007/06/14 03:29:34 deraadt Exp $	*/
a184 1

@


1.60
log
@do not depend on previous loop variable, use a constant instead
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.59 2007/06/12 20:57:43 deraadt Exp $	*/
d96 1
@


1.59
log
@all disksubr.c did their b_flags manipulation differently (and wrong).
correct and unify; ok thib miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.58 2007/06/09 23:06:46 krw Exp $	*/
d93 3
a95 3
	if (DL_GETPSIZE(&lp->d_partitions[i]) == 0)
		DL_SETPSIZE(&lp->d_partitions[i], DL_GETDSIZE(lp));
	DL_SETPOFFSET(&lp->d_partitions[i], 0);
@


1.58
log
@The differences in the last non-homogeneous bounds_check_with_label()
routines (alpha, vax) prove to be not worth keeping. Move
bounds_check_with_label() into the MI world. Eliminate unreliable and
almost certainly useless checks for overwriting a disklabel.

After discussion with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.57 2007/06/09 18:06:50 deraadt Exp $	*/
d178 1
a178 1
		bp->b_flags = B_INVAL | B_AGE | B_READ;
d194 1
a194 1
	struct buf *bp;
d199 1
a199 9
		return (error);

#if 0	/* XXX - Allow writing native disk labels? */
	{
		struct disklabel *dlp;
		dlp = (struct disklabel *)(clp->cd_block + LABELOFFSET);
		*dlp = *lp;	/* struct assignment */
	}
#endif
d210 1
a210 1
	bp->b_flags = B_WRITE;
a212 1
	brelse(bp);
d214 5
@


1.57
log
@kill stupid character difference
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.56 2007/06/09 04:08:39 deraadt Exp $	*/
a223 56
}

/*
 * Determine the size of the transfer, and make sure it is
 * within the boundaries of the partition. Adjust transfer
 * if needed, and signal errors or early completion.
 */
int
bounds_check_with_label(struct buf *bp, struct disklabel *lp,
    struct cpu_disklabel *osdep, int wlabel)
{
#define blockpersec(count, lp) ((count) * (((lp)->d_secsize) / DEV_BSIZE))
	struct partition *p = lp->d_partitions + DISKPART(bp->b_dev);
	int labelsector = blockpersec(DL_GETPOFFSET(&lp->d_partitions[RAW_PART]), lp) +
	    LABELSECTOR;
	int sz = howmany(bp->b_bcount, DEV_BSIZE);

	/* avoid division by zero */
	if (lp->d_secpercyl == 0) {
		bp->b_error = EINVAL;
		goto bad;
	}

	/* beyond partition? */
	if (bp->b_blkno + sz > blockpersec(DL_GETPSIZE(p), lp)) {
		sz = blockpersec(DL_GETPSIZE(p), lp) - bp->b_blkno;
		if (sz == 0) {
			/* If exactly at end of disk, return EOF. */
			bp->b_resid = bp->b_bcount;
			return (-1);
		}
		if (sz < 0) {
			/* If past end of disk, return EINVAL. */
			bp->b_error = EINVAL;
			goto bad;
		}
		/* Otherwise, truncate request. */
		bp->b_bcount = sz << DEV_BSHIFT;
	}

	/* Overwriting disk label? */
	if (bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) <= labelsector &&
	    bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) + sz > labelsector &&
	    (bp->b_flags & B_READ) == 0 && !wlabel) {
		bp->b_error = EROFS;
		goto bad;
	}

	/* calculate cylinder for disksort to order transfers with */
	bp->b_cylinder = (bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp)) /
	    lp->d_secpercyl;
	return (1);

bad:
	bp->b_flags |= B_ERROR;
	return (-1);
@


1.56
log
@by hand i carefully found that all the differences in setdisklabel()
implimentations were simply either missing code, or spacing and such.
setdisklabel() can become MI now.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.55 2007/06/08 04:59:06 deraadt Exp $	*/
d352 1
a352 1
		return("SunOS disk label, bad checksum");
@


1.55
log
@- always set the partition disk size to full disk info (from driver)
- always store our new fatty 16-partitions-with-full-cpg-info style
  sun disklabels on the disk.
- correct an error in matching old-style 16-partition matching code;
  the checksum spanned a different region
tested by me, groked by krw, which is a lot more than the rest of
the post-hackathon exhausted slackers
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.54 2007/06/07 03:41:52 krw Exp $	*/
a184 41
/*
 * Check new disk label for sensibility
 * before setting it.
 */
int
setdisklabel(struct disklabel *olp, struct disklabel *nlp,
    u_int openmask, struct cpu_disklabel *clp)
{
	int i;
	struct partition *opp, *npp;

	/* sanity clause */
	if (nlp->d_secpercyl == 0 || nlp->d_secsize == 0 ||
	    (nlp->d_secsize % DEV_BSIZE) != 0)
		return(EINVAL);

	/* special case to allow disklabel to be invalidated */
	if (nlp->d_magic == 0xffffffff) {
		*olp = *nlp;
		return (0);
	}

	if (nlp->d_magic != DISKMAGIC || nlp->d_magic2 != DISKMAGIC ||
	    dkcksum(nlp) != 0)
		return (EINVAL);

	while ((i = ffs(openmask)) != 0) {
		i--;
		openmask &= ~(1 << i);
		if (nlp->d_npartitions <= i)
			return (EBUSY);
		opp = &olp->d_partitions[i];
		npp = &nlp->d_partitions[i];
		if (DL_GETPOFFSET(npp) != DL_GETPOFFSET(opp) ||
		    DL_GETPSIZE(npp) < DL_GETPSIZE(opp))
			return (EBUSY);
	}

	*olp = *nlp;
	return (0);
}
@


1.54
log
@Comment 'fixes'. All bounds_check_with_label now identical except for
vax and alpha.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.53 2007/06/07 00:28:17 krw Exp $	*/
d51 1
a51 1
static __inline u_int sun_extended_sum(struct sun_disklabel *);
d155 1
d356 1
a356 1
sun_extended_sum(struct sun_disklabel *sl)
d361 1
a361 1
	ep = (u_int *)&sl->sl_xxx1[0];
d450 9
a458 3
	/* Check to see if there's an "extended" partition table */
	if ((sl->sl_xpmag == SL_XPMAG || sl->sl_xpmag == SL_XPMAGTYP) &&
	    sun_extended_sum(sl) == sl->sl_xpsum) {	/* ...yes! */
a536 7
	/*
	 * The reason we store the extended table stuff only conditionally
	 * is so that a label that doesn't need it will have NULs there, like
	 * a "traditional" Sun label.  Since Suns seem to ignore everything
	 * between sl_text and sl_rpm, this probably doesn't matter, but it
	 * certainly doesn't hurt anything and it's easy to do.
	 */
d542 14
a555 26
	/* We do need to load the extended table? */
	if (i < SUNXPART) {
		sl->sl_xpmag = SL_XPMAGTYP;
		for (i = 0; i < SUNXPART; i++) {
			spp = &sl->sl_xpart[i];
			npp = &lp->d_partitions[i+8];
			if (DL_GETPOFFSET(npp) % secpercyl)
				return (EINVAL);
			sl->sl_xpart[i].sdkp_cyloffset =
			    DL_GETPOFFSET(npp) / secpercyl;
			sl->sl_xpart[i].sdkp_nsectors = DL_GETPSIZE(npp);
		}
		for (i = 0; i < MAXPARTITIONS; i++) {
			npp = &lp->d_partitions[i];
			sl->sl_types[i] = npp->p_fstype;
			sl->sl_fragblock[i] = npp->p_fragblock;
			sl->sl_cpg[i] = npp->p_cpg;
		}
		sl->sl_xpsum = sun_extended_sum(sl);
	} else {
		sl->sl_xpmag = 0;
		for (i = 0; i < SUNXPART; i++) {
			sl->sl_xpart[i].sdkp_cyloffset = 0;
			sl->sl_xpart[i].sdkp_nsectors = 0;
		}
		sl->sl_xpsum = 0;
d557 2
@


1.53
log
@More bounds_check_with_label homogenization. Fix a couple of typos while
there.

'so go to it!' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.52 2007/06/06 22:14:31 deraadt Exp $	*/
d304 1
a304 4
	/* overwriting disk label ? */
	/* XXX should also protect bootstrap in first 8K */
	/* XXX this assumes everything <=LABELSECTOR is label! */
	/*     But since LABELSECTOR is 0, that's ok for now. */
@


1.52
log
@clamp the disklabel d_secperunit to what the disk actually says it has,
not to what some bogus disklabel from the past may say (some of which
may have been caused by older openbsd disklabel programs).  resolves
issues seen by myself and Markus Lude on sparc/sparc64 machines
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.51 2007/06/06 16:42:06 deraadt Exp $	*/
d277 2
d293 1
a293 1
			return (0);
d308 3
a310 2
	if ((bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) <= LABELSECTOR) &&
	    ((bp->b_flags & B_READ) == 0) && (wlabel == 0)) {
d319 1
@


1.51
log
@a fair sprinking of knf, code movement, and sometimes character-by-character
accuracy so that the variious disksubr.c's can be compared easier.
setdisklabel() starts taking an int for openmask.
ok krw, and read by quite a few other people
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.50 2007/06/05 02:38:37 krw Exp $	*/
d405 2
a406 1
	DL_SETDSIZE(lp, (daddr64_t)secpercyl * sl->sl_ncylinders);
@


1.50
log
@bounds_check_with_label() checks for i/o outside of the partition and
for overwriting the disklabel. Reorder some checks so all copies of
bounds_check_with_label do the checks in the same order. Order picked
by using the currently most popular one. Should be no functional
change.

"If it's boring, commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.49 2007/06/05 00:38:18 deraadt Exp $	*/
d42 1
a48 4
#if MAXPARTITIONS != 16
#warn beware: Sun disklabel compatibility assumes MAXPARTITIONS == 16
#endif

d51 1
a51 1
static __inline u_long sun_extended_sum(struct sun_disklabel *);
a53 1
/* XXX for comparison below. */
d70 2
a71 6
readdisklabel(dev, strat, lp, clp, spoofonly)
	dev_t dev;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *clp;
	int spoofonly;
d103 17
d142 1
a142 19
#if NCD > 0
	if (strat == cdstrategy) {
#if defined(CD9660)
		if (iso_disklabelspoof(dev, strat, lp) == 0) {
			msg = NULL;
			goto done;
		}
#endif
#if defined(UDF)
		if (udf_disklabelspoof(dev, strat, lp) == 0) {
			msg = NULL;
			goto done;
		}
#endif
	}
#endif /* NCD > 0 */

	/* Check for a Sun disk label (for PROM compatibility). */
	slp = (struct sun_disklabel *) clp->cd_block;
d149 1
a149 1
	dlp = (struct disklabel *) (clp->cd_block + LABELOFFSET);
d189 2
a190 4
setdisklabel(olp, nlp, openmask, clp)
	struct disklabel *olp, *nlp;
	u_long openmask;
	struct cpu_disklabel *clp;
d210 1
a210 1
	while ((i = ffs((long)openmask)) != 0) {
d231 2
a232 5
writedisklabel(dev, strat, lp, clp)
	dev_t dev;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *clp;
d353 2
a354 3
static __inline u_long
sun_extended_sum(sl)
	struct sun_disklabel *sl;
d356 1
a356 3
	u_long lsum;
	u_long *xp;
	u_long *ep;
d358 2
a359 2
	xp = (u_long *) &sl->sl_xpmag;
	ep = (u_long *) &sl->sl_xxx1[0];
d361 1
a361 1
	lsum = 0;
d363 2
a364 2
		lsum += *xp;
	return(lsum);
d366 1
a366 1
	
d374 1
a374 3
disklabel_sun_to_bsd(cp, lp)
	char *cp;
	struct disklabel *lp;
d491 1
a491 3
disklabel_bsd_to_sun(lp, cp)
	struct disklabel *lp;
	char *cp;
d585 1
a585 3
isbad(bt, cyl, trk, sec)
	struct dkbad *bt;
	int cyl, trk, sec;
@


1.49
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.48 2007/06/02 02:35:27 krw Exp $	*/
a298 10
	/* overwriting disk label ? */
	/* XXX should also protect bootstrap in first 8K */
	/* XXX this assumes everything <=LABELSECTOR is label! */
	/*     But since LABELSECTOR is 0, that's ok for now. */
	if ((bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) <= LABELSECTOR) &&
	    ((bp->b_flags & B_READ) == 0) && (wlabel == 0)) {
		bp->b_error = EROFS;
		goto bad;
	}

d314 10
@


1.48
log
@Rename cvtdisklabelv1 -> disklabeltokernlabel. It does more than just
convert version 0 to version 1 disklabels.

Suggested by deraadt@@.

ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.47 2007/05/31 19:57:44 krw Exp $	*/
d90 2
a91 2
	if (lp->d_secperunit == 0)
		lp->d_secperunit = 0x1fffffff;
d98 2
a99 2
		lp->d_partitions[i].p_size = 0;
		lp->d_partitions[i].p_offset = 0;
d101 3
a103 3
	if (lp->d_partitions[i].p_size == 0)
		lp->d_partitions[i].p_size = lp->d_secperunit;
	lp->d_partitions[i].p_offset = 0;
d228 2
a229 1
		if (npp->p_offset != opp->p_offset || npp->p_size < opp->p_size)
d303 1
a303 1
	if ((bp->b_blkno + blockpersec(p->p_offset, lp) <= LABELSECTOR) &&
d310 2
a311 2
	if (bp->b_blkno + sz > blockpersec(p->p_size, lp)) {
		sz = blockpersec(p->p_size, lp) - bp->b_blkno;
d327 1
a327 1
	bp->b_cylinder = (bp->b_blkno + blockpersec(p->p_offset, lp)) /
d424 1
a424 1
	lp->d_secperunit = secpercyl * sl->sl_ncylinders;
d440 3
a442 3
		npp->p_offset = spp->sdkp_cyloffset * secpercyl;
		npp->p_size = spp->sdkp_nsectors;
		if (npp->p_size == 0) {
d461 2
a462 2
		npp->p_offset = 0;
		npp->p_size = 0;
d476 3
a478 3
			npp->p_offset = spp->sdkp_cyloffset * secpercyl;
			npp->p_size = spp->sdkp_nsectors;
			if (npp->p_size == 0) {
d542 1
a542 1
		if (npp->p_offset % secpercyl)
d544 2
a545 2
		spp->sdkp_cyloffset = npp->p_offset / secpercyl;
		spp->sdkp_nsectors = npp->p_size;
d557 2
a558 2
		if (lp->d_partitions[i+8].p_offset ||
		    lp->d_partitions[i+8].p_size)
d567 1
a567 1
			if (npp->p_offset % secpercyl)
d570 2
a571 2
			    npp->p_offset / secpercyl;
			sl->sl_xpart[i].sdkp_nsectors = npp->p_size;
@


1.47
log
@KNF, whitespace and comment rectification to make all
bounds_check_with_label() routines as identical as possible without
changing any code. Code nits and adjustments to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.46 2007/05/31 02:57:53 krw Exp $	*/
d189 1
a189 1
	cvtdisklabelv1(lp);
@


1.46
log
@Be consistant and use b_cylinder when saving the cylinder number for
disksort, not b_resid. b_cylinder is defined to be 'b_resid' so no
functional change.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.45 2007/05/31 00:30:08 deraadt Exp $	*/
d285 2
a286 5
bounds_check_with_label(bp, lp, osdep, wlabel)
	struct buf *bp;
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
	int wlabel;
d312 1
a312 1
			/* If exactly at end of disk, return an EOF */
d321 1
a321 1
		/* Or truncate if part of it fits */
@


1.45
log
@extend the sun disklabel format to contain filesystem types.  also,
store the information fsck needs.  this allows us to create raid
partitions, nicely, of course.
ok miod todd krw
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.44 2007/05/29 06:28:15 otto Exp $	*/
d329 1
a329 1
	bp->b_resid = (bp->b_blkno + blockpersec(p->p_offset, lp)) /
@


1.44
log
@Updated disklabel format to support larger disks and partitions. We
free room in struct partition by packing fragment size and
fragments/block more tighlty and use the resulting space to make
offset and size 48 bits.  For the disk part we use spare fields in
struct disklabel.  Kernel converts in-mem copy of the on-disk
label if needed, disklabel(8) writes new version.
We are careful to only change fields not used by bootloaders.
Conception of basic scheme by deraadt.
ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.43 2007/05/29 05:08:20 krw Exp $	*/
d427 1
d469 1
a469 1
	if (sl->sl_xpmag == SL_XPMAG &&
d491 7
d565 1
a565 1
		sl->sl_xpmag = SL_XPMAG;
d574 6
@


1.43
log
@Refactor readdisklabel() to ensure there is a single point of return, in
preparation for translating all disk labels visible to the kernel to
the soon to arrive V1 format.

ok otto@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.42 2006/10/21 16:01:54 krw Exp $	*/
d189 1
d452 2
a453 2
				npp->p_fsize = 2048;
				npp->p_frag = 8;
d485 2
a486 2
				npp->p_fsize = 2048;
				npp->p_frag = 8;
@


1.42
log
@Some KNF cleanup.

De-register. Move declaration to top of function for DOS MBR
processing. Indent nit in macppc.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.41 2006/08/17 10:34:14 krw Exp $	*/
d81 1
a81 1
	struct buf *bp;
d84 1
d92 4
a95 2
	if (lp->d_secpercyl == 0)
		return ("invalid geometry");
d109 1
a109 1
		return (NULL);
d128 4
a131 4
	bp->b_flags = B_INVAL | B_AGE | B_READ;
	brelse(bp);
	if (error)
		return ("disk label read error");
d136 4
a139 2
		if (iso_disklabelspoof(dev, strat, lp) == 0)
			return (NULL);
d142 4
a145 2
		if (udf_disklabelspoof(dev, strat, lp) == 0)
			return (NULL);
d152 4
a155 2
	if (slp->sl_magic == SUN_DKMAGIC)
		return (disklabel_sun_to_bsd(clp->cd_block, lp));
d160 4
a163 2
		if (dkcksum(dlp))
			return ("disk label corrupted");
d165 2
a166 1
		return (NULL);
d170 4
a173 2
	if (iso_disklabelspoof(dev, strat, lp) == 0)
		return (NULL);
d176 4
a179 2
	if (udf_disklabelspoof(dev, strat, lp) == 0)
		return (NULL);
d182 8
a189 1
	return ("no disk label");
@


1.41
log
@Check d_secpercyl in all readdisklable() functions, and have all of
them return 'invalid geometry' when d_secpercyl == 0. While there move
the check to a consistant location (after the check of d_secperunit)
and use a consistant idiom (i.e. some readdisklabel()'s have no 'done'
label).

prodded by thib@@ after a bad macppc experience. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.40 2006/08/11 21:32:40 krw Exp $	*/
d175 1
a175 1
	register struct disklabel *olp, *nlp;
d179 2
a180 2
	register int i;
	register struct partition *opp, *npp;
d220 1
a220 1
	register struct disklabel *lp;
d571 1
a571 1
	register struct dkbad *bt;
d574 2
a575 2
	register int i;
	register long blk, bblk;
@


1.40
log
@Use d_secperunit rather than 0x1fffffff as the default value for
RAW_PART's p_size. Since d_secperunit is initialized to 0x1fffffff if
not specified there should be no need to use the magic number again.
And if d_secperunit was specified then that value should be used
instead of the magic number.

This was already being done for hp300, luna88k, mac68k, mvme68k,
mvme88k.

Should be a no-op.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.39 2006/03/15 20:20:41 miod Exp $	*/
d91 2
@


1.39
log
@Nuke dk_establish(), no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.38 2006/03/15 20:07:28 miod Exp $	*/
d97 1
a97 1
		lp->d_partitions[i].p_size = 0x1fffffff;
@


1.38
log
@Switch sparc to device_register() to find out its boot device (when it's a
disk).
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.37 2006/01/27 23:03:12 miod Exp $	*/
a54 9

extern struct device *bootdv;

void
dk_establish(dk, dev)
	struct disk *dk;
	struct device *dev;
{
}
@


1.37
log
@Oops, removed too many includes in 1.34 by mistake; spotted matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.36 2006/01/22 00:40:02 miod Exp $	*/
a38 3
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

a57 8
/*
 * find the boot device (if it was a disk).   we must check to see if
 * unit info in saved bootpath structure matches unit info in our softc.
 * note that knowing the device name (e.g. "xd0") is not useful... we
 * must check the drive number (or target/lun, in the case of SCSI).
 * (XXX is it worth ifdef'ing this?)
 */

a62 43
	struct bootpath *bp = bootpath_store(0, NULL); /* restore bootpath! */
	struct scsibus_softc *sbsc;
	int target, lun;

	if (bp == NULL)
		return;

	/*
	 * scsi: sd,cd
	 */
	if (strncmp("sd", dev->dv_xname, 2) == 0 ||
	    strncmp("cd", dev->dv_xname, 2) == 0) {

		sbsc = (struct scsibus_softc *)dev->dv_parent;

		target = bp->val[0];
		lun = bp->val[1];

#if defined(SUN4)
		if (CPU_ISSUN4 && dev->dv_xname[0] == 's' &&
		    target == 0 && sbsc->sc_link[0][0] == NULL) {
			/*
			 * disk unit 0 is magic: if there is actually no
			 * target 0 scsi device, the PROM will call
			 * target 3 `sd0'.
			 * XXX - what if someone puts a tape at target 0?
			 */
			target = 3;	/* remap to 3 */
			lun = 0;
		}
#endif

#if defined(SUN4C)
		if (CPU_ISSUN4C && dev->dv_xname[0] == 's')
			target = sd_crazymap(target);
#endif

		if (sbsc->sc_link[target][lun] != NULL &&
		    sbsc->sc_link[target][lun]->device_softc == (void *)dev) {
			bp->dev = dev;	/* got it! */
			return;
		}
	}
@


1.36
log
@b_cylin -> b_cylinder; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.35 2006/01/20 23:27:25 miod Exp $	*/
d38 3
@


1.35
log
@b_un.b_addr -> b_data; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.34 2006/01/20 00:20:38 miod Exp $	*/
a55 2
#define b_cylin		b_resid

d172 1
a172 1
	bp->b_cylin = 0;
d303 1
a303 1
	bp->b_cylin = 0;
@


1.34
log
@Use <dev/sun/disklabel.h> instead of similar <machine/sun_disklabel.h> on
sparc and remove unused sun_dkioctl(). No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.33 2005/12/22 02:51:25 krw Exp $	*/
d183 1
a183 1
		bcopy(bp->b_un.b_addr, clp->cd_block, sizeof(clp->cd_block));
d300 1
a300 1
	bcopy(clp->cd_block, bp->b_un.b_addr, sizeof(clp->cd_block));
@


1.33
log
@Set correct partition offset to 0 when initializing RAW_PART.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.32 2005/04/19 21:30:20 miod Exp $	*/
a38 3
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

d41 1
a41 1
#include <machine/sun_disklabel.h>
a45 1
#include <sparc/dev/sbusvar.h>
a620 46
	return (0);
}

/* move this to compat/sunos */
int
sun_dkioctl(dk, cmd, data, partition)
	struct disk *dk;
	u_long cmd;
	caddr_t data;
	int partition;
{
	register struct partition *p;

	switch (cmd) {
	case DKIOCGGEOM:
#define geom	((struct sun_dkgeom *)data)
		bzero(data, sizeof(*geom));
		geom->sdkc_ncylinders = dk->dk_label->d_ncylinders;
		geom->sdkc_acylinders = dk->dk_label->d_acylinders;
		geom->sdkc_ntracks = dk->dk_label->d_ntracks;
		geom->sdkc_nsectors = dk->dk_label->d_nsectors;
		geom->sdkc_interleave = dk->dk_label->d_interleave;
		geom->sdkc_sparespercyl = dk->dk_label->d_sparespercyl;
		geom->sdkc_rpm = dk->dk_label->d_rpm;
		geom->sdkc_pcylinders =
			dk->dk_label->d_ncylinders + dk->dk_label->d_acylinders;
#undef geom
		break;
	case DKIOCINFO:
		/* Homey don't do DKIOCINFO */
		bzero(data, sizeof(struct sun_dkctlr));
		break;
	case DKIOCGPART:
		if (dk->dk_label->d_secpercyl == 0)
			return (ERANGE);	/* XXX */
		p = &dk->dk_label->d_partitions[partition];
		if (p->p_offset % dk->dk_label->d_secpercyl != 0)
			return (ERANGE);	/* XXX */
#define part	((struct sun_dkpart *)data)
		part->sdkp_cyloffset = p->p_offset / dk->dk_label->d_secpercyl;
		part->sdkp_nsectors = p->p_size;
#undef part
		break;
	default:
		return (-1);
	}
@


1.32
log
@As a late birthday present, a preliminary port to the Solbourne IDT systems
(S3000, S4000 and S4000DX).

Currently limited to diskless and serial console, and userland has issues.
Things will get better in the near future.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.31 2005/03/30 07:52:32 deraadt Exp $	*/
d164 1
a164 1
	lp->d_partitions[0].p_offset = 0;
@


1.31
log
@first approximation:  spoof UDF filesystem disklabels when we see them.
it is likely a slight bug or two will sneak in with this, so everyone
please keep an eye out on your disklabels
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.30 2004/03/17 14:16:04 miod Exp $	*/
d95 1
d107 1
d109 1
d112 1
@


1.30
log
@Make sure disklabels use at least DEV_BSIZE as their sector size.
This allows the kernel to survive reading the disklabel off a 256-bytes/sector
scsi device...

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.29 2003/07/16 18:06:34 tedu Exp $	*/
d190 9
a198 4
#if defined(CD9660) && (NCD > 0)
	if ((strat == cdstrategy) &&
	    (iso_disklabelspoof(dev, strat, lp) == NULL))
		return (NULL);
d200 2
d219 4
@


1.29
log
@sun disklabels need updating too.  frag size -> 2048.
pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.28 2003/06/02 18:47:58 deraadt Exp $	*/
d149 2
@


1.28
log
@remove terms 3 (and 4 in some places) where i am the author
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.27 2002/03/14 01:26:44 millert Exp $	*/
d475 1
a475 1
				npp->p_fsize = 1024;
d508 1
a508 1
				npp->p_fsize = 1024;
@


1.27
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.26 2001/10/15 04:03:45 jason Exp $	*/
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Theo de Raadt.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
@


1.26
log
@Make the test for iso9660 filesystems preferred if the device is a CD,
and use old behavior otherwise (check for sun label, then native label,
then iso label).
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.25 2001/06/26 22:31:47 miod Exp $	*/
d61 3
a63 3
static	char *disklabel_sun_to_bsd __P((char *, struct disklabel *));
static	int disklabel_bsd_to_sun __P((struct disklabel *, char *));
static __inline u_long sun_extended_sum __P((struct sun_disklabel *));
d125 1
a125 1
extern void cdstrategy __P((struct buf *));
d143 1
a143 1
	void (*strat) __P((struct buf *));
d271 1
a271 1
	void (*strat) __P((struct buf *));
@


1.26.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.26 2001/10/15 04:03:45 jason Exp $	*/
d61 3
a63 3
static	char *disklabel_sun_to_bsd(char *, struct disklabel *);
static	int disklabel_bsd_to_sun(struct disklabel *, char *);
static __inline u_long sun_extended_sum(struct sun_disklabel *);
d125 1
a125 1
extern void cdstrategy(struct buf *);
d143 1
a143 1
	void (*strat)(struct buf *);
d271 1
a271 1
	void (*strat)(struct buf *);
@


1.25
log
@126 -> NBT_BAD
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.24 2000/10/18 21:00:40 mickey Exp $	*/
d55 1
d123 5
d192 6
@


1.24
log
@typo in comment; from gluk@@ptci.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.23 1999/01/08 04:29:10 millert Exp $	*/
d664 1
a664 1
	for (i = 0; i < 126; i++) {
@


1.23
log
@check for lp->d_secpercyl == 0) in bounds_check_with_label()
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.22 1999/01/05 04:29:03 millert Exp $	*/
d124 1
a124 1
 * using the indicated stategy routine.
@


1.23.6.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.24 2000/10/18 21:00:40 mickey Exp $	*/
d124 1
a124 1
 * using the indicated strategy routine.
@


1.23.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.23.6.1 2001/05/14 21:37:15 niklas Exp $	*/
d664 1
a664 1
	for (i = 0; i < NBT_BAD; i++) {
@


1.23.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.23.6.2 2001/07/04 10:23:39 niklas Exp $	*/
a54 1
#include "cd.h"
a121 5
#if NCD > 0
/* XXX for comparison below. */
extern void cdstrategy __P((struct buf *));
#endif

a185 6

#if defined(CD9660) && (NCD > 0)
	if ((strat == cdstrategy) &&
	    (iso_disklabelspoof(dev, strat, lp) == NULL))
		return (NULL);
#endif
@


1.23.6.4
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d61 3
a63 3
static	char *disklabel_sun_to_bsd(char *, struct disklabel *);
static	int disklabel_bsd_to_sun(struct disklabel *, char *);
static __inline u_long sun_extended_sum(struct sun_disklabel *);
d125 1
a125 1
extern void cdstrategy(struct buf *);
d143 1
a143 1
	void (*strat)(struct buf *);
d271 1
a271 1
	void (*strat)(struct buf *);
@


1.23.6.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.23.6.4 2002/03/28 10:57:10 niklas Exp $	*/
d17 5
@


1.23.6.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d475 1
a475 1
				npp->p_fsize = 2048;
d508 1
a508 1
				npp->p_fsize = 2048;
@


1.23.6.7
log
@Merge with the trunk
@
text
@a148 2
	if (lp->d_secsize < DEV_BSIZE)
		lp->d_secsize = DEV_BSIZE;
@


1.22
log
@be extra careful to not divide by zero; more arches to come
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.21 1998/10/03 21:18:56 millert Exp $	*/
d311 6
a323 6
		goto bad;
	}

	/* avoid division by zero */
	if (lp->d_secpercyl == 0) {
		bp->b_error = EINVAL;
@


1.21
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.20 1998/05/02 03:57:51 millert Exp $	*/
d321 6
d530 2
a531 1
	if (lp->d_secsize != 512)
@


1.20
log
@type
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.19 1998/03/01 10:17:54 johns Exp $	*/
d135 1
a135 1
readdisklabel(dev, strat, lp, clp)
d140 1
d160 4
@


1.19
log
@Fixes for gcc 2.8
Added explicit type of integer to register variable i..
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.18 1997/10/01 22:54:20 deraadt Exp $	*/
d146 1
a146 1
	/* minimal requirements for archtypal disk label */
@


1.18
log
@make rawpart FS_UNUSED
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.17 1997/08/08 21:46:52 niklas Exp $	*/
d214 1
a214 1
	register i;
@


1.17
log
@Change the bounds_check_with_label API to also take a cpu_disklabel
reference for making transferral of meta-information possible from
readdisklabel to bounds_check_with_label.  The first (and maybe only)
thing that will use this is the multi-disklabel-format code on the
alpha where the labelsector is passed via cpu_disklabel so the label
write-protection can work correctly no matter what label was found.

Also use a new macro DKBAD to get at the dkbad field of the cpu_disklabel
implementations that contain it.  This too is for multi-disklabel
architectures where the "bad" field can be inside a union.  Use this
macro as a means for a driver to check if an architecture supports
dkbad constructs.

Remove proto of bounds_check_with_label from all MD disklabel.h as it
is in sys/disklabel.h.

I have not been able to test the changes everywhere, if I break anything
I apologize, and promise to fix it as soon as I become aware of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.16 1997/06/25 14:43:27 downsj Exp $	*/
d354 1
a354 1
	FS_OTHER,	/* c - whole disk */
@


1.16
log
@Add proto.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.15 1997/05/28 21:38:34 deraadt Exp $	*/
d296 1
a296 1
bounds_check_with_label(bp, lp, wlabel)
d299 1
@


1.15
log
@cd9660 spoof elsewhere
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.13 1997/04/06 06:09:25 deraadt Exp $	*/
d62 1
@


1.14
log
@check for iso9660 disklabel FIRST. This will be an experiment of sorts
@
text
@a158 4
#if defined(CD9660)
	if (iso_disklabelspoof(dev, strat, lp) == 0)
		return (NULL);
#endif
d195 4
@


1.13
log
@correct blocksize confusion
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.12 1997/04/02 18:28:09 deraadt Exp $	*/
d159 4
a198 4
#if defined(CD9660)
	if (iso_disklabelspoof(dev, strat, lp) == 0)
		return (NULL);
#endif
@


1.12
log
@warn about MAXPARTITIONS != 16, grr@@shandakor.tharsis.com
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.11 1997/01/02 06:28:43 deraadt Exp $	*/
d300 3
a302 5
#define dkpart(dev) DISKPART(dev)

	struct partition *p = lp->d_partitions + dkpart(bp->b_dev);
	int maxsz = p->p_size;
	int sz = (bp->b_bcount + DEV_BSIZE - 1) >> DEV_BSHIFT;
d308 1
a308 1
	if ((bp->b_blkno + p->p_offset <= LABELSECTOR) &&
d315 4
a318 3
	if (bp->b_blkno < 0 || bp->b_blkno + sz > maxsz) {
		/* if exactly at end of disk, return an EOF */
		if (bp->b_blkno == maxsz) {
d320 1
a320 1
			return(0);
d322 2
a323 3
		/* or truncate if part of it fits */
		sz = maxsz - bp->b_blkno;
		if (sz <= 0) {
d327 1
d332 3
a334 2
	bp->b_resid = (bp->b_blkno + p->p_offset) / lp->d_secpercyl;
	return(1);
d337 1
a337 1
	return(-1);
@


1.11
log
@do not confuse readdisklabel callers
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.10 1996/12/11 13:36:12 deraadt Exp $	*/
d56 4
d300 1
a300 1
#define dkpart(dev) (minor(dev) & (MAXPARTITIONS-1))
@


1.10
log
@SUNXPART always; also one case of MAXPARTITIONS not being there
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.9 1996/12/07 12:20:40 deraadt Exp $	*/
d139 1
a139 1
	int error;
d144 7
a150 3
	lp->d_npartitions = 1;
	if (lp->d_partitions[0].p_size == 0)
		lp->d_partitions[0].p_size = 0x1fffffff;
d152 2
@


1.9
log
@fake the isofs label only if other probes fail
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.8 1996/12/06 00:12:21 deraadt Exp $	*/
d176 1
a176 1
	/* Check for a NetBSD disk label (PROM can not boot it). */
d180 1
a180 1
			return ("NetBSD disk label corrupted");
d254 1
a254 1
#if 0	/* XXX - Allow writing NetBSD disk labels? */
d290 1
a290 1
#define dkpart(dev) (minor(dev) & 7)
a451 2
#if SUNXPART > 0

d461 20
a480 23
	if (sl->sl_xpmag == SL_XPMAG) {	/* probably... */
		if (sun_extended_sum(sl) == sl->sl_xpsum) {	/* ...yes! */
			/*
			 * There is.  Copy over the "extended" partitions.
			 * This code parallels the loop for partitions a-h.
			 *
			 * XXX Abstract the common code?
			 */
			for (i = 0; i < SUNXPART; i++) {
				spp = &sl->sl_xpart[i];
				npp = &lp->d_partitions[i+8];
				npp->p_offset = spp->sdkp_cyloffset * secpercyl;
				npp->p_size = spp->sdkp_nsectors;
				if (npp->p_size == 0) {
					npp->p_fstype = FS_UNUSED;
				} else {
					npp->p_fstype = sun_fstypes[i+8];
					if (npp->p_fstype == FS_BSDFFS) {
						npp->p_fsize = 1024;
						npp->p_frag = 8;
						npp->p_cpg = 16;
					}
				}
a483 1
#endif	/* if SUNXPART > 0 */
a534 1
#if SUNXPART > 0
d536 1
a536 1
	 * The reason we load the extended table stuff only conditionally
a541 2

	/* Do we need to load the extended table? */
d547 2
a548 1
	if (i < SUNXPART) { /* we do */
d554 3
a556 2
				return(EINVAL);
			sl->sl_xpart[i].sdkp_cyloffset = npp->p_offset / secpercyl;
a567 1
#endif	/* if SUNXPART > 0 */
@


1.8
log
@duh
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.7 1996/12/05 13:22:10 deraadt Exp $	*/
a148 5
#if defined(CD9660)
	if (iso_disklabelspoof(dev, strat, lp) == 0)
		return (NULL);
#endif

d185 4
@


1.7
log
@call iso_disklabelspoof() if neccessary
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.6 1996/09/12 04:33:29 downsj Exp $	*/
d151 1
a151 1
		return (msg);
@


1.6
log
@Add 16 partition support to the SPARC.  From NetBSD PR#2675, by der Mouse,
<mouse@@Collatz.McRCIM.McGill.EDU>.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d148 5
@


1.5
log
@netbsd port, now we merge our changes back in
@
text
@d1 1
a288 1
	int labelsect = lp->d_partitions[0].p_offset;
d294 4
a297 2
	if (bp->b_blkno + p->p_offset <= LABELSECTOR + labelsect &&
	    (bp->b_flags & B_READ) == 0 && wlabel == 0) {
d335 1
a335 1
sun_fstypes[8] = {
d344 8
d355 21
d422 1
a422 1
	lp->d_npartitions = 8;
d448 39
d536 36
@


1.4
log
@from netbsd;
New generic disk framework.  Highlights:
New metrics handling.  Metrics are now kept in the new `struct disk'.
Busy time is now stored as a timeval, and transfer count in bytes.
Storage for disklabels is now dynamically allocated, so that the size
of the disk structure is not machine-dependent.
Several new functions for attaching and detaching disks, and handling
metrics calculation.
Old-style instrumentation is still supported in drivers that did it
before.  However, old-style instrumentation is being deprecated, and
will go away once the userland utilities are updated for the new
framework.
For usage and architectural details, see the forthcoming disk(9)
manual page.
@
text
@d1 1
a1 1
/*	$NetBSD: disksubr.c,v 1.11 1996/01/07 22:03:12 thorpej Exp $ */
d35 1
d62 1
a62 1
/* 
d70 1
a70 1
int
a75 1
	char name[10];
d77 1
a77 1
	int targ, lun;
d80 1
a80 1
		return -1;
d85 1
a85 1
	if (strncmp("sd", dev->dv_xname, 2) == 0 || 
d87 1
a88 1
		targ = lun = 0;
d90 13
a102 25
#if defined(SUN4)
		if (cputyp == CPU_SUN4) {
			if (dev->dv_xname[0] == 's' && bp->val[0] == 0) { 
				/* disk unit 0 is magic */
				if (sbsc->sc_link[0][0] == NULL) {
					targ = 3; /* remap to 3 */
					lun = 0;
				}
			} else {
				extern struct om_vector *oldpvec;
				if (oldpvec->monId[0] > '1') {
					targ = bp->val[0] >> 3; /* new format */
					lun = bp->val[0] & 0x7;
				} else {
					targ = bp->val[0] >> 2; /* old format */
					lun = bp->val[0] & 0x3;
				}
			}
		} else
#endif
		{
			lun = bp->val[1];
			targ = (dev->dv_xname[0] == 's')
				? sd_crazymap(bp->val[0])
				: bp->val[0];
d105 7
a111 4
		if (sbsc->sc_link[targ][lun] != NULL &&
		    sbsc->sc_link[targ][lun]->device_softc == (void *)dev) {
			bootdv = dev; /* got it! */
			return 1;
a113 2

	return -1;
d116 1
a116 1
/* 
d119 1
a119 1
 * The label must be partly set up before this: 
d130 2
a131 2
	dev_t dev; 
	void (*strat)();
d157 1
a157 1
	(*strat)(bp); 
d207 1
a207 1
	if (nlp->d_magic == 0xffffffff) { 
d213 1
a213 1
		dkcksum(nlp) != 0)
d225 1
a225 1
		}
d227 2
a228 2
	*olp = *nlp;    
	return (0);     
d235 1
d238 1
a238 1
	void (*strat)();
d274 1
a274 1
/* 
d293 1
a293 1
	/* XXX should also protect bootstrap in first 8K */ 
d300 1
a300 1
	/* beyond partition? */ 
d314 1
a314 1
	}               
d480 1
a480 1
sunos_dkioctl(dk, cmd, data, partition)
d489 1
a489 1
	case SUNOS_DKIOCGGEOM:
d503 1
a503 1
	case SUNOS_DKIOCINFO:
d507 1
a507 1
	case SUNOS_DKIOCGPART:
d532 1
@


1.3
log
@from gwr, changes in sun3 port
@
text
@d1 1
a1 1
/*	$NetBSD: disksubr.c,v 1.9 1995/09/01 17:19:50 pk Exp $ */
d71 1
a71 1
	struct dkdevice *dk;
d490 2
a491 2
sun_dkioctl(dk, cmd, data, partition)
	struct dkdevice *dk;
d502 7
a508 7
		geom->sdkc_ncylinders = dk->dk_label.d_ncylinders;
		geom->sdkc_acylinders = dk->dk_label.d_acylinders;
		geom->sdkc_ntracks = dk->dk_label.d_ntracks;
		geom->sdkc_nsectors = dk->dk_label.d_nsectors;
		geom->sdkc_interleave = dk->dk_label.d_interleave;
		geom->sdkc_sparespercyl = dk->dk_label.d_sparespercyl;
		geom->sdkc_rpm = dk->dk_label.d_rpm;
d510 1
a510 1
			dk->dk_label.d_ncylinders + dk->dk_label.d_acylinders;
d518 1
a518 1
		if (dk->dk_label.d_secpercyl == 0)
d520 2
a521 2
		p = &dk->dk_label.d_partitions[partition];
		if (p->p_offset % dk->dk_label.d_secpercyl != 0)
d524 1
a524 1
		part->sdkp_cyloffset = p->p_offset / dk->dk_label.d_secpercyl;
@


1.2
log
@SUNOS_* ioctl done as such
@
text
@a235 9
		/*
		* Copy internally-set partition information
		* if new label doesn't include it.             XXX
		*/
		if (npp->p_fstype == FS_UNUSED && opp->p_fstype != FS_UNUSED) {
			npp->p_fstype = opp->p_fstype;
			npp->p_fsize = opp->p_fsize;
			npp->p_frag = opp->p_frag;
			npp->p_cpg = opp->p_cpg;
d237 1
a237 3
	}
	nlp->d_checksum = 0;
	nlp->d_checksum = dkcksum(nlp);
d383 2
a384 1
	lp->d_magic = 0;/* denote as pseudo */
d411 3
a413 1
		if (npp->p_size)
d415 10
d427 2
d448 3
@


1.1
log
@Initial revision
@
text
@d492 1
a492 1
	case DKIOCGGEOM:
d506 1
a506 1
	case DKIOCINFO:
d510 1
a510 1
	case DKIOCGPART:
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

