head	1.14;
access;
symbols
	OPENBSD_6_0:1.13.0.12
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.8
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.10
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.6
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.30
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.28
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.26
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.24
	OPENBSD_5_0:1.12.0.22
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.20
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.18
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.14
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.16
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.12
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.10
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.8
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.6
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.11.0.12
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.10
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.10
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.8
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.6
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.10
	UBC:1.10.0.4
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.16
	OPENBSD_2_8:1.9.0.14
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.12
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.10
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.8
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.6
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2016.09.01.09.23.42;	author tedu;	state dead;
branches;
next	1.13;
commitid	Q2PxaFNhqAe0Wmla;

1.13
date	2013.11.26.20.33.14;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.14.21.58.05;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.27.54;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.10.16.34.49;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	98.03.01.09.05.29;	author johns;	state Exp;
branches
	1.9.10.1;
next	1.8;

1.8
date	98.01.13.22.54.36;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	97.08.08.08.25.46;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.02.04.23.42.46;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.02.04.02.38.55;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.02.01.23.05.05;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.01.27.22.48.21;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.08.11.05.34.39;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.41;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.41;	author deraadt;	state Exp;
branches;
next	;

1.9.10.1
date	2001.10.31.03.07.57;	author nate;	state Exp;
branches;
next	1.9.10.2;

1.9.10.2
date	2003.06.07.11.14.43;	author ho;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: fpu.c,v 1.13 2013/11/26 20:33:14 deraadt Exp $	*/
/*	$NetBSD: fpu.c,v 1.6 1997/07/29 10:09:51 fair Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)fpu.c	8.1 (Berkeley) 6/11/93
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/signal.h>
#include <sys/systm.h>
#include <sys/syslog.h>
#include <sys/signalvar.h>

#include <machine/instr.h>
#include <machine/reg.h>

#include <sparc/fpu/fpu_emu.h>
#include <sparc/fpu/fpu_extern.h>

/*
 * fpu_execute returns the following error numbers (0 = no error):
 */
#define	FPE		1	/* take a floating point exception */
#define	NOTFPU		2	/* not an FPU instruction */

/*
 * Translate current exceptions into `first' exception.  The
 * bits go the wrong way for ffs() (0x10 is most important, etc).
 * There are only 5, so do it the obvious way.
 */
#define	X1(x) x
#define	X2(x) x,x
#define	X4(x) x,x,x,x
#define	X8(x) X4(x),X4(x)
#define	X16(x) X8(x),X8(x)

static char cx_to_trapx[] = {
	X1(FSR_NX),
	X2(FSR_DZ),
	X4(FSR_UF),
	X8(FSR_OF),
	X16(FSR_NV)
};
static u_char fpu_codes[] = {
	X1(FPE_FLTINEX_TRAP),
	X2(FPE_FLTDIV_TRAP),
	X4(FPE_FLTUND_TRAP),
	X8(FPE_FLTOVF_TRAP),
	X16(FPE_FLTOPERR_TRAP)
};

static int fpu_types[] = {
	X1(FPE_FLTRES),
	X2(FPE_FLTDIV),
	X4(FPE_FLTUND),
	X8(FPE_FLTOVF),
	X16(FPE_FLTINV)
};

/*
 * The FPU gave us an exception.  Clean up the mess.  Note that the
 * fp queue can only have FPops in it, never load/store FP registers
 * nor FBfcc instructions.  Experiments with `crashme' prove that
 * unknown FPops do enter the queue, however.
 */
void
fpu_cleanup(p, fs)
	register struct proc *p;
	register struct fpstate *fs;
{
	register int i, fsr = fs->fs_fsr, error;
	union instr instr;
	union sigval sv;
	struct fpemu fe;

	sv.sival_int = p->p_md.md_tf->tf_pc;  /* XXX only approximate */

	switch ((fsr >> FSR_FTT_SHIFT) & FSR_FTT_MASK) {

	case FSR_TT_NONE:
#if 0
		/* XXX I'm not sure how we get here, but ignoring the trap */
		/* XXX seems to work in my limited tests		   */
		/* XXX More research to be done =)			   */
		panic("fpu_cleanup 1"); /* ??? */
#else
		printf("fpu_cleanup 1\n");
#endif
		break;

	case FSR_TT_IEEE:
		if ((i = fsr & FSR_CX) == 0)
			panic("fpu ieee trap, but no exception");
		trapsignal(p, SIGFPE, fpu_codes[i - 1], fpu_types[i - 1], sv);
		break;		/* XXX should return, but queue remains */

	case FSR_TT_UNFIN:
	case FSR_TT_UNIMP:
		if (fs->fs_qsize == 0)
			panic("fpu_cleanup 2");
		break;

	case FSR_TT_SEQ:
		panic("fpu sequence error");
		/* NOTREACHED */

	case FSR_TT_HWERR:
		log(LOG_ERR, "fpu hardware error (%s[%d])\n",
		    p->p_comm, p->p_pid);
		uprintf("%s[%d]: fpu hardware error\n", p->p_comm, p->p_pid);
		trapsignal(p, SIGFPE, -1, FPE_FLTINV, sv);	/* ??? */
		goto out;

	default:
		printf("fsr=0x%x\n", fsr);
		panic("fpu error");
	}

	/* emulate the instructions left in the queue */
	fe.fe_fpstate = fs;
	for (i = 0; i < fs->fs_qsize; i++) {
		instr.i_int = fs->fs_queue[i].fq_instr;
		if (instr.i_any.i_op != IOP_reg ||
		    (instr.i_op3.i_op3 != IOP3_FPop1 &&
		     instr.i_op3.i_op3 != IOP3_FPop2))
			panic("bogus fpu queue");
		error = fpu_execute(&fe, instr);
		switch (error) {

		case 0:
			continue;

		case FPE:
			trapsignal(p, SIGFPE,
			    fpu_codes[(fs->fs_fsr & FSR_CX) - 1],
			    fpu_types[(fs->fs_fsr & FSR_CX) - 1], sv);
			break;

		case NOTFPU:
			trapsignal(p, SIGILL, 0, ILL_COPROC, sv);
			break;

		default:
			panic("fpu_cleanup 3");
			/* NOTREACHED */
		}
		/* XXX should stop here, but queue remains */
	}
out:
	fs->fs_qsize = 0;
}

#ifdef notyet
/*
 * If we have no FPU at all (are there any machines like this out
 * there!?) we have to emulate each instruction, and we need a pointer
 * to the trapframe so that we can step over them and do FBfcc's.
 * We know the `queue' is empty, though; we just want to emulate
 * the instruction at tf->tf_pc.
 */
fpu_emulate(p, tf, fs)
	struct proc *p;
	register struct trapframe *tf;
	register struct fpstate *fs;
{

	do {
		fetch instr from pc
		decode
		if (integer instr) {
			/*
			 * We do this here, rather than earlier, to avoid
			 * losing even more badly than usual.
			 */
			if (p->p_addr->u_pcb.pcb_uw) {
				write_user_windows();
				if (rwindow_save(p))
					sigexit(p, SIGILL);
			}
			if (loadstore) {
				do_it;
				pc = npc, npc += 4
			} else if (fbfcc) {
				do_annul_stuff;
			} else
				return;
		} else if (fpu instr) {
			fe.fe_fsr = fs->fs_fsr &= ~FSR_CX;
			error = fpu_execute(&fe, fs, instr);
			switch (error) {
				etc;
			}
		} else
			return;
		if (want to reschedule)
			return;
	} while (error == 0);
}
#endif

/*
 * Execute an FPU instruction (one that runs entirely in the FPU; not
 * FBfcc or STF, for instance).  On return, fe->fe_fs->fs_fsr will be
 * modified to reflect the setting the hardware would have left.
 *
 * Note that we do not catch all illegal opcodes, so you can, for instance,
 * multiply two integers this way.
 */
int
fpu_execute(fe, instr)
	register struct fpemu *fe;
	union instr instr;
{
	register struct fpn *fp;
	register int opf, rs1, rs2, rd, type, mask, fsr, cx;
	register struct fpstate *fs;
	u_int space[4];

	/*
	 * `Decode' and execute instruction.  Start with no exceptions.
	 * The type of any i_opf opcode is in the bottom two bits, so we
	 * squish them out here.
	 */
	opf = instr.i_opf.i_opf;
	type = opf & 3;
	mask = "\0\0\1\3"[type];
	rs1 = instr.i_opf.i_rs1 & ~mask;
	rs2 = instr.i_opf.i_rs2 & ~mask;
	rd = instr.i_opf.i_rd & ~mask;
#ifdef notdef
	if ((rs1 | rs2 | rd) & mask)
		return (BADREG);
#endif
	fs = fe->fe_fpstate;
	fe->fe_fsr = fs->fs_fsr & ~FSR_CX;
	fe->fe_cx = 0;
	switch (opf >>= 2) {

	default:
		return (NOTFPU);

	case FMOV >> 2:		/* these should all be pretty obvious */
		rs1 = fs->fs_regs[rs2];
		goto mov;

	case FNEG >> 2:
		rs1 = fs->fs_regs[rs2] ^ (1U << 31);
		goto mov;

	case FABS >> 2:
		rs1 = fs->fs_regs[rs2] & ~(1U << 31);
	mov:
		fs->fs_regs[rd] = rs1;
		fs->fs_fsr = fe->fe_fsr;
		return (0);	/* success */

	case FSQRT >> 2:
		fpu_explode(fe, &fe->fe_f1, type, rs2);
		fp = fpu_sqrt(fe);
		break;

	case FADD >> 2:
		fpu_explode(fe, &fe->fe_f1, type, rs1);
		fpu_explode(fe, &fe->fe_f2, type, rs2);
		fp = fpu_add(fe);
		break;

	case FSUB >> 2:
		fpu_explode(fe, &fe->fe_f1, type, rs1);
		fpu_explode(fe, &fe->fe_f2, type, rs2);
		fp = fpu_sub(fe);
		break;

	case FMUL >> 2:
		fpu_explode(fe, &fe->fe_f1, type, rs1);
		fpu_explode(fe, &fe->fe_f2, type, rs2);
		fp = fpu_mul(fe);
		break;

	case FDIV >> 2:
		fpu_explode(fe, &fe->fe_f1, type, rs1);
		fpu_explode(fe, &fe->fe_f2, type, rs2);
		fp = fpu_div(fe);
		break;

	case FCMP >> 2:
		fpu_explode(fe, &fe->fe_f1, type, rs1);
		fpu_explode(fe, &fe->fe_f2, type, rs2);
		fpu_compare(fe, 0);
		goto cmpdone;

	case FCMPE >> 2:
		fpu_explode(fe, &fe->fe_f1, type, rs1);
		fpu_explode(fe, &fe->fe_f2, type, rs2);
		fpu_compare(fe, 1);
	cmpdone:
		/*
		 * The only possible exception here is NV; catch it
		 * early and get out, as there is no result register.
		 */
		cx = fe->fe_cx;
		fsr = fe->fe_fsr | (cx << FSR_CX_SHIFT);
		if (cx != 0) {
			if (fsr & (FSR_NV << FSR_TEM_SHIFT)) {
				fs->fs_fsr = (fsr & ~FSR_FTT) |
				    (FSR_TT_IEEE << FSR_FTT_SHIFT);
				return (FPE);
			}
			fsr |= FSR_NV << FSR_AX_SHIFT;
		}
		fs->fs_fsr = fsr;
		return (0);

	case FSMULD >> 2:
	case FDMULX >> 2:
		if (type == FTYPE_EXT)
			return (NOTFPU);
		fpu_explode(fe, &fe->fe_f1, type, rs1);
		fpu_explode(fe, &fe->fe_f2, type, rs2);
		type++;	/* single to double, or double to quad */
		fp = fpu_mul(fe);
		break;

	case FTOI >> 2:
	case FTOS >> 2:
		rd = instr.i_opf.i_rd;
		goto fto;
	case FTOD >> 2:
		rd = instr.i_opf.i_rd & (~1);
		goto fto;
	case FTOX >> 2:
		rd = instr.i_opf.i_rd & (~3);

fto:
		fpu_explode(fe, fp = &fe->fe_f1, type, rs2);
		type = opf & 3;	/* sneaky; depends on instruction encoding */
		break;
	}

	/*
	 * ALU operation is complete.  Collapse the result and then check
	 * for exceptions.  If we got any, and they are enabled, do not
	 * alter the destination register, just stop with an exception.
	 * Otherwise set new current exceptions and accrue.
	 */
	fpu_implode(fe, fp, type, space);
	cx = fe->fe_cx;
	fsr = fe->fe_fsr;
	if (cx != 0) {
		mask = (fsr >> FSR_TEM_SHIFT) & FSR_TEM_MASK;
		if (cx & mask) {
			/* not accrued??? */
			fs->fs_fsr = (fsr & ~FSR_FTT) |
			    (FSR_TT_IEEE << FSR_FTT_SHIFT) |
			    (cx_to_trapx[(cx & mask) - 1] << FSR_CX_SHIFT);
			return (FPE);
		}
		fsr |= (cx << FSR_CX_SHIFT) | (cx << FSR_AX_SHIFT);
	}
	fs->fs_fsr = fsr;
	fs->fs_regs[rd] = space[0];
	if (type >= FTYPE_DBL) {
		fs->fs_regs[rd + 1] = space[1];
		if (type > FTYPE_DBL) {
			fs->fs_regs[rd + 2] = space[2];
			fs->fs_regs[rd + 3] = space[3];
		}
	}
	return (0);	/* success */
}
@


1.13
log
@1 << 31 cleanup.  Eitan Adler pointed out that there has been a
resurrection of the bad idiom in the tree.
sufficient review by miod, kettenis, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.12 2006/05/14 21:58:05 kettenis Exp $	*/
@


1.12
log
@Make the array of fpu exception types/codes big enough.
Fix a typo too, such that we actually read beyond element 0 in all cases.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.11 2003/06/02 23:27:54 millert Exp $	*/
d284 1
a284 1
		rs1 = fs->fs_regs[rs2] ^ (1 << 31);
d288 1
a288 1
		rs1 = fs->fs_regs[rs2] & ~(1 << 31);
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.10 2001/09/10 16:34:49 jason Exp $	*/
d90 5
a94 5
	FPE_FLTRES,
	FPE_FLTDIV,
	FPE_FLTUND,
	FPE_FLTOVF,
	FPE_FLTINV,
d131 1
a131 1
		trapsignal(p, SIGFPE, fpu_codes[i - 1], fpu_types[i - i], sv);
@


1.10
log
@applying the same mask to rs2 and rd is bad ju-ju for F?TO? instructions. Fix up rd in those cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.9 1998/03/01 09:05:29 johns Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@trapsignal() requires parameter five to be of type "union sigval".
gcc 2.8 will not allow us to pass in a caddr_t, changes based on
Niklas' stuff in i386 trap.c
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.8 1998/01/13 22:54:36 jason Exp $	*/
d365 1
d367 2
d370 2
d373 3
a375 1
	case FTOI >> 2:
@


1.9.10.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.9 1998/03/01 09:05:29 johns Exp $	*/
a364 1
	case FTOI >> 2:
a365 2
		rd = instr.i_opf.i_rd;
		goto fto;
a366 2
		rd = instr.i_opf.i_rd & (~1);
		goto fto;
d368 1
a368 3
		rd = instr.i_opf.i_rd & (~3);

fto:
@


1.9.10.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.9.10.1 2001/10/31 03:07:57 nate Exp $	*/
d25 5
a29 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.8
log
@Workaround for fpu_cleanup panic.  We just ignore it.  I'm going to
look further into really fixing this problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.7 1997/08/08 08:25:46 downsj Exp $	*/
d114 1
a114 1
	caddr_t pc = (caddr_t)p->p_md.md_tf->tf_pc;	/* XXX only approximate */
d117 2
d135 1
a135 1
		trapsignal(p, SIGFPE, fpu_codes[i - 1], fpu_types[i - i], pc);
d152 1
a152 1
		trapsignal(p, SIGFPE, -1, FPE_FLTINV, pc);	/* ??? */
d177 1
a177 1
			    fpu_types[(fs->fs_fsr & FSR_CX) - 1], pc);
d181 1
a181 1
			trapsignal(p, SIGILL, 0, ILL_COPROC, pc);
@


1.7
log
@Mostly sync to NetBSD-current 970804.

GENERIC currently compiles and runs; some devices (isp) are not complete and
not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d120 8
a127 1
		panic("fpu_cleanup 1");	/* ??? */
@


1.6
log
@provide fpe fault addr; thanks for help from torek@@bsdi.com
@
text
@d1 2
a2 1
/*	$NetBSD: fpu.c,v 1.3 1996/03/14 19:41:49 christos Exp $ */
d147 1
a147 1
		printf("fsr=%x\n", fsr);
@


1.5
log
@match SIGILL to ILL_COPROC
@
text
@d113 1
a122 1
		/* XXX missing trap address! */
d125 1
a125 1
		trapsignal(p, SIGFPE, fpu_codes[i - 1], fpu_types[i - i], 0);
d142 1
a142 1
		trapsignal(p, SIGFPE, -1, FPE_FLTINV, 0);	/* ??? */
d167 1
a167 1
			    fpu_types[(fs->fs_fsr & FSR_CX) - 1], 0);
d171 1
a171 1
			trapsignal(p, SIGILL, 0, ILL_COPROC, 0);
@


1.4
log
@trapsignal/sendsig type/sigval changes
@
text
@d171 1
a171 1
			trapsignal(p, SIGILL, 0, FPE_FLTINV, 0);
@


1.3
log
@add another parameter to trapsignal() and sendsig() -- fault addr to be
delivered with in the siginfo information
@
text
@d92 8
d125 1
a125 1
		trapsignal(p, SIGFPE, fpu_codes[i - 1], 0);
d142 1
a142 1
		trapsignal(p, SIGFPE, -1, 0);	/* ??? */
d166 2
a167 1
			    fpu_codes[(fs->fs_fsr & FSR_CX) - 1], 0);
d171 1
a171 1
			trapsignal(p, SIGILL, 0, 0);	/* ??? code?  */
@


1.2
log
@netbsd port, now we merge our changes back in
@
text
@d117 1
a117 1
		trapsignal(p, SIGFPE, fpu_codes[i - 1]);
d134 1
a134 1
		trapsignal(p, SIGFPE, -1);	/* ??? */
d158 1
a158 1
			    fpu_codes[(fs->fs_fsr & FSR_CX) - 1]);
d162 1
a162 1
			trapsignal(p, SIGILL, 0);	/* ??? code?  */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: fpu.c,v 1.2 1994/11/20 20:52:33 deraadt Exp $ */
d52 1
d58 1
d98 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

