head	1.8;
access;
symbols
	OPENBSD_6_0:1.8.0.22
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.18
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.20
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.12
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.16
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.14
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.10
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.8
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.6
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.4
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.6.0.4
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.24
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.26
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.22
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.20
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.18
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.16
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.14
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.12
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.10
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.3
	UBC:1.1.0.22
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.20
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.18
	OPENBSD_2_8:1.1.0.16
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.14
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.12
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.10
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.8
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.6
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.4
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.2
	OPENBSD_2_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2011.04.14.18.27.49;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2011.03.13.00.13.53;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.29.21.33.54;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.14.19.05.36;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.14.17.13.57;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2002.08.11.23.11.22;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.09.17.10.46.16;	author downsj;	state Exp;
branches
	1.1.12.1
	1.1.22.1;
next	;

1.1.12.1
date	2002.03.28.10.57.11;	author niklas;	state Exp;
branches;
next	1.1.12.2;

1.1.12.2
date	2003.03.27.23.49.26;	author niklas;	state Exp;
branches;
next	1.1.12.3;

1.1.12.3
date	2004.02.19.10.49.59;	author niklas;	state Exp;
branches;
next	;

1.1.22.1
date	2002.06.11.03.38.17;	author art;	state Exp;
branches;
next	1.1.22.2;

1.1.22.2
date	2002.10.29.00.28.11;	author art;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Sprinkle prototypes, kill unused locals, and stop contributing to global
warning.
@
text
@/*	$OpenBSD: bootxx.c,v 1.7 2011/03/13 00:13:53 deraadt Exp $	*/
/*	$NetBSD: bootxx.c,v 1.2 1997/09/14 19:28:17 pk Exp $	*/

/*
 * Copyright (c) 1994 Paul Kranenburg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Paul Kranenburg.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/time.h>
#include <a.out.h>

#include <lib/libsa/stand.h>

#include <sparc/stand/common/promdev.h>

int debug;
int netif_debug;

/*
 * Boot device is derived from ROM provided information.
 */
char		progname[] = "bootxx";
struct open_file	io;

/*
 * The contents of the block_* variables below is set by installboot(8)
 * to hold the filesystem data of the second-stage boot program
 * (typically `/boot'): filesystem block size, # of filesystem blocks and
 * the block numbers themselves.
 */
#define MAXBLOCKNUM	256	/* enough for a 2MB boot program (bs 8K) */
int32_t			block_size = 0;
int32_t			block_count = MAXBLOCKNUM;
daddr32_t		block_table[MAXBLOCKNUM] = { 0 };


void	loadboot(struct open_file *, caddr_t);

int
main(int argc, char *argv[])
{
	char	*dummy;
	register void (*entry)(caddr_t) = (void (*)(caddr_t))PROM_LOADADDR;

	prom_init();
	io.f_flags = F_RAW;
	if (devopen(&io, 0, &dummy)) {
		panic("%s: can't open device", progname);
	}

	(void)loadboot(&io, (caddr_t)PROM_LOADADDR);
	(io.f_dev->dv_close)(&io);
	(*entry)(cputyp == CPU_SUN4 ? (caddr_t)PROM_LOADADDR : (caddr_t)promvec);
	_rtt();
}

void
loadboot(f, addr)
	register struct open_file	*f;
	register char			*addr;
{
	register int	i;
	register char	*buf;
	size_t		n;
	daddr32_t	blk;

	/*
	 * Allocate a buffer that we can map into DVMA space; only
	 * needed for sun4 architecture, but use it for all machines
	 * to keep code size down as much as possible.
	 */
	buf = alloc(block_size);
	if (buf == NULL)
		panic("%s: alloc failed", progname);

	for (i = 0; i < block_count; i++) {
		if ((blk = block_table[i]) == 0)
			panic("%s: block table corrupt", progname);

#ifdef DEBUG
		printf("%s: block # %d = %d\n", progname, i, blk);
#endif
		if ((f->f_dev->dv_strategy)(f->f_devdata, F_READ,
					    blk, block_size, buf, &n)) {
			panic("%s: read failure", progname);
		}
		bcopy(buf, addr, block_size);
		if (n != block_size)
			panic("%s: short read", progname);
		if (i == 0) {
			register int m = N_GETMAGIC(*(struct exec *)addr);
			if (m == ZMAGIC || m == NMAGIC || m == OMAGIC) {
				/* Move exec header out of the way */
				bcopy(addr, addr - sizeof(struct exec), n);
				addr -= sizeof(struct exec);
			}
		}
		addr += n;
	}

}
@


1.7
log
@Change daddr_t to daddr32_t.  The bootblocks on our architectures only
do 32-bit block spanning.  If later on we get some that can/should do
64-bit, that can be done now using daddr64_t (but of course, we are taking
this step to finalize the daddr_t 64-bit conversion).
ok miod krw
@
text
@d1 1
a1 1
/*	$OpenBSD: bootxx.c,v 1.6 2010/06/29 21:33:54 miod Exp $	*/
a68 1
	size_t	n;
@


1.6
log
@In the boot blocks, stop assuming we have a 1:1 mapping of low physical
memory, but instead gather memory layout information and work with the MMU
(or the PROM) to make sure we can actually load the kernel image in a proper
contiguous physical memory area.

In order to do this, we look at the kernel image twice; during the first pass,
the kernel footprint is computed, and then after making sure it can be
loaded, the second pass loads the actual image.

Since such a logic doesn't work on media which can not seek backwards, such
as tapes, we check for the boot device being a tape and, in that case, assume
a fixed (generous) image size and don't load the kernel symbol table (to
avoid seeking backwards); since tape boot is supposed to be only used to
boot bsd.rd, this is something we can live with.

While there, lower the address the boot blocks are loaded in memory, because
the last crank did not work with some early sun4c OpenPROM, which only
map about 3.5MB of memory.

Memory games logic from NetBSD, tape handling by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: bootxx.c,v 1.5 2003/11/14 19:05:36 miod Exp $	*/
d60 1
a60 1
daddr_t			block_table[MAXBLOCKNUM] = { 0 };
d92 1
a92 1
	daddr_t		blk;
@


1.5
log
@the the; rohee@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bootxx.c,v 1.4 2003/08/14 17:13:57 deraadt Exp $	*/
d70 1
a70 1
	register void (*entry)(caddr_t) = (void (*)(caddr_t))LOADADDR;
d78 1
a78 1
	(void)loadboot(&io, LOADADDR);
d80 1
a80 1
	(*entry)(cputyp == CPU_SUN4 ? LOADADDR : (caddr_t)promvec);
@


1.4
log
@partial proto repairs
@
text
@d1 1
a1 1
/*	$OpenBSD: bootxx.c,v 1.3 2002/08/11 23:11:22 art Exp $	*/
d53 1
a53 1
 * to hold the the filesystem data of the second-stage boot program
@


1.3
log
@ELF support in sparc bootblocks.
Loadfile is from alpha, but heaviliy hacked here.
The build is done by building elf versions of boot and bootxx, then
merging the .rodata and .text sections into .text with a horrible hack
and then using objcopy to convert that into a.out.

Maybe someone will want to fix installboot to deal with ELF instead, but
I won't be that someone in the nearest future.
@
text
@d1 1
a1 1
/*	$OpenBSD: bootxx.c,v 1.2 2002/03/14 01:26:44 millert Exp $	*/
d66 1
a66 1
main()
@


1.2
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: bootxx.c,v 1.1 1997/09/17 10:46:16 downsj Exp $	*/
d48 1
a48 1
const char		progname[] = "bootxx";
@


1.1
log
@Reorganizaed bootblocks.  Builds like hp300 now.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d63 1
a63 1
void	loadboot __P((struct open_file *, caddr_t));
d70 1
a70 1
	register void (*entry)__P((caddr_t)) = (void (*)__P((caddr_t)))LOADADDR;
@


1.1.22.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bootxx.c,v 1.1 1997/09/17 10:46:16 downsj Exp $	*/
d63 1
a63 1
void	loadboot(struct open_file *, caddr_t);
d70 1
a70 1
	register void (*entry)(caddr_t) = (void (*)(caddr_t))LOADADDR;
@


1.1.22.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bootxx.c,v 1.1.22.1 2002/06/11 03:38:17 art Exp $	*/
d48 1
a48 1
char		progname[] = "bootxx";
@


1.1.12.1
log
@Merge in -current from about a week ago
@
text
@d63 1
a63 1
void	loadboot(struct open_file *, caddr_t);
d70 1
a70 1
	register void (*entry)(caddr_t) = (void (*)(caddr_t))LOADADDR;
@


1.1.12.2
log
@Sync the SMP branch with 3.3
@
text
@d48 1
a48 1
char		progname[] = "bootxx";
@


1.1.12.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d53 1
a53 1
 * to hold the filesystem data of the second-stage boot program
d66 1
a66 1
main(int argc, char *argv[])
@


