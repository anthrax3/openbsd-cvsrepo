head	1.15;
access;
symbols
	OPENBSD_6_0:1.15.0.4
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.10
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.8
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.6
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.4
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.9.0.4
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.2
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.6.0.26
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.28
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.24
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.22
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.20
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.18
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.16
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.14
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.12
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.4
	UBC:1.2.0.14
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.12
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.10
	OPENBSD_2_8:1.2.0.8
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.6
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.4
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.0.8
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.6
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.4
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.2
	OPENBSD_2_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.15
date	2015.11.16.19.33.52;	author miod;	state Exp;
branches;
next	1.14;
commitid	5gnqUR6VheSiU9SF;

1.14
date	2015.05.19.20.42.11;	author miod;	state Exp;
branches;
next	1.13;
commitid	Ic2axo9tl3k6gGgM;

1.13
date	2015.03.05.20.46.13;	author miod;	state Exp;
branches;
next	1.12;
commitid	zHrAlLBIQwzcFtAS;

1.12
date	2014.03.30.19.48.04;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2014.02.25.21.28.30;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2011.04.14.18.27.49;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2010.08.16.14.41.28;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2010.07.06.20.41.04;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.29.21.33.54;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.14.17.13.57;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.02.23.27.55;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.11.23.11.22;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.06.21.23.35.41;	author deraadt;	state Exp;
branches
	1.2.4.1
	1.2.14.1;
next	1.1;

1.1
date	97.09.17.10.46.15;	author downsj;	state Exp;
branches;
next	;

1.2.4.1
date	2002.03.28.10.57.11;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2003.03.27.23.49.26;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2003.06.07.11.14.44;	author ho;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2004.02.19.10.49.59;	author niklas;	state Exp;
branches;
next	;

1.2.14.1
date	2002.06.11.03.38.17;	author art;	state Exp;
branches;
next	1.2.14.2;

1.2.14.2
date	2002.10.29.00.28.11;	author art;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Replace unbounded gets() in libsa with getln() which takes a buffer size,
and convert all gets() users.
ok deraadt@@
@
text
@/*	$OpenBSD: boot.c,v 1.14 2015/05/19 20:42:11 miod Exp $	*/
/*	$NetBSD: boot.c,v 1.2 1997/09/14 19:27:21 pk Exp $	*/

/*-
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * 	@@(#)boot.c	8.1 (Berkeley) 6/10/93
 */

#include <sys/param.h>
#include <sys/reboot.h>
#include <sys/stat.h>
#define _KERNEL
#include <sys/fcntl.h>
#undef _KERNEL

#include <lib/libsa/loadfile.h>
#include <lib/libsa/stand.h>

#include <sparc/stand/common/promdev.h>

int debug;
int netif_debug;

#define	FOURMB		0x400000
#ifndef	RELOC2
#define	RELOC2		(RELOC + 0x40000)
#endif
#define	LOWSTACK	(16 * 1024)

/*
 * Boot device is derived from ROM provided information.
 */
#define	DEFAULT_KERNEL	"bsd"

extern char	*version;
char		fbuf[80], dbuf[128];
char		rnddata[BOOTRANDOM_MAX];

paddr_t	bstart, bend;	/* physical start & end address of the boot program */
int	compat = 1;	/* try to load in compat mode */
int	rnd_loaded = 0;

typedef void (*entry_t)(u_long, int, int, int, long, long);

int	fdloadfile(int, u_long *, int);
int	loadrandom(const char *, void *, size_t);

static paddr_t
getphysmem(u_long size)
{
	struct	memarr *pmemarr;	/* physical memory regions */
	u_int	npmemarr;		/* number of entries in pmemarr */
	struct memarr *mp;
	int i;
#ifdef DEBUG
	static int arrdpy;
#endif

	/*
	 * Get available physical memory from the prom.
	 */
	npmemarr = prom_makememarr(NULL, 0, MEMARR_AVAILPHYS);
	pmemarr = alloc(npmemarr*sizeof(struct memarr));
	if (pmemarr == NULL)
		return ((paddr_t)-1);
	npmemarr = prom_makememarr(pmemarr, npmemarr, MEMARR_AVAILPHYS);

#ifdef DEBUG
	if (arrdpy == 0) {
		arrdpy = 1;
		printf("Available physical memory:\n");
		for (mp = pmemarr, i = (int)npmemarr; --i >= 0; mp++) {
			uint64_t addr;
			addr = pmemarr[i].addr_hi;
			addr <<= 32;
			addr |= pmemarr[i].addr_lo;
			printf("%p at 0x%llx\n", pmemarr[i].len, addr);
		}
	}
#endif

	/*
	 * Find a suitable loading address.
	 */
	for (mp = pmemarr, i = (int)npmemarr; --i >= 0; mp++) {
		paddr_t pa;
		u_long len;

		/* Skip memory ranges the kernel can't use yet on sun4d */
		if (pmemarr[i].addr_hi != 0)
			continue;
		pa = (paddr_t)pmemarr[i].addr_lo;
		if (pa >= 0x80000000)
			continue;
		len = (u_long)pmemarr[i].len;
		if (len >= 0x80000000)
			len = 0x80000000;
		if (pa + len > 0x80000000)
			len = 0x80000000 - pa;

		if (len < size)
			continue;

		/* Check whether it will fit in front of us */
		if (pa < bstart && len >= size && (bstart - pa) >= size)
			return (pa);

		/* Skip the boot program memory */
		if (pa < bend) {
			if (len < bend - pa)
				/* Not large enough */
				continue;

			/* Shrink this segment */
			len -=  bend - pa;
			pa = bend;
		}

		/* Does it fit in the remainder of this segment? */
		if (len >= size)
			return (pa);
	}
	return ((paddr_t)-1);
}

static int
loadk(char *file, u_long *marks)
{
	int fd, error, flags;
	vaddr_t va;
	paddr_t pa;
	u_long minsize, size;
	vaddr_t extra;

	marks[MARK_RANDOM] = marks[MARK_ERANDOM] = 0;

	/*
	 * Regardless of the address where we load the kernel, we need to
	 * make sure it has enough valid space to use during pmap_bootstrap.
	 * locore.s tries to use the 512KB following the kernel image, and
	 * we need to make sure this extra room does not overwrite PROM data
	 * (such as the PROM page tables which are immediately below 4MB on
	 * most sun4c).
	 */
	extra = 512 * 1024;

	if ((fd = open(file, O_RDONLY)) < 0)
		return (errno ? errno : ENOENT);

	/*
	 * We need to know whether we are booting off a tape or not,
	 * because we can not seek backwards off tapes.
	 */

	if (files[fd].f_flags & F_RAW) {
		flags = (COUNT_KERNEL & ~COUNT_SYM) | (LOAD_KERNEL & ~LOAD_SYM);
		if (rnd_loaded == 0)
			flags &= ~LOAD_RANDOM;
		minsize = FOURMB;
		va = 0xf8000000;		/* KERNBASE */
#ifdef DEBUG
		printf("Tape boot: expecting a bsd.rd kernel smaller than %p\n",
		    minsize);
#endif
		/* compensate for extra room below */
		minsize -= extra;
	} else {
		flags = LOAD_KERNEL;
		if (rnd_loaded == 0)
			flags &= ~LOAD_RANDOM;

		/*
		 * Even though we just have opened the file, the gzip code
		 * has tried to read from it. Be sure to reset position in
		 * case the file is not compressed (transparent mode isn't
		 * so transparent...)
		 */
		if (lseek(fd, 0, SEEK_SET) == (off_t)-1) {
			error = errno;
			goto out;
		}

		marks[MARK_START] = 0;
		if ((error = fdloadfile(fd, marks, COUNT_KERNEL)) != 0)
			goto out;

		/* rewind file for the actual load operation later */
		if (lseek(fd, 0, SEEK_SET) == (off_t)-1) {
			error = errno;
			goto out;
		}

		minsize = marks[MARK_END] - marks[MARK_START];

		/* We want that leading 16K in front of the kernel image */
		minsize += PROM_LOADADDR;
		va = marks[MARK_START] - PROM_LOADADDR;
	}

	/*
	 * If the kernel would entirely fit under the boot code, and the
	 * boot code has been loaded 1:1, we do not need to allocate
	 * breathing room after it.
	 */
	size = minsize + extra;
	if (CPU_ISSUN4M || CPU_ISSUN4D)
		size += 1024 * 1024;
	if (compat != 0) {
		if (size <= RELOC2 - LOWSTACK)
			size = RELOC2 - LOWSTACK;
		else
			compat = 0;
	}

	/* Get a physical load address */
#ifdef DEBUG
	printf("kernel footprint %p, requesting %p\n", minsize, size);
#endif
	pa = getphysmem(size);
	if (pa == (paddr_t)-1) {
		/*
		 * The extra bootstrap memory estimate might have been
		 * too much, if physical memory doesn't have any contiguous
		 * large chunks (e.g. on sun4c systems with 4MB regions).
		 * If that increase caused us to cross a 4MB boundary, try
		 * to limit ourselves to a 4MB multiple.
		 */
		if (compat == 0 && size / FOURMB != minsize / FOURMB) {
			size = roundup(minsize, FOURMB);
#ifdef DEBUG
			printf("now trying %p\n", size);
#endif
			pa = getphysmem(size);
		}
		if (pa == (paddr_t)-1) {
			error = EFBIG;
			goto out;
		}
	}

	printf("Loading at physical address %lx\n", pa);
	if (pmap_map(va, pa, size) != 0) {
		error = EFAULT;
		goto out;
	}

	/* try and double-map at VA 0 for compatibility */
	if (pa + size > bstart) {
#ifdef DEBUG
		printf("WARNING: %s is too large for compat mode.\n"
		    "If your kernel is too old, it will not run correctly.\n",
		    file);
#endif
	} else {
		if (pa != 0 && pmap_map(0, pa, size) != 0) {
			error = EFAULT;
			goto out;
		}
	}

	marks[MARK_START] = 0;
	error = fdloadfile(fd, marks, flags);

	/*
	 * If we did not load a random.seed file yet, and we know we can try,
	 * load one.
	 */
	if (error == 0 && rnd_loaded == 0 && marks[MARK_RANDOM] != 0) {
		/*
		 * Some PROM do not like having a network device open()ed
		 * twice; better close the kernel fd before trying to get
		 * randomness.
		 */
		close(fd);

		rnd_loaded = loadrandom(BOOTRANDOM, rnddata, sizeof(rnddata));
		if (rnd_loaded != 0) {
			while (marks[MARK_RANDOM] < marks[MARK_ERANDOM]) {
				u_long m;
				m = MIN(marks[MARK_ERANDOM] -
				    marks[MARK_RANDOM], sizeof(rnddata));
				memcpy((void *)marks[MARK_RANDOM], rnddata, m);
				marks[MARK_RANDOM] += m;
			}
		}

		return 0;
	}

out:
	close(fd);
	return (error);
}

int
main(int argc, char *argv[])
{
	int	error;
	char	*file;
	u_long	marks[MARK_MAX];
	extern char start[];		/* top of stack (see srt0.S) */
	vaddr_t	bstart_va;

	prom_init();
	mmu_init();

	printf(">> OpenBSD BOOT %s\n", version);

	/*
	 * Find the physical memory area that's in use by the boot loader.
	 * Our stack grows down from label `start'; assume we need no more
	 * than 16K of stack space.
	 * The top of the boot loader is the next 4MB boundary.
	 */
	bstart_va = (vaddr_t)start - LOWSTACK;
	if (pmap_extract(bstart_va, &bstart) != 0)
		panic("can't figure out where we have been loaded");

	if (bstart != bstart_va)
		compat = 0;

	bend = roundup(bstart, FOURMB);
#ifdef DEBUG
	printf("bstart %p bend %p\n", bstart, bend);
#endif

	file = prom_bootfile;
	if (file == 0 || *file == 0)
		file = DEFAULT_KERNEL;

	for (;;) {
		if (prom_boothow & RB_ASKNAME) {
			printf("device[%s]: ", prom_bootdevice);
			getln(dbuf, sizeof dbuf);
			if (dbuf[0])
				prom_bootdevice = dbuf;
			printf("boot: ");
			getln(fbuf, sizeof fbuf);
			if (fbuf[0])
				file = fbuf;
		}

		printf("Booting %s\n", file);
		if ((error = loadk(file, marks)) == 0)
			break;

		printf("Cannot load %s: error=%d\n", file, error);
		prom_boothow |= RB_ASKNAME;
	}

	/* Note: args 2-4 not used due to conflicts with SunOS loaders */
	(*(entry_t)marks[MARK_ENTRY])(cputyp == CPU_SUN4 ?
	    PROM_LOADADDR : (u_long)promvec, 0, 0, 0,
	    marks[MARK_END], DDB_MAGIC1);

	_rtt();
}

int
loadrandom(const char *path, void *buf, size_t buflen)
{
	struct stat sb;
	int fd;
	int rc = 0;

	fd = open(path, O_RDONLY);
	if (fd == -1) {
		if (errno != EPERM)
			printf("cannot open %s: %s\n", path, strerror(errno));
		return 0;
	}
	if (fstat(fd, &sb) == -1 || sb.st_uid != 0 || !S_ISREG(sb.st_mode) ||
	    (sb.st_mode & (S_IWOTH|S_IROTH)))
		goto fail;
	(void) read(fd, buf, buflen);
	rc = 1;
fail:
	close(fd);
	return rc;
}
@


1.14
log
@Only attempt to load /etc/random.seed from the boot device after the kernel
image has been succesfully loaded (with the recent loadfile changes allowing
us to know where the randomness needs to be loaded). While there, don't
bother doing this when booting from tape.

This works around the sun4e PROM 1.6, which gets confused by PROM open() -
close() sequences without any I/O happening in between.

Crank boot blocks version to 2.11.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.13 2015/03/05 20:46:13 miod Exp $	*/
d360 1
a360 1
			gets(dbuf);
d364 1
a364 1
			gets(fbuf);
@


1.13
log
@When running on a sun4d or sun4m system, have the bootblocks ask for one
more megabyte of virtual memory beyond the kernel image; this is safe to do
as you can't find any such system with less than 8MB of contiguous memory.

While nothing in the kernel has a need for that extra memory to be available
to the kernel for its bootstrap needs, forthcoming changes (post-5.7) will
need it, and these kernels won't work when booted from boot loaders prior to
this change. By shipping 5.7 with updated boot blocks, we'll make upgrading
to 5.7-CURRENT easier for sun4m owners, when the time comes.

Crank boot blocks version.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.12 2014/03/30 19:48:04 miod Exp $	*/
d161 2
d183 2
a193 19
		/*
		 * If we did not load a random.seed file yet, try and load
		 * one.
		 */
		if (rnd_loaded == 0) {
			/*
			 * Some PROM do not like having a network device
			 * open()ed twice; better close and reopen after
			 * trying to get randomness.
			 */
			close(fd);

			rnd_loaded = loadrandom(BOOTRANDOM, rnddata,
			    sizeof(rnddata));

			if ((fd = open(file, O_RDONLY)) < 0)
				return (errno ? errno : ENOENT);
		}

d195 2
a196 1
		marks[MARK_START] = 0;
d209 1
d289 27
@


1.12
log
@Close the kernel fd before attempting to load /etc/random.seed, and reopen it
afterwards, for some prom misbehave if the network interface is opened twice;
repairs boot.net operation on at least SS5 PROM v2.21; found the hard way by
sebastia@@. Crank boot version; verified not to hurt disk boot.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.11 2014/02/25 21:28:30 miod Exp $	*/
d164 1
a164 1
	 * locore.s tries to map the 512KB following the kernel image, and
d245 2
d248 1
a248 1
		if (minsize + extra <= RELOC2 - LOWSTACK)
@


1.11
log
@/etc/random.seed support (unless booting from tape). Crank version.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.10 2011/04/14 18:27:49 miod Exp $	*/
d195 7
d204 3
@


1.10
log
@Sprinkle prototypes, kill unused locals, and stop contributing to global
warning.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.9 2010/08/16 14:41:28 miod Exp $	*/
d37 5
d63 1
d67 1
d71 2
a72 1
int fdloadfile(int, u_long *, int);
d171 1
a171 1
	if ((fd = open(file, 0)) < 0)
d190 9
d357 23
@


1.9
log
@Make sure we reserve enough room after the kernel image to avoid stomping
over the PROM page tables on sun4c; also crank the tape kernel generous
size estimate to 4MB; crank version.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.8 2010/07/06 20:41:04 miod Exp $	*/
d217 1
a223 2
	if (compat == 0)
		size = minsize + extra;
@


1.8
log
@sun4e support in the bootblocks, derived from a diff from jason@@ 7 years ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.7 2010/06/29 21:33:54 miod Exp $	*/
d155 5
a159 2
	 * make sure it has enough valid space to use during pmap_bootstrap;
	 * 4/4c picks it in locore, 4m needs it now.
d161 1
a161 4
	if (cputyp == CPU_SUN4 || cputyp == CPU_SUN4C)
		extra = 0;
	else
		extra = 512 * 1024;
d173 1
a173 1
		minsize = RELOC2 - LOWSTACK;
d260 1
d264 1
d331 2
a332 4
		if (error != ENOENT) {
			printf("Cannot load %s: error=%d\n", file, error);
			prom_boothow |= RB_ASKNAME;
		}
@


1.7
log
@In the boot blocks, stop assuming we have a 1:1 mapping of low physical
memory, but instead gather memory layout information and work with the MMU
(or the PROM) to make sure we can actually load the kernel image in a proper
contiguous physical memory area.

In order to do this, we look at the kernel image twice; during the first pass,
the kernel footprint is computed, and then after making sure it can be
loaded, the second pass loads the actual image.

Since such a logic doesn't work on media which can not seek backwards, such
as tapes, we check for the boot device being a tape and, in that case, assume
a fixed (generous) image size and don't load the kernel symbol table (to
avoid seeking backwards); since tape boot is supposed to be only used to
boot bsd.rd, this is something we can live with.

While there, lower the address the boot blocks are loaded in memory, because
the last crank did not work with some early sun4c OpenPROM, which only
map about 3.5MB of memory.

Memory games logic from NetBSD, tape handling by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.6 2003/08/14 17:13:57 deraadt Exp $	*/
d45 5
a49 1
#define	FOURMB	0x400000
a56 1
extern vaddr_t	esym;
a59 1
u_long	loadaddrmask = -1UL;
d151 11
d173 1
a173 1
		minsize = RELOC + 0x40000;	/* RELOC2 */
d180 1
a180 1
		minsize -= 512 * 1024;
d218 2
a219 2
		if (minsize < bstart)
			size = minsize;
d223 2
d226 1
a226 7
	/*
	 * If we are not loading the kernel in low physical addresses,
	 * we need to make sure it has enough valid space to use during
	 * pmap_bootstrap; 512KB ought to be enough.
	 */
	if (compat == 0) {
		size = minsize + 512 * 1024;
d228 1
a228 1
		printf("kernel footprint %p, requesting %p\n", minsize, size);
a229 3
	}

	/* Get a physical load address */
d233 5
a237 5
		 * That 512KB extra might have been too much, if physical
		 * memory doesn't have any contiguous large chunks (e.g.
		 * on sun4c systems with 4MB regions).
		 * If that 512KB increase caused us to cross a 4MB
		 * boundary, try to limit ourselves to a 4MB multiple.
d259 1
a259 1
	if (pa + size >= bstart) {
a267 1
		loadaddrmask = 0x07ffffffUL;
d297 1
a297 1
	bstart_va = (vaddr_t)start - 16 * 1024;
d338 1
a338 1
	    marks[MARK_END] & loadaddrmask, DDB_MAGIC1);
@


1.6
log
@partial proto repairs
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.5 2003/06/02 23:27:55 millert Exp $	*/
d37 1
a37 1
#include <a.out.h>
a41 2
void copyunix(int, char *);
void promsyms(int, struct exec *);
d45 2
d56 142
a197 2
typedef void (*entry_t)(caddr_t, int, int, int, long, long);
int loadfile(int, vaddr_t *);
d199 74
d275 1
a275 1
	int	io;
d277 3
a279 1
	entry_t entry;
d282 1
d286 18
d319 3
a321 1
		if ((io = open(file, 0)) >= 0)
d323 5
a327 2
		printf("open: %s: %s\n", file, strerror(errno));
		prom_boothow |= RB_ASKNAME;
a329 3
	printf("Booting %s @@ 0x%x\n", file, LOADADDR);
	loadfile(io, (vaddr_t *)&entry);

d331 3
a333 2
	(*entry)(cputyp == CPU_SUN4 ? LOADADDR : (caddr_t)promvec,
		 0, 0, 0, esym, DDB_MAGIC1);
@


1.5
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.4 2002/08/11 23:11:22 art Exp $	*/
d59 1
a59 2

main()
@


1.4
log
@ELF support in sparc bootblocks.
Loadfile is from alpha, but heaviliy hacked here.
The build is done by building elf versions of boot and bootxx, then
merging the .rodata and .text sections into .text with a horrible hack
and then using objcopy to convert that into a.out.

Maybe someone will want to fix installboot to deal with ELF instead, but
I won't be that someone in the nearest future.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.3 2002/03/14 01:26:44 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.2 1999/06/21 23:35:41 deraadt Exp $	*/
d56 3
a58 5
extern char		*version;
unsigned long		esym;
char			*strtab;
int			strtablen;
char			fbuf[80], dbuf[128];
d61 1
a62 1
void	loadfile(int, caddr_t);
d68 1
d96 1
a96 71
	loadfile(io, LOADADDR);

	_rtt();
}

void
loadfile(io, addr)
	register int	io;
	register caddr_t addr;
{
	register entry_t entry = (entry_t)LOADADDR;
	struct exec x;
	int i;

	i = read(io, (char *)&x, sizeof(x));
	if (i != sizeof(x) ||
	    N_BADMAG(x)) {
		printf("Bad format\n");
		return;
	}
	printf("%d", x.a_text);
	if (N_GETMAGIC(x) == ZMAGIC) {
		entry = (entry_t)(addr+sizeof(struct exec));
		addr += sizeof(struct exec);
	}
	if (read(io, (char *)addr, x.a_text) != x.a_text)
		goto shread;
	addr += x.a_text;
	if (N_GETMAGIC(x) == ZMAGIC || N_GETMAGIC(x) == NMAGIC)
		while ((int)addr & __LDPGSZ)
			*addr++ = 0;
	printf("+%d", x.a_data);
	if (read(io, addr, x.a_data) != x.a_data)
		goto shread;
	addr += x.a_data;
	printf("+%d", x.a_bss);
	for (i = x.a_bss; i ; --i)
		*addr++ = 0;
	if (x.a_syms != 0) {
		bcopy(&x.a_syms, addr, sizeof(x.a_syms));
		addr += sizeof(x.a_syms);
		printf("+[%d", x.a_syms);
		if (read(io, addr, x.a_syms) != x.a_syms)
			goto shread;
		addr += x.a_syms;

		if (read(io, &strtablen, sizeof(int)) != sizeof(int))
			goto shread;

		bcopy(&strtablen, addr, sizeof(int));
		if (i = strtablen) {
			i -= sizeof(int);
			addr += sizeof(int);
			if (read(io, addr, i) != i)
			    goto shread;
			addr += i;
		}
		printf("+%d]", i);
		esym = ((u_int)x.a_entry - (u_int)LOADADDR) +
			(((int)addr + sizeof(int) - 1) & ~(sizeof(int) - 1));
#if 0
		/*
		 * The FORTH word `loadsyms' is mentioned in the
		 * "Openboot command reference" book, but it seems it has
		 * not been implemented on at least one machine..
		 */
		promsyms(io, &x);
#endif
	}
	printf("=0x%x\n", addr);
	close(io);
a100 1
	return;
d102 1
a102 87
shread:
	printf("boot: short read\n");
	return;
}

#if 0
struct syms {
	u_int32_t	value;
	u_int32_t	index;
};

void
sort(syms, n)
	struct syms *syms;
	int n;
{
	register struct syms *sj;
	register int i, j, k;
	register u_int32_t value, index;

	/* Insertion sort.  This is O(n^2), but so what? */
	for (i = 1; i < n; i++) {
		/* save i'th entry */
		value = syms[i].value;
		index = syms[i].index;
		/* find j such that i'th entry goes before j'th */
		for (j = 0, sj = syms; j < i; j++, sj++)
			if (value < sj->value)
				break;
		/* slide up any additional entries */
		for (k = 0; k < (i - j); k++) {
			sj[k+1].value = sj[k].value;
			sj[k+1].index = sj[k].index;
		}
		sj->value = value;
		sj->index = index;
	}
}

void
promsyms(fd, hp)
	int fd;
	struct exec *hp;
{
	int i, n, strtablen;
	char *str, *p, *cp, buf[128];
	struct syms *syms;

	lseek(fd, sizeof(*hp)+hp->a_text+hp->a_data, SEEK_SET);
	n = hp->a_syms/sizeof(struct nlist);
	if (n == 0)
		return;
	syms = (struct syms *)alloc(n * sizeof(struct syms));

	printf("+[%x+", hp->a_syms);
	for (i = 0; i < n; i++) {
		struct nlist nlist;

		if (read(fd, &nlist, sizeof(nlist)) != sizeof(nlist)) {
			printf("promsyms: read failed\n");
			return;
		}
		syms[i].value = nlist.n_value;
		syms[i].index = nlist.n_un.n_strx - sizeof(strtablen);
	}

	sort(syms, n);

	if (read(fd, &strtablen, sizeof(strtablen)) != sizeof(strtablen)) {
		printf("promsym: read failed (strtablen)\n");
		return;
	}
	if (strtablen < sizeof(strtablen)) {
		printf("promsym: string table corrupted\n");
		return;
	}
	strtablen -= sizeof(strtablen);
	str = (char *)alloc(strtablen);

	printf("%x]", strtablen);
	if (read(fd, str, strtablen) != strtablen) {
		printf("promsym: read failed (strtab)\n");
		return;
	}

	sprintf(buf, "%x %d %x loadsyms", syms, n, str);
	(promvec->pv_fortheval.v2_eval)(buf);
a103 1
#endif
@


1.2
log
@avoid another sparc egcs bug, apparently
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.1 1997/09/17 10:46:15 downsj Exp $	*/
d46 2
a47 2
void copyunix __P((int, char *));
void promsyms __P((int, struct exec *));
d62 1
a62 1
typedef void (*entry_t)__P((caddr_t, int, int, int, long, long));
d64 1
a64 1
void	loadfile __P((int, caddr_t));
@


1.2.14.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.2 1999/06/21 23:35:41 deraadt Exp $	*/
d46 2
a47 2
void copyunix(int, char *);
void promsyms(int, struct exec *);
d62 1
a62 1
typedef void (*entry_t)(caddr_t, int, int, int, long, long);
d64 1
a64 1
void	loadfile(int, caddr_t);
@


1.2.14.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.2.14.1 2002/06/11 03:38:17 art Exp $	*/
d56 5
a60 3
extern char	*version;
extern vaddr_t	esym;
char		fbuf[80], dbuf[128];
a62 1
int loadfile(int, vaddr_t *);
d64 1
a69 1
	entry_t entry;
d97 71
a167 1
	loadfile(io, (vaddr_t *)&entry);
d172 6
d179 82
a260 1
	_rtt();
d262 1
@


1.2.4.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 2
a47 2
void copyunix(int, char *);
void promsyms(int, struct exec *);
d62 1
a62 1
typedef void (*entry_t)(caddr_t, int, int, int, long, long);
d64 1
a64 1
void	loadfile(int, caddr_t);
@


1.2.4.2
log
@Sync the SMP branch with 3.3
@
text
@d56 5
a60 3
extern char	*version;
extern vaddr_t	esym;
char		fbuf[80], dbuf[128];
a62 1
int loadfile(int, vaddr_t *);
d64 1
a69 1
	entry_t entry;
d97 71
a167 1
	loadfile(io, (vaddr_t *)&entry);
d172 6
d179 82
a260 1
	_rtt();
d262 1
@


1.2.4.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.2.4.2 2003/03/27 23:49:26 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.2.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 2
a60 1
main(int argc, char *argv[])
@


1.1
log
@Reorganizaed bootblocks.  Builds like hp300 now.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.5 1996/08/11 09:13:22 downsj Exp $	*/
d46 2
a47 2
static void copyunix __P((int, char *));
static void promsyms __P((int, struct exec *));
d133 1
a133 1
	for (i = 0; i < x.a_bss; i++)
d185 1
a185 1
static void
@

