head	1.6;
access;
symbols
	OPENBSD_4_7:1.5.0.26
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.28
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.24
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.22
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.20
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.18
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.16
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.14
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.3
	SMP:1.2.0.4
	OPENBSD_3_3:1.2.0.2
	OPENBSD_3_3_BASE:1.2
	UBC:1.1.0.4
	UBC_SYNC_B:1.1
	OPENBSD_3_2:1.1.0.2
	OPENBSD_3_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2010.06.29.21.33.54;	author miod;	state dead;
branches;
next	1.5;

1.5
date	2003.08.14.17.13.57;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.02.23.27.55;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.08.20.34.01;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.18.05.11.57;	author miod;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2002.08.11.23.11.22;	author art;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2002.10.29.00.28.11;	author art;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2003.05.19.21.46.33;	author tedu;	state Exp;
branches;
next	;

1.2.4.1
date	2003.05.13.19.41.09;	author ho;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2003.06.07.11.14.44;	author ho;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2004.02.19.10.49.59;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.6
log
@In the boot blocks, stop assuming we have a 1:1 mapping of low physical
memory, but instead gather memory layout information and work with the MMU
(or the PROM) to make sure we can actually load the kernel image in a proper
contiguous physical memory area.

In order to do this, we look at the kernel image twice; during the first pass,
the kernel footprint is computed, and then after making sure it can be
loaded, the second pass loads the actual image.

Since such a logic doesn't work on media which can not seek backwards, such
as tapes, we check for the boot device being a tape and, in that case, assume
a fixed (generous) image size and don't load the kernel symbol table (to
avoid seeking backwards); since tape boot is supposed to be only used to
boot bsd.rd, this is something we can live with.

While there, lower the address the boot blocks are loaded in memory, because
the last crank did not work with some early sun4c OpenPROM, which only
map about 3.5MB of memory.

Memory games logic from NetBSD, tape handling by me.
@
text
@/*	$OpenBSD: loadfile.c,v 1.5 2003/08/14 17:13:57 deraadt Exp $	*/
/*	$NetBSD: loadfile.c,v 1.3 1997/04/06 08:40:59 cgd Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)boot.c	8.1 (Berkeley) 6/10/93
 */

#define	ELFSIZE		32

#include <lib/libkern/libkern.h>
#include <lib/libsa/stand.h>
#include <sparc/stand/common/promdev.h>

#include <sys/param.h>
#include <sys/exec.h>
#include <sys/exec_elf.h>

#include <ddb/db_aout.h>

#ifdef SPARC_BOOT_AOUT
static int aout_exec(int, struct exec *, vaddr_t *);
#endif
#ifdef SPARC_BOOT_ELF
static int elf_exec(int, Elf_Ehdr *, vaddr_t *);
#endif
int loadfile(int, vaddr_t *);

vaddr_t ssym, esym;

union {
#ifdef SPARC_BOOT_AOUT
	struct exec aout;
#endif
#ifdef SPARC_BOOT_ELF
	Elf_Ehdr elf;
#endif
} hdr;

/*
 * Open 'filename', read in program and return the entry point or -1 if error.
 */
int
loadfile(int fd, vaddr_t *entryp)
{
	struct devices *dp;
	int rval;

	/* Read the exec header. */
	if (read(fd, &hdr, sizeof(hdr)) != sizeof(hdr)) {
		printf("read header: %s\n", strerror(errno));
		goto err;
	}

#ifdef SPARC_BOOT_ELF
	if (memcmp(ELFMAG, hdr.elf.e_ident, SELFMAG) == 0) {
		rval = elf_exec(fd, &hdr.elf, entryp);
	} else
#endif
#ifdef SPARC_BOOT_AOUT
	if (!N_BADMAG(hdr.aout)) {
		rval = aout_exec(fd, &hdr.aout, entryp);
	} else
#endif
	{
		printf("unknown executable format\n");
	}

err:
	if (fd >= 0)
		close(fd);
	return (rval);
}

#ifdef SPARC_BOOT_AOUT
static int
aout_exec(int fd, struct exec *aout, vaddr_t *entryp)
{
	caddr_t addr = (caddr_t)LOADADDR;
	int strtablen;
	char *strtab;
	vaddr_t entry = (vaddr_t)LOADADDR;
	int i;

	printf("%d", aout->a_text);
	if (N_GETMAGIC(*aout) == ZMAGIC) {
		entry = (vaddr_t)(addr+sizeof(struct exec));
		addr += sizeof(struct exec);
	}
	/* we can't lseek() here - we may be booting off tape */
	bcopy((char *)aout + sizeof(struct exec), addr,
	    sizeof(hdr) - sizeof(struct exec));
	if (read(fd, (char *)addr + sizeof(hdr) - sizeof(struct exec),
	    aout->a_text - (sizeof(hdr) - sizeof(struct exec))) !=
	    aout->a_text - (sizeof(hdr) - sizeof(struct exec)))
		goto shread;
	addr += aout->a_text;
	if (N_GETMAGIC(*aout) == ZMAGIC || N_GETMAGIC(*aout) == NMAGIC)
		while ((int)addr & __LDPGSZ)
			*addr++ = 0;
	printf("+%d", aout->a_data);
	if (read(fd, addr, aout->a_data) != aout->a_data)
		goto shread;
	addr += aout->a_data;
	printf("+%d", aout->a_bss);
	for (i = aout->a_bss; i ; --i)
		*addr++ = 0;
	if (aout->a_syms != 0) {
		bcopy(&aout->a_syms, addr, sizeof(aout->a_syms));
		addr += sizeof(aout->a_syms);
		printf("+[%d", aout->a_syms);
		if (read(fd, addr, aout->a_syms) != aout->a_syms)
			goto shread;
		addr += aout->a_syms;

		if (read(fd, &strtablen, sizeof(int)) != sizeof(int))
			goto shread;

		bcopy(&strtablen, addr, sizeof(int));
		if (i = strtablen) {
			i -= sizeof(int);
			addr += sizeof(int);
			if (read(fd, addr, i) != i)
			    goto shread;
			addr += i;
		}
		printf("+%d]", i);
		esym = ((u_int)aout->a_entry - (u_int)LOADADDR) +
			(((int)addr + sizeof(int) - 1) & ~(sizeof(int) - 1));
	}
	printf("=0x%x\n", addr);
	close(fd);

	*entryp = entry;
	return (0);

shread:
	printf("boot: short read\n");
	return (1);
}
#endif /* SPARC_BOOT_AOUT */

#ifdef SPARC_BOOT_ELF

/*
 * If we're booting off tape, we can't seek.
 * Emulate forward moves with reads, and give up on backwards moves.
 * bsd.rd ought to be correctly ordered.
 */
static int
elf_seek(int fd, off_t relpos)
{
#define DUMBBUFSIZE	4096
	char dumbbuf[DUMBBUFSIZE];
	int len;

	if (relpos < 0) {
#ifdef DEBUG
		printf("elf_seek: attempting to seek backwards from %llx bytes, "
		    "may fail!\n", -relpos);
#endif
		if (lseek(fd, relpos, SEEK_CUR) < 0)
			return (-1);
		return (0);
	}

	while (relpos != 0) {
		len = relpos > DUMBBUFSIZE ? DUMBBUFSIZE : relpos;
		if (read(fd, dumbbuf, len) != len)
			return (-1);
		relpos -= len;
	}

	return (0);
#undef DUMBBUFSIZE
}

static int
elf_exec(int fd, Elf_Ehdr *elf, vaddr_t *entryp)
{
	int i;
	int first = 1, havesyms;
	Elf_Shdr *shp;
	Elf_Off off;
	size_t sz;
	vaddr_t addr = 0;
	Elf_Ehdr *fake_elf;
#define	NUM_HEADERS	12	/* should be more than enough */
	Elf_Phdr headers[NUM_HEADERS], *phdr;
	off_t pos, newpos;

	*entryp = 0;

#define A(x) ((x) - *entryp + (vaddr_t)LOADADDR)

	pos = sizeof(hdr);

	/* load the headers */
	if (elf->e_phnum > NUM_HEADERS)
		elf->e_phnum = NUM_HEADERS;	/* amnesia rules */
	newpos = elf->e_phoff;
	if (elf_seek(fd, newpos - pos))
		return (1);
	pos = newpos;
	if (read(fd, (void *)headers, elf->e_phnum * sizeof(Elf_Phdr)) !=
	    elf->e_phnum * sizeof(Elf_Phdr)) {
		printf("read phdr: %s\n", strerror(errno));
		return (1);
	}
	pos += elf->e_phnum * sizeof(Elf_Phdr);

	/* loop through the pheaders and find the entry point. */
	for (i = 0; i < elf->e_phnum; i++) {
		phdr = &headers[i];
		if (phdr->p_type != PT_LOAD ||
		    (phdr->p_flags & (PF_W|PF_X)) == 0 ||
		    (phdr->p_vaddr != elf->e_entry))
			continue;

		*entryp = phdr->p_vaddr;
	}

	if (*entryp == 0) {
		printf("Can't find entry point.\n");
		return (-1);
	}

	for (i = 0; i < elf->e_phnum; i++) {
		phdr = &headers[i];
		if (phdr->p_type != PT_LOAD ||
		    (phdr->p_flags & (PF_W|PF_X)) == 0)
			continue;

		/* Read in segment. */
		printf("%s%lu", first ? "" : "+", phdr->p_filesz);
		newpos = phdr->p_offset;
		if (elf_seek(fd, newpos - pos))
			return (1);
		pos = newpos;

		if (read(fd, (caddr_t)A(phdr->p_vaddr), phdr->p_filesz) !=
		    phdr->p_filesz) {
			(void)printf("read text: %s\n", strerror(errno));
			return (1);
		}
		pos += phdr->p_filesz;

		/* keep track of highest addr we loaded. */
		if (first || addr < (phdr->p_vaddr + phdr->p_memsz))
			addr = (phdr->p_vaddr + phdr->p_memsz);

		/* Zero out bss. */
		if (phdr->p_filesz < phdr->p_memsz) {
			printf("+%lu", phdr->p_memsz - phdr->p_filesz);
			bzero((caddr_t)A(phdr->p_vaddr) + phdr->p_filesz,
			    phdr->p_memsz - phdr->p_filesz);
		}
		first = 0;
	}

	addr = A(addr);
	addr = roundup(addr, sizeof(long));

	ssym = addr;
	/*
	 * Retrieve symbols.
	 */
	addr += sizeof(Elf_Ehdr);

	newpos = elf->e_shoff;
	if (elf_seek(fd, newpos - pos)) {
		printf("seek to section headers: %s\n", strerror(errno));
		return (1);
	}
	pos = newpos;

	sz = elf->e_shnum * sizeof(Elf_Shdr);
	shp = (Elf_Shdr *)addr;
	addr += roundup(sz, sizeof(long));

	if (read(fd, shp, sz) != sz) {
		printf("read section headers: %d\n", strerror(errno));
		return (1);
	}
	pos += sz;

	/*
	 * Now load the symbol sections themselves.  Make sure the
	 * sections are aligned. Don't bother with string tables if
	 * there are no symbol sections.
	 */
	off = roundup((sizeof(Elf_Ehdr) + sz), sizeof(long));

	for (havesyms = i = 0; i < elf->e_shnum; i++)
		if (shp[i].sh_type == SHT_SYMTAB)
			havesyms = 1;

	if (!havesyms)
		goto no_syms;

	for (first = 1, i = 0; i < elf->e_shnum; i++) {
		if (shp[i].sh_type == SHT_SYMTAB ||
		    shp[i].sh_type == SHT_STRTAB) {
			printf("%s%ld", first ? " [" : "+",
			       (u_long)shp[i].sh_size);
			newpos = shp[i].sh_offset;
			if (elf_seek(fd, newpos - pos)) {
				printf("lseek symbols: %s\n", strerror(errno));
				return (1);
			}
			pos = newpos;
			if (read(fd, (void *)addr, shp[i].sh_size) !=
			    shp[i].sh_size) {
				printf("read symbols: %s\n", strerror(errno));
				return (1);
			}
			pos += shp[i].sh_size;
			addr += roundup(shp[i].sh_size, sizeof(long));
			shp[i].sh_offset = off;
			off += roundup(shp[i].sh_size, sizeof(long));
			first = 0;
		}
	}
	if (havesyms && first == 0)
		printf("]");

	elf->e_phoff = 0;
	elf->e_shoff = sizeof(Elf_Ehdr);
	elf->e_phentsize = 0;
	elf->e_phnum = 0;
	bcopy(elf, (void *)ssym, sizeof(*elf));

no_syms:
	esym = (addr - (vaddr_t)LOADADDR) + *entryp;

	*entryp = (vaddr_t)LOADADDR;

	printf("\n");
	return (0);
#undef NUM_HEADERS
}
#endif /* SPARC_BOOT_ELF */
@


1.5
log
@partial proto repairs
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.4 2003/06/02 23:27:55 millert Exp $	*/
@


1.4
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.3 2003/04/08 20:34:01 miod Exp $	*/
d179 1
a179 2
int elf_seek(int, off_t);
int
@


1.3
log
@Ahem, fix printf format.
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.2 2003/03/18 05:11:57 miod Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.2
log
@Restore bootable tape functionality. Previous loadfile() would never use
lseek(), which is not available on tapes when using the prom device routines;
instead, remember our file position, seek forward by reading and discarding data,
and only use lseek() in last resort for backwards seek.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.1 2002/08/11 23:11:22 art Exp $	*/
d193 1
a193 1
		printf("elf_seek: attempting to seek backwards from %lx bytes, "
@


1.2.4.1
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.2 2003/03/18 05:11:57 miod Exp $	*/
d193 1
a193 1
		printf("elf_seek: attempting to seek backwards from %llx bytes, "
@


1.2.4.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.2.4.1 2003/05/13 19:41:09 ho Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.2.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d179 2
a180 1
static int
@


1.1
log
@ELF support in sparc bootblocks.
Loadfile is from alpha, but heaviliy hacked here.
The build is done by building elf versions of boot and bootxx, then
merging the .rodata and .text sections into .text with a horrible hack
and then using objcopy to convert that into a.out.

Maybe someone will want to fix installboot to deal with ELF instead, but
I won't be that someone in the nearest future.
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.12 2002/03/14 01:26:27 millert Exp $	*/
d64 9
a79 8
	union {
#ifdef SPARC_BOOT_AOUT
		struct exec aout;
#endif
#ifdef SPARC_BOOT_ELF
		Elf_Ehdr elf;
#endif
	} hdr;
a118 1
	lseek(fd, sizeof(struct exec), SEEK_SET);
d123 6
a128 1
	if (read(fd, (char *)addr, aout->a_text) != aout->a_text)
d177 35
d222 3
d230 16
d248 4
a251 9
		Elf_Phdr phdr;
		lseek(fd, elf->e_phoff + sizeof(phdr) * i, SEEK_SET);
		if (read(fd, (void *)&phdr, sizeof(phdr)) != sizeof(phdr)) {
			(void)printf("read phdr: %s\n", strerror(errno));
			return (1);
		}
		if (phdr.p_type != PT_LOAD ||
		    (phdr.p_flags & (PF_W|PF_X)) == 0 ||
		    (phdr.p_vaddr != elf->e_entry))
d254 1
a254 1
		*entryp = phdr.p_vaddr;
d263 3
a265 8
		Elf_Phdr phdr;
		lseek(fd, elf->e_phoff + sizeof(phdr) * i, SEEK_SET);
		if (read(fd, (void *)&phdr, sizeof(phdr)) != sizeof(phdr)) {
			(void)printf("read phdr: %s\n", strerror(errno));
			return (1);
		}
		if (phdr.p_type != PT_LOAD ||
		    (phdr.p_flags & (PF_W|PF_X)) == 0)
d269 8
a276 4
		printf("%s%lu", first ? "" : "+", phdr.p_filesz);
		lseek(fd, phdr.p_offset, SEEK_SET);
		if (read(fd, (caddr_t)A(phdr.p_vaddr), phdr.p_filesz) !=
		    phdr.p_filesz) {
d280 1
d283 2
a284 2
		if (first || addr < (phdr.p_vaddr + phdr.p_memsz))
			addr = (phdr.p_vaddr + phdr.p_memsz);
d287 4
a290 4
		if (phdr.p_filesz < phdr.p_memsz) {
			(void)printf("+%lu", phdr.p_memsz - phdr.p_filesz);
			bzero((caddr_t)A(phdr.p_vaddr) + phdr.p_filesz,
			    phdr.p_memsz - phdr.p_filesz);
d300 1
a300 1
	 * Retreive symbols.
d304 2
a305 1
	if (lseek(fd, elf->e_shoff, SEEK_SET) == -1)  {
d309 1
d319 1
d340 2
a341 1
			if (lseek(fd, shp[i].sh_offset, SEEK_SET) == -1) {
d345 1
d351 1
d374 1
d376 1
a376 1
#endif /* ALPHA_BOOT_ELF */
@


1.1.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1.4.2
log
@sync
@
text
@a63 9
union {
#ifdef SPARC_BOOT_AOUT
	struct exec aout;
#endif
#ifdef SPARC_BOOT_ELF
	Elf_Ehdr elf;
#endif
} hdr;

d71 8
d118 1
d123 1
a123 6
	/* we can't lseek() here - we may be booting off tape */
	bcopy((char *)aout + sizeof(struct exec), addr,
	    sizeof(hdr) - sizeof(struct exec));
	if (read(fd, (char *)addr + sizeof(hdr) - sizeof(struct exec),
	    aout->a_text - (sizeof(hdr) - sizeof(struct exec))) !=
	    aout->a_text - (sizeof(hdr) - sizeof(struct exec)))
a171 35

/*
 * If we're booting off tape, we can't seek.
 * Emulate forward moves with reads, and give up on backwards moves.
 * bsd.rd ought to be correctly ordered.
 */
int elf_seek(int, off_t);
int
elf_seek(int fd, off_t relpos)
{
#define DUMBBUFSIZE	4096
	char dumbbuf[DUMBBUFSIZE];
	int len;

	if (relpos < 0) {
#ifdef DEBUG
		printf("elf_seek: attempting to seek backwards from %llx bytes, "
		    "may fail!\n", -relpos);
#endif
		if (lseek(fd, relpos, SEEK_CUR) < 0)
			return (-1);
		return (0);
	}

	while (relpos != 0) {
		len = relpos > DUMBBUFSIZE ? DUMBBUFSIZE : relpos;
		if (read(fd, dumbbuf, len) != len)
			return (-1);
		relpos -= len;
	}

	return (0);
#undef DUMBBUFSIZE
}

a181 3
#define	NUM_HEADERS	12	/* should be more than enough */
	Elf_Phdr headers[NUM_HEADERS], *phdr;
	off_t pos, newpos;
a186 16
	pos = sizeof(hdr);

	/* load the headers */
	if (elf->e_phnum > NUM_HEADERS)
		elf->e_phnum = NUM_HEADERS;	/* amnesia rules */
	newpos = elf->e_phoff;
	if (elf_seek(fd, newpos - pos))
		return (1);
	pos = newpos;
	if (read(fd, (void *)headers, elf->e_phnum * sizeof(Elf_Phdr)) !=
	    elf->e_phnum * sizeof(Elf_Phdr)) {
		printf("read phdr: %s\n", strerror(errno));
		return (1);
	}
	pos += elf->e_phnum * sizeof(Elf_Phdr);

d189 9
a197 4
		phdr = &headers[i];
		if (phdr->p_type != PT_LOAD ||
		    (phdr->p_flags & (PF_W|PF_X)) == 0 ||
		    (phdr->p_vaddr != elf->e_entry))
d200 1
a200 1
		*entryp = phdr->p_vaddr;
d209 8
a216 3
		phdr = &headers[i];
		if (phdr->p_type != PT_LOAD ||
		    (phdr->p_flags & (PF_W|PF_X)) == 0)
d220 4
a223 8
		printf("%s%lu", first ? "" : "+", phdr->p_filesz);
		newpos = phdr->p_offset;
		if (elf_seek(fd, newpos - pos))
			return (1);
		pos = newpos;

		if (read(fd, (caddr_t)A(phdr->p_vaddr), phdr->p_filesz) !=
		    phdr->p_filesz) {
a226 1
		pos += phdr->p_filesz;
d229 2
a230 2
		if (first || addr < (phdr->p_vaddr + phdr->p_memsz))
			addr = (phdr->p_vaddr + phdr->p_memsz);
d233 4
a236 4
		if (phdr->p_filesz < phdr->p_memsz) {
			printf("+%lu", phdr->p_memsz - phdr->p_filesz);
			bzero((caddr_t)A(phdr->p_vaddr) + phdr->p_filesz,
			    phdr->p_memsz - phdr->p_filesz);
d246 1
a246 1
	 * Retrieve symbols.
d250 1
a250 2
	newpos = elf->e_shoff;
	if (elf_seek(fd, newpos - pos)) {
a253 1
	pos = newpos;
a262 1
	pos += sz;
d283 1
a283 2
			newpos = shp[i].sh_offset;
			if (elf_seek(fd, newpos - pos)) {
a286 1
			pos = newpos;
a291 1
			pos += shp[i].sh_size;
a313 1
#undef NUM_HEADERS
d315 1
a315 1
#endif /* SPARC_BOOT_ELF */
@


