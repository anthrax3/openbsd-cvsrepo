head	1.18;
access;
symbols
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.17.0.4
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.15.0.8
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.6
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.14.0.8
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.6
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.4
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.9.0.26
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.28
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.24
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.22
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.20
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.18
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.16
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.14
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.12
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.7
	UBC:1.3.0.6
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.10
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.8
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.6
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.0.6
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.4
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.2
	OPENBSD_2_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.18
date	2016.03.19.11.34.22;	author mpi;	state Exp;
branches;
next	1.17;
commitid	15xZY6veDWwRM6Iq;

1.17
date	2015.01.11.18.10.33;	author miod;	state Exp;
branches;
next	1.16;
commitid	lzzATTucsIT5BPIH;

1.16
date	2015.01.11.15.29.03;	author miod;	state Exp;
branches;
next	1.15;
commitid	VQauECy07nAL7OWY;

1.15
date	2013.03.21.21.51.00;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2011.04.14.18.27.49;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2011.03.13.00.13.53;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2010.12.14.21.14.46;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2010.07.06.20.41.06;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.29.21.33.54;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.08.14.17.13.57;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.01.17.00.39;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.08.15.15.41.35;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.08.12.00.41.11;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.03.16.00;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.29.03.59.05;	author jason;	state Exp;
branches
	1.3.6.1;
next	1.2;

1.2
date	99.01.11.05.12.00;	author millert;	state Exp;
branches
	1.2.6.1;
next	1.1;

1.1
date	97.09.17.10.46.19;	author downsj;	state Exp;
branches;
next	;

1.2.6.1
date	2001.05.14.21.37.20;	author niklas;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2002.03.28.10.57.11;	author niklas;	state Exp;
branches;
next	1.2.6.3;

1.2.6.3
date	2003.03.27.23.49.26;	author niklas;	state Exp;
branches;
next	1.2.6.4;

1.2.6.4
date	2003.06.07.11.14.44;	author ho;	state Exp;
branches;
next	1.2.6.5;

1.2.6.5
date	2004.02.19.10.49.59;	author niklas;	state Exp;
branches;
next	;

1.3.6.1
date	2002.06.11.03.38.17;	author art;	state Exp;
branches;
next	1.3.6.2;

1.3.6.2
date	2002.10.29.00.28.11;	author art;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Reduces the noise around the global ``ticks'' variable by renaming
all the local ones to ``nticks''.

ok stefan@@, deraadt@@
@
text
@/*	$OpenBSD: promdev.c,v 1.17 2015/01/11 18:10:33 miod Exp $	*/
/*	$NetBSD: promdev.c,v 1.16 1995/11/14 15:04:01 pk Exp $ */

/*
 * Copyright (c) 1993 Paul Kranenburg
 * Copyright (c) 1995 Gordon W. Ross
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Paul Kranenburg.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Note: the `#ifndef BOOTXX' in here serve to queeze the code size
 * of the 1st-stage boot program.
 */
#include <sys/param.h>
#include <sys/reboot.h>
#include <machine/idprom.h>
#include <machine/oldmon.h>
#include <machine/ctlreg.h>

#include <lib/libsa/stand.h>

#include <sparc/stand/common/promdev.h>

/* u_long	_randseed = 1; */


int	obp_close(struct open_file *);
int	obp_strategy(void *, int, daddr32_t, size_t, void *, size_t *);
ssize_t	obp_xmit(struct promdata *, void *, size_t);
ssize_t	obp_recv(struct promdata *, void *, size_t);
int	prom0_close(struct open_file *);
int	prom0_strategy(void *, int, daddr32_t, size_t, void *, size_t *);
void	prom0_iclose(struct saioreq *);
int	prom0_iopen(struct promdata *);
ssize_t	prom0_xmit(struct promdata *, void *, size_t);
ssize_t	prom0_recv(struct promdata *, void *, size_t);

static char	*prom_mapin(u_long, int, int);

int	prom_findnode(int, const char *);
int	prom_findroot(void);
int	prom_firstchild(int);
int	getdevtype(int, char *);
int	prom_getprop(int, char *, void *, int);
int	prom_getproplen(int, char *);
char	*prom_getpropstring(int, char *);
int	prom_nextsibling(int);

static void	prom0_fake(void);

extern struct fs_ops file_system_nfs[];
extern struct fs_ops file_system_cd9660[];
extern struct fs_ops file_system_ufs[];

int
prom_open(struct open_file *f, ...)
{
	return 0;
}

int
prom_ioctl(struct open_file *f, u_long c, void *d)
{
	return EIO;
}

struct devsw devsw[] = {
	{ "prom0", prom0_strategy, prom_open, prom0_close, prom_ioctl },
	{ "prom", obp_strategy, prom_open, obp_close, prom_ioctl }
};

int	ndevs = (sizeof(devsw)/sizeof(devsw[0]));

char	*prom_bootdevice;
char	*prom_bootfile;
int	prom_boothow;

struct	promvec	*promvec;
static int	saveecho;

int
devopen(f, fname, file)
	struct open_file *f;
	const char *fname;
	char **file;
{
	int	error = 0, fd;
	struct	promdata *pd;

	pd = (struct promdata *)alloc(sizeof *pd);

	if (cputyp == CPU_SUN4) {
		error = prom0_iopen(pd);
#ifndef BOOTXX
		pd->xmit = prom0_xmit;
		pd->recv = prom0_recv;
#endif
	} else {
		fd = (promvec->pv_romvec_vers >= 2)
			? (*promvec->pv_v2devops.v2_open)(prom_bootdevice)
			: (*promvec->pv_v0devops.v0_open)(prom_bootdevice);
		if (fd == 0) {
			error = ENXIO;
		} else {
			pd->fd = fd;
#ifndef BOOTXX
			pd->xmit = obp_xmit;
			pd->recv = obp_recv;
#endif
		}
	}

	if (error) {
		printf("Can't open device `%s'\n", prom_bootdevice);
		return (error);
	}

#ifdef BOOTXX
	pd->devtype = DT_BLOCK;
#else /* BOOTXX */
	pd->devtype = getdevtype(fd, prom_bootdevice);
	/* Assume type BYTE is a raw device */
	if (pd->devtype != DT_BYTE)
		*file = (char *)fname;

	if (pd->devtype == DT_NET) {
		bcopy(file_system_nfs, file_system, sizeof(struct fs_ops));
		if ((error = net_open(pd)) != 0) {
			printf("Can't open network device `%s'\n",
				prom_bootdevice);
			return error;
		}
	} else {
		bcopy(file_system_ufs, file_system, sizeof(struct fs_ops));
		bcopy(&file_system_cd9660, file_system + 1, sizeof file_system[0]);
		nfsys = 2;
	}
#endif /* BOOTXX */

	f->f_dev = &devsw[cputyp == CPU_SUN4 ? 0 : 1];
	f->f_devdata = (void *)pd;
	return 0;
}

int
obp_strategy(devdata, flag, dblk, size, buf, rsize)
	void	*devdata;
	int	flag;
	daddr32_t	dblk;
	size_t	size;
	void	*buf;
	size_t	*rsize;
{
	int	error = 0;
	struct	promdata *pd = (struct promdata *)devdata;
	int	fd = pd->fd;

#ifdef DEBUG_PROM
	printf("promstrategy: size=%d dblk=%d\n", size, dblk);
#endif

	if (promvec->pv_romvec_vers >= 2) {
		if (pd->devtype == DT_BLOCK)
			(*promvec->pv_v2devops.v2_seek)(fd, 0, dbtob(dblk));

		*rsize = (*((flag == F_READ) ?
		    (u_int (*)(int, char *, size_t))promvec->pv_v2devops.v2_read :
		    (u_int (*)(int, char *, size_t))promvec->pv_v2devops.v2_write))
		    (fd, buf, size);
	} else {
		int n = (*((flag == F_READ) ?
		    (u_int (*)(int, int, daddr32_t, void *))promvec->pv_v0devops.v0_rbdev :
		    (u_int (*)(int, int, daddr32_t, void *))promvec->pv_v0devops.v0_wbdev))
		    (fd, btodb(size), dblk, buf);
		*rsize = dbtob(n);
	}

#ifdef DEBUG_PROM
	printf("rsize = %x\n", *rsize);
#endif
	return error;
}

/*
 * On old-monitor machines, things work differently.
 */
int
prom0_strategy(devdata, flag, dblk, size, buf, rsize)
	void	*devdata;
	int	flag;
	daddr32_t	dblk;
	size_t	size;
	void	*buf;
	size_t	*rsize;
{
	struct promdata	*pd = devdata;
	struct saioreq	*si;
	struct om_boottable *ops;
	struct devinfo *dip;
	char *dmabuf;
	int si_flag;
	size_t	xcnt, total, chunk;
	int rc = 0;

	si = pd->si;
	ops = si->si_boottab;
	dip = ops->b_devinfo;

#ifdef DEBUG_PROM
	printf("prom_strategy: size=%d dblk=%d\n", size, dblk);
#endif

	dmabuf = dvma_mapin(buf, size);

	/*
	 * Clamp I/O to the maximum DMA transfer size supported by the PROM,
	 * if necessary. Note that we need to round down to a block boundary
	 * as the value is not necessarily a power of two (8216 has been
	 * seen with PROM rev 1.3.)
	 */
	if (dip->d_dmabytes != 0)
		chunk = dbtob(btodb(dip->d_dmabytes));
	else
		chunk = size;

	total = 0;
	while (size != 0) {
		if (size < chunk)
			chunk = size;

		si->si_bn = dblk;
		si->si_ma = dmabuf;
		si->si_cc = chunk;

		si_flag = (flag == F_READ) ? SAIO_F_READ : SAIO_F_WRITE;
		xcnt = (*ops->b_strategy)(si, si_flag);

#ifdef DEBUG_PROM
		printf("disk_strategy: xcnt = %x\n", xcnt);
#endif

		if (xcnt <= 0) {
			rc = EIO;
			break;
		}

		total += xcnt;
		if (xcnt != chunk)
			break;

		size -= chunk;
		dmabuf += chunk;
		dblk += btodb(chunk);
	}

	dvma_mapout(dmabuf, size);

	*rsize = total;
	return rc;
}

int
obp_close(f)
	struct open_file *f;
{
	struct promdata *pd = f->f_devdata;
	register int fd = pd->fd;

#ifndef BOOTXX
	if (pd->devtype == DT_NET)
		net_close(pd);
#endif
	if (promvec->pv_romvec_vers >= 2)
		(void)(*promvec->pv_v2devops.v2_close)(fd);
	else
		(void)(*promvec->pv_v0devops.v0_close)(fd);
	return 0;
}

int
prom0_close(f)
	struct open_file *f;
{
	struct promdata *pd = f->f_devdata;

#ifndef BOOTXX
	if (pd->devtype == DT_NET)
		net_close(pd);
#endif
	prom0_iclose(pd->si);
	pd->si = NULL;
	*romp->echo = saveecho; /* Hmm, probably must go somewhere else */
	return 0;
}

#ifndef BOOTXX
ssize_t
obp_xmit(pd, buf, len)
	struct	promdata *pd;
	void	*buf;
	size_t	len;
{
	return (promvec->pv_romvec_vers >= 2
		? (*promvec->pv_v2devops.v2_write)(pd->fd, buf, len)
		: (*promvec->pv_v0devops.v0_wnet)(pd->fd, len, buf));
}

ssize_t
obp_recv(pd, buf, len)
	struct	promdata *pd;
	void	*buf;
	size_t	len;
{
	int n;

	n = (promvec->pv_romvec_vers >= 2
		? (*promvec->pv_v2devops.v2_read)(pd->fd, buf, len)
		: (*promvec->pv_v0devops.v0_rnet)(pd->fd, len, buf));
	return (n == -2 ? 0 : n);
}

ssize_t
prom0_xmit(pd, buf, len)
	struct	promdata *pd;
	void	*buf;
	size_t	len;
{
	struct saioreq	*si;
	struct saif	*sif;
	char		*dmabuf;
	int		rv;

	si = pd->si;
	sif = si->si_sif;
	if (sif == NULL) {
		printf("xmit: not a network device\n");
		return (-1);
	}
	dmabuf = dvma_mapin(buf, len);
	rv = sif->sif_xmit(si->si_devdata, dmabuf, len);
	dvma_mapout(dmabuf, len);

	return (ssize_t)(rv ? -1 : len);
}

ssize_t
prom0_recv(pd, buf, len)
	struct	promdata *pd;
	void	*buf;
	size_t	len;
{
	struct saioreq	*si;
	struct saif	*sif;
	char		*dmabuf;
	int		rv;

	si = pd->si;
	sif = si->si_sif;
	dmabuf = dvma_mapin(buf, len);
	rv = sif->sif_poll(si->si_devdata, dmabuf);
	dvma_mapout(dmabuf, len);

	return (ssize_t)rv;
}

int
getchar()
{
	char c;
	register int n;

	if (promvec->pv_romvec_vers > 2)
		while ((n = (*promvec->pv_v2devops.v2_read)
			(*promvec->pv_v2bootargs.v2_fd0, (caddr_t)&c, 1)) != 1);
	else {
                /* SUN4 PROM: must turn off local echo */
                struct om_vector *oldpvec = (struct om_vector *)PROM_BASE;
                int saveecho = 0;

                if (CPU_ISSUN4) {
                        saveecho = *(oldpvec->echo);
                        *(oldpvec->echo) = 0;
                }
                c = (*promvec->pv_getchar)();
                if (CPU_ISSUN4)
                        *(oldpvec->echo) = saveecho;
	}

	if (c == '\r')
		c = '\n';
	return (c);
}

int
cngetc(void)
{
	return getchar();
}

int
peekchar(void)
{
	char c;
	register int n;

	if (promvec->pv_romvec_vers > 2) {
		n = (*promvec->pv_v2devops.v2_read)
			(*promvec->pv_v2bootargs.v2_fd0, (caddr_t)&c, 1);
		if (n < 0)
			return -1;
	} else
		c = (*promvec->pv_nbgetchar)();

	if (c == '\r')
		c = '\n';
	return (c);
}
#endif

static void
pv_putchar(int c)
{
	char c0 = c;

	if (promvec->pv_romvec_vers > 2)
		(*promvec->pv_v2devops.v2_write)
			(*promvec->pv_v2bootargs.v2_fd1, &c0, 1);
	else
		(*promvec->pv_putchar)(c);
}

void
putchar(c)
	int c;
{

	if (c == '\n')
		pv_putchar('\r');
	pv_putchar(c);
}

void
_rtt()
{
	promvec->pv_halt();
}

#ifndef BOOTXX
int hz = 1000;

time_t
getsecs(void)
{
	register int nticks = getticks();
	return ((time_t)(nticks / hz));
}

int
getticks(void)
{
	if (promvec->pv_romvec_vers >= 2) {
		char c;
		(void)(*promvec->pv_v2devops.v2_read)
			(*promvec->pv_v2bootargs.v2_fd0, (caddr_t)&c, 0);
	} else {
		(void)(*promvec->pv_nbgetchar)();
	}
	return *(promvec->pv_ticks);
}

struct idprom *
prom_getidprom()
{
	if (cputyp == CPU_SUN4) {
		static struct idprom sun4_idprom;
		u_char *src, *dst;
		int len, x;

		if (sun4_idprom.id_format == 0) {
			dst = (char *)&sun4_idprom;
			src = (char *)AC_IDPROM;
			len = sizeof(struct idprom);
			do {
				x = lduba(src++, ASI_CONTROL);
				*dst++ = x;
			} while (--len > 0);
		}

		return &sun4_idprom;
	} else
		return NULL;
}

void
prom_getether(int fd, u_char *ea)
{
	if (cputyp == CPU_SUN4) {
		struct idprom *idp = prom_getidprom();
		bcopy(idp->id_ether, ea, 6);
	} else if (promvec->pv_romvec_vers <= 2) {
		(void)(*promvec->pv_enaddr)(fd, (char *)ea);
	} else {
		char buf[64];
		snprintf(buf, sizeof buf, "%x mac-address drop swap 6 cmove", ea);
		promvec->pv_fortheval.v2_eval(buf);
	}
}

/*
 * A number of well-known devices on sun4s.
 */
static struct dtab {
	char	*name;
	int	type;
} dtab[] = {
	{ "sd",	DT_BLOCK },
	{ "st",	DT_BYTE },
	{ "xd",	DT_BLOCK },
	{ "xy",	DT_BLOCK },
	{ "fd",	DT_BLOCK },
	{ "le",	DT_NET },
	{ "ie",	DT_NET },
	{ NULL, 0 }
};

int
getdevtype(fd, name)
	int	fd;
	char	*name;
{
	if (promvec->pv_romvec_vers >= 2) {
		int node = (*promvec->pv_v2devops.v2_fd_phandle)(fd);
		char *cp = prom_getpropstring(node, "device_type");
		if (strcmp(cp, "block") == 0)
			return DT_BLOCK;
		else if (strcmp(cp, "network") == 0)
			return DT_NET;
		else if (strcmp(cp, "byte") == 0)
			return DT_BYTE;
	} else {
		struct dtab *dp;
		for (dp = dtab; dp->name; dp++) {
			if (name[0] == dp->name[0] &&
			    name[1] == dp->name[1])
				return dp->type;
		}
	}
	return 0;
}

/*
 * OpenPROM nodes & property routines (from <sparc/autoconf.c>).
 */

int
prom_findnode(int first, const char *name)
{
	int node;

	for (node = first; node != 0; node = prom_nextsibling(node))
		if (strcmp(prom_getpropstring(node, "name"), name) == 0)
			return (node);
	return (0);
}

int
prom_findroot()
{
	static int rootnode;
	int node;

	if ((node = rootnode) == 0 && (node = prom_nextsibling(0)) == 0)
		panic("no PROM root device");
	rootnode = node;
	return (node);
}

int
prom_firstchild(int node)
{
	return promvec->pv_nodeops->no_child(node);
}

int
prom_getprop(int node, char *name, void *buf, int bufsiz)
{
	register struct nodeops *no;
	register int len;

	no = promvec->pv_nodeops;
	len = no->no_proplen(node, name);
	if (len > bufsiz) {
		printf("node %x property %s length %d > %d\n",
		    node, name, len, bufsiz);
		return (0);
	}
	no->no_getprop(node, name, buf);
	return (len);
}

int
prom_getproplen(int node, char *name)
{
	return promvec->pv_nodeops->no_proplen(node, name);
}

/*
 * Return a string property.  There is a (small) limit on the length;
 * the string is fetched into a static buffer which is overwritten on
 * subsequent calls.
 */
char *
prom_getpropstring(int node, char *name)
{
	register int len;
	static char stringbuf[64];

	len = prom_getprop(node, name, (void *)stringbuf, sizeof stringbuf - 1);
	if (len == -1)
		len = 0;
	stringbuf[len] = '\0';	/* usually unnecessary */
	return (stringbuf);
}

int
prom_nextsibling(int node)
{
	return (promvec->pv_nodeops->no_nextnode(node));
}

void
prom_interpret(char *s)
{
	if (promvec->pv_romvec_vers < 2)
		promvec->pv_fortheval.v0_eval(strlen(s), s);
	else
		promvec->pv_fortheval.v2_eval(s);
}

int
prom_makememarr(struct memarr *ap, u_int xmax, int which)
{
	struct v0mlist *mp;
	int node, n;
	char *prop;

	if (which != MEMARR_AVAILPHYS && which != MEMARR_TOTALPHYS)
		panic("makememarr");

	if (CPU_ISSUN4) {
		struct om_vector *oldpvec = (struct om_vector *)PROM_BASE;
		if (ap != NULL && xmax != 0) {
			ap[0].addr_hi = 0;
			ap[0].addr_lo = 0;
			ap[0].len = which == MEMARR_AVAILPHYS ?
			    *oldpvec->memoryAvail : *oldpvec->memorySize;
		}
		return 1;
	}

	switch (n = promvec->pv_romvec_vers) {
	case 0:
		/*
		 * Version 0 PROMs use a linked list to describe these
		 * guys.
		 */
		mp = which == MEMARR_AVAILPHYS ?
		    *promvec->pv_v0mem.v0_physavail :
		    *promvec->pv_v0mem.v0_phystot;

		for (n = 0; mp != NULL; mp = mp->next, n++) {
			if (ap == NULL || n >= xmax)
				continue;
			ap->addr_hi = 0;
			ap->addr_lo = (u_int)mp->addr;
			ap->len = mp->nbytes;
			ap++;
		}
		break;
	default:
		printf("makememarr: hope version %d PROM is like version 2\n",
		    n);
		/* FALLTHROUGH */
	case 3:
	case 2:
		/*
		 * Version 2 PROMs use a property array to describe them.
		 */
		if ((node = prom_findnode(prom_firstchild(prom_findroot()),
		    "memory")) == 0)
			panic("makememarr: cannot find \"memory\" node");
		prop = which == MEMARR_AVAILPHYS ? "available" : "reg";
		n = prom_getproplen(node, prop) / sizeof(struct memarr);
		if (ap != NULL) {
			if (prom_getprop(node, prop, ap,
			    xmax * sizeof(struct memarr)) <= 0)
				panic("makememarr: cannot get property");
		}
		break;
	}

	if (n <= 0)
		panic("makememarr: no memory found");
	return (n);
}
#endif /* BOOTXX */

void
prom_init()
{
	char	*cp, *dp;
#ifndef BOOTXX
	char	*ap;
	int node;
#endif

	if (cputyp == CPU_SUN4) {
		prom0_fake();
		dvma_init();
#ifdef BOOTXX
		pgshift = SUN4_PGSHIFT;
		nbpg = 1 << pgshift;
		pgofset = nbpg - 1;
#endif
	}

	if (promvec->pv_romvec_vers >= 2) {
#ifndef BOOTXX
		static char filestore[16];
#endif

		prom_bootdevice = *promvec->pv_v2bootargs.v2_bootpath;

#ifndef BOOTXX
		cp = *promvec->pv_v2bootargs.v2_bootargs;
		dp = prom_bootfile = filestore;
		while (*cp && *cp != '-')
			*dp++ = *cp++;
		while (dp > prom_bootfile && *--dp == ' ');
		*++dp = '\0';
		ap = cp;
#endif
	} else {
		static char bootstore[16];
		dp = prom_bootdevice = bootstore;
		cp = (*promvec->pv_v0bootargs)->ba_argv[0];
		while (*cp) {
			*dp++ = *cp;
			if (*cp++ == ')')
				break;
		}
		*dp = '\0';
#ifndef BOOTXX
		prom_bootfile = (*promvec->pv_v0bootargs)->ba_kernel;
		ap = (*promvec->pv_v0bootargs)->ba_argv[1];
#endif
	}

#ifndef BOOTXX
	if (ap != NULL && *ap == '-') {
		while (*ap) {
			switch (*ap++) {
			case 'a':
				prom_boothow |= RB_ASKNAME;
				break;
			case 'c':
				prom_boothow |= RB_CONFIG;
				break;
			case 'd':
				prom_boothow |= RB_KDB;
				debug = 1;
				break;
			case 's':
				prom_boothow |= RB_SINGLE;
				break;
			}
		}
	}
#endif

#ifndef BOOTXX
	/*
	 * Find out what type of machine we're running on.
	 *
	 * This process is actually started in srt0.S, which has discovered
	 * the minimal set of machine specific parameters for the 1st-level
	 * boot program (bootxx) to run. The CPU type is either CPU_SUN4 or
	 * CPU_SUN4C at this point; we need to figure out the exact cpu type
	 * and our page size.
	 */

	if (cputyp == CPU_SUN4) {
		pgshift = SUN4_PGSHIFT;
	} else {
		/*
		 * We are either SUN4C, SUN4D, SUN4E or SUN4M.
		 * Use the PROM `compatible' property to determine which.
		 * Absence of the `compatible' property means either sun4c
		 * or sun4e; these can be told apart by checking for the
		 * page size.
		 */

		node = prom_findroot();
		cp = prom_getpropstring(node, "compatible");
		if (*cp == '\0' || strcmp(cp, "sun4c") == 0) {
			char tmpstr[24];

			snprintf(tmpstr, sizeof tmpstr, "pagesize %x l!",
			    (u_long)&nbpg);
			prom_interpret(tmpstr);
			if (nbpg == 1 << SUN4_PGSHIFT) {
				pgshift = SUN4_PGSHIFT;
				/* if netbooted, PROM won't output a cr */
				printf("\n");
			} else
				pgshift = SUN4CM_PGSHIFT;
			/* note that we don't bother telling 4e apart from 4c */
			cputyp = CPU_SUN4C;
		} else if (strcmp(cp, "sun4m") == 0) {
			cputyp = CPU_SUN4M;
			pgshift = SUN4CM_PGSHIFT;
#ifdef CPU_SUN4D
		} else if (strcmp(cp, "sun4d") == 0) {
			cputyp = CPU_SUN4D;
			pgshift = SUN4CM_PGSHIFT;
#endif
		} else
			panic("Unknown CPU type (compatible=`%s')", cp);
	}

	nbpg = 1 << pgshift;
	pgofset = nbpg - 1;
#endif
}

/*
 * Old monitor routines
 */

#include <machine/pte.h>

struct saioreq prom_si;
static int promdev_inuse;

int
prom0_iopen(pd)
	struct promdata	*pd;
{
	struct om_bootparam *bp;
	struct om_boottable *ops;
	struct devinfo *dip;
	struct saioreq *si;
	int	error;

	if (promdev_inuse)
		return(EMFILE);

	bp = *romp->bootParam;
	ops = bp->bootTable;
	dip = ops->b_devinfo;

#ifdef DEBUG_PROM
	printf("Boot device type: %s\n", ops->b_desc);
	printf("d_devbytes=%d\n", dip->d_devbytes);
	printf("d_dmabytes=%d\n", dip->d_dmabytes);
	printf("d_localbytes=%d\n", dip->d_localbytes);
	printf("d_stdcount=%d\n", dip->d_stdcount);
	printf("d_stdaddrs[%d]=%x\n", bp->ctlrNum, dip->d_stdaddrs[bp->ctlrNum]);
	printf("d_devtype=%d\n", dip->d_devtype);
	printf("d_maxiobytes=%d\n", dip->d_maxiobytes);
#endif

	si = &prom_si;
	bzero((caddr_t)si, sizeof(*si));
	si->si_boottab = ops;
	si->si_ctlr = bp->ctlrNum;
	si->si_unit = bp->unitNum;
	si->si_boff = bp->partNum;

	if (si->si_ctlr > dip->d_stdcount) {
		printf("Invalid controller number\n");
		return(ENXIO);
	}

	if (dip->d_devbytes) {
		si->si_devaddr = prom_mapin(dip->d_stdaddrs[si->si_ctlr],
			dip->d_devbytes, dip->d_devtype);
#ifdef	DEBUG_PROM
		printf("prom_iopen: devaddr=0x%x pte=0x%x\n",
			si->si_devaddr,
			getpte((u_long)si->si_devaddr & ~PAGE_MASK));
#endif
	}

	if (dip->d_dmabytes) {
		si->si_dmaaddr = dvma_alloc(dip->d_dmabytes);
#ifdef	DEBUG_PROM
		printf("prom_iopen: dmaaddr=0x%x\n", si->si_dmaaddr);
#endif
	}

	if (dip->d_localbytes) {
		si->si_devdata = alloc(dip->d_localbytes);
#ifdef	DEBUG_PROM
		printf("prom_iopen: devdata=0x%x\n", si->si_devdata);
#endif
	}

	/* OK, call the PROM device open routine. */
	error = (*ops->b_open)(si);
	if (error != 0) {
		printf("prom_iopen: \"%s\" error=%d\n",
			   ops->b_desc, error);
		return (ENXIO);
	}
#ifdef	DEBUG_PROM
	printf("prom_iopen: succeeded, error=%d\n", error);
#endif

	pd->si = si;
	promdev_inuse++;
	return (0);
}

void
prom0_iclose(si)
	struct saioreq *si;
{
	struct om_boottable *ops;
	struct devinfo *dip;

	if (promdev_inuse == 0)
		return;

	ops = si->si_boottab;
	dip = ops->b_devinfo;

	(*ops->b_close)(si);

	if (si->si_dmaaddr) {
		dvma_free(si->si_dmaaddr, dip->d_dmabytes);
		si->si_dmaaddr = NULL;
	}

	promdev_inuse = 0;
}

static struct mapinfo {
	int maptype;
	int pgtype;
	int base;
} prom_mapinfo[] = {
	{ MAP_MAINMEM,   PG_OBMEM, 0 },
	{ MAP_OBIO,      PG_OBIO,  0 },
	{ MAP_MBMEM,     PG_VME16, 0xFF000000 },
	{ MAP_MBIO,      PG_VME16, 0xFFFF0000 },
	{ MAP_VME16A16D, PG_VME16, 0xFFFF0000 },
	{ MAP_VME16A32D, PG_VME32, 0xFFFF0000 },
	{ MAP_VME24A16D, PG_VME16, 0xFF000000 },
	{ MAP_VME24A32D, PG_VME32, 0xFF000000 },
	{ MAP_VME32A16D, PG_VME16, 0 },
	{ MAP_VME32A32D, PG_VME32, 0 },
};
static int prom_mapinfo_cnt = sizeof(prom_mapinfo) / sizeof(prom_mapinfo[0]);

/* The virtual address we will use for PROM device mappings. */
static u_long prom_devmap = MONSHORTSEG;

static char *
prom_mapin(physaddr, length, maptype)
	u_long physaddr;
	int length, maptype;
{
	int i, pa, pte, va;

	if (length > (4*PAGE_SIZE))
		panic("prom_mapin: length=%d", length);

	for (i = 0; i < prom_mapinfo_cnt; i++)
		if (prom_mapinfo[i].maptype == maptype)
			goto found;
	panic("prom_mapin: invalid maptype %d", maptype);
found:

	pte = prom_mapinfo[i].pgtype;
	pte |= (PG_V|PG_W|PG_S|PG_NC);
	pa = prom_mapinfo[i].base;
	pa += physaddr;
	pte |= ((pa >> PAGE_SHIFT) & PG_PFNUM);

	va = prom_devmap;
	do {
		setpte(va, pte);
		va += PAGE_SIZE;
		pte += 1;
		length -= PAGE_SIZE;
	} while (length > 0);
	return ((char *)(prom_devmap | (pa & PAGE_MASK)));
}

void
prom0_fake()
{
static	struct promvec promvecstore;

	promvec = &promvecstore;

	promvec->pv_stdin = romp->inSource;
	promvec->pv_stdout = romp->outSink;
	promvec->pv_putchar = romp->putChar;
	promvec->pv_putstr = romp->fbWriteStr;
	promvec->pv_nbgetchar = romp->mayGet;
	promvec->pv_getchar = romp->getChar;
	promvec->pv_romvec_vers = 0;            /* eek! */
	promvec->pv_reboot = romp->reBoot;
	promvec->pv_abort = romp->abortEntry;
	promvec->pv_setctxt = romp->setcxsegmap;
	promvec->pv_v0bootargs = (struct v0bootargs **)(romp->bootParam);
	promvec->pv_halt = romp->exitToMon;
	promvec->pv_ticks = romp->nmiClock;
	saveecho = *romp->echo;
	*romp->echo = 0;
}
@


1.17
log
@When using sun4 PROM I/O routines, make sure we never attempt to transfer more
than the maximum DMA transfer size the PROM reports.

Crank version to 2.9.
@
text
@d1 1
a1 1
/*	$OpenBSD: promdev.c,v 1.16 2015/01/11 15:29:03 miod Exp $	*/
d479 2
a480 2
	register int ticks = getticks();
	return ((time_t)(ticks / hz));
@


1.16
log
@Make sure to initialize nbpg to a sensible value in bootxx, when running on
a sun4 system - the prom i/o routines depend on it.
@
text
@d1 1
a1 1
/*	$OpenBSD: promdev.c,v 1.15 2013/03/21 21:51:00 deraadt Exp $	*/
d224 5
a228 3
	char	*dmabuf;
	int	si_flag;
	size_t	xcnt;
d232 1
d240 19
a258 3
	si->si_bn = dblk;
	si->si_ma = dmabuf;
	si->si_cc = size;
d260 2
a261 3
	si_flag = (flag == F_READ) ? SAIO_F_READ : SAIO_F_WRITE;
	xcnt = (*ops->b_strategy)(si, si_flag);
	dvma_mapout(dmabuf, size);
d264 1
a264 1
	printf("disk_strategy: xcnt = %x\n", xcnt);
d267 15
a281 2
	if (xcnt <= 0)
		return (EIO);
d283 2
a284 2
	*rsize = xcnt;
	return (0);
@


1.15
log
@NBPG -> PAGE_SIZE, PGSHIFT -> PAGE_SHIFT, PGOFSET -> PAGE_MASK
@
text
@d1 1
a1 1
/*	$OpenBSD: promdev.c,v 1.14 2011/04/14 18:27:49 miod Exp $	*/
d714 5
a796 11
#ifdef BOOTXX
		char tmpstr[24];

		snprintf(tmpstr, sizeof tmpstr, "pagesize %x l!",
		    (u_long)&nbpg);
		prom_interpret(tmpstr);
		if (nbpg == 1 << SUN4_PGSHIFT)
			pgshift = SUN4_PGSHIFT;
		else
			pgshift = SUN4CM_PGSHIFT;
#else
a822 1
#endif	/* BOOTXX */
@


1.14
log
@Sprinkle prototypes, kill unused locals, and stop contributing to global
warning.
@
text
@d1 1
a1 1
/*	$OpenBSD: promdev.c,v 1.13 2011/03/13 00:13:53 deraadt Exp $	*/
d892 1
a892 1
			getpte((u_long)si->si_devaddr & ~PGOFSET));
d977 1
a977 1
	if (length > (4*NBPG))
d990 1
a990 1
	pte |= ((pa >> PGSHIFT) & PG_PFNUM);
d995 1
a995 1
		va += NBPG;
d997 1
a997 1
		length -= NBPG;
d999 1
a999 1
	return ((char *)(prom_devmap | (pa & PGOFSET)));
@


1.13
log
@Change daddr_t to daddr32_t.  The bootblocks on our architectures only
do 32-bit block spanning.  If later on we get some that can/should do
64-bit, that can be done now using daddr64_t (but of course, we are taking
this step to finalize the daddr_t 64-bit conversion).
ok miod krw
@
text
@d1 1
a1 1
/*	$OpenBSD: promdev.c,v 1.12 2010/12/14 21:14:46 kettenis Exp $	*/
d705 1
a705 1
	char	*ap, *cp, *dp;
d707 1
d717 1
d719 1
d965 1
a965 1
static prom_mapinfo_cnt = sizeof(prom_mapinfo) / sizeof(prom_mapinfo[0]);
@


1.12
log
@There is no "struct filesystem"; uncovered by gcc4.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: promdev.c,v 1.11 2010/07/06 20:41:06 miod Exp $	*/
d53 1
a53 1
int	obp_strategy(void *, int, daddr_t, size_t, void *, size_t *);
d57 1
a57 1
int	prom0_strategy(void *, int, daddr_t, size_t, void *, size_t *);
d174 1
a174 1
	daddr_t	dblk;
d197 2
a198 2
		    (u_int (*)(int, int, daddr_t, void *))promvec->pv_v0devops.v0_rbdev :
		    (u_int (*)(int, int, daddr_t, void *))promvec->pv_v0devops.v0_wbdev))
d216 1
a216 1
	daddr_t	dblk;
@


1.11
log
@sun4e support in the bootblocks, derived from a diff from jason@@ 7 years ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: promdev.c,v 1.10 2010/06/29 21:33:54 miod Exp $	*/
d76 3
a78 3
extern struct filesystem file_system_nfs[];
extern struct filesystem file_system_cd9660[];
extern struct filesystem file_system_ufs[];
@


1.10
log
@In the boot blocks, stop assuming we have a 1:1 mapping of low physical
memory, but instead gather memory layout information and work with the MMU
(or the PROM) to make sure we can actually load the kernel image in a proper
contiguous physical memory area.

In order to do this, we look at the kernel image twice; during the first pass,
the kernel footprint is computed, and then after making sure it can be
loaded, the second pass loads the actual image.

Since such a logic doesn't work on media which can not seek backwards, such
as tapes, we check for the boot device being a tape and, in that case, assume
a fixed (generous) image size and don't load the kernel symbol table (to
avoid seeking backwards); since tape boot is supposed to be only used to
boot bsd.rd, this is something we can live with.

While there, lower the address the boot blocks are loaded in memory, because
the last crank did not work with some early sun4c OpenPROM, which only
map about 3.5MB of memory.

Memory games logic from NetBSD, tape handling by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: promdev.c,v 1.9 2003/08/14 17:13:57 deraadt Exp $	*/
d773 3
a775 2
	 * boot program (bootxx) to run. The page size has already been set
	 * and the CPU type is either CPU_SUN4 or CPU_SUN4C.
d778 10
a787 2
	if (cputyp == CPU_SUN4)
		return;
d789 2
a790 5
	/*
	 * We have SUN4C, SUN4M or SUN4D.
	 * Use the PROM `compatible' property to determine which.
	 * Absence of the `compatible' property means `sun4c'.
	 */
d792 27
a818 6
	node = prom_findroot();
	cp = prom_getpropstring(node, "compatible");
	if (*cp == '\0' || strcmp(cp, "sun4c") == 0)
		cputyp = CPU_SUN4C;
	else if (strcmp(cp, "sun4m") == 0)
		cputyp = CPU_SUN4M;
d820 3
a822 2
	else if (strcmp(cp, "sun4d") == 0)
		cputyp = CPU_SUN4D;
d824 7
a830 2
	else
		printf("Unknown CPU type (compatible=`%s')\n", cp);
@


1.9
log
@partial proto repairs
@
text
@d1 1
a1 1
/*	$OpenBSD: promdev.c,v 1.8 2003/06/01 17:00:39 deraadt Exp $	*/
d65 3
d69 4
a72 2
int	getprop(int, char *, void *, int);
char	*getpropstring(int, char *);
a105 62
void
prom_init()
{
	register char	*ap, *cp, *dp;

	if (cputyp == CPU_SUN4)
		prom0_fake();

	if (promvec->pv_romvec_vers >= 2) {
		static char filestore[16];

		prom_bootdevice = *promvec->pv_v2bootargs.v2_bootpath;

#ifndef BOOTXX
		cp = *promvec->pv_v2bootargs.v2_bootargs;
		dp = prom_bootfile = filestore;
		while (*cp && *cp != '-')
			*dp++ = *cp++;
		while (dp > prom_bootfile && *--dp == ' ');
		*++dp = '\0';
		ap = cp;
#endif
	} else {
		static char bootstore[16];
		dp = prom_bootdevice = bootstore;
		cp = (*promvec->pv_v0bootargs)->ba_argv[0];
		while (*cp) {
			*dp++ = *cp;
			if (*cp++ == ')')
				break;
		}
		*dp = '\0';
#ifndef BOOTXX
		prom_bootfile = (*promvec->pv_v0bootargs)->ba_kernel;
		ap = (*promvec->pv_v0bootargs)->ba_argv[1];
#endif
	}

#ifndef BOOTXX
	if (ap == NULL || *ap != '-')
		return;

	while (*ap) {
		switch (*ap++) {
		case 'a':
			prom_boothow |= RB_ASKNAME;
			break;
		case 'c':
			prom_boothow |= RB_CONFIG;
			break;
		case 'd':
			prom_boothow |= RB_KDB;
			debug = 1;
			break;
		case 's':
			prom_boothow |= RB_SINGLE;
			break;
		}
	}
#endif
}

d236 1
a236 1
	
d365 1
a365 1
 
d377 1
a377 1
                }       
d387 1
a387 1
 
d399 1
a399 1
 
d430 1
a430 1
 
d465 2
a466 2
void
prom_getether(int fd, u_char *ea)
d482 12
a493 1
		bcopy(sun4_idprom.id_ether, ea, 6);
a502 1

d511 1
a511 1
	{ "st",	DT_BLOCK },
d527 1
a527 1
		char *cp = getpropstring(node, "device_type");
d548 1
d550 2
a551 1
getprop(node, name, buf, bufsiz)
d553 27
a579 3
	char *name;
	void *buf;
	register int bufsiz;
d595 6
d607 1
a607 3
getpropstring(node, name)
	int node;
	char *name;
d612 1
a612 1
	len = getprop(node, name, (void *)stringbuf, sizeof stringbuf - 1);
d618 82
d702 99
a837 2
	dvma_init();

d921 1
a921 1
	{ MAP_MBIO,      PG_VME16, 0xFFFF0000 }, 
@


1.8
log
@strcpy/strcat/sprintf removal in all bootblocks.  various testing by
various people.  outside of some messy things in src/gnu, only one
thing in the main tree now violates this rule: bind
@
text
@d1 1
a1 1
/*	$OpenBSD: promdev.c,v 1.7 2002/08/15 15:41:35 millert Exp $	*/
d75 11
a85 2
int prom_open(struct open_file *f, ...) { return 0; }
int prom_ioctl(struct open_file *f, u_long c, void *d) { return EIO; }
d248 4
a251 4
		*rsize = (*((flag == F_READ)
				? (u_int (*)())promvec->pv_v2devops.v2_read
				: (u_int (*)())promvec->pv_v2devops.v2_write
			 ))(fd, buf, size);
d253 4
a256 4
		int n = (*((flag == F_READ)
				? (u_int (*)())promvec->pv_v0devops.v0_rbdev
				: (u_int (*)())promvec->pv_v0devops.v0_wbdev
			))(fd, btodb(size), dblk, buf);
d446 1
a446 1
cngetc()
d452 1
a452 1
peekchar()
d472 1
a472 2
pv_putchar(c)
	int c;
d503 1
a503 1
getsecs()
d510 1
a510 1
getticks()
d523 1
a523 2
prom_getether(fd, ea)
	u_char *ea;
@


1.7
log
@One line fix to make boot link from miod whose main NFS server
is down at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: promdev.c,v 1.5 2002/03/14 03:16:00 millert Exp $	*/
d537 1
a537 1
		sprintf(buf, "%x mac-address drop swap 6 cmove", ea);
@


1.6
log
@During prompts on sun4 class machines, disable local echo to prevent
ddoouubbllyy written characters.
Modeled from the kernel's prom console routines.
@
text
@d419 1
a419 1
                extern struct om_vector *oldpvec;
@


1.5
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: promdev.c,v 1.4 2002/03/14 01:26:44 millert Exp $	*/
d417 13
a429 2
	else
		c = (*promvec->pv_getchar)();
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: promdev.c,v 1.3 2001/01/29 03:59:05 jason Exp $	*/
d513 2
a514 2
			dst = (char*)&sun4_idprom;
			src = (char*)AC_IDPROM;
d783 1
a783 1
	return ((char*)(prom_devmap | (pa & PGOFSET)));
@


1.3
log
@bring sparc into the 20th century, add support for 'boot -c' (BOOT_CONFIG)
@
text
@d1 1
a1 1
/*	$OpenBSD: promdev.c,v 1.2 1999/01/11 05:12:00 millert Exp $	*/
d52 16
a67 16
int	obp_close __P((struct open_file *));
int	obp_strategy __P((void *, int, daddr_t, size_t, void *, size_t *));
ssize_t	obp_xmit __P((struct promdata *, void *, size_t));
ssize_t	obp_recv __P((struct promdata *, void *, size_t));
int	prom0_close __P((struct open_file *));
int	prom0_strategy __P((void *, int, daddr_t, size_t, void *, size_t *));
void	prom0_iclose __P((struct saioreq *));
int	prom0_iopen __P((struct promdata *));
ssize_t	prom0_xmit __P((struct promdata *, void *, size_t));
ssize_t	prom0_recv __P((struct promdata *, void *, size_t));

static char	*prom_mapin __P((u_long, int, int));

int	getdevtype __P((int, char *));
int	getprop __P((int, char *, void *, int));
char	*getpropstring __P((int, char *));
d69 1
a69 1
static void	prom0_fake __P((void));
d75 2
a76 2
int prom_open __P((struct open_file *f, ...)) { return 0; }
int prom_ioctl __P((struct open_file *f, u_long c, void *d)) { return EIO; }
@


1.3.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: promdev.c,v 1.3 2001/01/29 03:59:05 jason Exp $	*/
d52 16
a67 16
int	obp_close(struct open_file *);
int	obp_strategy(void *, int, daddr_t, size_t, void *, size_t *);
ssize_t	obp_xmit(struct promdata *, void *, size_t);
ssize_t	obp_recv(struct promdata *, void *, size_t);
int	prom0_close(struct open_file *);
int	prom0_strategy(void *, int, daddr_t, size_t, void *, size_t *);
void	prom0_iclose(struct saioreq *);
int	prom0_iopen(struct promdata *);
ssize_t	prom0_xmit(struct promdata *, void *, size_t);
ssize_t	prom0_recv(struct promdata *, void *, size_t);

static char	*prom_mapin(u_long, int, int);

int	getdevtype(int, char *);
int	getprop(int, char *, void *, int);
char	*getpropstring(int, char *);
d69 1
a69 1
static void	prom0_fake(void);
d75 2
a76 2
int prom_open(struct open_file *f, ...) { return 0; }
int prom_ioctl(struct open_file *f, u_long c, void *d) { return EIO; }
d513 2
a514 2
			dst = (char *)&sun4_idprom;
			src = (char *)AC_IDPROM;
d783 1
a783 1
	return ((char *)(prom_devmap | (pa & PGOFSET)));
@


1.3.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: promdev.c,v 1.3.6.1 2002/06/11 03:38:17 art Exp $	*/
d417 2
a418 13
	else {
                /* SUN4 PROM: must turn off local echo */
                struct om_vector *oldpvec = (struct om_vector *)PROM_BASE;
                int saveecho = 0;

                if (CPU_ISSUN4) {
                        saveecho = *(oldpvec->echo);
                        *(oldpvec->echo) = 0;
                }       
                c = (*promvec->pv_getchar)();
                if (CPU_ISSUN4)
                        *(oldpvec->echo) = saveecho;
	}
@


1.2
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: promdev.c,v 1.1 1997/09/17 10:46:19 downsj Exp $	*/
d139 2
a140 2
		case 's':
			prom_boothow |= RB_SINGLE;
d145 3
@


1.2.6.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: promdev.c,v 1.3 2001/01/29 03:59:05 jason Exp $	*/
d139 2
a140 2
		case 'c':
			prom_boothow |= RB_CONFIG;
a144 3
			break;
		case 's':
			prom_boothow |= RB_SINGLE;
@


1.2.6.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 16
a67 16
int	obp_close(struct open_file *);
int	obp_strategy(void *, int, daddr_t, size_t, void *, size_t *);
ssize_t	obp_xmit(struct promdata *, void *, size_t);
ssize_t	obp_recv(struct promdata *, void *, size_t);
int	prom0_close(struct open_file *);
int	prom0_strategy(void *, int, daddr_t, size_t, void *, size_t *);
void	prom0_iclose(struct saioreq *);
int	prom0_iopen(struct promdata *);
ssize_t	prom0_xmit(struct promdata *, void *, size_t);
ssize_t	prom0_recv(struct promdata *, void *, size_t);

static char	*prom_mapin(u_long, int, int);

int	getdevtype(int, char *);
int	getprop(int, char *, void *, int);
char	*getpropstring(int, char *);
d69 1
a69 1
static void	prom0_fake(void);
d75 2
a76 2
int prom_open(struct open_file *f, ...) { return 0; }
int prom_ioctl(struct open_file *f, u_long c, void *d) { return EIO; }
d513 2
a514 2
			dst = (char *)&sun4_idprom;
			src = (char *)AC_IDPROM;
d783 1
a783 1
	return ((char *)(prom_devmap | (pa & PGOFSET)));
@


1.2.6.3
log
@Sync the SMP branch with 3.3
@
text
@d417 2
a418 13
	else {
                /* SUN4 PROM: must turn off local echo */
                struct om_vector *oldpvec = (struct om_vector *)PROM_BASE;
                int saveecho = 0;

                if (CPU_ISSUN4) {
                        saveecho = *(oldpvec->echo);
                        *(oldpvec->echo) = 0;
                }       
                c = (*promvec->pv_getchar)();
                if (CPU_ISSUN4)
                        *(oldpvec->echo) = saveecho;
	}
@


1.2.6.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: promdev.c,v 1.2.6.3 2003/03/27 23:49:26 niklas Exp $	*/
d537 1
a537 1
		snprintf(buf, sizeof buf, "%x mac-address drop swap 6 cmove", ea);
@


1.2.6.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d75 2
a76 11
int
prom_open(struct open_file *f, ...)
{
	return 0;
}

int
prom_ioctl(struct open_file *f, u_long c, void *d)
{
	return EIO;
}
d239 4
a242 4
		*rsize = (*((flag == F_READ) ?
		    (u_int (*)(int, char *, size_t))promvec->pv_v2devops.v2_read :
		    (u_int (*)(int, char *, size_t))promvec->pv_v2devops.v2_write))
		    (fd, buf, size);
d244 4
a247 4
		int n = (*((flag == F_READ) ?
		    (u_int (*)(int, int, daddr_t, void *))promvec->pv_v0devops.v0_rbdev :
		    (u_int (*)(int, int, daddr_t, void *))promvec->pv_v0devops.v0_wbdev))
		    (fd, btodb(size), dblk, buf);
d437 1
a437 1
cngetc(void)
d443 1
a443 1
peekchar(void)
d463 2
a464 1
pv_putchar(int c)
d495 1
a495 1
getsecs(void)
d502 1
a502 1
getticks(void)
d515 2
a516 1
prom_getether(int fd, u_char *ea)
@


1.1
log
@Reorganizaed bootblocks.  Builds like hp300 now.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d759 1
a759 1
		panic("prom_mapin: length=%d\n", length);
d764 1
a764 1
	panic("prom_mapin: invalid maptype %d\n", maptype);
@

