head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.12
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.10
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.6
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.8
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.15.0.28
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.24
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.22
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.20
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.18
	OPENBSD_5_0:1.15.0.16
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.14
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.12
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.8
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.10
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.6
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.16
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.14
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.12
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.10
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.8
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.6
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	SMP:1.6.0.2
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	UBC:1.4.0.4
	UBC_SYNC_B:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4;
locks; strict;
comment	@ * @;


1.16
date	2014.04.26.06.17.26;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2007.10.21.17.30.18;	author drahn;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.21.15.17.29;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.15.01.06.13;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.09.21.36.05;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.09.21.23.53;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.08.19.26.37;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.08.16.25.25;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.08.16.11.57;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.08.16.05.32;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.27.17.40.19;	author drahn;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2003.02.20.16.48.25;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.15.09.01.59;	author deraadt;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2002.09.15.02.02.44;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.09.05.39.01;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.08.16.02.14;	author miod;	state Exp;
branches;
next	;

1.4.4.1
date	2003.05.19.21.49.44;	author tedu;	state Exp;
branches;
next	;

1.6.2.1
date	2003.04.19.19.17.49;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2003.05.13.19.41.07;	author ho;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2004.02.19.10.49.57;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.16
log
@remove a duplicate break statement
@
text
@/*	$OpenBSD: db_disasm.c,v 1.15 2007/10/21 17:30:18 drahn Exp $	*/
/*
 * Copyright (c) 1996, 2001, 2003 Dale Rahn. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/systm.h>

#include <machine/db_machdep.h>

#include <ddb/db_access.h>
#include <ddb/db_sym.h>
#include <ddb/db_variables.h>
#include <ddb/db_interface.h>
#include <ddb/db_output.h>

enum opf {
	Opf_INVALID,
	Opf_A,
	Opf_A0,
	Opf_B,
	Opf_BI,
	Opf_BI1,
	Opf_BO,
	Opf_CRM,
	Opf_D,
	Opf_S,
	Opf_FM,
	Opf_LK,
	Opf_RC,
	Opf_AA,
	Opf_LI,
	Opf_OE,
	Opf_SR,
	Opf_TO,
	Opf_SIMM,
	Opf_UIMM,
	Opf_d,
	Opf_crbA,
	Opf_crbB,
	Opf_crbD,
	Opf_crfD,
	Opf_crfS,
	Opf_spr,
	Opf_tbr,

	Opf_BD,
	Opf_C,

	Opf_NB,

	Opf_sh,
	Opf_SH,
	Opf_mb,
	Opf_MB,
	Opf_ME,
};


struct db_field {
	char *name;
	enum opf opf;
} db_fields[] = {
	{ "A",		Opf_A },
	{ "A0",		Opf_A0 },
	{ "B",		Opf_B },
	{ "D",		Opf_D },
	{ "S",		Opf_S },
	{ "AA",		Opf_AA },
	{ "LI",		Opf_LI },
	{ "BD",		Opf_BD },
	{ "BI",		Opf_BI },
	{ "BI1",	Opf_BI1 },
	{ "BO",		Opf_BO },
	{ "CRM",	Opf_CRM },
	{ "FM",		Opf_FM },
	{ "LK",		Opf_LK },
	{ "MB",		Opf_MB },
	{ "ME",		Opf_ME },
	{ "NB",		Opf_NB },
	{ "OE",		Opf_OE },
	{ "RC",		Opf_RC },
	{ "SH",		Opf_SH },
	{ "SR",		Opf_SR },
	{ "TO",		Opf_TO },
	{ "SIMM",	Opf_SIMM },
	{ "UIMM",	Opf_UIMM },
	{ "crbA",	Opf_crbA },
	{ "crbB",	Opf_crbB },
	{ "crbD",	Opf_crbD },
	{ "crfD",	Opf_crfD },
	{ "crfS",	Opf_crfS },
	{ "d",		Opf_d },
	{ "mb",		Opf_mb },
	{ "sh",		Opf_sh },
	{ "spr",	Opf_spr },
	{ "tbr",	Opf_tbr },
	{ NULL,		0 }
};

struct opcode {
	char *name;
	u_int32_t mask;
	u_int32_t code;
	char *decode_str;
};

typedef u_int32_t instr_t;
typedef void (op_class_func) (u_int32_t addr, instr_t instr);

u_int32_t extract_field(u_int32_t value, u_int32_t base, u_int32_t width);
void disasm_fields(u_int32_t addr, const struct opcode *popcode, instr_t instr,
    char *disasm_str, size_t bufsize);
void disasm_process_field(u_int32_t addr, instr_t instr, char **ppfmt,
    char *ppoutput, size_t bufsize);
void dis_ppc(u_int32_t addr, const struct opcode *opcodeset, instr_t instr);


op_class_func op_ill, op_base;
op_class_func op_cl_x13, op_cl_x1e, op_cl_x1f;
op_class_func op_cl_x3a, op_cl_x3b;
op_class_func op_cl_x3e, op_cl_x3f;

op_class_func *opcodes_base[] = {
/*x00*/	op_ill,		op_ill,		op_base,	op_ill,
/*x04*/	op_ill,		op_ill,		op_ill,		op_base,
/*x08*/	op_base,	op_base,	op_base,	op_base,
/*x0C*/	op_base,	op_base,	op_base/*XXX*/,	op_base/*XXX*/,
/*x10*/	op_base,	op_base,	op_base,	op_cl_x13,
/*x14*/	op_base,	op_base,	op_ill,		op_base,
/*x18*/	op_base,	op_base,	op_base,	op_base,
/*x1C*/	op_base,	op_base,	op_cl_x1e,	op_cl_x1f,
/*x20*/	op_base,	op_base,	op_base,	op_base,
/*x24*/	op_base,	op_base,	op_base,	op_base,
/*x28*/	op_base,	op_base,	op_base,	op_base,
/*x2C*/	op_base,	op_base,	op_base,	op_base,
/*x30*/	op_base,	op_base,	op_base,	op_base,
/*x34*/	op_base,	op_base,	op_base,	op_base,
/*x38*/	op_ill,		op_ill,		op_cl_x3a,	op_cl_x3b,
/*x3C*/	op_ill,		op_ill,		op_cl_x3e,	op_cl_x3f
};


/* This table could be modified to make significant the "reserved" fields
 * of the opcodes, But I didn't feel like it when typing in the table,
 * I would recommend that this table be looked over for errors,
 * This was derived from the table in Appendix A.2 of (Mot part # MPCFPE/AD)
 * PowerPC Microprocessor Family: The Programming Environments
 */
	
const struct opcode opcodes[] = {
	{ "tdi",	0xfc000000, 0x08000000, " %{TO},%{A},%{SIMM}" },
	{ "twi",	0xfc000000, 0x0c000000, " %{TO},%{A},%{SIMM}" },

	{ "mulli",	0xfc000000, 0x1c000000, " %{D},%{A},%{SIMM}" },
	{ "subfic",	0xfc000000, 0x20000000, " %{D},%{A},%{SIMM}" },
	{ "cmpli",	0xff800000, 0x28000000, " %{A},%{UIMM}" },
	{ "cmpli",	0xfc400000, 0x28000000, " %{crfD}%{A}, %{UIMM}" },
	{ "cmpi",	0xff800000, 0x2c000000, " %{A},%{SIMM}"},
	{ "cmpi",	0xfc400000, 0x2c000000, " %{crfD}%{A},%{SIMM}" },
	{ "addic",	0xfc000000, 0x30000000, " %{D},%{A},%{SIMM}" },
	{ "addic.",	0xfc000000, 0x34000000, " %{D},%{A},%{SIMM}" },
	{ "addi",	0xfc000000, 0x38000000, " %{D},%{A0}%{SIMM}" },
	{ "addis",	0xfc000000, 0x3c000000, " %{D},%{A0}%{SIMM}" },
	{ "sc",		0xffffffff, 0x44000002, "" },
	{ "b",		0xfc000000, 0x40000000, "%{BO}%{LK}%{AA} %{BI}%{BD}" },
	{ "b",		0xfc000000, 0x48000000, "%{LK}%{AA} %{LI}" },

	{ "rlwimi",	0xfc000000, 0x50000000, "%{RC} %{A},%{S},%{SH},%{MB},%{ME}" },
	{ "rlwinm",	0xfc000000, 0x54000000, "%{RC} %{A},%{S},%{SH},%{MB},%{ME}" },
	{ "rlwnm",	0xfc000000, 0x5c000000, "%{RC} %{A},%{S},%{SH},%{MB},%{ME}" },

	{ "ori",	0xfc000000, 0x60000000, " %{A},%{S},%{UIMM}" },
	{ "oris",	0xfc000000, 0x64000000, " %{A},%{S},%{UIMM}" },
	{ "xori",	0xfc000000, 0x68000000, " %{A},%{S},%{UIMM}" },
	{ "xoris",	0xfc000000, 0x6c000000, " %{A},%{S},%{UIMM}" },

	{ "andi.",	0xfc000000, 0x70000000, " %{A},%{S},%{UIMM}" },
	{ "andis.",	0xfc000000, 0x74000000, " %{A},%{S},%{UIMM}" },

	{ "lwz",	0xfc000000, 0x80000000, " %{D},%{d}(%{A})" },
	{ "lwzu",	0xfc000000, 0x84000000, " %{D},%{d}(%{A})" },
	{ "lbz",	0xfc000000, 0x88000000, " %{D},%{d}(%{A})" },
	{ "lbzu",	0xfc000000, 0x8c000000, " %{D},%{d}(%{A})" },
	{ "stw",	0xfc000000, 0x90000000, " %{S},%{d}(%{A})" },
	{ "stwu",	0xfc000000, 0x94000000, " %{S},%{d}(%{A})" },
	{ "stb",	0xfc000000, 0x98000000, " %{S},%{d}(%{A})" },
	{ "stbu",	0xfc000000, 0x9c000000, " %{S},%{d}(%{A})" },

	{ "lhz",	0xfc000000, 0xa0000000, " %{D},%{d}(%{A})" },
	{ "lhzu",	0xfc000000, 0xa4000000, " %{D},%{d}(%{A})" },
	{ "lha",	0xfc000000, 0xa8000000, " %{D},%{d}(%{A})" },
	{ "lhau",	0xfc000000, 0xac000000, " %{D},%{d}(%{A})" },
	{ "sth",	0xfc000000, 0xb0000000, " %{S},%{d}(%{A})" },
	{ "sthu",	0xfc000000, 0xb4000000, " %{S},%{d}(%{A})" },
	{ "lmw",	0xfc000000, 0xb8000000, " %{D},%{d}(%{A})" },
	{ "stmw",	0xfc000000, 0xbc000000, " %{S},%{d}(%{A})" },

	{ "lfs",	0xfc000000, 0xc0000000, " %{D},%{d}(%{A})" },
	{ "lfsu",	0xfc000000, 0xc4000000, " %{D},%{d}(%{A})" },
	{ "lfd",	0xfc000000, 0xc8000000, " %{D},%{d}(%{A})" },
	{ "lfdu",	0xfc000000, 0xcc000000, " %{D},%{d}(%{A})" },

	{ "stfs",	0xfc000000, 0xd0000000, " %{S},%{d}(%{A})" },
	{ "stfsu",	0xfc000000, 0xd4000000, " %{S},%{d}(%{A})" },
	{ "stfd",	0xfc000000, 0xd8000000, " %{S},%{d}(%{A})" },
	{ "stfdu",	0xfc000000, 0xdc000000, " %{S},%{d}(%{A})" },
	{ "",		0x0,		0x0, "" }

};

/* 13 * 4 = 4c */
const struct opcode opcodes_13[] = {
/* 0x13 << 2 */
	{ "mcrf",	0xfc0007fe, 0x4c000000, " %{crfD},%{crfS}" },
	{ "b",/*bclr*/	0xfc0007fe, 0x4c000020, "%{BO}lr%{LK} %{BI1}" },
	{ "crnor",	0xfc0007fe, 0x4c000042, " %{crbD},%{crbA},%{crbB}" },
	{ "rfi",	0xfc0007fe, 0x4c000064, "" },
	{ "crandc",	0xfc0007fe, 0x4c000102, " %{crbD},%{crbA},%{crbB}" },
	{ "isync",	0xfc0007fe, 0x4c00012c, "" },
	{ "crxor",	0xfc0007fe, 0x4c000182, " %{crbD},%{crbA},%{crbB}" },
	{ "crnand",	0xfc0007fe, 0x4c0001c2, " %{crbD},%{crbA},%{crbB}" },
	{ "crand",	0xfc0007fe, 0x4c000202, " %{crbD},%{crbA},%{crbB}" },
	{ "creqv",	0xfc0007fe, 0x4c000242, " %{crbD},%{crbA},%{crbB}" },
	{ "crorc",	0xfc0007fe, 0x4c000342, " %{crbD},%{crbA},%{crbB}" },
	{ "cror",	0xfc0007fe, 0x4c000382, " %{crbD},%{crbA},%{crbB}" },
	{ "b"/*bcctr*/,	0xfc0007fe, 0x4c000420, "%{BO}ctr%{LK} %{BI1}" },
	{ "",		0x0,		0x0, "" }
};

/* 1e * 4 = 78 */
const struct opcode opcodes_1e[] = {
	{ "rldicl",	0xfc00001c, 0x78000000, " %{A},%{S},%{sh},%{mb}" },
	{ "rldicr",	0xfc00001c, 0x78000004, " %{A},%{S},%{sh},%{mb}" },
	{ "rldic",	0xfc00001c, 0x78000008, " %{A},%{S},%{sh},%{mb}" },
	{ "rldimi",	0xfc00001c, 0x7800000c, " %{A},%{S},%{sh},%{mb}" },
	{ "rldcl",	0xfc00003e, 0x78000010, " %{A},%{S},%{B},%{mb}" },
	{ "rldcr",	0xfc00003e, 0x78000012, " %{A},%{S},%{B},%{mb}" },
	{ "",		0x0,		0x0, "" }
};

/* 1f * 4 = 7c */
const struct opcode opcodes_1f[] = {
/* 1f << 2 */
	{ "cmpd",	0xfc2007fe, 0x7c200000, " %{crfD}%{A},%{B}" },
	{ "cmpw",	0xfc2007fe, 0x7c000000, " %{crfD}%{A},%{B}" },
	{ "tw",		0xfc0007fe, 0x7c000008, " %{TO},%{A},%{B}" },
	{ "subfc",	0xfc0003fe, 0x7c000010, "%{OE}%{RC} %{D},%{A},%{B}" },
	{ "mulhdu",	0xfc0007fe, 0x7c000012, "%{RC} %{D},%{A},%{B}" },
	{ "addc",	0xfc0003fe, 0x7c000014, "%{OE}%{RC} %{D},%{A},%{B}" },
	{ "mulhwu",	0xfc0007fe, 0x7c000016, "%{RC} %{D},%{A},%{B}" },

	{ "mfcr",	0xfc0007fe, 0x7c000026, " %{D}" },
	{ "lwarx",	0xfc0007fe, 0x7c000028, " %{D},%{A0}%{B}" },
	{ "ldx",	0xfc0007fe, 0x7c00002a, " %{D},%{A0}%{B}" },
	{ "lwzx",	0xfc0007fe, 0x7c00002e, " %{D},%{A0}%{B}" },
	{ "slw",	0xfc0007fe, 0x7c000030, "%{RC} %{A},%{S},%{B}" },
	{ "cntlzw",	0xfc0007fe, 0x7c000034, "%{RC} %{A},%{S}" },
	{ "sld",	0xfc0007fe, 0x7c000036, "%{RC} %{A},%{S},%{B}" },
	{ "and",	0xfc0007fe, 0x7c000038, "%{RC} %{A},%{S},%{B}" },
	{ "cmpld",	0xfc2007fe, 0x7c200040, " %{crfD}%{A},%{B}" },
	{ "cmplw",	0xfc2007fe, 0x7c000040, " %{crfD}%{A},%{B}" },
	{ "subf",	0xfc0003fe, 0x7c000050, "%{OE}%{RC} %{D},%{A},%{B}" },
	{ "ldux",	0xfc0007fe, 0x7c00006a, " %{D},%{A},%{B}" },
	{ "dcbst",	0xfc0007fe, 0x7c00006c, " %{A0}%{B}" },
	{ "lwzux",	0xfc0007fe, 0x7c00006e, " %{D},%{A},%{B}" },
	{ "cntlzd",	0xfc0007fe, 0x7c000074, "%{RC} %{A},%{S}" },
	{ "andc",	0xfc0007fe, 0x7c000078, "%{RC} %{A},%{S},%{B}" },
	{ "td",		0xfc0007fe, 0x7c000088, " %{TO},%{A},%{B}" },
	{ "mulhd",	0xfc0007fe, 0x7c000092, "%{RC} %{D},%{A},%{B}" },
	{ "mulhw",	0xfc0007fe, 0x7c000096, "%{RC} %{D},%{A},%{B}" },
	{ "mfmsr",	0xfc0007fe, 0x7c0000a6, " %{D}" },
	{ "ldarx",	0xfc0007fe, 0x7c0000a8, " %{D},%{A0}%{B}" },
	{ "dcbf",	0xfc0007fe, 0x7c0000ac, " %{A0}%{B}" },
	{ "lbzx",	0xfc0007fe, 0x7c0000ae, " %{D},%{A0}%{B}" },
	{ "neg",	0xfc0003fe, 0x7c0000d0, "%{OE}%{RC} %{D},%{A}" },
	{ "lbzux",	0xfc0007fe, 0x7c0000ee, " %{D},%{A},%{B}" },
	{ "nor",	0xfc0007fe, 0x7c0000f8, "%{RC} %{A},%{S}" },
	{ "subfe",	0xfc0003fe, 0x7c000110, "%{OE}%{RC} %{D},%{A}" },
	{ "adde",	0xfc0003fe, 0x7c000114, "%{OE}%{RC} %{D},%{A}" },
	{ "mtcrf",	0xfc0007fe, 0x7c000120, " %{S},%{CRM}" },
	{ "mtmsr",	0xfc0007fe, 0x7c000124, " %{S}" },
	{ "stdx",	0xfc0007fe, 0x7c00012a, " %{S},%{A0}%{B}" },
	{ "stwcx.",	0xfc0007ff, 0x7c00012d, " %{S},%{A},%{B}" },
	{ "stwx",	0xfc0007fe, 0x7c00012e, " %{S},%{A},%{B}" },
	{ "stdux",	0xfc0007fe, 0x7c00016a, " %{S},%{A},%{B}" },
	{ "stwux",	0xfc0007fe, 0x7c00016e, " %{S},%{A},%{B}" },
	{ "subfze",	0xfc0003fe, 0x7c000190, "%{OE}%{RC} %{D},%{A}" },
	{ "addze",	0xfc0003fe, 0x7c000194, "%{OE}%{RC} %{D},%{A}" },
	{ "mtsr",	0xfc0007fe, 0x7c0001a4, " %{SR},%{S}" },
	{ "stdcx.",	0xfc0007ff, 0x7c0001ad, " %{S},%{A0}%{B}" },
	{ "stbx",	0xfc0007fe, 0x7c0001ae, " %{S},%{A0}%{B}" },
	{ "subfme",	0xfc0003fe, 0x7c0001d0, "%{OE}%{RC} %{D},%{A}" },
	{ "mulld",	0xfc0003fe, 0x7c0001d2, "%{OE}%{RC} %{D},%{A},%{B}" },
	{ "addme",	0xfc0003fe, 0x7c0001d4, "%{OE}%{RC} %{D},%{A}" },
	{ "mullw",	0xfc0003fe, 0x7c0001d6, "%{OE}%{RC} %{D},%{A},%{B}" },
	{ "mtsrin",	0xfc0007fe, 0x7c0001e4, " %{S},%{B}" },
	{ "dcbtst",	0xfc0007fe, 0x7c0001ec, " %{A0}%{B}" },
	{ "stbux",	0xfc0007fe, 0x7c0001ee, " %{S},%{A},%{B}" },
	{ "add",	0xfc0003fe, 0x7c000214, "" },
	{ "dcbt",	0xfc0007fe, 0x7c00022c, " %{A0}%{B}" },
	{ "lhzx",	0xfc0007ff, 0x7c00022e, " %{D},%{A0}%{B}" },
	{ "eqv",	0xfc0007fe, 0x7c000238, "%{RC} %{A},%{S},%{B}" },
	{ "tlbie",	0xfc0007fe, 0x7c000264, " %{B}" },
	{ "eciwx",	0xfc0007fe, 0x7c00026c, " %{D},%{A0}%{B}" },
	{ "lhzux",	0xfc0007fe, 0x7c00026e, " %{D},%{A},%{B}" },
	{ "xor",	0xfc0007fe, 0x7c000278, "%{RC} %{A},%{S},%{B}" },
	{ "mfspr",	0xfc0007fe, 0x7c0002a6, " %{D},%{spr}" },
	{ "lwax",	0xfc0007fe, 0x7c0002aa, " %{D},%{A0}%{B}" },
	{ "lhax",	0xfc0007fe, 0x7c0002ae, " %{D},%{A},%{B}" },
	{ "tlbia",	0xfc0007fe, 0x7c0002e4, "" },
	{ "mftb",	0xfc0007fe, 0x7c0002e6, " %{D},%{tbr}" },
	{ "lwaux",	0xfc0007fe, 0x7c0002ea, " %{D},%{A},%{B}" },
	{ "lhaux",	0xfc0007fe, 0x7c0002ee, " %{D},%{A},%{B}" },
	{ "sthx",	0xfc0007fe, 0x7c00032e, " %{S},%{A0}%{B}" },
	{ "orc",	0xfc0007fe, 0x7c000338, "%{RC} %{A},%{S},%{B}" },
	{ "ecowx",	0xfc0007fe, 0x7c00036c, "%{RC} %{S},%{A0}%{B}" },
	{ "slbie",	0xfc0007fc, 0x7c000364, " %{B}" },
	{ "sthux",	0xfc0007fe, 0x7c00036e, " %{S},%{A0}%{B}" },
	{ "or",		0xfc0007fe, 0x7c000378, "%{RC} %{A},%{S},%{B}" },
	{ "divdu",	0xfc0003fe, 0x7c000392, "%{OE}%{RC} %{S},%{A},%{B}" },
	{ "divwu",	0xfc0003fe, 0x7c000396, "%{OE}%{RC} %{S},%{A},%{B}" },
	{ "mtspr",	0xfc0007fe, 0x7c0003a6, " %{spr},%{S}" },
	{ "dcbi",	0xfc0007fe, 0x7c0003ac, " %{A0}%{B}" },
	{ "nand",	0xfc0007fe, 0x7c0003b8, "%{RC} %{A},%{S},%{B}" },
	{ "divd",	0xfc0003fe, 0x7c0003d2, "%{OE}%{RC} %{S},%{A},%{B}" },
	{ "divw",	0xfc0003fe, 0x7c0003d6, "%{OE}%{RC} %{S},%{A},%{B}" },
	{ "slbia",	0xfc0003fe, 0x7c0003e4, "%{OE}%{RC} %{S},%{A},%{B}" },
	{ "mcrxr",	0xfc0007fe, 0x7c000400, "crfD1" },
	{ "lswx",	0xfc0007fe, 0x7c00042a, " %{D},%{A0}%{B}" },
	{ "lwbrx",	0xfc0007fe, 0x7c00042c, " %{D},%{A0}%{B}" },
	{ "lfsx",	0xfc0007fe, 0x7c00042e, " %{D},%{A},%{B}" },
	{ "srw",	0xfc0007fe, 0x7c000430, "%{RC} %{A},%{S},%{B}" },
	{ "srd",	0xfc0007fe, 0x7c000436, "%{RC} %{A},%{S},%{B}" },
	{ "tlbsync",	0xffffffff, 0x7c00046c, "" },
	{ "lfsux",	0xfc0007fe, 0x7c00046e, " %{D},%{A},%{B}" },
	{ "mfsr",	0xfc0007fe, 0x7c0004a6, " %{D},%{SR}" },
	{ "lswi",	0xfc0007fe, 0x7c0004aa, " %{D},%{A},%{NB}" },
	{ "sync",	0xfc0007fe, 0x7c0004ac, "" },
	{ "lfdx",	0xfc0007fe, 0x7c0004ae, " %{D},%{A},%{B}" },
	{ "lfdux",	0xfc0007fe, 0x7c0004ee, " %{D},%{A},%{B}" },
	{ "mfsrin",	0xfc0007fe, 0x7c000526, "" },
	{ "stswx",	0xfc0007fe, 0x7c00052a, " %{S},%{A0}%{B}" },
	{ "stwbrx",	0xfc0007fe, 0x7c00052c, " %{S},%{A0}%{B}" },
	{ "stfsx",	0xfc0007fe, 0x7c00052e, " %{S},%{A0}%{B}" },
	{ "stfsux",	0xfc0007fe, 0x7c00056e, " %{S},%{A},%{B}" },
	{ "stswi",	0xfc0007fe, 0x7c0005aa, "%{S},%{A0}%{NB}" },
	{ "stfdx",	0xfc0007fe, 0x7c0005ae, " %{S},%{A0}%{B}" },
	{ "stfdux",	0xfc0007fe, 0x7c0005ee, " %{S},%{A},%{B}" },
	{ "lhbrx",	0xfc0007fe, 0x7c00062c, " %{D},%{A0}%{B}" },
	{ "sraw",	0xfc0007fe, 0x7c000630, " %{A},%{S},%{B}" },
	{ "srad",	0xfc0007fe, 0x7c000634, "%{RC} %{A},%{S},%{B}" },
	{ "srawi",	0xfc0007fe, 0x7c000670, "%{RC} %{A},%{SH}" },
	{ "sradi",	0xfc0007fc, 0x7c000674, " %{A},%{S},%{sh}" },
	{ "eieio",	0xfc0007fe, 0x7c0006ac, "" }, /* MASK? */
	{ "sthbrx",	0xfc0007fe, 0x7c00072c, " %{S},%{A0}%{B}" },
	{ "extsh",	0xfc0007fe, 0x7c000734, "%{RC} %{A},%{S}" },
	{ "extsb",	0xfc0007fe, 0x7c000774, "%{RC} %{A},%{S}" },
	{ "icbi",	0xfc0007fe, 0x7c0007ac, " %{A0}%{B}" },

	{ "stfiwx",	0xfc0007fe, 0x7c0007ae, " %{S},%{A0}%{B}" },
	{ "extsw",	0xfc0007fe, 0x7c0007b4, "%{RC} %{A},%{S}" },
	{ "dcbz",	0xfc0007fe, 0x7c0007ec, " %{A0}%{B}" },
	{ "",		0x0,		0x0, 0, }
};

/* 3a * 4 = e8 */
const struct opcode opcodes_3a[] = {
	{ "ld",		0xfc000003, 0xe8000000, " %{D},${ds}${A}" },
	{ "ldu",	0xfc000003, 0xe8000001, " %{D},${ds}${A}" },
	{ "lwa",	0xfc000003, 0xe8000002, " %{D},${ds}${A}" },
	{ "",		0x0,		0x0, "" }
};

/* 3b * 4 = ec */
const struct opcode opcodes_3b[] = {
	{ "fdivs",	0xfc00003e, 0xec000024, "%{RC} f%{D},f%{A},f%{B}" },
	{ "fsubs",	0xfc00003e, 0xec000028, "%{RC} f%{D},f%{A},f%{B}" },

	{ "fadds",	0xfc00003e, 0xec00002a, "%{RC} f%{D},f%{A},f%{B}" },
	{ "fsqrts",	0xfc00003e, 0xec00002c, "" },
	{ "fres",	0xfc00003e, 0xec000030, "" },
	{ "fmuls",	0xfc00003e, 0xec000032, "%{RC} f%{D},f%{A},f%{C}" },
	{ "fmsubs",	0xfc00003e, 0xec000038, "%{RC} f%{D},f%{A},f%{C},f%{B}" },
	{ "fmadds",	0xfc00003e, 0xec00003a, "%{RC} f%{D},f%{A},f%{C},f%{B}" },
	{ "fnmsubs",	0xfc00003e, 0xec00003c, "%{RC} f%{D},f%{A},f%{C},f%{B}" },
	{ "fnmadds",	0xfc00003e, 0xec00003e, "%{RC} f%{D},f%{A},f%{C},f%{B}" },
	{ "",		0x0,		0x0, "" }
};

/* 3e * 4 = f8 */
const struct opcode opcodes_3e[] = {
	{ "std",	0xfc000003, 0xf8000000, " %{D},${ds}${A}" },
	{ "stdu",	0xfc000003, 0xf8000001, " %{D},${ds}${A}" },
	{ "",		0x0,		0x0, "" }
};

/* 3f * 4 = fc */
const struct opcode opcodes_3f[] = {
	{ "fcmpu",	0xfc0007fe, 0xfc000000, " %{crfD},f%{A},f%{B}" },
	{ "frsp",	0xfc0007fe, 0xfc000018, "%{RC} f%{D},f%{B}" },
	{ "fctiw",	0xfc0007fe, 0xfc00001c, "%{RC} f%{D},f%{B}" },
	{ "fctiwz",	0xfc0007fe, 0xfc00001e, "%{RC} f%{D},f%{B}" },

	{ "fdiv",	0xfc00003e, 0xfc000024, "%{RC} f%{D},f%{A},f%{B}" },
	{ "fsub",	0xfc00003e, 0xfc000028, "%{RC} f%{D},f%{A},f%{B}" },
	{ "fadd",	0xfc00003e, 0xfc00002a, "%{RC} f%{D},f%{A},f%{B}" },
	{ "fsqrt",	0xfc00003e, 0xfc00002c, "%{RC} f%{D},f%{B}" },
	{ "fsel",	0xfc00003e, 0xfc00002e, "%{RC} f%{D},f%{A},f%{C},f%{B}" },
	{ "fmul",	0xfc00003e, 0xfc000032, "%{RC} f%{D},f%{A},f%{C}" },
	{ "frsqrte",	0xfc00003e, 0xfc000034, "%{RC} f%{D},f%{B}" },
	{ "fmsub",	0xfc00003e, 0xfc000038, "%{RC} f%{D},f%{A},f%{C},f%{B}" },
	{ "fmadd",	0xfc00003e, 0xfc00003a, "%{RC} f%{D},f%{A},f%{C},f%{B}" },
	{ "fnmsub",	0xfc00003e, 0xfc00003c, "%{RC} f%{D},f%{A},f%{C},f%{B}" },
	{ "fnmadd",	0xfc00003e, 0xfc00003e, "%{RC} f%{D},f%{A},f%{C},f%{B}" },

	{ "fcmpo",	0xfc0007fe, 0xfc000040, "%{RC} f%{D},f%{A},f%{C}" },
	{ "mtfsb1",	0xfc0007fe, 0xfc00004c, "%{RC} f%{D},f%{A},f%{C}" },
	{ "fneg",	0xfc0007fe, 0xfc000050, "%{RC} f%{D},f%{A},f%{C}" },
	{ "mcrfs",	0xfc0007fe, 0xfc000080, "%{RC} f%{D},f%{A},f%{C}" },
	{ "mtfsb0",	0xfc0007fe, 0xfc00008c, "%{RC} %{crfD},f%{C}" },
	{ "fmr",	0xfc0007fe, 0xfc000090, "%{RC} f%{D},f%{B}" },
	{ "mtfsfi",	0xfc0007fe, 0xfc00010c, "%{RC} %{crfD},f%{C},%{IMM}" },

	{ "fnabs",	0xfc0007fe, 0xfc000110, "%{RC} f%{D},f%{B}" },
	{ "fabs",	0xfc0007fe, 0xfc000210, "%{RC} f%{D},f%{B}" },
	{ "mffs",	0xfc0007fe, 0xfc00048e, "%{RC} f%{D},f%{B}" },
	{ "mtfsf",	0xfc0007fe, 0xfc00058e, "%{RC} %{FM},f%{B}" },
	{ "fctid",	0xfc0007fe, 0xfc00065c, "%{RC} f%{D},f%{B}" },
	{ "fctidz",	0xfc0007fe, 0xfc00065e, "%{RC} f%{D},f%{B}" },
	{ "fcfid",	0xfc0007fe, 0xfc00069c, "%{RC} f%{D},f%{B}" },
	{ "",		0x0,		0x0, "" }
};

void
op_ill(u_int32_t addr, instr_t instr)
{
	db_printf("illegal instruction %x\n", instr);
}

/*
 * Extracts bits out of an instruction opcode, base indicates the lsb
 * to keep.
 * Note that this uses the PowerPC bit number for base, MSb == 0
 * because all of the documentation is written that way.
 */
u_int32_t
extract_field(u_int32_t value, u_int32_t base, u_int32_t width)
{
	u_int32_t mask = (1 << width) - 1;
	return ((value >> (31 - base)) & mask);
}

const struct opcode * search_op(const struct opcode *);

char *db_BOBI_cond[] = {
	"ge",
	"le",
	"ne",
	"ns",
	"lt",
	"gt",
	"eq",
	"so"
};
/* what about prediction directions? */
char *db_BO_op[] = {
	"dnzf",
	"dnzf-",
	"dzf",
	"dzf-",
	"",
	"",
	"",
	"",
	"dnzt",
	"dnzt-",
	"dzt",
	"dzt-",
	"",
	"",
	"",
	"",
	"dnz",
	"dnz",
	"dz",
	"dz",
	"",
	"",
	"",
	"",
	"dnz",
	"dnz",
	"dz",
	"dz",
	"",
	"",
	"",
	""
};

char *BItbl[] = {
	"", "gt", "eq", "so"
};

char BO_uses_tbl[32] = {
	/* 0 */ 1,
	/* 1 */ 1,
	/* 2 */ 1,
	/* 3 */ 1,
	/* 4 */ 0,
	/* 5 */ 0,
	/* 6 */ 0, /* invalid */
	/* 7 */ 0, /* invalid */
	/* 8 */ 1,
	/* 9 */ 1,
	/* a */ 1,
	/* b */ 1,
	/* c */ 0,
	/* d */ 0,
	/* e */ 0, /* invalid */
	/* f */ 1,
	/* 10 */        1,
	/* 11 */        1,
	/* 12 */        1,
	/* 13 */        1,
	/* 14 */        1,
	/* 15 */        0, /* invalid */
	/* 16 */        0, /* invalid */
	/* 17 */        0, /* invalid */
	/* 18 */        0, /* invalid */
	/* 19 */        0, /* invalid */
	/* 1a */        0, /* invalid */
	/* 1b */        0, /* invalid */
	/* 1c */        0, /* invalid */
	/* 1d */        0, /* invalid */
	/* 1e */        0, /* invalid */
	/* 1f */        0, /* invalid */
};

void
disasm_process_field(u_int32_t addr, instr_t instr, char **ppfmt,
    char *disasm_buf, size_t bufsize)
{
	char field [8];
	char lbuf[50];
	int i;
	char *pfmt = *ppfmt;
	enum opf opf;
	char *name;
	db_expr_t offset;

	/* find field */
	if (pfmt[0] != '%' || pfmt[1] != '{') {
		printf("error in disasm fmt [%s]\n", pfmt);
	}
	pfmt = &pfmt[2];
	for (i = 0;
	    pfmt[i] != '\0' && pfmt[i] != '}' && i < sizeof(field);
	    i++) {
		field[i] = pfmt[i];
	}
	if (i == sizeof(field)) {
		printf("error in disasm fmt [%s]\n", pfmt);
		return;
	}
	field[i] = 0;
	if (pfmt[i] == '\0') {
		/* match following close paren { */
		printf("disasm_process_field: missing } in [%s]\n", pfmt);
	}
	*ppfmt = &pfmt[i+1];
	opf = Opf_INVALID;
	for (i = 0; db_fields[i].name != NULL; i++) {
		if (strcmp(db_fields[i].name, field) == 0) {
			opf = db_fields[i].opf;
			break;
		}
	}
	switch (opf) {
	case Opf_INVALID:
		{
			printf("unable to find variable [%s]\n", field);
		}
	case Opf_A:
		{
			u_int A;
			A = extract_field(instr, 15, 5);
			snprintf(lbuf, sizeof (lbuf), "r%d", A);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_A0:
		{
			u_int A;
			A = extract_field(instr, 15, 5);
			if (A != 0) {
				snprintf(lbuf, sizeof (lbuf), "r%d,", A);
				strlcat (disasm_buf, lbuf, bufsize);
			}
		}
		break;
	case Opf_AA:
		if (instr & 0x2) {
			strlcat (disasm_buf, "a", bufsize);
		}
		break;
	case Opf_LI:
		{
			u_int LI;
			LI = extract_field(instr, 29, 24);
			LI = LI << 2;
			if (LI & 0x02000000) {
				LI |= ~0x03ffffff;
			}
			if ((instr & (1 << 1)) == 0) {
				/* CHECK AA bit */
				LI = addr + LI;
			}
			db_find_sym_and_offset(LI, &name, &offset);
			if (name) {
				if (offset == 0) {
					snprintf(lbuf, sizeof (lbuf),
					    "0x%x (%s)", LI, name);
					strlcat (disasm_buf, lbuf, bufsize);
				} else {
					snprintf(lbuf, sizeof (lbuf),
					    "0x%x (%s+0x%lx)", LI, name,
					    offset);
					strlcat (disasm_buf, lbuf, bufsize);
				}
			} else {
				snprintf(lbuf, sizeof (lbuf), "0x%x", LI);
				strlcat (disasm_buf, lbuf, bufsize);
			}
		}
		break;
	case Opf_B:
		{
			u_int B;
			B = extract_field(instr, 20, 5);
			snprintf(lbuf, sizeof (lbuf), "r%d", B);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_BD:
		{
			u_int BD;
			BD = extract_field(instr, 29, 14);
			BD = BD << 2;
			if (BD & 0x00008000) {
				BD &= ~0x00007fff;
			}
			if ((instr & (1 << 1)) == 0) {
				/* CHECK AA bit */
				BD = addr + BD;
			}
			db_find_sym_and_offset(BD, &name, &offset);
			if (name) {
				if (offset == 0) {
					snprintf(lbuf, sizeof (lbuf),
					    "0x%x (%s)", BD, name);
					strlcat (disasm_buf, lbuf, bufsize);
				} else {
					snprintf(lbuf, sizeof (lbuf),
					    "0x%x (%s+0x%lx)", BD, name, offset);
					strlcat (disasm_buf, lbuf, bufsize);
				}
			} else {
				snprintf(lbuf, sizeof (lbuf), "0x%x", BD);
				strlcat (disasm_buf, lbuf, bufsize);
			}
		}
		break;
	case Opf_BI1:
	case Opf_BI:
		{
			int BO, BI, cr, printcomma = 0;
			BO = extract_field(instr, 10, 5);
			BI = extract_field(instr, 15, 5);
			cr =  (BI >> 2) & 7;
			if (cr != 0) {
				snprintf(lbuf, sizeof (lbuf), "cr%d", cr);
				strlcat (disasm_buf, lbuf, bufsize);
				printcomma = 1;
			}
			if (BO_uses_tbl[BO]) {
				if ((cr != 0) && ((BI & 3) != 0) &&
				    BO_uses_tbl[BO] != 0)
					strlcat (disasm_buf, "+", bufsize);

				snprintf(lbuf, sizeof (lbuf), "%s",
				    BItbl[BI & 3]);
				strlcat (disasm_buf, lbuf, bufsize);
				printcomma = 1;
			}
			if ((opf == Opf_BI) && printcomma)
				strlcat (disasm_buf, ",", bufsize);
		}
		break;
	case Opf_BO:
		{
			int BO, BI;
			BO = extract_field(instr, 10, 5);
			strlcat (disasm_buf, db_BO_op[BO], bufsize);
			if ((BO & 4) != 0) {
				BI = extract_field(instr, 15, 5);
				strlcat (disasm_buf,
				    db_BOBI_cond[(BI & 0x3)| (((BO & 8) >> 1))],
				    bufsize);

				if (BO & 1)
					strlcat (disasm_buf, "-", bufsize);
			}
		}
		break;
	case Opf_C:
		{
			u_int C;
			C = extract_field(instr, 25, 5);
			snprintf(lbuf, sizeof (lbuf), "r%d, ", C);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_CRM:
		{
			u_int CRM;
			CRM = extract_field(instr, 19, 8);
			snprintf(lbuf, sizeof (lbuf), "0x%x", CRM);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_FM:
		{
			u_int FM;
			FM = extract_field(instr, 10, 8);
			snprintf(lbuf, sizeof (lbuf), "%d", FM);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_LK:
		if (instr & 0x1) {
			strlcat (disasm_buf, "l", bufsize);
		}
		break;
	case Opf_MB:
		{
			u_int MB;
			MB = extract_field(instr, 20, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", MB);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_ME:
		{
			u_int ME;
			ME = extract_field(instr, 25, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", ME);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_NB:
		{
			u_int NB;
			NB = extract_field(instr, 20, 5);
			if (NB == 0 ) {
				NB=32;
			}
			snprintf(lbuf, sizeof (lbuf), "%d", NB);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_OE:
		if (instr & (1 << (31-21))) {
			strlcat (disasm_buf, "o", bufsize);
		}
		break;
	case Opf_RC:
		if (instr & 0x1) {
			strlcat (disasm_buf, ".", bufsize);
		}
		break;
	case Opf_S:
	case Opf_D:
		{
			u_int D;
			/* S and D are the same */
			D = extract_field(instr, 10, 5);
			snprintf(lbuf, sizeof (lbuf), "r%d", D);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_SH:
		{
			u_int SH;
			SH = extract_field(instr, 20, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", SH);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_SIMM:
	case Opf_d:
		{
			int32_t IMM;
			IMM = extract_field(instr, 31, 16);
			if (IMM & 0x8000)
				IMM |= ~0x7fff;
			snprintf(lbuf, sizeof (lbuf), "%d", IMM);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_UIMM:
		{
			u_int32_t IMM;
			IMM = extract_field(instr, 31, 16);
			snprintf(lbuf, sizeof (lbuf), "0x%x", IMM);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_SR:
		{
			u_int SR;
			SR = extract_field(instr, 15, 3);
			snprintf(lbuf, sizeof (lbuf), "sr%d", SR);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_TO:
		{
			u_int TO;
			TO = extract_field(instr, 10, 1);
			snprintf(lbuf, sizeof (lbuf), "%d", TO);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_crbA:
		{
			u_int crbA;
			crbA = extract_field(instr, 15, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", crbA);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_crbB:
		{
			u_int crbB;
			crbB = extract_field(instr, 20, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", crbB);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_crbD:
		{
			u_int crfD;
			crfD = extract_field(instr, 8, 3);
			snprintf(lbuf, sizeof (lbuf), "crf%d", crfD);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_crfD:
		{
			u_int crfD;
			crfD = extract_field(instr, 8, 3);
			snprintf(lbuf, sizeof (lbuf), "crf%d", crfD);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_crfS:
		{
			u_int crfS;
			crfS = extract_field(instr, 13, 3);
			snprintf(lbuf, sizeof (lbuf), "%d", crfS);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_mb:
		{
			u_int mb, mbl, mbh;
			mbl = extract_field(instr, 25, 4);
			mbh = extract_field(instr, 26, 1);
			mb = mbh << 4 | mbl;
			snprintf(lbuf, sizeof (lbuf), ", %d", mb);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_sh:
		{
			u_int sh, shl, shh;
			shl = extract_field(instr, 19, 4);
			shh = extract_field(instr, 20, 1);
			sh = shh << 4 | shl;
			snprintf(lbuf, sizeof (lbuf), ", %d", sh);
			strlcat (disasm_buf, lbuf, bufsize);
		}
		break;
	case Opf_spr:
		{
			u_int spr;
			u_int sprl;
			u_int sprh;
			char *reg;
			sprl = extract_field(instr, 15, 5);
			sprh = extract_field(instr, 20, 5);
			spr = sprh << 5 | sprl;

			/* this table could be written better */
			switch (spr) {
			case	1:
				reg = "xer";
				break;
			case	8:
				reg = "lr";
				break;
			case	9:
				reg = "ctr";
				break;
			case	18:
				reg = "dsisr";
				break;
			case	19:
				reg = "dar";
				break;
			case	22:
				reg = "dec";
				break;
			case	25:
				reg = "sdr1";
				break;
			case	26:
				reg = "srr0";
				break;
			case	27:
				reg = "srr1";
				break;
			case	272:
				reg = "SPRG0";
				break;
			case	273:
				reg = "SPRG1";
				break;
			case	274:
				reg = "SPRG3";
				break;
			case	275:
				reg = "SPRG3";
				break;
			case	280:
				reg = "asr";
				break;
			case	282:
				reg = "aer";
				break;
			case	287:
				reg = "pvr";
				break;
			case	528:
				reg = "ibat0u";
				break;
			case	529:
				reg = "ibat0l";
				break;
			case	530:
				reg = "ibat1u";
				break;
			case	531:
				reg = "ibat1l";
				break;
			case	532:
				reg = "ibat2u";
				break;
			case	533:
				reg = "ibat2l";
				break;
			case	534:
				reg = "ibat3u";
				break;
			case	535:
				reg = "ibat3l";
				break;
			case	536:
				reg = "dbat0u";
				break;
			case	537:
				reg = "dbat0l";
				break;
			case	538:
				reg = "dbat1u";
				break;
			case	539:
				reg = "dbat1l";
				break;
			case	540:
				reg = "dbat2u";
				break;
			case	541:
				reg = "dbat2l";
				break;
			case	542:
				reg = "dbat3u";
				break;
			case	543:
				reg = "dbat3l";
				break;
			case	1013:
				reg = "dabr";
				break;
			default:
				reg = 0;
			}
			if (reg == 0) {
				snprintf(lbuf, sizeof (lbuf), "spr%d", spr);
				strlcat (disasm_buf, lbuf, bufsize);
			} else {
				snprintf(lbuf, sizeof (lbuf), "%s", reg);
				strlcat (disasm_buf, lbuf, bufsize);
			}
		}
		break;
	case Opf_tbr:
		{
			u_int tbr;
			u_int tbrl;
			u_int tbrh;
			char *reg = NULL;
			tbrl = extract_field(instr, 15, 5);
			tbrh = extract_field(instr, 20, 5);
			tbr = tbrh << 5 | tbrl;

			switch (tbr) {
			case 268:
				reg = "tbl";
				break;
			case 269:
				reg = "tbu";
				break;
			default:
				reg = 0;
			}
			if (reg == NULL) {
				snprintf(lbuf, sizeof (lbuf), "tbr%d", tbr);
				strlcat (disasm_buf, lbuf, bufsize);
			} else {
				snprintf(lbuf, sizeof (lbuf), "%s", reg);
				strlcat (disasm_buf, lbuf, bufsize);
			}
		}
		break;
	}
}

void
disasm_fields(u_int32_t addr, const struct opcode *popcode, instr_t instr,
    char *disasm_str, size_t bufsize)
{
	char *pfmt;
	char cbuf[2];
	if (popcode->decode_str == NULL || popcode->decode_str[0] == '0') {
		return;
	}
	pfmt = popcode->decode_str;
	disasm_str[0] = '\0';

	while (*pfmt != '\0')  {
		if (*pfmt == '%') {
			disasm_process_field(addr, instr, &pfmt, disasm_str,
			    bufsize);
		} else {
			cbuf[0] = *pfmt;
			cbuf[1] = '\0';
			strlcat(disasm_str, cbuf, bufsize);
			pfmt++;
		}
	}
}

void
op_base(u_int32_t addr, instr_t instr)
{
	dis_ppc(addr, opcodes, instr);
}

void
op_cl_x13(u_int32_t addr, instr_t instr)
{
	dis_ppc(addr, opcodes_13, instr);
}

void
op_cl_x1e(u_int32_t addr, instr_t instr)
{
	dis_ppc(addr, opcodes_1e, instr);
}

void
op_cl_x1f(u_int32_t addr, instr_t instr)
{
	dis_ppc(addr, opcodes_1f, instr);
}

void
op_cl_x3a(u_int32_t addr, instr_t instr)
{
	dis_ppc(addr, opcodes_3a, instr);
}

void
op_cl_x3b(u_int32_t addr, instr_t instr)
{
	dis_ppc(addr, opcodes_3b, instr);
}

void
op_cl_x3e(u_int32_t addr, instr_t instr)
{
	dis_ppc(addr, opcodes_3e, instr);
}

void
op_cl_x3f(u_int32_t addr, instr_t instr)
{
	dis_ppc(addr, opcodes_3f, instr);
}

void
dis_ppc(u_int32_t addr, const struct opcode *opcodeset, instr_t instr)
{
	const struct opcode *op;
	int i;
	char disasm_str[80];

	for (i=0; opcodeset[i].mask != 0; i++) {
		op = &opcodeset[i];
		if ((instr & op->mask) == op->code) {
			disasm_fields(addr, op, instr, disasm_str,
			    sizeof disasm_str);
			db_printf("%s%s\n", op->name, disasm_str);
			return;
		}
	}
	op_ill(addr, instr);
}

db_addr_t
db_disasm(db_addr_t loc, boolean_t extended)
{
	int class;
	instr_t opcode;
	opcode = *(instr_t *)(loc);
	class = opcode >> 26;
	(opcodes_base[class])(loc, opcode);

	return loc + 4;
}
@


1.15
log
@Make certain the output buffer is zeroed before starting processing.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.14 2003/12/21 15:17:29 miod Exp $	*/
a895 1
		break;
@


1.14
log
@Switch db_expr_t from int to long, per consistency with all other arches.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.13 2003/10/15 01:06:13 drahn Exp $	*/
d1083 1
@


1.13
log
@Housecleaning, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.12 2003/05/09 21:36:05 drahn Exp $	*/
d649 1
a649 1
					    "0x%x (%s+0x%x)", LI, name,
d687 1
a687 1
					    "0x%x (%s+0x%x)", BD, name, offset);
@


1.12
log
@'found' variable was not used correctly, simplify the logic.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.11 2003/05/09 21:23:53 drahn Exp $	*/
d232 1
d395 1
d411 1
@


1.11
log
@sprintf() removal for ppc disassembler. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.10 2003/05/08 19:26:37 drahn Exp $	*/
a1145 1
	int found = 0;
d1149 2
a1150 3
	for (i=0, op = &opcodeset[0];
	    found == 0 && op->mask != 0;
	    i++, op= &opcodeset[i] ) {
a1151 1
			found = 1;
@


1.10
log
@'branch absolute linking' instruction is 'bla', not 'bal'.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.9 2003/05/08 16:25:25 drahn Exp $	*/
d134 3
a136 1
    char *disasm_str);
d139 1
a558 2

void disasm_process_field(u_int32_t addr, instr_t instr, char **ppfmt, char **ppoutput);
d560 2
a561 1
disasm_process_field(u_int32_t addr, instr_t instr, char **ppfmt, char **ppoutput)
d564 1
a566 1
	char *pstr;
d573 1
a573 1
		printf("error in disasm fmt [%s]\n",pfmt);
d576 3
a578 1
	for (i = 0; pfmt[i] != '\0' && pfmt[i] != '}';  i++) {
d581 4
d587 1
a597 1
	pstr = *ppoutput;
d601 1
a601 1
			printf("unable to find variable [%s]\n",field);
d607 2
a608 1
			pstr += sprintf(pstr, "r%d", A);
d616 2
a617 1
				pstr += sprintf(pstr, "r%d,", A);
d623 1
a623 1
			pstr += sprintf(pstr,"a");
d641 3
a643 2
				pstr += sprintf(pstr, "0x%x (%s)", LI,
					name);
d645 4
a648 2
				pstr += sprintf(pstr, "0x%x (%s+0x%x)", LI,
					name, offset);
d651 2
a652 1
				pstr += sprintf(pstr, "0x%x", LI);
d660 2
a661 1
			pstr += sprintf(pstr, "r%d", B);
d679 3
a681 2
				pstr += sprintf(pstr, "0x%x (%s)", BD,
					name);
d683 3
a685 2
				pstr += sprintf(pstr, "0x%x (%s+0x%x)", BD,
					name, offset);
d688 2
a689 1
				pstr += sprintf(pstr, "0x%x", BD);
d701 2
a702 1
				pstr += sprintf(pstr, "cr%d", cr);
d706 7
a712 4
				if ((cr != 0) && ((BI & 3) != 0))
					if (BO_uses_tbl[BO])
						pstr += sprintf(pstr, "+");
				pstr += sprintf(pstr, "%s", BItbl[BI & 3]);
d716 1
a716 1
				pstr += sprintf(pstr, ",");
d721 1
a721 1
			int BO,BI;
d723 1
a723 1
			pstr += sprintf(pstr ,"%s", db_BO_op[BO]);
d726 3
a728 3
				pstr += sprintf(pstr ,"%s",
				    db_BOBI_cond[(BI & 0x3)|
				    (((BO & 8) >> 1))] );
d731 1
a731 1
					pstr += sprintf(pstr ,"-");
d739 2
a740 1
			pstr += sprintf(pstr, "r%d, ", C);
d747 2
a748 1
			pstr += sprintf(pstr, "0x%x", CRM);
d755 2
a756 1
			pstr += sprintf(pstr, "%d", FM);
d761 1
a761 1
			pstr += sprintf(pstr,"l");
d768 2
a769 1
			pstr += sprintf(pstr, "%d", MB);
d776 2
a777 1
			pstr += sprintf(pstr, "%d", ME);
d787 2
a788 1
			pstr += sprintf(pstr, "%d", NB);
d793 1
a793 1
			*pstr++ = 'o';
d798 1
a798 1
			*pstr++  = '.';
d807 2
a808 1
			pstr += sprintf(pstr, "r%d", D);
d815 2
a816 1
			pstr += sprintf(pstr, "%d", SH);
d824 1
a824 1
			if (IMM & 0x8000) {
d826 2
a827 2
			}
			pstr += sprintf(pstr, "%d", IMM);
d834 2
a835 1
			pstr += sprintf(pstr, "0x%x", IMM);
d842 2
a843 1
			pstr += sprintf(pstr, "sr%d", SR);
d850 2
a851 1
			pstr += sprintf(pstr, "%d", TO);
d858 2
a859 1
			pstr += sprintf(pstr, "%d", crbA);
d866 2
a867 1
			pstr += sprintf(pstr, "%d", crbB);
d874 2
a875 1
			pstr += sprintf(pstr, "crf%d", crfD);
d882 2
a883 1
			pstr += sprintf(pstr, "crf%d", crfD);
d890 2
a891 1
			pstr += sprintf(pstr, "%d", crfS);
d901 2
a902 1
			pstr += sprintf(pstr, ", %d", mb);
d911 2
a912 1
			pstr += sprintf(pstr, ", %d", sh);
d1030 2
a1031 1
				pstr += sprintf(pstr, "spr%d", spr);
d1033 2
a1034 1
				pstr += sprintf(pstr, "%s", reg);
d1043 1
a1043 1
			char *reg;
d1058 3
a1060 2
			if (reg == 0) {
				pstr += sprintf(pstr, "tbr%d", tbr);
d1062 2
a1063 1
				pstr += sprintf(pstr, "%s", reg);
a1067 2
	*ppoutput = pstr;

d1071 2
a1072 1
disasm_fields(u_int32_t addr, const struct opcode *popcode, instr_t instr, char *disasm_str)
d1075 1
a1075 2
	char *poutput;
	disasm_str[0] = '\0';
a1079 1
	poutput = disasm_str;
d1083 2
a1084 1
			disasm_process_field(addr, instr, &pfmt, &poutput);
d1086 3
a1088 2
			*poutput = *pfmt;
			poutput++;
a1091 1
	*poutput = '\0';
d1097 1
a1097 1
	dis_ppc(addr, opcodes,instr);
d1103 1
a1103 1
	dis_ppc(addr, opcodes_13,instr);
d1109 1
a1109 1
	dis_ppc(addr, opcodes_1e,instr);
d1115 1
a1115 1
	dis_ppc(addr, opcodes_1f,instr);
d1121 1
a1121 1
	dis_ppc(addr, opcodes_3a,instr);
d1127 1
a1127 1
	dis_ppc(addr, opcodes_3b,instr);
d1133 1
a1133 1
	dis_ppc(addr, opcodes_3e,instr);
d1139 1
a1139 1
	dis_ppc(addr, opcodes_3f,instr);
d1148 1
a1148 1
	char disasm_str[30];
d1155 3
a1157 2
			disasm_fields(addr, op, instr, disasm_str);
			db_printf("%s%s\n",op->name, disasm_str);
@


1.9
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.8 2003/05/08 16:11:57 drahn Exp $	*/
d184 2
a185 2
	{ "b",		0xfc000000, 0x40000000, "%{BO}%{AA}%{LK} %{BI}%{BD}" },
	{ "b",		0xfc000000, 0x48000000, "%{AA}%{LK} %{LI}" },
@


1.8
log
@Change extract_field() arguments, eliminates the nasty '31 -' all over the
file. Remove NetBSD tag, this file is not used by NetBSD. Copyright cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.7 2003/05/08 16:05:32 drahn Exp $	*/
d24 1
a24 1
 */  
d119 1
a119 1
	{ NULL,	 	0 }
d145 3
a147 3
/*x08*/	op_base,	op_base,	op_base,	op_base,	
/*x0C*/ op_base,	op_base,	op_base/*XXX*/,	op_base/*XXX*/,
/*x10*/ op_base,	op_base,	op_base,	op_cl_x13,
d150 1
a150 1
/*x1C*/ op_base,	op_base,	op_cl_x1e,	op_cl_x1f,
d157 1
a157 1
/*x38*/ op_ill,		op_ill,		op_cl_x3a,	op_cl_x3b,
d164 1
a164 1
 * I would recommend that this table be looked over for errors, 
d599 1
a599 1
			pstr += sprintf (pstr, "r%d", A);
d607 1
a607 1
				pstr += sprintf (pstr, "r%d,", A);
d613 1
a613 1
			pstr += sprintf (pstr,"a");
d631 1
a631 1
				pstr += sprintf (pstr, "0x%x (%s)", LI,
d634 1
a634 1
				pstr += sprintf (pstr, "0x%x (%s+0x%x)", LI,
d638 1
a638 1
				pstr += sprintf (pstr, "0x%x", LI);
d646 1
a646 1
			pstr += sprintf (pstr, "r%d", B);
d664 1
a664 1
				pstr += sprintf (pstr, "0x%x (%s)", BD,
d667 1
a667 1
				pstr += sprintf (pstr, "0x%x (%s+0x%x)", BD,
d671 1
a671 1
				pstr += sprintf (pstr, "0x%x", BD);
d683 1
a683 1
				pstr += sprintf (pstr, "cr%d", cr);
d689 2
a690 2
						pstr += sprintf (pstr, "+");
				pstr += sprintf (pstr, "%s", BItbl[BI & 3]);
d694 1
a694 1
				pstr += sprintf (pstr, ",");
d701 1
a701 1
			pstr += sprintf (pstr ,"%s", db_BO_op[BO]);
d704 1
a704 1
				pstr += sprintf (pstr ,"%s",
d709 1
a709 1
					pstr += sprintf (pstr ,"-");
d717 1
a717 1
			pstr += sprintf (pstr, "r%d, ", C);
d724 1
a724 1
			pstr += sprintf (pstr, "0x%x", CRM);
d731 1
a731 1
			pstr += sprintf (pstr, "%d", FM);
d736 1
a736 1
			pstr += sprintf (pstr,"l");
d743 1
a743 1
			pstr += sprintf (pstr, "%d", MB);
d750 1
a750 1
			pstr += sprintf (pstr, "%d", ME);
d760 1
a760 1
			pstr += sprintf (pstr, "%d", NB);
d779 1
a779 1
			pstr += sprintf (pstr, "r%d", D);
d786 1
a786 1
			pstr += sprintf (pstr, "%d", SH);
d797 1
a797 1
			pstr += sprintf (pstr, "%d", IMM);
d804 1
a804 1
			pstr += sprintf (pstr, "0x%x", IMM);
d811 1
a811 1
			pstr += sprintf (pstr, "sr%d", SR);
d818 1
a818 1
			pstr += sprintf (pstr, "%d", TO);
d825 1
a825 1
			pstr += sprintf (pstr, "%d", crbA);
d832 1
a832 1
			pstr += sprintf (pstr, "%d", crbB);
d839 1
a839 1
			pstr += sprintf (pstr, "crf%d", crfD);
d846 1
a846 1
			pstr += sprintf (pstr, "crf%d", crfD);
d853 1
a853 1
			pstr += sprintf (pstr, "%d", crfS);
d863 1
a863 1
			pstr += sprintf (pstr, ", %d", mb);
d872 1
a872 1
			pstr += sprintf (pstr, ", %d", sh);
d887 1
a887 1
			case 	1:
d890 1
a890 1
			case 	8:
d893 1
a893 1
			case 	9:
d896 1
a896 1
			case 	18:
d899 1
a899 1
			case 	19:
d902 1
a902 1
			case 	22:
d905 1
a905 1
			case 	25:
d908 1
a908 1
			case 	26:
d911 1
a911 1
			case 	27:
d914 1
a914 1
			case 	272:
d917 1
a917 1
			case 	273:
d920 1
a920 1
			case 	274:
d923 1
a923 1
			case 	275:
d926 1
a926 1
			case 	280:
d929 1
a929 1
			case 	282:
d932 1
a932 1
			case 	287:
d935 1
a935 1
			case 	528:
d938 1
a938 1
			case 	529:
d941 1
a941 1
			case 	530:
d944 1
a944 1
			case 	531:
d947 1
a947 1
			case 	532:
d950 1
a950 1
			case 	533:
d953 1
a953 1
			case 	534:
d956 1
a956 1
			case 	535:
d959 1
a959 1
			case 	536:
d962 1
a962 1
			case 	537:
d965 1
a965 1
			case 	538:
d968 1
a968 1
			case 	539:
d971 1
a971 1
			case 	540:
d974 1
a974 1
			case 	541:
d977 1
a977 1
			case 	542:
d980 1
a980 1
			case 	543:
d983 1
a983 1
			case 	1013:
d990 1
a990 1
				pstr += sprintf (pstr, "spr%d", spr);
d992 1
a992 1
				pstr += sprintf (pstr, "%s", reg);
d1017 1
a1017 1
				pstr += sprintf (pstr, "tbr%d", tbr);
d1019 1
a1019 1
				pstr += sprintf (pstr, "%s", reg);
d1055 1
a1055 1
	dis_ppc (addr, opcodes,instr);
d1061 1
a1061 1
	dis_ppc (addr, opcodes_13,instr);
d1067 1
a1067 1
	dis_ppc (addr, opcodes_1e,instr);
d1073 1
a1073 1
	dis_ppc (addr, opcodes_1f,instr);
d1079 1
a1079 1
	dis_ppc (addr, opcodes_3a,instr);
d1085 1
a1085 1
	dis_ppc (addr, opcodes_3b,instr);
d1091 1
a1091 1
	dis_ppc (addr, opcodes_3e,instr);
d1097 1
a1097 1
	dis_ppc (addr, opcodes_3f,instr);
@


1.7
log
@Put newline on end of disasm so that x /i <addr>,<cnt> works correctly.
@
text
@d1 1
a1 2
/*	$NetBSD: db_disasm.c,v 1.8 2001/06/12 05:31:44 simonb Exp $	*/
/*	$OpenBSD: db_disasm.c,v 1.6 2003/03/27 17:40:19 drahn Exp $	*/
d3 1
a3 1
 * Copyright (c) 1996 Dale Rahn. All rights reserved.
a4 1
 *   
a12 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Dale Rahn.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d456 6
d466 1
a466 1
	return ((value >> base) & mask);
d598 1
a598 1
			A = extract_field(instr, 31 - 15, 5);
d605 1
a605 1
			A = extract_field(instr, 31 - 15, 5);
d619 1
a619 1
			LI = extract_field(instr, 31 - 29, 24);
d645 1
a645 1
			B = extract_field(instr, 31 - 20, 5);
d652 1
a652 1
			BD = extract_field(instr, 31 - 29, 14);
d679 2
a680 2
			BO = extract_field(instr, 31 - 10, 5);
			BI = extract_field(instr, 31 - 15, 5);
d700 1
a700 1
			BO = extract_field(instr, 31 - 10, 5);
d703 1
a703 1
				BI = extract_field(instr, 31 - 15, 5);
d716 1
a716 1
			C = extract_field(instr, 31 - 25, 5);
d723 1
a723 1
			CRM = extract_field(instr, 31 - 19, 8);
d730 1
a730 1
			FM = extract_field(instr, 31 - 10, 8);
d742 1
a742 1
			MB = extract_field(instr, 31 - 20, 5);
d749 1
a749 1
			ME = extract_field(instr, 31 - 25, 5);
d756 1
a756 1
			NB = extract_field(instr, 31 - 20, 5);
d778 1
a778 1
			D = extract_field(instr, 31 - 10, 5);
d785 1
a785 1
			SH = extract_field(instr, 31 - 20, 5);
d793 1
a793 1
			IMM = extract_field(instr, 31 - 31, 16);
d803 1
a803 1
			IMM = extract_field(instr, 31 - 31, 16);
d810 1
a810 1
			SR = extract_field(instr, 31 - 15, 3);
d817 1
a817 1
			TO = extract_field(instr, 31 - 10, 1);
d824 1
a824 1
			crbA = extract_field(instr, 31 - 15, 5);
d831 1
a831 1
			crbB = extract_field(instr, 31 - 20, 5);
d838 1
a838 1
			crfD = extract_field(instr, 31 - 8, 3);
d845 1
a845 1
			crfD = extract_field(instr, 31 - 8, 3);
d852 1
a852 1
			crfS = extract_field(instr, 31 - 13, 3);
d860 2
a861 2
			mbl = extract_field(instr, 31 - 25, 4);
			mbh = extract_field(instr, 31 - 26, 1);
d869 2
a870 2
			shl = extract_field(instr, 31 - 19, 4);
			shh = extract_field(instr, 31 - 20, 1);
d881 2
a882 2
			sprl = extract_field(instr, 31 - 15, 5);
			sprh = extract_field(instr, 31 - 20, 5);
d1002 2
a1003 2
			tbrl = extract_field(instr, 31 - 15, 5);
			tbrh = extract_field(instr, 31 - 20, 5);
@


1.6
log
@Improve disassmbly of powerpc branch instructions, print the conditional
information in a readable form.
@
text
@d2 1
a2 1
/*	$OpenBSD: db_disasm.c,v 1.5 2003/02/20 16:48:25 drahn Exp $	*/
d1115 1
a1115 1
			db_printf("%s%s",op->name, disasm_str);
@


1.6.2.1
log
@A sweep to fix remaining files not in sync with the SMP_SYNC_B point.
@
text
@d484 4
a487 4
	"dnz",
	"dnz",
	"dz",
	"dz",
d492 4
a495 4
	"dnz",
	"dnz",
	"dz",
	"dz",
d518 40
d676 1
d679 14
a692 13
			u_int BI;
			BI = extract_field(instr, 31 - 10, 5);
			if (BI != 0) {
			pstr += sprintf (pstr, "%d,", BI);
			}
		}
		break;
	case Opf_BI1:
		{
			u_int BI;
			BI = extract_field(instr, 31 - 10, 5);
			if (BI != 0) {
			pstr += sprintf (pstr, "%d", BI);
d694 2
d703 2
a704 2
			if (BO < 8) {
				BI = extract_field(instr, 31 - 10, 5);
d706 2
a707 1
				    db_BOBI_cond[(BI & 0x3)|((BO & 1) << 2)]);
d709 2
@


1.6.2.2
log
@Sync the SMP branch to -current.
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1996, 2001, 2003 Dale Rahn. All rights reserved.
d6 1
d15 5
d31 1
a31 1
 */
d126 1
a126 1
	{ NULL,		0 }
d141 1
a141 3
    char *disasm_str, size_t bufsize);
void disasm_process_field(u_int32_t addr, instr_t instr, char **ppfmt,
    char *ppoutput, size_t bufsize);
a143 1

d152 3
a154 3
/*x08*/	op_base,	op_base,	op_base,	op_base,
/*x0C*/	op_base,	op_base,	op_base/*XXX*/,	op_base/*XXX*/,
/*x10*/	op_base,	op_base,	op_base,	op_cl_x13,
d157 1
a157 1
/*x1C*/	op_base,	op_base,	op_cl_x1e,	op_cl_x1f,
d164 1
a164 1
/*x38*/	op_ill,		op_ill,		op_cl_x3a,	op_cl_x3b,
d171 1
a171 1
 * I would recommend that this table be looked over for errors,
d191 2
a192 2
	{ "b",		0xfc000000, 0x40000000, "%{BO}%{LK}%{AA} %{BI}%{BD}" },
	{ "b",		0xfc000000, 0x48000000, "%{LK}%{AA} %{LI}" },
a462 6
/*
 * Extracts bits out of an instruction opcode, base indicates the lsb
 * to keep.
 * Note that this uses the PowerPC bit number for base, MSb == 0
 * because all of the documentation is written that way.
 */
d467 1
a467 1
	return ((value >> (31 - base)) & mask);
d484 4
a487 4
	"dnzf",
	"dnzf-",
	"dzf",
	"dzf-",
d492 4
a495 4
	"dnzt",
	"dnzt-",
	"dzt",
	"dzt-",
d518 1
a518 39
char *BItbl[] = {
	"", "gt", "eq", "so"
};

char BO_uses_tbl[32] = {
	/* 0 */ 1,
	/* 1 */ 1,
	/* 2 */ 1,
	/* 3 */ 1,
	/* 4 */ 0,
	/* 5 */ 0,
	/* 6 */ 0, /* invalid */
	/* 7 */ 0, /* invalid */
	/* 8 */ 1,
	/* 9 */ 1,
	/* a */ 1,
	/* b */ 1,
	/* c */ 0,
	/* d */ 0,
	/* e */ 0, /* invalid */
	/* f */ 1,
	/* 10 */        1,
	/* 11 */        1,
	/* 12 */        1,
	/* 13 */        1,
	/* 14 */        1,
	/* 15 */        0, /* invalid */
	/* 16 */        0, /* invalid */
	/* 17 */        0, /* invalid */
	/* 18 */        0, /* invalid */
	/* 19 */        0, /* invalid */
	/* 1a */        0, /* invalid */
	/* 1b */        0, /* invalid */
	/* 1c */        0, /* invalid */
	/* 1d */        0, /* invalid */
	/* 1e */        0, /* invalid */
	/* 1f */        0, /* invalid */
};

d520 1
a520 2
disasm_process_field(u_int32_t addr, instr_t instr, char **ppfmt,
    char *disasm_buf, size_t bufsize)
a522 1
	char lbuf[50];
d525 1
d532 1
a532 1
		printf("error in disasm fmt [%s]\n", pfmt);
d535 1
a535 3
	for (i = 0;
	    pfmt[i] != '\0' && pfmt[i] != '}' && i < sizeof(field);
	    i++) {
a537 4
	if (i == sizeof(field)) {
		printf("error in disasm fmt [%s]\n", pfmt);
		return;
	}
a539 1
		/* match following close paren { */
d550 1
d554 1
a554 1
			printf("unable to find variable [%s]\n", field);
d559 2
a560 3
			A = extract_field(instr, 15, 5);
			snprintf(lbuf, sizeof (lbuf), "r%d", A);
			strlcat (disasm_buf, lbuf, bufsize);
d566 1
a566 1
			A = extract_field(instr, 15, 5);
d568 1
a568 2
				snprintf(lbuf, sizeof (lbuf), "r%d,", A);
				strlcat (disasm_buf, lbuf, bufsize);
d574 1
a574 1
			strlcat (disasm_buf, "a", bufsize);
d580 1
a580 1
			LI = extract_field(instr, 29, 24);
d592 2
a593 3
					snprintf(lbuf, sizeof (lbuf),
					    "0x%x (%s)", LI, name);
					strlcat (disasm_buf, lbuf, bufsize);
d595 2
a596 4
					snprintf(lbuf, sizeof (lbuf),
					    "0x%x (%s+0x%x)", LI, name,
					    offset);
					strlcat (disasm_buf, lbuf, bufsize);
d599 1
a599 2
				snprintf(lbuf, sizeof (lbuf), "0x%x", LI);
				strlcat (disasm_buf, lbuf, bufsize);
d606 2
a607 3
			B = extract_field(instr, 20, 5);
			snprintf(lbuf, sizeof (lbuf), "r%d", B);
			strlcat (disasm_buf, lbuf, bufsize);
d613 1
a613 1
			BD = extract_field(instr, 29, 14);
d625 2
a626 3
					snprintf(lbuf, sizeof (lbuf),
					    "0x%x (%s)", BD, name);
					strlcat (disasm_buf, lbuf, bufsize);
d628 2
a629 3
					snprintf(lbuf, sizeof (lbuf),
					    "0x%x (%s+0x%x)", BD, name, offset);
					strlcat (disasm_buf, lbuf, bufsize);
d632 1
a632 2
				snprintf(lbuf, sizeof (lbuf), "0x%x", BD);
				strlcat (disasm_buf, lbuf, bufsize);
a635 1
	case Opf_BI1:
d638 4
a641 8
			int BO, BI, cr, printcomma = 0;
			BO = extract_field(instr, 10, 5);
			BI = extract_field(instr, 15, 5);
			cr =  (BI >> 2) & 7;
			if (cr != 0) {
				snprintf(lbuf, sizeof (lbuf), "cr%d", cr);
				strlcat (disasm_buf, lbuf, bufsize);
				printcomma = 1;
d643 8
a650 9
			if (BO_uses_tbl[BO]) {
				if ((cr != 0) && ((BI & 3) != 0) &&
				    BO_uses_tbl[BO] != 0)
					strlcat (disasm_buf, "+", bufsize);

				snprintf(lbuf, sizeof (lbuf), "%s",
				    BItbl[BI & 3]);
				strlcat (disasm_buf, lbuf, bufsize);
				printcomma = 1;
a651 2
			if ((opf == Opf_BI) && printcomma)
				strlcat (disasm_buf, ",", bufsize);
d656 7
a662 8
			int BO, BI;
			BO = extract_field(instr, 10, 5);
			strlcat (disasm_buf, db_BO_op[BO], bufsize);
			if ((BO & 4) != 0) {
				BI = extract_field(instr, 15, 5);
				strlcat (disasm_buf,
				    db_BOBI_cond[(BI & 0x3)| (((BO & 8) >> 1))],
				    bufsize);
a663 2
				if (BO & 1)
					strlcat (disasm_buf, "-", bufsize);
d670 2
a671 3
			C = extract_field(instr, 25, 5);
			snprintf(lbuf, sizeof (lbuf), "r%d, ", C);
			strlcat (disasm_buf, lbuf, bufsize);
d677 2
a678 3
			CRM = extract_field(instr, 19, 8);
			snprintf(lbuf, sizeof (lbuf), "0x%x", CRM);
			strlcat (disasm_buf, lbuf, bufsize);
d684 2
a685 3
			FM = extract_field(instr, 10, 8);
			snprintf(lbuf, sizeof (lbuf), "%d", FM);
			strlcat (disasm_buf, lbuf, bufsize);
d690 1
a690 1
			strlcat (disasm_buf, "l", bufsize);
d696 2
a697 3
			MB = extract_field(instr, 20, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", MB);
			strlcat (disasm_buf, lbuf, bufsize);
d703 2
a704 3
			ME = extract_field(instr, 25, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", ME);
			strlcat (disasm_buf, lbuf, bufsize);
d710 1
a710 1
			NB = extract_field(instr, 20, 5);
d714 1
a714 2
			snprintf(lbuf, sizeof (lbuf), "%d", NB);
			strlcat (disasm_buf, lbuf, bufsize);
d719 1
a719 1
			strlcat (disasm_buf, "o", bufsize);
d724 1
a724 1
			strlcat (disasm_buf, ".", bufsize);
d732 2
a733 3
			D = extract_field(instr, 10, 5);
			snprintf(lbuf, sizeof (lbuf), "r%d", D);
			strlcat (disasm_buf, lbuf, bufsize);
d739 2
a740 3
			SH = extract_field(instr, 20, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", SH);
			strlcat (disasm_buf, lbuf, bufsize);
d747 2
a748 2
			IMM = extract_field(instr, 31, 16);
			if (IMM & 0x8000)
d750 2
a751 2
			snprintf(lbuf, sizeof (lbuf), "%d", IMM);
			strlcat (disasm_buf, lbuf, bufsize);
d757 2
a758 3
			IMM = extract_field(instr, 31, 16);
			snprintf(lbuf, sizeof (lbuf), "0x%x", IMM);
			strlcat (disasm_buf, lbuf, bufsize);
d764 2
a765 3
			SR = extract_field(instr, 15, 3);
			snprintf(lbuf, sizeof (lbuf), "sr%d", SR);
			strlcat (disasm_buf, lbuf, bufsize);
d771 2
a772 3
			TO = extract_field(instr, 10, 1);
			snprintf(lbuf, sizeof (lbuf), "%d", TO);
			strlcat (disasm_buf, lbuf, bufsize);
d778 2
a779 3
			crbA = extract_field(instr, 15, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", crbA);
			strlcat (disasm_buf, lbuf, bufsize);
d785 2
a786 3
			crbB = extract_field(instr, 20, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", crbB);
			strlcat (disasm_buf, lbuf, bufsize);
d792 2
a793 3
			crfD = extract_field(instr, 8, 3);
			snprintf(lbuf, sizeof (lbuf), "crf%d", crfD);
			strlcat (disasm_buf, lbuf, bufsize);
d799 2
a800 3
			crfD = extract_field(instr, 8, 3);
			snprintf(lbuf, sizeof (lbuf), "crf%d", crfD);
			strlcat (disasm_buf, lbuf, bufsize);
d806 2
a807 3
			crfS = extract_field(instr, 13, 3);
			snprintf(lbuf, sizeof (lbuf), "%d", crfS);
			strlcat (disasm_buf, lbuf, bufsize);
d814 2
a815 2
			mbl = extract_field(instr, 25, 4);
			mbh = extract_field(instr, 26, 1);
d817 1
a817 2
			snprintf(lbuf, sizeof (lbuf), ", %d", mb);
			strlcat (disasm_buf, lbuf, bufsize);
d823 2
a824 2
			shl = extract_field(instr, 19, 4);
			shh = extract_field(instr, 20, 1);
d826 1
a826 2
			snprintf(lbuf, sizeof (lbuf), ", %d", sh);
			strlcat (disasm_buf, lbuf, bufsize);
d835 2
a836 2
			sprl = extract_field(instr, 15, 5);
			sprh = extract_field(instr, 20, 5);
d841 1
a841 1
			case	1:
d844 1
a844 1
			case	8:
d847 1
a847 1
			case	9:
d850 1
a850 1
			case	18:
d853 1
a853 1
			case	19:
d856 1
a856 1
			case	22:
d859 1
a859 1
			case	25:
d862 1
a862 1
			case	26:
d865 1
a865 1
			case	27:
d868 1
a868 1
			case	272:
d871 1
a871 1
			case	273:
d874 1
a874 1
			case	274:
d877 1
a877 1
			case	275:
d880 1
a880 1
			case	280:
d883 1
a883 1
			case	282:
d886 1
a886 1
			case	287:
d889 1
a889 1
			case	528:
d892 1
a892 1
			case	529:
d895 1
a895 1
			case	530:
d898 1
a898 1
			case	531:
d901 1
a901 1
			case	532:
d904 1
a904 1
			case	533:
d907 1
a907 1
			case	534:
d910 1
a910 1
			case	535:
d913 1
a913 1
			case	536:
d916 1
a916 1
			case	537:
d919 1
a919 1
			case	538:
d922 1
a922 1
			case	539:
d925 1
a925 1
			case	540:
d928 1
a928 1
			case	541:
d931 1
a931 1
			case	542:
d934 1
a934 1
			case	543:
d937 1
a937 1
			case	1013:
d944 1
a944 2
				snprintf(lbuf, sizeof (lbuf), "spr%d", spr);
				strlcat (disasm_buf, lbuf, bufsize);
d946 1
a946 2
				snprintf(lbuf, sizeof (lbuf), "%s", reg);
				strlcat (disasm_buf, lbuf, bufsize);
d955 3
a957 3
			char *reg = NULL;
			tbrl = extract_field(instr, 15, 5);
			tbrh = extract_field(instr, 20, 5);
d970 2
a971 3
			if (reg == NULL) {
				snprintf(lbuf, sizeof (lbuf), "tbr%d", tbr);
				strlcat (disasm_buf, lbuf, bufsize);
d973 1
a973 2
				snprintf(lbuf, sizeof (lbuf), "%s", reg);
				strlcat (disasm_buf, lbuf, bufsize);
d978 2
d983 1
a983 2
disasm_fields(u_int32_t addr, const struct opcode *popcode, instr_t instr,
    char *disasm_str, size_t bufsize)
d986 2
a987 1
	char cbuf[2];
d992 1
d996 1
a996 2
			disasm_process_field(addr, instr, &pfmt, disasm_str,
			    bufsize);
d998 2
a999 3
			cbuf[0] = *pfmt;
			cbuf[1] = '\0';
			strlcat(disasm_str, cbuf, bufsize);
d1003 1
d1009 1
a1009 1
	dis_ppc(addr, opcodes, instr);
d1015 1
a1015 1
	dis_ppc(addr, opcodes_13, instr);
d1021 1
a1021 1
	dis_ppc(addr, opcodes_1e, instr);
d1027 1
a1027 1
	dis_ppc(addr, opcodes_1f, instr);
d1033 1
a1033 1
	dis_ppc(addr, opcodes_3a, instr);
d1039 1
a1039 1
	dis_ppc(addr, opcodes_3b, instr);
d1045 1
a1045 1
	dis_ppc(addr, opcodes_3e, instr);
d1051 1
a1051 1
	dis_ppc(addr, opcodes_3f, instr);
d1058 1
d1060 1
a1060 1
	char disasm_str[80];
d1062 3
a1064 2
	for (i=0; opcodeset[i].mask != 0; i++) {
		op = &opcodeset[i];
d1066 3
a1068 3
			disasm_fields(addr, op, instr, disasm_str,
			    sizeof disasm_str);
			db_printf("%s%s\n", op->name, disasm_str);
@


1.6.2.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a231 1

a393 1

a408 1

d646 1
a646 1
					    "0x%x (%s+0x%lx)", LI, name,
d684 1
a684 1
					    "0x%x (%s+0x%lx)", BD, name, offset);
@


1.5
log
@Fix the mask and sign extension for bl instruction which branch backwards.
When printing the address, address has already been added according to AA.
@
text
@d2 1
a2 1
/*	$OpenBSD: db_disasm.c,v 1.4 2002/09/15 09:01:59 deraadt Exp $	*/
d484 4
a487 4
	"dnz",
	"dnz",
	"dz",
	"dz",
d492 4
a495 4
	"dnz",
	"dnz",
	"dz",
	"dz",
d518 40
d676 1
d679 7
a685 4
			u_int BI;
			BI = extract_field(instr, 31 - 10, 5);
			if (BI != 0) {
			pstr += sprintf (pstr, "%d,", BI);
d687 6
a692 8
		}
		break;
	case Opf_BI1:
		{
			u_int BI;
			BI = extract_field(instr, 31 - 10, 5);
			if (BI != 0) {
			pstr += sprintf (pstr, "%d", BI);
d694 2
d703 2
a704 2
			if (BO < 8) {
				BI = extract_field(instr, 31 - 10, 5);
d706 2
a707 1
				    db_BOBI_cond[(BI & 0x3)|((BO & 1) << 2)]);
d709 2
@


1.4
log
@backout premature
@
text
@d2 1
a2 1
/*	$OpenBSD: db_disasm.c,v 1.2 2002/06/09 05:39:01 drahn Exp $	*/
d582 2
a583 2
			if (LI & 0x04000000) {
				LI &= ~0x7ffffff;
d592 1
a592 1
				pstr += sprintf (pstr, "0x%x (%s)", addr + LI,
d595 1
a595 1
				pstr += sprintf (pstr, "0x%x (%s+0x%x)", addr + LI,
d599 1
a599 1
				pstr += sprintf (pstr, "0x%x", addr + LI);
d625 1
a625 1
				pstr += sprintf (pstr, "0x%x (%s)", addr + BD,
d628 1
a628 1
				pstr += sprintf (pstr, "0x%x (%s+0x%x)", addr + BD,
d632 1
a632 1
				pstr += sprintf (pstr, "0x%x", addr + BD);
@


1.4.4.1
log
@sync
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1996, 2001, 2003 Dale Rahn. All rights reserved.
d6 1
d15 5
d31 1
a31 1
 */
d126 1
a126 1
	{ NULL,		0 }
d141 1
a141 3
    char *disasm_str, size_t bufsize);
void disasm_process_field(u_int32_t addr, instr_t instr, char **ppfmt,
    char *ppoutput, size_t bufsize);
a143 1

d152 3
a154 3
/*x08*/	op_base,	op_base,	op_base,	op_base,
/*x0C*/	op_base,	op_base,	op_base/*XXX*/,	op_base/*XXX*/,
/*x10*/	op_base,	op_base,	op_base,	op_cl_x13,
d157 1
a157 1
/*x1C*/	op_base,	op_base,	op_cl_x1e,	op_cl_x1f,
d164 1
a164 1
/*x38*/	op_ill,		op_ill,		op_cl_x3a,	op_cl_x3b,
d171 1
a171 1
 * I would recommend that this table be looked over for errors,
d191 2
a192 2
	{ "b",		0xfc000000, 0x40000000, "%{BO}%{LK}%{AA} %{BI}%{BD}" },
	{ "b",		0xfc000000, 0x48000000, "%{LK}%{AA} %{LI}" },
a462 6
/*
 * Extracts bits out of an instruction opcode, base indicates the lsb
 * to keep.
 * Note that this uses the PowerPC bit number for base, MSb == 0
 * because all of the documentation is written that way.
 */
d467 1
a467 1
	return ((value >> (31 - base)) & mask);
d484 4
a487 4
	"dnzf",
	"dnzf-",
	"dzf",
	"dzf-",
d492 4
a495 4
	"dnzt",
	"dnzt-",
	"dzt",
	"dzt-",
d518 1
a518 39
char *BItbl[] = {
	"", "gt", "eq", "so"
};

char BO_uses_tbl[32] = {
	/* 0 */ 1,
	/* 1 */ 1,
	/* 2 */ 1,
	/* 3 */ 1,
	/* 4 */ 0,
	/* 5 */ 0,
	/* 6 */ 0, /* invalid */
	/* 7 */ 0, /* invalid */
	/* 8 */ 1,
	/* 9 */ 1,
	/* a */ 1,
	/* b */ 1,
	/* c */ 0,
	/* d */ 0,
	/* e */ 0, /* invalid */
	/* f */ 1,
	/* 10 */        1,
	/* 11 */        1,
	/* 12 */        1,
	/* 13 */        1,
	/* 14 */        1,
	/* 15 */        0, /* invalid */
	/* 16 */        0, /* invalid */
	/* 17 */        0, /* invalid */
	/* 18 */        0, /* invalid */
	/* 19 */        0, /* invalid */
	/* 1a */        0, /* invalid */
	/* 1b */        0, /* invalid */
	/* 1c */        0, /* invalid */
	/* 1d */        0, /* invalid */
	/* 1e */        0, /* invalid */
	/* 1f */        0, /* invalid */
};

d520 1
a520 2
disasm_process_field(u_int32_t addr, instr_t instr, char **ppfmt,
    char *disasm_buf, size_t bufsize)
a522 1
	char lbuf[50];
d525 1
d532 1
a532 1
		printf("error in disasm fmt [%s]\n", pfmt);
d535 1
a535 3
	for (i = 0;
	    pfmt[i] != '\0' && pfmt[i] != '}' && i < sizeof(field);
	    i++) {
a537 4
	if (i == sizeof(field)) {
		printf("error in disasm fmt [%s]\n", pfmt);
		return;
	}
a539 1
		/* match following close paren { */
d550 1
d554 1
a554 1
			printf("unable to find variable [%s]\n", field);
d559 2
a560 3
			A = extract_field(instr, 15, 5);
			snprintf(lbuf, sizeof (lbuf), "r%d", A);
			strlcat (disasm_buf, lbuf, bufsize);
d566 1
a566 1
			A = extract_field(instr, 15, 5);
d568 1
a568 2
				snprintf(lbuf, sizeof (lbuf), "r%d,", A);
				strlcat (disasm_buf, lbuf, bufsize);
d574 1
a574 1
			strlcat (disasm_buf, "a", bufsize);
d580 1
a580 1
			LI = extract_field(instr, 29, 24);
d582 2
a583 2
			if (LI & 0x02000000) {
				LI |= ~0x03ffffff;
d592 2
a593 3
					snprintf(lbuf, sizeof (lbuf),
					    "0x%x (%s)", LI, name);
					strlcat (disasm_buf, lbuf, bufsize);
d595 2
a596 4
					snprintf(lbuf, sizeof (lbuf),
					    "0x%x (%s+0x%x)", LI, name,
					    offset);
					strlcat (disasm_buf, lbuf, bufsize);
d599 1
a599 2
				snprintf(lbuf, sizeof (lbuf), "0x%x", LI);
				strlcat (disasm_buf, lbuf, bufsize);
d606 2
a607 3
			B = extract_field(instr, 20, 5);
			snprintf(lbuf, sizeof (lbuf), "r%d", B);
			strlcat (disasm_buf, lbuf, bufsize);
d613 1
a613 1
			BD = extract_field(instr, 29, 14);
d625 2
a626 3
					snprintf(lbuf, sizeof (lbuf),
					    "0x%x (%s)", BD, name);
					strlcat (disasm_buf, lbuf, bufsize);
d628 2
a629 3
					snprintf(lbuf, sizeof (lbuf),
					    "0x%x (%s+0x%x)", BD, name, offset);
					strlcat (disasm_buf, lbuf, bufsize);
d632 1
a632 2
				snprintf(lbuf, sizeof (lbuf), "0x%x", BD);
				strlcat (disasm_buf, lbuf, bufsize);
a635 1
	case Opf_BI1:
d638 4
a641 8
			int BO, BI, cr, printcomma = 0;
			BO = extract_field(instr, 10, 5);
			BI = extract_field(instr, 15, 5);
			cr =  (BI >> 2) & 7;
			if (cr != 0) {
				snprintf(lbuf, sizeof (lbuf), "cr%d", cr);
				strlcat (disasm_buf, lbuf, bufsize);
				printcomma = 1;
d643 8
a650 9
			if (BO_uses_tbl[BO]) {
				if ((cr != 0) && ((BI & 3) != 0) &&
				    BO_uses_tbl[BO] != 0)
					strlcat (disasm_buf, "+", bufsize);

				snprintf(lbuf, sizeof (lbuf), "%s",
				    BItbl[BI & 3]);
				strlcat (disasm_buf, lbuf, bufsize);
				printcomma = 1;
a651 2
			if ((opf == Opf_BI) && printcomma)
				strlcat (disasm_buf, ",", bufsize);
d656 7
a662 8
			int BO, BI;
			BO = extract_field(instr, 10, 5);
			strlcat (disasm_buf, db_BO_op[BO], bufsize);
			if ((BO & 4) != 0) {
				BI = extract_field(instr, 15, 5);
				strlcat (disasm_buf,
				    db_BOBI_cond[(BI & 0x3)| (((BO & 8) >> 1))],
				    bufsize);
a663 2
				if (BO & 1)
					strlcat (disasm_buf, "-", bufsize);
d670 2
a671 3
			C = extract_field(instr, 25, 5);
			snprintf(lbuf, sizeof (lbuf), "r%d, ", C);
			strlcat (disasm_buf, lbuf, bufsize);
d677 2
a678 3
			CRM = extract_field(instr, 19, 8);
			snprintf(lbuf, sizeof (lbuf), "0x%x", CRM);
			strlcat (disasm_buf, lbuf, bufsize);
d684 2
a685 3
			FM = extract_field(instr, 10, 8);
			snprintf(lbuf, sizeof (lbuf), "%d", FM);
			strlcat (disasm_buf, lbuf, bufsize);
d690 1
a690 1
			strlcat (disasm_buf, "l", bufsize);
d696 2
a697 3
			MB = extract_field(instr, 20, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", MB);
			strlcat (disasm_buf, lbuf, bufsize);
d703 2
a704 3
			ME = extract_field(instr, 25, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", ME);
			strlcat (disasm_buf, lbuf, bufsize);
d710 1
a710 1
			NB = extract_field(instr, 20, 5);
d714 1
a714 2
			snprintf(lbuf, sizeof (lbuf), "%d", NB);
			strlcat (disasm_buf, lbuf, bufsize);
d719 1
a719 1
			strlcat (disasm_buf, "o", bufsize);
d724 1
a724 1
			strlcat (disasm_buf, ".", bufsize);
d732 2
a733 3
			D = extract_field(instr, 10, 5);
			snprintf(lbuf, sizeof (lbuf), "r%d", D);
			strlcat (disasm_buf, lbuf, bufsize);
d739 2
a740 3
			SH = extract_field(instr, 20, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", SH);
			strlcat (disasm_buf, lbuf, bufsize);
d747 2
a748 2
			IMM = extract_field(instr, 31, 16);
			if (IMM & 0x8000)
d750 2
a751 2
			snprintf(lbuf, sizeof (lbuf), "%d", IMM);
			strlcat (disasm_buf, lbuf, bufsize);
d757 2
a758 3
			IMM = extract_field(instr, 31, 16);
			snprintf(lbuf, sizeof (lbuf), "0x%x", IMM);
			strlcat (disasm_buf, lbuf, bufsize);
d764 2
a765 3
			SR = extract_field(instr, 15, 3);
			snprintf(lbuf, sizeof (lbuf), "sr%d", SR);
			strlcat (disasm_buf, lbuf, bufsize);
d771 2
a772 3
			TO = extract_field(instr, 10, 1);
			snprintf(lbuf, sizeof (lbuf), "%d", TO);
			strlcat (disasm_buf, lbuf, bufsize);
d778 2
a779 3
			crbA = extract_field(instr, 15, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", crbA);
			strlcat (disasm_buf, lbuf, bufsize);
d785 2
a786 3
			crbB = extract_field(instr, 20, 5);
			snprintf(lbuf, sizeof (lbuf), "%d", crbB);
			strlcat (disasm_buf, lbuf, bufsize);
d792 2
a793 3
			crfD = extract_field(instr, 8, 3);
			snprintf(lbuf, sizeof (lbuf), "crf%d", crfD);
			strlcat (disasm_buf, lbuf, bufsize);
d799 2
a800 3
			crfD = extract_field(instr, 8, 3);
			snprintf(lbuf, sizeof (lbuf), "crf%d", crfD);
			strlcat (disasm_buf, lbuf, bufsize);
d806 2
a807 3
			crfS = extract_field(instr, 13, 3);
			snprintf(lbuf, sizeof (lbuf), "%d", crfS);
			strlcat (disasm_buf, lbuf, bufsize);
d814 2
a815 2
			mbl = extract_field(instr, 25, 4);
			mbh = extract_field(instr, 26, 1);
d817 1
a817 2
			snprintf(lbuf, sizeof (lbuf), ", %d", mb);
			strlcat (disasm_buf, lbuf, bufsize);
d823 2
a824 2
			shl = extract_field(instr, 19, 4);
			shh = extract_field(instr, 20, 1);
d826 1
a826 2
			snprintf(lbuf, sizeof (lbuf), ", %d", sh);
			strlcat (disasm_buf, lbuf, bufsize);
d835 2
a836 2
			sprl = extract_field(instr, 15, 5);
			sprh = extract_field(instr, 20, 5);
d841 1
a841 1
			case	1:
d844 1
a844 1
			case	8:
d847 1
a847 1
			case	9:
d850 1
a850 1
			case	18:
d853 1
a853 1
			case	19:
d856 1
a856 1
			case	22:
d859 1
a859 1
			case	25:
d862 1
a862 1
			case	26:
d865 1
a865 1
			case	27:
d868 1
a868 1
			case	272:
d871 1
a871 1
			case	273:
d874 1
a874 1
			case	274:
d877 1
a877 1
			case	275:
d880 1
a880 1
			case	280:
d883 1
a883 1
			case	282:
d886 1
a886 1
			case	287:
d889 1
a889 1
			case	528:
d892 1
a892 1
			case	529:
d895 1
a895 1
			case	530:
d898 1
a898 1
			case	531:
d901 1
a901 1
			case	532:
d904 1
a904 1
			case	533:
d907 1
a907 1
			case	534:
d910 1
a910 1
			case	535:
d913 1
a913 1
			case	536:
d916 1
a916 1
			case	537:
d919 1
a919 1
			case	538:
d922 1
a922 1
			case	539:
d925 1
a925 1
			case	540:
d928 1
a928 1
			case	541:
d931 1
a931 1
			case	542:
d934 1
a934 1
			case	543:
d937 1
a937 1
			case	1013:
d944 1
a944 2
				snprintf(lbuf, sizeof (lbuf), "spr%d", spr);
				strlcat (disasm_buf, lbuf, bufsize);
d946 1
a946 2
				snprintf(lbuf, sizeof (lbuf), "%s", reg);
				strlcat (disasm_buf, lbuf, bufsize);
d955 3
a957 3
			char *reg = NULL;
			tbrl = extract_field(instr, 15, 5);
			tbrh = extract_field(instr, 20, 5);
d970 2
a971 3
			if (reg == NULL) {
				snprintf(lbuf, sizeof (lbuf), "tbr%d", tbr);
				strlcat (disasm_buf, lbuf, bufsize);
d973 1
a973 2
				snprintf(lbuf, sizeof (lbuf), "%s", reg);
				strlcat (disasm_buf, lbuf, bufsize);
d978 2
d983 1
a983 2
disasm_fields(u_int32_t addr, const struct opcode *popcode, instr_t instr,
    char *disasm_str, size_t bufsize)
d986 2
a987 1
	char cbuf[2];
d992 1
d996 1
a996 2
			disasm_process_field(addr, instr, &pfmt, disasm_str,
			    bufsize);
d998 2
a999 3
			cbuf[0] = *pfmt;
			cbuf[1] = '\0';
			strlcat(disasm_str, cbuf, bufsize);
d1003 1
d1009 1
a1009 1
	dis_ppc(addr, opcodes, instr);
d1015 1
a1015 1
	dis_ppc(addr, opcodes_13, instr);
d1021 1
a1021 1
	dis_ppc(addr, opcodes_1e, instr);
d1027 1
a1027 1
	dis_ppc(addr, opcodes_1f, instr);
d1033 1
a1033 1
	dis_ppc(addr, opcodes_3a, instr);
d1039 1
a1039 1
	dis_ppc(addr, opcodes_3b, instr);
d1045 1
a1045 1
	dis_ppc(addr, opcodes_3e, instr);
d1051 1
a1051 1
	dis_ppc(addr, opcodes_3f, instr);
d1058 1
d1060 1
a1060 1
	char disasm_str[80];
d1062 3
a1064 2
	for (i=0; opcodeset[i].mask != 0; i++) {
		op = &opcodeset[i];
d1066 3
a1068 3
			disasm_fields(addr, op, instr, disasm_str,
			    sizeof disasm_str);
			db_printf("%s%s\n", op->name, disasm_str);
@


1.3
log
@KNF
@
text
@a2 1

d6 1
d31 1
a31 1
 */
d126 1
a126 1
	{ NULL,		0 }
d152 1
a152 1
/*x08*/	op_base,	op_base,	op_base,	op_base,
d171 1
a171 1
 * I would recommend that this table be looked over for errors,
d175 1
a175 1

d560 1
a560 1
			pstr += sprintf(pstr, "r%d", A);
d568 1
a568 1
				pstr += sprintf(pstr, "r%d,", A);
d574 1
a574 1
			pstr += sprintf(pstr,"a");
d592 1
a592 1
				pstr += sprintf(pstr, "0x%x (%s)", addr + LI,
d595 1
a595 1
				pstr += sprintf(pstr, "0x%x (%s+0x%x)", addr + LI,
d599 1
a599 1
				pstr += sprintf(pstr, "0x%x", addr + LI);
d607 1
a607 1
			pstr += sprintf(pstr, "r%d", B);
d625 1
a625 1
				pstr += sprintf(pstr, "0x%x (%s)", addr + BD,
d628 1
a628 1
				pstr += sprintf(pstr, "0x%x (%s+0x%x)", addr + BD,
d632 1
a632 1
				pstr += sprintf(pstr, "0x%x", addr + BD);
d641 1
a641 1
			pstr += sprintf(pstr, "%d,", BI);
d650 1
a650 1
			pstr += sprintf(pstr, "%d", BI);
d658 1
a658 1
			pstr += sprintf(pstr ,"%s", db_BO_op[BO]);
d661 1
a661 1
				pstr += sprintf(pstr ,"%s",
d671 1
a671 1
			pstr += sprintf(pstr, "r%d, ", C);
d678 1
a678 1
			pstr += sprintf(pstr, "0x%x", CRM);
d685 1
a685 1
			pstr += sprintf(pstr, "%d", FM);
d690 1
a690 1
			pstr += sprintf(pstr,"l");
d697 1
a697 1
			pstr += sprintf(pstr, "%d", MB);
d704 1
a704 1
			pstr += sprintf(pstr, "%d", ME);
d714 1
a714 1
			pstr += sprintf(pstr, "%d", NB);
d733 1
a733 1
			pstr += sprintf(pstr, "r%d", D);
d740 1
a740 1
			pstr += sprintf(pstr, "%d", SH);
d751 1
a751 1
			pstr += sprintf(pstr, "%d", IMM);
d758 1
a758 1
			pstr += sprintf(pstr, "0x%x", IMM);
d765 1
a765 1
			pstr += sprintf(pstr, "sr%d", SR);
d772 1
a772 1
			pstr += sprintf(pstr, "%d", TO);
d779 1
a779 1
			pstr += sprintf(pstr, "%d", crbA);
d786 1
a786 1
			pstr += sprintf(pstr, "%d", crbB);
d793 1
a793 1
			pstr += sprintf(pstr, "crf%d", crfD);
d800 1
a800 1
			pstr += sprintf(pstr, "crf%d", crfD);
d807 1
a807 1
			pstr += sprintf(pstr, "%d", crfS);
d817 1
a817 1
			pstr += sprintf(pstr, ", %d", mb);
d826 1
a826 1
			pstr += sprintf(pstr, ", %d", sh);
d841 1
a841 1
			case	1:
d844 1
a844 1
			case	8:
d847 1
a847 1
			case	9:
d850 1
a850 1
			case	18:
d853 1
a853 1
			case	19:
d856 1
a856 1
			case	22:
d859 1
a859 1
			case	25:
d862 1
a862 1
			case	26:
d865 1
a865 1
			case	27:
d868 1
a868 1
			case	272:
d871 1
a871 1
			case	273:
d874 1
a874 1
			case	274:
d877 1
a877 1
			case	275:
d880 1
a880 1
			case	280:
d883 1
a883 1
			case	282:
d886 1
a886 1
			case	287:
d889 1
a889 1
			case	528:
d892 1
a892 1
			case	529:
d895 1
a895 1
			case	530:
d898 1
a898 1
			case	531:
d901 1
a901 1
			case	532:
d904 1
a904 1
			case	533:
d907 1
a907 1
			case	534:
d910 1
a910 1
			case	535:
d913 1
a913 1
			case	536:
d916 1
a916 1
			case	537:
d919 1
a919 1
			case	538:
d922 1
a922 1
			case	539:
d925 1
a925 1
			case	540:
d928 1
a928 1
			case	541:
d931 1
a931 1
			case	542:
d934 1
a934 1
			case	543:
d937 1
a937 1
			case	1013:
d944 1
a944 1
				pstr += sprintf(pstr, "spr%d", spr);
d946 1
a946 1
				pstr += sprintf(pstr, "%s", reg);
d971 1
a971 1
				pstr += sprintf(pstr, "tbr%d", tbr);
d973 1
a973 1
				pstr += sprintf(pstr, "%s", reg);
@


1.2
log
@KNF
@
text
@d2 2
a3 1
/*	$OpenBSD: db_disasm.c,v 1.1 2002/06/08 16:02:14 miod Exp $	*/
a6 1
 *   
d31 1
a31 1
 */  
d126 1
a126 1
	{ NULL,	 	0 }
d152 1
a152 1
/*x08*/	op_base,	op_base,	op_base,	op_base,	
d171 1
a171 1
 * I would recommend that this table be looked over for errors, 
d175 1
a175 1
	
d560 1
a560 1
			pstr += sprintf (pstr, "r%d", A);
d568 1
a568 1
				pstr += sprintf (pstr, "r%d,", A);
d574 1
a574 1
			pstr += sprintf (pstr,"a");
d592 1
a592 1
				pstr += sprintf (pstr, "0x%x (%s)", addr + LI,
d595 1
a595 1
				pstr += sprintf (pstr, "0x%x (%s+0x%x)", addr + LI,
d599 1
a599 1
				pstr += sprintf (pstr, "0x%x", addr + LI);
d607 1
a607 1
			pstr += sprintf (pstr, "r%d", B);
d625 1
a625 1
				pstr += sprintf (pstr, "0x%x (%s)", addr + BD,
d628 1
a628 1
				pstr += sprintf (pstr, "0x%x (%s+0x%x)", addr + BD,
d632 1
a632 1
				pstr += sprintf (pstr, "0x%x", addr + BD);
d641 1
a641 1
			pstr += sprintf (pstr, "%d,", BI);
d650 1
a650 1
			pstr += sprintf (pstr, "%d", BI);
d658 1
a658 1
			pstr += sprintf (pstr ,"%s", db_BO_op[BO]);
d661 1
a661 1
				pstr += sprintf (pstr ,"%s",
d671 1
a671 1
			pstr += sprintf (pstr, "r%d, ", C);
d678 1
a678 1
			pstr += sprintf (pstr, "0x%x", CRM);
d685 1
a685 1
			pstr += sprintf (pstr, "%d", FM);
d690 1
a690 1
			pstr += sprintf (pstr,"l");
d697 1
a697 1
			pstr += sprintf (pstr, "%d", MB);
d704 1
a704 1
			pstr += sprintf (pstr, "%d", ME);
d714 1
a714 1
			pstr += sprintf (pstr, "%d", NB);
d733 1
a733 1
			pstr += sprintf (pstr, "r%d", D);
d740 1
a740 1
			pstr += sprintf (pstr, "%d", SH);
d751 1
a751 1
			pstr += sprintf (pstr, "%d", IMM);
d758 1
a758 1
			pstr += sprintf (pstr, "0x%x", IMM);
d765 1
a765 1
			pstr += sprintf (pstr, "sr%d", SR);
d772 1
a772 1
			pstr += sprintf (pstr, "%d", TO);
d779 1
a779 1
			pstr += sprintf (pstr, "%d", crbA);
d786 1
a786 1
			pstr += sprintf (pstr, "%d", crbB);
d793 1
a793 1
			pstr += sprintf (pstr, "crf%d", crfD);
d800 1
a800 1
			pstr += sprintf (pstr, "crf%d", crfD);
d807 1
a807 1
			pstr += sprintf (pstr, "%d", crfS);
d817 1
a817 1
			pstr += sprintf (pstr, ", %d", mb);
d826 1
a826 1
			pstr += sprintf (pstr, ", %d", sh);
d841 1
a841 1
			case 	1:
d844 1
a844 1
			case 	8:
d847 1
a847 1
			case 	9:
d850 1
a850 1
			case 	18:
d853 1
a853 1
			case 	19:
d856 1
a856 1
			case 	22:
d859 1
a859 1
			case 	25:
d862 1
a862 1
			case 	26:
d865 1
a865 1
			case 	27:
d868 1
a868 1
			case 	272:
d871 1
a871 1
			case 	273:
d874 1
a874 1
			case 	274:
d877 1
a877 1
			case 	275:
d880 1
a880 1
			case 	280:
d883 1
a883 1
			case 	282:
d886 1
a886 1
			case 	287:
d889 1
a889 1
			case 	528:
d892 1
a892 1
			case 	529:
d895 1
a895 1
			case 	530:
d898 1
a898 1
			case 	531:
d901 1
a901 1
			case 	532:
d904 1
a904 1
			case 	533:
d907 1
a907 1
			case 	534:
d910 1
a910 1
			case 	535:
d913 1
a913 1
			case 	536:
d916 1
a916 1
			case 	537:
d919 1
a919 1
			case 	538:
d922 1
a922 1
			case 	539:
d925 1
a925 1
			case 	540:
d928 1
a928 1
			case 	541:
d931 1
a931 1
			case 	542:
d934 1
a934 1
			case 	543:
d937 1
a937 1
			case 	1013:
d944 1
a944 1
				pstr += sprintf (pstr, "spr%d", spr);
d946 1
a946 1
				pstr += sprintf (pstr, "%s", reg);
d971 1
a971 1
				pstr += sprintf (pstr, "tbr%d", tbr);
d973 1
a973 1
				pstr += sprintf (pstr, "%s", reg);
@


1.1
log
@One ddb to rule them all.

Move the ddb files form macppc/macppc to powerpc/ddb, so that mvmeppc
can benefit from the better ddb that was in macppc.
db_interface.c is left as an md part.
@
text
@d2 1
a2 1
/*	$OpenBSD: db_disasm.c,v 1.8 2001/09/21 17:55:39 miod Exp $	*/
d988 1
a988 1
	if(popcode->decode_str == NULL || popcode->decode_str[0] == '0') {
d1062 3
a1064 4
	for (   i=0, op = &opcodeset[0];
		found == 0 && op->mask != 0;
		i++, op= &opcodeset[i] )
	{
@

