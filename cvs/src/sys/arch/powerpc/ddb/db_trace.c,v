head	1.12;
access;
symbols
	OPENBSD_6_1:1.11.0.4
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.8.0.2
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.6.0.4
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.4.0.44
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.40
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.38
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.36
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.34
	OPENBSD_5_0:1.4.0.32
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.30
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.28
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.24
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.26
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.22
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.20
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.18
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.16
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.14
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.12
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.10
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.8
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.6
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.4
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	UBC_SYNC_A:1.3
	SMP:1.3.0.4
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	UBC:1.1.0.4
	UBC_SYNC_B:1.1
	OPENBSD_3_2:1.1.0.2
	OPENBSD_3_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.12
date	2017.05.30.15.39.05;	author mpi;	state Exp;
branches;
next	1.11;
commitid	PnZZkFEIj4rPydZo;

1.11
date	2017.01.24.00.58.55;	author mpi;	state Exp;
branches;
next	1.10;
commitid	r0ks7yUPmANG37rA;

1.10
date	2016.09.10.06.36.26;	author jasper;	state Exp;
branches;
next	1.9;
commitid	5zt7PjkXY2TQIokA;

1.9
date	2016.09.09.19.42.30;	author jasper;	state Exp;
branches;
next	1.8;
commitid	Qbet0NVZpZWm8AJv;

1.8
date	2016.03.05.17.24.27;	author mpi;	state Exp;
branches;
next	1.7;
commitid	oo3LXu9V3TFs8Av3;

1.7
date	2016.03.02.10.41.08;	author mpi;	state Exp;
branches;
next	1.6;
commitid	tgpPisVr93K5OCID;

1.6
date	2014.09.06.09.42.23;	author mpi;	state Exp;
branches;
next	1.5;
commitid	4fHo5VOQyKp2KbTB;

1.5
date	2014.07.13.12.11.01;	author jasper;	state Exp;
branches;
next	1.4;
commitid	XHZxhpAa5R1Ymp1z;

1.4
date	2003.10.15.01.06.13;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.26.21.54.44;	author drahn;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2003.02.12.22.41.35;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.08.16.02.14;	author miod;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.05.19.21.49.44;	author tedu;	state Exp;
branches;
next	;

1.3.4.1
date	2004.02.19.10.49.57;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Kill db_sym_t.

ok deraadt@@, kettenis@@, jasper@@
@
text
@/*	$OpenBSD: db_trace.c,v 1.11 2017/01/24 00:58:55 mpi Exp $	*/
/*	$NetBSD: db_trace.c,v 1.15 1996/02/22 23:23:41 gwr Exp $	*/

/*
 * Mach Operating System
 * Copyright (c) 1992 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/user.h>

#include <uvm/uvm_extern.h>

#include <machine/db_machdep.h>
#include <machine/signal.h>
#include <machine/pcb.h>
#include <machine/pmap.h>

#include <ddb/db_access.h>
#include <ddb/db_sym.h>
#include <ddb/db_variables.h>
#include <ddb/db_interface.h>
#include <ddb/db_output.h>

db_regs_t ddb_regs;

struct db_variable db_regs[] = {
	{ "r0",  (long *)&ddb_regs.fixreg[0],	FCN_NULL },
	{ "r1",  (long *)&ddb_regs.fixreg[1],	FCN_NULL },
	{ "r2",  (long *)&ddb_regs.fixreg[2],	FCN_NULL },
	{ "r3",  (long *)&ddb_regs.fixreg[3],	FCN_NULL },
	{ "r4",  (long *)&ddb_regs.fixreg[4],	FCN_NULL },
	{ "r5",  (long *)&ddb_regs.fixreg[5],	FCN_NULL },
	{ "r6",  (long *)&ddb_regs.fixreg[6],	FCN_NULL },
	{ "r7",  (long *)&ddb_regs.fixreg[7],	FCN_NULL },
	{ "r8",  (long *)&ddb_regs.fixreg[8],	FCN_NULL },
	{ "r9",  (long *)&ddb_regs.fixreg[9],	FCN_NULL },
	{ "r10", (long *)&ddb_regs.fixreg[10],	FCN_NULL },
	{ "r11", (long *)&ddb_regs.fixreg[11],	FCN_NULL },
	{ "r12", (long *)&ddb_regs.fixreg[12],	FCN_NULL },
	{ "r13", (long *)&ddb_regs.fixreg[13],	FCN_NULL },
	{ "r14", (long *)&ddb_regs.fixreg[13],	FCN_NULL },
	{ "r15", (long *)&ddb_regs.fixreg[13],	FCN_NULL },
	{ "r16", (long *)&ddb_regs.fixreg[13],	FCN_NULL },
	{ "r17", (long *)&ddb_regs.fixreg[17],	FCN_NULL },
	{ "r18", (long *)&ddb_regs.fixreg[18],	FCN_NULL },
	{ "r19", (long *)&ddb_regs.fixreg[19],	FCN_NULL },
	{ "r20", (long *)&ddb_regs.fixreg[20],	FCN_NULL },
	{ "r21", (long *)&ddb_regs.fixreg[21],	FCN_NULL },
	{ "r22", (long *)&ddb_regs.fixreg[22],	FCN_NULL },
	{ "r23", (long *)&ddb_regs.fixreg[23],	FCN_NULL },
	{ "r24", (long *)&ddb_regs.fixreg[24],	FCN_NULL },
	{ "r25", (long *)&ddb_regs.fixreg[25],	FCN_NULL },
	{ "r26", (long *)&ddb_regs.fixreg[26],	FCN_NULL },
	{ "r27", (long *)&ddb_regs.fixreg[27],	FCN_NULL },
	{ "r28", (long *)&ddb_regs.fixreg[28],	FCN_NULL },
	{ "r29", (long *)&ddb_regs.fixreg[29],	FCN_NULL },
	{ "r30", (long *)&ddb_regs.fixreg[30],	FCN_NULL },
	{ "r31", (long *)&ddb_regs.fixreg[31],	FCN_NULL },
	{ "lr",  (long *)&ddb_regs.lr,		FCN_NULL },
	{ "cr",  (long *)&ddb_regs.cr,		FCN_NULL },
	{ "xer", (long *)&ddb_regs.xer,		FCN_NULL },
	{ "ctr", (long *)&ddb_regs.ctr,		FCN_NULL },
	{ "iar", (long *)&ddb_regs.srr0,		FCN_NULL },
	{ "msr", (long *)&ddb_regs.srr1,		FCN_NULL },
};

struct db_variable *db_eregs = db_regs + nitems(db_regs);

/*
 * this is probably hackery.
 */
void
db_save_regs(struct trapframe *frame)
{
	bcopy(frame, &ddb_regs, sizeof (struct trapframe));
}

/* from locore.S */
extern db_addr_t trapexit;
extern db_addr_t esym;
#define	INTSTK		(8*1024)	/* 8K interrupt stack */

#define	INKERNEL(va)	(((vaddr_t)(va)) >= VM_MIN_KERNEL_ADDRESS &&	\
			((vaddr_t)(va)) < VM_MAX_KERNEL_ADDRESS)

#define	ININTSTK(va)	(((vaddr_t)(va)) >= round_page(esym) &&		\
			((vaddr_t)(va)) < (round_page(esym) + INTSTK))

/*
 *	Frame tracing.
 */
void
db_stack_trace_print(db_expr_t addr, int have_addr, db_expr_t count,
    char *modif, int (*pr)(const char *, ...))
{
	db_addr_t	 lr, sp, lastsp;
	db_expr_t	 offset;
	Elf_Sym		*sym;
	char		*name;
	char		 c, *cp = modif;
	int		 trace_proc = 0;

	while ((c = *cp++) != 0) {
		if (c == 'p')
			trace_proc = 1;
	}

	if (!have_addr) {
		sp = ddb_regs.fixreg[1];
		lr = ddb_regs.srr0;
	} else {
		if (trace_proc) {
			struct proc *p = tfind((pid_t)addr);
			if (p == NULL) {
				(*pr) ("not found\n");
				return;
			}
			addr = p->p_addr->u_pcb.pcb_sp;
		}
		sp = addr;
		db_read_bytes(sp + 4, sizeof(db_addr_t), (char *)&lr);
	}

	while (count && sp != 0) {
		/*
		 * lr contains the return address, so adjust its value
		 * to display the offset of the calling address.
		 */
		sym = db_search_symbol(lr - 4, DB_STGY_ANY, &offset);
		db_symbol_values(sym, &name, NULL);

		if (name == NULL || strcmp(name, "end") == 0) {
			(*pr)("at 0x%lx", lr - 4);
		} else {
			(*pr)("%s() at ", name);
			db_printsym(lr - 4, DB_STGY_PROC, pr);
		}
		(*pr)("\n");

		lastsp = sp;

		/*
		 * Abuse the fact that the return address of the trap()
		 * function is always 'trapexit'.
		 */
		if (lr == (db_addr_t)&trapexit) {
			struct trapframe *tf = (struct trapframe *)(sp + 8);
			uint32_t code = tf->fixreg[0];
			uint32_t type = tf->exc;

			if (tf->srr1 & PSL_PR)
				type |= EXC_USER;

			if (type == (EXC_SC|EXC_USER))
				(*pr)("--- syscall (number %d) ---\n", code);
			else
				(*pr)("--- trap (type 0x%x) ---\n", type);
		}

		db_read_bytes(sp, sizeof(db_addr_t), (char *)&sp);
		if (sp == 0)
			break;

		db_read_bytes(sp + 4, sizeof(db_addr_t), (char *)&lr);

		if (INKERNEL(sp)) {
			if (sp <= lastsp) {
				(*pr)("Bad frame pointer: 0x%lx\n", sp);
				break;
			}

			if (ININTSTK(lastsp))
				(*pr)("--- interrupt ---\n");

		} else  {
			if (!ININTSTK(sp)) {
				(*pr)("End of kernel: 0x%lx\n", sp);
				break;
			}
		}
		--count;
	}
	(*pr)("end trace frame: 0x%lx, count: %d\n", sp, count);
}
@


1.11
log
@Rename pfind(9) into tfind(9) to reflect that it deals with threads.

While here document prfind(9.

with and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.10 2016/09/10 06:36:26 jasper Exp $	*/
d122 1
a122 1
	db_sym_t	 sym;
@


1.10
log
@take it one step further and bring the message inline with arm/sparc64

pointed out by guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.9 2016/09/09 19:42:30 jasper Exp $	*/
d137 1
a137 1
			struct proc *p = pfind((pid_t)addr);
@


1.9
log
@don't hardcode the filename in an error message; use the function name instead

ok jsg@@ (who spotted the powerpc straggler too) millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.8 2016/03/05 17:24:27 mpi Exp $	*/
d139 1
a139 1
				(*pr) ("%s: process not found\n", __func__);
@


1.8
log
@Define db_reg_t like the other archs by typedef'ing "struct trapframe".

This will allow us to use some of the DDB macros on trapframe which are
not DDB_REGS.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.7 2016/03/02 10:41:08 mpi Exp $	*/
d139 1
a139 1
				(*pr) ("db_trace.c: process not found\n");
@


1.7
log
@DDB_REGS -> ddb_regs in db_regs[], no reason to be different.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.6 2014/09/06 09:42:23 mpi Exp $	*/
d51 38
a88 38
	{ "r0",  (long *)&ddb_regs.tf.fixreg[0],	FCN_NULL },
	{ "r1",  (long *)&ddb_regs.tf.fixreg[1],	FCN_NULL },
	{ "r2",  (long *)&ddb_regs.tf.fixreg[2],	FCN_NULL },
	{ "r3",  (long *)&ddb_regs.tf.fixreg[3],	FCN_NULL },
	{ "r4",  (long *)&ddb_regs.tf.fixreg[4],	FCN_NULL },
	{ "r5",  (long *)&ddb_regs.tf.fixreg[5],	FCN_NULL },
	{ "r6",  (long *)&ddb_regs.tf.fixreg[6],	FCN_NULL },
	{ "r7",  (long *)&ddb_regs.tf.fixreg[7],	FCN_NULL },
	{ "r8",  (long *)&ddb_regs.tf.fixreg[8],	FCN_NULL },
	{ "r9",  (long *)&ddb_regs.tf.fixreg[9],	FCN_NULL },
	{ "r10", (long *)&ddb_regs.tf.fixreg[10],	FCN_NULL },
	{ "r11", (long *)&ddb_regs.tf.fixreg[11],	FCN_NULL },
	{ "r12", (long *)&ddb_regs.tf.fixreg[12],	FCN_NULL },
	{ "r13", (long *)&ddb_regs.tf.fixreg[13],	FCN_NULL },
	{ "r14", (long *)&ddb_regs.tf.fixreg[13],	FCN_NULL },
	{ "r15", (long *)&ddb_regs.tf.fixreg[13],	FCN_NULL },
	{ "r16", (long *)&ddb_regs.tf.fixreg[13],	FCN_NULL },
	{ "r17", (long *)&ddb_regs.tf.fixreg[17],	FCN_NULL },
	{ "r18", (long *)&ddb_regs.tf.fixreg[18],	FCN_NULL },
	{ "r19", (long *)&ddb_regs.tf.fixreg[19],	FCN_NULL },
	{ "r20", (long *)&ddb_regs.tf.fixreg[20],	FCN_NULL },
	{ "r21", (long *)&ddb_regs.tf.fixreg[21],	FCN_NULL },
	{ "r22", (long *)&ddb_regs.tf.fixreg[22],	FCN_NULL },
	{ "r23", (long *)&ddb_regs.tf.fixreg[23],	FCN_NULL },
	{ "r24", (long *)&ddb_regs.tf.fixreg[24],	FCN_NULL },
	{ "r25", (long *)&ddb_regs.tf.fixreg[25],	FCN_NULL },
	{ "r26", (long *)&ddb_regs.tf.fixreg[26],	FCN_NULL },
	{ "r27", (long *)&ddb_regs.tf.fixreg[27],	FCN_NULL },
	{ "r28", (long *)&ddb_regs.tf.fixreg[28],	FCN_NULL },
	{ "r29", (long *)&ddb_regs.tf.fixreg[29],	FCN_NULL },
	{ "r30", (long *)&ddb_regs.tf.fixreg[30],	FCN_NULL },
	{ "r31", (long *)&ddb_regs.tf.fixreg[31],	FCN_NULL },
	{ "lr",  (long *)&ddb_regs.tf.lr,		FCN_NULL },
	{ "cr",  (long *)&ddb_regs.tf.cr,		FCN_NULL },
	{ "xer", (long *)&ddb_regs.tf.xer,		FCN_NULL },
	{ "ctr", (long *)&ddb_regs.tf.ctr,		FCN_NULL },
	{ "iar", (long *)&ddb_regs.tf.srr0,		FCN_NULL },
	{ "msr", (long *)&ddb_regs.tf.srr1,		FCN_NULL },
d99 1
a99 1
	bcopy(frame, &(ddb_regs.tf), sizeof (struct trapframe));
d133 2
a134 2
		sp = ddb_regs.tf.fixreg[1];
		lr = ddb_regs.tf.srr0;
@


1.6
log
@Rewrite the PowerPC stack dump routine to delimit the trap & interrupt
contexts with markers (---like on x86---) and print the associated type
or number when available.

While here, gyp' the support for process tracing (tr /p).

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.5 2014/07/13 12:11:01 jasper Exp $	*/
d51 38
a88 38
	{ "r0",  (long *)&(DDB_REGS->tf.fixreg[0]),	FCN_NULL },
	{ "r1",  (long *)&(DDB_REGS->tf.fixreg[1]),	FCN_NULL },
	{ "r2",  (long *)&(DDB_REGS->tf.fixreg[2]),	FCN_NULL },
	{ "r3",  (long *)&(DDB_REGS->tf.fixreg[3]),	FCN_NULL },
	{ "r4",  (long *)&(DDB_REGS->tf.fixreg[4]),	FCN_NULL },
	{ "r5",  (long *)&(DDB_REGS->tf.fixreg[5]),	FCN_NULL },
	{ "r6",  (long *)&(DDB_REGS->tf.fixreg[6]),	FCN_NULL },
	{ "r7",  (long *)&(DDB_REGS->tf.fixreg[7]),	FCN_NULL },
	{ "r8",  (long *)&(DDB_REGS->tf.fixreg[8]),	FCN_NULL },
	{ "r9",  (long *)&(DDB_REGS->tf.fixreg[9]),	FCN_NULL },
	{ "r10", (long *)&(DDB_REGS->tf.fixreg[10]),	FCN_NULL },
	{ "r11", (long *)&(DDB_REGS->tf.fixreg[11]),	FCN_NULL },
	{ "r12", (long *)&(DDB_REGS->tf.fixreg[12]),	FCN_NULL },
	{ "r13", (long *)&(DDB_REGS->tf.fixreg[13]),	FCN_NULL },
	{ "r14", (long *)&(DDB_REGS->tf.fixreg[13]),	FCN_NULL },
	{ "r15", (long *)&(DDB_REGS->tf.fixreg[13]),	FCN_NULL },
	{ "r16", (long *)&(DDB_REGS->tf.fixreg[13]),	FCN_NULL },
	{ "r17", (long *)&(DDB_REGS->tf.fixreg[17]),	FCN_NULL },
	{ "r18", (long *)&(DDB_REGS->tf.fixreg[18]),	FCN_NULL },
	{ "r19", (long *)&(DDB_REGS->tf.fixreg[19]),	FCN_NULL },
	{ "r20", (long *)&(DDB_REGS->tf.fixreg[20]),	FCN_NULL },
	{ "r21", (long *)&(DDB_REGS->tf.fixreg[21]),	FCN_NULL },
	{ "r22", (long *)&(DDB_REGS->tf.fixreg[22]),	FCN_NULL },
	{ "r23", (long *)&(DDB_REGS->tf.fixreg[23]),	FCN_NULL },
	{ "r24", (long *)&(DDB_REGS->tf.fixreg[24]),	FCN_NULL },
	{ "r25", (long *)&(DDB_REGS->tf.fixreg[25]),	FCN_NULL },
	{ "r26", (long *)&(DDB_REGS->tf.fixreg[26]),	FCN_NULL },
	{ "r27", (long *)&(DDB_REGS->tf.fixreg[27]),	FCN_NULL },
	{ "r28", (long *)&(DDB_REGS->tf.fixreg[28]),	FCN_NULL },
	{ "r29", (long *)&(DDB_REGS->tf.fixreg[29]),	FCN_NULL },
	{ "r30", (long *)&(DDB_REGS->tf.fixreg[30]),	FCN_NULL },
	{ "r31", (long *)&(DDB_REGS->tf.fixreg[31]),	FCN_NULL },
	{ "lr", (long *)&(DDB_REGS->tf.lr),	FCN_NULL },
	{ "cr", (long *)&(DDB_REGS->tf.cr),	FCN_NULL },
	{ "xer", (long *)&(DDB_REGS->tf.xer),	FCN_NULL },
	{ "ctr", (long *)&(DDB_REGS->tf.ctr),	FCN_NULL },
	{ "iar", (long *)&(DDB_REGS->tf.srr0),	FCN_NULL },
	{ "msr", (long *)&(DDB_REGS->tf.srr1),	FCN_NULL },
@


1.5
log
@use nitems() instead of handrolling something identical

ok mpi@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.4 2003/10/15 01:06:13 drahn Exp $	*/
d33 3
d40 1
a47 2
int db_read32(u_int32_t paddr, u_int32_t *value);

a92 2
extern label_t	*db_recover;

d102 4
a105 29
int
db_read32(u_int32_t paddr, u_int32_t *value)
{
	faultbuf env;
	faultbuf *old_onfault = curpcb->pcb_onfault;
	if (setfault(&env)) {
		curpcb->pcb_onfault = old_onfault;
		return EFAULT;
	}
	*value = *(u_int32_t *)paddr;
	curpcb->pcb_onfault = old_onfault;
	return 0;
}

db_expr_t
db_dumpframe(u_int32_t pframe, int (*pr)(const char *, ...))
{
	u_int32_t nextframe;
	u_int32_t lr;
	char *name;
	db_expr_t offset;

	if (db_read32(pframe, &nextframe) == EFAULT) {
		return 0;
	}

	if (db_read32(pframe+4, &lr) == EFAULT) {
		return 0;
	}
d107 2
a108 7
	db_find_sym_and_offset(lr-4, &name, &offset);
	if (!name) {
		name = "0";
		offset = lr-4;
	}
	(*pr)("%08x: %s+0x%x fp %x nfp %x\n",
		lr-4, name, offset, pframe, nextframe);
d110 2
a111 2
	return nextframe;
}
d120 86
a205 9

	if (count == 0 || count == -1)
		count = INT_MAX;
	if (have_addr == 0){
		addr = ddb_regs.tf.fixreg[1];
	}
	while (addr != 0 && count > 0) {
		addr = db_dumpframe(addr, pr);
		count --;
d207 1
@


1.4
log
@Housecleaning, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.3 2003/02/26 21:54:44 drahn Exp $	*/
d89 1
a89 1
struct db_variable *db_eregs = db_regs + sizeof(db_regs)/sizeof(db_regs[0]);
@


1.3
log
@Remove an unnecessary structure copy from useage of setfault(), call
by reference, not by value, ok matthieu#, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.2 2003/02/12 22:41:35 jason Exp $	*/
d44 2
d88 1
a101 2
int db_read32(u_int32_t paddr, u_int32_t *value);

d142 1
d147 2
a148 6
db_stack_trace_print(addr, have_addr, count, modif, pr)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char		*modif;
	int		(*pr)(const char *, ...);
@


1.3.4.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a43 2
int db_read32(u_int32_t paddr, u_int32_t *value);

a85 1

d99 2
a140 1

d145 6
a150 2
db_stack_trace_print(db_expr_t addr, int have_addr, db_expr_t count,
    char *modif, int (*pr)(const char *, ...))
@


1.2
log
@move ddb_regs decl from .h to .c to avoid common
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.1 2002/06/08 16:02:14 miod Exp $	*/
d106 1
a106 1
	if (setfault(env)) {
@


1.1
log
@One ddb to rule them all.

Move the ddb files form macppc/macppc to powerpc/ddb, so that mvmeppc
can benefit from the better ddb that was in macppc.
db_interface.c is left as an md part.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.6 2002/05/18 09:49:17 art Exp $	*/
d43 2
@


1.1.4.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a43 2
db_regs_t ddb_regs;

d104 1
a104 1
	if (setfault(&env)) {
@


