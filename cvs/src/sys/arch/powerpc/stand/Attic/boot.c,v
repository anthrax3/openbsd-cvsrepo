head	1.14;
access;
symbols
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	UBC_SYNC_A:1.14
	UBC_SYNC_B:1.14
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.8
	OPENBSD_2_8:1.12.0.6
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.4
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.2
	SMP_BASE:1.12
	kame_19991208:1.8
	OPENBSD_2_6:1.7.0.6
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	powerpc_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2001.09.01.15.39.02;	author drahn;	state dead;
branches;
next	1.13;

1.13
date	2001.06.23.01.53.01;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.24.03.07.54;	author rahnds;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2000.01.22.03.27.52;	author rahnds;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.14.05.44.18;	author rahnds;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.14.05.42.17;	author rahnds;	state Exp;
branches;
next	1.8;

1.8
date	99.11.09.06.30.15;	author rahnds;	state Exp;
branches;
next	1.7;

1.7
date	98.08.07.02.10.24;	author rahnds;	state Exp;
branches;
next	1.6;

1.6
date	98.05.29.04.15.46;	author rahnds;	state Exp;
branches;
next	1.5;

1.5
date	97.04.01.21.01.42;	author rahnds;	state Exp;
branches;
next	1.4;

1.4
date	97.02.06.23.44.56;	author rahnds;	state Exp;
branches;
next	1.3;

1.3
date	97.01.09.03.52.51;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	96.12.28.06.31.12;	author rahnds;	state Exp;
branches;
next	1.1;

1.1
date	96.12.21.20.35.59;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.12.21.20.35.59;	author rahnds;	state Exp;
branches;
next	;

1.12.2.1
date	2001.07.04.10.23.09;	author niklas;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2001.10.31.03.07.56;	author nate;	state dead;
branches;
next	;


desc
@@


1.14
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/stand to macppc/stand
@
text
@/*	$OpenBSD: boot.c,v 1.13 2001/06/23 01:53:01 drahn Exp $	*/
/*	$NetBSD: boot.c,v 1.1 1997/04/16 20:29:17 thorpej Exp $	*/

/*
 * Copyright (c) 1997 Jason R. Thorpe.  All rights reserved.
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * ELF support derived from NetBSD/alpha's boot loader, written
 * by Christopher G. Demetriou.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * First try for the boot code
 *
 * Input syntax is:
 *	[promdev[{:|,}partition]]/[filename] [flags]
 */

#define	ELFSIZE		32		/* We use 32-bit ELF. */

#include <sys/param.h>
#include <sys/exec.h>
#include <sys/exec_elf.h>
#include <sys/reboot.h>
#include <sys/disklabel.h>

#include <lib/libkern/libkern.h>
#include <lib/libsa/stand.h>
#include <lib/libsa/loadfile.h>


#include <machine/cpu.h>

#include <powerpc/stand/ofdev.h>
#include <powerpc/stand/openfirm.h>

char bootdev[128];
char bootfile[128];
int boothowto;
int debug;

#ifdef POWERPC_BOOT_ELF
int	elf_exec __P((int, Elf32_Ehdr *, u_int32_t *, void **));
#endif

#ifdef POWERPC_BOOT_AOUT
int	aout_exec __P((int, struct exec *, u_int32_t *, void **));
#endif

static void
prom2boot(dev)
	char *dev;
{
	char *cp, *lp = 0;
	
	for (cp = dev; *cp; cp++)
		if (*cp == ':')
			lp = cp;
	if (!lp)
		lp = cp;
	*lp = 0;
}

static void
parseargs(str, howtop)
	char *str;
	int *howtop;
{
	char *cp;

	/* Allow user to drop back to the PROM. */
	if (strcmp(str, "exit") == 0)
		_rtt();

	*howtop = 0;
	if (str[0] == '\0') {
		return;
	}
	cp = str;
	while (*cp != 0) {
		/* check for - */
		if (*cp == '-') {
			/* start of options found */
			break;
		}
		while (*cp != 0 && *cp != ' ') {
			/* character in the middle of the name, skip */
			cp++;
		}
		while (*cp == ' ') {
			*cp++ = 0;
		}
	}
	if (!*cp)
		return;
	
	*cp++ = 0;
	while (*cp) {
		switch (*cp++) {
		case 'a':
			*howtop |= RB_ASKNAME;
			break;
		case 's':
			*howtop |= RB_SINGLE;
			break;
		case 'd':
			*howtop |= RB_KDB;
			debug = 1;
			break;
		}
	}
}

static void
chain(entry, args, ssym, esym)
	void (*entry)();
	char *args;
	void *ssym;
	void *esym;
{
	extern char end[];
	int l, machine_tag;

	freeall();

	/*
	 * Stash pointer to end of symbol table after the argument
	 * strings.
	 */
	l = strlen(args) + 1;
	bcopy(&ssym, args + l, sizeof(ssym));
	l += sizeof(ssym);
	bcopy(&esym, args + l, sizeof(esym));
	l += sizeof(esym);

#ifdef __notyet__
	/*
	 * Tell the kernel we're an OpenFirmware system.
	 */
	machine_tag = POWERPC_MACHINE_OPENFIRMWARE;
	bcopy(&machine_tag, args + l, sizeof(machine_tag));
	l += sizeof(machine_tag);
#endif

	OF_chain((void *)RELOC, end - (char *)RELOC, entry, args, l);
	panic("chain");
}

int
main()
{
	int chosen;
	char bootline[512];		/* Should check size? */
	char *cp;
	u_long marks[MARK_MAX];
	u_int32_t entry;
	void *ssym, *esym;
	int fd;
	
	printf("\n>> OpenBSD/powerpc Boot\n");

	/*
	 * Get the boot arguments from Openfirmware
	 */
	if ((chosen = OF_finddevice("/chosen")) == -1
	    || OF_getprop(chosen, "bootpath", bootdev, sizeof bootdev) < 0
	    || OF_getprop(chosen, "bootargs", bootline, sizeof bootline) < 0) {
		printf("Invalid Openfirmware environment\n");
		exit();
	}
	prom2boot(bootdev);
	parseargs(bootline, &boothowto);
	for (;;) {
		if (boothowto & RB_ASKNAME) {
			printf("Boot: ");
			gets(bootline);
			parseargs(bootline, &boothowto);
		}
		marks[MARK_START] = 0;
		if (loadfile(bootline, marks, LOAD_ALL) >= 0)
			break;
		if (errno)
			printf("open %s: %s\n", opened_name, strerror(errno));
		boothowto |= RB_ASKNAME;
	}
#ifdef	__notyet__
	OF_setprop(chosen, "bootpath", opened_name, strlen(opened_name) + 1);
	cp = bootline;
#else
	strcpy(bootline, opened_name);
	cp = bootline + strlen(bootline);
	*cp++ = ' ';
#endif
	*cp = '-';
	if (boothowto & RB_ASKNAME)
		*++cp = 'a';
	if (boothowto & RB_SINGLE)
		*++cp = 's';
	if (boothowto & RB_KDB)
		*++cp = 'd';
	if (*cp == '-')
#ifdef	__notyet__
		*cp = 0;
#else
		*--cp = 0;
#endif
	else
		*++cp = 0;
#ifdef	__notyet__
	OF_setprop(chosen, "bootargs", bootline, strlen(bootline) + 1);
#endif
	entry = marks[MARK_ENTRY];
	ssym = (void *)marks[MARK_SYM];
	esym = (void *)marks[MARK_END];

	chain ((void*)entry, bootline, ssym, esym);

	_rtt();
	return 0;
}
@


1.13
log
@Support for powerpc to load symbols, uses new libsa loadfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.13 2001/06/23 01:48:41 drahn Exp $	*/
@


1.12
log
@Previous fix to allow '-' in filenames did not work as desired,
causes a trailing ' ' to be on filenames and was not recognized if at
beginning of string. Fixed so those instances work also.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.11 2000/01/22 03:27:52 rahnds Exp $	*/
a47 3
#include <lib/libkern/libkern.h>
#include <lib/libsa/stand.h>

d54 5
a59 3
/*
#include <machine/machine_type.h>
*/
d142 1
a142 1
chain(entry, args, esym)
d145 1
d158 2
a176 288
loadfile(fd, args)
	int fd;
	char *args;
{
	union {
#ifdef POWERPC_BOOT_AOUT
		struct exec aout;
#endif
#ifdef POWERPC_BOOT_ELF
		Elf32_Ehdr elf;
#endif
	} hdr;
	int rval;
	u_int32_t entry;
	void *esym;

	rval = 1;
	esym = NULL;

	/* Load the header. */
	if (read(fd, &hdr, sizeof(hdr)) != sizeof(hdr)) {
		printf("read header: %s\n", strerror(errno));
		goto err;
	}

	/* Determine file type, load kernel. */
#ifdef POWERPC_BOOT_AOUT
	if (N_BADMAG(hdr.aout) == 0 && N_GETMID(hdr.aout) == MID_POWERPC) {
		rval = aout_exec(fd, &hdr.aout, &entry, &esym);
	} else
#endif
#ifdef POWERPC_BOOT_ELF
	if (IS_ELF(hdr.elf)) {
		rval = elf_exec(fd, &hdr.elf, &entry, &esym);
	} else
#endif
	{
		printf("unknown executable format\n");
	}

	if (rval)
		goto err;

	printf(" start=0x%x\n", entry);

	close(fd);

	chain((void *)entry, args, esym);
	/* NOTREACHED */

 err:
	close(fd);
	return (rval);
}

#ifdef POWERPC_BOOT_AOUT
int
aout_exec(fd, hdr, entryp, esymp)
	int fd;
	struct exec *hdr;
	u_int32_t *entryp;
	void **esymp;
{
	void *addr;
	int n, *paddr;

	/* Display the load address (entry point) for a.out. */
	printf("Booting %s @@ 0x%lx\n", opened_name, hdr->a_entry);
	addr = (void *)(hdr->a_entry);

	/*
	 * Determine memory needed for kernel and allocate it from
	 * the firmware.
	 */
	n = hdr->a_text + hdr->a_data + hdr->a_bss + hdr->a_syms + sizeof(int);
	if ((paddr = OF_claim(addr, n, 0)) == (int *)-1)
		panic("cannot claim memory");

	/* Load text. */
	lseek(fd, N_TXTOFF(*hdr), SEEK_SET);
	printf("%lu", hdr->a_text);
	if (read(fd, paddr, hdr->a_text) != hdr->a_text) {
		printf("read text: %s\n", strerror(errno));
		return (1);
	}
	syncicache((void *)paddr, hdr->a_text);

	/* Load data. */
	printf("+%lu", hdr->a_data);
	if (read(fd, (void *)paddr + hdr->a_text, hdr->a_data) != hdr->a_data) {
		printf("read data: %s\n", strerror(errno));
		return (1);
	}

	/* Zero BSS. */
	printf("+%lu", hdr->a_bss);
	bzero((void *)paddr + hdr->a_text + hdr->a_data, hdr->a_bss);

	/* Symbols. */
	*esymp = paddr;
	paddr = (int *)((void *)paddr + hdr->a_text + hdr->a_data + hdr->a_bss);
	*paddr++ = hdr->a_syms;
	if (hdr->a_syms) {
		printf(" [%lu", hdr->a_syms);
		if (read(fd, paddr, hdr->a_syms) != hdr->a_syms) {
			printf("read symbols: %s\n", strerror(errno));
			return (1);
		}
		paddr = (int *)((void *)paddr + hdr->a_syms);
		if (read(fd, &n, sizeof(int)) != sizeof(int)) {
			printf("read symbols: %s\n", strerror(errno));
			return (1);
		}
		if (OF_claim((void *)paddr, n + sizeof(int), 0) == (void *)-1)
			panic("cannot claim memory");
		*paddr++ = n;
		if (read(fd, paddr, n - sizeof(int)) != n - sizeof(int)) {
			printf("read symbols: %s\n", strerror(errno));
			return (1);
		}
		printf("+%d]", n - sizeof(int));
		*esymp = paddr + (n - sizeof(int));
	}

	*entryp = hdr->a_entry;
	return (0);
}
#endif /* POWERPC_BOOT_AOUT */

#define LOAD_HDR 1
#define LOAD_SYM 2
#ifdef POWERPC_BOOT_ELF
int
elf_exec(fd, elf, entryp, esymp)
	int fd;
	Elf32_Ehdr *elf;
	u_int32_t *entryp;
	void **esymp;
	
{
	Elf32_Shdr *shp;
	Elf32_Off off;
	void *addr;
	size_t size;
	int i, first = 1;
	int n;
	u_int32_t maxp = 0; /*  correct type? */
	int flags = LOAD_HDR| LOAD_SYM;

	/*
	 * Don't display load address for ELF; it's encoded in
	 * each section.
	 */
	printf("Booting %s\n", opened_name);

	for (i = 0; i < elf->e_phnum; i++) {
		Elf32_Phdr phdr;
		(void)lseek(fd, elf->e_phoff + sizeof(phdr) * i, SEEK_SET);
		if (read(fd, (void *)&phdr, sizeof(phdr)) != sizeof(phdr)) {
			printf("read phdr: %s\n", strerror(errno));
			return (1);
		}
		if (phdr.p_type != PT_LOAD ||
		    (phdr.p_flags & (PF_W|PF_X)) == 0)
			continue;

		/* Read in segment. */
		printf("%s%lu@@0x%lx", first ? "" : "+", phdr.p_filesz,
		    (u_long)phdr.p_vaddr);
		(void)lseek(fd, phdr.p_offset, SEEK_SET);
		if (OF_claim((void *)phdr.p_vaddr, phdr.p_memsz, 0) ==
		    (void *)-1)
			panic("cannot claim memory");
		maxp = maxp > (phdr.p_vaddr+ phdr.p_memsz) ?
			maxp : (phdr.p_vaddr+ phdr.p_memsz);
		if (read(fd, (void *)phdr.p_vaddr, phdr.p_filesz) !=
		    phdr.p_filesz) {
			printf("read segment: %s\n", strerror(errno));
			return (1);
		}
		syncicache((void *)phdr.p_vaddr, phdr.p_filesz);

		/* Zero BSS. */
		if (phdr.p_filesz < phdr.p_memsz) {
			printf("+%lu@@0x%lx", phdr.p_memsz - phdr.p_filesz,
			    (u_long)(phdr.p_vaddr + phdr.p_filesz));
			bzero((void *)(phdr.p_vaddr + phdr.p_filesz),
			    phdr.p_memsz - phdr.p_filesz);
		}
		first = 0;
	}
	*esymp = 0; /* in case it is not set later */

#if 0
	/*
	 * Copy the ELF and section headers.
	 */
	maxp = roundup(maxp, sizeof(long));
	if (flags & (LOAD_HDR|COUNT_HDR)) {
		if (OF_claim((void *)maxp, sizeof(Elf_Ehdr), 0) ==
		    (void *)-1)
			panic("cannot claim memory");
		elfp = maxp;
		maxp += sizeof(Elf_Ehdr);
	}

	if (flags & (LOAD_SYM|COUNT_SYM)) {
		if (lseek(fd, elf->e_shoff, SEEK_SET) == -1)  {
			WARN(("lseek section headers"));
			return 1;
		}
		sz = elf->e_shnum * sizeof(Elf_Shdr);

		if (OF_claim((void *)maxp, sizeof(Elf_Ehdr), 0) ==
		    (void *)-1)
			panic("cannot claim memory");
		shpp = maxp;
		maxp += roundup(sz, sizeof(long)); 

		if (read(fd, shpp, sz) != sz) {
			WARN(("read section headers"));
			return 1;
		}
		/*
		 * Now load the symbol sections themselves.  Make sure the
		 * sections are aligned. Don't bother with string tables if
		 * there are no symbol sections.
		 */
		off = roundup((sizeof(Elf_Ehdr) + sz), sizeof(long));

		for (havesyms = i = 0; i < elf->e_shnum; i++)
			if (shpp[i].sh_type == Elf_sht_symtab)
				havesyms = 1;

		for (first = 1, i = 0; i < elf->e_shnum; i++) {
			if (shpp[i].sh_type == Elf_sht_symtab ||
			    shpp[i].sh_type == Elf_sht_strtab) {
				if (havesyms && (flags & LOAD_SYM)) {
					PROGRESS(("%s%ld", first ? " [" : "+",
					    (u_long)shpp[i].sh_size));
					if (lseek(fd, shpp[i].sh_offset,
					    SEEK_SET) == -1) {
						WARN(("lseek symbols"));
						FREE(shp, sz);
						return 1;
					}
					if (READ(fd, maxp, shpp[i].sh_size) !=
					    shpp[i].sh_size) {
						WARN(("read symbols"));
						return 1;
					}
				}
				maxp += roundup(shpp[i].sh_size,
				    sizeof(long));
				shpp[i].sh_offset = off;
				off += roundup(shpp[i].sh_size, sizeof(long));
				first = 0;
			}
		}
		if (flags & LOAD_SYM) {
			BCOPY(shp, shpp, sz);

			if (first == 0)
				PROGRESS(("]"));
		}
	}

	/*
	 * Frob the copied ELF header to give information relative
	 * to elfp.
	 */
	if (flags & LOAD_HDR) {
		elf->e_phoff = 0;
		elf->e_shoff = sizeof(Elf_Ehdr);
		elf->e_phentsize = 0;
		elf->e_phnum = 0;
		BCOPY(elf, elfp, sizeof(*elf));
	}
#endif
	printf(" \n");


	*entryp = elf->e_entry;
	return (0);
}
#endif /* POWERPC_BOOT_ELF */

int
d182 3
d206 2
a207 1
		if ((fd = open(bootline, 0)) >= 0)
d239 5
a243 2
	/* XXX void, for now */
	(void)loadfile(fd, bootline);
@


1.12.2.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.12 2000/01/24 03:07:54 rahnds Exp $	*/
d48 3
a56 5
#include <lib/libkern/libkern.h>
#include <lib/libsa/stand.h>
#include <lib/libsa/loadfile.h>


d58 3
d143 1
a143 1
chain(entry, args, ssym, esym)
a145 1
	void *ssym;
a157 2
	bcopy(&ssym, args + l, sizeof(ssym));
	l += sizeof(ssym);
d175 288
a467 3
	u_long marks[MARK_MAX];
	u_int32_t entry;
	void *ssym, *esym;
d489 1
a489 2
		marks[MARK_START] = 0;
		if (loadfile(bootline, marks, LOAD_ALL) >= 0)
d521 2
a522 5
	entry = marks[MARK_ENTRY];
	ssym = (void *)marks[MARK_SYM];
	esym = (void *)marks[MARK_END];

	chain ((void*)entry, bootline, ssym, esym);
@


1.12.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.12.2.1 2001/07/04 10:23:09 niklas Exp $	*/
@


1.11
log
@do not interpret a '-' character in a file or bootpath as the beginning of
options, the dash character is only special if a space preceeds it.

fixes booting from "/pci/mac-io/ide/disk/bsd".
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.10 2000/01/14 05:44:18 rahnds Exp $	*/
d107 5
a111 2
	for (cp = &str[1]; *cp; cp++) {
		if (cp[-1] == ' ' && *cp == '-') {
d113 7
@


1.10
log
@Remove change that was checked in by accident with last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.9 2000/01/14 05:42:17 rahnds Exp $	*/
a82 2
	int handle;
	char devtype[16];
d104 5
a108 2
	for (cp = str; *cp; cp++)
		if (*cp == ' ' || *cp == '-')
d110 2
@


1.9
log
@

UVM changes mainly. As of this checkin UVM is still not working for powerpc
it has a copyin bug after device configuration. However to get these diffs
out of my tree.

All of the UVM code is currently inside ifdef UVM the kernel works fine
without option UVM. Config files have been left without UVM for now.

Prelimiary changes for busdma, (what UVM was wanted for).
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.8 1999/11/09 06:30:15 rahnds Exp $	*/
d457 1
a457 1
	printf("\n>> OpenBSD/powerpc Boot tst \n");
@


1.8
log
@Add OpenBSD tags.
changes to boot on Apple iMac G3 (333). ethernet address changes
Locore.c
	OpenBSD tag
	hack to delay decrementer exception until after bootload,
	apple OFW enables interrupts during "system calls"
	add OF_call_method, to make ofw call by name.
	Apple OFW can return unexpected values from getchar calls.
alloc.c
	OpenBSD tag
boot.c
	OpenBSD tag
	updated (but still unused load symbol code).
	Code cleanup for egcs.
cache.c
	OpenBSD tag
	use dcbst, not dcbf
	icbi has both arguments as registers, not constant and register.
net.c
	OpenBSD tag
netif_of.c
	OpenBSD tag
	add "local-mac-address" to methods of fetching mac address,
	it can be stored in that variable or in mac-address.
	support dma buffers,
	add additional return value for OF_read for network timeout purposes.
ofdev.c
	OpenBSD tag
	support dma buffers,
ofdev.h
	OpenBSD tag
	add dmabuf
	remove MAC default kernel def.
ofwmagic.S
	OpenBSD tag
openfirm.h
	OpenBSD tag
boot.mac/Makefile
	Build debug, - not used for version 3 apple openfirmware, ie imacs.
@
text
@d1 1
a1 1
/*	$OpenBSD:$	*/
d457 1
a457 1
	printf("\n>> OpenBSD/powerpc Boot\n");
@


1.7
log
@Remove floppy checks from ofwboot. Ramdisk is kernel, not loadef from floppy.
@
text
@d1 1
d291 2
d300 1
d308 2
d335 2
d348 1
a348 1
			bzero(phdr.p_vaddr + phdr.p_filesz,
d353 1
d355 1
a355 3
	printf(" \n");

#if 0 /* I want to rethink this... --thorpej@@netbsd.org */
d357 1
a357 1
	 * Compute the size of the symbol table.
d359 7
a365 7
	size = sizeof(Elf32_Ehdr) + (elf->e_shnum * sizeof(Elf32_Shdr));
	shp = addr = alloc(elf->e_shnum * sizeof(Elf32_Shdr));
	(void)lseek(fd, elf->e_shoff, SEEK_SET);
	if (read(fd, addr, elf->e_shnum * sizeof(Elf32_Shdr)) !=
	    elf->e_shnum * sizeof(Elf32_Shdr)) {
		printf("read section headers: %s\n", strerror(errno));
		return (1);
d367 5
a371 8
	for (i = 0; i < elf->e_shnum; i++, shp++) {
		if (shp->sh_type == Elf32_sht_null)
			continue;
		if (shp->sh_type != Elf32_sht_symtab
		    && shp->sh_type != Elf32_sht_strtab) {
			shp->sh_offset = 0; 
			shp->sh_type = Elf32_sht_nobits;
			continue;
d373 7
a379 3
		size += shp->sh_size;
	}
	shp = addr;
d381 42
a422 5
	/*
	 * Reserve memory for the symbols.
	 */
	if ((addr = OF_claim(0, size, NBPG)) == (void *)-1)
		panic("no space for symbol table");
d424 4
a427 11
	/*
	 * Copy the headers.
	 */
	elf->e_phoff = 0;
	elf->e_shoff = sizeof(Elf32_Ehdr);
	elf->e_phentsize = 0;
	elf->e_phnum = 0;
	bcopy(elf, addr, sizeof(Elf32_Ehdr));
	bcopy(shp, addr + sizeof(Elf32_Ehdr), elf->e_shnum * sizeof(Elf32_Shdr));
	free(shp, elf->e_shnum * sizeof(Elf32_Shdr));
	*ssymp = addr;
d430 2
a431 1
	 * Now load the symbol sections themselves.
d433 6
a438 19
	shp = addr + sizeof(Elf32_Ehdr);
	addr += sizeof(Elf32_Ehdr) + (elf->e_shnum * sizeof(Elf32_Shdr));
	off = sizeof(Elf32_Ehdr) + (elf->e_shnum * sizeof(Elf32_Shdr));
	for (first = 1, i = 0; i < elf->e_shnum; i++, shp++) {
		if (shp->sh_type == Elf32_sht_symtab
		    || shp->sh_type == Elf32_sht_strtab) {
			if (first)
				printf("symbols @@ 0x%lx ", (u_long)addr);
			printf("%s%d", first ? "" : "+", shp->sh_size);
			(void)lseek(fd, shp->sh_offset, SEEK_SET);
			if (read(fd, addr, shp->sh_size) != shp->sh_size) {
				printf("read symbols: %s\n", strerror(errno));
				return (1);
			}
			addr += shp->sh_size;
			shp->sh_offset = off;
			off += shp->sh_size;
			first = 0;
		}
d440 3
a442 2
	*esymp = addr;
#endif /* 0 */
d449 1
a449 1
void
d512 1
@


1.6
log
@Major changes here and there, tweaks elsewhere.
Support for Openfirmware drivers was reintroduced so that more systems
were supported. This should work with the real driver configurations
as well.

Bootloader files were deleted/replaced with the newer versions in the
subdirectory. Some effort has been made to be closer to support booting
(at least the bootloader) on the Mac.

Config files that end with OFW are the openfirmware versions of the kernels
without have native drivers.

Native driver support has not been changed, presumably it still works.
I couldn't test that.
@
text
@a207 7
	/* XXX this should be replaced w/ a mountroothook. */
	if (floppyboot) {
		printf("Please insert root disk and press ENTER ");
		getchar();
		printf("\n");
	}

@


1.5
log
@Check in some changes hiding in my tree.
Now that ramdisk is used, booting from floppy does not wait for floppy change.
Do not force real mode for booting, this disables caches on certain machines.
use the freshly build hack-obj, do not require "." in the current path.
@
text
@d1 1
a1 2
/*	$OpenBSD: boot.c,v 1.4 1997/02/06 23:44:56 rahnds Exp $	*/
/*	$NetBSD: boot.c,v 1.2 1996/10/07 21:43:02 cgd Exp $	*/
d4 1
d9 3
d37 1
a43 1
#include <stand.h>
d45 6
d52 1
d56 4
a59 1
#include <sys/exec_elf.h>
d61 2
a62 2
#include "ofdev.h"
#include "openfirm.h"
d69 8
d99 5
a103 1
	
d129 1
a129 1
chain(entry, args)
d132 1
d134 2
a135 1
	extern end;
d138 19
a156 2
	OF_chain((void *)RELOC, (void *)&end - (void *)RELOC,
		 entry, args, strlen(args) + 1);
d160 2
a161 2
static void
loadfile(fd, addr, args)
a162 1
	void *addr;
d165 6
a170 10
	struct exec hdr;
	int n;
	int *paddr;
	void *exec_addr;
	
	if (read(fd, &hdr, sizeof hdr) != sizeof(hdr))
		panic("short a.out file");
	if (
#if defined (EXEC_AOUT)
		(N_BADMAG(hdr) || N_GETMID(hdr) != MID_POWERPC)
d172 19
a190 2
#if defined(EXEC_AOUT) && defined (EXEC_ELF)
		&&
d192 4
a195 2
#if defined (EXEC_ELF)
		(((u_int *)&hdr)[0] != 0x7f454c46) /* 0x7f E L F */
a196 1
		)
d198 62
a259 1
		panic("invalid executable format");
d261 74
a334 5
#ifdef EXEC_AOUT
	if (N_GETMID(hdr) == MID_POWERPC) {
		n = hdr.a_text + hdr.a_data + hdr.a_bss + hdr.a_syms
			+ sizeof(int);
		if ((paddr = OF_claim(addr, n, 0)) == (int *)-1)
d336 13
a348 5
		lseek(fd, N_TXTOFF(hdr), SEEK_SET);
		if (read(fd, paddr, hdr.a_text + hdr.a_data) !=
			hdr.a_text + hdr.a_data)
		{
			panic("short a.out file");
d350 25
a374 20
		bzero((void *)paddr + hdr.a_text + hdr.a_data, hdr.a_bss);
		paddr = (int *)((void *)paddr + hdr.a_text + hdr.a_data
			+ hdr.a_bss);
		*paddr++ = hdr.a_syms;
		if (hdr.a_syms) {
			if (read(fd, paddr, hdr.a_syms) != hdr.a_syms)
				panic("short a.out file");
			paddr = (int *)((void *)paddr + hdr.a_syms);
			if (read(fd, &n, sizeof(int)) != sizeof(int))
				panic("short a.out file");
			if (OF_claim((void *)paddr, n + sizeof(int), 0) ==
				(void *)-1)
			{
				panic("cannot claim memory");
			}
			*paddr++ = n;
			if (read(fd, paddr, n - sizeof(int)) != n - sizeof(int))
			{
				panic("short a.out file");
			}
d376 1
a376 1
		exec_addr = hdr.a_text;
d378 19
a396 7
#endif
#ifdef EXEC_ELF
	if (((u_int *)&hdr)[0] == 0x7f454c46) /* 0x7f E L F */ {
		Elf32_Ehdr ehdr;
		Elf32_Phdr phdr;
		int loc_phdr;
		int i;
d398 16
a413 21
		lseek (fd, 0, SEEK_SET);
		read (fd, &ehdr, sizeof (ehdr));
		loc_phdr = ehdr.e_phoff;
		for (i = 1; i <=ehdr.e_phnum; i++) {
			lseek(fd, loc_phdr, SEEK_SET);
			read (fd, &phdr, sizeof(phdr));
			loc_phdr += sizeof(phdr);
			
			if (phdr.p_type == PT_LOAD) {
				printf("phseg %d addr %x  size %x\n", i,
					phdr.p_vaddr, phdr.p_memsz);
				lseek(fd, phdr.p_offset, SEEK_SET);
				paddr = (int *)phdr.p_vaddr;
				n = phdr.p_memsz;
				if (OF_claim((void *)paddr, n , 0) == (int *)-1)
					panic("cannot claim memory");
				read (fd, paddr, phdr.p_filesz);
				if (phdr.p_filesz != phdr.p_memsz) {
					bzero (addr + n,
						phdr.p_memsz - phdr.p_filesz);
				}
d415 4
a419 1
		exec_addr = ehdr.e_entry;
d421 5
a425 10
#endif
	close(fd);
#if 0
	if (floppyboot) {
		printf("Please insert root disk and press ENTER ");
		getchar();
		printf("\n");
	}
#endif
	chain((void *)exec_addr, args);
d427 1
a428 1
char bootline[512];
d433 1
d437 1
a437 1
	printf(">> OpenBSD BOOT\n");
a461 1
	printf("Booting %s @@ 0x%x\n", opened_name, LOADADDR);
d466 1
a466 1
	strncpy(bootline, opened_name, 512);
d488 2
a489 1
	loadfile(fd, LOADADDR, bootline);
@


1.4
log
@Add zlib support for booting gzipped kernels.
Clean up to allow this to happen.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.3 1997/01/09 03:52:51 rahnds Exp $	*/
d213 1
d219 1
@


1.3
log
@Booting OpenBSD not NetBSD.
Change the print to reflect that.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.2 1996/12/28 06:31:12 rahnds Exp $	*/
a46 1
#include <machine/cpu.h>
a212 1
	syncicache(addr, exec_addr);
@


1.2
log
@add OpenBSD tag to files.
@
text
@d1 1
a1 1
/*	$OpenBSD:$	*/
d231 1
a231 1
	printf(">> NetBSD BOOT\n");
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@Check-in of powerpc kernel support.
NOTE: This will not work until the other pieces are checked in.
This is primarily the NetBSD powerpc port, with modifications
to support ELF. 
@
text
@@
