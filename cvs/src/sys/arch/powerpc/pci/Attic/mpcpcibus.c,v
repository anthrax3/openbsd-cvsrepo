head	1.34;
access;
symbols
	SMP_SYNC_A:1.34
	SMP_SYNC_B:1.34
	UBC_SYNC_A:1.34
	UBC_SYNC_B:1.34
	OPENBSD_2_9_BASE:1.25
	OPENBSD_2_9:1.25.0.2
	OPENBSD_2_8:1.22.0.2
	OPENBSD_2_8_BASE:1.22
	OPENBSD_2_7:1.16.0.2
	OPENBSD_2_7_BASE:1.16
	SMP:1.12.0.2
	SMP_BASE:1.12
	kame_19991208:1.10
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3;
locks; strict;
comment	@ * @;


1.34
date	2001.09.01.15.55.17;	author drahn;	state dead;
branches;
next	1.33;

1.33
date	2001.08.17.22.26.58;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2001.07.09.02.51.05;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.29.06.55.36;	author drahn;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.26.18.19.43;	author drahn;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.25.23.29.59;	author drahn;	state Exp;
branches;
next	1.28;

1.28
date	2001.06.25.04.52.35;	author drahn;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.24.05.18.19;	author drahn;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.08.08.09.20;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2001.03.29.20.05.04;	author drahn;	state Exp;
branches;
next	1.24;

1.24
date	2001.03.29.20.02.52;	author drahn;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.03.05.40.01;	author drahn;	state Exp;
branches;
next	1.22;

1.22
date	2000.10.19.04.53.06;	author drahn;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.06.02.09.18;	author rahnds;	state Exp;
branches;
next	1.20;

1.20
date	2000.08.08.17.11.27;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2000.07.28.13.06.15;	author rahnds;	state Exp;
branches;
next	1.18;

1.18
date	2000.07.08.19.36.01;	author rahnds;	state Exp;
branches;
next	1.17;

1.17
date	2000.07.07.13.28.58;	author rahnds;	state Exp;
branches;
next	1.16;

1.16
date	2000.04.01.15.38.21;	author rahnds;	state Exp;
branches;
next	1.15;

1.15
date	2000.03.31.04.25.41;	author rahnds;	state Exp;
branches;
next	1.14;

1.14
date	2000.03.24.06.56.41;	author rahnds;	state Exp;
branches;
next	1.13;

1.13
date	2000.03.20.07.10.50;	author rahnds;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.22.03.55.40;	author rahnds;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2000.01.14.05.42.16;	author rahnds;	state Exp;
branches;
next	1.10;

1.10
date	99.11.08.23.49.00;	author rahnds;	state Exp;
branches;
next	1.9;

1.9
date	99.01.11.05.11.53;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.08.25.08.20.23;	author pefo;	state Exp;
branches;
next	1.7;

1.7
date	98.08.23.22.08.51;	author rahnds;	state Exp;
branches;
next	1.6;

1.6
date	98.08.22.18.31.50;	author rahnds;	state Exp;
branches;
next	1.5;

1.5
date	98.08.06.15.04.00;	author pefo;	state Exp;
branches;
next	1.4;

1.4
date	98.04.06.20.23.21;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	97.10.21.18.01.44;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	97.10.20.19.52.42;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	97.10.11.11.29.30;	author pefo;	state Exp;
branches;
next	;

1.12.2.1
date	2000.03.24.09.08.42;	author niklas;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2001.05.14.21.36.51;	author niklas;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2001.07.04.10.22.42;	author niklas;	state Exp;
branches;
next	1.12.2.4;

1.12.2.4
date	2001.10.31.03.07.55;	author nate;	state dead;
branches;
next	1.12.2.5;

1.12.2.5
date	2001.11.13.21.04.16;	author niklas;	state Exp;
branches;
next	1.12.2.6;

1.12.2.6
date	2001.11.13.22.14.34;	author niklas;	state dead;
branches;
next	;


desc
@@


1.34
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/pci to macppc/pci

The file pci_machdep.h was not moved in this conversion.
It needs to be check if it is correct that should be the only shared
powerpc/pci file. Or if that file too should be MD, or more files MI.
@
text
@/*	$OpenBSD: mpcpcibus.c,v 1.33 2001/08/17 22:26:58 mickey Exp $ */

/*
 * Copyright (c) 1997 Per Fogelstrom
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD for RTMX Inc
 *      by Per Fogelstrom, Opsycon AB.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 * Generic PCI BUS Bridge driver.
 * specialized hooks for different config methods.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/proc.h>
#include <vm/vm.h>

#include <machine/autoconf.h>
#include <machine/bat.h>
#include <machine/powerpc.h>

#if 0
#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>
#endif

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <powerpc/pci/pcibrvar.h>
#include <powerpc/pci/mpc106reg.h>

#include <dev/ofw/openfirm.h>
extern vm_map_t phys_map;

int	 mpcpcibrmatch __P((struct device *, void *, void *));
void	 mpcpcibrattach __P((struct device *, struct device *, void *));

void	 mpc_attach_hook __P((struct device *, struct device *,
				struct pcibus_attach_args *));
int	 mpc_bus_maxdevs __P((void *, int));
pcitag_t mpc_make_tag __P((void *, int, int, int));
void	 mpc_decompose_tag __P((void *, pcitag_t, int *, int *, int *));
pcireg_t mpc_conf_read __P((void *, pcitag_t, int));
void	 mpc_conf_write __P((void *, pcitag_t, int, pcireg_t));

int      mpc_intr_map __P((void *, pcitag_t, int, int, pci_intr_handle_t *));
const char *mpc_intr_string __P((void *, pci_intr_handle_t));
int	 mpc_intr_line __P((void *, pci_intr_handle_t));
void     *mpc_intr_establish __P((void *, pci_intr_handle_t,
            int, int (*func)(void *), void *, char *));
void     mpc_intr_disestablish __P((void *, void *));
int      mpc_ether_hw_addr __P((struct ppc_pci_chipset *, u_int8_t *));
u_int32_t mpc_gen_config_reg __P((void *cpv, pcitag_t tag, int offset));
int	of_ether_hw_addr __P((struct ppc_pci_chipset *, u_int8_t *));
int	find_node_intr __P((int node, u_int32_t *addr, u_int32_t *intr));
u_int32_t pci_iack __P((void));

struct cfattach mpcpcibr_ca = {
        sizeof(struct pcibr_softc), mpcpcibrmatch, mpcpcibrattach,
};

struct cfdriver mpcpcibr_cd = {
	NULL, "mpcpcibr", DV_DULL,
};

static int      mpcpcibrprint __P((void *, const char *pnp));

struct pcibr_config mpc_config;

/*
 * config types
 * bit meanings
 * 0 - standard cf8/cfc type configurations,
 *     sometimes the base addresses for these are different
 * 1 - Config Method #2 configuration - uni-north
 *
 * 2 - 64 bit config bus, data for accesses &4 is at daddr+4;
 */
struct {
	char * compat;
	u_int32_t addr;	 /* offset */
	u_int32_t data;	 /* offset */
	int config_type;
} config_offsets[] = {
	{"grackle",		0x00c00cf8, 0x00e00cfc, 0 },
	{"bandit",		0x00800000, 0x00c00000, 0 },
	{"uni-north",		0x00800000, 0x00c00000, 3 },
	{"legacy",		0x00000cf8, 0x00000cfc, 0 },
	{"IBM,27-82660",	0x00000cf8, 0x00000cfc, 0 },
	{NULL,			0x00000000, 0x00000000, 0 },
};

struct powerpc_bus_dma_tag pci_bus_dma_tag = {
	NULL,
	_dmamap_create,
	_dmamap_destroy,
	_dmamap_load,
	_dmamap_load_mbuf,
	_dmamap_load_uio,
	_dmamap_load_raw,
	_dmamap_unload,
	_dmamap_sync,
	_dmamem_alloc,
	_dmamem_free,
	_dmamem_map,
	_dmamem_unmap,
	_dmamem_mmap
};

/*
 * Code from "pci/if_de.c" used to calculate crc32 of ether rom data.
 */
#define      TULIP_CRC32_POLY  0xEDB88320UL
static __inline__ unsigned
srom_crc32(
    const unsigned char *databuf,
    size_t datalen)
{
    u_int idx, bit, data, crc = 0xFFFFFFFFUL;

    for (idx = 0; idx < datalen; idx++)
        for (data = *databuf++, bit = 0; bit < 8; bit++, data >>= 1)
            crc = (crc >> 1) ^ (((crc ^ data) & 1) ? TULIP_CRC32_POLY : 0);
    return crc;
}

int
mpcpcibrmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct confargs *ca = aux;
	int found = 0;

	if (strcmp(ca->ca_name, mpcpcibr_cd.cd_name) != 0)
		return (found);

	found = 1;

	return found;
}

void fix_node_irq(int node, struct pcibus_attach_args *pba);

int pci_map_a = 0;
void
mpcpcibrattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct pcibr_softc *sc = (struct pcibr_softc *)self;
	struct confargs *ca = aux;
	struct pcibr_config *lcp;
	struct pcibus_attach_args pba;
	int map, node;
	char *bridge;
	int of_node = 0;

	switch(system_type) {
	case OFWMACH:
	case PWRSTK:
		{
			int handle; 
			int err;
			unsigned int val;
			handle = ppc_open_pci_bridge();
			/* if open fails something odd has happened,
			 * we did this before during probe...
			 */
			err = OF_call_method("config-l@@", handle, 1, 1,
				0x80000000, &val);
			if (err == 0) {
				switch (val) {
				/* supported ppc-pci bridges */
				case (PCI_VENDOR_MOT | ( PCI_PRODUCT_MOT_MPC105 <<16)):
					bridge = "MPC105";
					break;
				case (PCI_VENDOR_MOT | ( PCI_PRODUCT_MOT_MPC106 <<16)):
					bridge = "MPC106";
					break;
				default:
					;
				}

			}
			
			/* read the PICR1 register to find what 
			 * address map is being used
			 */
			err = OF_call_method("config-l@@", handle, 1, 1,
				0x800000a8, &val);
			if (val & 0x00010000) {
				map = 1; /* map A */
				pci_map_a = 1;
			} else {
				map = 0; /* map B */
				pci_map_a = 0;
			}

			ppc_close_pci_bridge(handle);
		}
		if (map == 1) {
			sc->sc_membus_space.bus_base = MPC106_P_PCI_MEM_SPACE;
			sc->sc_membus_space.bus_reverse = 1;
			sc->sc_iobus_space.bus_base = MPC106_P_PCI_IO_SPACE;
			sc->sc_iobus_space.bus_reverse = 1;
			if ( bus_space_map(&(sc->sc_iobus_space), 0, NBPG, 0,
				&lcp->ioh_cf8) != 0 )
			{
				panic("mpcpcibus: unable to map self\n");
			}
			lcp->ioh_cfc = lcp->ioh_cf8;
		} else {
			sc->sc_membus_space.bus_base =
				MPC106_P_PCI_MEM_SPACE_MAP_B;
			sc->sc_membus_space.bus_reverse = 1;
			sc->sc_iobus_space.bus_base =
				MPC106_P_PCI_IO_SPACE_MAP_B;
			sc->sc_iobus_space.bus_reverse = 1;
			if ( bus_space_map(&(sc->sc_iobus_space), 0xfec00000,
				NBPG, 0, &lcp->ioh_cf8) != 0 )
			{
				panic("mpcpcibus: unable to map self\n");
			}
			if ( bus_space_map(&(sc->sc_iobus_space), 0xfee00000,
				NBPG, 0, &lcp->ioh_cfc) != 0 )
			{
				panic("mpcpcibus: unable to map self\n");
			}
		}

		lcp->lc_pc.pc_conf_v = lcp;
		lcp->lc_pc.pc_attach_hook = mpc_attach_hook;
		lcp->lc_pc.pc_bus_maxdevs = mpc_bus_maxdevs;
		lcp->lc_pc.pc_make_tag = mpc_make_tag;
		lcp->lc_pc.pc_decompose_tag = mpc_decompose_tag;
		lcp->lc_pc.pc_conf_read = mpc_conf_read;
		lcp->lc_pc.pc_conf_write = mpc_conf_write;
		lcp->lc_pc.pc_ether_hw_addr = mpc_ether_hw_addr;
		lcp->lc_iot = &sc->sc_iobus_space;
		lcp->lc_memt = &sc->sc_membus_space;

	        lcp->lc_pc.pc_intr_v = lcp;
		lcp->lc_pc.pc_intr_map = mpc_intr_map;
		lcp->lc_pc.pc_intr_string = mpc_intr_string;
		lcp->lc_pc.pc_intr_line = mpc_intr_line;
		lcp->lc_pc.pc_intr_establish = mpc_intr_establish;
		lcp->lc_pc.pc_intr_disestablish = mpc_intr_disestablish;


		printf(": %s, Revision 0x%x, ", bridge, 
			mpc_cfg_read_1(lcp, MPC106_PCI_REVID));
		if (map == 1) {
			printf("Using Map A\n");
		} else  {
			printf("Using Map B\n");
		}
#if 0
		/* Reset status */
		mpc_cfg_write_2(lcp, MPC106_PCI_STAT, 0xff80);
#endif
		break;

	case APPL:
		/* scan the children of the root of the openfirmware
		 * tree to locate all nodes with device_type of "pci"
		 */

		if (ca->ca_node == 0) {
			printf("invalid node on mpcpcibr config\n");
			return;
		}
		{
			char compat[32];
			u_int32_t addr_offset;
			u_int32_t data_offset;
#if 0
			struct pci_reserve_mem null_reserve = {
				0,
				0,
				0
			};
#endif
			int i;
			int len;
			int rangelen;

			struct ranges_new {
				u_int32_t flags;
				u_int32_t pad1;
				u_int32_t pad2;
				u_int32_t base;
				u_int32_t pad3;
				u_int32_t size;
			};
			u_int32_t range_store[32];
			struct ranges_new *prange = (void *)&range_store;

			len=OF_getprop(ca->ca_node, "compatible", compat,
				sizeof (compat));
			if (len <= 0 ) {
				len=OF_getprop(ca->ca_node, "name", compat,
					sizeof (compat));
				if (len <= 0) {
					printf(" compatible and name not"
						" found\n");
					return;
				}
				compat[len] = 0; 
				if (strcmp (compat, "bandit") != 0) {
					printf(" compatible not found and name"
						" %s found\n", compat);
					return;
				}
			}
			compat[len] = 0; 
			if ((rangelen = OF_getprop(ca->ca_node, "ranges",
				range_store,
				sizeof (range_store))) <= 0)
			{
				printf("range lookup failed, node %x\n",
				ca->ca_node);
			}
			/* translate byte(s) into item count*/
			rangelen /= sizeof(struct ranges_new);

			lcp = sc->sc_pcibr = &sc->pcibr_config;

			{
				int found;
				unsigned int base = 0;
				unsigned int size = 0;

				/* mac configs */

				sc->sc_membus_space.bus_base = 0;
				sc->sc_membus_space.bus_reverse = 1;
				sc->sc_iobus_space.bus_base = 0;
				sc->sc_iobus_space.bus_reverse = 1;

				/* find io(config) base, flag == 0x01000000 */
				found = 0;
				for (i = 0; i < rangelen ; i++)
				{
					if (prange[i].flags == 0x01000000) {
						/* find last? */
						found = i;
					}
				}
				/* found the io space ranges */
				if (prange[found].flags == 0x01000000) {
					sc->sc_iobus_space.bus_base =
						prange[found].base;
					sc->sc_iobus_space.bus_size =
						prange[found].size;
				}

				/* the mem space ranges 
				 * apple openfirmware always puts full
				 * addresses in config information,
				 * it is not necessary to have correct bus
				 * base address, but since 0 is reserved
				 * and all IO and device memory will be in
				 * upper 2G of address space, set to
				 * 0x80000000
				 * start with segment 1 not 0, 0 is config.
				 */
				for (i = 0; i < rangelen ; i++)
				{
					if (prange[i].flags == 0x02000000) {
#if 0
						printf("\nfound mem %x %x",
							prange[i].base,
							prange[i].size);
#endif
							
						if (base != 0) {
							if ((base + size) ==
							    prange[i].base)
							{
							    size +=
								prange[i].size;
							} else {
								base =
								 prange[i].base;
								size =
								 prange[i].size;
							}
						} else {
							base = prange[i].base;
							size = prange[i].size;
						}
					}
				}
				sc->sc_membus_space.bus_base = base;
				sc->sc_membus_space.bus_size = size;

			}
			addr_offset = 0;
			for (i = 0; config_offsets[i].compat != NULL; i++) {
				if (strcmp(config_offsets[i].compat, compat)
					== 0)
				{
					addr_offset = config_offsets[i].addr; 
					data_offset = config_offsets[i].data; 
					lcp->config_type =
						config_offsets[i].config_type;
					break;
				}
			}
			if (addr_offset == 0) {
				printf("unable to find match for"
					" compatible %s\n", compat);
				return;
			}
#ifdef PCI_DEBUG
			printf(" mem base %x sz %x io base %x sz %x\n config addr %x"
				" config data %x\n",
				sc->sc_membus_space.bus_base,
				sc->sc_membus_space.bus_size,
				sc->sc_iobus_space.bus_base,
				sc->sc_iobus_space.bus_size,
				addr_offset, data_offset);
#endif



			if ( bus_space_map(&(sc->sc_iobus_space), addr_offset,
				NBPG, 0, &lcp->ioh_cf8) != 0 )
			{
				panic("mpcpcibus: unable to map self\n");
			}
			if ( bus_space_map(&(sc->sc_iobus_space), data_offset,
				NBPG, 0, &lcp->ioh_cfc) != 0 )
			{
				panic("mpcpcibus: unable to map self\n");
			}
			of_node = ca->ca_node;


			lcp->node = ca->ca_node;
			lcp->lc_pc.pc_conf_v = lcp;
			lcp->lc_pc.pc_attach_hook = mpc_attach_hook;
			lcp->lc_pc.pc_bus_maxdevs = mpc_bus_maxdevs;
			lcp->lc_pc.pc_make_tag = mpc_make_tag;
			lcp->lc_pc.pc_decompose_tag = mpc_decompose_tag;
			lcp->lc_pc.pc_conf_read = mpc_conf_read;
			lcp->lc_pc.pc_conf_write = mpc_conf_write;
			lcp->lc_pc.pc_ether_hw_addr = of_ether_hw_addr;
			lcp->lc_iot = &sc->sc_iobus_space;
			lcp->lc_memt = &sc->sc_membus_space;

			lcp->lc_pc.pc_intr_v = lcp;
			lcp->lc_pc.pc_intr_map = mpc_intr_map;
			lcp->lc_pc.pc_intr_string = mpc_intr_string;
			lcp->lc_pc.pc_intr_line = mpc_intr_line;
			lcp->lc_pc.pc_intr_establish = mpc_intr_establish;
			lcp->lc_pc.pc_intr_disestablish = mpc_intr_disestablish;

			printf(": %s, Revision 0x%x\n", compat, 
				mpc_cfg_read_1(lcp, MPC106_PCI_REVID));

#if 0
			pci_addr_fixup(sc, &lcp->lc_pc, 32, &null_reserve);
#endif
		}
		break;

	default:
		printf("unknown system_type %d\n",system_type);
		return;
	}

	pba.pba_dmat = &pci_bus_dma_tag;
		

	pba.pba_busname = "pci";
	pba.pba_iot = &sc->sc_iobus_space;
	pba.pba_memt = &sc->sc_membus_space;
	pba.pba_pc = &lcp->lc_pc;
	pba.pba_bus = 0;

	/* we want to check pci irq settings */
	if (of_node != 0) {
		int nn;

		for (node = OF_child(of_node); node; node = nn)
		{
			{
				char name[32];
				int len;
				len = OF_getprop(node, "name", name,
					sizeof(name));
				name[len] = 0;
#if 0
				printf("checking node %s\n", name);
#endif
			}
			fix_node_irq(node, &pba);

			/* iterate section */
			if ((nn = OF_child(node)) != 0) {
				continue;
			}
			while ((nn = OF_peer(node)) == 0) {
				node = OF_parent(node);
				if (node == of_node) {
					nn = 0; /* done */
					break;
				}
			}
		}
	}

	config_found(self, &pba, mpcpcibrprint);

}
                 
#define       OFW_PCI_PHYS_HI_BUSMASK         0x00ff0000
#define       OFW_PCI_PHYS_HI_BUSSHIFT        16
#define       OFW_PCI_PHYS_HI_DEVICEMASK      0x0000f800
#define       OFW_PCI_PHYS_HI_DEVICESHIFT     11
#define       OFW_PCI_PHYS_HI_FUNCTIONMASK    0x00000700
#define       OFW_PCI_PHYS_HI_FUNCTIONSHIFT   8

#define pcibus(x) \
	(((x) & OFW_PCI_PHYS_HI_BUSMASK) >> OFW_PCI_PHYS_HI_BUSSHIFT)
#define pcidev(x) \
	(((x) & OFW_PCI_PHYS_HI_DEVICEMASK) >> OFW_PCI_PHYS_HI_DEVICESHIFT)
#define pcifunc(x) \
	(((x) & OFW_PCI_PHYS_HI_FUNCTIONMASK) >> OFW_PCI_PHYS_HI_FUNCTIONSHIFT)

/* 
 * Find PCI IRQ from OF
 */
int
find_node_intr(node, addr, intr)
	int node;
	u_int32_t *addr, *intr;
{
	int parent, iparent, len, mlen;
	int match, i;
	u_int32_t map[64], *mp;
	u_int32_t imask[8], maskedaddr[8];
	u_int32_t icells;

	len = OF_getprop(node, "AAPL,interrupts", intr, 4);
	if (len == 4)
		return 1;

	parent = OF_parent(node);
	len = OF_getprop(parent, "interrupt-map", map, sizeof(map));
	mlen = OF_getprop(parent, "interrupt-map-mask", imask, sizeof(imask));

	if ((len == -1) || (mlen == -1))
		goto nomap;
	for (i = 0; i < (mlen / 4); i++) {
		maskedaddr[i] = addr[i] & imask[i];
	}
	mp = map;
	while (len > mlen) {
		match = bcmp(maskedaddr, mp, mlen);
		mp += mlen / 4;
		len -= mlen;
		iparent = *mp++;
		if (OF_getprop(iparent, "#interrupt-cells", &icells, 4) != 4)
			return -1;

		if (match == 0) {
			/* multiple irqs? */
			*intr = *mp;
			return 1;
		}
		mp += icells;
		len -= icells * 4;
	}
	return -1;
nomap:
	return -1;
}

void
fix_node_irq(node, pba)
	int node;
	struct pcibus_attach_args *pba;
{
	struct { 
		u_int32_t phys_hi, phys_mid, phys_lo;
		u_int32_t size_hi, size_lo;
	} addr [8];
	int len;
	pcitag_t tag;
	u_int32_t irq;
	u_int32_t intr;

	pci_chipset_tag_t pc = pba->pba_pc;

	len = OF_getprop(node, "assigned-addresses", addr, sizeof(addr));
	if (len < sizeof(addr[0])) {
		return;
	}
	tag = pci_make_tag(pc, pcibus(addr[0].phys_hi),
		pcidev(addr[0].phys_hi),
		pcifunc(addr[0].phys_hi));
	/* program the interrupt line register with the value
	 * found in openfirmware
	 */
	if (find_node_intr(node, &addr[0].phys_hi, &irq) == -1)
		return;

	intr = pci_conf_read(pc, tag, PCI_INTERRUPT_REG);
#if 0
	printf("changing interrupt from %d to %d\n",
		intr & PCI_INTERRUPT_LINE_MASK,
		irq & PCI_INTERRUPT_LINE_MASK);
#endif
	intr &= ~PCI_INTERRUPT_LINE_MASK;
	intr |= irq & PCI_INTERRUPT_LINE_MASK;
	pci_conf_write(pc, tag, PCI_INTERRUPT_REG, intr);
}

static int
mpcpcibrprint(aux, pnp)
	void *aux;
	const char *pnp;
{
	struct pcibus_attach_args *pba = aux;

	if(pnp)
		printf("%s at %s", pba->pba_busname, pnp);
	printf(" bus %d", pba->pba_bus);
	return(UNCONF);
}

/*
 *  Get PCI physical address from given viritual address.
 *  XXX Note that cross page boundarys are *not* guarantee to work!
 */

paddr_t
vtophys(pa)
	paddr_t pa;
{
	vaddr_t va = (vaddr_t) pa;

	if(va < VM_MIN_KERNEL_ADDRESS)
		pa = va;
	else
		pmap_extract(vm_map_pmap(phys_map), va, &pa);

	return (pa | ((pci_map_a == 1) ? MPC106_PCI_CPUMEM : 0 ));
}

void
mpc_attach_hook(parent, self, pba)
	struct device *parent, *self;
	struct pcibus_attach_args *pba;
{
}

int
of_ether_hw_addr(struct ppc_pci_chipset *lcpc, u_int8_t *oaddr)
{
	u_int8_t laddr[6];
	struct pcibr_config *lcp = lcpc->pc_conf_v;
	int of_node = lcp->node;
	int node, nn;
	for (node = OF_child(of_node); node; node = nn)
	{
		char name[32];
		int len;
		len = OF_getprop(node, "name", name,
			sizeof(name));
		name[len] = 0;
		if (sizeof (laddr) ==
			OF_getprop(node, "local-mac-address", laddr,
				sizeof laddr))
		{
			bcopy (laddr, oaddr, sizeof laddr);
			return 1;
			
		}

		/* iterate section */
		if ((nn = OF_child(node)) != 0) {
			continue;
		}
		while ((nn = OF_peer(node)) == 0) {
			node = OF_parent(node);
			if (node == of_node) {
				nn = 0; /* done */
				break;
			}
		}
	}
	oaddr[0] = oaddr[1] = oaddr[2] = 0xff;
	oaddr[3] = oaddr[4] = oaddr[5] = 0xff;
	return 0;
}

int
mpc_ether_hw_addr(p, s)
	struct ppc_pci_chipset *p;
	u_int8_t *s;
{
	printf("mpc_ether_hw_addr not supported\n");
	return(0);
}

int
mpc_bus_maxdevs(cpv, busno)
	void *cpv;
	int busno;
{
	return(32);
}

#define BUS_SHIFT 16
#define DEVICE_SHIFT 11
#define FNC_SHIFT 8

pcitag_t
mpc_make_tag(cpv, bus, dev, fnc)
	void *cpv;
	int bus, dev, fnc;
{
	return (bus << BUS_SHIFT) | (dev << DEVICE_SHIFT) | (fnc << FNC_SHIFT);
}

void
mpc_decompose_tag(cpv, tag, busp, devp, fncp)
	void *cpv;
	pcitag_t tag;
	int *busp, *devp, *fncp;
{
	if (busp != NULL)
		*busp = (tag >> BUS_SHIFT) & 0xff;
	if (devp != NULL)
		*devp = (tag >> DEVICE_SHIFT) & 0x1f;
	if (fncp != NULL)
		*fncp = (tag >> FNC_SHIFT) & 0x7;
}

u_int32_t
mpc_gen_config_reg(cpv, tag, offset)
	void *cpv;
	pcitag_t tag;
	int offset;
{
	struct pcibr_config *cp = cpv;
	unsigned int bus, dev, fcn;
	u_int32_t reg;
	/*
	static int spin = 0;
	while (spin > 85);
	spin++;
	*/

	mpc_decompose_tag(cpv, tag, &bus, &dev, &fcn);

	if (cp->config_type & 1) {
		/* Config Mechanism #2 */
		if (bus == 0) {
			if (dev < 11) {
				return 0xffffffff;
			}
			/*
			 * Need to do config type 0 operation
			 *  1 << (11?+dev) | fcn << 8 | reg
			 * 11? is because pci spec states
			 * that 11-15 is reserved.
			 */
			reg = 1 << (dev) | fcn << 8 | offset;
			
		} else {
			if (dev > 15) {
			 return 0xffffffff;
			}
			/*
			 * config type 1 
			 */
			reg =  tag  | offset | 1;

		}
	} else {
		/* config mechanism #2, type 0
		 * standard cf8/cfc config
		 */
		reg =  0x80000000 | tag  | offset;

	}
	return reg;
}

/* #define DEBUG_CONFIG  */
pcireg_t
mpc_conf_read(cpv, tag, offset)
	void *cpv;
	pcitag_t tag;
	int offset;
{
	struct pcibr_config *cp = cpv;

	pcireg_t data;
	u_int32_t reg;
	int s;
	int daddr = 0;

	if(offset & 3 || offset < 0 || offset >= 0x100) {
#ifdef DEBUG_CONFIG 
		printf ("pci_conf_read: bad reg %x\n", offset);
#endif /* DEBUG_CONFIG */
		return(~0);
	}

	reg = mpc_gen_config_reg(cpv, tag, offset);
	/* if invalid tag, return -1 */
	if (reg == 0xffffffff) {
		return 0xffffffff;
	}

	if ((cp->config_type & 2) && (offset & 0x04)) {
		daddr += 4;
	}

	s = splhigh();

	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, reg);
	bus_space_read_4(cp->lc_iot, cp->ioh_cf8, 0); /* XXX */
	data = bus_space_read_4(cp->lc_iot, cp->ioh_cfc, daddr);
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, 0); /* disable */
	bus_space_read_4(cp->lc_iot, cp->ioh_cf8, 0); /* XXX */

	splx(s);
#ifdef DEBUG_CONFIG
	if (!((offset == 0) && (data == 0xffffffff))) {
		unsigned int bus, dev, fcn;
		mpc_decompose_tag(cpv, tag, &bus, &dev, &fcn);
		printf("mpc_conf_read bus %x dev %x fcn %x offset %x", bus, dev, fcn,
			offset);
		printf(" daddr %x reg %x",daddr, reg);
		printf(" data %x\n", data);
	}
#endif

	return(data);
}

void
mpc_conf_write(cpv, tag, offset, data)
	void *cpv;
	pcitag_t tag;
	int offset;
	pcireg_t data;
{
	struct pcibr_config *cp = cpv;
	u_int32_t reg;
	int s;
	int daddr = 0;

	reg = mpc_gen_config_reg(cpv, tag, offset);

	/* if invalid tag, return ??? */
	if (reg == 0xffffffff) {
		return;
	}
	if ((cp->config_type & 2) && (offset & 0x04)) {
		daddr += 4;
	}
#ifdef DEBUG_CONFIG
	{
		unsigned int bus, dev, fcn;
		mpc_decompose_tag(cpv, tag, &bus, &dev, &fcn);
		printf("mpc_conf_write bus %x dev %x fcn %x offset %x", bus,
			dev, fcn, offset);
		printf(" daddr %x reg %x",daddr, reg);
		printf(" data %x\n", data);
	}
#endif

	s = splhigh();

	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, reg);
	bus_space_read_4(cp->lc_iot, cp->ioh_cf8, 0); /* XXX */
	bus_space_write_4(cp->lc_iot, cp->ioh_cfc, daddr, data);
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, 0); /* disable */
	bus_space_read_4(cp->lc_iot, cp->ioh_cf8, 0); /* XXX */

	splx(s);
}


/*ARGSUSED*/
int
mpc_intr_map(lcv, bustag, buspin, line, ihp)
	void *lcv;
	pcitag_t bustag;
	int buspin, line;
	pci_intr_handle_t *ihp;
{
	int error = 0;

	*ihp = -1;
        if (buspin == 0) {
                /* No IRQ used. */
                error = 1;
        }
        else if (buspin > 4) {
                printf("mpc_intr_map: bad interrupt pin %d\n", buspin);
                error = 1;
        }

	if(!error)
		*ihp = line;
	return error;
}

const char *
mpc_intr_string(lcv, ih)
	void *lcv;
	pci_intr_handle_t ih;
{
	static char str[16];

	sprintf(str, "irq %d", ih);
	return(str);
}

int
mpc_intr_line(lcv, ih)
	void *lcv;
	pci_intr_handle_t ih;
{
	return (ih);
}

void *
mpc_intr_establish(lcv, ih, level, func, arg, name)
	void *lcv;
	pci_intr_handle_t ih;
	int level;
	int (*func) __P((void *));
	void *arg;
	char *name;
{
	return (*intr_establish_func)(lcv, ih, IST_LEVEL, level, func, arg,
		name);
#if 0
	return isabr_intr_establish(NULL, ih, IST_LEVEL, level, func, arg,
		name);
#endif
}

void
mpc_intr_disestablish(lcv, cookie)
	void *lcv, *cookie;
{
	/* XXX We should probably do something clever here.... later */
}

#if 0
void
mpc_print_pci_stat()
{
	u_int32_t stat;

	stat = mpc_cfg_read_4(cp, MPC106_PCI_CMD);
	printf("pci: status 0x%08x.\n", stat);
	stat = mpc_cfg_read_2(cp, MPC106_PCI_STAT);
	printf("pci: status 0x%04x.\n", stat);
}
#endif

u_int32_t
pci_iack()
{
	/* do pci IACK cycle */
	/* this should be bus allocated. */
	volatile u_int8_t *iack = (u_int8_t *)0xbffffff0;
	u_int8_t val;

	val = *iack;
	return val;
}

void
mpc_cfg_write_1(cp, reg, val)
	struct pcibr_config *cp;
	u_int32_t reg;
	u_int8_t val;
{
	int s;
	s = splhigh();
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0,
		MPC106_REGOFFS(reg));
	bus_space_write_1(cp->lc_iot, cp->ioh_cfc, 0, val);
	splx(s);
}

void
mpc_cfg_write_2(cp, reg, val)
	struct pcibr_config *cp;
	u_int32_t reg;
	u_int16_t val;
{
	int s;
	s = splhigh();
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, MPC106_REGOFFS(reg));
	bus_space_write_2(cp->lc_iot, cp->ioh_cfc, 0, val);
	splx(s);
}

void
mpc_cfg_write_4(cp, reg, val)
	struct pcibr_config *cp;
	u_int32_t reg;
	u_int32_t val;
{

	int s;
	s = splhigh();
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, MPC106_REGOFFS(reg));
	bus_space_write_4(cp->lc_iot, cp->ioh_cfc, 0, val);
	splx(s);
}

u_int8_t
mpc_cfg_read_1(cp, reg)
	struct pcibr_config *cp;
	u_int32_t reg;
{
	u_int8_t _v_;

	int s;
	s = splhigh();
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, MPC106_REGOFFS(reg));
	_v_ = bus_space_read_1(cp->lc_iot, cp->ioh_cfc, 0);
	splx(s);
	return(_v_);
}

u_int16_t
mpc_cfg_read_2(cp, reg)
	struct pcibr_config *cp;
	u_int32_t reg;
{
	u_int16_t _v_;

	int s;
	s = splhigh();
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, MPC106_REGOFFS(reg));
	_v_ = bus_space_read_2(cp->lc_iot, cp->ioh_cfc, 0);
	splx(s);
	return(_v_);
}

u_int32_t
mpc_cfg_read_4(cp, reg)
	struct pcibr_config *cp;
	u_int32_t reg;
{
	u_int32_t _v_;

	int s;
	s = splhigh();
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, MPC106_REGOFFS(reg));
	_v_ = bus_space_read_4(cp->lc_iot, cp->ioh_cfc, 0);
	splx(s);
	return(_v_);
}
@


1.33
log
@provide a way to get the number used for irq line, not only a string
representation, this is needed for devices like cbb which pass
the interrupt line down to the cardbus attachment and not
getting the right line before pci_intr_map() has done it's
dirty deed.
tested on i386 by jason@@, compiles on alpha by art@@.
ppc and mveppc are to be test-compiled, but should work (;
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.32 2001/07/09 02:51:05 mickey Exp $ */
@


1.32
log
@proper vtophys types, spaces, protos
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.31 2001/06/29 06:55:36 drahn Exp $ */
d80 1
d278 1
d488 1
d959 8
@


1.31
log
@Include/header cleanup. More.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.30 2001/06/26 18:19:43 drahn Exp $ */
d84 4
a87 1
int      of_ether_hw_addr __P((struct ppc_pci_chipset *, u_int8_t *));
d669 3
a671 3
vm_offset_t
vtophys(p)
	void * p;
d673 1
a673 2
	paddr_t pa;
	vaddr_t va;
d675 1
a675 2
	va = (vaddr_t) p;
	if((vm_offset_t)va < VM_MIN_KERNEL_ADDRESS) {
d677 1
a677 2
	}
	else {
d679 2
a680 2
	}
	return(pa | ((pci_map_a == 1) ? MPC106_PCI_CPUMEM : 0 ));
d773 1
a773 1
static u_int32_t
d994 1
@


1.30
log
@Cleanup of interrupt configuration, move prototypes to header file,
not in each file.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.29 2001/06/25 23:29:59 drahn Exp $ */
d50 1
d64 1
a65 1
extern ofw_eth_addr[];
a187 36
	case POWER4e:
		lcp = sc->sc_pcibr = &mpc_config;

		addbatmap(MPC106_V_PCI_MEM_SPACE,
			  MPC106_P_PCI_MEM_SPACE, BAT_I);

		sc->sc_membus_space.bus_base = MPC106_V_PCI_MEM_SPACE;
		sc->sc_membus_space.bus_reverse = 1;
		sc->sc_iobus_space.bus_base = MPC106_V_PCI_IO_SPACE;
		sc->sc_iobus_space.bus_reverse = 1;

		lcp->lc_pc.pc_conf_v = lcp;
		lcp->lc_pc.pc_attach_hook = mpc_attach_hook;
		lcp->lc_pc.pc_bus_maxdevs = mpc_bus_maxdevs;
		lcp->lc_pc.pc_make_tag = mpc_make_tag;
		lcp->lc_pc.pc_decompose_tag = mpc_decompose_tag;
		lcp->lc_pc.pc_conf_read = mpc_conf_read;
		lcp->lc_pc.pc_conf_write = mpc_conf_write;
		lcp->lc_pc.pc_ether_hw_addr = mpc_ether_hw_addr;
		lcp->lc_iot = &sc->sc_iobus_space;
		lcp->lc_memt = &sc->sc_membus_space;

	        lcp->lc_pc.pc_intr_v = lcp;
		lcp->lc_pc.pc_intr_map = mpc_intr_map;
		lcp->lc_pc.pc_intr_string = mpc_intr_string;
		lcp->lc_pc.pc_intr_establish = mpc_intr_establish;
		lcp->lc_pc.pc_intr_disestablish = mpc_intr_disestablish;

		printf(": MPC106, Revision 0x%x.\n", 
				mpc_cfg_read_1(lcp, MPC106_PCI_REVID));
#if 0
		mpc_cfg_write_2(lcp, MPC106_PCI_STAT, 0xff80); /* Reset status */
#endif
		bridge = "MPC106";
		break;

d351 1
a351 1
			/* translate byte(s) into item count/*/
d816 2
a817 1
		/* standard cf8/cfc config */
a940 45

#if 0
	/* this hack belongs elsewhere */
	if(system_type == POWER4e) {
		pci_decompose_tag(pc, bustag, NULL, &device, NULL);
		route = in32rb(MPC106_PCI_CONF_SPACE + 0x860);
		switch(device) {
		case 1:			/* SCSI */
			line = 6;
			route &= ~0x0000ff00;
			route |= line << 8;
			break;

		case 2:			/* Ethernet */
			line = 14;
			route &= ~0x00ff0000;
			route |= line << 16;
			break;

		case 3:			/* Tundra VME */
			line = 15;
			route &= ~0xff000000;
			route |= line << 24;
			break;

		case 4:			/* PMC Slot */
			line = 9;
			route &= ~0x000000ff;
			route |= line;
			break;

		default:
			printf("mpc_intr_map: bad dev slot %d!\n", device);
			error = 1;
			break;
		}

		lvl = isa_inb(0x04d0);
		lvl |= isa_inb(0x04d1) << 8;
		lvl |= 1L << line;
		isa_outb(0x04d0, lvl);
		isa_outb(0x04d1, lvl >> 8);
		out32rb(MPC106_PCI_CONF_SPACE + 0x860, route);
	}
#endif
@


1.29
log
@closer to building with -Wno-uninitialized
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.28 2001/06/25 04:52:35 drahn Exp $ */
a1035 6

typedef void     *(intr_establish_t) __P((void *, pci_intr_handle_t,
            int, int, int (*func)(void *), void *, char *));
typedef void     (intr_disestablish_t) __P((void *, void *));
extern intr_establish_t *intr_establish_func;
extern intr_disestablish_t *intr_disestablish_func;
@


1.28
log
@Improved debug-ability printfs. now under ifdef PCI_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.27 2001/06/24 05:18:19 drahn Exp $ */
a159 1
	int handle; 
a160 4
	int err;
	unsigned int val;
	int qhandle;
	char type[32];
a184 2
	u_int32_t base;
	u_int32_t size;
d339 1
d345 1
a606 1
	char name [32];
a868 1
	int device;
a869 1
	int handle; 
a921 1
	int handle; 
d956 1
a963 2
	struct pcibr_config *lcp = lcv;
	pci_chipset_tag_t pc = &lcp->lc_pc; 
a964 3
	int route;
	int lvl;
	int device;
@


1.27
log
@Smattering of symbol type cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.26 2001/06/08 08:09:20 art Exp $ */
a465 8
#if 0
			printf("membase %x size %x iobase %x size %x\n",
				sc->sc_membus_space.bus_base,
				sc->sc_membus_space.bus_size,
				sc->sc_iobus_space.bus_base,
				sc->sc_iobus_space.bus_size);
#endif
			
d483 2
a484 2
#if 0
			printf(" mem base %x io base %x config addr %x"
d487 1
d489 1
@


1.26
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.25 2001/03/29 20:05:04 drahn Exp $ */
d710 1
a710 1
 *  XXX Note that cross page boundarys are *not* garantueed to work!
d715 1
a715 1
	void *p;
d717 2
a718 2
	vm_offset_t pa;
	vm_offset_t va;
d720 1
a720 1
	va = (vm_offset_t)p;
@


1.25
log
@Ok, forgot to clean up debug prints before checkin on that file.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.24 2001/03/29 20:02:52 drahn Exp $ */
d725 1
a725 1
		pa = pmap_extract(vm_map_pmap(phys_map), va);
@


1.24
log
@Detect pci bus base more accurately, and save it's size.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.23 2001/03/03 05:40:01 drahn Exp $ */
d438 1
a438 1
						/* find last? */
d442 1
d466 1
d472 1
a472 1

@


1.23
log
@Change how PCI bus memory base address is found for powerpc.
This is probably quite a hack. however some bridges have multiple
"memory" segment according to the openfirmware data. one is
the pci device probe register area, and the one or two more
that are real address regions. Such as base 0x80000000 sz 0x10000000,
base 0x90000000 sz 0x10000000. This should really be one region
but detecting the "last" region to avoid the first region causes the
wrong base address to be picked. Currently this hardcodes it to
0x80000000 because it seems to work for "normal" pci currently.
openfirmware puts full address in the field and the other devices
seem to work on tested machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.22 2000/10/19 04:53:06 drahn Exp $ */
d190 2
d346 5
d398 2
d421 2
d433 1
d435 28
a462 3
                         
				sc->sc_membus_space.bus_base = 0x80000000;
				sc->sc_membus_space.bus_reverse = 1;
d465 5
d532 4
d885 1
d887 1
@


1.22
log
@Changes to pci and if_gm to support obtaining the ethernet hardware address
from the pci bus. This is in preference to adding openfirmware code to
the device drivers. If there was a known way of obtaining the ethernet
hardware address from a eeprom or other methods that would be used, but
the only known way to get this information for the Apple machines with
if_gm is via openfirmware.

This modifies a previous mechanism that was used to obtain similar information
from different openfirmware systems, however the old mechanism would create
information such as media type. This information was hardcoded into
that code. Now the code only returns the actual address which is the
only informatin that openfirmware provides.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.21 2000/09/06 02:09:18 rahnds Exp $ */
d414 12
a425 22
				found = 0;
				/* find mem base, flag == 0x02000000 */
				for (i = 0; i < rangelen ; i++)
				{
					if (prange[i].flags == 0x02000000) {
						/* find last? */
						found = i;
					}
				}
				/* found the mem space ranges */
				if (prange[found].flags == 0x02000000) {
					sc->sc_membus_space.bus_base =
						prange[found].base;

				}
				if ( (sc->sc_iobus_space.bus_base == 0) ||
					(sc->sc_membus_space.bus_base == 0)) {
					printf("io or memory base not found"
						"mem %x io %x\n",
						sc->sc_membus_space.bus_base,
						sc->sc_iobus_space.bus_base);
				}
@


1.21
log
@If the bridge is an MPC106 (Grackle) print it's revision.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.20 2000/08/08 17:11:27 deraadt Exp $ */
d82 2
a83 1
int      mpc_ether_hw_addr __P((u_int8_t *, u_int8_t, u_int8_t));
d113 1
a113 1
	{"bandit",		0x00c00cf8, 0x00e00cfc, 0 },
d335 1
d480 1
d488 1
a488 1
			lcp->lc_pc.pc_ether_hw_addr = mpc_ether_hw_addr;
d700 1
a700 2
mpc_ether_hw_addr(p, b, s)
	u_int8_t *p, b, s;
d702 19
a720 1
	int i;
d722 24
a745 36
	for(i = 0; i < 128; i++)
		p[i] = 0x00;
	p[18] = 0x03;	/* Srom version. */
	p[19] = 0x01;	/* One chip. */
	/* Next six, ethernet address. */
	bcopy(ofw_eth_addr, &p[20], 6);

	p[26] = 0x00;	/* Chip 0 device number */
	p[27] = 30;		/* Descriptor offset */
	p[28] = 00;
	p[29] = 00;		/* MBZ */
					/* Descriptor */
	p[30] = 0x00;	/* Autosense. */
	p[31] = 0x08;
	p[32] = 0xff;	/* GP cntrl */
	p[33] = 0x01;	/* Block cnt */
#define GPR_LEN 0
#define	RES_LEN 0
	p[34] = 0x80 + 12 + GPR_LEN + RES_LEN;
	p[35] = 0x01;	/* MII PHY type */
	p[36] = 0x00;	/* PHY number 0 */
	p[37] = 0x00;	/* GPR Length */
	p[38] = 0x00;	/* Reset Length */
	p[39] = 0x00;	/* Media capabilities */
	p[40] = 0x78;	/* Media capabilities */
	p[41] = 0x00;	/* Autoneg advertisment */
	p[42] = 0x78;	/* Autoneg advertisment */
	p[43] = 0x00;	/* Full duplex map */
	p[44] = 0x50;	/* Full duplex map */
	p[45] = 0x00;	/* Treshold map */
	p[46] = 0x18;	/* Treshold map */

	i = (srom_crc32(p, 126) & 0xFFFF) ^ 0xFFFF;
	p[126] = i;
	p[127] = i >> 8;
	return(1);
@


1.20
log
@pretty print
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.19 2000/07/28 13:06:15 rahnds Exp $ */
d219 2
a220 1
		printf(": MPC106, Revision 0x%x\n", 0);
a221 1
				mpc_cfg_read_1(lcp, MPC106_PCI_REVID));
@


1.19
log
@Config changes to be closer to supporting older bandit based systems.
Openfirmware does not have entries for the interrupt controller.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.18 2000/07/08 19:36:01 rahnds Exp $ */
d219 1
a219 1
		printf(": MPC106, Revision %x.\n", 0);
d317 1
a317 1
		printf(": %s, Revision %x. ", bridge, 
d495 1
a495 1
			printf(": %s, Revision %x. ", compat, 
@


1.18
log
@Process memory ranges found in the openfirmware device tree by amount
retrieved, do not walk the (uninitialized?) stack until a value is found.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.17 2000/07/07 13:28:58 rahnds Exp $ */
d112 1
d360 13
a372 2
				printf(" compatible not found\n");
				return;
a374 1

a475 1
		}
d478 16
a493 10
		lcp->lc_pc.pc_conf_v = lcp;
		lcp->lc_pc.pc_attach_hook = mpc_attach_hook;
		lcp->lc_pc.pc_bus_maxdevs = mpc_bus_maxdevs;
		lcp->lc_pc.pc_make_tag = mpc_make_tag;
		lcp->lc_pc.pc_decompose_tag = mpc_decompose_tag;
		lcp->lc_pc.pc_conf_read = mpc_conf_read;
		lcp->lc_pc.pc_conf_write = mpc_conf_write;
		lcp->lc_pc.pc_ether_hw_addr = mpc_ether_hw_addr;
		lcp->lc_iot = &sc->sc_iobus_space;
		lcp->lc_memt = &sc->sc_membus_space;
d495 3
a497 8
	        lcp->lc_pc.pc_intr_v = lcp;
		lcp->lc_pc.pc_intr_map = mpc_intr_map;
		lcp->lc_pc.pc_intr_string = mpc_intr_string;
		lcp->lc_pc.pc_intr_establish = mpc_intr_establish;
		lcp->lc_pc.pc_intr_disestablish = mpc_intr_disestablish;

		printf(": %s, Revision %x. ", bridge, 
			mpc_cfg_read_1(lcp, MPC106_PCI_REVID));
@


1.17
log
@Support config type 2 as required for proper uni-north pci config cycles.
use the same code for read and write for easier maintance.
code to walk the openfirmware device tree when a bridge is configured
to copy the interrupt line information into the pci register so
that the device driver can use it. Apple Openfirmware doesn't do
this automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.16 2000/04/01 15:38:21 rahnds Exp $ */
d343 1
d364 3
a366 2
			if (OF_getprop(ca->ca_node, "ranges", range_store,
				sizeof (range_store)) <= 0)
d371 2
d388 2
a389 1
				for (i = 0; prange[i].flags != 0; i++) {
d403 2
a404 1
				for (i = 0; prange[i].flags != 0; i++) {
d414 1
d445 1
a445 1
			printf("found  mem base %x io base %x config addr %x"
@


1.16
log
@boot noise removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.15 2000/03/31 04:25:41 rahnds Exp $ */
d36 2
a37 1
 * MPC106  PCI BUS Bridge driver.
d96 9
d112 1
a112 1
	{"uni-north",		0x00800000, 0x00c00000, 1 },
d173 2
d185 1
a185 1
	int map;
d187 1
a343 11
#if 0
			/* for powerstack boxes? */
			struct ranges_old {
				u_int32_t flags;
				u_int32_t pad1;
				u_int32_t pad2;
				u_int32_t base;
				u_int32_t size;
			};
			struct ranges_old porange = &range_store;
#endif 
a371 18
#if 0			
			/* powerstack boxes? */
			if (strcmp(compat, "IBM,27-82660") {
				sc->sc_membus_space.bus_base =
					MPC106_P_PCI_MEM_SPACE;
				sc->sc_membus_space.bus_reverse = 1;
				sc->sc_iobus_space.bus_base =
					MPC106_P_PCI_IO_SPACE;
				sc->sc_iobus_space.bus_reverse = 1;
				if ( bus_space_map(&(sc->sc_iobus_space), 0,
					NBPG, 0, &lcp->ioh_cf8) != 0 )
				{
					panic("mpcpcibus: unable to"
						" map self\n");
				}
				lcp->ioh_cfc = lcp->ioh_cf8;
			} else
#endif
d429 1
d437 7
a443 2
			printf("found  mem base %x io base %x config addr %x config data %x\n",
				sc->sc_membus_space.bus_base, sc->sc_iobus_space.bus_base, addr_offset, data_offset);
d457 1
d460 1
a477 1

d488 1
d495 33
d531 104
d756 45
d802 5
a820 1
	unsigned int bus, dev, fcn;
d827 5
a831 1
	mpc_decompose_tag(cpv, tag, &bus, &dev, &fcn);
d833 3
a835 27
	if ((cp->config_type & 1) && (bus == 0)) {
		if (dev > (30 - 11)) {
			return 0xffffffff;
		}
#if 0
	printf(" bus %x dev %x fcn %x offset %x", bus, dev, fcn, offset);
#endif
		/*
		 * Need to do config type 1 operation
		 *  1 << (11+dev) | fcn << 8 | reg
		 */
		reg = 1 << (11+dev) | fcn << 8 | offset;
		if ((cp->config_type & 2) && (offset & 0x4)) {
			daddr += 4;
		}
		
	} else {
#if 0
	printf(" bus %x dev %x fcn %x offset %x", bus, dev, fcn, offset);
#endif
		/* Config type 0 operation
		 * 80000000 | tag | offset
		 */
		reg =  0x80000000 | tag  | offset;
		if (bus != 0) {
			reg |= 1;
		}
a836 4
	}
#if 0
	printf(" daddr %x reg %x",daddr, reg);
#endif
d846 9
a854 2
#if 0
	printf("data %x\n", data);
d871 1
d873 1
a873 3
#if 0
	printf("mpc_conf_write tag %x offset %x data %x\n", tag, offset, data);
#endif
d875 9
a883 3
	reg = 0x80000000 | tag | offset;

	if (cp->config_type == 1) {
d885 6
a890 7
		/*
		 * Need to do config type 1 operation
		 * 80800000 | 1 << dev | fcn << 8 | reg
		 */
		if ( dev > 11) {
#if 0
			printf("invalid device\n", dev);
a891 10
			return;
		}
		mpc_decompose_tag(cpv, tag, &bus, &dev, &fcn);
		reg = 0x80800000  | 1 << dev | fcn << 8 | offset;
		
	} else {
		/* Config type 0 operation
		 * 80800000 | bus << 16 | dev << 11 | 
		 */
		reg =  0x80000000 | tag  | offset;
d893 1
a893 1
	}
d897 1
a897 1
	bus_space_write_4(cp->lc_iot, cp->ioh_cfc, 0, data);
@


1.15
log
@Find last memory or io segment, in case multiple happen to be found,
allows imac to configure ohci.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.14 2000/03/24 06:56:41 rahnds Exp $ */
a849 1
	printf("mpc_pintr_establish called for [%s]\n", name);
@


1.14
log
@Correct config mechanism for uni-north bridge.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.13 2000/03/20 07:10:50 rahnds Exp $ */
d389 1
d399 1
d402 2
a403 2
						/* find first? */
						break;
d407 1
a407 1
				if (prange[i].flags == 0x01000000) {
d409 1
a409 1
						prange[i].base;
d412 1
d416 2
a417 2
						/* find first? */
						break;
d421 1
a421 1
				if (prange[i].flags == 0x02000000) {
d423 1
a423 1
						prange[i].base;
@


1.13
log
@Changes to support uninorth bridge (probably a bit of a hack for now).
cleaned up the previous support for the macobio that was there previously.

Now registers real interupt handler devices instead of the pseudo configed
ones before.

The G4 systems are not yet working, the onboard ide configures properly
and interrupts seem to work, but the system hangs before mounting
the root drive (even ramdisks). Maybe someone will point out something
bogus in the code, so it is being checked in.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.12 2000/01/22 03:55:40 rahnds Exp $ */
d102 1
a102 5
#if 1
	{"uni-north",		0x00800000, 0x00c00000, 5 },
#else
	{"uni-north",		0x00800cf8, 0x00c00cfc, 0 },
#endif
a107 1
#if 1
a123 1
#endif
a492 1
#if 1
a493 1
#endif
d499 1
a499 5
	if (lcp->config_type & 4) {
		pba.pba_bus = 1;
	} else {
		pba.pba_bus = 0;
	}
d646 1
a646 3
#if 0
	printf("mpc_conf_read tag %x offset %x: ", tag, offset);
#endif
d648 4
a651 2

	mpc_decompose_tag(cpv, tag, &bus, &dev, &fcn);
d653 1
a653 1
	printf(" bus %x dev %x fcn %x ", bus, dev, fcn);
a654 2

	if (cp->config_type & 1 && bus == 0) {
d657 1
a657 1
		 * 80800000 | 1 << dev | fcn << 8 | reg
d659 3
a661 5
		if ( dev > 11) {
#if 0
			printf("invalid device\n", dev);
#endif
			return 0xffffffff;
a662 1
		reg = 0x80800000  | 1 << dev | fcn << 8 | offset;
d665 3
d677 3
a679 5
	if ((cp->config_type & 2) && (offset & 0x4)) {
		daddr += 4;
		
	}

d683 1
d685 2
d721 1
a721 1
#if 1
d738 1
d740 2
@


1.12
log
@Fix pci probing for the powerpc port, it was previously only probing a
portion of the pci devices, 1,2,4,8,... instead of 1,2,3,4,5,6,7,8,...

Updated to use indirect PCI configuration, so that pci-pci buses could
be probed. And that devices > 11 on the pci bus could be detected.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.11 2000/01/14 05:42:16 rahnds Exp $ */
d93 18
a110 6
/* ick, static variables */
static struct mpc_pci_io {
	bus_space_tag_t	iot;
	bus_space_handle_t	ioh_cf8;
	bus_space_handle_t	ioh_cfc;
} mpc_io;
d112 18
a129 1
struct pcibr_config mpc_config;
d158 2
d164 1
a164 18
	handle = ppc_open_pci_bridge();
	if (handle != 0) {
		err = OF_call_method("config-l@@", handle, 1, 1,
			0x80000000, &val);
		if (err == 0) {
			switch (val) {
			/* supported ppc-pci bridges */
			case (PCI_VENDOR_MOT | ( PCI_PRODUCT_MOT_MPC105 <<16)):
			case (PCI_VENDOR_MOT | ( PCI_PRODUCT_MOT_MPC106 <<16)):
				found = 1;
				break;
			default:
				found = 0;
			}

		}
	}
	ppc_close_pci_bridge(handle);
d176 1
d202 2
d213 2
a214 4
				mpc_cfg_read_1(sc->sc_iobus_space, sc->ioh_cf8,
					sc->ioh_cfc, MPC106_PCI_REVID));
		mpc_cfg_write_2(sc->sc_iobus_space, sc->ioh_cf8, sc->ioh_cfc,
			MPC106_PCI_STAT, 0xff80); /* Reset status */
a220 2
	case APPL:
		lcp = sc->sc_pcibr = &mpc_config;
a260 2


d267 1
a267 1
				&sc->ioh_cf8) != 0 )
d271 1
a271 1
			sc->ioh_cfc = sc->ioh_cf8;
d280 1
a280 1
				NBPG, 0, &sc->ioh_cf8) != 0 )
d285 1
a285 1
				NBPG, 0, &sc->ioh_cfc) != 0 )
a290 2
		mpc_io.ioh_cf8 = sc->ioh_cf8;
		mpc_io.ioh_cfc = sc->ioh_cfc;
d299 2
d310 1
a310 2
			mpc_cfg_read_1(&sc->sc_iobus_space, sc->ioh_cf8,
				sc->ioh_cfc, MPC106_PCI_REVID));
d317 2
a318 2
		mpc_cfg_write_2(sc->sc_iobus_space, sc->ioh_cf8, sc->ioh_cfc,
			MPC106_PCI_STAT, 0xff80); /* Reset status */
d322 172
d499 4
d507 5
a511 1
	pba.pba_bus = 0;
d643 2
d650 2
d662 33
a694 1
	reg =  0x80000000 | tag  | offset;
d698 2
a699 2
	bus_space_write_4(mpc_io.iot, mpc_io.ioh_cf8, 0xcf8, reg);
	data = bus_space_read_4(mpc_io.iot, mpc_io.ioh_cfc, 0xcfc);
d716 1
d727 22
a748 1
	s = splhigh();
d750 2
a751 2
	bus_space_write_4(mpc_io.iot, mpc_io.ioh_cf8, 0xcf8, reg);
	bus_space_write_4(mpc_io.iot, mpc_io.ioh_cfc, 0xcfc, data);
d843 1
a843 1
            int, int (*func)(void *), void *, char *));
d858 2
a859 1
	return (*intr_establish_func)(lcv, ih, level, func, arg, name);
d879 1
a879 2
	stat = mpc_cfg_read_4(sc->sc_iobus_space, sc->ioh_cf8, sc->ioh_cfc,
		MPC106_PCI_CMD);
d881 1
a881 2
	stat = mpc_cfg_read_2(sc->sc_iobus_space, sc->ioh_cf8, sc->ioh_cfc,
		MPC106_PCI_STAT);
d898 2
a899 4
mpc_cfg_write_1(iot, ioh_cf8, ioh_cfc, reg, val)
	bus_space_tag_t iot;
	bus_space_handle_t ioh_cf8;
	bus_space_handle_t ioh_cfc;
d905 1
a905 1
	bus_space_write_4(mpc_io.iot, ioh_cf8, 0xcf8,
d907 1
a907 1
	bus_space_write_1(mpc_io.iot, ioh_cfc, 0xcfc, val);
d912 2
a913 4
mpc_cfg_write_2(iot, ioh_cf8, ioh_cfc, reg, val)
	bus_space_tag_t iot;
	bus_space_handle_t ioh_cf8;
	bus_space_handle_t ioh_cfc;
d919 2
a920 2
	bus_space_write_4(mpc_io.iot, ioh_cf8, 0xcf8, MPC106_REGOFFS(reg));
	bus_space_write_2(mpc_io.iot, ioh_cfc, 0xcfc, val);
d925 2
a926 4
mpc_cfg_write_4(iot, ioh_cf8, ioh_cfc, reg, val)
	bus_space_tag_t iot;
	bus_space_handle_t ioh_cf8;
	bus_space_handle_t ioh_cfc;
d933 2
a934 2
	bus_space_write_4(mpc_io.iot, ioh_cf8, 0xcf8, MPC106_REGOFFS(reg));
	bus_space_write_4(mpc_io.iot, ioh_cfc, 0xcfc, val);
d939 2
a940 4
mpc_cfg_read_1(iot, ioh_cf8, ioh_cfc, reg)
	bus_space_tag_t iot;
	bus_space_handle_t ioh_cf8;
	bus_space_handle_t ioh_cfc;
d947 2
a948 2
	bus_space_write_4(mpc_io.iot, ioh_cf8, 0xcf8, MPC106_REGOFFS(reg));
	_v_ = bus_space_read_1(mpc_io.iot, ioh_cfc, 0xcfc);
d954 2
a955 4
mpc_cfg_read_2(iot, ioh_cf8, ioh_cfc, reg)
	bus_space_tag_t iot;
	bus_space_handle_t ioh_cf8;
	bus_space_handle_t ioh_cfc;
d962 2
a963 2
	bus_space_write_4(mpc_io.iot, ioh_cf8, 0xcf8, MPC106_REGOFFS(reg));
	_v_ = bus_space_read_2(mpc_io.iot, ioh_cfc, 0xcfc);
d969 2
a970 4
mpc_cfg_read_4(iot, ioh_cf8, ioh_cfc, reg)
	bus_space_tag_t iot;
	bus_space_handle_t ioh_cf8;
	bus_space_handle_t ioh_cfc;
d977 2
a978 2
	bus_space_write_4(mpc_io.iot, ioh_cf8, 0xcf8, MPC106_REGOFFS(reg));
	_v_ = bus_space_read_4(mpc_io.iot, ioh_cfc, 0xcfc);
@


1.12.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d93 7
a101 30
struct {
	char * compat;
	u_int32_t addr;	 /* offset */
	u_int32_t data;	 /* offset */
	int config_type;
} config_offsets[] = {
	{"grackle",		0x00c00cf8, 0x00e00cfc, 0 },
	{"uni-north",		0x00800000, 0x00c00000, 1 },
	{"legacy",		0x00000cf8, 0x00000cfc, 0 },
	{"IBM,27-82660",	0x00000cf8, 0x00000cfc, 0 },
	{NULL,			0x00000000, 0x00000000, 0 },
};

struct powerpc_bus_dma_tag pci_bus_dma_tag = {
	NULL,
	_dmamap_create,
	_dmamap_destroy,
	_dmamap_load,
	_dmamap_load_mbuf,
	_dmamap_load_uio,
	_dmamap_load_raw,
	_dmamap_unload,
	_dmamap_sync,
	_dmamem_alloc,
	_dmamem_free,
	_dmamem_map,
	_dmamem_unmap,
	_dmamem_mmap
};

a128 2
	int qhandle;
	char type[32];
d133 18
a150 1
	found = 1;
a161 1
	struct confargs *ca = aux;
a186 2
		lcp->lc_iot = &sc->sc_iobus_space;
		lcp->lc_memt = &sc->sc_membus_space;
d196 4
a199 2
				mpc_cfg_read_1(lcp, MPC106_PCI_REVID));
		mpc_cfg_write_2(lcp, MPC106_PCI_STAT, 0xff80); /* Reset status */
d206 2
d248 2
d256 1
a256 1
				&lcp->ioh_cf8) != 0 )
d260 1
a260 1
			lcp->ioh_cfc = lcp->ioh_cf8;
d269 1
a269 1
				NBPG, 0, &lcp->ioh_cf8) != 0 )
d274 1
a274 1
				NBPG, 0, &lcp->ioh_cfc) != 0 )
d280 2
a289 2
		lcp->lc_iot = &sc->sc_iobus_space;
		lcp->lc_memt = &sc->sc_membus_space;
d299 2
a300 1
			mpc_cfg_read_1(lcp, MPC106_PCI_REVID));
d307 2
a308 2
		/* Reset status */
		mpc_cfg_write_2(lcp, MPC106_PCI_STAT, 0xff80);
a311 172
	case APPL:
		/* scan the children of the root of the openfirmware
		 * tree to locate all nodes with device_type of "pci"
		 */
		if (ca->ca_node == 0) {
			printf("invalid node on mpcpcibr config\n");
			return;
		}
		{
			char compat[32];
			u_int32_t addr_offset;
			u_int32_t data_offset;
			int i;
			int len;

#if 0
			/* for powerstack boxes? */
			struct ranges_old {
				u_int32_t flags;
				u_int32_t pad1;
				u_int32_t pad2;
				u_int32_t base;
				u_int32_t size;
			};
			struct ranges_old porange = &range_store;
#endif 
			struct ranges_new {
				u_int32_t flags;
				u_int32_t pad1;
				u_int32_t pad2;
				u_int32_t base;
				u_int32_t pad3;
				u_int32_t size;
			};
			u_int32_t range_store[32];
			struct ranges_new *prange = (void *)&range_store;

			len=OF_getprop(ca->ca_node, "compatible", compat,
				sizeof (compat));
			if (len <= 0 ) {
				printf(" compatible not found\n");
				return;
			}
			compat[len] = 0; 

			if (OF_getprop(ca->ca_node, "ranges", range_store,
				sizeof (range_store)) <= 0)
			{
				printf("range lookup failed, node %x\n",
				ca->ca_node);
			}

			lcp = sc->sc_pcibr = &sc->pcibr_config;

#if 0			
			/* powerstack boxes? */
			if (strcmp(compat, "IBM,27-82660") {
				sc->sc_membus_space.bus_base =
					MPC106_P_PCI_MEM_SPACE;
				sc->sc_membus_space.bus_reverse = 1;
				sc->sc_iobus_space.bus_base =
					MPC106_P_PCI_IO_SPACE;
				sc->sc_iobus_space.bus_reverse = 1;
				if ( bus_space_map(&(sc->sc_iobus_space), 0,
					NBPG, 0, &lcp->ioh_cf8) != 0 )
				{
					panic("mpcpcibus: unable to"
						" map self\n");
				}
				lcp->ioh_cfc = lcp->ioh_cf8;
			} else
#endif
			{

				/* mac configs */

				sc->sc_membus_space.bus_base = 0;
				sc->sc_membus_space.bus_reverse = 1;
				sc->sc_iobus_space.bus_base = 0;
				sc->sc_iobus_space.bus_reverse = 1;

				/* find io(config) base, flag == 0x01000000 */
				for (i = 0; prange[i].flags != 0; i++) {
					if (prange[i].flags == 0x01000000) {
						/* find first? */
						break;
					}
				}
				/* found the io space ranges */
				if (prange[i].flags == 0x01000000) {
					sc->sc_iobus_space.bus_base =
						prange[i].base;
				}

				/* find mem base, flag == 0x02000000 */
				for (i = 0; prange[i].flags != 0; i++) {
					if (prange[i].flags == 0x02000000) {
						/* find first? */
						break;
					}
				}
				/* found the mem space ranges */
				if (prange[i].flags == 0x02000000) {
					sc->sc_membus_space.bus_base =
						prange[i].base;
				}
				if ( (sc->sc_iobus_space.bus_base == 0) ||
					(sc->sc_membus_space.bus_base == 0)) {
					printf("io or memory base not found"
						"mem %x io %x\n",
						sc->sc_membus_space.bus_base,
						sc->sc_iobus_space.bus_base);
				}

			}

			
			addr_offset = 0;
			for (i = 0; config_offsets[i].compat != NULL; i++) {
				if (strcmp(config_offsets[i].compat, compat)
					== 0)
				{
					addr_offset = config_offsets[i].addr; 
					data_offset = config_offsets[i].data; 
					lcp->config_type =
						config_offsets[i].config_type;
				}
			}
			if (addr_offset == 0) {
				printf("unable to find match for"
					" compatible %s\n", compat);
				return;
			}
			printf("found  mem base %x io base %x config addr %x config data %x\n",
				sc->sc_membus_space.bus_base, sc->sc_iobus_space.bus_base, addr_offset, data_offset);



			if ( bus_space_map(&(sc->sc_iobus_space), addr_offset,
				NBPG, 0, &lcp->ioh_cf8) != 0 )
			{
				panic("mpcpcibus: unable to map self\n");
			}
			if ( bus_space_map(&(sc->sc_iobus_space), data_offset,
				NBPG, 0, &lcp->ioh_cfc) != 0 )
			{
				panic("mpcpcibus: unable to map self\n");
			}
		}

		lcp->lc_pc.pc_conf_v = lcp;
		lcp->lc_pc.pc_attach_hook = mpc_attach_hook;
		lcp->lc_pc.pc_bus_maxdevs = mpc_bus_maxdevs;
		lcp->lc_pc.pc_make_tag = mpc_make_tag;
		lcp->lc_pc.pc_decompose_tag = mpc_decompose_tag;
		lcp->lc_pc.pc_conf_read = mpc_conf_read;
		lcp->lc_pc.pc_conf_write = mpc_conf_write;
		lcp->lc_pc.pc_ether_hw_addr = mpc_ether_hw_addr;
		lcp->lc_iot = &sc->sc_iobus_space;
		lcp->lc_memt = &sc->sc_membus_space;

	        lcp->lc_pc.pc_intr_v = lcp;
		lcp->lc_pc.pc_intr_map = mpc_intr_map;
		lcp->lc_pc.pc_intr_string = mpc_intr_string;
		lcp->lc_pc.pc_intr_establish = mpc_intr_establish;
		lcp->lc_pc.pc_intr_disestablish = mpc_intr_disestablish;


		printf(": %s, Revision %x. ", bridge, 
			mpc_cfg_read_1(lcp, MPC106_PCI_REVID));
		break;

a316 2
	pba.pba_dmat = &pci_bus_dma_tag;

a452 2
	struct pcibr_config *cp = cpv;

a457 2
	int daddr = 0;
	unsigned int bus, dev, fcn;
a463 6
	mpc_decompose_tag(cpv, tag, &bus, &dev, &fcn);

	if ((cp->config_type & 1) && (bus == 0)) {
		if (dev > (30 - 11)) {
			return 0xffffffff;
		}
d465 1
a465 1
	printf(" bus %x dev %x fcn %x offset %x", bus, dev, fcn, offset);
a466 20
		/*
		 * Need to do config type 1 operation
		 *  1 << (11+dev) | fcn << 8 | reg
		 */
		reg = 1 << (11+dev) | fcn << 8 | offset;
		if ((cp->config_type & 2) && (offset & 0x4)) {
			daddr += 4;
		}
		
	} else {
#if 0
	printf(" bus %x dev %x fcn %x offset %x", bus, dev, fcn, offset);
#endif
		/* Config type 0 operation
		 * 80000000 | tag | offset
		 */
		reg =  0x80000000 | tag  | offset;
		if (bus != 0) {
			reg |= 1;
		}
d468 2
a469 4
	}
#if 0
	printf(" daddr %x reg %x",daddr, reg);
#endif
d472 2
a473 5
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, reg);
	bus_space_read_4(cp->lc_iot, cp->ioh_cf8, 0); /* XXX */
	data = bus_space_read_4(cp->lc_iot, cp->ioh_cfc, daddr);
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, 0); /* disable */
	bus_space_read_4(cp->lc_iot, cp->ioh_cf8, 0); /* XXX */
a489 1
	struct pcibr_config *cp = cpv;
d500 1
a500 22
	if (cp->config_type == 1) {
		unsigned int bus, dev, fcn;
		/*
		 * Need to do config type 1 operation
		 * 80800000 | 1 << dev | fcn << 8 | reg
		 */
		if ( dev > 11) {
#if 0
			printf("invalid device\n", dev);
#endif
			return;
		}
		mpc_decompose_tag(cpv, tag, &bus, &dev, &fcn);
		reg = 0x80800000  | 1 << dev | fcn << 8 | offset;
		
	} else {
		/* Config type 0 operation
		 * 80800000 | bus << 16 | dev << 11 | 
		 */
		reg =  0x80000000 | tag  | offset;

	}
d502 2
a503 5
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, reg);
	bus_space_read_4(cp->lc_iot, cp->ioh_cf8, 0); /* XXX */
	bus_space_write_4(cp->lc_iot, cp->ioh_cfc, 0, data);
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, 0); /* disable */
	bus_space_read_4(cp->lc_iot, cp->ioh_cf8, 0); /* XXX */
d595 1
a595 1
            int, int, int (*func)(void *), void *, char *));
d610 1
a610 2
	return (*intr_establish_func)(lcv, ih, IST_LEVEL, level, func, arg,
		name);
d630 2
a631 1
	stat = mpc_cfg_read_4(cp, MPC106_PCI_CMD);
d633 2
a634 1
	stat = mpc_cfg_read_2(cp, MPC106_PCI_STAT);
d651 4
a654 2
mpc_cfg_write_1(cp, reg, val)
	struct pcibr_config *cp;
d660 1
a660 1
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0,
d662 1
a662 1
	bus_space_write_1(cp->lc_iot, cp->ioh_cfc, 0, val);
d667 4
a670 2
mpc_cfg_write_2(cp, reg, val)
	struct pcibr_config *cp;
d676 2
a677 2
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, MPC106_REGOFFS(reg));
	bus_space_write_2(cp->lc_iot, cp->ioh_cfc, 0, val);
d682 4
a685 2
mpc_cfg_write_4(cp, reg, val)
	struct pcibr_config *cp;
d692 2
a693 2
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, MPC106_REGOFFS(reg));
	bus_space_write_4(cp->lc_iot, cp->ioh_cfc, 0, val);
d698 4
a701 2
mpc_cfg_read_1(cp, reg)
	struct pcibr_config *cp;
d708 2
a709 2
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, MPC106_REGOFFS(reg));
	_v_ = bus_space_read_1(cp->lc_iot, cp->ioh_cfc, 0);
d715 4
a718 2
mpc_cfg_read_2(cp, reg)
	struct pcibr_config *cp;
d725 2
a726 2
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, MPC106_REGOFFS(reg));
	_v_ = bus_space_read_2(cp->lc_iot, cp->ioh_cfc, 0);
d732 4
a735 2
mpc_cfg_read_4(cp, reg)
	struct pcibr_config *cp;
d742 2
a743 2
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, MPC106_REGOFFS(reg));
	_v_ = bus_space_read_4(cp->lc_iot, cp->ioh_cfc, 0);
@


1.12.2.2
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.25 2001/03/29 20:05:04 drahn Exp $ */
d36 1
a36 2
 * Generic PCI BUS Bridge driver.
 * specialized hooks for different config methods.
d81 1
a81 2
int      mpc_ether_hw_addr __P((struct ppc_pci_chipset *, u_int8_t *));
int      of_ether_hw_addr __P((struct ppc_pci_chipset *, u_int8_t *));
a94 9
/*
 * config types
 * bit meanings
 * 0 - standard cf8/cfc type configurations,
 *     sometimes the base addresses for these are different
 * 1 - Config Method #2 configuration - uni-north
 *
 * 2 - 64 bit config bus, data for accesses &4 is at daddr+4;
 */
d102 1
a102 2
	{"bandit",		0x00800000, 0x00c00000, 0 },
	{"uni-north",		0x00800000, 0x00c00000, 3 },
a162 2
void fix_node_irq(int node, struct pcibus_attach_args *pba);

d173 1
a173 1
	int map, node;
a174 3
	int of_node = 0;
	u_int32_t base;
	u_int32_t size;
d205 2
a206 1
		printf(": MPC106, Revision 0x%x.\n", 
a207 1
#if 0
d303 1
a303 1
		printf(": %s, Revision 0x%x, ", bridge, 
a319 1

a327 5
			struct pci_reserve_mem null_reserve = {
				0,
				0,
				0
			};
a329 1
			int rangelen;
d331 11
d356 2
a357 13
				len=OF_getprop(ca->ca_node, "name", compat,
					sizeof (compat));
				if (len <= 0) {
					printf(" compatible and name not"
						" found\n");
					return;
				}
				compat[len] = 0; 
				if (strcmp (compat, "bandit") != 0) {
					printf(" compatible not found and name"
						" %s found\n", compat);
					return;
				}
d360 3
a362 3
			if ((rangelen = OF_getprop(ca->ca_node, "ranges",
				range_store,
				sizeof (range_store))) <= 0)
a366 2
			/* translate byte(s) into item count/*/
			rangelen /= sizeof(struct ranges_new);
d370 18
a388 3
				int found;
				unsigned int base = 0;
				unsigned int size = 0;
d398 1
a398 3
				found = 0;
				for (i = 0; i < rangelen ; i++)
				{
d400 2
a401 2
						/* find last? */
						found = i;
d405 1
a405 1
				if (prange[found].flags == 0x01000000) {
d407 1
a407 3
						prange[found].base;
					sc->sc_iobus_space.bus_size =
						prange[found].size;
d410 2
a411 12
				/* the mem space ranges 
				 * apple openfirmware always puts full
				 * addresses in config information,
				 * it is not necessary to have correct bus
				 * base address, but since 0 is reserved
				 * and all IO and device memory will be in
				 * upper 2G of address space, set to
				 * 0x80000000
				 * start with segment 1 not 0, 0 is config.
				 */
				for (i = 0; i < rangelen ; i++)
				{
d413 2
a414 22
#if 0
						printf("\nfound mem %x %x",
							prange[i].base,
							prange[i].size);
#endif
							
						if (base != 0) {
							if ((base + size) ==
							    prange[i].base)
							{
							    size +=
								prange[i].size;
							} else {
								base =
								 prange[i].base;
								size =
								 prange[i].size;
							}
						} else {
							base = prange[i].base;
							size = prange[i].size;
						}
d417 12
a428 2
				sc->sc_membus_space.bus_base = base;
				sc->sc_membus_space.bus_size = size;
d431 1
a431 7
#if 0
			printf("membase %x size %x iobase %x size %x\n",
				sc->sc_membus_space.bus_base,
				sc->sc_membus_space.bus_size,
				sc->sc_iobus_space.bus_base,
				sc->sc_iobus_space.bus_size);
#endif
a441 1
					break;
d449 2
a450 7
#if 0
			printf(" mem base %x io base %x config addr %x"
				" config data %x\n",
				sc->sc_membus_space.bus_base,
				sc->sc_iobus_space.bus_base,
				addr_offset, data_offset);
#endif
d464 1
a464 1
			of_node = ca->ca_node;
d466 10
d477 5
a481 17
			lcp->node = ca->ca_node;
			lcp->lc_pc.pc_conf_v = lcp;
			lcp->lc_pc.pc_attach_hook = mpc_attach_hook;
			lcp->lc_pc.pc_bus_maxdevs = mpc_bus_maxdevs;
			lcp->lc_pc.pc_make_tag = mpc_make_tag;
			lcp->lc_pc.pc_decompose_tag = mpc_decompose_tag;
			lcp->lc_pc.pc_conf_read = mpc_conf_read;
			lcp->lc_pc.pc_conf_write = mpc_conf_write;
			lcp->lc_pc.pc_ether_hw_addr = of_ether_hw_addr;
			lcp->lc_iot = &sc->sc_iobus_space;
			lcp->lc_memt = &sc->sc_membus_space;

			lcp->lc_pc.pc_intr_v = lcp;
			lcp->lc_pc.pc_intr_map = mpc_intr_map;
			lcp->lc_pc.pc_intr_string = mpc_intr_string;
			lcp->lc_pc.pc_intr_establish = mpc_intr_establish;
			lcp->lc_pc.pc_intr_disestablish = mpc_intr_disestablish;
a482 2
			printf(": %s, Revision 0x%x\n", compat, 
				mpc_cfg_read_1(lcp, MPC106_PCI_REVID));
d484 2
a485 4
#if 0
			pci_addr_fixup(sc, &lcp->lc_pc, 32, &null_reserve);
#endif
		}
a493 1
		
a499 33

	/* we want to check pci irq settings */
	if (of_node != 0) {
		int nn;

		for (node = OF_child(of_node); node; node = nn)
		{
			{
				char name[32];
				int len;
				len = OF_getprop(node, "name", name,
					sizeof(name));
				name[len] = 0;
#if 0
				printf("checking node %s\n", name);
#endif
			}
			fix_node_irq(node, &pba);

			/* iterate section */
			if ((nn = OF_child(node)) != 0) {
				continue;
			}
			while ((nn = OF_peer(node)) == 0) {
				node = OF_parent(node);
				if (node == of_node) {
					nn = 0; /* done */
					break;
				}
			}
		}
	}

a502 104
                 
#define       OFW_PCI_PHYS_HI_BUSMASK         0x00ff0000
#define       OFW_PCI_PHYS_HI_BUSSHIFT        16
#define       OFW_PCI_PHYS_HI_DEVICEMASK      0x0000f800
#define       OFW_PCI_PHYS_HI_DEVICESHIFT     11
#define       OFW_PCI_PHYS_HI_FUNCTIONMASK    0x00000700
#define       OFW_PCI_PHYS_HI_FUNCTIONSHIFT   8

#define pcibus(x) \
	(((x) & OFW_PCI_PHYS_HI_BUSMASK) >> OFW_PCI_PHYS_HI_BUSSHIFT)
#define pcidev(x) \
	(((x) & OFW_PCI_PHYS_HI_DEVICEMASK) >> OFW_PCI_PHYS_HI_DEVICESHIFT)
#define pcifunc(x) \
	(((x) & OFW_PCI_PHYS_HI_FUNCTIONMASK) >> OFW_PCI_PHYS_HI_FUNCTIONSHIFT)

/* 
 * Find PCI IRQ from OF
 */
int
find_node_intr(node, addr, intr)
	int node;
	u_int32_t *addr, *intr;
{
	int parent, iparent, len, mlen;
	int match, i;
	u_int32_t map[64], *mp;
	u_int32_t imask[8], maskedaddr[8];
	u_int32_t icells;
	char name [32];

	len = OF_getprop(node, "AAPL,interrupts", intr, 4);
	if (len == 4)
		return 1;

	parent = OF_parent(node);
	len = OF_getprop(parent, "interrupt-map", map, sizeof(map));
	mlen = OF_getprop(parent, "interrupt-map-mask", imask, sizeof(imask));

	if ((len == -1) || (mlen == -1))
		goto nomap;
	for (i = 0; i < (mlen / 4); i++) {
		maskedaddr[i] = addr[i] & imask[i];
	}
	mp = map;
	while (len > mlen) {
		match = bcmp(maskedaddr, mp, mlen);
		mp += mlen / 4;
		len -= mlen;
		iparent = *mp++;
		if (OF_getprop(iparent, "#interrupt-cells", &icells, 4) != 4)
			return -1;

		if (match == 0) {
			/* multiple irqs? */
			*intr = *mp;
			return 1;
		}
		mp += icells;
		len -= icells * 4;
	}
	return -1;
nomap:
	return -1;
}

void
fix_node_irq(node, pba)
	int node;
	struct pcibus_attach_args *pba;
{
	struct { 
		u_int32_t phys_hi, phys_mid, phys_lo;
		u_int32_t size_hi, size_lo;
	} addr [8];
	int len;
	pcitag_t tag;
	u_int32_t irq;
	u_int32_t intr;

	pci_chipset_tag_t pc = pba->pba_pc;

	len = OF_getprop(node, "assigned-addresses", addr, sizeof(addr));
	if (len < sizeof(addr[0])) {
		return;
	}
	tag = pci_make_tag(pc, pcibus(addr[0].phys_hi),
		pcidev(addr[0].phys_hi),
		pcifunc(addr[0].phys_hi));
	/* program the interrupt line register with the value
	 * found in openfirmware
	 */
	if (find_node_intr(node, &addr[0].phys_hi, &irq) == -1)
		return;

	intr = pci_conf_read(pc, tag, PCI_INTERRUPT_REG);
#if 0
	printf("changing interrupt from %d to %d\n",
		intr & PCI_INTERRUPT_LINE_MASK,
		irq & PCI_INTERRUPT_LINE_MASK);
#endif
	intr &= ~PCI_INTERRUPT_LINE_MASK;
	intr |= irq & PCI_INTERRUPT_LINE_MASK;
	pci_conf_write(pc, tag, PCI_INTERRUPT_REG, intr);
}
d547 2
a548 1
of_ether_hw_addr(struct ppc_pci_chipset *lcpc, u_int8_t *oaddr)
d550 1
a550 19
	u_int8_t laddr[6];
	struct pcibr_config *lcp = lcpc->pc_conf_v;
	int of_node = lcp->node;
	int node, nn;
	for (node = OF_child(of_node); node; node = nn)
	{
		char name[32];
		int len;
		len = OF_getprop(node, "name", name,
			sizeof(name));
		name[len] = 0;
		if (sizeof (laddr) ==
			OF_getprop(node, "local-mac-address", laddr,
				sizeof laddr))
		{
			bcopy (laddr, oaddr, sizeof laddr);
			return 1;
			
		}
d552 36
a587 24
		/* iterate section */
		if ((nn = OF_child(node)) != 0) {
			continue;
		}
		while ((nn = OF_peer(node)) == 0) {
			node = OF_parent(node);
			if (node == of_node) {
				nn = 0; /* done */
				break;
			}
		}
	}
	oaddr[0] = oaddr[1] = oaddr[2] = 0xff;
	oaddr[3] = oaddr[4] = oaddr[5] = 0xff;
	return 0;
}

int
mpc_ether_hw_addr(p, s)
	struct ppc_pci_chipset *p;
	u_int8_t *s;
{
	printf("mpc_ether_hw_addr not supported\n");
	return(0);
a623 49
static u_int32_t
mpc_gen_config_reg(cpv, tag, offset)
	void *cpv;
	pcitag_t tag;
	int offset;
{
	struct pcibr_config *cp = cpv;
	unsigned int bus, dev, fcn;
	u_int32_t reg;
	/*
	static int spin = 0;
	while (spin > 85);
	spin++;
	*/

	mpc_decompose_tag(cpv, tag, &bus, &dev, &fcn);

	if (cp->config_type & 1) {
		/* Config Mechanism #2 */
		if (bus == 0) {
			if (dev < 11) {
				return 0xffffffff;
			}
			/*
			 * Need to do config type 0 operation
			 *  1 << (11?+dev) | fcn << 8 | reg
			 * 11? is because pci spec states
			 * that 11-15 is reserved.
			 */
			reg = 1 << (dev) | fcn << 8 | offset;
			
		} else {
			if (dev > 15) {
			 return 0xffffffff;
			}
			/*
			 * config type 1 
			 */
			reg =  tag  | offset | 1;

		}
	} else {
		/* config mechanism #2, type 0
		/* standard cf8/cfc config */
		reg =  0x80000000 | tag  | offset;

	}
	return reg;
}
a624 1
/* #define DEBUG_CONFIG  */
d639 1
a641 1
#ifdef DEBUG_CONFIG 
a642 1
#endif /* DEBUG_CONFIG */
d646 29
a674 5
	reg = mpc_gen_config_reg(cpv, tag, offset);
	/* if invalid tag, return -1 */
	if (reg == 0xffffffff) {
		return 0xffffffff;
	}
a675 2
	if ((cp->config_type & 2) && (offset & 0x04)) {
		daddr += 4;
d677 3
a679 1

d689 2
a690 9
#ifdef DEBUG_CONFIG
	if (!((offset == 0) && (data == 0xffffffff))) {
		unsigned int bus, dev, fcn;
		mpc_decompose_tag(cpv, tag, &bus, &dev, &fcn);
		printf("mpc_conf_read bus %x dev %x fcn %x offset %x", bus, dev, fcn,
			offset);
		printf(" daddr %x reg %x",daddr, reg);
		printf(" data %x\n", data);
	}
a706 1
	int daddr = 0;
d708 5
a712 1
	reg = mpc_gen_config_reg(cpv, tag, offset);
d714 1
a714 9
	/* if invalid tag, return ??? */
	if (reg == 0xffffffff) {
		return;
	}
	if ((cp->config_type & 2) && (offset & 0x04)) {
		daddr += 4;
	}
#ifdef DEBUG_CONFIG
	{
d716 10
d727 8
a734 4
		printf("mpc_conf_write bus %x dev %x fcn %x offset %x", bus,
			dev, fcn, offset);
		printf(" daddr %x reg %x",daddr, reg);
		printf(" data %x\n", data);
a735 3
#endif

	s = splhigh();
d739 1
a739 1
	bus_space_write_4(cp->lc_iot, cp->ioh_cfc, daddr, data);
d847 1
@


1.12.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.12.2.2 2001/05/14 21:36:51 niklas Exp $ */
a49 1
#include <machine/powerpc.h>
a62 1
#include <dev/ofw/openfirm.h>
d64 1
d160 1
d162 4
d190 2
d194 36
a345 1
#if 0
a350 1
#endif
d391 1
a391 1
			/* translate byte(s) into item count*/
d466 8
d491 2
a492 2
#ifdef PCI_DEBUG
			printf(" mem base %x sz %x io base %x sz %x\n config addr %x"
a494 1
				sc->sc_membus_space.bus_size,
a495 1
				sc->sc_iobus_space.bus_size,
d618 1
d710 1
a710 1
 *  XXX Note that cross page boundarys are *not* guarantee to work!
d715 1
a715 1
	void * p;
d717 2
a718 2
	paddr_t pa;
	vaddr_t va;
d720 1
a720 1
	va = (vaddr_t) p;
d725 1
a725 1
		pmap_extract(vm_map_pmap(phys_map), va, &pa);
d863 1
a863 2
		 * standard cf8/cfc config
		 */
d881 1
d883 1
d936 1
a970 1
/*ARGSUSED*/
d978 2
d981 3
d995 45
d1055 6
@


1.12.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.12.2.3 2001/07/04 10:22:42 niklas Exp $ */
@


1.12.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
@


1.12.2.6
log
@repair
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.12.2.5 2001/11/13 21:04:16 niklas Exp $ */
@


1.11
log
@

UVM changes mainly. As of this checkin UVM is still not working for powerpc
it has a copyin bug after device configuration. However to get these diffs
out of my tree.

All of the UVM code is currently inside ifdef UVM the kernel works fine
without option UVM. Config files have been left without UVM for now.

Prelimiary changes for busdma, (what UVM was wanted for).
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.10 1999/11/08 23:49:00 rahnds Exp $ */
d93 7
d194 1
a194 3
		printf(": MPC106, Revision %x.\n",
				mpc_cfg_read_1(sc->sc_iobus_space, sc->ioh,
					MPC106_PCI_REVID));
d196 3
a198 1
		mpc_cfg_write_2(sc->sc_iobus_space, sc->ioh,
d255 6
d268 10
d280 2
a295 5
		if ( bus_space_map(&(sc->sc_iobus_space), 0, NBPG, 0,
			&sc->ioh) != 0 )
		{
			panic("mpcpcibus: unable to map self\n");
		}
d298 3
a300 3
		printf("iospace base %x ioh %x\n", sc->sc_iobus_space.bus_base, 
			sc->ioh);
		printf(": %s, Revision %x. ", bridge, 0x999999);
d307 1
a307 3
			mpc_cfg_read_1(sc->sc_iobus_space, sc->ioh,
				MPC106_PCI_REVID));
		mpc_cfg_write_2(sc->sc_iobus_space, sc->ioh,
d417 1
a417 1
	return(16);
d420 4
d429 1
a429 1
	return (bus << 16) | (dev << 11) | (fnc << 8);
d439 1
a439 1
		*busp = (tag >> 16) & 0xff;
d441 1
a441 1
		*devp = (tag >> 11) & 0x1f;
d443 1
a443 1
		*fncp = (tag >> 8) & 0x7;
d446 1
d454 1
a454 1
	u_int32_t addr;
a458 2
	if((tag >> 16) != 0)
		return(~0);
a463 3
	device = (tag >> 11) & 0x1f;
	if(device > 11)
		return(~0);	/* Outside config space */
d468 1
a468 1
	addr = (0x800 << device) | (tag & 0x380) | offset;
a469 1
	handle = ppc_open_pci_bridge();
d472 2
a473 2
	OF_call_method("config-l@@", handle, 1, 1,
		0x80000000 | addr, &data);
a475 1
	ppc_close_pci_bridge(handle);
d490 1
a490 2
	u_int32_t addr;
	int device;
d493 1
d498 1
a498 2
	device = (tag >> 11) & 0x1f;
	addr = (0x800 << device) | (tag & 0x380) | offset;
a499 1
	handle = ppc_open_pci_bridge();
d502 3
a504 2
	OF_call_method("config-l!", handle, 1, 1,
		0x80000000 | addr, &data);
a505 1
	ppc_close_pci_bridge(handle);
d508 1
d594 6
d610 5
a614 4
	/*
	return isabr_intr_establish(NULL, ih, IST_LEVEL, level, func, arg, name);
	*/
	return NULL;
d630 2
a631 1
	stat = mpc_cfg_read_4(sc->sc_iobus_space, sc->ioh, MPC106_PCI_CMD);
d633 2
a634 1
	stat = mpc_cfg_read_2(sc->sc_iobus_space, sc->ioh, MPC106_PCI_STAT);
d648 98
@


1.10
log
@Changes for imac support. support for VI computers and MCG Powerstack
will need to be merged back in. Both are currently untested.
mac interrupt support is currently a big hack and needs to be redesigned
as part of the system, several of the mac drivers need busified also.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.9 1999/01/11 05:11:53 millert Exp $ */
d446 1
d448 1
d460 1
d462 1
d478 1
d480 1
@


1.9
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.8 1998/08/25 08:20:23 pefo Exp $ */
d50 1
d53 1
d57 1
a111 1

d118 4
d124 16
a139 1
		return (0);
d141 5
a145 1
	return (1);
d148 1
d157 2
d188 7
a194 2
				mpc_cfg_read_1(MPC106_PCI_REVID));
		mpc_cfg_write_2(MPC106_PCI_STAT, 0xff80); /* Reset status */
d199 1
d201 22
d224 4
a227 4
		{
			unsigned int addr;
			/* need to map 0xf0000000 also but cannot
			 * because kernel uses that address space
d229 8
a236 9
			for (addr =    0xc0000000;
			     addr >=	  0x80000000;
			     addr -=   0x10000000)
			{
				/* we map it 1-1, cache inibited,
				 * REALLY wish this could be cacheable
				 * that is the reason to not use the bat.
				 */
				addbatmap(addr, addr, BAT_I);
d238 2
d242 14
a255 4
		sc->sc_membus_space.bus_base = MPC106_V_PCI_MEM_SPACE;
		sc->sc_membus_space.bus_reverse = 1;
		sc->sc_iobus_space.bus_base = MPC106_V_PCI_IO_SPACE;
		sc->sc_iobus_space.bus_reverse = 1;
d271 5
d277 15
a291 3
		printf(": MPC106, Revision %x.\n",
				mpc_cfg_read_1(MPC106_PCI_REVID));
		mpc_cfg_write_2(MPC106_PCI_STAT, 0xff80); /* Reset status */
d340 1
a340 1
	return(pa | MPC106_PCI_CPUMEM);
d434 1
d446 1
d450 1
d453 2
a454 2
	/* low 20 bits of address are in the actual address */
	data = in32rb(MPC106_PCI_CONF_SPACE | addr);
d457 3
d473 2
d479 1
d482 2
a483 3
	/* low 20 bits of address are in the actual address */
	out32rb(MPC106_PCI_CONF_SPACE | addr, data);

d485 1
d512 2
d555 1
d582 2
a583 3
	if (ih == 0 || ih >= ICU_LEN || ih == 2)
		panic("pci_intr_establish: bogus handle 0x%x", ih);

d585 2
d596 1
d602 1
a602 1
	stat = mpc_cfg_read_4(MPC106_PCI_CMD);
d604 1
a604 1
	stat = mpc_cfg_read_2(MPC106_PCI_STAT);
d607 1
@


1.8
log
@Polish
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.7 1998/08/23 22:08:51 rahnds Exp $ */
d487 1
a487 1
		panic("pci_intr_establish: bogus handle 0x%x\n", ih);
@


1.7
log
@Code to maintain edge/level in the isa interrupt driver.
Use the pci iack cycle to determine interrupt cause instead of
polling the chip.
Probably could use some more work.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.6 1998/08/22 18:31:50 rahnds Exp $ */
d136 3
d141 1
a141 1
		sc->sc_iobus_space.bus_base = MPC106_PCI_IO_SPACE;
d163 1
a169 1

d187 1
a187 1
		sc->sc_iobus_space.bus_base = MPC106_PCI_IO_SPACE;
d209 1
d402 2
d407 1
d420 1
d422 2
a423 7
		switch(line) {
		case 14:
			line = 9;
			route &= ~0x000000ff;
			route |= line;
			break;
		case 11:
d428 2
a429 1
		case 12:
d434 2
a435 1
		case 13:
d440 11
d452 1
d454 1
a454 1
		lvl |= isa_inb(0x04d1);
@


1.6
log
@Various changes to allow mixing of ofw drivers and real drivers.
NCR driver seems to work.
Major changes are isa can be child of pci or mainbus.
ofroot is child of mainbus not root.
ofw bus configured before pci bus
Note that if a pci device configures accessing of driver will crash
the system. they need to be exclusive.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.5 1998/08/06 15:04:00 pefo Exp $ */
d164 17
a180 3
		addbatmap(0x80000000, 0x80000000, BAT_I);
		addbatmap(MPC106_P_PCI_MEM_SPACE,
			MPC106_P_PCI_MEM_SPACE, BAT_I);
d491 11
@


1.5
log
@Some small fixes for non ofw systems
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.4 1998/04/06 20:23:21 pefo Exp $ */
d48 1
d160 35
@


1.4
log
@fix some types
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.3 1997/10/21 18:01:44 pefo Exp $ */
d77 1
a77 1
int      mpc_ether_hw_addr __P((u_int8_t *));
d135 4
a138 2
		sc->sc_bus_space.bus_base = MPC106_V_PCI_MEM_SPACE;
		sc->sc_bus_space.bus_reverse = 1;
d162 2
a163 2
	pba.pba_iot = &sc->sc_bus_space;
	pba.pba_memt = &sc->sc_bus_space;
d213 2
a214 2
mpc_ether_hw_addr(p)
	u_int8_t *p;
@


1.3
log
@Dig out the ethernet address from the board configuration. This just takes
the first "network" with a "mac-address" for this. In the future this has
to be improved (probably) to handle more than one ethernet ifc.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.2 1997/10/20 19:52:42 pefo Exp $ */
d77 1
a77 1
void      mpc_ether_hw_addr __P((u_int8_t *));
d210 1
a210 1
void
d251 1
@


1.2
log
@Add IPSEC to GENERIC, move if_de srom emul to pci
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.1 1997/10/11 11:29:30 pefo Exp $ */
d59 1
d220 3
a222 6
/*XXX*/	p[20] = 0x00;	/* Next six, ethernet address. */
/*XXX*/	p[21] = 0xa0;	/* XXX Should be read from OFW */
/*XXX*/	p[22] = 0xf7;
/*XXX*/	p[23] = 0x04;
/*XXX*/	p[24] = 0x00;
/*XXX*/	p[25] = 0x4b;
@


1.1
log
@PCI bus code for monolithic PowerPC kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.4 1997/04/19 17:20:02 pefo Exp $ */
d76 1
a76 1
int      mpc_ether_hw_addr __P((u_int8_t *));
d90 18
d209 1
a209 1
int
d213 40
a252 1
	return(0);
@
