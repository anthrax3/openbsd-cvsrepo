head	1.17;
access;
symbols
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	UBC_SYNC_A:1.17
	UBC_SYNC_B:1.17
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.2.0.2
	SMP_BASE:1.2
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.17
date	2001.09.01.15.55.17;	author drahn;	state dead;
branches;
next	1.16;

1.16
date	2001.07.09.02.56.09;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.04.08.38.52;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.26.19.06.17;	author maja;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.26.18.19.43;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.25.23.09.55;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.25.19.15.44;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.17.03.34.01;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.20.04.18.07;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.08.17.11.27;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.31.03.47.36;	author rahnds;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.28.13.06.15;	author rahnds;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.31.06.08.26;	author rahnds;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.31.05.43.54;	author rahnds;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.20.07.10.50;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	2000.01.14.05.42.16;	author rahnds;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.11.08.23.48.59;	author rahnds;	state Exp;
branches;
next	;

1.2.2.1
date	2000.03.24.09.08.42;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2001.05.14.21.36.51;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2001.07.04.10.22.41;	author niklas;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2001.10.31.03.07.55;	author nate;	state dead;
branches;
next	1.2.2.5;

1.2.2.5
date	2001.11.13.21.04.16;	author niklas;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2001.11.13.22.14.34;	author niklas;	state dead;
branches;
next	;


desc
@@


1.17
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/pci to macppc/pci

The file pci_machdep.h was not moved in this conversion.
It needs to be check if it is correct that should be the only shared
powerpc/pci file. Or if that file too should be MD, or more files MI.
@
text
@/*	$OpenBSD: macobio.c,v 1.16 2001/07/09 02:56:09 mickey Exp $	*/
/*	$NetBSD: obio.c,v 1.6 1999/05/01 10:36:08 tsubai Exp $	*/

/*-
 * Copyright (C) 1998	Internet Research Institute, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by
 *	Internet Research Institute, Inc.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/ofw/openfirm.h>

#include <machine/bus.h>
#include <machine/autoconf.h>

void macobio_attach __P((struct device *, struct device *, void *));
int macobio_match __P((struct device *, void *, void *));
int macobio_print __P((void *, const char *));
void *undef_mac_establish __P((void * lcv, int irq, int type, int level,
    int (*ih_fun) __P((void *)), void *ih_arg, char *name));
void mac_intr_disestab __P((void *lcp, void *arg));

struct macobio_softc {
	struct device sc_dev;
	int sc_node;
	struct ppc_bus_space sc_membus_space;
};
struct cfdriver macobio_cd = {
	NULL, "macobio", DV_DULL,
};


struct cfattach macobio_ca = {
	sizeof(struct macobio_softc), macobio_match, macobio_attach
};

int
macobio_match(parent, cf, aux)
	struct device *parent;
	void *cf;
	void *aux;
{
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_APPLE)
		switch (PCI_PRODUCT(pa->pa_id)) {

		case PCI_PRODUCT_APPLE_GC:
		case PCI_PRODUCT_APPLE_OHARE:
		case PCI_PRODUCT_APPLE_HEATHROW:
		case PCI_PRODUCT_APPLE_PADDINGTON:
		case PCI_PRODUCT_APPLE_KEYLARGO:
		case PCI_PRODUCT_APPLE_PANGEA_MACIO:
			return 1;
		}

	return 0;
}

#define HEATHROW_FCR_OFFSET 0x38
u_int32_t *heathrow_FCR = NULL;

/*
 * Attach all the sub-devices we can find
 */
void
macobio_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct macobio_softc *sc = (struct macobio_softc *)self;
	struct pci_attach_args *pa = aux;
	struct confargs ca;
	int node, child, namelen;
	u_int32_t reg[20];
	int32_t intr[8];
	char name[32];
	int need_interrupt_controller = 0;

	switch (PCI_PRODUCT(pa->pa_id)) {

	/* XXX should not use name */
	case PCI_PRODUCT_APPLE_GC:
		node = OF_finddevice("/bandit/gc");
		need_interrupt_controller = 1;
		break;

	case PCI_PRODUCT_APPLE_OHARE:
		node = OF_finddevice("/bandit/ohare");
		need_interrupt_controller = 1;
		break;

	case PCI_PRODUCT_APPLE_HEATHROW:
	case PCI_PRODUCT_APPLE_PADDINGTON:
		node = OF_finddevice("mac-io");
		if (node == -1)
			node = OF_finddevice("/pci/mac-io");
		if (OF_getprop(node, "assigned-addresses", reg, sizeof(reg))
			== (sizeof (reg[0]) * 5))
		{
			/* always ??? */
			heathrow_FCR = mapiodev(reg[2] + HEATHROW_FCR_OFFSET,
				4);
		}
		break;
	case PCI_PRODUCT_APPLE_KEYLARGO:
	case PCI_PRODUCT_APPLE_PANGEA_MACIO:
		node = OF_finddevice("mac-io");
		if (node == -1)
			node = OF_finddevice("/pci/mac-io");

		break;
	default:
		printf(": unknown macobio controller\n");
		return;
	}
	sc->sc_node = node;

	if (OF_getprop(node, "assigned-addresses", reg, sizeof(reg)) < 12)
		return;

	ca.ca_baseaddr = reg[2];

	sc->sc_membus_space.bus_base = ca.ca_baseaddr;

	sc->sc_membus_space.bus_reverse = 1;

	ca.ca_iot = &sc->sc_membus_space;

	printf("\n");

	/*
	 * This might be a hack, but it makes the interrupt controller
	 * attach as expected if a device node existed in the OF tree.
	 */
	if (need_interrupt_controller) {
		/* force attachment of legacy interrupt controllers */
		ca.ca_name = "legacy-interrupt-controller";
		ca.ca_node = 0;

		ca.ca_nreg  = 0;
		ca.ca_nintr = 0;

		ca.ca_reg = 0;
		ca.ca_intr = 0;

		config_found(self, &ca, macobio_print);
	}

	for (child = OF_child(node); child; child = OF_peer(child)) {
		namelen = OF_getprop(child, "name", name, sizeof(name));
		if (namelen < 0)
			continue;
		if (namelen >= sizeof(name))
			continue;

		name[namelen] = 0;
		ca.ca_name = name;
		ca.ca_node = child;

		ca.ca_nreg  = OF_getprop(child, "reg", reg, sizeof(reg));
		ca.ca_nintr = OF_getprop(child, "AAPL,interrupts", intr,
				sizeof(intr));
		if (ca.ca_nintr == -1)
			ca.ca_nintr = OF_getprop(child, "interrupts", intr,
					sizeof(intr));

		ca.ca_reg = reg;
		ca.ca_intr = intr;

		config_found(self, &ca, macobio_print);
	}
}

int
macobio_print(aux, macobio)
	void *aux;
	const char *macobio;
{
#ifdef MACOBIOVERBOSE
	struct confargs *ca = aux;

	if (macobio)
		printf("%s at %s", ca->ca_name, macobio);

	if (ca->ca_nreg > 0)
		printf(" offset 0x%x", ca->ca_reg[0]);

	return UNCONF;
#else
	return QUIET;
#endif
}

void *
undef_mac_establish(lcv, irq, type, level, ih_fun, ih_arg, name)
	void * lcv;
	int irq;
	int type;
	int level;
	int (*ih_fun) __P((void *));
	void *ih_arg;
	char *name;
{
	printf("mac_intr_establish called, not yet inited\n");
	return 0;
}

void
mac_intr_disestab(lcp, arg)
	void *lcp;
	void *arg;
{
	printf("mac_intr_disestablish called, not yet inited\n");
}

intr_establish_t *mac_intr_establish_func = undef_mac_establish;
intr_disestablish_t *mac_intr_disestablish_func = mac_intr_disestab;

void *
mac_intr_establish(lcv, irq, type, level, ih_fun, ih_arg, name)
	void * lcv;
	int irq;
	int type;
	int level;
	int (*ih_fun) __P((void *));
	void *ih_arg;
	char *name;
{
	return (*mac_intr_establish_func)(lcv, irq, type, level, ih_fun,
		ih_arg, name);
}
void
mac_intr_disestablish(lcp, arg)
	void *lcp;
	void *arg;
{
	(*mac_intr_disestablish_func)(lcp, arg);
}
@


1.16
log
@protos and spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: macobio.c,v 1.15 2001/07/04 08:38:52 niklas Exp $	*/
@


1.15
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: obio.c,v 1.6 1999/05/01 10:36:08 tsubai Exp $	*/
d49 6
a54 3
static void macobio_attach __P((struct device *, struct device *, void *));
static int macobio_match __P((struct device *, void *, void *));
static int macobio_print __P((void *, const char *));
d166 1
a166 1
	 * This might be a hack, but it makes the interrupt controller 
d241 1
@


1.14
log
@Add support for the new iBook. from netbsd. ok @@drahn. -moj
@
text
@d1 1
@


1.13
log
@Cleanup of interrupt configuration, move prototypes to header file,
not in each file.
@
text
@d77 6
a82 5
		case 0x02:	/* gc */
		case 0x07:	/* ohare */
		case 0x10:	/* mac-io "Heathrow" */
		case 0x17:	/* mac-io "Paddington" */
		case 0x22:	/* mac-io "Keylargo" */
d112 1
a112 1
	case 0x02:
d117 1
a117 1
	case 0x07:
d122 2
a123 2
	case 0x10:	/* heathrow */
	case 0x17:	/* paddington */
d135 2
a136 1
	case 0x22:	/* keylargo */
@


1.12
log
@add MACOBIOVERBOSE as per discussion w/ dale
@
text
@a221 7
typedef int mac_intr_handle_t;

typedef void     *(intr_establish_t) __P((void *, mac_intr_handle_t,
            int, int, int (*func)(void *), void *, char *));
typedef void     (intr_disestablish_t) __P((void *, void *));


@


1.11
log
@obio -> macobio, and cleanups
@
text
@d207 1
a209 2
#if 0
/* no reason to clutter the screen with unneccessary printfs */
d217 2
a219 1
	return QUIET;
@


1.10
log
@Allow for more than 5 interrupt attribute values. awacs has 6.
@
text
@d48 3
a50 3
static void obio_attach __P((struct device *, struct device *, void *));
static int obio_match __P((struct device *, void *, void *));
static int obio_print __P((void *, const char *));
d52 1
a52 1
struct obio_softc {
d57 1
a57 1
struct cfdriver obio_cd = {
d62 2
a63 2
struct cfattach obio_ca = {
	sizeof(struct obio_softc), obio_match, obio_attach
d67 1
a67 1
obio_match(parent, cf, aux)
d95 1
a95 1
obio_attach(parent, self, aux)
d99 1
a99 1
	struct obio_softc *sc = (struct obio_softc *)self;
d141 1
a141 1
		printf(": unknown obio controller\n");
d174 1
a174 1
		config_found(self, &ca, obio_print);
d198 1
a198 1
		config_found(self, &ca, obio_print);
d203 1
a203 1
obio_print(aux, obio)
d205 1
a205 1
	const char *obio;
d211 2
a212 2
	if (obio)
		printf("%s at %s", ca->ca_name, obio);
@


1.9
log
@Make drivers more quiet, no point in printing useless information.
@
text
@d104 1
a104 1
	int32_t intr[5];
@


1.8
log
@pretty print
@
text
@d157 1
a157 1
	printf(": addr 0x%x\n", ca.ca_baseaddr);
@


1.7
log
@Correction for legacy interrupt controller attachment.
The previous change would incorrectly allow the macintr interrupt
controller to configure for the openpic interrupt controller.
@
text
@a107 2
	printf("obio ver %x", (PCI_PRODUCT(pa->pa_id)));

d141 1
a141 1
		printf("obio_attach: unknown obio controller\n");
@


1.6
log
@Config changes to be closer to supporting older bandit based systems.
Openfirmware does not have entries for the interrupt controller.
@
text
@d167 1
a167 1
		ca.ca_name = "interrupt-controller";
@


1.5
log
@Quiet down boot on openfirmware probe of macobio bus. Does not print
devices that are not recognize by drivers, it does not seem right
to imply that fd, scsi and adb devices exist on an imac, (ok, they
really do but apple did not bring the pins out where they were useable.)
@
text
@d106 1
d115 1
d120 1
d160 18
@


1.4
log
@Remove unnecessary debug printf.
@
text
@d107 1
a107 1
	printf("obio ver %x\n", (PCI_PRODUCT(pa->pa_id)));
d190 2
d199 2
@


1.3
log
@Changes to support uninorth bridge (probably a bit of a hack for now).
cleaned up the previous support for the macobio that was there previously.

Now registers real interupt handler devices instead of the pseudo configed
ones before.

The G4 systems are not yet working, the onboard ide configures properly
and interrupts seem to work, but the system hangs before mounting
the root drive (even ramdisks). Maybe someone will point out something
bogus in the code, so it is being checked in.
@
text
@a130 1
			printf("heathrow fcr, %x\n", heathrow_FCR);
@


1.2
log
@

UVM changes mainly. As of this checkin UVM is still not working for powerpc
it has a copyin bug after device configuration. However to get these diffs
out of my tree.

All of the UVM code is currently inside ifdef UVM the kernel works fine
without option UVM. Config files have been left without UVM for now.

Prelimiary changes for busdma, (what UVM was wanted for).
@
text
@d81 1
a90 9
void prog_switch (void *arg)
{
#ifdef DDB
	Debugger();
#else
	printf("programmer button pressed, debugger not available\n");
#endif
}

d134 4
d139 1
d148 1
a151 16
	{
		extern u_int32_t *interrupt_reg;
		/* OK THIS IS AN UGLY HACK */
		void mac_do_pending_int();
		void mac_ext_intr();
		typedef void  (void_f) (void);
		extern void_f *pending_int_f;

		interrupt_reg = (void*)ca.ca_baseaddr;

		install_extint(mac_ext_intr);
		pending_int_f = mac_do_pending_int;

		mac_intr_establish(0x14, IST_LEVEL, IPL_HIGH,
			prog_switch, 0x14);
	}
d198 52
@


1.2.2.1
log
@Sync with -current
@
text
@a80 1
		case 0x22:	/* mac-io "Keylargo" */
d90 9
a141 4
	case 0x22:	/* keylargo */
		node = OF_finddevice("mac-io");
		if (node == -1)
			node = OF_finddevice("/pci/mac-io");
a142 1
		break;
a150 1

d154 16
a215 52
}

typedef int mac_intr_handle_t;

typedef void     *(intr_establish_t) __P((void *, mac_intr_handle_t,
            int, int, int (*func)(void *), void *, char *));
typedef void     (intr_disestablish_t) __P((void *, void *));


void *
undef_mac_establish(lcv, irq, type, level, ih_fun, ih_arg, name)
	void * lcv;
	int irq;
	int type;
	int level;
	int (*ih_fun) __P((void *));
	void *ih_arg;
	char *name;
{
	printf("mac_intr_establish called, not yet inited\n");
	return 0;
}
void
mac_intr_disestab(lcp, arg)
	void *lcp;
	void *arg;
{
	printf("mac_intr_disestablish called, not yet inited\n");
}

intr_establish_t *mac_intr_establish_func = undef_mac_establish;
intr_disestablish_t *mac_intr_disestablish_func = mac_intr_disestab;

void *
mac_intr_establish(lcv, irq, type, level, ih_fun, ih_arg, name)
	void * lcv;
	int irq;
	int type;
	int level;
	int (*ih_fun) __P((void *));
	void *ih_arg;
	char *name;
{
	return (*mac_intr_establish_func)(lcv, irq, type, level, ih_fun,
		ih_arg, name);
}
void
mac_intr_disestablish(lcp, arg)
	void *lcp;
	void *arg;
{
	(*mac_intr_disestablish_func)(lcp, arg);
@


1.2.2.2
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d106 2
a107 1
	int need_interrupt_controller = 0;
a113 1
		need_interrupt_controller = 1;
a117 1
		need_interrupt_controller = 1;
d131 1
d141 1
a141 1
		printf(": unknown obio controller\n");
d157 1
a157 19
	printf("\n");

	/*
	 * This might be a hack, but it makes the interrupt controller 
	 * attach as expected if a device node existed in the OF tree.
	 */
	if (need_interrupt_controller) {
		/* force attachment of legacy interrupt controllers */
		ca.ca_name = "legacy-interrupt-controller";
		ca.ca_node = 0;

		ca.ca_nreg  = 0;
		ca.ca_nintr = 0;

		ca.ca_reg = 0;
		ca.ca_intr = 0;

		config_found(self, &ca, obio_print);
	}
a190 2
#if 0
/* no reason to clutter the screen with unneccessary printfs */
a197 2
#endif
	return QUIET;
@


1.2.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d48 3
a50 3
static void macobio_attach __P((struct device *, struct device *, void *));
static int macobio_match __P((struct device *, void *, void *));
static int macobio_print __P((void *, const char *));
d52 1
a52 1
struct macobio_softc {
d57 1
a57 1
struct cfdriver macobio_cd = {
d62 2
a63 2
struct cfattach macobio_ca = {
	sizeof(struct macobio_softc), macobio_match, macobio_attach
d67 1
a67 1
macobio_match(parent, cf, aux)
d77 5
a81 6
		case PCI_PRODUCT_APPLE_GC:
		case PCI_PRODUCT_APPLE_OHARE:
		case PCI_PRODUCT_APPLE_HEATHROW:
		case PCI_PRODUCT_APPLE_PADDINGTON:
		case PCI_PRODUCT_APPLE_KEYLARGO:
		case PCI_PRODUCT_APPLE_PANGEA_MACIO:
d95 1
a95 1
macobio_attach(parent, self, aux)
d99 1
a99 1
	struct macobio_softc *sc = (struct macobio_softc *)self;
d104 1
a104 1
	int32_t intr[8];
d111 1
a111 1
	case PCI_PRODUCT_APPLE_GC:
d116 1
a116 1
	case PCI_PRODUCT_APPLE_OHARE:
d121 2
a122 2
	case PCI_PRODUCT_APPLE_HEATHROW:
	case PCI_PRODUCT_APPLE_PADDINGTON:
d134 1
a134 2
	case PCI_PRODUCT_APPLE_KEYLARGO:
	case PCI_PRODUCT_APPLE_PANGEA_MACIO:
d141 1
a141 1
		printf(": unknown macobio controller\n");
d174 1
a174 1
		config_found(self, &ca, macobio_print);
d198 1
a198 1
		config_found(self, &ca, macobio_print);
d203 1
a203 1
macobio_print(aux, macobio)
d205 1
a205 1
	const char *macobio;
a206 1
#ifdef MACOBIOVERBOSE
d209 4
a212 2
	if (macobio)
		printf("%s at %s", ca->ca_name, macobio);
d218 1
a218 1
#else
a219 1
#endif
d221 7
@


1.2.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@@


1.2.2.5
log
@Merge in -current
@
text
@@


1.2.2.6
log
@repair
@
text
@@


1.1
log
@Changes for imac support. support for VI computers and MCG Powerstack
will need to be merged back in. Both are currently untested.
mac interrupt support is currently a big hack and needs to be redesigned
as part of the system, several of the mac drivers need busified also.
@
text
@d92 1
d94 3
@

