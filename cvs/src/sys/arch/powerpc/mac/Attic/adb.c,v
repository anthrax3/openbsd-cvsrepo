head	1.6;
access;
symbols
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	UBC_SYNC_A:1.6
	UBC_SYNC_B:1.6
	SMP:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2001.09.01.15.49.59;	author drahn;	state dead;
branches;
next	1.5;

1.5
date	2001.07.04.08.38.49;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.29.06.55.35;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.29.01.20.44;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.29.19.19.56;	author drahn;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.09.06.02.07.17;	author rahnds;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.14.21.36.45;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.07.04.10.22.31;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2001.10.31.03.07.55;	author nate;	state dead;
branches;
next	;


desc
@@


1.6
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/mac to macppc/dev
@
text
@/*	$OpenBSD: adb.c,v 1.5 2001/07/04 08:38:49 niklas Exp $	*/
/*	$NetBSD: adb.c,v 1.6 1999/08/16 06:28:09 tsubai Exp $	*/

/*-
 * Copyright (C) 1994	Bradley A. Grantham
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bradley A. Grantham.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/fcntl.h>
#include <sys/poll.h>
#include <sys/select.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/systm.h>

#include <machine/autoconf.h>

#include <powerpc/mac/adbvar.h>
#include <powerpc/mac/akbdvar.h>
#include <powerpc/mac/viareg.h>

#include "aed.h"

/*
 * Function declarations.
 */
static int	adbmatch __P((struct device *, void *, void *));
static void	adbattach __P((struct device *, struct device *, void *));
static int	adbprint __P((void *, const char *));

/*
 * Global variables.
 */
int     adb_polling = 0;	/* Are we polling?  (Debugger mode) */
int     adb_initted = 0;	/* adb_init() has completed successfully */
#ifdef ADB_DEBUG
int	adb_debug = 0;		/* Output debugging messages */
#endif /* ADB_DEBUG */

/*
 * Driver definition.
 */
struct cfattach adb_ca = {
	sizeof(struct adb_softc), adbmatch, adbattach
};
struct cfdriver adb_cd = {
	NULL, "adb", DV_DULL
};

extern int adbHardware;

static int
adbmatch(parent, cf, aux)
	struct device *parent;
	void *cf;
	void *aux;
{
	struct confargs *ca = aux;

	if (ca->ca_nreg < 8)
		return 0;

	if (ca->ca_nintr < 4)
		return 0;

	if (strcmp(ca->ca_name, "via-cuda") == 0)
		return 1;

	if (strcmp(ca->ca_name, "via-pmu") == 0)
		return 1;

	return 0;
}

/* HACK ALERT */
int adb_read_date_time(unsigned long *time);
int adb_write_date_time(unsigned long time);
int adb_set_date_time(unsigned long time);
typedef int (clock_read_t)(int *sec, int *min, int *hour, int *day,
         int *mon, int *yr);
typedef int (time_read_t)(unsigned long *sec);
typedef int (time_write_t)(unsigned long sec);
extern time_read_t  *time_read;
extern time_write_t  *time_write;
extern clock_read_t  *clock_read;



static void
adbattach(parent, self, aux)
	struct device *parent, *self;
	void   *aux;
{
	struct adb_softc *sc = (struct adb_softc *)self;
	struct confargs *ca = aux;

	ADBDataBlock adbdata;
	struct adb_attach_args aa_args;
	int totaladbs;
	int adbindex, adbaddr;

	extern volatile u_char *Via1Base;

	ca->ca_reg[0] += ca->ca_baseaddr;

	sc->sc_regbase = mapiodev(ca->ca_reg[0], ca->ca_reg[1]);
	Via1Base = sc->sc_regbase;

	if (strcmp(ca->ca_name, "via-cuda") == 0)
		adbHardware = ADB_HW_CUDA;
	else if (strcmp(ca->ca_name, "via-pmu") == 0)
		adbHardware = ADB_HW_PB;

	adb_polling = 1;
	ADBReInit();

	mac_intr_establish(parent, ca->ca_intr[0], IST_LEVEL, IPL_HIGH,
		adb_intr, sc, "adb");

	/* init powerpc globals which control RTC functionality */
	clock_read = NULL;
	time_read = adb_read_date_time;
	time_write = adb_set_date_time;

#ifdef ADB_DEBUG
	if (adb_debug)
		printf("adb: done with ADBReInit\n");
#endif
	totaladbs = CountADBs();

	printf(" irq %d", ca->ca_intr[0]);
	printf(": %d targets\n", totaladbs);

#if NAED > 0
	/* ADB event device for compatibility */
	aa_args.origaddr = 0;
	aa_args.adbaddr = 0;
	aa_args.handler_id = 0;
	(void)config_found(self, &aa_args, adbprint);
#endif

	/* for each ADB device */
	for (adbindex = 1; adbindex <= totaladbs; adbindex++) {
		/* Get the ADB information */
		adbaddr = GetIndADB(&adbdata, adbindex);

		aa_args.origaddr = adbdata.origADBAddr;
		aa_args.adbaddr = adbaddr;
		aa_args.handler_id = adbdata.devType;

		(void)config_found(self, &aa_args, adbprint);
	}

	if (adbHardware == ADB_HW_CUDA)
		adb_cuda_autopoll();
	adb_polling = 0;
}

int
adbprint(args, name)
	void *args;
	const char *name;
{
	struct adb_attach_args *aa_args = (struct adb_attach_args *)args;
	int rv = UNCONF;

	if (name) {	/* no configured device matched */
		rv = UNSUPP; /* most ADB device types are unsupported */

		/* print out what kind of ADB device we have found */
		printf("%s addr %d: ", name, aa_args->adbaddr);
		switch(aa_args->origaddr) {
#ifdef DIAGNOSTIC
		case 0:
			printf("ADB event device");
			rv = UNCONF;
			break;
		case ADBADDR_SECURE:
			printf("security dongle (%d)", aa_args->handler_id);
			break;
#endif
		case ADBADDR_MAP:
			printf("mapped device (%d)", aa_args->handler_id);
			rv = UNCONF;
			break;
		case ADBADDR_REL:
			printf("relative positioning device (%d)",
			    aa_args->handler_id);
			rv = UNCONF;
			break;
#ifdef DIAGNOSTIC
		case ADBADDR_ABS:
			switch (aa_args->handler_id) {
			case ADB_ARTPAD:
				printf("WACOM ArtPad II");
				break;
			default:
				printf("absolute positioning device (%d)",
				    aa_args->handler_id);
				break;
			}
			break;
		case ADBADDR_DATATX:
			printf("data transfer device (modem?) (%d)",
			    aa_args->handler_id);
			break;
		case ADBADDR_MISC:
			switch (aa_args->handler_id) {
			case ADB_POWERKEY:
				printf("Sophisticated Circuits PowerKey");
				break;
			default:
				printf("misc. device (remote control?) (%d)",
				    aa_args->handler_id);
				break;
			}
			break;
		default:
			printf("unknown type device, (handler %d)",
			    aa_args->handler_id);
			break;
#endif /* DIAGNOSTIC */
		}
	} else		/* a device matched and was configured */
                printf(" addr %d: ", aa_args->adbaddr);

	return rv;
}
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.6 1999/08/16 06:28:09 tsubai Exp $	*/
@


1.4
log
@Include/header cleanup. More.
@
text
@d1 1
@


1.3
log
@Hardware clock support, via adb.
This reduces the dependancy on openfirmware somewhat.
Since Openfirmware is not actually used for anything,
it is no longer necessary to configure it. so several lines of
useless dmesg are now gone.

This does not have clock setting code enabled yet.
All of the code is in place, but needs further testing before
it is trusted.

I wish Apple would store UTC not localtime in the hardware clock,
besides the fact that the clock base is 1904.

Need to keep the clock sane for dual boot machines.
@
text
@a127 1
	extern adb_intr();
@


1.2
log
@Code cleanup, some update from Nbsd.
@
text
@d101 14
d146 5
@


1.2.4.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@@


1.2.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@a100 14
/* HACK ALERT */
int adb_read_date_time(unsigned long *time);
int adb_write_date_time(unsigned long time);
int adb_set_date_time(unsigned long time);
typedef int (clock_read_t)(int *sec, int *min, int *hour, int *day,
         int *mon, int *yr);
typedef int (time_read_t)(unsigned long *sec);
typedef int (time_write_t)(unsigned long sec);
extern time_read_t  *time_read;
extern time_write_t  *time_write;
extern clock_read_t  *clock_read;



d114 1
a131 5

	/* init powerpc globals which control RTC functionality */
	clock_read = NULL;
	time_read = adb_read_date_time;
	time_write = adb_set_date_time;
@


1.2.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@@


1.1
log
@Add adb support, no devices attached to adb supported yet, but it
is used to power-off and reboot newer machines (that claim to not have adb).
@
text
@d130 1
a130 1
	mac_intr_establish(NULL, ca->ca_intr[0], IST_LEVEL, IPL_HIGH,
d169 2
a170 2
        void *args;
        const char *name;
d179 1
a179 1
		printf("%s addr %d: ", name, aa_args->origaddr);
d233 1
a233 1
                printf(" addr %d: ", aa_args->origaddr);
d235 1
a235 11
	return (rv);
}

void
extdms_complete(buffer, compdata, cmd)
	caddr_t buffer, compdata;
	int cmd;
{
	long *p = (long *)compdata;

	*p= -1;
@

