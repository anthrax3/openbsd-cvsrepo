head	1.10;
access;
symbols
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	UBC_SYNC_A:1.10
	UBC_SYNC_B:1.10
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.2.0.2
	SMP_BASE:1.2
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.10
date	2001.09.01.15.50.00;	author drahn;	state dead;
branches;
next	1.9;

1.9
date	2001.07.10.02.16.11;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.09.03.30.20;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.25.23.29.55;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.20.19.39.33;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.31.05.33.36;	author rahnds;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.25.04.36.56;	author rahnds;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.20.07.26.49;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.03.05.49.46;	author rahnds;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.11.08.23.46.01;	author rahnds;	state Exp;
branches;
next	;

1.2.2.1
date	2000.03.24.09.08.40;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2001.05.14.21.36.48;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2001.07.04.10.22.35;	author niklas;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2001.10.31.03.07.55;	author nate;	state dead;
branches;
next	;


desc
@@


1.10
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/mac to macppc/dev
@
text
@/*	$OpenBSD: if_bm.c,v 1.9 2001/07/10 02:16:11 fgsch Exp $	*/
/*	$NetBSD: if_bm.c,v 1.1 1999/01/01 01:27:52 tsubai Exp $	*/

/*-
 * Copyright (C) 1998, 1999 Tsubai Masanari.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifdef __NetBSD__
#include "opt_inet.h"
#include "opt_ns.h"
#endif /* __NetBSD__ */
#include "bpfilter.h"

#include <sys/param.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/systm.h>

#include <net/if.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#include <net/bpfdesc.h>
#endif

#include <vm/vm.h>

#include <dev/ofw/openfirm.h>

#include <machine/autoconf.h>
#include <machine/pio.h>

#include <powerpc/mac/dbdma.h>
#include <powerpc/mac/if_bmreg.h>

#define BMAC_TXBUFS 2
#define BMAC_RXBUFS 16
#define BMAC_BUFLEN 2048

struct bmac_softc {
	struct device sc_dev;
#ifdef __OpenBSD__
	struct arpcom arpcom;	/* per-instance network data */
#define sc_if arpcom.ac_if
#define	sc_enaddr arpcom.ac_enaddr
#else
	struct ethercom sc_ethercom;
#define sc_if sc_ethercom.ec_if
	u_char sc_enaddr[6];
#endif
	struct ifmedia sc_media;
	vaddr_t sc_regs;
	dbdma_regmap_t *sc_txdma;
	dbdma_regmap_t *sc_rxdma;
	dbdma_command_t *sc_txcmd;
	dbdma_command_t *sc_rxcmd;
	caddr_t sc_txbuf;
	caddr_t sc_rxbuf;
	int sc_rxlast;
	int sc_flags;
	int sc_debug;
	int txcnt_outstanding;
};

#define BMAC_BMACPLUS	0x01

extern u_int *heathrow_FCR;

static __inline int bmac_read_reg __P((struct bmac_softc *, int));
static __inline void bmac_write_reg __P((struct bmac_softc *, int, int));
static __inline void bmac_set_bits __P((struct bmac_softc *, int, int));
static __inline void bmac_reset_bits __P((struct bmac_softc *, int, int));

static int bmac_match __P((struct device *, void *, void *));
static void bmac_attach __P((struct device *, struct device *, void *));
static void bmac_reset_chip __P((struct bmac_softc *));
static void bmac_init __P((struct bmac_softc *));
static void bmac_init_dma __P((struct bmac_softc *));
static int bmac_intr __P((void *));
#ifdef WHY_IS_THIS_XXXX
static int bmac_tx_intr __P((void *));
#endif /* WHY_IS_THIS_XXXX */
static int bmac_rint __P((void *));
static void bmac_reset __P((struct bmac_softc *));
static void bmac_stop __P((struct bmac_softc *));
static void bmac_start __P((struct ifnet *));
static void bmac_transmit_packet __P((struct bmac_softc *, void *, int));
static int bmac_put __P((struct bmac_softc *, caddr_t, struct mbuf *));
static struct mbuf *bmac_get __P((struct bmac_softc *, caddr_t, int));
static void bmac_watchdog __P((struct ifnet *));
static int bmac_ioctl __P((struct ifnet *, u_long, caddr_t));
static int bmac_mediachange __P((struct ifnet *));
static void bmac_mediastatus __P((struct ifnet *, struct ifmediareq *));
static void bmac_setladrf __P((struct bmac_softc *));
void bmac_init_mif __P((struct bmac_softc *sc));
u_int bmac_mif_readbits __P((struct bmac_softc *sc, int nb));
void bmac_mif_writebits __P((struct bmac_softc *sc, u_int val, int nb));
u_int bmac_mif_read __P((struct bmac_softc *sc, u_int addr));
void bmac_mif_write __P((struct bmac_softc *sc, u_int addr, u_int val));

struct cfattach bm_ca = {
	sizeof(struct bmac_softc), bmac_match, bmac_attach
};

struct cfdriver bm_cd = {
	NULL, "bm", DV_IFNET
};

int
bmac_read_reg(sc, off)
	struct bmac_softc *sc;
	int off;
{
	return in16rb(sc->sc_regs + off);
}

void
bmac_write_reg(sc, off, val)
	struct bmac_softc *sc;
	int off, val;
{
	out16rb(sc->sc_regs + off, val);
}

void
bmac_set_bits(sc, off, val)
	struct bmac_softc *sc;
	int off, val;
{
	val |= bmac_read_reg(sc, off);
	bmac_write_reg(sc, off, val);
}

void
bmac_reset_bits(sc, off, val)
	struct bmac_softc *sc;
	int off, val;
{
	bmac_write_reg(sc, off, bmac_read_reg(sc, off) & ~val);
}

int
bmac_match(parent, cf, aux)
	struct device *parent;
	void *cf;
	void *aux;
{
	struct confargs *ca = aux;

	if (ca->ca_nreg < 24 || ca->ca_nintr < 12)
		return 0;

	if (strcmp(ca->ca_name, "bmac") == 0)		/* bmac */
		return 1;
	if (strcmp(ca->ca_name, "ethernet") == 0)	/* bmac+ */
		return 1;

	return 0;
}

void
bmac_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct confargs *ca = aux;
	struct bmac_softc *sc = (void *)self;
	struct ifnet *ifp = &sc->sc_if;
	u_char laddr[6];

	sc->sc_flags =0;
	if (strcmp(ca->ca_name, "ethernet") == 0) {
		sc->sc_flags |= BMAC_BMACPLUS;
	}

	ca->ca_reg[0] += ca->ca_baseaddr;
	ca->ca_reg[2] += ca->ca_baseaddr;
	ca->ca_reg[4] += ca->ca_baseaddr;

	sc->sc_regs = (vaddr_t)mapiodev(ca->ca_reg[0], NBPG);

	bmac_write_reg(sc, INTDISABLE, NoEventsMask);

	if (OF_getprop(ca->ca_node, "local-mac-address", laddr, 6) == -1 &&
	    OF_getprop(ca->ca_node, "mac-address", laddr, 6) == -1) {
		printf(": cannot get mac-address\n");
		return;
	}
	bcopy(laddr, sc->arpcom.ac_enaddr, 6);

	sc->sc_txdma = mapiodev(ca->ca_reg[2], 0x100);
	sc->sc_rxdma = mapiodev(ca->ca_reg[4], 0x100);
	sc->sc_txcmd = dbdma_alloc(BMAC_TXBUFS * sizeof(dbdma_command_t));
	sc->sc_rxcmd = dbdma_alloc((BMAC_RXBUFS + 1) * sizeof(dbdma_command_t));
	sc->sc_txbuf = malloc(BMAC_BUFLEN * BMAC_TXBUFS, M_DEVBUF, M_NOWAIT);
	sc->sc_rxbuf = malloc(BMAC_BUFLEN * BMAC_RXBUFS, M_DEVBUF, M_NOWAIT);
	if (sc->sc_txbuf == NULL || sc->sc_rxbuf == NULL ||
	    sc->sc_txcmd == NULL || sc->sc_rxcmd == NULL) {
		printf("cannot allocate memory\n");
		return;
	}

	printf(" irq %d,%d: address %s\n", ca->ca_intr[0], ca->ca_intr[2],
		ether_sprintf(laddr));

	mac_intr_establish(parent, ca->ca_intr[0], IST_LEVEL, IPL_NET,
		bmac_intr, sc, "bmac intr");
#ifdef WHY_IS_THIS_XXXX
	mac_intr_establish(parent, ca->ca_intr[1], IST_LEVEL, IPL_NET,
		bmac_tx_intr, sc, "bmac_tx");
#endif /* WHY_IS_THIS_XXXX */
	mac_intr_establish(parent, ca->ca_intr[2], IST_LEVEL, IPL_NET,
		bmac_rint, sc, "bmac rint");

	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_ioctl = bmac_ioctl;
	ifp->if_start = bmac_start;
	ifp->if_flags =
		IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
	ifp->if_watchdog = bmac_watchdog;

	ifmedia_init(&sc->sc_media, 0, bmac_mediachange, bmac_mediastatus);
	ifmedia_add(&sc->sc_media, IFM_ETHER|IFM_10_T, 0, NULL);
	ifmedia_set(&sc->sc_media, IFM_ETHER|IFM_10_T);

	bmac_reset_chip(sc);

	if_attach(ifp);
	ether_ifattach(ifp);
}

/*
 * Reset and enable bmac by heathrow FCR.
 */
void
bmac_reset_chip(sc)
	struct bmac_softc *sc;
{
	u_int v;

	dbdma_reset(sc->sc_txdma);
	dbdma_reset(sc->sc_rxdma);

	v = in32rb(heathrow_FCR);

	v |= EnetEnable;
	out32rb(heathrow_FCR, v);
	delay(50000);

	/* assert reset */
	v |= ResetEnetCell;
	out32rb(heathrow_FCR, v);
	delay(70000);

	/* deassert reset */
	v &= ~ResetEnetCell;
	out32rb(heathrow_FCR, v);
	delay(50000);

	/* enable */
	v |= EnetEnable;
	out32rb(heathrow_FCR, v);
	delay(50000);

	/* make certain they stay set? */
	out32rb(heathrow_FCR, v);
	v = in32rb(heathrow_FCR);
}

void
bmac_init(sc)
	struct bmac_softc *sc;
{
	struct ifnet *ifp = &sc->sc_if;
	struct ether_header *eh;
	caddr_t data;
	int tb;
	u_short *p;

	bmac_init_mif(sc);
	bmac_reset_chip(sc);

	bmac_write_reg(sc, RXRST, RxResetValue);
	bmac_write_reg(sc, TXRST, TxResetBit);

	/* Wait for reset completion. */
	do {
		delay(10000); 
	} while (bmac_read_reg(sc, TXRST) & TxResetBit);

	if (! (sc->sc_flags & BMAC_BMACPLUS)) {
		bmac_set_bits(sc, XCVRIF, ClkBit|SerialMode|COLActiveLow);
		delay(100);
	}

	__asm __volatile ("mftb %0" : "=r"(tb));
	bmac_write_reg(sc, RSEED, tb);
	bmac_set_bits(sc, XIFC, TxOutputEnable);
	bmac_read_reg(sc, PAREG);

	/* Reset various counters. */
	bmac_write_reg(sc, NCCNT, 0);
	bmac_write_reg(sc, NTCNT, 0);
	bmac_write_reg(sc, EXCNT, 0);
	bmac_write_reg(sc, LTCNT, 0);
	bmac_write_reg(sc, FRCNT, 0);
	bmac_write_reg(sc, LECNT, 0);
	bmac_write_reg(sc, AECNT, 0);
	bmac_write_reg(sc, FECNT, 0);
	bmac_write_reg(sc, RXCV, 0);

	/* Set tx fifo information. */
	bmac_write_reg(sc, TXTH, 4);	/* 4 octets before tx starts */

	bmac_write_reg(sc, TXFIFOCSR, 0);
	bmac_write_reg(sc, TXFIFOCSR, TxFIFOEnable);

	/* Set rx fifo information. */
	bmac_write_reg(sc, RXFIFOCSR, 0);
	bmac_write_reg(sc, RXFIFOCSR, RxFIFOEnable);

	/* Clear status register. */
	bmac_read_reg(sc, STATUS);

	bmac_write_reg(sc, HASH3, 0);
	bmac_write_reg(sc, HASH2, 0);
	bmac_write_reg(sc, HASH1, 0);
	bmac_write_reg(sc, HASH0, 0);

	/* Set MAC address. */
	p = (u_short *)sc->sc_enaddr;
	bmac_write_reg(sc, MADD0, *p++);
	bmac_write_reg(sc, MADD1, *p++);
	bmac_write_reg(sc, MADD2, *p);

	bmac_write_reg(sc, RXCFG,
		RxCRCEnable | RxHashFilterEnable | RxRejectOwnPackets);

	if (ifp->if_flags & IFF_PROMISC)
		bmac_set_bits(sc, RXCFG, RxPromiscEnable);

	bmac_init_dma(sc);

	/* Enable TX/RX */
	bmac_set_bits(sc, RXCFG, RxMACEnable);
	bmac_set_bits(sc, TXCFG, TxMACEnable);

	bmac_write_reg(sc, INTDISABLE, NormalIntEvents);

	ifp->if_flags |= IFF_RUNNING;
	ifp->if_flags &= ~IFF_OACTIVE;
	ifp->if_timer = 0;

	data = sc->sc_txbuf;
	eh = (struct ether_header *)data;

	bzero(data, sizeof(eh) + ETHERMIN);
	bcopy(sc->sc_enaddr, eh->ether_dhost, ETHER_ADDR_LEN);
	bcopy(sc->sc_enaddr, eh->ether_shost, ETHER_ADDR_LEN);
	bmac_transmit_packet(sc, data, sizeof(eh) + ETHERMIN);

	bmac_start(ifp);
}

void
bmac_init_dma(sc)
	struct bmac_softc *sc;
{
	dbdma_command_t *cmd = sc->sc_rxcmd;
	int i;

	dbdma_reset(sc->sc_txdma);
	dbdma_reset(sc->sc_rxdma);

	bzero(sc->sc_txcmd, BMAC_TXBUFS * sizeof(dbdma_command_t));
	bzero(sc->sc_rxcmd, (BMAC_RXBUFS + 1) * sizeof(dbdma_command_t));

	for (i = 0; i < BMAC_RXBUFS; i++) {
		DBDMA_BUILD(cmd, DBDMA_CMD_IN_LAST, 0, BMAC_BUFLEN,
			vtophys((vaddr_t)(sc->sc_rxbuf + BMAC_BUFLEN * i)),
			DBDMA_INT_ALWAYS, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
		cmd++;
	}
	DBDMA_BUILD(cmd, DBDMA_CMD_NOP, 0, 0, 0,
		DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_ALWAYS);
	dbdma_st32(&cmd->d_cmddep, vtophys((vaddr_t)sc->sc_rxcmd));

	sc->sc_rxlast = 0;

	dbdma_start(sc->sc_rxdma, sc->sc_rxcmd);
}

#ifdef WHY_IS_THIS_XXXX
int
bmac_tx_intr(v)
	void *v;
{
	struct bmac_softc *sc = v;

	sc->sc_if.if_flags &= ~IFF_OACTIVE;
	sc->sc_if.if_timer = 0;
	sc->sc_if.if_opackets++;
	bmac_start(&sc->sc_if);

#ifndef BMAC_DEBUG
	printf("bmac_tx_intr \n");
#endif
	#if 0
	stat = bmac_read_reg(sc, STATUS);
	if (stat == 0) {
		printf("tx intr fired, but status 0\n");
		return 0;
	}


	if (stat & IntFrameSent) {
		sc->sc_if.if_flags &= ~IFF_OACTIVE;
		sc->sc_if.if_timer = 0;
		sc->sc_if.if_opackets++;
		bmac_start(&sc->sc_if);
	}
	#endif
	return 1;
}
#endif /* WHY_IS_THIS_XXXX */
int
bmac_intr(v)
	void *v;
{
	struct bmac_softc *sc = v;
	int stat;

#ifdef BMAC_DEBUG
	printf("bmac_intr called\n");
#endif
	stat = bmac_read_reg(sc, STATUS);
	if (stat == 0)
		return 0;

#ifdef BMAC_DEBUG
	printf("bmac_intr status = 0x%x\n", stat);
#endif

	if (stat & IntFrameSent) {
		sc->sc_if.if_flags &= ~IFF_OACTIVE;
		sc->sc_if.if_timer = 0;
		sc->sc_if.if_opackets++;
		bmac_start(&sc->sc_if);
	}

	/* XXX should do more! */

	return 1;
}

int
bmac_rint(v)
	void *v;
{
	struct bmac_softc *sc = v;
	struct ifnet *ifp = &sc->sc_if;
	struct mbuf *m;
	dbdma_command_t *cmd;
	int status, resid, count, datalen;
	int i, n;
	void *data;
#ifdef BMAC_DEBUG
	printf("bmac_rint() called\n");
#endif

	i = sc->sc_rxlast;
	for (n = 0; n < BMAC_RXBUFS; n++, i++) {
		if (i == BMAC_RXBUFS)
			i = 0;
		cmd = &sc->sc_rxcmd[i];
		status = dbdma_ld16(&cmd->d_status);
		resid = dbdma_ld16(&cmd->d_resid);

#ifdef BMAC_DEBUG
		if (status != 0 && status != 0x8440 && status != 0x9440)
			printf("bmac_rint status = 0x%x\n", status);
#endif

		if ((status & DBDMA_CNTRL_ACTIVE) == 0)	/* 0x9440 | 0x8440 */
			continue;
		count = dbdma_ld16(&cmd->d_count);
		datalen = count - resid;
		if (datalen < sizeof(struct ether_header)) {
			printf("%s: short packet len = %d\n",
				ifp->if_xname, datalen);
			goto next;
		}
		DBDMA_BUILD_CMD(cmd, DBDMA_CMD_STOP, 0, 0, 0, 0);
		data = sc->sc_rxbuf + BMAC_BUFLEN * i;
		m = bmac_get(sc, data, datalen);

		if (m == NULL) {
			ifp->if_ierrors++;
			goto next;
		}

#if NBPFILTER > 0
		/*
		 * Check if there's a BPF listener on this interface.
		 * If so, hand off the raw packet to BPF.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m);
#endif
#ifdef __OpenBSD__
		ether_input_mbuf(ifp, m);
#else
		m_adj(m, sizeof(struct ether_header));
		ether_input(ifp, data, m);
#endif
		ifp->if_ipackets++;

next:
		DBDMA_BUILD_CMD(cmd, DBDMA_CMD_IN_LAST, 0, DBDMA_INT_ALWAYS,
			DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);

		cmd->d_status = 0;
		cmd->d_resid = 0;
		sc->sc_rxlast = i + 1;
	}
	dbdma_continue(sc->sc_rxdma);

	return 1;
}

void
bmac_reset(sc)
	struct bmac_softc *sc;
{
	int s;

	s = splnet();
	bmac_init(sc);
	splx(s);
}

void
bmac_stop(sc)
	struct bmac_softc *sc;
{
	struct ifnet *ifp = &sc->sc_if;
	int s;

	s = splnet();

	/* Disable TX/RX. */
	bmac_reset_bits(sc, TXCFG, TxMACEnable);
	bmac_reset_bits(sc, RXCFG, RxMACEnable);

	/* Disable all interrupts. */
	bmac_write_reg(sc, INTDISABLE, NoEventsMask);

	dbdma_stop(sc->sc_txdma);
	dbdma_stop(sc->sc_rxdma);

	ifp->if_flags &= ~(IFF_UP | IFF_RUNNING);
	ifp->if_timer = 0;

	splx(s);
}

void
bmac_start(ifp)
	struct ifnet *ifp;
{
	struct bmac_softc *sc = ifp->if_softc;
	struct mbuf *m;
	int tlen;

	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
		return;

	while (1) {
		if (ifp->if_flags & IFF_OACTIVE)
			return;

		IF_DEQUEUE(&ifp->if_snd, m);
		if (m == 0)
			break;
#if NBPFILTER > 0
		/*
		 * If BPF is listening on this interface, let it see the
		 * packet before we commit it to the wire.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m);
#endif

		ifp->if_flags |= IFF_OACTIVE;
		tlen = bmac_put(sc, sc->sc_txbuf, m);

		/* 5 seconds to watch for failing to transmit */
		ifp->if_timer = 5;
		ifp->if_opackets++;		/* # of pkts */

		bmac_transmit_packet(sc, sc->sc_txbuf, tlen);
	}
}

void
bmac_transmit_packet(sc, buff, len)
	struct bmac_softc *sc;
	void *buff;
	int len;
{
	dbdma_command_t *cmd = sc->sc_txcmd;
	vaddr_t va = (vaddr_t)buff;

#ifdef BMAC_DEBUG
	if (vtophys(va) + len - 1 != vtophys(va + len - 1))
		panic("bmac_transmit_packet");
#endif

	DBDMA_BUILD(cmd, DBDMA_CMD_OUT_LAST, 0, len, vtophys(va),
		DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
	cmd++;
	DBDMA_BUILD(cmd, DBDMA_CMD_STOP, 0, 0, 0,
		DBDMA_INT_ALWAYS, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);

	dbdma_start(sc->sc_txdma, sc->sc_txcmd);
}

int
bmac_put(sc, buff, m)
	struct bmac_softc *sc;
	caddr_t buff;
	struct mbuf *m;
{
	struct mbuf *n;
	int len, tlen = 0;

	for (; m; m = n) {
		len = m->m_len;
		if (len == 0) {
			MFREE(m, n);
			continue;
		}
		bcopy(mtod(m, caddr_t), buff, len);
		buff += len;
		tlen += len;
		MFREE(m, n);
	}
	if (tlen > NBPG)
		panic("%s: putpacket packet overflow", sc->sc_dev.dv_xname);

	return tlen;
}

struct mbuf *
bmac_get(sc, pkt, totlen)
	struct bmac_softc *sc;
	caddr_t pkt;
	int totlen;
{
	struct mbuf *m;
	struct mbuf *top, **mp;
	int len;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == 0)
		return 0;
	m->m_pkthdr.rcvif = &sc->sc_if;
	m->m_pkthdr.len = totlen;
	len = MHLEN;
	top = 0;
	mp = &top;

	while (totlen > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == 0) {
				m_freem(top);
				return 0;
			}
			len = MLEN;
		}
		if (totlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if ((m->m_flags & M_EXT) == 0) {
				m_free(m);
				m_freem(top);
				return 0;
			}
			len = MCLBYTES;
		}
		m->m_len = len = min(totlen, len);
		bcopy(pkt, mtod(m, caddr_t), len);
		pkt += len;
		totlen -= len;
		*mp = m;
		mp = &m->m_next;
	}

	return top;
}

void
bmac_watchdog(ifp)
	struct ifnet *ifp;
{
	struct bmac_softc *sc = ifp->if_softc;

	bmac_reset_bits(sc, RXCFG, RxMACEnable);
	bmac_reset_bits(sc, TXCFG, TxMACEnable);

	printf("%s: device timeout\n", ifp->if_xname);
	ifp->if_oerrors++;

	bmac_reset(sc);
}

int
bmac_ioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct bmac_softc *sc = ifp->if_softc;
	struct ifaddr *ifa = (struct ifaddr *)data;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {

	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;

		switch (ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			bmac_init(sc);
#ifdef __OpenBSD__
			arp_ifinit(&sc->arpcom, ifa);
#else
			arp_ifinit(ifp, ifa);
#endif
			break;
#endif
#ifdef NS
		case AF_NS:
		    {
			struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host =
				    *(union ns_host *)LLADDR(ifp->if_sadl);
			else {
				bcopy(ina->x_host.c_host,
				    LLADDR(ifp->if_sadl),
				    sizeof(sc->sc_enaddr));
			}
			/* Set new address. */
			bmac_init(sc);
			break;
		    }
#endif
		default:
			bmac_init(sc);
			break;
		}
		break;

	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running, then
			 * stop it.
			 */
			bmac_stop(sc);
			ifp->if_flags &= ~IFF_RUNNING;
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
		    (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped, then
			 * start it.
			 */
			bmac_init(sc);
		} else {
			/*
			 * Reset the interface to pick up changes in any other
			 * flags that affect hardware registers.
			 */
			/*bmac_stop(sc);*/
			bmac_init(sc);
		}
#ifdef BMAC_DEBUG
		if (ifp->if_flags & IFF_DEBUG)
			sc->sc_debug = 1;
		else
			sc->sc_debug = 0;
#endif
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
#if defined(__OpenBSD__)
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);
#else
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_ethercom) :
		    ether_delmulti(ifr, &sc->sc_ethercom);
#endif

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			bmac_init(sc);
			bmac_setladrf(sc);
			error = 0;
		}
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);
		break;

	default:
		error = EINVAL;
	}

	splx(s);
	return error;
}

int
bmac_mediachange(ifp)
	struct ifnet *ifp;
{
	return EINVAL;
}

void
bmac_mediastatus(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
{
	if ((ifp->if_flags & IFF_UP) == 0)
		return;

	ifmr->ifm_status = IFM_AVALID;
	ifmr->ifm_status |= IFM_ACTIVE;
}

#define MC_POLY_BE 0x04c11db7UL		/* mcast crc, big endian */
#define MC_POLY_LE 0xedb88320UL		/* mcast crc, little endian */

/*
 * Set up the logical address filter.
 */
void
bmac_setladrf(sc)
	struct bmac_softc *sc;
{
	struct ifnet *ifp = &sc->sc_if;
	struct ether_multi *enm;
	struct ether_multistep step;
	int i, j;
	u_int32_t crc;
	u_int16_t hash[4];
	u_int8_t octet;

	/*
	 * Set up multicast address filter by passing all multicast addresses
	 * through a crc generator, and then using the high order 6 bits as an
	 * index into the 64 bit logical address filter.  The high order bit
	 * selects the word, while the rest of the bits select the bit within
	 * the word.
	 */

	if (ifp->if_flags & IFF_ALLMULTI)
		goto allmulti;

	if (ifp->if_flags & IFF_PROMISC) {
		bmac_set_bits(sc, RXCFG, RxPromiscEnable);
		goto allmulti;
	}

	hash[3] = hash[2] = hash[1] = hash[0] = 0;
#ifdef __OpenBSD__
	ETHER_FIRST_MULTI(step, &sc->arpcom, enm);
#else
	ETHER_FIRST_MULTI(step, &sc->sc_ethercom, enm);
#endif
	while (enm != NULL) {
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			/*
			 * We must listen to a range of multicast addresses.
			 * For now, just accept all multicasts, rather than
			 * trying to set only those filter bits needed to match
			 * the range.  (At this time, the only use of address
			 * ranges is for IP multicast routing, for which the
			 * range is big enough to require all bits set.)
			 */
			goto allmulti;
		}

		crc = 0xffffffff;
		for (i = 0; i < ETHER_ADDR_LEN; i++) {
			octet = enm->enm_addrlo[i];

			for (j = 0; j < 8; j++) {
				if ((crc & 1) ^ (octet & 1)) {
					crc >>= 1;
					crc ^= MC_POLY_LE;
				}
				else
					crc >>= 1;
				octet >>= 1;
			}
		}

		/* Just want the 6 most significant bits. */
		crc >>= 26;

		/* Set the corresponding bit in the filter. */
		hash[crc >> 4] |= 1 << (crc & 0xf);

		ETHER_NEXT_MULTI(step, enm);
	}
	bmac_write_reg(sc, HASH3, hash[3]);
	bmac_write_reg(sc, HASH2, hash[2]);
	bmac_write_reg(sc, HASH1, hash[1]);
	bmac_write_reg(sc, HASH0, hash[0]);
	ifp->if_flags &= ~IFF_ALLMULTI;
	return;

allmulti:
	ifp->if_flags |= IFF_ALLMULTI;
	bmac_write_reg(sc, HASH3, 0xffff);
	bmac_write_reg(sc, HASH2, 0xffff);
	bmac_write_reg(sc, HASH1, 0xffff);
	bmac_write_reg(sc, HASH0, 0xffff);
}

#define MIFDELAY	delay(1)

u_int
bmac_mif_readbits(sc, nb)
	struct bmac_softc *sc;
	int nb;
{
	unsigned int val = 0;

	while (--nb >= 0) {
		bmac_write_reg(sc, MIFCSR, 0);
		MIFDELAY;
		if (bmac_read_reg(sc, MIFCSR) & 8)
			val |= 1 << nb;
		bmac_write_reg(sc, MIFCSR, 1);
		MIFDELAY;
	}
	bmac_write_reg(sc, MIFCSR, 0);
	MIFDELAY;
	bmac_write_reg(sc, MIFCSR, 1);
	MIFDELAY;
	return val;
}

void
bmac_mif_writebits(sc, val, nb)
	struct bmac_softc *sc;
	u_int val;
	int nb;
{
	int b;

	while (--nb >= 0) {
		b = (val & (1 << nb))? 6: 4;
		bmac_write_reg(sc, MIFCSR, b);
		MIFDELAY;
		bmac_write_reg(sc, MIFCSR, b|1);
		MIFDELAY;
	}
}

u_int
bmac_mif_read(sc, addr)
	struct bmac_softc *sc;
	u_int addr;
{
	u_int val;

	bmac_write_reg(sc, MIFCSR, 4);
	MIFDELAY;
	bmac_mif_writebits(sc, ~0U, 32);
	bmac_mif_writebits(sc, 6, 4);
	bmac_mif_writebits(sc, addr, 10);
	bmac_write_reg(sc, MIFCSR, 2);
	MIFDELAY;
	bmac_write_reg(sc, MIFCSR, 1);
	MIFDELAY;
	val = bmac_mif_readbits(sc, 17);
	bmac_write_reg(sc, MIFCSR, 4);
	MIFDELAY;
	/* printk(KERN_DEBUG "bmac_mif_read(%x) -> %x\n", addr, val); */
	return val;
}

void
bmac_mif_write(sc, addr, val)
	struct bmac_softc *sc;
	u_int addr;
	u_int val;
{
	bmac_write_reg(sc, MIFCSR, 4);
	MIFDELAY;
	bmac_mif_writebits(sc, ~0U, 32);
	bmac_mif_writebits(sc, 5, 4);
	bmac_mif_writebits(sc, addr, 10);
	bmac_mif_writebits(sc, 2, 2);
	bmac_mif_writebits(sc, val, 16);
	bmac_mif_writebits(sc, 3, 2);
}

void
bmac_init_mif(sc)
	struct bmac_softc *sc;
{
	int id;
	if (sc->sc_flags & BMAC_BMACPLUS) {
		id = bmac_mif_read(sc,2);
		switch (id) {
		case 0x7810:
			if (bmac_mif_read(sc,4) == 0xa1) {
				bmac_mif_write(sc, 0, 0x1000);
			} else {
				bmac_mif_write(sc, 4, 0xa1);
				bmac_mif_write(sc, 0, 0x1200);
			}
#if 0
			/* DEBUGGING */
			printf("mif 0 %x\n", bmac_mif_read(sc, 0));
			printf("mif 4 %x\n", bmac_mif_read(sc, 4));
#endif
			break;
		default:
			printf("bmac mif id %x not regcognized\n", id);
			/* nothing */
		}
	}
	return;
}
@


1.9
log
@ether_input_mbuf() conversion; thanks to drahn@@ for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.8 2001/07/09 03:30:20 mickey Exp $	*/
@


1.8
log
@a wagon and a small cart of protos, spaces, and includes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.7 2001/06/25 23:29:55 drahn Exp $	*/
d539 1
a539 6
#if 0
		ether_input(ifp, mtod(m, struct ether_header *), m);
#else
		m_adj(m, sizeof(struct ether_header));
		ether_input(ifp, data, m);
#endif
@


1.7
log
@closer to building with -Wno-uninitialized
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.6 2001/02/20 19:39:33 mickey Exp $	*/
d123 4
d408 1
a408 1
			vtophys(sc->sc_rxbuf + BMAC_BUFLEN * i),
d414 1
a414 1
	dbdma_st32(&cmd->d_cmddep, vtophys(sc->sc_rxcmd));
d983 1
a983 1
unsigned int
d1008 1
a1008 1
	unsigned int val;
d1022 1
a1022 1
unsigned int
d1025 1
a1025 1
	unsigned int addr;
d1027 1
a1027 1
	unsigned int val;
d1048 2
a1049 2
	unsigned int addr;
	unsigned int val;
@


1.6
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.5 2000/03/31 05:33:36 rahnds Exp $	*/
d107 1
d109 1
a192 1
	int i;
d231 1
a231 1
	/*
d234 1
a234 1
	*/
d301 1
a301 1
	int i, tb;
d417 1
a422 1
	u_int16_t stat;
d449 1
a755 1
	int temp;
@


1.5
log
@Revision 1.3 checked in again, version 1.4 was incorrectly checked in
when if_gm.c was supposed to be checked in. It was a non-functional working
version that has not yet been finished, it needs the bitbang mii code
from NetBSD, or the proper routines imbedded in the driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.3 2000/03/20 07:26:49 rahnds Exp $	*/
a252 4

#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
#endif
@


1.4
log
@Busified.
OpenBSD tag added.
mii code corrected (seems to work, anyone want to verify this?) only tesed at
10baseT
interrupt configuration hacked, pa_line contents not reliable, hacked for
now.
@
text
@d2 1
a2 1
/*	$NetBSD: if_bm.c,v 1.6 2000/02/02 17:09:43 thorpej Exp $	*/
d5 1
a5 1
 * Copyright (C) 1998, 1999, 2000 Tsubai Masanari.  All rights reserved.
a38 1
#include <sys/kernel.h>
a42 2
#include <vm/vm.h>

d50 1
d53 1
a53 6
#ifdef INET
#include <netinet/in.h>
#ifdef __NetBSD__
#include <netinet/if_inarp.h>
#endif /* __NetBSD__ */
#endif
a56 6
#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#ifdef __NetBSD__
#include <dev/mii/mii_bitbang.h>
#endif /* __NetBSD__ */

d78 1
d88 1
a88 1
	struct mii_data sc_mii;
a92 1
#define BMAC_DEBUGFLAG	0x02
d101 20
a120 28
int bmac_match __P((struct device *, void *, void *));
void bmac_attach __P((struct device *, struct device *, void *));
void bmac_reset_chip __P((struct bmac_softc *));
void bmac_init __P((struct bmac_softc *));
void bmac_init_dma __P((struct bmac_softc *));
int bmac_intr __P((void *));
int bmac_tx_intr __P((void *));
int bmac_rint __P((void *));
void bmac_reset __P((struct bmac_softc *));
void bmac_stop __P((struct bmac_softc *));
void bmac_start __P((struct ifnet *));
void bmac_transmit_packet __P((struct bmac_softc *, void *, int));
int bmac_put __P((struct bmac_softc *, caddr_t, struct mbuf *));
struct mbuf *bmac_get __P((struct bmac_softc *, caddr_t, int));
void bmac_watchdog __P((struct ifnet *));
int bmac_ioctl __P((struct ifnet *, u_long, caddr_t));
int bmac_mediachange __P((struct ifnet *));
void bmac_mediastatus __P((struct ifnet *, struct ifmediareq *));
void bmac_setladrf __P((struct bmac_softc *));

#ifdef __NetBSD__
int bmac_mii_readreg __P((struct device *, int, int));
void bmac_mii_writereg __P((struct device *, int, int, int));
void bmac_mii_statchg __P((struct device *));
void bmac_mii_tick __P((void *));
u_int32_t bmac_mbo_read __P((struct device *));
void bmac_mbo_write __P((struct device *, u_int32_t));
#endif /* __NetBSD__ */
a125 7
#ifdef __NetBSD__
struct mii_bitbang_ops bmac_mbo = {
	bmac_mbo_read, bmac_mbo_write,
	{ MIFDO, MIFDI, MIFDC, MIFDIR, 0 }
};
#endif /* __NetBSD__ */

d174 1
a174 1
	if (strcmp(ca->ca_name, "bmac") == 0) {		/* bmac */
d176 1
a176 2
	}
	if (strcmp(ca->ca_name, "ethernet") == 0) {	/* bmac+ */
a177 1
	}
a189 1
	struct mii_data *mii = &sc->sc_mii;
d191 1
a194 5
		char name[64];

		bzero(name, 64);
		OF_package_to_path(ca->ca_node, name, sizeof(name));
		OF_open(name);
d245 3
a247 21
#ifdef __NetBSD__
	mii->mii_ifp = ifp;
	mii->mii_readreg = bmac_mii_readreg;
	mii->mii_writereg = bmac_mii_writereg;
	mii->mii_statchg = bmac_mii_statchg;
#endif /* __NetBSD__ */

#ifdef __NetBSD__
	ifmedia_init(&mii->mii_media, 0, bmac_mediachange, bmac_mediastatus);
#endif /* __NetBSD__ */
#ifdef __NetBSD__
	mii_attach(&sc->sc_dev, mii, 0xffffffff, MII_PHY_ANY,
		      MII_OFFSET_ANY, 0);
#endif /* __NetBSD__ */

	/* Choose a default media. */
	if (LIST_FIRST(&mii->mii_phys) == NULL) {
		ifmedia_add(&mii->mii_media, IFM_ETHER|IFM_10_T, 0, NULL);
		ifmedia_set(&mii->mii_media, IFM_ETHER|IFM_10_T);
	} else
		ifmedia_set(&mii->mii_media, IFM_ETHER|IFM_AUTO);
d304 1
a304 1
	int i, tb, bmcr;
d307 1
a309 7
#ifdef __NetBSD__
	/* XXX */
	bmcr = bmac_mii_readreg((struct device *)sc, 0, MII_BMCR);
	bmcr &= ~BMCR_ISO;
	bmac_mii_writereg((struct device *)sc, 0, MII_BMCR, bmcr);
#endif /* __NetBSD__ */

d314 3
a316 5
 	do {
 		delay(100); 
 	} while (bmac_read_reg(sc, TXRST) & TxResetBit);
	if (i <= 0)
		printf("%s: reset timeout\n", ifp->if_xname);
d319 2
a320 1
  		bmac_set_bits(sc, XCVRIF, ClkBit|SerialMode|COLActiveLow);
a389 5

#ifdef __NetBSD__
	untimeout(bmac_mii_tick, sc);
	timeout(bmac_mii_tick, sc, hz);
#endif /* __NetBSD__ */
d537 3
d542 1
d544 2
a545 1
		(*ifp->if_input)(ifp, m);
a581 5
#ifdef __NetBSD__
	untimeout(bmac_mii_tick, sc);
	mii_down(&sc->sc_mii);
#endif /* __NetBSD__ */

d758 1
d828 3
a830 1
			sc->sc_flags |= BMAC_DEBUGFLAG;
d859 1
a859 1
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, cmd);
a869 1
#ifdef __NetBSD__
d874 1
a874 3
	struct bmac_softc *sc = ifp->if_softc;

	return mii_mediachg(&sc->sc_mii);
a875 1
#endif /* __NetBSD__ */
a876 1
#ifdef __NetBSD__
d882 2
a883 3
	struct bmac_softc *sc = ifp->if_softc;

	mii_pollstat(&sc->sc_mii);
d885 2
a886 2
	ifmr->ifm_status = sc->sc_mii.mii_media_status;
	ifmr->ifm_active = sc->sc_mii.mii_media_active;
a887 1
#endif /* __NetBSD__ */
d980 6
a985 5
#ifdef __NetBSD__
int
bmac_mii_readreg(dev, phy, reg)
	struct device *dev;
	int phy, reg;
d987 15
a1001 1
	return mii_bitbang_readreg(dev, &bmac_mbo, phy, reg);
a1002 1
#endif /* __NetBSD__ */
a1003 1
#ifdef __NetBSD__
d1005 4
a1008 3
bmac_mii_writereg(dev, phy, reg, val)
	struct device *dev;
	int phy, reg, val;
d1010 9
a1018 1
	mii_bitbang_writereg(dev, &bmac_mbo, phy, reg, val);
a1019 1
#endif /* __NetBSD__ */
d1021 4
a1024 4
#ifdef __NetBSD__
u_int32_t
bmac_mbo_read(dev)
	struct device *dev;
d1026 1
a1026 1
	struct bmac_softc *sc = (void *)dev;
d1028 14
a1041 1
	return bmac_read_reg(sc, MIFCSR);
d1045 4
a1048 3
bmac_mbo_write(dev, val)
	struct device *dev;
	u_int32_t val;
d1050 8
a1057 3
	struct bmac_softc *sc = (void *)dev;

	bmac_write_reg(sc, MIFCSR, val);
d1061 2
a1062 2
bmac_mii_statchg(dev)
	struct device *dev;
d1064 15
a1078 14
	struct bmac_softc *sc = (void *)dev;
	int x;

	/* Update duplex mode in TX configuration */
	x = bmac_read_reg(sc, TXCFG);
	if ((IFM_OPTIONS(sc->sc_mii.mii_media_active) & IFM_FDX) != 0)
		x |= TxFullDuplex;
	else
		x &= ~TxFullDuplex;
	bmac_write_reg(sc, TXCFG, x);

#ifdef BMAC_DEBUG
	printf("bmac_mii_statchg 0x%x\n",
		IFM_OPTIONS(sc->sc_mii.mii_media_active));
d1080 7
a1087 17
#endif /* __NetBSD__ */

#ifdef __NetBSD__
void
bmac_mii_tick(v)
	void *v;
{
	struct bmac_softc *sc = v;
	int s;

	s = splnet();
	mii_tick(&sc->sc_mii);
	splx(s);

	timeout(bmac_mii_tick, sc, hz);
}
#endif /* __NetBSD__ */
@


1.3
log
@Interrupt code changed from called routines, to initialized driver.
Added openpic support with this new driver scheme.

added support for keylargo-ata, G4 ide configures properly.
interrupt configuration changed to be more full featured, like isa had been.
@
text
@d1 2
a2 2
/*	$OpenBSD: if_bm.c,v 1.2 2000/02/03 05:49:46 rahnds Exp $	*/
/*	$NetBSD: if_bm.c,v 1.1 1999/01/01 01:27:52 tsubai Exp $	*/
d5 1
a5 1
 * Copyright (C) 1998, 1999 Tsubai Masanari.  All rights reserved.
d39 1
d44 2
a52 1
#include <net/bpfdesc.h>
d55 6
a60 1
#include <vm/vm.h>
d64 6
a90 1
	struct ifmedia sc_media;
d100 1
a100 1
	int sc_debug;
d105 1
d114 28
a141 20
static int bmac_match __P((struct device *, void *, void *));
static void bmac_attach __P((struct device *, struct device *, void *));
static void bmac_reset_chip __P((struct bmac_softc *));
static void bmac_init __P((struct bmac_softc *));
static void bmac_init_dma __P((struct bmac_softc *));
static int bmac_intr __P((void *));
static int bmac_tx_intr __P((void *));
static int bmac_rint __P((void *));
static void bmac_reset __P((struct bmac_softc *));
static void bmac_stop __P((struct bmac_softc *));
static void bmac_start __P((struct ifnet *));
static void bmac_transmit_packet __P((struct bmac_softc *, void *, int));
static int bmac_put __P((struct bmac_softc *, caddr_t, struct mbuf *));
static struct mbuf *bmac_get __P((struct bmac_softc *, caddr_t, int));
static void bmac_watchdog __P((struct ifnet *));
static int bmac_ioctl __P((struct ifnet *, u_long, caddr_t));
static int bmac_mediachange __P((struct ifnet *));
static void bmac_mediastatus __P((struct ifnet *, struct ifmediareq *));
static void bmac_setladrf __P((struct bmac_softc *));
void bmac_init_mif __P((struct bmac_softc *sc));
d147 7
d202 1
a202 1
	if (strcmp(ca->ca_name, "bmac") == 0)		/* bmac */
d204 2
a205 1
	if (strcmp(ca->ca_name, "ethernet") == 0)	/* bmac+ */
d207 1
d220 1
a221 1
	int i;
d225 5
d280 21
a300 3
	ifmedia_init(&sc->sc_media, 0, bmac_mediachange, bmac_mediastatus);
	ifmedia_add(&sc->sc_media, IFM_ETHER|IFM_10_T, 0, NULL);
	ifmedia_set(&sc->sc_media, IFM_ETHER|IFM_10_T);
d357 1
a357 1
	int i, tb;
a359 1
	bmac_init_mif(sc);
d362 7
d373 5
a377 3
	do {
		delay(10000); 
	} while (bmac_read_reg(sc, TXRST) & TxResetBit);
d380 1
a380 2
		bmac_set_bits(sc, XCVRIF, ClkBit|SerialMode|COLActiveLow);
		delay(100);
d450 5
a601 3
#if 0
		ether_input(ifp, mtod(m, struct ether_header *), m);
#else
a603 1
#endif
d605 1
a605 2
		m_adj(m, sizeof(struct ether_header));
		ether_input(ifp, data, m);
d642 5
a822 1
	int temp;
d892 1
a892 3
			sc->sc_debug = 1;
		else
			sc->sc_debug = 0;
d921 1
a921 1
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);
d932 1
d937 3
a939 1
	return EINVAL;
d941 1
d943 1
d949 3
a951 2
	if ((ifp->if_flags & IFF_UP) == 0)
		return;
d953 2
a954 2
	ifmr->ifm_status = IFM_AVALID;
	ifmr->ifm_status |= IFM_ACTIVE;
d956 1
d1049 9
a1057 1
#define MIFDELAY	delay(1)
d1059 5
a1063 4
unsigned int
bmac_mif_readbits(sc, nb)
	struct bmac_softc *sc;
	int nb;
d1065 1
a1065 15
	unsigned int val = 0;

	while (--nb >= 0) {
		bmac_write_reg(sc, MIFCSR, 0);
		MIFDELAY;
		if (bmac_read_reg(sc, MIFCSR) & 8)
			val |= 1 << nb;
		bmac_write_reg(sc, MIFCSR, 1);
		MIFDELAY;
	}
	bmac_write_reg(sc, MIFCSR, 0);
	MIFDELAY;
	bmac_write_reg(sc, MIFCSR, 1);
	MIFDELAY;
	return val;
d1067 1
d1069 4
a1072 5
void
bmac_mif_writebits(sc, val, nb)
	struct bmac_softc *sc;
	unsigned int val;
	int nb;
d1074 1
a1074 1
	int b;
d1076 1
a1076 7
	while (--nb >= 0) {
		b = (val & (1 << nb))? 6: 4;
		bmac_write_reg(sc, MIFCSR, b);
		MIFDELAY;
		bmac_write_reg(sc, MIFCSR, b|1);
		MIFDELAY;
	}
d1079 4
a1082 4
unsigned int
bmac_mif_read(sc, addr)
	struct bmac_softc *sc;
	unsigned int addr;
d1084 1
a1084 1
	unsigned int val;
d1086 1
a1086 14
	bmac_write_reg(sc, MIFCSR, 4);
	MIFDELAY;
	bmac_mif_writebits(sc, ~0U, 32);
	bmac_mif_writebits(sc, 6, 4);
	bmac_mif_writebits(sc, addr, 10);
	bmac_write_reg(sc, MIFCSR, 2);
	MIFDELAY;
	bmac_write_reg(sc, MIFCSR, 1);
	MIFDELAY;
	val = bmac_mif_readbits(sc, 17);
	bmac_write_reg(sc, MIFCSR, 4);
	MIFDELAY;
	/* printk(KERN_DEBUG "bmac_mif_read(%x) -> %x\n", addr, val); */
	return val;
d1090 2
a1091 4
bmac_mif_write(sc, addr, val)
	struct bmac_softc *sc;
	unsigned int addr;
	unsigned int val;
d1093 15
a1107 8
	bmac_write_reg(sc, MIFCSR, 4);
	MIFDELAY;
	bmac_mif_writebits(sc, ~0U, 32);
	bmac_mif_writebits(sc, 5, 4);
	bmac_mif_writebits(sc, addr, 10);
	bmac_mif_writebits(sc, 2, 2);
	bmac_mif_writebits(sc, val, 16);
	bmac_mif_writebits(sc, 3, 2);
d1109 1
d1111 1
d1113 2
a1114 2
bmac_init_mif(sc)
	struct bmac_softc *sc;
d1116 8
a1123 23
	int id;
	if (sc->sc_flags & BMAC_BMACPLUS) {
		id = bmac_mif_read(sc,2);
		switch (id) {
		case 0x7810:
			if (bmac_mif_read(sc,4) == 0xa1) {
				bmac_mif_write(sc, 0, 0x1000);
			} else {
				bmac_mif_write(sc, 4, 0xa1);
				bmac_mif_write(sc, 0, 0x1200);
			}
#if 0
			/* DEBUGGING */
			printf("mif 0 %x\n", bmac_mif_read(sc, 0));
			printf("mif 4 %x\n", bmac_mif_read(sc, 4));
#endif
			break;
		default:
			printf("bmac mif id %x not regcognized\n", id);
			/* nothing */
		}
	}
	return;
d1125 1
@


1.2
log
@Remove overly verbose printf during driver config.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.1 1999/11/08 23:46:01 rahnds Exp $	*/
d228 2
a229 1
	mac_intr_establish(ca->ca_intr[0], IST_LEVEL, IPL_NET, bmac_intr, sc);
d231 2
a232 1
	mac_intr_establish(ca->ca_intr[1], IST_LEVEL, IPL_NET, bmac_tx_intr, sc);
d234 2
a235 1
	mac_intr_establish(ca->ca_intr[2], IST_LEVEL, IPL_NET, bmac_rint, sc);
@


1.2.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d228 1
a228 2
	mac_intr_establish(parent, ca->ca_intr[0], IST_LEVEL, IPL_NET,
		bmac_intr, sc, "bmac intr");
d230 1
a230 2
	mac_intr_establish(parent, ca->ca_intr[1], IST_LEVEL, IPL_NET,
		bmac_tx_intr, sc, "bmac_tx");
d232 1
a232 2
	mac_intr_establish(parent, ca->ca_intr[2], IST_LEVEL, IPL_NET,
		bmac_rint, sc, "bmac rint");
@


1.2.2.2
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.6 2001/02/20 19:39:33 mickey Exp $	*/
d253 4
@


1.2.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.2.2.2 2001/05/14 21:36:48 niklas Exp $	*/
a106 1
#ifdef WHY_IS_THIS_XXXX
a107 1
#endif /* WHY_IS_THIS_XXXX */
d191 1
d230 1
a230 1
#ifdef WHY_IS_THIS_XXXX
d233 1
a233 1
#endif /* WHY_IS_THIS_XXXX */
d300 1
a300 1
	int tb;
a415 1
#ifdef WHY_IS_THIS_XXXX
d421 1
a447 1
#endif /* WHY_IS_THIS_XXXX */
d754 1
@


1.2.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.2.2.3 2001/07/04 10:22:35 niklas Exp $	*/
@


1.1
log
@Initial import of NetBSD macppc code to allow OpenBSD/powerpc to run
on the imac computer, Additional hardware and driver support will follow.
Initially wdc_obio support the imac (333Mhz) atapi cdrom and the ATA harddrive.
also Bmac ethernet is supported at least at 10Mb.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a200 5
	printf("D: reg0 %x, reg2 %x reg4 %x\n",
		ca->ca_reg[0],
		ca->ca_reg[2],
		ca->ca_reg[4]);
		
@

