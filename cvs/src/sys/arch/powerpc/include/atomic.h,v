head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.2
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.10.0.10
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.6
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.4.0.10
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.8
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.6
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.4
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.3.0.16
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.14
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.10
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.12
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.8
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.6
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.4
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.2.0.2
	OPENBSD_4_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.11
date	2017.05.12.08.47.48;	author mpi;	state Exp;
branches;
next	1.10;
commitid	hxdCT2MHrLIZMfqY;

1.10
date	2015.05.06.03.30.03;	author dlg;	state Exp;
branches;
next	1.9;
commitid	DCPElreKesYsDqGW;

1.9
date	2015.04.24.15.26.22;	author mpi;	state Exp;
branches;
next	1.8;
commitid	GoElOXEOJmsYGgqh;

1.8
date	2015.04.22.06.39.03;	author mpi;	state Exp;
branches;
next	1.7;
commitid	BaDVSrGJDtIvziTU;

1.7
date	2014.06.19.11.29.21;	author kettenis;	state Exp;
branches;
next	1.6;
commitid	q9Zro9QUNiHIioST;

1.6
date	2014.03.29.18.09.30;	author guenther;	state Exp;
branches;
next	1.5;

1.5
date	2013.08.06.08.19.52;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2011.03.23.16.54.36;	author pirofti;	state Exp;
branches;
next	1.3;

1.3
date	2007.03.17.22.10.04;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2007.02.19.17.18.43;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2007.02.06.17.13.33;	author art;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Make atomic.h ready to be included in userland.

- keep setbits/clearbits inside _KERNEL

ok dlg@@, kettenis@@
@
text
@/*	$OpenBSD: atomic.h,v 1.10 2015/05/06 03:30:03 dlg Exp $	*/

/*
 * Copyright (c) 2015 Martin Pieuchot
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */


#ifndef _POWERPC_ATOMIC_H_
#define _POWERPC_ATOMIC_H_

#if defined(_KERNEL)

static __inline void
atomic_setbits_int(volatile unsigned int *uip, unsigned int v)
{
	unsigned int tmp;

	__asm volatile (
	    "1:	lwarx	%0, 0, %2	\n"
	    "	or	%0, %1, %0	\n"
	    "	stwcx.	%0, 0, %2	\n"
	    "	bne-	1b		\n"
	    "	sync" : "=&r" (tmp) : "r" (v), "r" (uip) : "cc", "memory");
}

static __inline void
atomic_clearbits_int(volatile unsigned int *uip, unsigned int v)
{
	unsigned int tmp;

	__asm volatile (
	    "1:	lwarx	%0, 0, %2	\n"
	    "	andc	%0, %0, %1	\n"
	    "	stwcx.	%0, 0, %2	\n"
	    "	bne-	1b		\n"
	    "	sync" : "=&r" (tmp) : "r" (v), "r" (uip) : "cc", "memory");
}

#endif /* defined(_KERNEL) */

static inline unsigned int
_atomic_cas_uint(volatile unsigned int *p, unsigned int o, unsigned int n)
{
	unsigned int rv;

	__asm volatile (
	    "1:	lwarx	%0, 0, %2	\n"
	    "	cmpw	0, %0, %4	\n"
	    "	bne-	2f		\n"
	    "	stwcx.	%3, 0, %2	\n" 
	    "	bne-	1b		\n"
	    "2:				\n"
	    : "=&r" (rv), "+m" (*p)
	    : "r" (p), "r" (n), "r" (o)
	    : "cc");

	return (rv);
}
#define atomic_cas_uint(_p, _o, _n) _atomic_cas_uint((_p), (_o), (_n))

static inline unsigned long
_atomic_cas_ulong(volatile unsigned long *p, unsigned long o, unsigned long n)
{
	unsigned long rv;

	__asm volatile (
	    "1:	lwarx	%0, 0, %2	\n"
	    "	cmpw	0, %0, %4	\n"
	    "	bne-	2f		\n"
	    "	stwcx.	%3, 0, %2	\n" 
	    "	bne-	1b		\n"
	    "2:				\n"
	    : "=&r" (rv), "+m" (*p)
	    : "r" (p), "r" (n), "r" (o)
	    : "cc");

	return (rv);
}
#define atomic_cas_ulong(_p, _o, _n) _atomic_cas_ulong((_p), (_o), (_n))

static inline void *
_atomic_cas_ptr(volatile void *pp, void *o, void *n)
{
	void * volatile *p = pp;
	void *rv;

	__asm volatile (
	    "1:	lwarx	%0, 0, %2	\n"
	    "	cmpw	0, %0, %4	\n"
	    "	bne-	2f		\n"
	    "	stwcx.	%3, 0, %2	\n" 
	    "	bne-	1b		\n"
	    "2:				\n"
	    : "=&r" (rv), "+m" (*p)
	    : "r" (p), "r" (n), "r" (o)
	    : "cc");

	return (rv);
}
#define atomic_cas_ptr(_p, _o, _n) _atomic_cas_ptr((_p), (_o), (_n))

static inline unsigned int
_atomic_swap_uint(volatile unsigned int *p, unsigned int v)
{
	unsigned int rv;

	__asm volatile (
	    "1:	lwarx	%0, 0, %2	\n"
	    "	stwcx.	%3, 0, %2	\n"
	    "	bne-	1b		\n"
	    : "=&r" (rv), "+m" (*p)
	    : "r" (p), "r" (v)
	    : "cc");

	return (rv);
}
#define atomic_swap_uint(_p, _v) _atomic_swap_uint((_p), (_v))

static inline unsigned long
_atomic_swap_ulong(volatile unsigned long *p, unsigned long v)
{
	unsigned long rv;

	__asm volatile (
	    "1:	lwarx	%0, 0, %2	\n"
	    "	stwcx.	%3, 0, %2	\n"
	    "	bne-	1b		\n"
	    : "=&r" (rv), "+m" (*p)
	    : "r" (p), "r" (v)
	    : "cc");

	return (rv);
}
#define atomic_swap_ulong(_p, _v) _atomic_swap_ulong((_p), (_v))

static inline void *
_atomic_swap_ptr(volatile void *pp, void *v)
{
	void * volatile *p = pp;
	void *rv;

	__asm volatile (
	    "1:	lwarx	%0, 0, %2	\n"
	    "	stwcx.	%3, 0, %2	\n"
	    "	bne-	1b		\n"
	    : "=&r" (rv), "+m" (*p)
	    : "r" (p), "r" (v)
	    : "cc");

	return (rv);
}
#define atomic_swap_ptr(_p, _v) _atomic_swap_ptr((_p), (_v))

static inline unsigned int
_atomic_add_int_nv(volatile unsigned int *p, unsigned int v)
{
	unsigned int rv;

	__asm volatile (
	    "1:	lwarx	%0, 0, %2	\n"
	    "	add	%0, %3,	%0	\n"
	    "	stwcx.	%0, 0, %2	\n"
	    "	bne-	1b		\n"
	    : "=&r" (rv), "+m" (*p)
	    : "r" (p), "r" (v)
	    : "cc", "xer");

	return (rv);
}
#define atomic_add_int_nv(_p, _v) _atomic_add_int_nv((_p), (_v))

static inline unsigned long
_atomic_add_long_nv(volatile unsigned long *p, unsigned long v)
{
	unsigned long rv;

	__asm volatile (
	    "1:	lwarx	%0, 0, %2	\n"
	    "	add	%0, %3,	%0	\n"
	    "	stwcx.	%0, 0, %2	\n"
	    "	bne-	1b		\n"
	    : "=&r" (rv), "+m" (*p)
	    : "r" (p), "r" (v)
	    : "cc", "xer");

	return (rv);
}
#define atomic_add_long_nv(_p, _v) _atomic_add_long_nv((_p), (_v))

static inline unsigned int
_atomic_sub_int_nv(volatile unsigned int *p, unsigned int v)
{
	unsigned int rv;

	__asm volatile (
	    "1:	lwarx	%0, 0, %2	\n"
	    "	subf	%0, %3,	%0	\n"
	    "	stwcx.	%0, 0, %2	\n"
	    "	bne-	1b		\n"
	    : "=&r" (rv), "+m" (*p)
	    : "r" (p), "r" (v)
	    : "cc", "xer");

	return (rv);
}
#define atomic_sub_int_nv(_p, _v) _atomic_sub_int_nv((_p), (_v))

static inline unsigned long
_atomic_sub_long_nv(volatile unsigned long *p, unsigned long v)
{
	unsigned long rv;

	__asm volatile (
	    "1:	lwarx	%0, 0, %2	\n"
	    "	subf	%0, %3,	%0	\n"
	    "	stwcx.	%0, 0, %2	\n"
	    "	bne-	1b		\n"
	    : "=&r" (rv), "+m" (*p)
	    : "r" (p), "r" (v)
	    : "cc", "xer");

	return (rv);
}
#define atomic_sub_long_nv(_p, _v) _atomic_sub_long_nv((_p), (_v))

static inline unsigned int
_atomic_addic_int_nv(volatile unsigned int *p, unsigned int v)
{
	unsigned int rv;

	__asm volatile (
	    "1:	lwarx	%0, 0, %2	\n"
	    "	addic	%0, %0,	%3	\n"
	    "	stwcx.	%0, 0, %2	\n"
	    "	bne-	1b		\n"
	    : "=&r" (rv), "+m" (*p)
	    : "r" (p), "n" (v)
	    : "cc", "xer");

	return (rv);
}
#define atomic_inc_int_nv(_p) _atomic_addic_int_nv((_p), 1)
#define atomic_dec_int_nv(_p) _atomic_addic_int_nv((_p), -1)

static inline unsigned long
_atomic_addic_long_nv(volatile unsigned long *p, unsigned long v)
{
	unsigned long rv;

	__asm volatile (
	    "1:	lwarx	%0, 0, %2	\n"
	    "	addic	%0, %0,	%3	\n"
	    "	stwcx.	%0, 0, %2	\n"
	    "	bne-	1b		\n"
	    : "=&r" (rv), "+m" (*p)
	    : "r" (p), "n" (v)
	    : "cc", "xer");

	return (rv);
}
#define atomic_inc_long_nv(_p) _atomic_addic_long_nv((_p), 1)
#define atomic_dec_long_nv(_p) _atomic_addic_long_nv((_p), -1)

#define __membar(_f) do { __asm __volatile(_f ::: "memory"); } while (0)

#if defined(MULTIPROCESSOR) || !defined(_KERNEL)
#define membar_enter()		__membar("isync")
#define membar_exit()		__membar("sync")
#define membar_producer()	__membar("sync")
#define membar_consumer()	__membar("isync")
#define membar_sync()		__membar("sync")
#else
#define membar_enter()		__membar("")
#define membar_exit()		__membar("")
#define membar_producer()	__membar("")
#define membar_consumer()	__membar("")
#define membar_sync()		__membar("")
#endif

#endif /* _POWERPC_ATOMIC_H_ */
@


1.10
log
@put mpi's atomics back in, but with the return value of add (and therefore sub, inc, and dec) fixed.

the asm read the value from memory into a register, added to it,
and then tried to write it back. after succeeding it doesnt have
to add again before returning.

this splits sub, inc, and dec off from add. sub can use the subf
opcode, and inc and dec can use the addic opcode. explicitely
identify where the modified memory is so we can avoid using "memory"
as a clobber.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atomic.h,v 1.8 2015/04/22 06:39:03 mpi Exp $	*/
d51 2
d278 1
a278 1
#ifdef MULTIPROCESSOR
a291 1
#endif /* defined(_KERNEL) */
@


1.9
log
@Revert back to using GCC builtins.  This code triggers an off by one in
device_unref() as found by deraadt@@.
@
text
@d3 16
a18 1
/* Public Domain */
d50 223
@


1.8
log
@Implement the MI atomic API for PowerPC to avoid using gcc builtins that
include extra sync operations.

ok kettenis@@
@
text
@d1 1
a1 17
/*	$OpenBSD: atomic.h,v 1.7 2014/06/19 11:29:21 kettenis Exp $	*/

/*
 * Copyright (c) 2015 Martin Pieuchot
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
d3 1
a34 151

static inline unsigned int
_atomic_cas_uint(volatile unsigned int *p, unsigned int o, unsigned int n)
{
	unsigned int rv;

	__asm volatile (
	    "1:	lwarx	%0, 0, %1	\n"
	    "	cmpw	0, %0, %3	\n"
	    "	bne-	2f		\n"
	    "	stwcx.	%2, 0, %1	\n" 
	    "	bne-	1b		\n"
	    "2:				\n"
	    : "=&r" (rv)
	    : "r" (p), "r" (n), "r" (o)
	    : "cc", "memory");

	return (rv);
}
#define atomic_cas_uint(_p, _o, _n) _atomic_cas_uint((_p), (_o), (_n))

static inline unsigned long
_atomic_cas_ulong(volatile unsigned long *p, unsigned long o, unsigned long n)
{
	unsigned long rv;

	__asm volatile (
	    "1:	lwarx	%0, 0, %1	\n"
	    "	cmpw	0, %0, %3	\n"
	    "	bne-	2f		\n"
	    "	stwcx.	%2, 0, %1	\n" 
	    "	bne-	1b		\n"
	    "2:				\n"
	    : "=&r" (rv)
	    : "r" (p), "r" (n), "r" (o)
	    : "cc", "memory");

	return (rv);
}
#define atomic_cas_ulong(_p, _o, _n) _atomic_cas_ulong((_p), (_o), (_n))

static inline void *
_atomic_cas_ptr(volatile void *pp, void *o, void *n)
{
	void * volatile *p = pp;
	void *rv;

	__asm volatile (
	    "1:	lwarx	%0, 0, %3	\n"
	    "	cmpw	0, %0, %1	\n"
	    "	bne-	2f		\n"
	    "	stwcx.	%2, 0, %3	\n" 
	    "	bne-	1b		\n"
	    "2:				\n"
	    : "=&r" (rv)
	    : "r" (o), "r" (n), "r" (p)
	    : "cc", "memory");

	return (rv);
}
#define atomic_cas_ptr(_p, _o, _n) _atomic_cas_ptr((_p), (_o), (_n))

static inline unsigned int
_atomic_swap_uint(volatile unsigned int *p, unsigned int v)
{
	unsigned int rv;

	__asm volatile (
	    "1:	lwarx	%0, 0, %1	\n"
	    "	stwcx.	%2, 0, %1	\n"
	    "	bne-	1b		\n"
	    : "=&r" (rv)
	    : "r" (p), "r" (v)
	    : "cc", "memory");

	return (rv);
}
#define atomic_swap_uint(_p, _v) _atomic_swap_uint((_p), (_v))

static inline unsigned long
_atomic_swap_ulong(volatile unsigned long *p, unsigned long v)
{
	unsigned long rv;

	__asm volatile (
	    "1:	lwarx	%0, 0, %1	\n"
	    "	stwcx.	%2, 0, %1	\n"
	    "	bne-	1b		\n"
	    : "=&r" (rv)
	    : "r" (p), "r" (v)
	    : "cc", "memory");

	return (rv);
}
#define atomic_swap_ulong(_p, _v) _atomic_swap_ulong((_p), (_v))

static inline void *
_atomic_swap_ptr(volatile void *pp, void *v)
{
	void * volatile *p = pp;
	void *rv;

	__asm volatile (
	    "1:	lwarx	%0, 0, %1	\n"
	    "	stwcx.	%2, 0, %1	\n"
	    "	bne-	1b		\n"
	    : "=&r" (rv)
	    : "r" (p), "r" (v)
	    : "cc", "memory");

	return (rv);
}
#define atomic_swap_ptr(_p, _n) _atomic_swap_ptr((_p), (_n))

static inline unsigned int
_atomic_add_int_nv(volatile unsigned int *p, unsigned int v)
{
	unsigned int rv;

	__asm volatile (
	    "1:	lwarx	%0, 0, %1	\n"
	    "	add	%0, %2,	%0	\n"
	    "	stwcx.	%0, 0, %1	\n"
	    "	bne-	1b		\n"
	    : "=&r" (rv)
	    : "r" (p), "r" (v)
	    : "cc", "memory");

	return (rv + v);
}
#define atomic_add_int_nv(_p, _v) _atomic_add_int_nv((_p), (_v))
#define atomic_sub_int_nv(_p, _v) _atomic_add_int_nv((_p), 0 - (_v))

static inline unsigned long
_atomic_add_long_nv(volatile unsigned long *p, unsigned long v)
{
	unsigned long rv;

	__asm volatile (
	    "1:	lwarx	%0, 0, %1	\n"
	    "	add	%0, %2,	%0	\n"
	    "	stwcx.	%0, 0, %1	\n"
	    "	bne-	1b		\n"
	    : "=&r" (rv)
	    : "r" (p), "r" (v)
	    : "cc", "memory");

	return (rv + v);
}
#define atomic_add_long_nv(_p, _v) _atomic_add_long_nv((_p), (_v))
#define atomic_sub_long_nv(_p, _v) _atomic_add_long_nv((_p), 0 - (_v))
@


1.7
log
@Implement the membar(9) API for powerpc.

ok miod@@, dlg@@
@
text
@d1 17
a17 1
/*	$OpenBSD: atomic.h,v 1.6 2014/03/29 18:09:30 guenther Exp $	*/
a18 1
/* Public Domain */
d50 151
@


1.6
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atomic.h,v 1.5 2013/08/06 08:19:52 kettenis Exp $	*/
d35 16
@


1.5
log
@The atomic_setbits_int() and atomic_clearbits_int() functions touch the
condition code register so mark it s clobbered.

Fixes uvm_page_physload() and who knows what else.

ok jsg@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atomic.h,v 1.4 2011/03/23 16:54:36 pirofti Exp $	*/
d11 1
a11 1
atomic_setbits_int(__volatile unsigned int *uip, unsigned int v)
d24 1
a24 1
atomic_clearbits_int(__volatile unsigned int *uip, unsigned int v)
@


1.4
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: atomic.h,v 1.3 2007/03/17 22:10:04 kettenis Exp $	*/
d20 1
a20 1
	    "	sync" : "=&r" (tmp) : "r" (v), "r" (uip) : "memory");
d33 1
a33 1
	    "	sync" : "=&r" (tmp) : "r" (v), "r" (uip) : "memory");
@


1.3
log
@Implement proper atomic.h for powerpc.  With help from art@@ and drahn@@.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atomic.h,v 1.2 2007/02/19 17:18:43 deraadt Exp $	*/
d5 2
a6 2
#ifndef __POWERPC_ATOMIC_H__
#define __POWERPC_ATOMIC_H__
d37 1
a37 1
#endif /* __POWERPC_ATOMIC_H__ */
@


1.2
log
@only make this interface available to the kernel for now, discussed witha
rt and such; tested and ok miod drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: atomic.h,v 1.1 2007/02/06 17:13:33 art Exp $	*/
d13 8
a20 1
	*uip |= v;
d26 8
a33 1
	*uip &= ~v;
@


1.1
log
@Add machine/atomic.h to all architectures and define two operations
right now that are supposed to be atomic with respect to interrupts and
SMP: atomic_setbits_int and atomic_clearbits_int.

All architectures other than i386 and amd64 get dummy implementations
since at first we'll be replacing operations that are done with
"a |= bit" and "a &= ~bit" today. More proper implementations will follow

kettenis@@, miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d8 2
d22 2
a23 1
#endif
@

