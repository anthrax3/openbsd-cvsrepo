head	1.59;
access;
symbols
	OPENBSD_6_1:1.59.0.8
	OPENBSD_6_1_BASE:1.59
	OPENBSD_6_0:1.59.0.4
	OPENBSD_6_0_BASE:1.59
	OPENBSD_5_9:1.59.0.2
	OPENBSD_5_9_BASE:1.59
	OPENBSD_5_8:1.57.0.4
	OPENBSD_5_8_BASE:1.57
	OPENBSD_5_7:1.55.0.2
	OPENBSD_5_7_BASE:1.55
	OPENBSD_5_6:1.50.0.6
	OPENBSD_5_6_BASE:1.50
	OPENBSD_5_5:1.50.0.4
	OPENBSD_5_5_BASE:1.50
	OPENBSD_5_4:1.49.0.2
	OPENBSD_5_4_BASE:1.49
	OPENBSD_5_3:1.48.0.2
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.47.0.8
	OPENBSD_5_2_BASE:1.47
	OPENBSD_5_1_BASE:1.47
	OPENBSD_5_1:1.47.0.6
	OPENBSD_5_0:1.47.0.4
	OPENBSD_5_0_BASE:1.47
	OPENBSD_4_9:1.47.0.2
	OPENBSD_4_9_BASE:1.47
	OPENBSD_4_8:1.45.0.12
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.45.0.8
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.45.0.10
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.45.0.6
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.45.0.4
	OPENBSD_4_4_BASE:1.45
	OPENBSD_4_3:1.45.0.2
	OPENBSD_4_3_BASE:1.45
	OPENBSD_4_2:1.44.0.2
	OPENBSD_4_2_BASE:1.44
	OPENBSD_4_1:1.42.0.4
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.42.0.2
	OPENBSD_4_0_BASE:1.42
	OPENBSD_3_9:1.41.0.2
	OPENBSD_3_9_BASE:1.41
	OPENBSD_3_8:1.38.0.6
	OPENBSD_3_8_BASE:1.38
	OPENBSD_3_7:1.38.0.4
	OPENBSD_3_7_BASE:1.38
	OPENBSD_3_6:1.38.0.2
	OPENBSD_3_6_BASE:1.38
	SMP_SYNC_A:1.36
	SMP_SYNC_B:1.36
	OPENBSD_3_5:1.34.0.2
	OPENBSD_3_5_BASE:1.34
	OPENBSD_3_4:1.31.0.6
	OPENBSD_3_4_BASE:1.31
	UBC_SYNC_A:1.31
	OPENBSD_3_3:1.31.0.4
	OPENBSD_3_3_BASE:1.31
	OPENBSD_3_2:1.31.0.2
	OPENBSD_3_2_BASE:1.31
	OPENBSD_3_1:1.25.0.2
	OPENBSD_3_1_BASE:1.25
	UBC_SYNC_B:1.31
	UBC:1.23.0.2
	UBC_BASE:1.23
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.18
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.14
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	powerpc_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.59
date	2015.10.08.10.20.14;	author kettenis;	state Exp;
branches;
next	1.58;
commitid	XyklQUq12w27Mxrq;

1.58
date	2015.09.11.22.02.18;	author kettenis;	state Exp;
branches;
next	1.57;
commitid	BLslNV9mBJowqn8K;

1.57
date	2015.06.05.11.38.19;	author mpi;	state Exp;
branches;
next	1.56;
commitid	VG3VjtaKjHPdWfsX;

1.56
date	2015.03.31.16.00.38;	author mpi;	state Exp;
branches;
next	1.55;
commitid	MMWnK4Mn4W58afQM;

1.55
date	2015.02.15.21.34.33;	author miod;	state Exp;
branches;
next	1.54;
commitid	eahBabNpxnDWKzqJ;

1.54
date	2015.02.09.13.35.43;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	6dyy3ukeU7UdcPiK;

1.53
date	2015.02.09.13.34.49;	author deraadt;	state Exp;
branches;
next	1.52;
commitid	5yMidS9tJP3CVY3y;

1.52
date	2015.01.22.17.55.45;	author mpi;	state Exp;
branches;
next	1.51;
commitid	GiDlPECBAognbItE;

1.51
date	2015.01.20.17.04.21;	author mpi;	state Exp;
branches;
next	1.50;
commitid	fChEQy2ai2DbX4qD;

1.50
date	2014.01.30.18.16.41;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2013.03.23.16.12.26;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2012.08.30.18.14.26;	author mpi;	state Exp;
branches;
next	1.47;

1.47
date	2010.12.26.15.41.00;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2010.11.18.21.21.38;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2007.09.10.18.49.45;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2007.05.27.15.46.02;	author drahn;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.03.18.40.19;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2006.05.29.21.50.09;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2005.12.17.07.31.26;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2005.10.09.14.01.11;	author drahn;	state Exp;
branches;
next	1.39;

1.39
date	2005.10.03.02.18.50;	author drahn;	state Exp;
branches;
next	1.38;

1.38
date	2004.08.06.22.39.13;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2004.07.13.14.51.29;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2004.06.09.20.17.23;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2004.05.20.09.20.42;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2004.01.15.05.53.13;	author drahn;	state Exp;
branches;
next	1.33;

1.33
date	2004.01.03.00.57.06;	author pvalchev;	state Exp;
branches;
next	1.32;

1.32
date	2003.10.31.03.06.16;	author drahn;	state Exp;
branches;
next	1.31;

1.31
date	2002.09.15.09.01.59;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2002.09.15.02.02.44;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2002.09.12.12.50.47;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.24.02.19.28;	author drahn;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.15.17.01.26;	author drahn;	state Exp;
branches;
next	1.26;

1.26
date	2002.07.12.20.28.55;	author drahn;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.14.01.26.42;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.13.18.27.36;	author drahn;	state Exp;
branches;
next	1.23;

1.23
date	2001.12.05.00.11.51;	author millert;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2001.11.28.15.34.16;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.11.06.02.55.51;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.09.18.13.59.23;	author drahn;	state Exp;
branches;
next	1.19;

1.19
date	2001.09.10.16.44.52;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2001.09.01.15.49.05;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2001.08.18.20.50.18;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.18.19.36.57;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.18.13.47.11;	author drahn;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.18.10.47.05;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.10.01.34.32;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.09.02.26.05;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.09.02.14.05;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.29.06.07.09;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.24.23.26.29;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.24.05.17.04;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.26.03.27.58;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.25.23.33.47;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.09.15.31.26;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.22.03.26.23;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	97.01.09.03.03.46;	author rahnds;	state Exp;
branches
	1.3.14.1;
next	1.2;

1.2
date	96.12.28.06.25.20;	author rahnds;	state Exp;
branches;
next	1.1;

1.1
date	96.12.21.20.35.54;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.12.21.20.35.54;	author rahnds;	state Exp;
branches;
next	;

1.3.14.1
date	2001.04.18.16.13.04;	author niklas;	state Exp;
branches;
next	1.3.14.2;

1.3.14.2
date	2001.07.04.10.22.27;	author niklas;	state Exp;
branches;
next	1.3.14.3;

1.3.14.3
date	2001.10.31.03.07.55;	author nate;	state Exp;
branches;
next	1.3.14.4;

1.3.14.4
date	2001.11.13.21.04.16;	author niklas;	state Exp;
branches;
next	1.3.14.5;

1.3.14.5
date	2001.11.13.22.14.34;	author niklas;	state dead;
branches;
next	1.3.14.6;

1.3.14.6
date	2002.03.29.16.11.59;	author niklas;	state Exp;
branches;
next	1.3.14.7;

1.3.14.7
date	2003.03.27.23.42.35;	author niklas;	state Exp;
branches;
next	1.3.14.8;

1.3.14.8
date	2004.02.19.10.49.57;	author niklas;	state Exp;
branches;
next	1.3.14.9;

1.3.14.9
date	2004.06.05.23.10.56;	author niklas;	state Exp;
branches;
next	1.3.14.10;

1.3.14.10
date	2004.06.10.11.40.28;	author niklas;	state Exp;
branches;
next	;

1.23.2.1
date	2002.06.11.03.37.28;	author art;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2002.10.29.00.28.08;	author art;	state Exp;
branches;
next	;


desc
@@


1.59
log
@Add a per-page flag to indicate that all mappings of that page should be
uncached.  To be used in the drm code.

ok mpi@@
@
text
@/*	$OpenBSD: pmap.h,v 1.58 2015/09/11 22:02:18 kettenis Exp $	*/
/*	$NetBSD: pmap.h,v 1.1 1996/09/30 16:34:29 ws Exp $	*/

/*-
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef	_POWERPC_PMAP_H_
#define	_POWERPC_PMAP_H_

#include <machine/pte.h>

/*
 * Segment registers
 */
#ifndef	_LOCORE
typedef u_int sr_t;
#endif	/* _LOCORE */
#define	SR_TYPE		0x80000000
#define	SR_SUKEY	0x40000000
#define	SR_PRKEY	0x20000000
#define SR_NOEXEC	0x10000000
#define	SR_VSID		0x00ffffff
/*
 * bit 
 *   3  2 2  2    2 1  1 1  1 1            0
 *   1  8 7  4    0 9  6 5  2 1            0
 *  |XXXX|XXXX XXXX|XXXX XXXX|XXXX XXXX XXXX
 *
 *  bits 28 - 31 contain SR
 *  bits 20 - 27 contain L1 for VtoP translation
 *  bits 12 - 19 contain L2 for VtoP translation
 *  bits  0 - 11 contain page offset
 */
#ifndef _LOCORE
/* V->P mapping data */
#define VP_SR_SIZE	16
#define VP_SR_MASK	(VP_SR_SIZE-1)
#define VP_SR_POS 	28
#define VP_IDX1_SIZE	256
#define VP_IDX1_MASK	(VP_IDX1_SIZE-1)
#define VP_IDX1_POS 	20
#define VP_IDX2_SIZE	256
#define VP_IDX2_MASK	(VP_IDX2_SIZE-1)
#define VP_IDX2_POS 	12

/* cache flags */
#define PMAP_CACHE_DEFAULT	0 	/* WB cache managed mem, devices not */
#define PMAP_CACHE_CI		1 	/* cache inhibit */
#define PMAP_CACHE_WT		2 	/* writethru */
#define PMAP_CACHE_WB		3	/* writeback */

#ifdef	_KERNEL

/*
 * Pmap stuff
 */
struct pmap {
	sr_t pm_sr[16];		/* segments used in this pmap */
	struct pmapvp *pm_vp[VP_SR_SIZE];	/* virtual to physical table */
	u_int32_t pm_exec[16];	/* segments used in this pmap */
	int pm_refs;		/* ref count */
	struct pmap_statistics	pm_stats;	/* pmap statistics */
	struct mutex		pm_mtx;		/* protect VP table */
};

/*
 * Segment handling stuff
 */
#define	PPC_SEGMENT_LENGTH	0x10000000
#define	PPC_SEGMENT_MASK	0xf0000000

/*
 * Some system constants
 */
#ifndef	NPMAPS
#define	NPMAPS		32768	/* Number of pmaps in system */
#endif

typedef	struct pmap *pmap_t;

extern struct pmap kernel_pmap_;
#define	pmap_kernel()	(&kernel_pmap_)


#define pmap_clear_modify(pg)		pmap_clear_attrs((pg), PG_PMAP_MOD)
#define	pmap_clear_reference(pg)	pmap_clear_attrs((pg), PG_PMAP_REF)
#define	pmap_is_modified(pg)		pmap_test_attrs((pg), PG_PMAP_MOD)
#define	pmap_is_referenced(pg)		pmap_test_attrs((pg), PG_PMAP_REF)

#define	pmap_unwire(pm, va)
#define pmap_update(pmap)	/* nothing (yet) */

#define pmap_resident_count(pmap)       ((pmap)->pm_stats.resident_count) 

/*
 * Alternate mapping methods for pool.
 * Really simple. 0x0->0x80000000 contain 1->1 mappings of the physical
 * memory. - XXX
 */
#define pmap_map_direct(pg)		((vaddr_t)VM_PAGE_TO_PHYS(pg))
#define pmap_unmap_direct(va)		PHYS_TO_VM_PAGE((paddr_t)va)
#define	__HAVE_PMAP_DIRECT

void pmap_bootstrap(u_int kernelstart, u_int kernelend);
void pmap_enable_mmu();

int pmap_clear_attrs(struct vm_page *, unsigned int);
int pmap_test_attrs(struct vm_page *, unsigned int);

void pmap_pinit(struct pmap *);
void pmap_release(struct pmap *);

void pmap_real_memory(vaddr_t *start, vsize_t *size);
void switchexit(struct proc *);

int pte_spill_v(struct pmap *pm, u_int32_t va, u_int32_t dsisr, int exec_fault);
#define pmap_copy(dst_pmap, src_pmap, dst_addr, len, src_addr) ;
int reserve_dumppages(caddr_t p);

#define pmap_unuse_final(p)		/* nothing */
#define	pmap_remove_holes(vm)		do { /* nothing */ } while (0)

#define	PMAP_STEAL_MEMORY

#define PG_PMAP_MOD	PG_PMAP0
#define PG_PMAP_REF	PG_PMAP1
#define PG_PMAP_EXE	PG_PMAP2
#define PG_PMAP_UC	PG_PMAP3

/*
 * MD flags that we use for pmap_enter (in the pa):
 */
#define PMAP_PA_MASK	~((paddr_t)PAGE_MASK) /* to remove the flags */
#define PMAP_NOCACHE	0x1		/* map uncached */
#define PMAP_WT		0x2		/* map write-through */

#endif	/* _KERNEL */

#include <sys/mutex.h>

struct vm_page_md {
	struct mutex pv_mtx;
	LIST_HEAD(,pte_desc) pv_list;
};

#define VM_MDPAGE_INIT(pg) do {                 \
	mtx_init(&(pg)->mdpage.pv_mtx, IPL_VM); \
	LIST_INIT(&((pg)->mdpage.pv_list)); 	\
} while (0)

#endif	/* _LOCORE */

#endif	/* _POWERPC_PMAP_H_ */
@


1.58
log
@Make the powerpc pmap (more) mpsafe by protecting both the pmap itself and the
pv lists with a mutex.  This should make pmap_enter(9), pmap_remove(9) and
pmap_page_protect(9) safe to use without holding the kernel lock.

ok visa@@, mpi@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.57 2015/06/05 11:38:19 mpi Exp $	*/
d153 4
a156 3
#define PG_PMAP_MOD     PG_PMAP0
#define PG_PMAP_REF     PG_PMAP1
#define PG_PMAP_EXE     PG_PMAP2
@


1.57
log
@Add bits missed in previous... I suck at cvs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.56 2015/03/31 16:00:38 mpi Exp $	*/
d166 2
d169 1
d174 1
@


1.56
log
@Make it possisble to disable block address translation mechanism on
processors that support it.

Due to the way trap code is patched it is currently not possible to
enabled/disable BAT at runtime.

ok miod@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.55 2015/02/15 21:34:33 miod Exp $	*/
d91 1
a110 1
boolean_t pteclrbits(struct vm_page *pg, u_int mask, u_int clear);
d113 4
a116 8
#define pmap_clear_modify(page) \
	(pteclrbits((page), PG_PMAP_MOD, TRUE))
#define	pmap_clear_reference(page) \
	(pteclrbits((page), PG_PMAP_REF, TRUE))
#define	pmap_is_modified(page) \
	(pteclrbits((page), PG_PMAP_MOD, FALSE))
#define	pmap_is_referenced(page) \
	(pteclrbits((page), PG_PMAP_REF, FALSE))
d134 3
@


1.55
log
@Change pmap_remove_holes() to take a vmspace instead of a map as its argument.

Use this on vax to correctly pick the end of the stack area now that the
stackgap adjustment code will no longer guarantee it is a fixed location.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.54 2015/02/09 13:35:43 deraadt Exp $	*/
d137 1
@


1.54
log
@oops, accidental commit
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.52 2015/01/22 17:55:45 mpi Exp $	*/
d149 1
a149 1
#define	pmap_remove_holes(map)		do { /* nothing */ } while (0)
@


1.53
log
@sync
@
text
@a73 3
/* functions used by the bus layer for device accesses */
void pmap_kenter_cache(vaddr_t va, paddr_t pa, vm_prot_t prot, int cacheable);

d158 1
a158 1
 * MD flags to pmap_enter:
d160 1
a160 3

/* to get just the pa from params to pmap_enter */
#define PMAP_PA_MASK	~((paddr_t)PAGE_MASK)
d162 1
@


1.52
log
@Let powerpc's bus_space(9) use the same pmap and uvm interfaces than the
other archs.

Specify the caching policy by passing PMAP_* flags to pmap_kenter_pa()
like the majority of our archs do and kill pmap_kenter_cache().

Spread some pmap_update() along the way.

While here remove the unused flag argument from pmap_fill_pte().

Finally convert the bus map/unmap functions to km_alloc/free() instead
of uvm_km_valloc/free().

Inputs from kettenis@@ and miod@@, ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.51 2015/01/20 17:04:21 mpi Exp $	*/
d74 3
d161 1
a161 1
 * MD flags that we use for pmap_enter (in the pa):
d163 3
a165 1
#define PMAP_PA_MASK	~((paddr_t)PAGE_MASK) /* to remove the flags */
a166 1
#define PMAP_WT		0x2		/* map write-through */
@


1.51
log
@Various cleanups. Explicitly include <sys/atomic.h>, Use pmap_remove_pg()
for the kernel pmap and kill pmap_kremove_pg().  Finally guard the hash
lock code under "MULTIPROCESSOR" to explicit which part of the code
received some MP love.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.50 2014/01/30 18:16:41 miod Exp $	*/
a73 3
/* functions used by the bus layer for device accesses */
void pmap_kenter_cache(vaddr_t va, paddr_t pa, vm_prot_t prot, int cacheable);

d158 1
a158 1
 * MD flags to pmap_enter:
d160 1
a160 3

/* to get just the pa from params to pmap_enter */
#define PMAP_PA_MASK	~((paddr_t)PAGE_MASK)
d162 1
@


1.50
log
@Move declaration of struct vm_page_md from <machine/vmparam.h> to
<machine/pmap.h> where it belongs, and compensate in <uvm/uvm_extern.h>
by including <uvm/uvm_pmap.h> before <uvm/uvm_page.h>. Tested on all
MACHINE_ARCH but amd64 and i386 (and hppa64).
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.49 2013/03/23 16:12:26 deraadt Exp $	*/
a75 1
void pmap_kremove_pg(vaddr_t va);
@


1.49
log
@refactor sys/param.h and machine/param.h.  A lot of #ifdef _KERNEL is added
to keep definitions our of user space.  The MD files now follow a consistant
order -- all namespace intrusion is at the tail can be cleaned up
independently.  locore, bootblocks, and libkvm still see enough visibility to
build.  Checked on 90% of platforms...
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.48 2012/08/30 18:14:26 mpi Exp $	*/
d170 9
d180 1
@


1.48
log
@Add the possibility to map DMA memory non-cached, based on the i386/amd64
implementation. For the moment only the BUS_DMA_NOCACHE macro is required
to build drm on macppc but it will be used soon.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.47 2010/12/26 15:41:00 miod Exp $	*/
d96 13
@


1.47
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.46 2010/11/18 21:21:38 miod Exp $	*/
d147 8
@


1.46
log
@Declare pmap_proc_iflush() in <uvm/uvm_pmap.h> unless <machine/pmap.h>
provides an inline version of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.45 2007/09/10 18:49:45 miod Exp $	*/
a113 1
#define	pmap_phys_address(x)		(x)
@


1.45
log
@Introduce a md pmap hook, pmap_remove_holes(), which is supposed to mark
the holes a MMU may have from a given vm_map. This will be automagically
invoked for newly created vmspaces.

On platforms with MMU holes (e.g. sun4, sun4c and vax), this prevents
mmap(2) hints which would end up being in the hole to be accepted as valid,
causing unexpected signals when the process tries to access the hole
(since pmap can not fill the hole anyway).

Unfortunately, the logic mmap() uses to pick a valid address for anonymous
mappings needs work, as it will only try to find an address higher than the
hint, which causes all mmap() with a hint in the hole to fail on vax. This
will be improved later.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.44 2007/05/27 15:46:02 drahn Exp $	*/
a139 1
void pmap_proc_iflush(struct proc *proc, vaddr_t va, vsize_t len);
@


1.44
log
@Move powerpc to vm_page_md, 'throw it in' kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.43 2007/05/03 18:40:19 miod Exp $	*/
d142 1
@


1.43
log
@Implement pmap_steal_memory() on powerpc. With some help from art@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.42 2006/05/29 21:50:09 deraadt Exp $	*/
d101 1
a101 1
boolean_t pteclrbits(paddr_t pa, u_int mask, u_int clear);
d105 1
a105 1
	(pteclrbits(VM_PAGE_TO_PHYS(page), PTE_CHG_32, TRUE))
d107 1
a107 1
	(pteclrbits(VM_PAGE_TO_PHYS(page), PTE_REF_32, TRUE))
d109 1
a109 1
	(pteclrbits(VM_PAGE_TO_PHYS(page), PTE_CHG_32, FALSE))
d111 1
a111 1
	(pteclrbits(VM_PAGE_TO_PHYS(page), PTE_REF_32, FALSE))
d144 4
@


1.42
log
@clean userland namespace a bit more; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.41 2005/12/17 07:31:26 miod Exp $	*/
d142 2
@


1.41
log
@Get rid of deprecated vm_{offset,size}_t types for good, use {p,v}{addr,size}_t
instead; looked at millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.40 2005/10/09 14:01:11 drahn Exp $	*/
d84 2
a98 1
#ifdef	_KERNEL
@


1.40
log
@Nearly functional crashdump support for macppc. Because savecore
does not recognize the resulting crashdumps, the writing has been disabled.
Better here than in my forest of trees.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.39 2005/10/03 02:18:50 drahn Exp $	*/
d132 1
a132 1
void pmap_real_memory(vm_offset_t *start, vm_size_t *size);
@


1.39
log
@G5 pmap support, most of this G5 work has been done by kettenis@@
without his forging ahead, it would barely be started.
Again this is one step of many, but needs to be tested, this is
independant of the locore change just committed which kettenis@@ and
deraadt@@ significantly wrote.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.38 2004/08/06 22:39:13 deraadt Exp $	*/
d137 1
@


1.38
log
@rename sparc kill_user_windows() to pmap_unuse_final().  provide empty stubs
on all other architectures.  remove last architecture dependent #ifdef from
uvm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.37 2004/07/13 14:51:29 tedu Exp $	*/
d104 1
a104 1
	(pteclrbits(VM_PAGE_TO_PHYS(page), PTE_CHG, TRUE))
d106 1
a106 1
	(pteclrbits(VM_PAGE_TO_PHYS(page), PTE_REF, TRUE))
d108 1
a108 1
	(pteclrbits(VM_PAGE_TO_PHYS(page), PTE_CHG, FALSE))
d110 2
a111 1
	(pteclrbits(VM_PAGE_TO_PHYS(page), PTE_REF, FALSE))
@


1.37
log
@#define __HAVE_PMAP_DIRECT and use it.  requested by art
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.36 2004/06/09 20:17:23 tedu Exp $	*/
d138 1
@


1.36
log
@rename POOLPAGE macros to pmap_map_direct
break out uvm_km_page bits for this case, no thread here
lots of testing tech@@, deraadt@@, naddy@@, mickey@@, ...
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.35 2004/05/20 09:20:42 kettenis Exp $	*/
d124 1
@


1.35
log
@Properly flush instruction cache for ptrace(PT_WRTIE_{DI}, ...) on powerpc
and m68k.
ok drahn@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.34 2004/01/15 05:53:13 drahn Exp $	*/
d122 2
a123 2
#define PMAP_MAP_POOLPAGE(pg)		((vaddr_t)VM_PAGE_TO_PHYS(pg))
#define PMAP_UNMAP_POOLPAGE(va)		PHYS_TO_VM_PAGE((paddr_t)va)
@


1.34
log
@Undo backout of this piece of 'SR restores', this feature is used by
on pegasos.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.33 2004/01/03 00:57:06 pvalchev Exp $	*/
d135 2
@


1.33
log
@backout segment register restore diff which causes reproducible hangs; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.31 2002/09/15 09:01:59 deraadt Exp $	*/
d74 3
a76 1
void pmap_kenter_cache( vaddr_t va, paddr_t pa, vm_prot_t prot, int cacheable);
@


1.32
log
@Fix ppc segment register restores, this fixes the 1GB ram limit and
cleans up pieces in the pmap code.
tested otto, brad, miod, pval.
@
text
@d74 1
a74 3
/* functions used by the bus layer for device accesses */
void pmap_kenter_cache(vaddr_t va, paddr_t pa, vm_prot_t prot, int cacheable);
void pmap_kremove_pg(vaddr_t va);
@


1.31
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.29 2002/09/12 12:50:47 art Exp $	*/
d74 3
a76 1
void pmap_kenter_cache( vaddr_t va, paddr_t pa, vm_prot_t prot, int cacheable);
@


1.30
log
@KNF
@
text
@d52 1
a52 1
 * bit
d66 1
a66 1
#define VP_SR_POS	28
d69 1
a69 1
#define VP_IDX1_POS	20
d72 1
a72 1
#define VP_IDX2_POS	12
d77 3
a79 3
#define PMAP_CACHE_DEFAULT	0	/* WB cache managed mem, devices not */
#define PMAP_CACHE_CI		1	/* cache inhibit */
#define PMAP_CACHE_WT		2	/* writethru */
d113 1
a113 1
#define pmap_resident_count(pmap)	((pmap)->pm_stats.resident_count)
@


1.29
log
@Change the PMAP_{MAP,UNMAP}_POOLPAGE api to take a vm_page as argument
and return a VM_PAGE. This is to allow sparc64 to cheaply record the
VAC color for those pages.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.28 2002/07/24 02:19:28 drahn Exp $	*/
d52 1
a52 1
 * bit 
d66 1
a66 1
#define VP_SR_POS 	28
d69 1
a69 1
#define VP_IDX1_POS 	20
d72 1
a72 1
#define VP_IDX2_POS 	12
d77 3
a79 3
#define PMAP_CACHE_DEFAULT	0 	/* WB cache managed mem, devices not */
#define PMAP_CACHE_CI		1 	/* cache inhibit */
#define PMAP_CACHE_WT		2 	/* writethru */
d113 1
a113 1
#define pmap_resident_count(pmap)       ((pmap)->pm_stats.resident_count) 
@


1.28
log
@- change pte_spill_X() to take an extra parameter to determine if
  the fault is a EXE fault or R/W fault.

- mask/or the SR_NOEXEC bit into the segment register value
  when the number of executable pages becomes 0/non-zero.

- create segments with SR_NOEXEC set, will be cleared when first
  exec mapping in the segment is created.

- allow pte_spill_X() to deal with a new type of fault, page mapped
  but non executable, when execute was requested.

Adds up to - non-exec stack support for powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.27 2002/07/15 17:01:26 drahn Exp $	*/
d120 2
a121 2
#define PMAP_MAP_POOLPAGE(pa) ((vaddr_t)pa)
#define PMAP_UNMAP_POOLPAGE(va)       ((paddr_t)va)
@


1.27
log
@Perform accounting for executable pages on powerpc, prepare for
non-executeable stack.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.26 2002/07/12 20:28:55 drahn Exp $	*/
d49 1
d131 1
a131 1
int pte_spill_v(struct pmap *pm, u_int32_t va, u_int32_t dsisr);
@


1.26
log
@Cleanup: use less _t typedefs, use the structure itself.

pmap_t is the exception, it is required by the MI code so pmap_t will
be used instead of using 'struct pmap *' in the code.  (consistency)
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.26 2002/07/12 20:26:10 drahn Exp $	*/
d87 1
@


1.25
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.24 2002/03/13 18:27:36 drahn Exp $	*/
a62 1
typedef struct pmapvp pmapvp_t;
d86 1
a86 1
	pmapvp_t *pm_vp[VP_SR_SIZE];	/* virtual to physical table */
@


1.24
log
@Complete rewrite of the powerpc pmap handling, Instead of keeping
the spill list for each PTEG, the V->P translations are stored in
trees for each pmap. All valid kernel mappings are preallocated
in 1-1 memory so that tlb spill/loads for kernel accesses can be
looked up while physical, user mappings are not guaranteed to
be 1-1 mapped, thus the kernel must go virtual to look up user
mappings. While this is more expensive, the tree search is much
lower cost than the long linked list search. Also on each pmap_remove()
it was necessary to search the linked lists for each possible mapping,
now it just looks up the entry in the tree.
This change gives a 25-36% speedup in 'make build' time. What was
around 2:50 is now around 1:55 on a 733MHz G4.

This change causes a likely existing bug to appear quite often,
it deals with the segment register invalidation in kernel mode.
Because of that problem, currently this change limits the physical
memory used to 256MB. This limitation will be fixed soon, it is not
an error in the pmap code.

 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.23 2001/12/05 00:11:51 millert Exp $	*/
d122 1
a122 1
void pmap_bootstrap __P((u_int kernelstart, u_int kernelend));
d124 2
a125 2
void pmap_pinit __P((struct pmap *));
void pmap_release __P((struct pmap *));
d127 2
a128 2
void pmap_real_memory __P((vm_offset_t *start, vm_size_t *size));
void switchexit __P((struct proc *));
@


1.23
log
@Update pmap_update macro for arches Art missed.  Still just a noop.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.22 2001/11/28 15:34:16 art Exp $	*/
d50 11
a60 1

d63 2
a64 2
typedef int pmapv_t;
#define VP_SR_SIZE	32
d66 2
a67 2
#define VP_SR_POS 	27
#define VP_IDX1_SIZE	1024
d69 2
a70 2
#define VP_IDX1_POS 	17
#define VP_IDX2_SIZE	32
d87 1
a88 1
	pmapv_t *vps[VP_SR_SIZE];	/* virtual to physical table */
a92 1
boolean_t ptemodify(paddr_t pa, u_int mask, u_int val);
d97 1
a97 1
int ptebits(paddr_t pa, int bit);
d100 8
a107 4
#define pmap_clear_modify(page)	 (ptemodify(VM_PAGE_TO_PHYS(page), PTE_CHG, 0))
#define	pmap_clear_reference(page) (ptemodify(VM_PAGE_TO_PHYS(page), PTE_REF, 0))
#define	pmap_is_modified(page)	 (ptebits(VM_PAGE_TO_PHYS(page), PTE_CHG))
#define	pmap_is_referenced(page) (ptebits(VM_PAGE_TO_PHYS(page), PTE_REF))
d117 1
a117 1
 * memory.
d119 2
a120 2
#define PMAP_MAP_POOLPAGE(pa)	((vaddr_t)pa)
#define PMAP_UNMAP_POOLPAGE(va)	((paddr_t)va)
d129 3
@


1.23.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.23 2001/12/05 00:11:51 millert Exp $	*/
d50 1
a50 11
/*
 * bit 
 *   3  2 2  2    2 1  1 1  1 1            0
 *   1  8 7  4    0 9  6 5  2 1            0
 *  |XXXX|XXXX XXXX|XXXX XXXX|XXXX XXXX XXXX
 *
 *  bits 28 - 31 contain SR
 *  bits 20 - 27 contain L1 for VtoP translation
 *  bits 12 - 19 contain L2 for VtoP translation
 *  bits  0 - 11 contain page offset
 */
d53 2
a54 2
typedef struct pmapvp pmapvp_t;
#define VP_SR_SIZE	16
d56 2
a57 2
#define VP_SR_POS 	28
#define VP_IDX1_SIZE	256
d59 2
a60 2
#define VP_IDX1_POS 	20
#define VP_IDX2_SIZE	256
a76 1
	pmapvp_t *pm_vp[VP_SR_SIZE];	/* virtual to physical table */
d78 1
d83 1
d88 1
a88 1
boolean_t pteclrbits(paddr_t pa, u_int mask, u_int clear);
d91 4
a94 8
#define pmap_clear_modify(page) \
	(pteclrbits(VM_PAGE_TO_PHYS(page), PTE_CHG, TRUE))
#define	pmap_clear_reference(page) \
	(pteclrbits(VM_PAGE_TO_PHYS(page), PTE_REF, TRUE))
#define	pmap_is_modified(page) \
	(pteclrbits(VM_PAGE_TO_PHYS(page), PTE_CHG, FALSE))
#define	pmap_is_referenced(page) \
	(pteclrbits(VM_PAGE_TO_PHYS(page), PTE_REF, FALSE))
d104 1
a104 1
 * memory. - XXX
d106 2
a107 4
#define PMAP_MAP_POOLPAGE(pa) ((vaddr_t)pa)
#define PMAP_UNMAP_POOLPAGE(va)       ((paddr_t)va)

void pmap_bootstrap(u_int kernelstart, u_int kernelend);
d109 1
a109 2
void pmap_pinit(struct pmap *);
void pmap_release(struct pmap *);
d111 2
a112 2
void pmap_real_memory(vm_offset_t *start, vm_size_t *size);
void switchexit(struct proc *);
d114 2
a115 2
int pte_spill_v(struct pmap *pm, u_int32_t va, u_int32_t dsisr);
#define pmap_copy(dst_pmap, src_pmap, dst_addr, len, src_addr) ;
@


1.23.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.23.2.1 2002/06/11 03:37:28 art Exp $	*/
a48 1
#define SR_NOEXEC	0x10000000
d63 1
d87 1
a87 2
	struct pmapvp *pm_vp[VP_SR_SIZE];	/* virtual to physical table */
	u_int32_t pm_exec[16];	/* segments used in this pmap */
d119 2
a120 2
#define PMAP_MAP_POOLPAGE(pg)		((vaddr_t)VM_PAGE_TO_PHYS(pg))
#define PMAP_UNMAP_POOLPAGE(va)		PHYS_TO_VM_PAGE((paddr_t)va)
d130 1
a130 1
int pte_spill_v(struct pmap *pm, u_int32_t va, u_int32_t dsisr, int exec_fault);
@


1.22
log
@Make pmap_update functions into nops so that we can have a consistent
pmap_update API (right now it's nop).
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.21 2001/11/06 02:55:51 art Exp $	*/
d97 1
a97 1
#define pmap_update()		/* nothing */
@


1.21
log
@Need to prototype pmap_pinit and pmap_release here.
(although they are leftovers from an earlier bad time, the macppc
decided that it's a good idea to use them.)
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.20 2001/09/18 13:59:23 drahn Exp $	*/
d97 1
@


1.20
log
@Changing the way the pmap code works again.
Changes to the pmap_enter code so that the pmap_kenter/pmap_kremove
has a method to create mappings without adding them to the _pv lists
(part of the point of pmap_k* functions). Also adds an interface
so that device mappings can be created with cacheable attributes.
So that devices such as display memory can be mapped writethru
greatly increasing their speed.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.19 2001/09/10 16:44:52 mickey Exp $	*/
d109 3
@


1.19
log
@move vtophys proto into a port-area in order to remove it for macppc eventually; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.18 2001/09/01 15:49:05 drahn Exp $	*/
d63 8
@


1.18
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/include to macppc/include
Some files were not "moved" but wrapper files were created which include
the powerpc/include version.

Several of the powerpc/include files where changed to reflect that they
are POWERPC_* not MACHINE_*.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.17 2001/08/18 20:50:18 art Exp $	*/
a103 2

paddr_t vtophys __P((vaddr_t));
@


1.17
log
@Move pmap_{de,}activate to vm/pmap.h, it's same on all archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.16 2001/07/18 19:36:57 mickey Exp $	*/
d35 2
a36 2
#ifndef	_MACHINE_PMAP_H_
#define	_MACHINE_PMAP_H_
d109 1
a109 1
#endif	/* _MACHINE_PMAP_H_ */
@


1.16
log
@fxp and de are fixed, enable vtophys
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.15 2001/07/18 13:47:11 drahn Exp $	*/
a101 2
void pmap_deactivate __P((struct proc *p));
void pmap_activate __P((struct proc *p));
@


1.15
log
@Fix prototype that art missed...
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.14 2001/07/18 10:47:05 art Exp $	*/
d107 1
a107 4
/* 
 * NOT YET - fix fxp and if_de  first
paddr_t vtophys __P((paddr_t));
 */
@


1.14
log
@Get rid of the PMAP_NEW option by making it mandatory for all archs.
The archs that didn't have a proper PMAP_NEW now have a dummy implementation
with wrappers around the old functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.13 2001/07/10 01:34:32 drahn Exp $	*/
d75 1
a75 1
void ptemodify(vm_offset_t pa, u_int mask, u_int val);
@


1.13
log
@Until fxp and if_de are fixed with the correct parameter to vtophys()
this function cannot be prototyped.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.12 2001/07/09 02:26:05 mickey Exp $	*/
a40 4
 * FUCK 
#define PMAP_NEW
 */
/*
d83 4
a86 5
#ifdef PMAP_NEW
#define pmap_clear_modify(page)	 (ptemodify((page)->phys_addr, PTE_CHG, 0))
#define	pmap_clear_reference(page) (ptemodify((page)->phys_addr, PTE_REF, 0))
#define	pmap_is_modified(page)	 (ptebits((page)->phys_addr, PTE_CHG))
#define	pmap_is_referenced(page) (ptebits((page)->phys_addr, PTE_REF))
a87 10
#else
#define pmap_clear_modify(pa)	 (ptemodify((pa), PTE_CHG, 0))
#define	pmap_clear_reference(pa) (ptemodify((pa), PTE_REF, 0))
#define	pmap_is_modified(pa)	 (ptebits((pa), PTE_CHG))
#define	pmap_is_referenced(pa) (ptebits((pa), PTE_REF))
#define	pmap_unwire(pm, va)
/* XXX */
void pmap_kenter_pa(vaddr_t va, paddr_t pa, vm_prot_t prot);
#endif

@


1.12
log
@looking at other archs vtophys lives there
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.11 2001/07/09 02:14:05 mickey Exp $	*/
d122 2
d125 1
@


1.11
log
@more spacees, includes, protos
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.10 2001/06/29 06:07:09 drahn Exp $	*/
d121 2
@


1.10
log
@header file include/define cleanup. commit N of many.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.9 2001/06/24 23:26:29 drahn Exp $	*/
d99 2
@


1.9
log
@Add prototypes for softnet, ofrootfound.
Code cleanup for pmap headers.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.8 2001/06/24 05:17:04 drahn Exp $	*/
d41 4
d87 11
a97 4
#define pmap_clear_modify(pa)		(ptemodify((pa), PTE_CHG, 0))
#define	pmap_clear_reference(pa)	(ptemodify((pa), PTE_REF, 0))
#define	pmap_is_modified(pa)		(ptebits((pa), PTE_CHG))
#define	pmap_is_referenced(pa)		(ptebits((pa), PTE_REF))
d99 1
d115 4
a118 3
void pmap_deactivate(struct proc *p);
void pmap_activate(struct proc *p);
void pmap_real_memory(vm_offset_t *start, vm_size_t *size);
@


1.8
log
@Prototype functions used in macros in this header file.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.7 2001/05/26 03:27:58 art Exp $	*/
d55 1
a55 1
#define VP_SR_MASK	VP_SR_SIZE-1
d58 1
a58 1
#define VP_IDX1_MASK	VP_IDX1_SIZE-1
d61 1
a61 1
#define VP_IDX2_MASK	VP_IDX2_SIZE-1
d105 1
@


1.7
log
@Add one more '0' in comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.6 2001/05/25 23:33:47 art Exp $	*/
d75 1
d80 2
d102 3
@


1.6
log
@Implement PMAP_MAP_POOLPAGE.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.5 2001/05/09 15:31:26 art Exp $	*/
d92 1
a92 1
 * Really simple. 0x0->0x8000000 contain 1->1 mappings of the physical
@


1.5
log
@More sync to NetBSD.

 - Change pmap_change_wiring to pmap_unwire because it's only called that way.
 - Remove pmap_pageable because it's seldom implemented and when it is, it's
   either almost useless or incorrect. The same information is already passed
   to the pmap anyway by pmap_enter and pmap_unwire.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.4 2001/02/22 03:26:23 drahn Exp $	*/
d89 8
@


1.4
log
@Improve the page mapped check algorithm in the powerpc pmap module,
before it was looking through two arrays of 8 and a linked list of
undetermined size, before deciding that a mapping was not valid.
Now it allocates a data structure and caches that data.

This improves both pmap_enter and pmap_remove because both check
to see if a mapping is valid before taking the appropriate actions.

Also in pmap_remove, if the va mapping is found, stop searching for
it in the rest of this array, the alternate array and the linked list.
only one valid mapping of each va is allowed.

This change improved lat_mmap (from lmbench) from 1300 to 720
and fork+exit from 7320 to 2724 microseconds.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.3 1997/01/09 03:03:46 rahnds Exp $	*/
d84 1
a84 1
#define	pmap_change_wiring(pm, va, wired)
@


1.3
log
@adding further support.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.2 1996/12/28 06:25:20 rahnds Exp $	*/
d52 12
d70 1
@


1.3.14.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.4 2001/02/22 03:26:23 drahn Exp $	*/
a51 12
/* V->P mapping data */
typedef int pmapv_t;
#define VP_SR_SIZE	32
#define VP_SR_MASK	VP_SR_SIZE-1
#define VP_SR_POS 	27
#define VP_IDX1_SIZE	1024
#define VP_IDX1_MASK	VP_IDX1_SIZE-1
#define VP_IDX1_POS 	17
#define VP_IDX2_SIZE	32
#define VP_IDX2_MASK	VP_IDX2_SIZE-1
#define VP_IDX2_POS 	12

a57 1
	pmapv_t *vps[VP_SR_SIZE];	/* virtual to physical table */
@


1.3.14.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.3.14.1 2001/04/18 16:13:04 niklas Exp $	*/
a40 4
 * FUCK 
#define PMAP_NEW
 */
/*
d55 1
a55 1
#define VP_SR_MASK	(VP_SR_SIZE-1)
d58 1
a58 1
#define VP_IDX1_MASK	(VP_IDX1_SIZE-1)
d61 1
a61 1
#define VP_IDX2_MASK	(VP_IDX2_SIZE-1)
a74 1
void ptemodify(vm_offset_t pa, u_int mask, u_int val);
a78 1
int ptebits(paddr_t pa, int bit);
d80 5
a84 14

#ifdef PMAP_NEW
#define pmap_clear_modify(page)	 (ptemodify((page)->phys_addr, PTE_CHG, 0))
#define	pmap_clear_reference(page) (ptemodify((page)->phys_addr, PTE_REF, 0))
#define	pmap_is_modified(page)	 (ptebits((page)->phys_addr, PTE_CHG))
#define	pmap_is_referenced(page) (ptebits((page)->phys_addr, PTE_REF))
#define	pmap_unwire(pm, va)
#else
#define pmap_clear_modify(pa)	 (ptemodify((pa), PTE_CHG, 0))
#define	pmap_clear_reference(pa) (ptemodify((pa), PTE_REF, 0))
#define	pmap_is_modified(pa)	 (ptebits((pa), PTE_CHG))
#define	pmap_is_referenced(pa) (ptebits((pa), PTE_REF))
#define	pmap_unwire(pm, va)
#endif
a89 8
/*
 * Alternate mapping methods for pool.
 * Really simple. 0x0->0x80000000 contain 1->1 mappings of the physical
 * memory.
 */
#define PMAP_MAP_POOLPAGE(pa)	((vaddr_t)pa)
#define PMAP_UNMAP_POOLPAGE(va)	((paddr_t)va)

a90 5

void pmap_deactivate __P((struct proc *p));
void pmap_activate __P((struct proc *p));
void pmap_real_memory __P((vm_offset_t *start, vm_size_t *size));
void switchexit __P((struct proc *));
@


1.3.14.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.3.14.2 2001/07/04 10:22:27 niklas Exp $	*/
d35 2
a36 2
#ifndef	_POWERPC_PMAP_H_
#define	_POWERPC_PMAP_H_
d41 4
a67 8
void pmap_kenter_cache( vaddr_t va, paddr_t pa, vm_prot_t prot, int cacheable);

/* cache flags */
#define PMAP_CACHE_DEFAULT	0 	/* WB cache managed mem, devices not */
#define PMAP_CACHE_CI		1 	/* cache inhibit */
#define PMAP_CACHE_WT		2 	/* writethru */
#define PMAP_CACHE_WB		3	/* writeback */

d79 1
a79 1
boolean_t ptemodify(paddr_t pa, u_int mask, u_int val);
d87 11
a97 4
#define pmap_clear_modify(page)	 (ptemodify(VM_PAGE_TO_PHYS(page), PTE_CHG, 0))
#define	pmap_clear_reference(page) (ptemodify(VM_PAGE_TO_PHYS(page), PTE_REF, 0))
#define	pmap_is_modified(page)	 (ptebits(VM_PAGE_TO_PHYS(page), PTE_CHG))
#define	pmap_is_referenced(page) (ptebits(VM_PAGE_TO_PHYS(page), PTE_REF))
d99 2
d115 2
d122 1
a122 1
#endif	/* _POWERPC_PMAP_H_ */
@


1.3.14.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a108 3

void pmap_pinit __P((struct pmap *));
void pmap_release __P((struct pmap *));
@


1.3.14.5
log
@repair
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.3.14.4 2001/11/13 21:04:16 niklas Exp $	*/
@


1.3.14.6
log
@Re-add missing pieces
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.25 2002/03/14 01:26:42 millert Exp $	*/
d50 1
a50 11
/*
 * bit 
 *   3  2 2  2    2 1  1 1  1 1            0
 *   1  8 7  4    0 9  6 5  2 1            0
 *  |XXXX|XXXX XXXX|XXXX XXXX|XXXX XXXX XXXX
 *
 *  bits 28 - 31 contain SR
 *  bits 20 - 27 contain L1 for VtoP translation
 *  bits 12 - 19 contain L2 for VtoP translation
 *  bits  0 - 11 contain page offset
 */
d53 2
a54 2
typedef struct pmapvp pmapvp_t;
#define VP_SR_SIZE	16
d56 2
a57 2
#define VP_SR_POS 	28
#define VP_IDX1_SIZE	256
d59 2
a60 2
#define VP_IDX1_POS 	20
#define VP_IDX2_SIZE	256
a76 1
	pmapvp_t *pm_vp[VP_SR_SIZE];	/* virtual to physical table */
d78 1
d83 1
d88 1
a88 1
boolean_t pteclrbits(paddr_t pa, u_int mask, u_int clear);
d91 4
a94 8
#define pmap_clear_modify(page) \
	(pteclrbits(VM_PAGE_TO_PHYS(page), PTE_CHG, TRUE))
#define	pmap_clear_reference(page) \
	(pteclrbits(VM_PAGE_TO_PHYS(page), PTE_REF, TRUE))
#define	pmap_is_modified(page) \
	(pteclrbits(VM_PAGE_TO_PHYS(page), PTE_CHG, FALSE))
#define	pmap_is_referenced(page) \
	(pteclrbits(VM_PAGE_TO_PHYS(page), PTE_REF, FALSE))
a96 1
#define pmap_update(pmap)	/* nothing (yet) */
d103 1
a103 1
 * memory. - XXX
d105 2
a106 4
#define PMAP_MAP_POOLPAGE(pa) ((vaddr_t)pa)
#define PMAP_UNMAP_POOLPAGE(va)       ((paddr_t)va)

void pmap_bootstrap(u_int kernelstart, u_int kernelend);
d108 1
a108 2
void pmap_pinit(struct pmap *);
void pmap_release(struct pmap *);
d110 2
a111 2
void pmap_real_memory(vm_offset_t *start, vm_size_t *size);
void switchexit(struct proc *);
d113 2
a114 2
int pte_spill_v(struct pmap *pm, u_int32_t va, u_int32_t dsisr);
#define pmap_copy(dst_pmap, src_pmap, dst_addr, len, src_addr) ;
@


1.3.14.7
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a48 1
#define SR_NOEXEC	0x10000000
d63 1
d87 1
a87 2
	struct pmapvp *pm_vp[VP_SR_SIZE];	/* virtual to physical table */
	u_int32_t pm_exec[16];	/* segments used in this pmap */
d119 2
a120 2
#define PMAP_MAP_POOLPAGE(pg)		((vaddr_t)VM_PAGE_TO_PHYS(pg))
#define PMAP_UNMAP_POOLPAGE(va)		PHYS_TO_VM_PAGE((paddr_t)va)
d130 1
a130 1
int pte_spill_v(struct pmap *pm, u_int32_t va, u_int32_t dsisr, int exec_fault);
@


1.3.14.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d74 1
a74 3
/* functions used by the bus layer for device accesses */
void pmap_kenter_cache(vaddr_t va, paddr_t pa, vm_prot_t prot, int cacheable);
void pmap_kremove_pg(vaddr_t va);
@


1.3.14.9
log
@Merge with the trunk
@
text
@a135 2
void pmap_proc_iflush(struct proc *proc, vaddr_t va, vsize_t len);

@


1.3.14.10
log
@sync with head, make i386 __HAVE_CPUINFO
@
text
@d122 2
a123 2
#define pmap_map_direct(pg)		((vaddr_t)VM_PAGE_TO_PHYS(pg))
#define pmap_unmap_direct(va)		PHYS_TO_VM_PAGE((paddr_t)va)
@


1.2
log
@adding OpenBSD tag to files.
@
text
@d1 1
a1 1
/*	$OpenBSD:$	*/
d58 1
d74 2
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@Check-in of powerpc kernel support.
NOTE: This will not work until the other pieces are checked in.
This is primarily the NetBSD powerpc port, with modifications
to support ELF. 
@
text
@@
