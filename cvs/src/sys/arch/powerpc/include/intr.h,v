head	1.53;
access;
symbols
	OPENBSD_6_2_BASE:1.53
	OPENBSD_6_1:1.52.0.8
	OPENBSD_6_1_BASE:1.52
	OPENBSD_6_0:1.52.0.4
	OPENBSD_6_0_BASE:1.52
	OPENBSD_5_9:1.52.0.2
	OPENBSD_5_9_BASE:1.52
	OPENBSD_5_8:1.51.0.4
	OPENBSD_5_8_BASE:1.51
	OPENBSD_5_7:1.50.0.2
	OPENBSD_5_7_BASE:1.50
	OPENBSD_5_6:1.49.0.8
	OPENBSD_5_6_BASE:1.49
	OPENBSD_5_5:1.49.0.6
	OPENBSD_5_5_BASE:1.49
	OPENBSD_5_4:1.49.0.2
	OPENBSD_5_4_BASE:1.49
	OPENBSD_5_3:1.48.0.2
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.47.0.4
	OPENBSD_5_2_BASE:1.47
	OPENBSD_5_1_BASE:1.47
	OPENBSD_5_1:1.47.0.2
	OPENBSD_5_0:1.46.0.4
	OPENBSD_5_0_BASE:1.46
	OPENBSD_4_9:1.46.0.2
	OPENBSD_4_9_BASE:1.46
	OPENBSD_4_8:1.44.0.2
	OPENBSD_4_8_BASE:1.44
	OPENBSD_4_7:1.43.0.2
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.41.0.4
	OPENBSD_4_6_BASE:1.41
	OPENBSD_4_5:1.38.0.2
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.34.0.4
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.34.0.2
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.31.0.4
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.31.0.2
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.29.0.4
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.29.0.2
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.26.0.2
	OPENBSD_3_6_BASE:1.26
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.25.0.2
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.21.0.4
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.21
	UBC:1.13.0.2
	UBC_BASE:1.13
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.3.0.6
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.1.0.4
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.2
	OPENBSD_2_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.53
date	2017.07.25.03.46.59;	author visa;	state Exp;
branches;
next	1.52;
commitid	iDGc7nomftBxJjyX;

1.52
date	2015.09.13.14.06.40;	author kettenis;	state Exp;
branches;
next	1.51;
commitid	nd1GrmzGVu0nRnyw;

1.51
date	2015.06.24.11.58.06;	author mpi;	state Exp;
branches;
next	1.50;
commitid	ydQ89S8LGKdOdYT1;

1.50
date	2015.01.04.13.01.42;	author mpi;	state Exp;
branches;
next	1.49;
commitid	NhpbICTczAMSUxav;

1.49
date	2013.05.17.19.38.52;	author kettenis;	state Exp;
branches;
next	1.48;

1.48
date	2012.08.21.09.24.52;	author kettenis;	state Exp;
branches;
next	1.47;

1.47
date	2011.08.29.20.21.43;	author drahn;	state Exp;
branches;
next	1.46;

1.46
date	2011.01.08.18.10.20;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2010.12.21.14.56.24;	author claudio;	state Exp;
branches;
next	1.44;

1.44
date	2010.04.23.03.50.22;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2009.10.01.20.19.19;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.41;

1.41
date	2009.06.09.01.12.38;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2009.06.02.21.38.10;	author drahn;	state Exp;
branches;
next	1.39;

1.39
date	2009.03.15.19.40.40;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2008.11.21.17.35.52;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2008.09.19.01.42.05;	author drahn;	state Exp;
branches;
next	1.36;

1.36
date	2008.09.18.03.56.25;	author drahn;	state Exp;
branches;
next	1.35;

1.35
date	2008.09.16.04.20.42;	author drahn;	state Exp;
branches;
next	1.34;

1.34
date	2007.11.14.20.33.32;	author thib;	state Exp;
branches;
next	1.33;

1.33
date	2007.05.19.10.20.57;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2007.03.20.20.59.53;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.12.02.55.58;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.11.15.07.29;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2005.04.19.15.29.48;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2004.12.24.22.50.30;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2004.10.01.15.07.36;	author drahn;	state Exp;
branches;
next	1.26;

1.26
date	2004.06.28.02.49.10;	author aaron;	state Exp;
branches;
next	1.25;

1.25
date	2003.10.31.03.04.16;	author drahn;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.19.21.57.35;	author drahn;	state Exp;
branches;
next	1.23;

1.23
date	2003.07.14.19.23.52;	author drahn;	state Exp;
branches;
next	1.22;

1.22
date	2003.07.14.18.56.12;	author drahn;	state Exp;
branches;
next	1.21;

1.21
date	2002.09.15.09.01.59;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2002.09.15.02.02.44;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.23.17.53.25;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.29.07.35.22;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.26.42;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.26.15.22.52;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.21.17.20.22;	author drahn;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.21.17.18.46;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.19.05.13.50;	author drahn;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.09.01.15.49.05;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.24.23.26.29;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.24.17.05.38;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.24.04.41.37;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.29.18.47.18;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.07.13.22.42;	author rahnds;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.06.15.29.53;	author ho;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.31.04.16.34;	author rahnds;	state Exp;
branches;
next	1.4;

1.4
date	99.11.09.04.13.54;	author rahnds;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	98.10.09.02.06.40;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	98.08.25.06.53.19;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	97.10.13.10.53.45;	author pefo;	state Exp;
branches;
next	;

1.4.2.1
date	2001.04.18.16.13.02;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2001.07.04.10.22.24;	author niklas;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2001.10.31.03.07.55;	author nate;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2001.11.13.22.14.34;	author niklas;	state dead;
branches;
next	1.4.2.5;

1.4.2.5
date	2002.03.29.16.11.59;	author niklas;	state Exp;
branches;
next	1.4.2.6;

1.4.2.6
date	2003.03.27.23.42.35;	author niklas;	state Exp;
branches;
next	1.4.2.7;

1.4.2.7
date	2004.02.19.10.49.57;	author niklas;	state Exp;
branches;
next	;

1.13.2.1
date	2002.01.31.22.55.21;	author niklas;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2002.06.11.03.37.28;	author art;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2002.10.29.00.28.08;	author art;	state Exp;
branches;
next	;


desc
@@


1.53
log
@Remove leftovers of a past softintr mechanism.

OK mpi@@, kettenis@@
@
text
@/*	$OpenBSD: intr.h,v 1.52 2015/09/13 14:06:40 kettenis Exp $ */

/*
 * Copyright (c) 1997 Per Fogelstrom, Opsycon AB and RTMX Inc, USA.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Per Fogelstrom, Opsycon AB, Sweden for RTMX Inc, North Carolina USA.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#ifndef _POWERPC_INTR_H_
#define _POWERPC_INTR_H_

#define	IPL_NONE	0
#define	IPL_SOFT	1
#define	IPL_SOFTCLOCK	2
#define	IPL_SOFTNET	3
#define	IPL_SOFTTTY	4
#define	IPL_BIO		5
#define	IPL_NET		6
#define	IPL_TTY		7
#define	IPL_VM		8
#define	IPL_AUDIO	9
#define	IPL_CLOCK	10
#define	IPL_SCHED	11
#define	IPL_HIGH	12
#define	IPL_NUM		13

#define	IPL_MPSAFE	0x100

#define	IST_NONE	0
#define	IST_PULSE	1
#define	IST_EDGE	2
#define	IST_LEVEL	3

#if defined(_KERNEL) && !defined(_LOCORE)

#include <sys/evcount.h>
#include <machine/atomic.h>

#define	PPC_NIRQ	66
#define	PPC_CLK_IRQ	64
#define	PPC_STAT_IRQ	65

int	splraise(int);
int	spllower(int);
void	splx(int);

typedef int (ppc_splraise_t) (int);
typedef int (ppc_spllower_t) (int);
typedef void (ppc_splx_t) (int);

extern struct ppc_intr_func {
	ppc_splraise_t *raise;
	ppc_spllower_t *lower;
	ppc_splx_t *x;
}ppc_intr_func;

extern int ppc_smask[IPL_NUM];

void ppc_smask_init(void);
char *ppc_intr_typename(int type);

void do_pending_int(void);

/* SPL asserts */
#ifdef DIAGNOSTIC
/*
 * Although this function is implemented in MI code, it must be in this MD
 * header because we don't want this header to include MI includes.
 */
void splassert_fail(int, int, const char *);
extern int splassert_ctl;
void splassert_check(int, const char *);
#define splassert(__wantipl) do {			\
	if (splassert_ctl > 0) {			\
		splassert_check(__wantipl, __func__);	\
	}						\
} while (0)
#define splsoftassert(wantipl) splassert(wantipl)
#else
#define splassert(wantipl)	do { /* nada */ } while (0)
#define splsoftassert(wantipl)	do { /* nada */ } while (0)
#endif

#define	set_sint(p)	atomic_setbits_int(&curcpu()->ci_ipending, p)

#define	splbio()	splraise(IPL_BIO)
#define	splnet()	splraise(IPL_NET)
#define	spltty()	splraise(IPL_TTY)
#define	splaudio()	splraise(IPL_AUDIO)
#define	splclock()	splraise(IPL_CLOCK)
#define	splvm()		splraise(IPL_VM)
#define	splsched()	splhigh()
#define	spllock()	splhigh()
#define	splstatclock()	splhigh()
#define	splsoftclock()	splraise(IPL_SOFTCLOCK)
#define	splsoftnet()	splraise(IPL_SOFTNET)
#define	splsofttty()	splraise(IPL_SOFTTTY)

#define	SI_TO_IRQBIT(x) (1 << (x))

#define	SI_SOFTCLOCK		0	/* for IPL_SOFTCLOCK */
#define	SI_SOFTNET		1	/* for IPL_SOFTNET */
#define	SI_SOFTTTY		2	/* for IPL_SOFTSERIAL */

#define	SI_NQUEUES		3

#include <machine/mutex.h>
#include <sys/queue.h>

struct soft_intrhand {
	TAILQ_ENTRY(soft_intrhand) sih_list;
	void	(*sih_func)(void *);
	void	*sih_arg;
	struct soft_intrq *sih_siq;
	int	sih_pending;
};

struct soft_intrq {
	TAILQ_HEAD(, soft_intrhand) siq_list;
	int siq_si;
	struct mutex siq_mtx;
};

void	softintr_disestablish(void *);
void	softintr_dispatch(int);
void	*softintr_establish(int, void (*)(void *), void *);
void	softintr_init(void);

void	softintr_schedule(void *);
void	dosoftint(int);

#define	splhigh()	splraise(IPL_HIGH)
#define	spl0()		spllower(IPL_NONE)

/*
 *	Interrupt control struct used to control the ICU setup.
 */

struct intrhand {
	TAILQ_ENTRY(intrhand) ih_list;
	int		(*ih_fun)(void *);
	void		*ih_arg;
	struct evcount	ih_count;
	int		ih_type;
	int		ih_level;
	int		ih_flags;
	int		ih_irq;
	const char	*ih_what;
};

struct intrq {
	TAILQ_HEAD(, intrhand) iq_list; /* handler list */
	int iq_ipl;			/* IPL_ to mask while handling */
	int iq_ist;			/* share type */
};

extern int ppc_configed_intr_cnt;
#define	MAX_PRECONF_INTR 16
extern struct intrhand ppc_configed_intr[MAX_PRECONF_INTR];

void intr_barrier(void *);

#define PPC_IPI_NOP		0
#define PPC_IPI_DDB		1

void ppc_send_ipi(struct cpu_info *, int);

#endif /* _LOCORE */
#endif /* _POWERPC_INTR_H_ */
@


1.52
log
@intr_barrier(9) for macppc and socppc.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.51 2015/06/24 11:58:06 mpi Exp $ */
a157 4
#define	setsoftclock()	set_sint(SI_TO_IRQBIT(SI_SOFTCLOCK))
#define	setsoftnet()	set_sint(SI_TO_IRQBIT(SI_SOFTNET))
#define	setsofttty()	set_sint(SI_TO_IRQBIT(SI_SOFTTTY))
 
@


1.51
log
@IPL_MPSAFE bits for macppc with openpic(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.50 2015/01/04 13:01:42 mpi Exp $ */
a149 1

d190 2
@


1.50
log
@Implement splassert(9) for powerpc.

This changes the logic to prevent a recursion when processing soft
interrupts.  Previously a per-CPU flag was set before re-enabling
interrupts.  Now the IPL level is raised to SOFTTTY which makes
splsoftassert() happy, greatly inspired by mips64.

As a side effect, the ppc_intr_{disable,enable}() dance is now done
only once instead of twice per splx(9).

While here, make use of dosoftint() instead of having 3 different
functions for dispatching soft interrupts.

Tested by deraadt@@ on G4 smp and by myself G5 smp, G3, G4 and socppc.

No objection from the usual (and over busy) suspects.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.49 2013/05/17 19:38:52 kettenis Exp $ */
a43 1
#define	IPL_AUDIO	IPL_BIO /* XXX - was defined this val in audio_if.h */
d47 5
a51 4
#define	IPL_CLOCK	9
#define	IPL_SCHED	10
#define	IPL_HIGH	11
#define	IPL_NUM		12
d53 1
a53 1
#define	IPL_MPSAFE	0	/* no "mpsafe" interrupts */
a158 2
#define	set_sint(p)	atomic_setbits_int(&curcpu()->ci_ipending, p)

d177 1
@


1.49
log
@Add a dummy IPL_MPSAFE definition.

ok miod@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.48 2012/08/21 09:24:52 kettenis Exp $ */
d91 18
a108 2
#define	splassert(wantipl)	/* nothing */
#define	splsoftassert(wantipl)	/* nothing */
d157 1
@


1.48
log
@For interrupts that get established before we attach the interrupt controller,
store the type of the interrupt (level, edge).

ok miod@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.47 2011/08/29 20:21:43 drahn Exp $ */
d52 2
@


1.47
log
@Return of the long missing powerpc interrupt rewrite.  Was working for
several weeks before release on macppc, socppc bugs just fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.46 2011/01/08 18:10:20 deraadt Exp $ */
d158 1
@


1.46
log
@rename imask[] to cpu_imask[] to because imask is too loud as far as
kernel namespace
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.45 2010/12/21 14:56:24 claudio Exp $ */
d5 1
a5 1
 * 
d39 5
a43 1
#define	IPL_BIO		1
d45 7
a51 7
#define	IPL_NET		2
#define	IPL_TTY		3
#define	IPL_VM		4
#define	IPL_CLOCK	5
#define	IPL_SCHED	6
#define	IPL_HIGH	6
#define	IPL_NUM		7
d63 3
a65 3
#define PPC_NIRQ	66
#define PPC_CLK_IRQ	64
#define PPC_STAT_IRQ	65
d71 14
a87 2
extern int cpu_imask[IPL_NUM];

d92 1
a92 6
#define SINTBIT(q)	(31 - (q))
#define SINTMASK(q)	(1 << SINTBIT(q))

#define	SPL_CLOCKMASK	SINTMASK(SI_NQUEUES)

/* Soft interrupt masks. */
d94 18
a111 3
#define	IPL_SOFTCLOCK	0
#define	IPL_SOFTNET	1
#define	IPL_SOFTTTY	2
d113 1
a113 7
#define	SI_SOFTCLOCK	0	/* for IPL_SOFTCLOCK */
#define	SI_SOFTNET	1	/* for IPL_SOFTNET */
#define	SI_SOFTTTY	2	/* for IPL_SOFTTY */

#define	SINT_ALLMASK	(SINTMASK(SI_SOFTCLOCK) | \
			 SINTMASK(SI_SOFTNET) | SINTMASK(SI_SOFTTTY))
#define	SI_NQUEUES	3
d132 3
a134 2
void	 softintr_disestablish(void *);
void	 softintr_dispatch(int);
d136 3
a138 2
void	 softintr_init(void);
void	 softintr_schedule(void *);
d140 1
a140 16
#define	SINT_CLOCK	SINTMASK(SI_SOFTCLOCK)
#define	SINT_NET	SINTMASK(SI_SOFTNET)
#define	SINT_TTY	SINTMASK(SI_SOFTTTY)

#define splbio()	splraise(cpu_imask[IPL_BIO])
#define splnet()	splraise(cpu_imask[IPL_NET])
#define spltty()	splraise(cpu_imask[IPL_TTY])
#define splaudio()	splraise(cpu_imask[IPL_AUDIO])
#define splclock()	splraise(cpu_imask[IPL_CLOCK])
#define splvm()		splraise(cpu_imask[IPL_VM])
#define splsched()	splhigh()
#define spllock()	splhigh()
#define splstatclock()	splhigh()
#define	splsoftclock()	splraise(SINT_CLOCK)
#define	splsoftnet()	splraise(SINT_NET|SINT_CLOCK)
#define	splsofttty()	splraise(SINT_TTY|SINT_NET|SINT_CLOCK)
d142 6
a147 2
#define	splhigh()	splraise(0xffffffff)
#define	spl0()		spllower(0)
d154 1
a154 1
	struct intrhand	*ih_next;
d162 7
d170 1
a170 1
#define MAX_PRECONF_INTR 16
a171 1
void softnet(int isr);
@


1.45
log
@Convert netisr to a normal soft interrupt instead of hanving MD code
for it. This makes the netisr a real C function which will help further
development. No noticable performance change on i386 and amd64.
With input from kettenis@@ and miod@@ additional OKs mikeb@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.44 2010/04/23 03:50:22 miod Exp $ */
d70 1
a70 1
extern int imask[IPL_NUM];
d122 6
a127 6
#define splbio()	splraise(imask[IPL_BIO])
#define splnet()	splraise(imask[IPL_NET])
#define spltty()	splraise(imask[IPL_TTY])
#define splaudio()	splraise(imask[IPL_AUDIO])
#define splclock()	splraise(imask[IPL_CLOCK])
#define splvm()		splraise(imask[IPL_VM])
@


1.44
log
@Make sure IPL_SCHED is always defined by MD headers, instead of having a MI
fallback definition in <sys/sched.h>, so that there is no hidden include
ordering requirement between <machine/intr.h> and <sys/sched.h>.
ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.43 2009/10/01 20:19:19 kettenis Exp $ */
a116 5

/* XXX For legacy software interrupts. */
extern struct soft_intrhand *softnet_intrhand;

#define	setsoftnet()	softintr_schedule(softnet_intrhand)
@


1.43
log
@Generic soft interrupts for macppc.  Tested by mk@@, deraadt@@
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.42 2009/08/22 02:54:50 mk Exp $ */
d45 1
@


1.42
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.41 2009/06/09 01:12:38 deraadt Exp $ */
a61 7
void setsoftclock(void);
void clearsoftclock(void);
int  splsoftclock(void);
void setsoftnet(void);
void clearsoftnet(void);
int  splsoftnet(void);

d75 4
a78 1
#define	set_sint(p)	atomic_setbits_int(&curcpu()->ci_ipending, p)
d80 45
a124 5
#define	SINT_CLOCK	0x10000000
#define	SINT_NET	0x20000000
#define	SINT_TTY	0x40000000
#define	SPL_CLOCK	0x80000000
#define	SINT_MASK	(SINT_CLOCK|SINT_NET|SINT_TTY)
a137 4

#define	setsoftclock()	set_sint(SINT_CLOCK);
#define	setsoftnet()	set_sint(SINT_NET);
#define	setsofttty()	set_sint(SINT_TTY);
@


1.41
log
@backout interrupt diff until it the next round of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.39 2009/03/15 19:40:40 miod Exp $ */
d121 1
a121 1
	char		*ih_what;
@


1.40
log
@Reintroduce the macppc interrupt subsystem rewrite. Several bugs have
been found and corrected.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.37 2008/09/19 01:42:05 drahn Exp $ */
d5 1
a5 1
 *
d39 1
a39 5
#define	IPL_SOFT	1
#define	IPL_SOFTCLOCK	2
#define	IPL_SOFTNET	3
#define	IPL_SOFTTTY	4
#define	IPL_BIO		5
d41 6
a46 6
#define	IPL_NET		6
#define	IPL_TTY		7
#define	IPL_VM		8
#define	IPL_CLOCK	9
#define	IPL_HIGH	10
#define	IPL_NUM		11
d58 3
a60 3
#define	PPC_NIRQ	66
#define	PPC_CLK_IRQ	64
#define	PPC_STAT_IRQ	65
a72 9
typedef int (ppc_splraise_t) (int);
typedef int (ppc_spllower_t) (int);
typedef void (ppc_splx_t) (int);

extern struct ppc_intr_func {
	ppc_splraise_t *raise;
	ppc_spllower_t *lower;
	ppc_splx_t *x;
}ppc_intr_func;
d74 1
a74 1
extern int ppc_smask[IPL_NUM];
d76 1
a76 4
void ppc_smask_init(void);
char *ppc_intr_typename(int type);

void do_pending_int(void);
d84 25
a108 19
#define	splbio()	splraise(IPL_BIO)
#define	splnet()	splraise(IPL_NET)
#define	spltty()	splraise(IPL_TTY)
#define	splaudio()	splraise(IPL_AUDIO)
#define	splclock()	splraise(IPL_CLOCK)
#define	splvm()		splraise(IPL_VM)
#define	splsched()	splhigh()
#define	spllock()	splhigh()
#define	splstatclock()	splhigh()
#define	splsoftclock()	splraise(IPL_SOFTCLOCK)
#define	splsoftnet()	splraise(IPL_SOFTNET)
#define	splsofttty()	splraise(IPL_SOFTTTY)

#define	setsoftclock()	set_sint(SI_TO_IRQBIT(SI_SOFTCLOCK))
#define	setsoftnet()	set_sint(SI_TO_IRQBIT(SI_SOFTNET))
#define	setsofttty()	set_sint(SI_TO_IRQBIT(SI_SOFTTTY))
 
#define	splhigh()	splraise(IPL_HIGH)
#define	spl0()		spllower(IPL_NONE)
d115 1
a115 1
	TAILQ_ENTRY(intrhand) ih_list;
a122 7

struct intrq {
	TAILQ_HEAD(, intrhand) iq_list; /* handler list */
	int iq_ipl;			/* IPL_ to mask while handling */
	int iq_ist;			/* share type */
};

d124 1
a124 1
#define	MAX_PRECONF_INTR 16
a126 18

#define	SI_TO_IRQBIT(x) (1 << (x))

#define	SI_SOFT			0	/* for IPL_SOFT */
#define	SI_SOFTCLOCK		1	/* for IPL_SOFTCLOCK */
#define	SI_SOFTNET		2	/* for IPL_SOFTNET */
#define	SI_SOFTTTY		3	/* for IPL_SOFTSERIAL */

#if 0
#define	SI_NQUEUES		4

#define SI_QUEUENAMES {		\
	"generic",		\
	"clock",		\
	"net",			\
	"serial",		\
}
#endif
@


1.39
log
@Introduce splsoftassert(), similar to splassert() but for soft interrupt
levels. This will allow for platforms where soft interrupt levels do not
map to real hardware interrupt levels to have soft ipl values overlapping
hard ipl values without breaking spl asserts.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.38 2008/11/21 17:35:52 deraadt Exp $ */
d5 1
a5 1
 * 
d39 5
a43 1
#define	IPL_BIO		1
d45 6
a50 6
#define	IPL_NET		2
#define	IPL_TTY		3
#define	IPL_VM		4
#define	IPL_CLOCK	5
#define	IPL_HIGH	6
#define	IPL_NUM		7
d62 3
a64 3
#define PPC_NIRQ	66
#define PPC_CLK_IRQ	64
#define PPC_STAT_IRQ	65
d77 14
a93 2
extern int imask[IPL_NUM];

d100 19
a118 25
#define	SINT_CLOCK	0x10000000
#define	SINT_NET	0x20000000
#define	SINT_TTY	0x40000000
#define	SPL_CLOCK	0x80000000
#define	SINT_MASK	(SINT_CLOCK|SINT_NET|SINT_TTY)

#define splbio()	splraise(imask[IPL_BIO])
#define splnet()	splraise(imask[IPL_NET])
#define spltty()	splraise(imask[IPL_TTY])
#define splaudio()	splraise(imask[IPL_AUDIO])
#define splclock()	splraise(imask[IPL_CLOCK])
#define splvm()		splraise(imask[IPL_VM])
#define splsched()	splhigh()
#define spllock()	splhigh()
#define splstatclock()	splhigh()
#define	splsoftclock()	splraise(SINT_CLOCK)
#define	splsoftnet()	splraise(SINT_NET|SINT_CLOCK)
#define	splsofttty()	splraise(SINT_TTY|SINT_NET|SINT_CLOCK)

#define	setsoftclock()	set_sint(SINT_CLOCK);
#define	setsoftnet()	set_sint(SINT_NET);
#define	setsofttty()	set_sint(SINT_TTY);

#define	splhigh()	splraise(0xffffffff)
#define	spl0()		spllower(0)
d125 1
a125 1
	struct intrhand	*ih_next;
d133 7
d141 1
a141 1
#define MAX_PRECONF_INTR 16
d144 18
@


1.38
log
@back out the new interrupt subsystem because some little bug still lurks in there
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.35 2008/09/16 04:20:42 drahn Exp $ */
d80 1
@


1.37
log
@miod pointed out that some items were multiply defined (patched into
existance too many times).
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.36 2008/09/18 03:56:25 drahn Exp $ */
d39 1
a39 5
#define	IPL_SOFT	1
#define	IPL_SOFTCLOCK	2
#define	IPL_SOFTNET	3
#define	IPL_SOFTTTY	4
#define	IPL_BIO		5
d41 6
a46 6
#define	IPL_NET		6
#define	IPL_TTY		7
#define	IPL_VM		8
#define	IPL_CLOCK	9
#define	IPL_HIGH	10
#define	IPL_NUM		11
d58 3
a60 3
#define	PPC_NIRQ	66
#define	PPC_CLK_IRQ	64
#define	PPC_STAT_IRQ	65
a72 16
typedef int (ppc_splraise_t) (int);
typedef int (ppc_spllower_t) (int);
typedef void (ppc_splx_t) (int);

extern struct ppc_intr_func {
	ppc_splraise_t *raise;
	ppc_spllower_t *lower;
	ppc_splx_t *x;
}ppc_intr_func;

#if 0
/* does it make sense to call directly ?? */
#define	splraise(x)	ppc_intr.raise(x)
#define	spllower(x)	ppc_intr.lower(x)
#define	splx(x)		ppc_intr.x(x)
#endif
d74 1
a74 4
extern int ppc_smask[IPL_NUM];

void ppc_smask_init(void);
char *ppc_intr_typename(int type);
d76 1
a76 1
void do_pending_int(void);
a82 1
#if 0
a87 1
#endif
d89 16
a104 16
#define	splbio()	splraise(IPL_BIO)
#define	splnet()	splraise(IPL_NET)
#define	spltty()	splraise(IPL_TTY)
#define	splaudio()	splraise(IPL_AUDIO)
#define	splclock()	splraise(IPL_CLOCK)
#define	splvm()		splraise(IPL_VM)
#define	splsched()	splhigh()
#define	spllock()	splhigh()
#define	splstatclock()	splhigh()
#define	splsoftclock()	splraise(IPL_SOFTCLOCK)
#define	splsoftnet()	splraise(IPL_SOFTNET)
#define	splsofttty()	splraise(IPL_SOFTTTY)

#define	setsoftclock()	set_sint(SI_TO_IRQBIT(SI_SOFTCLOCK))
#define	setsoftnet()	set_sint(SI_TO_IRQBIT(SI_SOFTNET))
#define	setsofttty()	set_sint(SI_TO_IRQBIT(SI_SOFTTTY))
d106 2
a107 2
#define	splhigh()	splraise(IPL_HIGH)
#define	spl0()		spllower(IPL_NONE)
d114 1
a114 1
	TAILQ_ENTRY(intrhand) ih_list;
a121 7

struct intrq {
	TAILQ_HEAD(, intrhand) iq_list; /* handler list */
	int iq_ipl;			/* IPL_ to mask while handling */ 
	int iq_ist;			/* share type */
};

d123 1
a123 1
#define	MAX_PRECONF_INTR 16
a125 16

#define	SI_TO_IRQBIT(x) (1 << (x))

#define	SI_SOFT			0	/* for IPL_SOFT */
#define	SI_SOFTCLOCK		1	/* for IPL_SOFTCLOCK */
#define	SI_SOFTNET		2	/* for IPL_SOFTNET */
#define	SI_SOFTTTY		3	/* for IPL_SOFTSERIAL */

#define	SI_NQUEUES		4

#define SI_QUEUENAMES {		\
	"generic",		\
	"clock",		\
	"net",			\
	"serial",		\
}
@


1.36
log
@Redesign of the powerpc interrupt architecture, use true levels intead of
blocking specific interrupts. Needs signficant testing to prove that
one remaining elusive bug has been squashed.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.35 2008/09/16 04:20:42 drahn Exp $ */
a173 5

#define PPC_IPI_NOP		0
#define PPC_IPI_DDB		1

void ppc_send_ipi(struct cpu_info *, int);
@


1.35
log
@SMP ddb support, with some feedback from kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.34 2007/11/14 20:33:32 thib Exp $ */
d39 5
a43 1
#define	IPL_BIO		1
d45 6
a50 6
#define	IPL_NET		2
#define	IPL_TTY		3
#define	IPL_VM		4
#define	IPL_CLOCK	5
#define	IPL_HIGH	6
#define	IPL_NUM		7
d62 3
a64 3
#define PPC_NIRQ	66
#define PPC_CLK_IRQ	64
#define PPC_STAT_IRQ	65
d77 21
a100 2
extern int imask[IPL_NUM];

d106 1
d112 1
d114 16
a129 16
#define splbio()	splraise(imask[IPL_BIO])
#define splnet()	splraise(imask[IPL_NET])
#define spltty()	splraise(imask[IPL_TTY])
#define splaudio()	splraise(imask[IPL_AUDIO])
#define splclock()	splraise(imask[IPL_CLOCK])
#define splvm()		splraise(imask[IPL_VM])
#define splsched()	splhigh()
#define spllock()	splhigh()
#define splstatclock()	splhigh()
#define	splsoftclock()	splraise(SINT_CLOCK)
#define	splsoftnet()	splraise(SINT_NET|SINT_CLOCK)
#define	splsofttty()	splraise(SINT_TTY|SINT_NET|SINT_CLOCK)

#define	setsoftclock()	set_sint(SINT_CLOCK);
#define	setsoftnet()	set_sint(SINT_NET);
#define	setsofttty()	set_sint(SINT_TTY);
d131 2
a132 2
#define	splhigh()	splraise(0xffffffff)
#define	spl0()		spllower(0)
d139 1
a139 1
	struct intrhand	*ih_next;
d147 7
d155 1
a155 1
#define MAX_PRECONF_INTR 16
d158 21
@


1.34
log
@Turn the spl* macros into functions.
Shaves a few bytes of the kernel.
No measurable performance loss.

ok drahn@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.33 2007/05/19 10:20:57 miod Exp $ */
d126 5
@


1.33
log
@Use atomic operations in set_sint() instead of disabling interrupts in the
function. ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.32 2007/03/20 20:59:53 kettenis Exp $ */
d69 5
a79 45

/*
 * Reorder protection in the following inline functions is
 * achived with an empty asm volatile statement. the compiler
 * will not move instructions past asm volatiles.
 */
volatile static __inline int
splraise(int newcpl)
{
	struct cpu_info *ci = curcpu();
	int oldcpl;

	__asm__ volatile("":::"memory");	/* don't reorder.... */
	oldcpl = ci->ci_cpl;
	ci->ci_cpl = oldcpl | newcpl;
	__asm__ volatile("":::"memory");	/* don't reorder.... */
	return(oldcpl);
}

volatile static __inline void
splx(int newcpl)
{
	struct cpu_info *ci = curcpu();

	__asm__ volatile("":::"memory");	/* reorder protect */
	ci->ci_cpl = newcpl;
	if(ci->ci_ipending & ~newcpl)
		do_pending_int();
	__asm__ volatile("":::"memory");	/* reorder protect */
}

volatile static __inline int
spllower(int newcpl)
{
	struct cpu_info *ci = curcpu();
	int oldcpl;

	__asm__ volatile("":::"memory");	/* reorder protect */
	oldcpl = ci->ci_cpl;
	ci->ci_cpl = newcpl;
	if(ci->ci_ipending & ~newcpl)
		do_pending_int();
	__asm__ volatile("":::"memory");	/* reorder protect */
	return(oldcpl);
}
@


1.32
log
@Move macppc to __HAVE_CPUINFO, and make locore.S and trap.c suitable for
MULTIPROCESSOR.  From now on sprg0 holds a pointer to struct cpuinfo, which
is used to spill registers to during trap instead of the globals we used to
use for that purpose.  Bits and pieces from NetBSD.  Help from drahn@@ and art@@.
Tested by xsa@@, thib@@, miod@@, gwk@@, deraadt@@.

ok drahn@@, gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.31 2006/03/12 02:55:58 brad Exp $ */
d56 1
a70 1

d121 1
a121 13
/* Following code should be implemented with lwarx/stwcx to avoid
 * the disable/enable. i need to read the manual once more.... */
static __inline void
set_sint(int pending)
{
	struct cpu_info *ci = curcpu();
	int	msrsave;

	__asm__ ("mfmsr %0" : "=r"(msrsave));
	__asm__ volatile ("mtmsr %0" :: "r"(msrsave & ~PSL_EE));
	ci->ci_ipending |= pending;
	__asm__ volatile ("mtmsr %0" :: "r"(msrsave));
}
@


1.31
log
@remove IPL_IMP and splimp().
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.30 2006/03/11 15:07:29 miod Exp $ */
a70 1
volatile extern int cpl, ipending, astpending;
d84 1
d88 2
a89 2
	oldcpl = cpl;
	cpl = oldcpl | newcpl;
d97 2
d100 2
a101 2
	cpl = newcpl;
	if(ipending & ~newcpl)
d109 1
d113 3
a115 3
	oldcpl = cpl;
	cpl = newcpl;
	if(ipending & ~newcpl)
d126 1
d131 1
a131 1
	ipending |= pending;
d147 2
@


1.30
log
@cbb needs IPL_VM to be defined now.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.29 2005/04/19 15:29:48 mickey Exp $ */
a43 1
#define	IPL_IMP		IPL_VM
a139 1
#define splimp()	splraise(imask[IPL_IMP])
d142 1
a142 1
#define splvm()		splraise(imask[IPL_IMP])
@


1.29
log
@nothing uses spllowersoftclock() anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.28 2004/12/24 22:50:30 miod Exp $ */
d43 2
a44 1
#define	IPL_IMP		4
@


1.28
log
@{e,}intr{cnt,names} bye-bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.27 2004/10/01 15:07:36 drahn Exp $ */
a144 1
#define	spllowersoftclock()	spllower(SINT_CLOCK)
@


1.27
log
@Block splsoftclock in splsoftnet, and splsoftclock and splsoftnet in splsofttty
Prevents a race which can corrupt pools, found dhartmei, fix by art and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.26 2004/06/28 02:49:10 aaron Exp $ */
a59 1
extern int intrcnt[PPC_NIRQ];
@


1.26
log
@Use new event counter API for interrupt counting on macppc.  drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.25 2003/10/31 03:04:16 drahn Exp $ */
d148 2
a149 2
#define	splsoftnet()	splraise(SINT_NET)
#define	splsofttty()	splraise(SINT_TTY)
@


1.25
log
@tab/whitespace cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.24 2003/10/19 21:57:35 drahn Exp $ */
d53 3
a55 1
#ifndef _LOCORE
d163 7
a169 7
	struct	intrhand *ih_next;
	int	(*ih_fun)(void *);
	void    *ih_arg;
	u_long  ih_count;
	int     ih_level;
	int     ih_irq;
	char    *ih_what;
@


1.24
log
@Use defines instead of magic constants for more IPL_ stuff, also sort
the IPL_ values by priority, not somewhat random values. No unmodified
code relied on the order of these defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.23 2003/07/14 19:23:52 drahn Exp $ */
d46 1
a46 1
#define IPL_NUM		7
a174 2


@


1.23
log
@tickspending is now a private variable of clock.c
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.22 2003/07/14 18:56:12 drahn Exp $ */
d38 2
a39 1
#define	IPL_BIO		0
d41 4
a44 5
#define	IPL_NET		1
#define	IPL_TTY		2
#define	IPL_IMP		3
#define	IPL_CLOCK	4
#define	IPL_NONE	5
d46 1
d71 1
a71 1
extern int imask[7];
@


1.22
log
@'dual' clock support for macppc, this allows the stat clock to run
at a rate independant of the HZ clock. when profiling is enabled
stat clock now runs at 1000/s instead of the normal 100/s. Other
improvements to the ppc clock handling and KNF/ansi.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.21 2002/09/15 09:01:59 deraadt Exp $ */
d69 1
a69 1
volatile extern int cpl, ipending, astpending, tickspending;
@


1.21
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.19 2002/07/23 17:53:25 drahn Exp $ */
d54 1
a54 1
#define PPC_NIRQ	65
d56 1
@


1.20
log
@KNF
@
text
@d5 1
a5 1
 *
d96 1
a96 1
	if (ipending & ~newcpl)
d109 1
a109 1
	if (ipending & ~newcpl)
d161 5
a165 5
	void	*ih_arg;
	u_long	ih_count;
	int	ih_level;
	int	ih_irq;
	char	*ih_what;
@


1.19
log
@Cardbus/pcmcia support for macppc. parts borrowed from NetBSD, and other
portions of the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.18 2002/04/29 07:35:22 miod Exp $ */
d5 1
a5 1
 * 
d96 1
a96 1
	if(ipending & ~newcpl)
d109 1
a109 1
	if(ipending & ~newcpl)
d161 5
a165 5
	void    *ih_arg;
	u_long  ih_count;
	int     ih_level;
	int     ih_irq;
	char    *ih_what;
@


1.18
log
@Define placeholders for art's splassert() debugging stuff on all arches.
Currently as no-ops everywhere.

ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.17 2002/03/14 01:26:42 millert Exp $ */
d39 1
d138 1
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.16 2002/01/26 15:22:52 drahn Exp $ */
d69 3
@


1.16
log
@splclock() should block SPL_BIO - SPL_IMP.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.15 2002/01/21 17:20:22 drahn Exp $ */
d57 6
a62 6
void setsoftclock __P((void));
void clearsoftclock __P((void));
int  splsoftclock __P((void));
void setsoftnet   __P((void));
void clearsoftnet __P((void));
int  splsoftnet   __P((void));
d64 1
a64 1
void do_pending_int __P((void));
d155 1
a155 1
	int	(*ih_fun) __P((void *));
@


1.15
log
@ARGH, fix it right...
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.14 2002/01/21 17:18:46 drahn Exp $ */
a132 1
#define splclock()	splraise(SPL_CLOCK|SINT_MASK)
d134 1
@


1.14
log
@Better barrier protection. pefo found an instance where the previous
protection was not good enough. work from theo, pefo, toby.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.13 2001/11/19 05:13:50 drahn Exp $ */
d87 1
a87 1
static _volatile _inline void
@


1.13
log
@Remove pointless additional 'syncing' instructions in the powerpc spl*()
functions.  Seems to have no effect on system run time (it should have...)
reduces GENERIC kernel size by 52k.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.12 2001/09/01 15:49:05 drahn Exp $ */
d75 1
a75 1
static __inline int
d80 1
a80 1
	__asm__ volatile("");	/* don't reorder.... */
d83 1
a83 1
	__asm__ volatile("");	/* reorder protect */
d87 1
a87 1
static __inline void
d90 1
a90 1
	__asm__ volatile("");	/* reorder protect */
d94 1
a94 1
	__asm__ volatile("");	/* reorder protect */
d97 1
a97 1
static __inline int
d102 1
a102 1
	__asm__ volatile("");	/* reorder protect */
d107 1
a107 1
	__asm__ volatile("");	/* reorder protect */
@


1.13.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.16 2002/01/26 15:22:52 drahn Exp $ */
d75 1
a75 1
volatile static __inline int
d80 1
a80 1
	__asm__ volatile("":::"memory");	/* don't reorder.... */
d83 1
a83 1
	__asm__ volatile("":::"memory");	/* don't reorder.... */
d87 1
a87 1
volatile static __inline void
d90 1
a90 1
	__asm__ volatile("":::"memory");	/* reorder protect */
d94 1
a94 1
	__asm__ volatile("":::"memory");	/* reorder protect */
d97 1
a97 1
volatile static __inline int
d102 1
a102 1
	__asm__ volatile("":::"memory");	/* reorder protect */
d107 1
a107 1
	__asm__ volatile("":::"memory");	/* reorder protect */
d133 1
a134 1
#define splclock()	splraise(imask[IPL_CLOCK])
@


1.13.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.13.2.1 2002/01/31 22:55:21 niklas Exp $ */
d57 6
a62 6
void setsoftclock(void);
void clearsoftclock(void);
int  splsoftclock(void);
void setsoftnet(void);
void clearsoftnet(void);
int  splsoftnet(void);
d64 1
a64 1
void do_pending_int(void);
a69 3
/* SPL asserts */
#define	splassert(wantipl)	/* nothing */

d155 1
a155 1
	int	(*ih_fun)(void *);
@


1.13.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.13.2.2 2002/06/11 03:37:28 art Exp $ */
a38 1
#define	IPL_AUDIO	IPL_BIO /* XXX - was defined this val in audio_if.h */
a136 1
#define splaudio()	splraise(imask[IPL_AUDIO])
@


1.12
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/include to macppc/include
Some files were not "moved" but wrapper files were created which include
the powerpc/include version.

Several of the powerpc/include files where changed to reflect that they
are POWERPC_* not MACHINE_*.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.11 2001/06/24 23:26:29 drahn Exp $ */
d71 3
a73 3
 *  Reorder protection in the following inline functions is
 * achived with the "eieio" instruction which the assembler
 * seems to detect and then doen't move instructions past....
d80 1
a80 1
	__asm__ volatile("sync; eieio\n");	/* don't reorder.... */
d83 1
a83 1
	__asm__ volatile("sync; eieio\n");	/* reorder protect */
d90 1
a90 1
	__asm__ volatile("sync; eieio\n");	/* reorder protect */
d94 1
a94 1
	__asm__ volatile("sync; eieio\n");	/* reorder protect */
d102 1
a102 1
	__asm__ volatile("sync; eieio\n");	/* reorder protect */
d107 1
a107 1
	__asm__ volatile("sync; eieio\n");	/* reorder protect */
@


1.11
log
@Add prototypes for softnet, ofrootfound.
Code cleanup for pmap headers.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.10 2001/06/24 17:05:38 miod Exp $ */
d35 2
a36 2
#ifndef _MACHINE_INTR_H_
#define _MACHINE_INTR_H_
d170 1
a170 1
#endif /* _MACHINE_INTR_H_ */
@


1.10
log
@Define splvm() for arches who don't already provide it, with the same
definition as splimp().
art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.9 2001/06/24 04:41:37 drahn Exp $ */
d165 1
@


1.9
log
@inlined function definition clean, in preparation of more strict -W warning
flags.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.8 2001/03/29 18:47:18 drahn Exp $ */
d135 1
@


1.8
log
@Make several global variables referenced as extern, not common.
Cleans up symbols in object files.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.7 2000/07/07 13:22:42 rahnds Exp $ */
d76 1
a76 2
splraise(newcpl)
	int newcpl;
d88 1
a88 2
splx(newcpl)
	int newcpl;
d98 1
a98 2
spllower(newcpl)
	int newcpl;
d114 1
a114 2
set_sint(pending)
	int	pending;
@


1.7
log
@Since it is possible for the interrupt controller to be configured late
in the config cycle, and pci devices as well as mac onboard devices
do not use interrupts to probe. It is possible to record that the
interrupt is to be configured, but not configure it with the interrupt
controller until the interrupt controller configures itself.
This is lazy binding of interrupts. If there is a conflicting interrupt
or other problem it will be noticed when the interrupt controller configures
and collects the data rather than when the device configures.
Currently on the openpic interrupt controller supports these pre-configured
interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.6 2000/07/06 15:29:53 ho Exp $ */
d67 2
a68 2
volatile int cpl, ipending, astpending, tickspending;
int imask[7];
@


1.6
log
@Change splsoftclock() to raise the spl, instead of lowering it.
Add spllowersoftclock() for the former behaviour. Update comment. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.5 2000/03/31 04:16:34 rahnds Exp $ */
d165 3
@


1.5
log
@add support for intrcnt from "C", make CLK_IRQ available
to count clock interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.4 1999/11/09 04:13:54 rahnds Exp $ */
d140 2
a141 1
#define	splsoftclock()	spllower(SINT_CLOCK)
@


1.4
log
@autoconf.h
	add mac hooks to the powerpc config structure, probably
	a hack, and certainly needs to be cleaned up.
bus.h
	p4e_ -> ppc_X
	add write_multi and prototypes for bus_space_X_raw_multi functions.
intr.h
	add structure for interrupt handler.
pio.h
	remove the unnecessary and slowing "sync" instruction from
	each pio access.
	remove unnecessary newline characters from the generated asm.
	eieio after writes, but before reads.
types.h
	formatting change
vmparam.h
	change powerpc kernel virtual memory sizing from a fixed segment
	to a variable, initialized with a segment size, this is
	so that the pmap allocator can steal virtual memory, if vm
	is not yet set up. Necessary for mapping devices before the
	kernel vm structures are initialized.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.3 1998/10/09 02:06:40 rahnds Exp $ */
d52 4
@


1.4.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.8 2001/03/29 18:47:18 drahn Exp $ */
a52 4
#define PPC_NIRQ	65
#define PPC_CLK_IRQ	64
extern int intrcnt[PPC_NIRQ];

d63 2
a64 2
volatile extern int cpl, ipending, astpending, tickspending;
extern int imask[7];
d136 1
a136 2
#define	spllowersoftclock()	spllower(SINT_CLOCK)
#define	splsoftclock()	splraise(SINT_CLOCK)
a159 3
extern int ppc_configed_intr_cnt;
#define MAX_PRECONF_INTR 16
extern struct intrhand ppc_configed_intr[MAX_PRECONF_INTR];
@


1.4.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.4.2.1 2001/04/18 16:13:02 niklas Exp $ */
d76 2
a77 1
splraise(int newcpl)
d89 2
a90 1
splx(int newcpl)
d100 2
a101 1
spllower(int newcpl)
d117 2
a118 1
set_sint(int pending)
a138 1
#define splvm()		splraise(imask[IPL_IMP])
a167 1
void softnet(int isr);
@


1.4.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.4.2.2 2001/07/04 10:22:24 niklas Exp $ */
d35 2
a36 2
#ifndef _POWERPC_INTR_H_
#define _POWERPC_INTR_H_
d170 1
a170 1
#endif /* _POWERPC_INTR_H_ */
@


1.4.2.4
log
@repair
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.4.2.3 2001/10/31 03:07:55 nate Exp $ */
@


1.4.2.5
log
@Re-add missing pieces
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.17 2002/03/14 01:26:42 millert Exp $ */
d57 6
a62 6
void setsoftclock(void);
void clearsoftclock(void);
int  splsoftclock(void);
void setsoftnet(void);
void clearsoftnet(void);
int  splsoftnet(void);
d64 1
a64 1
void do_pending_int(void);
d71 3
a73 3
 * Reorder protection in the following inline functions is
 * achived with an empty asm volatile statement. the compiler
 * will not move instructions past asm volatiles.
d75 1
a75 1
volatile static __inline int
d80 1
a80 1
	__asm__ volatile("":::"memory");	/* don't reorder.... */
d83 1
a83 1
	__asm__ volatile("":::"memory");	/* don't reorder.... */
d87 1
a87 1
volatile static __inline void
d90 1
a90 1
	__asm__ volatile("":::"memory");	/* reorder protect */
d94 1
a94 1
	__asm__ volatile("":::"memory");	/* reorder protect */
d97 1
a97 1
volatile static __inline int
d102 1
a102 1
	__asm__ volatile("":::"memory");	/* reorder protect */
d107 1
a107 1
	__asm__ volatile("":::"memory");	/* reorder protect */
d133 1
a134 1
#define splclock()	splraise(imask[IPL_CLOCK])
d155 1
a155 1
	int	(*ih_fun)(void *);
@


1.4.2.6
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a38 1
#define	IPL_AUDIO	IPL_BIO /* XXX - was defined this val in audio_if.h */
a69 3
/* SPL asserts */
#define	splassert(wantipl)	/* nothing */

a133 1
#define splaudio()	splraise(imask[IPL_AUDIO])
@


1.4.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d38 1
a38 2
#define	IPL_NONE	0
#define	IPL_BIO		1
d40 5
a44 4
#define	IPL_NET		2
#define	IPL_TTY		3
#define	IPL_IMP		4
#define	IPL_CLOCK	5
a45 1
#define	IPL_NUM		7
d54 1
a54 1
#define PPC_NIRQ	66
a55 1
#define PPC_STAT_IRQ	65
d68 2
a69 2
volatile extern int cpl, ipending, astpending;
extern int imask[IPL_NUM];
d173 2
@


1.3
log
@requesting tty and net soft interrupts does not mean requesting a clock
soft interrupt.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.2 1998/08/25 06:53:19 pefo Exp $ */
d147 14
d162 1
@


1.2
log
@Fix a couple of spl errors - spotted by Dale and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.1 1997/10/13 10:53:45 pefo Exp $ */
d141 2
a142 2
#define	setsoftnet()	set_sint(SINT_NET|SINT_CLOCK);
#define	setsofttty()	set_sint(SINT_TTY|SINT_CLOCK);
@


1.1
log
@Monolithic PowerPC kernel, new include
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d133 1
a133 1
#define splclock()	splraise(SPL_CLOCK|SINT_CLOCK|SINT_NET)
d141 2
a142 2
#define	setsoftnet()	set_sint(SINT_NET);
#define	setsofttty()	set_sint(SINT_TTY);
@

