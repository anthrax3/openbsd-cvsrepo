head	1.19;
access;
symbols
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	UBC_SYNC_A:1.19
	UBC_SYNC_B:1.19
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.4
	OPENBSD_2_6:1.3.0.6
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.0.2
	OPENBSD_2_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.19
date	2001.09.01.15.49.05;	author drahn;	state dead;
branches;
next	1.18;

1.18
date	2001.08.01.23.53.09;	author pvalchev;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.30.14.16.00;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.09.02.14.05;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.26.05.17.04;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.25.06.21.18;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.24.04.44.19;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.10.15.20.16;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.29.18.50.11;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.07.06.06.10;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.11.17.27.45;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.03.03.02.50;	author rahnds;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.07.13.11.04;	author rahnds;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.03.05.44.09;	author rahnds;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.01.14.05.42.16;	author rahnds;	state Exp;
branches;
next	1.4;

1.4
date	99.11.09.04.13.54;	author rahnds;	state Exp;
branches;
next	1.3;

1.3
date	98.08.25.07.43.40;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	98.01.20.18.40.24;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.10.13.10.53.42;	author pefo;	state Exp;
branches;
next	;

1.6.2.1
date	2001.04.18.16.13.00;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.07.04.10.22.19;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.10.31.03.07.55;	author nate;	state dead;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.11.13.21.04.16;	author niklas;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2001.11.13.22.14.34;	author niklas;	state dead;
branches;
next	;


desc
@@


1.19
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/include to macppc/include
Some files were not "moved" but wrapper files were created which include
the powerpc/include version.

Several of the powerpc/include files where changed to reflect that they
are POWERPC_* not MACHINE_*.
@
text
@/*	$OpenBSD: bus.h,v 1.18 2001/08/01 23:53:09 pvalchev Exp $	*/

/*
 * Copyright (c) 1997 Per Fogelstrom.  All rights reserved.
 * Copyright (c) 1996 Niklas Hallqvist.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _MACHINE_BUS_H_
#define _MACHINE_BUS_H_

#include <machine/pio.h>

#ifdef __STDC__
#define CAT(a,b)	a##b
#define CAT3(a,b,c)	a##b##c
#else
#define CAT(a,b)	a/**/b
#define CAT3(a,b,c)	a/**/b/**/c
#endif

/*
 * Bus access types.
 */
typedef u_long    bus_addr_t;
typedef u_int32_t bus_size_t;
typedef u_int32_t bus_space_handle_t;
typedef struct ppc_bus_space *bus_space_tag_t;

struct ppc_bus_space {
	u_int32_t	bus_base;
	u_int32_t	bus_size;
	u_int8_t	bus_reverse;	/* Reverse bytes */
};
#define POWERPC_BUS_TAG_BASE(x)  ((x)->bus_base)

extern struct ppc_bus_space ppc_isa_io, ppc_isa_mem;

/*
 * Access methods for bus resources
 */
int	bus_space_map __P((bus_space_tag_t t, bus_addr_t addr,
	    bus_size_t size, int cacheable, bus_space_handle_t *bshp));
void	bus_space_unmap __P((bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t size));
int	bus_space_subregion __P((bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp));
int	bus_space_alloc __P((bus_space_tag_t tag, bus_addr_t rstart,
	    bus_addr_t rend, bus_size_t size, bus_size_t alignment,
	    bus_size_t boundary, int cacheable, bus_addr_t *addrp,
	    bus_space_handle_t *handlep));
void	bus_space_free __P((bus_space_tag_t tag, bus_space_handle_t handle,
	    bus_size_t size));

#define bus_space_read(n,m)						      \
static __inline CAT3(u_int,m,_t)					      \
CAT(bus_space_read_,n)(bus_space_tag_t bst, bus_space_handle_t bsh,	      \
     bus_addr_t ba)							      \
{									      \
    if(bst->bus_reverse)						      \
	return CAT3(in,m,rb)((volatile CAT3(u_int,m,_t) *)(bsh + (ba)));      \
    else								      \
	return CAT(in,m)((volatile CAT3(u_int,m,_t) *)(bsh + (ba)));	      \
}

bus_space_read(1,8)
bus_space_read(2,16)
bus_space_read(4,32)

#define	bus_space_read_8	!!! bus_space_read_8 unimplemented !!!

#define bus_space_write(n,m)						      \
static __inline void							      \
CAT(bus_space_write_,n)(bus_space_tag_t bst, bus_space_handle_t bsh,	      \
     bus_addr_t ba, CAT3(u_int,m,_t) x)					      \
{									      \
    if(bst->bus_reverse)						      \
	CAT3(out,m,rb)((volatile CAT3(u_int,m,_t) *)(bsh + (ba)), x);	      \
    else								      \
	CAT(out,m)((volatile CAT3(u_int,m,_t) *)(bsh + (ba)), x);	      \
}

bus_space_write(1,8)
bus_space_write(2,16)
bus_space_write(4,32)

#define	bus_space_write_8	!!! bus_space_write_8 unimplemented !!!

#define bus_space_read_multi(n, m)					      \
static __inline void						       	      \
CAT(bus_space_read_multi_,n)(bus_space_tag_t bst, bus_space_handle_t bsh,     \
    bus_size_t ba, CAT3(u_int,m,_t) *buf, bus_size_t cnt)		      \
{									      \
	while (cnt--)							      \
		*buf++ = CAT(bus_space_read_,n)(bst, bsh, ba);		      \
}

bus_space_read_multi(1,8)
bus_space_read_multi(2,16)
bus_space_read_multi(4,32)

#define	bus_space_read_multi_8	!!! bus_space_read_multi_8 not implemented !!!


#define	bus_space_write_multi_8	!!! bus_space_write_multi_8 not implemented !!!

#define bus_space_write_multi(n, m)					      \
static __inline void								      \
CAT(bus_space_write_multi_,n)(bus_space_tag_t bst, bus_space_handle_t bsh,    \
    bus_size_t ba, const CAT3(u_int,m,_t) *buf, bus_size_t cnt)		      \
{									      \
	while (cnt--)							      \
		CAT(bus_space_write_,n)(bst, bsh, ba, *buf++);		      \
}

bus_space_write_multi(1,8)
bus_space_write_multi(2,16)
bus_space_write_multi(4,32)

#define	bus_space_write_multi_8	!!! bus_space_write_multi_8 not implemented !!!

/*
 *	void bus_space_read_region_N __P((bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t *addr, size_t count));
 *
 * Read `count' 1, 2, 4, or 8 byte quantities from bus space
 * described by tag/handle and starting at `offset' and copy into
 * buffer provided.
 */
#define __BA(t, h, o) ((void *)((h) + (o)))

static __inline void
bus_space_read_region_1(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, u_int8_t *addr, size_t count)
{
	volatile u_int8_t *s = __BA(tag, bsh, offset);

	while (count--)
		*addr++ = *s++;
	__asm __volatile("eieio; sync");
}

static __inline void
bus_space_read_region_2(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, u_int16_t *addr, size_t count)
{
	volatile u_int16_t *s = __BA(tag, bsh, offset);

	while (count--)
		__asm __volatile("lhbrx %0, 0, %1" :
			"=r"(*addr++) : "r"(s++));
	__asm __volatile("eieio; sync");
}

static __inline void
bus_space_read_region_4(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, u_int32_t *addr, size_t count)
{
	volatile u_int32_t *s = __BA(tag, bsh, offset);

	while (count--)
		__asm __volatile("lwbrx %0, 0, %1" :
			"=r"(*addr++) : "r"(s++));
	__asm __volatile("eieio; sync");
}

#if 0	/* Cause a link error for bus_space_read_region_8 */
#define	bus_space_read_region_8		!!! unimplemented !!!
#endif


/*
 *	void bus_space_write_region_N __P((bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_intN_t *addr, size_t count));
 *
 * Write `count' 1, 2, 4, or 8 byte quantities from the buffer provided
 * to bus space described by tag/handle starting at `offset'.
 */

static __inline void
bus_space_write_region_1(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, const u_int8_t *addr, size_t count)
{
	volatile u_int8_t *d = __BA(tag, bsh, offset);

	while (count--)
		*d++ = *addr++;
	__asm __volatile("eieio; sync");
}

static __inline void
bus_space_write_region_2(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, const u_int16_t *addr, size_t count)
{
	volatile u_int16_t *d = __BA(tag, bsh, offset);

	while (count--)
		__asm __volatile("sthbrx %0, 0, %1" ::
			"r"(*addr++), "r"(d++));
	__asm __volatile("eieio; sync");
}

static __inline void
bus_space_write_region_4(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, const u_int32_t *addr, size_t count)
{
	volatile u_int32_t *d = __BA(tag, bsh, offset);

	while (count--)
		__asm __volatile("stwbrx %0, 0, %1" ::
			"r"(*addr++), "r"(d++));
	__asm __volatile("eieio; sync");
}

#if 0
#define	bus_space_write_region_8 !!! bus_space_write_region_8 unimplemented !!!
#endif

/*
 *	void bus_space_set_multi_N __P((bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset, u_intN_t val,
 *	    size_t count));
 *
 * Write the 1, 2, 4, or 8 byte value `val' to bus space described
 * by tag/handle/offset `count' times.
 */
static __inline void bus_space_set_multi_1 __P((bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int8_t, size_t));
static __inline void bus_space_set_multi_2 __P((bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int16_t, size_t));
static __inline void bus_space_set_multi_4 __P((bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int32_t, size_t));

static __inline void
bus_space_set_multi_1(tag, bsh, offset, val, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int8_t val;
	size_t count;
{
	volatile u_int8_t *d = __BA(tag, bsh, offset);

	while (count--)
		*d = val;
	__asm__ volatile("eieio; sync");
}

static __inline void
bus_space_set_multi_2(tag, bsh, offset, val, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int16_t val;
	size_t count;
{
	volatile u_int16_t *d = __BA(tag, bsh, offset);

	while (count--)
		__asm__ volatile("sthbrx %0, 0, %1" ::
			"r"(val), "r"(d));
	__asm__ volatile("eieio; sync");
}

static __inline void
bus_space_set_multi_4(tag, bsh, offset, val, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int32_t val;
	size_t count;
{
	volatile u_int32_t *d = __BA(tag, bsh, offset);

	while (count--)
		__asm__ volatile("stwbrx %0, 0, %1" ::
			"r"(val), "r"(d));
	__asm__ volatile("eieio; sync");
}

#define	bus_space_set_multi_8 !!! bus_space_set_multi_8 unimplemented !!!

/* These are OpenBSD extensions to the general NetBSD bus interface.  */
void
bus_space_read_raw_multi_1(bus_space_tag_t bst, bus_space_handle_t bsh,
	bus_addr_t ba, u_int8_t *dst, bus_size_t size);
void
bus_space_read_raw_multi_2(bus_space_tag_t bst, bus_space_handle_t bsh,
	bus_addr_t ba, u_int8_t *dst, bus_size_t size);
void
bus_space_read_raw_multi_4(bus_space_tag_t bst, bus_space_handle_t bsh,
	bus_addr_t ba, u_int8_t *dst, bus_size_t size);
#define	bus_space_read_raw_multi_8 \
    !!! bus_space_read_raw_multi_8 not implemented !!!

void
bus_space_write_raw_multi_1(bus_space_tag_t bst, bus_space_handle_t bsh,
	bus_addr_t ba, const u_int8_t *src, bus_size_t size);
void
bus_space_write_raw_multi_2(bus_space_tag_t bst, bus_space_handle_t bsh,
	bus_addr_t ba, const u_int8_t *src, bus_size_t size);
void
bus_space_write_raw_multi_4(bus_space_tag_t bst, bus_space_handle_t bsh,
	bus_addr_t ba, const u_int8_t *src, bus_size_t size);
#define	bus_space_write_raw_multi_8 \
    !!! bus_space_write_raw_multi_8 not implemented !!!

void
bus_space_set_region_1 __P((void *v, bus_space_handle_t h, bus_size_t o,
    u_int8_t val, bus_size_t c));
void
bus_space_set_region_2 __P((void *v, bus_space_handle_t h, bus_size_t o,
    u_int16_t val, bus_size_t c));
void
bus_space_set_region_4 __P((void *v, bus_space_handle_t h, bus_size_t o,
    u_int32_t val, bus_size_t c));
#define	bus_space_set_region_8 \
    !!! bus_space_write_raw_multi_8 not implemented !!!

void
bus_space_copy_1 __P((void *v, bus_space_handle_t h1, bus_space_handle_t h2,
    bus_size_t o1, bus_size_t o2, bus_size_t c));
void
bus_space_copy_2 __P((void *v, bus_space_handle_t h1, bus_space_handle_t h2,
    bus_size_t o1, bus_size_t o2, bus_size_t c));
void
bus_space_copy_4 __P((void *v, bus_space_handle_t h1, bus_space_handle_t h2,
    bus_size_t o1, bus_size_t o2, bus_size_t c));
#define	bus_space_copy_8 \
    !!! bus_space_write_raw_multi_8 not implemented !!!

/*
 * Bus read/write barrier methods.
 *
 *	void bus_space_barrier __P((bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    bus_size_t len, int flags));
 * 
 * Note: powerpc does not currently implement barriers, but we must
 * provide the flags to MI code.
 * the processor does have eieio which is effectively the barrier
 * operator, however due to how memory is mapped this should? not
 * be required.
 */
#define bus_space_barrier(t, h, o, l, f)	\
	((void)((void)(t), (void)(h), (void)(o), (void)(l), (void)(f)))  
#define BUS_SPACE_BARRIER_READ  0x01		/* force read barrier */ 
#define BUS_SPACE_BARRIER_WRITE 0x02		/* force write barrier */
/* Compatibility defines */
#define BUS_BARRIER_READ        BUS_SPACE_BARRIER_READ
#define BUS_BARRIER_WRITE       BUS_SPACE_BARRIER_WRITE


#define	BUS_DMA_WAITOK		0x00
#define	BUS_DMA_NOWAIT		0x01
#define	BUS_DMA_ALLOCNOW	0x02
#define	BUS_DMAMEM_NOSYNC	0x04
#define	BUS_DMA_COHERENT	0x08
#define	BUS_DMA_BUS1		0x10	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x20
#define	BUS_DMA_BUS3		0x40
#define	BUS_DMA_BUS4		0x80

/* Forwards needed by prototypes below. */
struct mbuf;
struct proc;
struct uio;

typedef enum {
	BUS_DMASYNC_POSTREAD,
	BUS_DMASYNC_POSTWRITE,
	BUS_DMASYNC_PREREAD,
	BUS_DMASYNC_PREWRITE
} bus_dmasync_op_t;

typedef struct powerpc_bus_dma_tag	*bus_dma_tag_t;
typedef struct powerpc_bus_dmamap	*bus_dmamap_t;

/*
 *	bus_dma_segment_t
 *
 *	Describes a single contiguous DMA transaction.  Values
 *	are suitable for programming into DMA registers.
 */
struct powerpc_bus_dma_segment {
	bus_addr_t	ds_addr;	/* DMA address */
	bus_size_t	ds_len;		/* length of transfer */
};
typedef struct powerpc_bus_dma_segment	bus_dma_segment_t;

/*
 *	bus_dma_tag_t
 *
 *	A machine-dependent opaque type describing the implementation of
 *	DMA for a given bus.
 */

struct powerpc_bus_dma_tag {
	void	*_cookie;		/* cookie used in the guts */

	/*
	 * DMA mapping methods.
	 */
	int	(*_dmamap_create) __P((bus_dma_tag_t , bus_size_t, int,
		    bus_size_t, bus_size_t, int, bus_dmamap_t *));
	void	(*_dmamap_destroy) __P((bus_dma_tag_t , bus_dmamap_t));
	int	(*_dmamap_load) __P((bus_dma_tag_t , bus_dmamap_t, void *,
		    bus_size_t, struct proc *, int));
	int	(*_dmamap_load_mbuf) __P((bus_dma_tag_t , bus_dmamap_t,
		    struct mbuf *, int));
	int	(*_dmamap_load_uio) __P((bus_dma_tag_t , bus_dmamap_t,
		    struct uio *, int));
	int	(*_dmamap_load_raw) __P((bus_dma_tag_t , bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int));
	void	(*_dmamap_unload) __P((bus_dma_tag_t , bus_dmamap_t));
	void	(*_dmamap_sync) __P((bus_dma_tag_t , bus_dmamap_t, bus_dmasync_op_t));

	/*
	 * DMA memory utility functions.
	 */
	int	(*_dmamem_alloc) __P((bus_dma_tag_t, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int));
	void	(*_dmamem_free) __P((bus_dma_tag_t, bus_dma_segment_t *, int));
	int	(*_dmamem_map) __P((bus_dma_tag_t, bus_dma_segment_t *,
		    int, size_t, caddr_t *, int));
	void	(*_dmamem_unmap) __P((bus_dma_tag_t, caddr_t, size_t));
	paddr_t	(*_dmamem_mmap) __P((bus_dma_tag_t, bus_dma_segment_t *,
		    int, off_t, int, int));
};

#define	bus_dmamap_create(t, s, n, m, b, f, p)			\
	(*(t)->_dmamap_create)((t), (s), (n), (m), (b), (f), (p))
#define	bus_dmamap_destroy(t, p)				\
	(*(t)->_dmamap_destroy)((t), (p))
#define	bus_dmamap_load(t, m, b, s, p, f)			\
	(*(t)->_dmamap_load)((t), (m), (b), (s), (p), (f))
#define	bus_dmamap_load_mbuf(t, m, b, f)			\
	(*(t)->_dmamap_load_mbuf)((t), (m), (b), (f))
#define	bus_dmamap_load_uio(t, m, u, f)				\
	(*(t)->_dmamap_load_uio)((t), (m), (u), (f))
#define	bus_dmamap_load_raw(t, m, sg, n, s, f)			\
	(*(t)->_dmamap_load_raw)((t), (m), (sg), (n), (s), (f))
#define	bus_dmamap_unload(t, p)					\
	(*(t)->_dmamap_unload)((t), (p))
#define	bus_dmamap_sync(t, p, o)				\
	(void)((t)->_dmamap_sync ?				\
	    (*(t)->_dmamap_sync)((t), (p), (o)) : (void)0)

#define	bus_dmamem_alloc(t, s, a, b, sg, n, r, f)		\
	(*(t)->_dmamem_alloc)((t)->_cookie, (s), (a), (b), (sg), (n), (r), (f))
#define	bus_dmamem_free(t, sg, n)				\
	(*(t)->_dmamem_free)((t)->_cookie, (sg), (n))
#define	bus_dmamem_map(t, sg, n, s, k, f)			\
	(*(t)->_dmamem_map)((t)->_cookie, (sg), (n), (s), (k), (f))
#define	bus_dmamem_unmap(t, k, s)				\
	(*(t)->_dmamem_unmap)((t)->_cookie, (k), (s))
#define	bus_dmamem_mmap(t, sg, n, o, p, f)			\
	(*(t)->_dmamem_mmap)((t)->_cookie, (sg), (n), (o), (p), (f))

int	_dmamap_create __P((bus_dma_tag_t, bus_size_t, int,
	    bus_size_t, bus_size_t, int, bus_dmamap_t *));
void	_dmamap_destroy __P((bus_dma_tag_t, bus_dmamap_t));
int	_dmamap_load __P((bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int));
int	_dmamap_load_mbuf __P((bus_dma_tag_t, bus_dmamap_t, struct mbuf *, int));
int	_dmamap_load_uio __P((bus_dma_tag_t, bus_dmamap_t, struct uio *, int));
int	_dmamap_load_raw __P((bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int));
void	_dmamap_unload __P((bus_dma_tag_t, bus_dmamap_t));
void	_dmamap_sync __P((bus_dma_tag_t, bus_dmamap_t, bus_dmasync_op_t));

int	_dmamem_alloc __P((bus_dma_tag_t, bus_size_t, bus_size_t,
	    bus_size_t, bus_dma_segment_t *, int, int *, int));
void	_dmamem_free __P((bus_dma_tag_t, bus_dma_segment_t *, int));
int	_dmamem_map __P((bus_dma_tag_t, bus_dma_segment_t *,
	    int, size_t, caddr_t *, int));
void	_dmamem_unmap __P((bus_dma_tag_t, caddr_t, size_t));
paddr_t	_dmamem_mmap __P((bus_dma_tag_t, bus_dma_segment_t *, int, off_t, int, int));

/*
 *	bus_dmamap_t
 *
 *	Describes a DMA mapping.
 */
struct powerpc_bus_dmamap {
	/*
	 * PRIVATE MEMBERS: not for use by machine-independent code.
	 */
	bus_size_t	_dm_size;	/* largest DMA transfer mappable */
	int		_dm_segcnt;	/* number of segs this map can map */
	bus_size_t	_dm_maxsegsz;	/* largest possible segment */
	bus_size_t	_dm_boundary;	/* don't cross this */
	int		_dm_flags;	/* misc. flags */

	void		*_dm_cookie;	/* cookie for bus-specific functions */

	/*
	 * PUBLIC MEMBERS: these are used by machine-independent code.
	 */
	int		dm_nsegs;	/* # valid segments in mapping */
	bus_dma_segment_t dm_segs[1];	/* segments; variable length */
};

#endif /* _MACHINE_BUS_H_ */
@


1.18
log
@make this compile. ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.17 2001/07/30 14:16:00 art Exp $	*/
@


1.17
log
@Change:
int bus_dmamem_mmap(bus_dma_tag_t, bus_dma_segment_t, int, int, int, int);
to:
paddr_t bus_dmamem_mmap(bus_dma_tag_t, bus_dma_segment_t, int, int, off_t, int);

To allow mmaping offsets larger than INT_MAX. And to simply make more sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.16 2001/07/09 02:14:05 mickey Exp $	*/
d505 1
a505 1
int	_dmamem_mmap __P((bus_dma_tag_t, bus_dma_segment_t *, int, int, int, int));
@


1.16
log
@more spacees, includes, protos
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.15 2001/06/26 05:17:04 mickey Exp $	*/
d454 2
a455 2
	int	(*_dmamem_mmap) __P((bus_dma_tag_t, bus_dma_segment_t *,
		    int, int, int, int));
@


1.15
log
@stub bus_space_{alloc,free}
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.14 2001/06/25 06:21:18 mickey Exp $	*/
d320 2
d332 2
d335 11
a345 2
#define	bus_space_read_raw_multi_8 \
    !!! bus_space_read_raw_multi_8 not implemented !!!
d347 10
a356 1
#define	bus_space_write_raw_multi_8 \
@


1.14
log
@implement bus_space_set_multi_*, based on netbsd code; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.13 2001/06/24 04:44:19 drahn Exp $	*/
d73 6
@


1.13
log
@More inline function clean for -W flags strictness.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.12 2001/06/10 15:20:16 drahn Exp $	*/
d240 63
@


1.12
log
@Post pmap_extract() changes cleanup.
bus_addr_t vs vaddr_t/paddr_t
Return correct value for poalloc();
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.11 2001/03/29 18:50:11 drahn Exp $	*/
d153 2
a154 6
bus_space_read_region_1(tag, bsh, offset, addr, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int8_t *addr;
	size_t count;
d164 2
a165 6
bus_space_read_region_2(tag, bsh, offset, addr, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int16_t *addr;
	size_t count;
d176 2
a177 6
bus_space_read_region_4(tag, bsh, offset, addr, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int32_t *addr;
	size_t count;
d202 2
a203 6
bus_space_write_region_1(tag, bsh, offset, addr, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	const u_int8_t *addr;
	size_t count;
d213 2
a214 6
bus_space_write_region_2(tag, bsh, offset, addr, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	const u_int16_t *addr;
	size_t count;
d225 2
a226 6
bus_space_write_region_4(tag, bsh, offset, addr, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	const u_int32_t *addr;
	size_t count;
@


1.11
log
@bus_space_*_raw_multi_* is supposed to take u_int8_t parameter, not
access size parameter. Also add field to hold bus size for later usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.10 2001/02/07 06:06:10 drahn Exp $	*/
d50 1
a50 1
typedef u_int32_t bus_addr_t;
@


1.10
log
@Add support for bus_space_write_region_[1248] bus_space_read_region_[1248]
as needed for some drivers, primarily drivers from NetBSD, where these
defines came from.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.9 2000/11/11 17:27:45 drahn Exp $	*/
d57 1
d271 1
a271 1
	bus_addr_t ba, u_int16_t *dst, bus_size_t size);
d274 1
a274 1
	bus_addr_t ba, u_int32_t *dst, bus_size_t size);
d281 1
a281 1
	bus_addr_t ba, const u_int16_t *src, bus_size_t size);
d284 1
a284 1
	bus_addr_t ba, const u_int32_t *src, bus_size_t size);
@


1.9
log
@Add bus_space_barrier code to powerpc bus.h. This portion of the
bus interface was not previously implemented. This functionality is
required for the latest USB changes.
The bus_space_barrier does not perform any operation with this change,
it expects that the device mappings will be performed with the Guard
bit set which then should not require this forced sync.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.8 2000/08/03 03:02:50 rahnds Exp $	*/
d139 124
@


1.8
log
@Fixes to bus dmamem code.
(Fixed by replacing the code with the version from the i386 port.)
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.7 2000/07/07 13:11:04 rahnds Exp $	*/
d166 22
@


1.7
log
@Additional bus defines, required to build ahc driver. ahc not quite working
due to busdma issues on powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.6 2000/02/03 05:44:09 rahnds Exp $	*/
d217 1
a217 1
	int	(*_dmamap_create) __P((void *, bus_size_t, int,
d219 2
a220 2
	void	(*_dmamap_destroy) __P((void *, bus_dmamap_t));
	int	(*_dmamap_load) __P((void *, bus_dmamap_t, void *,
d222 1
a222 1
	int	(*_dmamap_load_mbuf) __P((void *, bus_dmamap_t,
d224 1
a224 1
	int	(*_dmamap_load_uio) __P((void *, bus_dmamap_t,
d226 1
a226 1
	int	(*_dmamap_load_raw) __P((void *, bus_dmamap_t,
d228 2
a229 2
	void	(*_dmamap_unload) __P((void *, bus_dmamap_t));
	void	(*_dmamap_sync) __P((void *, bus_dmamap_t, bus_dmasync_op_t));
d234 1
a234 1
	int	(*_dmamem_alloc) __P((void *, bus_size_t, bus_size_t,
d236 2
a237 2
	void	(*_dmamem_free) __P((void *, bus_dma_segment_t *, int));
	int	(*_dmamem_map) __P((void *, bus_dma_segment_t *,
d239 2
a240 2
	void	(*_dmamem_unmap) __P((void *, caddr_t, size_t));
	int	(*_dmamem_mmap) __P((void *, bus_dma_segment_t *,
d273 1
a273 1
int	_dmamap_create __P((void *, bus_size_t, int,
d275 2
a276 2
void	_dmamap_destroy __P((void *, bus_dmamap_t));
int	_dmamap_load __P((void *, bus_dmamap_t, void *,
d278 3
a280 3
int	_dmamap_load_mbuf __P((void *, bus_dmamap_t, struct mbuf *, int));
int	_dmamap_load_uio __P((void *, bus_dmamap_t, struct uio *, int));
int	_dmamap_load_raw __P((void *, bus_dmamap_t,
d282 2
a283 2
void	_dmamap_unload __P((void *, bus_dmamap_t));
void	_dmamap_sync __P((void *, bus_dmamap_t, bus_dmasync_op_t));
d285 1
a285 1
int	_dmamem_alloc __P((void *, bus_size_t, bus_size_t,
d287 2
a288 2
void	_dmamem_free __P((void *, bus_dma_segment_t *, int));
int	_dmamem_map __P((void *, bus_dma_segment_t *,
d290 2
a291 2
void	_dmamem_unmap __P((void *, caddr_t, size_t));
int	_dmamem_mmap __P((void *, bus_dma_segment_t *, int, int, int, int));
@


1.6
log
@Define missed when the intial bus_dma code was checked in.
Full dma code not yet integrated.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.5 2000/01/14 05:42:16 rahnds Exp $	*/
d171 5
a175 1
#define	BUS_DMA_COHERENT	0x04
@


1.6.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.11 2001/03/29 18:50:11 drahn Exp $	*/
a56 1
	u_int32_t	bus_size;
a139 124
/*
 *	void bus_space_read_region_N __P((bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t *addr, size_t count));
 *
 * Read `count' 1, 2, 4, or 8 byte quantities from bus space
 * described by tag/handle and starting at `offset' and copy into
 * buffer provided.
 */
#define __BA(t, h, o) ((void *)((h) + (o)))

static __inline void
bus_space_read_region_1(tag, bsh, offset, addr, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int8_t *addr;
	size_t count;
{
	volatile u_int8_t *s = __BA(tag, bsh, offset);

	while (count--)
		*addr++ = *s++;
	__asm __volatile("eieio; sync");
}

static __inline void
bus_space_read_region_2(tag, bsh, offset, addr, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int16_t *addr;
	size_t count;
{
	volatile u_int16_t *s = __BA(tag, bsh, offset);

	while (count--)
		__asm __volatile("lhbrx %0, 0, %1" :
			"=r"(*addr++) : "r"(s++));
	__asm __volatile("eieio; sync");
}

static __inline void
bus_space_read_region_4(tag, bsh, offset, addr, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int32_t *addr;
	size_t count;
{
	volatile u_int32_t *s = __BA(tag, bsh, offset);

	while (count--)
		__asm __volatile("lwbrx %0, 0, %1" :
			"=r"(*addr++) : "r"(s++));
	__asm __volatile("eieio; sync");
}

#if 0	/* Cause a link error for bus_space_read_region_8 */
#define	bus_space_read_region_8		!!! unimplemented !!!
#endif


/*
 *	void bus_space_write_region_N __P((bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_intN_t *addr, size_t count));
 *
 * Write `count' 1, 2, 4, or 8 byte quantities from the buffer provided
 * to bus space described by tag/handle starting at `offset'.
 */

static __inline void
bus_space_write_region_1(tag, bsh, offset, addr, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	const u_int8_t *addr;
	size_t count;
{
	volatile u_int8_t *d = __BA(tag, bsh, offset);

	while (count--)
		*d++ = *addr++;
	__asm __volatile("eieio; sync");
}

static __inline void
bus_space_write_region_2(tag, bsh, offset, addr, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	const u_int16_t *addr;
	size_t count;
{
	volatile u_int16_t *d = __BA(tag, bsh, offset);

	while (count--)
		__asm __volatile("sthbrx %0, 0, %1" ::
			"r"(*addr++), "r"(d++));
	__asm __volatile("eieio; sync");
}

static __inline void
bus_space_write_region_4(tag, bsh, offset, addr, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	const u_int32_t *addr;
	size_t count;
{
	volatile u_int32_t *d = __BA(tag, bsh, offset);

	while (count--)
		__asm __volatile("stwbrx %0, 0, %1" ::
			"r"(*addr++), "r"(d++));
	__asm __volatile("eieio; sync");
}

#if 0
#define	bus_space_write_region_8 !!! bus_space_write_region_8 unimplemented !!!
#endif


d146 1
a146 1
	bus_addr_t ba, u_int8_t *dst, bus_size_t size);
d149 1
a149 1
	bus_addr_t ba, u_int8_t *dst, bus_size_t size);
d156 1
a156 1
	bus_addr_t ba, const u_int8_t *src, bus_size_t size);
d159 1
a159 1
	bus_addr_t ba, const u_int8_t *src, bus_size_t size);
a166 22
/*
 * Bus read/write barrier methods.
 *
 *	void bus_space_barrier __P((bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    bus_size_t len, int flags));
 * 
 * Note: powerpc does not currently implement barriers, but we must
 * provide the flags to MI code.
 * the processor does have eieio which is effectively the barrier
 * operator, however due to how memory is mapped this should? not
 * be required.
 */
#define bus_space_barrier(t, h, o, l, f)	\
	((void)((void)(t), (void)(h), (void)(o), (void)(l), (void)(f)))  
#define BUS_SPACE_BARRIER_READ  0x01		/* force read barrier */ 
#define BUS_SPACE_BARRIER_WRITE 0x02		/* force write barrier */
/* Compatibility defines */
#define BUS_BARRIER_READ        BUS_SPACE_BARRIER_READ
#define BUS_BARRIER_WRITE       BUS_SPACE_BARRIER_WRITE


d171 1
a171 5
#define	BUS_DMA_COHERENT	0x08
#define	BUS_DMA_BUS1		0x10	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x20
#define	BUS_DMA_BUS3		0x40
#define	BUS_DMA_BUS4		0x80
d213 1
a213 1
	int	(*_dmamap_create) __P((bus_dma_tag_t , bus_size_t, int,
d215 2
a216 2
	void	(*_dmamap_destroy) __P((bus_dma_tag_t , bus_dmamap_t));
	int	(*_dmamap_load) __P((bus_dma_tag_t , bus_dmamap_t, void *,
d218 1
a218 1
	int	(*_dmamap_load_mbuf) __P((bus_dma_tag_t , bus_dmamap_t,
d220 1
a220 1
	int	(*_dmamap_load_uio) __P((bus_dma_tag_t , bus_dmamap_t,
d222 1
a222 1
	int	(*_dmamap_load_raw) __P((bus_dma_tag_t , bus_dmamap_t,
d224 2
a225 2
	void	(*_dmamap_unload) __P((bus_dma_tag_t , bus_dmamap_t));
	void	(*_dmamap_sync) __P((bus_dma_tag_t , bus_dmamap_t, bus_dmasync_op_t));
d230 1
a230 1
	int	(*_dmamem_alloc) __P((bus_dma_tag_t, bus_size_t, bus_size_t,
d232 2
a233 2
	void	(*_dmamem_free) __P((bus_dma_tag_t, bus_dma_segment_t *, int));
	int	(*_dmamem_map) __P((bus_dma_tag_t, bus_dma_segment_t *,
d235 2
a236 2
	void	(*_dmamem_unmap) __P((bus_dma_tag_t, caddr_t, size_t));
	int	(*_dmamem_mmap) __P((bus_dma_tag_t, bus_dma_segment_t *,
d269 1
a269 1
int	_dmamap_create __P((bus_dma_tag_t, bus_size_t, int,
d271 2
a272 2
void	_dmamap_destroy __P((bus_dma_tag_t, bus_dmamap_t));
int	_dmamap_load __P((bus_dma_tag_t, bus_dmamap_t, void *,
d274 3
a276 3
int	_dmamap_load_mbuf __P((bus_dma_tag_t, bus_dmamap_t, struct mbuf *, int));
int	_dmamap_load_uio __P((bus_dma_tag_t, bus_dmamap_t, struct uio *, int));
int	_dmamap_load_raw __P((bus_dma_tag_t, bus_dmamap_t,
d278 2
a279 2
void	_dmamap_unload __P((bus_dma_tag_t, bus_dmamap_t));
void	_dmamap_sync __P((bus_dma_tag_t, bus_dmamap_t, bus_dmasync_op_t));
d281 1
a281 1
int	_dmamem_alloc __P((bus_dma_tag_t, bus_size_t, bus_size_t,
d283 2
a284 2
void	_dmamem_free __P((bus_dma_tag_t, bus_dma_segment_t *, int));
int	_dmamem_map __P((bus_dma_tag_t, bus_dma_segment_t *,
d286 2
a287 2
void	_dmamem_unmap __P((bus_dma_tag_t, caddr_t, size_t));
int	_dmamem_mmap __P((bus_dma_tag_t, bus_dma_segment_t *, int, int, int, int));
@


1.6.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.6.2.1 2001/04/18 16:13:00 niklas Exp $	*/
d50 1
a50 1
typedef u_long    bus_addr_t;
a72 6
int	bus_space_alloc __P((bus_space_tag_t tag, bus_addr_t rstart,
	    bus_addr_t rend, bus_size_t size, bus_size_t alignment,
	    bus_size_t boundary, int cacheable, bus_addr_t *addrp,
	    bus_space_handle_t *handlep));
void	bus_space_free __P((bus_space_tag_t tag, bus_space_handle_t handle,
	    bus_size_t size));
d153 6
a158 2
bus_space_read_region_1(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, u_int8_t *addr, size_t count)
d168 6
a173 2
bus_space_read_region_2(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, u_int16_t *addr, size_t count)
d184 6
a189 2
bus_space_read_region_4(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, u_int32_t *addr, size_t count)
d214 6
a219 2
bus_space_write_region_1(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, const u_int8_t *addr, size_t count)
d229 6
a234 2
bus_space_write_region_2(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, const u_int16_t *addr, size_t count)
d245 6
a250 2
bus_space_write_region_4(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, const u_int32_t *addr, size_t count)
a263 63
/*
 *	void bus_space_set_multi_N __P((bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset, u_intN_t val,
 *	    size_t count));
 *
 * Write the 1, 2, 4, or 8 byte value `val' to bus space described
 * by tag/handle/offset `count' times.
 */
static __inline void bus_space_set_multi_1 __P((bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int8_t, size_t));
static __inline void bus_space_set_multi_2 __P((bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int16_t, size_t));
static __inline void bus_space_set_multi_4 __P((bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int32_t, size_t));

static __inline void
bus_space_set_multi_1(tag, bsh, offset, val, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int8_t val;
	size_t count;
{
	volatile u_int8_t *d = __BA(tag, bsh, offset);

	while (count--)
		*d = val;
	__asm__ volatile("eieio; sync");
}

static __inline void
bus_space_set_multi_2(tag, bsh, offset, val, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int16_t val;
	size_t count;
{
	volatile u_int16_t *d = __BA(tag, bsh, offset);

	while (count--)
		__asm__ volatile("sthbrx %0, 0, %1" ::
			"r"(val), "r"(d));
	__asm__ volatile("eieio; sync");
}

static __inline void
bus_space_set_multi_4(tag, bsh, offset, val, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int32_t val;
	size_t count;
{
	volatile u_int32_t *d = __BA(tag, bsh, offset);

	while (count--)
		__asm__ volatile("stwbrx %0, 0, %1" ::
			"r"(val), "r"(d));
	__asm__ volatile("eieio; sync");
}

#define	bus_space_set_multi_8 !!! bus_space_set_multi_8 unimplemented !!!
@


1.6.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.6.2.2 2001/07/04 10:22:19 niklas Exp $	*/
@


1.6.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.6.2.5
log
@repair
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.6.2.4 2001/11/13 21:04:16 niklas Exp $	*/
@


1.5
log
@

UVM changes mainly. As of this checkin UVM is still not working for powerpc
it has a copyin bug after device configuration. However to get these diffs
out of my tree.

All of the UVM code is currently inside ifdef UVM the kernel works fine
without option UVM. Config files have been left without UVM for now.

Prelimiary changes for busdma, (what UVM was wanted for).
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.4 1999/11/09 04:13:54 rahnds Exp $	*/
d171 1
@


1.4
log
@autoconf.h
	add mac hooks to the powerpc config structure, probably
	a hack, and certainly needs to be cleaned up.
bus.h
	p4e_ -> ppc_X
	add write_multi and prototypes for bus_space_X_raw_multi functions.
intr.h
	add structure for interrupt handler.
pio.h
	remove the unnecessary and slowing "sync" instruction from
	each pio access.
	remove unnecessary newline characters from the generated asm.
	eieio after writes, but before reads.
types.h
	formatting change
vmparam.h
	change powerpc kernel virtual memory sizing from a fixed segment
	to a variable, initialized with a segment size, this is
	so that the pmap allocator can steal virtual memory, if vm
	is not yet set up. Necessary for mapping devices before the
	kernel vm structures are initialized.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.3 1998/08/25 07:43:40 pefo Exp $	*/
d167 144
a310 3
/* XXX placeholders */
typedef void *bus_dma_tag_t;
typedef void *bus_dmamap_t;
@


1.3
log
@Local macro
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.2 1998/01/20 18:40:24 niklas Exp $	*/
d53 1
a53 1
typedef struct p4e_bus_space *bus_space_tag_t;
d55 1
a55 1
struct p4e_bus_space {
d59 1
d61 1
a61 1
extern struct p4e_bus_space p4e_isa_io, p4e_isa_mem;
d66 6
a71 7
#define bus_space_map(t, addr, size, cacheable, bshp)			      \
    ((*(bshp) = (t)->bus_base + (addr)), 0)

#define bus_space_unmap(t, bsh, size)

#define bus_space_addr(bshp, offs)					      \
    ((vm_offset_t)((bshp) + (offs)))
a89 14
#define bus_space_read_multi_1(t, h, o, a, c) do {			      \
		insb((u_int8_t *)((h) + (o)), (a), (c));		      \
	} while(0)

#define bus_space_read_multi_2(t, h, o, a, c) do {			      \
		insw((u_int16_t *)((h) + (o)), (a), (c));		      \
	} while(0)

#define bus_space_read_multi_4(t, h, o, a, c) do {			      \
		insl((u_int32_t *)((h) + (o)), (a), (c));		      \
	} while(0)

#define	bus_space_read_multi_8	!!! bus_space_read_multi_8 not implemented !!!

d107 14
a121 11
#define bus_space_write_multi_1(t, h, o, a, c) do {			      \
		outsb((u_int8_t *)((h) + (o)), (a), (c));		      \
	} while(0)

#define bus_space_write_multi_2(t, h, o, a, c) do {			      \
		outsw((u_int16_t *)((h) + (o)), (a), (c));		      \
	} while(0)

#define bus_space_write_multi_4(t, h, o, a, c) do {			      \
		outsl((u_int32_t *)((h) + (o)), (a), (c));		      \
	} while(0)
d125 4
a128 5
/* These are OpenBSD extensions to the general NetBSD bus interface.  */
#define	bus_space_read_raw_multi(n,m,l)					      \
static __inline void							      \
CAT(bus_space_read_raw_multi_,n)(bus_space_tag_t bst, bus_space_handle_t bsh, \
    bus_addr_t ba, u_int8_t *buf, bus_size_t cnt)			      \
d130 2
a131 2
	CAT(bus_space_read_multi_,n)(bst, bsh, ba, (CAT3(u_int,m,_t) *)buf,   \
	    cnt >> l);							      \
d134 26
a159 2
bus_space_read_raw_multi(2,16,1)
bus_space_read_raw_multi(4,32,2)
a162 12

#define	bus_space_write_raw_multi(n,m,l)				      \
static __inline void							      \
CAT(bus_space_write_raw_multi_,n)(bus_space_tag_t bst, bus_space_handle_t bsh,\
    bus_addr_t ba, const u_int8_t *buf, bus_size_t cnt)			      \
{									      \
	CAT(bus_space_write_multi_,n)(bst, bsh, ba,			      \
	    (const CAT3(u_int,m,_t) *)buf, cnt >> l);			      \
}

bus_space_write_raw_multi(2,16,1)
bus_space_write_raw_multi(4,32,2)
@


1.2
log
@Merge bus_dma support from NetBSD, mostly by Jason Thorpe.  Only i386 uses it
 so far, the other archs gets placeholders for now.  I wrote a compatibility
layer for OpenBSD's old isadma code so we can still use our old
driver sources.  They will however get changed to native bus_dma use,
on a case by case basis.   Oh yes, I almost forgot, I kept our notion
of isadma being a device so DMA-less ISA-busses still work
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.1 1997/10/13 10:53:42 pefo Exp $	*/
d69 3
@


1.1
log
@Monolithic PowerPC kernel, new include
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.13 1997/04/19 17:19:56 pefo Exp $	*/
d163 4
@
