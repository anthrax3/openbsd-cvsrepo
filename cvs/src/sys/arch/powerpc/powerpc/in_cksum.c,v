head	1.10;
access;
symbols
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.14
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.10
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.6
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.8
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.8.0.26
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.22
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.20
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.18
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.16
	OPENBSD_5_0:1.8.0.14
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.12
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.10
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.6
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.8
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.4
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.2
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.7.0.12
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.10
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.8
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.6
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.4
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.3.0.6
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.5
	UBC:1.3.0.4
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.14
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	powerpc_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2014.07.22.10.35.35;	author mpi;	state Exp;
branches;
next	1.9;
commitid	EXpEDqO4x724IPl8;

1.9
date	2014.03.29.18.09.30;	author guenther;	state Exp;
branches;
next	1.8;

1.8
date	2008.05.15.22.17.08;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.02.02.39.45;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.15.02.43.09;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.15.09.01.59;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.15.02.02.44;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.24.05.08.11;	author drahn;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	96.12.28.06.22.02;	author rahnds;	state Exp;
branches
	1.2.14.1;
next	1.1;

1.1
date	96.12.21.20.35.57;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.12.21.20.35.57;	author rahnds;	state Exp;
branches;
next	;

1.2.14.1
date	2001.07.04.10.22.57;	author niklas;	state Exp;
branches;
next	1.2.14.2;

1.2.14.2
date	2001.11.13.22.14.34;	author niklas;	state dead;
branches;
next	1.2.14.3;

1.2.14.3
date	2002.03.29.19.46.01;	author niklas;	state Exp;
branches;
next	1.2.14.4;

1.2.14.4
date	2004.02.19.10.49.57;	author niklas;	state Exp;
branches;
next	;

1.3.4.1
date	2002.10.29.00.28.08;	author art;	state Exp;
branches;
next	;


desc
@@


1.10
log
@<netinet/in_systm.h> is no longer needed.
@
text
@/*	$OpenBSD: in_cksum.c,v 1.9 2014/03/29 18:09:30 guenther Exp $	*/
/*	$NetBSD: in_cksum.c,v 1.7 2003/07/15 02:54:48 lukem Exp $	*/

/*
 * Copyright 2001 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Simon Burge and Eduardo Horvath for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project by
 *      Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socketvar.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>

/*
 * Checksum routine for Internet Protocol family headers.
 *
 * This routine is very heavily used in the network
 * code and should be modified for each CPU to be as fast as possible.
 *
 * PowerPC version.
 */

#define	REDUCE1		sum = (sum & 0xffff) + (sum >> 16)
/* Two REDUCE1s is faster than REDUCE1; if (sum > 65535) sum -= 65536; */
#define	REDUCE		{ REDUCE1; REDUCE1; }

static __inline__ int
in_cksum_internal(struct mbuf *m, int off, int len, u_int sum)
{
	uint8_t *w;
	int mlen = 0;
	int byte_swapped = 0;
	int n;

	union {
		uint8_t  c[2];
		uint16_t s;
	} s_util;

	for (;m && len; m = m->m_next) {
		if (m->m_len == 0)
			continue;
		w = mtod(m, uint8_t *) + off;

		/*
		 * 'off' can only be non-zero on the first pass of this
		 * loop when mlen != -1, so we don't need to worry about
		 * 'off' in the if clause below.
		 */
		if (mlen == -1) {
			/*
			 * The first byte of this mbuf is the continuation
			 * of a word spanning between this mbuf and the
			 * last mbuf.
			 *
			 * s_util.c[0] is already saved when scanning previous 
			 * mbuf.
			 */
			s_util.c[1] = *w++;
			sum += s_util.s;
			mlen = m->m_len - 1;
			len--;
		} else {
			mlen = m->m_len - off;
			off = 0;
		}
		if (len < mlen)
			mlen = len;
		len -= mlen;

		/*
		 * Force to a word boundary.
		 */
		if ((3 & (long) w) && (mlen > 0)) {
			if ((1 & (long) w)) {
				REDUCE;
				sum <<= 8;
				s_util.c[0] = *w++;
				mlen--;
				byte_swapped = 1;
			}
			if ((2 & (long) w) && (mlen > 1)) {
				/*
				 * Since the `sum' may contain full 32 bit
				 * value, we can't simply add any value.
				 */
				__asm volatile(
				    "lhz 7,0(%1);"	/* load current data
							   half word */
				    "addc %0,%0,7;"	/* add to sum */
				    "addze %0,%0;"	/* add carry bit */
				    : "+r"(sum)
				    : "b"(w)
				    : "7");		/* clobber r7 */
				w += 2;
				mlen -= 2;
			}
		}

		if (mlen >= 64) {
			n = mlen >> 6;
			__asm volatile(
			    "addic 0,0,0;"		/* clear carry */
			    "mtctr %1;"			/* load loop count */
			    "1:"
			    "lwz 7,4(%2);"		/* load current data
							   word */
			    "lwz 8,8(%2);"
			    "lwz 9,12(%2);"
			    "lwz 10,16(%2);"
			    "adde %0,%0,7;"		/* add to sum */
			    "adde %0,%0,8;"
			    "adde %0,%0,9;"
			    "adde %0,%0,10;"
			    "lwz 7,20(%2);"
			    "lwz 8,24(%2);"
			    "lwz 9,28(%2);"
			    "lwz 10,32(%2);"
			    "adde %0,%0,7;"
			    "adde %0,%0,8;"
			    "adde %0,%0,9;"
			    "adde %0,%0,10;"
			    "lwz 7,36(%2);"
			    "lwz 8,40(%2);"
			    "lwz 9,44(%2);"
			    "lwz 10,48(%2);"
			    "adde %0,%0,7;"
			    "adde %0,%0,8;"
			    "adde %0,%0,9;"
			    "adde %0,%0,10;"
			    "lwz 7,52(%2);"
			    "lwz 8,56(%2);"
			    "lwz 9,60(%2);"
			    "lwzu 10,64(%2);"
			    "adde %0,%0,7;"
			    "adde %0,%0,8;"
			    "adde %0,%0,9;"
			    "adde %0,%0,10;"
			    "bdnz 1b;"			/* loop */
			    "addze %0,%0;"		/* add carry bit */
			    : "+r"(sum)
			    : "r"(n), "b"(w - 4)
			    : "7", "8", "9", "10");	/* clobber r7, r8, r9,
							   r10 */
			w += n * 64;
			mlen -= n * 64;
		}

		if (mlen >= 8) {
			n = mlen >> 3;
			__asm volatile(
			    "addic 0,0,0;"		/* clear carry */
			    "mtctr %1;"			/* load loop count */
			    "1:"
			    "lwz 7,4(%2);"		/* load current data
							   word */
			    "lwzu 8,8(%2);"
			    "adde %0,%0,7;"		/* add to sum */
			    "adde %0,%0,8;"
			    "bdnz 1b;"			/* loop */
			    "addze %0,%0;"		/* add carry bit */
			    : "+r"(sum)
			    : "r"(n), "b"(w - 4)
			    : "7", "8");		/* clobber r7, r8 */
			w += n * 8;
			mlen -= n * 8;
		}

		if (mlen == 0 && byte_swapped == 0)
			continue;
		REDUCE;

		while ((mlen -= 2) >= 0) {
			sum += *(uint16_t *)w;
			w += 2;
		}

		if (byte_swapped) {
			REDUCE;
			sum <<= 8;
			byte_swapped = 0;
			if (mlen == -1) {
				s_util.c[1] = *w;
				sum += s_util.s;
				mlen = 0;
			} else
				mlen = -1;
		} else if (mlen == -1)
			s_util.c[0] = *w;
	}
	if (len)
		printf("cksum: out of data\n");
	if (mlen == -1) {
		/* The last mbuf has odd # of bytes. Follow the
		   standard (the odd byte may be shifted left by 8 bits
		   or not as determined by endian-ness of the machine) */
		s_util.c[1] = 0;
		sum += s_util.s;
	}
	REDUCE;
	return (~sum & 0xffff);
}

int
in_cksum(struct mbuf *m, int len)
{

	return (in_cksum_internal(m, 0, len, 0));
}

int
in4_cksum(struct mbuf *m, uint8_t nxt, int off, int len)
{
	uint16_t *w;
	u_int sum = 0;
	union {
		struct ipovly ipov;
		u_int16_t w[10];
	} u;

	if (nxt != 0) {
		/* pseudo header */
		memset(&u.ipov, 0, sizeof(u.ipov));
		u.ipov.ih_len = htons(len);
		u.ipov.ih_pr = nxt; 
		u.ipov.ih_src = mtod(m, struct ip *)->ip_src; 
		u.ipov.ih_dst = mtod(m, struct ip *)->ip_dst;
		w = u.w;
		/* assumes sizeof(ipov) == 20 */
		sum += w[0]; sum += w[1]; sum += w[2]; sum += w[3]; sum += w[4];
		sum += w[5]; sum += w[6]; sum += w[7]; sum += w[8]; sum += w[9];
	}

	/* skip unnecessary part */
	while (m && off > 0) {
		if (m->m_len > off)
			break;
		off -= m->m_len;
		m = m->m_next;
	}

	return (in_cksum_internal(m, off, len, sum));
}
@


1.9
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_cksum.c,v 1.8 2008/05/15 22:17:08 brad Exp $	*/
d43 1
a44 1
#include <netinet/in_systm.h>
@


1.8
log
@Remove commented out NetBSD __KERNEL_RCSID macro usage.

ok dlg@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_cksum.c,v 1.7 2005/05/02 02:39:45 brad Exp $	*/
d121 1
a121 1
				__asm __volatile(
d136 1
a136 1
			__asm __volatile(
d185 1
a185 1
			__asm __volatile(
@


1.7
log
@New in{,4}_cksum that is between 1.5 and 5 times faster than the
old version depending on CPU type.

From NetBSD

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_cksum.c,v 1.6 2003/10/15 02:43:09 drahn Exp $	*/
a37 5

#if 0
#include <sys/cdefs.h>
__KERNEL_RCSID(0, "$NetBSD: in_cksum.c,v 1.7 2003/07/15 02:54:48 lukem Exp $");
#endif
@


1.6
log
@Sometimes KNF is not a destination, but a journey. Also ANSI.
Binaries unchanged.
@
text
@d1 2
a2 2
/*	$OpenBSD: in_cksum.c,v 1.5 2002/09/15 09:01:59 deraadt Exp $	*/
/*	$NetBSD: in_cksum.c,v 1.1 1996/09/30 16:34:47 ws Exp $	*/
d5 1
a5 2
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
d8 2
d20 5
a24 3
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d26 11
a36 10
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d38 6
d47 1
d49 3
d54 6
a59 2
 * First cut for in_cksum.
 * This code is in C and should be optimized for PPC later.
a60 6
#define	REDUCE		(sum = (sum & 0xffff) + (sum >> 16))
#define	ROL		(sum = sum << 8)
#define	ADDB		(ROL, sum += *w, byte_swapped ^= 1)
#define	ADDS		(sum += *(u_short *)w)
#define	SHIFT(n)	(w += (n), mlen -= (n))
#define	ADDCARRY	do { while (sum > 0xffff) REDUCE; } while (0)
d62 6
a67 2
int
in_cksum(struct mbuf *m, int len)
d69 2
a70 3
	u_char *w;
	u_int sum = 0;
	int mlen;
d72 8
a79 2
	
	for (; m && len; m = m->m_next) {
d82 24
a105 2
		w = mtod(m, u_char *);
		mlen = m->m_len;
d109 77
a185 4
		if ((long)w & 1) {
			REDUCE;
			ADDB;
			SHIFT(1);
d187 19
a205 3
		while (mlen >= 2) {
			ADDS;
			SHIFT(2);
d207 3
d211 27
a237 2
		if (mlen == 1)
			ADDB;
d239 40
a278 3
	if (byte_swapped) {
		REDUCE;
		ROL;
d280 2
a281 2
	ADDCARRY;
	return sum ^ 0xffff;
@


1.5
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: in_cksum.c,v 1.3 2001/06/24 05:08:11 drahn Exp $	*/
d51 1
a51 3
in_cksum(m, len)
	struct mbuf *m;
	int len;
@


1.4
log
@KNF
@
text
@d59 1
a59 1

@


1.3
log
@include header files for proper defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_cksum.c,v 1.2 1996/12/28 06:22:02 rahnds Exp $	*/
d59 1
a59 1
	
@


1.3.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in_cksum.c,v 1.3 2001/06/24 05:08:11 drahn Exp $	*/
@


1.2
log
@Adding OpenBSD tags to files.
@
text
@d1 1
a1 1
/*	$OpenBSD:$	*/
d35 1
d37 1
@


1.2.14.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_cksum.c,v 1.2 1996/12/28 06:22:02 rahnds Exp $	*/
a34 1
#include <sys/systm.h>
a35 1
#include <netinet/in.h>
@


1.2.14.2
log
@repair
@
text
@d1 1
a1 1
/*	$OpenBSD: in_cksum.c,v 1.2.14.1 2001/07/04 10:22:57 niklas Exp $	*/
@


1.2.14.3
log
@Re-add missing pieces
@
text
@d1 1
a1 1
/*	$OpenBSD: in_cksum.c,v 1.3 2001/06/24 05:08:11 drahn Exp $	*/
@


1.2.14.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 3
a53 1
in_cksum(struct mbuf *m, int len)
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@Check-in of powerpc kernel support.
NOTE: This will not work until the other pieces are checked in.
This is primarily the NetBSD powerpc port, with modifications
to support ELF. 
@
text
@@
