head	1.15;
access;
symbols
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	UBC_SYNC_A:1.15
	UBC_SYNC_B:1.15
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.4
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.4.0.6
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	powerpc_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2001.09.01.15.44.20;	author drahn;	state dead;
branches;
next	1.14;

1.14
date	2001.06.24.04.59.26;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.10.20.01.42;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.09.04.51.16;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.02.16.49.18;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.29.01.20.44;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.06.18.15.49;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.11.02.44.30;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.31.04.14.18;	author rahnds;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.23.04.12.48;	author rahnds;	state Exp;
branches;
next	1.5;

1.5
date	99.11.09.00.20.41;	author rahnds;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	98.08.25.07.46.58;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	97.10.13.13.42.53;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	96.12.28.06.21.39;	author rahnds;	state Exp;
branches;
next	1.1;

1.1
date	96.12.21.20.35.56;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.12.21.20.35.56;	author rahnds;	state Exp;
branches;
next	;

1.5.2.1
date	2000.03.24.09.08.42;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2001.05.14.21.36.54;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2001.07.04.10.22.48;	author niklas;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2001.10.31.03.07.55;	author nate;	state dead;
branches;
next	1.5.2.5;

1.5.2.5
date	2001.11.13.21.04.16;	author niklas;	state Exp;
branches;
next	1.5.2.6;

1.5.2.6
date	2001.11.13.22.14.34;	author niklas;	state dead;
branches;
next	;


desc
@@


1.15
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/powerpc to macppc/macppc

This moves hardware specific files from the common directory to the
platform specific directory. This leaves common files.
With this change all of the debugger (db_) files have been moved to
the platform specific directory. The debugger should be reconsidered
and commonized.
@
text
@/*	$OpenBSD: clock.c,v 1.14 2001/06/24 04:59:26 drahn Exp $	*/
/*	$NetBSD: clock.c,v 1.1 1996/09/30 16:34:40 ws Exp $	*/

/*
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/systm.h>

#include <machine/autoconf.h>
#include <machine/pio.h>
#include <machine/intr.h>
#include <dev/ofw/openfirm.h>

#if 0
#include <powerpc/pci/mpc106reg.h>
#endif

void resettodr(void);
static inline u_quad_t mftb(void);

/* XXX, called from asm code */
void decr_intr(struct clockframe *frame);

/*
 * Initially we assume a processor with a bus frequency of 12.5 MHz.
 */
static u_long ticks_per_sec = 3125000;
static u_long ns_per_tick = 320;
static long ticks_per_intr;
static volatile u_long lasttb;

/*
 * BCD to decimal and decimal to BCD.
 */
#define FROMBCD(x)      (((x) >> 4) * 10 + ((x) & 0xf))
#define TOBCD(x)        (((x) / 10 * 16) + ((x) % 10))

#define SECDAY          (24 * 60 * 60)
#define SECYR           (SECDAY * 365)
#define LEAPYEAR(y)     (((y) & 3) == 0)
#define YEAR0		1900

typedef int (clock_read_t)(int *sec, int *min, int *hour, int *day,
         int *mon, int *yr);
typedef int (time_read_t)(u_long *sec);
typedef int (time_write_t)(u_long sec);

int power4e_getclock(int *, int *, int *, int *, int *, int *);

clock_read_t *clock_read = NULL;
time_read_t  *time_read  = NULL;
time_write_t  *time_write  = NULL;

static u_long
chiptotime(int sec, int min, int hour, int day, int mon, int year);

/*
 * For now we let the machine run with boot time, not changing the clock
 * at inittodr at all.
 *
 * We might continue to do this due to setting up the real wall clock with
 * a user level utility in the future.
 */

/* ARGSUSED */
void
inittodr(base)
	time_t base;
{
	int sec, min, hour, day, mon, year;

	int badbase = 0, waszero = base == 0;

        if (base < 5 * SECYR) {
                /*
                 * If base is 0, assume filesystem time is just unknown
                 * instead of preposterous. Don't bark.
                 */
                if (base != 0)
                        printf("WARNING: preposterous time in file system\n");
                /* not going to use it anyway, if the chip is readable */
                base = 21*SECYR + 186*SECDAY + SECDAY/2;
                badbase = 1;
        }

	if (clock_read != NULL ) {
		(*clock_read)( &sec, &min, &hour, &day, &mon, &year);
		time.tv_sec = chiptotime(sec, min, hour, day, mon, year);
	} else if (time_read != NULL) {
		u_long cursec;
		(*time_read)(&cursec);
		time.tv_sec = cursec;
	} else {
		/* force failure */
		time.tv_sec = 0;
	} 
	if (time.tv_sec == 0) {
		printf("WARNING: unable to get date/time");
		/*
		 * Believe the time in the file system for lack of
		 * anything better, resetting the clock.
		 */
		time.tv_sec = base;
		if (!badbase)
			resettodr();
	} else {
		int deltat;

		time.tv_sec += tz.tz_minuteswest * 60;
		if (tz.tz_dsttime)
			time.tv_sec -= 3600;

		deltat = time.tv_sec - base;

		if (deltat < 0)
			deltat = -deltat;
		if (waszero || deltat < 2 * SECDAY)
			return;
		printf("WARNING: clock %s %d days",
		    time.tv_sec < base ? "lost" : "gained", deltat / SECDAY);
	}
	printf(" -- CHECK AND RESET THE DATE!\n");
}

/*
 * This code is defunct after 2068.
 * Will Unix still be here then??
 */
const short dayyr[12] =
    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };

static u_long
chiptotime(sec, min, hour, day, mon, year)
        int sec, min, hour, day, mon, year;
{
	int days, yr;
		
	sec = FROMBCD(sec);
	min = FROMBCD(min);
	hour = FROMBCD(hour);
	day = FROMBCD(day);
	mon = FROMBCD(mon);
	year = FROMBCD(year) + YEAR0;
		
	/* simple sanity checks */
	if (year < 1970 || mon < 1 || mon > 12 || day < 1 || day > 31)
		return (0);
	days = 0;
	for (yr = 1970; yr < year; yr++)
		days += LEAPYEAR(yr) ? 366 : 365;
	days += dayyr[mon - 1] + day - 1;
	if (LEAPYEAR(yr) && mon > 2)
		days++;
	/* now have days since Jan 1, 1970; the rest is easy... */
	return (days * SECDAY + hour * 3600 + min * 60 + sec);
}


/*
 * Similar to the above
 */
void
resettodr()
{
	struct timeval curtime = time;
	if (time_write != NULL) {
		curtime.tv_sec -= tz.tz_minuteswest * 60;
		if (tz.tz_dsttime) {
			curtime.tv_sec += 3600;
		}
		(*time_write)(curtime.tv_sec);
	}
}


void
decr_intr(frame)
	struct clockframe *frame;
{
	int msr;
	u_long tb;
	long tick;
	int nticks;
	int pri;

	/*
	 * Check whether we are initialized.
	 */
	if (!ticks_per_intr)
		return;

	intrcnt[PPC_CLK_IRQ]++;

	/*
	 * Based on the actual time delay since the last decrementer reload,
	 * we arrange for earlier interrupt next time.
	 */
	asm ("mftb %0; mfdec %1" : "=r"(tb), "=r"(tick));
	for (nticks = 0; tick < 0; nticks++)
		tick += ticks_per_intr;
	asm volatile ("mtdec %0" :: "r"(tick));
	/*
	 * lasttb is used during microtime. Set it to the virtual
	 * start of this tick interval.
	 */
	lasttb = tb + tick - ticks_per_intr;

	pri = splclock();

	if (pri & SPL_CLOCK) {
		tickspending += nticks;
	} else {
		nticks += tickspending;
		tickspending = 0;
		/*
		 * Reenable interrupts
		 */
		asm volatile ("mfmsr %0; ori %0, %0, %1; mtmsr %0"
			      : "=r"(msr) : "K"(PSL_EE));
		
		/*
		 * Do standard timer interrupt stuff.
		 * Do softclock stuff only on the last iteration.
		 */
		frame->pri = pri | SINT_CLOCK;
		while (--nticks > 0)
			hardclock(frame);
		frame->pri = pri;
		hardclock(frame);
	}
	splx(pri);
}

void
cpu_initclocks()
{
	int msr, scratch;
	asm volatile ("mfmsr %0; andi. %1, %0, %2; mtmsr %1"
		      : "=r"(msr), "=r"(scratch) : "K"((u_short)~PSL_EE));
	asm volatile ("mftb %0" : "=r"(lasttb));
	asm volatile ("mtdec %0" :: "r"(ticks_per_intr));
	asm volatile ("mtmsr %0" :: "r"(msr));
}

void
calc_delayconst()
{
	int qhandle, phandle;
	char name[32];
	int msr, scratch;
	
	/*
	 * Get this info during autoconf?				XXX
	 */
	for (qhandle = OF_peer(0); qhandle; qhandle = phandle) {
		if (OF_getprop(qhandle, "device_type", name, sizeof name) >= 0
		    && !strcmp(name, "cpu")
		    && OF_getprop(qhandle, "timebase-frequency",
				  &ticks_per_sec, sizeof ticks_per_sec) >= 0) {
			/*
			 * Should check for correct CPU here?		XXX
			 */
			asm volatile ("mfmsr %0; andi. %1, %0, %2; mtmsr %1"
				      : "=r"(msr), "=r"(scratch) : "K"((u_short)~PSL_EE));
			ns_per_tick = 1000000000 / ticks_per_sec;
			ticks_per_intr = ticks_per_sec / hz;
			asm volatile ("mtmsr %0" :: "r"(msr));
			break;
		}
		if ((phandle = OF_child(qhandle)))
			continue;
		while (qhandle) {
			if ((phandle = OF_peer(qhandle)))
				break;
			qhandle = OF_parent(qhandle);
		}
	}
	if (!phandle)
		panic("no cpu node");
}

static inline u_quad_t
mftb()
{
	u_long scratch;
	u_quad_t tb;
	
	asm ("1: mftbu %0; mftb %0+1; mftbu %1; cmpw 0,%0,%1; bne 1b"
	     : "=r"(tb), "=r"(scratch));
	return tb;
}

/*
 * Fill in *tvp with current time with microsecond resolution.
 */
void
microtime(tvp)
	struct timeval *tvp;
{
	u_long tb;
	u_long ticks;
	int msr, scratch;
	
	asm volatile ("mfmsr %0; andi. %1,%0,%2; mtmsr %1"
		      : "=r"(msr), "=r"(scratch) : "K"((u_short)~PSL_EE));
	asm ("mftb %0" : "=r"(tb));
	ticks = (tb - lasttb) * ns_per_tick;
	*tvp = time;
	asm volatile ("mtmsr %0" :: "r"(msr));
	ticks /= 1000;
	tvp->tv_usec += ticks;
	while (tvp->tv_usec >= 1000000) {
		tvp->tv_usec -= 1000000;
		tvp->tv_sec++;
	}
}

/*
 * Wait for about n microseconds (us) (at least!).
 */
void
delay(n)
	unsigned n;
{
	u_quad_t tb;
	u_long tbh, tbl, scratch;
	
	tb = mftb();
	tb += (n * 1000 + ns_per_tick - 1) / ns_per_tick;
	tbh = tb >> 32;
	tbl = tb;
	asm ("1: mftbu %0; cmplw %0,%1; blt 1b; bgt 2f;"
	     " mftb %0; cmplw %0,%2; blt 1b; 2:"
	     :: "r"(scratch), "r"(tbh), "r"(tbl));

	tb = mftb();
}

/*
 * Nothing to do.
 */
void
setstatclockrate(arg)
	int arg;
{
	/* Do nothing */
}
@


1.14
log
@include header for prototypes, prototype functions, assignment in
conditional cleanup, -W warning cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.13 2001/06/10 20:01:42 drahn Exp $	*/
@


1.13
log
@Do not print time in seconds since epoc on boot,
debugging was not removed before commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.12 2001/06/09 04:51:16 drahn Exp $	*/
d37 1
d39 1
d42 1
d48 6
a53 1
void resettodr();
d205 1
d300 1
a300 1
		if (phandle = OF_child(qhandle))
d303 1
a303 1
			if (phandle = OF_peer(qhandle))
@


1.12
log
@Account for timer interrupts which occur while timer is "blocked".
Current change will cause the timer(s) missed to be noticed on the
next timer interrupt and then it will be accounted for.
This really should set a soft interrupt or an interrupt pending bit
for the timer, to more accurately reflect when the timer should have occurred.
System time should no longer be lost with this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.11 2001/06/02 16:49:18 drahn Exp $	*/
a114 1
		printf ("time is %d seconds\n", cursec);
@


1.11
log
@Support writing to the hardware clock for powerpc apple systems.
Note this writes the clock in UTC time, not localtime in the default
kernel. MacOS/OS X expect the hardware clock to be in local time.
If the system is to be dual booted, the time offset can be adjusted using
"config -e" and setting the timezone of the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.10 2001/05/29 01:20:44 drahn Exp $	*/
d232 1
a232 1
	if (pri & SPL_CLOCK)
d234 3
a236 1
	else {
@


1.10
log
@Hardware clock support, via adb.
This reduces the dependancy on openfirmware somewhat.
Since Openfirmware is not actually used for anything,
it is no longer necessary to configure it. so several lines of
useless dmesg are now gone.

This does not have clock setting code enabled yet.
All of the code is in place, but needs further testing before
it is trusted.

I wish Apple would store UTC not localtime in the hardware clock,
besides the fact that the clock base is 1904.

Need to keep the clock sane for dual boot machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.9 2000/09/06 18:15:49 matthieu Exp $	*/
d188 1
a188 2
	struct timeval curtime;
	#if 0
a189 1
		curtime = time;
d194 1
a194 1
		(*time_write)(time.tv_sec);
a195 1
	#endif
@


1.9
log
@take offset from hardware clock specified with 'option TIMEZONE=' and
'option DST=' into account when initializing the clock. ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.8 2000/04/11 02:44:30 pjanzen Exp $	*/
d67 2
d73 2
d110 6
d117 2
a118 2
		/* force failure on chiptotime */
		mon = 0;
d120 1
a120 1
	if ((time.tv_sec = chiptotime(sec, min, hour, day, mon, year)) == 0) {
d188 11
a370 25


#if 0
int
power4e_getclock(sec, min, hour, day, mon, year)
	int *sec;
	int *min;
	int *hour;
	int *day;
	int *mon;
	int *year;
{
	int clkbase = MPC106_V_PCI_MEM_SPACE + 0x000f1ff8;

	outb(clkbase, inb(clkbase) | 0x40);	/* stop update */
	*sec = inb(clkbase + 1);
	*min = inb(clkbase + 2);
	*hour = inb(clkbase + 3);
	*day = inb(clkbase + 5);
	*mon = inb(clkbase + 6);
	*year = inb(clkbase + 7);
	outb(clkbase, inb(clkbase) & ~0x40);
	return(0);
}
#endif
@


1.8
log
@Check usec for >= 1000000, not just > ; as msaitoh@@NetBSD.org
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.7 2000/03/31 04:14:18 rahnds Exp $	*/
d120 7
a126 1
		int deltat = time.tv_sec - base;
@


1.7
log
@Count clock interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.6 2000/03/23 04:12:48 rahnds Exp $	*/
d308 1
a308 1
	while (tvp->tv_usec > 1000000) {
@


1.6
log
@If failure occurs on clock reading routine, make certain that the time
translation failes.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.5 1999/11/09 00:20:41 rahnds Exp $	*/
d39 1
d189 2
@


1.5
log
@autoconf.c:
	calculate delay time for delay() before it is acutally used.
	add support for md_diskconf come closer to supporting crashdumps,
	eventually this code should be un if 0 ed and supported.
	add the wd device as a supported device, fix some comments.
clock.c:
	support calculation of delay loop earlier, do the spin loop correcly,
	unsigned math on the lower half, not signed math.
conf.c:
	addd support for wd driver, block major 0, char major 11.
machdep.c:
	bus_space_map becomes a real function, not just inlined function.
	Support devices that are not mapped with bats (most still currently
	are mapped with bats,...). BAT mapping does not allow proper
	mapping of cachable devices.
	mapiodev HACK, NEEDS TO BE REMOVED. added for quicker import
	of BROKEN mac drivers. the drivers NEED to be rewritten in
	a busified manner. it would FIX all of the endian swabbing
	done by each driver. (Is that emphasized enough?)

	bus_space_(read|write)_raw_multi as functions, should these
	be turned into inline functions and put in bus.h?
ofw_machdep.c:
	removed extranious variable.
openfirm.c:
	telling openfirmware to "boot" will put the system
	in somewhat of a strange state, try reset-all, but that
	typically fails, therefore, try OF_exit before spinning.
pmap.c:
	support stealing memory from kernel address space so that
	mappings can be created before vm is initalized.
vm_machdep.c:
	maybe the meaning of removing this will later become obvious. ???
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.4 1998/08/25 07:46:58 pefo Exp $	*/
d105 4
a108 1
	}
@


1.5.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d105 1
a105 4
	} else {
		/* force failure on chiptotime */
		mon = 0;
	} 
@


1.5.2.2
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.9 2000/09/06 18:15:49 matthieu Exp $	*/
a38 1
#include <machine/intr.h>
d119 1
a119 7
		int deltat;

		time.tv_sec += tz.tz_minuteswest * 60;
		if (tz.tz_dsttime)
			time.tv_sec -= 3600;

		deltat = time.tv_sec - base;
a188 2
	intrcnt[PPC_CLK_IRQ]++;

d305 1
a305 1
	while (tvp->tv_usec >= 1000000) {
@


1.5.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.5.2.2 2001/05/14 21:36:54 niklas Exp $	*/
a36 1
#include <sys/systm.h>
a37 1
#include <machine/autoconf.h>
a39 1
#include <dev/ofw/openfirm.h>
d45 1
a45 6
void resettodr(void);
static inline u_quad_t mftb(void);

/* XXX, called from asm code */
void decr_intr(struct clockframe *frame);

a66 2
typedef int (time_read_t)(u_long *sec);
typedef int (time_write_t)(u_long sec);
a70 2
time_read_t  *time_read  = NULL;
time_write_t  *time_write  = NULL;
a105 5
		time.tv_sec = chiptotime(sec, min, hour, day, mon, year);
	} else if (time_read != NULL) {
		u_long cursec;
		(*time_read)(&cursec);
		time.tv_sec = cursec;
d107 2
a108 2
		/* force failure */
		time.tv_sec = 0;
d110 1
a110 1
	if (time.tv_sec == 0) {
a177 8
	struct timeval curtime = time;
	if (time_write != NULL) {
		curtime.tv_sec -= tz.tz_minuteswest * 60;
		if (tz.tz_dsttime) {
			curtime.tv_sec += 3600;
		}
		(*time_write)(curtime.tv_sec);
	}
a179 1

d214 1
a214 1
	if (pri & SPL_CLOCK) {
d216 1
a216 3
	} else {
		nticks += tickspending;
		tickspending = 0;
d272 1
a272 1
		if ((phandle = OF_child(qhandle)))
d275 1
a275 1
			if ((phandle = OF_peer(qhandle)))
d350 25
@


1.5.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.5.2.3 2001/07/04 10:22:48 niklas Exp $	*/
@


1.5.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.5.2.6
log
@repair
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.5.2.5 2001/11/13 21:04:16 niklas Exp $	*/
@


1.4
log
@Use symbolic names
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.3 1997/10/13 13:42:53 pefo Exp $	*/
d40 1
d42 1
d69 1
a69 1
clock_read_t *clock_read = power4e_getclock;
d227 11
a256 2
			asm volatile ("mftb %0" : "=r"(lasttb));
			asm volatile ("mtdec %0" :: "r"(ticks_per_intr));
d278 1
a278 1
	asm ("1: mftbu %0; mftb %0+1; mftbu %1; cmpw %0,%1; bne 1b"
d309 1
a309 1
 * Wait for about n microseconds (at least!).
d322 2
a323 1
	asm ("1: mftbu %0; cmpw %0,%1; blt 1b; bgt 2f; mftb %0; cmpw %0,%2; blt 1b; 2:"
d325 2
d340 1
d362 1
@


1.3
log
@Monolithic (No OpenFirmware driver crap...) PowerPC kernel. This is the
first release based on Wolfgang Solfrank, TooLs GmbH, work. Most OFW stuff
has been ripped out. Only a few functions for memory probing and halt/reboot
functionality has been kept. The kernel currently works with V.I's power.4e
PowerPC604 board, but more will come.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.2 1996/12/28 06:21:39 rahnds Exp $	*/
d40 2
d335 1
a335 1
	int clkbase = 0xc00f1ff8;
@


1.2
log
@Adding OpenBSD tags to files.
@
text
@d1 1
a1 1
/*	$OpenBSD:$	*/
d38 2
d58 1
d62 4
a65 1
clock_read_t *clock_read;
a101 2
printf("time: sec %x, min %x, hour %x, day %x, mon %x, year %x\n",
	sec, min, hour, day, mon, year);
a136 1
#if 0
a142 1
#endif
d196 4
a199 4
	pri = cpl;
	
	if (pri & SPLCLOCK)
		clockpending += nticks;
a200 2
		cpl = pri | SPLCLOCK | SPLSOFTCLOCK | SPLSOFTNET;

d211 1
a211 1
		frame->pri = pri | SPLSOFTCLOCK;
d217 1
a217 1
	intr_return(pri);
d321 23
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@Check-in of powerpc kernel support.
NOTE: This will not work until the other pieces are checked in.
This is primarily the NetBSD powerpc port, with modifications
to support ELF. 
@
text
@@
