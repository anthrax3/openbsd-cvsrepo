head	1.13;
access;
symbols
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	UBC_SYNC_A:1.13
	UBC_SYNC_B:1.13
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.2.0.6
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.4
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.0.8
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.6
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.4
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.2
	OPENBSD_2_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.13
date	2001.09.01.15.44.20;	author drahn;	state dead;
branches;
next	1.12;

1.12
date	2001.07.09.04.41.28;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.18.21.36.06;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.21.19.52.55;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.11.04.48.12;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.10.23.14.32;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.04.05.10.57;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.05.22.16.03;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.20.15.18.27;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.14.18.26.43;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.15.03.13.59;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	99.07.05.20.21.10;	author rahnds;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	97.10.13.13.42.56;	author pefo;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.14.21.36.55;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.07.04.10.22.51;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2001.10.31.03.07.55;	author nate;	state dead;
branches;
next	1.2.4.4;

1.2.4.4
date	2001.11.13.21.04.16;	author niklas;	state Exp;
branches;
next	1.2.4.5;

1.2.4.5
date	2001.11.13.22.14.34;	author niklas;	state dead;
branches;
next	;


desc
@@


1.13
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/powerpc to macppc/macppc

This moves hardware specific files from the common directory to the
platform specific directory. This leaves common files.
With this change all of the debugger (db_) files have been moved to
the platform specific directory. The debugger should be reconsidered
and commonized.
@
text
@/*	$OpenBSD: cpu.c,v 1.12 2001/07/09 04:41:28 mickey Exp $ */

/*
 * Copyright (c) 1997 Per Fogelstrom
 * Copyright (c) 1997 RTMX Inc
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD for RTMX Inc
 *	North Carolina, USA, by Per Fogelstrom, Opsycon AB, Sweden.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/device.h>

#include <dev/ofw/openfirm.h>

#include <machine/autoconf.h>

#define MPC601          1
#define MPC603          3
#define MPC604          4
#define MPC603e         6
#define MPC603ev        7
#define MPC750          8
#define MPC604ev        9
#define MPC7400         12
#define MPC7410         0x800c
#define MPC7450         0x8000

/* only valid on 603(e,ev) and G3, G4 */
#define HID0_DOZE	(1 << (31-8))
#define HID0_NAP	(1 << (31-9))
#define HID0_SLEEP	(1 << (31-10))
#define HID0_DPM	(1 << (31-11))

char cpu_model[80];
char machine[] = "powerpc";	/* cpu architecture */

/* Definition of the driver for autoconfig. */
int	cpumatch(struct device *, void *, void *);
void	cpuattach(struct device *, struct device *, void *);

struct cfattach cpu_ca = {
	sizeof(struct device), cpumatch, cpuattach
};

struct cfdriver cpu_cd = {
	NULL, "cpu", DV_DULL, NULL, 0
};

void config_l2cr __P((void));

int
cpumatch(parent, cfdata, aux)
	struct device *parent;
	void *cfdata;
	void *aux;
{
	struct confargs *ca = aux;

	/* make sure that we're looking for a CPU. */
	if (strcmp(ca->ca_name, cpu_cd.cd_name) != 0)
		return (0);

	return (1);
}

void
cpuattach(parent, dev, aux)
	struct device *parent;
	struct device *dev;
	void *aux;
{
	unsigned int cpu, pvr, hid0;
	char name[32];
	int qhandle, phandle;
	unsigned int clock_freq = 0;

	__asm__ ("mfpvr %0" : "=r"(pvr));
	cpu = pvr >> 16;
	switch (cpu) {
	case MPC601:
		sprintf(cpu_model, "601");
		break;
	case MPC603:
		sprintf(cpu_model, "603");
		break;
	case MPC604:
		sprintf(cpu_model, "604");
		break;
	case MPC603e:
		sprintf(cpu_model, "603e");
		break;
	case MPC603ev:
		sprintf(cpu_model, "603ev");
		break;
	case MPC750:
		sprintf(cpu_model, "750");
		break;
	case MPC604ev:
		sprintf(cpu_model, "604ev");
		break;
	case MPC7400:
		sprintf(cpu_model, "7400");
		break;
	case MPC7410:
		sprintf(cpu_model, "7410");
		break;
	case MPC7450:
		sprintf(cpu_model, "7450");
		break;
	default:
		sprintf(cpu_model, "Version %x", cpu);
		break;
	}
	sprintf(cpu_model + strlen(cpu_model), " (Revision %x)", pvr & 0xffff);
	printf(": %s", cpu_model);

	/* This should only be executed on openfirmware systems... */

	for (qhandle = OF_peer(0); qhandle; qhandle = phandle) {
                if (OF_getprop(qhandle, "device_type", name, sizeof name) >= 0
                    && !strcmp(name, "cpu")
                    && OF_getprop(qhandle, "clock-frequency",
                                  &clock_freq , sizeof clock_freq ) >= 0)
		{
			break;
		}
                if ((phandle = OF_child(qhandle)))
                        continue;
                while (qhandle) {
                        if ((phandle = OF_peer(qhandle)))
                                break;
                        qhandle = OF_parent(qhandle);
                }
	}

	if (clock_freq != 0) {
		/* Openfirmware stores clock in Hz, not MHz */
		clock_freq /= 1000000;
		printf(": %d MHz", clock_freq);

	}
	/* power savings mode */
	asm ("mfspr %0,1008" : "=r" (hid0));
	switch (cpu) {
	case MPC603:
	case MPC603e:
	case MPC750:
	case MPC7400:
	case MPC7410:
	case MPC7450:
		/* select DOZE mode */
		hid0 &= ~(HID0_NAP | HID0_SLEEP);
		hid0 |= HID0_DOZE | HID0_DPM; 
	}
	asm ("mtspr %0,1008" : "=r" (hid0));

	/* if processor is G3 or G4, configure l2 cache */ 
	if  ( (cpu == MPC750) || (cpu == MPC7400) 
		|| (cpu == MPC7410))
	{
		config_l2cr();
	}
	printf("\n");


}

#define L2CR 1017

#define L2CR_L2E        0x80000000 /* 0: L2 enable */
#define L2CR_L2PE       0x40000000 /* 1: L2 data parity enable */
#define L2CR_L2SIZ      0x30000000 /* 2-3: L2 size */
#define  L2SIZ_RESERVED         0x00000000
#define  L2SIZ_256K             0x10000000
#define  L2SIZ_512K             0x20000000
#define  L2SIZ_1M       0x30000000
#define L2CR_L2CLK      0x0e000000 /* 4-6: L2 clock ratio */
#define  L2CLK_DIS              0x00000000 /* disable L2 clock */
#define  L2CLK_10               0x02000000 /* core clock / 1   */
#define  L2CLK_15               0x04000000 /*            / 1.5 */
#define  L2CLK_20               0x08000000 /*            / 2   */
#define  L2CLK_25               0x0a000000 /*            / 2.5 */
#define  L2CLK_30               0x0c000000 /*            / 3   */
#define L2CR_L2RAM      0x01800000 /* 7-8: L2 RAM type */
#define  L2RAM_FLOWTHRU_BURST   0x00000000
#define  L2RAM_PIPELINE_BURST   0x01000000
#define  L2RAM_PIPELINE_LATE    0x01800000
#define L2CR_L2DO       0x00400000 /* 9: L2 data-only.
                                      Setting this bit disables instruction
                                      caching. */
#define L2CR_L2I        0x00200000 /* 10: L2 global invalidate. */
#define L2CR_L2CTL      0x00100000 /* 11: L2 RAM control (ZZ enable).
                                      Enables automatic operation of the
                                      L2ZZ (low-power mode) signal. */
#define L2CR_L2WT       0x00080000 /* 12: L2 write-through. */
#define L2CR_L2TS       0x00040000 /* 13: L2 test support. */
#define L2CR_L2OH       0x00030000 /* 14-15: L2 output hold. */
#define L2CR_L2SL       0x00008000 /* 16: L2 DLL slow. */
#define L2CR_L2DF       0x00004000 /* 17: L2 differential clock. */
#define L2CR_L2BYP      0x00002000 /* 18: L2 DLL bypass. */
#define L2CR_L2IP       0x00000001 /* 31: L2 global invalidate in progress
                                      (read only). */
#ifdef L2CR_CONFIG
u_int l2cr_config = L2CR_CONFIG;
#else
u_int l2cr_config = 0;
#endif

void
config_l2cr()
{
	u_int l2cr, x;

	__asm __volatile ("mfspr %0, 1017" : "=r"(l2cr));

	/*
	 * Configure L2 cache if not enabled.
	 */
	if ((l2cr & L2CR_L2E) == 0 && l2cr_config != 0) {
		l2cr = l2cr_config;
		asm volatile ("mtspr 1017,%0" :: "r"(l2cr));

		/* Wait for L2 clock to be stable (640 L2 clocks). */
		delay(100);

		/* Invalidate all L2 contents. */
		l2cr |= L2CR_L2I;
		asm volatile ("mtspr 1017,%0" :: "r"(l2cr));
		do {
			asm volatile ("mfspr %0, 1017" : "=r"(x));
		} while (x & L2CR_L2IP);
				      
		/* Enable L2 cache. */
		l2cr &= ~L2CR_L2I;
		l2cr |= L2CR_L2E;
		asm volatile ("mtspr 1017,%0" :: "r"(l2cr));
	}

	if (l2cr & L2CR_L2E) {
		switch (l2cr & L2CR_L2SIZ) {
		case L2SIZ_256K:
			printf(": 256KB");
			break;
		case L2SIZ_512K:
			printf(": 512KB");
			break;
		case L2SIZ_1M:  
			printf(": 1MB");
			break;
		default:
			printf(": unknown size");
		}
#if 0
		switch (l2cr & L2CR_L2RAM) {
		case L2RAM_FLOWTHRU_BURST:
			printf(" Flow-through synchronous burst SRAM");
			break;
		case L2RAM_PIPELINE_BURST:
			printf(" Pipelined synchronous burst SRAM");
			break;
		case L2RAM_PIPELINE_LATE:
			printf(" Pipelined synchronous late-write SRAM");
			break;
		default:
			printf(" unknown type");
		}
		
		if (l2cr & L2CR_L2PE)
			printf(" with parity");  
#endif
		printf(" backside cache");
	} else
		printf(": L2 cache not enabled");
		
}
@


1.12
log
@only on prog_switch, more includes and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.11 2001/06/18 21:36:06 drahn Exp $ */
@


1.11
log
@Close PR 1864, Mhz should be written as MHz.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.10 2001/05/21 19:52:55 drahn Exp $ */
d42 2
d67 2
a68 2
static int	cpumatch(struct device *, void *, void *);
static void	cpuattach(struct device *, struct device *, void *);
d73 1
d78 3
a80 1
static int
a93 1
void config_l2cr();
d95 1
a95 1
static void
d156 1
a156 1
                if (phandle = OF_child(qhandle))
d159 1
a159 1
                        if (phandle = OF_peer(qhandle))
@


1.10
log
@Name the PowerPC G4 processors better. Do not perform the cache control
on the 7450 until docs have been reviewed and it has been tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.10 2001/05/21 19:52:08 drahn Exp $ */
d162 1
a162 1
		/* Openfirmware stores clock in HZ, not Mhz */
d164 1
a164 1
		printf(": %d Mhz", clock_freq);
@


1.9
log
@Remove debugging print from last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.8 2001/03/10 23:14:32 drahn Exp $ */
d52 2
a53 1
#define MPC7400v         0x800c
d127 1
a127 1
		sprintf(cpu_model, "7400(G4)");
d129 5
a133 2
	case MPC7400v:
		sprintf(cpu_model, "7400v(G4?)");
d174 2
a175 1
	case MPC7400v:
d184 1
a184 1
		|| (cpu == MPC7400v) )
@


1.8
log
@Support the DOZE low power mode on the appropriate processors.
This should increase battery life on some systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.7 2001/03/04 05:10:57 brad Exp $ */
a174 1
	printf("hid0 %x:",hid0);
@


1.7
log
@fix typo in comment, org -> or
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.6 2000/11/05 22:16:03 drahn Exp $ */
d44 16
d96 1
a96 1
	int cpu, pvr;
d104 1
a104 1
	case 1:
d107 1
a107 1
	case 3:
d110 1
a110 1
	case 4:
d113 1
a113 4
	case 5:
		sprintf(cpu_model, "602");
		break;
	case 6:
d116 1
a116 1
	case 7:
d119 1
a119 1
	case 8:
d122 1
a122 1
	case 9:
d125 1
a125 1
	case 12:
d128 2
a129 2
	case 20:
		sprintf(cpu_model, "620");
d163 15
d179 3
a181 1
	if  ( (cpu == 8) || (cpu == 12) ) {
@


1.6
log
@Changes to print out size of L2 Cache for G4 and G3 machines.
It "configures" the cache, but it seemed to be configured by
openfirmware previously.
From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.5 2000/10/20 15:18:27 drahn Exp $ */
a46 1

d145 1
a145 1
		/* Openfirmware  stores clock in HZ, not Mhz */
d150 1
a150 1
	/* if processor is G3 org G4, configure l2 cache */ 
a266 1

@


1.5
log
@Add Mhz to cpu information.
Ok'd deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.4 2000/09/14 18:26:43 deraadt Exp $ */
d73 1
d151 4
d158 109
@


1.4
log
@simplify printing
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.3 2000/06/15 03:13:59 rahnds Exp $ */
d82 2
d113 1
a113 1
		sprintf(cpu_model, "7400");
d123 30
a152 1
	printf(": %s\n", cpu_model);
@


1.3
log
@Recognize PowerPC G4 processor (called it's Motorola name "7400").
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.2 1999/07/05 20:21:10 rahnds Exp $ */
a82 2
	printf(": ");

d121 1
a121 2
	printf(" %s", cpu_model);
	printf("\n");
@


1.2
log
@Recognize the 750 (G3) processor.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.1 1997/10/13 13:42:56 pefo Exp $ */
d111 3
@


1.2.4.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.9 2001/03/11 04:48:12 drahn Exp $ */
a43 16
#define MPC601          1
#define MPC603          3
#define MPC604          4
#define MPC603e         6
#define MPC603ev        7
#define MPC750          8
#define MPC604ev        9
#define MPC7400         12
#define MPC7400v         0x800c

/* only valid on 603(e,ev) and G3, G4 */
#define HID0_DOZE	(1 << (31-8))
#define HID0_NAP	(1 << (31-9))
#define HID0_SLEEP	(1 << (31-10))
#define HID0_DPM	(1 << (31-11))

d47 1
a72 1
void config_l2cr();
d80 1
a80 1
	unsigned int cpu, pvr, hid0;
d82 2
a83 2
	int qhandle, phandle;
	unsigned int clock_freq = 0;
d88 1
a88 1
	case MPC601:
d91 1
a91 1
	case MPC603:
d94 1
a94 1
	case MPC604:
d97 4
a100 1
	case MPC603e:
d103 1
a103 1
	case MPC603ev:
d106 1
a106 1
	case MPC750:
d109 1
a109 1
	case MPC604ev:
d112 2
a113 5
	case MPC7400:
		sprintf(cpu_model, "7400(G4)");
		break;
	case MPC7400v:
		sprintf(cpu_model, "7400v(G4?)");
d120 1
a120 47
	printf(": %s", cpu_model);

	/* This should only be executed on openfirmware systems... */

	for (qhandle = OF_peer(0); qhandle; qhandle = phandle) {
                if (OF_getprop(qhandle, "device_type", name, sizeof name) >= 0
                    && !strcmp(name, "cpu")
                    && OF_getprop(qhandle, "clock-frequency",
                                  &clock_freq , sizeof clock_freq ) >= 0)
		{
			break;
		}
                if (phandle = OF_child(qhandle))
                        continue;
                while (qhandle) {
                        if (phandle = OF_peer(qhandle))
                                break;
                        qhandle = OF_parent(qhandle);
                }
	}

	if (clock_freq != 0) {
		/* Openfirmware stores clock in HZ, not Mhz */
		clock_freq /= 1000000;
		printf(": %d Mhz", clock_freq);

	}
	/* power savings mode */
	asm ("mfspr %0,1008" : "=r" (hid0));
	switch (cpu) {
	case MPC603:
	case MPC603e:
	case MPC750:
	case MPC7400:
	case MPC7400v:
		/* select DOZE mode */
		hid0 &= ~(HID0_NAP | HID0_SLEEP);
		hid0 |= HID0_DOZE | HID0_DPM; 
	}
	asm ("mtspr %0,1008" : "=r" (hid0));

	/* if processor is G3 or G4, configure l2 cache */ 
	if  ( (cpu == MPC750) || (cpu == MPC7400) 
		|| (cpu == MPC7400v) )
	{
		config_l2cr();
	}
a121 2


a123 108
#define L2CR 1017

#define L2CR_L2E        0x80000000 /* 0: L2 enable */
#define L2CR_L2PE       0x40000000 /* 1: L2 data parity enable */
#define L2CR_L2SIZ      0x30000000 /* 2-3: L2 size */
#define  L2SIZ_RESERVED         0x00000000
#define  L2SIZ_256K             0x10000000
#define  L2SIZ_512K             0x20000000
#define  L2SIZ_1M       0x30000000
#define L2CR_L2CLK      0x0e000000 /* 4-6: L2 clock ratio */
#define  L2CLK_DIS              0x00000000 /* disable L2 clock */
#define  L2CLK_10               0x02000000 /* core clock / 1   */
#define  L2CLK_15               0x04000000 /*            / 1.5 */
#define  L2CLK_20               0x08000000 /*            / 2   */
#define  L2CLK_25               0x0a000000 /*            / 2.5 */
#define  L2CLK_30               0x0c000000 /*            / 3   */
#define L2CR_L2RAM      0x01800000 /* 7-8: L2 RAM type */
#define  L2RAM_FLOWTHRU_BURST   0x00000000
#define  L2RAM_PIPELINE_BURST   0x01000000
#define  L2RAM_PIPELINE_LATE    0x01800000
#define L2CR_L2DO       0x00400000 /* 9: L2 data-only.
                                      Setting this bit disables instruction
                                      caching. */
#define L2CR_L2I        0x00200000 /* 10: L2 global invalidate. */
#define L2CR_L2CTL      0x00100000 /* 11: L2 RAM control (ZZ enable).
                                      Enables automatic operation of the
                                      L2ZZ (low-power mode) signal. */
#define L2CR_L2WT       0x00080000 /* 12: L2 write-through. */
#define L2CR_L2TS       0x00040000 /* 13: L2 test support. */
#define L2CR_L2OH       0x00030000 /* 14-15: L2 output hold. */
#define L2CR_L2SL       0x00008000 /* 16: L2 DLL slow. */
#define L2CR_L2DF       0x00004000 /* 17: L2 differential clock. */
#define L2CR_L2BYP      0x00002000 /* 18: L2 DLL bypass. */
#define L2CR_L2IP       0x00000001 /* 31: L2 global invalidate in progress
                                      (read only). */
#ifdef L2CR_CONFIG
u_int l2cr_config = L2CR_CONFIG;
#else
u_int l2cr_config = 0;
#endif

void
config_l2cr()
{
	u_int l2cr, x;

	__asm __volatile ("mfspr %0, 1017" : "=r"(l2cr));

	/*
	 * Configure L2 cache if not enabled.
	 */
	if ((l2cr & L2CR_L2E) == 0 && l2cr_config != 0) {
		l2cr = l2cr_config;
		asm volatile ("mtspr 1017,%0" :: "r"(l2cr));

		/* Wait for L2 clock to be stable (640 L2 clocks). */
		delay(100);

		/* Invalidate all L2 contents. */
		l2cr |= L2CR_L2I;
		asm volatile ("mtspr 1017,%0" :: "r"(l2cr));
		do {
			asm volatile ("mfspr %0, 1017" : "=r"(x));
		} while (x & L2CR_L2IP);
				      
		/* Enable L2 cache. */
		l2cr &= ~L2CR_L2I;
		l2cr |= L2CR_L2E;
		asm volatile ("mtspr 1017,%0" :: "r"(l2cr));
	}

	if (l2cr & L2CR_L2E) {
		switch (l2cr & L2CR_L2SIZ) {
		case L2SIZ_256K:
			printf(": 256KB");
			break;
		case L2SIZ_512K:
			printf(": 512KB");
			break;
		case L2SIZ_1M:  
			printf(": 1MB");
			break;
		default:
			printf(": unknown size");
		}
#if 0
		switch (l2cr & L2CR_L2RAM) {
		case L2RAM_FLOWTHRU_BURST:
			printf(" Flow-through synchronous burst SRAM");
			break;
		case L2RAM_PIPELINE_BURST:
			printf(" Pipelined synchronous burst SRAM");
			break;
		case L2RAM_PIPELINE_LATE:
			printf(" Pipelined synchronous late-write SRAM");
			break;
		default:
			printf(" unknown type");
		}
		
		if (l2cr & L2CR_L2PE)
			printf(" with parity");  
#endif
		printf(" backside cache");
	} else
		printf(": L2 cache not enabled");
		
}
@


1.2.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.2.4.1 2001/05/14 21:36:55 niklas Exp $ */
d52 1
a52 2
#define MPC7410         0x800c
#define MPC7450         0x8000
d126 1
a126 1
		sprintf(cpu_model, "7400");
d128 2
a129 5
	case MPC7410:
		sprintf(cpu_model, "7410");
		break;
	case MPC7450:
		sprintf(cpu_model, "7450");
d158 1
a158 1
		/* Openfirmware stores clock in Hz, not MHz */
d160 1
a160 1
		printf(": %d MHz", clock_freq);
d170 1
a170 2
	case MPC7410:
	case MPC7450:
d179 1
a179 1
		|| (cpu == MPC7410))
@


1.2.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.2.4.2 2001/07/04 10:22:51 niklas Exp $ */
@


1.2.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
@


1.2.4.5
log
@repair
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.2.4.4 2001/11/13 21:04:16 niklas Exp $ */
@


1.1
log
@Monolithic (No OpenFirmware driver crap...) PowerPC kernel. This is the
first release based on Wolfgang Solfrank, TooLs GmbH, work. Most OFW stuff
has been ripped out. Only a few functions for memory probing and halt/reboot
functionality has been kept. The kernel currently works with V.I's power.4e
PowerPC604 board, but more will come.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.9 1997/06/14 23:28:53 deraadt Exp $ */
d105 3
@

