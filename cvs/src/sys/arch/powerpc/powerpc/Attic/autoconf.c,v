head	1.13;
access;
symbols
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	UBC_SYNC_A:1.13
	UBC_SYNC_B:1.13
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.6
	OPENBSD_2_8:1.10.0.4
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	SMP:1.9.0.2
	SMP_BASE:1.9
	kame_19991208:1.8
	OPENBSD_2_6:1.7.0.6
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	powerpc_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2001.09.01.15.44.20;	author drahn;	state dead;
branches;
next	1.12;

1.12
date	2001.06.24.04.49.27;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.05.22.34.13;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.04.02.11.47;	author rahnds;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.23.17.32.02;	author rahnds;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	99.11.09.00.20.41;	author rahnds;	state Exp;
branches;
next	1.7;

1.7
date	98.08.22.18.31.52;	author rahnds;	state Exp;
branches;
next	1.6;

1.6
date	98.08.06.15.04.05;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	98.05.29.04.15.37;	author rahnds;	state Exp;
branches;
next	1.4;

1.4
date	97.10.21.11.00.09;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	97.10.13.13.42.53;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	96.12.28.06.21.36;	author rahnds;	state Exp;
branches;
next	1.1;

1.1
date	96.12.21.20.35.56;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.12.21.20.35.56;	author rahnds;	state Exp;
branches;
next	;

1.9.2.1
date	2001.05.14.21.36.54;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2001.07.04.10.22.47;	author niklas;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2001.10.31.03.07.55;	author nate;	state dead;
branches;
next	1.9.2.4;

1.9.2.4
date	2001.11.13.21.04.16;	author niklas;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2001.11.13.22.14.34;	author niklas;	state dead;
branches;
next	;


desc
@@


1.13
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/powerpc to macppc/macppc

This moves hardware specific files from the common directory to the
platform specific directory. This leaves common files.
With this change all of the debugger (db_) files have been moved to
the platform specific directory. The debugger should be reconsidered
and commonized.
@
text
@/*	$OpenBSD: autoconf.c,v 1.12 2001/06/24 04:49:27 drahn Exp $	*/
/*
 * Copyright (c) 1996, 1997 Per Fogelstrom
 * Copyright (c) 1995 Theo de Raadt
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department and Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah Hdr: autoconf.c 1.31 91/01/21
 *
 *	from: @@(#)autoconf.c	8.1 (Berkeley) 6/10/93
 *      $Id: autoconf.c,v 1.12 2001/06/24 04:49:27 drahn Exp $
 */

/*
 * Setup the system to run on the current machine.
 *
 * cpu_configure() is called at boot time.  Available
 * devices are determined (from possibilities mentioned in ioconf.c),
 * and the drivers are initialized.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/disklabel.h>
#include <sys/conf.h>
#include <sys/reboot.h>
#include <sys/device.h>

#include <machine/autoconf.h>

struct  device *parsedisk __P((char *, int, int, dev_t *));
void    setroot __P((void));
void	swapconf __P((void));
extern void	dumpconf __P((void));
static int findblkmajor __P((struct device *));
static struct device * getdisk __P((char *, int, int, dev_t *));
struct device * getdevunit __P((char *, int));
static struct devmap * findtype __P((char **));
void makebootdev __P((char *cp));
int getpno __P((char **));
void diskconf(void);

/*
 * The following several variables are related to
 * the configuration process, and are used in initializing
 * the machine.
 */
int	cold = 1;	/* if 1, still working on cold-start */
char	bootdev[16];	/* to hold boot dev name */
struct device *bootdv = NULL;

/*
 *  Configure all devices found that we know about.
 *  This is done at boot time.
 */
void
cpu_configure()
{
	(void)splhigh();	/* To be really sure.. */
	calc_delayconst();

	/*
	if(system_type == OFWMACH) {
		ofrootfound();
	}
	*/
	if(config_rootfound("mainbus", "mainbus") == 0)
		panic("no mainbus found");
	(void)spl0();

	/*
	 * We can not know which is our root disk, defer
	 * until we can checksum blocks to figure it out.
	 */
	md_diskconf = diskconf;
	cold = 0;
}
/*
 * Now that we are fully operational, we can checksum the
 * disks, and using some heuristics, hopefully are able to
 * always determine the correct root disk.
 */
void
diskconf()
{
	/*
	 * Configure root, swap, and dump area.  This is
	 * currently done by running the same checksum
	 * algorithm over all known disks, as was done in
	 * /boot.  Then we basically fixup the *dev vars
	 * from the info we gleaned from this.
	dkcsumattach();
	 * - XXX
	 */

#if 0
	rootconf();
#endif
	setroot();
	swapconf();
#if 0
	dumpconf();
#endif
}

/*
 * Configure swap space and related parameters.
 */
void
swapconf()
{
	register struct swdevt *swp;
	register int nblks;

	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (bdevsw[major(swp->sw_dev)].d_psize) {
			nblks =
			  (*bdevsw[major(swp->sw_dev)].d_psize)(swp->sw_dev);
			if (nblks != -1 &&
			    (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
			swp->sw_nblks = ctod(dtoc(swp->sw_nblks));
		}
	}
#if 0
	dumpconf();
#endif
}

/*
 * Crash dump handling.
 */
u_long dumpmag = 0x8fca0101;		/* magic number */
int dumpsize = 0;			/* size of dump in pages */
long dumplo = -1;			/* blocks */

/*
 * This is called by configure to set dumplo and dumpsize.
 * Dumps always skip the first CLBYTES of disk space
 * in case there might be a disk label stored there.
 * If there is extra space, put dump at the end to
 * reduce the chance that swapping trashes it.
 */
#if 0
void
dumpconf()
{
	int nblks;	/* size of dump area */
	int maj;

	if (dumpdev == NODEV)
		return;
	maj = major(dumpdev);
	if (maj < 0 || maj >= nblkdev)
		panic("dumpconf: bad dumpdev=0x%x", dumpdev);
	if (bdevsw[maj].d_psize == NULL)
		return;
	nblks = (*bdevsw[maj].d_psize)(dumpdev);
	if (nblks <= ctod(1))
		return;

	dumpsize = btoc(IOM_END + ctob(dumpmem_high));

	/* Always skip the first CLBYTES, in case there is a label there. */
	if (dumplo < ctod(1))
		dumplo = ctod(1);

	/* Put dump at end of partition, and make it fit. */
	if (dumpsize > dtoc(nblks - dumplo))
		dumpsize = dtoc(nblks - dumplo);
	if (dumplo < nblks - ctod(dumpsize))
		dumplo = nblks - ctod(dumpsize);
}
#endif

static	struct nam2blk {
	char *name;
	int  maj;
} nam2blk[] = {
	{ "wd",		0 },	/* 0 = wd */
	{ "sd",		2 },	/* 2 = sd */
	{ "ofdisk",	4 },	/* 4 = ofdisk */
};

static int
findblkmajor(dv)
	struct device *dv;
{
	char *name = dv->dv_xname;
	register int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[0].name)) == 0)
			return (nam2blk[i].maj);
	 return (-1);
}

static struct device *
getdisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	register struct device *dv;

	if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
		printf("use one of:");
		for (dv = alldevs.tqh_first; dv != NULL;
		    dv = dv->dv_list.tqe_next) {
			if (dv->dv_class == DV_DISK)
				printf(" %s[a-h]", dv->dv_xname);
#ifdef NFSCLIENT
			if (dv->dv_class == DV_IFNET)
				printf(" %s", dv->dv_xname); 
#endif
		}
		printf("\n");
	}
	return (dv);
}

struct device *
parsedisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	register struct device *dv;
	register char *cp, c;
	int majdev, part;

	if (len == 0)
		return (NULL);
	cp = str + len - 1;
	c = *cp;
	if (c >= 'a' && (c - 'a') < MAXPARTITIONS) {
		part = c - 'a';
		*cp = '\0';
	} else
		part = defpart;

	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
		if (dv->dv_class == DV_DISK &&
		    strcmp(str, dv->dv_xname) == 0) {
			majdev = findblkmajor(dv);
			if (majdev < 0)
				panic("parsedisk");
			*devp = MAKEDISKDEV(majdev, dv->dv_unit, part);
			break;
		}
#ifdef NFSCLIENT
		if (dv->dv_class == DV_IFNET &&
		    strcmp(str, dv->dv_xname) == 0) {
			*devp = NODEV;
			break;
		}
#endif
	}

	*cp = c;
	return (dv);
}

/*
 * Attempt to find the device from which we were booted.
 * If we can do so, and not instructed not to do so,
 * change rootdev to correspond to the load device.
 */
void
setroot()
{
	int  majdev, mindev, unit, part, len;
	dev_t temp;
	struct swdevt *swp;
	struct device *dv;
	dev_t nrootdev, nswapdev = NODEV;
	char buf[128];

#if defined(NFSCLIENT)
	extern char *nfsbootdevname;
#endif

printf("bootpath: '%s'\n", bootpath);
	makebootdev(bootpath);
	if(boothowto & RB_DFLTROOT)
		return;		/* Boot compiled in */

	/* Lookup boot device from boot if not set by configuration */
	if(bootdv == NULL) {
		bootdv = parsedisk(bootdev, strlen(bootdev), 0, &temp);
	}
	if(bootdv == NULL) {
		printf("boot device: lookup '%s' failed.\n", bootdev);
		boothowto |= RB_ASKNAME; /* Don't Panic :-) */
		/* boothowto |= RB_SINGLE; */
	}
	else {
		printf("boot device: %s.\n", bootdv->dv_xname);
	}

	if (boothowto & RB_ASKNAME) {
		for (;;) {
			printf("root device ");
			if (bootdv != NULL)
				 printf("(default %s%c)",
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK
						? 'a' : ' ');
			printf(": ");
			len = getsn(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				strcpy(buf, bootdv->dv_xname);
				len = strlen(buf);
			}
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				dv = getdisk(buf, len, 1, &nrootdev);
				if (dv != NULL) {
					bootdv = dv;
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			dv = getdisk(buf, len, 0, &nrootdev);
			if (dv != NULL) {
				bootdv = dv;
				break;
			}
		}
		/*
		 * because swap must be on same device as root, for
		 * network devices this is easy.
		 */
		if (bootdv->dv_class == DV_IFNET) {
			goto gotswap;
		}
		for (;;) {
			printf("swap device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK?'b':' ');
			printf(": ");
			len = getsn(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				switch (bootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
					break;
				case DV_TAPE:
				case DV_TTY:
				case DV_DULL:
				case DV_CPU:
					break;
				}
				break;
			}
			dv = getdisk(buf, len, 1, &nswapdev);
			if (dv) {
				if (dv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				break;
			}
		}

gotswap:
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
	}
	else if(mountroot == NULL) {
		/*
		 * `swap generic': Use the device the ROM told us to use.
		 */
		if (bootdv == NULL)
			panic("boot device not known");

		majdev = findblkmajor(bootdv);

		if (majdev >= 0) {
			/*
			 * Root and Swap are on disk.
			 * Boot is always from partition 0.
			 */
			rootdev = MAKEDISKDEV(majdev, bootdv->dv_unit, 0);
			nswapdev = MAKEDISKDEV(majdev, bootdv->dv_unit, 1);
			dumpdev = nswapdev;
		}
		else {
			/*
			 *  Root and Swap are on net.
			 */	
			nswapdev = dumpdev = NODEV;
		}
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;

	} else {

		/*
		 * `root DEV swap DEV': honour rootdev/swdevt.
		 * rootdev/swdevt/mountroot already properly set.
		 */
		return;
	}

	switch (bootdv->dv_class) {
#if defined(NFSCLIENT)
	case DV_IFNET:
		mountroot = nfs_mountroot;
		nfsbootdevname = bootdv->dv_xname;
		return;
#endif
	case DV_DISK:
		mountroot = dk_mountroot;
		majdev = major(rootdev);
		mindev = minor(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);
		printf("root on %s%c\n", bootdv->dv_xname, part + 'a');
		break;
	default:
		printf("can't figure root, hope your kernel is right\n");
		return;
	}

	/*
	 * XXX: What is this doing?
	 */
	temp = NODEV;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    unit == DISKUNIT(swp->sw_dev)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev == NODEV)
		return;

	/*
	 * If dumpdev was the same as the old primary swap device, move
	 * it to the new primary swap device.
	 */
	if (temp == dumpdev)
		dumpdev = swdevt[0].sw_dev;
}

/*
 * find a device matching "name" and unit number
 */
struct device *
getdevunit(name, unit)
	char *name;
	int unit;
{
	struct device *dev = alldevs.tqh_first;
	char num[10], fullname[16];
	int lunit;

	/* compute length of name and decimal expansion of unit number */
	sprintf(num, "%d", unit);
	lunit = strlen(num);
	if (strlen(name) + lunit >= sizeof(fullname) - 1)
		panic("config_attach: device name too long");

	strcpy(fullname, name);
	strcat(fullname, num);

	while (strcmp(dev->dv_xname, fullname) != 0) {
		if ((dev = dev->dv_list.tqe_next) == NULL)
			return NULL;
	}
	return dev;
}

struct devmap {
	char *att;
	char *dev;
	int   type;
};
#define	T_IFACE	0x10

#define	T_BUS	0x00
#define	T_SCSI	0x11
#define	T_IDE	0x12
#define	T_DISK	0x21

static struct devmap *
findtype(s)
	char **s;
{
	static struct devmap devmap[] = {
		{ "/pci@@",	NULL, T_BUS },
		{ "/pci",	NULL, T_BUS },
		{ "/mac-io@@",	NULL, T_BUS },
		{ "/mac-io",	NULL, T_BUS },
		{ "/@@",		NULL, T_BUS },
		{ "/scsi@@",	"sd", T_SCSI },
		{ "/ide",	"wd", T_IDE },
		{ "/ata",	"wd", T_IDE },
		{ "/disk@@",	"sd", T_DISK },
		{ "/disk",	"wd", T_DISK },
		{ NULL, NULL }
	};
	struct devmap *dp = &devmap[0];

	while (dp->att) {
		if (strncmp (*s, dp->att, strlen(dp->att)) == 0) {
			*s += strlen(dp->att);
			break;
		}
		dp++;
	}
	if (dp->att == NULL) {
		printf("string [%s]not found\n", *s);
	}
	return(dp);
}

/*
 * Look at the string 'bp' and decode the boot device.
 * Boot names look like: '/pci/scsi@@c/disk@@0,0/bsd'
 *                       '/pci/mac-io/ide@@20000/disk@@0,0/bsd
 *                       '/pci/mac-io/ide/disk/bsd
 */
void
makebootdev(bp)
	char *bp;
{
	int	unit;
	char   *dev, *cp;
	struct devmap *dp;

	cp = bp;
	do {
		while(*cp && *cp != '/') {
			cp++;
		}
		dp = findtype(&cp);
		if (!dp->att) {
			printf("Warning: boot device unrecognized: %s\n", bp);
			return;
		}
	} while((dp->type & T_IFACE) == 0);

	dev = dp->dev;
	while(*cp && *cp != '/')
		cp++;
	dp = findtype(&cp);
	if (!dp->att || dp->type != T_DISK) {
		printf("Warning: boot device unrecognized: %s\n", bp);
		return;
	}
	unit = getpno(&cp);
	sprintf(bootdev, "%s%d%c", dev, unit, 'a');
}

int
getpno(cp)
	char **cp;
{
	int val = 0;
	char *cx = *cp;

	while(*cx && *cx >= '0' && *cx <= '9') {
		val = val * 10 + *cx - '0';
		cx++;
	}
	*cp = cx;
	return val;
}
@


1.12
log
@properly prototype diskconf()
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11 2001/05/05 22:34:13 art Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.11 2001/05/05 22:34:13 art Exp $
@


1.11
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.10 2000/04/04 02:11:47 rahnds Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.10 2000/04/04 02:11:47 rahnds Exp $
d75 1
a75 1
void diskconf();
@


1.10
log
@support root drive detection for G4 powermac.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9 2000/01/23 17:32:02 rahnds Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.9 2000/01/23 17:32:02 rahnds Exp $
d50 1
a50 1
 * Configure() is called at boot time.  Available
a66 1
void	configure __P((void));
d91 1
a91 1
configure()
@


1.9
log
@Slight changes to root drive detection for powerpc (mac).
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.8 1999/11/09 00:20:41 rahnds Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.8 1999/11/09 00:20:41 rahnds Exp $
d536 10
a545 7
		{ "/pci", NULL, T_BUS },
		{ "/mac-io", NULL, T_BUS },
		{ "/scsi@@", "sd", T_SCSI },
		{ "/ide@@", "wd", T_IDE },
		{ "/ide", "wd", T_IDE },
		{ "/disk@@", "sd", T_DISK },
		{ "/disk", "wd", T_DISK },
d579 3
@


1.9.2.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.10 2000/04/04 02:11:47 rahnds Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.10 2000/04/04 02:11:47 rahnds Exp $
d536 7
a542 10
		{ "/pci@@",	NULL, T_BUS },
		{ "/pci",	NULL, T_BUS },
		{ "/mac-io@@",	NULL, T_BUS },
		{ "/mac-io",	NULL, T_BUS },
		{ "/@@",		NULL, T_BUS },
		{ "/scsi@@",	"sd", T_SCSI },
		{ "/ide",	"wd", T_IDE },
		{ "/ata",	"wd", T_IDE },
		{ "/disk@@",	"sd", T_DISK },
		{ "/disk",	"wd", T_DISK },
a575 3
		while(*cp && *cp != '/') {
			cp++;
		}
@


1.9.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9.2.1 2001/05/14 21:36:54 niklas Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.9.2.1 2001/05/14 21:36:54 niklas Exp $
d50 1
a50 1
 * cpu_configure() is called at boot time.  Available
d67 1
d76 1
a76 1
void diskconf(void);
d92 1
a92 1
cpu_configure()
@


1.9.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9.2.2 2001/07/04 10:22:47 niklas Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.9.2.2 2001/07/04 10:22:47 niklas Exp $
@


1.9.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
 *      $Id$
@


1.9.2.5
log
@repair
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9.2.4 2001/11/13 21:04:16 niklas Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.9.2.4 2001/11/13 21:04:16 niklas Exp $
@


1.8
log
@autoconf.c:
	calculate delay time for delay() before it is acutally used.
	add support for md_diskconf come closer to supporting crashdumps,
	eventually this code should be un if 0 ed and supported.
	add the wd device as a supported device, fix some comments.
clock.c:
	support calculation of delay loop earlier, do the spin loop correcly,
	unsigned math on the lower half, not signed math.
conf.c:
	addd support for wd driver, block major 0, char major 11.
machdep.c:
	bus_space_map becomes a real function, not just inlined function.
	Support devices that are not mapped with bats (most still currently
	are mapped with bats,...). BAT mapping does not allow proper
	mapping of cachable devices.
	mapiodev HACK, NEEDS TO BE REMOVED. added for quicker import
	of BROKEN mac drivers. the drivers NEED to be rewritten in
	a busified manner. it would FIX all of the endian swabbing
	done by each driver. (Is that emphasized enough?)

	bus_space_(read|write)_raw_multi as functions, should these
	be turned into inline functions and put in bus.h?
ofw_machdep.c:
	removed extranious variable.
openfirm.c:
	telling openfirmware to "boot" will put the system
	in somewhat of a strange state, try reset-all, but that
	typically fails, therefore, try OF_exit before spinning.
pmap.c:
	support stealing memory from kernel address space so that
	mappings can be created before vm is initalized.
vm_machdep.c:
	maybe the meaning of removing this will later become obvious. ???
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.7 1998/08/22 18:31:52 rahnds Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.7 1998/08/22 18:31:52 rahnds Exp $
d524 6
a529 3
#define	T_BUS	0
#define	T_SCSI	1
#define	T_DISK	2
d537 1
d539 2
d542 1
d554 3
d563 2
d581 1
a581 1
	} while(dp->type != T_SCSI);
@


1.7
log
@Various changes to allow mixing of ofw drivers and real drivers.
NCR driver seems to work.
Major changes are isa can be child of pci or mainbus.
ofroot is child of mainbus not root.
ofw bus configured before pci bus
Note that if a pci device configures accessing of driver will crash
the system. they need to be exclusive.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.6 1998/08/06 15:04:05 pefo Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.6 1998/08/06 15:04:05 pefo Exp $
d76 1
d95 2
d106 28
d136 3
a138 1
	cold = 0;
d165 46
d215 1
d217 1
a217 1
	{ "ofdisk",	4 },	/* 2 = ofdisk */
d551 1
a551 1
 * Look at the string 'cp' and decode the boot device.
@


1.6
log
@Some small fixes for non ofw systems
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.5 1998/05/29 04:15:37 rahnds Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.5 1998/05/29 04:15:37 rahnds Exp $
d94 1
a94 2
	if(config_rootfound("mainbus", "mainbus") == 0)
		panic("no mainbus found");
d98 3
@


1.5
log
@Major changes here and there, tweaks elsewhere.
Support for Openfirmware drivers was reintroduced so that more systems
were supported. This should work with the real driver configurations
as well.

Bootloader files were deleted/replaced with the newer versions in the
subdirectory. Some effort has been made to be closer to support booting
(at least the bootloader) on the Mac.

Config files that end with OFW are the openfirmware versions of the kernels
without have native drivers.

Native driver support has not been changed, presumably it still works.
I couldn't test that.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.4 1997/10/21 11:00:09 pefo Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.4 1997/10/21 11:00:09 pefo Exp $
d96 3
a98 1
	ofrootfound();
@


1.4
log
@Straighten up boot options.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.3 1997/10/13 13:42:53 pefo Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.3 1997/10/13 13:42:53 pefo Exp $
d96 1
d132 2
a133 1
	{ "sd",	2 },	/* 2 = sd */
d246 1
a246 1
		boothowto |= RB_SINGLE;
@


1.3
log
@Monolithic (No OpenFirmware driver crap...) PowerPC kernel. This is the
first release based on Wolfgang Solfrank, TooLs GmbH, work. Most OFW stuff
has been ripped out. Only a few functions for memory probing and halt/reboot
functionality has been kept. The kernel currently works with V.I's power.4e
PowerPC604 board, but more will come.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9 1997/05/18 13:45:20 pefo Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.9 1997/05/18 13:45:20 pefo Exp $
d73 1
d233 1
d434 1
a434 1
	char *attachment;
d436 1
d438 7
a444 9

/*
 * Look at the string 'cp' and decode the boot device.
 * Boot names look like: '/pci/scsi@@c/disk@@0,0/bsd'
 * (beware for empty scsi id's...)
 */
void
makebootdev(cp)
	char *cp;
a445 1
	int	unit, part, ctrl;
d447 3
a449 3
		{ "multi", "fd" },
		{ "eisa", "wd" },
		{ "scsi", "sd" },
d454 3
a456 2
	while (dp->attachment) {
		if (strncmp (cp, dp->attachment, strlen(dp->attachment)) == 0)
d458 1
d461 30
a490 2
	if (!dp->attachment) {
		printf("Warning: boot device unrecognized: %s\n", cp);
d493 2
a494 8
	ctrl = getpno(&cp);
	if(*cp++ == ')')
		unit = getpno(&cp);
	if(*cp++ == ')')
		getpno(&cp);
	if(*cp++ == ')')
		part = getpno(&cp) - 1;
	sprintf(bootdev, "%s%d%c", dp->dev, ctrl*16 + unit, 'a' + part);
d504 2
a505 1
	while(*cx && *cx != '(')
a506 6
	if(*cx == '(') {
		cx++;
		while(*cx && *cx != ')') {
			val = val * 10 + *cx - '0';
			cx++;
		}
@


1.2
log
@Adding OpenBSD tags to files.
@
text
@d1 1
a1 3
/*	$OpenBSD:$	*/
/*	$NetBSD: autoconf.c,v 1.1 1996/09/30 16:34:39 ws Exp $	*/

d3 9
a11 3
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
d23 30
a52 14
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d56 3
d60 1
a61 2
#include <sys/reboot.h>
#include <sys/systm.h>
d63 1
a63 1
#include <machine/powerpc.h>
d65 10
a74 5
extern int cold;

void configure __P((void));
void setroot __P((void));
void swapconf __P((void));
d76 8
d86 2
a87 1
 * Determine device configuration for a machine.
d92 3
a94 1
	ofrootfound();
a96 4
	/*
	 * Setup root device.
	 * Configure swap area.
	 */
d103 113
a215 1
 * Try to find the device we were booted from to set rootdev.
d220 132
a351 3
	char *cp;
	
	if (mountroot) {
d353 2
a354 1
		 * rootdev/swdevt/mountroot etc. already setup by config.
d358 21
a378 1
	
d380 1
a380 1
	 * Try to find the device where we were booted from.
d382 8
a389 8
	for (cp = bootpath + strlen(bootpath); --cp >= bootpath;) {
		if (*cp == '/') {
			*cp = '\0';
			if (!dk_match(bootpath)) {
				*cp = '/';
				break;
			}
			*cp = '/';
d392 35
a426 3
	if (cp < bootpath || boothowto & RB_ASKNAME) {
		/* Insert -a processing here				XXX */
		panic("Cannot find root device");
d428 1
a428 1
	dk_cleanup();
d431 5
d437 3
a439 1
 * Configure swap space
d442 34
a475 1
swapconf()
d477 10
a486 10
	struct swdevt *swp;
	int nblks;
	
	for (swp = swdevt; swp->sw_dev != NODEV; swp++)
		if (bdevsw[major(swp->sw_dev)].d_psize) {
			nblks = (*bdevsw[major(swp->sw_dev)].d_psize)(swp->sw_dev);
			if (nblks != -1
			    && (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
			swp->sw_nblks = ctod(dtoc(swp->sw_nblks));
d488 3
a490 1
	dumpconf();
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@Check-in of powerpc kernel support.
NOTE: This will not work until the other pieces are checked in.
This is primarily the NetBSD powerpc port, with modifications
to support ELF. 
@
text
@@
