head	1.17;
access;
symbols
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	UBC_SYNC_A:1.17
	UBC_SYNC_B:1.17
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	SMP:1.12.0.6
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.4
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	powerpc_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2001.09.01.15.44.20;	author drahn;	state dead;
branches;
next	1.16;

1.16
date	2001.06.24.05.06.13;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.14.08.02.12;	author drahn;	state Exp;
branches;
next	1.14;

1.14
date	2000.10.18.21.00.39;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.24.04.53.01;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	99.01.08.04.29.09;	author millert;	state Exp;
branches
	1.12.6.1;
next	1.11;

1.11
date	98.10.03.21.18.56;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.03.31.18.21.30;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	98.02.19.20.36.43;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.01.11.20.42.07;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	97.10.18.10.35.04;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.10.14.17.11.12;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	97.10.13.13.42.57;	author pefo;	state Exp;
branches;
next	1.4;

1.4
date	97.08.08.21.46.50;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	97.04.07.12.00.17;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.12.28.06.21.55;	author rahnds;	state Exp;
branches;
next	1.1;

1.1
date	96.12.21.20.35.57;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.12.21.20.35.57;	author rahnds;	state Exp;
branches;
next	;

1.12.6.1
date	2001.05.14.21.36.55;	author niklas;	state Exp;
branches;
next	1.12.6.2;

1.12.6.2
date	2001.07.04.10.22.54;	author niklas;	state Exp;
branches;
next	1.12.6.3;

1.12.6.3
date	2001.10.31.03.07.55;	author nate;	state dead;
branches;
next	1.12.6.4;

1.12.6.4
date	2001.11.13.21.04.16;	author niklas;	state Exp;
branches;
next	1.12.6.5;

1.12.6.5
date	2001.11.13.22.14.34;	author niklas;	state dead;
branches;
next	;


desc
@@


1.17
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/powerpc to macppc/macppc

This moves hardware specific files from the common directory to the
platform specific directory. This leaves common files.
With this change all of the debugger (db_) files have been moved to
the platform specific directory. The debugger should be reconsidered
and commonized.
@
text
@/*	$OpenBSD: disksubr.c,v 1.16 2001/06/24 05:06:13 drahn Exp $	*/
/*	$NetBSD: disksubr.c,v 1.21 1996/05/03 19:42:03 christos Exp $	*/

/*
 * Copyright (c) 1996 Theo de Raadt
 * Copyright (c) 1982, 1986, 1988 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ufs_disksubr.c	7.16 (Berkeley) 5/4/91
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/syslog.h>
#include <sys/disk.h>

#define	b_cylin	b_resid

#define BOOT_MAGIC 0xAA55
#define BOOT_MAGIC_OFF (DOSPARTOFF+NDOSPART*sizeof(struct dos_partition))

void
dk_establish(dk, dev)
	struct disk *dk;
	struct device *dev;
{
}

/*
 * Attempt to read a disk label from a device
 * using the indicated strategy routine.
 * The label must be partly set up before this:
 * secpercyl, secsize and anything required for a block i/o read
 * operation in the driver's strategy/start routines
 * must be filled in before calling us.
 *
 * If dos partition table requested, attempt to load it and
 * find disklabel inside a DOS partition. Also, if bad block
 * table needed, attempt to extract it as well. Return buffer
 * for use in signalling errors if requested.
 *
 * We would like to check if each MBR has a valid BOOT_MAGIC, but
 * we cannot because it doesn't always exist. So.. we assume the
 * MBR is valid.
 *
 * Returns null on success and an error string on failure.
 */
char *
readdisklabel(dev, strat, lp, osdep, spoofonly)
	dev_t dev;
	void (*strat) __P((struct buf *));
	register struct disklabel *lp;
	struct cpu_disklabel *osdep;
	int spoofonly;
{
	struct dos_partition *dp = osdep->dosparts, *dp2;
	struct dkbad *bdp = &DKBAD(osdep);
	struct buf *bp;
	struct disklabel *dlp;
	char *msg = NULL, *cp;
	char *s;
	int dospartoff, cyl, i, ourpart = -1;
	/* HFS variables */
	int part_cnt, n, hfspartoff;
	struct part_map_entry *part;


	/* minimal requirements for archtypal disk label */
	if (lp->d_secsize == 0)
		lp->d_secsize = DEV_BSIZE;
	if (lp->d_secperunit == 0)
		lp->d_secperunit = 0x1fffffff;
	lp->d_npartitions = RAW_PART + 1;
	for (i = 0; i < RAW_PART; i++) {
		lp->d_partitions[i].p_size = 0;
		lp->d_partitions[i].p_offset = 0;
	}
	if (lp->d_partitions[i].p_size == 0)
		lp->d_partitions[i].p_size = 0x1fffffff;
	lp->d_partitions[i].p_offset = 0;

	/* get a buffer and initialize it */
	bp = geteblk((int)lp->d_secsize);
	bp->b_dev = dev;

	/* DPME (HFS) disklabel */

	bp->b_blkno = 1; 
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_BUSY | B_READ;
	bp->b_cylin = 1 / lp->d_secpercyl;
	(*strat)(bp);

	/* if successful, wander through DPME partition table */
	if (biowait(bp)) {
		msg = "DPME partition I/O error";
		goto hfs_done;
	}

	part = (struct part_map_entry *)bp->b_data;
	/* if first partition is not valid, assume not HFS/DPME partitioned */
        if (part->pmSig != PART_ENTRY_MAGIC) {
		msg = "DPME partition invalid";
		osdep->macparts[0].pmSig = 0; /* make invalid */
		goto hfs_done;
        }
	osdep->macparts[0] = *part;
	part_cnt = part->pmMapBlkCnt;
	n = 0;
	for (i = 0; i < part_cnt; i++) {
		struct partition *pp = &lp->d_partitions[8+n];

		bp->b_blkno = 1+i; 
		bp->b_bcount = lp->d_secsize;
		bp->b_flags = B_BUSY | B_READ;
		bp->b_cylin = 1+i / lp->d_secpercyl;
		(*strat)(bp);

		if (biowait(bp)) {
			msg = "DPME partition I/O error";
			goto hfs_done;
		}
		part = (struct part_map_entry *)bp->b_data;
		/* toupper the string, in case caps are different... */
		for (s = part->pmPartType; *s; s++)
			if ((*s >= 'a') && (*s <= 'z'))
				*s = (*s - 'a' + 'A');

		if (0 == strcmp(part->pmPartType, PART_TYPE_OPENBSD)) {
			hfspartoff = part->pmPyPartStart;
			osdep->macparts[1] = *part;
		}
		/* currently we ignore all but HFS partitions */
		if (0 == strcmp(part->pmPartType, PART_TYPE_MAC)) {
			pp->p_offset = part->pmPyPartStart;
			pp->p_size = part->pmPartBlkCnt;
			pp->p_fstype = FS_HFS;
			n++;
#if 0
			printf("found DPME HFS partition [%s], adding to fake\n",
				part->pmPartName);
#endif
		}
	}
	lp->d_npartitions = MAXPARTITIONS;

	/* don't read the on-disk label if we are in spoofed-only mode */
	if (spoofonly)
		goto done;

	/* next, dig out disk label */
	bp->b_blkno = hfspartoff;
	bp->b_cylin = hfspartoff/lp->d_secpercyl; /* XXX */
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_BUSY | B_READ;
	(*strat)(bp);

	/* if successful, locate disk label within block and validate */
	if (biowait(bp)) {
		/* XXX we return the faked label built so far */
		msg = "disk label I/O error";
		goto done;
	}
	goto found_disklabel;


hfs_done:
	/* MBR type disklabel */
	/* do dos partitions in the process of getting disklabel? */
	dospartoff = 0;
	cyl = LABELSECTOR / lp->d_secpercyl;
	if (dp) {
	        daddr_t part_blkno = DOSBBSECTOR;
		unsigned long extoff = 0;
		int wander = 1, loop = 0;
		n = 0;

		/*
		 * Read dos partition table, follow extended partitions.
		 * Map the partitions to disklabel entries i-p
		 */
		while (wander && n < 8 && loop < 8) {
		        loop++;
			wander = 0;

			/* read boot record */
			bp->b_blkno = part_blkno;
			bp->b_bcount = lp->d_secsize;
			bp->b_flags = B_BUSY | B_READ;
			bp->b_cylin = part_blkno / lp->d_secpercyl;
			(*strat)(bp);
		     
			/* if successful, wander through dos partition table */
			if (biowait(bp)) {
				msg = "dos partition I/O error";
				goto done;
			}
			bcopy(bp->b_data + DOSPARTOFF, dp, NDOSPART * sizeof(*dp));

			if (ourpart == -1) {
				/* Search for our MBR partition */
				for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
				    i++, dp2++)
					if (get_le(&dp2->dp_size) &&
					    dp2->dp_typ == DOSPTYP_OPENBSD)
						ourpart = i;
				for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
				    i++, dp2++)
					if (get_le(&dp2->dp_size) &&
					    dp2->dp_typ == DOSPTYP_FREEBSD)
						ourpart = i;
				for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
				    i++, dp2++)
					if (get_le(&dp2->dp_size) &&
					    dp2->dp_typ == DOSPTYP_NETBSD)
						ourpart = i;
				if (ourpart == -1)
					goto donot;
				/*
				 * This is our MBR partition. need sector address
				 * for SCSI/IDE, cylinder for ESDI/ST506/RLL
				 */
				dp2 = &dp[ourpart];
				dospartoff = get_le(&dp2->dp_start) + part_blkno;
				cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);

				/* XXX build a temporary disklabel */
				lp->d_partitions[0].p_size = get_le(&dp2->dp_size);
				lp->d_partitions[0].p_offset =
					get_le(&dp2->dp_start) + part_blkno;
				if (lp->d_ntracks == 0)
					lp->d_ntracks = dp2->dp_ehd + 1;
				if (lp->d_nsectors == 0)
					lp->d_nsectors = DPSECT(dp2->dp_esect);
				if (lp->d_secpercyl == 0)
					lp->d_secpercyl = lp->d_ntracks *
					    lp->d_nsectors;
			}
donot:
			/*
			 * In case the disklabel read below fails, we want to
			 * provide a fake label in i-p.
			 */
			for (dp2=dp, i=0; i < NDOSPART && n < 8; i++, dp2++) {
				struct partition *pp = &lp->d_partitions[8+n];

				if (dp2->dp_typ == DOSPTYP_OPENBSD)
					continue;
				if (get_le(&dp2->dp_size) > lp->d_secperunit)
					continue;
				if (get_le(&dp2->dp_size))
					pp->p_size = get_le(&dp2->dp_size);
				if (get_le(&dp2->dp_start))
					pp->p_offset =
					    get_le(&dp2->dp_start) + part_blkno;

				switch (dp2->dp_typ) {
				case DOSPTYP_UNUSED:
					for (cp = (char *)dp2;
					    cp < (char *)(dp2 + 1); cp++)
						if (*cp)
							break;
					/*
					 * Was it all zeroes?  If so, it is
					 * an unused entry that we don't
					 * want to show.
					 */
					if (cp == (char *)(dp2 + 1))
					    continue;
					lp->d_partitions[8 + n++].p_fstype =
					    FS_UNUSED;
					break;

				case DOSPTYP_LINUX:
					pp->p_fstype = FS_EXT2FS;
					n++;
					break;

				case DOSPTYP_FAT12:
				case DOSPTYP_FAT16S:
				case DOSPTYP_FAT16B:
				case DOSPTYP_FAT16C:
				case DOSPTYP_FAT32:
					pp->p_fstype = FS_MSDOS;
					n++;
					break;
				case DOSPTYP_EXTEND:
				case DOSPTYP_EXTENDL:
					part_blkno = get_le(&dp2->dp_start) + extoff;
					if (!extoff)
						extoff = get_le(&dp2->dp_start);
					wander = 1;
					break;
				default:
					pp->p_fstype = FS_OTHER;
					n++;
					break;
				}
			}
		}
		lp->d_bbsize = 8192;
		lp->d_sbsize = 64*1024;		/* XXX ? */
		lp->d_npartitions = MAXPARTITIONS;
	}

	/* don't read the on-disk label if we are in spoofed-only mode */
	if (spoofonly)
		goto done;

	/* next, dig out disk label */
	bp->b_blkno = dospartoff + LABELSECTOR;
	bp->b_cylin = cyl;
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_BUSY | B_READ;
	(*strat)(bp);

	/* if successful, locate disk label within block and validate */
	if (biowait(bp)) {
		/* XXX we return the faked label built so far */
		msg = "disk label I/O error";
		goto done;
	}

found_disklabel:
	for (dlp = (struct disklabel *)bp->b_data;
	    dlp <= (struct disklabel *)(bp->b_data + lp->d_secsize - sizeof(*dlp));
	    dlp = (struct disklabel *)((char *)dlp + sizeof(long))) {
		if (dlp->d_magic != DISKMAGIC || dlp->d_magic2 != DISKMAGIC) {
			if (msg == NULL)
				msg = "no disk label";
		} else if (dlp->d_npartitions > MAXPARTITIONS ||
			   dkcksum(dlp) != 0)
			msg = "disk label corrupted";
		else {
			*lp = *dlp;
			msg = NULL;
			break;
		}
	}

	if (msg) {
#if defined(CD9660)
		if (iso_disklabelspoof(dev, strat, lp) == 0)
			msg = NULL;
#endif
		goto done;
	}

	/* obtain bad sector table if requested and present */
	if (bdp && (lp->d_flags & D_BADSECT)) {
		struct dkbad *db;

		i = 0;
		do {
			/* read a bad sector table */
			bp->b_flags = B_BUSY | B_READ;
			bp->b_blkno = lp->d_secperunit - lp->d_nsectors + i;
			if (lp->d_secsize > DEV_BSIZE)
				bp->b_blkno *= lp->d_secsize / DEV_BSIZE;
			else
				bp->b_blkno /= DEV_BSIZE / lp->d_secsize;
			bp->b_bcount = lp->d_secsize;
			bp->b_cylin = lp->d_ncylinders - 1;
			(*strat)(bp);

			/* if successful, validate, otherwise try another */
			if (biowait(bp)) {
				msg = "bad sector table I/O error";
			} else {
				db = (struct dkbad *)(bp->b_data);
#define DKBAD_MAGIC 0x4321
				if (db->bt_mbz == 0
					&& db->bt_flag == DKBAD_MAGIC) {
					msg = NULL;
					*bdp = *db;
					break;
				} else
					msg = "bad sector table corrupted";
			}
		} while ((bp->b_flags & B_ERROR) && (i += 2) < 10 &&
			i < lp->d_nsectors);
	}

done:
	bp->b_flags |= B_INVAL;
	brelse(bp);
	return (msg);
}

/*
 * Check new disk label for sensibility
 * before setting it.
 */
int
setdisklabel(olp, nlp, openmask, osdep)
	register struct disklabel *olp, *nlp;
	u_long openmask;
	struct cpu_disklabel *osdep;
{
	register int i;
	register struct partition *opp, *npp;

	/* sanity clause */
	if (nlp->d_secpercyl == 0 || nlp->d_secsize == 0 ||
	    (nlp->d_secsize % DEV_BSIZE) != 0)
		return(EINVAL);

	/* special case to allow disklabel to be invalidated */
	if (nlp->d_magic == 0xffffffff) {
		*olp = *nlp;
		return (0);
	}

	if (nlp->d_magic != DISKMAGIC || nlp->d_magic2 != DISKMAGIC ||
	    dkcksum(nlp) != 0)
		return (EINVAL);

	/* XXX missing check if other dos partitions will be overwritten */

	while (openmask != 0) {
		i = ffs(openmask) - 1;
		openmask &= ~(1 << i);
		if (nlp->d_npartitions <= i)
			return (EBUSY);
		opp = &olp->d_partitions[i];
		npp = &nlp->d_partitions[i];
		if (npp->p_offset != opp->p_offset || npp->p_size < opp->p_size)
			return (EBUSY);
		/*
		 * Copy internally-set partition information
		 * if new label doesn't include it.		XXX
		 */
		if (npp->p_fstype == FS_UNUSED && opp->p_fstype != FS_UNUSED) {
			npp->p_fstype = opp->p_fstype;
			npp->p_fsize = opp->p_fsize;
			npp->p_frag = opp->p_frag;
			npp->p_cpg = opp->p_cpg;
		}
	}
	nlp->d_checksum = 0;
	nlp->d_checksum = dkcksum(nlp);
	*olp = *nlp;
	return (0);
}


/*
 * Write disk label back to device after modification.
 * XXX cannot handle OpenBSD partitions in extended partitions!
 */
int
writedisklabel(dev, strat, lp, osdep)
	dev_t dev;
	void (*strat) __P((struct buf *));
	register struct disklabel *lp;
	struct cpu_disklabel *osdep;
{
	struct dos_partition *dp = osdep->dosparts, *dp2;
	struct buf *bp;
	struct disklabel *dlp;
	int error, dospartoff, cyl, i;
	int ourpart = -1;

	/* get a buffer and initialize it */
	bp = geteblk((int)lp->d_secsize);
	bp->b_dev = dev;

	/* try DPME partition */
	if (osdep->macparts[0].pmSig == PART_ENTRY_MAGIC) {
		
		/* only write if a valid "OpenBSD" partition type exists */
		if (osdep->macparts[1].pmSig == PART_ENTRY_MAGIC) {
			bp->b_blkno = osdep->macparts[1].pmPyPartStart;
			bp->b_cylin = bp->b_blkno/lp->d_secpercyl;
			bp->b_bcount = lp->d_secsize;
			bp->b_flags = B_BUSY | B_WRITE;
			*(struct disklabel *)bp->b_data = *lp;
			(*strat)(bp);
			error = biowait(bp);
			goto done;
		}

		/* SHOULD FAIL TO WRITE LABEL IF VALID HFS partition exists
		 * and no OpenBSD partition exists 
		 */
		error = 1; /* EPERM? */
		goto done;
	}

	/* do dos partitions in the process of getting disklabel? */
	dospartoff = 0;
	cyl = LABELSECTOR / lp->d_secpercyl;
	if (dp) {
		/* read master boot record */
		bp->b_blkno = DOSBBSECTOR;
		bp->b_bcount = lp->d_secsize;
		bp->b_flags = B_BUSY | B_READ;
		bp->b_cylin = DOSBBSECTOR / lp->d_secpercyl;
		(*strat)(bp);

		if ((error = biowait(bp)) != 0)
			goto done;

		/* XXX how do we check veracity/bounds of this? */
		bcopy(bp->b_data + DOSPARTOFF, dp,
		    NDOSPART * sizeof(*dp));

		for (dp2=dp, i=0; i < NDOSPART && ourpart == -1; i++, dp2++)
			if (get_le(&dp2->dp_size) && dp2->dp_typ == DOSPTYP_OPENBSD)
				ourpart = i;
		for (dp2=dp, i=0; i < NDOSPART && ourpart == -1; i++, dp2++)
			if (get_le(&dp2->dp_size) && dp2->dp_typ == DOSPTYP_FREEBSD)
				ourpart = i;
		for (dp2=dp, i=0; i < NDOSPART && ourpart == -1; i++, dp2++)
			if (get_le(&dp2->dp_size) && dp2->dp_typ == DOSPTYP_NETBSD)
				ourpart = i;

		if (ourpart != -1) {
			dp2 = &dp[ourpart];

			/*
			 * need sector address for SCSI/IDE,
			 * cylinder for ESDI/ST506/RLL
			 */
			dospartoff = get_le(&dp2->dp_start);
			cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);
		}
	}

	/* next, dig out disk label */
	bp->b_blkno = dospartoff + LABELSECTOR;
	bp->b_cylin = cyl;
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_BUSY | B_READ;
	(*strat)(bp);

	/* if successful, locate disk label within block and validate */
	if ((error = biowait(bp)) != 0)
		goto done;
	for (dlp = (struct disklabel *)bp->b_data;
	    dlp <= (struct disklabel *)(bp->b_data + lp->d_secsize - sizeof(*dlp));
	    dlp = (struct disklabel *)((char *)dlp + sizeof(long))) {
		if (dlp->d_magic == DISKMAGIC && dlp->d_magic2 == DISKMAGIC &&
		    dkcksum(dlp) == 0) {
			*dlp = *lp;
			bp->b_flags = B_BUSY | B_WRITE;
			(*strat)(bp);
			error = biowait(bp);
			goto done;
		}
	}

	/* Write it in the regular place. */
	*(struct disklabel *)bp->b_data = *lp;
	bp->b_flags = B_BUSY | B_WRITE;
	(*strat)(bp);
	error = biowait(bp);
	goto done;

done:
	bp->b_flags |= B_INVAL;
	brelse(bp);
	return (error);
}

/*
 * Determine the size of the transfer, and make sure it is
 * within the boundaries of the partition. Adjust transfer
 * if needed, and signal errors or early completion.
 */
int
bounds_check_with_label(bp, lp, osdep, wlabel)
	struct buf *bp;
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
	int wlabel;
{
#define blockpersec(count, lp) ((count) * (((lp)->d_secsize) / DEV_BSIZE))
	struct partition *p = lp->d_partitions + DISKPART(bp->b_dev);
	int labelsector = blockpersec(lp->d_partitions[RAW_PART].p_offset, lp) +
	    LABELSECTOR;
	int sz = howmany(bp->b_bcount, DEV_BSIZE);

	/* avoid division by zero */
	if (lp->d_secpercyl == 0) {
		bp->b_error = EINVAL;
		goto bad;
	}

	if (bp->b_blkno + sz > blockpersec(p->p_size, lp)) {
		sz = blockpersec(p->p_size, lp) - bp->b_blkno;
		if (sz == 0) {
			/* If exactly at end of disk, return EOF. */
			bp->b_resid = bp->b_bcount;
			goto done;
		}
		if (sz < 0) {
			/* If past end of disk, return EINVAL. */
			bp->b_error = EINVAL;
			goto bad;
		}
		/* Otherwise, truncate request. */
		bp->b_bcount = sz << DEV_BSHIFT;
	}

	/* Overwriting disk label? */
	if (bp->b_blkno + blockpersec(p->p_offset, lp) <= labelsector &&
#if LABELSECTOR != 0
	    bp->b_blkno + blockpersec(p->p_offset, lp) + sz > labelsector &&
#endif
	    (bp->b_flags & B_READ) == 0 && !wlabel) {
		bp->b_error = EROFS;
		goto bad;
	}

	/* calculate cylinder for disksort to order transfers with */
	bp->b_cylin = (bp->b_blkno + blockpersec(p->p_offset, lp)) /
	    lp->d_secpercyl;
	return (1);

bad:
	bp->b_flags |= B_ERROR;
done:
	return (0);
}
@


1.16
log
@register i; is not a valid variable declaration.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.15 2001/03/14 08:02:12 drahn Exp $	*/
@


1.15
log
@Support shared disks with MacOS. This is only one of the pieces of
the task. The kernel now support a BSD disklabel located inside
a HFS(DPME) partition of type "OpenBSD". It will use this disklabel
for OpenBSD. If no OpenBSD DPME partition exists it will fake HFS
partitions for apple HFS partitions of the disk.
The tool to change the DPME partition type to OpenBSD and booting
support in ofwboot are not yet ready.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.15 2001/03/14 07:57:50 drahn Exp $	*/
d431 1
a431 1
	register i;
@


1.14
log
@typo in comment; from gluk@@ptci.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.13 2000/04/24 04:53:01 deraadt Exp $	*/
d92 1
d94 4
d117 83
d206 2
a207 1
		int wander = 1, n = 0, loop = 0;
d354 2
d498 22
@


1.13
log
@support DOSPTYP_EXTENDL like DOSPTYP_EXTEND; scott@@nts.umn.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.12 1999/01/08 04:29:09 millert Exp $	*/
d62 1
a62 1
 * using the indicated stategy routine.
@


1.12
log
@check for lp->d_secpercyl == 0) in bounds_check_with_label()
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.11 1998/10/03 21:18:56 millert Exp $	*/
d230 1
@


1.12.6.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.15 2001/03/14 08:02:12 drahn Exp $	*/
d62 1
a62 1
 * using the indicated strategy routine.
a91 1
	char *s;
a92 4
	/* HFS variables */
	int part_cnt, n, hfspartoff;
	struct part_map_entry *part;

a111 83
	/* DPME (HFS) disklabel */

	bp->b_blkno = 1; 
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_BUSY | B_READ;
	bp->b_cylin = 1 / lp->d_secpercyl;
	(*strat)(bp);

	/* if successful, wander through DPME partition table */
	if (biowait(bp)) {
		msg = "DPME partition I/O error";
		goto hfs_done;
	}

	part = (struct part_map_entry *)bp->b_data;
	/* if first partition is not valid, assume not HFS/DPME partitioned */
        if (part->pmSig != PART_ENTRY_MAGIC) {
		msg = "DPME partition invalid";
		osdep->macparts[0].pmSig = 0; /* make invalid */
		goto hfs_done;
        }
	osdep->macparts[0] = *part;
	part_cnt = part->pmMapBlkCnt;
	n = 0;
	for (i = 0; i < part_cnt; i++) {
		struct partition *pp = &lp->d_partitions[8+n];

		bp->b_blkno = 1+i; 
		bp->b_bcount = lp->d_secsize;
		bp->b_flags = B_BUSY | B_READ;
		bp->b_cylin = 1+i / lp->d_secpercyl;
		(*strat)(bp);

		if (biowait(bp)) {
			msg = "DPME partition I/O error";
			goto hfs_done;
		}
		part = (struct part_map_entry *)bp->b_data;
		/* toupper the string, in case caps are different... */
		for (s = part->pmPartType; *s; s++)
			if ((*s >= 'a') && (*s <= 'z'))
				*s = (*s - 'a' + 'A');

		if (0 == strcmp(part->pmPartType, PART_TYPE_OPENBSD)) {
			hfspartoff = part->pmPyPartStart;
			osdep->macparts[1] = *part;
		}
		/* currently we ignore all but HFS partitions */
		if (0 == strcmp(part->pmPartType, PART_TYPE_MAC)) {
			pp->p_offset = part->pmPyPartStart;
			pp->p_size = part->pmPartBlkCnt;
			pp->p_fstype = FS_HFS;
			n++;
#if 0
			printf("found DPME HFS partition [%s], adding to fake\n",
				part->pmPartName);
#endif
		}
	}
	lp->d_npartitions = MAXPARTITIONS;

	/* don't read the on-disk label if we are in spoofed-only mode */
	if (spoofonly)
		goto done;

	/* next, dig out disk label */
	bp->b_blkno = hfspartoff;
	bp->b_cylin = hfspartoff/lp->d_secpercyl; /* XXX */
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_BUSY | B_READ;
	(*strat)(bp);

	/* if successful, locate disk label within block and validate */
	if (biowait(bp)) {
		/* XXX we return the faked label built so far */
		msg = "disk label I/O error";
		goto done;
	}
	goto found_disklabel;


hfs_done:
	/* MBR type disklabel */
d118 1
a118 2
		int wander = 1, loop = 0;
		n = 0;
a229 1
				case DOSPTYP_EXTENDL:
a263 2

found_disklabel:
a405 22

	/* try DPME partition */
	if (osdep->macparts[0].pmSig == PART_ENTRY_MAGIC) {
		
		/* only write if a valid "OpenBSD" partition type exists */
		if (osdep->macparts[1].pmSig == PART_ENTRY_MAGIC) {
			bp->b_blkno = osdep->macparts[1].pmPyPartStart;
			bp->b_cylin = bp->b_blkno/lp->d_secpercyl;
			bp->b_bcount = lp->d_secsize;
			bp->b_flags = B_BUSY | B_WRITE;
			*(struct disklabel *)bp->b_data = *lp;
			(*strat)(bp);
			error = biowait(bp);
			goto done;
		}

		/* SHOULD FAIL TO WRITE LABEL IF VALID HFS partition exists
		 * and no OpenBSD partition exists 
		 */
		error = 1; /* EPERM? */
		goto done;
	}
@


1.12.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.12.6.1 2001/05/14 21:36:55 niklas Exp $	*/
d431 1
a431 1
	register int i;
@


1.12.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.12.6.2 2001/07/04 10:22:54 niklas Exp $	*/
@


1.12.6.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.12.6.5
log
@repair
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.12.6.4 2001/11/13 21:04:16 niklas Exp $	*/
@


1.11
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.10 1998/03/31 18:21:30 mickey Exp $	*/
d500 6
@


1.10
log
@real cute to have those fingerprints cleaned up
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.9 1998/02/19 20:36:43 deraadt Exp $	*/
d80 1
a80 1
readdisklabel(dev, strat, lp, osdep)
d85 1
d246 4
@


1.9
log
@add netbsd partition, rename 386BSD one to FreeBSD..
@
text
@d1 1
a1 1
x1/*	$OpenBSD: disksubr.c,v 1.8 1998/01/11 20:42:07 provos Exp $	*/
@


1.8
log
@disklabel spoofing for FAT32.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.7 1997/10/18 10:35:04 deraadt Exp $	*/
d151 6
a156 1
					    dp2->dp_typ == DOSPTYP_386BSD)
d424 4
a427 1
			if (get_le(&dp2->dp_size) && dp2->dp_typ == DOSPTYP_386BSD)
@


1.7
log
@do not create spoofed partition for DOSTYP_OPENBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.27 1997/10/02 00:50:51 deraadt Exp $	*/
d219 1
@


1.6
log
@Get a few things right...
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.5 1997/10/13 13:42:57 pefo Exp $	*/
d142 1
a142 1
				/* Search for our DOS partition */
d156 1
a156 1
				 * This is our DOS partition. need sector address
d183 4
d455 7
a461 1
	error = ESRCH;
@


1.5
log
@Monolithic (No OpenFirmware driver crap...) PowerPC kernel. This is the
first release based on Wolfgang Solfrank, TooLs GmbH, work. Most OFW stuff
has been ripped out. Only a few functions for memory probing and halt/reboot
functionality has been kept. The kernel currently works with V.I's power.4e
PowerPC604 board, but more will come.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.15 1997/08/08 21:46:36 niklas Exp $	*/
d51 1
a51 1
#define BOOT_MAGIC_OFF (MBRPARTOFF+NMBRPART*sizeof(struct mbr_partition))
d69 1
a69 1
 * find disklabel inside a MBR partition. Also, if bad block
d86 1
a86 1
	struct mbr_partition *dp = osdep->dosparts, *dp2;
d115 1
a115 1
	        daddr_t part_blkno = MBRSECTOR;
d139 1
a139 1
			bcopy(bp->b_data + MBRPARTOFF, dp, NMBRPART * sizeof(*dp));
d142 2
a143 2
				/* Search for our MBR partition */
				for (dp2=dp, i=0; i < NMBRPART && ourpart == -1;
d145 2
a146 2
					if (get_le(&dp2->mbr_size) &&
					    dp2->mbr_type == DOSPTYP_OPENBSD)
d148 1
a148 1
				for (dp2=dp, i=0; i < NMBRPART && ourpart == -1;
d150 2
a151 2
					if (get_le(&dp2->mbr_size) &&
					    dp2->mbr_type == DOSPTYP_386BSD)
d156 1
a156 1
				 * This is our MBR partition. need sector address
d160 2
a161 2
				dospartoff = get_le(&dp2->mbr_start) + part_blkno;
				cyl = DPCYL(dp2->mbr_scyl, dp2->mbr_ssect);
d164 1
a164 1
				lp->d_partitions[0].p_size = get_le(&dp2->mbr_size);
d166 1
a166 1
					get_le(&dp2->mbr_start) + part_blkno;
d168 1
a168 1
					lp->d_ntracks = dp2->mbr_ehd + 1;
d170 1
a170 1
					lp->d_nsectors = DPSECT(dp2->mbr_esect);
d180 1
a180 1
			for (dp2=dp, i=0; i < NMBRPART && n < 8; i++, dp2++) {
d183 3
a185 3
				if (get_le(&dp2->mbr_size))
					pp->p_size = get_le(&dp2->mbr_size);
				if (get_le(&dp2->mbr_start))
d187 1
a187 1
					    get_le(&dp2->mbr_start) + part_blkno;
d189 1
a189 1
				switch (dp2->mbr_type) {
d219 1
a219 1
					part_blkno = get_le(&dp2->mbr_start) + extoff;
d221 1
a221 1
						extoff = get_le(&dp2->mbr_start);
d382 1
a382 1
	struct mbr_partition *dp = osdep->dosparts, *dp2;
d397 1
a397 1
		bp->b_blkno = MBRSECTOR;
d400 1
a400 1
		bp->b_cylin = MBRSECTOR / lp->d_secpercyl;
d407 2
a408 2
		bcopy(bp->b_data + MBRPARTOFF, dp,
		    NMBRPART * sizeof(*dp));
d410 2
a411 2
		for (dp2=dp, i=0; i < NMBRPART && ourpart == -1; i++, dp2++)
			if (get_le(&dp2->mbr_size) && dp2->mbr_type == DOSPTYP_OPENBSD)
d413 2
a414 2
		for (dp2=dp, i=0; i < NMBRPART && ourpart == -1; i++, dp2++)
			if (get_le(&dp2->mbr_size) && dp2->mbr_type == DOSPTYP_386BSD)
d424 2
a425 2
			dospartoff = get_le(&dp2->mbr_start);
			cyl = DPCYL(dp2->mbr_scyl, dp2->mbr_ssect);
@


1.4
log
@Change the bounds_check_with_label API to also take a cpu_disklabel
reference for making transferral of meta-information possible from
readdisklabel to bounds_check_with_label.  The first (and maybe only)
thing that will use this is the multi-disklabel-format code on the
alpha where the labelsector is passed via cpu_disklabel so the label
write-protection can work correctly no matter what label was found.

Also use a new macro DKBAD to get at the dkbad field of the cpu_disklabel
implementations that contain it.  This too is for multi-disklabel
architectures where the "bad" field can be inside a union.  Use this
macro as a means for a driver to check if an architecture supports
dkbad constructs.

Remove proto of bounds_check_with_label from all MD disklabel.h as it
is in sys/disklabel.h.

I have not been able to test the changes everywhere, if I break anything
I apologize, and promise to fix it as soon as I become aware of it.
@
text
@d1 2
a2 2
/*	$OpenBSD: disksubr.c,v 1.3 1997/04/07 12:00:17 deraadt Exp $	*/
/*	$NetBSD: disksubr.c,v 1.1 1996/09/30 16:34:43 ws Exp $	*/
d5 2
a6 2
 * Copyright (C) 1996 Wolfgang Solfrank.
 * Copyright (C) 1996 TooLs GmbH.
d19 5
a23 3
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d25 13
a37 10
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d39 1
d41 1
a42 1
#include <sys/conf.h>
d44 2
a46 6
#include <sys/disklabel.h>
#include <sys/fcntl.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/stat.h>
#include <sys/systm.h>
d48 1
a48 17
static inline unsigned short get_short __P((void *p));
static inline unsigned long get_long __P((void *p));
static int get_netbsd_label __P((dev_t dev, void (*strat)(struct buf *),
				 struct disklabel *lp, daddr_t bno));
static int mbr_to_label __P((dev_t dev, void (*strat)(struct buf *),
			     daddr_t bno, struct disklabel *lp,
			     unsigned short *pnpart,
			     struct cpu_disklabel *osdep, daddr_t off));

/*
 * Little endian access routines
 */
static inline unsigned short
get_short(p)
	void *p;
{
	unsigned char *cp = p;
d50 2
a51 2
	return cp[0] | (cp[1] << 8);
}
d53 4
a56 3
static inline unsigned long
get_long(p)
	void *p;
a57 3
	unsigned char *cp = p;

	return cp[0] | (cp[1] << 8) | (cp[2] << 16) | (cp[3] << 24);
d61 17
a77 1
 * Get real NetBSD disk label
d79 2
a80 2
static int
get_netbsd_label(dev, strat, lp, bno)
d82 3
a84 3
	void (*strat)();
	struct disklabel *lp;
	daddr_t bno;
d86 2
d90 16
d111 128
a238 2
	/* Now get the label block */
	bp->b_blkno = bno + LABELSECTOR;
a240 1
	bp->b_cylinder = bp->b_blkno / (lp->d_secsize / DEV_BSIZE) / lp->d_secpercyl;
d243 4
a246 1
	if (biowait(bp))
d248 1
a248 1

d250 9
a258 6
	     dlp <= (struct disklabel *)(bp->b_data + lp->d_secsize - sizeof (*dlp));
	     dlp = (struct disklabel *)((char *)dlp + sizeof(long))) {
		if (dlp->d_magic == DISKMAGIC
		    && dlp->d_magic2 == DISKMAGIC
		    && dlp->d_npartitions <= MAXPARTITIONS
		    && dkcksum(dlp) == 0) {
d260 2
a261 2
			brelse(bp);
			return 1;
a263 38
done:
	bp->b_flags |= B_INVAL;
	brelse(bp);
	return 0;
}

/*
 * Construct disklabel entries from partition entries.
 */
static int
mbr_to_label(dev, strat, bno, lp, pnpart, osdep, off)
	dev_t dev;
	void (*strat)();
	daddr_t bno;
	struct disklabel *lp;
	unsigned short *pnpart;
	struct cpu_disklabel *osdep;
	daddr_t off;
{
	static int recursion = 0;
	struct mbr_partition *mp;
	struct partition *pp;
	struct buf *bp;
	int i, found = 0;

	/* Check for recursion overflow. */
	if (recursion > MAXPARTITIONS)
		return 0;

	/*
	 * Extended partitions seem to be relative to their first occurence?
	 */
	if (recursion++ == 1)
		off = bno;

	/* get a buffer and initialize it */
	bp = geteblk((int)lp->d_secsize);
	bp->b_dev = dev;
d265 5
a269 11
	/* Now get the MBR */
	bp->b_blkno = bno;
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_BUSY | B_READ;
	bp->b_cylinder = bp->b_blkno / (lp->d_secsize / DEV_BSIZE) / lp->d_secpercyl;
	(*strat)(bp);

	if (biowait(bp))
		goto done;

	if (get_short(bp->b_data + MBRMAGICOFF) != MBRMAGIC)
d271 1
d273 30
a302 33
	/* Extract info from MBR partition table */
	mp = (struct mbr_partition *)(bp->b_data + MBRPARTOFF);
	for (i = 0; i < NMBRPART; i++, mp++) {
		if (get_long(&mp->mbr_size)) {
			switch (mp->mbr_type) {
			case MBR_EXTENDED:
				if (*pnpart < MAXPARTITIONS) {
					pp = lp->d_partitions + *pnpart;
					bzero(pp, sizeof *pp);
					pp->p_size = get_long(&mp->mbr_size);
					pp->p_offset = off + get_long(&mp->mbr_start);
					++*pnpart;
				}
				if (found = mbr_to_label(dev, strat,
							 off + get_long(&mp->mbr_start),
							 lp, pnpart, osdep, off))
					goto done;
				break;
			case MBR_NETBSD:
				/* Found the real NetBSD partition, use it */
				osdep->cd_start = off + get_long(&mp->mbr_start);
				if (found = get_netbsd_label(dev, strat, lp, osdep->cd_start))
					goto done;
				/* FALLTHROUGH */
			default:
				if (*pnpart < MAXPARTITIONS) {
					pp = lp->d_partitions + *pnpart;
					bzero(pp, sizeof *pp);
					pp->p_size = get_long(&mp->mbr_size);
					pp->p_offset = off + get_long(&mp->mbr_start);
					++*pnpart;
				}
				break;
d304 2
a305 1
		}
d307 1
a308 1
	recursion--;
d311 1
a311 45
	return found;
}

/*
 * Attempt to read a disk label from a device
 * using the indicated strategy routine.
 *
 * If we can't find a NetBSD label, we attempt to fake one
 * based on the MBR (and extended partition) information
 */
char *
readdisklabel(dev, strat, lp, osdep)
	dev_t dev;
	void (*strat)();
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
{
	struct mbr_partition *mp;
	struct buf *bp;
	char *msg = 0;
	int i;

	/* Initialize disk label with some defaults */
	if (lp->d_secsize == 0)
		lp->d_secsize = DEV_BSIZE;
	if (lp->d_secpercyl == 0)
		lp->d_secpercyl = 1;
	if (lp->d_secperunit == 0)
		lp->d_secperunit = 0x7fffffff;
	lp->d_npartitions = RAW_PART + 1;
	for (i = 0; i < MAXPARTITIONS; i++) {
		if (i != RAW_PART) {
			lp->d_partitions[i].p_size = 0;
			lp->d_partitions[i].p_offset = 0;
		}
	}
	if (lp->d_partitions[RAW_PART].p_size == 0) {
		lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
		lp->d_partitions[RAW_PART].p_offset = 0;
	}

	osdep->cd_start = -1;

	mbr_to_label(dev, strat, MBRSECTOR, lp, &lp->d_npartitions, osdep, 0);
	return 0;
d315 2
a316 1
 * Check new disk label for sensibility before setting it.
d320 1
a320 1
	struct disklabel *olp, *nlp;
d324 3
d328 3
a330 3
	if (nlp->d_secpercyl == 0 || nlp->d_secsize == 0
	    || (nlp->d_secsize % DEV_BSIZE) != 0)
		return EINVAL;
d335 1
a335 1
		return 0;
d338 28
a365 6
	if (nlp->d_magic != DISKMAGIC || nlp->d_magic2 != DISKMAGIC
	    || dkcksum(nlp) != 0)
		return EINVAL;

	/* openmask parameter ignored */

d367 1
a367 1
	return 0;
d370 1
d373 1
d378 2
a379 2
	void (*strat)();
	struct disklabel *lp;
d382 1
d384 3
a386 10
	int error;
	struct disklabel label;

	/*
	 * Try to re-read a disklabel, in case he changed the MBR.
	 */
	label = *lp;
	readdisklabel(dev, strat, &label, osdep);
	if (osdep->cd_start < 0)
		return EINVAL;
d389 1
a389 1
	bp = geteblk(lp->d_secsize);
d392 13
a404 4
	bp->b_blkno = osdep->cd_start + LABELSECTOR;
	bp->b_cylinder = bp->b_blkno / (lp->d_secsize / DEV_BSIZE) / lp->d_secpercyl;
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_BUSY | B_WRITE;
d406 22
a427 1
	bcopy((caddr_t)lp, (caddr_t)bp->b_data, sizeof *lp);
d429 5
a434 1
	error = biowait(bp);
d436 18
d456 1
a456 2

	return error;
d461 1
a461 1
 * within the boundaris of the partition.  Adjust transfer
d473 2
d480 1
a480 1
			/* If axactly at end of disk, return EOF. */
d489 1
a489 1
		/* Otherwise truncate request. */
d493 10
d504 1
a504 1
	bp->b_cylinder = (bp->b_blkno + blockpersec(p->p_offset, lp)) /
d506 1
a506 1
	return 1;
d511 1
a511 39
	return 0;
}

extern int dumpsize;
/*
 * This is called by configure to set dumplo and dumpsize.
 */
void
dumpconf()
{
	int nblks;		/* size of dump device */
	int skip;
	int maj;

	if (dumpdev == NODEV)
		return;
	maj = major(dumpdev);
	if (maj < 0 || maj >= nblkdev)
		panic("dumpconf: bad dumpdev=0x%x", dumpdev);
	if (bdevsw[maj].d_psize == NULL)
		return;
	nblks = (*bdevsw[maj].d_psize)(dumpdev);
	if (nblks <= ctod(1))
		return;

	dumpsize = physmem;

	/* Skip enough blocks at start of disk to preserve an eventual disklabel. */
	skip = LABELSECTOR + 1;
	skip += ctod(1) - 1;
	skip = ctod(dtoc(skip));
	if (dumplo < skip)
		dumplo = skip;

	/* Put dump at end of partition */
	if (dumpsize > dtoc(nblks - dumplo))
		dumpsize = dtoc(nblks - dumplo);
	if (dumplo < nblks - ctod(dumpsize))
		dumplo = nblks - ctod(dumpsize);
@


1.3
log
@unconfuse partition/block sizing stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.2 1996/12/28 06:21:55 rahnds Exp $	*/
d332 1
a332 1
bounds_check_with_label(bp, lp, wlabel)
d335 1
@


1.2
log
@Adding OpenBSD tags to files.
@
text
@d1 1
a1 1
/*	$OpenBSD:$	*/
d337 1
d339 1
a339 1
	int sz;
d341 2
a342 4
	sz = howmany(bp->b_bcount, lp->d_secsize);

	if (bp->b_blkno + sz > p->p_size) {
		sz = p->p_size - bp->b_blkno;
d354 1
a354 1
		bp->b_bcount = sz * lp->d_secsize;
d358 2
a359 3
	bp->b_cylinder = (bp->b_blkno + p->p_offset)
			 / (lp->d_secsize / DEV_BSIZE) / lp->d_secpercyl;

@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@Check-in of powerpc kernel support.
NOTE: This will not work until the other pieces are checked in.
This is primarily the NetBSD powerpc port, with modifications
to support ELF. 
@
text
@@
