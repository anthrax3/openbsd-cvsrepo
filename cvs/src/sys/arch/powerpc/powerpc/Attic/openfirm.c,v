head	1.9;
access;
symbols
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	UBC_SYNC_A:1.9
	UBC_SYNC_B:1.9
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	powerpc_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2001.09.01.15.44.20;	author drahn;	state dead;
branches;
next	1.8;

1.8
date	2001.06.24.23.29.36;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2000.09.07.03.30.10;	author rahnds;	state Exp;
branches;
next	1.6;

1.6
date	99.11.09.00.20.42;	author rahnds;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.10.28.04.28.03;	author rahnds;	state Exp;
branches;
next	1.4;

1.4
date	99.07.05.20.56.26;	author rahnds;	state Exp;
branches;
next	1.3;

1.3
date	97.10.13.13.43.00;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	96.12.28.06.22.12;	author rahnds;	state Exp;
branches;
next	1.1;

1.1
date	96.12.21.20.35.58;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.12.21.20.35.58;	author rahnds;	state Exp;
branches;
next	;

1.6.2.1
date	2001.05.14.21.36.57;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.07.04.10.23.01;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.10.31.03.07.55;	author nate;	state dead;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.11.13.21.04.16;	author niklas;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2001.11.13.22.14.34;	author niklas;	state dead;
branches;
next	;


desc
@@


1.9
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/powerpc to macppc/macppc

This moves hardware specific files from the common directory to the
platform specific directory. This leaves common files.
With this change all of the debugger (db_) files have been moved to
the platform specific directory. The debugger should be reconsidered
and commonized.
@
text
@/*	$OpenBSD: openfirm.c,v 1.8 2001/06/24 23:29:36 drahn Exp $	*/
/*	$NetBSD: openfirm.c,v 1.1 1996/09/30 16:34:52 ws Exp $	*/

/*
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <sys/param.h>
#include <sys/systm.h>

#include <machine/psl.h>
#include <machine/stdarg.h>

#include <dev/ofw/openfirm.h>

extern void ofw_stack __P((void));
extern void ofbcopy __P((const void *, void *, size_t));

int
OF_peer(phandle)
	int phandle;
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int phandle;
		int sibling;
	} args = {
		"peer",
		1,
		1,
	};
	
	ofw_stack();
	args.phandle = phandle;
	if (openfirmware(&args) == -1)
		return 0;
	return args.sibling;
}

int
OF_child(phandle)
	int phandle;
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int phandle;
		int child;
	} args = {
		"child",
		1,
		1,
	};
	
	ofw_stack();
	args.phandle = phandle;
	if (openfirmware(&args) == -1)
		return 0;
	return args.child;
}

int
OF_parent(phandle)
	int phandle;
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int phandle;
		int parent;
	} args = {
		"parent",
		1,
		1,
	};
	
	ofw_stack();
	args.phandle = phandle;
	if (openfirmware(&args) == -1)
		return 0;
	return args.parent;
}

int
OF_getprop(handle, prop, buf, buflen)
	int handle;
	char *prop;
	void *buf;
	int buflen;
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int phandle;
		char *prop;
		void *buf;
		int buflen;
		int size;
	} args = {
		"getprop",
		4,
		1,
	};

	ofw_stack();
	if (buflen > NBPG)
		return -1;
	args.phandle = handle;
	args.prop = prop;
	args.buf = OF_buf;
	args.buflen = buflen;
	if (openfirmware(&args) == -1)
		return -1;
	if (args.size > 0)
		ofbcopy(OF_buf, buf, args.size);
	return args.size;
}

int
OF_interpret(char *cmd, int nreturns, ...)
{
	va_list ap;
	int i;
	static struct {
		char *name;  
		int nargs;
		int nreturns;
		char *cmd; 
		int status;
		int results[8];
	} args = {
		"interpret",
		1,
		2,
	};

	ofw_stack();
	if (nreturns > 8)
		return -1;
	if ((i = strlen(cmd)) >= NBPG)
		return -1;
	ofbcopy(cmd, OF_buf, i + 1);
	args.cmd = OF_buf;
	args.nargs = 1;
	args.nreturns = nreturns + 1;
	if (openfirmware(&args) == -1)
		return -1;
	va_start(ap, nreturns);
	for (i = 0; i < nreturns; i++)
		*va_arg(ap, int *) = args.results[i];
	va_end(ap);
	return args.status;
}


int
OF_finddevice(name)
	char *name;
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		char *device;
		int phandle;
	} args = {
		"finddevice",
		1,
		1,
	};	

	ofw_stack();
	args.device = name;
	if (openfirmware(&args) == -1)
		return -1;
	return args.phandle;
}
static void OF_rboot(char *bootspec);

static void
OF_rboot(bootspec)
	char *bootspec;
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
	} args = {
		"reset-all",
		0,
		0,
	};
	int l;
	
	if ((l = strlen(bootspec)) >= NBPG)
		panic("OF_boot");
	ofw_stack();
	openfirmware(&args);
	/* will attempt exit in OF_boot */
}


void
OF_boot(bootspec)
	char *bootspec;
{
	OF_rboot(bootspec);
	printf ("OF_boot returned!");		/* just in case */
	OF_exit();
	while(1);
}

void
OF_exit()
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
	} args = {
		"exit",
		0,
		0,
	};

	ofw_stack();
	openfirmware(&args);
	panic ("OF_exit returned!");		/* just in case */
	while (1);
}

/* XXX What is the reason to have this instead of bcopy/memcpy? */
void
ofbcopy(src, dst, len)
        const void *src;    
        void *dst;         
        size_t len;
{
        const char *sp = src;
        char *dp = dst;

        if (src == dst)
                return; 
                
        while (len-- > 0)                     
                *dp++ = *sp++;
}

@


1.8
log
@-Warn cleanups for powerpc, still not done.
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.7 2000/09/07 03:30:10 rahnds Exp $	*/
@


1.7
log
@add OF_interpret, to obtain output from openfirmware commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.6 1999/11/09 00:20:42 rahnds Exp $	*/
d35 1
d209 1
d211 1
a211 1
void
a232 1
void OF_exit();
@


1.6
log
@autoconf.c:
	calculate delay time for delay() before it is acutally used.
	add support for md_diskconf come closer to supporting crashdumps,
	eventually this code should be un if 0 ed and supported.
	add the wd device as a supported device, fix some comments.
clock.c:
	support calculation of delay loop earlier, do the spin loop correcly,
	unsigned math on the lower half, not signed math.
conf.c:
	addd support for wd driver, block major 0, char major 11.
machdep.c:
	bus_space_map becomes a real function, not just inlined function.
	Support devices that are not mapped with bats (most still currently
	are mapped with bats,...). BAT mapping does not allow proper
	mapping of cachable devices.
	mapiodev HACK, NEEDS TO BE REMOVED. added for quicker import
	of BROKEN mac drivers. the drivers NEED to be rewritten in
	a busified manner. it would FIX all of the endian swabbing
	done by each driver. (Is that emphasized enough?)

	bus_space_(read|write)_raw_multi as functions, should these
	be turned into inline functions and put in bus.h?
ofw_machdep.c:
	removed extranious variable.
openfirm.c:
	telling openfirmware to "boot" will put the system
	in somewhat of a strange state, try reset-all, but that
	typically fails, therefore, try OF_exit before spinning.
pmap.c:
	support stealing memory from kernel address space so that
	mappings can be created before vm is initalized.
vm_machdep.c:
	maybe the meaning of removing this will later become obvious. ???
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.5 1999/10/28 04:28:03 rahnds Exp $	*/
d148 37
@


1.6.2.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.7 2000/09/07 03:30:10 rahnds Exp $	*/
a147 37

int
OF_interpret(char *cmd, int nreturns, ...)
{
	va_list ap;
	int i;
	static struct {
		char *name;  
		int nargs;
		int nreturns;
		char *cmd; 
		int status;
		int results[8];
	} args = {
		"interpret",
		1,
		2,
	};

	ofw_stack();
	if (nreturns > 8)
		return -1;
	if ((i = strlen(cmd)) >= NBPG)
		return -1;
	ofbcopy(cmd, OF_buf, i + 1);
	args.cmd = OF_buf;
	args.nargs = 1;
	args.nreturns = nreturns + 1;
	if (openfirmware(&args) == -1)
		return -1;
	va_start(ap, nreturns);
	for (i = 0; i < nreturns; i++)
		*va_arg(ap, int *) = args.results[i];
	va_end(ap);
	return args.status;
}

@


1.6.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.6.2.1 2001/05/14 21:36:57 niklas Exp $	*/
a34 1
#include <sys/systm.h>
a207 1
static void OF_rboot(char *bootspec);
d209 1
a209 1
static void
d231 1
@


1.6.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.6.2.2 2001/07/04 10:23:01 niklas Exp $	*/
@


1.6.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.6.2.5
log
@repair
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.6.2.4 2001/11/13 21:04:16 niklas Exp $	*/
@


1.5
log
@clean up a global pointer/array reference for OF_buf.
fix typo someone made.
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.4 1999/07/05 20:56:26 rahnds Exp $	*/
d173 1
a173 1
OF_boot(bootspec)
a179 1
		char *bootspec;
d181 2
a182 2
		"boot",
		1,
a189 2
	ofbcopy(bootspec, OF_buf, l + 1);
	args.bootspec = OF_buf;
d191 10
d202 2
a203 1
	while (1);
@


1.4
log
@Several changes here:
(Some of these changes are work in progress and may change more later)
locore.S:
        rearranged to remove most of the direct openfirmware references in
        the attempt to move all of the openfirmware pieces into ofw_ files.
        This could allow other firmware type to be supported easier. Also
        this keeps the openfirmware code grouped in the same files.

        OF_buf is now statically allocated in the data/bss section instead
        of allocated during initialization.

machdep.c:
        change the order of vm initialization, Still considering removing
        the BATs from use. instead of calls directly to ppc_exit and ppc_boot
        these are now called via a firmware function pointer structure.
        Add iMac recognition to systems
ofw_machdep.c:
        function pointer structure to allow different firmware to supply
        specific system functionality, normally startup and reset,
        including a hook to notify when bsd is about to go virtual,
        in case firmware calls need to act different after that time.

        Allow BSD to handle the virtual memory operations for openfirmware.
        this idea was copied from NetBSD macppc, It is not fully implemented,
        among other problems, openfirmware does not have a mechanism to
        add new mappings.

ofwreal.S:
        Major rewrite of the firmware call code, It still copies
        a portion of the stack, but now does not restore exeception vectors.
        Modified to be similar in idea to NetBSD macppc with BSD handling
        the openfirmware VM faults/TLB misses.
        This still needs to be reviewed, Should be possible to not require
        any stack copy.

opendev.c:
        OF_bus is not a pointer to the buffer, but is the buffer itself now.

openfirm.c:
        OF_bus is not a pointer to the buffer, but is the buffer itself now.
        Dont panic if OF_boot fails, OF_boot can be called by panic.
        instead print and the hang in a spin loop.

pmap.c:
        call the firmware function to get memory regions.
        Scale the PowerPC hash table size by size of real memory.
        Properly align the hash table based on the start, not just
        the size.
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.3 1997/10/13 13:43:00 pefo Exp $	*/
d39 1
a39 3
/*#include <dev/ofw/openfirm.h>*/

extern char OF_buf[];
d214 1
@


1.3
log
@Monolithic (No OpenFirmware driver crap...) PowerPC kernel. This is the
first release based on Wolfgang Solfrank, TooLs GmbH, work. Most OFW stuff
has been ripped out. Only a few functions for memory probing and halt/reboot
functionality has been kept. The kernel currently works with V.I's power.4e
PowerPC604 board, but more will come.
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.2 1996/12/28 06:22:12 rahnds Exp $	*/
d41 1
a41 1
char *OF_buf;
d196 2
a197 1
	panic ("OF_boot returned!");		/* just in case */
@


1.2
log
@Adding OpenBSD tags to files.
@
text
@d1 1
a1 1
/*	$OpenBSD:$	*/
d39 1
a39 1
#include <dev/ofw/openfirm.h>
a115 23
OF_instance_to_package(ihandle)
	int ihandle;
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int ihandle;
		int phandle;
	} args = {
		"instance-to-package",
		1,
		1,
	};

	ofw_stack();
	args.ihandle = ihandle;
	if (openfirmware(&args) == -1)
		return -1;
	return args.phandle;
}

int
a173 311
int
OF_instance_to_path(ihandle, buf, buflen)
	int ihandle;
	char *buf;
	int buflen;
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int ihandle;
		char *buf;
		int buflen;
		int length;
	} args = {
		"instance-to-path",
		3,
		1,
	};

	if (buflen > NBPG)
		return -1;
	args.ihandle = ihandle;
	args.buf = OF_buf;
	args.buflen = buflen;
	if (openfirmware(&args) < 0)
		return -1;
	if (args.length > 0)
		ofbcopy(OF_buf, buf, args.length);
	return args.length;
}

int
OF_package_to_path(phandle, buf, buflen)
	int phandle;
	char *buf;
	int buflen;
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int phandle;
		char *buf;
		int buflen;
		int length;
	} args = {
		"package-to-path",
		3,
		1,
	};
	
	ofw_stack();
	if (buflen > NBPG)
		return -1;
	args.phandle = phandle;
	args.buf = OF_buf;
	args.buflen = buflen;
	if (openfirmware(&args) < 0)
		return -1;
	if (args.length > 0)
		ofbcopy(OF_buf, buf, args.length);
	return args.length;
}

int
#ifdef	__STDC__
OF_call_method(char *method, int ihandle, int nargs, int nreturns, ...)
#else
OF_call_method(method, ihandle, nargs, nreturns, va_alist)
	char *method;
	int ihandle;
	int nargs;
	int nreturns;
	va_dcl
#endif
{
	va_list ap;
	static struct {
		char *name;
		int nargs;
		int nreturns;
		char *method;
		int ihandle;
		int args_n_results[12];
	} args = {
		"call-method",
		2,
		1,
	};
	int *ip, n;
	
	if (nargs > 6)
		return -1;
	args.nargs = nargs + 2;
	args.nreturns = nreturns + 1;
	args.method = method;
	args.ihandle = ihandle;
	va_start(ap, nreturns);
	for (ip = args.args_n_results + (n = nargs); --n >= 0;)
		*--ip = va_arg(ap, int);
	ofw_stack();
	if (openfirmware(&args) == -1)
		return -1;
	if (args.args_n_results[nargs])
		return args.args_n_results[nargs];
	for (ip = args.args_n_results + nargs + (n = args.nreturns); --n > 0;)
		*va_arg(ap, int *) = *--ip;
	va_end(ap);
	return 0;
}

int
#ifdef	__STDC__
OF_call_method_1(char *method, int ihandle, int nargs, ...)
#else
OF_call_method_1(method, ihandle, nargs, va_alist)
	char *method;
	int ihandle;
	int nargs;
	va_dcl
#endif
{
	va_list ap;
	static struct {
		char *name;
		int nargs;
		int nreturns;
		char *method;
		int ihandle;
		int args_n_results[8];
	} args = {
		"call-method",
		2,
		2,
	};
	int *ip, n;
	
	if (nargs > 6)
		return -1;
	args.nargs = nargs + 2;
	args.method = method;
	args.ihandle = ihandle;
	va_start(ap, nargs);
	for (ip = args.args_n_results + (n = nargs); --n >= 0;)
		*--ip = va_arg(ap, int);
	va_end(ap);
	ofw_stack();
	if (openfirmware(&args) == -1)
		return -1;
	if (args.args_n_results[nargs])
		return -1;
	return args.args_n_results[nargs + 1];
}

int
OF_open(dname)
	char *dname;
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		char *dname;
		int handle;
	} args = {
		"open",
		1,
		1,
	};
	int l;
	
	ofw_stack();
	if ((l = strlen(dname)) >= NBPG)
		return -1;
	ofbcopy(dname, OF_buf, l + 1);
	args.dname = OF_buf;
	if (openfirmware(&args) == -1)
		return -1;
	return args.handle;
}

void
OF_close(handle)
	int handle;
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int handle;
	} args = {
		"close",
		1,
		0,
	};

	ofw_stack();
	args.handle = handle;
	openfirmware(&args);
}

/* 
 * This assumes that character devices don't read in multiples of NBPG.
 */
int
OF_read(handle, addr, len)
	int handle;
	void *addr;
	int len;
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int ihandle;
		void *addr;
		int len;
		int actual;
	} args = {
		"read",
		3,
		1,
	};
	int l, act = 0;
	
	ofw_stack();
	args.ihandle = handle;
	args.addr = OF_buf;
	for (; len > 0; len -= l, addr += l) {
		l = min(NBPG, len);
		args.len = l;
		if (openfirmware(&args) == -1)
			return -1;
		if (args.actual > 0) {
			ofbcopy(OF_buf, addr, args.actual);
			act += args.actual;
		}
		if (args.actual < l)
			if (act)
				return act;
			else
				return args.actual;
	}
	return act;
}

int
OF_write(handle, addr, len)
	int handle;
	void *addr;
	int len;
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int ihandle;
		void *addr;
		int len;
		int actual;
	} args = {
		"write",
		3,
		1,
	};
	int l, act = 0;
	
	ofw_stack();
	args.ihandle = handle;
	args.addr = OF_buf;
	for (; len > 0; len -= l, addr += l) {
		l = min(NBPG, len);
		ofbcopy(addr, OF_buf, l);
		args.len = l;
		if (openfirmware(&args) == -1)
			return -1;
		l = args.actual;
		act += l;
	}
	return act;
}

int
OF_seek(handle, pos)
	int handle;
	u_quad_t pos;
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int handle;
		int poshi;
		int poslo;
		int status;
	} args = {
		"seek",
		3,
		1,
	};

	ofw_stack();
	args.handle = handle;
	args.poshi = (int)(pos >> 32);
	args.poslo = (int)pos;
	if (openfirmware(&args) == -1)
		return -1;
	return args.status;
}

d196 1
a196 18
	while (1);			/* just in case */
}

void
OF_enter()
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
	} args = {
		"enter",
		0,
		0,
	};

	ofw_stack();
	openfirmware(&args);
d214 1
a214 1
	while (1);			/* just in case */
d217 1
d219 13
a231 20
(*OF_set_callback(newfunc))()
	void (*newfunc)();
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		void (*newfunc)();
		void (*oldfunc)();
	} args = {
		"set-callback",
		1,
		1,
	};

	ofw_stack();
	args.newfunc = newfunc;
	if (openfirmware(&args) == -1)
		return 0;
	return args.oldfunc;
a233 21
/*
 * This version of bcopy doesn't work for overlapping regions!
 */
void
ofbcopy(src, dst, len)
	const void *src;
	void *dst;
	size_t len;
{
	const char *sp = src;
	char *dp = dst;

	if (src == dst)
		return;
	
	/*
	 * Do some optimization?						XXX
	 */
	while (len-- > 0)
		*dp++ = *sp++;
}
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@Check-in of powerpc kernel support.
NOTE: This will not work until the other pieces are checked in.
This is primarily the NetBSD powerpc port, with modifications
to support ELF. 
@
text
@@
