head	1.81;
access;
symbols
	SMP_SYNC_A:1.81
	SMP_SYNC_B:1.81
	UBC_SYNC_A:1.81
	UBC_SYNC_B:1.81
	OPENBSD_2_9_BASE:1.56
	OPENBSD_2_9:1.56.0.2
	OPENBSD_2_8:1.50.0.2
	OPENBSD_2_8_BASE:1.50
	OPENBSD_2_7:1.41.0.2
	OPENBSD_2_7_BASE:1.41
	SMP:1.32.0.2
	SMP_BASE:1.32
	kame_19991208:1.29
	OPENBSD_2_6:1.25.0.2
	OPENBSD_2_6_BASE:1.25
	OPENBSD_2_5:1.22.0.2
	OPENBSD_2_5_BASE:1.22
	OPENBSD_2_4:1.20.0.2
	OPENBSD_2_4_BASE:1.20
	OPENBSD_2_3:1.12.0.4
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	powerpc_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.81
date	2001.09.01.15.44.20;	author drahn;	state dead;
branches;
next	1.80;

1.80
date	2001.08.23.14.01.03;	author art;	state Exp;
branches;
next	1.79;

1.79
date	2001.08.23.12.02.04;	author art;	state Exp;
branches;
next	1.78;

1.78
date	2001.08.23.00.09.15;	author drahn;	state Exp;
branches;
next	1.77;

1.77
date	2001.08.21.03.07.02;	author drahn;	state Exp;
branches;
next	1.76;

1.76
date	2001.08.19.20.02.22;	author drahn;	state Exp;
branches;
next	1.75;

1.75
date	2001.08.18.05.58.34;	author drahn;	state Exp;
branches;
next	1.74;

1.74
date	2001.08.17.22.29.21;	author drahn;	state Exp;
branches;
next	1.73;

1.73
date	2001.07.25.13.25.33;	author art;	state Exp;
branches;
next	1.72;

1.72
date	2001.07.09.02.14.05;	author mickey;	state Exp;
branches;
next	1.71;

1.71
date	2001.06.27.04.37.21;	author art;	state Exp;
branches;
next	1.70;

1.70
date	2001.06.26.18.19.43;	author drahn;	state Exp;
branches;
next	1.69;

1.69
date	2001.06.26.05.17.04;	author mickey;	state Exp;
branches;
next	1.68;

1.68
date	2001.06.25.23.30.03;	author drahn;	state Exp;
branches;
next	1.67;

1.67
date	2001.06.25.00.43.16;	author mickey;	state Exp;
branches;
next	1.66;

1.66
date	2001.06.24.22.00.12;	author drahn;	state Exp;
branches;
next	1.65;

1.65
date	2001.06.24.05.14.38;	author drahn;	state Exp;
branches;
next	1.64;

1.64
date	2001.06.23.01.57.00;	author drahn;	state Exp;
branches;
next	1.63;

1.63
date	2001.06.10.18.45.02;	author drahn;	state Exp;
branches;
next	1.62;

1.62
date	2001.06.08.08.09.22;	author art;	state Exp;
branches;
next	1.61;

1.61
date	2001.05.17.18.41.50;	author provos;	state Exp;
branches;
next	1.60;

1.60
date	2001.05.07.01.24.55;	author drahn;	state Exp;
branches;
next	1.59;

1.59
date	2001.05.05.22.34.14;	author art;	state Exp;
branches;
next	1.58;

1.58
date	2001.05.05.20.56.51;	author art;	state Exp;
branches;
next	1.57;

1.57
date	2001.05.02.06.02.45;	author drahn;	state Exp;
branches;
next	1.56;

1.56
date	2001.04.08.05.00.27;	author drahn;	state Exp;
branches;
next	1.55;

1.55
date	2001.03.29.19.02.06;	author drahn;	state Exp;
branches;
next	1.54;

1.54
date	2001.03.01.23.19.34;	author drahn;	state Exp;
branches;
next	1.53;

1.53
date	2001.02.15.04.11.11;	author drahn;	state Exp;
branches;
next	1.52;

1.52
date	2001.02.12.06.26.30;	author drahn;	state Exp;
branches;
next	1.51;

1.51
date	2001.01.18.23.00.42;	author drahn;	state Exp;
branches;
next	1.50;

1.50
date	2000.10.27.00.16.17;	author mickey;	state Exp;
branches;
next	1.49;

1.49
date	2000.10.19.03.13.57;	author drahn;	state Exp;
branches;
next	1.48;

1.48
date	2000.09.19.05.26.34;	author rahnds;	state Exp;
branches;
next	1.47;

1.47
date	2000.09.15.03.52.37;	author rahnds;	state Exp;
branches;
next	1.46;

1.46
date	2000.09.06.23.05.17;	author rahnds;	state Exp;
branches;
next	1.45;

1.45
date	2000.09.06.02.45.11;	author rahnds;	state Exp;
branches;
next	1.44;

1.44
date	2000.07.14.03.45.27;	author rahnds;	state Exp;
branches;
next	1.43;

1.43
date	2000.07.07.13.22.43;	author rahnds;	state Exp;
branches;
next	1.42;

1.42
date	2000.06.08.22.25.22;	author niklas;	state Exp;
branches;
next	1.41;

1.41
date	2000.05.02.02.58.53;	author rahnds;	state Exp;
branches;
next	1.40;

1.40
date	2000.04.02.00.14.31;	author rahnds;	state Exp;
branches;
next	1.39;

1.39
date	2000.04.01.15.30.00;	author rahnds;	state Exp;
branches;
next	1.38;

1.38
date	2000.03.31.05.18.46;	author rahnds;	state Exp;
branches;
next	1.37;

1.37
date	2000.03.31.04.09.31;	author rahnds;	state Exp;
branches;
next	1.36;

1.36
date	2000.03.23.09.59.56;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2000.03.23.04.01.55;	author rahnds;	state Exp;
branches;
next	1.34;

1.34
date	2000.03.20.07.05.52;	author rahnds;	state Exp;
branches;
next	1.33;

1.33
date	2000.02.22.19.27.58;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2000.01.22.03.51.56;	author rahnds;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2000.01.14.05.42.17;	author rahnds;	state Exp;
branches;
next	1.30;

1.30
date	2000.01.14.05.16.03;	author rahnds;	state Exp;
branches;
next	1.29;

1.29
date	99.11.28.23.36.16;	author rahnds;	state Exp;
branches;
next	1.28;

1.28
date	99.11.09.04.38.17;	author rahnds;	state Exp;
branches;
next	1.27;

1.27
date	99.11.09.00.20.42;	author rahnds;	state Exp;
branches;
next	1.26;

1.26
date	99.10.28.04.28.03;	author rahnds;	state Exp;
branches;
next	1.25;

1.25
date	99.07.05.20.56.26;	author rahnds;	state Exp;
branches;
next	1.24;

1.24
date	99.05.24.23.09.07;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	99.05.22.21.22.29;	author weingart;	state Exp;
branches;
next	1.22;

1.22
date	99.01.11.05.11.54;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	99.01.07.23.16.06;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	98.10.09.02.13.56;	author rahnds;	state Exp;
branches;
next	1.19;

1.19
date	98.09.27.03.56.00;	author rahnds;	state Exp;
branches;
next	1.18;

1.18
date	98.09.20.22.11.48;	author rahnds;	state Exp;
branches;
next	1.17;

1.17
date	98.09.12.19.58.56;	author rahnds;	state Exp;
branches;
next	1.16;

1.16
date	98.09.09.04.44.59;	author rahnds;	state Exp;
branches;
next	1.15;

1.15
date	98.08.25.07.58.48;	author pefo;	state Exp;
branches;
next	1.14;

1.14
date	98.08.22.18.31.57;	author rahnds;	state Exp;
branches;
next	1.13;

1.13
date	98.05.29.04.15.39;	author rahnds;	state Exp;
branches;
next	1.12;

1.12
date	97.10.21.18.01.45;	author pefo;	state Exp;
branches;
next	1.11;

1.11
date	97.10.21.11.00.10;	author pefo;	state Exp;
branches;
next	1.10;

1.10
date	97.10.15.14.07.52;	author pefo;	state Exp;
branches;
next	1.9;

1.9
date	97.10.13.13.42.58;	author pefo;	state Exp;
branches;
next	1.8;

1.8
date	97.07.23.06.58.27;	author denny;	state Exp;
branches;
next	1.7;

1.7
date	97.02.27.23.40.19;	author rahnds;	state Exp;
branches;
next	1.6;

1.6
date	97.02.24.12.50.28;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.02.05.01.33.54;	author rahnds;	state Exp;
branches;
next	1.4;

1.4
date	97.01.20.20.43.48;	author rahnds;	state Exp;
branches;
next	1.3;

1.3
date	97.01.16.20.43.44;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.12.28.06.22.05;	author rahnds;	state Exp;
branches;
next	1.1;

1.1
date	96.12.21.20.35.57;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.12.21.20.35.57;	author rahnds;	state Exp;
branches;
next	;

1.32.2.1
date	2000.03.02.07.04.32;	author niklas;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2000.03.24.09.08.43;	author niklas;	state Exp;
branches;
next	1.32.2.3;

1.32.2.3
date	2001.05.14.21.36.56;	author niklas;	state Exp;
branches;
next	1.32.2.4;

1.32.2.4
date	2001.07.04.10.22.58;	author niklas;	state Exp;
branches;
next	1.32.2.5;

1.32.2.5
date	2001.10.31.03.07.55;	author nate;	state dead;
branches;
next	1.32.2.6;

1.32.2.6
date	2001.11.13.21.04.16;	author niklas;	state Exp;
branches;
next	1.32.2.7;

1.32.2.7
date	2001.11.13.22.14.34;	author niklas;	state dead;
branches;
next	;


desc
@@


1.81
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/powerpc to macppc/macppc

This moves hardware specific files from the common directory to the
platform specific directory. This leaves common files.
With this change all of the debugger (db_) files have been moved to
the platform specific directory. The debugger should be reconsidered
and commonized.
@
text
@/*	$OpenBSD: machdep.c,v 1.80 2001/08/23 14:01:03 art Exp $	*/
/*	$NetBSD: machdep.c,v 1.4 1996/10/16 19:33:11 ws Exp $	*/

/*
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
#include "machine/ipkdb.h"
*/

#include <sys/param.h>
#include <sys/buf.h>
#include <sys/timeout.h>
#include <sys/exec.h>
#include <sys/malloc.h>
#include <sys/map.h>
#include <sys/mbuf.h>
#include <sys/mount.h>
#include <sys/msgbuf.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/reboot.h>
#include <sys/syscallargs.h>
#include <sys/syslog.h>
#include <sys/extent.h>
#include <sys/systm.h>
#include <sys/user.h>

#include <vm/vm.h>
#include <vm/vm_kern.h>

#ifdef SYSVSHM
#include <sys/shm.h>
#endif
#ifdef SYSVSEM
#include <sys/sem.h>
#endif
#ifdef SYSVMSG
#include <sys/msg.h>
#endif
#include <net/netisr.h>

#include <dev/cons.h>

#include <dev/ofw/openfirm.h>

#include <dev/pci/pcivar.h>

#include <machine/bat.h>
#include <machine/pmap.h>
#include <machine/powerpc.h>
#include <machine/trap.h>
#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/pio.h>

#include "adb.h"
#if NADB > 0
#include <arch/powerpc/mac/adbvar.h>
#include <arch/powerpc/mac/adb_direct.h>
#endif

#ifdef DDB
#include <machine/db_machdep.h>
#include <ddb/db_access.h>
#include <ddb/db_sym.h>
#include <ddb/db_extern.h>
#endif

/*
 * Global variables used here and there
 */
struct pcb *curpcb;
struct pmap *curpm;
struct proc *fpuproc;

extern struct user *proc0paddr;

/*
 * Declare these as initialized data so we can patch them.
 */
int	nswbuf = 0;
#ifdef NBUF
int	nbuf = NBUF;
#else
int	nbuf = 0;
#endif
#ifdef BUFPAGES
int bufpages = BUFPAGES;
#else
int bufpages = 0;
#endif

struct bat battable[16];

vm_map_t exec_map = NULL;
vm_map_t mb_map = NULL;
vm_map_t phys_map = NULL;

int astpending;
int ppc_malloc_ok = 0;

#ifndef SYS_TYPE
/* XXX Hardwire it for now */
#define SYS_TYPE POWER4e
#endif

int system_type = SYS_TYPE;	/* XXX Hardwire it for now */

char ofw_eth_addr[6];		/* Save address of first network ifc found */
char *bootpath;
char bootpathbuf[512];

struct firmware *fw = NULL;

#ifdef DDB
void * startsym, *endsym;
#endif

void ofw_dbg(char *str);

caddr_t allocsys __P((caddr_t));
void dumpsys __P((void));
void systype __P((char *name));
void lcsplx __P((int ipl));	/* called from LCore */
int power4e_get_eth_addr __P((void));
void nameinterrupt __P((int replace, char *newstr));
void ppc_intr_setup __P((intr_establish_t *establish,
    intr_disestablish_t *disestablish));
void *ppc_intr_establish __P((void *lcv, pci_intr_handle_t ih, int type,
    int level, int (*func) __P((void *)), void *arg, char *name));
int bus_mem_add_mapping __P((bus_addr_t bpa, bus_size_t size, int cacheable,
    bus_space_handle_t *bshp));

/*
 * Extent maps to manage I/O. Allocate storage for 8 regions in each,
 * initially. Later devio_malloc_safe will indicate that it's save to
 * use malloc() to dynamically allocate region descriptors.
 */
static long devio_ex_storage[EXTENT_FIXED_STORAGE_SIZE(8) / sizeof (long)];
struct extent *devio_ex;
static int devio_malloc_safe = 0;

/* HACK - XXX */
int segment8_a_mapped = 0;

extern int OF_stdout;
extern int where;

/* XXX, called from asm */
void initppc(u_int startkernel, u_int endkernel, char *args);

void
initppc(startkernel, endkernel, args)
	u_int startkernel, endkernel;
	char *args;
{
	extern void *trapcode; extern int trapsize;
	extern void *dsitrap; extern int dsisize;
	extern void *isitrap; extern int isisize;
	extern void *alitrap; extern int alisize;
	extern void *decrint; extern int decrsize;
	extern void *tlbimiss; extern int tlbimsize;
	extern void *tlbdlmiss; extern int tlbdlmsize;
	extern void *tlbdsmiss; extern int tlbdsmsize;
	extern void *ddblow; extern int ddbsize;
#if NIPKDB > 0
	extern ipkdblow, ipkdbsize;
#endif
	extern void consinit __P((void));
	extern void callback __P((void *));
	int exc, scratch;

	proc0.p_addr = proc0paddr;
	bzero(proc0.p_addr, sizeof *proc0.p_addr);

	/*
	 * XXX We use the page just above the interrupt vector as
	 * message buffer
	 */
	initmsgbuf((void *)0x3000, MSGBUFSIZE);

where = 3;
	curpcb = &proc0paddr->u_pcb;

	curpm = curpcb->pcb_pmreal = curpcb->pcb_pm = pmap_kernel();

	/*
	 * Initialize BAT registers to unmapped to not generate
	 * overlapping mappings below.
	 */
	__asm__ volatile ("mtibatu 0,%0" :: "r"(0));
	__asm__ volatile ("mtibatu 1,%0" :: "r"(0));
	__asm__ volatile ("mtibatu 2,%0" :: "r"(0));
	__asm__ volatile ("mtibatu 3,%0" :: "r"(0));
	__asm__ volatile ("mtdbatu 0,%0" :: "r"(0));
	__asm__ volatile ("mtdbatu 1,%0" :: "r"(0));
	__asm__ volatile ("mtdbatu 2,%0" :: "r"(0));
	__asm__ volatile ("mtdbatu 3,%0" :: "r"(0));

	/*
	 * Set up initial BAT table to only map the lowest 256 MB area
	 */
	battable[0].batl = BATL(0x00000000, BAT_M);
	battable[0].batu = BATU(0x00000000);

	battable[0x8].batl = BATL(0x80000000, BAT_I);
	battable[0x8].batu = BATU(0x80000000);
	battable[0x9].batl = BATL(0x90000000, BAT_I);
	battable[0x9].batu = BATU(0x90000000);
	battable[0xa].batl = BATL(0xa0000000, BAT_I);
	battable[0xa].batu = BATU(0xa0000000);
	segment8_a_mapped = 1;

	/*
	 * Now setup fixed bat registers
	 *
	 * Note that we still run in real mode, and the BAT
	 * registers were cleared above.
	 */
	/* IBAT0 used for initial 256 MB segment */
	__asm__ volatile ("mtibatl 0,%0; mtibatu 0,%1"
		      :: "r"(battable[0].batl), "r"(battable[0].batu));
	/* DBAT0 used similar */
	__asm__ volatile ("mtdbatl 0,%0; mtdbatu 0,%1"
		      :: "r"(battable[0].batl), "r"(battable[0].batu));

#if 0
	__asm__ volatile ("mtdbatl 1,%0; mtdbatu 1,%1"
		      :: "r"(battable[1].batl), "r"(battable[1].batu));
	__asm__ volatile ("sync;isync");
#endif

	/*
	 * Set up trap vectors
	 */
	for (exc = EXC_RSVD; exc <= EXC_LAST; exc += 0x100)
		switch (exc) {
		default:
			bcopy(&trapcode, (void *)exc, (size_t)&trapsize);
			break;
		case EXC_EXI:
			/*
			 * This one is (potentially) installed during autoconf
			 */
			break;
#if 1
		case EXC_DSI:
			bcopy(&dsitrap, (void *)EXC_DSI, (size_t)&dsisize);
			break;
		case EXC_ISI:
			bcopy(&isitrap, (void *)EXC_ISI, (size_t)&isisize);
			break;
		case EXC_ALI:
			bcopy(&alitrap, (void *)EXC_ALI, (size_t)&alisize);
			break;
#endif
		case EXC_DECR:
			bcopy(&decrint, (void *)EXC_DECR, (size_t)&decrsize);
			break;
		case EXC_IMISS:
			bcopy(&tlbimiss, (void *)EXC_IMISS, (size_t)&tlbimsize);
			break;
		case EXC_DLMISS:
			bcopy(&tlbdlmiss, (void *)EXC_DLMISS, (size_t)&tlbdlmsize);
			break;
		case EXC_DSMISS:
			bcopy(&tlbdsmiss, (void *)EXC_DSMISS, (size_t)&tlbdsmsize);
			break;
		case EXC_PGM:
		case EXC_TRC:
		case EXC_BPT:
#if defined(DDB)
			bcopy(&ddblow, (void *)exc, (size_t)&ddbsize);
#else
#if NIPKDB > 0
			bcopy(&ipkdblow, (void *)exc, (size_t)&ipkdbsize);
#endif
#endif
			break;
		}

	syncicache((void *)EXC_RST, EXC_LAST - EXC_RST + 0x100);


	uvmexp.pagesize = 4096;
	uvm_setpagesize();

	/*
	 * Initialize pmap module.
	 */
	pmap_bootstrap(startkernel, endkernel);

	/* now that we know physmem size, map physical memory with BATs */
	if (physmem > btoc(0x10000000)) {
		battable[0x1].batl = BATL(0x10000000, BAT_M);
		battable[0x1].batu = BATU(0x10000000);
	}
	if (physmem > btoc(0x20000000)) {
		battable[0x2].batl = BATL(0x20000000, BAT_M);
		battable[0x2].batu = BATU(0x20000000);
	}
	if (physmem > btoc(0x30000000)) {
		battable[0x3].batl = BATL(0x30000000, BAT_M);
		battable[0x3].batu = BATU(0x30000000);
	}
	if (physmem > btoc(0x40000000)) {
		battable[0x4].batl = BATL(0x40000000, BAT_M);
		battable[0x4].batu = BATU(0x40000000);
	}
	if (physmem > btoc(0x50000000)) {
		battable[0x5].batl = BATL(0x50000000, BAT_M);
		battable[0x5].batu = BATU(0x50000000);
	}
	if (physmem > btoc(0x60000000)) {
		battable[0x6].batl = BATL(0x60000000, BAT_M);
		battable[0x6].batu = BATU(0x60000000);
	}
	if (physmem > btoc(0x70000000)) {
		battable[0x7].batl = BATL(0x70000000, BAT_M);
		battable[0x7].batu = BATU(0x70000000);
	}

	/*
	 * Now enable translation (and machine checks/recoverable interrupts).
	 */
	(fw->vmon)();

	__asm__ volatile ("eieio; mfmsr %0; ori %0,%0,%1; mtmsr %0; sync;isync"
		      : "=r"(scratch) : "K"(PSL_IR|PSL_DR|PSL_ME|PSL_RI));

	/*
	 * Look at arguments passed to us and compute boothowto.
	 * Default to SINGLE and ASKNAME if no args or
	 * SINGLE and DFLTROOT if this is a ramdisk kernel.
	 */
#ifdef RAMDISK_HOOKS
	boothowto = RB_SINGLE | RB_DFLTROOT;
#else
	boothowto = RB_AUTOBOOT;
#endif /* RAMDISK_HOOKS */

	/*
	 * Parse arg string.
	 */

	/* make a copy of the args! */
	strncpy(bootpathbuf, args, 512);
	bootpath= &bootpathbuf[0];
	while ( *++bootpath && *bootpath != ' ');
	if (*bootpath) {
		*bootpath++ = 0;
		while (*bootpath) {
			switch (*bootpath++) {
			case 'a':
				boothowto |= RB_ASKNAME;
				break;
			case 's':
				boothowto |= RB_SINGLE;
				break;
			case 'd':
				boothowto |= RB_KDB;
				break;
			case 'c':
				boothowto |= RB_CONFIG;
				break;
			default:
				break;
			}
		}
	}
	bootpath= &bootpathbuf[0];
#if 0
	bcopy(args +strlen(args) + 1, &startsym, sizeof(startsym));
	bcopy(args +strlen(args) + 5, &endsym, sizeof(endsym));
	ddb_init((int)((u_int)endsym - (u_int)startsym), startsym, endsym);
#endif

#ifdef DDB
	ddb_init();
#endif

	/*
	 * Set up extents for pci mappings
	 * Is this too late?
	 *
	 * what are good start and end values here??
	 * 0x0 - 0x80000000 mcu bus
	 * MAP A				MAP B
	 * 0x80000000 - 0xbfffffff io		0x80000000 - 0xefffffff mem
	 * 0xc0000000 - 0xffffffff mem		0xf0000000 - 0xffffffff io
	 *
	 * of course bsd uses 0xe and 0xf
	 * So the BSD PPC memory map will look like this
	 * 0x0 - 0x80000000 memory (whatever is filled)
	 * 0x80000000 - 0xdfffffff (pci space, memory or io)
	 * 0xe0000000 - kernel vm segment
	 * 0xf0000000 - kernel map segment (user space mapped here)
	 */

	devio_ex = extent_create("devio", 0x80000000, 0xffffffff, M_DEVBUF,
		(caddr_t)devio_ex_storage, sizeof(devio_ex_storage),
		EX_NOCOALESCE|EX_NOWAIT);

	/*
	 * Now we can set up the console as mapping is enabled.
	 */
	consinit();
	/* while using openfirmware, run userconfig */
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
	/*
	 * Replace with real console.
	 */
	cninit();
	ofwconprobe();

#if NIPKDB > 0
	/*
	 * Now trap to IPKDB
	 */
	ipkdb_init();
	if (boothowto & RB_KDB)
		ipkdb_connect(0);
#else
#ifdef DDB
	if (boothowto & RB_KDB)
		Debugger();
#endif
#endif

	/*
	 * Figure out ethernet address.
	 */
	(void)power4e_get_eth_addr();

}
void ofw_dbg(char *str)
{
	int i = strlen (str);
	OF_write(OF_stdout, str, i);
}


void
install_extint(handler)
	void (*handler) __P((void));
{
	void extint __P((void));
	void extsize __P((void));
	extern u_long extint_call;
	u_long offset = (u_long)handler - (u_long)&extint_call;
	int omsr, msr;

#ifdef	DIAGNOSTIC
	if (offset > 0x1ffffff)
		panic("install_extint: too far away");
#endif
	__asm__ volatile ("mfmsr %0; andi. %1, %0, %2; mtmsr %1"
		      : "=r"(omsr), "=r"(msr) : "K"((u_short)~PSL_EE));
	extint_call = (extint_call & 0xfc000003) | offset;
	bcopy(&extint, (void *)EXC_EXI, (size_t)&extsize);
	syncicache((void *)&extint_call, sizeof extint_call);
	syncicache((void *)EXC_EXI, (int)&extsize);
	__asm__ volatile ("mtmsr %0" :: "r"(omsr));
}

/*
 * Machine dependent startup code.
 */
void
cpu_startup()
{
	int sz, i;
	caddr_t v;
	vm_offset_t minaddr, maxaddr;
	int base, residual;
	v = (caddr_t)proc0paddr + USPACE;

	proc0.p_addr = proc0paddr;

	printf("%s", version);

	printf("real mem = %d\n", ctob(physmem));

	/*
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addresses.
	 */
	sz = (int)allocsys((caddr_t)0);
	if ((v = (caddr_t)uvm_km_zalloc(kernel_map, round_page(sz))) == 0)
		panic("startup: no room for tables");
	if (allocsys(v) - v != sz)
		panic("startup: table size inconsistency");

	/*
	 * Now allocate buffers proper.  They are different than the above
	 * in that they usually occupy more virtual memory than physical.
	 */
	sz = MAXBSIZE * nbuf;
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(sz),
		    NULL, UVM_UNKNOWN_OFFSET,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
				UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
		panic("cpu_startup: cannot allocate VM for buffers");
	/*
	addr = (vaddr_t)buffers;
	*/
	base = bufpages / nbuf;
	residual = bufpages % nbuf;
	if (base >= MAXBSIZE) {
		/* Don't want to alloc more physical mem than ever needed */
		base = MAXBSIZE;
		residual = 0;
	}
	for (i = 0; i < nbuf; i++) {
		vm_size_t curbufsize;
		vm_offset_t curbuf;
		struct vm_page *pg;

		curbuf = (vm_offset_t)buffers + i * MAXBSIZE;
		curbufsize = PAGE_SIZE * (i < residual ? base + 1 : base);
		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: not enough memory for"
					" buffer cache");
			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
					VM_PROT_READ|VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
	}

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr, 16 * NCARGS,
	    TRUE, FALSE, NULL);

	/*
	 * Allocate a submap for physio
	 */
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_PHYS_SIZE, TRUE, FALSE, NULL);
	ppc_malloc_ok = 1;

	mb_map = uvm_km_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
	    VM_MBUF_SIZE, FALSE, FALSE, NULL);

	printf("avail mem = %d\n", ptoa(uvmexp.free));
	printf("using %d buffers containing %d bytes of memory\n", nbuf,
	    bufpages * PAGE_SIZE);

	/*
	 * Set up the buffers.
	 */
	bufinit();

	devio_malloc_safe = 1;
}

/*
 * Allocate space for system data structures.
 */
caddr_t
allocsys(v)
	caddr_t v;
{
#define	valloc(name, type, num) \
	v = (caddr_t)(((name) = (type *)v) + (num))

#ifdef	SYSVSHM
	valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
#endif
#ifdef	SYSVSEM
	valloc(sema, struct semid_ds, seminfo.semmni);
	valloc(sem, struct sem, seminfo.semmns);
	valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
#endif
#ifdef	SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif
	/*
	 * Decide on buffer space to use.
	 */
	if (bufpages == 0)
		bufpages = physmem * BUFCACHEPERCENT / 100;
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}
	/* Restrict to at most 70% filled kvm */
	if (nbuf * MAXBSIZE >
	    (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) * 7 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 7 / 10;

	/* More buffer pages than fits into the buffers is senseless.  */
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;

	if (nswbuf == 0) {
		nswbuf = (nbuf / 2) & ~1;
		if (nswbuf > 256)
			nswbuf = 256;
	}
	valloc(buf, struct buf, nbuf);

	return v;
}

/*
 * consinit
 * Initialize system console.
 */
void
consinit()
{
	static int cons_initted = 0;

	if (cons_initted)
		return;
	cninit();
	cons_initted = 1;
}

/*
 * Clear registers on exec
 */
void
setregs(p, pack, stack, retval)
	struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
{
	u_int32_t newstack;
	u_int32_t pargs;
	u_int32_t args[4];

	struct trapframe *tf = trapframe(p);
	pargs = -roundup(-stack + 8, 16);
	newstack = (u_int32_t)(pargs - 32);

	copyin ((void*)(VM_MAX_ADDRESS-0x10), &args, 0x10);

	bzero(tf, sizeof *tf);
	tf->fixreg[1] = newstack;
	tf->fixreg[3] = retval[0] = args[1];	/* XXX */
	tf->fixreg[4] = retval[1] = args[0];	/* XXX */
	tf->fixreg[5] = args[2];		/* XXX */
	tf->fixreg[6] = args[3];		/* XXX */
	tf->srr0 = pack->ep_entry;
	tf->srr1 = PSL_MBO | PSL_USERSET | PSL_FE_DFLT;
	p->p_addr->u_pcb.pcb_flags = 0;
}

/*
 * Send a signal to process.
 */
void
sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
{
	struct proc *p = curproc;
	struct trapframe *tf;
	struct sigframe *fp, frame;
	struct sigacts *psp = p->p_sigacts;
	int oldonstack;

	frame.sf_signum = sig;

	tf = trapframe(p);
	oldonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;

	/*
	 * Allocate stack space for signal handler.
	 */
	if ((psp->ps_flags & SAS_ALTSTACK)
	    && !oldonstack
	    && (psp->ps_sigonstack & sigmask(sig))) {
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp
					 + psp->ps_sigstk.ss_size);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
	} else
		fp = (struct sigframe *)tf->fixreg[1];
	fp = (struct sigframe *)((int)(fp - 1) & ~0xf);

	/*
	 * Generate signal context for SYS_sigreturn.
	 */
	frame.sf_sc.sc_onstack = oldonstack;
	frame.sf_sc.sc_mask = mask;
	frame.sf_sip = NULL;
	bcopy(tf, &frame.sf_sc.sc_frame, sizeof *tf);
	if (psp->ps_siginfo & sigmask(sig)) {
		frame.sf_sip = &fp->sf_si;
		initsiginfo(&frame.sf_si, sig, code, type, val);
	}
	if (copyout(&frame, fp, sizeof frame) != 0)
		sigexit(p, SIGILL);


	tf->fixreg[1] = (int)fp;
	tf->lr = (int)catcher;
	tf->fixreg[3] = (int)sig;
	tf->fixreg[4] = (psp->ps_siginfo & sigmask(sig)) ? (int)&fp->sf_si : NULL;
	tf->fixreg[5] = (int)&fp->sf_sc;
	tf->srr0 = (int)(((char *)PS_STRINGS)
			 - (p->p_emul->e_esigcode - p->p_emul->e_sigcode));

#if WHEN_WE_ONLY_FLUSH_DATA_WHEN_DOING_PMAP_ENTER
	pmap_extract(vm_map_pmap(&p->p_vmspace->vm_map),tf->srr0, &pa);
	syncicache(pa, (p->p_emul->e_esigcode - p->p_emul->e_sigcode));
#endif
}

/*
 * System call to cleanup state after a signal handler returns.
 */
int
sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	struct sigcontext sc;
	struct trapframe *tf;
	int error;

	if ((error = copyin(SCARG(uap, sigcntxp), &sc, sizeof sc)))
		return error;
	tf = trapframe(p);
	if ((sc.sc_frame.srr1 & PSL_USERSTATIC) != (tf->srr1 & PSL_USERSTATIC))
		return EINVAL;
	bcopy(&sc.sc_frame, tf, sizeof *tf);
	if (sc.sc_onstack & 1)
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
	p->p_sigmask = sc.sc_mask & ~sigcantmask;
	return EJUSTRETURN;
}

/*
 * Machine dependent system variables.
 * None for now.
 */
int
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
{
	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return ENOTDIR;
	switch (name[0]) {
	default:
		return EOPNOTSUPP;
	}
}

void
dumpsys()
{
	printf("dumpsys: TBD\n");
}

volatile int cpl, ipending, astpending, tickspending;
int imask[7];

/*
 * Soft networking interrupts.
 */
void
softnet(isr)
	int isr;
{
#ifdef	INET
#include "ether.h"
#if NETHER > 0
	if (isr & (1 << NETISR_ARP))
		arpintr();
#endif
	if (isr & (1 << NETISR_IP))
		ipintr();
#endif
#ifdef INET6
	if (isr & (1 << NETISR_IPV6))
		ip6intr();
#endif
#ifdef NETATALK
	if (isr & (1 << NETISR_ATALK))
		atintr();
#endif
#ifdef	IMP
	if (isr & (1 << NETISR_IMP))
		impintr();
#endif
#ifdef	NS
	if (isr & (1 << NETISR_NS))
		nsintr();
#endif
#ifdef	ISO
	if (isr & (1 << NETISR_ISO))
		clnlintr();
#endif
#ifdef	CCITT
	if (isr & (1 << NETISR_CCITT))
		ccittintr();
#endif
#include "ppp.h"
#if NPPP > 0
	if (isr & (1 << NETISR_PPP))
		pppintr();
#endif
#include "bridge.h"
#if NBRIDGE > 0
	if (isr & (1 << NETISR_BRIDGE))
		bridgeintr();
#endif
}

void
lcsplx(ipl)
	int ipl;
{
	splx(ipl);
}

/*
 * Halt or reboot the machine after syncing/dumping according to howto.
 */
void
boot(howto)
	int howto;
#if 0
	char *what;
#endif
{
	static int syncing;
	static char str[256];

	boothowto = howto;
	if (!cold && !(howto & RB_NOSYNC) && !syncing) {
		syncing = 1;
		vfs_shutdown();		/* sync */
#if 0
		/* resettodr does not currently do anything, address
		 * this later
		 */
		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
		 */
		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
#endif
	}
	splhigh();
	if (howto & RB_HALT) {
		doshutdownhooks();
		if ((howto & RB_POWERDOWN) == RB_POWERDOWN) {
#if NADB > 0
			delay(1000000);
			adb_poweroff();
			printf("WARNING: powerdown failed!\n");
#endif
		}

		printf("halted\n\n");
		(fw->exit)();
	}
	if (!cold && (howto & RB_DUMP))
		dumpsys();
	doshutdownhooks();
	printf("rebooting\n\n");

#if NADB > 0
	adb_restart();  /* not return */
#endif

	OF_exit();
	(fw->boot)(str);
	printf("boot failed, spinning\n");
	while(1) /* forever */;
}

/*
 *  Get Ethernet address for the onboard ethernet chip.
 */
int
power4e_get_eth_addr()
{
	int qhandle, phandle;
	char name[32];

	for (qhandle = OF_peer(0); qhandle; qhandle = phandle) {
		if (OF_getprop(qhandle, "device_type", name, sizeof name) >= 0
		    && !strcmp(name, "network")
		    && OF_getprop(qhandle, "local-mac-address",
				  &ofw_eth_addr, sizeof ofw_eth_addr) >= 0) {
			return(0);
		}
		if ((phandle = OF_child(qhandle)))
			continue;
		while (qhandle) {
			if ((phandle = OF_peer(qhandle)))
				break;
			qhandle = OF_parent(qhandle);
		}
	}
	return(-1);
}

typedef void  (void_f) (void);
void_f *pending_int_f = NULL;

/* call the bus/interrupt controller specific pending interrupt handler
 * would be nice if the offlevel interrupt code was handled here
 * instead of being in each of the specific handler code
 */
void
do_pending_int()
{
	if (pending_int_f != NULL) {
		(*pending_int_f)();
	}
}

/*
 * set system type from string
 */
void
systype(char *name)
{
	/* this table may be order specific if substrings match several
	 * computers but a longer string matches a specific
	 */
	int i;
	struct systyp {
		char *name;
		char *systypename;
		int type;
	} systypes[] = {
		{ "MOT",	"(PWRSTK) MCG powerstack family", PWRSTK },
		{ "V-I Power",	"(POWER4e) V-I ppc vme boards ",  POWER4e},
		{ "iMac",	"(APPL) Apple iMac ",  APPL},
		{ "PowerMac",	"(APPL) Apple PowerMac ",  APPL},
		{ "PowerBook",	"(APPL) Apple Powerbook ",  APPL},
		{ NULL,"",0}
	};
	for (i = 0; systypes[i].name != NULL; i++) {
		if (strncmp( name , systypes[i].name,
			strlen (systypes[i].name)) == 0)
		{
			system_type = systypes[i].type;
			printf("recognized system type of %s as %s\n",
				name, systypes[i].systypename);
			break;
		}
	}
	if (system_type == OFWMACH) {
		printf("System type %snot recognized, good luck\n",
			name);
	}
}

/*
 * one attempt at interrupt stuff..
 *
 */
#include <dev/pci/pcivar.h>

int ppc_configed_intr_cnt = 0;
struct intrhand ppc_configed_intr[MAX_PRECONF_INTR];

void *
ppc_intr_establish(lcv, ih, type, level, func, arg, name)
	void *lcv;
	pci_intr_handle_t ih;
	int type;
	int level;
	int (*func) __P((void *));
	void *arg;
	char *name;
{
	if (ppc_configed_intr_cnt < MAX_PRECONF_INTR) {
		ppc_configed_intr[ppc_configed_intr_cnt].ih_fun = func;
		ppc_configed_intr[ppc_configed_intr_cnt].ih_arg = arg;
		ppc_configed_intr[ppc_configed_intr_cnt].ih_level = level;
		ppc_configed_intr[ppc_configed_intr_cnt].ih_irq = ih;
		ppc_configed_intr[ppc_configed_intr_cnt].ih_what = name;
		ppc_configed_intr_cnt++;
	} else {
		panic("ppc_intr_establish called before interrupt controller"
			" configured: driver %s too many interrupts\n", name);
	}
	/* disestablish is going to be tricky to supported for these :-) */
	return (void *)ppc_configed_intr_cnt;
}

intr_establish_t *intr_establish_func = (intr_establish_t *)ppc_intr_establish;
intr_disestablish_t *intr_disestablish_func;

void
ppc_intr_setup(intr_establish_t *establish, intr_disestablish_t *disestablish)
{
	intr_establish_func = establish;
	intr_disestablish_func = disestablish;
}

/*
 * General functions to enable and disable interrupts
 * without having inlined assembly code in many functions,
 * should be moved into a header file for inlining the function
 * so it is faster
 */
void
ppc_intr_enable(int enable)
{
	u_int32_t emsr, dmsr;
	if (enable != 0)  {
		__asm__ volatile("mfmsr %0" : "=r"(emsr));
		dmsr = emsr | PSL_EE;
		__asm__ volatile("mtmsr %0" :: "r"(dmsr));
	}
}

int
ppc_intr_disable(void)
{
	u_int32_t emsr, dmsr;
	__asm__ volatile("mfmsr %0" : "=r"(emsr));
	dmsr = emsr & ~PSL_EE;
	__asm__ volatile("mtmsr %0" :: "r"(dmsr));
	return (emsr & PSL_EE);
}

/* BUS functions */
int
bus_space_map(t, bpa, size, cacheable, bshp)
	bus_space_tag_t t;
	bus_addr_t bpa;
	bus_size_t size;
	int cacheable;
	bus_space_handle_t *bshp;
{
	int error;

	if  (POWERPC_BUS_TAG_BASE(t) == 0) {
		/* if bus has base of 0 fail. */
		return 1;
	}
	bpa |= POWERPC_BUS_TAG_BASE(t);
	if ((error = extent_alloc_region(devio_ex, bpa, size, EX_NOWAIT |
		(ppc_malloc_ok ? EX_MALLOCOK : 0))))
	{
		return error;
	}
	if ((bpa >= 0x80000000) && ((bpa+size) < 0xb0000000)) {
		if (segment8_a_mapped) {
			*bshp = bpa;
			return 0;
		}
	}
	if ((error  = bus_mem_add_mapping(bpa, size, cacheable, bshp))) {
		if (extent_free(devio_ex, bpa, size, EX_NOWAIT |
			(ppc_malloc_ok ? EX_MALLOCOK : 0)))
		{
			printf("bus_space_map: pa 0x%x, size 0x%x\n",
				bpa, size);
			printf("bus_space_map: can't free region\n");
		}
	}
	return 0;
}
bus_addr_t bus_space_unmap_p __P((bus_space_tag_t t, bus_space_handle_t bsh,
			  bus_size_t size));
void bus_space_unmap __P((bus_space_tag_t t, bus_space_handle_t bsh,
			  bus_size_t size));
bus_addr_t
bus_space_unmap_p(t, bsh, size)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t size;
{
	bus_addr_t paddr;

	pmap_extract(pmap_kernel(), bsh, &paddr);
	bus_space_unmap((t), (bsh), (size));
	return paddr ;
}
void
bus_space_unmap(t, bsh, size)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t size;
{
	bus_addr_t sva;
	bus_size_t off, len;

	/* should this verify that the proper size is freed? */
	sva = trunc_page(bsh);
	off = bsh - sva;
	len = size+off;

	uvm_km_free_wakeup(phys_map, sva, len);
#if 0
	pmap_extract(pmap_kernel(), sva, &bpa);
	if (extent_free(devio_ex, bpa, size, EX_NOWAIT |
		(ppc_malloc_ok ? EX_MALLOCOK : 0)))
	{
		printf("bus_space_map: pa 0x%x, size 0x%x\n",
			bpa, size);
		printf("bus_space_map: can't free region\n");
	}
#endif
	pmap_remove(vm_map_pmap(phys_map), sva, sva+len);
}

int
bus_mem_add_mapping(bpa, size, cacheable, bshp)
	bus_addr_t bpa;
	bus_size_t size;
	int cacheable;
	bus_space_handle_t *bshp;
{
	bus_addr_t vaddr;
	bus_addr_t spa, epa;
	bus_size_t off;
	int len;

	spa = trunc_page(bpa);
	epa = bpa + size;
	off = bpa - spa;
	len = size+off;

#if 0
	if (epa <= spa) {
		panic("bus_mem_add_mapping: overflow");
	}
#endif
	if (ppc_malloc_ok == 0) {
		bus_size_t alloc_size;

		/* need to steal vm space before kernel vm is initialized */
		alloc_size = round_page(size);
		ppc_kvm_size -= alloc_size;

		vaddr = VM_MIN_KERNEL_ADDRESS + ppc_kvm_size;
	} else {
		vaddr = uvm_km_valloc_wait(phys_map, len);
	}
	*bshp = vaddr + off;
#ifdef DEBUG_BUS_MEM_ADD_MAPPING
	printf("mapping %x size %x to %x vbase %x\n",
		bpa, size, *bshp, spa);
#endif
	for (; len > 0; len -= PAGE_SIZE) {
#if 0
		pmap_enter(vm_map_pmap(phys_map), vaddr, spa,
#else
		pmap_enter(pmap_kernel(), vaddr, spa,
#endif
			VM_PROT_READ | VM_PROT_WRITE, PMAP_WIRED /* XXX */);
		spa += PAGE_SIZE;
		vaddr += PAGE_SIZE;
	}
	return 0;
}

int
bus_space_alloc(tag, rstart, rend, size, alignment, boundary, cacheable, addrp, handlep)
	bus_space_tag_t tag;
	bus_addr_t rstart, rend;
	bus_size_t size, alignment, boundary;
	int cacheable;
	bus_addr_t *addrp;
	bus_space_handle_t *handlep;
{

	panic("bus_space_alloc: unimplemented");
}

void
bus_space_free(tag, handle, size)
	bus_space_tag_t tag;
	bus_space_handle_t handle;
	bus_size_t size;
{

	panic("bus_space_free: unimplemented");
}

void *
mapiodev(pa, len)
	paddr_t pa;
	psize_t len;
{
	paddr_t spa;
	vaddr_t vaddr, va;
	int off;
	int size;

	spa = trunc_page(pa);
	off = pa - spa;
	size = round_page(off+len);
	if ((pa >= 0x80000000) && ((pa+len) < 0xb0000000)) {
		if (segment8_a_mapped) {
			return (void *)pa;
		}
	}
	va = vaddr = uvm_km_valloc(phys_map, size);

	if (va == 0)
		return NULL;

	for (; size > 0; size -= PAGE_SIZE) {
#if 0
		pmap_enter(vm_map_pmap(phys_map), vaddr, spa,
#else
		pmap_enter(pmap_kernel(), vaddr, spa,
#endif
			VM_PROT_READ | VM_PROT_WRITE, PMAP_WIRED/* XXX */);
		spa += PAGE_SIZE;
		vaddr += PAGE_SIZE;
	}
	return (void*) (va+off);
}
void
unmapiodev(kva, p_size)
	void *kva;
	psize_t p_size;
{
	vaddr_t vaddr;
	int size;

	size = p_size;

	vaddr = trunc_page((vaddr_t)kva);

	uvm_km_free_wakeup(phys_map, vaddr, size);

	for (; size > 0; size -= PAGE_SIZE) {
#if 0
		pmap_remove(vm_map_pmap(phys_map), vaddr, vaddr+PAGE_SIZE-1);
#else
		pmap_remove(pmap_kernel(), vaddr,  vaddr+PAGE_SIZE-1);
#endif
		vaddr += PAGE_SIZE;
	}
	return;
}



/*
 * probably should be ppc_space_copy
 */

#define _CONCAT(A,B) A ## B
#define __C(A,B)	_CONCAT(A,B)

#define BUS_SPACE_COPY_N(BYTES,TYPE)					\
void									\
__C(bus_space_copy_,BYTES)(v, h1, o1, h2, o2, c)			\
	void *v;							\
	bus_space_handle_t h1, h2;					\
	bus_size_t o1, o2, c;						\
{									\
	TYPE *src, *dst;						\
	int i;								\
									\
	src = (TYPE *) (h1+o1);						\
	dst = (TYPE *) (h2+o2);						\
									\
	if (h1 == h2 && o2 > o1) {					\
		for (i = c; i > 0; i--) {				\
			dst[i] = src[i];				\
		}							\
	} else {							\
		for (i = 0; i < c; i++) {				\
			dst[i] = src[i];				\
		}							\
	}								\
}
BUS_SPACE_COPY_N(1,u_int8_t)
BUS_SPACE_COPY_N(2,u_int16_t)
BUS_SPACE_COPY_N(4,u_int32_t)

#define BUS_SPACE_SET_REGION_N(BYTES,TYPE)				\
void									\
__C(bus_space_set_region_,BYTES)(v, h, o, val, c)			\
	void *v;							\
	bus_space_handle_t h;						\
	TYPE val;							\
	bus_size_t o, c;						\
{									\
	TYPE *dst;							\
	int i;								\
									\
	dst = (TYPE *) (h+o);						\
	for (i = 0; i < c; i++) {					\
		dst[i] = val;						\
	}								\
}

BUS_SPACE_SET_REGION_N(1,u_int8_t)
BUS_SPACE_SET_REGION_N(2,u_int16_t)
BUS_SPACE_SET_REGION_N(4,u_int32_t)

#define BUS_SPACE_READ_RAW_MULTI_N(BYTES,SHIFT,TYPE)			\
void									\
__C(bus_space_read_raw_multi_,BYTES)(bst, h, o, dst, size)		\
	bus_space_tag_t bst;						\
	bus_space_handle_t h;						\
	bus_addr_t o;							\
	u_int8_t *dst;							\
	bus_size_t size;						\
{									\
	TYPE *src;							\
	TYPE *rdst = (TYPE *)dst;					\
	int i;								\
	int count = size >> SHIFT;					\
									\
	src = (TYPE *)(h+o);						\
	for (i = 0; i < count; i++) {					\
		rdst[i] = *src;						\
		__asm__("eieio");					\
	}								\
}
BUS_SPACE_READ_RAW_MULTI_N(1,0,u_int8_t)
BUS_SPACE_READ_RAW_MULTI_N(2,1,u_int16_t)
BUS_SPACE_READ_RAW_MULTI_N(4,2,u_int32_t)

#define BUS_SPACE_WRITE_RAW_MULTI_N(BYTES,SHIFT,TYPE)			\
void									\
__C(bus_space_write_raw_multi_,BYTES)(bst, h, o, src, size)		\
	bus_space_tag_t bst;						\
	bus_space_handle_t h;						\
	bus_addr_t o;							\
	const u_int8_t *src;						\
	bus_size_t size;						\
{									\
	int i;								\
	TYPE *dst;							\
	TYPE *rsrc = (TYPE *)src;					\
	int count = size >> SHIFT;					\
									\
	dst = (TYPE *)(h+o);						\
	for (i = 0; i < count; i++) {					\
		*dst = rsrc[i];						\
		__asm__("eieio");					\
	}								\
}

BUS_SPACE_WRITE_RAW_MULTI_N(1,0,u_int8_t)
BUS_SPACE_WRITE_RAW_MULTI_N(2,1,u_int16_t)
BUS_SPACE_WRITE_RAW_MULTI_N(4,2,u_int32_t)

int
bus_space_subregion(t, bsh, offset, size, nbshp)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t offset, size;
	bus_space_handle_t *nbshp;
{
	*nbshp = bsh + offset;
	return (0);
}

int
ppc_open_pci_bridge()
{
	char *
	pci_bridges[] = {
		"/pci",
		NULL
	};
	int handle;
	int i;

	for (i = 0; pci_bridges[i] != NULL; i++) {
		handle = OF_open(pci_bridges[i]);
		if ( handle != -1) {
			return handle;
		}
	}
	return 0;
}
void
ppc_close_pci_bridge(int handle)
{
	OF_close(handle);
}

/* bcopy(), error on fault */
int
kcopy(from, to, size)
	const void *from;
	void *to;
	size_t size;
{
	faultbuf env;
	register void *oldh = curproc->p_addr->u_pcb.pcb_onfault;

	if (setfault(env)) {
		curpcb->pcb_onfault = 0;
		return EFAULT;
	}
	bcopy(from, to, size);
	curproc->p_addr->u_pcb.pcb_onfault = oldh;

	return 0;
}

void
nameinterrupt(replace, newstr)
	int replace;
	char *newstr;
{
#define NENTRIES 66
	char intrname[NENTRIES][30];
	char *p, *src;
	int i;
	extern char intrnames[];
	extern char eintrnames[];

	if (replace > NENTRIES) {
		return;
	}
	src = intrnames;

	for (i = 0; i < NENTRIES; i++) {
		src += strlcpy(intrname[i], src, 30);
		src+=1; /* skip the NUL */
	}

	strcat(intrname[replace], "/");
	strcat(intrname[replace], newstr);

	p = intrnames;
	for (i = 0; i < NENTRIES; i++) {
		p += strlcpy(p, intrname[i], eintrnames - p);
		p += 1; /* skip the NUL */
	}
}
@


1.80
log
@We can now move timeout_init into main().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.79 2001/08/23 12:02:04 art Exp $	*/
@


1.79
log
@Remove even more old timeout tentacles.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.78 2001/08/23 00:09:15 drahn Exp $	*/
a582 5

	/*
	 * Initialize timeouts.
	 */
	timeout_init();
@


1.78
log
@Move the limited memory mapping code later in configuration, after
physmem size is known. Now this runs on systems > 256M again.
This is still a BAD idea. New pmap module is coming soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.77 2001/08/21 03:07:02 drahn Exp $	*/
a610 1
	valloc(timeouts, struct timeout, ntimeout);
@


1.77
log
@use round_page() not an incorrect version of it using trunc_page().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.76 2001/08/19 20:02:22 drahn Exp $	*/
a233 31
	/* map all of possible physical memory, ick */
	if (ctob(physmem) > 0x10000000) {
		battable[0x1].batl = BATL(0x10000000, BAT_M);
		battable[0x1].batu = BATU(0x10000000);
	}
	if (ctob(physmem) > 0x20000000) {
		battable[0x2].batl = BATL(0x20000000, BAT_M);
		battable[0x2].batu = BATU(0x20000000);
	}
	if (ctob(physmem) > 0x30000000) {
		battable[0x3].batl = BATL(0x30000000, BAT_M);
		battable[0x3].batu = BATU(0x30000000);
	}
	if (ctob(physmem) > 0x40000000) {
		battable[0x4].batl = BATL(0x40000000, BAT_M);
		battable[0x4].batu = BATU(0x40000000);
	}
	if (ctob(physmem) > 0x50000000) {
		battable[0x5].batl = BATL(0x50000000, BAT_M);
		battable[0x5].batu = BATU(0x50000000);
	}
	if (ctob(physmem) > 0x60000000) {
		battable[0x6].batl = BATL(0x60000000, BAT_M);
		battable[0x6].batu = BATU(0x60000000);
	}
	if (ctob(physmem) > 0x70000000) {
		battable[0x7].batl = BATL(0x70000000, BAT_M);
		battable[0x7].batu = BATU(0x70000000);
	}


d320 30
@


1.76
log
@more NBPG -> PAGE_SIZE renames.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.76 2001/08/19 19:58:35 drahn Exp $	*/
d1213 1
a1213 1
		alloc_size = trunc_page(size + PAGE_SIZE-1);
@


1.75
log
@Only map memory above 256MB if the memory is present in the system.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.75 2001/08/18 05:55:40 drahn Exp $	*/
d1213 1
a1213 1
		alloc_size = trunc_page(size + NBPG-1);
d1225 1
a1225 1
	for (; len > 0; len -= NBPG) {
d1232 2
a1233 2
		spa += NBPG;
		vaddr += NBPG;
d1284 1
a1284 1
	for (; size > 0; size -= NBPG) {
d1291 2
a1292 2
		spa += NBPG;
		vaddr += NBPG;
d1310 1
a1310 1
	for (; size > 0; size -= NBPG) {
d1312 1
a1312 1
		pmap_remove(vm_map_pmap(phys_map), vaddr, vaddr+NBPG-1);
d1314 1
a1314 1
		pmap_remove(pmap_kernel(), vaddr,  vaddr+NBPG-1);
d1316 1
a1316 1
		vaddr += NBPG;
@


1.74
log
@When rounding up to the next page size, add NBPG-1, not NBPG before
trunc_page.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.73 2001/07/25 13:25:33 art Exp $	*/
d235 29
a263 14
	battable[0x1].batl = BATL(0x10000000, BAT_M);
	battable[0x1].batu = BATU(0x10000000);
	battable[0x2].batl = BATL(0x20000000, BAT_M);
	battable[0x2].batu = BATU(0x20000000);
	battable[0x3].batl = BATL(0x30000000, BAT_M);
	battable[0x3].batu = BATU(0x30000000);
	battable[0x4].batl = BATL(0x40000000, BAT_M);
	battable[0x4].batu = BATU(0x40000000);
	battable[0x5].batl = BATL(0x50000000, BAT_M);
	battable[0x5].batu = BATU(0x50000000);
	battable[0x6].batl = BATL(0x60000000, BAT_M);
	battable[0x6].batu = BATU(0x60000000);
	battable[0x7].batl = BATL(0x70000000, BAT_M);
	battable[0x7].batu = BATU(0x70000000);
@


1.73
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.72 2001/07/09 02:14:05 mickey Exp $	*/
d1198 1
a1198 1
		alloc_size = trunc_page(size + NBPG);
@


1.72
log
@more spacees, includes, protos
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.71 2001/06/27 04:37:21 art Exp $	*/
d1216 1
a1216 1
			VM_PROT_READ | VM_PROT_WRITE, TRUE, 0/* XXX */);
d1275 1
a1275 1
			VM_PROT_READ | VM_PROT_WRITE, TRUE, 0/* XXX */);
@


1.71
log
@kill old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.70 2001/06/26 18:19:43 drahn Exp $	*/
d74 2
d83 1
d85 4
d106 1
a106 1
/* 
d150 3
d154 7
d203 1
a203 1
	
d212 1
a212 1
	
d227 1
a227 1
	
d276 1
a276 1
	
d318 1
a318 1
#else 
d345 2
a346 2
	/*                                                              
	 * Look at arguments passed to us and compute boothowto.      
d348 3
a350 3
	 * SINGLE and DFLTROOT if this is a ramdisk kernel.                     
	 */                                                               
#ifdef RAMDISK_HOOKS                                         
d384 1
a384 1
	}			
d388 1
a388 1
	bcopy(args +strlen(args) + 5, &endsym, sizeof(endsym)); 
d399 1
a399 1
	 * 
d405 1
a405 1
	 * 
d420 1
a420 1
         */
d467 2
a468 1
	extern extint, extsize;
d472 1
a472 1
	
d497 1
a497 1
	
d501 1
a501 1
	
d538 1
a538 1
		
d566 1
a566 1
	
d569 1
a569 1
	
d574 1
a574 1
	
d578 1
a578 2
	
	
a585 1
	
d642 1
a642 1
	
d673 1
a673 1
	u_int32_t       args[4];
d680 1
a680 1
	
d708 1
a708 1
	
d710 1
a710 1
	
d713 1
a713 1
	
d726 1
a726 1
	
d740 1
a740 1
	
d771 2
a772 2
	
	if (error = copyin(SCARG(uap, sigcntxp), &sc, sizeof sc))
d955 1
a955 1
		if (phandle = OF_child(qhandle))
d958 1
a958 1
			if (phandle = OF_peer(qhandle))
d988 1
a988 1
	 * computers but a longer string matches a specific 
d1018 2
a1019 1
/* 
d1053 1
a1053 1
intr_establish_t *intr_establish_func = ppc_intr_establish;;
d1100 1
a1100 1
	
d1117 2
a1118 2
	if (error  = bus_mem_add_mapping(bpa, size, cacheable, bshp)) {
		if (extent_free(devio_ex, bpa, size, EX_NOWAIT | 
d1161 1
a1161 1
	if (extent_free(devio_ex, bpa, size, EX_NOWAIT | 
d1194 1
a1194 1
	if (ppc_malloc_ok == 0) { 
d1207 1
a1207 1
	printf("mapping %x size %x to %x vbase %x\n", 
d1230 1
a1230 1
        bus_space_handle_t *handlep;
d1266 1
a1266 1
	if (va == 0) 
d1281 1
a1281 1
void 
d1315 2
a1316 2
#define BUS_SPACE_COPY_N(BYTES,TYPE) 					\
void 									\
d1348 1
a1348 1
	bus_size_t c;							\
d1467 1
@


1.70
log
@Cleanup of interrupt configuration, move prototypes to header file,
not in each file.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.69 2001/06/26 05:17:04 mickey Exp $	*/
a115 2
#ifdef UVM
/* ??? */
a118 1
#endif
a311 1
#ifdef UVM
a314 4
#else
	vm_set_page_size();
#endif

a490 1
#ifdef UVM
a492 4
#else
	if ((v = (caddr_t)kmem_alloc(kernel_map, round_page(sz))) == 0)
		panic("startup: no room for tables");
#endif
a500 1
#ifdef UVM
a508 7
#else
	buffer_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr, sz, TRUE);
	buffers = (char *)minaddr;
	if (vm_map_find(buffer_map, vm_object_allocate(sz), (vm_offset_t)0,
	   &minaddr, sz, FALSE) != KERN_SUCCESS)
		panic("startup: cannot allocate buffers");
#endif
a522 1
#ifdef UVM
a532 5
#else
		vm_map_pageable(buffer_map, curbuf, curbuf + curbufsize,
		    FALSE);
		vm_map_simplify(buffer_map, curbuf);
#endif
a538 1
#ifdef UVM
a540 4
#else
	exec_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr, 16 * NCARGS,
	    TRUE);
#endif
a544 1
#ifdef UVM
a546 4
#else
	phys_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr, VM_PHYS_SIZE,
	    TRUE);
#endif
a548 1
#ifdef UVM
a550 4
#else
	mb_map = kmem_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
	    VM_MBUF_SIZE, FALSE);
#endif
a556 1
#ifdef UVM
a557 3
#else
	printf("avail mem = %d\n", ptoa(cnt.v_free_count));
#endif
a624 3
#if !defined(UVM)
	valloc(swbuf, struct buf, nswbuf);
#endif
a1140 1
#ifdef UVM
a1141 3
#else
	kmem_free_wakeup(phys_map, sva, len);
#endif
a1185 1
#ifdef UVM
a1186 3
#else
		vaddr = kmem_alloc_wait(phys_map, len);
#endif
a1246 1
#ifdef UVM
a1247 3
#else
	va = vaddr = kmem_alloc(phys_map, size);
#endif
a1275 1
#ifdef UVM
a1276 3
#else
	kmem_free_wakeup(phys_map, vaddr, size);
#endif
@


1.69
log
@stub bus_space_{alloc,free}
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.68 2001/06/25 23:30:03 drahn Exp $	*/
a1055 3
typedef void     *(intr_establish_t) __P((void *, pci_intr_handle_t,
            int, int, int (*func)(void *), void *, char *));
typedef void     (intr_disestablish_t) __P((void *, void *));
@


1.68
log
@closer to building with -Wno-uninitialized
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.67 2001/06/25 00:43:16 mickey Exp $	*/
d1265 24
@


1.67
log
@cold is in systm now
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.66 2001/06/24 22:00:12 drahn Exp $	*/
a740 1
	int pa;
a921 1
	char *ap = str, *ap1 = ap;
a1186 1
	bus_addr_t bpa;
a1348 1
	TYPE val;							\
@


1.66
log
@Changes in ddb, mostly from NetBSD, to support ddb continue.
Other cleanups in debugger.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.65 2001/06/24 05:14:38 drahn Exp $	*/
a97 1
extern int cold;
@


1.65
log
@comment out unused header file, add header files for proper prototypes,
extern trap symbols with decent prototypes,
use proper ddb_init() function.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.64 2001/06/23 01:57:00 drahn Exp $	*/
d180 1
a299 1
#if NIPKDB > 0
d303 4
d308 2
a310 1
#endif
@


1.64
log
@Support ddb initialization on powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.63 2001/06/10 18:45:02 drahn Exp $	*/
d34 1
d36 1
d70 4
d83 7
d163 4
d172 8
a179 11
	int phandle, qhandle;
	char name[32];
	struct machvec *mp;
	extern trapcode, trapsize;
	extern dsitrap, dsisize;
	extern isitrap, isisize;
	extern alitrap, alisize;
	extern decrint, decrsize;
	extern tlbimiss, tlbimsize;
	extern tlbdlmiss, tlbdlmsize;
	extern tlbdsmiss, tlbdsmsize;
d373 1
a373 1
#if 1
d377 4
@


1.63
log
@Hack/workaround for gcc bug. GCC will generate a load/store double instruction
to do data copies, however it will not correctly identify that a load/store
double will not correctly copy data where the address is misaligned.
This emulates the load/store double operations in the kernel.
Fixes gtk+ runtime problems.
From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.62 2001/06/08 08:09:22 art Exp $	*/
d127 4
d336 5
a340 6
	args = bootpath;
	while ( *++args && *args != ' ');
	if (*args) {
		*args++ = 0;
		while (*args) {
			switch (*args++) {
d353 2
d358 5
a362 2
#if 0
	ddb_init((int)(esym - (&_end)), &_end, esym);
@


1.62
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.61 2001/05/17 18:41:50 provos Exp $	*/
d157 1
d264 3
@


1.61
log
@convert mbuf and cluster allocation to pool, mostly from NetBSD
okay art@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.60 2001/05/07 01:24:55 drahn Exp $	*/
d751 1
a751 1
	pa = pmap_extract(vm_map_pmap(&p->p_vmspace->vm_map),tf->srr0);
d1143 1
a1143 1
	paddr = (bus_addr_t) pmap_extract(pmap_kernel(), bsh);
d1168 1
a1168 1
	bpa = pmap_extract(pmap_kernel(), sva);
@


1.60
log
@Fix fallout from recent trunc_page() changes.
problem and fix pointed out by dhartmei,
variable name changed to make slightly easier to read.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.59 2001/05/05 22:34:14 art Exp $	*/
a551 6
	/*
	 * Allocate mbuf pool.
	 */
	mclrefcnt = (char *)malloc(NMBCLUSTERS + PAGE_SIZE/MCLBYTES, M_MBUF,
	    M_NOWAIT);
	bzero(mclrefcnt, NMBCLUSTERS + PAGE_SIZE/MCLBYTES);
@


1.59
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.58 2001/05/05 20:56:51 art Exp $	*/
d1280 2
a1281 2
unmapiodev(va, p_size)
	void *va;
d1289 1
a1289 1
	vaddr = trunc_page(va);
@


1.58
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.57 2001/05/02 06:02:45 drahn Exp $	*/
a584 3
	/*
	 * Configure devices.
	 */
a585 1
	configure();
@


1.57
log
@Move powerpc interrupt enablement into the interrupt controller, not after
config runs. openpic already had this change.
Cleans up config operations for other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.56 2001/04/08 05:00:27 drahn Exp $	*/
d509 1
a509 1
		curbufsize = CLBYTES * (i < residual ? base + 1 : base);
d555 1
a555 1
	mclrefcnt = (char *)malloc(NMBCLUSTERS + CLBYTES/MCLBYTES, M_MBUF,
d557 1
a557 1
	bzero(mclrefcnt, NMBCLUSTERS + CLBYTES/MCLBYTES);
d577 1
a577 1
	    bufpages * CLBYTES);
d626 1
a626 1
		bufpages = physmem * BUFCACHEPERCENT / (100 * CLSIZE);
d639 2
a640 2
	if (bufpages > nbuf * MAXBSIZE / CLBYTES)
		bufpages = nbuf * MAXBSIZE / CLBYTES;
@


1.56
log
@Attempt at tracking interrupt source better than "irqN", with this
change, when the interrupt is established, the string will be changed
from irqN to irqN/dvrname. Some drivers establish nice names, "usb0"
some do not, "wdc_obio".
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.55 2001/03/29 19:02:06 drahn Exp $	*/
a589 11
	
	/*
	 * Now allow hardware interrupts.
	 */
	{
		int msr;
		
		splhigh();
		__asm__ volatile ("mfmsr %0; ori %0, %0, %1; mtmsr %0"
			      : "=r"(msr) : "K"(PSL_EE));
	}
@


1.55
log
@Variables removed from common need to live somewhere. Here is good.
Changes for raw_multi types, obey the correct type defines.
Additional support for bus_space_unmap, not quite complete.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.54 2001/03/01 23:19:34 drahn Exp $	*/
d1484 31
@


1.54
log
@Fix (or a least hack around) console configuration changes to wscons.
Needs to be looked at closer, but seems to work. Mostly copied from i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.54 2001/03/01 23:12:51 drahn Exp $	*/
d836 3
d1152 2
d1156 12
d1176 1
d1188 8
a1195 6
#ifdef DESTROY_MAPPINGS
	for (; len > 0; len -= NBPG) {
		pmap_enter(vm_map_pmap(phys_map), vaddr, sva,
			VM_PROT_READ | VM_PROT_WRITE, TRUE);
		sva += NBPG;
		vaddr += NBPG;
d1198 1
a1198 1

d1387 1
a1387 1
	TYPE *dst;							\
d1391 1
d1397 1
a1397 1
		dst[i] = *src;						\
d1411 1
a1411 1
	const TYPE *src;						\
d1416 1
d1421 1
a1421 1
		*dst = src[i];						\
@


1.53
log
@approaching UVM support for powerpc, initialize all of the buffer
entries, not just the first entry of each buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.52 2001/02/12 06:26:30 drahn Exp $	*/
d390 1
@


1.52
log
@One more step to UVM. It is necessary to map the I/O buffers, using uvm or vm.
These changes taken from alpha/i386 combination.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.51 2001/01/18 23:00:42 drahn Exp $	*/
d510 10
a519 6
		pg = uvm_pagealloc(NULL, 0, NULL, 0);
		if (pg == NULL)
			panic("cpu_startup: not enough memory for"
				" buffer cache");
		pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
				VM_PROT_READ|VM_PROT_WRITE);
@


1.51
log
@Support more than 256MB of physical memory.
Other pieces of the kernel need to be reviewed that 256+MB does not cause
other problems with the kernel accessing memory via user sr registers,
instead of via the BAT registers. when in kernel context, segment registers
0-7 should _NOT_ have user mappings in them.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.51 2001/01/18 10:58:24 drahn Exp $	*/
a473 1
#if !defined (UVM)
d479 10
d494 1
d505 1
d509 8
d520 1
a521 1
#endif
@


1.50
log
@more precise BUFCACHEPERCENT calculations.
from gluk@@ptci.ru; deraadt@@ and niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.49 2000/10/19 03:13:57 drahn Exp $	*/
d201 16
a216 1
#if 1
a223 9
#if 0
	if(system_type == POWER4e) {
		/* Map ISA I/O */
		addbatmap(MPC106_V_ISA_IO_SPACE, MPC106_P_ISA_IO_SPACE, BAT_I);
		battable[1].batl = BATL(0xbfffe000, BAT_I);
		battable[1].batu = BATU(0xbfffe000);
	}
#endif
#endif
@


1.49
log
@remove unnecessary printf during boot.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.48 2000/09/19 05:26:34 rahnds Exp $	*/
d607 1
a607 1
		bufpages = (physmem / ((100 / BUFCACHEPERCENT) / CLSIZE));
@


1.48
log
@Use the BATs to map devices. This is partially so that larger
displays can be mapped so that the pmap module does not need to
allocate potables before vm is inited (vga console).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.48 2000/09/19 06:24:31 drahn Exp $	*/
a372 1
	printf("inited\n");
@


1.47
log
@When calling a signal handler, don't pass the kernel (local) address in r5.
- From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.46 2000/09/06 23:05:17 rahnds Exp $	*/
d142 1
a142 1
int segment8_mapped = 0;
d202 7
a208 3
	battable[1].batl = BATL(0x80000000, BAT_I);
	battable[1].batu = BATU(0x80000000);
	segment8_mapped = 1;
d232 1
a232 1
#if 1
d1103 6
d1219 2
a1220 3
	if ((pa >= 0x80000000) && ((pa+len) < 0x90000000)) {
		extern int segment8_mapped;
		if (segment8_mapped) {
@


1.46
log
@user_config needs ifdef BOOT_CONFIG protection.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.45 2000/09/06 02:45:11 rahnds Exp $	*/
d734 1
a734 1
	tf->fixreg[5] = (int)&frame.sf_sc;
@


1.45
log
@First cut at vga console support for PowerMac (USB keyboard)
uses adb to reboot or power-off system.
add support for various USB devices into device table, as well
as some other missing devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.44 2000/07/14 03:45:27 rahnds Exp $	*/
d372 1
d374 3
@


1.44
log
@ppc_intr_enable change that was previously missed in checkins.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43 2000/07/07 13:22:43 rahnds Exp $	*/
d75 1
d333 3
d339 3
a364 2
	ofwconprobe();

d369 9
a378 3
#if 0
	dump_avail();
#endif
d895 8
d910 3
a912 18
#if 0
	if (what && *what) {
		if (strlen(what) > sizeof str - 5)
			printf("boot string too large, ignored\n");
		else {
			strcpy(str, what);
			ap1 = ap = str + strlen(str);
			*ap++ = ' ';
		}
	}
	*ap++ = '-';
	if (howto & RB_SINGLE)
		*ap++ = 's';
	if (howto & RB_KDB)
		*ap++ = 'd';
	*ap++ = 0;
	if (ap[-2] == '-')
		*ap1 = 0;
d914 1
@


1.43
log
@Since it is possible for the interrupt controller to be configured late
in the config cycle, and pci devices as well as mac onboard devices
do not use interrupts to probe. It is possible to record that the
interrupt is to be configured, but not configure it with the interrupt
controller until the interrupt controller configures itself.
This is lazy binding of interrupts. If there is a conflicting interrupt
or other problem it will be noticed when the interrupt controller configures
and collects the data rather than when the device configures.
Currently on the openpic interrupt controller supports these pre-configured
interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.42 2000/06/08 22:25:22 niklas Exp $	*/
d1049 1
a1049 1
ppc_intr_enable(void)
d1052 5
a1056 3
	__asm__ volatile("mfmsr %0" : "=r"(emsr));
	dmsr = emsr | PSL_EE;
	__asm__ volatile("mtmsr %0" :: "r"(dmsr));
d1059 1
a1059 1
void
d1066 1
@


1.42
log
@Add explicit inclusions of signalvar.h to files actually using syms defined
there but relying on an indirect inclusion
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.42 2000/06/08 21:12:06 niklas Exp $	*/
d1001 1
a1001 1
            int, int (*func)(void *), void *, char *));
d1004 3
d1008 1
a1008 1
ppc_intr_establish(lcv, ih, level, func, arg, name)
d1011 1
d1017 13
a1029 1
	panic("ppc_intr_establish called before interrupt controller configured: driver %s", name);
@


1.41
log
@Fix bug caused by <= comparison on unsigned value.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.40 2000/04/02 00:14:31 rahnds Exp $	*/
d46 1
@


1.40
log
@callout->timeout.
Ok, my tree was not fully updated, and it was committed
incorrectly. This is version 1.38 checked in again.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38 2000/03/31 05:18:46 rahnds Exp $	*/
d1208 1
a1208 1
unmapiodev(va, size)
d1210 1
a1210 1
	psize_t size;
d1213 3
@


1.39
log
@timeout -> callout.
@
text
@d38 1
a46 3
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/callout.h>
d518 1
a518 1
	 * Initialize callouts
d520 1
a520 4
	callfree = callout;
	for (i = 1; i < ncallout; i++) {
		callout[i-1].c_next = &callout[i];
	}
d565 1
a565 1
        valloc(callout, struct callout, ncallout);
@


1.38
log
@Remove unnecessary debug prints.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.37 2000/03/31 04:09:31 rahnds Exp $	*/
a37 1
#include <sys/timeout.h>
d46 3
d520 1
a520 1
	 * Initialize timeouts.
d522 4
a525 1
	timeout_init();
d570 1
a570 1
	valloc(timeouts, struct timeout, ntimeout);
@


1.37
log
@Add ummapiodev() functionality, to mirror mapiodev().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.36 2000/03/23 09:59:56 art Exp $	*/
a1129 2
printf("mem_add_mapping bpa %x size %x, spa %x epa %x\n",
	bpa, size, spa, epa);
@


1.36
log
@New API for timeouts. Replaces the old timeout()/untimeout() API and
makes it the callers responsibility to allocate resources for the
timeouts.

This is a KISS implementation and does _not_ solve the problems of slow
handling of a large number of pending timeouts (this will be solved in
future work) (although hardclock is now guarateed to take constant time
for handling of timeouts).

Old timeout() and untimeout() are implemented as wrappers around the new
API and kept for compatibility. They will be removed as soon as all
subsystems are converted to use the new API.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35 2000/03/23 04:01:55 rahnds Exp $	*/
d1209 27
@


1.35
log
@comment out bounds check, ncr card on G4 is triggering it, replaced
with a debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.34 2000/03/20 07:05:52 rahnds Exp $	*/
d38 1
a38 1
#include <sys/callout.h>
d518 1
a518 1
	 * Initialize callouts.
d520 1
a520 3
	callfree = callout;
	for (i = 1; i < ncallout; i++)
		callout[i - 1].c_next = &callout[i];
d565 1
a565 1
	valloc(callout, struct callout, ncallout);
@


1.34
log
@add first version of bus_dma for powerpc.
changes to trap handler to print out better information for jump to 0 bugs.
changes to pmap.c and machdep.c to debug a duplicate memory region
bug occasionally observed on imac with compressed kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.33 2000/02/22 19:27:58 deraadt Exp $	*/
d1132 3
d1138 1
@


1.33
log
@enlarge msgbuf, somewhat line netbsd did
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32 2000/01/22 03:51:56 rahnds Exp $	*/
a74 1
#include <powerpc/pci/mpc106reg.h>
d173 1
a173 1
	initmsgbuf(0x3000, MSGBUFSIZE);
d200 2
a201 2
	battable[1].batl = BATL(MPC106_V_ISA_IO_SPACE, BAT_I);
	battable[1].batu = BATU(MPC106_P_ISA_IO_SPACE);
d203 1
d211 1
d364 3
d1180 6
a1194 6
	if (pa >= 0x80000000 && pa+len < 0x90000000) {
		extern int segment8_mapped;
		if (segment8_mapped) {
			return (void *)pa;
		}
	}
@


1.32
log
@Allow the address specified in the bus_space_map to either be
the absolute address requested, or the offset address, this is
done by oring the requested address with the bus base address.

Devices on the mac-io bus are bus base relative, but the pci devices
are absolute addresses.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 2000/01/14 05:42:17 rahnds Exp $	*/
a127 6
/*
 * We use the page just above the interrupt vector as message buffer
 */
struct msgbuf *msgbufp = (struct msgbuf *)0x3000;
int msgbufmapped = 1;		/* message buffer is always mapped */

d170 6
@


1.32.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d128 6
a175 6
	/*
	 * XXX We use the page just above the interrupt vector as
	 * message buffer
	 */
	initmsgbuf(0x3000, MSGBUFSIZE);

@


1.32.2.2
log
@Sync with -current
@
text
@d38 1
a38 1
#include <sys/timeout.h>
d75 1
d174 1
a174 1
	initmsgbuf((void *)0x3000, MSGBUFSIZE);
d201 2
a202 2
	battable[1].batl = BATL(0x80000000, BAT_I);
	battable[1].batu = BATU(0x80000000);
a203 1
#if 0
a210 1
#endif
a362 3
#if 0
	dump_avail();
#endif
d514 1
a514 1
	 * Initialize timeouts.
d516 3
a518 1
	timeout_init();
d563 1
a563 1
	valloc(timeouts, struct timeout, ntimeout);
a1127 3
printf("mem_add_mapping bpa %x size %x, spa %x epa %x\n",
	bpa, size, spa, epa);
#if 0
a1130 1
#endif
a1175 6
	if ((pa >= 0x80000000) && ((pa+len) < 0x90000000)) {
		extern int segment8_mapped;
		if (segment8_mapped) {
			return (void *)pa;
		}
	}
d1185 6
@


1.32.2.3
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.56 2001/04/08 05:00:27 drahn Exp $	*/
a45 1
#include <sys/signalvar.h>
a73 1
#include "adb.h"
d140 1
a140 1
int segment8_a_mapped = 0;
d199 13
a211 23
	/* map all of possible physical memory, ick */
	battable[0x1].batl = BATL(0x10000000, BAT_M);
	battable[0x1].batu = BATU(0x10000000);
	battable[0x2].batl = BATL(0x20000000, BAT_M);
	battable[0x2].batu = BATU(0x20000000);
	battable[0x3].batl = BATL(0x30000000, BAT_M);
	battable[0x3].batu = BATU(0x30000000);
	battable[0x4].batl = BATL(0x40000000, BAT_M);
	battable[0x4].batu = BATU(0x40000000);
	battable[0x5].batl = BATL(0x50000000, BAT_M);
	battable[0x5].batu = BATU(0x50000000);
	battable[0x6].batl = BATL(0x60000000, BAT_M);
	battable[0x6].batu = BATU(0x60000000);
	battable[0x7].batl = BATL(0x70000000, BAT_M);
	battable[0x7].batu = BATU(0x70000000);

	battable[0x8].batl = BATL(0x80000000, BAT_I);
	battable[0x8].batu = BATU(0x80000000);
	battable[0x9].batl = BATL(0x90000000, BAT_I);
	battable[0x9].batu = BATU(0x90000000);
	battable[0xa].batl = BATL(0xa0000000, BAT_I);
	battable[0xa].batu = BATU(0xa0000000);
	segment8_a_mapped = 1;
d226 1
a226 1
#if 0
a330 3
			case 'c':
				boothowto |= RB_CONFIG;
				break;
a333 3
#if 0
	ddb_init((int)(esym - (&_end)), &_end, esym);
#endif
d357 2
d363 3
a365 6
	/* while using openfirmware, run userconfig */
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
a366 7
	}
	/*
	 * Replace with real console.
	 */
	cninit();
	ofwconprobe();

d449 1
a454 10
#ifdef UVM
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(sz),
		    NULL, UVM_UNKNOWN_OFFSET,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
				UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
		panic("cpu_startup: cannot allocate VM for buffers");
	/*
	addr = (vaddr_t)buffers;
	*/
#else
a459 1
#endif
a469 1
		struct vm_page *pg;
a472 12
#ifdef UVM
		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: not enough memory for"
					" buffer cache");
			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
					VM_PROT_READ|VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
#else
d476 1
a477 1
	}
d588 1
a588 1
		bufpages = physmem * BUFCACHEPERCENT / (100 * CLSIZE);
d718 1
a718 1
	tf->fixreg[5] = (int)&fp->sf_sc;
a786 3
volatile int cpl, ipending, astpending, tickspending;
int imask[7];

a882 8
		if ((howto & RB_POWERDOWN) == RB_POWERDOWN) {
#if NADB > 0
			delay(1000000);
			adb_poweroff();
			printf("WARNING: powerdown failed!\n");
#endif
		}

d890 18
a907 3

#if NADB > 0
	adb_restart();  /* not return */
a908 1

d1000 1
a1000 1
            int, int, int (*func)(void *), void *, char *));
a1002 3
int ppc_configed_intr_cnt = 0;
struct intrhand ppc_configed_intr[MAX_PRECONF_INTR];

d1004 1
a1004 1
ppc_intr_establish(lcv, ih, type, level, func, arg, name)
a1006 1
	int type;
d1012 1
a1012 13
	if (ppc_configed_intr_cnt < MAX_PRECONF_INTR) {
		ppc_configed_intr[ppc_configed_intr_cnt].ih_fun = func;
		ppc_configed_intr[ppc_configed_intr_cnt].ih_arg = arg;
		ppc_configed_intr[ppc_configed_intr_cnt].ih_level = level;
		ppc_configed_intr[ppc_configed_intr_cnt].ih_irq = ih;
		ppc_configed_intr[ppc_configed_intr_cnt].ih_what = name;
		ppc_configed_intr_cnt++;
	} else {
		panic("ppc_intr_establish called before interrupt controller"
			" configured: driver %s too many interrupts\n", name);
	}
	/* disestablish is going to be tricky to supported for these :-) */
	return (void *)ppc_configed_intr_cnt;
d1032 1
a1032 1
ppc_intr_enable(int enable)
d1035 3
a1037 5
	if (enable != 0)  {
		__asm__ volatile("mfmsr %0" : "=r"(emsr));
		dmsr = emsr | PSL_EE;
		__asm__ volatile("mtmsr %0" :: "r"(dmsr));
	}
d1040 1
a1040 1
int
a1046 1
	return (emsr & PSL_EE);
a1069 6
	if ((bpa >= 0x80000000) && ((bpa+size) < 0xb0000000)) {
		if (segment8_a_mapped) {
			*bshp = bpa;
			return 0;
		}
	}
a1080 2
bus_addr_t bus_space_unmap_p __P((bus_space_tag_t t, bus_space_handle_t bsh,
			  bus_size_t size));
a1082 12
bus_addr_t
bus_space_unmap_p(t, bsh, size)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t size;
{
	bus_addr_t paddr;

	paddr = (bus_addr_t) pmap_extract(pmap_kernel(), bsh);
	bus_space_unmap((t), (bsh), (size));
	return paddr ;
}
a1090 1
	bus_addr_t bpa;
d1102 6
a1107 8
#if 0
	bpa = pmap_extract(pmap_kernel(), sva);
	if (extent_free(devio_ex, bpa, size, EX_NOWAIT | 
		(ppc_malloc_ok ? EX_MALLOCOK : 0)))
	{
		printf("bus_space_map: pa 0x%x, size 0x%x\n",
			bpa, size);
		printf("bus_space_map: can't free region\n");
d1110 1
a1110 1
	pmap_remove(vm_map_pmap(phys_map), sva, sva+len);
d1130 2
d1182 3
a1184 2
	if ((pa >= 0x80000000) && ((pa+len) < 0xb0000000)) {
		if (segment8_a_mapped) {
a1208 30
void 
unmapiodev(va, p_size)
	void *va;
	psize_t p_size;
{
	vaddr_t vaddr;
	int size;

	size = p_size;

	vaddr = trunc_page(va);

#ifdef UVM
	uvm_km_free_wakeup(phys_map, vaddr, size);
#else
	kmem_free_wakeup(phys_map, vaddr, size);
#endif

	for (; size > 0; size -= NBPG) {
#if 0
		pmap_remove(vm_map_pmap(phys_map), vaddr, vaddr+NBPG-1);
#else
		pmap_remove(pmap_kernel(), vaddr,  vaddr+NBPG-1);
#endif
		vaddr += NBPG;
	}
	return;
}


d1272 1
a1272 1
	u_int8_t *dst;							\
a1275 1
	TYPE *rdst = (TYPE *)dst;					\
d1281 1
a1281 1
		rdst[i] = *src;						\
d1295 1
a1295 1
	const u_int8_t *src;						\
a1299 1
	TYPE *rsrc = (TYPE *)src;					\
d1304 1
a1304 1
		*dst = rsrc[i];						\
a1366 31
}
void
nameinterrupt(replace, newstr)
	int replace;
	char *newstr;
{
#define NENTRIES 66
	char intrname[NENTRIES][30];
	char *p, *src;
	int i;
	extern char intrnames[];
	extern char eintrnames[];

	if (replace > NENTRIES) {
		return;
	}
	src = intrnames;

	for (i = 0; i < NENTRIES; i++) {
		src += strlcpy(intrname[i], src, 30);
		src+=1; /* skip the NUL */
	}

	strcat(intrname[replace], "/");
	strcat(intrname[replace], newstr);

	p = intrnames;
	for (i = 0; i < NENTRIES; i++) {
		p += strlcpy(p, intrname[i], eintrnames - p);
		p += 1; /* skip the NUL */
	}
@


1.32.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32.2.3 2001/05/14 21:36:56 niklas Exp $	*/
a33 1
/*
a34 1
*/
a67 4
#include <dev/cons.h>

#include <dev/ofw/openfirm.h>

a76 7
#ifdef DDB
#include <machine/db_machdep.h>
#include <ddb/db_access.h>
#include <ddb/db_sym.h>
#include <ddb/db_extern.h>
#endif

d85 1
d104 2
d109 1
a126 4
#ifdef DDB
void * startsym, *endsym;
#endif

a145 4

/* XXX, called from asm */
void initppc(u_int startkernel, u_int endkernel, char *args);

d151 10
a160 9
	extern void *trapcode; extern int trapsize;
	extern void *dsitrap; extern int dsisize;
	extern void *isitrap; extern int isisize;
	extern void *alitrap; extern int alisize;
	extern void *decrint; extern int decrsize;
	extern void *tlbimiss; extern int tlbimsize;
	extern void *tlbdlmiss; extern int tlbdlmsize;
	extern void *tlbdsmiss; extern int tlbdsmsize;
	extern void *ddblow; extern int ddbsize;
a263 3
		case EXC_ALI:
			bcopy(&alitrap, (void *)EXC_ALI, (size_t)&alisize);
			break;
d277 1
a280 4
#if defined(DDB)
			bcopy(&ddblow, (void *)exc, (size_t)&ddbsize);
#else 
#if NIPKDB > 0
d282 1
a283 2
#endif
			break;
d289 1
d293 4
d328 6
a333 5
	while ( *++bootpath && *bootpath != ' ');
	if (*bootpath) {
		*bootpath++ = 0;
		while (*bootpath) {
			switch (*bootpath++) {
a345 2
			default:
				break;
a348 1
	bootpath= &bootpathbuf[0];
d350 1
a350 7
	bcopy(args +strlen(args) + 1, &startsym, sizeof(startsym));
	bcopy(args +strlen(args) + 5, &endsym, sizeof(endsym)); 
	ddb_init((int)((u_int)endsym - (u_int)startsym), startsym, endsym);
#endif

#ifdef DDB
	ddb_init();
d465 1
d468 4
d480 1
d489 7
d509 2
a510 1
		curbufsize = PAGE_SIZE * (i < residual ? base + 1 : base);
d521 5
d532 1
d535 4
d543 1
d546 4
d552 7
d561 4
d571 1
d573 3
d577 1
a577 1
	    bufpages * PAGE_SIZE);
d585 3
d589 12
d637 1
a637 1
		bufpages = physmem * BUFCACHEPERCENT / 100;
d650 2
a651 2
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;
d658 3
d728 1
d772 1
a772 1
	pmap_extract(vm_map_pmap(&p->p_vmspace->vm_map),tf->srr0, &pa);
d910 1
d1045 3
d1164 1
a1164 1
	pmap_extract(pmap_kernel(), bsh, &paddr);
d1176 1
d1183 1
d1185 3
d1189 1
a1189 1
	pmap_extract(pmap_kernel(), sva, &bpa);
d1232 1
d1234 3
a1254 24

int
bus_space_alloc(tag, rstart, rend, size, alignment, boundary, cacheable, addrp, handlep)
	bus_space_tag_t tag;
	bus_addr_t rstart, rend;
	bus_size_t size, alignment, boundary;
	int cacheable;
	bus_addr_t *addrp;
        bus_space_handle_t *handlep;
{

	panic("bus_space_alloc: unimplemented");
}

void
bus_space_free(tag, handle, size)
	bus_space_tag_t tag;
	bus_space_handle_t handle;
	bus_size_t size;
{

	panic("bus_space_free: unimplemented");
}

d1273 1
d1275 3
d1295 2
a1296 2
unmapiodev(kva, p_size)
	void *kva;
d1304 1
a1304 1
	vaddr = trunc_page((vaddr_t)kva);
d1306 1
d1308 3
d1339 1
@


1.32.2.5
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32.2.4 2001/07/04 10:22:58 niklas Exp $	*/
@


1.32.2.6
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.32.2.7
log
@repair
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32.2.6 2001/11/13 21:04:16 niklas Exp $	*/
@


1.31
log
@

UVM changes mainly. As of this checkin UVM is still not working for powerpc
it has a copyin bug after device configuration. However to get these diffs
out of my tree.

All of the UVM code is currently inside ifdef UVM the kernel works fine
without option UVM. Config files have been left without UVM for now.

Prelimiary changes for busdma, (what UVM was wanted for).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 1999/11/09 04:38:17 rahnds Exp $	*/
d1062 1
a1062 1
	bpa += POWERPC_BUS_TAG_BASE(t);
@


1.30
log
@fix ipv6 typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.29 1999/11/28 23:36:16 rahnds Exp $	*/
d72 1
d86 15
d103 7
d276 5
d282 1
a296 1

d435 4
d441 1
d445 1
d454 1
a454 1
			&minaddr, sz, FALSE) != KERN_SUCCESS)
d469 2
a470 1
		vm_map_pageable(buffer_map, curbuf, curbuf + curbufsize, FALSE);
d473 1
d479 7
a485 2
	exec_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
				 16*NCARGS, TRUE);
d490 7
a496 2
	phys_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
				 VM_PHYS_SIZE, TRUE);
d502 2
a503 2
	mclrefcnt = (char *)malloc(NMBCLUSTERS + CLBYTES/MCLBYTES,
				   M_MBUF, M_NOWAIT);
d505 4
d510 2
a511 1
			       VM_MBUF_SIZE, FALSE);
d520 3
d524 3
a526 2
	printf("using %d buffers containing %d bytes of memory\n",
	       nbuf, bufpages * CLBYTES);
d586 1
a586 1
		bufpages = (physmem / ((100/BUFCACHEPERCENT) / CLSIZE));
d594 2
a595 2
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) * 7 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
d607 1
d609 1
d974 1
a974 1
		{ "PowerBook",  "(APPL) Apple Powerbook ",  APPL},
d1095 3
d1099 1
d1140 3
d1144 1
d1176 3
d1180 1
d1341 20
@


1.29
log
@Add recognition support for powerbook, it is reported to work with
ethernet and disk now.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 1999/11/09 04:38:17 rahnds Exp $	*/
d746 1
a746 1
		ipv6intr();
@


1.28
log
@Merge error in previous version caused compilation failure.
Commit properly started and terminated.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27 1999/11/09 00:20:42 rahnds Exp $	*/
d917 1
@


1.27
log
@autoconf.c:
	calculate delay time for delay() before it is acutally used.
	add support for md_diskconf come closer to supporting crashdumps,
	eventually this code should be un if 0 ed and supported.
	add the wd device as a supported device, fix some comments.
clock.c:
	support calculation of delay loop earlier, do the spin loop correcly,
	unsigned math on the lower half, not signed math.
conf.c:
	addd support for wd driver, block major 0, char major 11.
machdep.c:
	bus_space_map becomes a real function, not just inlined function.
	Support devices that are not mapped with bats (most still currently
	are mapped with bats,...). BAT mapping does not allow proper
	mapping of cachable devices.
	mapiodev HACK, NEEDS TO BE REMOVED. added for quicker import
	of BROKEN mac drivers. the drivers NEED to be rewritten in
	a busified manner. it would FIX all of the endian swabbing
	done by each driver. (Is that emphasized enough?)

	bus_space_(read|write)_raw_multi as functions, should these
	be turned into inline functions and put in bus.h?
ofw_machdep.c:
	removed extranious variable.
openfirm.c:
	telling openfirmware to "boot" will put the system
	in somewhat of a strange state, try reset-all, but that
	typically fails, therefore, try OF_exit before spinning.
pmap.c:
	support stealing memory from kernel address space so that
	mappings can be created before vm is initalized.
vm_machdep.c:
	maybe the meaning of removing this will later become obvious. ???
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.26 1999/10/28 04:28:03 rahnds Exp $	*/
d349 1
@


1.26
log
@clean up a global pointer/array reference for OF_buf.
fix typo someone made.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.25 1999/07/05 20:56:26 rahnds Exp $	*/
d49 1
d88 1
d103 2
d114 11
a149 1

d177 1
d180 1
a180 1
#if 0
d202 1
d206 1
a251 6
	/*
	 * Now enable translation (and machine checks/recoverable interrupts).
	 */
	(fw->vmon)();
	#if 0
	#endif
d260 5
d306 29
a348 8
	ofwconprobe();

	/*
	 * Now we can set up the console as mapping is enabled.
         */
	consinit();

	/*
d352 6
d393 1
a395 1
	v = (caddr_t)proc0paddr + USPACE;
d400 1
a400 1
	
d410 1
a410 1
	
d450 1
d472 1
d481 1
a720 7
/*
 * Crash dump handling.
 */
u_long dumpmag = 0x8fca0101;		/* magic number */
int dumpsize = 0;			/* size of dump in pages */
long dumplo = -1;			/* blocks */

d915 1
d988 145
d1170 5
a1174 1
__C(bus_space_set_region_,BYTES)(v, h, o, val, c)					\
d1176 1
a1176 1
	TYPE *src, *dst;						\
d1188 83
@


1.25
log
@Several changes here:
(Some of these changes are work in progress and may change more later)
locore.S:
        rearranged to remove most of the direct openfirmware references in
        the attempt to move all of the openfirmware pieces into ofw_ files.
        This could allow other firmware type to be supported easier. Also
        this keeps the openfirmware code grouped in the same files.

        OF_buf is now statically allocated in the data/bss section instead
        of allocated during initialization.

machdep.c:
        change the order of vm initialization, Still considering removing
        the BATs from use. instead of calls directly to ppc_exit and ppc_boot
        these are now called via a firmware function pointer structure.
        Add iMac recognition to systems
ofw_machdep.c:
        function pointer structure to allow different firmware to supply
        specific system functionality, normally startup and reset,
        including a hook to notify when bsd is about to go virtual,
        in case firmware calls need to act different after that time.

        Allow BSD to handle the virtual memory operations for openfirmware.
        this idea was copied from NetBSD macppc, It is not fully implemented,
        among other problems, openfirmware does not have a mechanism to
        add new mappings.

ofwreal.S:
        Major rewrite of the firmware call code, It still copies
        a portion of the stack, but now does not restore exeception vectors.
        Modified to be similar in idea to NetBSD macppc with BSD handling
        the openfirmware VM faults/TLB misses.
        This still needs to be reviewed, Should be possible to not require
        any stack copy.

opendev.c:
        OF_bus is not a pointer to the buffer, but is the buffer itself now.

openfirm.c:
        OF_bus is not a pointer to the buffer, but is the buffer itself now.
        Dont panic if OF_boot fails, OF_boot can be called by panic.
        instead print and the hang in a spin loop.

pmap.c:
        call the firmware function to get memory regions.
        Scale the PowerPC hash table size by size of real memory.
        Properly align the hash table based on the start, not just
        the size.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 1999/05/24 23:09:07 jason Exp $	*/
a310 1
	printf("hello\n");
d812 2
@


1.24
log
@Only do basic work in the ethernet interrupt context, and queue packets to
be bridged.  Do the real work in a scheduled netisr.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.23 1999/05/22 21:22:29 weingart Exp $	*/
d99 1
d111 2
d139 1
a143 1

d163 3
d172 1
a186 1
#if 1
d189 1
a189 1
#endif
d204 1
d211 1
d238 3
a240 2
	__asm__ volatile ("mfmsr %0; ori %0,%0,%1; mtmsr %0; isync"
		      : "=r"(scratch) : "K"(PSL_IR|PSL_DR|PSL_ME|PSL_RI));
d242 1
a242 1
	ofwconprobe();
d245 7
a251 3
	 * Now we can set up the console as mapping is enabled.
         */
	consinit();
d304 2
d307 3
a309 3
	 * Initialize pmap module.
	 */
	pmap_bootstrap(startkernel, endkernel);
d311 1
d786 1
a786 1
		ppc_exit();
d811 2
a812 1
	ppc_boot(str);
d872 1
a872 1
		{ "MOT,",	"(PWRSTK) MCG powerstack family", PWRSTK },
d874 1
d888 2
a889 1
		printf("System type not recognized, good luck\n");
@


1.23
log
@Add new vm_swap code for dynamic swap.  From netbsd, munged some by me, and
others.   syscall commit pending.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.22 1999/01/11 05:11:54 millert Exp $	*/
d717 5
@


1.22
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21 1999/01/07 23:16:06 deraadt Exp $	*/
a446 1
	valloc(swapmap, struct map, nswapmap = maxproc * 2);
@


1.21
log
@global decl for *intr() routines, plus add INET6
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.20 1998/10/09 02:13:56 rahnds Exp $	*/
d887 1
a887 1
	panic("ppc_intr_establish called before interrupt controller configured: driver %s\n", name);
@


1.20
log
@Functions to enable and disable interrupts, instead of spreading asm code
through the drivers. Ok, it would not be too bad to have it an inlined
function in a header file, but it is not that bad.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.19 1998/09/27 03:56:00 rahnds Exp $	*/
d689 4
@


1.19
log
@add wscons support to powerpc port.
This contains several pieces of the port
MI:
    vgafb, on powerpc under openfirmware the vga card comes up in gfx mode.
    instead of resetting it to text mode, vgafb treats this as a raster
    display. The mechanism used may not have been the best, it's
    interface to wscons is as a text display, and it does the character
    plotting itself.
    font_8x16.c was stolen from the atari port for use.

MD:
    ppcppi support stolen from alpha
    pms.c, pckbd.c and the rest of the support files were
    used nearly directly.

    powerpc
      conf.c to support wscon, vga/kbd
      machdep.c hack to get around a bus_space_set_region,bus_space_copy error.
      ofw_machdep.c some hack code on the road to supporting wscons as console.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.18 1998/09/20 22:11:48 rahnds Exp $	*/
d895 25
@


1.18
log
@Changes to probe for address, and frequency for serial console.
This should enable the same kernel to work on VI machines as
well as MCG machines. Only remaining piece is the rtc.

For now an extra config file has been added to use serial for MCG
machines until all issues are resolved.  The various extra config
files and ramdisks should go away as soon as merger is finished.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.17 1998/09/12 19:58:56 rahnds Exp $	*/
d895 51
@


1.17
log
@Detect more that just Motorola machines for openfirmware hardware
detection. This should allow MIX to run on Power4 and possibly Power3 machines.
It emits a warning when the system was not recognised.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.16 1998/09/09 04:44:59 rahnds Exp $	*/
a98 1
int cons_initted;
d233 2
d504 2
a505 1
	
@


1.16
log
@Allow ddb to be entered upon boot via boot command argument.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.15 1998/08/25 07:58:48 pefo Exp $	*/
d836 25
a860 3
	if (strncmp (name, "MOT,", 4) == 0) {
		system_type = PWRSTK;
		printf("recognized system type of %s as PWRSTK\n", name);
@


1.15
log
@Mapping stuff v.i 4e
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.14 1998/08/22 18:31:57 rahnds Exp $	*/
d283 5
@


1.14
log
@Various changes to allow mixing of ofw drivers and real drivers.
NCR driver seems to work.
Major changes are isa can be child of pci or mainbus.
ofroot is child of mainbus not root.
ofw bus configured before pci bus
Note that if a pci device configures accessing of driver will crash
the system. they need to be exclusive.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.13 1998/05/29 04:15:39 rahnds Exp $	*/
d162 4
a165 7
		/* DBAT1 maps I/O */
		battable[1].batl = BATL(0x80000000, BAT_I);
		battable[1].batu = BATU(0x80000000);

		/* DBAT2 maps PCI mem */
		battable[2].batl = BATL(MPC106_P_PCI_MEM_SPACE, BAT_I);
		battable[2].batu = BATU(MPC106_V_PCI_MEM_SPACE);
d181 1
d184 1
a184 2
	__asm__ volatile ("mtdbatl 2,%0; mtdbatu 2,%1"
		      :: "r"(battable[2].batl), "r"(battable[2].batu));
d413 5
d427 1
a428 6
	/*
	 * Configure devices.
	 */
	configure();
	
}
@


1.13
log
@Major changes here and there, tweaks elsewhere.
Support for Openfirmware drivers was reintroduced so that more systems
were supported. This should work with the real driver configurations
as well.

Bootloader files were deleted/replaced with the newer versions in the
subdirectory. Some effort has been made to be closer to support booting
(at least the bootloader) on the Mac.

Config files that end with OFW are the openfirmware versions of the kernels
without have native drivers.

Native driver support has not been changed, presumably it still works.
I couldn't test that.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.12 1997/10/21 18:01:45 pefo Exp $	*/
d826 42
@


1.12
log
@Dig out the ethernet address from the board configuration. This just takes
the first "network" with a "mac-address" for this. In the future this has
to be improved (probably) to handle more than one ethernet ifc.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.11 1997/10/21 11:00:10 pefo Exp $	*/
d88 6
a93 1
int system_type = POWER4e;	/* XXX Hardwire it for now */
d811 15
@


1.11
log
@Straighten up boot options.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.10 1997/10/15 14:07:52 pefo Exp $	*/
d90 1
d103 1
d287 5
d779 27
@


1.10
log
@Add shm/sem includes, fix up disklabel stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.9 1997/10/13 13:42:58 pefo Exp $	*/
d242 2
a243 2
#else    
	boothowto = RB_SINGLE | RB_ASKNAME;
@


1.9
log
@Monolithic (No OpenFirmware driver crap...) PowerPC kernel. This is the
first release based on Wolfgang Solfrank, TooLs GmbH, work. Most OFW stuff
has been ripped out. Only a few functions for memory probing and halt/reboot
functionality has been kept. The kernel currently works with V.I's power.4e
PowerPC604 board, but more will come.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.8 1997/07/23 06:58:27 denny Exp $	*/
d55 9
@


1.8
log
@Add AppleTalk netisr. Only tested (indeed, only compiled) on mac68k port.
Add options NETATALK to your config to try it out.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.7 1997/02/27 23:40:19 rahnds Exp $	*/
d61 2
d64 1
d73 1
d79 2
d84 2
a93 9
static void fake_splx __P((int));
static void fake_irq_establish __P((int, int, void (*)(void *), void *));

struct machvec machine_interface = {
	fake_splx,
	fake_irq_establish,
};

int cold = 1;
d117 1
a123 7
	
	/*
	 * i386 port says, that this shouldn't be here,
	 * but I really think the console should be initialized
	 * as early as possible.
	 */
	consinit();
d125 1
a125 3
#ifdef	__notyet__		/* Needs some rethinking regarding real/virtual OFW */
	OF_set_callback(callback);
#endif
d130 8
a137 8
	asm volatile ("mtibatu 0,%0" :: "r"(0));
	asm volatile ("mtibatu 1,%0" :: "r"(0));
	asm volatile ("mtibatu 2,%0" :: "r"(0));
	asm volatile ("mtibatu 3,%0" :: "r"(0));
	asm volatile ("mtdbatu 0,%0" :: "r"(0));
	asm volatile ("mtdbatu 1,%0" :: "r"(0));
	asm volatile ("mtdbatu 2,%0" :: "r"(0));
	asm volatile ("mtdbatu 3,%0" :: "r"(0));
d145 10
d162 1
a162 1
	asm volatile ("mtibatl 0,%0; mtibatu 0,%1"
d165 1
a165 1
	asm volatile ("mtdbatl 0,%0; mtdbatu 0,%1"
d167 5
d218 1
a218 1
	asm volatile ("mfmsr %0; ori %0,%0,%1; mtmsr %0; isync"
d222 16
a277 50
/*
 * This should probably be in autoconf!				XXX
 */
int cpu;
char cpu_model[80];
char machine[] = "powerpc";	/* cpu architecture */

void
identifycpu()
{
	int phandle, pvr;
	char name[32];

	/*
	 * Find cpu type (Do it by OpenFirmware?)
	 */
	asm ("mfpvr %0" : "=r"(pvr));
	cpu = pvr >> 16;
	switch (cpu) {
	case 1:
		sprintf(cpu_model, "601");
		break;
	case 3:
		sprintf(cpu_model, "603");
		break;
	case 4:
		sprintf(cpu_model, "604");
		break;
	case 5:
		sprintf(cpu_model, "602");
		break;
	case 6:
		sprintf(cpu_model, "603e");
		break;
	case 7:
		sprintf(cpu_model, "603ev");
		break;
	case 9:
		sprintf(cpu_model, "604ev");
		break;
	case 20:
		sprintf(cpu_model, "620");
		break;
	default:
		sprintf(cpu_model, "Version %x", cpu);
		break;
	}
	sprintf(cpu_model + strlen(cpu_model), " (Revision %x)", pvr & 0xffff);
	printf("CPU: %s\n", cpu_model);
}
d292 1
a292 1
	asm volatile ("mfmsr %0; andi. %1, %0, %2; mtmsr %1"
d298 1
a298 1
	asm volatile ("mtmsr %0" :: "r"(omsr));
a315 1
	identifycpu();
d401 1
a401 1
		asm volatile ("mfmsr %0; ori %0, %0, %1; mtmsr %0"
a479 1
	static int initted;
d481 1
a481 1
	if (initted)
a482 1
	initted = 1;
d484 1
d534 1
d576 5
a648 3
int cpl;
int clockpending, softclockpending, softnetpending;

d653 2
a654 1
softnet()
a655 3
	int isr = netisr;

	netisr = 0;
a691 3
/*
 * Stray interrupts.
 */
d693 2
a694 2
strayintr(irq)
	int irq;
d696 1
a696 143
	log(LOG_ERR, "stray interrupt %d\n", irq);
}

int
splraise(bits)
	int bits;
{
	int old;
	
	old = cpl;
	cpl |= bits;

	if ((bits & SPLMACHINE) & ~old)
		(*machine_interface.splx)(cpl & SPLMACHINE);

	return old;
}

int
splx(new)
	int new;
{
	int pending, old = cpl;
	int emsr, dmsr;
	
	asm ("mfmsr %0" : "=r"(emsr));
	dmsr = emsr & ~PSL_EE;
	
	cpl = new;
	
	if ((new & SPLMACHINE) != (old & SPLMACHINE))
		(*machine_interface.splx)(new & SPLMACHINE);

	while (1) {
		cpl = new;
		
		asm volatile ("mtmsr %0" :: "r"(dmsr));
		if (clockpending && !(cpl & SPLCLOCK)) {
			struct clockframe frame;
			extern int intr_depth;
			
			cpl |= SPLCLOCK;
			clockpending--;
			asm volatile ("mtmsr %0" :: "r"(emsr));
			
			/*
			 * Fake a clock interrupt frame
			 */
			frame.pri = new;
			frame.depth = intr_depth + 1;
			frame.srr1 = 0;
			frame.srr0 = (int)splx;
			/*
			 * Do standard timer interrupt stuff
			 */
			hardclock(&frame);
			continue;
		}
		if (softclockpending && !(cpl & SPLSOFTCLOCK)) {
			
			cpl |= SPLSOFTCLOCK;
			softclockpending = 0;
			asm volatile ("mtmsr %0" :: "r"(emsr));
			
			softclock();
			continue;
		}
		if (softnetpending && !(cpl & SPLSOFTNET)) {
			cpl |= SPLSOFTNET;
			softnetpending = 0;
			asm volatile ("mtmsr %0" :: "r"(emsr));
			softnet();
			continue;
		}
		
		asm volatile ("mtmsr %0" :: "r"(emsr));
		
		return old;
	}
}

/*
 * This one is similar to the above, but returns with interrupts disabled.
 * It is intended for use during interrupt exit (as the name implies :-)).
 */
void
intr_return(level)
	int level;
{
	int pending, old = cpl;
	int emsr, dmsr;
	
	asm ("mfmsr %0" : "=r"(emsr));
	dmsr = emsr & ~PSL_EE;
	
	cpl = level;
	
	if ((level & SPLMACHINE) != (old & SPLMACHINE))
		(*machine_interface.splx)(level & SPLMACHINE);

	while (1) {
		cpl = level;
		
		asm volatile ("mtmsr %0" :: "r"(dmsr));
		if (clockpending && !(cpl & SPLCLOCK)) {
			struct clockframe frame;
			extern int intr_depth;
			
			cpl |= SPLCLOCK;
			clockpending--;
			asm volatile ("mtmsr %0" :: "r"(emsr));
			
			/*
			 * Fake a clock interrupt frame
			 */
			frame.pri = level | (clockpending ? SPLSOFTCLOCK : 0);
			frame.depth = intr_depth + 1;
			frame.srr1 = 0;
			frame.srr0 = (int)splx;
			/*
			 * Do standard timer interrupt stuff
			 */
			hardclock(&frame);
			continue;
		}
		if (softclockpending && !(cpl & SPLSOFTCLOCK)) {
			
			cpl |= SPLSOFTCLOCK;
			softclockpending = 0;
			asm volatile ("mtmsr %0" :: "r"(emsr));
			
			softclock();
			continue;
		}
		if (softnetpending && !(cpl & SPLSOFTNET)) {
			cpl |= SPLSOFTNET;
			softnetpending = 0;
			asm volatile ("mtmsr %0" :: "r"(emsr));
			softnet();
			continue;
		}
		break;
	}
a762 28
}

/*
 * OpenFirmware callback routine
 */
void
callback(p)
	void *p;
{
	panic("callback");	/* for now			XXX */
}

/*
 * Fake routines for spl/interrupt handling before autoconfig
 */
static void
fake_splx(new)
	int new;
{
}

static void
fake_irq_establish(irq, level, handler, arg)
	int irq, level;
	void (*handler) __P((void *));
	void *arg;
{
	panic("fake_irq_establish");
@


1.7
log
@Fix MAXBUFCACHE changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.6 1997/02/24 12:50:28 deraadt Exp $	*/
d693 4
@


1.6
log
@implement BUFCACHEPERCENT and take care with kva space
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.5 1997/02/05 01:33:54 rahnds Exp $	*/
d475 1
a475 1
		bufpages = (physmem / ((100/BUFCACHEPERCENT) / CLSIZE);
@


1.5
log
@Siginfo changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.4 1997/01/20 20:43:48 rahnds Exp $	*/
d468 3
d475 1
a475 1
		bufpages = (physmem / 20) / CLSIZE;
d481 10
@


1.4
log
@ifdef the RB_TIMEBAD change,
resettodr doesn't currently do anything anyway, put this problem
off till later.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.3 1997/01/16 20:43:44 kstailey Exp $	*/
d539 1
a539 1
sendsig(catcher, sig, mask, code)
d543 2
a569 2
	frame.sf_code = code;
	
d575 1
d577 4
d584 1
d588 1
a588 1
	tf->fixreg[4] = (int)code;
@


1.3
log
@do not call resettodr() if RB_TIMEBAD is set due to being in ddb with clock updates suspended
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.2 1996/12/28 06:22:05 rahnds Exp $	*/
d868 4
d882 1
@


1.2
log
@Adding OpenBSD tags to files.
@
text
@d1 1
a1 1
/*	$OpenBSD:$	*/
d868 10
a877 1
		resettodr();		/* set wall clock */
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@Check-in of powerpc kernel support.
NOTE: This will not work until the other pieces are checked in.
This is primarily the NetBSD powerpc port, with modifications
to support ELF. 
@
text
@@
