head	1.26;
access;
symbols
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	UBC_SYNC_A:1.26
	UBC_SYNC_B:1.26
	OPENBSD_2_9_BASE:1.21
	OPENBSD_2_9:1.21.0.2
	OPENBSD_2_8:1.19.0.2
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	SMP:1.12.0.2
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	powerpc_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2001.09.01.15.44.20;	author drahn;	state dead;
branches;
next	1.25;

1.25
date	2001.08.18.05.39.03;	author drahn;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.11.16.18.42;	author matthieu;	state Exp;
branches;
next	1.23;

1.23
date	2001.07.25.13.25.33;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.24.23.29.35;	author drahn;	state Exp;
branches;
next	1.21;

1.21
date	2001.03.03.05.33.47;	author drahn;	state Exp;
branches;
next	1.20;

1.20
date	2001.03.02.01.53.30;	author drahn;	state Exp;
branches;
next	1.19;

1.19
date	2000.10.19.03.16.16;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2000.09.19.05.54.32;	author rahnds;	state Exp;
branches;
next	1.17;

1.17
date	2000.09.19.05.28.11;	author rahnds;	state Exp;
branches;
next	1.16;

1.16
date	2000.09.07.03.02.04;	author rahnds;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.06.02.45.12;	author rahnds;	state Exp;
branches;
next	1.14;

1.14
date	2000.03.23.04.04.21;	author rahnds;	state Exp;
branches;
next	1.13;

1.13
date	2000.03.20.07.05.53;	author rahnds;	state Exp;
branches;
next	1.12;

1.12
date	99.11.09.00.20.42;	author rahnds;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	99.09.03.18.01.49;	author art;	state Exp;
branches;
next	1.10;

1.10
date	99.07.05.20.56.26;	author rahnds;	state Exp;
branches;
next	1.9;

1.9
date	98.09.27.03.56.00;	author rahnds;	state Exp;
branches;
next	1.8;

1.8
date	98.09.20.22.11.48;	author rahnds;	state Exp;
branches;
next	1.7;

1.7
date	98.09.09.04.48.16;	author rahnds;	state Exp;
branches;
next	1.6;

1.6
date	98.06.28.04.35.17;	author rahnds;	state Exp;
branches;
next	1.5;

1.5
date	98.05.29.04.15.40;	author rahnds;	state Exp;
branches;
next	1.4;

1.4
date	97.10.13.13.42.59;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	97.02.24.12.51.54;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.12.28.06.22.09;	author rahnds;	state Exp;
branches;
next	1.1;

1.1
date	96.12.21.20.35.58;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.12.21.20.35.58;	author rahnds;	state Exp;
branches;
next	;

1.12.2.1
date	2000.03.24.09.08.43;	author niklas;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2001.05.14.21.36.57;	author niklas;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2001.07.04.10.23.00;	author niklas;	state Exp;
branches;
next	1.12.2.4;

1.12.2.4
date	2001.10.31.03.07.55;	author nate;	state dead;
branches;
next	1.12.2.5;

1.12.2.5
date	2001.11.13.21.04.16;	author niklas;	state Exp;
branches;
next	1.12.2.6;

1.12.2.6
date	2001.11.13.22.14.34;	author niklas;	state dead;
branches;
next	;


desc
@@


1.26
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/powerpc to macppc/macppc

This moves hardware specific files from the common directory to the
platform specific directory. This leaves common files.
With this change all of the debugger (db_) files have been moved to
the platform specific directory. The debugger should be reconsidered
and commonized.
@
text
@/*	$OpenBSD: ofw_machdep.c,v 1.25 2001/08/18 05:39:03 drahn Exp $	*/
/*	$NetBSD: ofw_machdep.c,v 1.1 1996/09/30 16:34:50 ws Exp $	*/

/*
 * Copyright (C) 1996 Wolfgang Solfrank.
 * Copyright (C) 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <sys/param.h>
#include <sys/buf.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/disk.h>
#include <sys/disklabel.h>
#include <sys/fcntl.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/stat.h>
#include <sys/systm.h>

#include <vm/vm.h>
#include <vm/vm_kern.h>

#include <machine/powerpc.h>
#include <machine/autoconf.h>

#include <dev/ofw/openfirm.h>

#include <ukbd.h>
#include <akbd.h>
#include <dev/usb/ukbdvar.h>
#include <powerpc/mac/akbdvar.h>

/* XXX, called from asm */
int save_ofw_mapping(void);
int restore_ofw_mapping(void);

void OF_exit __P((void)) __attribute__((__noreturn__));
void OF_boot __P((char *bootspec)) __attribute__((__noreturn__));
void ofw_mem_regions __P((struct mem_region **memp, struct mem_region **availp));
void ofw_vmon __P((void));

struct firmware ofw_firmware = {
	ofw_mem_regions,
	OF_exit,
	OF_boot,
	ofw_vmon
#ifdef FW_HAS_PUTC
	ofwcnputc;
#endif
};

#define	OFMEM_REGIONS	32
static struct mem_region OFmem[OFMEM_REGIONS + 1], OFavail[OFMEM_REGIONS + 3];

/*
 * This is called during initppc, before the system is really initialized.
 * It shall provide the total and the available regions of RAM.
 * Both lists must have a zero-size entry as terminator.
 * The available regions need not take the kernel into account, but needs
 * to provide space for two additional entry beyond the terminating one.
 */
void
ofw_mem_regions(memp, availp)
	struct mem_region **memp, **availp;
{
	int phandle;
	
	/*
	 * Get memory.
	 */
	if ((phandle = OF_finddevice("/memory")) == -1
	    || OF_getprop(phandle, "reg",
			  OFmem, sizeof OFmem[0] * OFMEM_REGIONS)
	       <= 0
	    || OF_getprop(phandle, "available",
			  OFavail, sizeof OFavail[0] * OFMEM_REGIONS)
	       <= 0)
		panic("no memory?");
	*memp = OFmem;
	/* HACK */
	if (OFmem[0].size == 0) {
		*memp = OFavail;
	}
	*availp = OFavail;
}

typedef void (fwcall_f) __P((int, int));
extern fwcall_f *fwcall;
fwcall_f fwentry;
extern u_int32_t ofmsr;

void
ofw_vmon()
{
	fwcall = &fwentry;
}

/* code to save and create the necessary mappings for BSD to handle
 * the vm-setup for OpenFirmware
 */
static int N_mapping;
static struct {
	vm_offset_t va;
	int len;
	vm_offset_t pa;
	int mode;
} ofw_mapping[256];

int OF_stdout;
int OF_stdin;

int
save_ofw_mapping()
{
	int mmui, mmu;
	int chosen;
	int stdout, stdin;
	if ((chosen = OF_finddevice("/chosen")) == -1) {
		return 0;
	}
	if (OF_getprop(chosen, "stdin", &stdin, sizeof stdin) != sizeof stdin)
	{
		return 0;
	}
	OF_stdin = stdin;
	if (OF_getprop(chosen, "stdout", &stdout, sizeof stdout) != sizeof stdout)
	{
		return 0;
	}
	OF_stdout = stdout;

	chosen = OF_finddevice("/chosen");

	OF_getprop(chosen, "mmu", &mmui, 4);
	mmu = OF_instance_to_package(mmui);
	bzero(ofw_mapping, sizeof(ofw_mapping));
	N_mapping =
	    OF_getprop(mmu, "translations", ofw_mapping, sizeof(ofw_mapping));
	N_mapping /= sizeof(ofw_mapping[0]);

	fw = &ofw_firmware;
	fwcall = &fwentry;
	return 0;
}

struct pmap ofw_pmap;
int
restore_ofw_mapping()
{
	int i;

	pmap_pinit(&ofw_pmap);

	ofw_pmap.pm_sr[KERNEL_SR] = KERNEL_SEGMENT;

	for (i = 0; i < N_mapping; i++) {
		vm_offset_t pa = ofw_mapping[i].pa;
		vm_offset_t va = ofw_mapping[i].va;
		int size = ofw_mapping[i].len;

		if (va < 0xf8000000)			/* XXX */
			continue;

		while (size > 0) {
			pmap_enter(&ofw_pmap, va, pa, VM_PROT_ALL, PMAP_WIRED);
			pa += NBPG;
			va += NBPG;
			size -= NBPG;
		}
	}

	return 0;
}

typedef void  (void_f) (void);
extern void_f *pending_int_f;
void ofw_do_pending_int(void);
extern int system_type;

void ofw_intr_init(void);
void
ofrootfound()
{
	int node;
	struct ofprobe probe;
		
	if (!(node = OF_peer(0)))
		panic("No PROM root");
	probe.phandle = node;
	if (!config_rootfound("ofroot", &probe))
		panic("ofroot not configured");
	if (system_type == OFWMACH) {
		pending_int_f = ofw_do_pending_int;
		ofw_intr_init();
	}
}
void
ofw_intr_establish()
{
	if (system_type == OFWMACH) {
		pending_int_f = ofw_do_pending_int;
		ofw_intr_init();
	}
}
void
ofw_intr_init()
{
	/*
	 * There are tty, network and disk drivers that use free() at interrupt
	 * time, so imp > (tty | net | bio).
	 */
	/* with openfirmware drivers all levels block clock
	 * (have to block polling)
	 */
	imask[IPL_IMP] = SPL_CLOCK;
	imask[IPL_TTY] = SPL_CLOCK | SINT_TTY;
	imask[IPL_NET] = SPL_CLOCK | SINT_NET;
	imask[IPL_BIO] = SPL_CLOCK;
	imask[IPL_IMP] |= imask[IPL_TTY] | imask[IPL_NET] | imask[IPL_BIO];

	/*
	 * Enforce a hierarchy that gives slow devices a better chance at not
	 * dropping data.
	 */
	imask[IPL_TTY] |= imask[IPL_NET] | imask[IPL_BIO];
	imask[IPL_NET] |= imask[IPL_BIO];

	/*
	 * These are pseudo-levels.
	 */
	imask[IPL_NONE] = 0x00000000;
	imask[IPL_HIGH] = 0xffffffff;

}
void
ofw_do_pending_int()
{
	int pcpl;
	int emsr, dmsr;
static int processing;

	if(processing)
		return;

	processing = 1;
	__asm__ volatile("mfmsr %0" : "=r"(emsr));
	dmsr = emsr & ~PSL_EE;
	__asm__ volatile("mtmsr %0" :: "r"(dmsr));


	pcpl = splhigh();		/* Turn off all */
	if((ipending & SINT_CLOCK) && ((pcpl & imask[IPL_CLOCK]) == 0)) {
		ipending &= ~SINT_CLOCK;
		softclock();
	}
	if((ipending & SINT_NET) && ((pcpl & imask[IPL_NET]) == 0) ) {
		extern int netisr;
		int pisr = netisr;
		netisr = 0;
		ipending &= ~SINT_NET;
		softnet(pisr);
	}
	ipending &= pcpl;
	cpl = pcpl;	/* Don't use splx... we are here already! */
	__asm__ volatile("mtmsr %0" :: "r"(emsr));
	processing = 0;
}
#if 0
u_int32_t ppc_console_iomem=0;
u_int32_t ppc_console_addr=0;
u_int32_t ppc_console_qhandle=0;
u_int32_t ppc_console_serfreq;

void
ofwtrysercon(char *name, int qhandle)
{
/* for serial we want regs field */
	int regs[4];
	int freq;
	int regn;
	if ((regn = OF_getprop(qhandle, "reg", &regs[0], sizeof regs)) >= 0) {

		if (regs[1] == 0x3f8) {
			/* found preferred console */
			ppc_console_addr = regs[1];
			ppc_console_qhandle = qhandle;
			ppc_console_iomem=0; /* 0 means io, 1 means mem */
		}
		if ((regs[1] == 0x2e8) && (ppc_console_addr == 0)) {
			/* found nonpreferred console */
			ppc_console_addr = regs[1];
			ppc_console_qhandle = qhandle;
			ppc_console_iomem=0; /* 0 means io, 1 means mem */
		}
	}
	if ((OF_getprop(qhandle, "clock-frequency", &freq, sizeof regs)) >= 0) {
		/* MCG value for this does not agree with PC value,
		 * but works correctly (while PC value does not),
		 * does VI set this correctly???
		 */
		ppc_console_serfreq=freq;
	}
}
#endif

#include <dev/pci/pcivar.h>
#include <arch/powerpc/pci/vgafb_pcivar.h>
static pcitag_t ofw_make_tag( void *cpv, int bus, int dev, int fnc);

/* ARGSUSED */
static pcitag_t 
ofw_make_tag(cpv, bus, dev, fnc)
        void *cpv;
        int bus, dev, fnc;
{
        return (bus << 16) | (dev << 11) | (fnc << 8);
}

#if 0
/* XXX */
void
ofwenablepcimemio(char *name, int qhandle)
{
	/* THIS PROBABLY IS A MAJOR HACK
	 * AND IT WOULD PREVENT ofdisk and ofnet from working 
	 * on MCG, VI machines.
	 */
}
#endif
#define       OFW_PCI_PHYS_HI_BUSMASK         0x00ff0000
#define       OFW_PCI_PHYS_HI_BUSSHIFT        16
#define       OFW_PCI_PHYS_HI_DEVICEMASK      0x0000f800
#define       OFW_PCI_PHYS_HI_DEVICESHIFT     11
#define       OFW_PCI_PHYS_HI_FUNCTIONMASK    0x00000700
#define       OFW_PCI_PHYS_HI_FUNCTIONSHIFT   8
   
#define pcibus(x) \
	(((x) & OFW_PCI_PHYS_HI_BUSMASK) >> OFW_PCI_PHYS_HI_BUSSHIFT)
#define pcidev(x) \
	(((x) & OFW_PCI_PHYS_HI_DEVICEMASK) >> OFW_PCI_PHYS_HI_DEVICESHIFT)
#define pcifunc(x) \
	(((x) & OFW_PCI_PHYS_HI_FUNCTIONMASK) >> OFW_PCI_PHYS_HI_FUNCTIONSHIFT)


struct ppc_bus_space ppc_membus;
int cons_displaytype=0;
bus_space_tag_t cons_membus = &ppc_membus;
bus_space_handle_t cons_display_mem_h;
bus_space_handle_t cons_display_ctl_h;
int cons_height, cons_width, cons_linebytes, cons_depth;
int cons_display_ofh;
u_int32_t cons_addr;

#include "vgafb_pci.h"

struct usb_kbd_ihandles {
        struct usb_kbd_ihandles *next;
	int ihandle;
};


void
ofwconprobe()
{
#if NVGAFB_PCI > 0
	char name[32];
	char iname[32];
	int len;
	int stdout_node, stdin_node;
	int err;
	u_int32_t memtag, iotag;
	struct ppc_pci_chipset pa;
	struct {
		u_int32_t phys_hi, phys_mid, phys_lo;
		u_int32_t size_hi, size_lo;
	} addr [8];

	pa.pc_make_tag = &ofw_make_tag;

	stdout_node = OF_instance_to_package(OF_stdout);
	len = OF_getprop(stdout_node, "name", name, 20);
	name[len] = 0;
	printf("console out [%s]", name);
	cons_displaytype=1;
	cons_display_ofh = OF_stdout;
	err = OF_getprop(stdout_node, "width", &cons_width, 4);
	if ( err != 4) {
		cons_width = 0;
	}
	err = OF_getprop(stdout_node, "linebytes", &cons_linebytes, 4);
	if ( err != 4) {
		cons_linebytes = cons_width;
	}
	err = OF_getprop(stdout_node, "height", &cons_height, 4);
	if ( err != 4) {
		cons_height = 0;
	}
	err = OF_getprop(stdout_node, "depth", &cons_depth, 4);
	if ( err != 4) {
		cons_depth = 0;
	}
	err = OF_getprop(stdout_node, "address", &cons_addr, 4);
	if ( err != 4) {
		OF_interpret("frame-buffer-adr", 1, &cons_addr);
	}

	stdin_node = OF_instance_to_package(OF_stdin);
	len = OF_getprop(stdin_node, "name", iname, 20);
	iname[len] = 0;
	printf("console in [%s] ", iname);
	/* what to do about serial console? */
	if (strcmp ("keyboard", iname) == 0) {
		struct usb_kbd_ihandles *ukbds;
#if NAKBD > 0
		int akbd;
#endif
		/* if there is a usb keyboard, we want it, do not 
		 * dereference the pointer that is returned
		 */
		if (OF_call_method("`usb-kbd-ihandles", OF_stdin, 0, 1, &ukbds)
			!= -1 && ukbds != NULL)
		{
			printf("USB");
			ukbd_cnattach();
			goto kbd_found;
		}
#if NAKBD > 0
		if (OF_call_method("`adb-kbd-ihandle", OF_stdin, 0, 1, &akbd)
			!= -1 &&
		   akbd != 0 &&
		   OF_instance_to_package(akbd) != -1)
		{
			printf("ADB");
			akbd_cnattach();
			goto kbd_found;
		}
#endif
		panic("no console keyboard");
kbd_found:
	}
	printf("\n");

	len = OF_getprop(stdout_node, "assigned-addresses", addr, sizeof(addr));
	if (len == -1) {
		int node;
		node = OF_parent(stdout_node);
		len = OF_getprop(node, "name", name, 20);
		name[len] = 0;

		printf("using parent %s:", name);
		len = OF_getprop(node, "assigned-addresses",
			addr, sizeof(addr));
		if (len < sizeof(addr[0])) {
			panic(": no address\n");
		}
	}
	memtag = ofw_make_tag(NULL, pcibus(addr[0].phys_hi),
		pcidev(addr[0].phys_hi),
		pcifunc(addr[0].phys_hi));
	iotag = ofw_make_tag(NULL, pcibus(addr[1].phys_hi),
		pcidev(addr[1].phys_hi),
		pcifunc(addr[1].phys_hi));

#if 1
	printf(": memaddr %x size %x, ", addr[0].phys_lo, addr[0].size_lo);
	printf(": consaddr %x, ", cons_addr);
	printf(": ioaddr %x, size %x", addr[1].phys_lo, addr[1].size_lo);
	printf(": memtag %x, iotag %x", memtag, iotag);
	printf(": cons_width %d cons_linebytes %d cons_height %d\n",
		cons_width, cons_linebytes, cons_height);
#endif

	{
		int i;

		cons_membus->bus_base = 0x80000000;
		cons_membus->bus_reverse = 1;
#if 0
		err = bus_space_map( cons_membus, cons_addr, addr[0].size_lo,
			0, &cons_display_mem_h);
		printf("mem map err %x",err);
		bus_space_map( cons_membus, addr[1].phys_lo, addr[1].size_lo,
			0, &cons_display_ctl_h);
#endif

		vgafb_pci_console(cons_membus,
			addr[1].phys_lo, addr[1].size_lo,
			cons_membus, 
			cons_addr, addr[0].size_lo,
			&pa, pcibus(addr[1].phys_hi), pcidev(addr[1].phys_hi),
			pcifunc(addr[1].phys_hi));

#if 1
		for (i = 0; i < cons_linebytes * cons_height; i++) {
			bus_space_write_1(cons_membus,
				cons_display_mem_h, i, 0);

		}
#endif
	}
#endif
}
@


1.25
log
@make this compile __with__ akdb in the kernel configuration.
Without this, it would not configure on systems with akbd.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.24 2001/08/11 16:18:42 matthieu Exp $	*/
@


1.24
log
@make this compile without akbd in the kernel configuration.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.23 2001/07/25 13:25:33 art Exp $	*/
d55 1
@


1.23
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.22 2001/06/24 23:29:35 drahn Exp $	*/
d439 1
d441 1
d452 1
d462 1
@


1.22
log
@-Warn cleanups for powerpc, still not done.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.21 2001/03/03 05:33:47 drahn Exp $	*/
d190 1
a190 1
			pmap_enter(&ofw_pmap, va, pa, VM_PROT_ALL, 1, 0);
@


1.21
log
@Support ADB keyboards as console. Only use adb if no USB keyboard is
present.  Code mostly borrowed from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.21 2001/03/03 05:19:10 drahn Exp $	*/
d52 2
d55 6
d91 1
a91 1
	int phandle, i, j, cnt;
d136 1
a199 2
#include <dev/ofw/openfirm.h>

d202 1
a202 1
void ofw_do_pending_int();
d205 1
a205 1
void ofw_intr_init();
a262 1
	int vector;
a263 1
	int hwpend;
d277 1
a277 1
	if((ipending & SINT_CLOCK) && (pcpl & imask[IPL_CLOCK] == 0)) {
d293 1
d329 1
d333 1
d335 2
a336 2
static
pcitag_t 
d344 2
d354 1
a394 1
	int parent;
a437 1
		int node;
a439 1
		char type[20];
d495 1
a495 1
		int i,j;
@


1.20
log
@Support video controllers which have two outputs which in openfirmware have
two children of which the "screen" device is one. This exists on some laptop
systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.19 2000/10/19 03:16:16 drahn Exp $	*/
d370 6
d429 2
d432 21
a452 7
		/* ok we have a keyboard, is it usb or adb? */
		/* TODO */
		/* configure usb if UKBD exists */
#if NUKBD > 0
		printf("USB");
		ukbd_cnattach();
#endif
d477 1
a477 1
#if 0
@


1.19
log
@Clean up printfs during boot, print reasonable information, not extra
information.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.18 2000/09/19 05:54:32 rahnds Exp $	*/
d435 12
a446 3
	if (len < sizeof(addr[0])) {
		printf(": no address\n");
		return;
a482 1

@


1.18
log
@Remove hack code that "limited" the mapped memory to 64k. Now that
the BAT is used to map the 16M display memory, no size limit is needed.
(Was only originally needed because of pmap limitations).
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.17 2000/09/19 05:28:11 rahnds Exp $	*/
a391 1
	/*
a392 1
	*/
d419 1
a419 1
	printf("console in [%s]", iname);
d432 1
d446 1
d453 1
@


1.17
log
@Add openfirmware handle so that vgafb can set colormap via openfirmware.
This is an ugly kludge, but until the vgafb is made smart enough to
modify the vga registers directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.16 2000/09/07 03:02:04 rahnds Exp $	*/
a452 5

	if (addr[0].size_lo > 0x100000) {
		addr[0].size_lo = 0x100000;
	}

@


1.16
log
@Fix base address of screen (obtained from openfirmware)
Fill screen with background color.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.15 2000/09/06 02:45:12 rahnds Exp $	*/
d365 1
d396 1
@


1.15
log
@First cut at vga console support for PowerMac (USB keyboard)
uses adb to reboot or power-off system.
add support for various USB devices into device table, as well
as some other missing devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.14 2000/03/23 04:04:21 rahnds Exp $	*/
d365 1
d411 4
d446 1
d463 1
a463 1
		err = bus_space_map( cons_membus, addr[0].phys_lo, addr[0].size_lo,
d473 1
a473 1
			addr[0].phys_lo, addr[0].size_lo,
d478 4
a481 5
#if 0
		for (j = 2; j < 4; j++) {
			for (i = 0; i < cons_width * cons_height; i++) {
				bus_space_write_1(cons_membus,
					cons_display_mem_h, i, j);
a482 1
			}
@


1.14
log
@Hack to make physmem something almost reasonable, if for some reason
the G4 decides to claim that no real memory exists in the machine, even
though memory is available. Real memory size is aliased to available.
Take this out if a real cause is determined.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.13 2000/03/20 07:05:53 rahnds Exp $	*/
d52 2
d127 1
d133 1
a133 1
	int stdout;
d137 5
d323 4
d328 1
a328 1
u_int32_t 
d344 24
a367 7
#include <machine/bat.h>
/* HACK */
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>
#include <powerpc/pci/pcibrvar.h>
#include <powerpc/pci/mpc106reg.h>
d371 1
a371 1
	int qhandle, phandle;
d373 105
a477 5
	for (qhandle = OF_peer(0); qhandle; qhandle = phandle) {
		if (OF_getprop(qhandle, "device_type", name, sizeof name) >= 0)
		{
			if (strcmp (name, "serial") == 0) {
				ofwtrysercon (name, qhandle);
d480 1
a480 8

		if (phandle = OF_child(qhandle))
			continue;
		while (qhandle) {
			if (phandle = OF_peer(qhandle))
				break;
			qhandle = OF_parent(qhandle);
		}
a481 5
	/* setup pci/isa as necessary to found map io area */
#if 0
	printf("found desired console address %x qhandle %x serfreq %x\n",
		ppc_console_addr, ppc_console_qhandle,
		ppc_console_serfreq);
a482 4
		
	/* do this from probed values, not from constants */
	addbatmap(MPC106_V_ISA_IO_SPACE, MPC106_P_ISA_IO_SPACE, BAT_I); 
	addbatmap(0xB0000000, 0xB0000000, BAT_I);  /* map interrupt vector */  
@


1.13
log
@add first version of bus_dma for powerpc.
changes to trap handler to print out better information for jump to 0 bugs.
changes to pmap.c and machdep.c to debug a duplicate memory region
bug occasionally observed on imac with compressed kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.12 1999/11/09 00:20:42 rahnds Exp $	*/
d95 4
@


1.12
log
@autoconf.c:
	calculate delay time for delay() before it is acutally used.
	add support for md_diskconf come closer to supporting crashdumps,
	eventually this code should be un if 0 ed and supported.
	add the wd device as a supported device, fix some comments.
clock.c:
	support calculation of delay loop earlier, do the spin loop correcly,
	unsigned math on the lower half, not signed math.
conf.c:
	addd support for wd driver, block major 0, char major 11.
machdep.c:
	bus_space_map becomes a real function, not just inlined function.
	Support devices that are not mapped with bats (most still currently
	are mapped with bats,...). BAT mapping does not allow proper
	mapping of cachable devices.
	mapiodev HACK, NEEDS TO BE REMOVED. added for quicker import
	of BROKEN mac drivers. the drivers NEED to be rewritten in
	a busified manner. it would FIX all of the endian swabbing
	done by each driver. (Is that emphasized enough?)

	bus_space_(read|write)_raw_multi as functions, should these
	be turned into inline functions and put in bus.h?
ofw_machdep.c:
	removed extranious variable.
openfirm.c:
	telling openfirmware to "boot" will put the system
	in somewhat of a strange state, try reset-all, but that
	typically fails, therefore, try OF_exit before spinning.
pmap.c:
	support stealing memory from kernel address space so that
	mappings can be created before vm is initalized.
vm_machdep.c:
	maybe the meaning of removing this will later become obvious. ???
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.11 1999/09/03 18:01:49 art Exp $	*/
d330 4
@


1.12.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a94 4
	/* HACK */
	if (OFmem[0].size == 0) {
		*memp = OFavail;
	}
a329 4
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>
#include <powerpc/pci/pcibrvar.h>
@


1.12.2.2
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.21 2001/03/03 05:33:47 drahn Exp $	*/
a51 2
#include <ukbd.h>

a124 1
int OF_stdin;
d130 1
a130 1
	int stdout, stdin;
a133 5
	if (OF_getprop(chosen, "stdin", &stdin, sizeof stdin) != sizeof stdin)
	{
		return 0;
	}
	OF_stdin = stdin;
a314 4

#include <dev/pci/pcivar.h>
#include <arch/powerpc/pci/vgafb_pcivar.h>

d316 1
a316 1
pcitag_t 
d332 7
a338 32
#define       OFW_PCI_PHYS_HI_BUSMASK         0x00ff0000
#define       OFW_PCI_PHYS_HI_BUSSHIFT        16
#define       OFW_PCI_PHYS_HI_DEVICEMASK      0x0000f800
#define       OFW_PCI_PHYS_HI_DEVICESHIFT     11
#define       OFW_PCI_PHYS_HI_FUNCTIONMASK    0x00000700
#define       OFW_PCI_PHYS_HI_FUNCTIONSHIFT   8
   
#define pcibus(x) \
	(((x) & OFW_PCI_PHYS_HI_BUSMASK) >> OFW_PCI_PHYS_HI_BUSSHIFT)
#define pcidev(x) \
	(((x) & OFW_PCI_PHYS_HI_DEVICEMASK) >> OFW_PCI_PHYS_HI_DEVICESHIFT)
#define pcifunc(x) \
	(((x) & OFW_PCI_PHYS_HI_FUNCTIONMASK) >> OFW_PCI_PHYS_HI_FUNCTIONSHIFT)


struct ppc_bus_space ppc_membus;
int cons_displaytype=0;
bus_space_tag_t cons_membus = &ppc_membus;
bus_space_handle_t cons_display_mem_h;
bus_space_handle_t cons_display_ctl_h;
int cons_height, cons_width, cons_linebytes, cons_depth;
int cons_display_ofh;
u_int32_t cons_addr;

#include "vgafb_pci.h"

struct usb_kbd_ihandles {
        struct usb_kbd_ihandles *next;
	int ihandle;
};


d342 1
a342 1
#if NVGAFB_PCI > 0
d344 2
a345 65
	char iname[32];
	int len;
	int stdout_node, stdin_node;
	int parent;
	int err;
	u_int32_t memtag, iotag;
	struct ppc_pci_chipset pa;
	struct {
		u_int32_t phys_hi, phys_mid, phys_lo;
		u_int32_t size_hi, size_lo;
	} addr [8];

	pa.pc_make_tag = &ofw_make_tag;

	stdout_node = OF_instance_to_package(OF_stdout);
	len = OF_getprop(stdout_node, "name", name, 20);
	name[len] = 0;
	printf("console out [%s]", name);
	cons_displaytype=1;
	cons_display_ofh = OF_stdout;
	err = OF_getprop(stdout_node, "width", &cons_width, 4);
	if ( err != 4) {
		cons_width = 0;
	}
	err = OF_getprop(stdout_node, "linebytes", &cons_linebytes, 4);
	if ( err != 4) {
		cons_linebytes = cons_width;
	}
	err = OF_getprop(stdout_node, "height", &cons_height, 4);
	if ( err != 4) {
		cons_height = 0;
	}
	err = OF_getprop(stdout_node, "depth", &cons_depth, 4);
	if ( err != 4) {
		cons_depth = 0;
	}
	err = OF_getprop(stdout_node, "address", &cons_addr, 4);
	if ( err != 4) {
		OF_interpret("frame-buffer-adr", 1, &cons_addr);
	}

	stdin_node = OF_instance_to_package(OF_stdin);
	len = OF_getprop(stdin_node, "name", iname, 20);
	iname[len] = 0;
	printf("console in [%s] ", iname);
	/* what to do about serial console? */
	if (strcmp ("keyboard", iname) == 0) {
		int node;
		struct usb_kbd_ihandles *ukbds;
		int akbd;
		char type[20];
		/* if there is a usb keyboard, we want it, do not 
		 * dereference the pointer that is returned
		 */
		if (OF_call_method("`usb-kbd-ihandles", OF_stdin, 0, 1, &ukbds)
			!= -1 && ukbds != NULL)
		{
			printf("USB");
			ukbd_cnattach();
			goto kbd_found;
		}
		if (OF_call_method("`adb-kbd-ihandle", OF_stdin, 0, 1, &akbd)
			!= -1 &&
		   akbd != 0 &&
		   OF_instance_to_package(akbd) != -1)
d347 3
a349 3
			printf("ADB");
			akbd_cnattach();
			goto kbd_found;
a350 4
		panic("no console keyboard");
kbd_found:
	}
	printf("\n");
d352 6
a357 12
	len = OF_getprop(stdout_node, "assigned-addresses", addr, sizeof(addr));
	if (len == -1) {
		int node;
		node = OF_parent(stdout_node);
		len = OF_getprop(node, "name", name, 20);
		name[len] = 0;

		printf("using parent %s:", name);
		len = OF_getprop(node, "assigned-addresses",
			addr, sizeof(addr));
		if (len < sizeof(addr[0])) {
			panic(": no address\n");
d360 1
a360 21
	memtag = ofw_make_tag(NULL, pcibus(addr[0].phys_hi),
		pcidev(addr[0].phys_hi),
		pcifunc(addr[0].phys_hi));
	iotag = ofw_make_tag(NULL, pcibus(addr[1].phys_hi),
		pcidev(addr[1].phys_hi),
		pcifunc(addr[1].phys_hi));

#if 1
	printf(": memaddr %x size %x, ", addr[0].phys_lo, addr[0].size_lo);
	printf(": consaddr %x, ", cons_addr);
	printf(": ioaddr %x, size %x", addr[1].phys_lo, addr[1].size_lo);
	printf(": memtag %x, iotag %x", memtag, iotag);
	printf(": cons_width %d cons_linebytes %d cons_height %d\n",
		cons_width, cons_linebytes, cons_height);
#endif

	{
		int i,j;

		cons_membus->bus_base = 0x80000000;
		cons_membus->bus_reverse = 1;
d362 3
a364 22
		err = bus_space_map( cons_membus, cons_addr, addr[0].size_lo,
			0, &cons_display_mem_h);
		printf("mem map err %x",err);
		bus_space_map( cons_membus, addr[1].phys_lo, addr[1].size_lo,
			0, &cons_display_ctl_h);
#endif

		vgafb_pci_console(cons_membus,
			addr[1].phys_lo, addr[1].size_lo,
			cons_membus, 
			cons_addr, addr[0].size_lo,
			&pa, pcibus(addr[1].phys_hi), pcidev(addr[1].phys_hi),
			pcifunc(addr[1].phys_hi));

#if 1
		for (i = 0; i < cons_linebytes * cons_height; i++) {
			bus_space_write_1(cons_membus,
				cons_display_mem_h, i, 0);

		}
#endif
	}
d366 4
@


1.12.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.12.2.2 2001/05/14 21:36:57 niklas Exp $	*/
a51 2
#include <dev/ofw/openfirm.h>

a52 6
#include <dev/usb/ukbdvar.h>
#include <powerpc/mac/akbdvar.h>

/* XXX, called from asm */
int save_ofw_mapping(void);
int restore_ofw_mapping(void);
d83 1
a83 1
	int phandle;
a127 1

d191 2
d195 1
a195 1
void ofw_do_pending_int(void);
d198 1
a198 1
void ofw_intr_init(void);
d256 1
d258 1
d272 1
a272 1
	if((ipending & SINT_CLOCK) && ((pcpl & imask[IPL_CLOCK]) == 0)) {
a287 1
#if 0
a322 1
#endif
a325 1
static pcitag_t ofw_make_tag( void *cpv, int bus, int dev, int fnc);
d327 2
a328 2
/* ARGSUSED */
static pcitag_t 
a335 2
#if 0
/* XXX */
a343 1
#endif
d384 1
d428 1
d431 1
d487 1
a487 1
		int i;
@


1.12.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.12.2.3 2001/07/04 10:23:00 niklas Exp $	*/
@


1.12.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.12.2.6
log
@repair
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.12.2.5 2001/11/13 21:04:16 niklas Exp $	*/
@


1.11
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.10 1999/07/05 20:56:26 rahnds Exp $	*/
a243 1
	struct intrhand *ih;
@


1.10
log
@Several changes here:
(Some of these changes are work in progress and may change more later)
locore.S:
        rearranged to remove most of the direct openfirmware references in
        the attempt to move all of the openfirmware pieces into ofw_ files.
        This could allow other firmware type to be supported easier. Also
        this keeps the openfirmware code grouped in the same files.

        OF_buf is now statically allocated in the data/bss section instead
        of allocated during initialization.

machdep.c:
        change the order of vm initialization, Still considering removing
        the BATs from use. instead of calls directly to ppc_exit and ppc_boot
        these are now called via a firmware function pointer structure.
        Add iMac recognition to systems
ofw_machdep.c:
        function pointer structure to allow different firmware to supply
        specific system functionality, normally startup and reset,
        including a hook to notify when bsd is about to go virtual,
        in case firmware calls need to act different after that time.

        Allow BSD to handle the virtual memory operations for openfirmware.
        this idea was copied from NetBSD macppc, It is not fully implemented,
        among other problems, openfirmware does not have a mechanism to
        add new mappings.

ofwreal.S:
        Major rewrite of the firmware call code, It still copies
        a portion of the stack, but now does not restore exeception vectors.
        Modified to be similar in idea to NetBSD macppc with BSD handling
        the openfirmware VM faults/TLB misses.
        This still needs to be reviewed, Should be possible to not require
        any stack copy.

opendev.c:
        OF_bus is not a pointer to the buffer, but is the buffer itself now.

openfirm.c:
        OF_bus is not a pointer to the buffer, but is the buffer itself now.
        Dont panic if OF_boot fails, OF_boot can be called by panic.
        instead print and the hang in a spin loop.

pmap.c:
        call the firmware function to get memory regions.
        Scale the PowerPC hash table size by size of real memory.
        Properly align the hash table based on the start, not just
        the size.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.9 1998/09/27 03:56:00 rahnds Exp $	*/
d169 1
a169 1
			pmap_enter(&ofw_pmap, va, pa, VM_PROT_ALL, 1);
@


1.9
log
@add wscons support to powerpc port.
This contains several pieces of the port
MI:
    vgafb, on powerpc under openfirmware the vga card comes up in gfx mode.
    instead of resetting it to text mode, vgafb treats this as a raster
    display. The mechanism used may not have been the best, it's
    interface to wscons is as a text display, and it does the character
    plotting itself.
    font_8x16.c was stolen from the atari port for use.

MD:
    ppcppi support stolen from alpha
    pms.c, pckbd.c and the rest of the support files were
    used nearly directly.

    powerpc
      conf.c to support wscon, vga/kbd
      machdep.c hack to get around a bus_space_set_region,bus_space_copy error.
      ofw_machdep.c some hack code on the road to supporting wscons as console.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.8 1998/09/20 22:11:48 rahnds Exp $	*/
d46 3
d54 12
d78 1
a78 1
mem_regions(memp, availp)
d98 5
d104 1
a104 1
ppc_exit()
d106 42
a147 1
	OF_exit();
d150 3
a152 3
void
ppc_boot(str)
	char *str;
d154 23
a176 1
	OF_boot(str);
a341 3
			}
			if (strcmp (name, "pci") == 0) {
				ofwenablepcimemio (name, qhandle);
@


1.8
log
@Changes to probe for address, and frequency for serial console.
This should enable the same kernel to work on VI machines as
well as MCG machines. Only remaining piece is the rtc.

For now an extra config file has been added to use serial for MCG
machines until all issues are resolved.  The various extra config
files and ramdisks should go away as soon as merger is finished.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.7 1998/09/09 04:48:16 rahnds Exp $	*/
d229 17
d259 3
@


1.7
log
@support for putting ofroot on mainbus, not on root.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.6 1998/06/28 04:35:17 rahnds Exp $	*/
d193 70
@


1.6
log
@Stability fix for powerpc openfirmware system.
Actually implement interrupt masking as appropriate for the
openfirmware drivers.

This problem was caused by the use of the X86 style of interrupt
handling introduced to the powerpc some time back. A problem may
still exist in the non-openfirmware drivers:
soft_net functions may get called when going from splhigh -> splclock
using splx when the soft functions should not be called.

Also look into SINT_CLOCK handling (where is this set).

Possibly real work can now be done...
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.5 1998/05/29 04:15:40 rahnds Exp $	*/
d115 8
@


1.5
log
@Major changes here and there, tweaks elsewhere.
Support for Openfirmware drivers was reintroduced so that more systems
were supported. This should work with the real driver configurations
as well.

Bootloader files were deleted/replaced with the newer versions in the
subdirectory. Some effort has been made to be closer to support booting
(at least the bootloader) on the Mac.

Config files that end with OFW are the openfirmware versions of the kernels
without have native drivers.

Native driver support has not been changed, presumably it still works.
I couldn't test that.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.4 1997/10/13 13:42:59 pefo Exp $	*/
d103 1
d117 1
d121 30
d168 1
d170 1
a170 1
	if(ipending & SINT_CLOCK) {
d174 1
a174 1
	if(ipending & SINT_NET) {
@


1.4
log
@Monolithic (No OpenFirmware driver crap...) PowerPC kernel. This is the
first release based on Wolfgang Solfrank, TooLs GmbH, work. Most OFW stuff
has been ripped out. Only a few functions for memory probing and halt/reboot
functionality has been kept. The kernel currently works with V.I's power.4e
PowerPC604 board, but more will come.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.3 1997/02/24 12:51:54 deraadt Exp $	*/
d47 1
d94 58
@


1.3
log
@for generic case, use dk_mountroot not special hacks
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.2 1996/12/28 06:22:09 rahnds Exp $	*/
d46 1
a46 5
#include <dev/ofw/openfirm.h>

#if defined(FFS) && defined(CD9660)
#include <ufs/ffs/fs.h>
#endif
d48 2
a49 1
#include <machine/powerpc.h>
a92 260
}

/*
 * Establish a list of all available disks to allow specifying the root/swap/dump dev.
 */
struct ofb_disk {
	LIST_ENTRY(ofb_disk) ofb_list;
	struct disk *ofb_dk;
	struct device *ofb_dev;
	int ofb_phandle;
	int ofb_unit;
};

static LIST_HEAD(ofb_list, ofb_disk) ofb_head;	/* LIST_INIT?		XXX */

void
dk_establish(dk, dev)
	struct disk *dk;
	struct device *dev;
{
	struct ofb_disk *od;
	struct ofb_softc *ofp = (void *)dev;

	MALLOC(od, struct ofb_disk *, sizeof *od, M_TEMP, M_NOWAIT);
	if (!od)
		panic("dk_establish");
	od->ofb_dk = dk;
	od->ofb_dev = dev;
	od->ofb_phandle = ofp->sc_phandle;
	if (dev->dv_class == DV_DISK)					/* XXX */
		od->ofb_unit = ofp->sc_unit;
	else
		od->ofb_unit = -1;
	LIST_INSERT_HEAD(&ofb_head, od, ofb_list);
}

/*
 * Cleanup the list.
 */
void
dk_cleanup()
{
	struct ofb_disk *od, *nd;

	for (od = ofb_head.lh_first; od; od = nd) {
		nd = od->ofb_list.le_next;
		LIST_REMOVE(od, ofb_list);
		FREE(od, M_TEMP);
	}
}

#if defined(FFS) && defined(CD9660)
static int
dk_match_ffs()
{
	int error;
	struct partinfo dpart;
	int bsize = DEV_BSIZE;
	int secpercyl = 1;
	struct buf *bp;
	struct fs *fs;

	if (bdevsw[major(rootdev)].d_ioctl(rootdev, DIOCGPART, (caddr_t)&dpart, FREAD, 0) == 0
	    && dpart.disklab->d_secsize != 0) {
		bsize = dpart.disklab->d_secsize;
		secpercyl = dpart.disklab->d_secpercyl;
	}

	bp = geteblk(SBSIZE);
	bp->b_dev = rootdev;

	/* Try to read the superblock */
	bp->b_blkno = SBOFF / bsize;
	bp->b_bcount = SBSIZE;
	bp->b_flags = B_BUSY | B_READ;
	bp->b_cylinder = bp->b_blkno / (bsize / DEV_BSIZE) / secpercyl;
	bdevsw[major(rootdev)].d_strategy(bp);

	if (error = biowait(bp))
		goto done;

	fs = (struct fs *)bp->b_data;
	if (fs->fs_magic != FS_MAGIC || fs->fs_bsize > MAXBSIZE
	    || fs->fs_bsize < sizeof(struct fs))
		error = EIO;
done:
	brelse(bp);
	return error;
}
#endif

/* These should probably be somewhere else!				XXX */
extern char *nfsbootdevname;

static void
dk_setroot(od, part)
	struct ofb_disk *od;
	int part;
{
	char type[8];
	int maj, min;
	struct partinfo dpart;
	char *cp;

	if (OF_getprop(od->ofb_phandle, "device_type", type, sizeof type) < 0)
		panic("OF_getproperty");
#if defined(FFS) || defined(CD9660)
	if (!strcmp(type, "block")) {
		for (maj = 0; maj < nblkdev; maj++) {
			if (bdevsw[maj].d_strategy == od->ofb_dk->dk_driver->d_strategy)
				break;
		}
		if (maj >= nblkdev)
			panic("dk_setroot");

		/*
		 * Find the unit.
		 */
		min = 0;
		for (cp = od->ofb_dk->dk_name; *cp; cp++) {
			if (*cp >= '0' && *cp <= '9')
				min = min * 10 + *cp - '0';
			else
				/* Start anew */
				min = 0;
		}

		if (part == -1) {
			/* Try to open partition 'a' first */
			rootdev = makedev(maj, min * MAXPARTITIONS);

			if (bdevsw[maj].d_open(rootdev, FREAD, S_IFBLK, 0) < 0)
				panic("dk_setroot");
			dpart.part = 0;
			bdevsw[major(rootdev)].d_ioctl(rootdev, DIOCGPART,
						       (caddr_t)&dpart, FREAD, 0);
			bdevsw[maj].d_close(rootdev, FREAD, S_IFBLK, 0);
			if (!dpart.part || dpart.part->p_size <= 0) {
				/* Now we use the whole disk */
				rootdev = makedev(maj, min * MAXPARTITIONS + RAW_PART);
			}
		} else
			rootdev = makedev(maj, min * MAXPARTITIONS + part);

		mountroot = dk_mountroot;
		/*
		 * Now setup the swap/dump device
		 */
		dumpdev = makedev(major(rootdev), min * MAXPARTITIONS + 1);
		swdevt[0].sw_dev = dumpdev;
		swdevt[1].sw_dev = NODEV;

		return;
	}
#endif	/* defined(FFS) || defined(CD9660) */
#ifdef	NFSCLIENT
	if (!strcmp(type, "network")) {
		mountroot = nfs_mountroot;
		nfsbootdevname = od->ofb_dev->dv_xname;
		rootdev = NODEV;
		dumpdev = NODEV;
		swdevt[0].sw_dev = NODEV;
		return;
	}
#endif
	panic("Where were we booted from?");
}

/*
 * Try to find a disk with the given name.
 * This allows either the OpenFirmware device name,
 * or the NetBSD device name, both with optional trailing partition.
 */
int
dk_match(name)
	char *name;
{
	struct ofb_disk *od;
	char *cp;
	int phandle;
	int part, unit;
	int l;

	for (od = ofb_head.lh_first; od; od = od->ofb_list.le_next) {
		/*
		 * First try the NetBSD name.
		 */
		l = strlen(od->ofb_dev->dv_xname);
		if (!bcmp(name, od->ofb_dev->dv_xname, l)) {
			if (!name[l]) {
				/* Default partition, (or none at all) */
				dk_setroot(od, -1);
				return 0;
			}
			if (!name[l + 1]) {
				switch (name[l]) {
				case '*':
					/* Default partition */
					dk_setroot(od, -1);
					return 0;
				default:
					if (name[l] >= 'a'
					    && name[l] < 'a' + MAXPARTITIONS) {
						/* specified partition */
						dk_setroot(od, name[l] - 'a');
						return 0;
					}
					break;
				}
			}
		}
	}
	/*
	 * Now try the OpenFirmware name
	 */
	l = strlen(name);
	for (cp = name + l; --cp >= name;)
		if (*cp == '/' || *cp == ':')
			break;
	if (cp >= name && *cp == ':')
		*cp++ = 0;
	else
		cp = name + l;
	part = *cp >= 'a' && *cp < 'a' + MAXPARTITIONS
		? *cp - 'a'
		: -1;
	while (--cp >= name && *cp != '@@');
	if (cp - 4 < name || bcmp(cp - 4, "disk", 4))
		unit = -1;
	else {
		for (unit = 0; *++cp >= '0' && *cp <= '9';)
			unit = unit * 10 + *cp - '0';
	}

	if ((phandle = OF_finddevice(name)) != -1) {
		for (od = ofb_head.lh_first; od; od = od->ofb_list.le_next) {
			if (phandle == od->ofb_phandle) {
				/* Check for matching units */
				if (od->ofb_dk
				    && od->ofb_unit != unit)
					continue;
				dk_setroot(od, part);
				return 0;
			}
		}
	}
	return ENODEV;
}

void
ofrootfound()
{
	int node;
	struct ofprobe probe;

	if (!(node = OF_peer(0)))
		panic("No PROM root");
	probe.phandle = node;
	if (!config_rootfound("ofroot", &probe))
		panic("ofroot not configured");
@


1.2
log
@Adding OpenBSD tags to files.
@
text
@d1 1
a1 1
/*	$OpenBSD:$	*/
a187 2
extern int ffs_mountroot __P((void));
extern int cd9660_mountroot __P((void));
a188 3
extern int nfs_mountroot __P((void));

extern int (*mountroot) __P((void));
a238 18
#if defined(FFS) && defined(CD9660)
		/*
		 * Find out whether to use ffs or cd9660.
		 */
		if (bdevsw[maj].d_open(rootdev, FREAD, S_IFBLK, 0) < 0)
			panic("dk_setroot");
		if (!dk_match_ffs())
			mountroot = ffs_mountroot;
		else							/* XXX */
			mountroot = cd9660_mountroot;
		bdevsw[maj].d_close(rootdev, FREAD, S_IFBLK, 0);
#elif defined(FFS)
		mountroot = ffs_mountroot;
#elif defined(CD9660)
		mountroot = cd9660_mountroot;
#else				/* Cannot occur */
		panic("dk_setroot: No disk filesystem");
#endif
d240 1
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@Check-in of powerpc kernel support.
NOTE: This will not work until the other pieces are checked in.
This is primarily the NetBSD powerpc port, with modifications
to support ELF. 
@
text
@@
