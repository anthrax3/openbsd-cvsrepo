head	1.13;
access;
symbols
	OPENBSD_6_0:1.13.0.36
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.32
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.34
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.26
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.30
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.28
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.24
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.22
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.20
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.18
	OPENBSD_5_0:1.13.0.16
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.14
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.12
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.8
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.10
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.6
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.7
	UBC:1.4.0.4
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.14
	OPENBSD_2_8:1.3.0.12
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.10
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.8
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.6
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	powerpc_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2007.09.09.20.49.18;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2007.03.20.20.59.53;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.15.21.02.44;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.09.14.52.12;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2005.06.20.20.02.04;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.15.02.43.09;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.15.09.01.59;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.15.02.02.44;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.00.42.24;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.09.01.11.09;	author mickey;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	98.08.07.02.22.08;	author rahnds;	state Exp;
branches
	1.3.8.1;
next	1.2;

1.2
date	96.12.28.06.22.16;	author rahnds;	state Exp;
branches;
next	1.1;

1.1
date	96.12.21.20.35.58;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.12.21.20.35.58;	author rahnds;	state Exp;
branches;
next	;

1.3.8.1
date	2001.10.31.03.07.56;	author nate;	state Exp;
branches;
next	1.3.8.2;

1.3.8.2
date	2001.11.13.22.14.34;	author niklas;	state dead;
branches;
next	1.3.8.3;

1.3.8.3
date	2002.03.29.19.46.01;	author niklas;	state Exp;
branches;
next	1.3.8.4;

1.3.8.4
date	2004.02.19.10.49.57;	author niklas;	state Exp;
branches;
next	;

1.4.4.1
date	2002.06.11.03.37.28;	author art;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2002.10.29.00.28.09;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Make sure ptrace(2) cannot change any priviliged bits in the Machine State
Register.  Fixes PR 5574.  From Stefan Kempf.

ok deraadt@@
@
text
@/*	$OpenBSD: process_machdep.c,v 1.12 2007/03/20 20:59:53 kettenis Exp $	*/
/*	$NetBSD: process_machdep.c,v 1.1 1996/09/30 16:34:53 ws Exp $	*/

/*
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/ptrace.h>
#include <sys/user.h>

#include <machine/fpu.h>
#include <machine/pcb.h>
#include <machine/psl.h>
#include <machine/reg.h>

int
process_read_regs(struct proc *p, struct reg *regs)
{
	struct cpu_info *ci = curcpu();
	struct trapframe *tf = trapframe(p);
	struct pcb *pcb = &p->p_addr->u_pcb;

	bcopy(tf->fixreg, regs->gpr, sizeof(regs->gpr));

	if (!(pcb->pcb_flags & PCB_FPU)) {
		bzero(regs->fpr, sizeof(regs->fpr));
	} else {
		/* XXX What if the state is on the other cpu? */
		if (p == ci->ci_fpuproc)
			save_fpu();
		bcopy(pcb->pcb_fpu.fpr, regs->fpr, sizeof(regs->fpr));
	}

	regs->pc  = tf->srr0;
	regs->ps  = tf->srr1; /* is this the correct value for this ? */
	regs->cnd = tf->cr;
	regs->lr  = tf->lr;
	regs->cnt = tf->ctr;
	regs->xer = tf->xer;
	regs->mq  = 0; /*  what should this really be? */

	return (0);
}

int
process_read_fpregs(struct proc *p, struct fpreg *regs)
{
	struct cpu_info *ci = curcpu();
	struct pcb *pcb = &p->p_addr->u_pcb;

	if (!(pcb->pcb_flags & PCB_FPU)) {
		bzero(regs->fpr, sizeof(regs->fpr));
		regs->fpscr = 0;
	} else {
		/* XXX What if the state is on the other cpu? */
		if (p == ci->ci_fpuproc)
			save_fpu();
		bcopy(pcb->pcb_fpu.fpr, regs->fpr, sizeof(regs->fpr));
		regs->fpscr = *(u_int64_t *)&pcb->pcb_fpu.fpcsr;
	}

	return (0);
}

#ifdef PTRACE

/*
 * Set the process's program counter.
 */
int
process_set_pc(struct proc *p, caddr_t addr)
{
	struct trapframe *tf = trapframe(p);
	
	tf->srr0 = (u_int32_t)addr;
	return 0;
}

int
process_sstep(struct proc *p, int sstep)
{
	struct trapframe *tf = trapframe(p);
	
	if (sstep)
		tf->srr1 |= PSL_SE;
	else
		tf->srr1 &= ~PSL_SE;
	return 0;
}

int
process_write_regs(struct proc *p, struct reg *regs)
{
	struct cpu_info *ci = curcpu();
	struct trapframe *tf = trapframe(p);
	struct pcb *pcb = &p->p_addr->u_pcb;

	if ((regs->ps ^ tf->srr1) & PSL_USERSTATIC)
		return EINVAL;

	bcopy(regs->gpr, tf->fixreg, sizeof(regs->gpr));

	/* XXX What if the state is on the other cpu? */
	if (p == ci->ci_fpuproc) {	/* release the fpu */
		save_fpu();
		ci->ci_fpuproc = NULL;
	}

	bcopy(regs->fpr, pcb->pcb_fpu.fpr, sizeof(regs->fpr));
	if (!(pcb->pcb_flags & PCB_FPU)) {
		pcb->pcb_fpu.fpcsr = 0;
		pcb->pcb_flags |= PCB_FPU;
	}

	tf->srr0 = regs->pc;
	tf->srr1 = regs->ps;  /* is this the correct value for this ? */
	tf->cr   = regs->cnd;
	tf->lr   = regs->lr;
	tf->ctr  = regs->cnt;
	tf->xer  = regs->xer;
	/*  regs->mq = 0; what should this really be? */

	return (0);
}

int
process_write_fpregs(struct proc *p, struct fpreg *regs)
{
	struct cpu_info *ci = curcpu();
	struct pcb *pcb = &p->p_addr->u_pcb;
	u_int64_t fpscr = regs->fpscr;

	/* XXX What if the state is on the other cpu? */
	if (p == ci->ci_fpuproc) {	/* release the fpu */
		save_fpu();
		ci->ci_fpuproc = NULL;
	}

	bcopy(regs->fpr, pcb->pcb_fpu.fpr, sizeof(regs->fpr));
	pcb->pcb_fpu.fpcsr = *(double *)&fpscr;
	pcb->pcb_flags |= PCB_FPU;

	return (0);
}

#endif	/* PTRACE */
@


1.12
log
@Move macppc to __HAVE_CPUINFO, and make locore.S and trap.c suitable for
MULTIPROCESSOR.  From now on sprg0 holds a pointer to struct cpuinfo, which
is used to spill registers to during trap instead of the globals we used to
use for that purpose.  Bits and pieces from NetBSD.  Help from drahn@@ and art@@.
Tested by xsa@@, thib@@, miod@@, gwk@@, deraadt@@.

ok drahn@@, gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.11 2006/05/15 21:02:44 kettenis Exp $	*/
d126 3
@


1.11
log
@Implement PT_{GET|SET}FPREGS.
"looks good to me" miod@@, ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.10 2005/10/09 14:52:12 drahn Exp $	*/
d48 1
d57 2
a58 1
		if (p == fpuproc)
d77 1
d84 2
a85 1
		if (p == fpuproc)
d123 1
d129 2
a130 1
	if (p == fpuproc) {	/* release the fpu */
d132 1
a132 1
		fpuproc = NULL;
d155 1
d159 2
a160 1
	if (p == fpuproc) {	/* release the fpu */
d162 1
a162 1
		fpuproc = NULL;
@


1.10
log
@Subtle changes to the powerpc fpu handling, basically fpuproc is handled
in a non-raceable manner inside save_fpu and enable_fpu so that the
eventual SMP case will not grab a half loaded fpu context.
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.9 2005/06/20 20:02:04 kettenis Exp $	*/
d72 18
d142 18
@


1.9
log
@Handle floating-point registers.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.8 2003/10/15 02:43:09 drahn Exp $	*/
d57 1
a57 1
			save_fpu(fpuproc);
d107 1
a107 1
		save_fpu(fpuproc);
@


1.8
log
@Sometimes KNF is not a destination, but a journey. Also ANSI.
Binaries unchanged.
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.7 2002/09/15 09:01:59 deraadt Exp $	*/
d38 5
d49 11
a60 5
	bcopy(&(tf->fixreg[0]), &(regs->gpr[0]), sizeof(regs->gpr));
	bzero(&(regs->fpr[0]), sizeof(regs->fpr));
	/* 
	 * need to do floating point here
	 */
d102 14
a116 4
	bcopy(&(regs->gpr[0]), &(tf->fixreg[0]), sizeof(regs->gpr));
	/* 
	 * need to do floating point here
	 */
@


1.7
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.5 2002/03/14 00:42:24 miod Exp $	*/
d41 1
a41 3
process_read_regs(p, regs)
	struct proc *p;
	struct reg *regs;
d67 1
a67 3
process_set_pc(p, addr)
	struct proc *p;
	caddr_t addr;
d71 1
a71 1
	tf->srr0 = (int)addr;
d76 1
a76 3
process_sstep(p, sstep)
	struct proc *p;
	int sstep;
d88 1
a88 3
process_write_regs(p, regs)
	struct proc *p;
	struct reg *regs;
@


1.6
log
@KNF
@
text
@d49 1
a49 1
	/*
d74 1
a74 1

d85 1
a85 1

d101 1
a101 1
	/*
@


1.5
log
@Turn the ptrace(2) syscall into a kernel compile option, option PTRACE in
your kernel configuration file.
By default, GENERIC will enable this.

When PTRACE is not enabled, several ptrace-like features of the procfs
filesystem will be disabled as well (namely, the ability to read and write
any process' registers, as well as attching, single stepping and detaching
to/from processes).

This should help paranoid people build better sandboxens, and us to build
smaller ramdisks.
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.4 2001/07/09 01:11:09 mickey Exp $	*/
d49 1
a49 1
	/* 
d74 1
a74 1
	
d85 1
a85 1
	
d101 1
a101 1
	/* 
@


1.4
log
@missing includes
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.3 1998/08/07 02:22:08 rahnds Exp $	*/
d40 25
a91 6
int
process_read_regs(p, regs)
	struct proc *p;
	struct reg *regs;
{
	struct trapframe *tf = trapframe(p);
a92 15
	bcopy(&(tf->fixreg[0]), &(regs->gpr[0]), sizeof(regs->gpr));
	bzero(&(regs->fpr[0]), sizeof(regs->fpr));
	/* 
	 * need to do floating point here
	 */
	regs->pc  = tf->srr0;
	regs->ps  = tf->srr1; /* is this the correct value for this ? */
	regs->cnd = tf->cr;
	regs->lr  = tf->lr;
	regs->cnt = tf->ctr;
	regs->xer = tf->xer;
	regs->mq  = 0; /*  what should this really be? */

	return (0);
}
d114 2
@


1.4.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.4 2001/07/09 01:11:09 mickey Exp $	*/
a39 25
int
process_read_regs(p, regs)
	struct proc *p;
	struct reg *regs;
{
	struct trapframe *tf = trapframe(p);

	bcopy(&(tf->fixreg[0]), &(regs->gpr[0]), sizeof(regs->gpr));
	bzero(&(regs->fpr[0]), sizeof(regs->fpr));
	/* 
	 * need to do floating point here
	 */
	regs->pc  = tf->srr0;
	regs->ps  = tf->srr1; /* is this the correct value for this ? */
	regs->cnd = tf->cr;
	regs->lr  = tf->lr;
	regs->cnt = tf->ctr;
	regs->xer = tf->xer;
	regs->mq  = 0; /*  what should this really be? */

	return (0);
}

#ifdef PTRACE

d67 6
d74 15
a109 2

#endif	/* PTRACE */
@


1.4.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.4.4.1 2002/06/11 03:37:28 art Exp $	*/
@


1.3
log
@Add kernel support for debugging with gdb. This also make /proc allow
access to the registers. The format of the registers returned in ptrace,
/proc and in the coredump header match what gdb was expecting.
Floating point registers are not yet copied into the structure.
The location of the fpr needs to be found and copied. <- TODO

Changes to trap.c was to add some interm debugging. code is commented out.

powerpc does not currently have a MID_* type, since it uses ELF instead
of a.out, one was never added. Currently the coredump is done in form
of MID_NONE. What is the correct approach for this?? Elf format coredumps...
maybe?
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.2 1996/12/28 06:22:16 rahnds Exp $	*/
d35 1
d37 1
@


1.3.8.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.3 1998/08/07 02:22:08 rahnds Exp $	*/
a34 1
#include <sys/systm.h>
a35 1
#include <sys/ptrace.h>
@


1.3.8.2
log
@repair
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.3.8.1 2001/10/31 03:07:56 nate Exp $	*/
@


1.3.8.3
log
@Re-add missing pieces
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.5 2002/03/14 00:42:24 miod Exp $	*/
a39 25
int
process_read_regs(p, regs)
	struct proc *p;
	struct reg *regs;
{
	struct trapframe *tf = trapframe(p);

	bcopy(&(tf->fixreg[0]), &(regs->gpr[0]), sizeof(regs->gpr));
	bzero(&(regs->fpr[0]), sizeof(regs->fpr));
	/* 
	 * need to do floating point here
	 */
	regs->pc  = tf->srr0;
	regs->ps  = tf->srr1; /* is this the correct value for this ? */
	regs->cnd = tf->cr;
	regs->lr  = tf->lr;
	regs->cnt = tf->ctr;
	regs->xer = tf->xer;
	regs->mq  = 0; /*  what should this really be? */

	return (0);
}

#ifdef PTRACE

d67 6
d74 15
a109 2

#endif	/* PTRACE */
@


1.3.8.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 3
a43 1
process_read_regs(struct proc *p, struct reg *regs)
d69 3
a71 1
process_set_pc(struct proc *p, caddr_t addr)
d75 1
a75 1
	tf->srr0 = (u_int32_t)addr;
d80 3
a82 1
process_sstep(struct proc *p, int sstep)
d94 3
a96 1
process_write_regs(struct proc *p, struct reg *regs)
@


1.2
log
@Adding OpenBSD tags to files.
@
text
@d1 1
a1 1
/*	$OpenBSD:$	*/
d36 1
d64 43
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@Check-in of powerpc kernel support.
NOTE: This will not work until the other pieces are checked in.
This is primarily the NetBSD powerpc port, with modifications
to support ELF. 
@
text
@@
