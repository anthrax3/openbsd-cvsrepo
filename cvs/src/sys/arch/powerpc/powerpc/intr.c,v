head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.6
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.8
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.4
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.14
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.12
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.8
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.6
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.4
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.10
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.8
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.6
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	OPENBSD_4_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.9
date	2015.09.13.14.06.40;	author kettenis;	state Exp;
branches;
next	1.8;
commitid	nd1GrmzGVu0nRnyw;

1.8
date	2015.01.04.13.01.42;	author mpi;	state Exp;
branches;
next	1.7;
commitid	NhpbICTczAMSUxav;

1.7
date	2011.08.29.20.21.44;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.09.01.12.38;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.02.21.38.10;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.21.17.35.52;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2008.09.18.03.56.25;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2007.11.14.20.47.34;	author thib;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.14.20.33.32;	author thib;	state Exp;
branches;
next	;


desc
@@


1.9
log
@intr_barrier(9) for macppc and socppc.
@
text
@/*	$OpenBSD: intr.c,v 1.8 2015/01/04 13:01:42 mpi Exp $	*/

/*
 * Copyright (c) 1997 Per Fogelstrom, Opsycon AB and RTMX Inc, USA.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Per Fogelstrom, Opsycon AB, Sweden for RTMX Inc, North Carolina USA.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
#include <sys/param.h>

#include <machine/cpu.h>
#include <machine/intr.h>

int ppc_dflt_splraise(int);
int ppc_dflt_spllower(int);
void ppc_dflt_splx(int);

/* provide a function for asm code to call */
#undef splraise
#undef spllower
#undef splx

int ppc_smask[IPL_NUM];

void
ppc_smask_init()
{
        int i;

        for (i = IPL_NONE; i <= IPL_HIGH; i++)  {
                ppc_smask[i] = 0;
                if (i < IPL_SOFTCLOCK)
                        ppc_smask[i] |= SI_TO_IRQBIT(SI_SOFTCLOCK);
                if (i < IPL_SOFTNET)
                        ppc_smask[i] |= SI_TO_IRQBIT(SI_SOFTNET);
                if (i < IPL_SOFTTTY)
                        ppc_smask[i] |= SI_TO_IRQBIT(SI_SOFTTTY);
        }
}

int
splraise(int newcpl)
{
	return ppc_intr_func.raise(newcpl);
}

int
spllower(int newcpl)
{
	return ppc_intr_func.lower(newcpl);
}

void
splx(int newcpl)
{
	ppc_intr_func.x(newcpl);
}

/*
 * functions with 'default' behavior to use before the real
 * interrupt controller attaches
 */

int
ppc_dflt_splraise(int newcpl)
{
        struct cpu_info *ci = curcpu();
        int oldcpl;

        oldcpl = ci->ci_cpl;
        if (newcpl < oldcpl)
                newcpl = oldcpl;
        ci->ci_cpl = newcpl;

        return (oldcpl);
}

int
ppc_dflt_spllower(int newcpl)
{
        struct cpu_info *ci = curcpu();
        int oldcpl;

        oldcpl = ci->ci_cpl;

        splx(newcpl);

        return (oldcpl);
}

void
ppc_dflt_splx(int newcpl)
{
        struct cpu_info *ci = curcpu();

        ci->ci_cpl = newcpl;

        if (ci->ci_ipending & ppc_smask[newcpl])
		dosoftint(newcpl);
}

struct ppc_intr_func ppc_intr_func =
{
        ppc_dflt_splraise,
	ppc_dflt_spllower,
	ppc_dflt_splx
};

char *
ppc_intr_typename(int type)
{
	switch (type) {
	case IST_NONE :
		return ("none");
	case IST_PULSE:
		return ("pulsed");
	case IST_EDGE:
		return ("edge-triggered");
	case IST_LEVEL:
		return ("level-triggered");
	default:
		return ("unknown");
	}
}

void
intr_barrier(void *ih)
{
	sched_barrier(NULL);
}

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	struct cpu_info *ci = curcpu();

	if (ci->ci_cpl < wantipl)
		splassert_fail(wantipl, ci->ci_cpl, func);

	if (wantipl == IPL_NONE && ci->ci_intrdepth != -1)
		splassert_fail(-1, ci->ci_intrdepth, func);
}
#endif
@


1.8
log
@Implement splassert(9) for powerpc.

This changes the logic to prevent a recursion when processing soft
interrupts.  Previously a per-CPU flag was set before re-enabling
interrupts.  Now the IPL level is raised to SOFTTTY which makes
splsoftassert() happy, greatly inspired by mips64.

As a side effect, the ppc_intr_{disable,enable}() dance is now done
only once instead of twice per splx(9).

While here, make use of dosoftint() instead of having 3 different
functions for dispatching soft interrupts.

Tested by deraadt@@ on G4 smp and by myself G5 smp, G3, G4 and socppc.

No objection from the usual (and over busy) suspects.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.7 2011/08/29 20:21:44 drahn Exp $	*/
d149 6
@


1.7
log
@Return of the long missing powerpc interrupt rewrite.  Was working for
several weeks before release on macppc, socppc bugs just fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.6 2009/06/09 01:12:38 deraadt Exp $	*/
d124 1
a124 1
		do_pending_int();
d150 14
@


1.6
log
@backout interrupt diff until it the next round of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.4 2008/11/21 17:35:52 deraadt Exp $	*/
d39 27
d69 14
a82 2
	struct cpu_info *ci = curcpu();
	int oldcpl;
d84 4
a87 4
	__asm__ volatile("":::"memory");	/* reorder protect */
	oldcpl = ci->ci_cpl;
	ci->ci_cpl = oldcpl | newcpl;
	__asm__ volatile("":::"memory");
d89 12
a100 1
	return (oldcpl);
d104 1
a104 1
spllower(int newcpl)
d106 4
a109 2
	struct cpu_info *ci = curcpu();
	int oldcpl;
d111 1
a111 6
	__asm__ volatile("":::"memory");	/* reorder protect */
	oldcpl = ci->ci_cpl;
	ci->ci_cpl = newcpl;
	if (ci->ci_ipending & ~newcpl)
		do_pending_int();
	__asm__ volatile("":::"memory");
d113 1
a113 1
	return (oldcpl);
d117 1
a117 1
splx(int newcpl)
d119 1
a119 1
	struct cpu_info *ci = curcpu();
d121 3
a123 3
	__asm__ volatile("":::"memory");	/* reorder protect */
	ci->ci_cpl = newcpl;
	if (ci->ci_ipending & ~newcpl)
d125 24
a148 1
	__asm__ volatile("":::"memory");
@


1.5
log
@Reintroduce the macppc interrupt subsystem rewrite. Several bugs have
been found and corrected.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.3 2008/09/18 03:56:25 drahn Exp $	*/
a37 34
#include <machine/lock.h>

int ppc_dflt_splraise(int);
int ppc_dflt_spllower(int);
void ppc_dflt_splx(int);

/* provide a function for asm code to call */
#undef splraise
#undef spllower
#undef splx

int ppc_smask[IPL_NUM];

void
ppc_smask_init()
{
	int i;

        for (i = IPL_NONE; i <= IPL_HIGH; i++)  {
                ppc_smask[i] = 0;
#if 0
	/* NOT YET */
                if (i < IPL_SOFT)
                        ppc_smask[i] |= SI_TO_IRQBIT(SI_SOFT);
#endif
                if (i < IPL_SOFTCLOCK)
                        ppc_smask[i] |= SI_TO_IRQBIT(SI_SOFTCLOCK);
                if (i < IPL_SOFTNET)
                        ppc_smask[i] |= SI_TO_IRQBIT(SI_SOFTNET);
                if (i < IPL_SOFTTTY)
                        ppc_smask[i] |= SI_TO_IRQBIT(SI_SOFTTTY);
        }
}

a41 22
	return ppc_intr_func.raise(newcpl);
}

int
spllower(int newcpl)
{
	return ppc_intr_func.lower(newcpl);
}

void
splx(int newcpl)
{
	ppc_intr_func.x(newcpl);
}

/*
 * functions with 'default' behavior to use before the real
 * interrupt controller attaches
 */
int
ppc_dflt_splraise(int newcpl)
{
d45 1
d47 2
a48 3
	if (newcpl < oldcpl)
		newcpl = oldcpl;
	ci->ci_cpl = newcpl;
d54 1
a54 1
ppc_dflt_spllower(int newcpl)
d59 1
d61 4
a64 2

	splx(newcpl);
d70 1
a70 1
ppc_dflt_splx(int newcpl)
d74 1
d76 1
a76 2

	if (ci->ci_ipending & ppc_smask[newcpl])
d78 1
a78 24
}

struct ppc_intr_func ppc_intr_func =
{
	ppc_dflt_splraise,
	ppc_dflt_spllower,
	ppc_dflt_splx
};

char *
ppc_intr_typename(int type)
{
	switch (type) {
        case IST_NONE :
		return ("none");
        case IST_PULSE:
		return ("pulsed");
        case IST_EDGE:
		return ("edge-triggered");
        case IST_LEVEL:
		return ("level-triggered");
	default:
		return ("unknown");
	}
@


1.4
log
@back out the new interrupt subsystem because some little bug still lurks in there
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.2 2007/11/14 20:47:34 thib Exp $	*/
d38 34
d76 22
a100 1
	__asm__ volatile("":::"memory");	/* reorder protect */
d102 3
a104 2
	ci->ci_cpl = oldcpl | newcpl;
	__asm__ volatile("":::"memory");
d110 1
a110 1
spllower(int newcpl)
a114 1
	__asm__ volatile("":::"memory");	/* reorder protect */
d116 2
a117 4
	ci->ci_cpl = newcpl;
	if (ci->ci_ipending & ~newcpl)
		do_pending_int();
	__asm__ volatile("":::"memory");
d123 1
a123 1
splx(int newcpl)
a126 1
	__asm__ volatile("":::"memory");	/* reorder protect */
d128 2
a129 1
	if (ci->ci_ipending & ~newcpl)
d131 24
a154 1
	__asm__ volatile("":::"memory");
@


1.3
log
@Redesign of the powerpc interrupt architecture, use true levels intead of
blocking specific interrupts. Needs signficant testing to prove that
one remaining elusive bug has been squashed.
@
text
@a37 34
#include <machine/lock.h>

int ppc_dflt_splraise(int);
int ppc_dflt_spllower(int);
void ppc_dflt_splx(int);

/* provide a function for asm code to call */
#undef splraise
#undef spllower
#undef splx

int ppc_smask[IPL_NUM];

void
ppc_smask_init()
{
	int i;

        for (i = IPL_NONE; i <= IPL_HIGH; i++)  {
                ppc_smask[i] = 0;
#if 0
	/* NOT YET */
                if (i < IPL_SOFT)
                        ppc_smask[i] |= SI_TO_IRQBIT(SI_SOFT);
#endif
                if (i < IPL_SOFTCLOCK)
                        ppc_smask[i] |= SI_TO_IRQBIT(SI_SOFTCLOCK);
                if (i < IPL_SOFTNET)
                        ppc_smask[i] |= SI_TO_IRQBIT(SI_SOFTNET);
                if (i < IPL_SOFTTTY)
                        ppc_smask[i] |= SI_TO_IRQBIT(SI_SOFTTTY);
        }
}

a41 18
	return ppc_intr_func.raise(newcpl);
}

int
spllower(int newcpl)
{
	return ppc_intr_func.lower(newcpl);
}

void
splx(int newcpl)
{
	ppc_intr_func.x(newcpl);
}

int
ppc_dflt_splraise(int newcpl)
{
d45 1
d47 2
a48 3
	if (newcpl < oldcpl)
		newcpl = oldcpl;
	ci->ci_cpl = newcpl;
a52 4
/*
 * functions with 'default' behavior to use before the real
 * interrupt controller attaches
 */
d54 1
a54 1
ppc_dflt_spllower(int newcpl)
d59 1
d61 4
a64 2

	splx(newcpl);
d70 1
a70 1
ppc_dflt_splx(int newcpl)
d74 1
d76 1
a76 2

	if (ci->ci_ipending & ppc_smask[newcpl])
d78 1
a78 24
}

struct ppc_intr_func ppc_intr_func =
{
	ppc_dflt_splraise,
	ppc_dflt_spllower,
	ppc_dflt_splx
};

char *
ppc_intr_typename(int type)
{
	switch (type) {
        case IST_NONE :
		return ("none");
        case IST_PULSE:
		return ("pulsed");
        case IST_EDGE:
		return ("edge-triggered");
        case IST_LEVEL:
		return ("level-triggered");
	default:
		return ("unknown");
	}
@


1.2
log
@prettify the RCS id (less whitespace)
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.1 2007/11/14 20:33:32 thib Exp $	*/
d38 34
d76 18
a96 1
	__asm__ volatile("":::"memory");	/* reorder protect */
d98 3
a100 2
	ci->ci_cpl = oldcpl | newcpl;
	__asm__ volatile("":::"memory");
d105 4
d110 1
a110 1
spllower(int newcpl)
a114 1
	__asm__ volatile("":::"memory");	/* reorder protect */
d116 2
a117 4
	ci->ci_cpl = newcpl;
	if (ci->ci_ipending & ~newcpl)
		do_pending_int();
	__asm__ volatile("":::"memory");
d123 1
a123 1
splx(int newcpl)
a126 1
	__asm__ volatile("":::"memory");	/* reorder protect */
d128 2
a129 1
	if (ci->ci_ipending & ~newcpl)
d131 24
a154 1
	__asm__ volatile("":::"memory");
@


1.1
log
@Turn the spl* macros into functions.
Shaves a few bytes of the kernel.
No measurable performance loss.

ok drahn@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$							*/
@

