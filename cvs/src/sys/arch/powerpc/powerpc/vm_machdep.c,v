head	1.49;
access;
symbols
	OPENBSD_6_2:1.49.0.6
	OPENBSD_6_2_BASE:1.49
	OPENBSD_6_1:1.49.0.4
	OPENBSD_6_1_BASE:1.49
	OPENBSD_6_0:1.48.0.6
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.48.0.2
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.48.0.4
	OPENBSD_5_8_BASE:1.48
	OPENBSD_5_7:1.47.0.2
	OPENBSD_5_7_BASE:1.47
	OPENBSD_5_6:1.46.0.10
	OPENBSD_5_6_BASE:1.46
	OPENBSD_5_5:1.46.0.8
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.46.0.4
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.46.0.2
	OPENBSD_5_3_BASE:1.46
	OPENBSD_5_2:1.45.0.20
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.18
	OPENBSD_5_0:1.45.0.16
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.45.0.14
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.45.0.12
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.45.0.8
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.45.0.10
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.45.0.6
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.45.0.4
	OPENBSD_4_4_BASE:1.45
	OPENBSD_4_3:1.45.0.2
	OPENBSD_4_3_BASE:1.45
	OPENBSD_4_2:1.44.0.2
	OPENBSD_4_2_BASE:1.44
	OPENBSD_4_1:1.41.0.2
	OPENBSD_4_1_BASE:1.41
	OPENBSD_4_0:1.40.0.4
	OPENBSD_4_0_BASE:1.40
	OPENBSD_3_9:1.40.0.2
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.38.0.6
	OPENBSD_3_8_BASE:1.38
	OPENBSD_3_7:1.38.0.4
	OPENBSD_3_7_BASE:1.38
	OPENBSD_3_6:1.38.0.2
	OPENBSD_3_6_BASE:1.38
	SMP_SYNC_A:1.37
	SMP_SYNC_B:1.37
	OPENBSD_3_5:1.37.0.2
	OPENBSD_3_5_BASE:1.37
	OPENBSD_3_4:1.36.0.6
	OPENBSD_3_4_BASE:1.36
	UBC_SYNC_A:1.36
	OPENBSD_3_3:1.36.0.4
	OPENBSD_3_3_BASE:1.36
	OPENBSD_3_2:1.36.0.2
	OPENBSD_3_2_BASE:1.36
	OPENBSD_3_1:1.33.0.2
	OPENBSD_3_1_BASE:1.33
	UBC_SYNC_B:1.36
	UBC:1.29.0.2
	UBC_BASE:1.29
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.11.0.4
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.2
	SMP_BASE:1.11
	kame_19991208:1.9
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	powerpc_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.49
date	2017.02.12.04.55.08;	author guenther;	state Exp;
branches;
next	1.48;
commitid	1rXx7AiXIWFC9gYa;

1.48
date	2015.05.05.02.13.47;	author guenther;	state Exp;
branches;
next	1.47;
commitid	dNPv28CJI5BxtRGW;

1.47
date	2014.11.16.12.30.58;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	yv0ECmCdICvq576h;

1.46
date	2013.01.16.19.04.43;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2007.10.10.15.53.52;	author art;	state Exp;
branches;
next	1.44;

1.44
date	2007.06.20.17.29.36;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.27.20.59.26;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2007.03.20.20.59.53;	author kettenis;	state Exp;
branches;
next	1.41;

1.41
date	2006.11.29.12.26.14;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2005.12.17.07.31.27;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2005.10.09.14.52.12;	author drahn;	state Exp;
branches;
next	1.38;

1.38
date	2004.06.24.22.35.56;	author drahn;	state Exp;
branches;
next	1.37;

1.37
date	2003.10.15.02.43.09;	author drahn;	state Exp;
branches;
next	1.36;

1.36
date	2002.09.15.09.01.59;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2002.09.15.02.02.44;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2002.05.14.19.21.31;	author drahn;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.28.07.21.12;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.14.23.51.47;	author drahn;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.14.01.26.42;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2002.01.20.03.41.29;	author drahn;	state Exp;
branches;
next	1.29;

1.29
date	2001.12.17.03.19.01;	author drahn;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2001.12.08.02.24.07;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2001.11.13.14.31.52;	author drahn;	state Exp;
branches;
next	1.26;

1.26
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.06.18.41.10;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2001.09.21.17.33.15;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2001.09.19.20.50.57;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2001.09.17.15.14.15;	author drahn;	state Exp;
branches;
next	1.21;

1.21
date	2001.07.25.13.25.33;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.09.02.14.06;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.29.06.07.09;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.27.04.37.22;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.25.23.30.04;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.08.08.09.23;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.05.21.26.40;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.04.03.20.27.26;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.08.22.25.22;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.05.11.03.04;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.16.22.52.22;	author rahnds;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2000.01.14.05.42.17;	author rahnds;	state Exp;
branches;
next	1.9;

1.9
date	99.11.09.00.20.42;	author rahnds;	state Exp;
branches;
next	1.8;

1.8
date	99.09.03.18.01.51;	author art;	state Exp;
branches;
next	1.7;

1.7
date	99.08.17.10.32.17;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.01.23.19.41.33;	author rahnds;	state Exp;
branches;
next	1.5;

1.5
date	99.01.10.13.34.19;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	98.08.07.02.22.10;	author rahnds;	state Exp;
branches;
next	1.3;

1.3
date	97.10.13.13.43.02;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	96.12.28.06.22.31;	author rahnds;	state Exp;
branches;
next	1.1;

1.1
date	96.12.21.20.35.59;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.12.21.20.35.59;	author rahnds;	state Exp;
branches;
next	;

1.11.2.1
date	2001.05.14.21.36.58;	author niklas;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2001.07.04.10.23.04;	author niklas;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2001.10.31.03.07.56;	author nate;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2001.11.13.21.04.16;	author niklas;	state Exp;
branches;
next	1.11.2.5;

1.11.2.5
date	2001.11.13.22.14.34;	author niklas;	state dead;
branches;
next	1.11.2.6;

1.11.2.6
date	2002.03.29.19.46.01;	author niklas;	state Exp;
branches;
next	1.11.2.7;

1.11.2.7
date	2003.03.27.23.42.35;	author niklas;	state Exp;
branches;
next	1.11.2.8;

1.11.2.8
date	2004.02.19.10.49.57;	author niklas;	state Exp;
branches;
next	;

1.29.2.1
date	2002.01.31.22.55.21;	author niklas;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2002.06.11.03.37.28;	author art;	state Exp;
branches;
next	1.29.2.3;

1.29.2.3
date	2002.10.29.00.28.09;	author art;	state Exp;
branches;
next	;


desc
@@


1.49
log
@Split up fork1():
 - FORK_THREAD handling is a totally separate function, thread_fork(),
   that is only used by sys___tfork() and which loses the flags, func,
   arg, and newprocp parameters and gains tcb parameter to guarantee
   the new thread's TCB is set before the creating thread returns
 - fork1() loses its stack and tidptr parameters
Common bits factor out:
 - struct proc allocation and initialization moves to thread_new()
 - maxthread handling moves to fork_check_maxthread()
 - setting the new thread running moves to fork_thread_start()
The MD cpu_fork() function swaps its unused stacksize parameter for
a tcb parameter.

luna88k testing by aoyama@@, alpha testing by dlg@@
ok mpi@@
@
text
@/*	$OpenBSD: vm_machdep.c,v 1.48 2015/05/05 02:13:47 guenther Exp $	*/
/*	$NetBSD: vm_machdep.c,v 1.1 1996/09/30 16:34:57 ws Exp $	*/

/*
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <sys/param.h>
#include <sys/exec.h>
#include <sys/pool.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/user.h>
#include <sys/vnode.h>
#include <sys/ptrace.h>

#include <uvm/uvm_extern.h>

#include <machine/pcb.h>
#include <machine/fpu.h>

/*
 * Finish a fork operation, with process p2 nearly set up.
 */
void
cpu_fork(struct proc *p1, struct proc *p2, void *stack, void *tcb,
    void (*func)(void *), void *arg)
{
	struct trapframe *tf;
	struct callframe *cf;
	struct switchframe *sf;
	caddr_t stktop1, stktop2;
	extern void fork_trampoline(void);
	struct pcb *pcb = &p2->p_addr->u_pcb;
	struct cpu_info *ci = curcpu();

	if (p1 == ci->ci_fpuproc)
		save_fpu();
	*pcb = p1->p_addr->u_pcb;
	
#ifdef ALTIVEC
	if (p1->p_addr->u_pcb.pcb_vr != NULL) {
		if (p1 == ci->ci_vecproc)
			save_vec(p1);
		pcb->pcb_vr = pool_get(&ppc_vecpl, PR_WAITOK);
		*pcb->pcb_vr = *p1->p_addr->u_pcb.pcb_vr;
	} else
		pcb->pcb_vr = NULL;

#endif /* ALTIVEC */

	pcb->pcb_pm = p2->p_vmspace->vm_map.pmap;

	pmap_extract(pmap_kernel(),
	    (vaddr_t)pcb->pcb_pm, (paddr_t *)&pcb->pcb_pmreal);
	
	/*
	 * Setup the trap frame for the new process
	 */
	stktop1 = (caddr_t)trapframe(p1);
	stktop2 = (caddr_t)trapframe(p2);
	bcopy(stktop1, stktop2, sizeof(struct trapframe));

	/*
	 * If specified, give the child a different stack.
	 */
	if (stack != NULL) {
		tf = trapframe(p2);
		tf->fixreg[1] = (register_t)stack;
	}
	if (tcb != NULL) {
		tf = trapframe(p2);
		tf->fixreg[2] = (register_t)tcb;
	}

	stktop2 = (caddr_t)((u_long)stktop2 & ~15);  /* Align stack pointer */
	
	/*
	 * There happens to be a callframe, too.
	 */
	cf = (struct callframe *)stktop2;
	cf->lr = (int)fork_trampoline;
	
	/*
	 * Below the trap frame, there is another call frame:
	 */
	stktop2 -= 16;
	cf = (struct callframe *)stktop2;
	cf->r31 = (register_t)func;
	cf->r30 = (register_t)arg;
	
	/*
	 * Below that, we allocate the switch frame:
	 */
	/* must match SFRAMELEN in genassym */
	stktop2 -= roundup(sizeof *sf, 16);

	sf = (struct switchframe *)stktop2;
	bzero((void *)sf, sizeof *sf);		/* just in case */
	sf->sp = (int)cf;
	sf->user_sr = pmap_kernel()->pm_sr[PPC_USER_SR]; /* just in case */
	pcb->pcb_sp = (int)stktop2;
}

/*
 * cpu_exit is called as the last action during exit.
 * We release the address space and machine-dependent resources,
 * including the memory for the user structure and kernel stack.
 *
 * Since we don't have curproc anymore, we cannot sleep, and therefor
 * this is at least incorrect for the multiprocessor version.
 * Not sure whether we can get away with this in the single proc version.		XXX
 */
void
cpu_exit(struct proc *p)
{
	struct cpu_info *ci = curcpu();
#ifdef ALTIVEC
	struct pcb *pcb = &p->p_addr->u_pcb;
#endif /* ALTIVEC */
	
	/* XXX What if the state is on the other cpu? */
	if (p == ci->ci_fpuproc) 	/* release the fpu */
		ci->ci_fpuproc = NULL;

#ifdef ALTIVEC
	/* XXX What if the state is on the other cpu? */
	if (p == ci->ci_vecproc)
		ci->ci_vecproc = NULL; 	/* release the Altivec Unit */
	if (pcb->pcb_vr != NULL)
		pool_put(&ppc_vecpl, pcb->pcb_vr);
#endif /* ALTIVEC */
	
	pmap_deactivate(p);
	sched_exit(p);
}

/*
 * Map an IO request into kernel virtual address space.
 */
void
vmapbuf(struct buf *bp, vsize_t len)
{
	vaddr_t faddr, taddr, off;
	paddr_t pa;
	
#ifdef	DIAGNOSTIC
	if (!(bp->b_flags & B_PHYS))
		panic("vmapbuf");
#endif
	faddr = trunc_page((vaddr_t)(bp->b_saveaddr = bp->b_data));
	off = (vaddr_t)bp->b_data - faddr;
	len = round_page(off + len);
	taddr = uvm_km_valloc_wait(phys_map, len);
	bp->b_data = (caddr_t)(taddr + off);
	for (; len > 0; len -= NBPG) {
		pmap_extract(vm_map_pmap(&bp->b_proc->p_vmspace->vm_map),
		    faddr, &pa);
		pmap_enter(vm_map_pmap(phys_map), taddr, pa,
		    PROT_READ | PROT_WRITE, PMAP_WIRED);
		faddr += NBPG;
		taddr += NBPG;
	}
	pmap_update(vm_map_pmap(phys_map));
}

/*
 * Free the io map addresses associated with this IO operation.
 */
void
vunmapbuf(struct buf *bp, vsize_t len)
{
	vaddr_t addr, off;
	
#ifdef	DIAGNOSTIC
	if (!(bp->b_flags & B_PHYS))
		panic("vunmapbuf");
#endif
	addr = trunc_page((vaddr_t)bp->b_data);
	off = (vaddr_t)bp->b_data - addr;
	len = round_page(off + len);
	pmap_remove(vm_map_pmap(phys_map), addr, addr + len);
	pmap_update(vm_map_pmap(phys_map));
	uvm_km_free_wakeup(phys_map, addr, len);
	bp->b_data = bp->b_saveaddr;
	bp->b_saveaddr = 0;
}
@


1.48
log
@emul_native is only used for kernel threads which can't dump core, so
delete coredump_trad(), uvm_coredump(), cpu_coredump(), struct md_coredump,
and various #includes that are superfluous.

This leaves compat_linux processes without a coredump callback.  If that
ability is desired, someone should update it to use coredump_elf32() and
verify the results...

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.47 2014/11/16 12:30:58 deraadt Exp $	*/
d52 1
a52 1
cpu_fork(struct proc *p1, struct proc *p2, void *stack, size_t stacksize,
d95 5
a99 1
		tf->fixreg[1] = (register_t)stack + stacksize;
@


1.47
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.46 2013/01/16 19:04:43 miod Exp $	*/
a34 1
#include <sys/core.h>
a157 37
}

/*
 * Write the machine-dependent part of a core dump.
 */
int
cpu_coredump(struct proc *p, struct vnode *vp, struct ucred *cred,
    struct core *chdr)
{
	struct coreseg cseg;
	struct md_coredump md_core;
	int error;
	
	CORE_SETMAGIC(*chdr, COREMAGIC, MID_POWERPC, 0);
	chdr->c_hdrsize = ALIGN(sizeof *chdr);
	chdr->c_seghdrsize = ALIGN(sizeof cseg);
	chdr->c_cpusize = sizeof md_core;

	process_read_regs(p, &(md_core.regs));
	
	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_POWERPC, CORE_CPU);
	cseg.c_addr = 0;
	cseg.c_size = chdr->c_cpusize;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&cseg, chdr->c_seghdrsize,
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE, IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&md_core, sizeof md_core,
	    (off_t)(chdr->c_hdrsize + chdr->c_seghdrsize), UIO_SYSSPACE,
	    IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	chdr->c_nseg++;
	return 0;
@


1.46
log
@cpu_coredump() also needs to invoke vn_rdwr() without IO_NODELOCKED; only
affects a.out binaries' core dumps.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.45 2007/10/10 15:53:52 art Exp $	*/
d220 1
a220 1
		    VM_PROT_READ | VM_PROT_WRITE, PMAP_WIRED);
@


1.45
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.44 2007/06/20 17:29:36 miod Exp $	*/
d184 1
a184 2
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT,
	    cred, NULL, p);
d190 1
a190 1
	    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
@


1.44
log
@In vunmapbuf(), explicitely remove mappings before invoking uvm_km_free().
Even if the latter would end up removing the mappings by itself, it would
do so using pmap_remove() because phys_map is not intrsafe; but some
platforms use pmap_kenter_pa() in vmapbuf(). By removing the mappings
ourselves, we can ensure the remove function used matches the enter function
which has been used.
Discussed and theoretical ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.43 2007/05/27 20:59:26 miod Exp $	*/
a125 1
	pcb->pcb_spl = 0;
d157 2
a158 2
	(void)splsched();
	switchexit(p);
@


1.43
log
@pagemove() is no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.42 2007/03/20 20:59:53 kettenis Exp $	*/
d226 1
a226 1
	pmap_update(pmap_kernel());
d244 2
@


1.42
log
@Move macppc to __HAVE_CPUINFO, and make locore.S and trap.c suitable for
MULTIPROCESSOR.  From now on sprg0 holds a pointer to struct cpuinfo, which
is used to spill registers to during trap instead of the globals we used to
use for that purpose.  Bits and pieces from NetBSD.  Help from drahn@@ and art@@.
Tested by xsa@@, thib@@, miod@@, gwk@@, deraadt@@.

ok drahn@@, gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.41 2006/11/29 12:26:14 miod Exp $	*/
a126 20
}

/*
 * Move pages from one kernel virtual address to another.
 */
void
pagemove(caddr_t from, caddr_t to, size_t size)
{
	vaddr_t va;
	paddr_t pa;
	
	for (va = (vaddr_t)from; size > 0; size -= NBPG) {
		pmap_extract(pmap_kernel(), va, &pa);
		pmap_kremove(va, NBPG);
		pmap_kenter_pa((vaddr_t)to, pa,
			   VM_PROT_READ | VM_PROT_WRITE );
		va += NBPG;
		to += NBPG;
	}
	pmap_update(pmap_kernel());
@


1.41
log
@Remove cpu_swapin() and cpu_swapout(), they are no longer necessary (except
for cpu_swapin() on hppa* which is kept).
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.40 2005/12/17 07:31:27 miod Exp $	*/
d62 1
d64 1
a64 1
	if (p1 == fpuproc)
d70 1
a70 1
		if (p1 == ppc_vecproc)
d161 1
d166 3
a168 2
	if (p == fpuproc) 	/* release the fpu */
		fpuproc = NULL;
d171 3
a173 2
	if (p == ppc_vecproc)
		ppc_vecproc = NULL; 	/* release the Altivec Unit */
d178 1
a178 1
	(void)splhigh();
@


1.40
log
@Get rid of deprecated vm_{offset,size}_t types for good, use {p,v}{addr,size}_t
instead; looked at millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.39 2005/10/09 14:52:12 drahn Exp $	*/
a125 9
}

void
cpu_swapin(struct proc *p)
{
	struct pcb *pcb = &p->p_addr->u_pcb;
	
	pmap_extract(pmap_kernel(),
	    (vaddr_t)pcb->pcb_pm, (paddr_t *)&pcb->pcb_pmreal);
@


1.39
log
@Subtle changes to the powerpc fpu handling, basically fpuproc is handled
in a non-raceable manner inside save_fpu and enable_fpu so that the
eventual SMP case will not grab a half loaded fpu context.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.38 2004/06/24 22:35:56 drahn Exp $	*/
d81 1
a81 1
	    (vm_offset_t)pcb->pcb_pm, (paddr_t *)&pcb->pcb_pmreal);
d134 1
a134 1
	    (vm_offset_t)pcb->pcb_pm, (paddr_t *)&pcb->pcb_pmreal);
d146 1
a146 1
	for (va = (vm_offset_t)from; size > 0; size -= NBPG) {
d149 1
a149 1
		pmap_kenter_pa((vm_offset_t)to, pa,
d229 1
a229 1
vmapbuf(struct buf *bp, vm_size_t len)
d231 2
a232 2
	vm_offset_t faddr, taddr, off;
	vm_offset_t pa;
d239 1
a239 1
	off = (vm_offset_t)bp->b_data - faddr;
d258 1
a258 1
vunmapbuf(struct buf *bp, vm_size_t len)
d260 1
a260 1
	vm_offset_t addr, off;
d267 1
a267 1
	off = (vm_offset_t)bp->b_data - addr;
@


1.38
log
@Do a better job at containing powerpc specific #defines to PPC_...
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.37 2003/10/15 02:43:09 drahn Exp $	*/
d64 1
a64 1
		save_fpu(p1);
d173 2
a174 2
	if (p == fpuproc)	/* release the fpu */
		fpuproc = 0;
@


1.37
log
@Sometimes KNF is not a destination, but a journey. Also ANSI.
Binaries unchanged.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.36 2002/09/15 09:01:59 deraadt Exp $	*/
d117 3
a119 1
	stktop2 -= roundup(sizeof *sf, 16);	/* must match SFRAMELEN in genassym */
d123 1
a123 1
	sf->user_sr = pmap_kernel()->pm_sr[USER_SR]; /* again, just in case */
d134 1
a134 1
		(vm_offset_t)pcb->pcb_pm, (paddr_t *)&pcb->pcb_pmreal);
@


1.36
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.34 2002/05/14 19:21:31 drahn Exp $	*/
d53 2
a54 6
cpu_fork(p1, p2, stack, stacksize, func, arg)
	struct proc *p1, *p2;
	void *stack;
	size_t stacksize;
	void (*func)(void *);
	void *arg;
d73 1
a73 1
	} else {
d75 1
a75 1
	}
d81 1
a81 1
		(vm_offset_t)pcb->pcb_pm, (paddr_t *)&pcb->pcb_pmreal);
d98 1
a98 1
	stktop2 = (caddr_t)((u_long)stktop2 & ~15);	/* Align stack pointer */
d127 1
a127 2
cpu_swapin(p)
	struct proc *p;
d139 1
a139 3
pagemove(from, to, size)
	caddr_t from, to;
	size_t size;
d165 1
a165 2
cpu_exit(p)
	struct proc *p;
d189 2
a190 5
cpu_coredump(p, vp, cred, chdr)
	struct proc *p;
	struct vnode *vp;
	struct ucred *cred;
	struct core *chdr;
d207 4
a210 3
	if ((error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&cseg, chdr->c_seghdrsize,
			    (off_t)chdr->c_hdrsize, UIO_SYSSPACE,
			    IO_NODELOCKED|IO_UNIT, cred, NULL, p)))
d212 5
a216 3
	if ((error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&md_core, sizeof md_core,
			    (off_t)(chdr->c_hdrsize + chdr->c_seghdrsize),
			    UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT, cred, NULL, p)))
d227 1
a227 3
vmapbuf(bp, len)
	struct buf *bp;
	vm_size_t len;
d242 2
a243 1
		pmap_extract(vm_map_pmap(&bp->b_proc->p_vmspace->vm_map), faddr, &pa);
d245 1
a245 1
			   VM_PROT_READ | VM_PROT_WRITE, PMAP_WIRED);
d256 1
a256 3
vunmapbuf(bp, len)
	struct buf *bp;
	vm_size_t len;
@


1.35
log
@KNF
@
text
@d70 1
a70 1

d86 1
a86 1

d103 1
a103 1

d109 1
a109 1

d117 1
a117 1

d135 1
a135 1

d150 1
a150 1

d178 1
a178 1

d184 1
a184 1
		ppc_vecproc = NULL;	/* release the Altivec Unit */
d188 1
a188 1

d206 1
a206 1

d213 1
a213 1

d241 1
a241 1

d270 1
a270 1

@


1.34
log
@powerpc generates powerpc coredumps, not hppa coredumps.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.33 2002/03/28 07:21:12 deraadt Exp $	*/
d70 1
a70 1
	
d86 1
a86 1
	
d103 1
a103 1
	
d109 1
a109 1
	
d117 1
a117 1
	
d135 1
a135 1
	
d150 1
a150 1
	
d178 1
a178 1
	
d184 1
a184 1
		ppc_vecproc = NULL; 	/* release the Altivec Unit */
d188 1
a188 1
	
d206 1
a206 1
	
d213 1
a213 1
	
d241 1
a241 1
	
d270 1
a270 1
	
@


1.33
log
@do not use MID_ZERO!  then file(1) does not work
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.32 2002/03/14 23:51:47 drahn Exp $	*/
d207 1
a207 1
	CORE_SETMAGIC(*chdr, COREMAGIC, MID_HPPA, 0);
d214 1
a214 1
	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_HPPA, CORE_CPU);
@


1.32
log
@Improved altivec support for powerpc/macppc.
Fix bug where altivec context was not freed on process exit.
Fix bug where vscr was not correctly saved/restored.
replace asm statement was macros which expand to the same
asm code or to .long XXX which evaluates to the same instruction
since in-tree gas does not support altivec.
Enable ALTIVEC support by default on macppc, still conditional
for other powerpc ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.31 2002/03/14 01:26:42 millert Exp $	*/
d207 1
a207 1
	CORE_SETMAGIC(*chdr, COREMAGIC, MID_ZERO, 0);
d214 1
a214 1
	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_ZERO, CORE_CPU);
@


1.31
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.30 2002/01/20 03:41:29 drahn Exp $	*/
d71 1
a71 2
#ifdef PPC_VECTOR_SUPPORTED
	/* ALTIVEC */
d80 1
a80 1
#endif /* PPC_VECTOR_SUPPORTED */
d175 4
d181 7
@


1.30
log
@fix quite appearent bug in cpu_swapin(), missing '&' can easily corrupt
memory, pmap structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.29 2001/12/17 03:19:01 drahn Exp $	*/
d64 1
a64 1
	extern void fork_trampoline __P((void));
@


1.29
log
@Move the process_read_reg prototype to the correct file, it is specified
in ptrace.h, not in md header files.
Protect vector functions/variables with _KERNEL.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.28 2001/12/08 02:24:07 art Exp $	*/
d86 1
a86 1
		 (vm_offset_t)pcb->pcb_pm, (paddr_t *)&pcb->pcb_pmreal);
d138 1
a138 1
		(vm_offset_t)pcb->pcb_pm, (paddr_t *)pcb->pcb_pmreal);
@


1.29.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.30 2002/01/20 03:41:29 drahn Exp $	*/
d86 1
a86 1
		(vm_offset_t)pcb->pcb_pm, (paddr_t *)&pcb->pcb_pmreal);
d138 1
a138 1
		(vm_offset_t)pcb->pcb_pm, (paddr_t *)&pcb->pcb_pmreal);
@


1.29.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.29.2.1 2002/01/31 22:55:21 niklas Exp $	*/
d64 1
a64 1
	extern void fork_trampoline(void);
d71 2
a72 1
#ifdef ALTIVEC
d81 1
a81 1
#endif /* ALTIVEC */
a175 4
#ifdef ALTIVEC
	struct pcb *pcb = &p->p_addr->u_pcb;
#endif /* ALTIVEC */
	
a177 7

#ifdef ALTIVEC
	if (p == ppc_vecproc)
		ppc_vecproc = NULL; 	/* release the Altivec Unit */
	if (pcb->pcb_vr != NULL)
		pool_put(&ppc_vecpl, pcb->pcb_vr);
#endif /* ALTIVEC */
d197 1
a197 1
	CORE_SETMAGIC(*chdr, COREMAGIC, MID_POWERPC, 0);
d204 1
a204 1
	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_POWERPC, CORE_CPU);
@


1.29.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.29.2.2 2002/06/11 03:37:28 art Exp $	*/
@


1.28
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.27 2001/11/13 14:31:52 drahn Exp $	*/
d42 1
@


1.27
log
@Add AltiVec support to powerpc/macppc. This is not currently enabled because
the 'as' in openbsd source tree does not yet support altivec instructions.
The pieces to enable it have been put in macppc/conf/GENERIC and
macppc/conf/Makefile.macppc in comments.
Once 'as' is updated the kernel option should be removed.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.26 2001/11/06 19:53:16 miod Exp $	*/
d159 1
d247 1
@


1.26
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.25 2001/11/06 18:41:10 art Exp $	*/
d37 1
d70 12
@


1.25
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.24 2001/09/21 17:33:15 miod Exp $	*/
a40 2

#include <vm/vm.h>
@


1.24
log
@Correctly initialize variables in cpu_fork(). From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.23 2001/09/19 20:50:57 mickey Exp $	*/
d53 1
a53 1
cpu_fork(p1, p2, stack, stacksize)
d57 2
a64 1
	extern void child_return __P((struct proc *));
d104 2
a105 2
	cf->r31 = (register_t)child_return;
	cf->r30 = (register_t)p2;
a116 17
}

/*
 * Set initial pc of process forked by above.
 */
void
cpu_set_kpc(p, pc, arg)
	struct proc *p;
	void (*pc) __P((void *));
	void *arg;
{
	struct switchframe *sf = (struct switchframe *)p->p_addr->u_pcb.pcb_sp;
	struct callframe *cf = (struct callframe *)sf->sp;
	
	cf->r30 = (register_t)arg;
	cf->r31 = (register_t)pc;
	cf++->lr = (register_t)pc;
@


1.23
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.22 2001/09/17 15:14:15 drahn Exp $	*/
d85 2
a86 1
	if (stack != NULL)
d88 1
@


1.22
log
@pagemove() should use the pmap_k* functions instead of pmap_enter/remove.

The buffer cache is initialized with pmap_k* for all powerpc systems.
Does not cause a problem with current code because pmap_k* are only
wrappers around pmap_enter/remove.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.21 2001/07/25 13:25:33 art Exp $	*/
a42 1
#include <vm/vm_kern.h>
@


1.21
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.20 2001/07/09 02:14:06 mickey Exp $	*/
d157 3
a159 4
		pmap_remove(pmap_kernel(), va, va + NBPG);
		pmap_enter(pmap_kernel(), (vm_offset_t)to, pa,
			   VM_PROT_READ | VM_PROT_WRITE,
			   VM_PROT_READ | VM_PROT_WRITE | PMAP_WIRED);
@


1.20
log
@more spacees, includes, protos
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.19 2001/06/29 06:07:09 drahn Exp $	*/
d159 2
a160 2
			   VM_PROT_READ | VM_PROT_WRITE, 1,
			   VM_PROT_READ | VM_PROT_WRITE);
d247 1
a247 1
			   VM_PROT_READ | VM_PROT_WRITE, 1, 0);
@


1.19
log
@header file include/define cleanup. commit N of many.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.18 2001/06/27 04:37:22 art Exp $	*/
d48 1
d211 1
a211 1
	if (error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&cseg, chdr->c_seghdrsize,
d213 1
a213 1
			    IO_NODELOCKED|IO_UNIT, cred, NULL, p))
d215 3
a217 3
	if (error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&md_core, sizeof md_core,
			    (off_t)(chdr->c_hdrsize + chdr->c_seghdrsize), UIO_SYSSPACE,
			    IO_NODELOCKED|IO_UNIT, cred, NULL, p))
@


1.18
log
@kill old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.17 2001/06/25 23:30:04 drahn Exp $	*/
d204 1
a204 1
	process_read_regs(p, &md_core);
@


1.17
log
@closer to building with -Wno-uninitialized
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.16 2001/06/08 08:09:23 art Exp $	*/
a44 1
#ifdef UVM
a45 1
#endif
a240 1
#ifdef UVM
a241 3
#else
	taddr = kmem_alloc_wait(phys_map, len);
#endif
a268 1
#ifdef UVM
a269 3
#else
	kmem_free_wakeup(phys_map, addr, len);
#endif
@


1.16
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.15 2001/05/05 21:26:40 art Exp $	*/
a198 1
	struct trapframe *tf;
a200 1
#if 1
a221 1
#endif
@


1.15
log
@Remove the (vaddr_t) casts inside the round_page and trunc_page macros.
We might want to use them on types that are bigger than vaddr_t.

Fix all callers that pass pointers without casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.14 2001/04/03 20:27:26 art Exp $	*/
d74 2
a75 1
	pcb->pcb_pmreal = (struct pmap *)pmap_extract(pmap_kernel(), (vm_offset_t)pcb->pcb_pm);
d141 2
a142 1
	pcb->pcb_pmreal = (struct pmap *)pmap_extract(pmap_kernel(), (vm_offset_t)pcb->pcb_pm);
d153 2
a154 1
	vm_offset_t pa, va;
d157 1
a157 1
		pa = pmap_extract(pmap_kernel(), va);
d253 1
a253 1
		pa = pmap_extract(vm_map_pmap(&bp->b_proc->p_vmspace->vm_map), faddr);
@


1.14
log
@vm_map.pmap should always be used, not only for uvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.13 2000/06/08 22:25:22 niklas Exp $	*/
d240 1
a240 1
	faddr = trunc_page(bp->b_saveaddr = bp->b_data);
d272 1
a272 1
	addr = trunc_page(bp->b_data);
@


1.13
log
@Add explicit inclusions of signalvar.h to files actually using syms defined
there but relying on an indirect inclusion
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.13 2000/06/08 21:12:07 niklas Exp $	*/
a71 1
#ifdef UVM
a72 3
#else
	pcb->pcb_pm = &p2->p_vmspace->vm_pmap;
#endif
@


1.12
log
@Changes to exit handling.

cpu_exit no longer frees the vmspace and u-area. This is now handled by a
separate kernel thread "reaper". This is to avoid sleeping locks in the
critical path of cpu_exit where we're not allowed to sleep.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.11 2000/01/16 22:52:22 rahnds Exp $	*/
d38 1
@


1.11
log
@Closer to support for UVM on powerpc, tries to execute user programs, but
then fails with illegal instruction. (init or shell).
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.10 2000/01/14 05:42:17 rahnds Exp $	*/
a182 5
#ifdef UVM
	uvmspace_free(p->p_vmspace);
#else
	vmspace_free(p->p_vmspace);
#endif
d184 1
a184 1
	switchexit(kernel_map, p->p_addr, USPACE);
@


1.11.2.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.14 2001/04/03 20:27:26 art Exp $	*/
a37 1
#include <sys/signalvar.h>
d71 1
d73 3
d183 5
d189 1
a189 1
	switchexit(p);
@


1.11.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.11.2.1 2001/05/14 21:36:58 niklas Exp $	*/
d45 1
d47 1
d74 1
a74 2
	pmap_extract(pmap_kernel(),
		 (vm_offset_t)pcb->pcb_pm, (paddr_t *)&pcb->pcb_pmreal);
d140 1
a140 2
	pmap_extract(pmap_kernel(),
		(vm_offset_t)pcb->pcb_pm, (paddr_t *)pcb->pcb_pmreal);
d151 1
a151 2
	vaddr_t va;
	paddr_t pa;
d154 1
a154 1
		pmap_extract(pmap_kernel(), va, &pa);
d196 1
d199 1
d205 1
a205 1
	process_read_regs(p, &(md_core.regs));
d221 1
d240 1
a240 1
	faddr = trunc_page((vaddr_t)(bp->b_saveaddr = bp->b_data));
d243 1
d245 3
d250 1
a250 1
		pmap_extract(vm_map_pmap(&bp->b_proc->p_vmspace->vm_map), faddr, &pa);
d272 1
a272 1
	addr = trunc_page((vaddr_t)bp->b_data);
d275 1
d277 3
@


1.11.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.11.2.2 2001/07/04 10:23:04 niklas Exp $	*/
d43 1
a47 1
#include <machine/fpu.h>
d85 1
a85 2
	if (stack != NULL) {
		tf = trapframe(p2);
a86 1
	}
d156 4
a159 3
		pmap_kremove(va, NBPG);
		pmap_kenter_pa((vm_offset_t)to, pa,
			   VM_PROT_READ | VM_PROT_WRITE );
d210 1
a210 1
	if ((error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&cseg, chdr->c_seghdrsize,
d212 1
a212 1
			    IO_NODELOCKED|IO_UNIT, cred, NULL, p)))
d214 3
a216 3
	if ((error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&md_core, sizeof md_core,
			    (off_t)(chdr->c_hdrsize + chdr->c_seghdrsize),
			    UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT, cred, NULL, p)))
d246 1
a246 1
			   VM_PROT_READ | VM_PROT_WRITE, PMAP_WIRED);
@


1.11.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 2
d53 1
a53 1
cpu_fork(p1, p2, stack, stacksize, func, arg)
a56 2
	void (*func)(void *);
	void *arg;
d63 1
d103 2
a104 2
	cf->r31 = (register_t)func;
	cf->r30 = (register_t)arg;
d116 17
@


1.11.2.5
log
@repair
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.11.2.4 2001/11/13 21:04:16 niklas Exp $	*/
@


1.11.2.6
log
@Re-add missing pieces
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.32 2002/03/14 23:51:47 drahn Exp $	*/
a36 1
#include <sys/pool.h>
a40 1
#include <sys/ptrace.h>
d62 1
a62 1
	extern void fork_trampoline(void);
a68 11
#ifdef ALTIVEC
	if (p1->p_addr->u_pcb.pcb_vr != NULL) {
		if (p1 == ppc_vecproc)
			save_vec(p1);
		pcb->pcb_vr = pool_get(&ppc_vecpl, PR_WAITOK);
		*pcb->pcb_vr = *p1->p_addr->u_pcb.pcb_vr;
	} else {
		pcb->pcb_vr = NULL;
	}
#endif /* ALTIVEC */

d72 1
a72 1
		(vm_offset_t)pcb->pcb_pm, (paddr_t *)&pcb->pcb_pmreal);
d124 1
a124 1
		(vm_offset_t)pcb->pcb_pm, (paddr_t *)&pcb->pcb_pmreal);
a145 1
	pmap_update(pmap_kernel());
a160 4
#ifdef ALTIVEC
	struct pcb *pcb = &p->p_addr->u_pcb;
#endif /* ALTIVEC */
	
a162 7

#ifdef ALTIVEC
	if (p == ppc_vecproc)
		ppc_vecproc = NULL; 	/* release the Altivec Unit */
	if (pcb->pcb_vr != NULL)
		pool_put(&ppc_vecpl, pcb->pcb_vr);
#endif /* ALTIVEC */
a232 1
	pmap_update(pmap_kernel());
@


1.11.2.7
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d207 1
a207 1
	CORE_SETMAGIC(*chdr, COREMAGIC, MID_POWERPC, 0);
d214 1
a214 1
	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_POWERPC, CORE_CPU);
@


1.11.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d53 6
a58 2
cpu_fork(struct proc *p1, struct proc *p2, void *stack, size_t stacksize,
    void (*func)(void *), void *arg)
d77 1
a77 1
	} else
d79 1
a79 1

d85 1
a85 1
	    (vm_offset_t)pcb->pcb_pm, (paddr_t *)&pcb->pcb_pmreal);
d102 1
a102 1
	stktop2 = (caddr_t)((u_long)stktop2 & ~15);  /* Align stack pointer */
d131 2
a132 1
cpu_swapin(struct proc *p)
d144 3
a146 1
pagemove(caddr_t from, caddr_t to, size_t size)
d172 2
a173 1
cpu_exit(struct proc *p)
d197 5
a201 2
cpu_coredump(struct proc *p, struct vnode *vp, struct ucred *cred,
    struct core *chdr)
d218 3
a220 4
	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&cseg, chdr->c_seghdrsize,
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT,
	    cred, NULL, p);
	if (error)
d222 3
a224 5

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&md_core, sizeof md_core,
	    (off_t)(chdr->c_hdrsize + chdr->c_seghdrsize), UIO_SYSSPACE,
	    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
	if (error)
d235 3
a237 1
vmapbuf(struct buf *bp, vm_size_t len)
d252 1
a252 2
		pmap_extract(vm_map_pmap(&bp->b_proc->p_vmspace->vm_map),
		    faddr, &pa);
d254 1
a254 1
		    VM_PROT_READ | VM_PROT_WRITE, PMAP_WIRED);
d265 3
a267 1
vunmapbuf(struct buf *bp, vm_size_t len)
@


1.10
log
@

UVM changes mainly. As of this checkin UVM is still not working for powerpc
it has a copyin bug after device configuration. However to get these diffs
out of my tree.

All of the UVM code is currently inside ifdef UVM the kernel works fine
without option UVM. Config files have been left without UVM for now.

Prelimiary changes for busdma, (what UVM was wanted for).
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.9 1999/11/09 00:20:42 rahnds Exp $	*/
d71 3
d75 2
a76 3
	/*
	pcb->pcb_pm = &p2->p_vmspace->vm_map.pmap;
	*/
@


1.9
log
@autoconf.c:
	calculate delay time for delay() before it is acutally used.
	add support for md_diskconf come closer to supporting crashdumps,
	eventually this code should be un if 0 ed and supported.
	add the wd device as a supported device, fix some comments.
clock.c:
	support calculation of delay loop earlier, do the spin loop correcly,
	unsigned math on the lower half, not signed math.
conf.c:
	addd support for wd driver, block major 0, char major 11.
machdep.c:
	bus_space_map becomes a real function, not just inlined function.
	Support devices that are not mapped with bats (most still currently
	are mapped with bats,...). BAT mapping does not allow proper
	mapping of cachable devices.
	mapiodev HACK, NEEDS TO BE REMOVED. added for quicker import
	of BROKEN mac drivers. the drivers NEED to be rewritten in
	a busified manner. it would FIX all of the endian swabbing
	done by each driver. (Is that emphasized enough?)

	bus_space_(read|write)_raw_multi as functions, should these
	be turned into inline functions and put in bus.h?
ofw_machdep.c:
	removed extranious variable.
openfirm.c:
	telling openfirmware to "boot" will put the system
	in somewhat of a strange state, try reset-all, but that
	typically fails, therefore, try OF_exit before spinning.
pmap.c:
	support stealing memory from kernel address space so that
	mappings can be created before vm is initalized.
vm_machdep.c:
	maybe the meaning of removing this will later become obvious. ???
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.8 1999/09/03 18:01:51 art Exp $	*/
d44 4
d181 3
d185 1
d249 3
d253 1
d281 3
d285 1
@


1.8
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.7 1999/08/17 10:32:17 niklas Exp $	*/
d68 3
@


1.7
log
@New cpu_fork API to take a stack in which you point the child's stackpointer
to, at the bottom or the top, depending on your architecture's stack growth
direction.  This is in preparation for Linux' clone(2) emulation.
port maintainers, please check that I did the work right.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.6 1999/01/23 19:41:33 rahnds Exp $	*/
d151 2
a152 1
			   VM_PROT_READ | VM_PROT_WRITE, 1);
d243 1
a243 1
			   VM_PROT_READ | VM_PROT_WRITE, 1);
@


1.6
log
@Fixes to update to that the powerpc port builds again.
These change were necessary due to the following changes:
The change/import of the "generic" isa/pcppi driver. The powerpc
port currently has it's own copy of that driver. The two versions
need to be merged.
The parameter changes to cpu_set_kpc. The powerpc change was not quite correct.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.5 1999/01/10 13:34:19 niklas Exp $	*/
d50 1
a50 1
cpu_fork(p1, p2)
d52 2
d76 7
@


1.5
log
@Generalize cpu_set_kpc to take any kind of arg; mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.4 1998/08/07 02:22:10 rahnds Exp $	*/
d114 3
a116 3
	cf->r30 = (int)arg;
	cf->r31 = (int)pc;
	cf++->lr = pc;
@


1.4
log
@Add kernel support for debugging with gdb. This also make /proc allow
access to the registers. The format of the registers returned in ptrace,
/proc and in the coredump header match what gdb was expecting.
Floating point registers are not yet copied into the structure.
The location of the fpr needs to be found and copied. <- TODO

Changes to trap.c was to add some interm debugging. code is commented out.

powerpc does not currently have a MID_* type, since it uses ELF instead
of a.out, one was never added. Currently the coredump is done in form
of MID_NONE. What is the correct approach for this?? Elf format coredumps...
maybe?
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.3 1997/10/13 13:43:02 pefo Exp $	*/
d106 1
a106 1
cpu_set_kpc(p, pc)
d108 2
a109 1
	u_long pc;
d114 2
a115 2
	cf->r30 = (int)p;
	cf->r31 = pc;
@


1.3
log
@Monolithic (No OpenFirmware driver crap...) PowerPC kernel. This is the
first release based on Wolfgang Solfrank, TooLs GmbH, work. Most OFW stuff
has been ripped out. Only a few functions for memory probing and halt/reboot
functionality has been kept. The kernel currently works with V.I's power.4e
PowerPC604 board, but more will come.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.2 1996/12/28 06:22:31 rahnds Exp $	*/
d183 2
a184 2
#if 0
	CORE_SETMAGIC(*chdr, COREMAGIC, MID_POWERPC, 0);
d189 1
a189 2
	tf = trapframe(p);
	bcopy(tf, &md_core.frame, sizeof md_core.frame);
d191 1
a191 1
	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_POWERPC, CORE_CPU);
@


1.2
log
@Adding OpenBSD tags to files.
@
text
@d1 1
a1 1
/*	$OpenBSD:$	*/
d164 1
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@Check-in of powerpc kernel support.
NOTE: This will not work until the other pieces are checked in.
This is primarily the NetBSD powerpc port, with modifications
to support ELF. 
@
text
@@
