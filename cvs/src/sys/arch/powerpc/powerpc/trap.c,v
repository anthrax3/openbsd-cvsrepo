head	1.106;
access;
symbols
	OPENBSD_6_2:1.106.0.6
	OPENBSD_6_2_BASE:1.106
	OPENBSD_6_1:1.106.0.4
	OPENBSD_6_1_BASE:1.106
	OPENBSD_6_0:1.105.0.6
	OPENBSD_6_0_BASE:1.105
	OPENBSD_5_9:1.105.0.2
	OPENBSD_5_9_BASE:1.105
	OPENBSD_5_8:1.105.0.4
	OPENBSD_5_8_BASE:1.105
	OPENBSD_5_7:1.103.0.2
	OPENBSD_5_7_BASE:1.103
	OPENBSD_5_6:1.101.0.4
	OPENBSD_5_6_BASE:1.101
	OPENBSD_5_5:1.94.0.8
	OPENBSD_5_5_BASE:1.94
	OPENBSD_5_4:1.94.0.4
	OPENBSD_5_4_BASE:1.94
	OPENBSD_5_3:1.94.0.2
	OPENBSD_5_3_BASE:1.94
	OPENBSD_5_2:1.90.0.2
	OPENBSD_5_2_BASE:1.90
	OPENBSD_5_1_BASE:1.89
	OPENBSD_5_1:1.89.0.2
	OPENBSD_5_0:1.88.0.2
	OPENBSD_5_0_BASE:1.88
	OPENBSD_4_9:1.83.0.12
	OPENBSD_4_9_BASE:1.83
	OPENBSD_4_8:1.83.0.10
	OPENBSD_4_8_BASE:1.83
	OPENBSD_4_7:1.83.0.6
	OPENBSD_4_7_BASE:1.83
	OPENBSD_4_6:1.83.0.8
	OPENBSD_4_6_BASE:1.83
	OPENBSD_4_5:1.83.0.4
	OPENBSD_4_5_BASE:1.83
	OPENBSD_4_4:1.83.0.2
	OPENBSD_4_4_BASE:1.83
	OPENBSD_4_3:1.79.0.2
	OPENBSD_4_3_BASE:1.79
	OPENBSD_4_2:1.78.0.2
	OPENBSD_4_2_BASE:1.78
	OPENBSD_4_1:1.73.0.2
	OPENBSD_4_1_BASE:1.73
	OPENBSD_4_0:1.72.0.4
	OPENBSD_4_0_BASE:1.72
	OPENBSD_3_9:1.72.0.2
	OPENBSD_3_9_BASE:1.72
	OPENBSD_3_8:1.68.0.2
	OPENBSD_3_8_BASE:1.68
	OPENBSD_3_7:1.65.0.2
	OPENBSD_3_7_BASE:1.65
	OPENBSD_3_6:1.64.0.2
	OPENBSD_3_6_BASE:1.64
	SMP_SYNC_A:1.62
	SMP_SYNC_B:1.62
	OPENBSD_3_5:1.62.0.2
	OPENBSD_3_5_BASE:1.62
	OPENBSD_3_4:1.60.0.2
	OPENBSD_3_4_BASE:1.60
	UBC_SYNC_A:1.58
	OPENBSD_3_3:1.58.0.2
	OPENBSD_3_3_BASE:1.58
	OPENBSD_3_2:1.54.0.2
	OPENBSD_3_2_BASE:1.54
	OPENBSD_3_1:1.45.0.2
	OPENBSD_3_1_BASE:1.45
	UBC_SYNC_B:1.55
	UBC:1.41.0.2
	UBC_BASE:1.41
	OPENBSD_3_0:1.33.0.2
	OPENBSD_3_0_BASE:1.33
	OPENBSD_2_9_BASE:1.24
	OPENBSD_2_9:1.24.0.2
	OPENBSD_2_8:1.20.0.2
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.17.0.2
	OPENBSD_2_7_BASE:1.17
	SMP:1.16.0.2
	SMP_BASE:1.16
	kame_19991208:1.15
	OPENBSD_2_6:1.15.0.2
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	powerpc_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.106
date	2016.12.20.12.08.01;	author jsg;	state Exp;
branches;
next	1.105;
commitid	L9O78oFJUMOAl3x8;

1.105
date	2015.07.29.18.52.44;	author miod;	state Exp;
branches;
next	1.104;
commitid	f8evG97O4V8Sypqs;

1.104
date	2015.04.29.04.43.25;	author jsg;	state Exp;
branches;
next	1.103;
commitid	6MgwCRlM4lbSTY6i;

1.103
date	2014.11.16.12.30.58;	author deraadt;	state Exp;
branches;
next	1.102;
commitid	yv0ECmCdICvq576h;

1.102
date	2014.09.06.09.42.23;	author mpi;	state Exp;
branches;
next	1.101;
commitid	4fHo5VOQyKp2KbTB;

1.101
date	2014.07.09.08.32.57;	author deraadt;	state Exp;
branches;
next	1.100;
commitid	VmrpNZFYjhK34vKr;

1.100
date	2014.05.11.00.12.44;	author guenther;	state Exp;
branches;
next	1.99;

1.99
date	2014.05.10.16.48.36;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	2014.05.10.05.33.00;	author guenther;	state Exp;
branches;
next	1.97;

1.97
date	2014.05.09.18.16.15;	author miod;	state Exp;
branches;
next	1.96;

1.96
date	2014.04.18.11.51.17;	author guenther;	state Exp;
branches;
next	1.95;

1.95
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.94;

1.94
date	2012.12.31.06.46.13;	author guenther;	state Exp;
branches;
next	1.93;

1.93
date	2012.08.08.04.11.08;	author miod;	state Exp;
branches;
next	1.92;

1.92
date	2012.08.07.17.17.46;	author guenther;	state Exp;
branches;
next	1.91;

1.91
date	2012.08.07.05.16.54;	author guenther;	state Exp;
branches;
next	1.90;

1.90
date	2012.04.11.14.38.55;	author mikeb;	state Exp;
branches;
next	1.89;

1.89
date	2011.11.16.20.50.19;	author deraadt;	state Exp;
branches;
next	1.88;

1.88
date	2011.07.30.20.50.47;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2011.07.11.15.40.47;	author guenther;	state Exp;
branches;
next	1.86;

1.86
date	2011.07.07.18.11.24;	author art;	state Exp;
branches;
next	1.85;

1.85
date	2011.07.06.21.41.37;	author art;	state Exp;
branches;
next	1.84;

1.84
date	2011.04.03.14.56.28;	author guenther;	state Exp;
branches;
next	1.83;

1.83
date	2008.06.14.10.55.20;	author mk;	state Exp;
branches;
next	1.82;

1.82
date	2008.05.03.17.27.04;	author miod;	state Exp;
branches;
next	1.81;

1.81
date	2008.04.27.16.01.47;	author drahn;	state Exp;
branches;
next	1.80;

1.80
date	2008.04.27.15.59.49;	author drahn;	state Exp;
branches;
next	1.79;

1.79
date	2007.10.27.22.31.17;	author kettenis;	state Exp;
branches;
next	1.78;

1.78
date	2007.04.26.21.36.32;	author kettenis;	state Exp;
branches;
next	1.77;

1.77
date	2007.04.01.09.29.27;	author art;	state Exp;
branches;
next	1.76;

1.76
date	2007.03.23.21.06.06;	author miod;	state Exp;
branches;
next	1.75;

1.75
date	2007.03.20.20.59.53;	author kettenis;	state Exp;
branches;
next	1.74;

1.74
date	2007.03.15.10.22.29;	author art;	state Exp;
branches;
next	1.73;

1.73
date	2006.12.24.20.29.19;	author miod;	state Exp;
branches
	1.73.2.1;
next	1.72;

1.72
date	2005.12.17.07.31.27;	author miod;	state Exp;
branches
	1.72.2.1
	1.72.4.1;
next	1.71;

1.71
date	2005.10.09.22.33.18;	author drahn;	state Exp;
branches;
next	1.70;

1.70
date	2005.10.09.14.52.12;	author drahn;	state Exp;
branches;
next	1.69;

1.69
date	2005.09.15.21.09.29;	author miod;	state Exp;
branches;
next	1.68;

1.68
date	2005.05.30.22.12.32;	author drahn;	state Exp;
branches;
next	1.67;

1.67
date	2005.04.21.04.39.35;	author mickey;	state Exp;
branches;
next	1.66;

1.66
date	2005.04.17.21.34.26;	author kettenis;	state Exp;
branches;
next	1.65;

1.65
date	2004.12.06.20.12.25;	author miod;	state Exp;
branches
	1.65.2.1;
next	1.64;

1.64
date	2004.08.05.20.56.24;	author pefo;	state Exp;
branches
	1.64.2.1;
next	1.63;

1.63
date	2004.06.24.22.35.56;	author drahn;	state Exp;
branches;
next	1.62;

1.62
date	2003.12.21.15.17.32;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2003.10.15.02.43.09;	author drahn;	state Exp;
branches;
next	1.60;

1.60
date	2003.07.02.21.57.52;	author drahn;	state Exp;
branches;
next	1.59;

1.59
date	2003.07.02.21.30.12;	author drahn;	state Exp;
branches;
next	1.58;

1.58
date	2003.03.04.19.11.37;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2003.03.04.19.10.31;	author drahn;	state Exp;
branches;
next	1.56;

1.56
date	2003.02.26.21.54.44;	author drahn;	state Exp;
branches;
next	1.55;

1.55
date	2002.10.13.18.26.12;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2002.09.15.09.01.59;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2002.09.15.02.02.44;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2002.07.24.02.19.28;	author drahn;	state Exp;
branches;
next	1.51;

1.51
date	2002.06.07.21.57.57;	author drahn;	state Exp;
branches;
next	1.50;

1.50
date	2002.06.04.00.09.08;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2002.05.18.09.49.17;	author art;	state Exp;
branches;
next	1.48;

1.48
date	2002.05.16.21.11.17;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2002.05.15.22.49.16;	author drahn;	state Exp;
branches;
next	1.46;

1.46
date	2002.05.13.17.55.02;	author drahn;	state Exp;
branches;
next	1.45;

1.45
date	2002.03.14.23.51.47;	author drahn;	state Exp;
branches;
next	1.44;

1.44
date	2002.03.14.01.26.42;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2002.03.13.18.27.37;	author drahn;	state Exp;
branches;
next	1.42;

1.42
date	2002.01.13.05.30.17;	author drahn;	state Exp;
branches;
next	1.41;

1.41
date	2001.11.29.04.47.41;	author drahn;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2001.11.28.16.13.29;	author art;	state Exp;
branches;
next	1.39;

1.39
date	2001.11.28.13.47.39;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2001.11.13.14.31.52;	author drahn;	state Exp;
branches;
next	1.37;

1.37
date	2001.11.11.04.43.53;	author drahn;	state Exp;
branches;
next	1.36;

1.36
date	2001.11.07.01.02.36;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2001.11.05.22.26.57;	author drahn;	state Exp;
branches;
next	1.33;

1.33
date	2001.09.20.13.46.04;	author drahn;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2001.09.19.20.50.57;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2001.09.18.01.51.54;	author drahn;	state Exp;
branches;
next	1.30;

1.30
date	2001.09.14.14.58.44;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2001.07.09.02.07.49;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2001.07.09.01.35.33;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.27.04.37.22;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.25.23.30.04;	author drahn;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.10.18.45.02;	author drahn;	state Exp;
branches;
next	1.24;

1.24
date	2001.03.30.05.13.46;	author drahn;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.29.21.47.40;	author drahn;	state Exp;
branches;
next	1.22;

1.22
date	2001.01.25.03.02.43;	author drahn;	state Exp;
branches;
next	1.21;

1.21
date	2000.11.10.18.15.42;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2000.09.06.22.48.13;	author rahnds;	state Exp;
branches;
next	1.19;

1.19
date	2000.07.08.19.43.39;	author rahnds;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.08.22.25.22;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.20.07.05.53;	author rahnds;	state Exp;
branches;
next	1.16;

1.16
date	2000.01.14.05.42.17;	author rahnds;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	99.07.05.20.29.14;	author rahnds;	state Exp;
branches;
next	1.14;

1.14
date	99.04.22.06.08.06;	author rahnds;	state Exp;
branches;
next	1.13;

1.13
date	99.03.13.01.49.07;	author rahnds;	state Exp;
branches;
next	1.12;

1.12
date	98.09.09.04.54.43;	author rahnds;	state Exp;
branches;
next	1.11;

1.11
date	98.08.25.08.02.23;	author pefo;	state Exp;
branches;
next	1.10;

1.10
date	98.08.22.17.54.26;	author rahnds;	state Exp;
branches;
next	1.9;

1.9
date	98.08.07.02.22.09;	author rahnds;	state Exp;
branches;
next	1.8;

1.8
date	98.05.29.04.15.41;	author rahnds;	state Exp;
branches;
next	1.7;

1.7
date	98.04.06.20.21.11;	author pefo;	state Exp;
branches;
next	1.6;

1.6
date	97.10.13.13.43.01;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	97.02.05.06.10.05;	author rahnds;	state Exp;
branches;
next	1.4;

1.4
date	97.02.05.01.33.55;	author rahnds;	state Exp;
branches;
next	1.3;

1.3
date	96.12.28.06.22.27;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	96.12.28.06.09.30;	author rahnds;	state Exp;
branches;
next	1.1;

1.1
date	96.12.21.20.35.59;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.12.21.20.35.59;	author rahnds;	state Exp;
branches;
next	;

1.16.2.1
date	2000.03.24.09.08.43;	author niklas;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2001.05.14.21.36.58;	author niklas;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2001.07.04.10.23.03;	author niklas;	state Exp;
branches;
next	1.16.2.4;

1.16.2.4
date	2001.10.31.03.07.56;	author nate;	state Exp;
branches;
next	1.16.2.5;

1.16.2.5
date	2001.11.13.21.04.16;	author niklas;	state Exp;
branches;
next	1.16.2.6;

1.16.2.6
date	2001.11.13.22.14.34;	author niklas;	state dead;
branches;
next	1.16.2.7;

1.16.2.7
date	2002.03.29.19.46.01;	author niklas;	state Exp;
branches;
next	1.16.2.8;

1.16.2.8
date	2003.03.27.23.42.35;	author niklas;	state Exp;
branches;
next	1.16.2.9;

1.16.2.9
date	2004.02.19.10.49.57;	author niklas;	state Exp;
branches;
next	;

1.33.2.1
date	2001.11.13.17.45.27;	author jason;	state Exp;
branches;
next	;

1.41.2.1
date	2002.01.31.22.55.21;	author niklas;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2002.06.11.03.37.28;	author art;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2002.10.29.00.28.09;	author art;	state Exp;
branches;
next	1.41.2.4;

1.41.2.4
date	2003.05.19.21.49.44;	author tedu;	state Exp;
branches;
next	;

1.64.2.1
date	2005.06.05.01.56.56;	author brad;	state Exp;
branches;
next	;

1.65.2.1
date	2005.06.11.02.31.36;	author brad;	state Exp;
branches;
next	;

1.72.2.1
date	2007.04.26.23.56.01;	author ckuethe;	state Exp;
branches;
next	;

1.72.4.1
date	2007.04.26.23.56.59;	author ckuethe;	state Exp;
branches;
next	;

1.73.2.1
date	2007.04.28.01.12.10;	author ckuethe;	state Exp;
branches;
next	;


desc
@@


1.106
log
@fix an uninitialised variable on altivec assist trap
ok krw@@ kettenis@@
@
text
@/*	$OpenBSD: trap.c,v 1.105 2015/07/29 18:52:44 miod Exp $	*/
/*	$NetBSD: trap.c,v 1.3 1996/10/13 03:31:37 christos Exp $	*/

/*
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <sys/param.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/reboot.h>
#include <sys/systm.h>
#include <sys/user.h>
#include <sys/pool.h>
#include <sys/syscall.h>
#include <sys/syscall_mi.h>

#include <dev/cons.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/fpu.h>
#include <machine/frame.h>
#include <machine/pcb.h>
#include <machine/psl.h>
#include <machine/trap.h>
#include <machine/db_machdep.h>

#include <ddb/db_extern.h>
#include <ddb/db_sym.h>
#include <ddb/db_output.h>

static int fix_unaligned(struct proc *p, struct trapframe *frame);
int badaddr(char *addr, u_int32_t len);
void trap(struct trapframe *frame);

/* These definitions should probably be somewhere else				XXX */
#define	FIRSTARG	3		/* first argument is in reg 3 */
#define	NARGREG		8		/* 8 args are in registers */
#define	MOREARGS(sp)	((caddr_t)((int)(sp) + 8)) /* more args go here */

#ifdef ALTIVEC
/*
 * Save state of the vector processor, This is done lazily in the hope
 * that few processes in the system will be using the vector unit
 * and that the exception time taken to switch them will be less than
 * the necessary time to save the vector on every context switch.
 *
 * Also note that in this version, the VRSAVE register is saved with
 * the state of the current process holding the vector processor,
 * and the contents of that register are not used to optimize the save.
 *
 * This can lead to VRSAVE corruption, data passing between processes,
 * because this register is accessable without the MSR[VEC] bit set.
 * To store/restore this cleanly a processor identifier bit would need
 * to be saved and this register saved on every context switch.
 * Since we do not use the information, we may be able to get by
 * with not saving it rigorously.
 */
void
save_vec(struct proc *p)
{
	struct pcb *pcb = &p->p_addr->u_pcb;
	struct vreg *pcb_vr = pcb->pcb_vr;
	u_int32_t oldmsr, msr;

	/* first we enable vector so that we dont throw an exception
	 * in kernel mode
	 */
	oldmsr = ppc_mfmsr();
	msr = (oldmsr & ~PSL_EE) | PSL_VEC;
	ppc_mtmsr(msr);
	__asm__ volatile ("sync;isync");

	pcb->pcb_vr->vrsave = ppc_mfvrsave();

#define STR(x) #x
#define SAVE_VEC_REG(reg, addr)   \
	__asm__ volatile ("stvxl %0, 0, %1" :: "n"(reg),"r" (addr));

	SAVE_VEC_REG(0,&pcb_vr->vreg[0]);
	SAVE_VEC_REG(1,&pcb_vr->vreg[1]);
	SAVE_VEC_REG(2,&pcb_vr->vreg[2]);
	SAVE_VEC_REG(3,&pcb_vr->vreg[3]);
	SAVE_VEC_REG(4,&pcb_vr->vreg[4]);
	SAVE_VEC_REG(5,&pcb_vr->vreg[5]);
	SAVE_VEC_REG(6,&pcb_vr->vreg[6]);
	SAVE_VEC_REG(7,&pcb_vr->vreg[7]);
	SAVE_VEC_REG(8,&pcb_vr->vreg[8]);
	SAVE_VEC_REG(9,&pcb_vr->vreg[9]);
	SAVE_VEC_REG(10,&pcb_vr->vreg[10]);
	SAVE_VEC_REG(11,&pcb_vr->vreg[11]);
	SAVE_VEC_REG(12,&pcb_vr->vreg[12]);
	SAVE_VEC_REG(13,&pcb_vr->vreg[13]);
	SAVE_VEC_REG(14,&pcb_vr->vreg[14]);
	SAVE_VEC_REG(15,&pcb_vr->vreg[15]);
	SAVE_VEC_REG(16,&pcb_vr->vreg[16]);
	SAVE_VEC_REG(17,&pcb_vr->vreg[17]);
	SAVE_VEC_REG(18,&pcb_vr->vreg[18]);
	SAVE_VEC_REG(19,&pcb_vr->vreg[19]);
	SAVE_VEC_REG(20,&pcb_vr->vreg[20]);
	SAVE_VEC_REG(21,&pcb_vr->vreg[21]);
	SAVE_VEC_REG(22,&pcb_vr->vreg[22]);
	SAVE_VEC_REG(23,&pcb_vr->vreg[23]);
	SAVE_VEC_REG(24,&pcb_vr->vreg[24]);
	SAVE_VEC_REG(25,&pcb_vr->vreg[25]);
	SAVE_VEC_REG(26,&pcb_vr->vreg[26]);
	SAVE_VEC_REG(27,&pcb_vr->vreg[27]);
	SAVE_VEC_REG(28,&pcb_vr->vreg[28]);
	SAVE_VEC_REG(29,&pcb_vr->vreg[29]);
	SAVE_VEC_REG(30,&pcb_vr->vreg[30]);
	SAVE_VEC_REG(31,&pcb_vr->vreg[31]);
	__asm__ volatile ("mfvscr 0");
	SAVE_VEC_REG(0,&pcb_vr->vscr);

	curcpu()->ci_vecproc = NULL;
	pcb->pcb_veccpu = NULL;

	/* fix kernel msr back */
	ppc_mtmsr(oldmsr);
}

/*
 * Copy the context of a given process into the vector registers.
 */
void
enable_vec(struct proc *p)
{
	struct pcb *pcb = &p->p_addr->u_pcb;
	struct vreg *pcb_vr = pcb->pcb_vr;
	struct cpu_info *ci = curcpu();
	u_int32_t oldmsr, msr;

	/* If this is the very first altivec instruction executed
	 * by this process, create a context.
	 */
	if (pcb->pcb_vr == NULL)
		pcb->pcb_vr = pool_get(&ppc_vecpl, PR_WAITOK | PR_ZERO);

	if (curcpu()->ci_vecproc != NULL || pcb->pcb_veccpu != NULL)
		printf("attempting to restore vector in use vecproc %p"
		    " veccpu %p\n", curcpu()->ci_vecproc, pcb->pcb_veccpu);

	/* first we enable vector so that we dont throw an exception
	 * in kernel mode
	 */
	oldmsr = ppc_mfmsr();
	msr = (oldmsr & ~PSL_EE) | PSL_VEC;
	ppc_mtmsr(msr);
	__asm__ volatile ("sync;isync");
	ci->ci_vecproc = p;
	pcb->pcb_veccpu = ci;

#define LOAD_VEC_REG(reg, addr)   \
	__asm__ volatile ("lvxl %0, 0, %1" :: "n"(reg), "r" (addr));

	LOAD_VEC_REG(0, &pcb_vr->vscr);
	__asm__ volatile ("mtvscr 0");
	ppc_mtvrsave(pcb_vr->vrsave);

	LOAD_VEC_REG(0, &pcb_vr->vreg[0]);
	LOAD_VEC_REG(1, &pcb_vr->vreg[1]);
	LOAD_VEC_REG(2, &pcb_vr->vreg[2]);
	LOAD_VEC_REG(3, &pcb_vr->vreg[3]);
	LOAD_VEC_REG(4, &pcb_vr->vreg[4]);
	LOAD_VEC_REG(5, &pcb_vr->vreg[5]);
	LOAD_VEC_REG(6, &pcb_vr->vreg[6]);
	LOAD_VEC_REG(7, &pcb_vr->vreg[7]);
	LOAD_VEC_REG(8, &pcb_vr->vreg[8]);
	LOAD_VEC_REG(9, &pcb_vr->vreg[9]);
	LOAD_VEC_REG(10, &pcb_vr->vreg[10]);
	LOAD_VEC_REG(11, &pcb_vr->vreg[11]);
	LOAD_VEC_REG(12, &pcb_vr->vreg[12]);
	LOAD_VEC_REG(13, &pcb_vr->vreg[13]);
	LOAD_VEC_REG(14, &pcb_vr->vreg[14]);
	LOAD_VEC_REG(15, &pcb_vr->vreg[15]);
	LOAD_VEC_REG(16, &pcb_vr->vreg[16]);
	LOAD_VEC_REG(17, &pcb_vr->vreg[17]);
	LOAD_VEC_REG(18, &pcb_vr->vreg[18]);
	LOAD_VEC_REG(19, &pcb_vr->vreg[19]);
	LOAD_VEC_REG(20, &pcb_vr->vreg[20]);
	LOAD_VEC_REG(21, &pcb_vr->vreg[21]);
	LOAD_VEC_REG(22, &pcb_vr->vreg[22]);
	LOAD_VEC_REG(23, &pcb_vr->vreg[23]);
	LOAD_VEC_REG(24, &pcb_vr->vreg[24]);
	LOAD_VEC_REG(25, &pcb_vr->vreg[25]);
	LOAD_VEC_REG(26, &pcb_vr->vreg[26]);
	LOAD_VEC_REG(27, &pcb_vr->vreg[27]);
	LOAD_VEC_REG(28, &pcb_vr->vreg[28]);
	LOAD_VEC_REG(29, &pcb_vr->vreg[29]);
	LOAD_VEC_REG(30, &pcb_vr->vreg[30]);
	LOAD_VEC_REG(31, &pcb_vr->vreg[31]);

	/* fix kernel msr back */
	ppc_mtmsr(oldmsr);
}
#endif /* ALTIVEC */

void
trap(struct trapframe *frame)
{
	struct cpu_info *ci = curcpu();
	struct proc *p = curproc;
	int type = frame->exc;
	union sigval sv;
	char *name;
	db_expr_t offset;

	if (frame->srr1 & PSL_PR) {
		type |= EXC_USER;
		refreshcreds(p);
	}

	switch (type) {
	case EXC_TRC|EXC_USER:		
		{
			sv.sival_int = frame->srr0;
			KERNEL_LOCK();
			trapsignal(p, SIGTRAP, type, TRAP_TRACE, sv);
			KERNEL_UNLOCK();
		}
		break;

	case EXC_MCHK:
		{
			faultbuf *fb;

			if ((fb = p->p_addr->u_pcb.pcb_onfault)) {
				p->p_addr->u_pcb.pcb_onfault = 0;
				frame->srr0 = fb->pc;		/* PC */
				frame->fixreg[1] = fb->sp;	/* SP */
				frame->fixreg[3] = 1;		/* != 0 */
				frame->cr = fb->cr;
				bcopy(&fb->regs[0], &frame->fixreg[13], 19*4);
				return;
			}
		}
		goto brain_damage;

	case EXC_DSI:
		{
			struct vm_map *map;
			vaddr_t va;
			int ftype;
			faultbuf *fb;
			
			map = kernel_map;
			va = frame->dar;
			if ((va >> ADDR_SR_SHIFT) == PPC_USER_SR) {
				sr_t user_sr;
				
				asm ("mfsr %0, %1"
				     : "=r"(user_sr) : "K"(PPC_USER_SR));
				va &= ADDR_PIDX | ADDR_POFF;
				va |= user_sr << ADDR_SR_SHIFT;
				map = &p->p_vmspace->vm_map;
				if (pte_spill_v(map->pmap, va, frame->dsisr, 0))
					return;
			}
			if (frame->dsisr & DSISR_STORE)
				ftype = PROT_READ | PROT_WRITE;
			else
				ftype = PROT_READ;
			KERNEL_LOCK();
			if (uvm_fault(map, trunc_page(va), 0, ftype) == 0) {
				KERNEL_UNLOCK();
				return;
			}
			KERNEL_UNLOCK();

			if ((fb = p->p_addr->u_pcb.pcb_onfault)) {
				p->p_addr->u_pcb.pcb_onfault = 0;
				frame->srr0 = fb->pc;		/* PC */
				frame->fixreg[1] = fb->sp;	/* SP */
				frame->fixreg[3] = 1;		/* != 0 */
				frame->cr = fb->cr;
				bcopy(&fb->regs[0], &frame->fixreg[13], 19*4);
				return;
			}
			map = kernel_map;
		}
printf("kern dsi on addr %x iar %x\n", frame->dar, frame->srr0);
		goto brain_damage;
	case EXC_DSI|EXC_USER:
		{
			int ftype, vftype;
			
			/* Try spill handler first */
			if (pte_spill_v(p->p_vmspace->vm_map.pmap,
			    frame->dar, frame->dsisr, 0))
				break;

			KERNEL_LOCK();
			if (frame->dsisr & DSISR_STORE) {
				ftype = PROT_READ | PROT_WRITE;
				vftype = PROT_WRITE;
			} else
				vftype = ftype = PROT_READ;
			if (uvm_fault(&p->p_vmspace->vm_map,
				     trunc_page(frame->dar), 0, ftype) == 0) {
				uvm_grow(p, trunc_page(frame->dar));
				KERNEL_UNLOCK();
				break;
			}

#if 0
printf("dsi on addr %x iar %x lr %x\n", frame->dar, frame->srr0,frame->lr);
#endif
/*
 * keep this for later in case we want it later.
*/
			sv.sival_int = frame->dar;
			trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR, sv);
			KERNEL_UNLOCK();
		}
		break;
	case EXC_ISI|EXC_USER:
		{
			int ftype;
			
			/* Try spill handler */
			if (pte_spill_v(p->p_vmspace->vm_map.pmap,
			    frame->srr0, 0, 1))
				break;

			KERNEL_LOCK();
			ftype = PROT_READ | PROT_EXEC;
			if (uvm_fault(&p->p_vmspace->vm_map,
			    trunc_page(frame->srr0), 0, ftype) == 0) {
				uvm_grow(p, trunc_page(frame->srr0));
				KERNEL_UNLOCK();
				break;
			}
			KERNEL_UNLOCK();
		}
#if 0
printf("isi iar %x lr %x\n", frame->srr0, frame->lr);
#endif
		/* FALLTHROUGH */
	case EXC_MCHK|EXC_USER:
/* XXX Likely that returning from this trap is bogus... */
/* XXX Have to make sure that sigreturn does the right thing. */
		sv.sival_int = frame->srr0;
		KERNEL_LOCK();
		trapsignal(p, SIGSEGV, PROT_EXEC, SEGV_MAPERR, sv);
		KERNEL_UNLOCK();
		break;
	case EXC_SC|EXC_USER:
		{
			struct sysent *callp;
			size_t argsize;
			register_t code, error;
			register_t *params, rval[2];
			int nsys, n;
			register_t args[10];
			
			uvmexp.syscalls++;
			
			nsys = p->p_p->ps_emul->e_nsysent;
			callp = p->p_p->ps_emul->e_sysent;
			
			code = frame->fixreg[0];
			params = frame->fixreg + FIRSTARG;
			
			switch (code) {
			case SYS_syscall:
				/*
				 * code is first argument,
				 * followed by actual args.
				 */
				code = *params++;
				break;
			case SYS___syscall:
				/*
				 * Like syscall, but code is a quad,
				 * so as to maintain quad alignment
				 * for the rest of the args.
				 */
				if (callp != sysent)
					break;
				params++;
				code = *params++;
				break;
			default:
				break;
			}
			if (code < 0 || code >= nsys)
				callp += p->p_p->ps_emul->e_nosys;
			else
				callp += code;
			argsize = callp->sy_argsize;
			n = NARGREG - (params - (frame->fixreg + FIRSTARG));
			if (argsize > n * sizeof(register_t)) {
				bcopy(params, args, n * sizeof(register_t));

				if ((error = copyin(MOREARGS(frame->fixreg[1]),
				   args + n,
				   argsize - n * sizeof(register_t))))
					goto bad;
				params = args;
			}

			rval[0] = 0;
			rval[1] = frame->fixreg[FIRSTARG + 1];

			error = mi_syscall(p, code, callp, params, rval);

			switch (error) {
			case 0:
				frame->fixreg[0] = error;
				frame->fixreg[FIRSTARG] = rval[0];
				frame->fixreg[FIRSTARG + 1] = rval[1];
				frame->cr &= ~0x10000000;
				break;
			case ERESTART:
				/*
				 * Set user's pc back to redo the system call.
				 */
				frame->srr0 -= 4;
				break;
			case EJUSTRETURN:
				/* nothing to do */
				break;
			default:
			bad:
				frame->fixreg[0] = error;
				frame->fixreg[FIRSTARG] = error;
				frame->fixreg[FIRSTARG + 1] = rval[1];
				frame->cr |= 0x10000000;
				break;
			}

			mi_syscall_return(p, code, error, rval);
			goto finish;
		}

	case EXC_FPU|EXC_USER:
		if (ci->ci_fpuproc)
			save_fpu();
		uvmexp.fpswtch++;
		enable_fpu(p);
		break;

	case EXC_ALI|EXC_USER:
		/* alignment exception 
		 * we check to see if this can be fixed up
		 * by the code that fixes the typical gcc misaligned code
		 * then kill the process if not.
		 */
		if (fix_unaligned(p, frame) == 0)
			frame->srr0 += 4;
		else {
			sv.sival_int = frame->srr0;
			KERNEL_LOCK();
			trapsignal(p, SIGBUS, PROT_EXEC, BUS_ADRALN,
				sv);
			KERNEL_UNLOCK();
		}
		break;

	default:
	
brain_damage:
/*
mpc_print_pci_stat();
*/

#ifdef DDB
		/* set up registers */
		db_save_regs(frame);
		db_find_sym_and_offset(frame->srr0, &name, &offset);
#else
		name = NULL;
#endif
		if (!name) {
			name = "0";
			offset = frame->srr0;
		}
		panic ("trap type %x at %x (%s+0x%lx) lr %lx",
			type, frame->srr0, name, offset, frame->lr);


	case EXC_PGM|EXC_USER:
	{
#if 0
		char *errstr[8];
		int errnum = 0;

		if (frame->srr1 & (1<<(31-11))) { 
			/* floating point enabled program exception */
			errstr[errnum] = "floating point";
			errnum++;
		} 
		if (frame->srr1 & (1<<(31-12))) {
			/* illegal instruction program exception */
			errstr[errnum] = "illegal instruction";
			errnum++;
		}
		if (frame->srr1 & (1<<(31-13))) {
			/* privileged instruction exception */
			errstr[errnum] = "privileged instr";
			errnum++;
		}
#endif
		if (frame->srr1 & (1<<(31-14))) {
#if 0
			errstr[errnum] = "trap instr";
			errnum++;
#endif
			sv.sival_int = frame->srr0;
			KERNEL_LOCK();
			trapsignal(p, SIGTRAP, type, TRAP_BRKPT, sv);
			KERNEL_UNLOCK();
			break;
		}
#if 0
		if (frame->srr1 & (1<<(31-15))) {
			errstr[errnum] = "previous address";
			errnum++;
		}
#endif
#if 0
printf("pgm iar %x srr1 %x\n", frame->srr0, frame->srr1);
{ 
int i;
for (i = 0; i < errnum; i++) {
	printf("\t[%s]\n", errstr[i]);
}
}
#endif
		sv.sival_int = frame->srr0;
		KERNEL_LOCK();
		trapsignal(p, SIGILL, 0, ILL_ILLOPC, sv);
		KERNEL_UNLOCK();
		break;
	}
	case EXC_PGM:
		/* should check for correct byte here or panic */
#ifdef DDB
		db_save_regs(frame);
		cnpollc(TRUE);
		db_trap(T_BREAKPOINT, 0);
		cnpollc(FALSE);
#else
		panic("trap EXC_PGM");
#endif
		break;

	/* This is not really a perf exception, but is an ALTIVEC unavail
	 * if we do not handle it, kill the process with illegal instruction.
	 */
	case EXC_PERF|EXC_USER:
#ifdef ALTIVEC 
	case EXC_VEC|EXC_USER:
		if (ci->ci_vecproc)
			save_vec(ci->ci_vecproc);

		enable_vec(p);
		break;
#else  /* ALTIVEC */
		sv.sival_int = frame->srr0;
		KERNEL_LOCK();
		trapsignal(p, SIGILL, 0, ILL_ILLOPC, sv);
		KERNEL_UNLOCK();
		break;
#endif

	case EXC_VECAST|EXC_USER:
		sv.sival_int = frame->srr0;
		KERNEL_LOCK();
		trapsignal(p, SIGFPE, 0, FPE_FLTRES, sv);
		KERNEL_UNLOCK();
		break;

	case EXC_AST|EXC_USER:
		p->p_md.md_astpending = 0;	/* we are about to do it */
		uvmexp.softs++;
		mi_ast(p, ci->ci_want_resched);
		break;
	}

	userret(p);

finish:
	/*
	 * If someone stole the fpu while we were away, disable it
	 */
	if (p != ci->ci_fpuproc)
		frame->srr1 &= ~PSL_FP;
	else if (p->p_addr->u_pcb.pcb_flags & PCB_FPU)
		frame->srr1 |= PSL_FP;

#ifdef ALTIVEC
	/*
	 * If someone stole the vector unit while we were away, disable it
	 */
	if (p == ci->ci_vecproc)
		frame->srr1 |= PSL_VEC;
	else 
		frame->srr1 &= ~PSL_VEC;
#endif /* ALTIVEC */
}

void
child_return(void *arg)
{
	struct proc *p = (struct proc *)arg;
	struct trapframe *tf = trapframe(p);

	tf->fixreg[0] = 0;
	tf->fixreg[FIRSTARG] = 0;
	tf->fixreg[FIRSTARG + 1] = 1;
	tf->cr &= ~0x10000000;
	/* Disable FPU, VECT, as we can't be fpuproc */
	tf->srr1 &= ~(PSL_FP|PSL_VEC);

	KERNEL_UNLOCK();

	mi_child_return(p);
}

int
badaddr(char *addr, u_int32_t len)
{
	faultbuf env;
	u_int32_t v;
	void *oldh = curpcb->pcb_onfault;

	if (setfault(&env)) {
		curpcb->pcb_onfault = oldh;
		return EFAULT;
	}
	switch(len) {
	case 4:
		v = *((volatile u_int32_t *)addr);
		break;
	case 2:
		v = *((volatile u_int16_t *)addr);
		break;
	default:
		v = *((volatile u_int8_t *)addr);
		break;
	}
	/* Make sure all loads retire before turning off fault handling!! */
	__asm__ volatile ("sync");
	curpcb->pcb_onfault = oldh;
	return(0);
}


/*
 * For now, this only deals with the particular unaligned access case
 * that gcc tends to generate.  Eventually it should handle all of the
 * possibilities that can happen on a 32-bit PowerPC in big-endian mode.
 */

static int
fix_unaligned(struct proc *p, struct trapframe *frame)
{
	int indicator = EXC_ALI_OPCODE_INDICATOR(frame->dsisr);
	struct cpu_info *ci = curcpu();

	switch (indicator) {
	case EXC_ALI_LFD:
	case EXC_ALI_STFD:
		{
			int reg = EXC_ALI_RST(frame->dsisr);
			double *fpr = &p->p_addr->u_pcb.pcb_fpu.fpr[reg];

			/* Juggle the FPU to ensure that we've initialized
			 * the FPRs, and that their current state is in
			 * the PCB.
			 */
			if (ci->ci_fpuproc != p) {
				if (ci->ci_fpuproc)
					save_fpu();
				enable_fpu(p);
			}
			save_fpu();

			if (indicator == EXC_ALI_LFD) {
				if (copyin((void *)frame->dar, fpr,
				    sizeof(double)) != 0)
					return -1;
			} else {
				if (copyout(fpr, (void *)frame->dar,
				    sizeof(double)) != 0)
					return -1;
			}
			enable_fpu(p);
			return 0;
		}
		break;
	}
	return -1;
}
@


1.105
log
@17 years ago, setfault() was modified to save the status register in the
faultbuf. But 1/ sr was only restored for machine check exceptions, and 2/ the
way it was saved was unsafe if interrupts were enabled, and could cause %r2
to be lost.

Discussing this with deraadt@@ at the end of c2k15, this was probably needed
for the old VI boards which were the target of the original powerpc port,
came with a worse-than-Genesi openfirmware. Since then, machine check
exceptions have been unheard of; or, if they happen, they do not need the
status register to be restored.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.104 2015/04/29 04:43:25 jsg Exp $	*/
d596 1
@


1.104
log
@Remove a check for NULL that would have been after a NULL dereference
if callers of save_vec() weren't expected to pass a non NULL pointer
as an argument.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.103 2014/11/16 12:30:58 deraadt Exp $	*/
a257 1
				frame->srr1 = fb->sr;		/* SR */
@


1.103
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.102 2014/09/06 09:42:23 mpi Exp $	*/
a92 3

	if (p == NULL)
		return;
@


1.102
log
@Rewrite the PowerPC stack dump routine to delimit the trap & interrupt
contexts with markers (---like on x86---) and print the associated type
or number when available.

While here, gyp' the support for process tracing (tr /p).

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.101 2014/07/09 08:32:57 deraadt Exp $	*/
d292 1
a292 1
				ftype = VM_PROT_READ | VM_PROT_WRITE;
d294 1
a294 1
				ftype = VM_PROT_READ;
d326 2
a327 2
				ftype = VM_PROT_READ | VM_PROT_WRITE;
				vftype = VM_PROT_WRITE;
d329 1
a329 1
				vftype = ftype = VM_PROT_READ;
d358 1
a358 1
			ftype = VM_PROT_READ | VM_PROT_EXECUTE;
d376 1
a376 1
		trapsignal(p, SIGSEGV, VM_PROT_EXECUTE, SEGV_MAPERR, sv);
d486 1
a486 1
			trapsignal(p, SIGBUS, VM_PROT_EXECUTE, BUS_ADRALN,
@


1.101
log
@pull in uvm/uvm_extern.h (before and) and instead pmap.h, and do not assume
that user.h's tentacles fetched it even earlier.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.100 2014/05/11 00:12:44 guenther Exp $	*/
a67 15

#ifdef DDB
void ppc_dumpbt(struct trapframe *frame);

void
ppc_dumpbt(struct trapframe *frame)
{
	u_int32_t addr;
	/* dumpframe is defined in db_trace.c */
	addr=frame->fixreg[1];
	while (addr != 0)
		addr = db_dumpframe(addr, db_printf);
	return;
}
#endif
@


1.100
log
@Move the increment of uvmexp.softs back to the caller of mi_ast():
it needs to be done atomicly on some MP archs and we don't have
atomic_add_int() everywhere yet.  Also, mi_ast() was meant to be inline.

noted by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.99 2014/05/10 16:48:36 deraadt Exp $	*/
d46 2
a51 1
#include <machine/pmap.h>
a54 2

#include <uvm/uvm_extern.h>
@


1.99
log
@bring things syscall_mi.h needs into scope earlier
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.98 2014/05/10 05:33:00 guenther Exp $	*/
d623 1
@


1.98
log
@Factor out the common ast bits into mi_ast()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.97 2014/05/09 18:16:15 miod Exp $	*/
a37 2
#include <sys/syscall.h>
#include <sys/syscall_mi.h>
d41 2
@


1.97
log
@Format string fixes and removal of -Wno-format for *ppc kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.96 2014/04/18 11:51:17 guenther Exp $	*/
a621 1
		uvmexp.softs++;
d623 1
a623 7
		if (p->p_flag & P_OWEUPC) {
			KERNEL_LOCK();
			ADDUPROF(p);
			KERNEL_UNLOCK();
		}
		if (ci->ci_want_resched)
			preempt(NULL);
@


1.96
log
@Have each thread keeps its own (counted!) reference to the process's ucreds
to avoid possible use-after-free references when swapping ids in threaded
processes.  "Do I have the right creds?" checks are always made with the
threads creds.

Inspired by FreeBSD and NetBSD
"right time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.95 2014/03/26 05:23:42 guenther Exp $	*/
d187 2
a188 2
		printf("attempting to restore vector in use vecproc %x"
		    " veccpu %x\n", curcpu()->ci_vecproc, pcb->pcb_veccpu);
d526 1
a526 1
		panic ("trap type %x at %x (%s+0x%lx) lr %x",
@


1.95
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.94 2012/12/31 06:46:13 guenther Exp $	*/
d257 1
@


1.94
log
@Remove emulation errno mapping code from platforms that no longer have
non-native emulations.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.93 2012/08/08 04:11:08 miod Exp $	*/
d405 2
a406 2
			nsys = p->p_emul->e_nsysent;
			callp = p->p_emul->e_sysent;
d434 1
a434 1
				callp += p->p_emul->e_nosys;
@


1.93
log
@Make this compile again.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.92 2012/08/07 17:17:46 guenther Exp $	*/
a471 2
				if (p->p_emul->e_errno)
					error = p->p_emul->e_errno[error];
@


1.92
log
@<sys/ktrace.h> is now pulled in via <sys/syscall_mi.h>, so drop it from here
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.91 2012/08/07 05:16:54 guenther Exp $	*/
d400 1
a400 1
			int nsys, n, nolock;
@


1.91
log
@Move the common bits of syscall invocation and return handling into
an MI file, <sys/syscall_mi.h>, correcting inconsistencies and the
handling when copyin() of arguments fails.

Tested on i386, amd64, sparc64, and alpha (thanks naddy@@)
Any issues with other platforms will be fixed in tree.

header name from millert@@; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.90 2012/04/11 14:38:55 mikeb Exp $	*/
a41 1
#include <sys/ktrace.h>
@


1.90
log
@The first ktrace record for a newly spawned thread is a return
from a fork syscall done by the parent.  Use __tfork, not rfork
here to match the ktrace records for the parent (CALL __tfork,
RET __tfork).  ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.89 2011/11/16 20:50:19 deraadt Exp $	*/
d39 1
a55 3
#include "systrace.h"
#include <dev/systrace.h>

d443 4
a446 11
				error = copyin(MOREARGS(frame->fixreg[1]),
				   args + n, argsize - n * sizeof(register_t));
				if (error) {
#ifdef	KTRACE
					/* Can't get all the arguments! */
					if (KTRPOINT(p, KTR_SYSCALL))
						ktrsyscall(p, code,
							   argsize, args);
#endif
					goto syscall_bad;
				}
a449 7
#ifdef	KTRACE
			if (KTRPOINT(p, KTR_SYSCALL)) {
				KERNEL_LOCK();
				ktrsyscall(p, code, argsize, params);
				KERNEL_UNLOCK();
			}
#endif
d453 1
a453 5
#ifdef SYSCALL_DEBUG
			KERNEL_LOCK();
			scdebug_call(p, code, params);
			KERNEL_UNLOCK();
#endif
a454 17
			
#if NSYSTRACE > 0
			if (ISSET(p->p_flag, P_SYSTRACE)) {
				KERNEL_LOCK();
				error = systrace_redirect(code, p, params,
				    rval);
				KERNEL_UNLOCK();
			} else
#endif
			{
				nolock = (callp->sy_flags & SY_NOLOCK);
				if (!nolock)
					KERNEL_LOCK();
				error = (*callp->sy_call)(p, params, rval);
				if (!nolock)
					KERNEL_UNLOCK();
			}
d472 1
a472 1
syscall_bad:
d481 3
a483 12
#ifdef SYSCALL_DEBUG
			KERNEL_LOCK();
			scdebug_ret(p, code, error, rval); 
			KERNEL_UNLOCK();
#endif  
#ifdef	KTRACE
			if (KTRPOINT(p, KTR_SYSRET)) {
				KERNEL_LOCK();
				ktrsysret(p, code, error, rval[0]);
				KERNEL_UNLOCK();
			}
#endif
a484 1
		break;
d638 1
d673 1
a673 12
	userret(p);

#ifdef	KTRACE
	if (KTRPOINT(p, KTR_SYSRET)) {
		KERNEL_LOCK();
		ktrsysret(p,
		    (p->p_flag & P_THREAD) ? SYS___tfork :
		    (p->p_p->ps_flags & PS_PPWAIT) ? SYS_vfork : SYS_fork,
		    0, 0);
		KERNEL_UNLOCK();
	}
#endif
@


1.89
log
@Make userret() MI.  On architectures which jammed stuff into it in the
past, pull that code out seperately.
ok guenther miod
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.88 2011/07/30 20:50:47 deraadt Exp $	*/
d725 1
a725 1
		    (p->p_flag & P_THREAD) ? SYS_rfork :
@


1.88
log
@Send SIGBUS instead of SIGSEGV for unaligned access which is not emulated
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.87 2011/07/11 15:40:47 guenther Exp $	*/
a65 1
static __inline void userret(struct proc *);
a246 11

static __inline void
userret(struct proc *p)
{
	int sig;

	/* take pending signals */
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);
	curcpu()->ci_schedstate.spc_curpriority = p->p_priority;
}
@


1.87
log
@Revert art@@'s moving around of the KERNEL_LOCK()/KERNEL_UNLOCK() calls,
as it causes hangs in some ports, including libsigsegv's configure script

confirmed by krw@@, landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.85 2011/07/06 21:41:37 art Exp $	*/
d563 1
a563 1
			trapsignal(p, SIGSEGV, VM_PROT_EXECUTE, SEGV_MAPERR,
@


1.86
log
@There is a bunch of places in the kernel entry points where we don't
hold the kernel lock, but still need call one function that needs it.

Instead of grabbing the lock all over the place, move the locks into
the affected functions: trapsignal, scdebug*, ktrsyscall, ktrsysret,
systrace_redirect and ADDUPROF. In the cases we already hold the biglock
we'll just recurse.

kettenis@@, beck@@ ok
@
text
@d278 1
d280 1
d405 1
d407 1
d473 1
d475 1
d482 1
d484 1
d490 1
d493 1
d531 1
d533 1
d537 1
d539 1
d562 1
d565 1
d619 1
d621 1
d640 1
d642 1
d670 1
d672 1
d677 1
d679 1
d686 1
d688 1
d735 1
d740 1
@


1.85
log
@Clean up after P_BIGLOCK removal.
KERNEL_PROC_LOCK -> KERNEL_LOCK
KERNEL_PROC_UNLOCK -> KERNEL_UNLOCK

oga@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.84 2011/04/03 14:56:28 guenther Exp $	*/
a277 1
			KERNEL_LOCK();
a278 1
			KERNEL_UNLOCK();
a402 1
		KERNEL_LOCK();
a403 1
		KERNEL_UNLOCK();
a468 1
				KERNEL_LOCK();
a469 1
				KERNEL_UNLOCK();
a475 1
			KERNEL_LOCK();
a476 1
			KERNEL_UNLOCK();
a481 1
				KERNEL_LOCK();
a483 1
				KERNEL_UNLOCK();
a520 1
			KERNEL_LOCK();
a521 1
			KERNEL_UNLOCK();
a524 1
				KERNEL_LOCK();
a525 1
				KERNEL_UNLOCK();
a547 1
			KERNEL_LOCK();
a549 1
			KERNEL_UNLOCK();
a602 1
			KERNEL_LOCK();
a603 1
			KERNEL_UNLOCK();
a621 1
		KERNEL_LOCK();
a622 1
		KERNEL_UNLOCK();
a649 1
		KERNEL_LOCK();
a650 1
		KERNEL_UNLOCK();
a654 1
		KERNEL_LOCK();
a655 1
		KERNEL_UNLOCK();
a661 1
			KERNEL_LOCK();
a662 1
			KERNEL_UNLOCK();
a708 1
		KERNEL_LOCK();
a712 1
		KERNEL_UNLOCK();
@


1.84
log
@Move PPWAIT flag from struct proc to process, so that rthreads in
a vforked child behave correctly.  Have the parent in a vfork()
wait on a (different) flag in *its* process instead of the child
to prevent a possible use-after-free.  When ktracing the child
return from a fork, call it rfork if an rthread was created.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.83 2008/06/14 10:55:20 mk Exp $	*/
d278 1
a278 1
			KERNEL_PROC_LOCK(p);
d280 1
a280 1
			KERNEL_PROC_UNLOCK(p);
d354 1
a354 1
			KERNEL_PROC_LOCK(p);
d363 1
a363 1
				KERNEL_PROC_UNLOCK(p);
d375 1
a375 1
			KERNEL_PROC_UNLOCK(p);
d387 1
a387 1
			KERNEL_PROC_LOCK(p);
d392 1
a392 1
				KERNEL_PROC_UNLOCK(p);
d395 1
a395 1
			KERNEL_PROC_UNLOCK(p);
d405 1
a405 1
		KERNEL_PROC_LOCK(p);
d407 1
a407 1
		KERNEL_PROC_UNLOCK(p);
d473 1
a473 1
				KERNEL_PROC_LOCK(p);
d475 1
a475 1
				KERNEL_PROC_UNLOCK(p);
d482 1
a482 1
			KERNEL_PROC_LOCK(p);
d484 1
a484 1
			KERNEL_PROC_UNLOCK(p);
d490 1
a490 1
				KERNEL_PROC_LOCK(p);
d493 1
a493 1
				KERNEL_PROC_UNLOCK(p);
d499 1
a499 1
					KERNEL_PROC_LOCK(p);
d502 1
a502 1
					KERNEL_PROC_UNLOCK(p);
d531 1
a531 1
			KERNEL_PROC_LOCK(p);
d533 1
a533 1
			KERNEL_PROC_UNLOCK(p);
d537 1
a537 1
				KERNEL_PROC_LOCK(p);
d539 1
a539 1
				KERNEL_PROC_UNLOCK(p);
d562 1
a562 1
			KERNEL_PROC_LOCK(p);
d565 1
a565 1
			KERNEL_PROC_UNLOCK(p);
d619 1
a619 1
			KERNEL_PROC_LOCK(p);
d621 1
a621 1
			KERNEL_PROC_UNLOCK(p);
d640 1
a640 1
		KERNEL_PROC_LOCK(p);
d642 1
a642 1
		KERNEL_PROC_UNLOCK(p);
d670 1
a670 1
		KERNEL_PROC_LOCK(p);
d672 1
a672 1
		KERNEL_PROC_UNLOCK(p);
d677 1
a677 1
		KERNEL_PROC_LOCK(p);
d679 1
a679 1
		KERNEL_PROC_UNLOCK(p);
d686 1
a686 1
			KERNEL_PROC_LOCK(p);
d688 1
a688 1
			KERNEL_PROC_UNLOCK(p);
d729 1
a729 1
	KERNEL_PROC_UNLOCK(p);
d735 1
a735 1
		KERNEL_PROC_LOCK(p);
d740 1
a740 1
		KERNEL_PROC_UNLOCK(p);
@


1.83
log
@A bunch of pool_get() + bzero() -> pool_get(..., .. | PR_ZERO)
conversions that should shave a few bytes off the kernel.

ok henning, krw, jsing, oga, miod, and thib (``even though i usually prefer
FOO|BAR''; thanks for looking.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.82 2008/05/03 17:27:04 miod Exp $	*/
d737 3
a739 1
		    (p->p_flag & P_PPWAIT) ? SYS_vfork : SYS_fork, 0, 0);
@


1.82
log
@Do not acquire the kernel lock for SY_NOLOCK system calls; ok drahn@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.81 2008/04/27 16:01:47 drahn Exp $	*/
d187 2
a188 4
	if (pcb->pcb_vr == NULL) {
		pcb->pcb_vr = pool_get(&ppc_vecpl, PR_WAITOK);
		bzero(pcb->pcb_vr, sizeof *(pcb->pcb_vr));
	}
@


1.81
log
@FPU/Altivec cleanup and prep for SMP.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.80 2008/04/27 15:59:49 drahn Exp $	*/
d417 1
a417 1
			int nsys, n;
a472 1
			KERNEL_PROC_LOCK(p);
d474 2
a475 1
			if (KTRPOINT(p, KTR_SYSCALL))
d477 2
d484 1
d486 1
d491 2
a492 1
			if (ISSET(p->p_flag, P_SYSTRACE))
d495 2
a496 1
			else
d498 4
d503 3
a505 1
			KERNEL_PROC_UNLOCK(p);
@


1.80
log
@Switch to proc based ast pending for SMP. ok kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.79 2007/10/27 22:31:17 kettenis Exp $	*/
d121 1
a121 1
	msr = oldmsr | PSL_VEC;
d166 3
d181 1
d192 4
d200 1
a200 1
	msr = oldmsr | PSL_VEC;
d203 2
a655 1
		ci->ci_vecproc = p;
@


1.79
log
@Grab kernel lock for EXC_DSI.

Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.78 2007/04/26 21:36:32 kettenis Exp $	*/
d665 1
a665 1
		ci->ci_astpending = 0;		/* we are about to do it */
@


1.78
log
@Handle AltiVec Assist exceptions.  Fixes a panic when running crashme.

ok thib@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.77 2007/04/01 09:29:27 art Exp $	*/
d317 3
a319 1
			if (uvm_fault(map, trunc_page(va), 0, ftype) == 0)
d321 2
@


1.77
log
@Remove some leftovers from the userret cleanups.
No need to save sticks anymore.
miod@@ ok and test
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.76 2007/03/23 21:06:06 miod Exp $	*/
d652 6
@


1.76
log
@Define PROC_PC and simplify userret(); ok kettenis@@ (and I think drahn@@ too)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.75 2007/03/20 20:59:53 kettenis Exp $	*/
a257 1
	u_quad_t sticks;
a263 1
		sticks = p->p_sticks;
@


1.75
log
@Move macppc to __HAVE_CPUINFO, and make locore.S and trap.c suitable for
MULTIPROCESSOR.  From now on sprg0 holds a pointer to struct cpuinfo, which
is used to spill registers to during trap instead of the globals we used to
use for that purpose.  Bits and pieces from NetBSD.  Help from drahn@@ and art@@.
Tested by xsa@@, thib@@, miod@@, gwk@@, deraadt@@.

ok drahn@@, gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.74 2007/03/15 10:22:29 art Exp $	*/
d66 1
a66 1
static __inline void userret(struct proc *, int, u_quad_t);
d242 1
a242 1
userret(struct proc *p, int pc, u_quad_t oticks)
a248 11
	p->p_priority = p->p_usrpri;

	/*
	 * If profiling, charge recent system time to the trapped pc.
	 */
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, pc, (int)(p->p_sticks - oticks) * psratio);
	}

d668 1
a668 1
	userret(p, frame->srr0, sticks);
d704 1
a704 1
	userret(p, tf->srr0, 0);
@


1.74
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.73 2006/12/24 20:29:19 miod Exp $	*/
a73 4
volatile int want_resched;
struct proc *ppc_vecproc;
struct proc *fpuproc;

d260 1
a260 1
	curpriority = p->p_priority;
d266 1
d283 1
d285 1
d355 1
d364 1
d376 1
d388 1
d393 1
d396 1
d406 1
d408 1
d471 2
d492 1
d520 3
a522 1
        scdebug_ret(p, code, error, rval); 
d525 2
a526 1
			if (KTRPOINT(p, KTR_SYSRET))
d528 2
d535 1
a535 1
		if (fpuproc)
d551 1
d554 1
d608 1
d610 1
d629 1
d631 1
d652 2
a653 2
		if (ppc_vecproc)
			save_vec(ppc_vecproc);
d655 1
a655 1
		ppc_vecproc = p;
d660 1
d662 1
d668 1
a668 1
		astpending = 0;		/* we are about to do it */
d670 1
d672 1
d674 1
a674 1
		if (want_resched)
d684 1
a684 1
	if (p != fpuproc)
d693 1
a693 1
	if (p == ppc_vecproc)
d713 2
d718 2
a719 1
	if (KTRPOINT(p, KTR_SYSRET))
d722 2
d766 1
d779 2
a780 2
			if (fpuproc != p) {
				if (fpuproc)
@


1.73
log
@Check for want_resched when processing AST and nowhere else. But then, when
doing so, do not check for signals - userret() will do this.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.72 2005/12/17 07:31:27 miod Exp $	*/
a646 1
			p->p_flag &= ~P_OWEUPC;
@


1.73.2.1
log
@Handle AltiVec Assist exceptions.  Fixes a panic when running crashme.

original patch by kettenis@@
original patch ok thib@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.73 2006/12/24 20:29:19 miod Exp $	*/
a641 6

	case EXC_VECAST|EXC_USER:
		KERNEL_PROC_LOCK(p);
		trapsignal(p, SIGFPE, 0, FPE_FLTRES, sv);
		KERNEL_PROC_UNLOCK(p);
		break;
@


1.72
log
@Get rid of deprecated vm_{offset,size}_t types for good, use {p,v}{addr,size}_t
instead; looked at millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.71 2005/10/09 22:33:18 drahn Exp $	*/
a253 6
	if (want_resched) {
		/* We're being preempted.  */
		preempt(NULL);
		while ((sig = CURSIG(p)))
			postsig(sig);
	}
d645 7
a651 1
		/* This is just here that we trap */
a652 7
	}

	astpending = 0;		/* we are about to do it */

	if (p->p_flag & P_OWEUPC) {
		p->p_flag &= ~P_OWEUPC;
		ADDUPROF(p);
@


1.72.4.1
log
@MFC: Handle AltiVec Assist exceptions.  Fixes a panic when running crashme.

original diff ok thib@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.72 2005/12/17 07:31:27 miod Exp $	*/
a647 6

	case EXC_VECAST|EXC_USER:
		KERNEL_PROC_LOCK(p);
		trapsignal(p, SIGFPE, 0, FPE_FLTRES, sv);
		KERNEL_PROC_UNLOCK(p);
		break;
@


1.72.2.1
log
@MFC: Handle AltiVec Assist exceptions.  Fixes a panic when running crashme.

original diff ok thib@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.72 2005/12/17 07:31:27 miod Exp $	*/
a647 6

	case EXC_VECAST|EXC_USER:
		KERNEL_PROC_LOCK(p);
		trapsignal(p, SIGFPE, 0, FPE_FLTRES, sv);
		KERNEL_PROC_UNLOCK(p);
		break;
@


1.71
log
@unbreak altivec support.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.70 2005/10/09 14:52:12 drahn Exp $	*/
d316 1
a316 1
			vm_offset_t va;
@


1.70
log
@Subtle changes to the powerpc fpu handling, basically fpuproc is handled
in a non-raceable manner inside save_fpu and enable_fpu so that the
eventual SMP case will not grab a half loaded fpu context.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.69 2005/09/15 21:09:29 miod Exp $	*/
d676 3
a678 1
	if (p != ppc_vecproc)
@


1.69
log
@Change child_return() to record a proper ktrace record for vfork child
processes.

ok art@@ uwe@@ (some time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.68 2005/05/30 22:12:32 drahn Exp $	*/
d76 1
d527 1
a527 2
			save_fpu(fpuproc);
		fpuproc = p;
a677 2
	else
		frame->srr1 |= PSL_VEC;
d756 1
a756 1
					save_fpu(fpuproc);
d759 1
a759 1
			save_fpu(p);
a764 1
				enable_fpu(p);
d770 1
@


1.68
log
@Only enable the FPU when the process has an FPU context. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.67 2005/04/21 04:39:35 mickey Exp $	*/
d700 2
a701 1
		ktrsysret(p, SYS_fork, 0, 0);
@


1.67
log
@count fpu lazy context switches; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.66 2005/04/17 21:34:26 kettenis Exp $	*/
d669 1
a669 1
	else
@


1.66
log
@Generate SIGTRAP instead of SIGILL for breakpoint instructions.
Disable some debug code in the process.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.65 2004/12/06 20:12:25 miod Exp $	*/
d528 1
@


1.65
log
@Use uvm_grow() to account for stack growth, rather than home-grown code
or nothing.
Inspired by a similar recent change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.64 2004/08/05 20:56:24 pefo Exp $	*/
d570 1
d589 1
d591 1
d594 4
a597 10
			/* trap instruction exception */
			/*
				instr = copyin (srr0)
				if (instr == BKPT_INST && uid == 0) {
					cnpollc(TRUE);
					db_trap(T_BREAKPOINT?)
					cnpollc(FALSE);
					break;
				}
			*/
d599 1
d604 1
@


1.65.2.1
log
@MFC:
Fix by drahn@@

Only enable the FPU when the process has an FPU context.

ok deraadt@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.65 2004/12/06 20:12:25 miod Exp $	*/
d669 1
a669 1
	else if (p->p_addr->u_pcb.pcb_flags & PCB_FPU)
@


1.64
log
@When probing using badaddr make sure the probe load instruction
is retired before turning off trap handling. Otherwise a panic
trap may be taken.
OK drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.63 2004/06/24 22:35:56 drahn Exp $	*/
d367 2
a368 1
				     trunc_page(frame->dar), 0, ftype) == 0)
d370 1
d393 2
a394 1
			    trunc_page(frame->srr0), 0, ftype) == 0)
d396 1
d401 1
@


1.64.2.1
log
@MFC:
Fix by drahn@@

Only enable the FPU when the process has an FPU context.

ok deraadt@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.64 2004/08/05 20:56:24 pefo Exp $	*/
d664 1
a664 1
	else if (p->p_addr->u_pcb.pcb_flags & PCB_FPU)
@


1.63
log
@Do a better job at containing powerpc specific #defines to PPC_...
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.62 2003/12/21 15:17:32 miod Exp $	*/
d721 2
@


1.62
log
@Switch db_expr_t from int to long, per consistency with all other arches.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.61 2003/10/15 02:43:09 drahn Exp $	*/
d321 1
a321 1
			if ((va >> ADDR_SR_SHIFT) == USER_SR) {
d325 1
a325 1
				     : "=r"(user_sr) : "K"(USER_SR));
@


1.61
log
@Sometimes KNF is not a destination, but a journey. Also ANSI.
Binaries unchanged.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.60 2003/07/02 21:57:52 drahn Exp $	*/
d559 1
a559 1
		panic ("trap type %x at %x (%s+0x%x) lr %x",
@


1.60
log
@If the fpu or vector registers are not currently associated with any
process, the fpuproc or vecproc are set to NULL, prevent these
functions from potentially attempting to access thru a NULL pointer.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.59 2003/07/02 21:30:12 drahn Exp $	*/
d86 1
a86 1
	while (addr != 0) {
a87 1
	}
d245 1
a245 1
userret(register struct proc *p, int pc, u_quad_t oticks)
d254 1
a254 4

		/*
		 * We're being preempted.
		 */
d273 1
a273 2
trap(frame)
	struct trapframe *frame;
d329 1
a329 1
				if (pte_spill_v(map->pmap, va, frame->dsisr, 0)) {
a330 1
				}
d336 1
a336 1
			if (uvm_fault(map, trunc_page(va), 0, ftype) == 0) {
d338 1
a338 1
			}
d356 1
d358 1
a358 3
				frame->dar, frame->dsisr, 0))
			{
				/* fault handled by spill handler */
a359 1
			}
d367 1
a367 1
				     trunc_page(frame->dar), 0, ftype) == 0) {
d369 1
a369 1
			}
d384 1
d386 1
a386 3
				frame->srr0, 0, 1))
			{
				/* fault handled by spill handler */
d388 1
a388 1
			}
d391 1
a391 1
				     trunc_page(frame->srr0), 0, ftype) == 0) {
a392 1
			}
d450 4
a453 2
				if ((error = copyin(MOREARGS(frame->fixreg[1]),
				   args + n, argsize - n * sizeof(register_t)))) {
d532 1
a532 1
		if (fix_unaligned(p, frame) == 0) {
d534 1
a534 1
		} else {
d632 1
a632 1
		if (ppc_vecproc) {
d634 1
a634 1
		}
d662 1
a662 1
	if (p != fpuproc) {
d664 1
a664 1
	} else {
a665 1
	}
d671 1
a671 1
	if (p != ppc_vecproc) {
d673 1
a673 1
	} else {
a674 1
	}
d679 1
a679 2
child_return(arg)
	void *arg;
d700 1
a700 3
badaddr(addr, len)
	char *addr;
	u_int32_t len;
d704 1
a704 1
	register void *oldh = curpcb->pcb_onfault;
d733 1
a733 3
fix_unaligned(p, frame)
	struct proc *p;
	struct trapframe *frame;
a768 1

@


1.59
log
@Reduce the amount of asm code in powerpc/macppc by replacing it with
inlined functions, helps improve readability and fix a couple of bugs.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.58 2003/03/04 19:11:37 deraadt Exp $	*/
d117 4
@


1.58
log
@told you it was not knf
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.57 2003/03/04 19:10:31 drahn Exp $	*/
a116 1
	u_int32_t tmp;
d120 1
a120 1
	__asm__ volatile ("mfmsr %0" : "=r" (oldmsr));
d122 1
a122 1
	__asm__ volatile ("mtmsr %0" :: "r" (msr));
d125 1
a125 2
	__asm__ volatile ("mfspr %0, 256" : "=r" (tmp));
	pcb->pcb_vr->vrsave = tmp;
d167 1
a167 1
	__asm__ volatile ("mfmsr %0" :: "r" (oldmsr));
a178 1
	u_int32_t tmp;
d191 1
a191 1
	__asm__ volatile ("mfmsr %0" : "=r" (oldmsr));
d193 1
a193 1
	__asm__ volatile ("mtmsr %0" :: "r" (msr));
d201 1
a201 2
	tmp = pcb_vr->vrsave;
	__asm__ volatile ("mtspr 256, %0" :: "r" (tmp));
d237 1
a237 1
	__asm__ volatile ("mfmsr %0" :: "r" (oldmsr));
@


1.57
log
@Move 'userret' code to a seperate function, add it to child_return(). w/KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.56 2003/02/26 21:54:44 drahn Exp $	*/
d270 1
a270 2
		addupc_task(p, pc,
			    (int)(p->p_sticks - oticks) * psratio);
@


1.56
log
@Remove an unnecessary structure copy from useage of setfault(), call
by reference, not by value, ok matthieu#, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.55 2002/10/13 18:26:12 krw Exp $	*/
d66 1
d245 31
d666 1
a666 19
	/* take pending signals */
	{
		int sig;

		while ((sig = CURSIG(p)))
			postsig(sig);
	}

	p->p_priority = p->p_usrpri;
	if (want_resched) {
		int sig;

		/*
		 * We're being preempted.
		 */
		preempt(NULL);
		while ((sig = CURSIG(p)))
			postsig(sig);
	}
a668 9
	 * If profiling, charge recent system time to the trapped pc.
	 */
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, frame->srr0,
			    (int)(p->p_sticks - sticks) * psratio);
	}
	/*
a686 2

	curpriority = p->p_priority;
d702 3
a708 2
	/* Profiling?							XXX */
	curpriority = p->p_priority;
@


1.55
log
@Remove more '\n's from panic() statements.  From Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.54 2002/09/15 09:01:59 deraadt Exp $	*/
d716 1
a716 1
	if (setfault(env)) {
@


1.54
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.52 2002/07/24 02:19:28 drahn Exp $	*/
d536 1
a536 1
		panic ("trap type %x at %x (%s+0x%x) lr %x\n",
@


1.53
log
@KNF
@
text
@d262 1
a262 1
	case EXC_TRC|EXC_USER:
d292 1
a292 1

d297 1
a297 1

d299 1
a299 1
				    : "=r"(user_sr) : "K"(USER_SR));
d330 1
a330 1

d332 2
a333 1
			    frame->dar, frame->dsisr, 0)) {
d344 1
a344 1
			    trunc_page(frame->dar), 0, ftype) == 0) {
d360 1
a360 1

d362 2
a363 1
			    frame->srr0, 0, 1)) {
d369 1
a369 1
			    trunc_page(frame->srr0), 0, ftype) == 0) {
d390 1
a390 1

d392 1
a392 1

d395 1
a395 1

d398 1
a398 1

d452 1
d487 2
a488 2
			scdebug_ret(p, code, error, rval);
#endif
d504 1
a504 1
		/* alignment exception
d519 1
a519 1

d545 1
a545 1
		if (frame->srr1 & (1<<(31-11))) {
d549 1
a549 1
		}
d580 1
a580 1
{
d607 1
a607 1
#ifdef ALTIVEC
d720 1
a720 1
	switch (len) {
@


1.52
log
@- change pte_spill_X() to take an extra parameter to determine if
  the fault is a EXE fault or R/W fault.

- mask/or the SR_NOEXEC bit into the segment register value
  when the number of executable pages becomes 0/non-zero.

- create segments with SR_NOEXEC set, will be cleared when first
  exec mapping in the segment is created.

- allow pte_spill_X() to deal with a new type of fault, page mapped
  but non executable, when execute was requested.

Adds up to - non-exec stack support for powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.51 2002/06/07 21:57:57 drahn Exp $	*/
d262 1
a262 1
	case EXC_TRC|EXC_USER:		
d292 1
a292 1
			
d297 1
a297 1
				
d299 1
a299 1
				     : "=r"(user_sr) : "K"(USER_SR));
d330 1
a330 1
			
d332 1
a332 2
				frame->dar, frame->dsisr, 0))
			{
d343 1
a343 1
				     trunc_page(frame->dar), 0, ftype) == 0) {
d359 1
a359 1
			
d361 1
a361 2
				frame->srr0, 0, 1))
			{
d367 1
a367 1
				     trunc_page(frame->srr0), 0, ftype) == 0) {
d388 1
a388 1
			
d390 1
a390 1
			
d393 1
a393 1
			
d396 1
a396 1
			
a449 1
			
d484 2
a485 2
        scdebug_ret(p, code, error, rval); 
#endif  
d501 1
a501 1
		/* alignment exception 
d516 1
a516 1
	
d542 1
a542 1
		if (frame->srr1 & (1<<(31-11))) { 
d546 1
a546 1
		} 
d577 1
a577 1
{ 
d604 1
a604 1
#ifdef ALTIVEC 
d717 1
a717 1
	switch(len) {
@


1.51
log
@More DDB fallout.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.50 2002/06/04 00:09:08 deraadt Exp $	*/
d303 1
a303 1
				if (pte_spill_v(map->pmap, va, frame->dsisr)) {
d332 1
a332 1
				frame->dar, frame->dsisr))
d362 1
a362 1
				frame->srr0, 0))
@


1.50
log
@spelling; raj@@cerias.purdue.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.49 2002/05/18 09:49:17 art Exp $	*/
d528 3
a531 1
		db_find_sym_and_offset(frame->srr0, &name, &offset);
@


1.49
log
@Rename the MD db_stack_trace_cmd to db_stack_trace_print. Add an argument
that specifies which printf funciton it should use. Implement
db_stack_trace_cmd in MI code.

Thanks to miod@@ for all the tests.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.48 2002/05/16 21:11:17 miod Exp $	*/
d555 1
a555 1
			errstr[errnum] = "priviledged instr";
@


1.48
log
@Add systrace support to all the remaining architectures.

Tested by various people on various platforms, I'm willing to fix any
breakage this causes.

ok niels@@ deraadt@@ and mickey@@ (after his comments were applied)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.47 2002/05/15 22:49:16 drahn Exp $	*/
d62 1
d86 1
a86 1
		addr = db_dumpframe(addr);
@


1.47
log
@Remove the assembler kludges to allow altivec support without assembler help
now that binutils is updated. As hoped, resulting .o file was identical.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.46 2002/05/13 17:55:02 drahn Exp $	*/
d55 3
d448 1
a448 1
	scdebug_call(p, code, params);
d452 8
a459 1
			switch (error = (*callp->sy_call)(p, params, rval)) {
@


1.46
log
@Add missing cnpollc() calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.45 2002/03/14 23:51:47 drahn Exp $	*/
a123 1
#ifdef AS_SUPPORTS_ALTIVEC
a126 5
#else
#define STR(x) #x
#define SAVE_VEC_REG(reg, addr)   \
	__asm__ volatile (".long 0x7c0003ce + (%0 << 21) + (%1 << 11)" :: "n"(reg), "r" (addr))
#endif
a159 1
#ifdef AS_SUPPORTS_ALTIVEC
a160 3
#else 
	__asm__ volatile (".long 0x10000604");
#endif
a193 1
#ifdef AS_SUPPORTS_ALTIVEC
a195 4
#else
#define LOAD_VEC_REG(reg, addr)   \
	__asm__ volatile (".long 0x7c0002ce + (%0 << 21) + (%1 << 11)" :: "n"(reg), "r" (addr));
#endif
a197 1
#ifdef AS_SUPPORTS_ALTIVEC
a198 3
#else
	__asm__ volatile (".long 0x10000644");
#endif
@


1.45
log
@Improved altivec support for powerpc/macppc.
Fix bug where altivec context was not freed on process exit.
Fix bug where vscr was not correctly saved/restored.
replace asm statement was macros which expand to the same
asm code or to .long XXX which evaluates to the same instruction
since in-tree gas does not support altivec.
Enable ALTIVEC support by default on macppc, still conditional
for other powerpc ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.44 2002/03/14 01:26:42 millert Exp $	*/
d44 2
d573 1
d575 1
d601 1
d603 1
@


1.44
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.43 2002/03/13 18:27:37 drahn Exp $	*/
d86 1
a86 1
#ifdef PPC_VECTOR_SUPPORTED
d108 1
d119 1
a119 1
	__asm__ volatile ("mfvscr %0" : "=r" (tmp));
a120 2
	__asm__ volatile ("mfspr %0, 256" : "=r" (tmp));
	pcb->pcb_vr->vscr = tmp;
d122 48
a169 32
	__asm__ volatile ("stvxl  0, 0, %0" ::"r" (&pcb->pcb_vr->vreg[0]));
	__asm__ volatile ("stvxl  1, 0, %0" ::"r" (&pcb->pcb_vr->vreg[1]));
	__asm__ volatile ("stvxl  2, 0, %0" ::"r" (&pcb->pcb_vr->vreg[2]));
	__asm__ volatile ("stvxl  3, 0, %0" ::"r" (&pcb->pcb_vr->vreg[3]));
	__asm__ volatile ("stvxl  4, 0, %0" ::"r" (&pcb->pcb_vr->vreg[4]));
	__asm__ volatile ("stvxl  5, 0, %0" ::"r" (&pcb->pcb_vr->vreg[5]));
	__asm__ volatile ("stvxl  6, 0, %0" ::"r" (&pcb->pcb_vr->vreg[6]));
	__asm__ volatile ("stvxl  7, 0, %0" ::"r" (&pcb->pcb_vr->vreg[7]));
	__asm__ volatile ("stvxl  8, 0, %0" ::"r" (&pcb->pcb_vr->vreg[8]));
	__asm__ volatile ("stvxl  9, 0, %0" ::"r" (&pcb->pcb_vr->vreg[9]));
	__asm__ volatile ("stvxl  10, 0, %0" ::"r" (&pcb->pcb_vr->vreg[10]));
	__asm__ volatile ("stvxl  11, 0, %0" ::"r" (&pcb->pcb_vr->vreg[11]));
	__asm__ volatile ("stvxl  12, 0, %0" ::"r" (&pcb->pcb_vr->vreg[12]));
	__asm__ volatile ("stvxl  13, 0, %0" ::"r" (&pcb->pcb_vr->vreg[13]));
	__asm__ volatile ("stvxl  14, 0, %0" ::"r" (&pcb->pcb_vr->vreg[14]));
	__asm__ volatile ("stvxl  15, 0, %0" ::"r" (&pcb->pcb_vr->vreg[15]));
	__asm__ volatile ("stvxl  16, 0, %0" ::"r" (&pcb->pcb_vr->vreg[16]));
	__asm__ volatile ("stvxl  17, 0, %0" ::"r" (&pcb->pcb_vr->vreg[17]));
	__asm__ volatile ("stvxl  18, 0, %0" ::"r" (&pcb->pcb_vr->vreg[18]));
	__asm__ volatile ("stvxl  19, 0, %0" ::"r" (&pcb->pcb_vr->vreg[19]));
	__asm__ volatile ("stvxl  20, 0, %0" ::"r" (&pcb->pcb_vr->vreg[20]));
	__asm__ volatile ("stvxl  21, 0, %0" ::"r" (&pcb->pcb_vr->vreg[21]));
	__asm__ volatile ("stvxl  22, 0, %0" ::"r" (&pcb->pcb_vr->vreg[22]));
	__asm__ volatile ("stvxl  23, 0, %0" ::"r" (&pcb->pcb_vr->vreg[23]));
	__asm__ volatile ("stvxl  24, 0, %0" ::"r" (&pcb->pcb_vr->vreg[24]));
	__asm__ volatile ("stvxl  25, 0, %0" ::"r" (&pcb->pcb_vr->vreg[25]));
	__asm__ volatile ("stvxl  26, 0, %0" ::"r" (&pcb->pcb_vr->vreg[26]));
	__asm__ volatile ("stvxl  27, 0, %0" ::"r" (&pcb->pcb_vr->vreg[27]));
	__asm__ volatile ("stvxl  28, 0, %0" ::"r" (&pcb->pcb_vr->vreg[28]));
	__asm__ volatile ("stvxl  29, 0, %0" ::"r" (&pcb->pcb_vr->vreg[29]));
	__asm__ volatile ("stvxl  30, 0, %0" ::"r" (&pcb->pcb_vr->vreg[30]));
	__asm__ volatile ("stvxl  31, 0, %0" ::"r" (&pcb->pcb_vr->vreg[31]));
d182 1
d202 15
a216 3
	tmp = pcb->pcb_vr->vrsave;
	__asm__ volatile ("mtvscr %0" :: "r" (tmp));
	tmp = pcb->pcb_vr->vscr;
d219 32
a250 32
	__asm__ volatile ("lvxl  0, 0, %0" ::"r" (&pcb->pcb_vr->vreg[0]));
	__asm__ volatile ("lvxl  1, 0, %0" ::"r" (&pcb->pcb_vr->vreg[1]));
	__asm__ volatile ("lvxl  2, 0, %0" ::"r" (&pcb->pcb_vr->vreg[2]));
	__asm__ volatile ("lvxl  3, 0, %0" ::"r" (&pcb->pcb_vr->vreg[3]));
	__asm__ volatile ("lvxl  4, 0, %0" ::"r" (&pcb->pcb_vr->vreg[4]));
	__asm__ volatile ("lvxl  5, 0, %0" ::"r" (&pcb->pcb_vr->vreg[5]));
	__asm__ volatile ("lvxl  6, 0, %0" ::"r" (&pcb->pcb_vr->vreg[6]));
	__asm__ volatile ("lvxl  7, 0, %0" ::"r" (&pcb->pcb_vr->vreg[7]));
	__asm__ volatile ("lvxl  8, 0, %0" ::"r" (&pcb->pcb_vr->vreg[8]));
	__asm__ volatile ("lvxl  9, 0, %0" ::"r" (&pcb->pcb_vr->vreg[9]));
	__asm__ volatile ("lvxl  10, 0, %0" ::"r" (&pcb->pcb_vr->vreg[10]));
	__asm__ volatile ("lvxl  11, 0, %0" ::"r" (&pcb->pcb_vr->vreg[11]));
	__asm__ volatile ("lvxl  12, 0, %0" ::"r" (&pcb->pcb_vr->vreg[12]));
	__asm__ volatile ("lvxl  13, 0, %0" ::"r" (&pcb->pcb_vr->vreg[13]));
	__asm__ volatile ("lvxl  14, 0, %0" ::"r" (&pcb->pcb_vr->vreg[14]));
	__asm__ volatile ("lvxl  15, 0, %0" ::"r" (&pcb->pcb_vr->vreg[15]));
	__asm__ volatile ("lvxl  16, 0, %0" ::"r" (&pcb->pcb_vr->vreg[16]));
	__asm__ volatile ("lvxl  17, 0, %0" ::"r" (&pcb->pcb_vr->vreg[17]));
	__asm__ volatile ("lvxl  18, 0, %0" ::"r" (&pcb->pcb_vr->vreg[18]));
	__asm__ volatile ("lvxl  19, 0, %0" ::"r" (&pcb->pcb_vr->vreg[19]));
	__asm__ volatile ("lvxl  20, 0, %0" ::"r" (&pcb->pcb_vr->vreg[20]));
	__asm__ volatile ("lvxl  21, 0, %0" ::"r" (&pcb->pcb_vr->vreg[21]));
	__asm__ volatile ("lvxl  22, 0, %0" ::"r" (&pcb->pcb_vr->vreg[22]));
	__asm__ volatile ("lvxl  23, 0, %0" ::"r" (&pcb->pcb_vr->vreg[23]));
	__asm__ volatile ("lvxl  24, 0, %0" ::"r" (&pcb->pcb_vr->vreg[24]));
	__asm__ volatile ("lvxl  25, 0, %0" ::"r" (&pcb->pcb_vr->vreg[25]));
	__asm__ volatile ("lvxl  26, 0, %0" ::"r" (&pcb->pcb_vr->vreg[26]));
	__asm__ volatile ("lvxl  27, 0, %0" ::"r" (&pcb->pcb_vr->vreg[27]));
	__asm__ volatile ("lvxl  28, 0, %0" ::"r" (&pcb->pcb_vr->vreg[28]));
	__asm__ volatile ("lvxl  29, 0, %0" ::"r" (&pcb->pcb_vr->vreg[29]));
	__asm__ volatile ("lvxl  30, 0, %0" ::"r" (&pcb->pcb_vr->vreg[30]));
	__asm__ volatile ("lvxl  31, 0, %0" ::"r" (&pcb->pcb_vr->vreg[31]));
d255 1
a255 1
#endif /* PPC_VECTOR_SUPPORTED */
d607 1
a607 1
#ifdef PPC_VECTOR_SUPPORTED
d615 1
a615 1
#else /* PPC_VECTOR_SUPPORTED */
d619 1
a619 1
#endif /* PPC_VECTOR_SUPPORTED */
d672 1
a672 1
#ifdef PPC_VECTOR_SUPPORTED
d681 1
a681 1
#endif /* PPC_VECTOR_SUPPORTED */
@


1.43
log
@Complete rewrite of the powerpc pmap handling, Instead of keeping
the spill list for each PTEG, the V->P translations are stored in
trees for each pmap. All valid kernel mappings are preallocated
in 1-1 memory so that tlb spill/loads for kernel accesses can be
looked up while physical, user mappings are not guaranteed to
be 1-1 mapped, thus the kernel must go virtual to look up user
mappings. While this is more expensive, the tree search is much
lower cost than the long linked list search. Also on each pmap_remove()
it was necessary to search the linked lists for each possible mapping,
now it just looks up the entry in the tree.
This change gives a 25-36% speedup in 'make build' time. What was
around 2:50 is now around 1:55 on a 733MHz G4.

This change causes a likely existing bug to appear quite often,
it deals with the segment register invalidation in kernel mode.
Because of that problem, currently this change limits the physical
memory used to 256MB. This limitation will be fixed soon, it is not
an error in the pmap code.

 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.42 2002/01/13 05:30:17 drahn Exp $	*/
d58 3
a60 3
static int fix_unaligned __P((struct proc *p, struct trapframe *frame));
int badaddr __P((char *addr, u_int32_t len));
void trap __P((struct trapframe *frame));
d71 1
a71 1
void ppc_dumpbt __P((struct trapframe *frame));
@


1.42
log
@better accounting for 'soft' interrupts, before all exceptions were
counted as soft interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.41 2001/11/29 04:47:41 drahn Exp $	*/
d280 1
a280 1
			if ((va >> ADDR_SR_SHFT) == USER_SR) {
d286 1
a286 1
				va |= user_sr << ADDR_SR_SHFT;
d288 3
d316 7
d346 6
d359 1
a359 1
printf("isi iar %x\n", frame->srr0);
d554 2
d559 1
a678 7
static inline void
setusr(int content)
{
	asm volatile ("isync; mtsr %0,%1; isync"
		      :: "n"(USER_SR), "r"(content));
}

a706 59
int
copyin(udaddr, kaddr, len)
	const void *udaddr;
	void *kaddr;
	size_t len;
{
	void *p;
	size_t l;
	faultbuf env;
	register void *oldh = curpcb->pcb_onfault;

	if (setfault(env)) {
		curpcb->pcb_onfault = oldh;
		return EFAULT;
	}
	while (len > 0) {
		p = USER_ADDR + ((u_int)udaddr & ~SEGMENT_MASK);
		l = (USER_ADDR + SEGMENT_LENGTH) - p;
		if (l > len)
			l = len;
		setusr(curpcb->pcb_pm->pm_sr[(u_int)udaddr >> ADDR_SR_SHFT]);
		bcopy(p, kaddr, l);
		udaddr += l;
		kaddr += l;
		len -= l;
	}
	curpcb->pcb_onfault = oldh;
	return 0;
}

int
copyout(kaddr, udaddr, len)
	const void *kaddr;
	void *udaddr;
	size_t len;
{
	void *p;
	size_t l;
	faultbuf env;
	register void *oldh = curpcb->pcb_onfault;

	if (setfault(env)) {
		curpcb->pcb_onfault = oldh;
		return EFAULT;
	}
	while (len > 0) {
		p = USER_ADDR + ((u_int)udaddr & ~SEGMENT_MASK);
		l = (USER_ADDR + SEGMENT_LENGTH) - p;
		if (l > len)
			l = len;
		setusr(curpcb->pcb_pm->pm_sr[(u_int)udaddr >> ADDR_SR_SHFT]);
		bcopy(kaddr, p, l);
		udaddr += l;
		kaddr += l;
		len -= l;
	}
	curpcb->pcb_onfault = oldh;
	return 0;
}
@


1.41
log
@Fix for thinko that was caught in code review, error was found 3x, however
it was fixed 2x, leaving one instance of the error.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.40 2001/11/28 16:13:29 art Exp $	*/
d575 1
a580 2

	uvmexp.softs++;
@


1.41.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.42 2002/01/13 05:30:17 drahn Exp $	*/
a574 1
		uvmexp.softs++;
d580 2
@


1.41.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.41.2.1 2002/01/31 22:55:21 niklas Exp $	*/
a43 2
#include <dev/cons.h>

a52 3
#include "systrace.h"
#include <dev/systrace.h>

a56 1
#include <ddb/db_output.h>
d58 3
a60 3
static int fix_unaligned(struct proc *p, struct trapframe *frame);
int badaddr(char *addr, u_int32_t len);
void trap(struct trapframe *frame);
d71 1
a71 1
void ppc_dumpbt(struct trapframe *frame);
d80 1
a80 1
		addr = db_dumpframe(addr, db_printf);
d86 1
a86 1
#ifdef ALTIVEC
a107 1
	struct vreg *pcb_vr = pcb->pcb_vr;
d118 2
d121 1
a121 1
	pcb->pcb_vr->vrsave = tmp;
d123 32
a154 38
#define STR(x) #x
#define SAVE_VEC_REG(reg, addr)   \
	__asm__ volatile ("stvxl %0, 0, %1" :: "n"(reg),"r" (addr));

	SAVE_VEC_REG(0,&pcb_vr->vreg[0]);
	SAVE_VEC_REG(1,&pcb_vr->vreg[1]);
	SAVE_VEC_REG(2,&pcb_vr->vreg[2]);
	SAVE_VEC_REG(3,&pcb_vr->vreg[3]);
	SAVE_VEC_REG(4,&pcb_vr->vreg[4]);
	SAVE_VEC_REG(5,&pcb_vr->vreg[5]);
	SAVE_VEC_REG(6,&pcb_vr->vreg[6]);
	SAVE_VEC_REG(7,&pcb_vr->vreg[7]);
	SAVE_VEC_REG(8,&pcb_vr->vreg[8]);
	SAVE_VEC_REG(9,&pcb_vr->vreg[9]);
	SAVE_VEC_REG(10,&pcb_vr->vreg[10]);
	SAVE_VEC_REG(11,&pcb_vr->vreg[11]);
	SAVE_VEC_REG(12,&pcb_vr->vreg[12]);
	SAVE_VEC_REG(13,&pcb_vr->vreg[13]);
	SAVE_VEC_REG(14,&pcb_vr->vreg[14]);
	SAVE_VEC_REG(15,&pcb_vr->vreg[15]);
	SAVE_VEC_REG(16,&pcb_vr->vreg[16]);
	SAVE_VEC_REG(17,&pcb_vr->vreg[17]);
	SAVE_VEC_REG(18,&pcb_vr->vreg[18]);
	SAVE_VEC_REG(19,&pcb_vr->vreg[19]);
	SAVE_VEC_REG(20,&pcb_vr->vreg[20]);
	SAVE_VEC_REG(21,&pcb_vr->vreg[21]);
	SAVE_VEC_REG(22,&pcb_vr->vreg[22]);
	SAVE_VEC_REG(23,&pcb_vr->vreg[23]);
	SAVE_VEC_REG(24,&pcb_vr->vreg[24]);
	SAVE_VEC_REG(25,&pcb_vr->vreg[25]);
	SAVE_VEC_REG(26,&pcb_vr->vreg[26]);
	SAVE_VEC_REG(27,&pcb_vr->vreg[27]);
	SAVE_VEC_REG(28,&pcb_vr->vreg[28]);
	SAVE_VEC_REG(29,&pcb_vr->vreg[29]);
	SAVE_VEC_REG(30,&pcb_vr->vreg[30]);
	SAVE_VEC_REG(31,&pcb_vr->vreg[31]);
	__asm__ volatile ("mfvscr 0");
	SAVE_VEC_REG(0,&pcb_vr->vscr);
a166 1
	struct vreg *pcb_vr = pcb->pcb_vr;
d186 3
a188 6
#define LOAD_VEC_REG(reg, addr)   \
	__asm__ volatile ("lvxl %0, 0, %1" :: "n"(reg), "r" (addr));

	LOAD_VEC_REG(0, &pcb_vr->vscr);
	__asm__ volatile ("mtvscr 0");
	tmp = pcb_vr->vrsave;
d191 32
a222 32
	LOAD_VEC_REG(0, &pcb_vr->vreg[0]);
	LOAD_VEC_REG(1, &pcb_vr->vreg[1]);
	LOAD_VEC_REG(2, &pcb_vr->vreg[2]);
	LOAD_VEC_REG(3, &pcb_vr->vreg[3]);
	LOAD_VEC_REG(4, &pcb_vr->vreg[4]);
	LOAD_VEC_REG(5, &pcb_vr->vreg[5]);
	LOAD_VEC_REG(6, &pcb_vr->vreg[6]);
	LOAD_VEC_REG(7, &pcb_vr->vreg[7]);
	LOAD_VEC_REG(8, &pcb_vr->vreg[8]);
	LOAD_VEC_REG(9, &pcb_vr->vreg[9]);
	LOAD_VEC_REG(10, &pcb_vr->vreg[10]);
	LOAD_VEC_REG(11, &pcb_vr->vreg[11]);
	LOAD_VEC_REG(12, &pcb_vr->vreg[12]);
	LOAD_VEC_REG(13, &pcb_vr->vreg[13]);
	LOAD_VEC_REG(14, &pcb_vr->vreg[14]);
	LOAD_VEC_REG(15, &pcb_vr->vreg[15]);
	LOAD_VEC_REG(16, &pcb_vr->vreg[16]);
	LOAD_VEC_REG(17, &pcb_vr->vreg[17]);
	LOAD_VEC_REG(18, &pcb_vr->vreg[18]);
	LOAD_VEC_REG(19, &pcb_vr->vreg[19]);
	LOAD_VEC_REG(20, &pcb_vr->vreg[20]);
	LOAD_VEC_REG(21, &pcb_vr->vreg[21]);
	LOAD_VEC_REG(22, &pcb_vr->vreg[22]);
	LOAD_VEC_REG(23, &pcb_vr->vreg[23]);
	LOAD_VEC_REG(24, &pcb_vr->vreg[24]);
	LOAD_VEC_REG(25, &pcb_vr->vreg[25]);
	LOAD_VEC_REG(26, &pcb_vr->vreg[26]);
	LOAD_VEC_REG(27, &pcb_vr->vreg[27]);
	LOAD_VEC_REG(28, &pcb_vr->vreg[28]);
	LOAD_VEC_REG(29, &pcb_vr->vreg[29]);
	LOAD_VEC_REG(30, &pcb_vr->vreg[30]);
	LOAD_VEC_REG(31, &pcb_vr->vreg[31]);
d227 1
a227 1
#endif /* ALTIVEC */
d280 1
a280 1
			if ((va >> ADDR_SR_SHIFT) == USER_SR) {
d286 1
a286 1
				va |= user_sr << ADDR_SR_SHIFT;
a287 3
				if (pte_spill_v(map->pmap, va, frame->dsisr)) {
					return;
				}
a312 7
			if (pte_spill_v(p->p_vmspace->vm_map.pmap,
				frame->dar, frame->dsisr))
			{
				/* fault handled by spill handler */
				break;
			}

a335 6
			if (pte_spill_v(p->p_vmspace->vm_map.pmap,
				frame->srr0, 0))
			{
				/* fault handled by spill handler */
				break;
			}
d343 1
a343 1
printf("isi iar %x lr %x\n", frame->srr0, frame->lr);
d418 1
a418 1
			scdebug_call(p, code, params);
d422 1
a422 8
#if NSYSTRACE > 0
			if (ISSET(p->p_flag, P_SYSTRACE))
				error = systrace_redirect(code, p, params,
				    rval);
			else
#endif
				error = (*callp->sy_call)(p, params, rval);
			switch (error) {
d490 1
a491 3
#else
		name = NULL;
#endif
d517 1
a517 1
			errstr[errnum] = "privileged instr";
a526 1
					cnpollc(TRUE);
a527 1
					cnpollc(FALSE);
a537 2
{ 
int i;
a540 1
}
a549 1
		cnpollc(TRUE);
a550 1
		cnpollc(FALSE);
d560 1
a560 1
#ifdef ALTIVEC 
d568 1
a568 1
#else  /* ALTIVEC */
d572 1
a572 1
#endif
d625 1
a625 1
#ifdef ALTIVEC
d634 1
a634 1
#endif /* ALTIVEC */
d660 7
d695 59
@


1.41.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.41.2.2 2002/06/11 03:37:28 art Exp $	*/
d303 1
a303 1
				if (pte_spill_v(map->pmap, va, frame->dsisr, 0)) {
d332 1
a332 1
				frame->dar, frame->dsisr, 0))
d362 1
a362 1
				frame->srr0, 0, 1))
d536 1
a536 1
		panic ("trap type %x at %x (%s+0x%x) lr %x",
@


1.41.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a65 1
static __inline void userret(struct proc *, int, u_quad_t);
a243 30
static __inline void
userret(register struct proc *p, int pc, u_quad_t oticks)
{
	int sig;

	/* take pending signals */
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);
	p->p_priority = p->p_usrpri;
	if (want_resched) {

		/*
		 * We're being preempted.
		 */
		preempt(NULL);
		while ((sig = CURSIG(p)))
			postsig(sig);
	}

	/*
	 * If profiling, charge recent system time to the trapped pc.
	 */
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, pc, (int)(p->p_sticks - oticks) * psratio);
	}

	curpriority = p->p_priority;
}
d634 19
a652 1
	userret(p, frame->srr0, sticks);
d655 9
d682 2
a698 3

	userret(p, tf->srr0, 0);

d703 2
d716 1
a716 1
	if (setfault(&env)) {
@


1.40
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.39 2001/11/28 13:47:39 art Exp $	*/
d338 1
a338 1
				     trunc_page(frame->srr0), 0, ftype)) {
@


1.39
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.38 2001/11/13 14:31:52 drahn Exp $	*/
d273 1
a273 1
			vm_map_t map;
@


1.38
log
@Add AltiVec support to powerpc/macppc. This is not currently enabled because
the 'as' in openbsd source tree does not yet support altivec instructions.
The pieces to enable it have been put in macppc/conf/GENERIC and
macppc/conf/Makefile.macppc in comments.
Once 'as' is updated the kernel option should be removed.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.37 2001/11/11 04:43:53 drahn Exp $	*/
d293 1
a293 3
			if (uvm_fault(map, trunc_page(va), 0, ftype)
			    == KERN_SUCCESS)
			{
d319 1
a319 2
				     trunc_page(frame->dar), 0, ftype)
			    == KERN_SUCCESS) {
d338 1
a338 2
				     trunc_page(frame->srr0), 0, ftype)
			    == KERN_SUCCESS) {
@


1.37
log
@Fix matching brace error. Fortunately PGM errors do not happen in the
kernel much. This has been there quite a while.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.36 2001/11/07 01:02:36 art Exp $	*/
d42 1
d68 1
d86 144
d561 1
a561 1
	 * which we do not handle, kill the process with illegal instruction.
d564 9
d576 1
d624 1
a624 1
	if (p != fpuproc)
d626 15
d655 2
a656 1
	tf->srr1 &= ~PSL_FP;	/* Disable FPU, as we can't be fpuproc */
@


1.36
log
@unbreak child_return.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.35 2001/11/06 19:53:16 miod Exp $	*/
d403 1
a413 1
	}
@


1.35
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.34 2001/11/05 22:26:57 drahn Exp $	*/
d474 2
a475 2
child_return(p)
	struct proc *p;
d477 1
@


1.34
log
@Workaround to prevent Altivec Unavilable problem.
Why did Motorola put this exception misaligned with respect to all other
exceptions?
Altivec is not supported. This will cause any process executing altivec
instructions to recieve an illegal instruction signal.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.33 2001/09/20 13:46:04 drahn Exp $	*/
a50 2

#include <vm/vm.h>
@


1.33
log
@Allow nesting of fault handlers by saving old onfault handler and
restoring it when the copying/copyout/badaddr functions finish.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.32 2001/09/19 20:50:57 mickey Exp $	*/
d416 8
@


1.33.2.1
log
@Pull in patch from current:
Workaround to prevent Altivec Unavilable problem.
Why did Motorola put this exception misaligned with respect to all other
exceptions?
Altivec is not supported. This will cause any process executing altivec
instructions to recieve an illegal instruction signal.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.33 2001/09/20 13:46:04 drahn Exp $	*/
a415 8
	/* This is not really a perf exception, but is an ALTIVEC unavail
	 * which we do not handle, kill the process with illegal instruction.
	 */
	case EXC_PERF|EXC_USER:
		sv.sival_int = frame->srr0;
		trapsignal(p, SIGILL, 0, ILL_ILLOPC, sv);
		break;

@


1.32
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31 2001/09/18 01:51:54 drahn Exp $	*/
d500 1
d503 1
a503 1
		curpcb->pcb_onfault = 0;
d517 1
a517 1
	curpcb->pcb_onfault = 0;
d530 1
d533 1
a533 1
		curpcb->pcb_onfault = 0;
d547 1
a547 1
	curpcb->pcb_onfault = 0;
d560 1
d563 1
a563 1
		curpcb->pcb_onfault = 0;
d577 1
a577 1
	curpcb->pcb_onfault = 0;
@


1.31
log
@Improve the panic message, print symbol and offset, of where fault occurs
instead of just address. Managed to test this out a few times today.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.30 2001/09/14 14:58:44 art Exp $	*/
a52 1
#include <vm/vm_kern.h>
@


1.30
log
@simplify userret
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.29 2001/07/09 02:07:49 mickey Exp $	*/
d58 1
d95 2
d352 7
a358 2
		panic ("trap type %x at %x lr %x\n",
			type, frame->srr0, frame->lr);
@


1.29
log
@protos, includes, spaces; from prev ci
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.28 2001/07/09 01:35:33 mickey Exp $	*/
d433 1
a433 1
		int s, sig;
d436 1
a436 6
		 * Since we are curproc, a clock interrupt could
		 * change our priority without changing run queues
		 * (the running process is not kept on a run queue).
		 * If this happened after we setrunqueue ourselves but
		 * before switch()'ed, we might not be on the queue
		 * indicated by our priority.
d438 1
a438 5
		s = splstatclock();
		setrunqueue(p);
		p->p_stats->p_ru.ru_nivcsw++;
		mi_switch();
		splx(s);
@


1.28
log
@lots of parens, protos
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.27 2001/06/27 04:37:22 art Exp $	*/
a70 1
u_int32_t db_dumpframe(u_int32_t);
@


1.27
log
@kill old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.26 2001/06/25 23:30:04 drahn Exp $	*/
a42 5
#include <vm/vm.h>
#include <vm/vm_kern.h>

#include <uvm/uvm_extern.h>

d44 1
d52 7
d60 2
d72 2
d86 1
d113 1
a113 1
			if (fb = p->p_addr->u_pcb.pcb_onfault) {
d153 1
a153 1
			if (fb = p->p_addr->u_pcb.pcb_onfault) {
d257 2
a258 3
				if (error = copyin(MOREARGS(frame->fixreg[1]),
						   args + n,
						   argsize - n * sizeof(register_t))) {
d403 1
a403 1
		db_trap(T_BREAKPOINT);
d428 1
a428 1
		while (sig = CURSIG(p))
d449 1
a449 1
		while (sig = CURSIG(p))
d490 1
a490 2
setusr(content)
	int content;
@


1.26
log
@closer to building with -Wno-uninitialized
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.25 2001/06/10 18:45:02 drahn Exp $	*/
a45 1
#ifdef UVM
a46 1
#endif
a139 1
#ifdef UVM
a141 4
#else
			if (vm_fault(map, trunc_page(va), ftype, FALSE)
			    == KERN_SUCCESS)
#endif
a166 1
#ifdef UVM
d169 1
a169 7
			    == KERN_SUCCESS)
#else
			if (vm_fault(&p->p_vmspace->vm_map,
				     trunc_page(frame->dar), ftype, FALSE)
			    == KERN_SUCCESS)
#endif
			{
a186 1
#ifdef UVM
d189 1
a189 7
			    == KERN_SUCCESS)
#else
			if (vm_fault(&p->p_vmspace->vm_map,
				     trunc_page(frame->srr0), ftype, FALSE)
			    == KERN_SUCCESS)
#endif
			{
a210 1
#ifdef UVM
a211 3
#else
			cnt.v_syscall++;
#endif
a409 1
#ifdef UVM
a410 3
#else
	cnt.v_soft++;
#endif
@


1.25
log
@Hack/workaround for gcc bug. GCC will generate a load/store double instruction
to do data copies, however it will not correctly identify that a load/store
double will not correctly copy data where the address is misaligned.
This emulates the load/store double operations in the kernel.
Fixes gtk+ runtime problems.
From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.24 2001/03/30 05:13:46 drahn Exp $	*/
a375 1
		int i;
@


1.24
log
@Just because someone writes an errant program does not mean we should log
every problem to the console. #if 0 the rest of the user process
crash prints.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23 2001/03/29 21:47:40 drahn Exp $	*/
d58 2
d343 12
a354 2
		/* alignment exception, kill process */
		trapsignal(p, SIGSEGV, VM_PROT_EXECUTE, SEGV_MAPERR, sv);
d603 49
@


1.23
log
@This debug print has outlived it's usefulness, It seems that the VM problems
have been fixed and certain config scripts perform abnormal tests which
trigger this print. This kernel print is a potential DOS attack, thus
should be removed.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.22 2001/01/25 03:02:43 drahn Exp $	*/
d212 1
d214 1
d397 1
d402 1
@


1.22
log
@fill in rval[1] return value for non signal return other than 0 (normal).

Found when playing with threads.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.21 2000/11/10 18:15:42 art Exp $	*/
d184 1
d186 1
@


1.21
log
@Change the ktrace interface functions from taking the trace vnode to taking the
traced proc. The vnode is in the proc and all functions need the proc.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20 2000/09/06 22:48:13 rahnds Exp $	*/
d315 1
@


1.20
log
@catch misaligned access exception for user mode.
wasn't here before because supposedly the processor
would handle misaligned accesses itself.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19 2000/07/08 19:43:39 rahnds Exp $	*/
d274 1
a274 1
						ktrsyscall(p->p_tracep, code,
d283 1
a283 1
				ktrsyscall(p->p_tracep, code, argsize, params);
d323 1
a323 1
				ktrsysret(p->p_tracep, code, error, rval[0]);
d487 1
a487 1
		ktrsysret(p->p_tracep, SYS_fork, 0, 0);
@


1.19
log
@More useful panic message. Improves debugging slightly.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.18 2000/06/08 22:25:22 niklas Exp $	*/
d333 5
@


1.18
log
@Add explicit inclusions of signalvar.h to files actually using syms defined
there but relying on an indirect inclusion
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.18 2000/06/08 21:12:07 niklas Exp $	*/
a337 2
		printf("trap type %x at %x lr %x\n",
			type, frame->srr0, frame->lr);
d346 2
a347 1
		panic("trap");
d400 1
a400 1
		panic("trap");
@


1.17
log
@add first version of bus_dma for powerpc.
changes to trap handler to print out better information for jump to 0 bugs.
changes to pmap.c and machdep.c to debug a duplicate memory region
bug occasionally observed on imac with compressed kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16 2000/01/14 05:42:17 rahnds Exp $	*/
d36 1
@


1.16
log
@

UVM changes mainly. As of this checkin UVM is still not working for powerpc
it has a copyin bug after device configuration. However to get these diffs
out of my tree.

All of the UVM code is currently inside ifdef UVM the kernel works fine
without option UVM. Config files have been left without UVM for now.

Prelimiary changes for busdma, (what UVM was wanted for).
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.15 1999/07/05 20:29:14 rahnds Exp $	*/
d337 2
a338 1
		printf("trap type %x at %x\n", type, frame->srr0);
@


1.16.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d337 1
a337 2
		printf("trap type %x at %x lr %x\n",
			type, frame->srr0, frame->lr);
@


1.16.2.2
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.24 2001/03/30 05:13:46 drahn Exp $	*/
a35 1
#include <sys/signalvar.h>
a182 1
#if 0
a183 1
#endif
a208 1
#if 0
a209 1
#endif
d273 1
a273 1
						ktrsyscall(p, code,
d282 1
a282 1
				ktrsyscall(p, code, argsize, params);
a313 1
				frame->fixreg[FIRSTARG + 1] = rval[1];
d322 1
a322 1
				ktrsysret(p, code, error, rval[0]);
a333 5
	case EXC_ALI|EXC_USER:
		/* alignment exception, kill process */
		trapsignal(p, SIGSEGV, VM_PROT_EXECUTE, SEGV_MAPERR, sv);
		break;

d337 2
d347 1
a347 2
		panic ("trap type %x at %x lr %x\n",
			type, frame->srr0, frame->lr);
a386 1
#if 0
a390 1
#endif
d400 1
a400 1
		panic("trap EXC_PGM");
d482 1
a482 1
		ktrsysret(p, SYS_fork, 0, 0);
@


1.16.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16.2.2 2001/05/14 21:36:58 niklas Exp $	*/
d46 1
d48 1
a57 2
static int fix_unaligned __P((struct proc *p, struct trapframe *frame));

d140 1
d143 4
d172 1
d175 7
a181 1
			    == KERN_SUCCESS) {
d199 1
d202 7
a208 1
			    == KERN_SUCCESS) {
d230 1
d232 3
d341 2
a342 12
		/* alignment exception 
		 * we check to see if this can be fixed up
		 * by the code that fixes the typical gcc misaligned code
		 * then kill the process if not.
		 */
		if (fix_unaligned(p, frame) == 0) {
			frame->srr0 += 4;
		} else {
			sv.sival_int = frame->srr0;
			trapsignal(p, SIGSEGV, VM_PROT_EXECUTE, SEGV_MAPERR,
				sv);
		}
d364 1
d424 1
d426 3
a590 49
}

/*
 * For now, this only deals with the particular unaligned access case
 * that gcc tends to generate.  Eventually it should handle all of the
 * possibilities that can happen on a 32-bit PowerPC in big-endian mode.
 */

static int
fix_unaligned(p, frame)
	struct proc *p;
	struct trapframe *frame;
{
	int indicator = EXC_ALI_OPCODE_INDICATOR(frame->dsisr);

	switch (indicator) {
	case EXC_ALI_LFD:
	case EXC_ALI_STFD:
		{
			int reg = EXC_ALI_RST(frame->dsisr);
			double *fpr = &p->p_addr->u_pcb.pcb_fpu.fpr[reg];

			/* Juggle the FPU to ensure that we've initialized
			 * the FPRs, and that their current state is in
			 * the PCB.
			 */
			if (fpuproc != p) {
				if (fpuproc)
					save_fpu(fpuproc);
				enable_fpu(p);
			}
			save_fpu(p);

			if (indicator == EXC_ALI_LFD) {
				if (copyin((void *)frame->dar, fpr,
				    sizeof(double)) != 0)
					return -1;
				enable_fpu(p);
			} else {
				if (copyout(fpr, (void *)frame->dar,
				    sizeof(double)) != 0)
					return -1;
			}
			return 0;
		}
		break;
	}

	return -1;
@


1.16.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16.2.3 2001/07/04 10:23:03 niklas Exp $	*/
d43 5
a48 1
#include <machine/fpu.h>
a55 7
#include <vm/vm.h>

#include <uvm/uvm_extern.h>

#include <ddb/db_extern.h>
#include <ddb/db_sym.h>

a56 2
int badaddr __P((char *addr, u_int32_t len));
void trap __P((struct trapframe *frame));
d66 1
a66 2
void ppc_dumpbt __P((struct trapframe *frame));

a78 1

a86 2
	char *name;
	db_expr_t offset;
d105 1
a105 1
			if ((fb = p->p_addr->u_pcb.pcb_onfault)) {
d145 1
a145 1
			if ((fb = p->p_addr->u_pcb.pcb_onfault)) {
d249 3
a251 2
				if ((error = copyin(MOREARGS(frame->fixreg[1]),
				   args + n, argsize - n * sizeof(register_t)))) {
d343 2
a344 7
		db_find_sym_and_offset(frame->srr0, &name, &offset);
		if (!name) {
			name = "0";
			offset = frame->srr0;
		}
		panic ("trap type %x at %x (%s+0x%x) lr %x\n",
			type, frame->srr0, name, offset, frame->lr);
d396 1
a396 1
		db_trap(T_BREAKPOINT, 0);
d421 1
a421 1
		while ((sig = CURSIG(p)))
d427 1
a427 1
		int sig;
d430 6
a435 1
		 * We're being preempted.
d437 6
a442 2
		preempt(NULL);
		while ((sig = CURSIG(p)))
d483 2
a484 1
setusr(int content)
a496 1
	register void *oldh = curpcb->pcb_onfault;
d499 1
a499 1
		curpcb->pcb_onfault = oldh;
d513 1
a513 1
	curpcb->pcb_onfault = oldh;
a525 1
	register void *oldh = curpcb->pcb_onfault;
d528 1
a528 1
		curpcb->pcb_onfault = oldh;
d542 1
a542 1
	curpcb->pcb_onfault = oldh;
a554 1
	register void *oldh = curpcb->pcb_onfault;
d557 1
a557 1
		curpcb->pcb_onfault = oldh;
d571 1
a571 1
	curpcb->pcb_onfault = oldh;
@


1.16.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 2
a404 1
	}
d415 1
a415 8
	/* This is not really a perf exception, but is an ALTIVEC unavail
	 * which we do not handle, kill the process with illegal instruction.
	 */
	case EXC_PERF|EXC_USER:
		sv.sival_int = frame->srr0;
		trapsignal(p, SIGILL, 0, ILL_ILLOPC, sv);
		break;

d468 2
a469 2
child_return(arg)
	void *arg;
a470 1
	struct proc *p = (struct proc *)arg;
@


1.16.2.6
log
@repair
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16.2.5 2001/11/13 21:04:16 niklas Exp $	*/
@


1.16.2.7
log
@Re-add missing pieces
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.45 2002/03/14 23:51:47 drahn Exp $	*/
a41 1
#include <sys/pool.h>
d57 3
a59 3
static int fix_unaligned(struct proc *p, struct trapframe *frame);
int badaddr(char *addr, u_int32_t len);
void trap(struct trapframe *frame);
a66 1
struct proc *ppc_vecproc;
d69 1
a69 1
void ppc_dumpbt(struct trapframe *frame);
a83 172
#ifdef ALTIVEC
/*
 * Save state of the vector processor, This is done lazily in the hope
 * that few processes in the system will be using the vector unit
 * and that the exception time taken to switch them will be less than
 * the necessary time to save the vector on every context switch.
 *
 * Also note that in this version, the VRSAVE register is saved with
 * the state of the current process holding the vector processor,
 * and the contents of that register are not used to optimize the save.
 *
 * This can lead to VRSAVE corruption, data passing between processes,
 * because this register is accessable without the MSR[VEC] bit set.
 * To store/restore this cleanly a processor identifier bit would need
 * to be saved and this register saved on every context switch.
 * Since we do not use the information, we may be able to get by
 * with not saving it rigorously.
 */
void
save_vec(struct proc *p)
{
	struct pcb *pcb = &p->p_addr->u_pcb;
	struct vreg *pcb_vr = pcb->pcb_vr;
	u_int32_t oldmsr, msr;
	u_int32_t tmp;
	/* first we enable vector so that we dont throw an exception
	 * in kernel mode
	 */
	__asm__ volatile ("mfmsr %0" : "=r" (oldmsr));
	msr = oldmsr | PSL_VEC;
	__asm__ volatile ("mtmsr %0" :: "r" (msr));
	__asm__ volatile ("sync;isync");

	__asm__ volatile ("mfspr %0, 256" : "=r" (tmp));
	pcb->pcb_vr->vrsave = tmp;

#ifdef AS_SUPPORTS_ALTIVEC
#define STR(x) #x
#define SAVE_VEC_REG(reg, addr)   \
	__asm__ volatile ("stvxl %0, 0, %1" :: "n"(reg),"r" (addr));
#else
#define STR(x) #x
#define SAVE_VEC_REG(reg, addr)   \
	__asm__ volatile (".long 0x7c0003ce + (%0 << 21) + (%1 << 11)" :: "n"(reg), "r" (addr))
#endif

	SAVE_VEC_REG(0,&pcb_vr->vreg[0]);
	SAVE_VEC_REG(1,&pcb_vr->vreg[1]);
	SAVE_VEC_REG(2,&pcb_vr->vreg[2]);
	SAVE_VEC_REG(3,&pcb_vr->vreg[3]);
	SAVE_VEC_REG(4,&pcb_vr->vreg[4]);
	SAVE_VEC_REG(5,&pcb_vr->vreg[5]);
	SAVE_VEC_REG(6,&pcb_vr->vreg[6]);
	SAVE_VEC_REG(7,&pcb_vr->vreg[7]);
	SAVE_VEC_REG(8,&pcb_vr->vreg[8]);
	SAVE_VEC_REG(9,&pcb_vr->vreg[9]);
	SAVE_VEC_REG(10,&pcb_vr->vreg[10]);
	SAVE_VEC_REG(11,&pcb_vr->vreg[11]);
	SAVE_VEC_REG(12,&pcb_vr->vreg[12]);
	SAVE_VEC_REG(13,&pcb_vr->vreg[13]);
	SAVE_VEC_REG(14,&pcb_vr->vreg[14]);
	SAVE_VEC_REG(15,&pcb_vr->vreg[15]);
	SAVE_VEC_REG(16,&pcb_vr->vreg[16]);
	SAVE_VEC_REG(17,&pcb_vr->vreg[17]);
	SAVE_VEC_REG(18,&pcb_vr->vreg[18]);
	SAVE_VEC_REG(19,&pcb_vr->vreg[19]);
	SAVE_VEC_REG(20,&pcb_vr->vreg[20]);
	SAVE_VEC_REG(21,&pcb_vr->vreg[21]);
	SAVE_VEC_REG(22,&pcb_vr->vreg[22]);
	SAVE_VEC_REG(23,&pcb_vr->vreg[23]);
	SAVE_VEC_REG(24,&pcb_vr->vreg[24]);
	SAVE_VEC_REG(25,&pcb_vr->vreg[25]);
	SAVE_VEC_REG(26,&pcb_vr->vreg[26]);
	SAVE_VEC_REG(27,&pcb_vr->vreg[27]);
	SAVE_VEC_REG(28,&pcb_vr->vreg[28]);
	SAVE_VEC_REG(29,&pcb_vr->vreg[29]);
	SAVE_VEC_REG(30,&pcb_vr->vreg[30]);
	SAVE_VEC_REG(31,&pcb_vr->vreg[31]);
#ifdef AS_SUPPORTS_ALTIVEC
	__asm__ volatile ("mfvscr 0");
#else 
	__asm__ volatile (".long 0x10000604");
#endif
	SAVE_VEC_REG(0,&pcb_vr->vscr);

	/* fix kernel msr back */
	__asm__ volatile ("mfmsr %0" :: "r" (oldmsr));
}

/*
 * Copy the context of a given process into the vector registers.
 */
void
enable_vec(struct proc *p)
{
	struct pcb *pcb = &p->p_addr->u_pcb;
	struct vreg *pcb_vr = pcb->pcb_vr;
	u_int32_t oldmsr, msr;
	u_int32_t tmp;

	/* If this is the very first altivec instruction executed
	 * by this process, create a context.
	 */
	if (pcb->pcb_vr == NULL) {
		pcb->pcb_vr = pool_get(&ppc_vecpl, PR_WAITOK);
		bzero(pcb->pcb_vr, sizeof *(pcb->pcb_vr));
	}

	/* first we enable vector so that we dont throw an exception
	 * in kernel mode
	 */
	__asm__ volatile ("mfmsr %0" : "=r" (oldmsr));
	msr = oldmsr | PSL_VEC;
	__asm__ volatile ("mtmsr %0" :: "r" (msr));
	__asm__ volatile ("sync;isync");

#ifdef AS_SUPPORTS_ALTIVEC
#define LOAD_VEC_REG(reg, addr)   \
	__asm__ volatile ("lvxl %0, 0, %1" :: "n"(reg), "r" (addr));
#else
#define LOAD_VEC_REG(reg, addr)   \
	__asm__ volatile (".long 0x7c0002ce + (%0 << 21) + (%1 << 11)" :: "n"(reg), "r" (addr));
#endif

	LOAD_VEC_REG(0, &pcb_vr->vscr);
#ifdef AS_SUPPORTS_ALTIVEC
	__asm__ volatile ("mtvscr 0");
#else
	__asm__ volatile (".long 0x10000644");
#endif
	tmp = pcb_vr->vrsave;
	__asm__ volatile ("mtspr 256, %0" :: "r" (tmp));

	LOAD_VEC_REG(0, &pcb_vr->vreg[0]);
	LOAD_VEC_REG(1, &pcb_vr->vreg[1]);
	LOAD_VEC_REG(2, &pcb_vr->vreg[2]);
	LOAD_VEC_REG(3, &pcb_vr->vreg[3]);
	LOAD_VEC_REG(4, &pcb_vr->vreg[4]);
	LOAD_VEC_REG(5, &pcb_vr->vreg[5]);
	LOAD_VEC_REG(6, &pcb_vr->vreg[6]);
	LOAD_VEC_REG(7, &pcb_vr->vreg[7]);
	LOAD_VEC_REG(8, &pcb_vr->vreg[8]);
	LOAD_VEC_REG(9, &pcb_vr->vreg[9]);
	LOAD_VEC_REG(10, &pcb_vr->vreg[10]);
	LOAD_VEC_REG(11, &pcb_vr->vreg[11]);
	LOAD_VEC_REG(12, &pcb_vr->vreg[12]);
	LOAD_VEC_REG(13, &pcb_vr->vreg[13]);
	LOAD_VEC_REG(14, &pcb_vr->vreg[14]);
	LOAD_VEC_REG(15, &pcb_vr->vreg[15]);
	LOAD_VEC_REG(16, &pcb_vr->vreg[16]);
	LOAD_VEC_REG(17, &pcb_vr->vreg[17]);
	LOAD_VEC_REG(18, &pcb_vr->vreg[18]);
	LOAD_VEC_REG(19, &pcb_vr->vreg[19]);
	LOAD_VEC_REG(20, &pcb_vr->vreg[20]);
	LOAD_VEC_REG(21, &pcb_vr->vreg[21]);
	LOAD_VEC_REG(22, &pcb_vr->vreg[22]);
	LOAD_VEC_REG(23, &pcb_vr->vreg[23]);
	LOAD_VEC_REG(24, &pcb_vr->vreg[24]);
	LOAD_VEC_REG(25, &pcb_vr->vreg[25]);
	LOAD_VEC_REG(26, &pcb_vr->vreg[26]);
	LOAD_VEC_REG(27, &pcb_vr->vreg[27]);
	LOAD_VEC_REG(28, &pcb_vr->vreg[28]);
	LOAD_VEC_REG(29, &pcb_vr->vreg[29]);
	LOAD_VEC_REG(30, &pcb_vr->vreg[30]);
	LOAD_VEC_REG(31, &pcb_vr->vreg[31]);

	/* fix kernel msr back */
	__asm__ volatile ("mfmsr %0" :: "r" (oldmsr));
}
#endif /* ALTIVEC */


d127 1
a127 1
			struct vm_map *map;
d134 1
a134 1
			if ((va >> ADDR_SR_SHIFT) == USER_SR) {
d140 1
a140 1
				va |= user_sr << ADDR_SR_SHIFT;
a141 3
				if (pte_spill_v(map->pmap, va, frame->dsisr)) {
					return;
				}
d147 3
a149 1
			if (uvm_fault(map, trunc_page(va), 0, ftype) == 0) {
a168 7
			if (pte_spill_v(p->p_vmspace->vm_map.pmap,
				frame->dar, frame->dsisr))
			{
				/* fault handled by spill handler */
				break;
			}

d175 2
a176 1
				     trunc_page(frame->dar), 0, ftype) == 0) {
a192 6
			if (pte_spill_v(p->p_vmspace->vm_map.pmap,
				frame->srr0, 0))
			{
				/* fault handled by spill handler */
				break;
			}
d195 2
a196 1
				     trunc_page(frame->srr0), 0, ftype) == 0) {
d201 1
a201 1
printf("isi iar %x lr %x\n", frame->srr0, frame->lr);
a395 2
{ 
int i;
a398 1
}
d415 1
a415 1
	 * if we do not handle it, kill the process with illegal instruction.
a417 9
#ifdef ALTIVEC 
	case EXC_VEC|EXC_USER:
		if (ppc_vecproc) {
			save_vec(ppc_vecproc);
		}
		ppc_vecproc = p;
		enable_vec(p);
		break;
#else  /* ALTIVEC */
a420 1
#endif
a422 1
		uvmexp.softs++;
d429 2
d468 1
a468 1
	if (p != fpuproc) {
a469 15
	} else {
		frame->srr1 |= PSL_FP;
	}

#ifdef ALTIVEC
	/*
	 * If someone stole the vector unit while we were away, disable it
	 */
	if (p != ppc_vecproc) {
		frame->srr1 &= ~PSL_VEC;
	} else {
		frame->srr1 |= PSL_VEC;
	}
#endif /* ALTIVEC */

d484 1
a484 2
	/* Disable FPU, VECT, as we can't be fpuproc */
	tf->srr1 &= ~(PSL_FP|PSL_VEC);
d493 7
d528 59
@


1.16.2.8
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a43 2
#include <dev/cons.h>

a52 3
#include "systrace.h"
#include <dev/systrace.h>

a56 1
#include <ddb/db_output.h>
a59 1
static __inline void userret(struct proc *, int, u_quad_t);
d80 1
a80 1
		addr = db_dumpframe(addr, db_printf);
d122 1
d126 5
d164 1
d166 3
d202 1
d205 4
d211 1
d213 3
a256 30
static __inline void
userret(register struct proc *p, int pc, u_quad_t oticks)
{
	int sig;

	/* take pending signals */
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);
	p->p_priority = p->p_usrpri;
	if (want_resched) {

		/*
		 * We're being preempted.
		 */
		preempt(NULL);
		while ((sig = CURSIG(p)))
			postsig(sig);
	}

	/*
	 * If profiling, charge recent system time to the trapped pc.
	 */
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, pc, (int)(p->p_sticks - oticks) * psratio);
	}

	curpriority = p->p_priority;
}
d316 1
a316 1
				if (pte_spill_v(map->pmap, va, frame->dsisr, 0)) {
d345 1
a345 1
				frame->dar, frame->dsisr, 0))
d375 1
a375 1
				frame->srr0, 0, 1))
d462 1
a462 1
			scdebug_call(p, code, params);
d466 1
a466 8
#if NSYSTRACE > 0
			if (ISSET(p->p_flag, P_SYSTRACE))
				error = systrace_redirect(code, p, params,
				    rval);
			else
#endif
				error = (*callp->sy_call)(p, params, rval);
			switch (error) {
d534 1
a535 3
#else
		name = NULL;
#endif
d540 1
a540 1
		panic ("trap type %x at %x (%s+0x%x) lr %x",
d561 1
a561 1
			errstr[errnum] = "privileged instr";
a570 1
					cnpollc(TRUE);
a571 1
					cnpollc(FALSE);
a596 1
		cnpollc(TRUE);
a597 1
		cnpollc(FALSE);
d634 19
a652 1
	userret(p, frame->srr0, sticks);
d655 9
d682 2
a698 3

	userret(p, tf->srr0, 0);

d703 2
d716 1
a716 1
	if (setfault(&env)) {
@


1.16.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d86 1
a86 1
	while (addr != 0)
d88 1
d117 1
a117 4

	if (p == NULL)
		return;

d121 1
a121 1
	oldmsr = ppc_mfmsr();
d123 1
a123 1
	ppc_mtmsr(msr);
d126 2
a127 1
	pcb->pcb_vr->vrsave = ppc_mfvrsave();
d169 1
a169 1
	ppc_mtmsr(oldmsr);
d181 1
d194 1
a194 1
	oldmsr = ppc_mfmsr();
d196 1
a196 1
	ppc_mtmsr(msr);
d204 2
a205 1
	ppc_mtvrsave(pcb_vr->vrsave);
d241 1
a241 1
	ppc_mtmsr(oldmsr);
d246 1
a246 1
userret(struct proc *p, int pc, u_quad_t oticks)
d255 4
a258 1
		/* We're being preempted.  */
d277 2
a278 1
trap(struct trapframe *frame)
d334 1
a334 1
				if (pte_spill_v(map->pmap, va, frame->dsisr, 0))
d336 1
d342 1
a342 1
			if (uvm_fault(map, trunc_page(va), 0, ftype) == 0)
d344 1
a344 1

a361 1
			/* Try spill handler first */
d363 3
a365 1
			    frame->dar, frame->dsisr, 0))
d367 1
d375 1
a375 1
				     trunc_page(frame->dar), 0, ftype) == 0)
d377 1
a377 1

a391 1
			/* Try spill handler */
d393 3
a395 1
			    frame->srr0, 0, 1))
d397 1
a397 1

d400 1
a400 1
			    trunc_page(frame->srr0), 0, ftype) == 0)
d402 1
d460 2
a461 4

				error = copyin(MOREARGS(frame->fixreg[1]),
				   args + n, argsize - n * sizeof(register_t));
				if (error) {
d540 1
a540 1
		if (fix_unaligned(p, frame) == 0)
d542 1
a542 1
		else {
d567 1
a567 1
		panic ("trap type %x at %x (%s+0x%lx) lr %x",
d640 1
a640 1
		if (ppc_vecproc)
d642 1
a642 1

d670 1
a670 1
	if (p != fpuproc)
d672 1
a672 1
	else
d674 1
d680 1
a680 1
	if (p != ppc_vecproc)
d682 1
a682 1
	else
d684 1
d689 2
a690 1
child_return(void *arg)
d711 3
a713 1
badaddr(char *addr, u_int32_t len)
d717 1
a717 1
	void *oldh = curpcb->pcb_onfault;
d746 3
a748 1
fix_unaligned(struct proc *p, struct trapframe *frame)
d784 1
@


1.15
log
@move some code under ifdef DDB, it uses a db_ function during the call.
It is a debugging operation anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.14 1999/04/22 06:08:06 rahnds Exp $	*/
d45 4
d139 4
d145 2
d148 1
d171 5
d179 2
d182 1
d196 5
d204 2
d207 1
d225 3
d229 1
d411 3
d415 1
d505 1
a505 1
		return EACCES;
d534 1
a534 1
		return EACCES;
d563 1
a563 1
		return EACCES;
@


1.14
log
@Bug fixes from NetBSD, port-powerpc/7240 and port-powerpc/7243

The first fixes a major problem seen _too_ many times to record.
If a task that is busy doing disk io is interrupted with a ^C,
its would frequently put the system into a mode where it would
very shortly crash, It was known that it was a signal delivery
that was occurring incorrectly, but had not been diagnosed where.
It is no longer possible to crash the machine on whim.
(This probably should be recorded as a stability patch for 25).

The second was not a bug that had ever been seen to be identified,
but looking at the code it was obvious that the onfault variable was not
being reset before the function exit. The code differs between NetBSD
and OpenBSD somewhat, however only two instances of the code was
reported, and three instances exist in the OpenBSD code. (all were fixed).
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.13 1999/03/13 01:49:07 rahnds Exp $	*/
d60 2
a61 2
#ifdef PPC_WANT_BACKTRACE
u_int32_t dumpframe(u_int32_t);
d65 1
d69 1
a69 1
		addr = dumpframe(addr);
a166 1
ppc_dumpbt(frame);
@


1.13
log
@If a program crashes due to a "program" exeception, dump additional
information as to why, illegal instruction, floating point, ...
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.12 1998/09/09 04:54:43 rahnds Exp $	*/
d136 1
a136 1
				break;
d468 2
a469 1
	if (setfault(env))
d471 1
d497 2
a498 1
	if (setfault(env))
d500 1
d527 1
@


1.12
log
@Weak version of support for ddb breakpoints. Works, but not fully
implemented.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11 1998/08/25 08:02:23 pefo Exp $	*/
d319 6
a324 2
printf("pgm iar %x\n", frame->srr0);
		if (frame->srr1 && (1<<11)) { 
d326 4
a329 2
		}
		if (frame->srr1 && (1<<12)) {
d331 2
d334 1
a334 1
		if (frame->srr1 && (1<<13)) {
d336 2
d339 3
a341 1
		if (frame->srr1 && (1<<14)) {
d351 8
d372 1
@


1.11
log
@Add badaddr() and fix faultbuf handling
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.10 1998/08/22 17:54:26 rahnds Exp $	*/
d331 7
d342 10
@


1.10
log
@Changes to get a at least mostly working kernel debugger.
Need to get symbol support in the loader too.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.9 1998/08/07 02:22:09 rahnds Exp $	*/
d94 18
d138 6
a143 4
				frame->srr0 = (*fb)[0];
				frame->fixreg[1] = (*fb)[1];
				frame->cr = (*fb)[2];
				bcopy(&(*fb)[3], &frame->fixreg[13], 19);
d183 3
d423 25
d484 1
a484 1
	if (setfault(env))
d486 1
@


1.9
log
@Add kernel support for debugging with gdb. This also make /proc allow
access to the registers. The format of the registers returned in ptrace,
/proc and in the coredump header match what gdb was expecting.
Floating point registers are not yet copied into the structure.
The location of the fpr needs to be found and copied. <- TODO

Changes to trap.c was to add some interm debugging. code is commented out.

powerpc does not currently have a MID_* type, since it uses ELF instead
of a.out, one was never added. Currently the coredump is done in form
of MID_NONE. What is the correct approach for this?? Elf format coredumps...
maybe?
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.8 1998/05/29 04:15:41 rahnds Exp $	*/
d51 1
d61 1
a61 20
void dumpframe (u_int32_t pframe)
{
	u_int32_t nextframe;
	u_int32_t lr;
	int error;
	if (error = copyin ((void *)pframe, &nextframe , 4) ){
		printf("unable to read next frame @@%x\n", pframe);
		return;
	}
	if (error = copyin ((void *)(pframe+4), &lr , 4) ){
		printf("unable to read lr @@%x\n", pframe+4);
		return;
	}
	printf("lr %x fp %x nfp %x\n", lr, pframe, nextframe);

	if (nextframe != 0) {
		dumpframe(nextframe);
	}
	return;
}
d65 5
a69 1
	dumpframe(frame->fixreg[1]);
d88 5
a92 2
	case EXC_TRC|EXC_USER:		/* Temporarily!					XXX */
		printf("TRC: %x\n", frame->srr0);
d287 5
d294 1
d297 12
@


1.8
log
@Major changes here and there, tweaks elsewhere.
Support for Openfirmware drivers was reintroduced so that more systems
were supported. This should work with the real driver configurations
as well.

Bootloader files were deleted/replaced with the newer versions in the
subdirectory. Some effort has been made to be closer to support booting
(at least the bootloader) on the Mac.

Config files that end with OFW are the openfirmware versions of the kernels
without have native drivers.

Native driver support has not been changed, presumably it still works.
I couldn't test that.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.7 1998/04/06 20:21:11 pefo Exp $	*/
d59 28
d154 5
a158 1
printf("dsi on addr %x iar %x\n", frame->dar, frame->srr0);
@


1.7
log
@somewhat more correct trapsignal call
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.6 1997/10/13 13:43:01 pefo Exp $	*/
d263 1
d265 1
@


1.6
log
@Monolithic (No OpenFirmware driver crap...) PowerPC kernel. This is the
first release based on Wolfgang Solfrank, TooLs GmbH, work. Most OFW stuff
has been ripped out. Only a few functions for memory probing and halt/reboot
functionality has been kept. The kernel currently works with V.I's power.4e
PowerPC604 board, but more will come.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.5 1997/02/05 06:10:05 rahnds Exp $	*/
d66 1
d127 2
a128 2
			trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR,
			    frame->dar);
d142 2
a143 2
		trapsignal(p, SIGSEGV, VM_PROT_EXECUTE, SEGV_MAPERR,
		    frame->srr0);
d268 2
a269 1
		trapsignal(p, SIGILL, 0, ILL_ILLOPC, frame->srr0);
@


1.5
log
@Fixups of the siginfo code changes.
All of the siginfo changes were from theo, I just cleaned up the header
files and tested it.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.4 1997/02/05 01:33:55 rahnds Exp $	*/
a56 1
volatile int astpending;
d262 1
@


1.4
log
@Siginfo changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.3 1996/12/28 06:22:27 rahnds Exp $	*/
d115 1
a115 1
			int ftype;
d117 1
a117 1
			if (frame->dsisr & DSISR_STORE)
d119 3
a121 2
			else
				ftype = VM_PROT_READ;
d126 3
a129 2
printf("dsi on addr %x iar %x\n", frame->dar, frame->srr0);
		trapsignal(p, SIGSEGV, EXC_DSI, SEGV_MAPERR, frame->dar);
d142 2
a143 1
		trapsignal(p, SIGSEGV, EXC_ISI, SEGV_MAPERR, frame->srr0);
d267 1
a267 1
		trapsignal(p, SIGILL, EXC_PGM, ILL_ILLOPC, frame->srr0);
@


1.3
log
@Adding OpenBSD tags to files.
@
text
@d1 1
a1 1
/*	$OpenBSD:$	*/
d127 1
a127 1
		trapsignal(p, SIGSEGV, EXC_DSI);
d140 1
a140 1
		trapsignal(p, SIGSEGV, EXC_ISI);
d264 1
a264 1
		trapsignal(p, SIGILL,EXC_PGM);
@


1.2
log
@Changes necessary to make the kernel compile and boot.
Some merging with NetBSD port.
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d110 1
d125 1
a125 1
printf("dsi on addr %x iar %x\n", frame->dsisr, frame->srr0);
d354 1
a354 1
	void *udaddr;
d381 1
a381 1
	void *kaddr;
@


1.1.1.1
log
@Check-in of powerpc kernel support.
NOTE: This will not work until the other pieces are checked in.
This is primarily the NetBSD powerpc port, with modifications
to support ELF. 
@
text
@@
