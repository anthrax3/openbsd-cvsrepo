head	1.22;
access;
symbols
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.18.0.14
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.10
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.8
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.6
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.4
	OPENBSD_5_0:1.18.0.2
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.16
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.12
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.10
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.8
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.13.0.4
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.10
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.8
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.10.0.4
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.7.0.10
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.8
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.6
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.0.2
	OPENBSD_2_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.22
date	2015.09.02.14.07.43;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	cHp48PuRRgzjq4bx;

1.21
date	2015.05.19.20.28.14;	author miod;	state Exp;
branches;
next	1.20;
commitid	YdrkA6WJKqXchmio;

1.20
date	2014.12.09.06.58.28;	author doug;	state Exp;
branches;
next	1.19;
commitid	yWAxzpQP2PPpYlfT;

1.19
date	2014.07.12.18.44.40;	author tedu;	state Exp;
branches;
next	1.18;
commitid	uKVPYMN2MLxdZxzH;

1.18
date	2011.04.15.20.40.05;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2010.09.20.06.33.46;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.30.20.16.22;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.15.20.08.29;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.29.10.47.35;	author martin;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.25.23.02.23;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.28.02.28.42;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.26;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.25.00.43.07;	author mickey;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	2000.11.08.21.27.13;	author ericj;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.08.16.01.08;	author art;	state Exp;
branches;
next	1.7;

1.7
date	99.02.08.18.14.11;	author millert;	state Exp;
branches
	1.7.6.1;
next	1.6;

1.6
date	99.02.08.00.05.09;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.12.31.09.17.58;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	98.12.27.00.27.18;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	98.06.29.05.32.50;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	97.11.10.15.53.08;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.07.09.02.58.34;	author deraadt;	state Exp;
branches;
next	;

1.7.6.1
date	2001.04.18.16.00.44;	author niklas;	state Exp;
branches;
next	1.7.6.2;

1.7.6.2
date	2001.07.04.10.14.34;	author niklas;	state Exp;
branches;
next	1.7.6.3;

1.7.6.3
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	;

1.10.4.1
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	;


desc
@@


1.22
log
@sizes for free()
@
text
@/* $OpenBSD: shared_intr.c,v 1.21 2015/05/19 20:28:14 miod Exp $ */
/* $NetBSD: shared_intr.c,v 1.13 2000/03/19 01:46:18 thorpej Exp $ */

/*
 * Copyright (c) 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Authors: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 * Common shared-interrupt-line functionality.
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/syslog.h>
#include <sys/queue.h>

#include <machine/intr.h>

static const char *intr_typename(int);

static const char *
intr_typename(type)
	int type;
{

	switch (type) {
	case IST_UNUSABLE:
		return ("disabled");
	case IST_NONE:
		return ("none");
	case IST_PULSE:
		return ("pulsed");
	case IST_EDGE:
		return ("edge-triggered");
	case IST_LEVEL:
		return ("level-triggered");
	}
	panic("intr_typename: unknown type %d", type);
}

struct alpha_shared_intr *
alpha_shared_intr_alloc(n)
	unsigned int n;
{
	struct alpha_shared_intr *intr;
	unsigned int i;

	intr = mallocarray(n, sizeof(struct alpha_shared_intr), M_DEVBUF,
	    cold ? M_NOWAIT : M_WAITOK);
	if (intr == NULL)
		panic("alpha_shared_intr_alloc: couldn't malloc intr");

	for (i = 0; i < n; i++) {
		TAILQ_INIT(&intr[i].intr_q);
		intr[i].intr_sharetype = IST_NONE;
		intr[i].intr_dfltsharetype = IST_NONE;
		intr[i].intr_nstrays = 0;
		intr[i].intr_maxstrays = 5;
		intr[i].intr_private = NULL;
	}

	return (intr);
}

int
alpha_shared_intr_dispatch(intr, num)
	struct alpha_shared_intr *intr;
	unsigned int num;
{
	struct alpha_shared_intrhand *ih;
	int rv, handled;

	handled = 0;
	TAILQ_FOREACH(ih, &intr[num].intr_q, ih_q) {
#if defined(MULTIPROCESSOR)
		/* XXX Need to support IPL_MPSAFE eventually. */
		if (ih->ih_level < IPL_CLOCK)
			__mp_lock(&kernel_lock);
#endif
		/*
		 * The handler returns one of three values:
		 *   0:	This interrupt wasn't for me.
		 *   1: This interrupt was for me.
		 *  -1: This interrupt might have been for me, but I can't say
		 *      for sure.
		 */
		rv = (*ih->ih_fn)(ih->ih_arg);
		if (rv)
			ih->ih_count.ec_count++;
#if defined(MULTIPROCESSOR)
		if (ih->ih_level < IPL_CLOCK)
			__mp_unlock(&kernel_lock);
#endif
		handled = handled || (rv != 0);
		if (intr_shared_edge == 0 && rv == 1)
			break;
	}

	return (handled);
}

void *
alpha_shared_intr_establish(intr, num, type, level, fn, arg, basename)
	struct alpha_shared_intr *intr;
	unsigned int num;
	int type, level;
	int (*fn)(void *);
	void *arg;
	const char *basename;
{
	struct alpha_shared_intrhand *ih;

	if (intr[num].intr_sharetype == IST_UNUSABLE) {
		printf("alpha_shared_intr_establish: %s %d: unusable\n",
		    basename, num);
		return NULL;
	}

	/* no point in sleeping unless someone can free memory. */
	ih = malloc(sizeof *ih, M_DEVBUF, cold ? M_NOWAIT : M_WAITOK);
	if (ih == NULL)
		panic("alpha_shared_intr_establish: can't malloc intrhand");

#ifdef DIAGNOSTIC
	if (type == IST_NONE)
		panic("alpha_shared_intr_establish: bogus type");
#endif

	switch (intr[num].intr_sharetype) {
	case IST_EDGE:
		intr_shared_edge = 1;
		/* FALLTHROUGH */
	case IST_LEVEL:
		if (type == intr[num].intr_sharetype)
			break;
	case IST_PULSE:
		if (type != IST_NONE) {
			if (TAILQ_EMPTY(&intr[num].intr_q)) {
				printf("alpha_shared_intr_establish: %s %d: warning: using %s on %s\n",
				    basename, num, intr_typename(type),
				    intr_typename(intr[num].intr_sharetype));
				type = intr[num].intr_sharetype;
			} else {
				panic("alpha_shared_intr_establish: %s %d: can't share %s with %s",
				    basename, num, intr_typename(type),
				    intr_typename(intr[num].intr_sharetype));
			}
		}
		break;

	case IST_NONE:
		/* not currently used; safe */
		break;
	}

	ih->ih_intrhead = intr;
	ih->ih_fn = fn;
	ih->ih_arg = arg;
	ih->ih_level = level;
	ih->ih_num = num;
	evcount_attach(&ih->ih_count, basename, &ih->ih_num);

	intr[num].intr_sharetype = type;
	TAILQ_INSERT_TAIL(&intr[num].intr_q, ih, ih_q);

	return (ih);
}

void
alpha_shared_intr_disestablish(intr, cookie)
	struct alpha_shared_intr *intr;
	void *cookie;
{
	struct alpha_shared_intrhand *ih = cookie;
	unsigned int num = ih->ih_num;

	/*
	 * Just remove it from the list and free the entry.  We let
	 * the caller deal with resetting the share type, if appropriate.
	 */
	evcount_detach(&ih->ih_count);
	TAILQ_REMOVE(&intr[num].intr_q, ih, ih_q);
	free(ih, M_DEVBUF, sizeof *ih);
}

int
alpha_shared_intr_get_sharetype(intr, num)
	struct alpha_shared_intr *intr;
	unsigned int num;
{

	return (intr[num].intr_sharetype);
}

int
alpha_shared_intr_isactive(intr, num)
	struct alpha_shared_intr *intr;
	unsigned int num;
{

	return (!TAILQ_EMPTY(&intr[num].intr_q));
}

int
alpha_shared_intr_firstactive(struct alpha_shared_intr *intr, unsigned int num)
{

	return (!TAILQ_EMPTY(&intr[num].intr_q) &&
		TAILQ_NEXT(intr[num].intr_q.tqh_first, ih_q) == NULL);
}

void
alpha_shared_intr_set_dfltsharetype(intr, num, newdfltsharetype)
	struct alpha_shared_intr *intr;
	unsigned int num;
	int newdfltsharetype;
{

#ifdef DIAGNOSTIC
	if (alpha_shared_intr_isactive(intr, num))
		panic("alpha_shared_intr_set_dfltsharetype on active intr");
#endif

	intr[num].intr_dfltsharetype = newdfltsharetype;
	intr[num].intr_sharetype = intr[num].intr_dfltsharetype;
}

void
alpha_shared_intr_set_maxstrays(intr, num, newmaxstrays)
	struct alpha_shared_intr *intr;
	unsigned int num;
	int newmaxstrays;
{
	int s = splhigh();
	intr[num].intr_maxstrays = newmaxstrays;
	intr[num].intr_nstrays = 0;
	splx(s);
}

void
alpha_shared_intr_reset_strays(intr, num)
	struct alpha_shared_intr *intr;
	unsigned int num;
{

	/*
	 * Don't bother blocking interrupts; this doesn't have to be
	 * precise, but it does need to be fast.
	 */
	intr[num].intr_nstrays = 0;
}

void
alpha_shared_intr_stray(intr, num, basename)
	struct alpha_shared_intr *intr;
	unsigned int num;
	const char *basename;
{

	intr[num].intr_nstrays++;

	if (intr[num].intr_maxstrays == 0)
		return;

	if (intr[num].intr_nstrays <= intr[num].intr_maxstrays)
		log(LOG_ERR, "stray %s %d%s\n", basename, num,
		    intr[num].intr_nstrays >= intr[num].intr_maxstrays ?
		      "; stopped logging" : "");
}

void
alpha_shared_intr_set_private(intr, num, v)
	struct alpha_shared_intr *intr;
	unsigned int num;
	void *v;
{

	intr[num].intr_private = v;
}

void *
alpha_shared_intr_get_private(intr, num)
	struct alpha_shared_intr *intr;
	unsigned int num;
{

	return (intr[num].intr_private);
}
@


1.21
log
@Move acquisition of the kernel lock deeper in the interrupt path, and make
sure clock interrupts do not attempt to acquire it.
This will also eventually allow for IPL_MPSAFE interrupts on alpha.

Tested by dlg@@ and I.
@
text
@d1 1
a1 1
/* $OpenBSD: shared_intr.c,v 1.20 2014/12/09 06:58:28 doug Exp $ */
d208 1
a208 1
	free(ih, M_DEVBUF, 0);
@


1.20
log
@Replace some malloc(n*size,...) calls with mallocarray().

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: shared_intr.c,v 1.19 2014/07/12 18:44:40 tedu Exp $ */
d100 5
d115 4
@


1.19
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: shared_intr.c,v 1.18 2011/04/15 20:40:05 deraadt Exp $ */
d73 1
a73 1
	intr = malloc(n * sizeof (struct alpha_shared_intr), M_DEVBUF,
@


1.18
log
@More than a decade ago, interrupt handlers on sparc started returning 0
(interrupt was not for me), 1 (positive interrupt was for me), or -1
(i am not sure...).  We have continued with this practice in as many
drivers as possible, throughout the tree.

This makes some of the architectures use that information in their
interrupt handler calling code -- if 1 is returned (and we know
this specific machine does not have edge-shared interrupts), we
finish servicing other possible handlers on the same pin.  If the
interrupt pin remains asserted (from a different device), we will
end up back in the interrupt servicing code of course... but this is
cheaper than calling all the chained interrupts on a pin.

This does of course count on shared level interrupts being properly
sorted by IPL.

There have been some concerns about starvation of drivers which
incorrectly return 1.  Those drivers should be hunted down so that
they return -1.

(other architectures will follow)

ok kettenis drahn dlg miod
@
text
@d1 1
a1 1
/* $OpenBSD: shared_intr.c,v 1.17 2010/09/20 06:33:46 matthew Exp $ */
d199 1
a199 1
	free(ih, M_DEVBUF);
@


1.17
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: shared_intr.c,v 1.16 2009/09/30 20:16:22 miod Exp $ */
d107 2
a108 1
		if ((rv = (*ih->ih_fn)(ih->ih_arg)))
a109 1

d111 2
d147 2
@


1.16
log
@Remove unused last argument of alpha_shared_intr_disestablish().
@
text
@d1 1
a1 1
/* $OpenBSD: shared_intr.c,v 1.15 2006/06/15 20:08:29 brad Exp $ */
d173 1
a173 2
	evcount_attach(&ih->ih_count, basename, (void *)&ih->ih_num,
	    &evcount_intr);
@


1.15
log
@Rework the interrupt code, shaving some cycles off in the process.
Rather than an "iointr" routine that decomposes a vector into an
IRQ, we maintain a vector table directly, hooking up each "iointr"
routine at the correct vector. This also allows us to hook device
interrupts up to specific vectors.

From thorpej NetBSD

Tested by myself and a number of end-users.
@
text
@d1 1
a1 1
/* $OpenBSD: shared_intr.c,v 1.14 2006/01/29 10:47:35 martin Exp $ */
d183 1
a183 1
alpha_shared_intr_disestablish(intr, cookie, basename)
a185 1
	const char *basename;
@


1.14
log
@Add a alpha_shared_intr_reset_strays() function that resets the stray
interrupt counter for a given shared interrupt descriptor.
When an interrupt is successfully handled, reset the strays counter,
thus preventing a "slow leak" from eventually shutting off the interrupt
vector.

from NetBSD via KUDO Takashi
@
text
@d1 1
a1 1
/* $OpenBSD: shared_intr.c,v 1.13 2004/12/25 23:02:23 miod Exp $ */
d216 8
@


1.13
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: shared_intr.c,v 1.12 2004/06/28 02:28:42 aaron Exp $ */
d244 13
@


1.12
log
@Use new event counter API for interrupt counting on alpha.  By me, with some
edits by Theo.  deraadt@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: shared_intr.c,v 1.11 2002/03/14 01:26:26 millert Exp $ */
a97 1
	ih = intr[num].intr_q.tqh_first;
d99 1
a99 2
	while (ih != NULL) {

a110 1
		ih = ih->ih_q.tqe_next;
d150 1
a150 1
			if (intr[num].intr_q.tqh_first == NULL) {
d215 1
a215 1
	return (intr[num].intr_q.tqh_first != NULL);
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: shared_intr.c,v 1.10 2001/06/25 00:43:07 mickey Exp $ */
d109 2
a110 1
		rv = (*ih->ih_fn)(ih->ih_arg);
d176 2
d198 1
d200 1
@


1.10
log
@cold is in systm now
@
text
@d1 1
a1 1
/* $OpenBSD: shared_intr.c,v 1.9 2000/11/08 21:27:13 ericj Exp $ */
d44 1
a44 1
static const char *intr_typename __P((int));
d123 1
a123 1
	int (*fn) __P((void *));
@


1.10.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: shared_intr.c,v 1.10 2001/06/25 00:43:07 mickey Exp $ */
d44 1
a44 1
static const char *intr_typename(int);
d123 1
a123 1
	int (*fn)(void *);
@


1.9
log
@tag the rest of alpha tree
@
text
@d1 1
a1 1
/* $OpenBSD: shared_intr.c,v 1.13 2000/03/19 01:46:18 thorpej Exp $ */
a44 2

extern int cold;
@


1.8
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
@


1.7
log
@In alpha_shared_intr_stray(), if intr_maxstrays is 0 just return (NetBSD)
@
text
@d1 1
a1 2
/*	$OpenBSD: shared_intr.c,v 1.6 1999/02/08 00:05:09 millert Exp $	*/
/*	$NetBSD: shared_intr.c,v 1.1 1996/11/17 02:03:08 cgd Exp $	*/
d35 1
d43 2
a46 2
static const char *intr_typename __P((int));

d85 1
a118 32
/*
 * Just check to see if an IRQ is available/can be shared.
 * 0 = interrupt not available
 * 1 = interrupt shareable
 * 2 = interrupt all to ourself
 */
int
alpha_shared_intr_check(intr, num, type)
	struct alpha_shared_intr *intr;
	unsigned int num;
	int type;
{

	switch (intr[num].intr_sharetype) {
	case IST_UNUSABLE:
		return (0);
		break;
	case IST_NONE:
		return (2);
		break;
	case IST_LEVEL:
		if (type == intr[num].intr_sharetype)
			break;
	case IST_EDGE:
	case IST_PULSE:
		if ((type != IST_NONE) && (intr[num].intr_q.tqh_first != NULL))
			return (0);
	}

	return (1);
}

d171 1
d175 1
d183 16
d239 1
a239 6

#ifdef DIAGNOSTIC
	if (alpha_shared_intr_isactive(intr, num))
		panic("alpha_shared_intr_set_maxstrays on active intr");
#endif

d242 1
d261 19
@


1.7.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 2
/* $OpenBSD: shared_intr.c,v 1.9 2000/11/08 21:27:13 ericj Exp $ */
/* $NetBSD: shared_intr.c,v 1.13 2000/03/19 01:46:18 thorpej Exp $ */
a35 1
#include <sys/kernel.h>
d43 2
a46 2
extern int cold;

a84 1
		intr[i].intr_private = NULL;
d118 32
a201 1
	ih->ih_intrhead = intr;
a204 1
	ih->ih_num = num;
a211 16
void
alpha_shared_intr_disestablish(intr, cookie, basename)
	struct alpha_shared_intr *intr;
	void *cookie;
	const char *basename;
{
	struct alpha_shared_intrhand *ih = cookie;
	unsigned int num = ih->ih_num;

	/*
	 * Just remove it from the list and free the entry.  We let
	 * the caller deal with resetting the share type, if appropriate.
	 */
	TAILQ_REMOVE(&intr[num].intr_q, ih, ih_q);
}

d252 6
a257 1
	int s = splhigh();
a259 1
	splx(s);
a277 19
}

void
alpha_shared_intr_set_private(intr, num, v)
	struct alpha_shared_intr *intr;
	unsigned int num;
	void *v;
{

	intr[num].intr_private = v;
}

void *
alpha_shared_intr_get_private(intr, num)
	struct alpha_shared_intr *intr;
	unsigned int num;
{

	return (intr[num].intr_private);
@


1.7.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: shared_intr.c,v 1.7.6.1 2001/04/18 16:00:44 niklas Exp $ */
d45 2
@


1.7.6.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d44 1
a44 1
static const char *intr_typename(int);
d123 1
a123 1
	int (*fn)(void *);
@


1.6
log
@Because of BROKEN_PROM braindamage we need to allow an interupt
initialized (but not registered) as IST_LEVEL be assigned IST_EDGE.
@
text
@d1 1
a1 1
/*	$OpenBSD: shared_intr.c,v 1.5 1998/12/31 09:17:58 deraadt Exp $	*/
d270 4
@


1.5
log
@semantic change: prefer unshared intr, settle for level shared. this will still fail in some cases
@
text
@d1 1
a1 1
/*	$OpenBSD: shared_intr.c,v 1.4 1998/12/27 00:27:18 deraadt Exp $	*/
a129 2
	if (intr[num].intr_sharetype == IST_UNUSABLE)
		return (0);
d132 3
d139 2
a140 3
		if (type != intr[num].intr_sharetype)
			return (0);
		return (1);
@


1.4
log
@new priority mechanism for pcmcia interrupt allocation, ie. "best effort"
for machines low on interrupts. work by fgsch, and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: shared_intr.c,v 1.3 1998/06/29 05:32:50 downsj Exp $	*/
d118 6
d140 1
a140 1
		return (2);
@


1.3
log
@isa_intr_check(), alpha style.
@
text
@d1 1
a1 1
/*	$OpenBSD: shared_intr.c,v 1.2 1997/11/10 15:53:08 niklas Exp $	*/
d128 7
a135 3
	case IST_LEVEL:
		if (type == intr[num].intr_sharetype)
			break;
d138 1
a138 3
				return (0);
	case IST_NONE:
		break;
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: shared_intr.c,v 1.1 1996/11/17 02:03:08 cgd Exp $	*/
d116 24
@


1.1
log
@alpha/common/ insults my filec
@
text
@d1 1
@
