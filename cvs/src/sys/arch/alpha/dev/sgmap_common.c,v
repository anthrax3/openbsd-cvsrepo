head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.10
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.8
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.4
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.10.0.26
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.22
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.20
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.18
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.16
	OPENBSD_5_0:1.10.0.14
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.12
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.10
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.6
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.8
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.4
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.6.0.10
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.5
	UBC:1.3.0.2
	UBC_BASE:1.3
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.1.0.4
	OPENBSD_2_9_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.14
date	2014.12.09.06.58.28;	author doug;	state Exp;
branches;
next	1.13;
commitid	yWAxzpQP2PPpYlfT;

1.13
date	2014.07.12.18.44.40;	author tedu;	state Exp;
branches;
next	1.12;
commitid	uKVPYMN2MLxdZxzH;

1.12
date	2014.06.14.23.11.20;	author jmatthew;	state Exp;
branches;
next	1.11;
commitid	bNrqGO9e64n0bceZ;

1.11
date	2014.03.31.21.10.10;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.26.05.42.08;	author ray;	state Exp;
branches;
next	1.9;

1.9
date	2006.04.13.14.41.08;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.04.21.18.43;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.20.01.00.58;	author martin;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.18.20.14.41;	author jmc;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.25.21.33.21;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.20.22.48.58;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.06.19.53.13;	author miod;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.07.05.10.00.25;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.21.17.26.38;	author art;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.04.18.16.00.42;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.10.31.02.52.44;	author nate;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.11.13.21.00.49;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2002.03.21.14.46.08;	author art;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2003.03.27.23.18.06;	author niklas;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2004.02.19.09.59.34;	author niklas;	state Exp;
branches;
next	;

1.3.2.1
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2002.10.29.00.28.00;	author art;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Replace some malloc(n*size,...) calls with mallocarray().

ok tedu@@ deraadt@@
@
text
@/* $OpenBSD: sgmap_common.c,v 1.13 2014/07/12 18:44:40 tedu Exp $ */
/* $NetBSD: sgmap_common.c,v 1.13 2000/06/29 09:02:57 mrg Exp $ */

/*-
 * Copyright (c) 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#define _ALPHA_BUS_DMA_PRIVATE

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/proc.h>

#include <uvm/uvm_extern.h>

#include <machine/bus.h>

#include <alpha/dev/sgmapvar.h>

/*
 * Some systems will prefetch the next page during a memory -> device DMA.
 * This can cause machine checks if there is not a spill page after the
 * last page of the DMA (thus avoiding hitting an invalid SGMAP PTE).
 */
vaddr_t		alpha_sgmap_prefetch_spill_page_va;
bus_addr_t	alpha_sgmap_prefetch_spill_page_pa;

void
alpha_sgmap_init(t, sgmap, name, wbase, sgvabase, sgvasize, ptesize, ptva,
    minptalign)
	bus_dma_tag_t t;
	struct alpha_sgmap *sgmap;
	const char *name;
	bus_addr_t wbase;
	bus_addr_t sgvabase;
	bus_size_t sgvasize;
	size_t ptesize;
	void *ptva;
	bus_size_t minptalign;
{
	bus_dma_segment_t seg;
	size_t ptsize;
	int rseg;

	if (sgvasize & PGOFSET) {
		printf("size botch for sgmap `%s'\n", name);
		goto die;
	}

	sgmap->aps_wbase = wbase;
	sgmap->aps_sgvabase = sgvabase;
	sgmap->aps_sgvasize = sgvasize;

	if (ptva != NULL) {
		/*
		 * We already have a page table; this may be a system
		 * where the page table resides in bridge-resident SRAM.
		 */
		sgmap->aps_pt = ptva;
		sgmap->aps_ptpa = 0;
	} else {
		/*
		 * Compute the page table size and allocate it.  At minimum,
		 * this must be aligned to the page table size.  However,
		 * some platforms have more strict alignment requirements.
		 */
		ptsize = (sgvasize / PAGE_SIZE) * ptesize;
		if (minptalign != 0) {
			if (minptalign < ptsize)
				minptalign = ptsize;
		} else
			minptalign = ptsize;
		if (bus_dmamem_alloc(t, ptsize, minptalign, 0, &seg, 1, &rseg,
		    BUS_DMA_NOWAIT)) {
			panic("unable to allocate page table for sgmap `%s'",
			    name);
			goto die;
		}
		sgmap->aps_ptpa = seg.ds_addr;
		sgmap->aps_pt = (caddr_t)ALPHA_PHYS_TO_K0SEG(sgmap->aps_ptpa);
	}

	/*
	 * Create the extent map used to manage the virtual address
	 * space.
	 */
	sgmap->aps_ex = extent_create((char *)name, sgvabase, sgvasize - 1,
	    M_DEVBUF, NULL, 0, EX_NOWAIT|EX_NOCOALESCE);
	if (sgmap->aps_ex == NULL) {
		printf("unable to create extent map for sgmap `%s'\n",
		    name);
		goto die;
	}
	mtx_init(&sgmap->aps_mtx, IPL_HIGH);

	/*
	 * Allocate a spill page if that hasn't already been done.
	 */
	if (alpha_sgmap_prefetch_spill_page_va == 0) {
		if (bus_dmamem_alloc(t, PAGE_SIZE, 0, 0, &seg, 1, &rseg,
		    BUS_DMA_NOWAIT)) {
			printf("unable to allocate spill page for sgmap `%s'\n",
			    name);
			goto die;
		}
		alpha_sgmap_prefetch_spill_page_pa = seg.ds_addr;
		alpha_sgmap_prefetch_spill_page_va =
		    ALPHA_PHYS_TO_K0SEG(alpha_sgmap_prefetch_spill_page_pa);
		bzero((caddr_t)alpha_sgmap_prefetch_spill_page_va, PAGE_SIZE);
	}
	
	return;
 die:
	panic("alpha_sgmap_init");
}

int
alpha_sgmap_dmamap_setup(map, nsegments, flags)
	bus_dmamap_t map;
	int nsegments;
	int flags;
{
	map->_dm_cookie = mallocarray(nsegments, sizeof(struct extent_region),
	    M_DEVBUF, (flags & BUS_DMA_NOWAIT) ? M_NOWAIT : M_WAITOK);
	return (map->_dm_cookie == NULL);
}

int
alpha_sgmap_dmamap_create(t, size, nsegments, maxsegsz, boundary,
    flags, dmamp)
	bus_dma_tag_t t;
	bus_size_t size;
	int nsegments;
	bus_size_t maxsegsz;
	bus_size_t boundary;
	int flags;
	bus_dmamap_t *dmamp;
{
	bus_dmamap_t map;
	int error;

	error = _bus_dmamap_create(t, size, nsegments, maxsegsz,
	    boundary, flags, dmamp);
	if (error)
		return (error);

	map = *dmamp;
	if (alpha_sgmap_dmamap_setup(map, nsegments, flags)) {
		_bus_dmamap_destroy(t, map);
		return (ENOMEM);
	}

	/* XXX BUS_DMA_ALLOCNOW */

	return (0);
}

void
alpha_sgmap_dmamap_teardown(map)
	bus_dmamap_t map;
{
	free(map->_dm_cookie, M_DEVBUF, 0);
}

void
alpha_sgmap_dmamap_destroy(t, map)
	bus_dma_tag_t t;
	bus_dmamap_t map;
{
	KASSERT(map->dm_mapsize == 0);

	alpha_sgmap_dmamap_teardown(map);
	_bus_dmamap_destroy(t, map);
}
@


1.13
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: sgmap_common.c,v 1.12 2014/06/14 23:11:20 jmatthew Exp $ */
d151 1
a151 1
	map->_dm_cookie = malloc(nsegments * sizeof(struct extent_region),
@


1.12
log
@Preallocate sgmap extent regions for tsp, cia and mcpcia dma maps, which fall
back to sgmap if the direct mapping fails.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: sgmap_common.c,v 1.11 2014/03/31 21:10:10 kettenis Exp $ */
d190 1
a190 1
	free(map->_dm_cookie, M_DEVBUF);
@


1.11
log
@Use extent_alloc_with_descr(9) and add a mutex to protect the extent.
This should make bus_dmamap_load(9) and bus_dmamap_unload(9) "mpsafe".

As a bonus this gets rid of a potential memory allocation in the IO path.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: sgmap_common.c,v 1.10 2008/06/26 05:42:08 ray Exp $ */
d146 11
d176 1
a176 3
	map->_dm_cookie = malloc(nsegments * sizeof(struct extent_region),
	    M_DEVBUF, (flags & BUS_DMA_NOWAIT) ? M_NOWAIT : M_WAITOK);
	if (map->_dm_cookie == NULL) {
d187 7
d200 1
a200 1
	free(map->_dm_cookie, M_DEVBUF);
@


1.10
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sgmap_common.c,v 1.9 2006/04/13 14:41:08 brad Exp $ */
d122 1
d165 6
d174 1
a174 1
	return (error);
d184 1
@


1.9
log
@Use PAGE_SIZE rather than NBPG.

From NetBSD

ok martin@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: sgmap_common.c,v 1.8 2006/04/04 21:18:43 brad Exp $ */
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.8
log
@clean up after Theo's "support mbuf handling in alpha sgmap dma maps" commit.

ok martin@@
@
text
@d1 1
a1 1
/* $OpenBSD: sgmap_common.c,v 1.7 2006/03/20 01:00:58 martin Exp $ */
d102 1
a102 1
		ptsize = (sgvasize / NBPG) * ptesize;
d134 1
a134 1
		if (bus_dmamem_alloc(t, NBPG, 0, 0, &seg, 1, &rseg,
d143 1
a143 1
		bzero((caddr_t)alpha_sgmap_prefetch_spill_page_va, NBPG);
@


1.7
log
@factorize SGMAP-mapped DMA map creation and destroy code

ok miod@@, additional testing jsg@@

from NetBSD
@
text
@d1 1
a1 1
/* $OpenBSD: sgmap_common.c,v 1.6 2003/10/18 20:14:41 jmc Exp $ */
a151 83
alpha_sgmap_alloc(map, origlen, sgmap, flags)
	bus_dmamap_t map;
	bus_size_t origlen;
	struct alpha_sgmap *sgmap;
	int flags;
{
	int error;
	bus_size_t len = origlen, boundary, alignment;
	int s;

#ifdef DIAGNOSTIC
	if (map->_dm_flags & DMAMAP_HAS_SGMAP)
		panic("alpha_sgmap_alloc: already have sgva space");
#endif
	/*
	 * Add a range for spill page.
	 */
	len += NBPG;

	/*
	 * And add an additional amount in case of ALLOCNOW.
	 */
	if (flags & BUS_DMA_ALLOCNOW)
		len += NBPG;

	map->_dm_sgvalen = round_page(len);

	/*
	 * ARGH! If the addition of spill pages bumped us over our
	 * boundary, we have to 2x the boundary limit.
	 */
	boundary = map->_dm_boundary;
	if (boundary && boundary < map->_dm_sgvalen) {
		alignment = boundary;
		do {
			boundary <<= 1;
		} while (boundary < map->_dm_sgvalen);
	} else
		alignment = NBPG;
#if 0
	printf("len %x -> %x, _dm_sgvalen %x _dm_boundary %x boundary %x -> ",
	    origlen, len, map->_dm_sgvalen, map->_dm_boundary, boundary);
#endif

	s = splvm();
	error = extent_alloc(sgmap->aps_ex, map->_dm_sgvalen, alignment, 0,
	    boundary, (flags & BUS_DMA_NOWAIT) ? EX_NOWAIT : EX_WAITOK,
	    &map->_dm_sgva);
	splx(s);
#if 0
	printf("error %d _dm_sgva %x\n", error, map->_dm_sgva);
#endif

	if (error == 0)
		map->_dm_flags |= DMAMAP_HAS_SGMAP;
	else
		map->_dm_flags &= ~DMAMAP_HAS_SGMAP;
	
	return (error);
}

void
alpha_sgmap_free(map, sgmap)
	bus_dmamap_t map;
	struct alpha_sgmap *sgmap;
{
	int s;

#ifdef DIAGNOSTIC
	if ((map->_dm_flags & DMAMAP_HAS_SGMAP) == 0)
		panic("alpha_sgmap_free: no sgva space to free");
#endif

	s = splvm();
	if (extent_free(sgmap->aps_ex, map->_dm_sgva, map->_dm_sgvalen,
	    EX_NOWAIT))
		panic("alpha_sgmap_free");
	splx(s);

	map->_dm_flags &= ~DMAMAP_HAS_SGMAP;
}

int
d172 1
a172 6
	if (flags & BUS_DMA_ALLOCNOW) {
		error = alpha_sgmap_alloc(map, round_page(size),
		    t->_sgmap, flags);
		if (error)
			alpha_sgmap_dmamap_destroy(t, map);
}
d174 1
a174 1
 return (error);
d182 1
a182 3

	if (map->_dm_flags & DMAMAP_HAS_SGMAP)
	alpha_sgmap_free(map, t->_sgmap);
@


1.6
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/* $OpenBSD: sgmap_common.c,v 1.5 2002/06/25 21:33:21 miod Exp $ */
d41 2
d232 43
@


1.5
log
@No \n at the end of a panic() message... I thought all occurences had been
squashed already.
@
text
@d1 1
a1 1
/* $OpenBSD: sgmap_common.c,v 1.4 2002/03/20 22:48:58 art Exp $ */
d98 1
a98 1
		 * some platforms have more strict alignment reqirements.
@


1.4
log
@Since the sgmap is used in interrupts protect the extent with splvm.
nate@@ ok.

Should fix a bunch of random memory corruption problems on many machines.
How we could live so long without it is beyond me. Now my traktor is happy.
@
text
@d1 1
a1 1
/* $OpenBSD: sgmap_common.c,v 1.3 2001/11/06 19:53:13 miod Exp $ */
d108 1
a108 1
			panic("unable to allocate page table for sgmap `%s'\n",
@


1.3
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/* $OpenBSD: sgmap_common.c,v 1.2 2001/07/05 10:00:25 art Exp $ */
d158 1
d194 1
d198 1
d216 1
d223 1
d227 1
@


1.3.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: sgmap_common.c,v 1.3 2001/11/06 19:53:13 miod Exp $ */
a157 1
	int s;
a192 1
	s = splvm();
a195 1
	splx(s);
a212 1
	int s;
a218 1
	s = splvm();
a221 1
	splx(s);
@


1.3.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: sgmap_common.c,v 1.3.2.1 2002/06/11 03:33:40 art Exp $ */
d108 1
a108 1
			panic("unable to allocate page table for sgmap `%s'",
@


1.2
log
@Get rid of the wrapper macros around extent_alloc*1
Pass the right amount of arguments and rename them back to their right names.
@
text
@d1 1
a1 1
/* $OpenBSD: sgmap_common.c,v 1.1 2001/03/21 17:26:38 art Exp $ */
a46 1
#include <vm/vm.h>
@


1.1
log
@Move files from common to dev to be more like other archs
(and so that tab completion on "compile" works as on other archs. :))
@
text
@d1 1
a1 1
/* $OpenBSD: sgmap_common.c,v 1.2 2000/11/08 21:27:10 ericj Exp $ */
d194 1
a194 1
	error = extent_alloc(sgmap->aps_ex, map->_dm_sgvalen, alignment,
@


1.1.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/* $OpenBSD: sgmap_common.c,v 1.1 2001/03/21 17:26:38 art Exp $ */
@


1.1.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: sgmap_common.c,v 1.1.2.1 2001/04/18 16:00:42 niklas Exp $ */
d194 1
a194 1
	error = extent_alloc(sgmap->aps_ex, map->_dm_sgvalen, alignment, 0,
@


1.1.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d47 1
@


1.1.2.4
log
@merge in rev 1.4
@
text
@d1 1
a1 1
/* $OpenBSD: sgmap_common.c,v 1.4 2002/03/20 22:48:58 art Exp $ */
a157 1
	int s;
a192 1
	s = splvm();
a195 1
	splx(s);
a212 1
	int s;
a218 1
	s = splvm();
a221 1
	splx(s);
@


1.1.2.5
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d108 1
a108 1
			panic("unable to allocate page table for sgmap `%s'",
@


1.1.2.6
log
@Merge of -current from two weeks ago into the SMP branch
@
text
@d98 1
a98 1
		 * some platforms have more strict alignment requirements.
@


