head	1.46;
access;
symbols
	OPENBSD_6_1:1.46.0.4
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.46.0.2
	OPENBSD_6_0_BASE:1.46
	OPENBSD_5_9:1.45.0.2
	OPENBSD_5_9_BASE:1.45
	OPENBSD_5_8:1.44.0.6
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.44.0.2
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.43.0.6
	OPENBSD_5_6_BASE:1.43
	OPENBSD_5_5:1.43.0.4
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.40.0.2
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.39.0.8
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.6
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.4
	OPENBSD_5_0:1.39.0.2
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.37.0.2
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.36.0.2
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.34.0.2
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.33.0.4
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.29.0.4
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.28.0.4
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.23.0.4
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.15.0.8
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.6
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.15
	UBC:1.12.0.4
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.10
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.8
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.6
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.46
date	2016.06.13.01.26.14;	author dlg;	state Exp;
branches;
next	1.45;
commitid	ofg7tRWmBtMrMB35;

1.45
date	2015.09.13.20.37.28;	author kettenis;	state Exp;
branches;
next	1.44;
commitid	l4dcqI5s8IEqvgBi;

1.44
date	2015.02.11.01.13.22;	author dlg;	state Exp;
branches;
next	1.43;
commitid	CEDdiZTkUWnRZPMs;

1.43
date	2014.02.01.21.19.39;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2014.02.01.21.18.24;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2014.01.26.17.40.11;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2013.05.17.19.38.51;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2011.04.15.20.40.05;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2011.03.23.16.54.34;	author pirofti;	state Exp;
branches;
next	1.37;

1.37
date	2010.12.21.14.56.23;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2010.05.31.21.39.55;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2010.04.23.03.50.20;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2009.09.30.20.16.29;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2009.03.25.21.41.41;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2009.03.15.19.41.36;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2009.03.15.19.40.38;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2009.03.07.15.31.43;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2008.06.26.05.42.08;	author ray;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.16.19.37.06;	author thib;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.05.20.46.36;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2007.04.21.21.37.09;	author martin;	state Exp;
branches;
next	1.25;

1.25
date	2007.04.13.08.31.50;	author martin;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.12.14.38.36;	author martin;	state Exp;
branches;
next	1.23;

1.23
date	2006.06.15.20.08.29;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.12.03.14.36;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2006.01.29.10.47.35;	author martin;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.19.15.29.47;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2004.08.16.16.43.52;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2004.06.28.02.28.42;	author aaron;	state Exp;
branches;
next	1.17;

1.17
date	2004.06.13.21.49.12;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.16.04.52.05;	author pvalchev;	state Exp;
branches;
next	1.15;

1.15
date	2002.04.29.07.35.13;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.03.15.50;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.27;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.30.13.08.45;	author art;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2001.07.09.18.55.22;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.24.17.05.26;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.12.10.35.01;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.08.21.27.19;	author ericj;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.08.16.01.11;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.06.15.25.02;	author ho;	state Exp;
branches;
next	1.5;

1.5
date	98.06.29.05.32.51;	author downsj;	state Exp;
branches
	1.5.8.1;
next	1.4;

1.4
date	97.01.24.19.57.12;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.10.30.22.39.09;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.07.29.22.58.52;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.06.18.09.43.18;	author deraadt;	state Exp;
branches;
next	;

1.5.8.1
date	2001.04.18.16.00.54;	author niklas;	state Exp;
branches;
next	1.5.8.2;

1.5.8.2
date	2001.07.04.10.14.36;	author niklas;	state Exp;
branches;
next	1.5.8.3;

1.5.8.3
date	2001.10.31.02.52.44;	author nate;	state Exp;
branches;
next	1.5.8.4;

1.5.8.4
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	1.5.8.5;

1.5.8.5
date	2003.03.27.23.18.06;	author niklas;	state Exp;
branches;
next	1.5.8.6;

1.5.8.6
date	2004.06.05.23.10.43;	author niklas;	state Exp;
branches;
next	;

1.12.4.1
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	;


desc
@@


1.46
log
@rename _splraise to splraise

gets us a bit closer to an MI splraise api.
@
text
@/* $OpenBSD: intr.h,v 1.45 2015/09/13 20:37:28 kettenis Exp $ */
/* $NetBSD: intr.h,v 1.26 2000/06/03 20:47:41 thorpej Exp $ */

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1997 Christopher G. Demetriou.  All rights reserved.
 * Copyright (c) 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#ifndef _MACHINE_INTR_H_
#define _MACHINE_INTR_H_

#include <sys/evcount.h>
#include <sys/mutex.h>
#include <sys/queue.h>
#include <machine/atomic.h>

/*
 * The Alpha System Control Block.  This is 8k long, and you get
 * 16 bytes per vector (i.e. the vector numbers are spaced 16
 * apart).
 *
 * This is sort of a "shadow" SCB -- rather than the CPU jumping
 * to (SCBaddr + (16 * vector)), like it does on the VAX, we get
 * a vector number in a1.  We use the SCB to look up a routine/arg
 * and jump to it.
 *
 * Since we use the SCB only for I/O interrupts, we make it shorter
 * than normal, starting it at vector 0x800 (the start of the I/O
 * interrupt vectors).
 */
#define	SCB_IOVECBASE	0x0800
#define	SCB_VECSIZE	0x0010
#define	SCB_SIZE	0x2000

#define	SCB_VECTOIDX(x)	((x) >> 4)
#define	SCB_IDXTOVEC(x)	((x) << 4)

#define	SCB_NIOVECS	SCB_VECTOIDX(SCB_SIZE - SCB_IOVECBASE)

struct scbvec { 
	void	(*scb_func)(void *, u_long);
	void	*scb_arg;
};

/*
 * Alpha interrupts come in at one of 4 levels:
 *
 *	software interrupt level
 *	i/o level 1
 *	i/o level 2
 *	clock level
 *
 * However, since we do not have any way to know which hardware
 * level a particular i/o interrupt comes in on, we have to
 * whittle it down to 3.
 */

#define	IPL_NONE	ALPHA_PSL_IPL_0
#define	IPL_SOFTINT	ALPHA_PSL_IPL_SOFT
#define	IPL_BIO		ALPHA_PSL_IPL_IO
#define	IPL_NET		ALPHA_PSL_IPL_IO
#define	IPL_TTY		ALPHA_PSL_IPL_IO
#define	IPL_SERIAL	ALPHA_PSL_IPL_IO
#define	IPL_AUDIO	ALPHA_PSL_IPL_IO
#define	IPL_VM		ALPHA_PSL_IPL_IO
#define	IPL_CLOCK	ALPHA_PSL_IPL_CLOCK
#define	IPL_SCHED	ALPHA_PSL_IPL_CLOCK
#define	IPL_IPI		ALPHA_PSL_IPL_HIGH	/* occur on _CLOCK, though */
#define	IPL_HIGH	ALPHA_PSL_IPL_HIGH

#define	IPL_SOFTSERIAL	0	/* serial software interrupts */
#define	IPL_SOFTCLOCK	1	/* clock software interrupts */
#define	IPL_SOFTNET	2	/* network software interrupts */
#define	IPL_SOFT	3	/* other software interrupts */

#define	IPL_MPSAFE	0	/* no "mpsafe" interrupts */

#define	IST_UNUSABLE	-1	/* interrupt cannot be used */
#define	IST_NONE	0	/* none (dummy) */
#define	IST_PULSE	1	/* pulsed */
#define	IST_EDGE	2	/* edge-triggered */
#define	IST_LEVEL	3	/* level-triggered */

#define SI_SOFT		0
#define SI_SOFTCLOCK	1
#define SI_SOFTNET	2
#define SI_SOFTSERIAL	3
#define	SI_NSOFT	4

#ifdef	_KERNEL

void intr_barrier(void *);

/* SPL asserts */
#ifdef DIAGNOSTIC
/*
 * Although this function is implemented in MI code, it must be in this MD
 * header because we don't want this header to include MI includes.
 */
void splassert_fail(int, int, const char *);
extern int splassert_ctl;
void splassert_check(int, const char *);
#define	splassert(__wantipl)						\
	do {								\
		if (splassert_ctl > 0) {				\
			splassert_check(__wantipl, __func__);		\
		}							\
	} while (0)
#define	splsoftassert(wantipl)	splassert(IPL_SOFTINT)
#else
#define	splassert(wantipl)	do { /* nothing */ } while (0)
#define	splsoftassert(wantipl)	do { /* nothing */ } while (0)
#endif

/* IPL-lowering/restoring macros */
#define splx(s)								\
    ((s) == ALPHA_PSL_IPL_0 ? spl0() : alpha_pal_swpipl(s))

/* IPL-raising functions/macros */
int splraise(int);

#define splsoft()		splraise(IPL_SOFTINT)
#define splsoftserial()		splsoft()
#define splsoftclock()		splsoft()
#define splsoftnet()		splsoft()
#define splnet()		splraise(IPL_NET)
#define splbio()		splraise(IPL_BIO)
#define spltty()		splraise(IPL_TTY)
#define splserial()		splraise(IPL_SERIAL)
#define splaudio()		splraise(IPL_AUDIO)
#define splvm()			splraise(IPL_VM)
#define splclock()		splraise(IPL_CLOCK)
#define splstatclock()		splraise(IPL_CLOCK)
#define splsched()		splraise(IPL_SCHED)
#define splipi()		splraise(IPL_IPI)
#define splhigh()		splraise(IPL_HIGH)

#define spllock()		splhigh()

/*
 * Interprocessor interrupts.  In order how we want them processed.
 */
#define	ALPHA_IPI_HALT			(1UL << 0)
#define	ALPHA_IPI_SHOOTDOWN		(1UL << 1)
#define	ALPHA_IPI_IMB			(1UL << 2)
#define	ALPHA_IPI_AST			(1UL << 3)
#define	ALPHA_IPI_SYNCH_FPU		(1UL << 4)
#define	ALPHA_IPI_DISCARD_FPU		(1UL << 5)
#define	ALPHA_IPI_PAUSE			(1UL << 6)

#define	ALPHA_NIPIS		7	/* must not exceed 64 */

struct cpu_info;
struct trapframe;

void	alpha_ipi_process(struct cpu_info *, struct trapframe *);
#ifdef MP_LOCKDEBUG
void	alpha_ipi_process_with_frame(struct cpu_info *);
#else
#define	alpha_ipi_process_with_frame(ci) alpha_ipi_process((ci), NULL)
#endif
void	alpha_send_ipi(unsigned long, unsigned long);
void	alpha_broadcast_ipi(unsigned long);
void	alpha_multicast_ipi(unsigned long, unsigned long);

/*
 * Alpha shared-interrupt-line common code.
 */

struct alpha_shared_intrhand {
	TAILQ_ENTRY(alpha_shared_intrhand)
		ih_q;
	struct alpha_shared_intr *ih_intrhead;
	int	(*ih_fn)(void *);
	void	*ih_arg;
	int	ih_level;
	unsigned int ih_num;
	struct evcount ih_count;
};

struct alpha_shared_intr {
	TAILQ_HEAD(,alpha_shared_intrhand)
		intr_q;
	void	*intr_private;
	int	intr_sharetype;
	int	intr_dfltsharetype;
	int	intr_nstrays;
	int	intr_maxstrays;
};

#define	ALPHA_SHARED_INTR_DISABLE(asi, num)				\
	((asi)[num].intr_maxstrays != 0 &&				\
	 (asi)[num].intr_nstrays == (asi)[num].intr_maxstrays)

extern int	intr_shared_edge;

/*
 * simulated software interrupt register
 */
extern unsigned long ssir;

#define	setsoft(x)	atomic_setbits_ulong(&ssir, 1 << (x))

struct alpha_soft_intrhand {
	TAILQ_ENTRY(alpha_soft_intrhand)
		sih_q;
	struct alpha_soft_intr *sih_intrhead;
	void	(*sih_fn)(void *);
	void	*sih_arg;
	int	sih_pending;
};

struct alpha_soft_intr {
	TAILQ_HEAD(, alpha_soft_intrhand)
		softintr_q;
	struct mutex softintr_mtx;
	unsigned long softintr_siq;
};

void	 softintr_disestablish(void *);
void	 softintr_dispatch(void);
void	*softintr_establish(int, void (*)(void *), void *);
void	 softintr_init(void);
void	 softintr_schedule(void *);

struct alpha_shared_intr *alpha_shared_intr_alloc(unsigned int);
int	alpha_shared_intr_dispatch(struct alpha_shared_intr *,
	    unsigned int);
void	*alpha_shared_intr_establish(struct alpha_shared_intr *,
	    unsigned int, int, int, int (*)(void *), void *, const char *);
void	alpha_shared_intr_disestablish(struct alpha_shared_intr *, void *);
int	alpha_shared_intr_get_sharetype(struct alpha_shared_intr *,
	    unsigned int);
int	alpha_shared_intr_isactive(struct alpha_shared_intr *,
	    unsigned int);
int	alpha_shared_intr_firstactive(struct alpha_shared_intr *,
	    unsigned int);
void	alpha_shared_intr_set_dfltsharetype(struct alpha_shared_intr *,
	    unsigned int, int);
void	alpha_shared_intr_set_maxstrays(struct alpha_shared_intr *,
	    unsigned int, int);
void	alpha_shared_intr_reset_strays(struct alpha_shared_intr *,
	    unsigned int);
void	alpha_shared_intr_stray(struct alpha_shared_intr *, unsigned int,
	    const char *);
void	alpha_shared_intr_set_private(struct alpha_shared_intr *,
	    unsigned int, void *);
void	*alpha_shared_intr_get_private(struct alpha_shared_intr *,
	    unsigned int);

extern struct scbvec scb_iovectab[];

void	scb_init(void);
void	scb_set(u_long, void (*)(void *, u_long), void *);
u_long	scb_alloc(void (*)(void *, u_long), void *);
void	scb_free(u_long);

#define	SCB_ALLOC_FAILED	((u_long) -1)

#endif /* _KERNEL */
#endif /* ! _MACHINE_INTR_H_ */
@


1.45
log
@intr_barrier(9) for alpha.
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.44 2015/02/11 01:13:22 dlg Exp $ */
d172 1
a172 1
int _splraise(int);
d174 1
a174 1
#define splsoft()		_splraise(IPL_SOFTINT)
d178 11
a188 11
#define splnet()		_splraise(IPL_NET)
#define splbio()		_splraise(IPL_BIO)
#define spltty()		_splraise(IPL_TTY)
#define splserial()		_splraise(IPL_SERIAL)
#define splaudio()		_splraise(IPL_AUDIO)
#define splvm()			_splraise(IPL_VM)
#define splclock()		_splraise(IPL_CLOCK)
#define splstatclock()		_splraise(IPL_CLOCK)
#define splsched()		_splraise(IPL_SCHED)
#define splipi()		_splraise(IPL_IPI)
#define splhigh()		_splraise(IPL_HIGH)
@


1.44
log
@alpha (nor any other arch) uses any types or api provided by sys/lock.h.
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.43 2014/02/01 21:19:39 miod Exp $ */
d143 2
@


1.43
log
@Lower IPL_SCHED to IPL_CLOCK where it belongs.
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.42 2014/02/01 21:18:24 miod Exp $ */
a64 1
#include <sys/lock.h>
@


1.42
log
@Allow MP_LOCKDEBUG kernels to get tracebacks from other processors when
entering ddb. No change for !MP_LOCKDEBUG kernels.
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.41 2014/01/26 17:40:11 miod Exp $ */
d120 2
a121 2
#define	IPL_SCHED	ALPHA_PSL_IPL_HIGH
#define	IPL_IPI		ALPHA_PSL_IPL_HIGH	/* occur on _IO, though */
d185 1
a189 1
#define splsched()		splhigh()
@


1.41
log
@Work in progress work towards SMP, heavily based upon NetBSD. The MP kernel
will boot multiuser, but will deadlock under load, and I can't find my
mistake yet.
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.40 2013/05/17 19:38:51 kettenis Exp $ */
d208 5
@


1.40
log
@Add a dummy IPL_MPSAFE definition.

ok miod@@, mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.39 2011/04/15 20:40:05 deraadt Exp $ */
d121 1
d177 4
a180 4
#define splnet()                _splraise(IPL_NET)
#define splbio()                _splraise(IPL_BIO)
#define spltty()                _splraise(IPL_TTY)
#define splserial()             _splraise(IPL_SERIAL)
d183 4
a186 3
#define splclock()              _splraise(IPL_CLOCK)
#define splstatclock()          _splraise(IPL_CLOCK)
#define splhigh()               _splraise(IPL_HIGH)
d194 7
a200 9
#define	ALPHA_IPI_HALT		0x0000000000000001UL
#define	ALPHA_IPI_TBIA		0x0000000000000002UL
#define	ALPHA_IPI_TBIAP		0x0000000000000004UL
#define	ALPHA_IPI_SHOOTDOWN	0x0000000000000008UL
#define	ALPHA_IPI_IMB		0x0000000000000010UL
#define	ALPHA_IPI_AST		0x0000000000000020UL
#define	ALPHA_IPI_SYNCH_FPU	0x0000000000000040UL
#define	ALPHA_IPI_DISCARD_FPU	0x0000000000000080UL
#define	ALPHA_IPI_PAUSE		0x0000000000000100UL
d202 1
a202 1
#define	ALPHA_NIPIS		6	/* must not exceed 64 */
d204 2
a205 2
typedef void (*ipifunc_t)(void);
extern	ipifunc_t ipifuncs[ALPHA_NIPIS];
d207 1
@


1.39
log
@More than a decade ago, interrupt handlers on sparc started returning 0
(interrupt was not for me), 1 (positive interrupt was for me), or -1
(i am not sure...).  We have continued with this practice in as many
drivers as possible, throughout the tree.

This makes some of the architectures use that information in their
interrupt handler calling code -- if 1 is returned (and we know
this specific machine does not have edge-shared interrupts), we
finish servicing other possible handlers on the same pin.  If the
interrupt pin remains asserted (from a different device), we will
end up back in the interrupt servicing code of course... but this is
cheaper than calling all the chained interrupts on a pin.

This does of course count on shared level interrupts being properly
sorted by IPL.

There have been some concerns about starvation of drivers which
incorrectly return 1.  Those drivers should be hunted down so that
they return -1.

(other architectures will follow)

ok kettenis drahn dlg miod
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.38 2011/03/23 16:54:34 pirofti Exp $ */
d127 2
@


1.38
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.37 2010/12/21 14:56:23 claudio Exp $ */
d237 2
@


1.37
log
@Convert netisr to a normal soft interrupt instead of hanving MD code
for it. This makes the netisr a real C function which will help further
development. No noticable performance change on i386 and amd64.
With input from kettenis@@ and miod@@ additional OKs mikeb@@ and henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.36 2010/05/31 21:39:55 deraadt Exp $ */
d61 2
a62 2
#ifndef _ALPHA_INTR_H_
#define _ALPHA_INTR_H_
d302 1
a302 1
#endif /* ! _ALPHA_INTR_H_ */
@


1.36
log
@there is no spllpt(), since lpt's are just tty devices (call tty functions,
and thus should be using spltty()
from Matthew Dempsky
ok oga guenther
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.35 2010/04/23 03:50:20 miod Exp $ */
a265 5

/* XXX For legacy software interrupts. */
extern struct alpha_soft_intrhand *softnet_intrhand;

#define	setsoftnet()	softintr_schedule(softnet_intrhand)
@


1.35
log
@Make sure IPL_SCHED is always defined by MD headers, instead of having a MI
fallback definition in <sys/sched.h>, so that there is no hidden include
ordering requirement between <machine/intr.h> and <sys/sched.h>.
ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.34 2009/09/30 20:16:29 miod Exp $ */
a183 1
#define spllpt()		spltty()
@


1.34
log
@Remove unused last argument of alpha_shared_intr_disestablish().
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.33 2009/03/25 21:41:41 miod Exp $ */
d120 1
@


1.33
log
@Deinline softintr_schedule(). Also fix softintr priorities I got inverted after
adding splsoftassert().
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.32 2009/03/15 19:41:36 miod Exp $ */
d277 1
a277 2
void	alpha_shared_intr_disestablish(struct alpha_shared_intr *,
	    void *, const char *);
@


1.32
log
@Now that we have splsoftassert(), make the soft ipl levels positive and
remove the special casing in splassert().
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.31 2009/03/15 19:40:38 miod Exp $ */
d66 1
d123 2
a124 2
#define	IPL_SOFTNET	1	/* network software interrupts */
#define	IPL_SOFTCLOCK	2	/* clock software interrupts */
d133 4
a136 4
#define SI_SOFTSERIAL	0
#define SI_SOFTNET	1
#define SI_SOFTCLOCK	2
#define SI_SOFT		3
d257 1
a257 1
	struct simplelock softintr_slock;
d261 2
d264 2
a265 20
void	softintr_disestablish(void *);
void	softintr_init(void);
void	softintr_dispatch(void);

#define	softintr_schedule(arg)						\
do {									\
	struct alpha_soft_intrhand *__sih = (arg);			\
	struct alpha_soft_intr *__si = __sih->sih_intrhead;		\
	int __s;							\
									\
	__s = splhigh();						\
	simple_lock(&__si->softintr_slock);				\
	if (__sih->sih_pending == 0) {					\
		TAILQ_INSERT_TAIL(&__si->softintr_q, __sih, sih_q);	\
		__sih->sih_pending = 1;					\
		setsoft(__si->softintr_siq);				\
	}								\
	simple_unlock(&__si->softintr_slock);				\
	splx(__s);							\
} while (0)
@


1.31
log
@Introduce splsoftassert(), similar to splassert() but for soft interrupt
levels. This will allow for platforms where soft interrupt levels do not
map to real hardware interrupt levels to have soft ipl values overlapping
hard ipl values without breaking spl asserts.
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.30 2009/03/07 15:31:43 miod Exp $ */
d121 4
a124 4
#define	IPL_SOFTSERIAL	-1	/* serial software interrupts */
#define	IPL_SOFTNET	-2	/* network software interrupts */
#define	IPL_SOFTCLOCK	-3	/* clock software interrupts */
#define	IPL_SOFT	-4	/* other software interrupts */
@


1.30
log
@No need to register a soft interrupt for softclock, it's done in MI code.
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.29 2008/06/26 05:42:08 ray Exp $ */
d155 1
d158 1
@


1.29
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.28 2007/05/16 19:37:06 thib Exp $ */
a281 1
extern struct alpha_soft_intrhand *softclock_intrhand;
a283 1
#define	setsoftclock()	softintr_schedule(softclock_intrhand)
@


1.28
log
@splassert_ctl defaults to 1 now, so dont wrap the checks for
splassert_ctl > 0 in __predict_false().

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.27 2007/05/05 20:46:36 miod Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.27
log
@Directly map IPL_xxx in terms of ALPHA_PSL_IPL_xxx values, and implement
splassert. ok art@@ martin@@
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.26 2007/04/21 21:37:09 martin Exp $ */
d158 1
a158 1
		if (__predict_false(splassert_ctl > 0)) {		\
@


1.26
log
@fix generic soft interrupts; improve establishing and disestablishing of
soft interrupts

from NetBSD, 'reads good art@@', also tested by robert@@
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.25 2007/04/13 08:31:50 martin Exp $ */
d117 15
a131 14
#define	IPL_NONE	1	/* disable only this interrupt */
#define	IPL_BIO		1	/* disable block I/O interrupts */
#define	IPL_NET		1	/* disable network interrupts */
#define	IPL_TTY		1	/* disable terminal interrupts */
#define	IPL_CLOCK	2	/* disable clock interrupts */
#define	IPL_HIGH	3	/* disable all interrupts */
#define	IPL_SERIAL	1	/* disable serial interrupts */
#define	IPL_AUDIO	1	/* disable audio interrupts */

#define	IPL_SOFTSERIAL	0	/* serial software interrupts */
#define	IPL_SOFTNET	1	/* network software interrupts */
#define	IPL_SOFTCLOCK	2	/* clock software interrupts */
#define	IPL_SOFT	3	/* other software interrupts */
#define	IPL_NSOFT	4
d143 1
d148 17
a164 1
#define	splassert(wantipl)	/* nothing */
d173 1
a173 1
#define splsoft()		_splraise(ALPHA_PSL_IPL_SOFT)
d177 9
a185 9
#define splnet()                _splraise(ALPHA_PSL_IPL_IO)
#define splbio()                _splraise(ALPHA_PSL_IPL_IO)
#define spltty()                _splraise(ALPHA_PSL_IPL_IO)
#define splserial()             _splraise(ALPHA_PSL_IPL_IO)
#define splaudio()		_splraise(ALPHA_PSL_IPL_IO)
#define splvm()			_splraise(ALPHA_PSL_IPL_IO)
#define splclock()              _splraise(ALPHA_PSL_IPL_CLOCK)
#define splstatclock()          _splraise(ALPHA_PSL_IPL_CLOCK)
#define splhigh()               _splraise(ALPHA_PSL_IPL_HIGH)
@


1.25
log
@get alpha SMP into a state where it at least compiles:

- add machine-dependent spinlock operations
- add basic interprocessor interrupt sending and receiving code

from NetBSD; ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.24 2007/04/12 14:38:36 martin Exp $ */
d138 5
a230 1
#define	__GENERIC_SOFT_INTERRUPTS
d232 1
a232 1
	LIST_ENTRY(alpha_soft_intrhand)
d241 1
a241 1
	LIST_HEAD(, alpha_soft_intrhand)
d244 1
a244 1
	unsigned long softintr_ipl;
d255 12
a266 2
	__sih->sih_pending = 1;						\
	setsoft(__sih->sih_intrhead->softintr_ipl);			\
@


1.24
log
@__HAVE_CPUINFO for alpha, with bits from netbsd

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.23 2006/06/15 20:08:29 brad Exp $ */
d165 1
d177 3
@


1.23
log
@Rework the interrupt code, shaving some cycles off in the process.
Rather than an "iointr" routine that decomposes a vector into an
IRQ, we maintain a vector table directly, hooking up each "iointr"
routine at the correct vector. This also allows us to hook device
interrupts up to specific vectors.

From thorpej NetBSD

Tested by myself and a number of end-users.
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.22 2006/03/12 03:14:36 brad Exp $ */
d165 1
@


1.22
log
@remove splimp.
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.21 2006/01/29 10:47:35 martin Exp $ */
d77 28
d268 2
d283 8
a290 1
void	set_iointr(void (*)(void *, unsigned long));
@


1.21
log
@Add a alpha_shared_intr_reset_strays() function that resets the stray
interrupt counter for a given shared interrupt descriptor.
When an interrupt is successfully handled, reset the strays counter,
thus preventing a "slow leak" from eventually shutting off the interrupt
vector.

from NetBSD via KUDO Takashi
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.20 2005/04/19 15:29:47 mickey Exp $ */
a127 1
#define splimp()                _splraise(ALPHA_PSL_IPL_IO)
@


1.20
log
@nothing uses spllowersoftclock() anymore
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.19 2004/08/16 16:43:52 art Exp $ */
d245 2
@


1.19
log
@Uninline splraise to save some time and space.

deraadt@@ ok, tested by many for a long time.
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.18 2004/06/28 02:28:42 aaron Exp $ */
a117 1
#define	spllowersoftclock()	alpha_pal_swpipl(ALPHA_PSL_IPL_SOFT)
@


1.18
log
@Use new event counter API for interrupt counting on alpha.  By me, with some
edits by Theo.  deraadt@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.17 2004/06/13 21:49:12 niklas Exp $ */
d121 2
a122 8
static __inline int _splraise(int);
static __inline int
_splraise(s)
	int s;
{
	int cur = alpha_pal_rdps() & ALPHA_PSL_IPL_MASK;
	return (s > cur ? alpha_pal_swpipl(s) : cur);
}
@


1.17
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d71 1
d177 1
@


1.16
log
@provide MI splaudio(); ok miod
from RATT
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.15 2002/04/29 07:35:13 miod Exp $ */
d162 1
@


1.15
log
@Define placeholders for art's splassert() debugging stuff on all arches.
Currently as no-ops everywhere.

ok art@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.14 2002/03/14 03:15:50 millert Exp $ */
d95 1
d137 2
a138 1
#define	splvm()			_splraise(ALPHA_PSL_IPL_IO)
@


1.14
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.13 2002/03/14 01:26:27 millert Exp $ */
d109 3
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.12 2001/09/30 13:08:45 art Exp $ */
d210 1
a210 1
void	*softintr_establish __P((int, void (*)(void *), void *));
d232 2
a233 2
void	*alpha_shared_intr_establish __P((struct alpha_shared_intr *,
	    unsigned int, int, int, int (*)(void *), void *, const char *));
@


1.12
log
@Generic soft interrupts from NetBSD plus some minor cleanups.
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.11 2001/07/09 18:55:22 millert Exp $ */
d116 1
a116 1
static __inline int _splraise __P((int));
d152 1
a152 1
typedef void (*ipifunc_t) __P((void));
d155 2
a156 2
void	alpha_send_ipi __P((unsigned long, unsigned long));
void	alpha_broadcast_ipi __P((unsigned long));
d166 1
a166 1
	int	(*ih_fn) __P((void *));
d198 1
a198 1
	void	(*sih_fn) __P((void *));
d211 3
a213 3
void	softintr_disestablish __P((void *));
void	softintr_init __P((void));
void	softintr_dispatch __P((void));
d229 3
a231 3
struct alpha_shared_intr *alpha_shared_intr_alloc __P((unsigned int));
int	alpha_shared_intr_dispatch __P((struct alpha_shared_intr *,
	    unsigned int));
d234 16
a249 16
void	alpha_shared_intr_disestablish __P((struct alpha_shared_intr *,
	    void *, const char *));
int	alpha_shared_intr_get_sharetype __P((struct alpha_shared_intr *,
	    unsigned int));
int	alpha_shared_intr_isactive __P((struct alpha_shared_intr *,
	    unsigned int));
void	alpha_shared_intr_set_dfltsharetype __P((struct alpha_shared_intr *,
	    unsigned int, int));
void	alpha_shared_intr_set_maxstrays __P((struct alpha_shared_intr *,
	    unsigned int, int));
void	alpha_shared_intr_stray __P((struct alpha_shared_intr *, unsigned int,
	    const char *));
void	alpha_shared_intr_set_private __P((struct alpha_shared_intr *,
	    unsigned int, void *));
void	*alpha_shared_intr_get_private __P((struct alpha_shared_intr *,
	    unsigned int));
@


1.12.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.12 2001/09/30 13:08:45 art Exp $ */
a109 3
/* SPL asserts */
#define	splassert(wantipl)	/* nothing */

d116 1
a116 1
static __inline int _splraise(int);
d152 1
a152 1
typedef void (*ipifunc_t)(void);
d155 2
a156 2
void	alpha_send_ipi(unsigned long, unsigned long);
void	alpha_broadcast_ipi(unsigned long);
d166 1
a166 1
	int	(*ih_fn)(void *);
d198 1
a198 1
	void	(*sih_fn)(void *);
d210 4
a213 4
void	*softintr_establish(int, void (*)(void *), void *);
void	softintr_disestablish(void *);
void	softintr_init(void);
void	softintr_dispatch(void);
d229 21
a249 21
struct alpha_shared_intr *alpha_shared_intr_alloc(unsigned int);
int	alpha_shared_intr_dispatch(struct alpha_shared_intr *,
	    unsigned int);
void	*alpha_shared_intr_establish(struct alpha_shared_intr *,
	    unsigned int, int, int, int (*)(void *), void *, const char *);
void	alpha_shared_intr_disestablish(struct alpha_shared_intr *,
	    void *, const char *);
int	alpha_shared_intr_get_sharetype(struct alpha_shared_intr *,
	    unsigned int);
int	alpha_shared_intr_isactive(struct alpha_shared_intr *,
	    unsigned int);
void	alpha_shared_intr_set_dfltsharetype(struct alpha_shared_intr *,
	    unsigned int, int);
void	alpha_shared_intr_set_maxstrays(struct alpha_shared_intr *,
	    unsigned int, int);
void	alpha_shared_intr_stray(struct alpha_shared_intr *, unsigned int,
	    const char *);
void	alpha_shared_intr_set_private(struct alpha_shared_intr *,
	    unsigned int, void *);
void	*alpha_shared_intr_get_private(struct alpha_shared_intr *,
	    unsigned int);
@


1.11
log
@Make quad types on alpha be "long long" not "long".  This means that
printf's "%lld" can be used with a quad_t or int64_t without a bogus cast.
@
text
@d1 38
a38 2
/* $OpenBSD: intr.h,v 1.10 2001/06/24 17:05:26 miod Exp $ */
/* $NetBSD: intr.h,v 1.25 2000/05/23 05:12:56 thorpej Exp $ */
d71 1
d75 14
a88 1
#define	IPL_NONE	0	/* disable only this interrupt */
d90 11
a100 5
#define	IPL_NET		2	/* disable network interrupts */
#define	IPL_TTY		3	/* disable terminal interrupts */
#define	IPL_CLOCK	4	/* disable clock interrupts */
#define	IPL_HIGH	5	/* disable all interrupts */
#define	IPL_SERIAL	6	/* disable serial interrupts */
a140 15
 * simulated software interrupt register
 */
extern u_long ssir;

#define	SIR_NET		0x1
#define	SIR_CLOCK	0x2
#define	SIR_SERIAL	0x4

#define	setsoft(x)	atomic_setbits_ulong(&ssir, (x))

#define	setsoftnet()	setsoft(SIR_NET)
#define	setsoftclock()	setsoft(SIR_CLOCK)
#define	setsoftserial()	setsoft(SIR_SERIAL)

/*
d185 43
@


1.10
log
@Define splvm() for arches who don't already provide it, with the same
definition as splimp().
art@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.9 2001/04/12 10:35:01 art Exp $ */
d87 1
a87 1
extern u_int64_t ssir;
@


1.9
log
@Remove a bogus __attribute__ ((unused)) from _splraise.
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.8 2000/11/08 21:27:19 ericj Exp $ */
d77 1
@


1.8
log
@tag the rest of alpha tree
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.25 2000/05/23 05:12:56 thorpej Exp $ */
d60 1
a60 1
static __inline int _splraise __P((int)) __attribute__ ((unused));
@


1.7
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
@


1.6
log
@Add spllowersoftclock(), same as splsoftclock(). (art@@ ok)
@
text
@d1 1
a1 2
/*	$OpenBSD: intr.h,v 1.5 1998/06/29 05:32:51 downsj Exp $	*/
/*	$NetBSD: intr.h,v 1.4 1996/12/03 17:34:47 cgd Exp $	*/
d4 1
d35 1
d43 1
d51 3
d55 26
a80 12
	    (s == ALPHA_PSL_IPL_0 ? spl0() : alpha_pal_swpipl(s))
#define splsoft()               alpha_pal_swpipl(ALPHA_PSL_IPL_SOFT)
#define spllowersoftclock()     splsoft()
#define splsoftclock()          splsoft()
#define splsoftnet()            splsoft()
#define splnet()                alpha_pal_swpipl(ALPHA_PSL_IPL_IO)
#define splbio()                alpha_pal_swpipl(ALPHA_PSL_IPL_IO)
#define splimp()                alpha_pal_swpipl(ALPHA_PSL_IPL_IO)
#define spltty()                alpha_pal_swpipl(ALPHA_PSL_IPL_IO)
#define splclock()              alpha_pal_swpipl(ALPHA_PSL_IPL_CLOCK)
#define splstatclock()          alpha_pal_swpipl(ALPHA_PSL_IPL_CLOCK)
#define splhigh()               alpha_pal_swpipl(ALPHA_PSL_IPL_HIGH)
d89 19
d109 5
a113 2
#define	setsoftnet()	ssir |= SIR_NET
#define	setsoftclock()	ssir |= SIR_CLOCK
d122 1
d126 1
d132 1
d139 4
a145 2
int	alpha_shared_intr_check __P((struct alpha_shared_intr *,
	    unsigned int, int));
d148 2
d160 6
d167 2
a168 1
#endif
@


1.5
log
@isa_intr_check(), alpha style.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.4 1997/01/24 19:57:12 niklas Exp $	*/
d52 1
@


1.5.8.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 2
/* $OpenBSD: intr.h,v 1.9 2001/04/12 10:35:01 art Exp $ */
/* $NetBSD: intr.h,v 1.25 2000/05/23 05:12:56 thorpej Exp $ */
a4 1
 * Copyright (c) 1997 Christopher G. Demetriou.  All rights reserved.
a34 1
#include <machine/atomic.h>
a41 1
#define	IPL_SERIAL	6	/* disable serial interrupts */
a48 3
#ifdef	_KERNEL

/* IPL-lowering/restoring macros */
d50 11
a60 26
    ((s) == ALPHA_PSL_IPL_0 ? spl0() : alpha_pal_swpipl(s))
#define	spllowersoftclock()	alpha_pal_swpipl(ALPHA_PSL_IPL_SOFT)

/* IPL-raising functions/macros */
static __inline int _splraise __P((int));
static __inline int
_splraise(s)
	int s;
{
	int cur = alpha_pal_rdps() & ALPHA_PSL_IPL_MASK;
	return (s > cur ? alpha_pal_swpipl(s) : cur);
}
#define splsoft()		_splraise(ALPHA_PSL_IPL_SOFT)
#define splsoftserial()		splsoft()
#define splsoftclock()		splsoft()
#define splsoftnet()		splsoft()
#define splnet()                _splraise(ALPHA_PSL_IPL_IO)
#define splbio()                _splraise(ALPHA_PSL_IPL_IO)
#define splimp()                _splraise(ALPHA_PSL_IPL_IO)
#define spltty()                _splraise(ALPHA_PSL_IPL_IO)
#define splserial()             _splraise(ALPHA_PSL_IPL_IO)
#define splclock()              _splraise(ALPHA_PSL_IPL_CLOCK)
#define splstatclock()          _splraise(ALPHA_PSL_IPL_CLOCK)
#define splhigh()               _splraise(ALPHA_PSL_IPL_HIGH)

#define spllpt()		spltty()
a68 19
#define	SIR_SERIAL	0x4

#define	setsoft(x)	atomic_setbits_ulong(&ssir, (x))

#define	setsoftnet()	setsoft(SIR_NET)
#define	setsoftclock()	setsoft(SIR_CLOCK)
#define	setsoftserial()	setsoft(SIR_SERIAL)

/*
 * Interprocessor interrupts.  In order how we want them processed.
 */
#define	ALPHA_IPI_HALT		0x0000000000000001UL
#define	ALPHA_IPI_TBIA		0x0000000000000002UL
#define	ALPHA_IPI_TBIAP		0x0000000000000004UL
#define	ALPHA_IPI_SHOOTDOWN	0x0000000000000008UL
#define	ALPHA_IPI_IMB		0x0000000000000010UL
#define	ALPHA_IPI_AST		0x0000000000000020UL

#define	ALPHA_NIPIS		6	/* must not exceed 64 */
d70 2
a71 5
typedef void (*ipifunc_t) __P((void));
extern	ipifunc_t ipifuncs[ALPHA_NIPIS];

void	alpha_send_ipi __P((unsigned long, unsigned long));
void	alpha_broadcast_ipi __P((unsigned long));
a79 1
	struct alpha_shared_intr *ih_intrhead;
a82 1
	unsigned int ih_num;
a87 1
	void	*intr_private;
a93 4
#define	ALPHA_SHARED_INTR_DISABLE(asi, num)				\
	((asi)[num].intr_maxstrays != 0 &&				\
	 (asi)[num].intr_nstrays == (asi)[num].intr_maxstrays)

d97 2
a100 2
void	alpha_shared_intr_disestablish __P((struct alpha_shared_intr *,
	    void *, const char *));
a110 6
void	alpha_shared_intr_set_private __P((struct alpha_shared_intr *,
	    unsigned int, void *));
void	*alpha_shared_intr_get_private __P((struct alpha_shared_intr *,
	    unsigned int));

void	set_iointr(void (*)(void *, unsigned long));
d112 1
a112 2
#endif /* _KERNEL */
#endif /* ! _ALPHA_INTR_H_ */
@


1.5.8.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: intr.h,v 1.5.8.1 2001/04/18 16:00:54 niklas Exp $ */
a76 1
#define	splvm()			_splraise(ALPHA_PSL_IPL_IO)
@


1.5.8.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 38
/* $OpenBSD: intr.h,v 1.5.8.2 2001/07/04 10:14:36 niklas Exp $ */
/* $NetBSD: intr.h,v 1.26 2000/06/03 20:47:41 thorpej Exp $ */

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
a34 1
#include <sys/lock.h>
d38 1
a38 14
/*
 * Alpha interrupts come in at one of 4 levels:
 *
 *	software interrupt level
 *	i/o level 1
 *	i/o level 2
 *	clock level
 *
 * However, since we do not have any way to know which hardware
 * level a particular i/o interrupt comes in on, we have to
 * whittle it down to 3.
 */

#define	IPL_NONE	1	/* disable only this interrupt */
d40 5
a44 11
#define	IPL_NET		1	/* disable network interrupts */
#define	IPL_TTY		1	/* disable terminal interrupts */
#define	IPL_CLOCK	2	/* disable clock interrupts */
#define	IPL_HIGH	3	/* disable all interrupts */
#define	IPL_SERIAL	1	/* disable serial interrupts */

#define	IPL_SOFTSERIAL	0	/* serial software interrupts */
#define	IPL_SOFTNET	1	/* network software interrupts */
#define	IPL_SOFTCLOCK	2	/* clock software interrupts */
#define	IPL_SOFT	3	/* other software interrupts */
#define	IPL_NSOFT	4
d85 15
a143 43

/*
 * simulated software interrupt register
 */
extern unsigned long ssir;

#define	setsoft(x)	atomic_setbits_ulong(&ssir, 1 << (x))

#define	__GENERIC_SOFT_INTERRUPTS
struct alpha_soft_intrhand {
	LIST_ENTRY(alpha_soft_intrhand)
		sih_q;
	struct alpha_soft_intr *sih_intrhead;
	void	(*sih_fn) __P((void *));
	void	*sih_arg;
	int	sih_pending;
};

struct alpha_soft_intr {
	LIST_HEAD(, alpha_soft_intrhand)
		softintr_q;
	struct simplelock softintr_slock;
	unsigned long softintr_ipl;
};

void	*softintr_establish __P((int, void (*)(void *), void *));
void	softintr_disestablish __P((void *));
void	softintr_init __P((void));
void	softintr_dispatch __P((void));

#define	softintr_schedule(arg)						\
do {									\
	struct alpha_soft_intrhand *__sih = (arg);			\
	__sih->sih_pending = 1;						\
	setsoft(__sih->sih_intrhead->softintr_ipl);			\
} while (0)

/* XXX For legacy software interrupts. */
extern struct alpha_soft_intrhand *softnet_intrhand;
extern struct alpha_soft_intrhand *softclock_intrhand;

#define	setsoftnet()	softintr_schedule(softnet_intrhand)
#define	setsoftclock()	softintr_schedule(softclock_intrhand)
@


1.5.8.4
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d116 1
a116 1
static __inline int _splraise(int);
d152 1
a152 1
typedef void (*ipifunc_t)(void);
d155 2
a156 3
void	alpha_send_ipi(unsigned long, unsigned long);
void	alpha_broadcast_ipi(unsigned long);
void	alpha_multicast_ipi(unsigned long, unsigned long);
d166 1
a166 1
	int	(*ih_fn)(void *);
d198 1
a198 1
	void	(*sih_fn)(void *);
d210 4
a213 4
void	*softintr_establish(int, void (*)(void *), void *);
void	softintr_disestablish(void *);
void	softintr_init(void);
void	softintr_dispatch(void);
d229 21
a249 21
struct alpha_shared_intr *alpha_shared_intr_alloc(unsigned int);
int	alpha_shared_intr_dispatch(struct alpha_shared_intr *,
	    unsigned int);
void	*alpha_shared_intr_establish(struct alpha_shared_intr *,
	    unsigned int, int, int, int (*)(void *), void *, const char *);
void	alpha_shared_intr_disestablish(struct alpha_shared_intr *,
	    void *, const char *);
int	alpha_shared_intr_get_sharetype(struct alpha_shared_intr *,
	    unsigned int);
int	alpha_shared_intr_isactive(struct alpha_shared_intr *,
	    unsigned int);
void	alpha_shared_intr_set_dfltsharetype(struct alpha_shared_intr *,
	    unsigned int, int);
void	alpha_shared_intr_set_maxstrays(struct alpha_shared_intr *,
	    unsigned int, int);
void	alpha_shared_intr_stray(struct alpha_shared_intr *, unsigned int,
	    const char *);
void	alpha_shared_intr_set_private(struct alpha_shared_intr *,
	    unsigned int, void *);
void	*alpha_shared_intr_get_private(struct alpha_shared_intr *,
	    unsigned int);
@


1.5.8.5
log
@Sync the SMP branch with 3.3
@
text
@a109 3
/* SPL asserts */
#define	splassert(wantipl)	/* nothing */

@


1.5.8.6
log
@Merge with the trunk
@
text
@a94 1
#define	IPL_AUDIO	1	/* disable audio interrupts */
d136 1
a136 2
#define splaudio()		_splraise(ALPHA_PSL_IPL_IO)
#define splvm()			_splraise(ALPHA_PSL_IPL_IO)
@


1.4
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.3 1996/10/30 22:39:09 niklas Exp $	*/
d97 2
@


1.3
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 2
a2 2
/*	$OpenBSD: intr.h,v 1.2 1996/07/09 00:33:25 cgd Exp $	*/
/*	$NetBSD: intr.h,v 1.2 1996/07/09 00:33:25 cgd Exp $	*/
d34 2
d43 1
a69 1
#define	siroff(x)	ssir &= ~(x)
d72 37
@


1.2
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: intr.h,v 1.1 1996/04/12 01:42:17 cgd Exp $	*/
/*	$NetBSD: intr.h,v 1.1 1996/04/12 01:42:17 cgd Exp $	*/
d31 3
d45 27
@


1.1
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@
