head	1.13;
access;
symbols
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.2
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.12.0.10
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.12
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.4
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.8
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.11.0.2
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.10.0.42
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.40
	OPENBSD_5_0:1.10.0.38
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.36
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.34
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.30
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.32
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.28
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.26
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.24
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.22
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.20
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.18
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.16
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.14
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.12
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.10
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.8
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.6
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.8
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.10
	UBC:1.9.0.6
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.7.0.8
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.6
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.4
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.10
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.8
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.05.27.16.32.38;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	c5mTYSkstZ7XStNS;

1.12
date	2013.03.28.17.41.03;	author martynas;	state Exp;
branches;
next	1.11;

1.11
date	2012.09.21.13.58.48;	author naddy;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.26.19.57.11;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.08.21.27.16;	author ericj;	state Exp;
branches
	1.9.6.1;
next	1.8;

1.8
date	2000.11.08.16.01.10;	author art;	state Exp;
branches;
next	1.7;

1.7
date	99.09.26.11.07.32;	author kstailey;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	97.01.24.19.57.07;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.10.30.22.38.52;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.07.29.22.58.25;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.06.18.09.43.05;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.53.02;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.41;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.41;	author deraadt;	state Exp;
branches;
next	;

1.7.4.1
date	2001.04.18.16.00.45;	author niklas;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2003.03.27.23.18.06;	author niklas;	state Exp;
branches;
next	;

1.9.6.1
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Remove the non ELF macros
ok millert
@
text
@/* $OpenBSD: asm.h,v 1.12 2013/03/28 17:41:03 martynas Exp $ */
/* $NetBSD: asm.h,v 1.23 2000/06/23 12:18:45 kleink Exp $ */

/* 
 * Copyright (c) 1991,1990,1989,1994,1995,1996 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */

/*
 *	Assembly coding style
 *
 *	This file contains macros and register defines to
 *	aid in writing more readable assembly code.
 *	Some rules to make assembly code understandable by
 *	a debugger are also noted.
 *
 *	The document
 *
 *		"ALPHA Calling Standard", DEC 27-Apr-90
 *
 *	defines (a superset of) the rules and conventions
 *	we use.  While we make no promise of adhering to
 *	such standard and its evolution (esp where we
 *	can get faster code paths) it is certainly intended
 *	that we be interoperable with such standard.
 *
 *	In this sense, this file is a proper part of the
 *	definition of the (software) Alpha architecture.
 */

/*
 *	Symbolic register names and register saving rules
 *
 *	Legend:
 *		T	Saved by caller (Temporaries)
 *		S	Saved by callee (call-Safe registers)
 */

#define	v0	$0	/* (T)		return value		*/
#define t0	$1	/* (T)		temporary registers	*/
#define t1	$2
#define t2	$3
#define t3	$4
#define t4	$5
#define t5	$6
#define t6	$7
#define t7	$8

#define s0	$9	/* (S)		call-safe registers	*/
#define s1	$10
#define s2	$11
#define s3	$12
#define s4	$13
#define s5	$14
#define s6	$15
#define a0	$16	/* (T)		argument registers	*/
#define a1	$17
#define a2	$18
#define a3	$19
#define a4	$20
#define a5	$21
#define t8	$22	/* (T)		temporary registers	*/
#define t9	$23
#define t10	$24
#define t11	$25
#define ra	$26	/* (T)		return address		*/
#define t12	$27	/* (T)		another temporary	*/
#define at_reg	$28	/* (T)		assembler scratch	*/
#define	gp	$29	/* (T)		(local) data pointer	*/
#define sp	$30	/* (S)		stack pointer		*/
#define zero	$31	/* 		wired zero		*/

/* Floating point registers  (XXXX VERIFY THIS) */
#define	fv0	$f0	/* (T)		return value (real)	*/
#define	fv1	$f1	/* (T)		return value (imaginary)*/
#define	ft0	fv1
#define	fs0	$f2	/* (S)		call-safe registers	*/
#define	fs1	$f3
#define	fs2	$f4
#define	fs3	$f5
#define	fs4	$f6
#define	fs5	$f7
#define	fs6	$f8
#define	fs7	$f9
#define	ft1	$f10	/* (T)		temporary registers	*/
#define	ft2	$f11
#define	ft3	$f12
#define	ft4	$f13
#define	ft5	$f14
#define	ft6	$f15
#define	fa0	$f16	/* (T)		argument registers	*/
#define	fa1	$f17
#define	fa2	$f18
#define	fa3	$f19
#define	fa4	$f20
#define	fa5	$f21
#define	ft7	$f22	/* (T)		more temporaries	*/
#define	ft8	$f23
#define	ft9	$f24
#define	ft10	$f25
#define	ft11	$f26
#define	ft12	$f27
#define	ft13	$f28
#define	ft14	$f29
#define	ft15	$f30
#define	fzero	$f31	/*		wired zero		*/


/* Other DEC standard names */
#define fp	$15	/* (S)		frame pointer		*/
#define ai	$25	/* (T)		argument information	*/
#define pv	$27	/* (T)		procedure value		*/
#define AT	$28	/* (T)		assembler scratch	*/


/*
 * Useful stuff.
 */
#ifdef __STDC__
#define	__CONCAT(a,b)	a ## b
#else
#define	__CONCAT(a,b)	a/**/b
#endif
#define ___CONCAT(a,b)	__CONCAT(a,b)

/*
 * Macro to make a local label name.
 */
#define	LLABEL(name,num)	___CONCAT(___CONCAT(L,name),num)

/*
 *
 * Debuggers need symbol table information to be able to properly
 * decode a stack trace.  The minimum that should be provided is:
 *
 * 	name:
 *		.proc	name,numargs
 *
 * where "name" 	is the function's name;
 *	 "numargs"	how many arguments it expects. For varargs
 *			procedures this should be a negative number,
 *			indicating the minimum required number of
 *			arguments (which is at least 1);
 *
 * NESTED functions (functions that call other functions) should define
 * how they handle their stack frame in a .frame directive:
 *
 *		.frame	framesize, pc_reg, i_mask, f_mask
 *
 * where "framesize"	is the size of the frame for this function, in bytes.
 *			That is:
 *				new_sp + framesize == old_sp
 *			Framesizes should be rounded to a cacheline size.
 *			Note that old_sp plays the role of a conventional
 *			"frame pointer";
 *	 "pc_reg"	is either a register which preserves the caller's PC
 *			or 'std', if std the saved PC should be stored at
 *				old_sp-8
 * 	 "i_mask"	is a bitmask that indicates which of the integer
 *			registers are saved. See the M_xx defines at the
 *			end for the encoding of this 32bit value.
 *	 "f_mask"	is the same, for floating point registers.
 *
 * Note, 10/31/97: This is interesting but it isn't the way gcc outputs
 * frame directives and it isn't the way the macros below output them
 * either. Frame directives look like this:
 *
 *		.frame	$15,framesize,$26,0
 *
 * If no fp is set up then $30 should be used instead of $15.
 * Also, gdb expects to find a <lda sp,-framesize(sp)> at the beginning
 * of a procedure. Don't use things like sub sp,framesize,sp for this
 * reason. End Note 10/31/97. ross@@netbsd.org
 *
 * Note that registers should be saved starting at "old_sp-8", where the
 * return address should be stored. Other registers follow at -16-24-32..
 * starting from register 0 (if saved) and up. Then float registers (ifany)
 * are saved.
 *
 * If you need to alias a leaf function, or to provide multiple entry points
 * use the LEAF() macro for the main entry point and XLEAF() for the other
 * additional/alternate entry points.
 * "XLEAF"s must be nested within a "LEAF" and a ".end".
 * Similar rules for nested routines, e.g. use NESTED/XNESTED
 * Symbols that should not be exported can be declared with the STATIC_xxx
 * macros.
 *
 * All functions must be terminated by the END macro
 *
 * It is conceivable, although currently at the limits of compiler
 * technology, that while performing inter-procedural optimizations
 * the compiler/linker be able to avoid unnecessary register spills
 * if told about the register usage of LEAF procedures (and by transitive
 * closure of NESTED procedures as well).  Assembly code can help
 * this process using the .reguse directive:
 *
 *		.reguse	i_mask, f_mask
 *
 * where the register masks are built as above or-ing M_xx defines.
 *	
 *
 * All symbols are internal unless EXPORTed.  Symbols that are IMPORTed
 * must be appropriately described to the debugger.
 *
 */

/*
 * MCOUNT
 */

#ifndef GPROF
#define MCOUNT	/* nothing */
#else
#define MCOUNT							\
	.set noat;						\
	jsr	at_reg,_mcount;					\
	.set at
#endif
/*
 * PALVECT, ESETUP, and ERSAVE
 *	Declare a palcode transfer point, and carefully construct
 *	gdb symbols with an unusual _negative_ register-save offset
 *	so that gdb can find the otherwise lost PC and then
 *	invert the vector for traceback. Also, fix up framesize,
 *	allowing for the palframe for the same reason.
 */

#define PALVECT(_name_)						\
	ESETUP(_name_);						\
	ERSAVE()

#define	ESETUP(_name_)						\
	/* .loc	1 __LINE__; */					\
	.globl	_name_;						\
	.ent	_name_ 0;					\
_name_:;							\
	.set	noat;						\
	lda	sp,-(FRAME_SW_SIZE*8)(sp);			\
	.frame	$30,(FRAME_SW_SIZE+6)*8,$26,0;   /* give gdb the real size */\
	.mask	0x4000000,-0x28;				\
	.set	at

#define	ERSAVE()						\
	.set	noat;						\
	stq	at_reg,(FRAME_AT*8)(sp);			\
	.set	at;						\
	stq	ra,(FRAME_RA*8)(sp);				\
	/* .loc	1 __LINE__; */					\
	bsr	ra,exception_save_regs         /* jmp/CALL trashes pv/t12 */


/*
 * LEAF
 *	Declare a global leaf function.
 *	A leaf function does not call other functions AND does not
 *	use any register that is callee-saved AND does not modify
 *	the stack pointer.
 */
#define	LEAF(_name_,_n_args_)					\
	.globl	_name_;						\
	.ent	_name_ 0;					\
_name_:;							\
	.frame	sp,0,ra;					\
	MCOUNT
/* should have been
	.proc	_name_,_n_args_;				\
	.frame	0,ra,0,0
*/

#define	LEAF_NOPROFILE(_name_,_n_args_)					\
	.globl	_name_;						\
	.ent	_name_ 0;					\
_name_:;							\
	.frame	sp,0,ra
/* should have been
	.proc	_name_,_n_args_;				\
	.frame	0,ra,0,0
*/

/*
 * STATIC_LEAF
 *	Declare a local leaf function.
 */
#define STATIC_LEAF(_name_,_n_args_)				\
	.ent	_name_ 0;					\
_name_:;							\
	.frame	sp,0,ra;					\
	MCOUNT
/* should have been
	.proc	_name_,_n_args_;				\
	.frame	0,ra,0,0
*/
/*
 * XLEAF
 *	Global alias for a leaf function, or alternate entry point
 */
#define	XLEAF(_name_,_n_args_)					\
	.globl	_name_;						\
	.aent	_name_ 0;					\
_name_:
/* should have been
	.aproc	_name_,_n_args_;
*/

/*
 * STATIC_XLEAF
 *	Local alias for a leaf function, or alternate entry point
 */
#define	STATIC_XLEAF(_name_,_n_args_)				\
	.aent	_name_ 0;					\
_name_:
/* should have been
	.aproc	_name_,_n_args_;
*/

/*
 * NESTED
 *	Declare a (global) nested function
 *	A nested function calls other functions and needs
 *	therefore stack space to save/restore registers.
 */
#define	NESTED(_name_, _n_args_, _framesize_, _pc_reg_, _i_mask_, _f_mask_ ) \
	.globl	_name_;						\
	.ent	_name_ 0;					\
_name_:;							\
	.frame	sp,_framesize_,_pc_reg_;			\
	.livereg _i_mask_,_f_mask_;				\
	MCOUNT
/* should have been
	.proc	_name_,_n_args_;				\
	.frame	_framesize_, _pc_reg_, _i_mask_, _f_mask_
*/

#define	NESTED_NOPROFILE(_name_, _n_args_, _framesize_, _pc_reg_, _i_mask_, _f_mask_ ) \
	.globl	_name_;						\
	.ent	_name_ 0;					\
_name_:;							\
	.frame	sp,_framesize_,_pc_reg_;			\
	.livereg _i_mask_,_f_mask_
/* should have been
	.proc	_name_,_n_args_;				\
	.frame	_framesize_, _pc_reg_, _i_mask_, _f_mask_
*/

/*
 * STATIC_NESTED
 *	Declare a local nested function.
 */
#define	STATIC_NESTED(_name_, _n_args_, _framesize_, _pc_reg_, _i_mask_, _f_mask_ ) \
	.ent	_name_ 0;					\
_name_:;							\
	.frame	sp,_framesize_,_pc_reg_;			\
	.livereg _i_mask_,_f_mask_;				\
	MCOUNT
/* should have been
	.proc	_name_,_n_args_;				\
	.frame	_framesize_, _pc_reg_, _i_mask_, _f_mask_
*/

/*
 * XNESTED
 *	Same as XLEAF, for a nested function.
 */
#define	XNESTED(_name_,_n_args_)				\
	.globl	_name_;						\
	.aent	_name_ 0;					\
_name_:
/* should have been
	.aproc	_name_,_n_args_;
*/


/*
 * STATIC_XNESTED
 *	Same as STATIC_XLEAF, for a nested function.
 */
#define	STATIC_XNESTED(_name_,_n_args_)				\
	.aent	_name_ 0;					\
_name_:
/* should have been
	.aproc	_name_,_n_args_;
*/


/*
 * END
 *	Function delimiter
 */
#define	END(_name_)						\
	.end	_name_


/*
 * CALL
 *	Function invocation
 */
#define	CALL(_name_)						\
	/* .loc	1 __LINE__; */					\
	jsr	ra,_name_;					\
	ldgp	gp,0(ra)
/* but this would cover longer jumps
	br	ra,.+4;						\
	bsr	ra,_name_
*/


/*
 * RET
 *	Return from function
 */
#define	RET							\
	ret	zero,(ra),1


/*
 * EXPORT
 *	Export a symbol
 */
#define	EXPORT(_name_)						\
	.globl	_name_;						\
_name_:


/*
 * IMPORT
 *	Make an external name visible, typecheck the size
 */
#define	IMPORT(_name_, _size_)					\
	.extern	_name_,_size_


/*
 * ABS
 *	Define an absolute symbol
 */
#define	ABS(_name_, _value_)					\
	.globl	_name_;						\
_name_	=	_value_


/*
 * BSS
 *	Allocate un-initialized space for a global symbol
 */
#define	BSS(_name_,_numbytes_)					\
	.comm	_name_,_numbytes_

/*
 * VECTOR
 *	Make an exception entry point look like a called function,
 *	to make it digestible to the debugger (KERNEL only)
 */
#define	VECTOR(_name_, _i_mask_)				\
	.globl	_name_;						\
	.ent	_name_ 0;					\
_name_:;							\
	.mask	_i_mask_|IM_EXC,0;				\
	.frame	sp,MSS_SIZE,ra;				
/*	.livereg _i_mask_|IM_EXC,0	*/
/* should have been
	.proc	_name_,1;					\
	.frame	MSS_SIZE,$31,_i_mask_,0;			\
*/

/*
 * MSG
 *	Allocate space for a message (a read-only ascii string)
 */
#define	ASCIZ	.asciz
#define	MSG(msg,reg,label)					\
	lda reg, label;						\
	.data;							\
label:	ASCIZ msg;						\
	.text;

/*
 * PRINTF
 *	Print a message
 */
#define	PRINTF(msg,label)					\
	MSG(msg,a0,label);					\
	CALL(printf)

/*
 * PANIC
 *	Fatal error (KERNEL)
 */
#define	PANIC(msg,label)					\
	MSG(msg,a0,label);					\
	CALL(panic)

/*
 * Register mask defines, used to define both save
 * and use register sets.
 *
 * NOTE: The bit order should HAVE BEEN maintained when saving
 *	 registers on the stack: sp goes at the highest
 *	 address, gp lower on the stack, etc etc
 *	 BUT NOONE CARES ABOUT DEBUGGERS AT MIPS
 */

#define	IM_EXC	0x80000000
#define	IM_SP	0x40000000
#define	IM_GP	0x20000000
#define	IM_AT	0x10000000
#define	IM_T12	0x08000000
#	define	IM_PV	IM_T4
#define	IM_RA	0x04000000
#define	IM_T11	0x02000000
#	define	IM_AI	IM_T3
#define	IM_T10	0x01000000
#define	IM_T9	0x00800000
#define	IM_T8	0x00400000
#define	IM_A5	0x00200000
#define	IM_A4	0x00100000
#define	IM_A3	0x00080000
#define	IM_A2	0x00040000
#define	IM_A1	0x00020000
#define	IM_A0	0x00010000
#define	IM_S6	0x00008000
#define	IM_S5	0x00004000
#define	IM_S4	0x00002000
#define	IM_S3	0x00001000
#define	IM_S2	0x00000800
#define	IM_S1	0x00000400
#define	IM_S0	0x00000200
#define	IM_T7	0x00000100
#define	IM_T6	0x00000080
#define	IM_T5	0x00000040
#define	IM_T4	0x00000020
#define	IM_T3	0x00000010
#define	IM_T2	0x00000008
#define	IM_T1	0x00000004
#define	IM_T0	0x00000002
#define	IM_V0	0x00000001

#define	FM_T15	0x40000000
#define	FM_T14	0x20000000
#define	FM_T13	0x10000000
#define	FM_T12	0x08000000
#define	FM_T11	0x04000000
#define	FM_T10	0x02000000
#define	FM_T9	0x01000000
#define	FM_T8	0x00800000
#define	FM_T7	0x00400000
#define	FM_A5	0x00200000
#define	FM_A4	0x00100000
#define	FM_A3	0x00080000
#define	FM_A2	0x00040000
#define	FM_A1	0x00020000
#define	FM_A0	0x00010000
#define	FM_T6	0x00008000
#define	FM_T5	0x00004000
#define	FM_T4	0x00002000
#define	FM_T3	0x00001000
#define	FM_T2	0x00000800
#define	FM_T1	0x00000400
#define	FM_S7	0x00000200
#define	FM_S6	0x00000100
#define	FM_S5	0x00000080
#define	FM_S4	0x00000040
#define	FM_S3	0x00000020
#define	FM_S2	0x00000010
#define	FM_S1	0x00000008
#define	FM_S0	0x00000004
#define	FM_T0	0x00000002
#define	FM_V1	FM_T0
#define	FM_V0	0x00000001

/* Pull in PAL "function" codes. */
#include <machine/pal.h>

/*
 * System call glue.
 */
#define	SYSCALLNUM(name)					\
	___CONCAT(SYS_,name)

#define	CALLSYS_NOERROR(name)					\
	ldiq	v0, SYSCALLNUM(name);				\
	call_pal PAL_OSF1_callsys

#define NETBSD_SYSCALLNUM(name)					\
	___CONCAT(NETBSD_SYS_,name)

#define NETBSD_CALLSYS_NOERROR(name)				\
	ldiq	v0, NETBSD_SYSCALLNUM(name);			\
	call_pal PAL_OSF1_callsys

/*
 * Load the global pointer.
 */
#define	LDGP(reg)						\
	ldgp	gp, 0(reg)

/*
 * STRONG_ALIAS, WEAK_ALIAS
 *	Create a strong or weak alias.
 */
#define STRONG_ALIAS(alias,sym)					\
	.global alias;						\
	alias = sym
#define WEAK_ALIAS(alias,sym)					\
	.weak alias;						\
	alias = sym

/*
 * WARN_REFERENCES: create a warning if the specified symbol is referenced
 * (ELF only).
 */
#ifdef __STDC__
#define	WARN_REFERENCES(_sym,_msg)				\
	.section .gnu.warning. ## _sym ; .ascii _msg ; .text
#else
#define	WARN_REFERENCES(_sym,_msg)				\
	.section .gnu.warning./**/_sym ; .ascii _msg ; .text
#endif /* __STDC__ */

/*
 * Kernel RCS ID tag and copyright macros
 */

#ifdef _KERNEL

#define	__KERNEL_SECTIONSTRING(_sec, _str)				\
	.section _sec ; .asciz _str ; .text

#define	__KERNEL_RCSID(_n, _s)		__KERNEL_SECTIONSTRING(.ident, _s)
#define	__KERNEL_COPYRIGHT(_n, _s)	__KERNEL_SECTIONSTRING(.copyright, _s)

#ifdef NO_KERNEL_RCSIDS
#undef __KERNEL_RCSID
#define	__KERNEL_RCSID(_n, _s)		/* nothing */
#endif

#endif /* _KERNEL */
@


1.12
log
@Add STRONG_ALIAS macros to be used from assembly code in libc and
libm.  While at it, remove now unused workarounds for lint.
Agreed by kettenis@@, guenther@@, matthew@@.
@
text
@d1 1
a1 1
/* $OpenBSD: asm.h,v 1.11 2012/09/21 13:58:48 naddy Exp $ */
a619 1
#ifdef __ELF__
a625 1
#endif
a630 1
#ifdef __ELF__
a637 1
#endif /* __ELF__ */
a644 1
#ifdef __ELF__
a646 4
#else /* __ELF__ */
#define	__KERNEL_SECTIONSTRING(_sec, _str)				\
	.data ; .asciz _str ; .align 3 ; .text
#endif /* __ELF__ */
@


1.11
log
@add register aliases "fp" and "AT" as available on Tru64 and Linux; ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: asm.h,v 1.10 2002/04/26 19:57:11 fgsch Exp $ */
d617 2
a618 1
 * WEAK_ALIAS: create a weak alias (ELF only).
d621 3
@


1.10
log
@newer gas is picky about misplaced .loc directives; comment'em out for now.
tested by miod, deraadt ok
@
text
@d1 1
a1 1
/* $OpenBSD: asm.h,v 1.9 2000/11/08 21:27:16 ericj Exp $ */
d130 1
d133 1
@


1.9
log
@tag the rest of alpha tree
@
text
@d1 1
a1 1
/* $OpenBSD: asm.h,v 1.23 2000/06/23 12:18:45 kleink Exp $ */
d251 1
a251 1
	.loc	1 __LINE__;					\
d266 1
a266 1
	.loc	1 __LINE__;					\
d416 1
a416 1
	.loc	1 __LINE__;					\
@


1.9.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: asm.h,v 1.9 2000/11/08 21:27:16 ericj Exp $ */
d251 1
a251 1
	/* .loc	1 __LINE__; */					\
d266 1
a266 1
	/* .loc	1 __LINE__; */					\
d416 1
a416 1
	/* .loc	1 __LINE__; */					\
@


1.8
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
@


1.7
log
@netbsd_sendsig() + supporting code
@
text
@d1 1
a1 2
/*	$OpenBSD: asm.h,v 1.6 1997/01/24 19:57:07 niklas Exp $	*/
/*	$NetBSD: asm.h,v 1.11 1996/11/30 02:48:57 jtc Exp $	*/
d181 11
d236 32
d415 1
d476 1
a476 1
/*	.livereg _i_mask_|IM_EXC,0
d587 2
a588 63
/*
 * PAL "function" codes (used as arguments to call_pal instructions).
 *
 * Those marked with "P" are privileged, and those marked with "U"
 * are unprivileged.
 */

/* Common PAL function codes. */
#define	PAL_halt		0x0000			/* P */
#define	PAL_draina		0x0002			/* P */
#define	PAL_cserve		0x0009			/* P */
#define	PAL_swppal		0x000a			/* P */
#define	PAL_bpt			0x0080			/* U */
#define	PAL_bugchk		0x0081			/* U */
#define	PAL_imb			0x0086			/* U */
#define	PAL_rdunique		0x009e			/* U */
#define	PAL_wrunique		0x009f			/* U */
#define	PAL_gentrap		0x00aa			/* U */

/* VMS PAL function codes. */
#define	PAL_VMS_ldqp		0x0003			/* P */
#define	PAL_VMS_stqp		0x0004			/* P */
#define	PAL_VMS_mtpr_fen	0x000c			/* P */
#define	PAL_VMS_mtpr_ipir	0x000d			/* P */
#define	PAL_VMS_mfpr_ipl	0x000e			/* P */
#define	PAL_VMS_mtpr_ipl	0x000f			/* P */
#define	PAL_VMS_mfpr_mces	0x0010			/* P */
#define	PAL_VMS_mtpr_mces	0x0011			/* P */
#define	PAL_VMS_mfpr_prbr	0x0013			/* P */
#define	PAL_VMS_mtpr_prbr	0x0014			/* P */
#define	PAL_VMS_mfpr_ptbr	0x0015			/* P */
#define	PAL_VMS_mtpr_scbb	0x0017			/* P */
#define	PAL_VMS_mtpr_sirr	0x0018			/* P */
#define	PAL_VMS_mtpr_tbia	0x001b			/* P */
#define	PAL_VMS_mtpr_tbiap	0x001c			/* P */
#define	PAL_VMS_mtpr_tbis	0x001d			/* P */
#define	PAL_VMS_mfpr_usp	0x0022			/* P */
#define	PAL_VMS_mtpr_usp	0x0023			/* P */
#define	PAL_VMS_mfpr_vptb	0x0029			/* P */
#define	PAL_VMS_mfpr_whami	0x003f			/* P */
#define	PAL_VMS_rei		0x0092			/* U */

/* OSF/1 PAL function codes. */
#define	PAL_OSF1_rdmces		0x0010			/* P */
#define	PAL_OSF1_wrmces		0x0011			/* P */
#define	PAL_OSF1_wrfen		0x002b			/* P */
#define	PAL_OSF1_wrvptptr	0x002d			/* P */
#define	PAL_OSF1_swpctx		0x0030			/* P */
#define	PAL_OSF1_wrval		0x0031			/* P */
#define	PAL_OSF1_rdval		0x0032			/* P */
#define	PAL_OSF1_tbi		0x0033			/* P */
#define	PAL_OSF1_wrent		0x0034			/* P */
#define	PAL_OSF1_swpipl		0x0035			/* P */
#define	PAL_OSF1_rdps		0x0036			/* P */
#define	PAL_OSF1_wrkgp		0x0037			/* P */
#define	PAL_OSF1_wrusp		0x0038			/* P */
#define	PAL_OSF1_rdusp		0x003a			/* P */
#define	PAL_OSF1_whami		0x003c			/* P */
#define	PAL_OSF1_retsys		0x003d			/* P */
#define	PAL_OSF1_rti		0x003f			/* P */
#define	PAL_OSF1_callsys	0x0083			/* U */
#define	PAL_OSF1_imb		0x0086			/* U */

d621 38
@


1.7.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 2
/* $OpenBSD: asm.h,v 1.9 2000/11/08 21:27:16 ericj Exp $ */
/* $NetBSD: asm.h,v 1.23 2000/06/23 12:18:45 kleink Exp $ */
a181 11
 * Note, 10/31/97: This is interesting but it isn't the way gcc outputs
 * frame directives and it isn't the way the macros below output them
 * either. Frame directives look like this:
 *
 *		.frame	$15,framesize,$26,0
 *
 * If no fp is set up then $30 should be used instead of $15.
 * Also, gdb expects to find a <lda sp,-framesize(sp)> at the beginning
 * of a procedure. Don't use things like sub sp,framesize,sp for this
 * reason. End Note 10/31/97. ross@@netbsd.org
 *
a225 32
/*
 * PALVECT, ESETUP, and ERSAVE
 *	Declare a palcode transfer point, and carefully construct
 *	gdb symbols with an unusual _negative_ register-save offset
 *	so that gdb can find the otherwise lost PC and then
 *	invert the vector for traceback. Also, fix up framesize,
 *	allowing for the palframe for the same reason.
 */

#define PALVECT(_name_)						\
	ESETUP(_name_);						\
	ERSAVE()

#define	ESETUP(_name_)						\
	.loc	1 __LINE__;					\
	.globl	_name_;						\
	.ent	_name_ 0;					\
_name_:;							\
	.set	noat;						\
	lda	sp,-(FRAME_SW_SIZE*8)(sp);			\
	.frame	$30,(FRAME_SW_SIZE+6)*8,$26,0;   /* give gdb the real size */\
	.mask	0x4000000,-0x28;				\
	.set	at

#define	ERSAVE()						\
	.set	noat;						\
	stq	at_reg,(FRAME_AT*8)(sp);			\
	.set	at;						\
	stq	ra,(FRAME_RA*8)(sp);				\
	.loc	1 __LINE__;					\
	bsr	ra,exception_save_regs         /* jmp/CALL trashes pv/t12 */

a372 1
	.loc	1 __LINE__;					\
d433 1
a433 1
/*	.livereg _i_mask_|IM_EXC,0	*/
d544 63
a606 2
/* Pull in PAL "function" codes. */
#include <machine/pal.h>
a638 38

/*
 * WARN_REFERENCES: create a warning if the specified symbol is referenced
 * (ELF only).
 */
#ifdef __ELF__
#ifdef __STDC__
#define	WARN_REFERENCES(_sym,_msg)				\
	.section .gnu.warning. ## _sym ; .ascii _msg ; .text
#else
#define	WARN_REFERENCES(_sym,_msg)				\
	.section .gnu.warning./**/_sym ; .ascii _msg ; .text
#endif /* __STDC__ */
#endif /* __ELF__ */

/*
 * Kernel RCS ID tag and copyright macros
 */

#ifdef _KERNEL

#ifdef __ELF__
#define	__KERNEL_SECTIONSTRING(_sec, _str)				\
	.section _sec ; .asciz _str ; .text
#else /* __ELF__ */
#define	__KERNEL_SECTIONSTRING(_sec, _str)				\
	.data ; .asciz _str ; .align 3 ; .text
#endif /* __ELF__ */

#define	__KERNEL_RCSID(_n, _s)		__KERNEL_SECTIONSTRING(.ident, _s)
#define	__KERNEL_COPYRIGHT(_n, _s)	__KERNEL_SECTIONSTRING(.copyright, _s)

#ifdef NO_KERNEL_RCSIDS
#undef __KERNEL_RCSID
#define	__KERNEL_RCSID(_n, _s)		/* nothing */
#endif

#endif /* _KERNEL */
@


1.7.4.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d251 1
a251 1
	/* .loc	1 __LINE__; */					\
d266 1
a266 1
	/* .loc	1 __LINE__; */					\
d416 1
a416 1
	/* .loc	1 __LINE__; */					\
@


1.6
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: asm.h,v 1.5 1996/10/30 22:38:52 niklas Exp $	*/
d616 7
@


1.5
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 2
a2 2
/*	$OpenBSD: asm.h,v 1.10 1996/10/17 18:33:53 cgd Exp $	*/
/*	$NetBSD: asm.h,v 1.10 1996/10/17 18:33:53 cgd Exp $	*/
d218 1
a218 1
#ifndef PROF
@


1.4
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: asm.h,v 1.4 1996/04/12 01:36:51 cgd Exp $	*/
/*	$NetBSD: asm.h,v 1.4 1996/04/12 01:36:51 cgd Exp $	*/
d133 16
d222 3
a224 12
	lda	sp, -16(sp);					\
	stq	pv, 0(sp);					\
								\
	br	pv, 1f;						\
1:	ldgp	gp, 0(pv);					\
	lda	pv, _mcount;					\
	jsr	at_reg, (pv);					\
	br	pv, 2f;						\
2:	ldgp	gp, 0(pv);					\
								\
	ldq	pv, 0(sp);					\
	lda	sp, 16(sp)
d444 2
a445 2
#define	MSG(msg,reg)						\
	lda reg, 9f;						\
d447 1
a447 1
9:	ASCIZ msg;						\
d454 2
a455 2
#define	PRINTF(msg)						\
	MSG(msg,a0);						\
d462 2
a463 2
#define	PANIC(msg)						\
	MSG(msg,a0);						\
d551 1
a551 1
/* Common PAL codes. */
d554 1
d563 1
a563 1
/* VMS PAL codes. */
d586 3
a588 1
/* OSF/1 PAL codes. */
d607 1
d609 1
a609 1
 * Defintions to make things portable between gcc and OSF/1 cc.
d611 2
a612 1
#define	SETGP(pv)	ldgp	gp,0(pv)
d614 9
a622 4
#define	MF_FPCR(x)	mf_fpcr x
#define	MT_FPCR(x)	mt_fpcr x
#define	JMP(loc)	jmp	zero,loc
#define	CONST(c,reg)	ldiq	reg, c
d624 8
@


1.3
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.2
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: asm.h,v 1.2 1995/11/23 02:35:45 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1991,1990,1989,1994,1995 Carnegie Mellon University
d603 1
a603 1
#define	JMP(loc)	br	zero,loc
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: asm.h,v 1.1 1995/02/13 23:07:30 cgd Exp $	*/
d198 22
d230 11
d254 2
a255 1
	.frame	sp,0,ra
d294 12
d320 2
a321 1
	.livereg _i_mask_,_f_mask_
a434 3
#ifdef __ALPHA_AS__
#define	ASCIZ	.asciiz
#else
a435 1
#endif
a600 6
#ifdef __ALPHA_AS__
#define	MF_FPCR(x)	mf_fpcr x,x,x
#define	MT_FPCR(x)	mt_fpcr x,x,x
#define	JMP(loc)	jmp	loc
#define	CONST(c,reg)	mov	c, reg
#else
a604 1
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
