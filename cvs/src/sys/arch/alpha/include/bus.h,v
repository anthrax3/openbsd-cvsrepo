head	1.30;
access;
symbols
	OPENBSD_6_1:1.30.0.6
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.2
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.29.0.18
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.20
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.12
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.16
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.14
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.10
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.8
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.6
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.4
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.28.0.6
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.4
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.26.0.4
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.25.0.2
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.24.0.10
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.8
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.6
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.4
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.20.0.4
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.19.0.6
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.4
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.18.0.6
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.18.0.4
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.18
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.13.0.4
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.10.0.14
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.12
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.10
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.8
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.6
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.4
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.30
date	2016.05.03.11.22.08;	author dlg;	state Exp;
branches;
next	1.29;
commitid	WTv6RR7Dlt8iJ4yn;

1.29
date	2011.03.23.16.54.34;	author pirofti;	state Exp;
branches;
next	1.28;

1.28
date	2009.12.25.20.52.32;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2009.07.30.21.39.15;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2009.04.20.00.42.05;	author oga;	state Exp;
branches;
next	1.25;

1.25
date	2009.02.01.14.33.58;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2006.05.12.20.48.19;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2006.04.27.15.17.07;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2006.04.04.21.20.40;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2006.04.04.21.18.43;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.25.18.29.58;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2003.10.18.20.14.41;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.30.16.11.25;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.26.27;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.07.18.08.08;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.05.17.25.57;	author art;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.10.26.01.28.06;	author nate;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.15.12.03.42;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.15.21.38.05;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.08.16.01.10;	author art;	state Exp;
branches;
next	1.10;

1.10
date	98.01.20.18.40.09;	author niklas;	state Exp;
branches
	1.10.10.1;
next	1.9;

1.9
date	97.06.05.23.21.30;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.04.10.01.28.53;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.04.02.22.08.07;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	97.03.21.00.16.32;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.01.24.19.57.09;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.11.12.22.46.26;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.10.30.22.38.55;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.07.29.22.58.29;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.06.18.09.43.08;	author deraadt;	state Exp;
branches;
next	;

1.10.10.1
date	2001.04.18.16.00.47;	author niklas;	state Exp;
branches;
next	1.10.10.2;

1.10.10.2
date	2001.10.31.02.52.44;	author nate;	state Exp;
branches;
next	1.10.10.3;

1.10.10.3
date	2001.11.13.21.00.49;	author niklas;	state Exp;
branches;
next	1.10.10.4;

1.10.10.4
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	1.10.10.5;

1.10.10.5
date	2003.03.27.23.18.06;	author niklas;	state Exp;
branches;
next	1.10.10.6;

1.10.10.6
date	2004.02.19.09.59.34;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.10.29.00.28.00;	author art;	state Exp;
branches;
next	;


desc
@@


1.30
log
@alias bus_space_{read,write}_raw to the non-raw counterparts

busses are little endian, so the non-raw ops are raw anyway. fixes
the kernel build after xge grew the use of the raw ops.
@
text
@/*	$OpenBSD: bus.h,v 1.29 2011/03/23 16:54:34 pirofti Exp $	*/
/*	$NetBSD: bus.h,v 1.10 1996/12/02 22:19:32 cgd Exp $	*/

/*
 * Copyright (c) 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#ifndef _MACHINE_BUS_H_
#define	_MACHINE_BUS_H_

/*
 * Addresses (in bus space).
 */
typedef u_long bus_addr_t;
typedef u_long bus_size_t;

/*
 * Access methods for bus space.
 */
typedef struct alpha_bus_space *bus_space_tag_t;
typedef u_long bus_space_handle_t;

struct alpha_bus_space {
	/* cookie */
	void		*abs_cookie;

	/* mapping/unmapping */
	int		(*abs_map)(void *, bus_addr_t, bus_size_t,
			    int, bus_space_handle_t *);
	void		(*abs_unmap)(void *, bus_space_handle_t,
			    bus_size_t);
	int		(*abs_subregion)(void *, bus_space_handle_t,
			    bus_size_t, bus_size_t, bus_space_handle_t *);

	/* allocation/deallocation */
	int		(*abs_alloc)(void *, bus_addr_t, bus_addr_t,
			    bus_size_t, bus_size_t, bus_size_t, int,
			    bus_addr_t *, bus_space_handle_t *);
	void		(*abs_free)(void *, bus_space_handle_t,
			    bus_size_t);

	/* get kernel virtual address */
	void *		(*abs_vaddr)(void *, bus_space_handle_t);

	/* barrier */
	void		(*abs_barrier)(void *, bus_space_handle_t,
			    bus_size_t, bus_size_t, int);

	/* read (single) */
	u_int8_t	(*abs_r_1)(void *, bus_space_handle_t,
			    bus_size_t);
	u_int16_t	(*abs_r_2)(void *, bus_space_handle_t,
			    bus_size_t);
	u_int32_t	(*abs_r_4)(void *, bus_space_handle_t,
			    bus_size_t);
	u_int64_t	(*abs_r_8)(void *, bus_space_handle_t,
			    bus_size_t);

	/* read multiple */
	void		(*abs_rm_1)(void *, bus_space_handle_t,
			    bus_size_t, u_int8_t *, bus_size_t);
	void		(*abs_rm_2)(void *, bus_space_handle_t,
			    bus_size_t, u_int16_t *, bus_size_t);
	void		(*abs_rm_4)(void *, bus_space_handle_t,
			    bus_size_t, u_int32_t *, bus_size_t);
	void		(*abs_rm_8)(void *, bus_space_handle_t,
			    bus_size_t, u_int64_t *, bus_size_t);
					
	/* read region */
	void		(*abs_rr_1)(void *, bus_space_handle_t,
			    bus_size_t, u_int8_t *, bus_size_t);
	void		(*abs_rr_2)(void *, bus_space_handle_t,
			    bus_size_t, u_int16_t *, bus_size_t);
	void		(*abs_rr_4)(void *, bus_space_handle_t,
			    bus_size_t, u_int32_t *, bus_size_t);
	void		(*abs_rr_8)(void *, bus_space_handle_t,
			    bus_size_t, u_int64_t *, bus_size_t);
					
	/* write (single) */
	void		(*abs_w_1)(void *, bus_space_handle_t,
			    bus_size_t, u_int8_t);
	void		(*abs_w_2)(void *, bus_space_handle_t,
			    bus_size_t, u_int16_t);
	void		(*abs_w_4)(void *, bus_space_handle_t,
			    bus_size_t, u_int32_t);
	void		(*abs_w_8)(void *, bus_space_handle_t,
			    bus_size_t, u_int64_t);

	/* write multiple */
	void		(*abs_wm_1)(void *, bus_space_handle_t,
			    bus_size_t, const u_int8_t *, bus_size_t);
	void		(*abs_wm_2)(void *, bus_space_handle_t,
			    bus_size_t, const u_int16_t *, bus_size_t);
	void		(*abs_wm_4)(void *, bus_space_handle_t,
			    bus_size_t, const u_int32_t *, bus_size_t);
	void		(*abs_wm_8)(void *, bus_space_handle_t,
			    bus_size_t, const u_int64_t *, bus_size_t);
					
	/* write region */
	void		(*abs_wr_1)(void *, bus_space_handle_t,
			    bus_size_t, const u_int8_t *, bus_size_t);
	void		(*abs_wr_2)(void *, bus_space_handle_t,
			    bus_size_t, const u_int16_t *, bus_size_t);
	void		(*abs_wr_4)(void *, bus_space_handle_t,
			    bus_size_t, const u_int32_t *, bus_size_t);
	void		(*abs_wr_8)(void *, bus_space_handle_t,
			    bus_size_t, const u_int64_t *, bus_size_t);

	/* set multiple */
	void		(*abs_sm_1)(void *, bus_space_handle_t,
			    bus_size_t, u_int8_t, bus_size_t);
	void		(*abs_sm_2)(void *, bus_space_handle_t,
			    bus_size_t, u_int16_t, bus_size_t);
	void		(*abs_sm_4)(void *, bus_space_handle_t,
			    bus_size_t, u_int32_t, bus_size_t);
	void		(*abs_sm_8)(void *, bus_space_handle_t,
			    bus_size_t, u_int64_t, bus_size_t);

	/* set region */
	void		(*abs_sr_1)(void *, bus_space_handle_t,
			    bus_size_t, u_int8_t, bus_size_t);
	void		(*abs_sr_2)(void *, bus_space_handle_t,
			    bus_size_t, u_int16_t, bus_size_t);
	void		(*abs_sr_4)(void *, bus_space_handle_t,
			    bus_size_t, u_int32_t, bus_size_t);
	void		(*abs_sr_8)(void *, bus_space_handle_t,
			    bus_size_t, u_int64_t, bus_size_t);

	/* copy */
	void		(*abs_c_1)(void *, bus_space_handle_t, bus_size_t,
			    bus_space_handle_t, bus_size_t, bus_size_t);
	void		(*abs_c_2)(void *, bus_space_handle_t, bus_size_t,
			    bus_space_handle_t, bus_size_t, bus_size_t);
	void		(*abs_c_4)(void *, bus_space_handle_t, bus_size_t,
			    bus_space_handle_t, bus_size_t, bus_size_t);
	void		(*abs_c_8)(void *, bus_space_handle_t, bus_size_t,
			    bus_space_handle_t, bus_size_t, bus_size_t);

	/* OpenBSD extensions follows */

	/* read multiple raw */
	void		(*abs_rrm_2)(void *, bus_space_handle_t,
			    bus_size_t, u_int8_t *, bus_size_t);
	void		(*abs_rrm_4)(void *, bus_space_handle_t,
			    bus_size_t, u_int8_t *, bus_size_t);
	void		(*abs_rrm_8)(void *, bus_space_handle_t,
			    bus_size_t, u_int8_t *, bus_size_t);

	/* write multiple raw */
	void		(*abs_wrm_2)(void *, bus_space_handle_t,
			    bus_size_t, const u_int8_t *, bus_size_t);
	void		(*abs_wrm_4)(void *, bus_space_handle_t,
			    bus_size_t, const u_int8_t *, bus_size_t);
	void		(*abs_wrm_8)(void *, bus_space_handle_t,
			    bus_size_t, const u_int8_t *, bus_size_t);
};


/*
 * Utility macros; INTERNAL USE ONLY.
 */
#define	__abs_c(a,b)		__CONCAT(a,b)
#define	__abs_opname(op,size)	__abs_c(__abs_c(__abs_c(abs_,op),_),size)

#define	__abs_rs(sz, t, h, o)						\
	(*(t)->__abs_opname(r,sz))((t)->abs_cookie, h, o)
#define	__abs_ws(sz, t, h, o, v)					\
	(*(t)->__abs_opname(w,sz))((t)->abs_cookie, h, o, v)
#define	__abs_nonsingle(type, sz, t, h, o, a, c)			\
	(*(t)->__abs_opname(type,sz))((t)->abs_cookie, h, o, a, c)
#ifndef DEBUG
#define	__abs_aligned_nonsingle(type, sz, t, h, o, a, c)		\
	__abs_nonsingle(type, sz, (t), (h), (o), (a), (c))

#else
#define	__abs_aligned_nonsingle(type, sz, t, h, o, a, c)		\
    do {								\
	if (((unsigned long)a & (sz - 1)) != 0)				\
		panic("bus non-single %d-byte unaligned (to %p) at %s:%d", \
		    sz, a, __FILE__, __LINE__);				\
	(*(t)->__abs_opname(type,sz))((t)->abs_cookie, h, o, a, c);	\
    } while (0)
#endif
#define	__abs_set(type, sz, t, h, o, v, c)				\
	(*(t)->__abs_opname(type,sz))((t)->abs_cookie, h, o, v, c)
#define	__abs_copy(sz, t, h1, o1, h2, o2, cnt)			\
	(*(t)->__abs_opname(c,sz))((t)->abs_cookie, h1, o1, h2, o2, cnt)

/*
 * Mapping and unmapping operations.
 */
#define	bus_space_map(t, a, s, c, hp)					\
	(*(t)->abs_map)((t)->abs_cookie, (a), (s), (c), (hp))
#define alpha_bus_space_map_noacct bus_space_map
#define	bus_space_unmap(t, h, s)					\
	(*(t)->abs_unmap)((t)->abs_cookie, (h), (s))
#define alpha_bus_space_unmap_noacct bus_space_unmap
#define	bus_space_subregion(t, h, o, s, hp)				\
	(*(t)->abs_subregion)((t)->abs_cookie, (h), (o), (s), (hp))

#define	BUS_SPACE_MAP_CACHEABLE		0x01
#define	BUS_SPACE_MAP_LINEAR		0x02
#define	BUS_SPACE_MAP_PREFETCHABLE	0x04

/*
 * Allocation and deallocation operations.
 */
#define	bus_space_alloc(t, rs, re, s, a, b, c, ap, hp)			\
	(*(t)->abs_alloc)((t)->abs_cookie, (rs), (re), (s), (a), (b),	\
	    (c), (ap), (hp))
#define	bus_space_free(t, h, s)						\
	(*(t)->abs_free)((t)->abs_cookie, (h), (s))

/*
 * Get kernel virtual address for ranges mapped BUS_SPACE_MAP_LINEAR.
 */
#define bus_space_vaddr(t, h)						\
	(*(t)->abs_vaddr)((t)->abs_cookie, (h))

/*
 * Bus barrier operations.
 */
#define	bus_space_barrier(t, h, o, l, f)				\
	(*(t)->abs_barrier)((t)->abs_cookie, (h), (o), (l), (f))

#define BUS_SPACE_BARRIER_READ	0x01
#define BUS_SPACE_BARRIER_WRITE	0x02


/*
 * Bus read (single) operations.
 */
#define	bus_space_read_1(t, h, o)	__abs_rs(1,(t),(h),(o))
#define	bus_space_read_2(t, h, o)	__abs_rs(2,(t),(h),(o))
#define	bus_space_read_4(t, h, o)	__abs_rs(4,(t),(h),(o))
#define	bus_space_read_8(t, h, o)	__abs_rs(8,(t),(h),(o))


/*
 * Bus read (single) operations.
 */
#define	bus_space_read_raw_1(t, h, o)	__abs_rs(1,(t),(h),(o))
#define	bus_space_read_raw_2(t, h, o)	__abs_rs(2,(t),(h),(o))
#define	bus_space_read_raw_4(t, h, o)	__abs_rs(4,(t),(h),(o))
#define	bus_space_read_raw_8(t, h, o)	__abs_rs(8,(t),(h),(o))


/*
 * Bus read multiple operations.
 */
#define	bus_space_read_multi_1(t, h, o, a, c)				\
	__abs_nonsingle(rm,1,(t),(h),(o),(a),(c))
#define	bus_space_read_multi_2(t, h, o, a, c)				\
	__abs_aligned_nonsingle(rm,2,(t),(h),(o),(a),(c))
#define	bus_space_read_multi_4(t, h, o, a, c)				\
	__abs_aligned_nonsingle(rm,4,(t),(h),(o),(a),(c))
#define	bus_space_read_multi_8(t, h, o, a, c)				\
	__abs_aligned_nonsingle(rm,8,(t),(h),(o),(a),(c))


/*
 *	void bus_space_read_raw_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_int8_t *addr, size_t count);
 *
 * Read `count' bytes in 2, 4 or 8 byte wide quantities from bus space
 * described by tag/handle/offset and copy into buffer provided.  The buffer
 * must have proper alignment for the N byte wide entities.  Furthermore
 * possible byte-swapping should be done by these functions.
 */

#define	bus_space_read_raw_multi_2(t, h, o, a, c)			\
	__abs_nonsingle(rrm,2,(t),(h),(o),(a),(c))
#define	bus_space_read_raw_multi_4(t, h, o, a, c)			\
	__abs_nonsingle(rrm,4,(t),(h),(o),(a),(c))
#define	bus_space_read_raw_multi_8(t, h, o, a, c)			\
	__abs_nonsingle(rrm,8,(t),(h),(o),(a),(c))

/*
 * Bus read region operations.
 */
#define	bus_space_read_region_1(t, h, o, a, c)				\
	__abs_nonsingle(rr,1,(t),(h),(o),(a),(c))
#define	bus_space_read_region_2(t, h, o, a, c)				\
	__abs_aligned_nonsingle(rr,2,(t),(h),(o),(a),(c))
#define	bus_space_read_region_4(t, h, o, a, c)				\
	__abs_aligned_nonsingle(rr,4,(t),(h),(o),(a),(c))
#define	bus_space_read_region_8(t, h, o, a, c)				\
	__abs_aligned_nonsingle(rr,8,(t),(h),(o),(a),(c))


/*
 *	void bus_space_read_raw_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_int8_t *addr, size_t count);
 *
 * Read `count' bytes in 2, 4 or 8 byte wide quantities from bus space
 * described by tag/handle and starting at `offset' from the
 * buffer provided.  The buffer must have proper alignment for the N byte
 * wide entities.  Furthermore possible byte-swapping should be done by
 * these functions.
 */

#define bus_space_read_raw_region_2(t, h, o, a, c)			\
    bus_space_read_region_2((t), (h), (o), (u_int16_t *)(a), (c) >> 1)
#define bus_space_read_raw_region_4(t, h, o, a, c)			\
    bus_space_read_region_4((t), (h), (o), (u_int32_t *)(a), (c) >> 2)

/*
 * Bus write (single) operations.
 */
#define	bus_space_write_1(t, h, o, v)	__abs_ws(1,(t),(h),(o),(v))
#define	bus_space_write_2(t, h, o, v)	__abs_ws(2,(t),(h),(o),(v))
#define	bus_space_write_4(t, h, o, v)	__abs_ws(4,(t),(h),(o),(v))
#define	bus_space_write_8(t, h, o, v)	__abs_ws(8,(t),(h),(o),(v))


/*
 * Bus write raw (single) operations.
 */
#define	bus_space_write_raw_1(t, h, o, v)	__abs_ws(1,(t),(h),(o),(v))
#define	bus_space_write_raw_2(t, h, o, v)	__abs_ws(2,(t),(h),(o),(v))
#define	bus_space_write_raw_4(t, h, o, v)	__abs_ws(4,(t),(h),(o),(v))
#define	bus_space_write_raw_8(t, h, o, v)	__abs_ws(8,(t),(h),(o),(v))


/*
 * Bus write multiple operations.
 */
#define	bus_space_write_multi_1(t, h, o, a, c)				\
	__abs_nonsingle(wm,1,(t),(h),(o),(a),(c))
#define	bus_space_write_multi_2(t, h, o, a, c)				\
	__abs_aligned_nonsingle(wm,2,(t),(h),(o),(a),(c))
#define	bus_space_write_multi_4(t, h, o, a, c)				\
	__abs_aligned_nonsingle(wm,4,(t),(h),(o),(a),(c))
#define	bus_space_write_multi_8(t, h, o, a, c)				\
	__abs_aligned_nonsingle(wm,8,(t),(h),(o),(a),(c))

/*
 *	void bus_space_write_raw_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_int8_t *addr, size_t count);
 *
 * Write `count' bytes in 2, 4 or 8 byte wide quantities from the buffer
 * provided to bus space described by tag/handle/offset.  The buffer
 * must have proper alignment for the N byte wide entities.  Furthermore
 * possible byte-swapping should be done by these functions.
 */

#define	bus_space_write_raw_multi_2(t, h, o, a, c)			\
	__abs_nonsingle(wrm,2,(t),(h),(o),(a),(c))
#define	bus_space_write_raw_multi_4(t, h, o, a, c)			\
	__abs_nonsingle(wrm,4,(t),(h),(o),(a),(c))
#define	bus_space_write_raw_multi_8(t, h, o, a, c)			\
	__abs_nonsingle(wrm,8,(t),(h),(o),(a),(c))

/*
 * Bus write region operations.
 */
#define	bus_space_write_region_1(t, h, o, a, c)				\
	__abs_nonsingle(wr,1,(t),(h),(o),(a),(c))
#define	bus_space_write_region_2(t, h, o, a, c)				\
	__abs_aligned_nonsingle(wr,2,(t),(h),(o),(a),(c))
#define	bus_space_write_region_4(t, h, o, a, c)				\
	__abs_aligned_nonsingle(wr,4,(t),(h),(o),(a),(c))
#define	bus_space_write_region_8(t, h, o, a, c)				\
	__abs_aligned_nonsingle(wr,8,(t),(h),(o),(a),(c))


/*
 *	void bus_space_write_raw_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_int8_t *addr, size_t count);
 *
 * Write `count' bytes in 2, 4 or 8 byte wide quantities to bus space
 * described by tag/handle and starting at `offset' from the
 * buffer provided.  The buffer must have proper alignment for the N byte
 * wide entities.  Furthermore possible byte-swapping should be done by
 * these functions.
 */

#define bus_space_write_raw_region_2(t, h, o, a, c)			\
    bus_space_write_region_2((t), (h), (o), (const u_int16_t *)(a), (c) >> 1)
#define bus_space_write_raw_region_4(t, h, o, a, c)			\
    bus_space_write_region_4((t), (h), (o), (const u_int32_t *)(a), (c) >> 2)

/*
 * Set multiple operations.
 */
#define	bus_space_set_multi_1(t, h, o, v, c)				\
	__abs_set(sm,1,(t),(h),(o),(v),(c))
#define	bus_space_set_multi_2(t, h, o, v, c)				\
	__abs_set(sm,2,(t),(h),(o),(v),(c))
#define	bus_space_set_multi_4(t, h, o, v, c)				\
	__abs_set(sm,4,(t),(h),(o),(v),(c))
#define	bus_space_set_multi_8(t, h, o, v, c)				\
	__abs_set(sm,8,(t),(h),(o),(v),(c))


/*
 * Set region operations.
 */
#define	bus_space_set_region_1(t, h, o, v, c)				\
	__abs_set(sr,1,(t),(h),(o),(v),(c))
#define	bus_space_set_region_2(t, h, o, v, c)				\
	__abs_set(sr,2,(t),(h),(o),(v),(c))
#define	bus_space_set_region_4(t, h, o, v, c)				\
	__abs_set(sr,4,(t),(h),(o),(v),(c))
#define	bus_space_set_region_8(t, h, o, v, c)				\
	__abs_set(sr,8,(t),(h),(o),(v),(c))


/*
 * Copy operations.
 */
#define	bus_space_copy_1(t, h1, o1, h2, o2, c)				\
	__abs_copy(1, t, h1, o1, h2, o2, c)
#define	bus_space_copy_2(t, h1, o1, h2, o2, c)				\
	__abs_copy(2, t, h1, o1, h2, o2, c)
#define	bus_space_copy_4(t, h1, o1, h2, o2, c)				\
	__abs_copy(4, t, h1, o1, h2, o2, c)
#define	bus_space_copy_8(t, h1, o1, h2, o2, c)				\
	__abs_copy(8, t, h1, o1, h2, o2, c)

/*
 * Bus DMA methods.
 */

/*
 * Flags used in various bus DMA methods.
 */
#define	BUS_DMA_WAITOK		0x0000	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x0001	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x0002	/* perform resource allocation now */
#define	BUS_DMA_COHERENT	0x0004	/* hint: map memory DMA coherent */
#define	BUS_DMA_BUS1		0x0010	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x0020
#define	BUS_DMA_BUS3		0x0040
#define	BUS_DMA_24BIT		0x0080	/* isadma map */
#define	BUS_DMA_STREAMING	0x0100	/* hint: sequential, unidirectional */
#define	BUS_DMA_READ		0x0200	/* mapping is device -> memory only */
#define	BUS_DMA_WRITE		0x0400	/* mapping is memory -> device only */
#define	BUS_DMA_ZERO		0x1000	/* zero memory in dmamem_alloc */

/*
 * Private flags stored in the DMA map.
 */
#define	DMAMAP_NO_COALESCE	0x40000000	/* don't coalesce adjacent
						   segments */

/* Forwards needed by prototypes below. */
struct mbuf;
struct uio;
struct alpha_sgmap;

/*
 * Operations performed by bus_dmamap_sync().
 */
#define BUS_DMASYNC_PREREAD	0x01
#define BUS_DMASYNC_POSTREAD	0x02
#define BUS_DMASYNC_PREWRITE	0x04
#define BUS_DMASYNC_POSTWRITE	0x08

/*
 *	alpha_bus_t
 *
 *	Busses supported by NetBSD/alpha, used by internal
 *	utility functions.  NOT TO BE USED BY MACHINE-INDEPENDENT
 *	CODE!
 */
typedef enum {
	ALPHA_BUS_TURBOCHANNEL,
	ALPHA_BUS_PCI,
	ALPHA_BUS_EISA,
	ALPHA_BUS_ISA,
	ALPHA_BUS_TLSB,
} alpha_bus_t;

typedef struct alpha_bus_dma_tag	*bus_dma_tag_t;
typedef struct alpha_bus_dmamap		*bus_dmamap_t;

/*
 *	bus_dma_segment_t
 *
 *	Describes a single contiguous DMA transaction.  Values
 *	are suitable for programming into DMA registers.
 */
struct alpha_bus_dma_segment {
	bus_addr_t	ds_addr;	/* DMA address */
	bus_size_t	ds_len;		/* length of transfer */
};
typedef struct alpha_bus_dma_segment	bus_dma_segment_t;

/*
 *	bus_dma_tag_t
 *
 *	A machine-dependent opaque type describing the implementation of
 *	DMA for a given bus.
 */
struct alpha_bus_dma_tag {
	void	*_cookie;		/* cookie used in the guts */
	bus_addr_t _wbase;		/* DMA window base */

	/*
	 * The following two members are used to chain DMA windows
	 * together.  If, during the course of a map load, the
	 * resulting physical memory address is too large to
	 * be addressed by the window, the next window will be
	 * attempted.  These would be chained together like so:
	 *
	 *	direct -> sgmap -> NULL
	 *  or
	 *	sgmap -> NULL
	 *  or
	 *	direct -> NULL
	 *
	 * If the window size is 0, it will not be checked (e.g.
	 * TurboChannel DMA).
	 */
	bus_size_t _wsize;
	struct alpha_bus_dma_tag *_next_window;

	/*
	 * Some chipsets have a built-in boundary constraint, independent
	 * of what the device requests.  This allows that boundary to
	 * be specified.  If the device has a more restrictive constraint,
	 * the map will use that, otherwise this boundary will be used.
	 * This value is ignored if 0.
	 */
	bus_size_t _boundary;

	/*
	 * A chipset may have more than one SGMAP window, so SGMAP
	 * windows also get a pointer to their SGMAP state.
	 */
	struct alpha_sgmap *_sgmap;

	/*
	 * Internal-use only utility methods.  NOT TO BE USED BY
	 * MACHINE-INDEPENDENT CODE!
	 */
	bus_dma_tag_t (*_get_tag)(bus_dma_tag_t, alpha_bus_t);

	/*
	 * DMA mapping methods.
	 */
	int	(*_dmamap_create)(bus_dma_tag_t, bus_size_t, int,
		    bus_size_t, bus_size_t, int, bus_dmamap_t *);
	void	(*_dmamap_destroy)(bus_dma_tag_t, bus_dmamap_t);
	int	(*_dmamap_load)(bus_dma_tag_t, bus_dmamap_t, void *,
		    bus_size_t, struct proc *, int);
	int	(*_dmamap_load_mbuf)(bus_dma_tag_t, bus_dmamap_t,
		    struct mbuf *, int);
	int	(*_dmamap_load_uio)(bus_dma_tag_t, bus_dmamap_t,
		    struct uio *, int);
	int	(*_dmamap_load_raw)(bus_dma_tag_t, bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int);
	void	(*_dmamap_unload)(bus_dma_tag_t, bus_dmamap_t);
	void	(*_dmamap_sync)(bus_dma_tag_t, bus_dmamap_t,
		    bus_addr_t, bus_size_t, int);

	/*
	 * DMA memory utility functions.
	 */
	int	(*_dmamem_alloc)(bus_dma_tag_t, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int);
	void	(*_dmamem_free)(bus_dma_tag_t,
		    bus_dma_segment_t *, int);
	int	(*_dmamem_map)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, size_t, caddr_t *, int);
	void	(*_dmamem_unmap)(bus_dma_tag_t, caddr_t, size_t);
	paddr_t	(*_dmamem_mmap)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, off_t, int, int);
};

#define	alphabus_dma_get_tag(t, b)				\
	(*(t)->_get_tag)(t, b)

#define	bus_dmamap_create(t, s, n, m, b, f, p)			\
	(*(t)->_dmamap_create)((t), (s), (n), (m), (b), (f), (p))
#define	bus_dmamap_destroy(t, p)				\
	(*(t)->_dmamap_destroy)((t), (p))
#define	bus_dmamap_load(t, m, b, s, p, f)			\
	(*(t)->_dmamap_load)((t), (m), (b), (s), (p), (f))
#define	bus_dmamap_load_mbuf(t, m, b, f)			\
	(*(t)->_dmamap_load_mbuf)((t), (m), (b), (f))
#define	bus_dmamap_load_uio(t, m, u, f)				\
	(*(t)->_dmamap_load_uio)((t), (m), (u), (f))
#define	bus_dmamap_load_raw(t, m, sg, n, s, f)			\
	(*(t)->_dmamap_load_raw)((t), (m), (sg), (n), (s), (f))
#define	bus_dmamap_unload(t, p)					\
	(void)(t),						\
	(*(p)->_dm_window->_dmamap_unload)((p)->_dm_window, (p))
#define	bus_dmamap_sync(t, p, a, s, op)				\
	(void)(t), 						\
	(*(p)->_dm_window->_dmamap_sync)((p)->_dm_window, (p), (a), (s), (op))
#define	bus_dmamem_alloc(t, s, a, b, sg, n, r, f)		\
	(*(t)->_dmamem_alloc)((t), (s), (a), (b), (sg), (n), (r), (f))
#define	bus_dmamem_free(t, sg, n)				\
	(*(t)->_dmamem_free)((t), (sg), (n))
#define	bus_dmamem_map(t, sg, n, s, k, f)			\
	(*(t)->_dmamem_map)((t), (sg), (n), (s), (k), (f))
#define	bus_dmamem_unmap(t, k, s)				\
	(*(t)->_dmamem_unmap)((t), (k), (s))
#define	bus_dmamem_mmap(t, sg, n, o, p, f)			\
	(*(t)->_dmamem_mmap)((t), (sg), (n), (o), (p), (f))

/*
 *	bus_dmamap_t
 *
 *	Describes a DMA mapping.
 */
struct alpha_bus_dmamap {
	/*
	 * PRIVATE MEMBERS: not for use by machine-independent code.
	 */
	bus_size_t	_dm_size;	/* largest DMA transfer mappable */
	int		_dm_segcnt;	/* number of segs this map can map */
	bus_size_t	_dm_maxsegsz;	/* largest possible segment */
	bus_size_t	_dm_boundary;	/* don't cross this */
	int		_dm_flags;	/* misc. flags */

	/*
	 * Private cookie to be used by the DMA back-end.
	 */
	void		*_dm_cookie;

	/*
	 * The DMA window that we ended up being mapped in.
	 */
	bus_dma_tag_t	_dm_window;

	/*
	 * PUBLIC MEMBERS: these are used by machine-independent code.
	 */
	bus_size_t	dm_mapsize;	/* size of the mapping */
	int		dm_nsegs;	/* # valid segments in mapping */
	bus_dma_segment_t dm_segs[1];	/* segments; variable length */
};

#ifdef _ALPHA_BUS_DMA_PRIVATE
int	_bus_dmamap_create(bus_dma_tag_t, bus_size_t, int, bus_size_t,
	    bus_size_t, int, bus_dmamap_t *);
void	_bus_dmamap_destroy(bus_dma_tag_t, bus_dmamap_t);

int	_bus_dmamap_load_direct(bus_dma_tag_t, bus_dmamap_t,
	    void *, bus_size_t, struct proc *, int);
int	_bus_dmamap_load_mbuf_direct(bus_dma_tag_t,
	    bus_dmamap_t, struct mbuf *, int);
int	_bus_dmamap_load_uio_direct(bus_dma_tag_t,
	    bus_dmamap_t, struct uio *, int);
int	_bus_dmamap_load_raw_direct(bus_dma_tag_t,
	    bus_dmamap_t, bus_dma_segment_t *, int, bus_size_t, int);

void	_bus_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
void	_bus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
	    bus_size_t, int);

int	_bus_dmamem_alloc(bus_dma_tag_t tag, bus_size_t size,
	    bus_size_t alignment, bus_size_t boundary,
	    bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags);
int	_bus_dmamem_alloc_range(bus_dma_tag_t tag, bus_size_t size,
	    bus_size_t alignment, bus_size_t boundary,
	    bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags,
	    paddr_t low, paddr_t high);
void	_bus_dmamem_free(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs);
int	_bus_dmamem_map(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, size_t size, caddr_t *kvap, int flags);
void	_bus_dmamem_unmap(bus_dma_tag_t tag, caddr_t kva,
	    size_t size);
paddr_t	_bus_dmamem_mmap(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, off_t off, int prot, int flags);
#endif /* _ALPHA_BUS_DMA_PRIVATE */

#endif /* _MACHINE_BUS_H_ */
@


1.29
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.28 2009/12/25 20:52:32 miod Exp $	*/
d263 9
d339 9
@


1.28
log
@Add bus_space_vaddr() when applicable; from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.27 2009/07/30 21:39:15 miod Exp $	*/
d31 2
a32 2
#ifndef _ALPHA_BUS_H_
#define	_ALPHA_BUS_H_
d681 1
a681 1
#endif /* _ALPHA_BUS_H_ */
@


1.27
log
@Get rid of the obsolet BUS_BARRIER_xxx constants for bus_space_barrier(), only
provide and use BUS_SPACE_BARRIER_xxx.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.26 2009/04/20 00:42:05 oga Exp $	*/
d65 3
d237 5
@


1.26
log
@Add a BUS_DMA_ZERO flag for bus_dmamem_alloc() to return zeroed memory.

Saves every damned driver calling bzero(), and continues the M_ZERO,
PR_ZERO symmetry.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.25 2009/02/01 14:33:58 miod Exp $	*/
d241 2
a242 4
#define	BUS_BARRIER_READ	0x01
#define	BUS_BARRIER_WRITE	0x02
#define BUS_SPACE_BARRIER_READ	BUS_BARRIER_READ
#define BUS_SPACE_BARRIER_WRITE	BUS_BARRIER_WRITE
@


1.25
log
@Remove unused _pfthresh member from struct alpha_bus_dma_tag.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.24 2006/05/12 20:48:19 brad Exp $	*/
d431 12
a442 11
#define	BUS_DMA_WAITOK		0x000	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x001	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x002	/* perform resource allocation now */
#define	BUS_DMA_COHERENT	0x004	/* hint: map memory DMA coherent */
#define	BUS_DMA_BUS1		0x010	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x020
#define	BUS_DMA_BUS3		0x040
#define	BUS_DMA_24BIT		0x080	/* isadma map */
#define	BUS_DMA_STREAMING	0x100	/* hint: sequential, unidirectional */
#define	BUS_DMA_READ		0x200	/* mapping is device -> memory only */
#define	BUS_DMA_WRITE		0x400	/* mapping is memory -> device only */
@


1.24
log
@Keep track of which DMA window was actually used to map the
request (not always the passed in DMA tag if we try direct-map
and then fall back to sgmap-mapped).  Use the actual window
when performing dmamap_sync and dmamap_unload operations.

From NetBSD

ok martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.23 2006/04/27 15:17:07 mickey Exp $	*/
d221 3
a534 10

	/*
	 * The SGMAP MMU implements a prefetch FIFO to keep data
	 * moving down the pipe, when doing host->bus DMA writes.
	 * The threshold (distance until the next page) used to
	 * trigger the prefetch is differnet on different chipsets,
	 * and we need to know what it is in order to know whether
	 * or not to allocate a spill page.
	 */
	bus_size_t _pfthresh;
@


1.23
log
@from PAE work:
add a BUS_DMA_24BIT flag to signify that dmamap being created
is for the isadma use (thus already backed up by the bounce
buffers). later also to be used for dmamem allocation.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.22 2006/04/04 21:20:40 brad Exp $	*/
d597 2
a598 1
	(*(t)->_dmamap_unload)((t), (p))
d600 2
a601 1
	(*(t)->_dmamap_sync)((t), (p), (a), (s), (op))
d632 5
@


1.22
log
@Add a `prefetch threshold' member to the bus_dma_tag_t, so that
eventually we can determine whether or not to allocate a spill
page on a per-mapping basis.

From NetBSD

ok martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.21 2006/04/04 21:18:43 brad Exp $	*/
d435 1
a435 1
#define	BUS_DMA_BUS4		0x080
@


1.21
log
@clean up after Theo's "support mbuf handling in alpha sgmap dma maps" commit.

ok martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.20 2005/05/25 18:29:58 jason Exp $	*/
d532 10
@


1.20
log
@comment typo
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.19 2003/10/18 20:14:41 jmc Exp $	*/
a444 1
#define	DMAMAP_HAS_SGMAP	0x80000000	/* sgva/len are valid */
a614 9

	/*
	 * This is used only for SGMAP-mapped DMA, but we keep it
	 * here to avoid pointless indirection.
	 */
	int		_dm_pteidx;	/* PTE index */
	int		_dm_ptecnt;	/* PTE count */
	u_long		_dm_sgva;	/* allocated sgva */
	bus_size_t	_dm_sgvalen;	/* svga length */
@


1.19
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.18 2002/06/30 16:11:25 miod Exp $	*/
d609 1
a609 1
	 * PRIVATE MEMBERS: not for use my machine-independent code.
@


1.18
log
@Dummy bus_space_read_raw_region implementation.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.17 2002/03/14 01:26:27 millert Exp $	*/
d522 1
a522 1
	 * be specified.  If the device has a more restrictive contraint,
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.16 2002/03/07 18:08:08 jason Exp $	*/
d296 17
@


1.16
log
@Clean up BUS_DMA_* flags, and make sure all arch's define:
BUS_DMA_READ, BUS_DMA_WRITE, and BUS_DMA_STREAMING
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.15 2001/11/05 17:25:57 art Exp $	*/
d350 1
a350 1
 *	void bus_space_write_raw_region_N __P((bus_space_tag_t tag,
d352 1
a352 1
 *	    const u_int8_t *addr, size_t count));
@


1.15
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.14 2001/10/26 01:28:06 nate Exp $	*/
d411 11
a421 8
#define	BUS_DMA_WAITOK		0x00	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x01	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x02	/* perform resource allocation now */
#define	BUS_DMA_COHERENT	0x04	/* hint: map memory DMA coherent */
#define	BUS_DMA_BUS1		0x10	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x20
#define	BUS_DMA_BUS3		0x40
#define	BUS_DMA_BUS4		0x80
@


1.15.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.15 2001/11/05 17:25:57 art Exp $	*/
d350 1
a350 1
 *	void bus_space_write_raw_region_N(bus_space_tag_t tag,
d352 1
a352 1
 *	    const u_int8_t *addr, size_t count);
d411 8
a418 11
#define	BUS_DMA_WAITOK		0x000	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x001	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x002	/* perform resource allocation now */
#define	BUS_DMA_COHERENT	0x004	/* hint: map memory DMA coherent */
#define	BUS_DMA_BUS1		0x010	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x020
#define	BUS_DMA_BUS3		0x040
#define	BUS_DMA_BUS4		0x080
#define	BUS_DMA_STREAMING	0x100	/* hint: sequential, unidirectional */
#define	BUS_DMA_READ		0x200	/* mapping is device -> memory only */
#define	BUS_DMA_WRITE		0x400	/* mapping is memory -> device only */
@


1.15.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.15.2.1 2002/06/11 03:33:40 art Exp $	*/
a295 17

/*
 *	void bus_space_read_raw_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_int8_t *addr, size_t count);
 *
 * Read `count' bytes in 2, 4 or 8 byte wide quantities from bus space
 * described by tag/handle and starting at `offset' from the
 * buffer provided.  The buffer must have proper alignment for the N byte
 * wide entities.  Furthermore possible byte-swapping should be done by
 * these functions.
 */

#define bus_space_read_raw_region_2(t, h, o, a, c)			\
    bus_space_read_region_2((t), (h), (o), (u_int16_t *)(a), (c) >> 1)
#define bus_space_read_raw_region_4(t, h, o, a, c)			\
    bus_space_read_region_4((t), (h), (o), (u_int32_t *)(a), (c) >> 2)
@


1.14
log
@First cut at a port of isadma and floppy driver.  ok art@@
From NetBSD via jay@@rootaction.net
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.13 2001/01/15 12:03:42 art Exp $	*/
a432 2
 * bus_dmasync_op_t
 *
d435 4
a438 6
typedef enum {
	BUS_DMASYNC_PREREAD,
	BUS_DMASYNC_POSTREAD,
	BUS_DMASYNC_PREWRITE,
	BUS_DMASYNC_POSTWRITE,
} bus_dmasync_op_t;
d536 1
a536 1
		    bus_dmasync_op_t);
d569 2
a570 2
#define	bus_dmamap_sync(t, p, op)				\
	(*(t)->_dmamap_sync)((t), (p), (op))
d634 2
a635 1
void	_bus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_dmasync_op_t);
@


1.13
log
@'implement' bus_space_write_raw_region_{2,4}.
From d@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.12 2000/12/15 21:38:05 art Exp $	*/
d214 1
d217 1
@


1.12
log
@Define BUS_SPACE_BARRIER_{READ,WRITE} as synonmys for BUS_BARRIER_{READ,WRITE}
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.11 2000/11/08 16:01:10 art Exp $	*/
d346 17
@


1.11
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.10 1998/01/20 18:40:09 niklas Exp $	*/
d238 2
@


1.10
log
@Merge bus_dma support from NetBSD, mostly by Jason Thorpe.  Only i386 uses it
 so far, the other archs gets placeholders for now.  I wrote a compatibility
layer for OpenBSD's old isadma code so we can still use our old
driver sources.  They will however get changed to native bus_dma use,
on a case by case basis.   Oh yes, I almost forgot, I kept our notion
of isadma being a device so DMA-less ISA-busses still work
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.9 1997/06/05 23:21:30 deraadt Exp $	*/
d51 6
a56 6
	int		(*abs_map) __P((void *, bus_addr_t, bus_size_t,
			    int, bus_space_handle_t *));
	void		(*abs_unmap) __P((void *, bus_space_handle_t,
			    bus_size_t));
	int		(*abs_subregion) __P((void *, bus_space_handle_t,
			    bus_size_t, bus_size_t, bus_space_handle_t *));
d59 1
a59 1
	int		(*abs_alloc) __P((void *, bus_addr_t, bus_addr_t,
d61 3
a63 3
			    bus_addr_t *, bus_space_handle_t *));
	void		(*abs_free) __P((void *, bus_space_handle_t,
			    bus_size_t));
d66 2
a67 2
	void		(*abs_barrier) __P((void *, bus_space_handle_t,
			    bus_size_t, bus_size_t, int));
d70 8
a77 8
	u_int8_t	(*abs_r_1) __P((void *, bus_space_handle_t,
			    bus_size_t));
	u_int16_t	(*abs_r_2) __P((void *, bus_space_handle_t,
			    bus_size_t));
	u_int32_t	(*abs_r_4) __P((void *, bus_space_handle_t,
			    bus_size_t));
	u_int64_t	(*abs_r_8) __P((void *, bus_space_handle_t,
			    bus_size_t));
d80 8
a87 8
	void		(*abs_rm_1) __P((void *, bus_space_handle_t,
			    bus_size_t, u_int8_t *, bus_size_t));
	void		(*abs_rm_2) __P((void *, bus_space_handle_t,
			    bus_size_t, u_int16_t *, bus_size_t));
	void		(*abs_rm_4) __P((void *, bus_space_handle_t,
			    bus_size_t, u_int32_t *, bus_size_t));
	void		(*abs_rm_8) __P((void *, bus_space_handle_t,
			    bus_size_t, u_int64_t *, bus_size_t));
d90 8
a97 8
	void		(*abs_rr_1) __P((void *, bus_space_handle_t,
			    bus_size_t, u_int8_t *, bus_size_t));
	void		(*abs_rr_2) __P((void *, bus_space_handle_t,
			    bus_size_t, u_int16_t *, bus_size_t));
	void		(*abs_rr_4) __P((void *, bus_space_handle_t,
			    bus_size_t, u_int32_t *, bus_size_t));
	void		(*abs_rr_8) __P((void *, bus_space_handle_t,
			    bus_size_t, u_int64_t *, bus_size_t));
d100 8
a107 8
	void		(*abs_w_1) __P((void *, bus_space_handle_t,
			    bus_size_t, u_int8_t));
	void		(*abs_w_2) __P((void *, bus_space_handle_t,
			    bus_size_t, u_int16_t));
	void		(*abs_w_4) __P((void *, bus_space_handle_t,
			    bus_size_t, u_int32_t));
	void		(*abs_w_8) __P((void *, bus_space_handle_t,
			    bus_size_t, u_int64_t));
d110 8
a117 8
	void		(*abs_wm_1) __P((void *, bus_space_handle_t,
			    bus_size_t, const u_int8_t *, bus_size_t));
	void		(*abs_wm_2) __P((void *, bus_space_handle_t,
			    bus_size_t, const u_int16_t *, bus_size_t));
	void		(*abs_wm_4) __P((void *, bus_space_handle_t,
			    bus_size_t, const u_int32_t *, bus_size_t));
	void		(*abs_wm_8) __P((void *, bus_space_handle_t,
			    bus_size_t, const u_int64_t *, bus_size_t));
d120 8
a127 8
	void		(*abs_wr_1) __P((void *, bus_space_handle_t,
			    bus_size_t, const u_int8_t *, bus_size_t));
	void		(*abs_wr_2) __P((void *, bus_space_handle_t,
			    bus_size_t, const u_int16_t *, bus_size_t));
	void		(*abs_wr_4) __P((void *, bus_space_handle_t,
			    bus_size_t, const u_int32_t *, bus_size_t));
	void		(*abs_wr_8) __P((void *, bus_space_handle_t,
			    bus_size_t, const u_int64_t *, bus_size_t));
d130 8
a137 8
	void		(*abs_sm_1) __P((void *, bus_space_handle_t,
			    bus_size_t, u_int8_t, bus_size_t));
	void		(*abs_sm_2) __P((void *, bus_space_handle_t,
			    bus_size_t, u_int16_t, bus_size_t));
	void		(*abs_sm_4) __P((void *, bus_space_handle_t,
			    bus_size_t, u_int32_t, bus_size_t));
	void		(*abs_sm_8) __P((void *, bus_space_handle_t,
			    bus_size_t, u_int64_t, bus_size_t));
d140 8
a147 8
	void		(*abs_sr_1) __P((void *, bus_space_handle_t,
			    bus_size_t, u_int8_t, bus_size_t));
	void		(*abs_sr_2) __P((void *, bus_space_handle_t,
			    bus_size_t, u_int16_t, bus_size_t));
	void		(*abs_sr_4) __P((void *, bus_space_handle_t,
			    bus_size_t, u_int32_t, bus_size_t));
	void		(*abs_sr_8) __P((void *, bus_space_handle_t,
			    bus_size_t, u_int64_t, bus_size_t));
d150 8
a157 8
	void		(*abs_c_1) __P((void *, bus_space_handle_t, bus_size_t,
			    bus_space_handle_t, bus_size_t, bus_size_t));
	void		(*abs_c_2) __P((void *, bus_space_handle_t, bus_size_t,
			    bus_space_handle_t, bus_size_t, bus_size_t));
	void		(*abs_c_4) __P((void *, bus_space_handle_t, bus_size_t,
			    bus_space_handle_t, bus_size_t, bus_size_t));
	void		(*abs_c_8) __P((void *, bus_space_handle_t, bus_size_t,
			    bus_space_handle_t, bus_size_t, bus_size_t));
d162 6
a167 6
	void		(*abs_rrm_2) __P((void *, bus_space_handle_t,
			    bus_size_t, u_int8_t *, bus_size_t));
	void		(*abs_rrm_4) __P((void *, bus_space_handle_t,
			    bus_size_t, u_int8_t *, bus_size_t));
	void		(*abs_rrm_8) __P((void *, bus_space_handle_t,
			    bus_size_t, u_int8_t *, bus_size_t));
d170 6
a175 6
	void		(*abs_wrm_2) __P((void *, bus_space_handle_t,
			    bus_size_t, const u_int8_t *, bus_size_t));
	void		(*abs_wrm_4) __P((void *, bus_space_handle_t,
			    bus_size_t, const u_int8_t *, bus_size_t));
	void		(*abs_wrm_8) __P((void *, bus_space_handle_t,
			    bus_size_t, const u_int8_t *, bus_size_t));
d263 1
a263 1
 *	void bus_space_read_raw_multi_N __P((bus_space_tag_t tag,
d265 1
a265 1
 *	    u_int8_t *addr, size_t count));
d315 1
a315 1
 *	void bus_space_write_raw_multi_N __P((bus_space_tag_t tag,
d317 1
a317 1
 *	    u_int8_t *addr, size_t count));
d383 252
a634 3
/* XXX placeholders */
typedef void *bus_dma_tag_t;
typedef void *bus_dmamap_t;
@


1.10.10.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.13 2001/01/15 12:03:42 art Exp $	*/
d51 6
a56 6
	int		(*abs_map)(void *, bus_addr_t, bus_size_t,
			    int, bus_space_handle_t *);
	void		(*abs_unmap)(void *, bus_space_handle_t,
			    bus_size_t);
	int		(*abs_subregion)(void *, bus_space_handle_t,
			    bus_size_t, bus_size_t, bus_space_handle_t *);
d59 1
a59 1
	int		(*abs_alloc)(void *, bus_addr_t, bus_addr_t,
d61 3
a63 3
			    bus_addr_t *, bus_space_handle_t *);
	void		(*abs_free)(void *, bus_space_handle_t,
			    bus_size_t);
d66 2
a67 2
	void		(*abs_barrier)(void *, bus_space_handle_t,
			    bus_size_t, bus_size_t, int);
d70 8
a77 8
	u_int8_t	(*abs_r_1)(void *, bus_space_handle_t,
			    bus_size_t);
	u_int16_t	(*abs_r_2)(void *, bus_space_handle_t,
			    bus_size_t);
	u_int32_t	(*abs_r_4)(void *, bus_space_handle_t,
			    bus_size_t);
	u_int64_t	(*abs_r_8)(void *, bus_space_handle_t,
			    bus_size_t);
d80 8
a87 8
	void		(*abs_rm_1)(void *, bus_space_handle_t,
			    bus_size_t, u_int8_t *, bus_size_t);
	void		(*abs_rm_2)(void *, bus_space_handle_t,
			    bus_size_t, u_int16_t *, bus_size_t);
	void		(*abs_rm_4)(void *, bus_space_handle_t,
			    bus_size_t, u_int32_t *, bus_size_t);
	void		(*abs_rm_8)(void *, bus_space_handle_t,
			    bus_size_t, u_int64_t *, bus_size_t);
d90 8
a97 8
	void		(*abs_rr_1)(void *, bus_space_handle_t,
			    bus_size_t, u_int8_t *, bus_size_t);
	void		(*abs_rr_2)(void *, bus_space_handle_t,
			    bus_size_t, u_int16_t *, bus_size_t);
	void		(*abs_rr_4)(void *, bus_space_handle_t,
			    bus_size_t, u_int32_t *, bus_size_t);
	void		(*abs_rr_8)(void *, bus_space_handle_t,
			    bus_size_t, u_int64_t *, bus_size_t);
d100 8
a107 8
	void		(*abs_w_1)(void *, bus_space_handle_t,
			    bus_size_t, u_int8_t);
	void		(*abs_w_2)(void *, bus_space_handle_t,
			    bus_size_t, u_int16_t);
	void		(*abs_w_4)(void *, bus_space_handle_t,
			    bus_size_t, u_int32_t);
	void		(*abs_w_8)(void *, bus_space_handle_t,
			    bus_size_t, u_int64_t);
d110 8
a117 8
	void		(*abs_wm_1)(void *, bus_space_handle_t,
			    bus_size_t, const u_int8_t *, bus_size_t);
	void		(*abs_wm_2)(void *, bus_space_handle_t,
			    bus_size_t, const u_int16_t *, bus_size_t);
	void		(*abs_wm_4)(void *, bus_space_handle_t,
			    bus_size_t, const u_int32_t *, bus_size_t);
	void		(*abs_wm_8)(void *, bus_space_handle_t,
			    bus_size_t, const u_int64_t *, bus_size_t);
d120 8
a127 8
	void		(*abs_wr_1)(void *, bus_space_handle_t,
			    bus_size_t, const u_int8_t *, bus_size_t);
	void		(*abs_wr_2)(void *, bus_space_handle_t,
			    bus_size_t, const u_int16_t *, bus_size_t);
	void		(*abs_wr_4)(void *, bus_space_handle_t,
			    bus_size_t, const u_int32_t *, bus_size_t);
	void		(*abs_wr_8)(void *, bus_space_handle_t,
			    bus_size_t, const u_int64_t *, bus_size_t);
d130 8
a137 8
	void		(*abs_sm_1)(void *, bus_space_handle_t,
			    bus_size_t, u_int8_t, bus_size_t);
	void		(*abs_sm_2)(void *, bus_space_handle_t,
			    bus_size_t, u_int16_t, bus_size_t);
	void		(*abs_sm_4)(void *, bus_space_handle_t,
			    bus_size_t, u_int32_t, bus_size_t);
	void		(*abs_sm_8)(void *, bus_space_handle_t,
			    bus_size_t, u_int64_t, bus_size_t);
d140 8
a147 8
	void		(*abs_sr_1)(void *, bus_space_handle_t,
			    bus_size_t, u_int8_t, bus_size_t);
	void		(*abs_sr_2)(void *, bus_space_handle_t,
			    bus_size_t, u_int16_t, bus_size_t);
	void		(*abs_sr_4)(void *, bus_space_handle_t,
			    bus_size_t, u_int32_t, bus_size_t);
	void		(*abs_sr_8)(void *, bus_space_handle_t,
			    bus_size_t, u_int64_t, bus_size_t);
d150 8
a157 8
	void		(*abs_c_1)(void *, bus_space_handle_t, bus_size_t,
			    bus_space_handle_t, bus_size_t, bus_size_t);
	void		(*abs_c_2)(void *, bus_space_handle_t, bus_size_t,
			    bus_space_handle_t, bus_size_t, bus_size_t);
	void		(*abs_c_4)(void *, bus_space_handle_t, bus_size_t,
			    bus_space_handle_t, bus_size_t, bus_size_t);
	void		(*abs_c_8)(void *, bus_space_handle_t, bus_size_t,
			    bus_space_handle_t, bus_size_t, bus_size_t);
d162 6
a167 6
	void		(*abs_rrm_2)(void *, bus_space_handle_t,
			    bus_size_t, u_int8_t *, bus_size_t);
	void		(*abs_rrm_4)(void *, bus_space_handle_t,
			    bus_size_t, u_int8_t *, bus_size_t);
	void		(*abs_rrm_8)(void *, bus_space_handle_t,
			    bus_size_t, u_int8_t *, bus_size_t);
d170 6
a175 6
	void		(*abs_wrm_2)(void *, bus_space_handle_t,
			    bus_size_t, const u_int8_t *, bus_size_t);
	void		(*abs_wrm_4)(void *, bus_space_handle_t,
			    bus_size_t, const u_int8_t *, bus_size_t);
	void		(*abs_wrm_8)(void *, bus_space_handle_t,
			    bus_size_t, const u_int8_t *, bus_size_t);
a237 2
#define BUS_SPACE_BARRIER_READ	BUS_BARRIER_READ
#define BUS_SPACE_BARRIER_WRITE	BUS_BARRIER_WRITE
d263 1
a263 1
 *	void bus_space_read_raw_multi_N(bus_space_tag_t tag,
d265 1
a265 1
 *	    u_int8_t *addr, size_t count);
d315 1
a315 1
 *	void bus_space_write_raw_multi_N(bus_space_tag_t tag,
d317 1
a317 1
 *	    u_int8_t *addr, size_t count);
a345 17
 *	void bus_space_write_raw_region_N __P((bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_int8_t *addr, size_t count));
 *
 * Write `count' bytes in 2, 4 or 8 byte wide quantities to bus space
 * described by tag/handle and starting at `offset' from the
 * buffer provided.  The buffer must have proper alignment for the N byte
 * wide entities.  Furthermore possible byte-swapping should be done by
 * these functions.
 */

#define bus_space_write_raw_region_2(t, h, o, a, c)			\
    bus_space_write_region_2((t), (h), (o), (const u_int16_t *)(a), (c) >> 1)
#define bus_space_write_raw_region_4(t, h, o, a, c)			\
    bus_space_write_region_4((t), (h), (o), (const u_int32_t *)(a), (c) >> 2)

/*
d383 3
a385 252
/*
 * Bus DMA methods.
 */

/*
 * Flags used in various bus DMA methods.
 */
#define	BUS_DMA_WAITOK		0x00	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x01	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x02	/* perform resource allocation now */
#define	BUS_DMA_COHERENT	0x04	/* hint: map memory DMA coherent */
#define	BUS_DMA_BUS1		0x10	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x20
#define	BUS_DMA_BUS3		0x40
#define	BUS_DMA_BUS4		0x80

/*
 * Private flags stored in the DMA map.
 */
#define	DMAMAP_NO_COALESCE	0x40000000	/* don't coalesce adjacent
						   segments */
#define	DMAMAP_HAS_SGMAP	0x80000000	/* sgva/len are valid */

/* Forwards needed by prototypes below. */
struct mbuf;
struct uio;
struct alpha_sgmap;

/*
 * bus_dmasync_op_t
 *
 * Operations performed by bus_dmamap_sync().
 */
typedef enum {
	BUS_DMASYNC_PREREAD,
	BUS_DMASYNC_POSTREAD,
	BUS_DMASYNC_PREWRITE,
	BUS_DMASYNC_POSTWRITE,
} bus_dmasync_op_t;

/*
 *	alpha_bus_t
 *
 *	Busses supported by NetBSD/alpha, used by internal
 *	utility functions.  NOT TO BE USED BY MACHINE-INDEPENDENT
 *	CODE!
 */
typedef enum {
	ALPHA_BUS_TURBOCHANNEL,
	ALPHA_BUS_PCI,
	ALPHA_BUS_EISA,
	ALPHA_BUS_ISA,
	ALPHA_BUS_TLSB,
} alpha_bus_t;

typedef struct alpha_bus_dma_tag	*bus_dma_tag_t;
typedef struct alpha_bus_dmamap		*bus_dmamap_t;

/*
 *	bus_dma_segment_t
 *
 *	Describes a single contiguous DMA transaction.  Values
 *	are suitable for programming into DMA registers.
 */
struct alpha_bus_dma_segment {
	bus_addr_t	ds_addr;	/* DMA address */
	bus_size_t	ds_len;		/* length of transfer */
};
typedef struct alpha_bus_dma_segment	bus_dma_segment_t;

/*
 *	bus_dma_tag_t
 *
 *	A machine-dependent opaque type describing the implementation of
 *	DMA for a given bus.
 */
struct alpha_bus_dma_tag {
	void	*_cookie;		/* cookie used in the guts */
	bus_addr_t _wbase;		/* DMA window base */

	/*
	 * The following two members are used to chain DMA windows
	 * together.  If, during the course of a map load, the
	 * resulting physical memory address is too large to
	 * be addressed by the window, the next window will be
	 * attempted.  These would be chained together like so:
	 *
	 *	direct -> sgmap -> NULL
	 *  or
	 *	sgmap -> NULL
	 *  or
	 *	direct -> NULL
	 *
	 * If the window size is 0, it will not be checked (e.g.
	 * TurboChannel DMA).
	 */
	bus_size_t _wsize;
	struct alpha_bus_dma_tag *_next_window;

	/*
	 * Some chipsets have a built-in boundary constraint, independent
	 * of what the device requests.  This allows that boundary to
	 * be specified.  If the device has a more restrictive contraint,
	 * the map will use that, otherwise this boundary will be used.
	 * This value is ignored if 0.
	 */
	bus_size_t _boundary;

	/*
	 * A chipset may have more than one SGMAP window, so SGMAP
	 * windows also get a pointer to their SGMAP state.
	 */
	struct alpha_sgmap *_sgmap;

	/*
	 * Internal-use only utility methods.  NOT TO BE USED BY
	 * MACHINE-INDEPENDENT CODE!
	 */
	bus_dma_tag_t (*_get_tag)(bus_dma_tag_t, alpha_bus_t);

	/*
	 * DMA mapping methods.
	 */
	int	(*_dmamap_create)(bus_dma_tag_t, bus_size_t, int,
		    bus_size_t, bus_size_t, int, bus_dmamap_t *);
	void	(*_dmamap_destroy)(bus_dma_tag_t, bus_dmamap_t);
	int	(*_dmamap_load)(bus_dma_tag_t, bus_dmamap_t, void *,
		    bus_size_t, struct proc *, int);
	int	(*_dmamap_load_mbuf)(bus_dma_tag_t, bus_dmamap_t,
		    struct mbuf *, int);
	int	(*_dmamap_load_uio)(bus_dma_tag_t, bus_dmamap_t,
		    struct uio *, int);
	int	(*_dmamap_load_raw)(bus_dma_tag_t, bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int);
	void	(*_dmamap_unload)(bus_dma_tag_t, bus_dmamap_t);
	void	(*_dmamap_sync)(bus_dma_tag_t, bus_dmamap_t,
		    bus_dmasync_op_t);

	/*
	 * DMA memory utility functions.
	 */
	int	(*_dmamem_alloc)(bus_dma_tag_t, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int);
	void	(*_dmamem_free)(bus_dma_tag_t,
		    bus_dma_segment_t *, int);
	int	(*_dmamem_map)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, size_t, caddr_t *, int);
	void	(*_dmamem_unmap)(bus_dma_tag_t, caddr_t, size_t);
	paddr_t	(*_dmamem_mmap)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, off_t, int, int);
};

#define	alphabus_dma_get_tag(t, b)				\
	(*(t)->_get_tag)(t, b)

#define	bus_dmamap_create(t, s, n, m, b, f, p)			\
	(*(t)->_dmamap_create)((t), (s), (n), (m), (b), (f), (p))
#define	bus_dmamap_destroy(t, p)				\
	(*(t)->_dmamap_destroy)((t), (p))
#define	bus_dmamap_load(t, m, b, s, p, f)			\
	(*(t)->_dmamap_load)((t), (m), (b), (s), (p), (f))
#define	bus_dmamap_load_mbuf(t, m, b, f)			\
	(*(t)->_dmamap_load_mbuf)((t), (m), (b), (f))
#define	bus_dmamap_load_uio(t, m, u, f)				\
	(*(t)->_dmamap_load_uio)((t), (m), (u), (f))
#define	bus_dmamap_load_raw(t, m, sg, n, s, f)			\
	(*(t)->_dmamap_load_raw)((t), (m), (sg), (n), (s), (f))
#define	bus_dmamap_unload(t, p)					\
	(*(t)->_dmamap_unload)((t), (p))
#define	bus_dmamap_sync(t, p, op)				\
	(*(t)->_dmamap_sync)((t), (p), (op))
#define	bus_dmamem_alloc(t, s, a, b, sg, n, r, f)		\
	(*(t)->_dmamem_alloc)((t), (s), (a), (b), (sg), (n), (r), (f))
#define	bus_dmamem_free(t, sg, n)				\
	(*(t)->_dmamem_free)((t), (sg), (n))
#define	bus_dmamem_map(t, sg, n, s, k, f)			\
	(*(t)->_dmamem_map)((t), (sg), (n), (s), (k), (f))
#define	bus_dmamem_unmap(t, k, s)				\
	(*(t)->_dmamem_unmap)((t), (k), (s))
#define	bus_dmamem_mmap(t, sg, n, o, p, f)			\
	(*(t)->_dmamem_mmap)((t), (sg), (n), (o), (p), (f))

/*
 *	bus_dmamap_t
 *
 *	Describes a DMA mapping.
 */
struct alpha_bus_dmamap {
	/*
	 * PRIVATE MEMBERS: not for use my machine-independent code.
	 */
	bus_size_t	_dm_size;	/* largest DMA transfer mappable */
	int		_dm_segcnt;	/* number of segs this map can map */
	bus_size_t	_dm_maxsegsz;	/* largest possible segment */
	bus_size_t	_dm_boundary;	/* don't cross this */
	int		_dm_flags;	/* misc. flags */

	/*
	 * This is used only for SGMAP-mapped DMA, but we keep it
	 * here to avoid pointless indirection.
	 */
	int		_dm_pteidx;	/* PTE index */
	int		_dm_ptecnt;	/* PTE count */
	u_long		_dm_sgva;	/* allocated sgva */
	bus_size_t	_dm_sgvalen;	/* svga length */

	/*
	 * Private cookie to be used by the DMA back-end.
	 */
	void		*_dm_cookie;

	/*
	 * PUBLIC MEMBERS: these are used by machine-independent code.
	 */
	bus_size_t	dm_mapsize;	/* size of the mapping */
	int		dm_nsegs;	/* # valid segments in mapping */
	bus_dma_segment_t dm_segs[1];	/* segments; variable length */
};

#ifdef _ALPHA_BUS_DMA_PRIVATE
int	_bus_dmamap_create(bus_dma_tag_t, bus_size_t, int, bus_size_t,
	    bus_size_t, int, bus_dmamap_t *);
void	_bus_dmamap_destroy(bus_dma_tag_t, bus_dmamap_t);

int	_bus_dmamap_load_direct(bus_dma_tag_t, bus_dmamap_t,
	    void *, bus_size_t, struct proc *, int);
int	_bus_dmamap_load_mbuf_direct(bus_dma_tag_t,
	    bus_dmamap_t, struct mbuf *, int);
int	_bus_dmamap_load_uio_direct(bus_dma_tag_t,
	    bus_dmamap_t, struct uio *, int);
int	_bus_dmamap_load_raw_direct(bus_dma_tag_t,
	    bus_dmamap_t, bus_dma_segment_t *, int, bus_size_t, int);

void	_bus_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
void	_bus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_dmasync_op_t);

int	_bus_dmamem_alloc(bus_dma_tag_t tag, bus_size_t size,
	    bus_size_t alignment, bus_size_t boundary,
	    bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags);
int	_bus_dmamem_alloc_range(bus_dma_tag_t tag, bus_size_t size,
	    bus_size_t alignment, bus_size_t boundary,
	    bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags,
	    paddr_t low, paddr_t high);
void	_bus_dmamem_free(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs);
int	_bus_dmamem_map(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, size_t size, caddr_t *kvap, int flags);
void	_bus_dmamem_unmap(bus_dma_tag_t tag, caddr_t kva,
	    size_t size);
paddr_t	_bus_dmamem_mmap(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, off_t off, int prot, int flags);
#endif /* _ALPHA_BUS_DMA_PRIVATE */
@


1.10.10.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.10.10.1 2001/04/18 16:00:47 niklas Exp $	*/
a213 1
#define alpha_bus_space_map_noacct bus_space_map
a215 1
#define alpha_bus_space_unmap_noacct bus_space_unmap
@


1.10.10.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d433 2
d437 6
a442 4
#define BUS_DMASYNC_PREREAD	0x01
#define BUS_DMASYNC_POSTREAD	0x02
#define BUS_DMASYNC_PREWRITE	0x04
#define BUS_DMASYNC_POSTWRITE	0x08
d540 1
a540 1
		    bus_addr_t, bus_size_t, int);
d573 2
a574 2
#define	bus_dmamap_sync(t, p, a, s, op)				\
	(*(t)->_dmamap_sync)((t), (p), (a), (s), (op))
d638 1
a638 2
void	_bus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
	    bus_size_t, int);
@


1.10.10.4
log
@Merge in -current from about a week ago
@
text
@d350 1
a350 1
 *	void bus_space_write_raw_region_N(bus_space_tag_t tag,
d352 1
a352 1
 *	    const u_int8_t *addr, size_t count);
d411 8
a418 11
#define	BUS_DMA_WAITOK		0x000	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x001	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x002	/* perform resource allocation now */
#define	BUS_DMA_COHERENT	0x004	/* hint: map memory DMA coherent */
#define	BUS_DMA_BUS1		0x010	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x020
#define	BUS_DMA_BUS3		0x040
#define	BUS_DMA_BUS4		0x080
#define	BUS_DMA_STREAMING	0x100	/* hint: sequential, unidirectional */
#define	BUS_DMA_READ		0x200	/* mapping is device -> memory only */
#define	BUS_DMA_WRITE		0x400	/* mapping is memory -> device only */
@


1.10.10.5
log
@Sync the SMP branch with 3.3
@
text
@a297 17
 *	void bus_space_read_raw_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_int8_t *addr, size_t count);
 *
 * Read `count' bytes in 2, 4 or 8 byte wide quantities from bus space
 * described by tag/handle and starting at `offset' from the
 * buffer provided.  The buffer must have proper alignment for the N byte
 * wide entities.  Furthermore possible byte-swapping should be done by
 * these functions.
 */

#define bus_space_read_raw_region_2(t, h, o, a, c)			\
    bus_space_read_region_2((t), (h), (o), (u_int16_t *)(a), (c) >> 1)
#define bus_space_read_raw_region_4(t, h, o, a, c)			\
    bus_space_read_region_4((t), (h), (o), (u_int32_t *)(a), (c) >> 2)

/*
@


1.10.10.6
log
@Merge of -current from two weeks ago into the SMP branch
@
text
@d522 1
a522 1
	 * be specified.  If the device has a more restrictive constraint,
@


1.9
log
@non-DEBUG __abs_nonsingle correct use; grr
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.8 1997/04/10 01:28:53 millert Exp $	*/
d382 4
@


1.8
log
@Fix typo (aligend -> aligned)
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.7 1997/04/02 22:08:07 niklas Exp $	*/
d193 1
a193 1
	__abs_nonsingle((type), (sz), (t), (h), (o), (a), (c))
@


1.7
log
@Better implementation of buf_space_*_raw_multi_* that deals well
with unaligned buffers
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.6 1997/03/21 00:16:32 niklas Exp $	*/
d196 1
a196 1
#define	__abs_aligend_nonsingle(type, sz, t, h, o, a, c)		\
@


1.6
log
@Add the bus_space_{read,write}_raw_multi_[248] extensions
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.5 1997/01/24 19:57:09 niklas Exp $	*/
d158 18
a188 1
#ifndef DEBUG
d191 4
d196 1
a196 1
#define	__abs_nonsingle(type, sz, t, h, o, a, c)			\
a208 1

d255 1
a255 1
	__abs_nonsingle(rm,2,(t),(h),(o),(a),(c))
d257 1
a257 1
	__abs_nonsingle(rm,4,(t),(h),(o),(a),(c))
d259 1
a259 1
	__abs_nonsingle(rm,8,(t),(h),(o),(a),(c))
d273 6
a278 6
#define	bus_space_read_raw_multi_2(t, h, o, a, c) \
    bus_space_read_multi_2((t), (h), (o), (u_int16_t *)(a), (c) >> 1)
#define	bus_space_read_raw_multi_4(t, h, o, a, c) \
    bus_space_read_multi_4((t), (h), (o), (u_int32_t *)(a), (c) >> 2)
#define	bus_space_read_raw_multi_8(t, h, o, a, c) \
    bus_space_read_multi_8((t), (h), (o), (u_int64_t *)(a), (c) >> 4)
d286 1
a286 1
	__abs_nonsingle(rr,2,(t),(h),(o),(a),(c))
d288 1
a288 1
	__abs_nonsingle(rr,4,(t),(h),(o),(a),(c))
d290 1
a290 1
	__abs_nonsingle(rr,8,(t),(h),(o),(a),(c))
d308 1
a308 1
	__abs_nonsingle(wm,2,(t),(h),(o),(a),(c))
d310 1
a310 1
	__abs_nonsingle(wm,4,(t),(h),(o),(a),(c))
d312 1
a312 1
	__abs_nonsingle(wm,8,(t),(h),(o),(a),(c))
d325 6
a330 6
#define	bus_space_write_raw_multi_2(t, h, o, a, c) \
    bus_space_write_multi_2((t), (h), (o), (u_int16_t *)(a), (c) >> 1)
#define	bus_space_write_raw_multi_4(t, h, o, a, c) \
    bus_space_write_multi_4((t), (h), (o), (u_int32_t *)(a), (c) >> 2)
#define	bus_space_write_raw_multi_8(t, h, o, a, c) \
    bus_space_write_multi_8((t), (h), (o), (u_int64_t *)(a), (c) >> 4)
d338 1
a338 1
	__abs_nonsingle(wr,2,(t),(h),(o),(a),(c))
d340 1
a340 1
	__abs_nonsingle(wr,4,(t),(h),(o),(a),(c))
d342 1
a342 1
	__abs_nonsingle(wr,8,(t),(h),(o),(a),(c))
@


1.5
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.4 1996/11/12 22:46:26 niklas Exp $	*/
d243 18
d294 17
@


1.4
log
@Arrival of new bus.h from NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: bus.h,v 1.6 1996/10/22 21:23:49 cgd Exp $	*/
/*	$NetBSD: bus.h,v 1.6 1996/10/22 21:23:49 cgd Exp $	*/
d65 4
d79 1
a79 1
	/* read multi */
d109 1
a109 1
	/* write multi */
d129 9
a137 2
	/* set multi */
	/* XXX IMPLEMENT */
d140 8
a147 1
	/* XXX IMPLEMENT */
d150 8
a157 5
	/* XXX IMPLEMENT */

	/* barrier */
	void		(*abs_barrier) __P((void *, bus_space_handle_t,
			    bus_size_t, bus_size_t, int));
d171 1
d174 13
d211 10
d293 8
a300 1
/* XXX IMPLEMENT */
d306 8
a313 1
/* XXX IMPLEMENT */
d319 8
a326 11
/* XXX IMPLEMENT */


/*
 * Bus barrier operations.
 */
#define	bus_space_barrier(t, h, o, l, f)				\
	(*(t)->abs_barrier)((t)->abs_cookie, (h), (o), (l), (f))

#define	BUS_BARRIER_READ	0x01
#define	BUS_BARRIER_WRITE	0x02
@


1.3
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 2
a2 2
/*	$OpenBSD: bus.h,v 1.4 1996/06/11 21:16:21 cgd Exp $	*/
/*	$NetBSD: bus.h,v 1.4 1996/06/11 21:16:21 cgd Exp $	*/
d32 1
a32 1
#define _ALPHA_BUS_H_
d35 1
a35 1
 * I/O addresses (in bus space)
d37 2
a38 2
typedef u_long bus_io_addr_t;
typedef u_long bus_io_size_t;
d41 4
a44 105
 * Memory addresses (in bus space)
 */
typedef u_long bus_mem_addr_t;
typedef u_long bus_mem_size_t;

/*
 * Access methods for bus resources, I/O space, and memory space.
 */
typedef struct alpha_bus_chipset *bus_chipset_tag_t;
typedef u_long bus_io_handle_t;
typedef u_long bus_mem_handle_t;

struct alpha_bus_chipset {
	/* I/O-space cookie */
	void		*bc_i_v;

	/* I/O-space control functions */
	int		(*bc_i_map) __P((void *v, bus_io_addr_t port,
			    bus_io_size_t size, bus_io_handle_t *iohp));
	void		(*bc_i_unmap) __P((void *v, bus_io_handle_t ioh,
			    bus_io_size_t size));
	int		(*bc_i_subregion) __P((void *v, bus_io_handle_t ioh,
			    bus_io_size_t offset, bus_io_size_t size,
			    bus_io_handle_t *nioh));

	/* I/O-space read functions */
	u_int8_t	(*bc_ir1) __P((void *v, bus_io_handle_t ioh,
			    bus_io_size_t off));
	u_int16_t	(*bc_ir2) __P((void *v, bus_io_handle_t ioh,
			    bus_io_size_t off));
	u_int32_t	(*bc_ir4) __P((void *v, bus_io_handle_t ioh,
			    bus_io_size_t off));
	u_int64_t	(*bc_ir8) __P((void *v, bus_io_handle_t ioh,
			    bus_io_size_t off));

	/* I/O-space read-multiple functions */
	void		(*bc_irm1) __P((void *v, bus_io_handle_t ioh,
			    bus_io_size_t off, u_int8_t *addr,
			    bus_io_size_t count));
	void		(*bc_irm2) __P((void *v, bus_io_handle_t ioh,
			    bus_io_size_t off, u_int16_t *addr,
			    bus_io_size_t count));
	void		(*bc_irm4) __P((void *v, bus_io_handle_t ioh,
			    bus_io_size_t off, u_int32_t *addr,
			    bus_io_size_t count));
	void		(*bc_irm8) __P((void *v, bus_io_handle_t ioh,
			    bus_io_size_t off, u_int64_t *addr,
			    bus_io_size_t count));

	/* I/O-space write functions */
	void		(*bc_iw1) __P((void *v, bus_io_handle_t ioh,
			    bus_io_size_t off, u_int8_t val));
	void		(*bc_iw2) __P((void *v, bus_io_handle_t ioh,
			    bus_io_size_t off, u_int16_t val));
	void		(*bc_iw4) __P((void *v, bus_io_handle_t ioh,
			    bus_io_size_t off, u_int32_t val));
	void		(*bc_iw8) __P((void *v, bus_io_handle_t ioh,
			    bus_io_size_t off, u_int64_t val));

	/* I/O-space write-multiple functions */
	void		(*bc_iwm1) __P((void *v, bus_io_handle_t ioh,
			    bus_io_size_t off, const u_int8_t *addr,
			    bus_io_size_t count));
	void		(*bc_iwm2) __P((void *v, bus_io_handle_t ioh,
			    bus_io_size_t off, const u_int16_t *addr,
			    bus_io_size_t count));
	void		(*bc_iwm4) __P((void *v, bus_io_handle_t ioh,
			    bus_io_size_t off, const u_int32_t *addr,
			    bus_io_size_t count));
	void		(*bc_iwm8) __P((void *v, bus_io_handle_t ioh,
			    bus_io_size_t off, const u_int64_t *addr,
			    bus_io_size_t count));

	/* Mem-space cookie */
	void		*bc_m_v;

	/* Mem-space control functions */
	int		(*bc_m_map) __P((void *v, bus_mem_addr_t buspa,
			    bus_mem_size_t size, int cacheable,
			    bus_mem_handle_t *mhp));
	void		(*bc_m_unmap) __P((void *v, bus_mem_handle_t mh,
			    bus_mem_size_t size));
	int		(*bc_m_subregion) __P((void *v, bus_mem_handle_t memh,
			    bus_mem_size_t offset, bus_mem_size_t size,
			    bus_mem_handle_t *nmemh));

	/* Mem-space read functions */
	u_int8_t	(*bc_mr1) __P((void *v, bus_mem_handle_t memh,
			    bus_mem_size_t off));
	u_int16_t	(*bc_mr2) __P((void *v, bus_mem_handle_t memh,
			    bus_mem_size_t off));
	u_int32_t	(*bc_mr4) __P((void *v, bus_mem_handle_t memh,
			    bus_mem_size_t off));
	u_int64_t	(*bc_mr8) __P((void *v, bus_mem_handle_t memh,
			    bus_mem_size_t off));

	/* Mem-space write functions */
	void		(*bc_mw1) __P((void *v, bus_mem_handle_t memh,
			    bus_mem_size_t off, u_int8_t val));
	void		(*bc_mw2) __P((void *v, bus_mem_handle_t memh,
			    bus_mem_size_t off, u_int16_t val));
	void		(*bc_mw4) __P((void *v, bus_mem_handle_t memh,
			    bus_mem_size_t off, u_int32_t val));
	void		(*bc_mw8) __P((void *v, bus_mem_handle_t memh,
			    bus_mem_size_t off, u_int64_t val));
d46 91
a136 2
	/* XXX THIS DOES NOT YET BELONG HERE */
	vm_offset_t	(*bc_XXX_dmamap) __P((void *addr));
a138 64
#define __bc_CONCAT(A,B)	__CONCAT(A,B)
#define __bc_ABC(A,B,C)		__bc_CONCAT(A,__bc_CONCAT(B,C))
#define __bc_ABCD(A,B,C,D)	__bc_CONCAT(__bc_ABC(A,B,C),D)

#define __bc_rd(t, h, o, sz, sp)					\
    (*(t)->__bc_ABCD(bc_,sp,r,sz))((t)->__bc_ABC(bc_,sp,_v), h, o)

#define __bc_wr(t, h, o, v, sz, sp)					\
    (*(t)->__bc_ABCD(bc_,sp,w,sz))((t)->__bc_ABC(bc_,sp,_v), h, o, v)

#define bus_io_map(t, port, size, iohp)					\
    (*(t)->bc_i_map)((t)->bc_i_v, (port), (size), (iohp))
#define bus_io_unmap(t, ioh, size)					\
    (*(t)->bc_i_unmap)((t)->bc_i_v, (ioh), (size))
#define bus_io_subregion(t, ioh, offset, size, nioh)			\
    (*(t)->bc_i_unmap)((t)->bc_i_v, (ioh), (offset), (size), (nioh))

#define	__bc_io_multi(t, h, o, a, s, dir, sz)				\
    (*(t)->__bc_ABCD(bc_i,dir,m,sz))((t)->bc_i_v, h, o, a, s)

#define	bus_io_read_1(t, h, o)		__bc_rd((t),(h),(o),1,i)
#define	bus_io_read_2(t, h, o)		__bc_rd((t),(h),(o),2,i)
#define	bus_io_read_4(t, h, o)		__bc_rd((t),(h),(o),4,i)
#define	bus_io_read_8(t, h, o)		__bc_rd((t),(h),(o),8,i)

#define	bus_io_read_multi_1(t, h, o, a, s)				\
    __bc_io_multi((t),(h),(o),(a),(s),r,1)
#define	bus_io_read_multi_2(t, h, o, a, s)				\
    __bc_io_multi((t),(h),(o),(a),(s),r,2)
#define	bus_io_read_multi_4(t, h, o, a, s)				\
    __bc_io_multi((t),(h),(o),(a),(s),r,4)
#define	bus_io_read_multi_8(t, h, o, a, s)				\
    __bc_io_multi((t),(h),(o),(a),(s),r,8)

#define	bus_io_write_1(t, h, o, v)	__bc_wr((t),(h),(o),(v),1,i)
#define	bus_io_write_2(t, h, o, v)	__bc_wr((t),(h),(o),(v),2,i)
#define	bus_io_write_4(t, h, o, v)	__bc_wr((t),(h),(o),(v),4,i)
#define	bus_io_write_8(t, h, o, v)	__bc_wr((t),(h),(o),(v),8,i)

#define	bus_io_write_multi_1(t, h, o, a, s)				\
    __bc_io_multi((t),(h),(o),(a),(s),w,1)
#define	bus_io_write_multi_2(t, h, o, a, s)				\
    __bc_io_multi((t),(h),(o),(a),(s),w,2)
#define	bus_io_write_multi_4(t, h, o, a, s)				\
    __bc_io_multi((t),(h),(o),(a),(s),w,4)
#define	bus_io_write_multi_8(t, h, o, a, s)				\
    __bc_io_multi((t),(h),(o),(a),(s),w,8)

#define bus_mem_map(t, bpa, size, cacheable, mhp)			\
    (*(t)->bc_m_map)((t)->bc_m_v, (bpa), (size), (cacheable), (mhp))
#define bus_mem_unmap(t, memh, size)					\
    (*(t)->bc_m_unmap)((t)->bc_m_v, (memh), (size))
#define bus_mem_subregion(t, memh, offset, size, nmemh)			\
    (*(t)->bc_m_unmap)((t)->bc_i_v, (memh), (offset), (size), (nmemh))

#define	bus_mem_read_1(t, h, o)		__bc_rd((t),(h),(o),1,m)
#define	bus_mem_read_2(t, h, o)		__bc_rd((t),(h),(o),2,m)
#define	bus_mem_read_4(t, h, o)		__bc_rd((t),(h),(o),4,m)
#define	bus_mem_read_8(t, h, o)		__bc_rd((t),(h),(o),8,m)

#define	bus_mem_write_1(t, h, o, v)	__bc_wr((t),(h),(o),(v),1,m)
#define	bus_mem_write_2(t, h, o, v)	__bc_wr((t),(h),(o),(v),2,m)
#define	bus_mem_write_4(t, h, o, v)	__bc_wr((t),(h),(o),(v),4,m)
#define	bus_mem_write_8(t, h, o, v)	__bc_wr((t),(h),(o),(v),8,m)
d140 131
a270 2
/* XXX THIS DOES NOT BELONG HERE YET. */
#define	__alpha_bus_XXX_dmamap(t, va) (*(t)->bc_XXX_dmamap)((va))
@


1.2
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: bus.h,v 1.2.4.2 1996/06/13 17:44:45 cgd Exp $	*/
/*	$NetBSD: bus.h,v 1.2.4.2 1996/06/13 17:44:45 cgd Exp $	*/
@


1.1
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@
