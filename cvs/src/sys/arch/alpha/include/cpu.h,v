head	1.58;
access;
symbols
	OPENBSD_6_2:1.58.0.2
	OPENBSD_6_2_BASE:1.58
	OPENBSD_6_1:1.57.0.6
	OPENBSD_6_1_BASE:1.57
	OPENBSD_6_0:1.57.0.2
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.55.0.2
	OPENBSD_5_9_BASE:1.55
	OPENBSD_5_8:1.55.0.4
	OPENBSD_5_8_BASE:1.55
	OPENBSD_5_7:1.54.0.2
	OPENBSD_5_7_BASE:1.54
	OPENBSD_5_6:1.53.0.4
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.51.0.4
	OPENBSD_5_5_BASE:1.51
	OPENBSD_5_4:1.50.0.2
	OPENBSD_5_4_BASE:1.50
	OPENBSD_5_3:1.48.0.2
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.44.0.2
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.4
	OPENBSD_5_0:1.43.0.2
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.42.0.2
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.40.0.2
	OPENBSD_4_8_BASE:1.40
	OPENBSD_4_7:1.39.0.2
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.38.0.4
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.36.0.2
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.33.0.2
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.31.0.2
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.26.0.2
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.25.0.10
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.25.0.8
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.6
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.25.0.4
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.25.0.2
	OPENBSD_3_6_BASE:1.25
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.22.0.2
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.20.0.4
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.15.0.4
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.20
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.7.0.16
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.14
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.12
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.10
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.58
date	2017.05.29.14.19.49;	author mpi;	state Exp;
branches;
next	1.57;
commitid	4u6PWvBw90PH7UDq;

1.57
date	2016.03.30.15.39.46;	author afresh1;	state Exp;
branches;
next	1.56;
commitid	AEwJ5MlE20muUoPp;

1.56
date	2016.03.01.19.17.37;	author mmcc;	state Exp;
branches;
next	1.55;
commitid	X6zJ1dl85dc0hfhR;

1.55
date	2015.07.02.01.33.59;	author dlg;	state Exp;
branches;
next	1.54;
commitid	HBmwORlhlW47BLMN;

1.54
date	2014.12.17.15.23.42;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	m1QU4zfUVMSJqLJo;

1.53
date	2014.07.11.10.53.07;	author uebayasi;	state Exp;
branches;
next	1.52;
commitid	CaCLs5fTSVpJlqFi;

1.52
date	2014.03.29.18.09.28;	author guenther;	state Exp;
branches;
next	1.51;

1.51
date	2014.01.26.17.40.11;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2013.05.31.17.00.57;	author tedu;	state Exp;
branches;
next	1.49;

1.49
date	2013.03.12.09.37.16;	author mpi;	state Exp;
branches;
next	1.48;

1.48
date	2013.02.12.08.06.22;	author mpi;	state Exp;
branches;
next	1.47;

1.47
date	2013.02.11.17.05.25;	author mpi;	state Exp;
branches;
next	1.46;

1.46
date	2012.12.02.07.03.30;	author guenther;	state Exp;
branches;
next	1.45;

1.45
date	2012.11.01.21.09.17;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2012.06.26.01.59.47;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2011.03.23.16.54.34;	author pirofti;	state Exp;
branches;
next	1.42;

1.42
date	2010.11.28.21.00.04;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2010.09.28.20.27.54;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2010.07.24.12.18.55;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2009.11.07.23.01.38;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2009.03.26.17.24.32;	author oga;	state Exp;
branches;
next	1.37;

1.37
date	2009.03.15.11.26.37;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2008.10.15.23.23.44;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2008.10.10.08.36.28;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2008.10.10.08.05.45;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2008.07.18.23.43.31;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2008.06.26.05.42.08;	author ray;	state Exp;
branches;
next	1.31;

1.31
date	2007.11.15.16.37.22;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.06.19.05.11;	author martin;	state Exp;
branches;
next	1.29;

1.29
date	2007.04.13.08.31.50;	author martin;	state Exp;
branches;
next	1.28;

1.28
date	2007.04.12.14.38.36;	author martin;	state Exp;
branches;
next	1.27;

1.27
date	2007.03.15.10.22.29;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2006.12.24.20.30.35;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2004.06.13.21.49.12;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	2004.06.08.20.13.23;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2004.06.08.18.11.28;	author marc;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.22.17.47.29;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.02.23.27.43;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.24.17.21.45;	author matthieu;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.28.16.50.38;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.07.21.33.43;	author nordin;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.26.07.55.01;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2002.04.28.20.55.14;	author pvalchev;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.06.18.41.09;	author art;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.11.04.23.12.46;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.26.21.13.43;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.26.20.25.50;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.12.11.12.35;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.20.21.24.05;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.08.21.27.18;	author ericj;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.08.16.01.11;	author art;	state Exp;
branches;
next	1.7;

1.7
date	97.07.08.10.55.52;	author niklas;	state Exp;
branches
	1.7.12.1;
next	1.6;

1.6
date	97.01.24.19.57.10;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.10.30.22.38.58;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.07.29.22.58.33;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.06.18.09.43.13;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.21.14.40.27;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.42;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.42;	author deraadt;	state Exp;
branches;
next	;

1.7.12.1
date	2001.04.18.16.00.48;	author niklas;	state Exp;
branches;
next	1.7.12.2;

1.7.12.2
date	2001.07.04.10.14.35;	author niklas;	state Exp;
branches;
next	1.7.12.3;

1.7.12.3
date	2001.11.13.21.00.49;	author niklas;	state Exp;
branches;
next	1.7.12.4;

1.7.12.4
date	2002.03.12.11.54.17;	author ho;	state Exp;
branches;
next	1.7.12.5;

1.7.12.5
date	2003.03.27.23.18.06;	author niklas;	state Exp;
branches;
next	1.7.12.6;

1.7.12.6
date	2003.06.07.11.11.33;	author ho;	state Exp;
branches;
next	1.7.12.7;

1.7.12.7
date	2004.02.19.09.59.34;	author niklas;	state Exp;
branches;
next	1.7.12.8;

1.7.12.8
date	2004.06.06.05.23.38;	author tedu;	state Exp;
branches;
next	1.7.12.9;

1.7.12.9
date	2004.06.06.22.04.17;	author tedu;	state Exp;
branches;
next	1.7.12.10;

1.7.12.10
date	2004.06.08.21.07.18;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.10.29.00.28.00;	author art;	state Exp;
branches;
next	;


desc
@@


1.58
log
@Kill SPINLOCK_SPIN_HOOK, use CPU_BUSY_CYCLE() instead.

ok visa@@, kettenis@@
@
text
@/* $OpenBSD: cpu.h,v 1.57 2016/03/30 15:39:46 afresh1 Exp $ */
/* $NetBSD: cpu.h,v 1.45 2000/08/21 02:03:12 thorpej Exp $ */

/*-
 * Copyright (c) 1998, 1999, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: cpu.h 1.16 91/03/25$
 *
 *	@@(#)cpu.h	8.4 (Berkeley) 1/5/94
 */

#ifndef _MACHINE_CPU_H_
#define _MACHINE_CPU_H_

#ifndef NO_IEEE
typedef union alpha_s_float {
	u_int32_t i;
	u_int32_t frac: 23,
		exp:   8,
		sign:  1;
} s_float;

typedef union alpha_t_float {
	u_int64_t i;
	u_int64_t frac: 52,
		exp:  11,
		sign:  1;
} t_float;
#endif

/*
 * Exported definitions unique to Alpha cpu support.
 */

#ifdef _KERNEL

#include <machine/alpha_cpu.h>
#include <machine/frame.h>
#include <machine/bus.h>
#include <machine/intr.h>
#include <sys/cdefs.h>
#include <sys/device.h>
#include <sys/sched.h>

struct pcb;
struct proc;
struct reg;
struct rpb;
struct trapframe;

extern u_long cpu_implver;		/* from IMPLVER instruction */
extern u_long cpu_amask;		/* from AMASK instruction */
extern int bootdev_debug;
extern int alpha_fp_sync_complete;
extern int alpha_unaligned_print, alpha_unaligned_fix, alpha_unaligned_sigbus;

void	XentArith(u_int64_t, u_int64_t, u_int64_t);		/* MAGIC */
void	XentIF(u_int64_t, u_int64_t, u_int64_t);		/* MAGIC */
void	XentInt(u_int64_t, u_int64_t, u_int64_t);		/* MAGIC */
void	XentMM(u_int64_t, u_int64_t, u_int64_t);		/* MAGIC */
void	XentRestart(void);					/* MAGIC */
void	XentSys(u_int64_t, u_int64_t, u_int64_t);		/* MAGIC */
void	XentUna(u_int64_t, u_int64_t, u_int64_t);		/* MAGIC */
void	alpha_init(u_long, u_long, u_long, u_long, u_long);
int	alpha_pa_access(u_long);
void	ast(struct trapframe *);
int	badaddr(void *, size_t);
int	badaddr_read(void *, size_t, void *);
u_int64_t console_restart(struct trapframe *);
void	do_sir(void);
void	dumpconf(void);
void	exception_return(void);					/* MAGIC */
void	frametoreg(struct trapframe *, struct reg *);
long	fswintrberr(void);					/* MAGIC */
void	init_bootstrap_console(void);
void	init_prom_interface(struct rpb *);
void	interrupt(unsigned long, unsigned long, unsigned long,
	    struct trapframe *);
void	machine_check(unsigned long, struct trapframe *, unsigned long,
	    unsigned long);
u_int64_t hwrpb_checksum(void);
void	hwrpb_restart_setup(void);
void	regdump(struct trapframe *);
void	regtoframe(struct reg *, struct trapframe *);
void	savectx(struct pcb *);
void    switch_exit(struct proc *);				/* MAGIC */
void	switch_trampoline(void);				/* MAGIC */
void	syscall(u_int64_t, struct trapframe *);
void	trap(unsigned long, unsigned long, unsigned long, unsigned long,
	    struct trapframe *);
void	trap_init(void);
void	enable_nsio_ide(bus_space_tag_t);

/* Multiprocessor glue; cpu.c */
struct cpu_info;
int	cpu_iccb_send(cpuid_t, const char *);
void	cpu_iccb_receive(void);
void	cpu_hatch(struct cpu_info *);
__dead
void	cpu_halt(void);
void	cpu_halt_secondary(unsigned long);
void	cpu_spinup_trampoline(void);				/* MAGIC */
void	cpu_pause(unsigned long);
void	cpu_resume(unsigned long);

/*
 * Machine check information.
 */
struct mchkinfo {
	volatile int mc_expected;	/* machine check is expected */
	volatile int mc_received;	/* machine check was received */
};

struct cpu_info {
	/*
	 * Private members accessed in assembly with 8 bit offsets.
	 */
	struct proc *ci_curproc;	/* current owner of the processor */
	paddr_t ci_curpcb;		/* PA of current HW PCB */

	/*
	 * Public members.
	 */
	struct schedstate_percpu ci_schedstate;	/* scheduler state */
#ifdef DIAGNOSTIC
	int	ci_mutex_level;
#endif
	cpuid_t ci_cpuid;		/* our CPU ID */
	struct cpu_info *ci_next;
	u_int32_t ci_randseed;

#if defined(MULTIPROCESSOR)
	struct srp_hazard ci_srp_hazards[SRP_HAZARD_NUM];
#endif

	/*
	 * Private members.
	 */
	struct mchkinfo ci_mcinfo;	/* machine check info */
	struct proc *ci_fpcurproc;	/* current owner of the FPU */
	struct pcb *ci_idle_pcb;	/* our idle PCB */
	paddr_t ci_idle_pcb_paddr;	/* PA of idle PCB */
	struct device *ci_dev;		/* pointer to our device */
	u_long ci_want_resched;		/* preempt current process */
	u_long ci_intrdepth;		/* interrupt trap depth */
	struct trapframe *ci_db_regs;	/* registers for debuggers */

#if defined(MULTIPROCESSOR)
	volatile u_long ci_flags;	/* flags; see below */
	volatile u_long ci_ipis;	/* interprocessor interrupts pending */
#endif
#ifdef GPROF
	struct gmonparam *ci_gmon;
#endif
};

#define	CPUF_PRIMARY	0x01		/* CPU is primary CPU */
#define	CPUF_RUNNING	0x02		/* CPU is running */
#define	CPUF_PAUSED	0x04		/* CPU is paused */
#define	CPUF_FPUSAVE	0x08		/* CPU is currently in fpusave_cpu() */

void	fpusave_cpu(struct cpu_info *, int);
void	fpusave_proc(struct proc *, int);

extern	struct cpu_info cpu_info_primary;
extern	struct cpu_info *cpu_info_list;

#define	CPU_INFO_UNIT(ci)	((ci)->ci_dev ? (ci)->ci_dev->dv_unit : 0)
#define	CPU_INFO_ITERATOR		int
#define	CPU_INFO_FOREACH(cii, ci)	for (cii = 0, ci = cpu_info_list; \
					    ci != NULL; ci = ci->ci_next)

#define MAXCPUS	ALPHA_MAXPROCS

#if defined(MULTIPROCESSOR)
extern	volatile u_long cpus_running;
extern	volatile u_long cpus_paused;
extern	struct cpu_info *cpu_info[];

#define	curcpu()			((struct cpu_info *)alpha_pal_rdval())
#define	CPU_IS_PRIMARY(ci)		((ci)->ci_flags & CPUF_PRIMARY)

void	cpu_boot_secondary_processors(void);

void	cpu_pause_resume(unsigned long, int);
void	cpu_pause_resume_all(int);
void	cpu_unidle(struct cpu_info *);

/*
 * On the Alpha, interprocessor interrupts come in at device priority
 * level.  This can cause some problems while waiting for r/w spinlocks
 * from a high'ish priority level: IPIs that come in will not be processed.
 * This can lead to deadlock.
 *
 * This hook allows IPIs to be processed while a spinlock's interlock
 * is released.
 */
#define	CPU_BUSY_CYCLE()						\
do {									\
	struct cpu_info *__ci = curcpu();				\
	int __s;							\
									\
	if (__ci->ci_ipis != 0) {					\
		__s = splipi();						\
		alpha_ipi_process_with_frame(__ci);			\
		splx(__s);						\
	}								\
} while (0)

#else /* ! MULTIPROCESSOR */

#define	curcpu()			(&cpu_info_primary)
#define	CPU_IS_PRIMARY(ci)		1
#define cpu_unidle(ci)			do { /* nothing */ } while (0)
#define CPU_BUSY_CYCLE()		do {} while (0)

#endif /* MULTIPROCESSOR */


#define	curproc		curcpu()->ci_curproc
#define	fpcurproc	curcpu()->ci_fpcurproc
#define	curpcb		curcpu()->ci_curpcb

/*
 * definitions of cpu-dependent requirements
 * referenced in generic code
 */
#define	cpu_number()		alpha_pal_whami()

/*
 * Arguments to hardclock and gatherstats encapsulate the previous
 * machine state in an opaque clockframe.  On the Alpha, we use
 * what we push on an interrupt (a trapframe).
 */
struct clockframe {
	struct trapframe	cf_tf;
};
#define	CLKF_USERMODE(framep)						\
	(((framep)->cf_tf.tf_regs[FRAME_PS] & ALPHA_PSL_USERMODE) != 0)
#define	CLKF_PC(framep)		((framep)->cf_tf.tf_regs[FRAME_PC])

/*
 * This isn't perfect; if the clock interrupt comes in before the
 * r/m/w cycle is complete, we won't be counted... but it's not
 * like this statistic has to be extremely accurate.
 */
#define	CLKF_INTR(framep)	(curcpu()->ci_intrdepth)

/*
 * This is used during profiling to integrate system time.
 */
#define	PROC_PC(p)	((p)->p_md.md_tf->tf_regs[FRAME_PC])
#define	PROC_STACK(p)	(alpha_pal_rdusp())	/*XXX only works for curproc */

/*
 * Preempt the current process if in interrupt from user mode,
 * or after the current trap/syscall if in system mode.
 */
#define	need_resched(ci)						\
do {									\
	(ci)->ci_want_resched = 1;					\
	if ((ci)->ci_curproc != NULL)					\
		aston((ci)->ci_curproc);				\
} while (/*CONSTCOND*/0)
#define clear_resched(ci) (ci)->ci_want_resched = 0

/*
 * Give a profiling tick to the current process when the user profiling
 * buffer pages are invalid.  On the Alpha, request an AST to send us
 * through trap, marking the proc as needing a profiling tick.
 */
#define	need_proftick(p)	aston(p)

/*
 * Notify the current process (p) that it has a signal pending,
 * process as soon as possible.
 */
#ifdef MULTIPROCESSOR
#define	signotify(p)	do { aston(p); cpu_unidle((p)->p_cpu); } while (0)
#else
#define signotify(p)	aston(p)
#endif

#define	aston(p)	((p)->p_md.md_astpending = 1)
#endif /* _KERNEL */

/*
 * CTL_MACHDEP definitions.
 */
#define	CPU_CONSDEV		1	/* dev_t: console terminal device */
#define	CPU_UNALIGNED_PRINT	3	/* int: print unaligned accesses */
#define	CPU_UNALIGNED_FIX	4	/* int: fix unaligned accesses */
#define	CPU_UNALIGNED_SIGBUS	5	/* int: SIGBUS unaligned accesses */
#define	CPU_BOOTED_KERNEL	6	/* string: booted kernel name */
#define	CPU_FP_SYNC_COMPLETE	7	/* int: always fixup sync fp traps */
#define CPU_CHIPSET		8	/* chipset information */
#define CPU_ALLOWAPERTURE	9
#define	CPU_LED_BLINK		10	/* int: blink leds on DEC 3000 */

#define	CPU_MAXID		11	/* valid machdep IDs */

#define CPU_CHIPSET_MEM		1	/* PCI memory address */
#define CPU_CHIPSET_BWX		2	/* PCI supports BWX */
#define CPU_CHIPSET_TYPE	3	/* PCI chipset name */
#define CPU_CHIPSET_DENSE	4	/* PCI chipset dense memory addr */
#define CPU_CHIPSET_PORTS	5	/* PCI port address */
#define CPU_CHIPSET_HAE_MASK	6	/* PCI chipset mask for HAE register */
#define CPU_CHIPSET_MAXID	7

#define	CTL_MACHDEP_NAMES { \
	{ 0, 0 }, \
	{ "console_device", CTLTYPE_STRUCT }, \
	{ 0, 0 }, \
	{ "unaligned_print", CTLTYPE_INT }, \
	{ "unaligned_fix", CTLTYPE_INT }, \
	{ "unaligned_sigbus", CTLTYPE_INT }, \
	{ "booted_kernel", CTLTYPE_STRING }, \
	{ "fp_sync_complete", CTLTYPE_INT }, \
	{ "chipset", CTLTYPE_NODE }, \
	{ "allowaperture", CTLTYPE_INT }, \
	{ "led_blink", CTLTYPE_INT } \
}

#define CTL_CHIPSET_NAMES { \
	{ 0, 0 }, \
	{ "memory", CTLTYPE_QUAD }, \
	{ "bwx", CTLTYPE_INT }, \
	{ "type", CTLTYPE_STRING }, \
	{ "dense_base", CTLTYPE_QUAD }, \
	{ "ports_base", CTLTYPE_QUAD }, \
	{ "hae_mask", CTLTYPE_QUAD }, \
}

#ifdef _KERNEL

struct pcb;
struct proc;
struct reg;
struct rpb;
struct trapframe;

/* IEEE and VAX FP completion */

#ifndef NO_IEEE
void alpha_sts(int, s_float *);					/* MAGIC */
void alpha_stt(int, t_float *);					/* MAGIC */
void alpha_lds(int, s_float *);					/* MAGIC */
void alpha_ldt(int, t_float *);					/* MAGIC */

uint64_t alpha_read_fpcr(void);					/* MAGIC */
void alpha_write_fpcr(u_int64_t);				/* MAGIC */

u_int64_t alpha_read_fp_c(struct proc *);
void alpha_write_fp_c(struct proc *, u_int64_t);

int alpha_fp_complete(u_long, u_long, struct proc *, u_int64_t *);
int alpha_fp_complete_at(u_long, struct proc *, u_int64_t *);
#endif

void alpha_enable_fp(struct proc *, int);

#ifdef MULTIPROCESSOR
#include <sys/mplock.h>
#endif

#endif /* _KERNEL */
#endif /* _MACHINE_CPU_H_ */
@


1.57
log
@Better support for alphas without all IEEE-mode instructions

From Miod Vallat

I trust miod deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.56 2016/03/01 19:17:37 mmcc Exp $ */
d249 21
d275 1
a278 1
#define CPU_BUSY_CYCLE()	do {} while (0)
@


1.56
log
@guard macro args with parens

from Michal Mazurek, ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.55 2015/07/02 01:33:59 dlg Exp $ */
d396 1
@


1.55
log
@introduce srp, which according to the manpage i wrote is short for
"shared reference pointers".

srp allows concurrent access to a data structure by multiple cpus
while avoiding interlocking cpu opcodes. it manages its own reference
counts and the garbage collection of those data structure to avoid
use after frees.

internally srp is a twisted version of hazard pointers, which are
a relative of RCU.

jmatthew wrote the bulk of a hazard pointer implementation and
changed bpf to use it to allow mpsafe access to bpfilters. however,
at s2k15 we were trying to apply it to other data structures but
the memory overhead of every hazard pointer would have blown out
significantly in several uses cases. a bulk of our time at s2k15
was spent reworking hazard pointers into srp.

this diff adds the srp api and adds the necessary metadata to struct
cpuinfo on our MP architectures. srp on uniprocessor platforms has
alternate code that is optimised because it knows there'll be no
concurrent access to data by multiple cpus.

srp is made available to the system via param.h, so it should be
available everywhere in the kernel.

the docs likely need improvement cos im too close to the implementation.

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.54 2014/12/17 15:23:42 deraadt Exp $ */
d323 1
a323 1
#define	aston(p)	(p)->p_md.md_astpending = 1
@


1.54
log
@remove simplelocks
ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.53 2014/07/11 10:53:07 uebayasi Exp $ */
d191 4
@


1.53
log
@CPU_BUSY_CYCLE(): A new MI statement for busy loop power reduction

The new CPU_BUSY_CYCLE() may be put in a busy loop body so that CPU can reduce
power consumption, as Linux's cpu_relax() and FreeBSD's cpu_spinwait().  To
start minimally, use PAUSE on i386/amd64 and empty on others.  The name is
chosen following the existing cpu_idle_*() functions.  Naming and API may be
polished later.

OK kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a187 1
	struct simplelock ci_slock;	/* lock on this data structure */
@


1.52
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.51 2014/01/26 17:40:11 miod Exp $ */
d253 2
@


1.51
log
@Work in progress work towards SMP, heavily based upon NetBSD. The MP kernel
will boot multiuser, but will deadlock under load, and I can't find my
mistake yet.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.50 2013/05/31 17:00:57 tedu Exp $ */
d170 2
a171 2
	__volatile int mc_expected;	/* machine check is expected */
	__volatile int mc_received;	/* machine check was received */
d206 2
a207 2
	__volatile u_long ci_flags;	/* flags; see below */
	__volatile u_long ci_ipis;	/* interprocessor interrupts pending */
d233 2
a234 2
extern	__volatile u_long cpus_running;
extern	__volatile u_long cpus_paused;
@


1.50
log
@remove counters for simplelocks
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.49 2013/03/12 09:37:16 mpi Exp $ */
d101 1
d159 2
d175 6
a180 1
	struct device *ci_dev;		/* pointer to our device */
a187 1
	struct proc *ci_curproc;	/* current owner of the processor */
d191 1
a197 1
	paddr_t ci_curpcb;		/* PA of current HW PCB */
d200 1
a200 1
	struct cpu_softc *ci_softc;	/* pointer to our device */
d204 1
d206 2
a207 2
	u_long ci_flags;		/* flags; see below */
	u_long ci_ipis;			/* interprocessor interrupts pending */
a208 1
	u_int32_t ci_randseed;
d215 3
a217 4
#define	CPUF_PRESENT	0x02		/* CPU is present */
#define	CPUF_RUNNING	0x04		/* CPU is running */
#define	CPUF_PAUSED	0x08		/* CPU is paused */
#define	CPUF_FPUSAVE	0x10		/* CPU is currently in fpusave_cpu() */
d222 3
d227 1
a227 1
#define	CPU_INFO_FOREACH(cii, ci)	for (cii = 0, ci = curcpu(); \
a231 2
#define cpu_unidle(ci)

d235 1
a235 1
extern	struct cpu_info cpu_info[];
d244 2
a246 1
extern	struct cpu_info cpu_info_store;
d248 4
a251 2
#define	curcpu()	(&cpu_info_store)
#define	CPU_IS_PRIMARY(ci)	1
a317 6
/*
 * XXXSMP
 * Should we send an AST IPI?  Or just let it handle it next time
 * it sees a normal kernel entry?  I guess letting it happen later
 * follows the `asynchronous' part of the name...
 */
@


1.49
log
@Fix kernel profiling on MP systems by using per-CPU buffers and teach
kgmon(8) to deal with them, this time without public header changes.

Previously various CPUs were iterating over the same global buffer at
the same time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok deraadt@@, mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.48 2013/02/12 08:06:22 mpi Exp $ */
a176 4
#if defined(DIAGNOSTIC) || defined(LOCKDEBUG)
	u_long ci_spin_locks;		/* # of spin locks held */
	u_long ci_simple_locks;		/* # of simple locks held */
#endif
@


1.48
log
@Back out per-CPU kernel profiling, it shouldn't modify a public header
at this moment.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.47 2013/02/11 17:05:25 mpi Exp $ */
d206 3
@


1.47
log
@Fix kernel profiling on MP systems by using per-CPU buffer. Previously
various CPUs were iterating over the same global buffer at the same
time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.46 2012/12/02 07:03:30 guenther Exp $ */
a205 3
#ifdef GPROF
	struct gmonparam *ci_gmon;
#endif
@


1.46
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.45 2012/11/01 21:09:17 miod Exp $ */
d206 3
@


1.45
log
@Switch alpha to per-process astpending.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.44 2012/06/26 01:59:47 deraadt Exp $ */
d278 1
@


1.44
log
@Stop the song and dance where alpha param.h tries to include the world.
"Why is this not commited yet?" says miod
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.43 2011/03/23 16:54:34 pirofti Exp $ */
a198 1
	u_long ci_astpending;		/* AST is pending */
a282 1
#ifdef MULTIPROCESSOR
d285 3
a287 2
	ci->ci_want_resched = 1;					\
	aston(curcpu());						\
a289 8
#else
#define	need_resched(ci)						\
do {									\
	curcpu()->ci_want_resched = 1;					\
	aston(curcpu());						\
} while (/*CONSTCOND*/0)
#define clear_resched(ci) curcpu()->ci_want_resched = 0
#endif
d296 1
a296 11
#ifdef notyet
#define	need_proftick(p)						\
do {									\
	aston((p)->p_cpu);						\
} while (/*CONSTCOND*/0)
#else
#define	need_proftick(p)						\
do {									\
	aston(curcpu());						\
} while (/*CONSTCOND*/0)
#endif
d302 2
a303 2
#ifdef notyet
#define	signotify(p)	aston((p)->p_cpu)
d305 1
a305 1
#define signotify(p)	aston(curcpu())
d314 1
a314 1
#define	aston(ci)	((ci)->ci_astpending = 1)
@


1.43
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.42 2010/11/28 21:00:04 miod Exp $ */
d95 2
a98 4
#include <machine/param.h>

#ifdef _KERNEL

@


1.42
log
@Get rid of machdep.root_device sysctl and related variables.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.41 2010/09/28 20:27:54 miod Exp $ */
d72 2
a73 2
#ifndef _ALPHA_CPU_H_
#define _ALPHA_CPU_H_
d417 1
a417 1
#endif /* _ALPHA_CPU_H_ */
@


1.41
log
@Implement a per-cpu held mutex counter if DIAGNOSTIC on all non-x86 platforms,
to complete matthew@@'s commit of a few days ago, and drop __HAVE_CPU_MUTEX_LEVEL
define. With help from, and ok deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.40 2010/07/24 12:18:55 miod Exp $ */
a341 1
#define	CPU_ROOT_DEVICE		2	/* string: root device name */
d364 1
a364 1
	{ "root_device", CTLTYPE_STRING }, \
@


1.40
log
@One the -> On the
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.39 2009/11/07 23:01:38 miod Exp $ */
d182 3
@


1.39
log
@Blink leds on the DEC 3000 models (three different led types).
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.38 2009/03/26 17:24:32 oga Exp $ */
d257 1
a257 1
 * machine state in an opaque clockframe.  One the Alpha, we use
@


1.38
log
@Remove cpu_wait(). It's original use was to be called from the reaper so
MD code would free resources that couldn't be freed until we were no
longer running in that processor. However, it's is unused on all
architectures since mikeb@@'s tss changes on x86 earlier in the year.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.37 2009/03/15 11:26:37 miod Exp $ */
d347 1
d349 1
a349 1
#define	CPU_MAXID		10	/* valid machdep IDs */
d370 1
@


1.37
log
@Allow CPU_INFO_UNIT() to be used before cpu0 attaches.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.36 2008/10/15 23:23:44 deraadt Exp $ */
a252 1
#define	cpu_wait(p)		/* nothing */
@


1.36
log
@make random(9) return per-cpu values (by saving the seed in the cpuinfo),
which are uniform for the profclock on each cpu in a SMP system (but using
a different seed for each cpu).  on all cpus, avoid seeding with a value out
of the [0, 2^31-1] range (since that is not stable)
ok kettenis drahn
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.35 2008/10/10 08:36:28 art Exp $ */
d217 1
a217 1
#define	CPU_INFO_UNIT(ci)		((ci)->ci_dev->dv_unit)
d347 1
a347 1
#define CPU_ALLOWAPERTURE         9
@


1.35
log
@Add empty cpu_unidle() macros for architectures that currently don't do
anything special to prod a cpu to leave the idle loop in signotify.
powerpc, i386, amd64 and sparc64 will follow soon so that everyone has
the same interface to wake an idling cpu.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.34 2008/10/10 08:05:45 art Exp $ */
d205 1
@


1.34
log
@Define MAXCPUS on all architectures.
For now, sparc64 is arbitrarily set to 256 (only architecture that didn't have
a practical limit in the code on the number of cpus).
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.33 2008/07/18 23:43:31 art Exp $ */
d222 2
@


1.33
log
@Add a macro that clears the want_resched flag that need_resched sets.
Right now when mi_switch picks up the same proc, we didn't clear the
flag which would mean that every time we service an AST we would attempt
a context switch. For some architectures, amd64 being probably the
most extreme, that meant attempting to context switch for every
trap and interrupt.

Now we clear_resched explicitly after every context switch, even if it
didn't do anything. Which also allows us to remove some more code
in cpu_switchto (not done yet).

miod@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.32 2008/06/26 05:42:08 ray Exp $ */
d220 2
@


1.32
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.31 2007/11/15 16:37:22 miod Exp $ */
d285 1
d292 1
@


1.31
log
@``stastic'' is a fantastic typo.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.30 2007/05/06 19:05:11 martin Exp $ */
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.30
log
@garbage collect release_fpu() and synchronize_fpstate()
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.29 2007/04/13 08:31:50 martin Exp $ */
d273 1
a273 1
 * like this stastic has to be extremely accurate.
@


1.29
log
@get alpha SMP into a state where it at least compiles:

- add machine-dependent spinlock operations
- add basic interprocessor interrupt sending and receiving code

from NetBSD; ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.28 2007/04/12 14:38:36 martin Exp $ */
a160 3

void	release_fpu(int);
void	synchronize_fpstate(struct proc *, int);
@


1.28
log
@__HAVE_CPUINFO for alpha, with bits from netbsd

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.27 2007/03/15 10:22:29 art Exp $ */
d104 1
d109 1
d210 1
d236 2
a237 2
#define	curcpu()		((struct cpu_info *)alpha_pal_rdval())
#define	CPU_IS_PRIMARY(ci)	((ci)->ci_flags & CPUF_PRIMARY)
d411 4
@


1.27
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.26 2006/12/24 20:30:35 miod Exp $ */
d109 1
d186 1
d194 1
d223 5
d244 1
@


1.26
log
@Define PROC_PC. Then, since profiling information is being reported in
statclock(), do not bother doing this in userret() anymore. As a result,
userret() does not need its pc and ticks arguments, simplify.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.25 2004/06/13 21:49:12 niklas Exp $ */
a298 1
	(p)->p_flag |= P_OWEUPC;					\
a303 1
	(p)->p_flag |= P_OWEUPC;					\
@


1.25
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d267 5
@


1.24
log
@Use cpuid_t whenever possible, rather than an angry combination of long
there and u_long elsewhere.

ok marc@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.23 2004/06/08 18:11:28 marc Exp $ */
d108 1
d181 1
d190 2
a196 1
	cpuid_t ci_cpuid;		/* our CPU ID */
a270 3
 *
 * XXXSMP
 * need_resched() needs to take a cpu_info *.
d272 8
a279 1
#define	need_resched()							\
d284 1
@


1.23
log
@pull up cpuid_t define from smp branch.   Kill alpha specific defininition
of cpuid_t.  OK art@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.22 2004/01/22 17:47:29 miod Exp $ */
d163 1
a163 1
int	cpu_iccb_send(long, const char *);
@


1.22
log
@dot_conv() is not used.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.21 2003/06/02 23:27:43 millert Exp $ */
a177 2

typedef long cpuid_t;
@


1.21
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.20 2002/08/24 17:21:45 matthieu Exp $ */
a156 1
char *	dot_conv(unsigned long);
@


1.20
log
@aperture driver for alpha. It works here the same as on i386
to allow access to VGA card's memory by mmapping /dev/xf86.
The macdep.allowaperture does also control /dev/pci access.
Ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.19 2002/06/28 16:50:38 art Exp $ */
d58 1
a58 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.19
log
@The IEEE fp stuff changed the rules for how fpu should be enabled.
We kept too much of the old code in trap handling.

This should fix floppies and bsd.rd on some machines.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.18 2002/06/07 21:33:43 nordin Exp $ */
d334 3
a336 1
#define	CPU_MAXID		9	/* 7 valid machdep IDs */
d356 1
@


1.18
log
@Remove obsolete CLKF_BASEPRI(). ok niklas@@, miod@@ and art@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.17 2002/05/26 07:55:01 matthieu Exp $ */
a387 1
void alpha_enable_fp(struct proc *, int);
d390 2
@


1.17
log
@- CPU_MAXID and CPU_CHIPSET were swapped in cpu.h
- add support to print machdep.chipset mib on alpha
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.16 2002/04/28 20:55:14 pvalchev Exp $ */
a262 2
#define	CLKF_BASEPRI(framep)						\
	(((framep)->cf_tf.tf_regs[FRAME_PS] & ALPHA_PSL_IPL_MASK) == 0)
@


1.16
log
@IEEE 754 floating point completion code, and implementation of the
FP_C (Floating Point Control Quadword).

From ross@@NetBSD.  Added a way to disable it with option NO_IEEE,
which appears on the ramdisks to save space.  This affects only
programs compiled with -mieee, and what it essentially does is
enabling infinities and NaNs, instead of generating SIGFPE on
division by zero, overflow, etc.
ok art, deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.15 2001/11/06 18:41:09 art Exp $ */
d335 2
a336 2
#define	CPU_MAXID		8	/* 7 valid machdep IDs */
#define CPU_CHIPSET		9	/* chipset information */
d344 1
d354 1
d356 10
a365 1
	{ "fp_sync_complete", CTLTYPE_INT }, \
@


1.15
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.14 2001/11/04 23:12:46 art Exp $ */
d86 16
d119 2
d122 2
d218 5
a245 3
extern	u_long cpu_implver;		/* from IMPLVER instruction */
extern	u_long cpu_amask;		/* from AMASK instruction */

d334 3
a336 2
#define CPU_CHIPSET		7	/* chipset information */
#define	CPU_MAXID		8	/* 6 valid machdep IDs */
d354 1
d364 18
@


1.15.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.15 2001/11/06 18:41:09 art Exp $ */
a85 16
#ifndef NO_IEEE
typedef union alpha_s_float {
	u_int32_t i;
	u_int32_t frac: 23,
		exp:   8,
		sign:  1;
} s_float;

typedef union alpha_t_float {
	u_int64_t i;
	u_int64_t frac: 52,
		exp:  11,
		sign:  1;
} t_float;
#endif

a102 2
extern u_long cpu_implver;		/* from IMPLVER instruction */
extern u_long cpu_amask;		/* from AMASK instruction */
a103 2
extern int alpha_fp_sync_complete;
extern int alpha_unaligned_print, alpha_unaligned_fix, alpha_unaligned_sigbus;
a197 5
#define	CPUF_PAUSED	0x08		/* CPU is paused */
#define	CPUF_FPUSAVE	0x10		/* CPU is currently in fpusave_cpu() */

void	fpusave_cpu(struct cpu_info *, int);
void	fpusave_proc(struct proc *, int);
d221 3
d241 2
d312 2
a313 3
#define	CPU_FP_SYNC_COMPLETE	7	/* int: always fixup sync fp traps */
#define CPU_CHIPSET		8	/* chipset information */
#define	CPU_MAXID		9	/* 7 valid machdep IDs */
a320 1
#define CPU_CHIPSET_MAXID	7
a329 1
	{ "fp_sync_complete", CTLTYPE_INT }, \
a332 10
#define CTL_CHIPSET_NAMES { \
	{ 0, 0 }, \
	{ "memory", CTLTYPE_QUAD }, \
	{ "bwx", CTLTYPE_INT }, \
	{ "type", CTLTYPE_STRING }, \
	{ "dense_base", CTLTYPE_QUAD }, \
	{ "ports_base", CTLTYPE_QUAD }, \
	{ "hae_mask", CTLTYPE_QUAD }, \
}

a339 18

/* IEEE and VAX FP completion */

#ifndef NO_IEEE
void alpha_sts(int, s_float *);					/* MAGIC */
void alpha_stt(int, t_float *);					/* MAGIC */
void alpha_lds(int, s_float *);					/* MAGIC */
void alpha_ldt(int, t_float *);					/* MAGIC */

uint64_t alpha_read_fpcr(void);					/* MAGIC */
void alpha_write_fpcr(u_int64_t);				/* MAGIC */

u_int64_t alpha_read_fp_c(struct proc *);
void alpha_write_fp_c(struct proc *, u_int64_t);

void alpha_enable_fp(struct proc *, int);
int alpha_fp_complete(u_long, u_long, struct proc *, u_int64_t *);
#endif
@


1.15.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.15.2.1 2002/06/11 03:33:40 art Exp $ */
d334 1
a334 3
#define CPU_ALLOWAPERTURE         9

#define	CPU_MAXID		10	/* valid machdep IDs */
a353 1
	{ "allowaperture", CTLTYPE_INT }, \
d388 1
a390 2

void alpha_enable_fp(struct proc *, int);
@


1.14
log
@Two new sysctls in the chipset tree.
CPU_CHIPSET_PORTS - address of the I/O ports.
CPU_CHIPSET_HAE_MASK - mask for the HAE register.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.13 2001/06/26 21:13:43 art Exp $ */
a116 1
void	child_return(void *);
@


1.13
log
@More chipset info needed by X.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.12 2001/06/26 20:25:50 art Exp $ */
d320 2
@


1.12
log
@Provide some chipset information to usreland through sysctl.
The chipset support is not here yet, but the skeleton works.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.11 2001/02/12 11:12:35 art Exp $ */
d319 1
@


1.11
log
@Remove duplicate definition of badaddr.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.10 2001/01/20 21:24:05 art Exp $ */
d313 6
a318 1
#define	CPU_MAXID		7	/* 6 valid machdep IDs */
d328 1
@


1.10
log
@machine/alpha.h is only included in cpu.h and the name gives
a collision in gcc build. merge alpha.h into cpu.h
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.9 2000/11/08 21:27:18 ericj Exp $ */
a331 2

int	badaddr(void *, size_t);
@


1.9
log
@tag the rest of alpha tree
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.45 2000/08/21 02:03:12 thorpej Exp $ */
d91 1
a91 1
#include <machine/alpha.h>
d94 62
a155 1
#include <machine/frame.h>
@


1.8
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
@


1.7
log
@Recognize that a symbol table may exist, move up proc0paddr if so.
@
text
@d1 38
a38 2
/*	$OpenBSD: cpu.h,v 1.6 1997/01/24 19:57:10 niklas Exp $	*/
/*	$NetBSD: cpu.h,v 1.14 1996/12/07 01:54:50 cgd Exp $	*/
d89 4
d96 68
d167 2
a168 1
#define	cpu_wait(p)			/* nothing */
d183 1
d185 3
a187 2
 * XXX No way to accurately tell if we were in interrupt mode before taking
 * clock interrupt.
d189 1
a189 1
#define	CLKF_INTR(framep)	(0)
d194 3
d198 5
a202 1
#define	need_resched()	{ want_resched = 1; aston(); }
d206 1
a206 1
 * buffer pages are invalid.  On the hp300, request an ast to send us
d209 13
a221 1
#define	need_proftick(p)	{ (p)->p_flag |= P_OWEUPC; aston(); }
d227 5
a231 6
#define	signotify(p)	aston()

#define	aston()		(astpending = 1)

u_int64_t astpending;		/* need to trap before returning to user mode */
u_int64_t want_resched;		/* resched() was called */
d233 8
d271 1
a271 37
extern int cold;
extern struct proc *fpcurproc;
extern struct rpb *hwrpb;

void	XentArith __P((u_int64_t, u_int64_t, u_int64_t));	/* MAGIC */
void	XentIF __P((u_int64_t, u_int64_t, u_int64_t));		/* MAGIC */
void	XentInt __P((u_int64_t, u_int64_t, u_int64_t));		/* MAGIC */
void	XentMM __P((u_int64_t, u_int64_t, u_int64_t));		/* MAGIC */
void	XentRestart __P((void));				/* MAGIC */
void	XentSys __P((u_int64_t, u_int64_t, u_int64_t));		/* MAGIC */
void	XentUna __P((u_int64_t, u_int64_t, u_int64_t));		/* MAGIC */
void	alpha_init __P((u_long, u_long, char *));
void	ast __P((struct trapframe *));
int	badaddr	__P((void *, size_t));
void	child_return __P((struct proc *p));
void	configure __P((void));
u_int64_t console_restart __P((u_int64_t, u_int64_t, u_int64_t));
void	do_sir __P((void));
void	dumpconf __P((void));
void	exception_return __P((void));				/* MAGIC */
void	frametoreg __P((struct trapframe *, struct reg *));
long	fswintrberr __P((void));				/* MAGIC */
void	init_prom_interface __P((void));
void	interrupt __P((unsigned long, unsigned long, unsigned long,
	    struct trapframe *));
u_int64_t hwrpb_checksum __P((void));
void	hwrpb_restart_setup __P((void));
void	regdump __P((struct trapframe *));
void	regtoframe __P((struct reg *, struct trapframe *));
void	savectx __P((struct pcb *));
void	set_clockintr __P((void));
void	set_iointr __P((void (*)(void *, unsigned long)));
void    switch_exit __P((struct proc *));			/* MAGIC */
void	switch_trampoline __P((void));				/* MAGIC */
void	syscall __P((u_int64_t, struct trapframe *));
void	trap __P((unsigned long, unsigned long, unsigned long, unsigned long,
	    struct trapframe *));
a273 1

@


1.7.12.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 39
/* $OpenBSD: cpu.h,v 1.11 2001/02/12 11:12:35 art Exp $ */
/* $NetBSD: cpu.h,v 1.45 2000/08/21 02:03:12 thorpej Exp $ */

/*-
 * Copyright (c) 1998, 1999, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
a52 1
#include <machine/alpha_cpu.h>
a54 132
#ifdef _KERNEL

#include <machine/bus.h>

struct pcb;
struct proc;
struct reg;
struct rpb;
struct trapframe;

extern int bootdev_debug;

void	XentArith(u_int64_t, u_int64_t, u_int64_t);		/* MAGIC */
void	XentIF(u_int64_t, u_int64_t, u_int64_t);		/* MAGIC */
void	XentInt(u_int64_t, u_int64_t, u_int64_t);		/* MAGIC */
void	XentMM(u_int64_t, u_int64_t, u_int64_t);		/* MAGIC */
void	XentRestart(void);					/* MAGIC */
void	XentSys(u_int64_t, u_int64_t, u_int64_t);		/* MAGIC */
void	XentUna(u_int64_t, u_int64_t, u_int64_t);		/* MAGIC */
void	alpha_init(u_long, u_long, u_long, u_long, u_long);
int	alpha_pa_access(u_long);
void	ast(struct trapframe *);
int	badaddr(void *, size_t);
int	badaddr_read(void *, size_t, void *);
void	child_return(void *);
u_int64_t console_restart(struct trapframe *);
void	do_sir(void);
void	dumpconf(void);
void	exception_return(void);					/* MAGIC */
void	frametoreg(struct trapframe *, struct reg *);
long	fswintrberr(void);					/* MAGIC */
void	init_bootstrap_console(void);
void	init_prom_interface(struct rpb *);
void	interrupt(unsigned long, unsigned long, unsigned long,
	    struct trapframe *);
void	machine_check(unsigned long, struct trapframe *, unsigned long,
	    unsigned long);
u_int64_t hwrpb_checksum(void);
void	hwrpb_restart_setup(void);
void	regdump(struct trapframe *);
void	regtoframe(struct reg *, struct trapframe *);
void	savectx(struct pcb *);
void    switch_exit(struct proc *);				/* MAGIC */
void	switch_trampoline(void);				/* MAGIC */
void	syscall(u_int64_t, struct trapframe *);
void	trap(unsigned long, unsigned long, unsigned long, unsigned long,
	    struct trapframe *);
void	trap_init(void);
void	enable_nsio_ide(bus_space_tag_t);
char *	dot_conv(unsigned long);

void	release_fpu(int);
void	synchronize_fpstate(struct proc *, int);

/* Multiprocessor glue; cpu.c */
struct cpu_info;
int	cpu_iccb_send(long, const char *);
void	cpu_iccb_receive(void);
void	cpu_hatch(struct cpu_info *);
void	cpu_halt_secondary(unsigned long);
void	cpu_spinup_trampoline(void);				/* MAGIC */
void	cpu_pause(unsigned long);
void	cpu_resume(unsigned long);

/*
 * Machine check information.
 */
struct mchkinfo {
	__volatile int mc_expected;	/* machine check is expected */
	__volatile int mc_received;	/* machine check was received */
};

typedef long cpuid_t;

struct cpu_info {
	/*
	 * Public members.
	 */
#if defined(DIAGNOSTIC) || defined(LOCKDEBUG)
	u_long ci_spin_locks;		/* # of spin locks held */
	u_long ci_simple_locks;		/* # of simple locks held */
#endif
	struct proc *ci_curproc;	/* current owner of the processor */

	/*
	 * Private members.
	 */
	struct mchkinfo ci_mcinfo;	/* machine check info */
	cpuid_t ci_cpuid;		/* our CPU ID */
	struct proc *ci_fpcurproc;	/* current owner of the FPU */
	paddr_t ci_curpcb;		/* PA of current HW PCB */
	struct pcb *ci_idle_pcb;	/* our idle PCB */
	paddr_t ci_idle_pcb_paddr;	/* PA of idle PCB */
	struct cpu_softc *ci_softc;	/* pointer to our device */
	u_long ci_want_resched;		/* preempt current process */
	u_long ci_astpending;		/* AST is pending */
	u_long ci_intrdepth;		/* interrupt trap depth */
#if defined(MULTIPROCESSOR)
	u_long ci_flags;		/* flags; see below */
	u_long ci_ipis;			/* interprocessor interrupts pending */
#endif
};

#define	CPUF_PRIMARY	0x01		/* CPU is primary CPU */
#define	CPUF_PRESENT	0x02		/* CPU is present */
#define	CPUF_RUNNING	0x04		/* CPU is running */

#if defined(MULTIPROCESSOR)
extern	__volatile u_long cpus_running;
extern	__volatile u_long cpus_paused;
extern	struct cpu_info cpu_info[];

#define	curcpu()		((struct cpu_info *)alpha_pal_rdval())
#define	CPU_IS_PRIMARY(ci)	((ci)->ci_flags & CPUF_PRIMARY)

void	cpu_boot_secondary_processors(void);

void	cpu_pause_resume(unsigned long, int);
void	cpu_pause_resume_all(int);
#else /* ! MULTIPROCESSOR */
extern	struct cpu_info cpu_info_store;

#define	curcpu()	(&cpu_info_store)
#endif /* MULTIPROCESSOR */

#define	curproc		curcpu()->ci_curproc
#define	fpcurproc	curcpu()->ci_fpcurproc
#define	curpcb		curcpu()->ci_curpcb

extern	u_long cpu_implver;		/* from IMPLVER instruction */
extern	u_long cpu_amask;		/* from AMASK instruction */

d59 1
a59 2
#define	cpu_wait(p)		/* nothing */
#define	cpu_number()		alpha_pal_whami()
a73 1

d75 2
a76 3
 * This isn't perfect; if the clock interrupt comes in before the
 * r/m/w cycle is complete, we won't be counted... but it's not
 * like this stastic has to be extremely accurate.
d78 1
a78 1
#define	CLKF_INTR(framep)	(curcpu()->ci_intrdepth)
a82 3
 *
 * XXXSMP
 * need_resched() needs to take a cpu_info *.
d84 1
a84 5
#define	need_resched()							\
do {									\
	curcpu()->ci_want_resched = 1;					\
	aston(curcpu());						\
} while (/*CONSTCOND*/0)
d88 1
a88 1
 * buffer pages are invalid.  On the Alpha, request an AST to send us
d91 1
a91 13
#ifdef notyet
#define	need_proftick(p)						\
do {									\
	(p)->p_flag |= P_OWEUPC;					\
	aston((p)->p_cpu);						\
} while (/*CONSTCOND*/0)
#else
#define	need_proftick(p)						\
do {									\
	(p)->p_flag |= P_OWEUPC;					\
	aston(curcpu());						\
} while (/*CONSTCOND*/0)
#endif
d97 6
a102 5
#ifdef notyet
#define	signotify(p)	aston((p)->p_cpu)
#else
#define signotify(p)	aston(curcpu())
#endif
a103 8
/*
 * XXXSMP
 * Should we send an AST IPI?  Or just let it handle it next time
 * it sees a normal kernel entry?  I guess letting it happen later
 * follows the `asynchronous' part of the name...
 */
#define	aston(ci)	((ci)->ci_astpending = 1)
#endif /* _KERNEL */
d134 38
d173 1
@


1.7.12.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.7.12.1 2001/04/18 16:00:48 niklas Exp $ */
d313 1
a313 7
#define CPU_CHIPSET		7	/* chipset information */
#define	CPU_MAXID		8	/* 6 valid machdep IDs */

#define CPU_CHIPSET_MEM		1	/* PCI memory address */
#define CPU_CHIPSET_BWX		2	/* PCI supports BWX */
#define CPU_CHIPSET_TYPE	3	/* PCI chipset name */
#define CPU_CHIPSET_DENSE	4	/* PCI chipset dense memory addr */
a322 1
	{ "chipset", CTLTYPE_NODE }, \
@


1.7.12.3
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d117 1
a319 2
#define CPU_CHIPSET_PORTS	5	/* PCI port address */
#define CPU_CHIPSET_HAE_MASK	6	/* PCI chipset mask for HAE register */
@


1.7.12.4
log
@A bit on the way to make GENERIC compile in the SMP branch.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.7.12.3 2001/11/13 21:00:49 niklas Exp $ */
a95 1
#include <sys/device.h>
d164 2
a166 1
	struct device *ci_dev;		/* pointer to our device */
a174 2
	struct simplelock ci_slock;	/* lock on this data structure */
	cpuid_t ci_cpuid;		/* our CPU ID */
d180 1
@


1.7.12.5
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a85 16
#ifndef NO_IEEE
typedef union alpha_s_float {
	u_int32_t i;
	u_int32_t frac: 23,
		exp:   8,
		sign:  1;
} s_float;

typedef union alpha_t_float {
	u_int64_t i;
	u_int64_t frac: 52,
		exp:  11,
		sign:  1;
} t_float;
#endif

a103 2
extern u_long cpu_implver;		/* from IMPLVER instruction */
extern u_long cpu_amask;		/* from AMASK instruction */
a104 2
extern int alpha_fp_sync_complete;
extern int alpha_unaligned_print, alpha_unaligned_fix, alpha_unaligned_sigbus;
a198 5
#define	CPUF_PAUSED	0x08		/* CPU is paused */
#define	CPUF_FPUSAVE	0x10		/* CPU is currently in fpusave_cpu() */

void	fpusave_cpu(struct cpu_info *, int);
void	fpusave_proc(struct proc *, int);
d222 3
d242 2
d313 2
a314 5
#define	CPU_FP_SYNC_COMPLETE	7	/* int: always fixup sync fp traps */
#define CPU_CHIPSET		8	/* chipset information */
#define CPU_ALLOWAPERTURE         9

#define	CPU_MAXID		10	/* valid machdep IDs */
a321 1
#define CPU_CHIPSET_MAXID	7
a330 1
	{ "fp_sync_complete", CTLTYPE_INT }, \
a331 11
	{ "allowaperture", CTLTYPE_INT }, \
}

#define CTL_CHIPSET_NAMES { \
	{ 0, 0 }, \
	{ "memory", CTLTYPE_QUAD }, \
	{ "bwx", CTLTYPE_INT }, \
	{ "type", CTLTYPE_STRING }, \
	{ "dense_base", CTLTYPE_QUAD }, \
	{ "ports_base", CTLTYPE_QUAD }, \
	{ "hae_mask", CTLTYPE_QUAD }, \
a340 19

/* IEEE and VAX FP completion */

#ifndef NO_IEEE
void alpha_sts(int, s_float *);					/* MAGIC */
void alpha_stt(int, t_float *);					/* MAGIC */
void alpha_lds(int, s_float *);					/* MAGIC */
void alpha_ldt(int, t_float *);					/* MAGIC */

uint64_t alpha_read_fpcr(void);					/* MAGIC */
void alpha_write_fpcr(u_int64_t);				/* MAGIC */

u_int64_t alpha_read_fp_c(struct proc *);
void alpha_write_fp_c(struct proc *, u_int64_t);

int alpha_fp_complete(u_long, u_long, struct proc *, u_int64_t *);
#endif

void alpha_enable_fp(struct proc *, int);
@


1.7.12.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.7.12.5 2003/03/27 23:18:06 niklas Exp $ */
d58 5
a62 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.12.7
log
@Merge of -current from two weeks ago into the SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d158 1
@


1.7.12.8
log
@need_resched macro needs to take ci arg to be compat with MP function
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.7.12.7 2004/02/19 09:59:34 niklas Exp $ */
d271 3
d275 1
a275 1
#define	need_resched(ci)						\
d277 1
a277 1
	ci->ci_want_resched = 1;					\
@


1.7.12.9
log
@repair
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.7.12.8 2004/06/06 05:23:38 tedu Exp $ */
a271 1
#ifdef MULTIPROCESSOR
a276 7
#else
#define	need_resched(ci)						\
do {									\
	curcpu()->ci_want_resched = 1;					\
	aston(curcpu());						\
} while (/*CONSTCOND*/0)
#endif
@


1.7.12.10
log
@sync to head
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d164 1
a164 1
int	cpu_iccb_send(cpuid_t, const char *);
@


1.6
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.5 1996/10/30 22:38:58 niklas Exp $	*/
d145 1
a145 1
void	alpha_init __P((u_long, u_long));
@


1.5
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 2
a2 2
/*	$OpenBSD: cpu.h,v 1.12 1996/07/14 04:15:10 cgd Exp $	*/
/*	$NetBSD: cpu.h,v 1.12 1996/07/14 04:15:10 cgd Exp $	*/
d113 2
a114 1
#define	CPU_MAXID		6	/* 5 valid machdep IDs */
d123 1
d125 48
@


1.4
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: cpu.h,v 1.7.4.1 1996/06/14 20:42:44 cgd Exp $	*/
/*	$NetBSD: cpu.h,v 1.7.4.1 1996/06/14 20:42:44 cgd Exp $	*/
d69 5
a73 3
#define	CLKF_USERMODE(framep)	(((framep)->cf_tf.tf_ps & PSL_U) != 0)
#define	CLKF_BASEPRI(framep)	(((framep)->cf_tf.tf_ps & PSL_IPL) == 0)
#define	CLKF_PC(framep)		((framep)->cf_tf.tf_pc)
a105 12
 * simulated software interrupt register
 */
extern u_int64_t ssir;

#define	SIR_NET		0x1
#define	SIR_CLOCK	0x2

#define	siroff(x)	ssir &= ~(x)
#define	setsoftnet()	ssir |= SIR_NET
#define	setsoftclock()	ssir |= SIR_CLOCK

/*
d110 4
a113 1
#define	CPU_MAXID		3	/* number of valid machdep ids */
d119 3
@


1.3
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.2
log
@from netbsd; cpu_setstack() is depricated
@
text
@d1 1
a1 1
/*	$NetBSD: cpu.h,v 1.7 1995/12/21 05:01:32 mycroft Exp $	*/
d118 2
a119 1
#define	CPU_MAXID		2	/* number of valid machdep ids */
d124 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: cpu.h,v 1.6 1995/06/28 02:55:18 cgd Exp $	*/
a58 1
#define	cpu_setstack(p, ap)		(p)->p_addr->u_pcb.pcb_usp
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
