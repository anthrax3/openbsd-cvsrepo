head	1.24;
access;
symbols
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.24.0.8
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.4
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.23.0.36
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.28
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.23.0.32
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.30
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.26
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.24
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.22
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.20
	OPENBSD_5_0:1.23.0.18
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.16
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.14
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.10
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.12
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.8
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.6
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.4
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.2
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.12.0.30
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.28
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.26
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.24
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.22
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.20
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.18
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.16
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.14
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.12.0.12
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.10
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.12.0.8
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.12.0.6
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.4
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.2
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.11.0.4
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.10.0.4
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2015.09.30.14.57.03;	author krw;	state Exp;
branches;
next	1.23;
commitid	DqSeHy1IhaIjFHPj;

1.23
date	2007.06.20.18.15.43;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.17.15.05.08;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.17.00.27.24;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.10.05.42.48;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2006.10.20.23.47.42;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2006.10.18.20.09.38;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2006.10.17.23.42.37;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2006.10.04.00.52.55;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2006.07.09.21.00.17;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2006.06.19.01.52.19;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.11.21.15.35;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	99.12.04.03.35.55;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	99.03.23.16.36.16;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.02.24.04.22.35;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.02.19.20.36.28;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.01.11.20.41.57;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	97.09.29.18.55.04;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.08.08.22.01.09;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.06.30.11.50.58;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	97.04.07.06.21.37;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.10.30.22.38.59;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.07.29.22.58.37;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.42;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.42;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Use consistant whitespace/comments for #define'ing LABELSECTOR,
LABELOFFSET and MAXPARTITIONS. Easier on the eye when scanning
through all these files. No functional change.
@
text
@/*	$OpenBSD: disklabel.h,v 1.23 2007/06/20 18:15:43 deraadt Exp $	*/

/*
 * Copyright (c) 1994 Christopher G. Demetriou
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _MACHINE_DISKLABEL_H_
#define _MACHINE_DISKLABEL_H_

#define	LABELSECTOR	0	/* sector containing label */
#define	LABELOFFSET	64	/* offset of label in sector */
#define	MAXPARTITIONS	16	/* number of partitions */

#endif /* _MACHINE_DISKLABEL_H_ */
@


1.23
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.22 2007/06/17 15:05:08 krw Exp $	*/
d36 3
a38 3
#define LABELSECTOR		0
#define LABELOFFSET		64
#define	MAXPARTITIONS		16		/* number of partitions */
@


1.22
log
@Eliminate a few straggling 'labelsector' field declarations from
cpu_disklabel's.  'labelsector' is not used anywhere according to grep.

'go for it' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.21 2007/06/17 00:27:24 deraadt Exp $	*/
a38 3

struct cpu_disklabel {
};
@


1.21
log
@significantly simplified disklabel infrastructure.  MBR handling becomes MI
to support hotplug media on most architectures.  disklabel setup and
verification done using new helper functions.  Disklabels must *always*
have a correct checksum now.  Same code paths are used to learn on-disk
location disklabels, to avoid new errors sneaking in.  Tested on almost all
cases, testing help from todd, kettenis, krw, otto, dlg, robert, gwk, drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.20 2007/06/10 05:42:48 krw Exp $	*/
a40 1
	int labelsector;
@


1.20
log
@No need for two *LABELSECTOR and *LABELOFFSET defines that mean the
same thing.  Keep LABELSECTOR and LABELOFFSET and nuke
ALPHA_LABELSECTOR and ALPHA_LABELOFFSET.

Kernel still compiles and boots.

Superfluidity pointed out by deraadt@@.
@
text
@d1 1
a1 2
/*	$OpenBSD: disklabel.h,v 1.19 2006/10/20 23:47:42 krw Exp $	*/
/*	$NetBSD: disklabel.h,v 1.1 1995/02/13 23:07:34 cgd Exp $	*/
a35 3
#define	I386_LABELSECTOR	1		/* sector containing label */
#define	I386_LABELOFFSET	0		/* offset of label in sector */

a37 1

a38 42
#define	RAW_PART		2		/* raw partition: xx?c */

/* DOS partition table -- located in boot block */
#define	DOSBBSECTOR	0		/* DOS boot block relative sector # */
#define	DOSPARTOFF	446
#define DOSACTIVE	0x80
#define	NDOSPART	4
#define DOSMBR_SIGNATURE 0xaa55
#define DOSMBR_SIGNATURE_OFF 0x1fe

struct dos_partition {
	u_int8_t	dp_flag;	/* bootstrap flags */
	u_int8_t	dp_shd;		/* starting head */
	u_int8_t	dp_ssect;	/* starting sector */
	u_int8_t	dp_scyl;	/* starting cylinder */
	u_int8_t	dp_typ;		/* partition type (see below) */
	u_int8_t	dp_ehd;		/* end head */
	u_int8_t	dp_esect;	/* end sector */
	u_int8_t	dp_ecyl;	/* end cylinder */
	u_int32_t	dp_start;	/* absolute starting sector number */
	u_int32_t	dp_size;	/* partition size in sectors */
};

/* Known DOS partition types. */
#define	DOSPTYP_UNUSED	0x00		/* Unused partition */
#define DOSPTYP_FAT12	0x01		/* 12-bit FAT */
#define DOSPTYP_FAT16S	0x04		/* 16-bit FAT, less than 32M */
#define DOSPTYP_EXTEND	0x05		/* Extended; contains sub-partitions */
#define DOSPTYP_FAT16B	0x06		/* 16-bit FAT, more than 32M */
#define DOSPTYP_FAT32	0x0b		/* 32-bit FAT */
#define DOSPTYP_FAT32L	0x0c		/* 32-bit FAT, LBA-mapped */
#define DOSPTYP_FAT16L	0x0e		/* 16-bit FAT, LBA-mapped */
#define DOSPTYP_EXTENDL 0x0f		/* Extended, LBA-mapped; contains sub-partitions */
#define DOSPTYP_ONTRACK	0x54
#define	DOSPTYP_LINUX	0x83		/* That other thing */
#define DOSPTYP_FREEBSD	0xa5		/* FreeBSD partition type */
#define DOSPTYP_OPENBSD	0xa6		/* OpenBSD partition type */
#define DOSPTYP_NETBSD	0xa9		/* NetBSD partition type */

/* Isolate the relevant bits to get sector and cylinder. */
#define	DPSECT(s)	((s) & 0x3f)
#define	DPCYL(c, s)	((c) + (((s) & 0xc0) << 2))
@


1.19
log
@Try again with local variable to avoid alignment issues.

"The dosparts member of cpu_disklabel was not used for any persistant
data. Eliminate it, and just use the data being read in while
processing MBR and EBR records.

Should be no functional change.

ok weingart@@ deraadt@@"
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.18 2006/10/18 20:09:38 deraadt Exp $	*/
a36 2
#define	ALPHA_LABELSECTOR	0		/* sector containing label */
#define	ALPHA_LABELOFFSET	64		/* offset of label in sector */
d40 2
a41 2
#define LABELSECTOR		ALPHA_LABELSECTOR
#define LABELOFFSET		ALPHA_LABELOFFSET
@


1.18
log
@back out disksubr changes ... since they violate strict alignment on
some architectures (kaboom); that will be fixed in the next iteration
hopefully!
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.16 2006/10/04 00:52:55 krw Exp $	*/
a90 7
	union {
		struct {
		} _alpha;
		struct {
			struct dos_partition dosparts[NDOSPART];
		} _i386;
	} u;
@


1.17
log
@The dosparts member of cpu_disklabel was not used for any persistant
data. Eliminate it, and just use the data being read in while
processing MBR and EBR records.

Should be no functional change.

ok weingart@@ deraadt@@
@
text
@d91 7
@


1.16
log
@Zap bad144 bad sector info in disklabels. Sparsely used if at all for
a few obsolete and easily replaced disk models. And didn't work anyway
according to Bob, who has tried.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.15 2006/07/09 21:00:17 krw Exp $	*/
a90 7
	union {
		struct {
		} _alpha;
		struct {
			struct dos_partition dosparts[NDOSPART];
		} _i386;
	} u;
@


1.15
log
@Remove DLT_* logic from Alpha as well, being careful to keep the
checksumming of the native disklabel.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.14 2006/06/19 01:52:19 krw Exp $	*/
a88 1
#include <sys/dkbad.h>
a95 1
			struct dkbad bad;
a98 2

#define DKBAD(x) ((x)->u._i386.bad)
@


1.14
log
@Zap Amiga bits of disklabel.h now that Amiga bits of readdisklabel() are
gone.

'go ahead' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.13 2006/06/11 21:15:35 krw Exp $	*/
a36 9
enum disklabel_tag { DLT_ALPHA, DLT_I386 };

/*
 * What disklabels are we probing for, and in which order?
 */
#ifndef LABELPROBES
#define LABELPROBES		DLT_ALPHA, DLT_I386
#endif

a90 1
	enum disklabel_tag labeltag;
@


1.13
log
@Amiga is no longer amoung us. Some architectures were too sentimental
to cut all ties when it left for the attic. Eliminate (theoretical)
ability to read Amiga disklabels on those architectures.

mips64 compile tested by miod@@

"whack away" deraadt@@ "my amiga runs 3.2" niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.12 1999/12/04 03:35:55 deraadt Exp $	*/
a96 158

/*
 * describes ados Rigid Disk Blocks
 * which are used to partition a drive
 */
#define RDBNULL ((u_int32_t)0xffffffff)

/*
 * you will find rdblock somewhere in [0, RDBMAXBLOCKS)
 */
#define RDB_MAXBLOCKS	16

struct rdblock {
	u_int32_t id;		/* 'RDSK' */
	u_int32_t nsumlong;	/* number of longs in check sum */
	u_int32_t chksum;	/* simple additive with wrap checksum */
	u_int32_t hostid;	/* scsi target of host */
	u_int32_t nbytes;	/* size of disk blocks */
	u_int32_t flags;
	u_int32_t badbhead;	/* linked list of badblocks */
	u_int32_t partbhead;	/* linked list of partblocks */
	u_int32_t fsbhead;	/*   "     "   of fsblocks */
	u_int32_t driveinit;
	u_int32_t resv1[6];	/* RDBNULL */
	u_int32_t ncylinders;	/* number of cylinders on drive */
	u_int32_t nsectors;	/* number of sectors per track */
	u_int32_t nheads;	/* number of tracks per cylinder */
	u_int32_t interleave;
	u_int32_t park;		/* only used with st506 i.e. not */
	u_int32_t resv2[3];
	u_int32_t wprecomp;	/* start cyl for write precomp */
	u_int32_t reducedwrite;	/* start cyl for reduced write current */
	u_int32_t steprate;	/* driver step rate in ?s */
	u_int32_t resv3[5];
	u_int32_t rdblowb;	/* lowblock of range for rdb's */
	u_int32_t rdbhighb;	/* high block of range for rdb's */
	u_int32_t lowcyl;	/* low cylinder of partition area */
	u_int32_t highcyl;	/* upper cylinder of partition area */
	u_int32_t secpercyl;	/* number of sectors per cylinder */
	u_int32_t parkseconds;	/* zero if no park needed */
	u_int32_t resv4[2];
	char   diskvendor[8];	/* inquiry stuff */
	char   diskproduct[16];	/* inquiry stuff */
	char   diskrevision[4];	/* inquiry stuff */
	char   contvendor[8];	/* inquiry stuff */
	char   contproduct[16];	/* inquiry stuff */
	char   contrevision[4];	/* inquiry stuff */
#if never_use_secsize
	u_int32_t resv5[0];
#endif
};


#define RDBF_LAST	0x1	/* last drive available */
#define RDBF_LASTLUN	0x2	/* last LUN available */
#define RDBF_LASTUNIT	0x4	/* last target available */
#define RDBF_NORESELECT	0x8	/* do not use reselect */
#define RDBF_DISKID	0x10	/* disk id is valid ?? */
#define RDBF_CTRLID	0x20	/* ctrl id is valid ?? */
#define RDBF_SYNC	0x40	/* drive supports SCSI synchronous mode */
	
struct ados_environ {
	u_int32_t tabsize;	/* 0: environ table size */
	u_int32_t sizeblock;	/* 1: n long words in a block */
	u_int32_t secorg;	/* 2: not used must be zero */
	u_int32_t numheads;	/* 3: number of surfaces */
	u_int32_t secperblk;	/* 4: must be 1 */
	u_int32_t secpertrk;	/* 5: blocks per track */
	u_int32_t resvblocks;	/* 6: reserved blocks at start */
	u_int32_t prefac;	/* 7: must be 0 */
	u_int32_t interleave;	/* 8: normally 1 */
	u_int32_t lowcyl;	/* 9: low cylinder of partition */
	u_int32_t highcyl;	/* 10: upper cylinder of partition */
	u_int32_t numbufs;	/* 11: ados: number of buffers */
	u_int32_t membuftype;	/* 12: ados: type of bufmem */
	u_int32_t maxtrans;	/* 13: maxtrans the ctrlr supports */
	u_int32_t mask;		/* 14: mask for valid address */
	u_int32_t bootpri;	/* 15: boot priority for autoboot */
	u_int32_t dostype;	/* 16: filesystem type */
	u_int32_t baud;		/* 17: serial handler baud rate */
	u_int32_t control;	/* 18: control word for fs */
	u_int32_t bootblocks;	/* 19: blocks containing boot code */
	u_int32_t fsize;	/* 20: file system block size */
	u_int32_t frag;		/* 21: allowable frags per block */
	u_int32_t cpg;		/* 22: cylinders per group */
};

struct partblock {
	u_int32_t id;		/* 'PART' */
	u_int32_t nsumlong;	/* number of longs in check sum */
	u_int32_t chksum;	/* simple additive with wrap checksum */
	u_int32_t hostid;	/* scsi target of host */
	u_int32_t next;		/* next in chain */
	u_int32_t flags;	/* see below */
	u_int32_t resv1[3];
	u_char partname[32];	/* (BCPL) part name (may not be unique) */
	u_int32_t resv2[15];
	struct ados_environ e;
#if never_use_secsize
	u_int32_t extra[9];	/* 8 for extra added to environ */
#endif
};

#define PBF_BOOTABLE	0x1	/* partition is bootable */
#define PBF_NOMOUNT	0x2	/* partition should be mounted */

struct badblock {
	u_int32_t id;		/* 'BADB' */
	u_int32_t nsumlong;	/* number of longs in check sum */
	u_int32_t chksum;	/* simple additive with wrap checksum */
	u_int32_t hostid;	/* scsi target of host */
	u_int32_t next;		/* next in chain */
	u_int32_t resv;
	struct badblockent {
		u_int32_t badblock;
		u_int32_t goodblock;
	} badtab[0];		/* 61 for secsize == 512 */
};

struct fsblock {
	u_int32_t id;		/* 'FSHD' */
	u_int32_t nsumlong;	/* number of longs in check sum */
	u_int32_t chksum;	/* simple additive with wrap checksum */
	u_int32_t hostid;	/* scsi target of host */
	u_int32_t next;		/* next in chain */
	u_int32_t flags;
	u_int32_t resv1[2];
	u_int32_t dostype;	/* this is a file system for this type */
	u_int32_t version;	/* version of this fs */
	u_int32_t patchflags;	/* describes which functions to replace */
	u_int32_t type;		/* zero */
	u_int32_t task;		/* zero */
	u_int32_t lock;		/* zero */
	u_int32_t handler;	/* zero */
	u_int32_t stacksize;	/* to use when loading handler */
	u_int32_t priority;	/* to run the fs at. */
	u_int32_t startup;	/* zero */
	u_int32_t lsegblocks;	/* linked list of lsegblocks of fs code */
	u_int32_t globalvec;	/* bcpl vector not used mostly */
#if never_use_secsize
	u_int32_t resv2[44];
#endif
};

struct lsegblock {
	u_int32_t id;		/* 'LSEG' */
	u_int32_t nsumlong;	/* number of longs in check sum */
	u_int32_t chksum;	/* simple additive with wrap checksum */
	u_int32_t hostid;	/* scsi target of host */
	u_int32_t next;		/* next in chain */
	u_int32_t loaddata[0];	/* load segment data, 123 for secsize == 512 */
};

#define RDBLOCK_ID	0x5244534b	/* 'RDSK' */
#define PARTBLOCK_ID	0x50415254	/* 'PART' */
#define BADBLOCK_ID	0x42414442	/* 'BADB' */
#define FSBLOCK_ID	0x46534844	/* 'FSHD' */
#define LSEGBLOCK_ID	0x4c534547	/* 'LSEG' */
@


1.12
log
@DOSPTYP_EXTENDL; sigh@@kuzirabekon.econ.nagasaki-u.ac.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.11 1999/03/23 16:36:16 millert Exp $	*/
d37 1
a37 1
enum disklabel_tag { DLT_ALPHA, DLT_I386, DLT_AMIGA };
d43 1
a43 1
#define LABELPROBES		DLT_ALPHA, DLT_I386, DLT_AMIGA
a49 2
#define	AMIGA_LABELSECTOR	0		/* sector containing label */
#define	AMIGA_LABELOFFSET	64		/* offset of label in sector */
a266 6
		struct {
			u_int32_t rdblock;		/* RDBNULL -> inval. */
			u_int32_t pblist[MAXPARTITIONS];/* pblock number */
			int pbindex[MAXPARTITIONS];	/* index of pblock */
			int valid;			/* valid? */
		} _amiga;
@


1.11
log
@Add DOSMBR_SIGNATURE_OFF define, needed for last disklabel change
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.10 1998/02/24 04:22:35 deraadt Exp $	*/
d89 1
@


1.10
log
@rename some DOS MBR partition types
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.9 1998/02/19 20:36:28 deraadt Exp $	*/
d65 1
@


1.9
log
@add netbsd partition, rename 386BSD one to FreeBSD..
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.8 1998/01/11 20:41:57 provos Exp $	*/
d86 2
a87 1
#define DOSPTYP_FAT16C	0x0e		/* 16-bit FAT, CHS-mapped */
@


1.8
log
@disklabel spoofing for FAT32.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.7 1997/09/29 18:55:04 deraadt Exp $	*/
d89 1
a89 2
#define DOSPTYP_386BSD	0xa5		/* 386BSD partition type */
#define DOSPTYP_NETBSD	DOSPTYP_386BSD	/* NetBSD partition type (XXX) */
d91 1
@


1.7
log
@DOSMBR_SIGNATURE, DOSACTIVE; weingart
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.6 1997/08/08 22:01:09 niklas Exp $	*/
d85 1
@


1.6
log
@Use the new bounds_check_with_label API.  Add generic support for reading
both little and big endian BSD disklabels.  Add a specific hook to read such
a big-endian disklabel as it is found on amiga (normally, however, amiga
uses the native RDB format, which still is not supported).
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.5 1997/06/30 11:50:58 niklas Exp $	*/
d62 1
d64 1
@


1.5
log
@Add MBR & i386/disklabel probing in a generic fashion usable for more
disklabel types, and for other architectures if they chose.  Both read/write
supported for both alpha and i386/arc disklabels.  ISO9660 spoofing kept
and tested.  Add "option DISKLABEL_ALL" to your config to use.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.4 1997/04/07 06:21:37 millert Exp $	*/
d37 1
a37 1
enum disklabel_tag { DLT_ALPHA, DLT_I386 };
d43 1
a43 1
#define LABELPROBES		DLT_ALPHA, DLT_I386
d50 2
a89 6
#include <sys/dkbad.h>
struct cpu_disklabel {
	struct dos_partition dosparts[NDOSPART];
	struct dkbad bad;
};

d94 99
a192 3
#ifdef _KERNEL
struct disklabel;
int	bounds_check_with_label __P((struct buf *, struct disklabel *, int));
d194 79
@


1.4
log
@16 partitions
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.3 1996/10/30 22:38:59 niklas Exp $	*/
d37 1
a37 4
#define	LABELSECTOR	0			/* sector containing label */
#define	LABELOFFSET	64			/* offset of label in sector */
#define	MAXPARTITIONS	16			/* number of partitions */
#define	RAW_PART	2			/* raw partition: xx?c */
d39 50
a88 1
/* Just a dummy */
d90 2
a91 1
	int	cd_dummy;			/* must have one element. */
d93 4
@


1.3
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.1 1995/02/13 23:07:34 cgd Exp $	*/
d39 1
a39 1
#define	MAXPARTITIONS	8			/* number of partitions */
d46 5
@


1.2
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
