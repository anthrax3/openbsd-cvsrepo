head	1.13;
access;
symbols
	OPENBSD_6_2_BASE:1.13
	OPENBSD_6_1:1.13.0.6
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.2
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.12.0.6
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.8
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.11.0.10
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.6
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.4
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.2
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.4
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.9.0.10
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.8
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.4
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.8.0.24
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.22
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.20
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.18
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.16
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.14
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.12
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.10
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.8
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.6
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.4
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.8
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.7
	UBC:1.6.0.6
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.4.0.12
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.10
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.8
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.6
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.13
date	2016.05.15.23.37.42;	author guenther;	state Exp;
branches;
next	1.12;
commitid	Hg9xYq6uyjPNjU8k;

1.12
date	2014.03.29.18.09.28;	author guenther;	state Exp;
branches;
next	1.11;

1.11
date	2012.06.26.01.59.47;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2011.03.23.16.54.33;	author pirofti;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.17.18.30.08;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.26.01.35.23;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.10.10.14.48;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.08.21.27.15;	author ericj;	state Exp;
branches
	1.6.6.1;
next	1.5;

1.5
date	2000.11.08.16.01.09;	author art;	state Exp;
branches;
next	1.4;

1.4
date	98.06.05.13.28.32;	author janjaap;	state Exp;
branches
	1.4.8.1;
next	1.3;

1.3
date	97.08.01.21.22.42;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.01.24.19.57.05;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.10.30.22.38.49;	author niklas;	state Exp;
branches;
next	;

1.4.8.1
date	2001.04.18.16.00.45;	author niklas;	state Exp;
branches;
next	1.4.8.2;

1.4.8.2
date	2003.03.27.23.18.06;	author niklas;	state Exp;
branches;
next	;

1.6.6.1
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	1.6.6.2;

1.6.6.2
date	2003.05.19.21.38.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Implement TCB_{GET,SET} using PAL_{rd,wr}unique.
Inline asm from NetBSD

testing deraadt@@
@
text
@/* $OpenBSD: alpha_cpu.h,v 1.12 2014/03/29 18:09:28 guenther Exp $ */
/* $NetBSD: alpha_cpu.h,v 1.43 2001/12/18 04:18:22 thorpej Exp $ */

/*
 * Copyright (c) 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#ifndef _MACHINE_ALPHA_CPU_H_
#define	_MACHINE_ALPHA_CPU_H_

/*
 * Alpha CPU + OSF/1 PALcode definitions for use by the kernel.
 *
 * Definitions for:
 *
 *	Process Control Block
 *	Interrupt/Exception/Syscall Stack Frame
 *	Processor Status Register
 *	Machine Check Error Summary Register
 *	Machine Check Logout Area
 *	Per CPU state Management of Machine Check Handling
 *	Virtual Memory Management
 *	Kernel Entry Vectors
 *	MMCSR Fault Type Codes
 *	Translation Buffer Invalidation
 *
 * and miscellaneous PALcode operations.
 */


/*
 * Process Control Block definitions [OSF/1 PALcode Specific]
 */

struct alpha_pcb {
	unsigned long	apcb_ksp;	/* kernel stack ptr */
	unsigned long	apcb_usp;	/* user stack ptr */
	unsigned long	apcb_ptbr;	/* page table base reg */
	unsigned int	apcb_cpc;	/* charged process cycles */
	unsigned int	apcb_asn;	/* address space number */
	unsigned long	apcb_unique;	/* process unique value */
	unsigned long	apcb_flags;	/* flags; see below */
	unsigned long	apcb_decrsv0;	/* DEC reserved */
	unsigned long	apcb_decrsv1;	/* DEC reserved */
};

#define	ALPHA_PCB_FLAGS_FEN	0x0000000000000001
#define	ALPHA_PCB_FLAGS_PME	0x4000000000000000

/*
 * Interrupt/Exception/Syscall "Hardware" (really PALcode)
 * Stack Frame definitions
 *
 * These are quadword offsets from the sp on kernel entry, i.e.
 * to get to the value in question you access (sp + (offset * 8)).
 *
 * On syscall entry, A0-A2 aren't written to memory but space
 * _is_ reserved for them.
 */

#define	ALPHA_HWFRAME_PS	0	/* processor status register */
#define	ALPHA_HWFRAME_PC	1	/* program counter */
#define	ALPHA_HWFRAME_GP	2	/* global pointer */
#define	ALPHA_HWFRAME_A0	3	/* a0 */
#define	ALPHA_HWFRAME_A1	4	/* a1 */
#define	ALPHA_HWFRAME_A2	5	/* a2 */

#define	ALPHA_HWFRAME_SIZE	6	/* 6 8-byte words */

/*
 * Processor Status Register [OSF/1 PALcode Specific]
 *
 * Includes user/kernel mode bit, interrupt priority levels, etc.
 */

#define	ALPHA_PSL_USERMODE	0x0008		/* set -> user mode */
#define	ALPHA_PSL_IPL_MASK	0x0007		/* interrupt level mask */

#define	ALPHA_PSL_IPL_0		0x0000		/* all interrupts enabled */
#define	ALPHA_PSL_IPL_SOFT	0x0001		/* software ints disabled */
#define	ALPHA_PSL_IPL_IO	0x0004		/* I/O dev ints disabled */
#define	ALPHA_PSL_IPL_CLOCK	0x0005		/* clock ints disabled */
#define	ALPHA_PSL_IPL_HIGH	0x0006		/* all but mchecks disabled */

#define	ALPHA_PSL_MUST_BE_ZERO	0xfffffffffffffff0

/* Convenience constants: what must be set/clear in user mode */
#define	ALPHA_PSL_USERSET	ALPHA_PSL_USERMODE
#define	ALPHA_PSL_USERCLR	(ALPHA_PSL_MUST_BE_ZERO | ALPHA_PSL_IPL_MASK)

/*
 * Interrupt Type Code Definitions [OSF/1 PALcode Specific]
 */
 
#define	ALPHA_INTR_XPROC	0	/* interprocessor interrupt */
#define	ALPHA_INTR_CLOCK	1	/* clock interrupt */
#define	ALPHA_INTR_ERROR	2	/* correctable error or mcheck */
#define	ALPHA_INTR_DEVICE	3	/* device interrupt */
#define	ALPHA_INTR_PERF		4	/* performance counter */
#define	ALPHA_INTR_PASSIVE	5	/* passive release */

/*
 * Machine Check Error Summary Register definitions [OSF/1 PALcode Specific]
 *
 * The following bits are values as read.  On write, _PCE, _SCE, and
 * _MIP are "write 1 to clear."
 */

#define	ALPHA_MCES_IMP							\
    0xffffffff00000000	/* impl. dependent */
#define	ALPHA_MCES_RSVD							\
    0x00000000ffffffe0	/* reserved */
#define	ALPHA_MCES_DSC							\
    0x0000000000000010	/* disable system correctable error reporting */
#define	ALPHA_MCES_DPC							\
    0x0000000000000008	/* disable processor correctable error reporting */
#define	ALPHA_MCES_PCE							\
    0x0000000000000004	/* processor correctable error in progress */
#define	ALPHA_MCES_SCE							\
    0x0000000000000002	/* system correctable error in progress */
#define	ALPHA_MCES_MIP							\
    0x0000000000000001	/* machine check in progress */

/*
 * Machine Check Error Summary Register definitions [OSF/1 PALcode Specific]
 *
 * Note that these are *generic* OSF/1 PALcode specific defines. There are
 * platform variations to these entities.
 */

struct alpha_logout_area {
	unsigned int	la_frame_size;		/* frame size */
	unsigned int	la_flags;		/* flags; see below */
	unsigned int	la_cpu_offset;		/* offset to cpu area */
	unsigned int	la_system_offset;	/* offset to system area */
};

#define	ALPHA_LOGOUT_FLAGS_RETRY	0x80000000	/* OK to continue */
#define	ALPHA_LOGOUT_FLAGS_SE		0x40000000	/* second error */
#define	ALPHA_LOGOUT_FLAGS_SBZ		0x3fffffff	/* should be zero */

#define	ALPHA_LOGOUT_NOT_BUILT						\
    (struct alpha_logout_area *)0xffffffffffffffff)

#define	ALPHA_LOGOUT_PAL_AREA(lap)					\
    (unsigned long *)((unsigned char *)(lap) + 16)
#define	ALPHA_LOGOUT_PAL_SIZE(lap)					\
    ((lap)->la_cpu_offset - 16)
#define	ALPHA_LOGOUT_CPU_AREA(lap)					\
    (unsigned long *)((unsigned char *)(lap) + (lap)->la_cpu_offset)
#define	ALPHA_LOGOUT_CPU_SIZE(lap)					\
    ((lap)->la_system_offset - (lap)->la_cpu_offset)
#define	ALPHA_LOGOUT_SYSTEM_AREA(lap)					\
    (unsigned long *)((unsigned char *)(lap) + (lap)->la_system_offset)
#define	ALPHA_LOGOUT_SYSTEM_SIZE(lap)					\
    ((lap)->la_frame_size - (lap)->la_system_offset)

/* types of machine checks */
#define	ALPHA_SYS_ERROR		0x620	/* System correctable error	*/
#define	ALPHA_PROC_ERROR	0x630	/* Processor correctable error	*/
#define	ALPHA_SYS_MCHECK	0x660	/* System machine check		*/
#define	ALPHA_PROC_MCHECK	0x670	/* Processor machine check	*/
#define	ALPHA_ENV_MCHECK	0x680	/* Environmental machine check */

/*
 * Virtual Memory Management definitions [OSF/1 PALcode Specific]
 *
 * Includes user and kernel space addresses and information,
 * page table entry definitions, etc.
 */

#define	ALPHA_USEG_BASE		0			/* virtual */
#define	ALPHA_USEG_END		0x000003ffffffffff

#define	ALPHA_K0SEG_BASE	0xfffffc0000000000	/* direct-mapped */
#define	ALPHA_K0SEG_END		0xfffffdffffffffff
#define	ALPHA_K1SEG_BASE	0xfffffe0000000000	/* virtual */
#define	ALPHA_K1SEG_END		0xffffffffffffffff

#define ALPHA_K0SEG_TO_PHYS(x)	((x) & ~ALPHA_K0SEG_BASE)
#define ALPHA_PHYS_TO_K0SEG(x)	((x) | ALPHA_K0SEG_BASE)

#define	ALPHA_PTE_VALID			0x0001UL

#define	ALPHA_PTE_FAULT_ON_READ		0x0002UL
#define	ALPHA_PTE_FAULT_ON_WRITE	0x0004UL
#define	ALPHA_PTE_FAULT_ON_EXECUTE	0x0008UL

#define	ALPHA_PTE_ASM			0x0010UL	/* addr. space match */
#define	ALPHA_PTE_GRANULARITY		0x0060UL	/* granularity hint */

#define	ALPHA_PTE_PROT			0xff00UL
#define	ALPHA_PTE_KR			0x0100UL
#define	ALPHA_PTE_UR			0x0200UL
#define	ALPHA_PTE_KW			0x1000UL
#define	ALPHA_PTE_UW			0x2000UL

#define	ALPHA_PTE_WRITE			(ALPHA_PTE_KW | ALPHA_PTE_UW)

#define	ALPHA_PTE_SOFTWARE		0x00000000ffff0000UL
#define	ALPHA_PTE_PALCODE		(~ALPHA_PTE_SOFTWARE) /* shorthand */

#define	ALPHA_PTE_PFN			0xffffffff00000000UL

#define	ALPHA_PTE_TO_PFN(pte)		((pte) >> 32)
#define	ALPHA_PTE_FROM_PFN(pfn)		((pfn) << 32)

typedef unsigned long alpha_pt_entry_t;

/*
 * Kernel Entry Vectors.  [OSF/1 PALcode Specific]
 */

#define	ALPHA_KENTRY_INT	0
#define	ALPHA_KENTRY_ARITH	1
#define	ALPHA_KENTRY_MM		2
#define	ALPHA_KENTRY_IF		3
#define	ALPHA_KENTRY_UNA	4
#define	ALPHA_KENTRY_SYS	5

/*
 * MMCSR Fault Type Codes.  [OSF/1 PALcode Specific]
 */

#define	ALPHA_MMCSR_INVALTRANS	0
#define	ALPHA_MMCSR_ACCESS	1
#define	ALPHA_MMCSR_FOR		2
#define	ALPHA_MMCSR_FOE		3
#define	ALPHA_MMCSR_FOW		4

/*
 * Instruction Fault Type Codes.  [OSF/1 PALcode Specific]
 */

#define	ALPHA_IF_CODE_BPT	0
#define	ALPHA_IF_CODE_BUGCHK	1
#define	ALPHA_IF_CODE_GENTRAP	2
#define	ALPHA_IF_CODE_FEN	3
#define	ALPHA_IF_CODE_OPDEC	4

#ifdef _KERNEL

/*
 * Translation Buffer Invalidation definitions [OSF/1 PALcode Specific]
 */

#define	ALPHA_TBIA()	alpha_pal_tbi(-2, 0)		/* all TB entries */
#define	ALPHA_TBIAP()	alpha_pal_tbi(-1, 0)		/* all per-process */
#define	ALPHA_TBISI(va)	alpha_pal_tbi(1, (va))		/* ITB entry for va */
#define	ALPHA_TBISD(va)	alpha_pal_tbi(2, (va))		/* DTB entry for va */
#define	ALPHA_TBIS(va)	alpha_pal_tbi(3, (va))		/* all for va */

#endif /* _KERNEL */

/*
 * Bits used in the amask instruction [EV56 and later]
 */

#define	ALPHA_AMASK_BWX		0x0001		/* byte/word extension */
#define	ALPHA_AMASK_FIX		0x0002		/* floating point conv. ext. */
#define	ALPHA_AMASK_CIX		0x0004		/* count extension */
#define	ALPHA_AMASK_MVI		0x0100		/* multimedia extension */
#define	ALPHA_AMASK_PAT		0x0200		/* precise arith. traps */

#define	ALPHA_AMASK_ALL		(ALPHA_AMASK_BWX|ALPHA_AMASK_FIX|	\
				 ALPHA_AMASK_CIX|ALPHA_AMASK_MVI|	\
				 ALPHA_AMASK_PAT)

#define	ALPHA_AMASK_BITS						\
    "\20\12PAT\11MVI\3CIX\2FIX\1BWX"

/*
 * Chip family IDs returned by implver instruction
 */

#define	ALPHA_IMPLVER_EV4	0		/* LCA/EV4/EV45 */
#define	ALPHA_IMPLVER_EV5	1		/* EV5/EV56/PCA56 */
#define	ALPHA_IMPLVER_EV6	2		/* EV6 */

#ifdef _KERNEL

/*
 * Maximum processor ID we allow from `whami', and related constants.
 *
 * XXX This is not really processor or PALcode specific, but this is
 * a convenient place to put these definitions.
 *
 * XXX This is clipped at 63 so that we can use `long's for proc bitmasks.
 */

#define	ALPHA_WHAMI_MAXID	63
#define	ALPHA_MAXPROCS		(ALPHA_WHAMI_MAXID + 1)

/*
 * Misc. support routines.
 */
const char	*alpha_dsr_sysname(void);

/*
 * Stubs for Alpha instructions normally inaccessible from C.
 */
unsigned long	alpha_amask(unsigned long);
unsigned long	alpha_implver(void);

#endif /* _KERNEL */

/* XXX Expose the insn wrappers to userspace, for now. */

static __inline unsigned long
alpha_rpcc(void)
{
	unsigned long v0;

	__asm volatile("rpcc %0" : "=r" (v0));
	return (v0);
}

#define	alpha_mb()	__asm volatile("mb" : : : "memory")
#define	alpha_wmb()	__asm volatile("mb" : : : "memory")	/* XXX */

#if defined(_KERNEL) || defined(_STANDALONE)

/*
 * Stubs for OSF/1 PALcode operations.
 */
#include <machine/pal.h>

void		alpha_pal_cflush(unsigned long);
void		alpha_pal_halt(void) __attribute__((__noreturn__));
unsigned long	_alpha_pal_swpipl(unsigned long);	/* for profiling */
void		alpha_pal_wrent(void *, unsigned long);
void		alpha_pal_wrvptptr(unsigned long);

#define	alpha_pal_draina() __asm volatile("call_pal %0 # PAL_draina"	\
				: : "i" (PAL_draina) : "memory")

#define	alpha_pal_imb()	__asm volatile("call_pal %0 # PAL_imb"	\
				: : "i" (PAL_imb) : "memory")

static __inline unsigned long
alpha_pal_rdmces(void)
{
	register unsigned long v0 __asm("$0");

	__asm volatile("call_pal %1 # PAL_OSF1_rdmces"
		: "=r" (v0)
		: "i" (PAL_OSF1_rdmces)
		/* clobbers t0, t8..t11 */
		: "$1", "$22", "$23", "$24", "$25");

	return (v0);
}

static __inline unsigned long
alpha_pal_rdps(void)
{
	register unsigned long v0 __asm("$0");

	__asm volatile("call_pal %1 # PAL_OSF1_rdps"
		: "=r" (v0)
		: "i" (PAL_OSF1_rdps)
		/* clobbers t0, t8..t11 */
		: "$1", "$22", "$23", "$24", "$25");

	return (v0);
}

static __inline unsigned long
alpha_pal_rdunique(void)
{
	register unsigned long v0 __asm("$0");

	__asm volatile("call_pal %1 # PAL_rdunique"
		: "=r" (v0)
		: "i" (PAL_rdunique));

	return (v0);
}

static __inline unsigned long
alpha_pal_rdusp(void)
{
	register unsigned long v0 __asm("$0");

	__asm volatile("call_pal %1 # PAL_OSF1_rdusp"
		: "=r" (v0)
		: "i" (PAL_OSF1_rdusp)
		/* clobbers t0, t8..t11 */
		: "$1", "$22", "$23", "$24", "$25");

	return (v0);
}

static __inline unsigned long
alpha_pal_rdval(void)
{
	register unsigned long v0 __asm("$0");

	__asm volatile("call_pal %1 # PAL_OSF1_rdval"
		: "=r" (v0)
		: "i" (PAL_OSF1_rdval)
		/* clobbers t0, t8..t11 */
		: "$1", "$22", "$23", "$24", "$25");

	return (v0);
}

static __inline unsigned long
alpha_pal_swpctx(unsigned long ctx)
{
	register unsigned long a0 __asm("$16") = ctx;
	register unsigned long v0 __asm("$0");

	__asm volatile("call_pal %2 # PAL_OSF1_swpctx"
		: "=r" (a0), "=r" (v0)
		: "i" (PAL_OSF1_swpctx), "0" (a0)
		/* clobbers t0, t8..t11, a0 (above) */
		: "$1", "$22", "$23", "$24", "$25", "memory");

	return (v0);
}

static __inline unsigned long
alpha_pal_swpipl(unsigned long ipl)
{
	register unsigned long a0 __asm("$16") = ipl;
	register unsigned long v0 __asm("$0");

	__asm volatile("call_pal %2 # PAL_OSF1_swpipl"
		: "=r" (a0), "=r" (v0)
		: "i" (PAL_OSF1_swpipl), "0" (a0)
		/* clobbers t0, t8..t11, a0 (above) */
		: "$1", "$22", "$23", "$24", "$25", "memory");

	return (v0);
}

static __inline void
alpha_pal_tbi(unsigned long op, vaddr_t va)
{
	register unsigned long a0 __asm("$16") = op;
	register unsigned long a1 __asm("$17") = va;

	__asm volatile("call_pal %2 # PAL_OSF1_tbi"
		: "=r" (a0), "=r" (a1)
		: "i" (PAL_OSF1_tbi), "0" (a0), "1" (a1)
		/* clobbers t0, t8..t11, a0 (above), a1 (above) */
		: "$1", "$22", "$23", "$24", "$25");
}

static __inline unsigned long
alpha_pal_whami(void)
{
	register unsigned long v0 __asm("$0");

	__asm volatile("call_pal %1 # PAL_OSF1_whami"
		: "=r" (v0)
		: "i" (PAL_OSF1_whami)
		/* clobbers t0, t8..t11 */
		: "$1", "$22", "$23", "$24", "$25");

	return (v0);
}

static __inline void
alpha_pal_wrfen(unsigned long onoff)
{
	register unsigned long a0 __asm("$16") = onoff;

	__asm volatile("call_pal %1 # PAL_OSF1_wrfen"
		: "=r" (a0)
		: "i" (PAL_OSF1_wrfen), "0" (a0)
		/* clobbers t0, t8..t11, a0 (above) */
		: "$1", "$22", "$23", "$24", "$25");
}

static __inline void
alpha_pal_wripir(unsigned long cpu_id)
{
	register unsigned long a0 __asm("$16") = cpu_id;

	__asm volatile("call_pal %1 # PAL_ipir"
		: "=r" (a0)
		: "i" (PAL_ipir), "0" (a0)
		/* clobbers t0, t8..t11, a0 (above) */
		: "$1", "$22", "$23", "$24", "$25");
}

static __inline void
alpha_pal_wrunique(unsigned long unique)
{
	register unsigned long a0 __asm("$16") = unique;

	__asm volatile("call_pal %1 # PAL_wrunique"
		: "=r" (a0)
		: "i" (PAL_wrunique), "0" (a0));
}

static __inline void
alpha_pal_wrusp(unsigned long usp)
{
	register unsigned long a0 __asm("$16") = usp;

	__asm volatile("call_pal %1 # PAL_OSF1_wrusp"
		: "=r" (a0)
		: "i" (PAL_OSF1_wrusp), "0" (a0)
		/* clobbers t0, t8..t11, a0 (above) */
		: "$1", "$22", "$23", "$24", "$25");
}

static __inline void
alpha_pal_wrmces(unsigned long mces)
{
	register unsigned long a0 __asm("$16") = mces;

	__asm volatile("call_pal %1 # PAL_OSF1_wrmces"
		: "=r" (a0)
		: "i" (PAL_OSF1_wrmces), "0" (a0)
		/* clobbers t0, t8..t11 */
		: "$1", "$22", "$23", "$24", "$25");
}

static __inline void
alpha_pal_wrval(unsigned long val)
{
	register unsigned long a0 __asm("$16") = val;

	__asm volatile("call_pal %1 # PAL_OSF1_wrval"
		: "=r" (a0)
		: "i" (PAL_OSF1_wrval), "0" (a0)
		/* clobbers t0, t8..t11, a0 (above) */
		: "$1", "$22", "$23", "$24", "$25");
}

#endif /* _KERNEL */

#endif /* _MACHINE_ALPHA_CPU_H_ */
@


1.12
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: alpha_cpu.h,v 1.11 2012/06/26 01:59:47 deraadt Exp $ */
a64 1
#define	apcb_backup_ksp	apcb_unique	/* backup kernel stack ptr */
d392 12
d510 10
@


1.11
log
@Stop the song and dance where alpha param.h tries to include the world.
"Why is this not commited yet?" says miod
@
text
@d1 1
a1 1
/* $OpenBSD: alpha_cpu.h,v 1.10 2011/03/23 16:54:33 pirofti Exp $ */
d338 1
a338 1
	__asm __volatile("rpcc %0" : "=r" (v0));
d342 2
a343 2
#define	alpha_mb()	__asm __volatile("mb" : : : "memory")
#define	alpha_wmb()	__asm __volatile("mb" : : : "memory")	/* XXX */
d358 1
a358 1
#define	alpha_pal_draina() __asm __volatile("call_pal %0 # PAL_draina"	\
d361 1
a361 1
#define	alpha_pal_imb()	__asm __volatile("call_pal %0 # PAL_imb"	\
d369 1
a369 1
	__asm __volatile("call_pal %1 # PAL_OSF1_rdmces"
d383 1
a383 1
	__asm __volatile("call_pal %1 # PAL_OSF1_rdps"
d397 1
a397 1
	__asm __volatile("call_pal %1 # PAL_OSF1_rdusp"
d411 1
a411 1
	__asm __volatile("call_pal %1 # PAL_OSF1_rdval"
d426 1
a426 1
	__asm __volatile("call_pal %2 # PAL_OSF1_swpctx"
d441 1
a441 1
	__asm __volatile("call_pal %2 # PAL_OSF1_swpipl"
d456 1
a456 1
	__asm __volatile("call_pal %2 # PAL_OSF1_tbi"
d468 1
a468 1
	__asm __volatile("call_pal %1 # PAL_OSF1_whami"
d482 1
a482 1
	__asm __volatile("call_pal %1 # PAL_OSF1_wrfen"
d494 1
a494 1
	__asm __volatile("call_pal %1 # PAL_ipir"
d506 1
a506 1
	__asm __volatile("call_pal %1 # PAL_OSF1_wrusp"
d518 1
a518 1
	__asm __volatile("call_pal %1 # PAL_OSF1_wrmces"
d530 1
a530 1
	__asm __volatile("call_pal %1 # PAL_OSF1_wrval"
@


1.10
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: alpha_cpu.h,v 1.9 2009/01/17 18:30:08 miod Exp $ */
a193 2
 *
 * NOTE THAT THESE DEFINITIONS MAY CHANGE IN FUTURE ALPHA CPUS!
a194 3

#define	ALPHA_PGSHIFT		13
#define	ALPHA_PGBYTES		(1 << ALPHA_PGSHIFT)
@


1.9
log
@Recognize environmental change machine checks on ES40, and report what
happens instead of panicing; while there, start providing more details
for ev6 processor machine checks as well.

This allows power supplies to be unplugged and exchanged while the system
is running, without causing the kernel to crash.
@
text
@d1 1
a1 1
/* $OpenBSD: alpha_cpu.h,v 1.8 2002/11/26 01:35:23 art Exp $ */
d31 2
a32 2
#ifndef __ALPHA_ALPHA_CPU_H__
#define	__ALPHA_ALPHA_CPU_H__
d544 1
a544 1
#endif /* __ALPHA_ALPHA_CPU_H__ */
@


1.8
log
@Make the PTE constants unsigned long with UL.

The macro PG_PALCODE in pte.h is supposed to be used when comparing
two ptes to see if we need a tlb flush. For that it uses the macro
ALPHA_PTE_PALCODE which in turn is defined to ~ALPHA_PTE_SOFTWARE.
Unfortunately ALPHA_PTE_SOFTWARE is small enough to fit in an int,
so ALPHA_PTE_PALCODE becomes an int to and the masking in PG_PALCODE
masks off the pfn in the pte and pmap_enter will then fail to flush
certain TLB entries when it needs to (this situation shouldn't
happen too often).

This might or might not be the solution for the memory corruption
bug I've been hunting for the last three months (the machine still
borks up, but in different ways now).
@
text
@d1 1
a1 1
/* $OpenBSD: alpha_cpu.h,v 1.7 2002/05/10 10:14:48 art Exp $ */
d187 1
@


1.7
log
@Some protection from userland and some __asm paranoia.
From NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: alpha_cpu.h,v 1.6 2000/11/08 21:27:15 ericj Exp $ */
d211 1
a211 1
#define	ALPHA_PTE_VALID			0x0001
d213 12
a224 12
#define	ALPHA_PTE_FAULT_ON_READ		0x0002
#define	ALPHA_PTE_FAULT_ON_WRITE	0x0004
#define	ALPHA_PTE_FAULT_ON_EXECUTE	0x0008

#define	ALPHA_PTE_ASM			0x0010		/* addr. space match */
#define	ALPHA_PTE_GRANULARITY		0x0060		/* granularity hint */

#define	ALPHA_PTE_PROT			0xff00
#define	ALPHA_PTE_KR			0x0100
#define	ALPHA_PTE_UR			0x0200
#define	ALPHA_PTE_KW			0x1000
#define	ALPHA_PTE_UW			0x2000
d228 1
a228 1
#define	ALPHA_PTE_SOFTWARE		0x00000000ffff0000
d231 1
a231 1
#define	ALPHA_PTE_PFN			0xffffffff00000000
@


1.6
log
@tag the rest of alpha tree
@
text
@d1 2
a2 2
/* $OpenBSD: alpha_cpu.h,v 1.41 2000/06/08 03:10:06 thorpej Exp $ */
/* $NetBSD: alpha_cpu.h,v 1.41 2000/06/08 03:10:06 thorpej Exp $ */
d269 2
d281 2
d308 2
d333 4
d349 2
d434 1
a434 1
		: "$1", "$22", "$23", "$24", "$25");
d449 1
a449 1
		: "$1", "$22", "$23", "$24", "$25");
d540 2
@


1.6.6.1
log
@Sync UBC branch to -current
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* $NetBSD: alpha_cpu.h,v 1.43 2001/12/18 04:18:22 thorpej Exp $ */
a268 2
#ifdef _KERNEL

a278 2
#endif /* _KERNEL */

a303 2
#ifdef _KERNEL

a326 4
#endif /* _KERNEL */

/* XXX Expose the insn wrappers to userspace, for now. */

a338 2
#if defined(_KERNEL) || defined(_STANDALONE)

d422 1
a422 1
		: "$1", "$22", "$23", "$24", "$25", "memory");
d437 1
a437 1
		: "$1", "$22", "$23", "$24", "$25", "memory");
a527 2

#endif /* _KERNEL */
@


1.6.6.2
log
@sync
@
text
@d211 1
a211 1
#define	ALPHA_PTE_VALID			0x0001UL
d213 12
a224 12
#define	ALPHA_PTE_FAULT_ON_READ		0x0002UL
#define	ALPHA_PTE_FAULT_ON_WRITE	0x0004UL
#define	ALPHA_PTE_FAULT_ON_EXECUTE	0x0008UL

#define	ALPHA_PTE_ASM			0x0010UL	/* addr. space match */
#define	ALPHA_PTE_GRANULARITY		0x0060UL	/* granularity hint */

#define	ALPHA_PTE_PROT			0xff00UL
#define	ALPHA_PTE_KR			0x0100UL
#define	ALPHA_PTE_UR			0x0200UL
#define	ALPHA_PTE_KW			0x1000UL
#define	ALPHA_PTE_UW			0x2000UL
d228 1
a228 1
#define	ALPHA_PTE_SOFTWARE		0x00000000ffff0000UL
d231 1
a231 1
#define	ALPHA_PTE_PFN			0xffffffff00000000UL
@


1.5
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
@


1.4
log
@Comment out text after #endif
@
text
@d1 1
a1 2
/*	$OpenBSD: alpha_cpu.h,v 1.3 1997/08/01 21:22:42 deraadt Exp $	*/
/*	$NetBSD: alpha_cpu.h,v 1.7 1996/11/23 06:25:31 cgd Exp $	*/
d43 1
d64 1
d115 11
d149 3
d180 7
a186 1
	
d227 2
a228 1
#define	ALPHA_PTE_SOFTWARE		0xffff0000
d279 42
d323 14
a336 3
unsigned long	alpha_rpcc __P((void));
void		alpha_mb __P((void));
void		alpha_wmb __P((void));
d341 186
a526 14
void		alpha_pal_imb __P((void));
void		alpha_pal_draina __P((void));
void		alpha_pal_halt __P((void)) __attribute__((__noreturn__));
unsigned long	alpha_pal_rdmces __P((void));
unsigned long	alpha_pal_rdusp __P((void));
unsigned long	alpha_pal_swpipl __P((unsigned long));
unsigned long	_alpha_pal_swpipl __P((unsigned long));	/* for profiling */
void		alpha_pal_tbi __P((unsigned long, vm_offset_t));
unsigned long	alpha_pal_whami __P((void));
void		alpha_pal_wrent __P((void *, unsigned long));
void		alpha_pal_wrfen __P((unsigned long));
void		alpha_pal_wrusp __P((unsigned long));
void		alpha_pal_wrvptptr __P((unsigned long));
void		alpha_pal_wrmces __P((unsigned long));
@


1.4.8.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 2
/* $OpenBSD: alpha_cpu.h,v 1.6 2000/11/08 21:27:15 ericj Exp $ */
/* $NetBSD: alpha_cpu.h,v 1.41 2000/06/08 03:10:06 thorpej Exp $ */
a43 1
 *	Per CPU state Management of Machine Check Handling
a63 1
#define	apcb_backup_ksp	apcb_unique	/* backup kernel stack ptr */
a113 11
 * Interrupt Type Code Definitions [OSF/1 PALcode Specific]
 */
 
#define	ALPHA_INTR_XPROC	0	/* interprocessor interrupt */
#define	ALPHA_INTR_CLOCK	1	/* clock interrupt */
#define	ALPHA_INTR_ERROR	2	/* correctable error or mcheck */
#define	ALPHA_INTR_DEVICE	3	/* device interrupt */
#define	ALPHA_INTR_PERF		4	/* performance counter */
#define	ALPHA_INTR_PASSIVE	5	/* passive release */

/*
a136 3
 *
 * Note that these are *generic* OSF/1 PALcode specific defines. There are
 * platform variations to these entities.
d165 1
a165 7

/* types of machine checks */
#define	ALPHA_SYS_ERROR		0x620	/* System correctable error	*/
#define	ALPHA_PROC_ERROR	0x630	/* Processor correctable error	*/
#define	ALPHA_SYS_MCHECK	0x660	/* System machine check		*/
#define	ALPHA_PROC_MCHECK	0x670	/* Processor machine check	*/

d206 1
a206 2
#define	ALPHA_PTE_SOFTWARE		0x00000000ffff0000
#define	ALPHA_PTE_PALCODE		(~ALPHA_PTE_SOFTWARE) /* shorthand */
a256 42
 * Bits used in the amask instruction [EV56 and later]
 */

#define	ALPHA_AMASK_BWX		0x0001		/* byte/word extension */
#define	ALPHA_AMASK_FIX		0x0002		/* floating point conv. ext. */
#define	ALPHA_AMASK_CIX		0x0004		/* count extension */
#define	ALPHA_AMASK_MVI		0x0100		/* multimedia extension */
#define	ALPHA_AMASK_PAT		0x0200		/* precise arith. traps */

#define	ALPHA_AMASK_ALL		(ALPHA_AMASK_BWX|ALPHA_AMASK_FIX|	\
				 ALPHA_AMASK_CIX|ALPHA_AMASK_MVI|	\
				 ALPHA_AMASK_PAT)

#define	ALPHA_AMASK_BITS						\
    "\20\12PAT\11MVI\3CIX\2FIX\1BWX"

/*
 * Chip family IDs returned by implver instruction
 */

#define	ALPHA_IMPLVER_EV4	0		/* LCA/EV4/EV45 */
#define	ALPHA_IMPLVER_EV5	1		/* EV5/EV56/PCA56 */
#define	ALPHA_IMPLVER_EV6	2		/* EV6 */

/*
 * Maximum processor ID we allow from `whami', and related constants.
 *
 * XXX This is not really processor or PALcode specific, but this is
 * a convenient place to put these definitions.
 *
 * XXX This is clipped at 63 so that we can use `long's for proc bitmasks.
 */

#define	ALPHA_WHAMI_MAXID	63
#define	ALPHA_MAXPROCS		(ALPHA_WHAMI_MAXID + 1)

/*
 * Misc. support routines.
 */
const char	*alpha_dsr_sysname(void);

/*
d259 3
a261 14
unsigned long	alpha_amask(unsigned long);
unsigned long	alpha_implver(void);

static __inline unsigned long
alpha_rpcc(void)
{
	unsigned long v0;

	__asm __volatile("rpcc %0" : "=r" (v0));
	return (v0);
}

#define	alpha_mb()	__asm __volatile("mb" : : : "memory")
#define	alpha_wmb()	__asm __volatile("mb" : : : "memory")	/* XXX */
d266 14
a279 186
#include <machine/pal.h>

void		alpha_pal_cflush(unsigned long);
void		alpha_pal_halt(void) __attribute__((__noreturn__));
unsigned long	_alpha_pal_swpipl(unsigned long);	/* for profiling */
void		alpha_pal_wrent(void *, unsigned long);
void		alpha_pal_wrvptptr(unsigned long);

#define	alpha_pal_draina() __asm __volatile("call_pal %0 # PAL_draina"	\
				: : "i" (PAL_draina) : "memory")

#define	alpha_pal_imb()	__asm __volatile("call_pal %0 # PAL_imb"	\
				: : "i" (PAL_imb) : "memory")

static __inline unsigned long
alpha_pal_rdmces(void)
{
	register unsigned long v0 __asm("$0");

	__asm __volatile("call_pal %1 # PAL_OSF1_rdmces"
		: "=r" (v0)
		: "i" (PAL_OSF1_rdmces)
		/* clobbers t0, t8..t11 */
		: "$1", "$22", "$23", "$24", "$25");

	return (v0);
}

static __inline unsigned long
alpha_pal_rdps(void)
{
	register unsigned long v0 __asm("$0");

	__asm __volatile("call_pal %1 # PAL_OSF1_rdps"
		: "=r" (v0)
		: "i" (PAL_OSF1_rdps)
		/* clobbers t0, t8..t11 */
		: "$1", "$22", "$23", "$24", "$25");

	return (v0);
}

static __inline unsigned long
alpha_pal_rdusp(void)
{
	register unsigned long v0 __asm("$0");

	__asm __volatile("call_pal %1 # PAL_OSF1_rdusp"
		: "=r" (v0)
		: "i" (PAL_OSF1_rdusp)
		/* clobbers t0, t8..t11 */
		: "$1", "$22", "$23", "$24", "$25");

	return (v0);
}

static __inline unsigned long
alpha_pal_rdval(void)
{
	register unsigned long v0 __asm("$0");

	__asm __volatile("call_pal %1 # PAL_OSF1_rdval"
		: "=r" (v0)
		: "i" (PAL_OSF1_rdval)
		/* clobbers t0, t8..t11 */
		: "$1", "$22", "$23", "$24", "$25");

	return (v0);
}

static __inline unsigned long
alpha_pal_swpctx(unsigned long ctx)
{
	register unsigned long a0 __asm("$16") = ctx;
	register unsigned long v0 __asm("$0");

	__asm __volatile("call_pal %2 # PAL_OSF1_swpctx"
		: "=r" (a0), "=r" (v0)
		: "i" (PAL_OSF1_swpctx), "0" (a0)
		/* clobbers t0, t8..t11, a0 (above) */
		: "$1", "$22", "$23", "$24", "$25");

	return (v0);
}

static __inline unsigned long
alpha_pal_swpipl(unsigned long ipl)
{
	register unsigned long a0 __asm("$16") = ipl;
	register unsigned long v0 __asm("$0");

	__asm __volatile("call_pal %2 # PAL_OSF1_swpipl"
		: "=r" (a0), "=r" (v0)
		: "i" (PAL_OSF1_swpipl), "0" (a0)
		/* clobbers t0, t8..t11, a0 (above) */
		: "$1", "$22", "$23", "$24", "$25");

	return (v0);
}

static __inline void
alpha_pal_tbi(unsigned long op, vaddr_t va)
{
	register unsigned long a0 __asm("$16") = op;
	register unsigned long a1 __asm("$17") = va;

	__asm __volatile("call_pal %2 # PAL_OSF1_tbi"
		: "=r" (a0), "=r" (a1)
		: "i" (PAL_OSF1_tbi), "0" (a0), "1" (a1)
		/* clobbers t0, t8..t11, a0 (above), a1 (above) */
		: "$1", "$22", "$23", "$24", "$25");
}

static __inline unsigned long
alpha_pal_whami(void)
{
	register unsigned long v0 __asm("$0");

	__asm __volatile("call_pal %1 # PAL_OSF1_whami"
		: "=r" (v0)
		: "i" (PAL_OSF1_whami)
		/* clobbers t0, t8..t11 */
		: "$1", "$22", "$23", "$24", "$25");

	return (v0);
}

static __inline void
alpha_pal_wrfen(unsigned long onoff)
{
	register unsigned long a0 __asm("$16") = onoff;

	__asm __volatile("call_pal %1 # PAL_OSF1_wrfen"
		: "=r" (a0)
		: "i" (PAL_OSF1_wrfen), "0" (a0)
		/* clobbers t0, t8..t11, a0 (above) */
		: "$1", "$22", "$23", "$24", "$25");
}

static __inline void
alpha_pal_wripir(unsigned long cpu_id)
{
	register unsigned long a0 __asm("$16") = cpu_id;

	__asm __volatile("call_pal %1 # PAL_ipir"
		: "=r" (a0)
		: "i" (PAL_ipir), "0" (a0)
		/* clobbers t0, t8..t11, a0 (above) */
		: "$1", "$22", "$23", "$24", "$25");
}

static __inline void
alpha_pal_wrusp(unsigned long usp)
{
	register unsigned long a0 __asm("$16") = usp;

	__asm __volatile("call_pal %1 # PAL_OSF1_wrusp"
		: "=r" (a0)
		: "i" (PAL_OSF1_wrusp), "0" (a0)
		/* clobbers t0, t8..t11, a0 (above) */
		: "$1", "$22", "$23", "$24", "$25");
}

static __inline void
alpha_pal_wrmces(unsigned long mces)
{
	register unsigned long a0 __asm("$16") = mces;

	__asm __volatile("call_pal %1 # PAL_OSF1_wrmces"
		: "=r" (a0)
		: "i" (PAL_OSF1_wrmces), "0" (a0)
		/* clobbers t0, t8..t11 */
		: "$1", "$22", "$23", "$24", "$25");
}

static __inline void
alpha_pal_wrval(unsigned long val)
{
	register unsigned long a0 __asm("$16") = val;

	__asm __volatile("call_pal %1 # PAL_OSF1_wrval"
		: "=r" (a0)
		: "i" (PAL_OSF1_wrval), "0" (a0)
		/* clobbers t0, t8..t11, a0 (above) */
		: "$1", "$22", "$23", "$24", "$25");
}
@


1.4.8.2
log
@Sync the SMP branch with 3.3
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* $NetBSD: alpha_cpu.h,v 1.43 2001/12/18 04:18:22 thorpej Exp $ */
d211 1
a211 1
#define	ALPHA_PTE_VALID			0x0001UL
d213 12
a224 12
#define	ALPHA_PTE_FAULT_ON_READ		0x0002UL
#define	ALPHA_PTE_FAULT_ON_WRITE	0x0004UL
#define	ALPHA_PTE_FAULT_ON_EXECUTE	0x0008UL

#define	ALPHA_PTE_ASM			0x0010UL	/* addr. space match */
#define	ALPHA_PTE_GRANULARITY		0x0060UL	/* granularity hint */

#define	ALPHA_PTE_PROT			0xff00UL
#define	ALPHA_PTE_KR			0x0100UL
#define	ALPHA_PTE_UR			0x0200UL
#define	ALPHA_PTE_KW			0x1000UL
#define	ALPHA_PTE_UW			0x2000UL
d228 1
a228 1
#define	ALPHA_PTE_SOFTWARE		0x00000000ffff0000UL
d231 1
a231 1
#define	ALPHA_PTE_PFN			0xffffffff00000000UL
a268 2
#ifdef _KERNEL

a278 2
#endif /* _KERNEL */

a303 2
#ifdef _KERNEL

a326 4
#endif /* _KERNEL */

/* XXX Expose the insn wrappers to userspace, for now. */

a338 2
#if defined(_KERNEL) || defined(_STANDALONE)

d422 1
a422 1
		: "$1", "$22", "$23", "$24", "$25", "memory");
d437 1
a437 1
		: "$1", "$22", "$23", "$24", "$25", "memory");
a527 2

#endif /* _KERNEL */
@


1.3
log
@ALPHA_PTE_WRITE needs to include the "user write" bit; thorpej
@
text
@d1 1
a1 1
/*	$OpenBSD: alpha_cpu.h,v 1.2 1997/01/24 19:57:05 niklas Exp $	*/
d281 1
a281 1
#endif __ALPHA_ALPHA_CPU_H__
@


1.2
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: alpha_cpu.h,v 1.1 1996/10/30 22:38:49 niklas Exp $	*/
d204 1
a204 1
#define	ALPHA_PTE_WRITE			(ALPHA_PTE_KW | ALPHA_PTE_KW)
@


1.1
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 2
a2 2
/*	$OpenBSD: alpha_cpu.h,v 1.6 1996/08/20 23:02:17 cgd Exp $	*/
/*	$NetBSD: alpha_cpu.h,v 1.6 1996/08/20 23:02:17 cgd Exp $	*/
d186 1
a186 1
#define ALPHA_K0SEG_TO_PHYS(x)	((x) & 0x00000003ffffffff)
@
