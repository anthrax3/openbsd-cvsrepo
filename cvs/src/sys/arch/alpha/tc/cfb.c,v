head	1.24;
access;
symbols
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.24.0.4
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.23.0.12
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.8
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.10
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.23.0.6
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.22.0.12
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.10
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.8
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.6
	OPENBSD_5_0:1.22.0.4
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.21.0.6
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.4
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.19.0.4
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.14.0.16
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.14
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.12
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.10
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.8
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.14
	UBC:1.12.0.6
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.4
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.8
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.6
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.4
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.24
date	2017.01.15.20.22.33;	author fcambus;	state Exp;
branches;
next	1.23;
commitid	tX0dEKV2WbrIyiOY;

1.23
date	2013.10.20.20.07.22;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2010.12.26.15.40.58;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.20;

1.20
date	2008.08.09.16.42.29;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2007.11.06.18.20.05;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.11.29.12.13.51;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.07.12.15.36.04;	author martin;	state Exp;
branches;
next	1.16;

1.16
date	2006.01.02.05.21.28;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.28.19.10.26;	author martin;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.03.15.51;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.28;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.01.18.05.30;	author art;	state Exp;
branches
	1.12.6.1;
next	1.11;

1.11
date	2000.08.04.16.45.47;	author ericj;	state Exp;
branches;
next	1.10;

1.10
date	98.11.21.18.13.03;	author millert;	state Exp;
branches
	1.10.6.1;
next	1.9;

1.9
date	97.11.06.12.27.05;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.07.31.13.40.03;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.01.24.19.58.08;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.12.08.00.20.55;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.11.23.21.44.57;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.11.12.20.29.42;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.10.30.22.41.01;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.07.29.23.01.56;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.06.18.09.45.09;	author deraadt;	state Exp;
branches;
next	;

1.10.6.1
date	2001.04.18.16.01.49;	author niklas;	state Exp;
branches;
next	1.10.6.2;

1.10.6.2
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	;

1.12.6.1
date	2002.06.11.03.33.41;	author art;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Harmonize the way frame buffer drivers display resolution and color
depth when attaching.

OK visa@@, deraadt@@
@
text
@/*	$OpenBSD: cfb.c,v 1.23 2013/10/20 20:07:22 miod Exp $	*/
/*	$NetBSD: cfb.c,v 1.7 1996/12/05 01:39:39 cgd Exp $	*/

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/conf.h>
#include <sys/ioctl.h>

#include <uvm/uvm_extern.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/tc/tcvar.h>
#include <machine/cfbreg.h>
#include <alpha/tc/cfbvar.h>

#include <dev/rcons/raster.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/wscons/wsdisplayvar.h>
#include <machine/fbio.h>

#include <machine/autoconf.h>
#include <machine/pte.h>

int	cfbmatch(struct device *, void *, void *);
void	cfbattach(struct device *, struct device *, void *);

struct cfattach cfb_ca = {
	sizeof(struct cfb_softc), cfbmatch, cfbattach,
};

struct cfdriver cfb_cd = {
	NULL, "cfb", DV_DULL,
};

void	cfb_getdevconfig(tc_addr_t dense_addr, struct cfb_devconfig *dc);
struct cfb_devconfig cfb_console_dc;
tc_addr_t cfb_consaddr;

struct wsdisplay_emulops cfb_emulfuncs = {
	rcons_cursor,			/* could use hardware cursor; punt */
	rcons_mapchar,
	rcons_putchar,
	rcons_copycols,
	rcons_erasecols,
	rcons_copyrows,
	rcons_eraserows,
	rcons_alloc_attr
};

struct wsscreen_descr cfb_stdscreen = {
        "std",
        0, 0,        /* will be filled in -- XXX shouldn't, it's global */
        &cfb_emulfuncs,
        0, 0
};

const struct wsscreen_descr *_cfb_scrlist[] = {
        &cfb_stdscreen,
        /* XXX other formats, graphics screen? */
};

struct wsscreen_list cfb_screenlist = {
        sizeof(_cfb_scrlist) / sizeof(struct wsscreen_descr *), _cfb_scrlist
};

int	cfbioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	cfbmmap(void *, off_t, int);

int	cfbintr(void *);
static int      cfb_alloc_screen(void *, const struct wsscreen_descr *,
		    void **, int *, int *, long *);
static void     cfb_free_screen(void *, void *);
static int      cfb_show_screen(void *, void *, int,
		    void (*) (void *, int, int), void *);

struct wsdisplay_accessops cfb_accessops = {
	.ioctl = cfbioctl,
	.mmap = cfbmmap,
	.alloc_screen = cfb_alloc_screen,
	.free_screen = cfb_free_screen,
	.show_screen = cfb_show_screen
};

int
cfbmatch(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct tc_attach_args *ta = aux;

	if (strncmp("PMAG-BA ", ta->ta_modname, TC_ROM_LLEN) != 0)
		return (0);

	return (10);
}

void
cfb_getdevconfig(dense_addr, dc)
	tc_addr_t dense_addr;
	struct cfb_devconfig *dc;
{
	struct raster *rap;
	struct rcons *rcp;
	char *ramdacregp;
	int i;

	dc->dc_vaddr = dense_addr;
	dc->dc_paddr = ALPHA_K0SEG_TO_PHYS(dc->dc_vaddr);	/* XXX */
	dc->dc_size = CFB_SIZE;

	ramdacregp = (char *)dc->dc_vaddr + CFB_RAMDAC_OFFSET;

	dc->dc_wid = 1024;
	dc->dc_ht = 864;
	dc->dc_depth = 8;			/* 8 plane */
	dc->dc_rowbytes = dc->dc_wid * (dc->dc_depth / 8);

	dc->dc_videobase = dc->dc_vaddr + CFB_FB_OFFSET;
	
	/* Initialize the RAMDAC/colormap */
	/* start XXX XXX XXX */
	(*(volatile u_int32_t *)(ramdacregp + CFB_RAMDAC_ADDRLOW)) = 0;
	(*(volatile u_int32_t *)(ramdacregp + CFB_RAMDAC_ADDRHIGH)) = 0;
	tc_wmb();
	for (i = 0; i < 256; i++) {
		(*(volatile u_int32_t *)(ramdacregp + CFB_RAMDAC_CMAPDATA)) =
		    i ? 0xff : 0;
		tc_wmb();
		(*(volatile u_int32_t *)(ramdacregp + CFB_RAMDAC_CMAPDATA)) =
		    i ? 0xff : 0;
		tc_wmb();
		(*(volatile u_int32_t *)(ramdacregp + CFB_RAMDAC_CMAPDATA)) =
		    i ? 0xff : 0;
		tc_wmb();
	}
	/* end XXX XXX XXX */
	
	/* clear the screen */
	for (i = 0; i < dc->dc_ht * dc->dc_rowbytes; i += sizeof(u_int32_t))
		*(u_int32_t *)(dc->dc_videobase + i) = 0x00000000;

	rap = &dc->dc_raster;
	rap->width = dc->dc_wid;
	rap->height = dc->dc_ht;
	rap->depth = 8;
	rap->linelongs = dc->dc_rowbytes / sizeof(u_int32_t);
	rap->pixels = (u_int32_t *)dc->dc_videobase;

	/* initialize the raster console blitter */
	rcp = &dc->dc_rcons;
	rcp->rc_sp = rap;
	rcp->rc_crow = rcp->rc_ccol = -1;
	rcp->rc_crowp = &rcp->rc_crow;
	rcp->rc_ccolp = &rcp->rc_ccol;
	rcons_init(rcp, 34, 80);

	cfb_stdscreen.nrows = dc->dc_rcons.rc_maxrow;
	cfb_stdscreen.ncols = dc->dc_rcons.rc_maxcol;
}

void
cfbattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct cfb_softc *sc = (struct cfb_softc *)self;
	struct tc_attach_args *ta = aux;
	struct wsemuldisplaydev_attach_args waa;
	int console;

	console = (ta->ta_addr == cfb_consaddr);
	if (console) {
		sc->sc_dc = &cfb_console_dc;
		sc->nscreens = 1;
	} else {
		sc->sc_dc = (struct cfb_devconfig *)
		    malloc(sizeof(struct cfb_devconfig), M_DEVBUF, M_WAITOK);
		cfb_getdevconfig(ta->ta_addr, sc->sc_dc);
	}
	if (sc->sc_dc->dc_vaddr == NULL) {
		printf(": can't map mem space\n");
		return;
	}
	printf(": %dx%d, %dbpp\n", sc->sc_dc->dc_wid, sc->sc_dc->dc_ht,
	    sc->sc_dc->dc_depth);

	/* Establish an interrupt handler, and clear any pending interrupts */
        tc_intr_establish(parent, ta->ta_cookie, IPL_TTY, cfbintr, sc,
	    self->dv_xname);
	*(volatile u_int32_t *)(sc->sc_dc->dc_vaddr + CFB_IREQCTRL_OFFSET) = 0;

	/* initialize the raster */
	waa.console = console;
	waa.scrdata = &cfb_screenlist;
	waa.accessops = &cfb_accessops;
	waa.accesscookie = sc;
	waa.defaultscreens = 0;

	config_found(self, &waa, wsemuldisplaydevprint);
}

int
cfbioctl(v, cmd, data, flag, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	struct cfb_softc *sc = v;
	struct cfb_devconfig *dc = sc->sc_dc;

	switch (cmd) {
	case FBIOGTYPE:
#define fbt ((struct fbtype *)data)
		fbt->fb_type = FBTYPE_CFB;
		fbt->fb_height = sc->sc_dc->dc_ht;
		fbt->fb_width = sc->sc_dc->dc_wid;
		fbt->fb_depth = sc->sc_dc->dc_depth;
		fbt->fb_cmsize = 256;		/* XXX ??? */
		fbt->fb_size = sc->sc_dc->dc_size;
#undef fbt
		return (0);

#if 0
	case FBIOPUTCMAP:
		return (*tgar->tgar_set_cmap)(dc, (struct fbcmap *)data);

	case FBIOGETCMAP:
		return (*tgar->tgar_get_cmap)(dc, (struct fbcmap *)data);
#endif

	case FBIOGATTR:
		return (ENOTTY);			/* XXX ? */

#if 0
	case FBIOSVIDEO:
		if (*(int *)data == FBVIDEO_OFF)
			cfb_blank(sc->sc_dc);
		else
			cfb_unblank(sc->sc_dc);
		return (0);
#endif

	case FBIOGVIDEO:
		*(int *)data = dc->dc_blanked ? FBVIDEO_OFF : FBVIDEO_ON;
		return (0);

#if 0
	case FBIOSCURSOR:
		return (*tgar->tgar_set_cursor)(dc, (struct fbcursor *)data);

	case FBIOGCURSOR:
		return (*tgar->tgar_get_cursor)(dc, (struct fbcursor *)data);

	case FBIOSCURPOS:
		return (*tgar->tgar_set_curpos)(dc, (struct fbcurpos *)data);

	case FBIOGCURPOS:
		return (*tgar->tgar_get_curpos)(dc, (struct fbcurpos *)data);

	case FBIOGCURMAX:
		return (*tgar->tgar_get_curmax)(dc, (struct fbcurpos *)data);
#endif
	}
	return (-1);
}

paddr_t
cfbmmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
{
	struct cfb_softc *sc = v;

	if (offset > CFB_SIZE)
		return (-1);
	return sc->sc_dc->dc_paddr + offset;
}

int
cfbintr(v)
	void *v;
{
	struct cfb_softc *sc = v;

	*(volatile u_int32_t *)(sc->sc_dc->dc_vaddr + CFB_IREQCTRL_OFFSET) = 0;

	return (1);
}

int 
cfb_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
{
	struct cfb_softc *sc = v;
	long defattr;

	if (sc->nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_dc->dc_rcons; /* one and only for now */
	*curxp = 0;
	*curyp = 0;
	rcons_alloc_attr(&sc->sc_dc->dc_rcons, 0, 0, 0, &defattr);
	*attrp = defattr;
	sc->nscreens++;
	return(0);
}

void
cfb_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct cfb_softc *sc = v;

	if (sc->sc_dc == &cfb_console_dc)
		panic("cfb_free_screen: console");

	sc->nscreens--;
}

int
cfb_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
	return (0);
}

#if 0
int 
cfb_cnattach(addr)
	tc_addr_t addr;
{
	struct cfb_devconfig *dc = &cfb_console_dc;
	long defattr;

	cfb_getdevconfig(addr, dcp);

	rcons_alloc_attr(&dcp->dc_rcons, 0, 0, 0, &defattr);
	
	wsdisplay_cnattach(&cfb_stdscreen, &dcp->dc_rcons,
		0,0, defattr;);

	cfb_consaddr = addr;
	return (0);
}
#endif
@


1.23
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfb.c,v 1.22 2010/12/26 15:40:58 miod Exp $	*/
d218 1
a218 1
	printf(": %d x %d, %dbpp\n", sc->sc_dc->dc_wid, sc->sc_dc->dc_ht,
@


1.22
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfb.c,v 1.21 2009/03/29 21:53:52 sthen Exp $	*/
d110 5
a114 5
	cfbioctl,
	cfbmmap,
	cfb_alloc_screen,
	cfb_free_screen,
	cfb_show_screen,
@


1.21
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfb.c,v 1.20 2008/08/09 16:42:29 miod Exp $	*/
d313 1
a313 1
	return atop(sc->sc_dc->dc_paddr + offset);
@


1.20
log
@Pass a device name to {tc,tcds,ioasic}_intr_establish in order to get
meaningful names associated to the interrupt counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfb.c,v 1.19 2007/11/06 18:20:05 miod Exp $	*/
d215 1
a215 1
		printf(": couldn't map memory space; punt!\n");
@


1.19
log
@Get rid of TC_IPL_xxx values and tc_intrlevel_t, and use IPL_xxx and int.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfb.c,v 1.18 2006/11/29 12:13:51 miod Exp $	*/
d222 2
a223 1
        tc_intr_establish(parent, ta->ta_cookie, IPL_TTY, cfbintr, sc);
@


1.18
log
@Add a new member to struct wsemuldisplaydev_attach_args, for a frame buffer
driver to be able to tell how many wscons screens to attach to it,
instead of WSDISPLAY_DEFAULTSCREENS which is a global setting.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfb.c,v 1.17 2006/07/12 15:36:04 martin Exp $	*/
d222 1
a222 1
        tc_intr_establish(parent, ta->ta_cookie, TC_IPL_TTY, cfbintr, sc);
@


1.17
log
@include uvm_extern.h for atop()
@
text
@d1 1
a1 1
/*	$OpenBSD: cfb.c,v 1.16 2006/01/02 05:21:28 brad Exp $	*/
d230 1
@


1.16
log
@remove last traces of __BROKEN_INDIRECT_CONFIG.

Thanks to aanriot@@ and Michael Knudsen for checking that alpha/i386/macppc
kernels still compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfb.c,v 1.15 2005/10/28 19:10:26 martin Exp $	*/
d39 2
@


1.15
log
@no more Mach-macros
@
text
@d1 1
a1 1
/*	$OpenBSD: cfb.c,v 1.14 2002/03/14 03:15:51 millert Exp $	*/
a54 1
#ifdef __BROKEN_INDIRECT_CONFIG
a55 3
#else
int	cfbmatch(struct device *, struct cfdata *, void *);
#endif
a117 1
#ifdef __BROKEN_INDIRECT_CONFIG
a118 3
#else
	struct cfdata *match;
#endif
@


1.14
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: cfb.c,v 1.13 2002/03/14 01:26:28 millert Exp $	*/
d317 1
a317 1
	return alpha_btop(sc->sc_dc->dc_paddr + offset);
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cfb.c,v 1.12 2001/02/01 18:05:30 art Exp $	*/
d106 1
a106 1
		          void **, int *, int *, long *);
d108 2
a109 2
static int      cfb_show_screen __P((void *, void *, int,
                                     void (*) (void *, int, int), void *));
@


1.12
log
@Adapt to recent wscons changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfb.c,v 1.11 2000/08/04 16:45:47 ericj Exp $	*/
d56 1
a56 1
int	cfbmatch __P((struct device *, void *, void *));
d58 1
a58 1
int	cfbmatch __P((struct device *, struct cfdata *, void *));
d60 1
a60 1
void	cfbattach __P((struct device *, struct device *, void *));
d70 1
a70 1
void	cfb_getdevconfig __P((tc_addr_t dense_addr, struct cfb_devconfig *dc));
d101 2
a102 2
int	cfbioctl __P((void *, u_long, caddr_t, int, struct proc *));
paddr_t	cfbmmap __P((void *, off_t, int));
d104 4
a107 4
int	cfbintr __P((void *));
static int      cfb_alloc_screen __P((void *, const struct wsscreen_descr *,
		          void **, int *, int *, long *));
static void     cfb_free_screen __P((void *, void *));
d372 1
a372 1
	void (*cb) __P((void *, int, int));
@


1.12.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cfb.c,v 1.12 2001/02/01 18:05:30 art Exp $	*/
d56 1
a56 1
int	cfbmatch(struct device *, void *, void *);
d58 1
a58 1
int	cfbmatch(struct device *, struct cfdata *, void *);
d60 1
a60 1
void	cfbattach(struct device *, struct device *, void *);
d70 1
a70 1
void	cfb_getdevconfig(tc_addr_t dense_addr, struct cfb_devconfig *dc);
d101 2
a102 2
int	cfbioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	cfbmmap(void *, off_t, int);
d104 6
a109 6
int	cfbintr(void *);
static int      cfb_alloc_screen(void *, const struct wsscreen_descr *,
		    void **, int *, int *, long *);
static void     cfb_free_screen(void *, void *);
static int      cfb_show_screen(void *, void *, int,
		    void (*) (void *, int, int), void *);
d372 1
a372 1
	void (*cb)(void *, int, int);
@


1.11
log
@
convert sfb and cfb to use new wscons; from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfb.c,v 1.10 1998/11/21 18:13:03 millert Exp $	*/
d102 1
a102 1
int	cfbmmap __P((void *, off_t, int));
d307 1
a307 1
int
@


1.10
log
@when mmap'ing check for offset >= size, not just > size and disallow negative offsets; mrg@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: cfb.c,v 1.9 1997/11/06 12:27:05 niklas Exp $	*/
a45 3
#if 0
#include <alpha/tc/bt459reg.h>
#endif
d49 1
a49 1
#include <dev/wscons/wsconsvar.h>
a60 1
int	cfbprint __P((void *, const char *));
d72 1
d74 1
a74 1
struct wscons_emulfuncs cfb_emulfuncs = {
d76 2
a77 1
	rcons_putstr,
d82 17
a98 1
	rcons_setattr,
d105 13
d196 3
d208 1
a208 2
	struct wscons_attach_args waa;
	struct wscons_odev_spec *wo;
d211 2
a212 2
	console = 0;					/* XXX */
	if (console)
d214 2
a215 1
	else {
d232 4
a235 2
	waa.waa_isconsole = console;
	wo = &waa.waa_odev_spec;
d237 1
a237 24
	wo->wo_emulfuncs = &cfb_emulfuncs;
	wo->wo_emulfuncs_cookie = &sc->sc_dc->dc_rcons;

	wo->wo_ioctl = cfbioctl;
	wo->wo_mmap = cfbmmap;
	wo->wo_miscfuncs_cookie = sc;

	wo->wo_nrows = sc->sc_dc->dc_rcons.rc_maxrow;
	wo->wo_ncols = sc->sc_dc->dc_rcons.rc_maxcol;
	wo->wo_crow = 0;
	wo->wo_ccol = 0;

	config_found(self, &waa, cfbprint);
}

int
cfbprint(aux, pnp)
	void *aux;
	const char *pnp;
{

	if (pnp)
		printf("wscons at %s", pnp);
	return (UNCONF);
d315 1
a315 1
	if (offset >= CFB_SIZE || offset < 0)
d331 47
d379 3
a381 5
void
tga_console(bc, pc, bus, device, function)
	bus_chipset_tag_t bc;
	pci_chipset_tag_t pc;
	int bus, device, function;
d383 2
a384 2
	struct tga_devconfig *dcp = &tga_console_dc;
	struct wscons_odev_spec wo;
d386 1
a386 1
	tga_getdevconfig(bc, pc, pci_make_tag(pc, bus, device, function), dcp);
d388 4
a391 22
	/* sanity checks */
	if (dcp->dc_vaddr == NULL)
		panic("tga_console(%d, %d): couldn't map memory space",
		    device, function);
	if (dcp->dc_tgaconf == NULL)
		panic("tga_console(%d, %d): unknown board configuration",
		    device, function);

	/*
	 * Initialize the RAMDAC but DO NOT allocate any private storage.
	 * Initialization includes disabling cursor, setting a sane
	 * colormap, etc.  It will be reinitialized in tgaattach().
	 */
	(*dcp->dc_tgaconf->tgac_ramdac->tgar_init)(dcp, 0);

	wo.wo_ef = &tga_emulfuncs;
	wo.wo_efa = &dcp->dc_rcons;
	wo.wo_nrows = dcp->dc_rcons.rc_maxrow;
	wo.wo_ncols = dcp->dc_rcons.rc_maxcol;
	wo.wo_crow = 0;
	wo.wo_ccol = 0;
	/* ioctl and mmap are unused until real attachment. */
d393 2
a394 1
	wscons_attach_console(&wo);
@


1.10.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfb.c,v 1.12 2001/02/01 18:05:30 art Exp $	*/
d46 3
d52 1
a52 1
#include <dev/wscons/wsdisplayvar.h>
d64 1
a75 1
tc_addr_t cfb_consaddr;
d77 1
a77 1
struct wsdisplay_emulops cfb_emulfuncs = {
d79 1
a79 2
	rcons_mapchar,
	rcons_putchar,
d84 1
a84 17
	rcons_alloc_attr
};

struct wsscreen_descr cfb_stdscreen = {
        "std",
        0, 0,        /* will be filled in -- XXX shouldn't, it's global */
        &cfb_emulfuncs,
        0, 0
};

const struct wsscreen_descr *_cfb_scrlist[] = {
        &cfb_stdscreen,
        /* XXX other formats, graphics screen? */
};

struct wsscreen_list cfb_screenlist = {
        sizeof(_cfb_scrlist) / sizeof(struct wsscreen_descr *), _cfb_scrlist
d88 1
a88 1
paddr_t	cfbmmap __P((void *, off_t, int));
a90 13
static int      cfb_alloc_screen __P((void *, const struct wsscreen_descr *,
		          void **, int *, int *, long *));
static void     cfb_free_screen __P((void *, void *));
static int      cfb_show_screen __P((void *, void *, int,
                                     void (*) (void *, int, int), void *));

struct wsdisplay_accessops cfb_accessops = {
	cfbioctl,
	cfbmmap,
	cfb_alloc_screen,
	cfb_free_screen,
	cfb_show_screen,
};
a168 3

	cfb_stdscreen.nrows = dc->dc_rcons.rc_maxrow;
	cfb_stdscreen.ncols = dc->dc_rcons.rc_maxcol;
d178 2
a179 1
	struct wsemuldisplaydev_attach_args waa;
d182 2
a183 2
	console = (ta->ta_addr == cfb_consaddr);
	if (console) {
d185 1
a185 2
		sc->nscreens = 1;
	} else {
d202 5
a206 4
	waa.console = console;
	waa.scrdata = &cfb_screenlist;
	waa.accessops = &cfb_accessops;
	waa.accesscookie = sc;
d208 21
a228 1
	config_found(self, &waa, wsemuldisplaydevprint);
d298 1
a298 1
paddr_t
d306 1
a306 1
	if (offset > CFB_SIZE)
d322 1
a322 23
int 
cfb_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
{
	struct cfb_softc *sc = v;
	long defattr;

	if (sc->nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_dc->dc_rcons; /* one and only for now */
	*curxp = 0;
	*curyp = 0;
	rcons_alloc_attr(&sc->sc_dc->dc_rcons, 0, 0, 0, &defattr);
	*attrp = defattr;
	sc->nscreens++;
	return(0);
}

d324 4
a327 19
cfb_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct cfb_softc *sc = v;

	if (sc->sc_dc == &cfb_console_dc)
		panic("cfb_free_screen: console");

	sc->nscreens--;
}

int
cfb_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb) __P((void *, int, int));
	void *cbarg;
d329 2
a330 2
	return (0);
}
d332 1
a332 7
#if 0
int 
cfb_cnattach(addr)
	tc_addr_t addr;
{
	struct cfb_devconfig *dc = &cfb_console_dc;
	long defattr;
d334 22
a355 6
	cfb_getdevconfig(addr, dcp);

	rcons_alloc_attr(&dcp->dc_rcons, 0, 0, 0, &defattr);
	
	wsdisplay_cnattach(&cfb_stdscreen, &dcp->dc_rcons,
		0,0, defattr;);
d357 1
a357 2
	cfb_consaddr = addr;
	return (0);
@


1.10.6.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 1
a56 1
int	cfbmatch(struct device *, void *, void *);
d58 1
a58 1
int	cfbmatch(struct device *, struct cfdata *, void *);
d60 1
a60 1
void	cfbattach(struct device *, struct device *, void *);
d70 1
a70 1
void	cfb_getdevconfig(tc_addr_t dense_addr, struct cfb_devconfig *dc);
d101 2
a102 2
int	cfbioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	cfbmmap(void *, off_t, int);
d104 6
a109 6
int	cfbintr(void *);
static int      cfb_alloc_screen(void *, const struct wsscreen_descr *,
		    void **, int *, int *, long *);
static void     cfb_free_screen(void *, void *);
static int      cfb_show_screen(void *, void *, int,
		    void (*) (void *, int, int), void *);
d372 1
a372 1
	void (*cb)(void *, int, int);
@


1.9
log
@Add some missing things for the MI vga driver.  Move wscons to an MI place as
well.  $OpenBSD$ tagging
@
text
@d1 1
a1 1
/*	$OpenBSD: cfb.c,v 1.8 1997/07/31 13:40:03 kstailey Exp $	*/
d306 2
a307 2
	if (offset > CFB_SIZE)
		return -1;
@


1.8
log
@text video attributes, tested only on vga, send me E-mail if it breaks something, thx.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfb.c,v 1.7 1997/01/24 19:58:08 niklas Exp $	*/
d51 2
a52 2
#include <alpha/wscons/wscons_raster.h>
#include <alpha/wscons/wsconsvar.h>
@


1.7
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: cfb.c,v 1.6 1996/12/08 00:20:55 niklas Exp $	*/
d84 1
@


1.6
log
@Merge to NetBSD 961107, i.e. mostly new bus.h
@
text
@d1 2
a2 2
/*	$OpenBSD: cfb.c,v 1.5 1996/11/23 21:44:57 kstailey Exp $	*/
/*	$NetBSD: cfb.c,v 1.5 1996/10/13 03:00:27 christos Exp $	*/
d58 1
d60 3
d86 2
a87 2
int	cfbioctl __P((struct device *, u_long, caddr_t, int, struct proc *));
int	cfbmmap __P((struct device *, off_t, int));
d94 6
a99 1
	void *match, *aux;
d203 8
a210 2
	wo->wo_ef = &cfb_emulfuncs;
	wo->wo_efa = &sc->sc_dc->dc_rcons;
a214 2
	wo->wo_ioctl = cfbioctl;
	wo->wo_mmap = cfbmmap;
d231 2
a232 2
cfbioctl(dev, cmd, data, flag, p)
	struct device *dev;
d238 1
a238 1
	struct cfb_softc *sc = (struct cfb_softc *)dev;
d298 2
a299 2
cfbmmap(dev, offset, prot)
	struct device *dev;
d303 1
a303 1
	struct cfb_softc *sc = (struct cfb_softc *)dev;
@


1.5
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: cfb.c,v 1.4 1996/11/12 20:29:42 niklas Exp $	*/
d40 1
a40 1
#include <machine/bus.old.h>
@


1.4
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$OpenBSD: cfb.c,v 1.3 1996/10/30 22:41:01 niklas Exp $	*/
d60 1
a60 1
int	cfbprint __P((void *, /* const */ char *));
d209 1
a209 1
	/* const */ char *pnp;
@


1.3
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfb.c,v 1.5 1996/10/13 03:00:27 christos Exp $	*/
d40 1
a40 1
#include <machine/bus.h>
@


1.2
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: cfb.c,v 1.1 1996/05/01 23:25:03 cgd Exp $	*/
/*	$NetBSD: cfb.c,v 1.1 1996/05/01 23:25:03 cgd Exp $	*/
d60 1
a60 1
int	cfbprint __P((void *, char *));
a91 1
	struct cfdata *cf = match;
d111 1
a111 1
	dc->dc_paddr = k0segtophys(dc->dc_vaddr);		/* XXX */
a170 1
	char *x;
d209 1
a209 1
	char *pnp;
@


1.1
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@
