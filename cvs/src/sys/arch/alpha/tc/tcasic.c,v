head	1.16;
access;
symbols
	OPENBSD_6_2_BASE:1.16
	OPENBSD_6_1:1.16.0.28
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.24
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.20
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.22
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.14
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.18
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.16
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.12
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.10
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.8
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.6
	OPENBSD_5_0:1.16.0.4
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.15.0.18
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.14
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.16
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.12
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.10
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.8
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.13.0.8
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.6
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.8
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.6
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.12
	UBC:1.8.0.6
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.7.0.18
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.16
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.14
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.12
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.10
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.8
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.16
date	2010.11.11.17.54.52;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.15.20.08.29;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.16.22.32.01;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.06.28.02.28.43;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.03.00.04.26;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.02.23.45.44;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.02.22.56.06;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.28;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.08.16.01.26;	author art;	state Exp;
branches
	1.8.6.1;
next	1.7;

1.7
date	97.01.24.19.58.21;	author niklas;	state Exp;
branches
	1.7.14.1;
next	1.6;

1.6
date	96.12.08.00.21.00;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.11.23.21.45.01;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.10.30.22.41.24;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.07.29.23.02.32;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.18.09.45.28;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.26.18.12.08;	author deraadt;	state Exp;
branches;
next	;

1.7.14.1
date	2001.04.18.16.01.52;	author niklas;	state Exp;
branches;
next	1.7.14.2;

1.7.14.2
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	1.7.14.3;

1.7.14.3
date	2003.03.27.23.18.07;	author niklas;	state Exp;
branches;
next	;

1.8.6.1
date	2002.06.11.03.33.41;	author art;	state Exp;
branches;
next	;


desc
@@


1.16
log
@DEC 3000/400 has a 22.5MHz TURBOchannel bus instead of the usual 25MHz;
correctly report this.

Then, in asc@@tc, compute synchronous transfer periods (involving the bus
clock) with a better accuracy.

ok krw@@
@
text
@/* $OpenBSD: tcasic.c,v 1.15 2006/06/15 20:08:29 brad Exp $ */
/* $NetBSD: tcasic.c,v 1.36 2001/08/23 01:16:52 nisimura Exp $ */

/*
 * Copyright (c) 1994, 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <machine/autoconf.h>
#include <machine/rpb.h>
#include <machine/cpu.h>

#include <dev/tc/tcvar.h>
#include <alpha/tc/tc_conf.h>

/* Definition of the driver for autoconfig. */
int	tcasicmatch(struct device *, void *, void *);
void	tcasicattach(struct device *, struct device *, void *);

struct cfattach tcasic_ca = {
	sizeof (struct device), tcasicmatch, tcasicattach,
};

struct cfdriver tcasic_cd = {
	NULL, "tcasic", DV_DULL,
};


int	tcasicprint(void *, const char *);

/* There can be only one. */
int	tcasicfound;

int
tcasicmatch(parent, cfdata, aux)
	struct device *parent;
	void *cfdata, *aux;
{
	struct mainbus_attach_args *ma = aux;

        /* Make sure that we're looking for a TurboChannel ASIC. */
        if (strcmp(ma->ma_name, tcasic_cd.cd_name))
                return (0);

	if (tcasicfound)
		return (0);

	return (1);
}

void
tcasicattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct tcbus_attach_args tba;
	void (*intr_setup)(void);
	void (*iointr)(void *, unsigned long);

	printf("\n");
	tcasicfound = 1;

	switch (cputype) {
#ifdef DEC_3000_500
	case ST_DEC_3000_500:

		intr_setup = tc_3000_500_intr_setup;
		iointr = tc_3000_500_iointr;

		if ((hwrpb->rpb_type & SV_ST_MASK) == SV_ST_SANDPIPER)
			tba.tba_speed = TC_SPEED_22_5_MHZ;
		else
			tba.tba_speed = TC_SPEED_25_MHZ;
		tba.tba_nslots = tc_3000_500_nslots;
		tba.tba_slots = tc_3000_500_slots;
		if (hwrpb->rpb_variation & SV_GRAPHICS) {
			tba.tba_nbuiltins = tc_3000_500_graphics_nbuiltins;
			tba.tba_builtins = tc_3000_500_graphics_builtins;
		} else {
			tba.tba_nbuiltins = tc_3000_500_nographics_nbuiltins;
			tba.tba_builtins = tc_3000_500_nographics_builtins;
		}
		tba.tba_intr_establish = tc_3000_500_intr_establish;
		tba.tba_intr_disestablish = tc_3000_500_intr_disestablish;
		tba.tba_get_dma_tag = tc_dma_get_tag_3000_500;

		/* Do 3000/500-specific DMA setup now. */
		tc_dma_init_3000_500(tc_3000_500_nslots);
		break;
#endif /* DEC_3000_500 */

#ifdef DEC_3000_300
	case ST_DEC_3000_300:

		intr_setup = tc_3000_300_intr_setup;
		iointr = tc_3000_300_iointr;

		tba.tba_speed = TC_SPEED_12_5_MHZ;
		tba.tba_nslots = tc_3000_300_nslots;
		tba.tba_slots = tc_3000_300_slots;
		tba.tba_nbuiltins = tc_3000_300_nbuiltins;
		tba.tba_builtins = tc_3000_300_builtins;
		tba.tba_intr_establish = tc_3000_300_intr_establish;
		tba.tba_intr_disestablish = tc_3000_300_intr_disestablish;
		tba.tba_get_dma_tag = tc_dma_get_tag_3000_300;
		break;
#endif /* DEC_3000_300 */

	default:
		panic("tcasicattach: bad cputype");
	}

	tba.tba_busname = "tc";
	tba.tba_memt = tc_bus_mem_init(NULL);
	
	tc_dma_init();

	(*intr_setup)();

	/* They all come in at 0x800. */
	scb_set(0x800, iointr, NULL);

	config_found(self, &tba, tcasicprint);
}

int
tcasicprint(aux, pnp)
	void *aux;
	const char *pnp;
{

	/* only TCs can attach to tcasics; easy. */
	if (pnp)
		printf("tc at %s", pnp);
	return (UNCONF);
}

#ifdef notyet

#include "wsdisplay.h"

#if NWSDISPLAY > 0

#include "sfb.h"
#include "sfbp.h"
#include "cfb.h"
#include "mfb.h"
#include "tfb.h"
#include "px.h"
#include "pxg.h"

extern void	sfb_cnattach(tc_addr_t);
extern void	sfbp_cnattach(tc_addr_t);
extern void	cfb_cnattach(tc_addr_t);
extern void	mfb_cnattach(tc_addr_t);
extern void	tfb_cnattach(tc_addr_t);
extern void	px_cnattach(tc_addr_t);
extern void	pxg_cnattach(tc_addr_t);
extern int	tc_checkslot(tc_addr_t, char *);

struct cnboards {
	const char	*cb_tcname;
	void	(*cb_cnattach)(tc_addr_t);
} static const cnboards[] = {
#if NSFB > 0
	{ "PMAGB-BA", sfb_cnattach },
#endif
#if NSFBP > 0
	{ "PMAGD   ", sfbp_cnattach },
#endif
#if NCFB > 0
	{ "PMAG-BA ", cfb_cnattach },
#endif
#if NMFB > 0
	{ "PMAG-AA ", mfb_cnattach },
#endif
#if NTFB > 0
	{ "PMAG-JA ", tfb_cnattach },
#endif
#if NPX > 0
	{ "PMAG-CA ", px_cnattach },
#endif
#if NPXG > 0
	{ "PMAG-DA ", pxg_cnattach },
	{ "PMAG-FA ", pxg_cnattach },
	{ "PMAG-FB ", pxg_cnattach },
	{ "PMAGB-FA", pxg_cnattach },
	{ "PMAGB-FB", pxg_cnattach },
#endif
};

/*
 * tc_fb_cnattach --
 *	Attempt to attach the appropriate display driver to the
 * output console.
 */
int
tc_fb_cnattach(tcaddr)
	tc_addr_t tcaddr;
{
	char tcname[TC_ROM_LLEN];
	int i;

	if (tc_badaddr(tcaddr) || (tc_checkslot(tcaddr, tcname) == 0))
		return (EINVAL);

	for (i = 0; i < sizeof(cnboards) / sizeof(cnboards[0]); i++)
		if (strncmp(tcname, cnboards[i].cb_tcname, TC_ROM_LLEN) == 0)
			break;

	if (i == sizeof(cnboards) / sizeof(cnboards[0]))
		return (ENXIO);

	(cnboards[i].cb_cnattach)(tcaddr);
	return (0);
}
#endif /* if NWSDISPLAY > 0 */

#else

int
tc_fb_cnattach(tcaddr)
	tc_addr_t tcaddr;
{
		return (ENXIO);
}
#endif
@


1.15
log
@Rework the interrupt code, shaving some cycles off in the process.
Rather than an "iointr" routine that decomposes a vector into an
IRQ, we maintain a vector table directly, hooking up each "iointr"
routine at the correct vector. This also allows us to hook device
interrupts up to specific vectors.

From thorpej NetBSD

Tested by myself and a number of end-users.
@
text
@d1 1
a1 1
/* $OpenBSD: tcasic.c,v 1.14 2006/03/16 22:32:01 miod Exp $ */
d97 4
a100 1
		tba.tba_speed = TC_SPEED_25_MHZ;
@


1.14
log
@Get rid of redundant check in tcasicmatch() - we will only request "tcasic"
as platform.iobus on tc-capable machines.
@
text
@d1 1
a1 1
/* $OpenBSD: tcasic.c,v 1.13 2004/06/28 02:28:43 aaron Exp $ */
d143 3
a145 1
	set_iointr(iointr);
@


1.13
log
@Use new event counter API for interrupt counting on alpha.  By me, with some
edits by Theo.  deraadt@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: tcasic.c,v 1.12 2002/05/03 00:04:26 millert Exp $ */
a69 4

        /* Make sure that the system supports a TurboChannel ASIC. */
	if ((cputype != ST_DEC_3000_500) && (cputype != ST_DEC_3000_300))
		return (0);
@


1.12
log
@Need a dummy tc_fb_cnattach() until we have real fb support on
TURBOchannel machines.
@
text
@d1 1
a1 1
/* $OpenBSD: tcasic.c,v 1.11 2002/05/02 23:45:44 miod Exp $ */
a110 1
		tba.tba_intr_evcnt = tc_3000_500_intr_evcnt;
a130 1
		tba.tba_intr_evcnt = tc_3000_300_intr_evcnt;
@


1.11
log
@Oops, it's too early for this chunk of code... spotted by millert@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tcasic.c,v 1.10 2002/05/02 22:56:06 miod Exp $ */
d247 8
@


1.10
log
@Big TURBOchannel support catchup from NetBSD, part 1.
A few local changes and tweaks remain.

This bring DEC 3000 machines back in the game, but framebuffers are still
not supported at the moment.

Thanks to ericj@@ and nate@@ for supplying me a DEC 3000 for testing.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d166 2
d246 2
@


1.9
log
@First round of __P removal in sys
@
text
@d1 2
a2 2
/*	$OpenBSD: tcasic.c,v 1.8 2000/11/08 16:01:26 art Exp $	*/
/*	$NetBSD: tcasic.c,v 1.14 1996/12/05 01:39:45 cgd Exp $	*/
d37 1
a42 1
#ifdef __BROKEN_INDIRECT_CONFIG
a43 3
#else
int	tcasicmatch(struct device *, struct cfdata *, void *);
#endif
d54 1
a56 2
extern int cputype;

d63 1
a63 6
#ifdef __BROKEN_INDIRECT_CONFIG
	void *cfdata;
#else
	struct cfdata *cfdata;
#endif
	void *aux;
a100 1
		tba.tba_busname = "tc";
d111 1
d114 4
a126 1
		tba.tba_busname = "tc";
d132 1
d135 1
d143 1
d145 2
a146 7

	/* XXX XXX BEGIN XXX XXX */
	{							/* XXX */
		extern vm_offset_t alpha_XXX_dmamap_or;		/* XXX */
		alpha_XXX_dmamap_or = 0;			/* XXX */
	}							/* XXX */
	/* XXX XXX END XXX XXX */
d165 79
@


1.8
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcasic.c,v 1.7 1997/01/24 19:58:21 niklas Exp $	*/
d57 1
a57 1
int	tcasicprint __P((void *, const char *));
d97 2
a98 2
	void (*intr_setup) __P((void));
	void (*iointr) __P((void *, unsigned long));
@


1.8.6.1
log
@Sync UBC branch to -current
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* $NetBSD: tcasic.c,v 1.36 2001/08/23 01:16:52 nisimura Exp $ */
a36 1
#include <machine/cpu.h>
d42 1
d44 3
d57 1
d59 1
a59 1
int	tcasicprint(void *, const char *);
d67 6
a72 1
	void *cfdata, *aux;
d97 2
a98 2
	void (*intr_setup)(void);
	void (*iointr)(void *, unsigned long);
d110 1
a120 1
		tba.tba_intr_evcnt = tc_3000_500_intr_evcnt;
a122 4
		tba.tba_get_dma_tag = tc_dma_get_tag_3000_500;

		/* Do 3000/500-specific DMA setup now. */
		tc_dma_init_3000_500(tc_3000_500_nslots);
d132 1
a137 1
		tba.tba_intr_evcnt = tc_3000_300_intr_evcnt;
a139 1
		tba.tba_get_dma_tag = tc_dma_get_tag_3000_300;
a146 1
	tba.tba_busname = "tc";
d148 7
a154 2
	
	tc_dma_init();
a172 91

#ifdef notyet

#include "wsdisplay.h"

#if NWSDISPLAY > 0

#include "sfb.h"
#include "sfbp.h"
#include "cfb.h"
#include "mfb.h"
#include "tfb.h"
#include "px.h"
#include "pxg.h"

extern void	sfb_cnattach(tc_addr_t);
extern void	sfbp_cnattach(tc_addr_t);
extern void	cfb_cnattach(tc_addr_t);
extern void	mfb_cnattach(tc_addr_t);
extern void	tfb_cnattach(tc_addr_t);
extern void	px_cnattach(tc_addr_t);
extern void	pxg_cnattach(tc_addr_t);
extern int	tc_checkslot(tc_addr_t, char *);

struct cnboards {
	const char	*cb_tcname;
	void	(*cb_cnattach)(tc_addr_t);
} static const cnboards[] = {
#if NSFB > 0
	{ "PMAGB-BA", sfb_cnattach },
#endif
#if NSFBP > 0
	{ "PMAGD   ", sfbp_cnattach },
#endif
#if NCFB > 0
	{ "PMAG-BA ", cfb_cnattach },
#endif
#if NMFB > 0
	{ "PMAG-AA ", mfb_cnattach },
#endif
#if NTFB > 0
	{ "PMAG-JA ", tfb_cnattach },
#endif
#if NPX > 0
	{ "PMAG-CA ", px_cnattach },
#endif
#if NPXG > 0
	{ "PMAG-DA ", pxg_cnattach },
	{ "PMAG-FA ", pxg_cnattach },
	{ "PMAG-FB ", pxg_cnattach },
	{ "PMAGB-FA", pxg_cnattach },
	{ "PMAGB-FB", pxg_cnattach },
#endif
};

/*
 * tc_fb_cnattach --
 *	Attempt to attach the appropriate display driver to the
 * output console.
 */
int
tc_fb_cnattach(tcaddr)
	tc_addr_t tcaddr;
{
	char tcname[TC_ROM_LLEN];
	int i;

	if (tc_badaddr(tcaddr) || (tc_checkslot(tcaddr, tcname) == 0))
		return (EINVAL);

	for (i = 0; i < sizeof(cnboards) / sizeof(cnboards[0]); i++)
		if (strncmp(tcname, cnboards[i].cb_tcname, TC_ROM_LLEN) == 0)
			break;

	if (i == sizeof(cnboards) / sizeof(cnboards[0]))
		return (ENXIO);

	(cnboards[i].cb_cnattach)(tcaddr);
	return (0);
}
#endif /* if NWSDISPLAY > 0 */

#else

int
tc_fb_cnattach(tcaddr)
	tc_addr_t tcaddr;
{
		return (ENXIO);
}
#endif
@


1.7
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: tcasic.c,v 1.6 1996/12/08 00:21:00 niklas Exp $	*/
d74 1
a74 1
	struct confargs *ca = aux;
d77 1
a77 1
        if (strcmp(ca->ca_name, tcasic_cd.cd_name))
@


1.7.14.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcasic.c,v 1.8 2000/11/08 16:01:26 art Exp $	*/
d74 1
a74 1
	struct mainbus_attach_args *ma = aux;
d77 1
a77 1
        if (strcmp(ma->ma_name, tcasic_cd.cd_name))
@


1.7.14.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 1
a57 1
int	tcasicprint(void *, const char *);
d97 2
a98 2
	void (*intr_setup)(void);
	void (*iointr)(void *, unsigned long);
@


1.7.14.3
log
@Sync the SMP branch with 3.3
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* $NetBSD: tcasic.c,v 1.36 2001/08/23 01:16:52 nisimura Exp $ */
a36 1
#include <machine/cpu.h>
d42 1
d44 3
d57 1
d59 1
a59 1
int	tcasicprint(void *, const char *);
d67 6
a72 1
	void *cfdata, *aux;
d110 1
a120 1
		tba.tba_intr_evcnt = tc_3000_500_intr_evcnt;
a122 4
		tba.tba_get_dma_tag = tc_dma_get_tag_3000_500;

		/* Do 3000/500-specific DMA setup now. */
		tc_dma_init_3000_500(tc_3000_500_nslots);
d132 1
a137 1
		tba.tba_intr_evcnt = tc_3000_300_intr_evcnt;
a139 1
		tba.tba_get_dma_tag = tc_dma_get_tag_3000_300;
a146 1
	tba.tba_busname = "tc";
d148 7
a154 2
	
	tc_dma_init();
a172 91

#ifdef notyet

#include "wsdisplay.h"

#if NWSDISPLAY > 0

#include "sfb.h"
#include "sfbp.h"
#include "cfb.h"
#include "mfb.h"
#include "tfb.h"
#include "px.h"
#include "pxg.h"

extern void	sfb_cnattach(tc_addr_t);
extern void	sfbp_cnattach(tc_addr_t);
extern void	cfb_cnattach(tc_addr_t);
extern void	mfb_cnattach(tc_addr_t);
extern void	tfb_cnattach(tc_addr_t);
extern void	px_cnattach(tc_addr_t);
extern void	pxg_cnattach(tc_addr_t);
extern int	tc_checkslot(tc_addr_t, char *);

struct cnboards {
	const char	*cb_tcname;
	void	(*cb_cnattach)(tc_addr_t);
} static const cnboards[] = {
#if NSFB > 0
	{ "PMAGB-BA", sfb_cnattach },
#endif
#if NSFBP > 0
	{ "PMAGD   ", sfbp_cnattach },
#endif
#if NCFB > 0
	{ "PMAG-BA ", cfb_cnattach },
#endif
#if NMFB > 0
	{ "PMAG-AA ", mfb_cnattach },
#endif
#if NTFB > 0
	{ "PMAG-JA ", tfb_cnattach },
#endif
#if NPX > 0
	{ "PMAG-CA ", px_cnattach },
#endif
#if NPXG > 0
	{ "PMAG-DA ", pxg_cnattach },
	{ "PMAG-FA ", pxg_cnattach },
	{ "PMAG-FB ", pxg_cnattach },
	{ "PMAGB-FA", pxg_cnattach },
	{ "PMAGB-FB", pxg_cnattach },
#endif
};

/*
 * tc_fb_cnattach --
 *	Attempt to attach the appropriate display driver to the
 * output console.
 */
int
tc_fb_cnattach(tcaddr)
	tc_addr_t tcaddr;
{
	char tcname[TC_ROM_LLEN];
	int i;

	if (tc_badaddr(tcaddr) || (tc_checkslot(tcaddr, tcname) == 0))
		return (EINVAL);

	for (i = 0; i < sizeof(cnboards) / sizeof(cnboards[0]); i++)
		if (strncmp(tcname, cnboards[i].cb_tcname, TC_ROM_LLEN) == 0)
			break;

	if (i == sizeof(cnboards) / sizeof(cnboards[0]))
		return (ENXIO);

	(cnboards[i].cb_cnattach)(tcaddr);
	return (0);
}
#endif /* if NWSDISPLAY > 0 */

#else

int
tc_fb_cnattach(tcaddr)
	tc_addr_t tcaddr;
{
		return (ENXIO);
}
#endif
@


1.6
log
@Merge to NetBSD 961107, i.e. mostly new bus.h
@
text
@d1 2
a2 2
/*	$OpenBSD: tcasic.c,v 1.5 1996/11/23 21:45:01 kstailey Exp $	*/
/*	$NetBSD: tcasic.c,v 1.12 1996/10/23 04:12:38 cgd Exp $	*/
d42 1
d44 3
d67 1
d69 3
d114 7
a120 2
		tba.tba_nbuiltins = tc_3000_500_nbuiltins;
		tba.tba_builtins = tc_3000_500_builtins;
@


1.5
log
@added const to second parameter of cfprint_t routines
@
text
@d1 2
a2 2
/*	$OpenBSD: tcasic.c,v 1.4 1996/10/30 22:41:24 niklas Exp $	*/
/*	$NetBSD: tcasic.c,v 1.10 1996/10/13 03:00:39 christos Exp $	*/
a90 1
	struct alpha_bus_chipset bc;
d134 8
a141 3
	tc_bus_io_init(&bc, NULL);
	tc_bus_mem_init(&bc, NULL);
	tba.tba_bc = &bc;
@


1.4
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcasic.c,v 1.10 1996/10/13 03:00:39 christos Exp $	*/
d53 1
a53 1
int	tcasicprint __P((void *, /* const */ char *));
d148 1
a148 1
	/* const */ char *pnp;
@


1.3
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: tcasic.c,v 1.5 1996/05/17 23:58:43 cgd Exp $	*/
/*	$NetBSD: tcasic.c,v 1.5 1996/05/17 23:58:43 cgd Exp $	*/
d32 1
d53 1
a53 1
int	tcasicprint __P((void *, char *));
d90 1
a90 1
	void (*iointr) __P((void *, int));
d148 1
a148 1
	char *pnp;
@


1.2
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.1
log
@from netbsd:
machine-independent TurboChannel bus configuration.  These files
deal with stuff like:
        (1) configuring built-in devices,
        (2) looking at TC slots configuring any devices found.
The lists of slots, slot locations, etc. and built-in devices
are provided by machine-dependent code.  Interrupt handling
is also provided by machine-dependent code, but the MD code provides
hooks so that standard names for 'establish' and 'disestablish'
can be used in drivers.

This code requires <machine/tc_machdep.h>, which defines some
portability types specific to the TurboChannel bus code.
@
text
@d1 1
a1 1
/*	$NetBSD: tcasic.c,v 1.1 1995/12/20 00:43:34 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1994, 1995 Carnegie-Mellon University.
d42 8
a49 3
struct cfdriver tcasiccd =
    { NULL, "tcasic", tcasicmatch, tcasicattach, DV_DULL,
    sizeof (struct device) };
d67 1
a67 1
        if (strcmp(ca->ca_name, tcasiccd.cd_name))
d86 1
a86 1
	struct tc_attach_args tc;
d89 1
d91 1
a96 1
		printf(": 25MHz\n");
d101 8
a108 6
		tc.tca_nslots = tc_3000_500_nslots;
		tc.tca_slots = tc_3000_500_slots;
		tc.tca_nbuiltins = tc_3000_500_nbuiltins;
		tc.tca_builtins = tc_3000_500_builtins;
		tc.tca_intr_establish = tc_3000_500_intr_establish;
		tc.tca_intr_disestablish = tc_3000_500_intr_disestablish;
a113 1
		printf(": 12.5MHz\n");
d118 8
a125 6
		tc.tca_nslots = tc_3000_300_nslots;
		tc.tca_slots = tc_3000_300_slots;
		tc.tca_nbuiltins = tc_3000_300_nbuiltins;
		tc.tca_builtins = tc_3000_300_builtins;
		tc.tca_intr_establish = tc_3000_300_intr_establish;
		tc.tca_intr_disestablish = tc_3000_300_intr_disestablish;
a129 1
		printf("\n");
d133 4
d140 1
a140 1
	config_found(self, &tc, tcasicprint);
@
