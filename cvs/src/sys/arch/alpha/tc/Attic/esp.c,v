head	1.11;
access;
symbols
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	UBC_SYNC_A:1.11
	UBC_SYNC_B:1.11
	OPENBSD_2_7:1.10.0.4
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.2
	SMP_BASE:1.10
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.6
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.8.0.6
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2000.07.05.21.50.39;	author ericj;	state dead;
branches;
next	1.10;

1.10
date	2000.02.04.17.30.07;	author deraadt;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	98.08.04.23.15.20;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.01.24.19.58.10;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.11.23.21.44.59;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	96.10.30.22.41.04;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.10.18.16.12.01;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.07.29.23.02.00;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.06.18.09.45.12;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.26.18.11.56;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.49;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.49;	author deraadt;	state Exp;
branches;
next	;

1.10.2.1
date	2001.04.18.16.01.50;	author niklas;	state dead;
branches;
next	;


desc
@@


1.11
log
@
change the esp scsi driver name to asc as not to conflict with
the ncr53c9x driver. ok niklas@@
@
text
@/*	$OpenBSD: esp.c,v 1.10 2000/02/04 17:30:07 deraadt Exp $	*/
/*	$NetBSD: esp.c,v 1.26 1996/12/05 01:39:40 cgd Exp $	*/

#ifdef __sparc__
#define	SPARC_DRIVER
#endif

/*
 * Copyright (c) 1996 Charles M. Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles M. Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1994 Peter Galbavy
 * Copyright (c) 1995 Paul Kranenburg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Peter Galbavy
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Based on aic6360 by Jarle Greipsland
 *
 * Acknowledgements: Many of the algorithms used in this driver are
 * inspired by the work of Julian Elischer (julian@@tfs.com) and
 * Charles Hannum (mycroft@@duality.gnu.ai.mit.edu).  Thanks a million!
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/buf.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/queue.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/scsi_message.h>

#include <machine/cpu.h>
#ifdef SPARC_DRIVER
#include <machine/autoconf.h>
#include <sparc/dev/sbusvar.h>
#include <sparc/dev/dmareg.h>
#include <sparc/dev/dmavar.h>
#include <sparc/dev/espreg.h>
#include <sparc/dev/espvar.h>
#else
#include <machine/autoconf.h>	/* badaddr() prototype */
#include <dev/tc/tcvar.h>
#include <alpha/tc/tcdsvar.h>
#include <alpha/tc/espreg.h>
#include <alpha/tc/espvar.h>
#endif

int esp_debug = 0; /*ESP_SHOWPHASE|ESP_SHOWMISC|ESP_SHOWTRAC|ESP_SHOWCMDS;*/

/*static*/ void	espattach	__P((struct device *, struct device *,
				    void *));
/*static*/ int	espprint	__P((void *, const char *));
#ifdef __BROKEN_INDIRECT_CONFIG
/*static*/ int	espmatch	__P((struct device *, void *, void *));
#else
/*static*/ int	espmatch	__P((struct device *, struct cfdata *,
				    void *));
#endif
/*static*/ u_int	esp_adapter_info __P((struct esp_softc *));
/*static*/ void	espreadregs	__P((struct esp_softc *));
/*static*/ void	esp_select	__P((struct esp_softc *, struct esp_ecb *));
/*static*/ int esp_reselect	__P((struct esp_softc *, int));
/*static*/ void	esp_scsi_reset	__P((struct esp_softc *));
/*static*/ void	esp_reset	__P((struct esp_softc *));
/*static*/ void	espinit	__P((struct esp_softc *, int));
/*static*/ int	esp_scsi_cmd	__P((struct scsi_xfer *));
/*static*/ int	esp_poll	__P((struct esp_softc *, struct scsi_xfer *,
				    int));
/*static*/ void	esp_sched	__P((struct esp_softc *));
/*static*/ void	esp_done	__P((struct esp_softc *, struct esp_ecb *));
/*static*/ void	esp_msgin	__P((struct esp_softc *));
/*static*/ void	esp_msgout	__P((struct esp_softc *));
/*static*/ int	espintr		__P((struct esp_softc *));
/*static*/ void	esp_timeout	__P((void *arg));
/*static*/ void	esp_abort	__P((struct esp_softc *, struct esp_ecb *));
/*static*/ void esp_dequeue	__P((struct esp_softc *, struct esp_ecb *));
void esp_sense __P((struct esp_softc *, struct esp_ecb *));
void esp_free_ecb __P((struct esp_softc *, struct esp_ecb *, int));
struct esp_ecb *esp_get_ecb __P((struct esp_softc *, int));
static inline int esp_stp2cpb __P((struct esp_softc *, int));
static inline int esp_cpb2stp __P((struct esp_softc *, int));
static inline void esp_setsync __P((struct esp_softc *, struct esp_tinfo *));

/* Linkup to the rest of the kernel */
struct cfattach esp_ca = {
	sizeof(struct esp_softc), espmatch, espattach
};

struct cfdriver esp_cd = {
	NULL, "esp", DV_DULL
};

struct scsi_adapter esp_switch = {
	esp_scsi_cmd,
	minphys,		/* no max at this level; handled by DMA code */
	NULL,
	NULL,
};

struct scsi_device esp_dev = {
	NULL,			/* Use default error handler */
	NULL,			/* have a queue, served by this */
	NULL,			/* have no async handler */
	NULL,			/* Use default 'done' routine */
};

/*
 * XXX should go when new generic scsiprint finds its way here
 */
int
espprint(aux, name)
	void *aux;
	const char *name;
{
	if (name != NULL)
		printf("scsibus at %s", name);
	return UNCONF;
}

int
#ifdef __BROKEN_INDIRECT_CONFIG
espmatch(parent, vcf, aux)
#else
espmatch(parent, cf, aux)
#endif
	struct device *parent;
#ifdef __BROKEN_INDIRECT_CONFIG
	void *vcf;
#else
	struct cfdata *cf;
#endif
	void *aux;
{
#ifdef SPARC_DRIVER
#ifdef __BROKEN_INDIRECT_CONFIG
	struct cfdata *cf = vcf;
#endif
	register struct confargs *ca = aux;
	register struct romaux *ra = &ca->ca_ra;

	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
		return (0);
	if (ca->ca_bustype == BUS_SBUS)
		return (1);
	ra->ra_len = NBPG;
	return (probeget(ra->ra_vaddr, 1) != -1);
#else
	struct tcdsdev_attach_args *tcdsdev = aux;

	if (strncmp(tcdsdev->tcdsda_modname, "PMAZ-AA ", TC_ROM_LLEN))
		return (0);
	return (!tc_badaddr(tcdsdev->tcdsda_addr));
#endif
}

/*
 * Attach this instance, and then all the sub-devices
 */
void
espattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
#ifdef SPARC_DRIVER
	register struct confargs *ca = aux;
#else
	register struct tcdsdev_attach_args *tcdsdev = aux;
#endif
	struct esp_softc *sc = (void *)self;
#ifdef SPARC_DRIVER
	struct bootpath *bp;
	int dmachild = strncmp(parent->dv_xname, "dma", 3) == 0;
#endif

#ifdef SPARC_DRIVER
	/*
	 * Make sure things are sane. I don't know if this is ever
	 * necessary, but it seem to be in all of Torek's code.
	 */
	if (ca->ca_ra.ra_nintr != 1) {
		printf(": expected 1 interrupt, got %d\n", ca->ca_ra.ra_nintr);
		return;
	}

	sc->sc_pri = ca->ca_ra.ra_intr[0].int_pri;
	printf(" pri %d", sc->sc_pri);

	/*
	 * Map my registers in, if they aren't already in virtual
	 * address space.
	 */
	if (ca->ca_ra.ra_vaddr)
		sc->sc_reg = (volatile u_char *) ca->ca_ra.ra_vaddr;
	else {
		sc->sc_reg = (volatile u_char *)
		    mapiodev(ca->ca_ra.ra_reg, 0, ca->ca_ra.ra_len, ca->ca_bustype);
	}
#else
	sc->sc_reg = (volatile u_int32_t *)tcdsdev->tcdsda_addr;
	sc->sc_cookie = tcdsdev->tcdsda_cookie;
	sc->sc_dma = tcdsdev->tcdsda_sc;

	printf(": address %p", sc->sc_reg);
	tcds_intr_establish(parent, sc->sc_cookie, TC_IPL_BIO,
	    (int (*)(void *))espintr, sc);
#endif

#ifdef SPARC_DRIVER
	/* Other settings */
	sc->sc_node = ca->ca_ra.ra_node;
	if (ca->ca_bustype == BUS_SBUS) {
		sc->sc_id = getpropint(sc->sc_node, "initiator-id", 7);
		sc->sc_freq = getpropint(sc->sc_node, "clock-frequency", -1);
	} else {
		sc->sc_id = 7;
		sc->sc_freq = 24000000;
	}
	if (sc->sc_freq < 0)
		sc->sc_freq = ((struct sbus_softc *)
		    sc->sc_dev.dv_parent)->sc_clockfreq;
#else
	if (parent->dv_cfdata->cf_driver == &tcds_cd) {
		sc->sc_id = tcdsdev->tcdsda_id;
		sc->sc_freq = tcdsdev->tcdsda_freq;
	} else {
		/* XXX */
		sc->sc_id = 7;
		sc->sc_freq = 24000000;
	}
#endif

	/* gimme Mhz */
	sc->sc_freq /= 1000000;

#ifdef SPARC_DRIVER
	if (dmachild) {
		sc->sc_dma = (struct dma_softc *)parent;
		sc->sc_dma->sc_esp = sc;
	} else {
		/*
		 * find the DMA by poking around the dma device structures
		 *
		 * What happens here is that if the dma driver has not been
		 * configured, then this returns a NULL pointer. Then when the
		 * dma actually gets configured, it does the opposing test, and
		 * if the sc->sc_esp field in it's softc is NULL, then tries to
		 * find the matching esp driver.
		 *
		 */
		sc->sc_dma = (struct dma_softc *)
			getdevunit("dma", sc->sc_dev.dv_unit);

		/*
		 * and a back pointer to us, for DMA
		 */
		if (sc->sc_dma)
			sc->sc_dma->sc_esp = sc;
		else
			panic("espattach: no dma found");
	}
#else
	sc->sc_dma->sc_esp = sc;		/* XXX */
#endif

	/*
	 * It is necessary to try to load the 2nd config register here,
	 * to find out what rev the esp chip is, else the esp_reset
	 * will not set up the defaults correctly.
	 */
	sc->sc_cfg1 = sc->sc_id | ESPCFG1_PARENB;
#ifdef SPARC_DRIVER
	sc->sc_cfg2 = ESPCFG2_SCSI2 | ESPCFG2_RPE;
	sc->sc_cfg3 = ESPCFG3_CDB;
	ESP_WRITE_REG(sc, ESP_CFG2, sc->sc_cfg2);

	if ((ESP_READ_REG(sc, ESP_CFG2) & ~ESPCFG2_RSVD) != (ESPCFG2_SCSI2 | ESPCFG2_RPE)) {
		printf(": ESP100");
		sc->sc_rev = ESP100;
	} else {
		sc->sc_cfg2 = ESPCFG2_SCSI2;
		ESP_WRITE_REG(sc, ESP_CFG2, sc->sc_cfg2);
		sc->sc_cfg3 = 0;
		ESP_WRITE_REG(sc, ESP_CFG3, sc->sc_cfg3);
		sc->sc_cfg3 = (ESPCFG3_CDB | ESPCFG3_FCLK);
		ESP_WRITE_REG(sc, ESP_CFG3, sc->sc_cfg3);
		if (ESP_READ_REG(sc, ESP_CFG3) != (ESPCFG3_CDB | ESPCFG3_FCLK)) {
			printf(": ESP100A");
			sc->sc_rev = ESP100A;
		} else {
			/* ESPCFG2_FE enables > 64K transfers */
			sc->sc_cfg2 |= ESPCFG2_FE;
			sc->sc_cfg3 = 0;
			ESP_WRITE_REG(sc, ESP_CFG3, sc->sc_cfg3);
			printf(": ESP200");
			sc->sc_rev = ESP200;
		}
	}
#else
	sc->sc_cfg2 = ESPCFG2_SCSI2;
	sc->sc_cfg3 = 0x4;		/* Save residual byte. XXX??? */
	printf(": NCR53C94");
	sc->sc_rev = NCR53C94;
#endif

	/*
	 * This is the value used to start sync negotiations
	 * Note that the ESP register "SYNCTP" is programmed
	 * in "clocks per byte", and has a minimum value of 4.
	 * The SCSI period used in negotiation is one-fourth
	 * of the time (in nanoseconds) needed to transfer one byte.
	 * Since the chip's clock is given in MHz, we have the following
	 * formula: 4 * period = (1000 / freq) * 4
	 */
	sc->sc_minsync = 1000 / sc->sc_freq;

#ifdef SPARC_DRIVER
	/*
	 * Alas, we must now modify the value a bit, because it's
	 * only valid when can switch on FASTCLK and FASTSCSI bits
	 * in config register 3...
	 */
	switch (sc->sc_rev) {
	case ESP100:
		sc->sc_maxxfer = 64 * 1024;
		sc->sc_minsync = 0;	/* No synch on old chip? */
		break;
	case ESP100A:
		sc->sc_maxxfer = 64 * 1024;
		sc->sc_minsync = esp_cpb2stp(sc, 5); /* Min clocks/byte is 5 */
		break;
	case ESP200:
		sc->sc_maxxfer = 16 * 1024 * 1024;
		/* XXX - do actually set FAST* bits */
	}
#else
	sc->sc_maxxfer = 64 * 1024;
#endif

	sc->sc_ccf = FREQTOCCF(sc->sc_freq);

	/* The value *must not* be == 1. Make it 2 */
	if (sc->sc_ccf == 1)
		sc->sc_ccf = 2;

	/*
	 * The recommended timeout is 250ms. This register is loaded
	 * with a value calculated as follows, from the docs:
	 *
	 *		(timout period) x (CLK frequency)
	 *	reg = -------------------------------------
	 *		 8192 x (Clock Conversion Factor)
	 *
	 * Since CCF has a linear relation to CLK, this generally computes
	 * to the constant of 153.
	 */
	sc->sc_timeout = ((250 * 1000) * sc->sc_freq) / (8192 * sc->sc_ccf);

	/* CCF register only has 3 bits; 0 is actually 8 */
	sc->sc_ccf &= 7;

	/* Reset state & bus */
	sc->sc_state = 0;
	espinit(sc, 1);

	printf(" %dMhz, target %d\n", sc->sc_freq, sc->sc_id);

#ifdef SPARC_DRIVER
	/* add me to the sbus structures */
	sc->sc_sd.sd_reset = (void *) esp_reset;
#if defined(SUN4C) || defined(SUN4M)
	if (ca->ca_bustype == BUS_SBUS) {
		if (dmachild)
			sbus_establish(&sc->sc_sd, sc->sc_dev.dv_parent);
		else
			sbus_establish(&sc->sc_sd, &sc->sc_dev);
	}
#endif /* SUN4C || SUN4M */
#endif

#ifdef SPARC_DRIVER
	/* and the interuppts */
	sc->sc_ih.ih_fun = (void *) espintr;
	sc->sc_ih.ih_arg = sc;
	intr_establish(sc->sc_pri, &sc->sc_ih);
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);
#endif

	/*
	 * fill in the prototype scsi_link.
	 */
	/* sc->sc_link.channel = SCSI_CHANNEL_ONLY_ONE; */
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter_target = sc->sc_id;
	sc->sc_link.adapter = &esp_switch;
	sc->sc_link.device = &esp_dev;
	sc->sc_link.openings = 2;

	/*
	 * If the boot path is "esp" at the moment and it's me, then
	 * walk our pointer to the sub-device, ready for the config
	 * below.
	 */
#ifdef SPARC_DRIVER
	bp = ca->ca_ra.ra_bp;
	switch (ca->ca_bustype) {
	case BUS_SBUS:
		if (bp != NULL && strcmp(bp->name, "esp") == 0 &&
		    SAME_ESP(sc, bp, ca))
			bootpath_store(1, bp + 1);
		break;
	default:
		if (bp != NULL && strcmp(bp->name, "esp") == 0 &&
			bp->val[0] == -1 && bp->val[1] == sc->sc_dev.dv_unit)
			bootpath_store(1, bp + 1);
		break;
	}
#endif

	/*
	 * Now try to attach all the sub-devices
	 */
	config_found(self, &sc->sc_link, /* scsiprint */ espprint);	/* XXX */

#ifdef SPARC_DRIVER
	bootpath_store(1, NULL);
#endif
}

/*
 * This is the generic esp reset function. It does not reset the SCSI bus,
 * only this controllers, but kills any on-going commands, and also stops
 * and resets the DMA.
 *
 * After reset, registers are loaded with the defaults from the attach
 * routine above.
 */
void
esp_reset(sc)
	struct esp_softc *sc;
{

	/* reset DMA first */
	DMA_RESET(sc->sc_dma);

	/* reset SCSI chip */
	ESPCMD(sc, ESPCMD_RSTCHIP);
	ESPCMD(sc, ESPCMD_NOP);
	DELAY(500);

	/* do these backwards, and fall through */
	switch (sc->sc_rev) {
#ifndef SPARC_DRIVER
	case NCR53C94:
#endif
	case ESP200:
		ESP_WRITE_REG(sc, ESP_CFG3, sc->sc_cfg3);
	case ESP100A:
		ESP_WRITE_REG(sc, ESP_CFG2, sc->sc_cfg2);
	case ESP100:
		ESP_WRITE_REG(sc, ESP_CFG1, sc->sc_cfg1);
		ESP_WRITE_REG(sc, ESP_CCF, sc->sc_ccf);
		ESP_WRITE_REG(sc, ESP_SYNCOFF, 0);
		ESP_WRITE_REG(sc, ESP_TIMEOUT, sc->sc_timeout);
		break;
	default:
		printf("%s: unknown revision code, assuming ESP100\n",
		    sc->sc_dev.dv_xname);
		ESP_WRITE_REG(sc, ESP_CFG1, sc->sc_cfg1);
		ESP_WRITE_REG(sc, ESP_CCF, sc->sc_ccf);
		ESP_WRITE_REG(sc, ESP_SYNCOFF, 0);
		ESP_WRITE_REG(sc, ESP_TIMEOUT, sc->sc_timeout);
	}
}

/*
 * Reset the SCSI bus, but not the chip
 */
void
esp_scsi_reset(sc)
	struct esp_softc *sc;
{
#ifdef SPARC_DRIVER
	/* stop DMA first, as the chip will return to Bus Free phase */
	DMACSR(sc->sc_dma) &= ~D_EN_DMA;
#else
	/*
	 * XXX STOP DMA FIRST
	 */
#endif

	printf("esp: resetting SCSI bus\n");
	ESPCMD(sc, ESPCMD_RSTSCSI);
}

/*
 * Initialize esp state machine
 */
void
espinit(sc, doreset)
	struct esp_softc *sc;
	int doreset;
{
	struct esp_ecb *ecb;
	int r;

	ESP_TRACE(("[ESPINIT(%d)] ", doreset));

	if (sc->sc_state == 0) {
		/* First time through; initialize. */
		TAILQ_INIT(&sc->ready_list);
		TAILQ_INIT(&sc->nexus_list);
		TAILQ_INIT(&sc->free_list);
		sc->sc_nexus = NULL;
		ecb = sc->sc_ecb;
		bzero(ecb, sizeof(sc->sc_ecb));
		for (r = 0; r < sizeof(sc->sc_ecb) / sizeof(*ecb); r++) {
			TAILQ_INSERT_TAIL(&sc->free_list, ecb, chain);
			ecb++;
		}
		bzero(sc->sc_tinfo, sizeof(sc->sc_tinfo));
	} else {
		/* Cancel any active commands. */
		sc->sc_state = ESP_CLEANING;
		if ((ecb = sc->sc_nexus) != NULL) {
			ecb->xs->error = XS_DRIVER_STUFFUP;
			untimeout(esp_timeout, ecb);
			esp_done(sc, ecb);
		}
		while ((ecb = sc->nexus_list.tqh_first) != NULL) {
			ecb->xs->error = XS_DRIVER_STUFFUP;
			untimeout(esp_timeout, ecb);
			esp_done(sc, ecb);
		}
	}

	/*
	 * reset the chip to a known state
	 */
	esp_reset(sc);

	sc->sc_phase = sc->sc_prevphase = INVALID_PHASE;
	for (r = 0; r < 8; r++) {
		struct esp_tinfo *ti = &sc->sc_tinfo[r];
/* XXX - config flags per target: low bits: no reselect; high bits: no synch */
		int fl = sc->sc_dev.dv_cfdata->cf_flags;

		ti->flags = ((sc->sc_minsync && !(fl & (1<<(r+8))))
				? T_NEGOTIATE : 0) |
				((fl & (1<<r)) ? T_RSELECTOFF : 0) |
				T_NEED_TO_RESET;
		ti->period = sc->sc_minsync;
		ti->offset = 0;
	}

	if (doreset) {
		sc->sc_state = ESP_SBR;
		ESPCMD(sc, ESPCMD_RSTSCSI);
	} else {
		sc->sc_state = ESP_IDLE;
	}
}

/*
 * Read the ESP registers, and save their contents for later use.
 * ESP_STAT, ESP_STEP & ESP_INTR are mostly zeroed out when reading
 * ESP_INTR - so make sure it is the last read.
 *
 * I think that (from reading the docs) most bits in these registers
 * only make sense when he DMA CSR has an interrupt showing. Call only
 * if an interrupt is pending.
 */
void
espreadregs(sc)
	struct esp_softc *sc;
{

	sc->sc_espstat = ESP_READ_REG(sc, ESP_STAT);
	/* Only the stepo bits are of interest */
	sc->sc_espstep = ESP_READ_REG(sc, ESP_STEP) & ESPSTEP_MASK;
	sc->sc_espintr = ESP_READ_REG(sc, ESP_INTR);
#ifndef SPARC_DRIVER
	/* Clear the TCDS interrupt bit. */
	(void)tcds_scsi_isintr(sc->sc_dma, 1);
#endif

	/*
	 * Determine the SCSI bus phase, return either a real SCSI bus phase
	 * or some pseudo phase we use to detect certain exceptions.
	 */

	sc->sc_phase = (sc->sc_espintr & ESPINTR_DIS)
			? /* Disconnected */ BUSFREE_PHASE
			: sc->sc_espstat & ESPSTAT_PHASE;

	ESP_MISC(("regs[intr=%02x,stat=%02x,step=%02x] ",
		sc->sc_espintr, sc->sc_espstat, sc->sc_espstep));
}

/*
 * Convert chip register Clock Per Byte value to Synchronous Transfer Period.
 */
static inline int
esp_cpb2stp(sc, cpb)
	struct esp_softc *sc;
	int cpb;
{
	return ((250 * cpb) / sc->sc_freq);
}

/*
 * Convert Synchronous Transfer Period to chip register Clock Per Byte value.
 */
static inline int
esp_stp2cpb(sc, period)
	struct esp_softc *sc;
	int period;
{
	int v;
	v = (sc->sc_freq * period) / 250;
	if (esp_cpb2stp(sc, v) < period)
		/* Correct round-down error */
		v++;
	return v;
}

static inline void
esp_setsync(sc, ti)
	struct esp_softc *sc;
	struct esp_tinfo *ti;
{

	if (ti->flags & T_SYNCMODE) {
		ESP_WRITE_REG(sc, ESP_SYNCOFF, ti->offset);
		ESP_WRITE_REG(sc, ESP_SYNCTP, esp_stp2cpb(sc, ti->period));
	} else {
		ESP_WRITE_REG(sc, ESP_SYNCOFF, 0);
		ESP_WRITE_REG(sc, ESP_SYNCTP, 0);
	}
}

/*
 * Send a command to a target, set the driver state to ESP_SELECTING
 * and let the caller take care of the rest.
 *
 * Keeping this as a function allows me to say that this may be done
 * by DMA instead of programmed I/O soon.
 */
void
esp_select(sc, ecb)
	struct esp_softc *sc;
	struct esp_ecb *ecb;
{
	struct scsi_link *sc_link = ecb->xs->sc_link;
	int target = sc_link->target;
	struct esp_tinfo *ti = &sc->sc_tinfo[target];
	u_char *cmd;
	int clen;

	ESP_TRACE(("[esp_select(t%d,l%d,cmd:%x)] ", sc_link->target, sc_link->lun, ecb->cmd.opcode));

	/* new state ESP_SELECTING */
	sc->sc_state = ESP_SELECTING;

	ESPCMD(sc, ESPCMD_FLUSH);

	/*
	 * The docs say the target register is never reset, and I
	 * can't think of a better place to set it
	 */
	ESP_WRITE_REG(sc, ESP_SELID, target);
	esp_setsync(sc, ti);

	/*
	 * Who am I. This is where we tell the target that we are
	 * happy for it to disconnect etc.
	 */
	ESP_WRITE_REG(sc, ESP_FIFO,
		MSG_IDENTIFY(sc_link->lun, (ti->flags & T_RSELECTOFF)?0:1));

	if (ti->flags & T_NEGOTIATE) {
		/* Arbitrate, select and stop after IDENTIFY message */
		ESPCMD(sc, ESPCMD_SELATNS);
		return;
	}

	/* Now the command into the FIFO */
	cmd = (u_char *)&ecb->cmd;
	clen = ecb->clen;
	while (clen--)
		ESP_WRITE_REG(sc, ESP_FIFO, *cmd++);

	/* And get the targets attention */
	ESPCMD(sc, ESPCMD_SELATN);
}

void
esp_free_ecb(sc, ecb, flags)
	struct esp_softc *sc;
	struct esp_ecb *ecb;
	int flags;
{
	int s;

	s = splbio();

	ecb->flags = 0;
	TAILQ_INSERT_HEAD(&sc->free_list, ecb, chain);

	/*
	 * If there were none, wake anybody waiting for one to come free,
	 * starting with queued entries.
	 */
	if (ecb->chain.tqe_next == 0)
		wakeup(&sc->free_list);

	splx(s);
}

struct esp_ecb *
esp_get_ecb(sc, flags)
	struct esp_softc *sc;
	int flags;
{
	struct esp_ecb *ecb;
	int s;

	s = splbio();

	while ((ecb = sc->free_list.tqh_first) == NULL &&
	       (flags & SCSI_NOSLEEP) == 0)
		tsleep(&sc->free_list, PRIBIO, "especb", 0);
	if (ecb) {
		TAILQ_REMOVE(&sc->free_list, ecb, chain);
		ecb->flags |= ECB_ALLOC;
	}

	splx(s);
	return ecb;
}

/*
 * DRIVER FUNCTIONS CALLABLE FROM HIGHER LEVEL DRIVERS
 */

/*
 * Start a SCSI-command
 * This function is called by the higher level SCSI-driver to queue/run
 * SCSI-commands.
 */
int
esp_scsi_cmd(xs)
	struct scsi_xfer *xs;
{
	struct scsi_link *sc_link = xs->sc_link;
	struct esp_softc *sc = sc_link->adapter_softc;
	struct esp_ecb *ecb;
	int s, flags;

	ESP_TRACE(("[esp_scsi_cmd] "));
	ESP_CMDS(("[0x%x, %d]->%d ", (int)xs->cmd->opcode, xs->cmdlen,
	    sc_link->target));

	flags = xs->flags;
	if ((ecb = esp_get_ecb(sc, flags)) == NULL) {
		xs->error = XS_DRIVER_STUFFUP;
		return TRY_AGAIN_LATER;
	}

	/* Initialize ecb */
	ecb->xs = xs;
	ecb->timeout = xs->timeout;

	if (xs->flags & SCSI_RESET) {
		ecb->flags |= ECB_RESET;
		ecb->clen = 0;
		ecb->dleft = 0;
	} else {
		bcopy(xs->cmd, &ecb->cmd, xs->cmdlen);
		ecb->clen = xs->cmdlen;
		ecb->daddr = xs->data;
		ecb->dleft = xs->datalen;
	}
	ecb->stat = 0;

	s = splbio();

	TAILQ_INSERT_TAIL(&sc->ready_list, ecb, chain);
	if (sc->sc_state == ESP_IDLE)
		esp_sched(sc);

	splx(s);

	if ((flags & SCSI_POLL) == 0)
		return SUCCESSFULLY_QUEUED;

	/* Not allowed to use interrupts, use polling instead */
	if (esp_poll(sc, xs, ecb->timeout)) {
		esp_timeout(ecb);
		if (esp_poll(sc, xs, ecb->timeout))
			esp_timeout(ecb);
	}
	return COMPLETE;
}

/*
 * Used when interrupt driven I/O isn't allowed, e.g. during boot.
 */
int
esp_poll(sc, xs, count)
	struct esp_softc *sc;
	struct scsi_xfer *xs;
	int count;
{

	ESP_TRACE(("[esp_poll] "));
	while (count) {
		if (DMA_ISINTR(sc->sc_dma)) {
			espintr(sc);
		}
#if alternatively
		if (ESP_READ_REG(sc, ESP_STAT) & ESPSTAT_INT)
			espintr(sc);
#endif
		if ((xs->flags & ITSDONE) != 0)
			return 0;
		if (sc->sc_state == ESP_IDLE) {
			ESP_TRACE(("[esp_poll: rescheduling] "));
			esp_sched(sc);
		}
		DELAY(1000);
		count--;
	}
	return 1;
}


/*
 * LOW LEVEL SCSI UTILITIES
 */

/*
 * Schedule a scsi operation.  This has now been pulled out of the interrupt
 * handler so that we may call it from esp_scsi_cmd and esp_done.  This may
 * save us an unecessary interrupt just to get things going.  Should only be
 * called when state == ESP_IDLE and at bio pl.
 */
void
esp_sched(sc)
	struct esp_softc *sc;
{
	struct esp_ecb *ecb;
	struct scsi_link *sc_link;
	struct esp_tinfo *ti;

	ESP_TRACE(("[esp_sched] "));
	if (sc->sc_state != ESP_IDLE)
		panic("esp_sched: not IDLE (state=%d)", sc->sc_state);

	/*
	 * Find first ecb in ready queue that is for a target/lunit
	 * combinations that is not busy.
	 */
	for (ecb = sc->ready_list.tqh_first; ecb; ecb = ecb->chain.tqe_next) {
		sc_link = ecb->xs->sc_link;
		ti = &sc->sc_tinfo[sc_link->target];
		if ((ti->lubusy & (1 << sc_link->lun)) == 0) {
			TAILQ_REMOVE(&sc->ready_list, ecb, chain);
			sc->sc_nexus = ecb;
			esp_select(sc, ecb);
			break;
		} else
			ESP_MISC(("%d:%d busy\n",
			    sc_link->target, sc_link->lun));
	}
}

void
esp_sense(sc, ecb)
	struct esp_softc *sc;
	struct esp_ecb *ecb;
{
	struct scsi_xfer *xs = ecb->xs;
	struct scsi_link *sc_link = xs->sc_link;
	struct esp_tinfo *ti = &sc->sc_tinfo[sc_link->target];
	struct scsi_sense *ss = (void *)&ecb->cmd;

	ESP_MISC(("requesting sense "));
	/* Next, setup a request sense command block */
	bzero(ss, sizeof(*ss));
	ss->opcode = REQUEST_SENSE;
	ss->byte2 = sc_link->lun << 5;
	ss->length = sizeof(struct scsi_sense_data);
	ecb->clen = sizeof(*ss);
	ecb->daddr = (char *)&xs->sense;
	ecb->dleft = sizeof(struct scsi_sense_data);
	ecb->flags |= ECB_SENSE;
	ti->senses++;
	if (ecb->flags & ECB_NEXUS)
		ti->lubusy &= ~(1 << sc_link->lun);
	if (ecb == sc->sc_nexus) {
		esp_select(sc, ecb);
	} else {
		esp_dequeue(sc, ecb);
		TAILQ_INSERT_HEAD(&sc->ready_list, ecb, chain);
		if (sc->sc_state == ESP_IDLE)
			esp_sched(sc);
	}
}

/*
 * POST PROCESSING OF SCSI_CMD (usually current)
 */
void
esp_done(sc, ecb)
	struct esp_softc *sc;
	struct esp_ecb *ecb;
{
	struct scsi_xfer *xs = ecb->xs;
	struct scsi_link *sc_link = xs->sc_link;
	struct esp_tinfo *ti = &sc->sc_tinfo[sc_link->target];

	ESP_TRACE(("[esp_done(error:%x)] ", xs->error));

	/*
	 * Now, if we've come here with no error code, i.e. we've kept the
	 * initial XS_NOERROR, and the status code signals that we should
	 * check sense, we'll need to set up a request sense cmd block and
	 * push the command back into the ready queue *before* any other
	 * commands for this target/lunit, else we lose the sense info.
	 * We don't support chk sense conditions for the request sense cmd.
	 */
	if (xs->error == XS_NOERROR) {
		if ((ecb->flags & ECB_ABORT) != 0) {
			xs->error = XS_DRIVER_STUFFUP;
		} else if ((ecb->flags & ECB_SENSE) != 0) {
			xs->error = XS_SENSE;
		} else if ((ecb->stat & ST_MASK) == SCSI_CHECK) {
			/* First, save the return values */
			xs->resid = ecb->dleft;
			xs->status = ecb->stat;
			esp_sense(sc, ecb);
			return;
		} else {
			xs->resid = ecb->dleft;
		}
	}

	xs->flags |= ITSDONE;

#ifdef ESP_DEBUG
	if (esp_debug & ESP_SHOWMISC) {
		if (xs->resid != 0)
			printf("resid=%lu ", xs->resid);
		if (xs->error == XS_SENSE)
			printf("sense=0x%02x\n", xs->sense.error_code);
		else
			printf("error=%d\n", xs->error);
	}
#endif

	/*
	 * Remove the ECB from whatever queue it's on.
	 */
	if (ecb->flags & ECB_NEXUS)
		ti->lubusy &= ~(1 << sc_link->lun);
	if (ecb == sc->sc_nexus) {
		sc->sc_nexus = NULL;
		sc->sc_state = ESP_IDLE;
		esp_sched(sc);
	} else
		esp_dequeue(sc, ecb);
		
	esp_free_ecb(sc, ecb, xs->flags);
	ti->cmds++;
	scsi_done(xs);
}

void
esp_dequeue(sc, ecb)
	struct esp_softc *sc;
	struct esp_ecb *ecb;
{

	if (ecb->flags & ECB_NEXUS) {
		TAILQ_REMOVE(&sc->nexus_list, ecb, chain);
	} else {
		TAILQ_REMOVE(&sc->ready_list, ecb, chain);
	}
}

/*
 * INTERRUPT/PROTOCOL ENGINE
 */

/*
 * Schedule an outgoing message by prioritizing it, and asserting
 * attention on the bus. We can only do this when we are the initiator
 * else there will be an illegal command interrupt.
 */
#define esp_sched_msgout(m) \
	do {						\
		ESP_MISC(("esp_sched_msgout %d ", m));	\
		ESPCMD(sc, ESPCMD_SETATN);		\
		sc->sc_flags |= ESP_ATN;		\
		sc->sc_msgpriq |= (m);			\
	} while (0)

int
esp_reselect(sc, message)
	struct esp_softc *sc;
	int message;
{
	u_char selid, target, lun;
	struct esp_ecb *ecb;
	struct scsi_link *sc_link;
	struct esp_tinfo *ti;

	/*
	 * The SCSI chip made a snapshot of the data bus while the reselection
	 * was being negotiated.  This enables us to determine which target did
	 * the reselect.
	 */
	selid = sc->sc_selid & ~(1 << sc->sc_id);
	if (selid & (selid - 1)) {
		printf("%s: reselect with invalid selid %02x; sending DEVICE RESET\n",
		    sc->sc_dev.dv_xname, selid);
		goto reset;
	}

	/*
	 * Search wait queue for disconnected cmd
	 * The list should be short, so I haven't bothered with
	 * any more sophisticated structures than a simple
	 * singly linked list.
	 */
	target = ffs(selid) - 1;
	lun = message & 0x07;
	for (ecb = sc->nexus_list.tqh_first; ecb != NULL;
	     ecb = ecb->chain.tqe_next) {
		sc_link = ecb->xs->sc_link;
		if (sc_link->target == target && sc_link->lun == lun)
			break;
	}
	if (ecb == NULL) {
		printf("%s: reselect from target %d lun %d with no nexus; sending ABORT\n",
		    sc->sc_dev.dv_xname, target, lun);
		goto abort;
	}

	/* Make this nexus active again. */
	TAILQ_REMOVE(&sc->nexus_list, ecb, chain);
	sc->sc_state = ESP_CONNECTED;
	sc->sc_nexus = ecb;
	ti = &sc->sc_tinfo[target];
	ti->lubusy |= (1 << lun);
	esp_setsync(sc, ti);

	if (ecb->flags & ECB_RESET)
		esp_sched_msgout(SEND_DEV_RESET);
	else if (ecb->flags & ECB_ABORT)
		esp_sched_msgout(SEND_ABORT);

	/* Do an implicit RESTORE POINTERS. */
	sc->sc_dp = ecb->daddr;
	sc->sc_dleft = ecb->dleft;

	return (0);

reset:
	esp_sched_msgout(SEND_DEV_RESET);
	return (1);

abort:
	esp_sched_msgout(SEND_ABORT);
	return (1);
}

#define IS1BYTEMSG(m) (((m) != 1 && (m) < 0x20) || (m) & 0x80)
#define IS2BYTEMSG(m) (((m) & 0xf0) == 0x20)
#define ISEXTMSG(m) ((m) == 1)

/*
 * Get an incoming message as initiator.
 *
 * The SCSI bus must already be in MESSAGE_IN_PHASE and there is a
 * byte in the FIFO
 */
void
esp_msgin(sc)
	register struct esp_softc *sc;
{
	register int v;

	ESP_TRACE(("[esp_msgin(curmsglen:%ld)] ", (long)sc->sc_imlen));

	if ((ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) == 0) {
		printf("%s: msgin: no msg byte available\n",
			sc->sc_dev.dv_xname);
		return;
	}

	/*
	 * Prepare for a new message.  A message should (according
	 * to the SCSI standard) be transmitted in one single
	 * MESSAGE_IN_PHASE. If we have been in some other phase,
	 * then this is a new message.
	 */
	if (sc->sc_prevphase != MESSAGE_IN_PHASE) {
		sc->sc_flags &= ~ESP_DROP_MSGI;
		sc->sc_imlen = 0;
	}

	v = ESP_READ_REG(sc, ESP_FIFO);
	ESP_MISC(("<msgbyte:0x%02x>", v));

#if 0
	if (sc->sc_state == ESP_RESELECTED && sc->sc_imlen == 0) {
		/*
		 * Which target is reselecting us? (The ID bit really)
		 */
		sc->sc_selid = v;
		ESP_MISC(("selid=0x%2x ", sc->sc_selid));
		return;
	}
#endif

	sc->sc_imess[sc->sc_imlen] = v;

	/*
	 * If we're going to reject the message, don't bother storing
	 * the incoming bytes.  But still, we need to ACK them.
	 */

	if ((sc->sc_flags & ESP_DROP_MSGI)) {
		ESPCMD(sc, ESPCMD_MSGOK);
		printf("<dropping msg byte %x>",
			sc->sc_imess[sc->sc_imlen]);
		return;
	}

	if (sc->sc_imlen >= ESP_MAX_MSG_LEN) {
		esp_sched_msgout(SEND_REJECT);
		sc->sc_flags |= ESP_DROP_MSGI;
	} else {
		sc->sc_imlen++;
		/*
		 * This testing is suboptimal, but most
		 * messages will be of the one byte variety, so
		 * it should not effect performance
		 * significantly.
		 */
		if (sc->sc_imlen == 1 && IS1BYTEMSG(sc->sc_imess[0]))
			goto gotit;
		if (sc->sc_imlen == 2 && IS2BYTEMSG(sc->sc_imess[0]))
			goto gotit;
		if (sc->sc_imlen >= 3 && ISEXTMSG(sc->sc_imess[0]) &&
		    sc->sc_imlen == sc->sc_imess[1] + 2)
			goto gotit;
	}
	/* Ack what we have so far */
	ESPCMD(sc, ESPCMD_MSGOK);
	return;

gotit:
	ESP_MSGS(("gotmsg(%x)", sc->sc_imess[0]));
	/*
	 * Now we should have a complete message (1 byte, 2 byte
	 * and moderately long extended messages).  We only handle
	 * extended messages which total length is shorter than
	 * ESP_MAX_MSG_LEN.  Longer messages will be amputated.
	 */
	switch (sc->sc_state) {
		struct esp_ecb *ecb;
		struct esp_tinfo *ti;

	case ESP_CONNECTED:
		ecb = sc->sc_nexus;
		ti = &sc->sc_tinfo[ecb->xs->sc_link->target];

		switch (sc->sc_imess[0]) {
		case MSG_CMDCOMPLETE:
			ESP_MSGS(("cmdcomplete "));
			if (sc->sc_dleft < 0) {
				struct scsi_link *sc_link = ecb->xs->sc_link;
				printf("%s: %ld extra bytes from %d:%d\n",
				    sc->sc_dev.dv_xname, -(long)sc->sc_dleft,
				    sc_link->target, sc_link->lun);
				sc->sc_dleft = 0;
			}
			ecb->xs->resid = ecb->dleft = sc->sc_dleft;
			sc->sc_state = ESP_CMDCOMPLETE;
			break;

		case MSG_MESSAGE_REJECT:
			if (esp_debug & ESP_SHOWMSGS)
				printf("%s: our msg rejected by target\n",
				    sc->sc_dev.dv_xname);
			switch (sc->sc_msgout) {
			case SEND_SDTR:
				sc->sc_flags &= ~ESP_SYNCHNEGO;
				ti->flags &= ~(T_NEGOTIATE | T_SYNCMODE);
				esp_setsync(sc, ti);
				break;
			case SEND_INIT_DET_ERR:
				goto abort;
			}
			break;

		case MSG_NOOP:
			ESP_MSGS(("noop "));
			break;

		case MSG_DISCONNECT:
			ESP_MSGS(("disconnect "));
			ti->dconns++;
			sc->sc_state = ESP_DISCONNECT;
			if ((ecb->xs->sc_link->quirks & SDEV_AUTOSAVE) == 0)
				break;
			/*FALLTHROUGH*/

		case MSG_SAVEDATAPOINTER:
			ESP_MSGS(("save datapointer "));
			ecb->daddr = sc->sc_dp;
			ecb->dleft = sc->sc_dleft;
			break;

		case MSG_RESTOREPOINTERS:
			ESP_MSGS(("restore datapointer "));
			sc->sc_dp = ecb->daddr;
			sc->sc_dleft = ecb->dleft;
			break;

		case MSG_EXTENDED:
			ESP_MSGS(("extended(%x) ", sc->sc_imess[2]));
			switch (sc->sc_imess[2]) {
			case MSG_EXT_SDTR:
				ESP_MSGS(("SDTR period %d, offset %d ",
					sc->sc_imess[3], sc->sc_imess[4]));
				if (sc->sc_imess[1] != 3)
					goto reject;
				ti->period = sc->sc_imess[3];
				ti->offset = sc->sc_imess[4];
				ti->flags &= ~T_NEGOTIATE;
				if (sc->sc_minsync == 0 ||
				    ti->offset == 0 ||
				    ti->period > 124) {
					printf("%s:%d: async\n", "esp",
						ecb->xs->sc_link->target);
					if ((sc->sc_flags&ESP_SYNCHNEGO) == 0) {
						/* target initiated negotiation */
						ti->offset = 0;
						ti->flags &= ~T_SYNCMODE;
						esp_sched_msgout(SEND_SDTR);
					} else {
						/* we are async */
						ti->flags &= ~T_SYNCMODE;
					}
				} else {
					int r = 250/ti->period;
					int s = (100*250)/ti->period - 100*r;
					int p;

					p =  esp_stp2cpb(sc, ti->period);
					ti->period = esp_cpb2stp(sc, p);
#ifdef ESP_DEBUG
					sc_print_addr(ecb->xs->sc_link);
					printf("max sync rate %d.%02dMb/s\n",
						r, s);
#endif
					if ((sc->sc_flags&ESP_SYNCHNEGO) == 0) {
						/* target initiated negotiation */
						if (ti->period < sc->sc_minsync)
							ti->period = sc->sc_minsync;
						if (ti->offset > 15)
							ti->offset = 15;
						ti->flags &= ~T_SYNCMODE;
						esp_sched_msgout(SEND_SDTR);
					} else {
						/* we are sync */
						ti->flags |= T_SYNCMODE;
					}
				}
				sc->sc_flags &= ~ESP_SYNCHNEGO;
				esp_setsync(sc, ti);
				break;

			default:
				printf("%s: unrecognized MESSAGE EXTENDED; sending REJECT\n",
				    sc->sc_dev.dv_xname);
				goto reject;
			}
			break;

		default:
			ESP_MSGS(("ident "));
			printf("%s: unrecognized MESSAGE; sending REJECT\n",
			    sc->sc_dev.dv_xname);
		reject:
			esp_sched_msgout(SEND_REJECT);
			break;
		}
		break;

	case ESP_RESELECTED:
		if (!MSG_ISIDENTIFY(sc->sc_imess[0])) {
			printf("%s: reselect without IDENTIFY; sending DEVICE RESET\n",
			    sc->sc_dev.dv_xname);
			goto reset;
		}

		(void) esp_reselect(sc, sc->sc_imess[0]);
		break;

	default:
		printf("%s: unexpected MESSAGE IN; sending DEVICE RESET\n",
		    sc->sc_dev.dv_xname);
	reset:
		esp_sched_msgout(SEND_DEV_RESET);
		break;

	abort:
		esp_sched_msgout(SEND_ABORT);
		break;
	}

	/* Ack last message byte */
	ESPCMD(sc, ESPCMD_MSGOK);

	/* Done, reset message pointer. */
	sc->sc_flags &= ~ESP_DROP_MSGI;
	sc->sc_imlen = 0;
}


/*
 * Send the highest priority, scheduled message
 */
void
esp_msgout(sc)
	register struct esp_softc *sc;
{
	struct esp_tinfo *ti;
	struct esp_ecb *ecb;
	size_t size;

	ESP_TRACE(("[esp_msgout(priq:%x, prevphase:%x)]", sc->sc_msgpriq, sc->sc_prevphase));

	if (sc->sc_flags & ESP_ATN) {
		if (sc->sc_prevphase != MESSAGE_OUT_PHASE) {
		new:
			ESPCMD(sc, ESPCMD_FLUSH);
			DELAY(1);
			sc->sc_msgoutq = 0;
			sc->sc_omlen = 0;
		}
	} else {
		if (sc->sc_prevphase == MESSAGE_OUT_PHASE) {
			esp_sched_msgout(sc->sc_msgoutq);
			goto new;
		} else {
			printf("esp at line %d: unexpected MESSAGE OUT phase\n", __LINE__);
		}
	}
			
	if (sc->sc_omlen == 0) {
		/* Pick up highest priority message */
		sc->sc_msgout = sc->sc_msgpriq & -sc->sc_msgpriq;
		sc->sc_msgoutq |= sc->sc_msgout;
		sc->sc_msgpriq &= ~sc->sc_msgout;
		sc->sc_omlen = 1;		/* "Default" message len */
		switch (sc->sc_msgout) {
		case SEND_SDTR:
			ecb = sc->sc_nexus;
			ti = &sc->sc_tinfo[ecb->xs->sc_link->target];
			sc->sc_omess[0] = MSG_EXTENDED;
			sc->sc_omess[1] = 3;
			sc->sc_omess[2] = MSG_EXT_SDTR;
			sc->sc_omess[3] = ti->period;
			sc->sc_omess[4] = ti->offset;
			sc->sc_omlen = 5;
			if ((sc->sc_flags & ESP_SYNCHNEGO) == 0) {
				ti->flags |= T_SYNCMODE;
				esp_setsync(sc, ti);
			}
			break;
		case SEND_IDENTIFY:
			if (sc->sc_state != ESP_CONNECTED) {
				printf("esp at line %d: no nexus\n", __LINE__);
			}
			ecb = sc->sc_nexus;
			sc->sc_omess[0] = MSG_IDENTIFY(ecb->xs->sc_link->lun,0);
			break;
		case SEND_DEV_RESET:
			sc->sc_flags |= ESP_ABORTING;
			sc->sc_omess[0] = MSG_BUS_DEV_RESET;
			ecb = sc->sc_nexus;
			ti = &sc->sc_tinfo[ecb->xs->sc_link->target];
			ti->flags &= ~T_SYNCMODE;
			ti->flags |= T_NEGOTIATE;
			break;
		case SEND_PARITY_ERROR:
			sc->sc_omess[0] = MSG_PARITY_ERROR;
			break;
		case SEND_ABORT:
			sc->sc_flags |= ESP_ABORTING;
			sc->sc_omess[0] = MSG_ABORT;
			break;
		case SEND_INIT_DET_ERR:
			sc->sc_omess[0] = MSG_INITIATOR_DET_ERR;
			break;
		case SEND_REJECT:
			sc->sc_omess[0] = MSG_MESSAGE_REJECT;
			break;
		default:
			ESPCMD(sc, ESPCMD_RSTATN);
			sc->sc_flags &= ~ESP_ATN;
			sc->sc_omess[0] = MSG_NOOP;
			break;
		}
		sc->sc_omp = sc->sc_omess;
	}

#if 1
	/* (re)send the message */
	size = min(sc->sc_omlen, sc->sc_maxxfer);
	DMA_SETUP(sc->sc_dma, &sc->sc_omp, &sc->sc_omlen, 0, &size);
	/* Program the SCSI counter */
	ESP_WRITE_REG(sc, ESP_TCL, size);
	ESP_WRITE_REG(sc, ESP_TCM, size >> 8);
	if (sc->sc_cfg2 & ESPCFG2_FE) {
		ESP_WRITE_REG(sc, ESP_TCH, size >> 16);
	}
	/* load the count in */
	ESPCMD(sc, ESPCMD_NOP|ESPCMD_DMA);
	ESPCMD(sc, ESPCMD_TRANS|ESPCMD_DMA);
	DMA_GO(sc->sc_dma);
#else
	{	int i;
		for (i = 0; i < sc->sc_omlen; i++)
			ESP_WRITE_REG(sc, FIFO, sc->sc_omess[i]);
		ESPCMD(sc, ESPCMD_TRANS);
		sc->sc_omlen = 0;
	}
#endif
}

/*
 * This is the most critical part of the driver, and has to know
 * how to deal with *all* error conditions and phases from the SCSI
 * bus. If there are no errors and the DMA was active, then call the
 * DMA pseudo-interrupt handler. If this returns 1, then that was it
 * and we can return from here without further processing.
 *
 * Most of this needs verifying.
 */
int
espintr(sc)
	register struct esp_softc *sc;
{
	register struct esp_ecb *ecb;
	register struct scsi_link *sc_link;
	struct esp_tinfo *ti;
	int loop;
	size_t size;

	ESP_TRACE(("[espintr]"));

	/*
	 * I have made some (maybe seriously flawed) assumptions here,
	 * but basic testing (uncomment the printf() below), show that
	 * certainly something happens when this loop is here.
	 *
	 * The idea is that many of the SCSI operations take very little
	 * time, and going away and getting interrupted is too high an
	 * overhead to pay. For example, selecting, sending a message
	 * and command and then doing some work can be done in one "pass".
	 *
	 * The DELAY is not variable because I do not understand that the
	 * DELAY loop should be fixed-time regardless of CPU speed, but
	 * I am *assuming* that the faster SCSI processors get things done
	 * quicker (sending a command byte etc), and so there is no
	 * need to be too slow.
	 *
	 * This is a heuristic. It is 2 when at 20Mhz, 2 at 25Mhz and 1
	 * at 40Mhz. This needs testing.
	 */
	for (loop = 0; 1;loop++, DELAY(50/sc->sc_freq)) {
		/* a feeling of deja-vu */
		if (!DMA_ISINTR(sc->sc_dma))
			return (loop != 0);
#if 0
		if (loop)
			printf("*");
#endif

		/* and what do the registers say... */
		espreadregs(sc);

		sc->sc_intrcnt.ev_count++;

		/*
		 * At the moment, only a SCSI Bus Reset or Illegal
		 * Command are classed as errors. A disconnect is a
		 * valid condition, and we let the code check is the
		 * "ESP_BUSFREE_OK" flag was set before declaring it
		 * and error.
		 *
		 * Also, the status register tells us about "Gross
		 * Errors" and "Parity errors". Only the Gross Error
		 * is really bad, and the parity errors are dealt
		 * with later
		 *
		 * TODO
		 *	If there are too many parity error, go to slow
		 *	cable mode ?
		 */

		/* SCSI Reset */
		if (sc->sc_espintr & ESPINTR_SBR) {
			if (ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) {
				ESPCMD(sc, ESPCMD_FLUSH);
				DELAY(1);
			}
			if (sc->sc_state != ESP_SBR) {
				printf("%s: SCSI bus reset\n",
					sc->sc_dev.dv_xname);
				espinit(sc, 0); /* Restart everything */
				return 1;
			}
#if 0
	/*XXX*/		printf("<expected bus reset: "
				"[intr %x, stat %x, step %d]>\n",
				sc->sc_espintr, sc->sc_espstat,
				sc->sc_espstep);
#endif
			if (sc->sc_nexus)
				panic("%s: nexus in reset state",
				      sc->sc_dev.dv_xname);
			goto sched;
		}

		ecb = sc->sc_nexus;

#define ESPINTR_ERR (ESPINTR_SBR|ESPINTR_ILL)
		if (sc->sc_espintr & ESPINTR_ERR ||
		    sc->sc_espstat & ESPSTAT_GE) {

			if (sc->sc_espstat & ESPSTAT_GE) {
				/* no target ? */
				if (ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) {
					ESPCMD(sc, ESPCMD_FLUSH);
					DELAY(1);
				}
				if (sc->sc_state == ESP_CONNECTED ||
				    sc->sc_state == ESP_SELECTING) {
					ecb->xs->error = XS_DRIVER_STUFFUP;
					esp_done(sc, ecb);
				}
				return 1;
			}

			if (sc->sc_espintr & ESPINTR_ILL) {
				/* illegal command, out of sync ? */
				printf("%s: illegal command: 0x%x (state %d, phase %x, prevphase %x)\n",
					sc->sc_dev.dv_xname, sc->sc_lastcmd,
					sc->sc_state, sc->sc_phase,
					sc->sc_prevphase);
				if (ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) {
					ESPCMD(sc, ESPCMD_FLUSH);
					DELAY(1);
				}
				espinit(sc, 0); /* Restart everything */
				return 1;
			}
		}

		/*
		 * Call if DMA is active.
		 *
		 * If DMA_INTR returns true, then maybe go 'round the loop
		 * again in case there is no more DMA queued, but a phase
		 * change is expected.
		 */
		if (DMA_ISACTIVE(sc->sc_dma)) {
			int r = DMA_INTR(sc->sc_dma);
			if (r == -1) {
				printf("%s: DMA error; resetting\n",
					sc->sc_dev.dv_xname);
				espinit(sc, 1);
			}
			/* If DMA active here, then go back to work... */
			if (DMA_ISACTIVE(sc->sc_dma))
				return 1;

			if (sc->sc_dleft == 0 &&
			    (sc->sc_espstat & ESPSTAT_TC) == 0)
				printf("%s: !TC [intr %x, stat %x, step %d]"
				       " prevphase %x, resid %lx\n",
					sc->sc_dev.dv_xname,
					sc->sc_espintr,
					sc->sc_espstat,
					sc->sc_espstep,
					sc->sc_prevphase,
					ecb?ecb->dleft:-1);
		}

#if 0	/* Unreliable on some ESP revisions? */
		if ((sc->sc_espstat & ESPSTAT_INT) == 0) {
			printf("%s: spurious interrupt\n", sc->sc_dev.dv_xname);
			return 1;
		}
#endif

		/*
		 * check for less serious errors
		 */
		if (sc->sc_espstat & ESPSTAT_PE) {
			printf("%s: SCSI bus parity error\n",
				sc->sc_dev.dv_xname);
			if (sc->sc_prevphase == MESSAGE_IN_PHASE)
				esp_sched_msgout(SEND_PARITY_ERROR);
			else
				esp_sched_msgout(SEND_INIT_DET_ERR);
		}

		if (sc->sc_espintr & ESPINTR_DIS) {
			ESP_MISC(("<DISC [intr %x, stat %x, step %d]>",
				sc->sc_espintr,sc->sc_espstat,sc->sc_espstep));
			if (ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) {
				ESPCMD(sc, ESPCMD_FLUSH);
				DELAY(1);
			}
			/*
			 * This command must (apparently) be issued within
			 * 250mS of a disconnect. So here you are...
			 */
			ESPCMD(sc, ESPCMD_ENSEL);
			switch (sc->sc_state) {
			case ESP_RESELECTED:
				goto sched;

			case ESP_SELECTING:
				ecb->xs->error = XS_SELTIMEOUT;
				goto finish;

			case ESP_CONNECTED:
				if ((sc->sc_flags & ESP_SYNCHNEGO)) {
#ifdef ESP_DEBUG
					if (ecb)
						sc_print_addr(ecb->xs->sc_link);
					printf("sync nego not completed!\n");
#endif
					ti = &sc->sc_tinfo[ecb->xs->sc_link->target];
					sc->sc_flags &= ~ESP_SYNCHNEGO;
					ti->flags &= ~(T_NEGOTIATE | T_SYNCMODE);
				}

				/* it may be OK to disconnect */
				if ((sc->sc_flags & ESP_ABORTING) == 0) {
					/*  
					 * Section 5.1.1 of the SCSI 2 spec
					 * suggests issuing a REQUEST SENSE
					 * following an unexpected disconnect.
					 * Some devices go into a contingent
					 * allegiance condition when
					 * disconnecting, and this is necessary
					 * to clean up their state.
					 */     
					printf("%s: unexpected disconnect; ",
					    sc->sc_dev.dv_xname);
					if (ecb->flags & ECB_SENSE) {
						printf("resetting\n");
						goto reset;
					}
					printf("sending REQUEST SENSE\n");
					esp_sense(sc, ecb);
					goto out;
				}

				ecb->xs->error = XS_DRIVER_STUFFUP;
				goto finish;

			case ESP_DISCONNECT:
				TAILQ_INSERT_HEAD(&sc->nexus_list, ecb, chain);
				sc->sc_nexus = NULL;
				goto sched;

			case ESP_CMDCOMPLETE:
				goto finish;
			}
		}

		switch (sc->sc_state) {

		case ESP_SBR:
			printf("%s: waiting for SCSI Bus Reset to happen\n",
				sc->sc_dev.dv_xname);
			return 1;

		case ESP_RESELECTED:
			/*
			 * we must be continuing a message ?
			 */
			if (sc->sc_phase != MESSAGE_IN_PHASE) {
				printf("%s: target didn't identify\n",
					sc->sc_dev.dv_xname);
				espinit(sc, 1);
				return 1;
			}
printf("<<RESELECT CONT'd>>");
#if XXXX
			esp_msgin(sc);
			if (sc->sc_state != ESP_CONNECTED) {
				/* IDENTIFY fail?! */
				printf("%s: identify failed\n",
					sc->sc_dev.dv_xname);
				espinit(sc, 1);
				return 1;
			}
#endif
			break;

		case ESP_IDLE:
if (sc->sc_flags & ESP_ICCS) printf("[[esp: BUMMER]]");
		case ESP_SELECTING:
			sc->sc_msgpriq = sc->sc_msgout = sc->sc_msgoutq = 0;
			sc->sc_flags = 0;

			if (sc->sc_espintr & ESPINTR_RESEL) {
				/*
				 * If we're trying to select a
				 * target ourselves, push our command
				 * back into the ready list.
				 */
				if (sc->sc_state == ESP_SELECTING) {
					ESP_MISC(("backoff selector "));
					sc_link = sc->sc_nexus->xs->sc_link;
					ti = &sc->sc_tinfo[sc_link->target];
					TAILQ_INSERT_HEAD(&sc->ready_list,
					    sc->sc_nexus, chain);
					ecb = sc->sc_nexus = NULL;
				}
				sc->sc_state = ESP_RESELECTED;
				if (sc->sc_phase != MESSAGE_IN_PHASE) {
					/*
					 * Things are seriously fucked up.
					 * Pull the brakes, i.e. reset
					 */
					printf("%s: target didn't identify\n",
						sc->sc_dev.dv_xname);
					espinit(sc, 1);
					return 1;
				}
				if ((ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) != 2) {
					printf("%s: RESELECT: %d bytes in FIFO!\n",
						sc->sc_dev.dv_xname,
						ESP_READ_REG(sc, ESP_FFLAG) &
						ESPFIFO_FF);
					espinit(sc, 1);
					return 1;
				}
				sc->sc_selid = ESP_READ_REG(sc, ESP_FIFO);
				ESP_MISC(("selid=0x%2x ", sc->sc_selid));
				esp_msgin(sc);	/* Handle identify message */
				if (sc->sc_state != ESP_CONNECTED) {
					/* IDENTIFY fail?! */
					printf("%s: identify failed\n",
						sc->sc_dev.dv_xname);
					espinit(sc, 1);
					return 1;
				}
				continue; /* ie. next phase expected soon */
			}

#define	ESPINTR_DONE	(ESPINTR_FC|ESPINTR_BS)
			if ((sc->sc_espintr & ESPINTR_DONE) == ESPINTR_DONE) {
				ecb = sc->sc_nexus;
				if (!ecb)
					panic("esp: not nexus at sc->sc_nexus");

				sc_link = ecb->xs->sc_link;
				ti = &sc->sc_tinfo[sc_link->target];

				switch (sc->sc_espstep) {
				case 0:
					printf("%s: select timeout/no disconnect\n",
						sc->sc_dev.dv_xname);
					ecb->xs->error = XS_SELTIMEOUT;
					goto finish;
				case 1:
					if ((ti->flags & T_NEGOTIATE) == 0) {
						printf("%s: step 1 & !NEG\n",
							sc->sc_dev.dv_xname);
						goto reset;
					}
					if (sc->sc_phase != MESSAGE_OUT_PHASE) {
						printf("%s: !MSGOUT\n",
							sc->sc_dev.dv_xname);
						goto reset;
					}
					/* Start negotiating */
					ti->period = sc->sc_minsync;
					ti->offset = 15;
					sc->sc_flags |= ESP_SYNCHNEGO;
					esp_sched_msgout(SEND_SDTR);
					break;
				case 3:
					/*
					 * Grr, this is supposed to mean
					 * "target left command phase
					 *  prematurely". It seems to happen
					 * regularly when sync mode is on.
					 * Look at FIFO to see if command
					 * went out.
					 * (Timing problems?)
					 */
					if ((ESP_READ_REG(sc, ESP_FFLAG)&ESPFIFO_FF) == 0) {
						/* Hope for the best.. */
						break;
					}
					printf("(%s:%d:%d): selection failed;"
						" %d left in FIFO "
						"[intr %x, stat %x, step %d]\n",
						sc->sc_dev.dv_xname,
						sc_link->target,
						sc_link->lun,
						ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF,
						sc->sc_espintr, sc->sc_espstat,
						sc->sc_espstep);
					ESPCMD(sc, ESPCMD_FLUSH);
					esp_sched_msgout(SEND_ABORT);
					return 1;
				case 2:
					/* Select stuck at Command Phase */
					ESPCMD(sc, ESPCMD_FLUSH);
				case 4:
					/* So far, everything went fine */
					break;
				}
#if 0
				if (ecb->xs->flags & SCSI_RESET)
					esp_sched_msgout(SEND_DEV_RESET);
				else if (ti->flags & T_NEGOTIATE)
					esp_sched_msgout(
					    SEND_IDENTIFY | SEND_SDTR);
				else
					esp_sched_msgout(SEND_IDENTIFY);
#endif

				ecb->flags |= ECB_NEXUS;
				ti->lubusy |= (1 << sc_link->lun);

				sc->sc_prevphase = INVALID_PHASE; /* ?? */
				/* Do an implicit RESTORE POINTERS. */
				sc->sc_dp = ecb->daddr;
				sc->sc_dleft = ecb->dleft;

				/* On our first connection, schedule a timeout. */
				if ((ecb->xs->flags & SCSI_POLL) == 0)
					timeout(esp_timeout, ecb, (ecb->timeout * hz) / 1000);

				sc->sc_state = ESP_CONNECTED;
				break;
			} else {
				printf("%s: unexpected status after select"
					": [intr %x, stat %x, step %x]\n",
					sc->sc_dev.dv_xname,
					sc->sc_espintr, sc->sc_espstat,
					sc->sc_espstep);
				ESPCMD(sc, ESPCMD_FLUSH);
				DELAY(1);
				goto reset;
			}
			if (sc->sc_state == ESP_IDLE) {
				printf("%s: stray interrupt\n", sc->sc_dev.dv_xname);
					return 0;
			}
			break;

		case ESP_CONNECTED:
			if (sc->sc_flags & ESP_ICCS) {
				u_char msg;

				sc->sc_flags &= ~ESP_ICCS;

				if (!(sc->sc_espintr & ESPINTR_DONE)) {
					printf("%s: ICCS: "
					      ": [intr %x, stat %x, step %x]\n",
						sc->sc_dev.dv_xname,
						sc->sc_espintr, sc->sc_espstat,
						sc->sc_espstep);
				}
				if ((ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) != 2) {
					int i = (ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) - 2;
					while (i--)
						(void) ESP_READ_REG(sc, ESP_FIFO);
				}
				ecb->stat = ESP_READ_REG(sc, ESP_FIFO);
				msg = ESP_READ_REG(sc, ESP_FIFO);
				ESP_PHASE(("<stat:(%x,%x)>", ecb->stat, msg));
				if (msg == MSG_CMDCOMPLETE) {
					ecb->xs->resid = ecb->dleft = sc->sc_dleft;
					sc->sc_state = ESP_CMDCOMPLETE;
				} else
					printf("%s: STATUS_PHASE: msg %d\n",
						sc->sc_dev.dv_xname, msg);
				ESPCMD(sc, ESPCMD_MSGOK);
				continue; /* ie. wait for disconnect */
			}
			break;
		default:
			panic("%s: invalid state: %d",
			      sc->sc_dev.dv_xname,
			      sc->sc_state);
		}

		/*
		 * Driver is now in state ESP_CONNECTED, i.e. we
		 * have a current command working the SCSI bus.
		 */
		if (sc->sc_state != ESP_CONNECTED || ecb == NULL) {
			panic("esp no nexus");
		}

		switch (sc->sc_phase) {
		case MESSAGE_OUT_PHASE:
			ESP_PHASE(("MESSAGE_OUT_PHASE "));
			esp_msgout(sc);
			sc->sc_prevphase = MESSAGE_OUT_PHASE;
			break;
		case MESSAGE_IN_PHASE:
			ESP_PHASE(("MESSAGE_IN_PHASE "));
			if (sc->sc_espintr & ESPINTR_BS) {
				ESPCMD(sc, ESPCMD_FLUSH);
				sc->sc_flags |= ESP_WAITI;
				ESPCMD(sc, ESPCMD_TRANS);
			} else if (sc->sc_espintr & ESPINTR_FC) {
				if ((sc->sc_flags & ESP_WAITI) == 0) {
					printf("%s: MSGIN: unexpected FC bit: "
						"[intr %x, stat %x, step %x]\n",
					sc->sc_dev.dv_xname,
					sc->sc_espintr, sc->sc_espstat,
					sc->sc_espstep);
				}
				sc->sc_flags &= ~ESP_WAITI;
				esp_msgin(sc);
			} else {
				printf("%s: MSGIN: weird bits: "
					"[intr %x, stat %x, step %x]\n",
					sc->sc_dev.dv_xname,
					sc->sc_espintr, sc->sc_espstat,
					sc->sc_espstep);
			}
			sc->sc_prevphase = MESSAGE_IN_PHASE;
			break;
		case COMMAND_PHASE: {
			/* well, this means send the command again */
			u_char *cmd = (u_char *)&ecb->cmd;
			int i;

			ESP_PHASE(("COMMAND_PHASE 0x%02x (%d) ",
				ecb->cmd.opcode, ecb->clen));
			if (ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) {
				ESPCMD(sc, ESPCMD_FLUSH);
				DELAY(1);
			}
			/* Now the command into the FIFO */
			for (i = 0; i < ecb->clen; i++)
				ESP_WRITE_REG(sc, ESP_FIFO, *cmd++);
			ESPCMD(sc, ESPCMD_TRANS);
			sc->sc_prevphase = COMMAND_PHASE;
			}
			break;
		case DATA_OUT_PHASE:
			ESP_PHASE(("DATA_OUT_PHASE [%ld] ",(long)sc->sc_dleft));
			ESPCMD(sc, ESPCMD_FLUSH);
			size = min(sc->sc_dleft, sc->sc_maxxfer);
			DMA_SETUP(sc->sc_dma, &sc->sc_dp, &sc->sc_dleft,
				  0, &size);
			sc->sc_prevphase = DATA_OUT_PHASE;
			goto setup_xfer;
		case DATA_IN_PHASE:
			ESP_PHASE(("DATA_IN_PHASE "));
			if (sc->sc_rev == ESP100)
				ESPCMD(sc, ESPCMD_FLUSH);
			size = min(sc->sc_dleft, sc->sc_maxxfer);
			DMA_SETUP(sc->sc_dma, &sc->sc_dp, &sc->sc_dleft,
				  1, &size);
			sc->sc_prevphase = DATA_IN_PHASE;
		setup_xfer:
			/* Program the SCSI counter */
			ESP_WRITE_REG(sc, ESP_TCL, size);
			ESP_WRITE_REG(sc, ESP_TCM, size >> 8);
			if (sc->sc_cfg2 & ESPCFG2_FE) {
				ESP_WRITE_REG(sc, ESP_TCH, size >> 16);
			}
			/* load the count in */
			ESPCMD(sc, ESPCMD_NOP|ESPCMD_DMA);

			/*
			 * Note that if `size' is 0, we've already transceived
			 * all the bytes we want but we're still in DATA PHASE.
			 * Apparently, the device needs padding. Also, a
			 * transfer size of 0 means "maximum" to the chip
			 * DMA logic.
			 */
			ESPCMD(sc,
			       (size==0?ESPCMD_TRPAD:ESPCMD_TRANS)|ESPCMD_DMA);
			DMA_GO(sc->sc_dma);
			return 1;
		case STATUS_PHASE:
			ESP_PHASE(("STATUS_PHASE "));
			sc->sc_flags |= ESP_ICCS;
			ESPCMD(sc, ESPCMD_ICCS);
			sc->sc_prevphase = STATUS_PHASE;
			break;
		case INVALID_PHASE:
			break;
		default:
			printf("%s: unexpected bus phase; resetting\n",
			    sc->sc_dev.dv_xname);
			goto reset;
		}
	}
	panic("esp: should not get here..");

reset:
	espinit(sc, 1);
	return 1;

finish:
	untimeout(esp_timeout, ecb);
	esp_done(sc, ecb);
	goto out;

sched:
	sc->sc_state = ESP_IDLE;
	esp_sched(sc);
	goto out;

out:
	return 1;
}

void
esp_abort(sc, ecb)
	struct esp_softc *sc;
	struct esp_ecb *ecb;
{

	/* 2 secs for the abort */
	ecb->timeout = ESP_ABORT_TIMEOUT;
	ecb->flags |= ECB_ABORT;

	if (ecb == sc->sc_nexus) {
		/*
		 * If we're still selecting, the message will be scheduled
		 * after selection is complete.
		 */
		if (sc->sc_state == ESP_CONNECTED)
			esp_sched_msgout(SEND_ABORT);

		/*
		 * Reschedule timeout. First, cancel a queued timeout (if any)
		 * in case someone decides to call esp_abort() from elsewhere.
		 */
		untimeout(esp_timeout, ecb);
		timeout(esp_timeout, ecb, (ecb->timeout * hz) / 1000);
	} else {
		esp_dequeue(sc, ecb);
		TAILQ_INSERT_HEAD(&sc->ready_list, ecb, chain);
		if (sc->sc_state == ESP_IDLE)
			esp_sched(sc);
	}
}

void
esp_timeout(arg)
	void *arg;
{
	struct esp_ecb *ecb = arg;
	struct scsi_xfer *xs = ecb->xs;
	struct scsi_link *sc_link = xs->sc_link;
	struct esp_softc *sc = sc_link->adapter_softc;
	int s;

	sc_print_addr(sc_link);
	printf("%s: timed out [ecb %p (flags 0x%x, dleft %x, stat %x)], "
	       "<state %d, nexus %p, phase(c %x, p %x), resid %lx, msg(q %x,o %x) %s>",
		sc->sc_dev.dv_xname,
		ecb, ecb->flags, ecb->dleft, ecb->stat,
		sc->sc_state, sc->sc_nexus, sc->sc_phase, sc->sc_prevphase,
		(long)sc->sc_dleft, sc->sc_msgpriq, sc->sc_msgout,
		DMA_ISACTIVE(sc->sc_dma) ? "DMA active" : "");
#if ESP_DEBUG > 0
	printf("TRACE: %s.", ecb->trace);
#endif

	s = splbio();

	if (ecb->flags & ECB_ABORT) {
		/* abort timed out */
		printf(" AGAIN\n");
		espinit(sc, 1);
	} else {
		/* abort the operation that has timed out */
		printf("\n");
		xs->error = XS_TIMEOUT;
		esp_abort(sc, ecb);
	}

	splx(s);
}
@


1.10
log
@esp_init collides with netinet; renamed it
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.9 1998/08/04 23:15:20 millert Exp $	*/
@


1.10.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.10 2000/02/04 17:30:07 deraadt Exp $	*/
@


1.9
log
@fix type of resid in printf
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.8 1997/01/24 19:58:10 niklas Exp $	*/
d126 1
a126 1
/*static*/ void	esp_init	__P((struct esp_softc *, int));
d424 1
a424 1
	esp_init(sc, 1);
d560 1
a560 1
esp_init(sc, doreset)
d567 1
a567 1
	ESP_TRACE(("[ESP_INIT(%d)] ", doreset));
d1588 1
a1588 1
				esp_init(sc, 0); /* Restart everything */
d1633 1
a1633 1
				esp_init(sc, 0); /* Restart everything */
d1650 1
a1650 1
				esp_init(sc, 1);
d1768 1
a1768 1
				esp_init(sc, 1);
d1778 1
a1778 1
				esp_init(sc, 1);
d1812 1
a1812 1
					esp_init(sc, 1);
d1820 1
a1820 1
					esp_init(sc, 1);
d1830 1
a1830 1
					esp_init(sc, 1);
d2089 1
a2089 1
	esp_init(sc, 1);
d2165 1
a2165 1
		esp_init(sc, 1);
@


1.8
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.7 1996/11/23 21:44:59 kstailey Exp $	*/
d1014 1
a1014 1
			printf("resid=%d ", xs->resid);
d1659 1
a1659 1
				       " prevphase %x, resid %x\n",
@


1.7
log
@added const to second parameter of cfprint_t routines
@
text
@d1 2
a2 2
/*	$OpenBSD: esp.c,v 1.6 1996/10/30 22:41:04 niklas Exp $	*/
/*	$NetBSD: esp.c,v 1.22 1996/10/15 21:30:19 mycroft Exp $	*/
d111 2
a112 1
/*static*/ void	espattach	__P((struct device *, struct device *, void *));
d114 1
d116 4
d128 2
a129 1
/*static*/ int	esp_poll	__P((struct esp_softc *, struct scsi_xfer *, int));
d182 1
d184 3
d188 6
a193 1
	void *vcf, *aux;
d196 1
d198 1
d264 1
a264 1
	printf(": address %x", sc->sc_reg);
d1155 1
a1155 1
	ESP_TRACE(("[esp_msgin(curmsglen:%d)] ", sc->sc_imlen));
a1234 1
		struct scsi_link *sc_link;
d1245 3
a1247 3
				sc_link = ecb->xs->sc_link;
				printf("%s: %d extra bytes from %d:%d\n",
				    sc->sc_dev.dv_xname, -sc->sc_dleft,
d1646 6
a1651 1
			DMA_INTR(sc->sc_dma);
d2036 1
a2036 1
			ESP_PHASE(("DATA_OUT_PHASE [%d] ",  sc->sc_dleft));
d2123 7
d2150 1
a2150 1
	       "<state %d, nexus %p, phase(c %x, p %x), resid %x, msg(q %x,o %x) %s>",
d2154 1
a2154 1
		sc->sc_dleft, sc->sc_msgpriq, sc->sc_msgout,
@


1.6
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.22 1996/10/15 21:30:19 mycroft Exp $	*/
d112 1
a112 1
/*static*/ int	espprint	__P((void *, char *));
d167 1
a167 1
	char *name;
@


1.5
log
@-Wall happiness
@
text
@d1 35
a35 2
/*	$OpenBSD: esp.c,v 1.4 1996/07/29 23:02:00 niklas Exp $	*/
/*	$NetBSD: esp.c,v 1.8.4.1 1996/06/05 00:39:03 cgd Exp $	*/
d53 1
a53 1
 * 4. The name of the author may not be used to endorse or promote products 
d102 1
a102 1
#include <machine/autoconf.h>
d112 1
d114 1
a114 1
/*static*/ int	espprint	__P((void *, char *));
d116 2
a117 2
/*static*/ void	espselect	__P((struct esp_softc *,
				     u_char, u_char, u_char *, u_char));
d122 1
a122 1
/*static*/ int	esp_poll	__P((struct esp_softc *, struct ecb *));
d124 1
a124 1
/*static*/ void	esp_done	__P((struct ecb *));
d129 8
a136 3
/*static*/ void	esp_abort	__P((struct esp_softc *, struct ecb *));
int esp_cpb2stp			__P((struct esp_softc *, int));
int esp_stp2cpb			__P((struct esp_softc *, int));
d140 1
a140 1
	sizeof(struct esp_softc), espmatch, espattach,
d144 1
a144 1
	NULL, "esp", DV_DULL,
d161 3
d215 1
a215 1
	int dmachild = strncmp(parent->dv_xname, "espdma", 6) == 0;
d301 2
d323 1
a323 1
		sc->sc_cfg2 = ESPCFG2_SCSI2 | ESPCFG2_FE;
d333 2
d367 1
d371 1
d375 1
d378 2
d434 1
d465 1
a465 1
	config_found(self, &sc->sc_link, espprint);
d480 1
a480 1
void 
d546 1
a546 1
	struct ecb *ecb;
d551 2
a552 1
	if (sc->sc_state == 0) {	/* First time through */
a560 1
			ECB_SETQ(ecb, ECB_QFREE);
d565 6
a570 5
		sc->sc_flags |= ESP_ABORTING;
		sc->sc_state = ESP_IDLE;
		if (sc->sc_nexus != NULL) {
			sc->sc_nexus->xs->error = XS_TIMEOUT;
			esp_done(sc->sc_nexus);
a571 1
		sc->sc_nexus = NULL;
d573 3
a575 2
			ecb->xs->error = XS_TIMEOUT;
			esp_done(ecb);
d586 10
a595 6
		struct esp_tinfo *tp = &sc->sc_tinfo[r];

		tp->flags = (sc->sc_minsync ? T_NEGOTIATE : 0) |
				T_NEED_TO_RESET | (tp->flags & T_XXX);
		tp->period = sc->sc_minsync;
		tp->offset = 0;
a596 1
	sc->sc_flags &= ~ESP_ABORTING;
d601 2
a602 1
		return;
a603 4
	
	sc->sc_state = ESP_IDLE;
	esp_sched(sc);
	return;
d643 11
d656 1
a656 1
int
d669 2
a670 5
/*
 * Convert chip register Clock Per Byte value to Synchronous Transfer Period.
 */
int
esp_cpb2stp(sc, cpb)
d672 1
a672 1
	int cpb;
d674 8
a681 1
	return ((250 * cpb) / sc->sc_freq);
d692 1
a692 1
espselect(sc, target, lun, cmd, clen)
d694 1
a694 3
	u_char target, lun;
	u_char *cmd;
	u_char clen;
d696 2
d699 2
a700 1
	int i;
d702 1
a702 1
	ESP_TRACE(("[espselect(t%d,l%d,cmd:%x)] ", target, lun, *(u_char *)cmd));
d707 2
d714 1
a714 7
	if (ti->flags & T_SYNCMODE) {
		ESP_WRITE_REG(sc, ESP_SYNCOFF, ti->offset);
		ESP_WRITE_REG(sc, ESP_SYNCTP, esp_stp2cpb(sc, ti->period));
	} else {
		ESP_WRITE_REG(sc, ESP_SYNCOFF, 0);
		ESP_WRITE_REG(sc, ESP_SYNCTP, 0);
	}
d720 2
a721 1
	ESP_WRITE_REG(sc, ESP_FIFO, MSG_IDENTIFY(lun, 1));
d730 3
a732 1
	for (i = 0; i < clen; i++)
d739 45
d793 1
a793 1
int 
d799 1
a799 1
	struct ecb 	*ecb;
d801 1
a801 1
	
d803 1
a803 1
	ESP_CMDS(("[0x%x, %d]->%d ", (int)xs->cmd->opcode, xs->cmdlen, 
d807 2
a808 12

	/* Get a esp command block */
	s = splbio();
	ecb = sc->free_list.tqh_first;
	if (ecb) {
		TAILQ_REMOVE(&sc->free_list, ecb, chain);
		ECB_SETQ(ecb, ECB_QNONE);
	}
	splx(s);
		
	if (ecb == NULL) {
		ESP_MISC(("TRY_AGAIN_LATER"));
d814 12
a825 4
	bcopy(xs->cmd, &ecb->cmd, xs->cmdlen);
	ecb->clen = xs->cmdlen;
	ecb->daddr = xs->data;
	ecb->dleft = xs->datalen;
d827 1
a827 1
	
d829 1
a830 3
	ECB_SETQ(ecb, ECB_QREADY);
	timeout(esp_timeout, ecb, (xs->timeout*hz)/1000);

d836 8
a843 3
	if (flags & SCSI_POLL) {
		/* Not allowed to use interrupts, use polling instead */
		return esp_poll(sc, ecb);
d845 1
a845 4

	ESP_MISC(("SUCCESSFULLY_QUEUED"));
	return SUCCESSFULLY_QUEUED;

d852 1
a852 1
esp_poll(sc, ecb)
d854 2
a855 1
	struct ecb *ecb;
a856 2
	struct scsi_xfer *xs = ecb->xs;
	int count = xs->timeout * 100;
d867 2
a868 3
		if (xs->flags & ITSDONE)
			break;
		DELAY(10);
d873 1
d876 1
a876 7

	if (count == 0) {
		ESP_MISC(("esp_poll: timeout"));
		esp_timeout((caddr_t)ecb);
	}

	return COMPLETE;
d894 1
d896 2
a897 3
	struct ecb *ecb;
	int t;
	
a901 3
	if (sc->sc_flags & ESP_ABORTING)
		return;

d908 2
a909 6
		t = sc_link->target;
		if (!(sc->sc_tinfo[t].lubusy & (1 << sc_link->lun))) {
			struct esp_tinfo *ti = &sc->sc_tinfo[t];

			if ((ecb->flags & ECB_QBITS) != ECB_QREADY)
				panic("esp: busy entry on ready list");
a910 1
			ECB_SETQ(ecb, ECB_QNONE);
d912 1
a912 11
			sc->sc_flags = 0;
			sc->sc_prevphase = INVALID_PHASE;
			sc->sc_dp = ecb->daddr;
			sc->sc_dleft = ecb->dleft;
			ti->lubusy |= (1<<sc_link->lun);
/*XXX*/if (sc->sc_msgpriq) {
	printf("esp: message queue not empty: %x!\n", sc->sc_msgpriq);
}
/*XXX*/sc->sc_msgpriq = sc->sc_msgout = 0;
			espselect(sc, t, sc_link->lun,
				  (u_char *)&ecb->cmd, ecb->clen);
d915 35
a949 1
			ESP_MISC(("%d:%d busy\n", t, sc_link->lun));
d957 3
a959 2
esp_done(ecb)
	struct ecb *ecb;
a962 1
	struct esp_softc *sc = sc_link->adapter_softc;
a966 2
	untimeout(esp_timeout, ecb);

d968 1
a968 1
	 * Now, if we've come here with no error code, i.e. we've kept the 
d970 2
a971 2
	 * check sense, we'll need to set up a request sense cmd block and 
	 * push the command back into the ready queue *before* any other 
d976 3
a978 3
		if ((ecb->flags & ECB_ABORTED) != 0) {
			xs->error = XS_TIMEOUT;
		} else if ((ecb->flags & ECB_CHKSENSE) != 0) {
a980 2
			struct scsi_sense *ss = (void *)&ecb->cmd;
			ESP_MISC(("requesting sense "));
d984 1
a984 20
			/* Next, setup a request sense command block */
			bzero(ss, sizeof(*ss));
			ss->opcode = REQUEST_SENSE;
			/*ss->byte2 = sc_link->lun << 5;*/
			ss->length = sizeof(struct scsi_sense_data);
			ecb->clen = sizeof(*ss);
			ecb->daddr = (char *)&xs->sense;
			ecb->dleft = sizeof(struct scsi_sense_data);
			ecb->flags |= ECB_CHKSENSE;
/*XXX - must take off queue here */
			TAILQ_INSERT_HEAD(&sc->ready_list, ecb, chain);
			ECB_SETQ(ecb, ECB_QREADY);
			ti->lubusy &= ~(1<<sc_link->lun);
			ti->senses++;
			timeout(esp_timeout, ecb, (xs->timeout*hz)/1000);
			if (sc->sc_nexus == ecb) {
				sc->sc_nexus = NULL;
				sc->sc_state = ESP_IDLE;
				esp_sched(sc);
			}
d995 6
a1000 12
		printf("err=0x%02x ",xs->error);
		if (xs->error == XS_SENSE) {
			printf("sense=%2x; ", xs->sense.error_code);
			if (xs->sense.error_code == 0x70)
				printf("extcode: %x; ", xs->sense.flags);
		}
	}
	if ((xs->resid || xs->error > XS_SENSE) && esp_debug & ESP_SHOWMISC) {
		if (xs->resid)
			printf("esp_done: resid=%d\n", xs->resid);
		if (xs->error)
			printf("esp_done: error=%d\n", xs->error);
d1007 4
a1010 5
	switch (ecb->flags & ECB_QBITS) {
	case ECB_QNONE:
		if (ecb != sc->sc_nexus) {
			panic("%s: floating ecb", sc->sc_dev.dv_xname);
		}
a1011 1
		ti->lubusy &= ~(1<<sc_link->lun);
d1013 17
a1029 2
		break;
	case ECB_QREADY:
a1030 8
		break;
	case ECB_QNEXUS:
		TAILQ_REMOVE(&sc->nexus_list, ecb, chain);
		ti->lubusy &= ~(1<<sc_link->lun);
		break;
	case ECB_QFREE:
		panic("%s: busy ecb on free list", sc->sc_dev.dv_xname);
		break;
a1031 8

	/* Put it on the free list, and clear flags. */
	TAILQ_INSERT_HEAD(&sc->free_list, ecb, chain);
	ecb->flags = ECB_QFREE;

	ti->cmds++;
	scsi_done(xs);
	return;
d1044 5
a1048 4
	do {				\
		ESP_MISC(("esp_sched_msgout %d ", m)); \
		ESPCMD(sc, ESPCMD_SETATN);	\
		sc->sc_msgpriq |= (m);	\
d1051 70
d1136 1
a1136 1
	
a1164 1
		sc->sc_selid &= ~(1<<sc->sc_id);
a1177 1
		ESPCMD(sc, ESPCMD_SETATN);
d1189 1
a1189 1
		/* 
d1215 8
a1222 3
	if (sc->sc_state == ESP_HASNEXUS) {
		struct ecb *ecb = sc->sc_nexus;
		struct esp_tinfo *ti = &sc->sc_tinfo[ecb->xs->sc_link->target];
d1228 4
a1231 4
				struct scsi_link *sc_link = ecb->xs->sc_link;
				printf("esp: %d extra bytes from %d:%d\n",
					-sc->sc_dleft,
					sc_link->target, sc_link->lun);
d1235 1
a1235 1
			sc->sc_flags |= ESP_BUSFREE_OK;
d1242 2
a1243 8
#if 0 /* XXX - must remember last message */
printf("<<target%d: MSG_MESSAGE_REJECT>>", ecb->xs->sc_link->target);
ti->period = ti->offset = 0;
sc->sc_flags &= ~ESP_SYNCHNEGO;
ti->flags &= ~T_NEGOTIATE;
#endif
			if (sc->sc_flags & ESP_SYNCHNEGO) {
				ti->period = ti->offset = 0;
d1245 5
a1249 1
				ti->flags &= ~T_NEGOTIATE;
a1250 3
			/* Not all targets understand INITIATOR_DETECTED_ERR */
			if (sc->sc_msgout == SEND_INIT_DET_ERR)
				esp_sched_msgout(SEND_ABORT);
d1252 1
d1256 1
d1260 5
a1264 3
			sc->sc_flags |= ESP_DISCON;
			sc->sc_flags |= ESP_BUSFREE_OK;
			break;
d1267 1
a1268 1
			ecb->daddr = sc->sc_dp;
d1270 1
a1272 6
			if (!ecb) {
				esp_sched_msgout(SEND_ABORT);
				printf("%s: no DATAPOINTERs to restore\n",
				    sc->sc_dev.dv_xname);
				break;
			}
d1276 1
a1276 3
		case MSG_PARITY_ERROR:
printf("<<esp:target%d: MSG_PARITY_ERROR>>", ecb->xs->sc_link->target);
			break;
d1283 2
a1284 7
	/*XXX*/if (ti->flags & T_XXX) {
		printf("%s:%d: rejecting SDTR\n",
			"esp", ecb->xs->sc_link->target);
		sc->sc_flags &= ~ESP_SYNCHNEGO;
		esp_sched_msgout(SEND_REJECT);
		break;
	}
d1287 4
a1290 5
				if (sc->sc_minsync == 0) {
					/* We won't do synch */
					ti->offset = 0;
					esp_sched_msgout(SEND_SDTR);
				} else if (ti->offset == 0) {
d1293 9
a1301 7
					ti->offset = 0;
					sc->sc_flags &= ~ESP_SYNCHNEGO;
				} else if (ti->period > 124) {
					printf("%s:%d: async\n", "esp",
						ecb->xs->sc_link->target);
					ti->offset = 0;
					esp_sched_msgout(SEND_SDTR);
d1306 1
a1308 5
					if ((sc->sc_flags&ESP_SYNCHNEGO) == 0) {
						/* Target initiated negotiation */
						sc->sc_flags |= ESP_SYNCHNEGO;
						if (ti->flags & T_SYNCMODE) {
							sc_print_addr(ecb->xs->sc_link);
d1310 3
a1312 1
							printf("%s:%d: dropping out of sync mode\n");
d1314 6
a1319 1
						}
a1320 2
						ESP_WRITE_REG(sc,
						    ESP_SYNCOFF, 0);
a1323 5
						sc->sc_flags &= ~ESP_SYNCHNEGO;
						ESP_WRITE_REG(sc,
						    ESP_SYNCOFF, ti->offset);
						ESP_WRITE_REG(sc,
						    ESP_SYNCTP, p);
a1324 6
						sc_print_addr(ecb->xs->sc_link);
#ifdef ESP_DEBUG
						printf("max sync "
						       "rate %d.%02dMb/s\n",
						        r, s);
#endif
d1327 2
a1328 4
				ti->flags &= ~T_NEGOTIATE;
				break;
			default: /* Extended messages we don't handle */
				ESPCMD(sc, ESPCMD_SETATN);
d1330 5
d1337 1
d1340 4
a1343 6
			/* thanks for that ident... */
			if (!MSG_ISIDENTIFY(sc->sc_imess[0])) {
				ESP_MISC(("unknown "));
printf("%s: unimplemented message: %d\n", sc->sc_dev.dv_xname, sc->sc_imess[0]);
				ESPCMD(sc, ESPCMD_SETATN);
			}
d1346 8
a1353 5
	} else if (sc->sc_state == ESP_RESELECTED) {
		struct scsi_link *sc_link;
		struct ecb *ecb;
		struct esp_tinfo *ti;
		u_char lunit;
d1355 2
a1356 20
		if (MSG_ISIDENTIFY(sc->sc_imess[0])) { 	/* Identify? */
			ESP_MISC(("searching "));
			/*
			 * Search wait queue for disconnected cmd
			 * The list should be short, so I haven't bothered with
			 * any more sophisticated structures than a simple
			 * singly linked list. 
			 */
			lunit = sc->sc_imess[0] & 0x07;
			for (ecb = sc->nexus_list.tqh_first; ecb;
			     ecb = ecb->chain.tqe_next) {
				sc_link = ecb->xs->sc_link;
				if (sc_link->lun == lunit &&
				    sc->sc_selid == (1<<sc_link->target)) {
					TAILQ_REMOVE(&sc->nexus_list, ecb,
					    chain);
					ECB_SETQ(ecb, ECB_QNONE);
					break;
				}
			}
d1358 2
a1359 28
			if (!ecb) {		/* Invalid reselection! */
				esp_sched_msgout(SEND_ABORT);
				printf("esp: invalid reselect (idbit=0x%2x)\n",
				    sc->sc_selid);
			} else {		/* Reestablish nexus */
				/*
				 * Setup driver data structures and
				 * do an implicit RESTORE POINTERS
				 */
				ti = &sc->sc_tinfo[sc_link->target];
				sc->sc_nexus = ecb;
				sc->sc_dp = ecb->daddr;
				sc->sc_dleft = ecb->dleft;
				sc->sc_tinfo[sc_link->target].lubusy
					|= (1<<sc_link->lun);
				ESP_WRITE_REG(sc, ESP_SYNCOFF, ti->offset);
				ESP_WRITE_REG(sc, ESP_SYNCTP,
				    esp_stp2cpb(sc, ti->period));
				ESP_MISC(("... found ecb"));
				sc->sc_state = ESP_HASNEXUS;
			}
		} else {
			printf("%s: bogus reselect (no IDENTIFY) %0x2x\n",
			    sc->sc_dev.dv_xname, sc->sc_selid);
			esp_sched_msgout(SEND_DEV_RESET);
		}
	} else { /* Neither ESP_HASNEXUS nor ESP_RESELECTED! */
		printf("%s: unexpected message in; will send DEV_RESET\n",
d1361 1
d1363 5
d1387 2
a1388 1
	struct ecb *ecb;
d1392 18
a1409 1
	if (sc->sc_prevphase != MESSAGE_OUT_PHASE) {
d1412 2
a1417 1
			sc->sc_flags |= ESP_SYNCHNEGO;
d1425 4
d1431 2
a1432 2
			if (sc->sc_state != ESP_HASNEXUS) {
				printf("esp at line %d: no nexus", __LINE__);
d1438 1
a1439 1
			sc->sc_flags |= ESP_BUSFREE_OK;
d1449 1
a1450 1
			sc->sc_flags |= ESP_BUSFREE_OK;
d1459 2
d1469 12
a1480 1
	DMA_START(sc->sc_dma, &sc->sc_omp, &sc->sc_omlen, 0);
a1482 1
		ESPCMD(sc, ESPCMD_FLUSH);
d1486 1
a1486 3
#if test_stuck_on_msgout
printf("<<XXXmsgoutdoneXXX>>");
#endif
d1500 1
a1500 1
int 
d1504 1
a1504 1
	register struct ecb *ecb;
d1508 1
d1511 1
a1511 1
	
d1531 1
a1531 1
	for (loop = 0; ; loop++, DELAY(50/sc->sc_freq)) {
d1583 1
a1583 3
			sc->sc_state = ESP_IDLE;
			esp_sched(sc);
			return 1;
d1598 1
a1598 1
				if (sc->sc_state == ESP_HASNEXUS ||
d1601 1
a1601 1
					esp_done(ecb);
d1628 2
a1629 1
		if (sc->sc_dma->sc_active && DMA_INTR(sc->sc_dma)) {
d1631 1
a1631 1
			if (sc->sc_dma->sc_active)
d1633 17
a1649 3
			if (!(sc->sc_espstat & ESPSTAT_TC))
				printf("%s: !TC\n", sc->sc_dev.dv_xname);
			continue;
d1651 1
d1661 1
a1661 1
			else 
d1666 2
a1667 1
			ESP_MISC(("<DISC [intr %x, stat %x, step %d]>", sc->sc_espintr, sc->sc_espstat, sc->sc_espstep));
d1677 9
a1685 1
			if (sc->sc_state != ESP_IDLE) {
d1687 8
a1694 2
					printf("%s: sync nego not completed!\n",
						sc->sc_dev.dv_xname);
a1695 1
			/*XXX*/sc->sc_msgpriq = sc->sc_msgout = 0;
d1698 19
a1716 10
				if (!(sc->sc_flags & ESP_BUSFREE_OK))
					ecb->xs->error = XS_TIMEOUT;
				else if (sc->sc_flags & ESP_DISCON) {
					TAILQ_INSERT_HEAD(&sc->nexus_list, ecb, chain);
					ECB_SETQ(ecb, ECB_QNEXUS);
					sc->sc_nexus = NULL;
					sc->sc_flags &= ~ESP_DISCON;
					sc->sc_state = ESP_IDLE;
					esp_sched(sc);
					return 1;
d1719 10
a1728 2
				esp_done(ecb);
				return 1;
a1729 9
			printf("DISCONNECT in IDLE state!\n");
		}

		/* did a message go out OK ? This must be broken */
		if (sc->sc_prevphase == MESSAGE_OUT_PHASE &&
		    sc->sc_phase != MESSAGE_OUT_PHASE) {
			/* we have sent it */
			sc->sc_msgpriq &= ~sc->sc_msgout;
			sc->sc_msgout = 0;
d1752 1
a1752 1
			if (sc->sc_state != ESP_HASNEXUS) {
d1765 2
a1779 2
					ECB_SETQ(sc->sc_nexus, ECB_QREADY);
					ti->lubusy &= ~(1<<sc_link->lun);
d1788 1
a1788 1
					printf("%s: target didn't identify\n", 
d1794 6
a1799 1
printf("<RESELECT: %d bytes in FIFO>", ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF);
a1801 1
				sc->sc_selid &= ~(1<<sc->sc_id);
d1804 1
a1804 1
				if (sc->sc_state != ESP_HASNEXUS) {
d1827 2
a1828 2
					esp_abort(sc, ecb);
					return 1;
d1833 1
a1833 2
						esp_abort(sc, ecb);
						return 1;
d1838 1
a1838 2
						esp_abort(sc, ecb);
						return 1;
d1843 2
a1844 1
					sc->sc_msgpriq = SEND_SDTR;
d1869 1
a1869 1
					sc->sc_flags |= ESP_ABORTING;
a1876 1
					sc->sc_msgpriq = 0;
a1879 1
/* Why set msgpriq? (and not raise ATN) */
d1881 1
a1881 1
					sc->sc_msgpriq = SEND_DEV_RESET;
d1883 2
a1884 2
					sc->sc_msgpriq =
					    SEND_IDENTIFY | SEND_SDTR;
d1886 1
a1886 1
					sc->sc_msgpriq = SEND_IDENTIFY;
d1888 4
a1891 2
				sc->sc_state = ESP_HASNEXUS;
				/*???sc->sc_flags = 0; */
d1893 1
d1896 6
a1901 1
				ti->lubusy |= (1<<sc_link->lun);
d1911 1
a1911 1
				esp_abort(sc, ecb);
d1919 1
a1919 1
		case ESP_HASNEXUS:
d1921 1
a1921 1
				unsigned char msg;
d1933 3
a1935 9
					printf("%s: ICCS: expected 2, got %d "
					      ": [intr %x, stat %x, step %x]\n",
						sc->sc_dev.dv_xname,
						ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF,
						sc->sc_espintr, sc->sc_espstat,
						sc->sc_espstep);
					ESPCMD(sc, ESPCMD_FLUSH);
					esp_abort(sc, ecb);
					return 1;
a1940 1
					sc->sc_flags |= ESP_BUSFREE_OK;
d1942 1
d1957 1
a1957 1
		 * Driver is now in state ESP_HASNEXUS, i.e. we
d1960 1
a1960 1
		if (sc->sc_state != ESP_HASNEXUS || ecb == NULL) {
d2016 3
a2018 1
			DMA_START(sc->sc_dma, &sc->sc_dp, &sc->sc_dleft, 0);
d2020 1
a2020 1
			return 1;
d2025 10
a2034 13
#if 0 /* Why is the fifo sometimes full after re-connect? */
			if (ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) {
				static int xxx;
				if (xxx <= 3) {
					printf("%s: lost %d bytes from FIFO ",
						sc->sc_dev.dv_xname,
						ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF);
					printf(" previous phase %x\n",
						sc->sc_prevphase);
					if (xxx == 3)
						printf("(stopped logging)");
					++xxx;
				}
d2036 13
a2048 4
#endif
			DMA_DRAIN(sc->sc_dma);
			DMA_START(sc->sc_dma, &sc->sc_dp, &sc->sc_dleft, 1);
			sc->sc_prevphase = DATA_IN_PHASE;
a2057 6
		case BUSFREE_PHASE:
			if (sc->sc_flags & ESP_BUSFREE_OK) {
				/*It's fun the 1st time.. */
				sc->sc_flags &= ~ESP_BUSFREE_OK;
			}
			break;
d2059 3
a2061 1
			panic("esp: bogus bus phase\n");
d2065 17
d2087 1
a2087 1
	struct ecb *ecb;
d2089 5
d2095 5
a2099 3
/*XXX*/sc->sc_tinfo[ecb->xs->sc_link->target].flags |= T_XXX;
		if (sc->sc_state == ESP_HASNEXUS) {
			sc->sc_flags |= ESP_ABORTING;
a2100 1
		}
d2102 2
d2113 1
a2113 3
	int s = splbio();
	struct ecb *ecb = (struct ecb *)arg;
	struct esp_softc *sc;
d2115 3
d2119 15
a2133 13
	sc = xs->sc_link->adapter_softc;
	sc_print_addr(xs->sc_link);
again:
	printf("timed out (ecb 0x%x (flags 0x%x, dleft %x), state %d, phase %d, msgpriq %x, msgout %x)",
		ecb, ecb->flags, ecb->dleft, sc->sc_state, sc->sc_phase,
		sc->sc_msgpriq, sc->sc_msgout);

	if (ecb->flags == ECB_QFREE) {
		printf("note: ecb already on free list\n");
		splx(s);
		return;
	}
	if (ecb->flags & ECB_ABORTED) {
a2135 1
		xs->retries = 0;
a2140 8
		ecb->flags |= ECB_ABORTED;
#if 0
if (sc->sc_dma->sc_active) {
	int x = esp_debug; esp_debug=0x3ff;
	DMA_INTR(sc->sc_dma);
	esp_debug = x;
}
#endif
a2141 17
		/* 2 secs for the abort */
		if ((xs->flags & SCSI_POLL) == 0)
			timeout(esp_timeout, ecb, 2 * hz);
		else {
			int count = 200000;
			while (count) {
				if (DMA_ISINTR(sc->sc_dma)) {
					espintr(sc);
				}
				if (xs->flags & ITSDONE)
					break;
				DELAY(10);
				--count;
			}
			if (count == 0)
				goto again;
		}
d2143 1
@


1.4
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.8.4.1 1996/06/05 00:39:03 cgd Exp $	*/
d69 1
d96 2
d137 1
a138 1
#ifdef SPARC_DRIVER
d592 1
d595 1
d608 1
@


1.3
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.2
log
@from netbsd:
machine-independent TurboChannel bus configuration.  These files
deal with stuff like:
        (1) configuring built-in devices,
        (2) looking at TC slots configuring any devices found.
The lists of slots, slot locations, etc. and built-in devices
are provided by machine-dependent code.  Interrupt handling
is also provided by machine-dependent code, but the MD code provides
hooks so that standard names for 'establish' and 'disestablish'
can be used in drivers.

This code requires <machine/tc_machdep.h>, which defines some
portability types specific to the TurboChannel bus code.
@
text
@d1 1
a1 1
/*	$NetBSD: esp.c,v 1.6 1995/12/20 00:40:21 cgd Exp $	*/
d96 6
a101 3
struct cfdriver espcd = {
	NULL, "esp", espmatch, espattach,
	DV_DULL, sizeof(struct esp_softc)
d196 2
a197 2
	sc->sc_reg = (volatile u_int32_t *)tcdsdev->tcdsda_tc.tcda_addr;
	sc->sc_cookie = tcdsdev->tcdsda_tc.tcda_cookie;
d219 1
a219 1
	if (parent->dv_cfdata->cf_driver == &tcdscd) {
d373 1
a374 1
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);
d895 1
a895 1
				printf("extcode: %x; ", xs->sense.extended_flags);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: esp.c,v 1.5 1995/08/03 00:52:06 cgd Exp $	*/
d5 1
d57 1
d60 1
d62 8
a69 2

#include <alpha/tc/tcds_dmavar.h>
d72 1
a72 2
#include <alpha/tc/tc.h>
#include <alpha/tc/tcds.h>
d74 1
a74 1
int esp_debug = ESP_SHOWPHASE|ESP_SHOWMISC|ESP_SHOWTRAC|ESP_SHOWCMDS; /**/ 
d76 18
a93 19
void	espattach	__P((struct device *, struct device *, void *));
int	espmatch	__P((struct device *, void *, void *));
int	espprint	__P((void *, char *));
void	espreadregs	__P((struct esp_softc *));
u_char	espgetbyte	__P((struct esp_softc *));
void	espselect	__P((struct esp_softc *, u_char, u_char,
			    caddr_t, u_char));
void	esp_scsi_reset	__P((struct esp_softc *));
void	esp_reset	__P((struct esp_softc *));
void	esp_init	__P((struct esp_softc *));
int	esp_scsi_cmd	__P((struct scsi_xfer *));
int	esp_poll	__P((struct esp_softc *, struct ecb *));
int	espphase	__P((struct esp_softc *));
void	esp_sched	__P((struct esp_softc *));
void	esp_done	__P((struct ecb *));
void	esp_msgin	__P((struct esp_softc *));
void	esp_msgout	__P((struct esp_softc *));
int	espintr		__P((void *));
void	esp_timeout	__P((void *arg));
d103 1
a103 1
	minphys,		/* no max transfer size; DMA engine deals */
a114 3
/*
 * Does anyone actually use this, and what for ?
 */
d120 3
a122 118
	return -1;
}

#define	CXXX(esp)	(RR((esp)->esp_stat) & ESPSTAT_INT)

/*
 * Read the ESP registers, and save their contents for later use.
 * ESP_STAT, ESP_STEP & ESP_INTR are mostly zeroed out when reading
 * ESP_INTR - so make sure it is the last read.
 *
 * I think that (from reading the docs) most bits in these registers
 * only make sense when he DMA CSR has an interrupt showing. So I have
 * coded this to not do anything if there is no interrupt or error
 * pending.
 */
void
espreadregs(sc)
	struct esp_softc *sc;
{
	int s;
	volatile espreg_t *esp = sc->sc_reg;

	/* They mean nothing if there is no pending interrupt??? */
	if (!(DMA_ISINTR(sc)))
		return;

	s = splhigh();

	/* Only the stepo bits are of interest. */
	sc->sc_espstep = RR(esp->esp_step) & ESPSTEP_MASK;	wbflush();
	sc->sc_espstat = RR(esp->esp_stat);			wbflush();
	sc->sc_espintr = RR(esp->esp_intr);			wbflush();

	/* Clear the TCDS interrupt bit. */
	(void)tcds_scsi_isintr(sc->sc_dev.dv_unit, 1);

	splx(s);

	ESP_MISC(("regs[intr=%02x,stat=%02x,step=%02x] ", sc->sc_espintr,
	    sc->sc_espstat, sc->sc_espstep));
}

/*
 * no error checking ouch
 */
u_char
espgetbyte(sc)
	struct esp_softc *sc;
{
	volatile espreg_t *esp = sc->sc_reg;
	u_int esp_fflag, esp_fifo;

	ESP_TRACE(("esp_getbyte "));
	esp_fflag = RR(esp->esp_fflag);				wbflush();
	if (!(esp_fflag & ESPFIFO_FF)) {
xxx:
		ESPCMD(sc, ESPCMD_TRANS);
		while (!DMA_ISINTR_CLR(sc))
			DELAY(1);
		/*
		 * If we read something, then clear the outstanding
		 * interrupts
		 */
		espreadregs(sc);
	}
	esp_fflag = RR(esp->esp_fflag);				wbflush();
	if (!(esp_fflag & ESPFIFO_FF)) {
		printf("error...\n");
		goto xxx;
	}
	esp_fifo = RR(esp->esp_fifo);				wbflush();
	return esp_fifo;
}

/*
 * Send a command to a target, set the driver state to ESP_SELECTING
 * and let the caller take care of the rest.
 *
 * Keeping this as a function allows me to say that this may be done
 * by DMA instead of programmed I/O soon.
 */
void
espselect(sc, target, lun, cmd, clen)
	struct esp_softc *sc;
	u_char target, lun;
	caddr_t cmd;
	u_char clen;
{
	volatile espreg_t *esp = sc->sc_reg;
	int i;

	ESP_TRACE(("esp_select "));

	/*
	 * The docs say the target register is never reset, and I
	 * can't think of a better place to set it
	 */
	esp->esp_id = target;					wbflush();
	esp->esp_syncoff = sc->sc_tinfo[target].offset;		wbflush();
	esp->esp_synctp = 250 / sc->sc_tinfo[target].period;	wbflush();

	/*
	 * Who am I. This is where we tell the target that we are
	 * happy for it to disconnect etc.
	 */
	esp->esp_fifo = ESP_MSG_IDENTIFY(lun);			wbflush();

	/* Now the command into the FIFO */
	for (i = 0; i < clen; i++) {
		esp->esp_fifo = (u_int)*cmd++;
		wbflush();
	}

	/* And get the targets attention */
	ESPCMD(sc, ESPCMD_SELATN);

	/* new state ESP_SELECTING */
	sc->sc_state = ESP_SELECTING;
d131 3
a133 2
	struct confargs *ca = aux;
	void *addr;
d135 1
a135 1
	if (!BUS_MATCHNAME(ca, "esp"))
d137 6
d144 3
a146 7
#define	ESP0_OFFSET	0x100000	/* SPARSE!! offset. */
#define	ESP1_OFFSET	0x100200	/* SPARSE!! offset. */
	addr = BUS_CVTADDR(ca);
#ifdef SPARSE
	addr = TC_DENSE_TO_SPARSE(addr);
#else
	AXP requires sparse addressing for the 53CF94.
a147 3
	addr = (u_int8_t *)addr +
	    (ca->ca_slot == 0 ? ESP0_OFFSET : ESP1_OFFSET);
	return (!badaddr(addr, 4));
d158 1
d160 3
d164 1
d166 2
a167 2
	void *addr;
	u_int esp_cfg2, esp_cfg3;
d187 1
a187 1
		sc->sc_reg = (volatile caddr_t) ca->ca_ra.ra_vaddr;
d189 2
a190 2
		sc->sc_reg = (volatile caddr_t)
		    mapiodev(ca->ca_ra.ra_paddr, ca->ca_ra.ra_len, ca->ca_bustype);
d193 4
a196 8
	addr = BUS_CVTADDR(ca);
#ifdef SPARSE
	addr = TC_DENSE_TO_SPARSE(addr);
#else
	AXP requires sparse addressing for the 53CF94.
#endif
	sc->sc_reg = (espreg_t *)((u_int8_t *)addr + 
	    (ca->ca_slot == 0 ? ESP0_OFFSET : ESP1_OFFSET));
d198 2
a199 1
	BUS_INTR_ESTABLISH(ca, espintr, (void *)sc);
d216 8
a223 6
	/*
	 * XXX
	 * Bus ID on AXP should be 6?
	 */
	sc->sc_id = 7;
	sc->sc_freq = 25000000;
d229 17
a245 10
	/*
	 * This is the value used to start sync negotiations
	 * For a 25Mhz clock, this gives us 40, or 160nS, or
	 * 6.25Mb/s. It is constant for each adapter.
	 *
	 * In turn, notice that the ESP register "SYNCTP" is
	 * = (250 / the negotiated period). It works, try it
	 * on paper.
	 */
	sc->sc_minsync = 1000 / sc->sc_freq;
d247 6
a252 33
	/* 0 is actually 8, even though the register only has 3 bits */
	sc->sc_ccf = FREQTOCCF(sc->sc_freq) & 0x07;

	/* The value *must not* be == 1. Make it 2 */
	if (sc->sc_ccf == 1)
		sc->sc_ccf = 2;

	/*
	 * The recommended timeout is 250ms. This register is loaded
	 * with a value calculated as follows, from the docs:
	 *
	 *		(timout period) x (CLK frequency)
	 *	reg = -------------------------------------
	 *		 8192 x (Clock Conversion Factor)
	 *
	 * We have the CCF from above, so the sum is simple, and generally
	 * gives us a constant of 153. Try working out a few and see.
	 */
	sc->sc_timeout = ESP_DEF_TIMEOUT;

#ifdef SPARC_DRIVER
	/*
	 * find the DMA by poking around the dma device structures
	 *
	 * What happens here is that if the dma driver has not been
	 * configured, then this returns a NULL pointer. Then when the
	 * dma actually gets configured, it does the opposing test, and
	 * if the sc->sc_esp field in it's softc is NULL, then tries to
	 * find the matching esp driver.
	 *
	 */
	sc->sc_dma = ((struct dma_softc *)getdevunit("dma",
	    sc->sc_dev.dv_unit));
d254 1
a254 3
	sc->sc_dma = &sc->__dma;
	sc->sc_dma->sc_dev = sc->sc_dev;		/* XXX */
	dma_init(sc->sc_dma);
a257 6
	 * and a back pointer to us, for DMA
	 */
	if (sc->sc_dma)
		sc->sc_dma->sc_esp = sc;

	/*
d264 1
a264 1
	sc->sc_cfg2 = ESPCFG2_SCSI2 | ESPCFG2_RSVD;
d266 1
a266 1
	sc->sc_reg->esp_cfg2 = sc->sc_cfg2;			wbflush();
d268 1
a268 3
	esp_cfg2 = RR(sc->sc_reg->esp_cfg2);			wbflush();
	if ((esp_cfg2 & ~ESPCFG2_RSVD) !=
	    (ESPCFG2_SCSI2 | ESPCFG2_RPE)) {
d272 2
a273 2
		sc->sc_cfg2 = 0;
		sc->sc_reg->esp_cfg2 = sc->sc_cfg2;		wbflush();
d275 4
a278 5
		sc->sc_reg->esp_cfg3 = sc->sc_cfg3;		wbflush();
		sc->sc_cfg3 = 5;
		sc->sc_reg->esp_cfg3 = sc->sc_cfg3;		wbflush();
		esp_cfg3 = RR(sc->sc_reg->esp_cfg3);		wbflush();
		if (esp_cfg3 != 5) {
d283 1
a283 1
			sc->sc_reg->esp_cfg3 = sc->sc_cfg3;	wbflush();
d290 1
a290 1
	sc->sc_cfg3 = 0x4;		/* Save residual byte. */
d295 52
d348 1
a348 1
	esp_init(sc);
d355 9
a363 2
	if (ca->ca_bustype == BUS_SBUS)
		sbus_establish(&sc->sc_sd, &sc->sc_dev);
d365 1
d393 1
a393 1
			sc->sc_bp = bp + 1;
d396 3
a398 2
		if (bp != NULL && strcmp(bp->name, "esp") == 0)
			sc->sc_bp = bp + 1;
d407 4
a424 1
	volatile espreg_t *esp = sc->sc_reg; 
d429 3
a431 2
	ESPCMD(sc, ESPCMD_RSTCHIP);		/* reset chip */
	ESPCMD(sc, ESPCMD_NOP);			/* requires following NOP. */
d434 1
a434 1
	/* ESP: do these backwards, and fall through */
d436 1
d438 1
a438 7
		esp->esp_cfg1 = sc->sc_cfg1;			wbflush();
		esp->esp_cfg2 = sc->sc_cfg2;			wbflush();
		esp->esp_cfg3 = sc->sc_cfg3;			wbflush();
		esp->esp_ccf = sc->sc_ccf;			wbflush();
		esp->esp_syncoff = 0;				wbflush();
		esp->esp_timeout = sc->sc_timeout;		wbflush();
		break;
d440 1
a440 1
		esp->esp_cfg3 = sc->sc_cfg3;			wbflush();
d442 1
a442 1
		esp->esp_cfg2 = sc->sc_cfg2;			wbflush();
d444 4
a447 4
		esp->esp_cfg1 = sc->sc_cfg1;			wbflush();
		esp->esp_ccf = sc->sc_ccf;			wbflush();
		esp->esp_syncoff = 0;				wbflush();
		esp->esp_timeout = sc->sc_timeout;		wbflush();
d452 4
a455 4
		esp->esp_cfg1 = sc->sc_cfg1;			wbflush();
		esp->esp_ccf = sc->sc_ccf;			wbflush();
		esp->esp_syncoff = 0;				wbflush();
		esp->esp_timeout = sc->sc_timeout;		wbflush();
d466 9
a476 1
	DELAY(50);
d483 1
a483 1
esp_init(sc)
d485 1
d489 2
a490 5
	
	/*
	 * reset the chip to a known state
	 */
	esp_reset(sc);
d496 1
a496 1
		sc->sc_nexus = 0;
d501 1
a503 1
		/* XXX: NetBSD error. */
d506 1
d509 1
a509 2
			sc->sc_nexus->xs->error = XS_DRIVER_STUFFUP;
			untimeout(esp_timeout, sc->sc_nexus);
d513 2
a514 3
		while (ecb = sc->nexus_list.tqh_first) {
			ecb->xs->error = XS_DRIVER_STUFFUP;
			untimeout(esp_timeout, ecb);
d518 6
a523 1
	
d527 3
a529 1
		tp->flags = DO_NEGOTIATE | NEED_TO_RESET;
d531 8
a538 1
		tp->offset = ESP_SYNC_REQ_ACK_OFS;
d540 1
d542 1
d547 115
d679 1
a679 1
	ESP_TRACE(("\nesp_scsi_cmd "));
d690 1
a694 1
		xs->error = XS_DRIVER_STUFFUP;
a699 1
	ecb->flags = ECB_ACTIVE;
d709 1
d736 1
a736 3
	int count = xs->timeout * 10;

	ESP_TRACE(("esp_poll "));
d738 1
d740 1
a740 1
		if (DMA_ISINTR(sc)) {
d743 4
d749 5
a753 1
		DELAY(5);
d765 1
a770 27
 * Determine the SCSI bus phase, return either a real SCSI bus phase
 * or some pseudo phase we use to detect certain exceptions.
 *
 * Notice that we do not read the live register on an ESP100. On the
 * ESP100A and above the FE (Feature Enable) bit in config 2 latches
 * the phase in the register so it is safe to read.
 */
int
espphase(sc)
	struct esp_softc *sc;
{
	u_int esp_stat;
	
	ESP_TRACE(("espphase "));
	if (sc->sc_espintr & ESPINTR_DIS)	/* Disconnected */
		return BUSFREE_PHASE;

	if (sc->sc_rev != ESP100) {
		esp_stat = RR(sc->sc_reg->esp_stat);		wbflush();
		return (esp_stat & ESPSTAT_PHASE);
	}

	return (sc->sc_espstat & ESPSTAT_PHASE);
}


/*
d784 6
a789 1
	ESP_TRACE(("esp_sched "));
a795 1
		caddr_t cmd = (caddr_t) &ecb->cmd;
d799 1
a799 1
			struct esp_tinfo *ti = &sc->sc_tinfo[ecb->xs->sc_link->target];
d801 2
d804 1
a807 3
			sc_link = ecb->xs->sc_link;
			espselect(sc, t, sc_link->lun, cmd, ecb->clen);
			ti = &sc->sc_tinfo[sc_link->target];
d811 6
d833 1
d835 3
a837 1
	ESP_TRACE(("esp_done "));
d847 6
a852 2
	if (xs->error == XS_NOERROR && !(ecb->flags & ECB_CHKSENSE)) {
		if ((ecb->stat & ST_MASK)==SCSI_CHECK) {
d861 1
a861 1
			ss->byte2 = sc_link->lun << 5;
d866 2
a867 1
			ecb->flags = ECB_ACTIVE|ECB_CHKSENSE;
d869 4
a872 4
			sc->sc_tinfo[sc_link->target].lubusy &=
			    ~(1<<sc_link->lun);
			sc->sc_tinfo[sc_link->target].senses++;
			/* found it */
d879 2
d883 1
a883 6
	
	if (xs->error == XS_NOERROR && (ecb->flags & ECB_CHKSENSE)) {
		xs->error = XS_SENSE;
	} else {
		xs->resid = ecb->dleft;
	}
d886 1
a886 1
#if ESP_DEBUG > 1
d889 5
a893 2
		if (xs->error == XS_SENSE)
			printf("sense=%2x\n", xs->sense.error_code);
d904 1
a904 5
	 * Remove the ECB from whatever queue it's on.  We have to do a bit of
	 * a hack to figure out which queue it's on.  Note that it is *not*
	 * necessary to cdr down the ready queue, but we must cdr down the
	 * nexus queue and see if it's there, so we can mark the unit as no
	 * longer busy.  This code is sickening, but it works.
d906 5
a910 1
	if (ecb == sc->sc_nexus) {
d912 1
a912 1
		sc->sc_tinfo[sc_link->target].lubusy &= ~(1<<sc_link->lun);
d914 2
a915 1
	} else if (sc->ready_list.tqh_last == &ecb->chain.tqe_next) {
d917 8
a924 19
	} else {
		register struct ecb *ecb2;
		for (ecb2 = sc->nexus_list.tqh_first; ecb2;
		    ecb2 = ecb2->chain.tqe_next)
			if (ecb2 == ecb) {
				TAILQ_REMOVE(&sc->nexus_list, ecb, chain);
				sc->sc_tinfo[sc_link->target].lubusy
					&= ~(1<<sc_link->lun);
				break;
			}
		if (ecb2)
			;
		else if (ecb->chain.tqe_next) {
			TAILQ_REMOVE(&sc->ready_list, ecb, chain);
		} else {
			printf("%s: can't find matching ecb\n",
			    sc->sc_dev.dv_xname);
			Debugger();
		}
d926 2
a927 2
	/* Put it on the free list. */
	ecb->flags = ECB_FREE;
d929 1
d931 1
a931 1
	sc->sc_tinfo[sc_link->target].cmds++;
d966 1
a966 2
	volatile espreg_t *esp = sc->sc_reg;
	int extlen;
d968 1
a968 1
	ESP_TRACE(("esp_msgin "));
d970 3
a972 3
	/* is something wrong ? */
	if (sc->sc_phase != MESSAGE_IN_PHASE) {
		printf("%s: not MESSAGE_IN_PHASE\n", sc->sc_dev.dv_xname);
d987 4
d995 2
a996 1
		sc->sc_selid = espgetbyte(sc) & ~(1<<sc->sc_id);
d998 1
d1000 8
d1009 7
a1015 8
	for (;;) {
		/*
		 * If parity errors just dump everything on the floor
		 */
		if (sc->sc_espstat & ESPSTAT_PE) {
			esp_sched_msgout(SEND_PARITY_ERROR);
			sc->sc_flags |= ESP_DROP_MSGI;
		}
d1017 10
a1026 3
		/*
		 * If we're going to reject the message, don't bother storing
		 * the incoming bytes.  But still, we need to ACK them.
d1028 7
a1034 26
		if ((sc->sc_flags & ESP_DROP_MSGI) == 0) {
			sc->sc_imess[sc->sc_imlen] = espgetbyte(sc);
			ESP_MISC(("0x%02x ", sc->sc_imess[sc->sc_imlen]));
			if (sc->sc_imlen >= ESP_MAX_MSG_LEN) {
				esp_sched_msgout(SEND_REJECT);
				sc->sc_flags |= ESP_DROP_MSGI;
			} else {
				sc->sc_imlen++;
				/* 
				 * This testing is suboptimal, but most
				 * messages will be of the one byte variety, so
				 * it should not effect performance
				 * significantly.
				 */
				if (sc->sc_imlen == 1 &&
				    IS1BYTEMSG(sc->sc_imess[0]))
					break;
				if (sc->sc_imlen == 2 &&
				    IS2BYTEMSG(sc->sc_imess[0]))
					break;
				if (sc->sc_imlen >= 3 &&
				    ISEXTMSG(sc->sc_imess[0]) &&
				    sc->sc_imlen == sc->sc_imess[1] + 2)
					break;
			}
		}
d1036 3
d1040 2
a1041 1
	ESP_MISC(("gotmsg "));
d1054 1
a1054 7
			ESP_MISC(("cmdcomplete "));
			if (!ecb) {
				esp_sched_msgout(SEND_ABORT);
				printf("%s: CMDCOMPLETE but no command?\n",
				    sc->sc_dev.dv_xname);
				break;
			}
d1058 3
a1060 2
				    -sc->sc_dleft, sc_link->target, sc_link->lun);
				ecb->dleft = 0;
a1061 1
			ESPCMD(sc, ESPCMD_MSGOK);
d1064 1
a1064 1
			return;
d1067 1
a1067 1
			if (esp_debug & ESP_SHOWMISC)
d1070 6
d1079 1
a1079 1
				ti->flags &= ~DO_NEGOTIATE;
a1083 1
			ESPCMD(sc, ESPCMD_MSGOK);
d1086 1
a1086 1
			ESPCMD(sc, ESPCMD_MSGOK);
d1089 1
a1089 7
			if (!ecb) {
				esp_sched_msgout(SEND_ABORT);
				printf("%s: nothing to DISCONNECT\n",
				    sc->sc_dev.dv_xname);
				break;
			}
			ESPCMD(sc, ESPCMD_MSGOK);
d1091 1
a1091 3
			TAILQ_INSERT_HEAD(&sc->nexus_list, ecb, chain);
			ecb = sc->sc_nexus = NULL;
			sc->sc_state = ESP_IDLE;
d1095 1
a1095 7
			if (!ecb) {
				esp_sched_msgout(SEND_ABORT);
				printf("%s: no DATAPOINTERs to save\n",
				    sc->sc_dev.dv_xname);
				break;
			}
			ESPCMD(sc, ESPCMD_MSGOK);
d1100 1
a1106 1
			ESPCMD(sc, ESPCMD_MSGOK);
d1110 3
d1114 1
d1117 9
d1128 2
a1129 2
				if (ti->offset == 0) {
					printf("%s: async\n", TARGETNAME(ecb));
d1131 6
d1138 2
a1139 1
					printf("%s: async\n", TARGETNAME(ecb));
d1142 34
a1175 4
				} else {	/* we are sync */
					printf("%s: sync rate %2fMb/s\n",
					    TARGETNAME(ecb),
					    sc->sc_freq/ti->period);
d1177 1
a1182 1
			ESPCMD(sc, ESPCMD_MSGOK);
d1185 1
d1187 1
a1187 1
			if (!ESP_MSG_ISIDENT(sc->sc_imess[0])) {
d1189 1
a1191 1
			ESPCMD(sc, ESPCMD_MSGOK);
d1197 1
d1199 2
a1200 1
		if (ESP_MSG_ISIDENT(sc->sc_imess[0])) { 	/* Identify? */
d1210 1
a1210 1
			    ecb = ecb->chain.tqe_next) {
d1216 1
d1230 1
d1236 3
a1238 6
				esp->esp_syncoff =
				    sc->sc_tinfo[sc_link->target].offset;
								wbflush();
				esp->esp_synctp =
				    250 / sc->sc_tinfo[sc_link->target].period;
								wbflush();
d1252 7
a1268 1
	volatile espreg_t *esp = sc->sc_reg;
d1272 2
a1273 1
	ESP_TRACE(("esp_msgout "));
d1279 1
a1279 1
		case SEND_SDTR:	/* Also implies an IDENTIFY message */
d1283 7
a1289 7
			sc->sc_omess[1] = MSG_EXTENDED;
			sc->sc_omess[2] = 3;
			sc->sc_omess[3] = MSG_EXT_SDTR;
			sc->sc_omess[4] = ti->period;
			sc->sc_omess[5] = ti->offset;
			sc->sc_omlen = 6;
			/* Fallthrough! */
a1292 1
				Debugger();
d1295 1
a1295 1
			sc->sc_omess[0] = ESP_MSG_IDENTIFY(ecb->xs->sc_link->lun);
d1300 4
d1306 1
a1306 1
			sc->sc_omess[0] = MSG_PARITY_ERR;
d1325 1
d1328 11
d1351 2
a1352 2
espintr(__sc)
	void *__sc;
d1354 1
a1354 2
	register struct esp_softc *sc = __sc;
	register struct ecb *ecb = sc->sc_nexus;
a1355 1
	volatile espreg_t *esp = sc->sc_reg;
a1356 2
	caddr_t cmd;
	u_int esp_fflag;
d1359 1
a1359 1
	ESP_TRACE(("espintr "));
d1380 1
a1380 2
#define FOREVER
	for (loop = 0; FOREVER;loop++) {
d1382 2
a1383 2
		if (!DMA_ISINTR(sc) && loop)
			return 1;
a1390 9
#ifndef SPARC_DRIVER
		if (!(sc->sc_espstat & ESPSTAT_INT))
			return (0);
#endif
		if (sc->sc_state == ESP_IDLE ||
		    !(sc->sc_espstat & ESPSTAT_INT)) {
			printf("%s: stray interrupt\n", sc->sc_dev.dv_xname);
			return 0;
		}
a1394 9
		 * What phase are we in when we *entered* the
		 * interrupt handler ?
		 *
		 * On laster ESP chips (ESP236 and up) the FE (features
		 * enable) bit in config 2 latches the phase bits
		 * at each "command completion".
		 */
		sc->sc_phase = espphase(sc);
		/*
d1396 1
a1396 1
		 * Command are classed as errors. A diconnect is a
a1409 1
#define ESPINTR_ERR (ESPINTR_SBR|ESPINTR_ILL)
d1411 7
a1417 9
		if (sc->sc_espintr & ESPINTR_ERR
		 || sc->sc_espstat & ESPSTAT_GE) {
			/* SCSI Reset */
			if (sc->sc_espintr & ESPINTR_SBR) {
				esp_fflag = RR(esp->esp_fflag);	wbflush();
				if (esp_fflag & ESPFIFO_FF) {
					ESPCMD(sc, ESPCMD_FLUSH);
					DELAY(1);
				}
d1419 2
a1420 2
				    sc->sc_dev.dv_xname);
				esp_init(sc); /* Restart everything */
d1423 19
d1445 1
a1445 2
				esp_fflag = RR(esp->esp_fflag);	wbflush();
				if (esp_fflag & ESPFIFO_FF) {
d1449 2
a1450 2
				DELAY(1);
				if (sc->sc_state == ESP_HASNEXUS) {
a1451 2
					untimeout(esp_timeout, ecb);
					espreadregs(sc);
d1459 5
a1463 4
				printf("%s: illegal command\n",
				    sc->sc_dev.dv_xname);
				esp_fflag = RR(esp->esp_fflag);	wbflush();
				if (esp_fflag & ESPFIFO_FF) {
d1467 1
a1467 6
				if (sc->sc_state == ESP_HASNEXUS) {
					ecb->xs->error = XS_DRIVER_STUFFUP;
					untimeout(esp_timeout, ecb);
					esp_done(ecb);
				}
				esp_reset(sc);		/* so start again */
d1483 2
a1484 1
			DELAY(50/sc->sc_freq);
d1492 2
a1493 1
			printf("esp: SCSI bus parity error\n");
d1501 2
a1502 3
			ESP_MISC(("disc "));
			esp_fflag = RR(esp->esp_fflag);		wbflush();
			if (esp_fflag & ESPFIFO_FF) {
d1512 6
d1521 10
a1530 1
				untimeout(esp_timeout, ecb);
d1534 1
d1547 5
d1558 2
a1559 2
				    sc->sc_dev.dv_xname);
				esp_init(sc);
d1562 2
d1568 2
a1569 2
				    sc->sc_dev.dv_xname);
				esp_init(sc);
d1572 1
d1576 1
d1587 2
d1591 3
a1593 1
					sc->sc_nexus = NULL;
d1602 2
a1603 2
					    sc->sc_dev.dv_xname);
					esp_init(sc);
d1606 6
d1616 2
a1617 2
					    sc->sc_dev.dv_xname);
					esp_init(sc);
d1620 1
a1620 1
				break;
d1628 1
d1631 61
d1694 1
a1694 1
				else if (ti->flags & DO_NEGOTIATE)
d1699 1
d1701 2
a1702 2
				sc->sc_flags = 0;
				sc->sc_prevphase = INVALID_PHASE;
d1707 13
a1719 9
			} else if (sc->sc_espintr & ESPINTR_FC) {
				if (sc->sc_espstep != ESPSTEP_DONE) {
					esp_fflag = RR(esp->esp_fflag);
					wbflush();
					if (esp_fflag & ESPFIFO_FF) {
						ESPCMD(sc, ESPCMD_FLUSH);
						DELAY(1);
					}
				}
d1721 1
a1721 3
			/* We aren't done yet, but expect to be soon */
			DELAY(50/sc->sc_freq);
			continue;
d1724 35
d1761 3
a1763 1
			panic("esp unknown state");
a1769 1
		cmd = (caddr_t) &ecb->cmd;
d1782 21
a1802 1
			esp_msgin(sc);
d1805 1
a1805 1
		case COMMAND_PHASE:
d1807 3
d1812 1
a1812 2
			esp_fflag = RR(esp->esp_fflag);		wbflush();
			if (esp_fflag & ESPFIFO_FF) {
d1816 4
a1819 3
			espselect(sc, ecb->xs->sc_link->target,
			    ecb->xs->sc_link->lun, (caddr_t)&ecb->cmd,
			    ecb->clen);
d1821 1
d1825 1
d1828 1
a1828 1
			break;
d1831 17
d1851 1
a1851 1
			break;
d1854 1
a1855 2
			ecb->stat = espgetbyte(sc);
			ESP_PHASE(("0x%02x ", ecb->stat));
d1869 18
a1886 1
		DELAY(50/sc->sc_freq);
d1897 1
d1899 48
a1946 9
	ESP_TRACE(("esp_timeout "));

	sc = ecb->xs->sc_link->adapter_softc;
	sc_print_addr(ecb->xs->sc_link);
	ecb->xs->error = XS_TIMEOUT;
	printf("timed out\n");

	esp_done(ecb);
	esp_reset(sc);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
