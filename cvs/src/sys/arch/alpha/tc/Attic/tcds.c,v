head	1.10;
access;
symbols
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	UBC_SYNC_A:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.10
	UBC:1.8.0.16
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.14
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.12
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.10
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.8
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.6
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.4
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.8
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2002.05.02.22.56.06;	author miod;	state dead;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.28;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.01.11.05.11.05;	author millert;	state Exp;
branches
	1.8.6.1
	1.8.16.1;
next	1.7;

1.7
date	97.01.24.19.58.22;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.11.23.21.45.02;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	96.10.30.22.41.27;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.07.29.23.02.34;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.06.18.09.45.29;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.26.18.12.08;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.50;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.50;	author deraadt;	state Exp;
branches;
next	;

1.8.6.1
date	2002.03.28.10.06.14;	author niklas;	state Exp;
branches;
next	1.8.6.2;

1.8.6.2
date	2003.03.27.23.18.07;	author niklas;	state dead;
branches;
next	;

1.8.16.1
date	2002.06.11.03.33.41;	author art;	state dead;
branches;
next	;


desc
@@


1.10
log
@Big TURBOchannel support catchup from NetBSD, part 1.
A few local changes and tweaks remain.

This bring DEC 3000 machines back in the game, but framebuffers are still
not supported at the moment.

Thanks to ericj@@ and nate@@ for supplying me a DEC 3000 for testing.
@
text
@/*	$OpenBSD: tcds.c,v 1.9 2002/03/14 01:26:28 millert Exp $	*/
/*	$NetBSD: tcds.c,v 1.16 1996/12/05 01:39:45 cgd Exp $	*/

/*
 * Copyright (c) 1994, 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Keith Bostic, Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <machine/pte.h>
#include <machine/rpb.h>
#ifndef EVCNT_COUNTERS
#include <machine/intrcnt.h>
#endif

#include <dev/tc/tcreg.h>
#include <dev/tc/tcvar.h>
#include <alpha/tc/tcdsreg.h>
#include <alpha/tc/tcdsvar.h>

struct tcds_softc {
	struct	device sc_dv;
	tc_addr_t sc_base;
	void	*sc_cookie;

	volatile u_int32_t *sc_cir;
	volatile u_int32_t *sc_imer;

	struct tcds_slotconfig sc_slots[2];
};

/* Definition of the driver for autoconfig. */
#ifdef __BROKEN_INDIRECT_CONFIG
int	tcdsmatch(struct device *, void *, void *);
#else
int	tcdsmatch(struct device *, struct cfdata *, void *);
#endif
void	tcdsattach(struct device *, struct device *, void *);
int     tcdsprint(void *, const char *);

struct cfattach tcds_ca = {
	sizeof(struct tcds_softc), tcdsmatch, tcdsattach,
};

struct cfdriver tcds_cd = {
	NULL, "tcds", DV_DULL,
};

/*static*/ int	tcds_intr(void *);
/*static*/ int	tcds_intrnull(void *);

int
tcdsmatch(parent, cfdata, aux)
	struct device *parent;
#ifdef __BROKEN_INDIRECT_CONFIG
	void *cfdata;
#else
	struct cfdata *cfdata;
#endif
	void *aux;
{
	struct tc_attach_args *ta = aux;
	extern int cputype;

	/* Make sure that we're looking for this type of device. */
	if (strncmp("PMAZ-DS ", ta->ta_modname, TC_ROM_LLEN))
		return (0);
	/* PMAZ-FS? */

	/* Check that it can actually exist. */
	if ((cputype != ST_DEC_3000_500) && (cputype != ST_DEC_3000_300))
		panic("tcdsmatch: how did we get here?");

	return (1);
}

void
tcdsattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct tcds_softc *sc = (struct tcds_softc *)self;
	struct tc_attach_args *ta = aux;
	struct tcdsdev_attach_args tcdsdev;
	struct tcds_slotconfig *slotc;
	int i;
	extern int cputype;

	printf("\n");

	sc->sc_base = ta->ta_addr;
	sc->sc_cookie = ta->ta_cookie;

	sc->sc_cir = TCDS_REG(sc->sc_base, TCDS_CIR);
	sc->sc_imer = TCDS_REG(sc->sc_base, TCDS_IMER);

	tc_intr_establish(parent, sc->sc_cookie, TC_IPL_BIO, tcds_intr, sc);

	/*
	 * XXX
	 * IMER apparently has some random (or, not so random, but still
	 * not useful) bits set in it when the system boots.  Clear it.
	 */
	*sc->sc_imer = 0;
	alpha_mb();

	/* XXX Initial contents of CIR? */

	/*
	 * Set up the per-slot defintions for later use.
	 */

	/* fill in common information first */
	for (i = 0; i < 2; i++) {
		slotc = &sc->sc_slots[i];

		bzero(slotc, sizeof *slotc);	/* clear everything */

		slotc->sc_slot = i;
		slotc->sc_tcds = sc;
		slotc->sc_esp = NULL;
		slotc->sc_intrhand = tcds_intrnull;
		slotc->sc_intrarg = (void *)(long)i;
	}

	/* information for slot 0 */
	slotc = &sc->sc_slots[0];
	slotc->sc_resetbits = TCDS_CIR_SCSI0_RESET;
	slotc->sc_intrmaskbits =
	    TCDS_IMER_SCSI0_MASK | TCDS_IMER_SCSI0_ENB;
	slotc->sc_intrbits = TCDS_CIR_SCSI0_INT;
	slotc->sc_dmabits = TCDS_CIR_SCSI0_DMAENA;
	slotc->sc_errorbits = 0;				/* XXX */
	slotc->sc_sda = TCDS_REG(sc->sc_base, TCDS_SCSI0_DMA_ADDR);
	slotc->sc_dic = TCDS_REG(sc->sc_base, TCDS_SCSI0_DMA_INTR);
	slotc->sc_dud0 = TCDS_REG(sc->sc_base, TCDS_SCSI0_DMA_DUD0);
	slotc->sc_dud1 = TCDS_REG(sc->sc_base, TCDS_SCSI0_DMA_DUD1);

	/* information for slot 1 */
	slotc = &sc->sc_slots[1];
	slotc->sc_resetbits = TCDS_CIR_SCSI1_RESET;
	slotc->sc_intrmaskbits =
	    TCDS_IMER_SCSI1_MASK | TCDS_IMER_SCSI1_ENB;
	slotc->sc_intrbits = TCDS_CIR_SCSI1_INT;
	slotc->sc_dmabits = TCDS_CIR_SCSI1_DMAENA;
	slotc->sc_errorbits = 0;				/* XXX */
	slotc->sc_sda = TCDS_REG(sc->sc_base, TCDS_SCSI1_DMA_ADDR);
	slotc->sc_dic = TCDS_REG(sc->sc_base, TCDS_SCSI1_DMA_INTR);
	slotc->sc_dud0 = TCDS_REG(sc->sc_base, TCDS_SCSI1_DMA_DUD0);
	slotc->sc_dud1 = TCDS_REG(sc->sc_base, TCDS_SCSI1_DMA_DUD1);

	/* find the hardware attached to the TCDS ASIC */
	strncpy(tcdsdev.tcdsda_modname, "PMAZ-AA ", TC_ROM_LLEN);
	tcdsdev.tcdsda_slot = 0;
	tcdsdev.tcdsda_offset = 0;
	tcdsdev.tcdsda_addr = (tc_addr_t)
	    TC_DENSE_TO_SPARSE(sc->sc_base + TCDS_SCSI0_OFFSET);
	tcdsdev.tcdsda_cookie = (void *)(long)0;
	tcdsdev.tcdsda_sc = &sc->sc_slots[0];
	tcdsdev.tcdsda_id = 7;				/* XXX */
	tcdsdev.tcdsda_freq = 25000000;			/* XXX */

	tcds_scsi_reset(tcdsdev.tcdsda_sc);

	config_found(self, &tcdsdev, tcdsprint);

	/* the second SCSI chip isn't present on the 3000/300 series. */
	if (cputype != ST_DEC_3000_300) {
		strncpy(tcdsdev.tcdsda_modname, "PMAZ-AA ",
		    TC_ROM_LLEN);
		tcdsdev.tcdsda_slot = 1;
		tcdsdev.tcdsda_offset = 0;
		tcdsdev.tcdsda_addr = (tc_addr_t)
		    TC_DENSE_TO_SPARSE(sc->sc_base + TCDS_SCSI1_OFFSET);
		tcdsdev.tcdsda_cookie = (void *)(long)1;
		tcdsdev.tcdsda_sc = &sc->sc_slots[1];
		tcdsdev.tcdsda_id = 7;			/* XXX */
		tcdsdev.tcdsda_freq = 25000000;		/* XXX */

		tcds_scsi_reset(tcdsdev.tcdsda_sc);

		config_found(self, &tcdsdev, tcdsprint);
	}
}

int
tcdsprint(aux, pnp)
	void *aux;
	const char *pnp;
{
	struct tc_attach_args *ta = aux;

	if (pnp)
		printf("%s at %s", ta->ta_modname, pnp);
	printf(" slot %d", ta->ta_slot);
	return (UNCONF);
}

void
tcds_intr_establish(tcds, cookie, level, func, arg)
	struct device *tcds;
	void *cookie, *arg;
	tc_intrlevel_t level;
	int (*func)(void *);
{
	struct tcds_softc *sc = (struct tcds_softc *)tcds;
	u_long slot;

	slot = (u_long)cookie;
#ifdef DIAGNOSTIC
	/* XXX check cookie. */
#endif

	if (sc->sc_slots[slot].sc_intrhand != tcds_intrnull)
		panic("tcds_intr_establish: cookie %d twice", slot);

	sc->sc_slots[slot].sc_intrhand = func;
	sc->sc_slots[slot].sc_intrarg = arg;
	tcds_scsi_reset(&sc->sc_slots[slot]);
}

void
tcds_intr_disestablish(tcds, cookie)
	struct device *tcds;
	void *cookie;
{
	struct tcds_softc *sc = (struct tcds_softc *)tcds;
	u_long slot;

	slot = (u_long)cookie;
#ifdef DIAGNOSTIC
	/* XXX check cookie. */
#endif

	if (sc->sc_slots[slot].sc_intrhand == tcds_intrnull)
		panic("tcds_intr_disestablish: cookie %d missing intr",
		    slot);

	sc->sc_slots[slot].sc_intrhand = tcds_intrnull;
	sc->sc_slots[slot].sc_intrarg = (void *)slot;

	tcds_dma_enable(&sc->sc_slots[slot], 0);
	tcds_scsi_enable(&sc->sc_slots[slot], 0);
}

int
tcds_intrnull(val)
	void *val;
{

	panic("tcds_intrnull: uncaught TCDS intr for cookie %ld",
	    (u_long)val);
}

void
tcds_scsi_reset(sc)
	struct tcds_slotconfig *sc;
{

	tcds_dma_enable(sc, 0);
	tcds_scsi_enable(sc, 0);

	TCDS_CIR_CLR(*sc->sc_tcds->sc_cir, sc->sc_resetbits);
	alpha_mb();
	DELAY(1);
	TCDS_CIR_SET(*sc->sc_tcds->sc_cir, sc->sc_resetbits);
	alpha_mb();

	tcds_scsi_enable(sc, 1);
	tcds_dma_enable(sc, 1);
}

void
tcds_scsi_enable(sc, on)
	struct tcds_slotconfig *sc;
	int on;
{

	if (on) 
		*sc->sc_tcds->sc_imer |= sc->sc_intrmaskbits;
	else
		*sc->sc_tcds->sc_imer &= ~sc->sc_intrmaskbits;
	alpha_mb();
}

void
tcds_dma_enable(sc, on)
	struct tcds_slotconfig *sc;
	int on;
{

	/* XXX Clear/set IOSLOT/PBS bits. */
	if (on) 
		TCDS_CIR_SET(*sc->sc_tcds->sc_cir, sc->sc_dmabits);
	else
		TCDS_CIR_CLR(*sc->sc_tcds->sc_cir, sc->sc_dmabits);
	alpha_mb();
}

int
tcds_scsi_isintr(sc, clear)
	struct tcds_slotconfig *sc;
	int clear;
{

	if ((*sc->sc_tcds->sc_cir & sc->sc_intrbits) != 0) {
		if (clear) {
			TCDS_CIR_CLR(*sc->sc_tcds->sc_cir, sc->sc_intrbits);
			alpha_mb();
		}
		return (1);
	} else
		return (0);
}

int
tcds_scsi_iserr(sc)
	struct tcds_slotconfig *sc;
{

	return ((*sc->sc_tcds->sc_cir & sc->sc_errorbits) != 0);
}

int
tcds_intr(val)
	void *val;
{
	struct tcds_softc *sc;
	u_int32_t ir;

	sc = val;

	/*
	 * XXX
	 * Copy and clear (gag!) the interrupts.
	 */
	ir = *sc->sc_cir;
	alpha_mb();
	TCDS_CIR_CLR(*sc->sc_cir, TCDS_CIR_ALLINTR);
	alpha_mb();
	tc_syncbus();
	alpha_mb();

#ifdef EVCNT_COUNTERS
	/* No interrupt counting via evcnt counters */ 
	XXX BREAK HERE XXX
#else
#define	INCRINTRCNT(slot)	intrcnt[INTRCNT_TCDS + slot]++
#endif

#define	CHECKINTR(slot)							\
	if (ir & sc->sc_slots[slot].sc_intrbits) {			\
		INCRINTRCNT(slot);					\
		(void)(*sc->sc_slots[slot].sc_intrhand)			\
		    (sc->sc_slots[slot].sc_intrarg);			\
	}
	CHECKINTR(0);
	CHECKINTR(1);
#undef CHECKINTR

#ifdef DIAGNOSTIC
	/* 
	 * Interrupts not currently handled, but would like to know if they
	 * occur.
	 *
	 * XXX
	 * Don't know if we have to set the interrupt mask and enable bits
	 * in the IMER to allow some of them to happen?
	 */
#define	PRINTINTR(msg, bits)						\
	if (ir & bits)							\
		printf(msg);
	PRINTINTR("SCSI0 DREQ interrupt.\n", TCDS_CIR_SCSI0_DREQ);
	PRINTINTR("SCSI1 DREQ interrupt.\n", TCDS_CIR_SCSI1_DREQ);
	PRINTINTR("SCSI0 prefetch interrupt.\n", TCDS_CIR_SCSI0_PREFETCH);
	PRINTINTR("SCSI1 prefetch interrupt.\n", TCDS_CIR_SCSI1_PREFETCH);
	PRINTINTR("SCSI0 DMA error.\n", TCDS_CIR_SCSI0_DMA);
	PRINTINTR("SCSI1 DMA error.\n", TCDS_CIR_SCSI1_DMA);
	PRINTINTR("SCSI0 DB parity error.\n", TCDS_CIR_SCSI0_DB);
	PRINTINTR("SCSI1 DB parity error.\n", TCDS_CIR_SCSI1_DB);
	PRINTINTR("SCSI0 DMA buffer parity error.\n", TCDS_CIR_SCSI0_DMAB_PAR);
	PRINTINTR("SCSI1 DMA buffer parity error.\n", TCDS_CIR_SCSI1_DMAB_PAR);
	PRINTINTR("SCSI0 DMA read parity error.\n", TCDS_CIR_SCSI0_DMAR_PAR);
	PRINTINTR("SCSI1 DMA read parity error.\n", TCDS_CIR_SCSI1_DMAR_PAR);
	PRINTINTR("TC write parity error.\n", TCDS_CIR_TCIOW_PAR);
	PRINTINTR("TC I/O address parity error.\n", TCDS_CIR_TCIOA_PAR);
#undef PRINTINTR
#endif

	/*
	 * XXX
	 * The MACH source had this, with the comment:
	 *	This is wrong, but machine keeps dying.
	 */
	DELAY(1);

	return (1);
}
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: tcds.c,v 1.8 1999/01/11 05:11:05 millert Exp $	*/
@


1.8
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: tcds.c,v 1.7 1997/01/24 19:58:22 niklas Exp $	*/
d60 1
a60 1
int	tcdsmatch __P((struct device *, void *, void *));
d62 1
a62 1
int	tcdsmatch __P((struct device *, struct cfdata *, void *));
d64 2
a65 2
void	tcdsattach __P((struct device *, struct device *, void *));
int     tcdsprint __P((void *, const char *));
d75 2
a76 2
/*static*/ int	tcds_intr __P((void *));
/*static*/ int	tcds_intrnull __P((void *));
d230 1
a230 1
	int (*func) __P((void *));
@


1.8.16.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tcds.c,v 1.8 1999/01/11 05:11:05 millert Exp $	*/
@


1.8.6.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 1
a60 1
int	tcdsmatch(struct device *, void *, void *);
d62 1
a62 1
int	tcdsmatch(struct device *, struct cfdata *, void *);
d64 2
a65 2
void	tcdsattach(struct device *, struct device *, void *);
int     tcdsprint(void *, const char *);
d75 2
a76 2
/*static*/ int	tcds_intr(void *);
/*static*/ int	tcds_intrnull(void *);
d230 1
a230 1
	int (*func)(void *);
@


1.8.6.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: tcds.c,v 1.8.6.1 2002/03/28 10:06:14 niklas Exp $	*/
@


1.7
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: tcds.c,v 1.6 1996/11/23 21:45:02 kstailey Exp $	*/
d277 1
a277 1
	panic("tcds_intrnull: uncaught TCDS intr for cookie %ld\n",
@


1.6
log
@added const to second parameter of cfprint_t routines
@
text
@d1 2
a2 2
/*	$OpenBSD: tcds.c,v 1.5 1996/10/30 22:41:27 niklas Exp $	*/
/*	$NetBSD: tcds.c,v 1.15 1996/10/13 03:00:41 christos Exp $	*/
d59 1
d61 3
d81 1
d83 3
@


1.5
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcds.c,v 1.15 1996/10/13 03:00:41 christos Exp $	*/
d61 1
a61 1
int     tcdsprint __P((void *, /* const */ char *));
d207 1
a207 1
	/* const */ char *pnp;
@


1.4
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: tcds.c,v 1.9.4.2 1996/06/05 01:32:26 cgd Exp $	*/
/*	$NetBSD: tcds.c,v 1.9.4.2 1996/06/05 01:32:26 cgd Exp $	*/
d61 1
a61 1
int     tcdsprint(void *, char *);
d123 1
a123 1
	wbflush();
d207 1
a207 1
	char *pnp;
d282 1
a282 1
	wbflush();
d285 1
a285 1
	wbflush();
d301 1
a301 1
	wbflush();
d315 1
a315 1
	wbflush();
d327 1
a327 1
			wbflush();
d356 1
a356 1
	wbflush();
d358 1
a358 1
	wbflush();
d360 1
a360 1
	wbflush();
d414 2
@


1.3
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.2
log
@from netbsd:
machine-independent TurboChannel bus configuration.  These files
deal with stuff like:
        (1) configuring built-in devices,
        (2) looking at TC slots configuring any devices found.
The lists of slots, slot locations, etc. and built-in devices
are provided by machine-dependent code.  Interrupt handling
is also provided by machine-dependent code, but the MD code provides
hooks so that standard names for 'establish' and 'disestablish'
can be used in drivers.

This code requires <machine/tc_machdep.h>, which defines some
portability types specific to the TurboChannel bus code.
@
text
@d1 1
a1 1
/*	$NetBSD: tcds.c,v 1.6 1995/12/20 00:40:29 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1994, 1995 Carnegie-Mellon University.
d37 3
d61 8
a68 2
struct cfdriver tcdscd =
    { NULL, "tcds", tcdsmatch, tcdsattach, DV_DULL, sizeof(struct tcds_softc) };
d79 1
a79 1
	struct tcdev_attach_args *tcdev = aux;
d83 1
a83 1
	if (strncmp("PMAZ-DS ", tcdev->tcda_modname, TC_ROM_LLEN))
d100 1
a100 1
	struct tcdev_attach_args *tcdev = aux;
d108 2
a109 2
	sc->sc_base = tcdev->tcda_addr;
	sc->sc_cookie = tcdev->tcda_cookie;
d208 1
a208 1
	struct tcdev_attach_args *tcdev = aux;
d211 2
a212 2
		printf("%s at %s", tcdev->tcda_modname, pnp);
	printf(" slot 0x%lx", tcdev->tcda_slot);
d361 7
d370 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: tcds.c,v 1.5 1995/08/03 00:52:39 cgd Exp $	*/
a34 1
#include <machine/autoconf.h>
d38 4
a41 3
#include <alpha/tc/tc.h>
#include <alpha/tc/tcds_dmavar.h>
#include <alpha/tc/tcds.h>
d45 7
a51 2
	struct	abus sc_bus;
	caddr_t	sc_base;
d61 2
a62 21
void    tcds_intr_establish __P((struct confargs *, int (*)(void *), void *));
void    tcds_intr_disestablish __P((struct confargs *));
caddr_t tcds_cvtaddr __P((struct confargs *));
int     tcds_matchname __P((struct confargs *, char *));

int	tcds_intr __P((void *));
int	tcds_intrnull __P((void *));

#define	TCDS_SLOT_SCSI0	0
#define	TCDS_SLOT_SCSI1	1

struct tcds_slot {
	struct confargs	ts_ca;
	intr_handler_t	ts_handler;
	void		*ts_val;
} tcds_slots[] = {
	{ { "esp",	0, 0x0, },
	    tcds_intrnull, (void *)(long)TCDS_SLOT_SCSI0, },
	{ { "esp",	1, 0x0, },
	    tcds_intrnull, (void *)(long)TCDS_SLOT_SCSI1, },
};
d65 1
a65 1
tcdsmatch(parent, vcf, aux)
d67 2
a68 1
	void *vcf, *aux;
d70 2
a71 2
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
d73 2
a74 2
	/* It can only occur on the turbochannel, anyway. */
	if (ca->ca_bus->ab_type != BUS_TC)
d76 1
d78 3
a80 3
	/* Make sure that we're looking for this type of device. */
	if (!BUS_MATCHNAME(ca, "PMAZ-DS "))
		return (0);
d91 3
a93 3
	struct confargs *ca = aux;
	struct confargs *nca;
	volatile u_int32_t *cir, *imer;
d99 2
a100 1
	sc->sc_base = BUS_CVTADDR(ca);
d102 2
a103 6
	sc->sc_bus.ab_dv = (struct device *)sc;
	sc->sc_bus.ab_type = BUS_TCDS;
	sc->sc_bus.ab_intr_establish = tcds_intr_establish;
	sc->sc_bus.ab_intr_disestablish = tcds_intr_disestablish;
	sc->sc_bus.ab_cvtaddr = tcds_cvtaddr;
	sc->sc_bus.ab_matchname = tcds_matchname;
d105 1
a105 1
	BUS_INTR_ESTABLISH(ca, tcds_intr, sc);
d112 1
a112 2
	imer = TCDS_REG(sc->sc_base, TCDS_IMER);
	*imer = 0;
d115 45
d161 13
a173 3
	nca = &tcds_slots[TCDS_SLOT_SCSI0].ts_ca;
	nca->ca_bus = &sc->sc_bus;
	config_found(self, nca, tcdsprint);
d177 14
a190 3
		nca = &tcds_slots[TCDS_SLOT_SCSI1].ts_ca;
		nca->ca_bus = &sc->sc_bus;
		config_found(self, nca, tcdsprint);
d199 1
a199 1
	struct confargs *ca = aux;
d202 2
a203 2
		printf("%s at %s", ca->ca_name, pnp);
	printf(" slot 0x%lx", ca->ca_slot);
d208 20
a227 25
tcds_intr_establish(ca, handler, val)
	struct confargs *ca;
	int (*handler) __P((void *));
	void *val;
{
	if (tcds_slots[ca->ca_slot].ts_handler != tcds_intrnull)
		panic("tcds_intr_establish: slot %d twice", ca->ca_slot);

	tcds_slots[ca->ca_slot].ts_handler = handler;
	tcds_slots[ca->ca_slot].ts_val = val;

	switch (ca->ca_slot) {
	case TCDS_SLOT_SCSI0:
		tcds_scsi_reset(0);
		break;

	case TCDS_SLOT_SCSI1:
		tcds_scsi_reset(1);
		break;

	default:
		panic("tcds_intr_establish: unknown slot number %d",
		    ca->ca_slot);
		/* NOTREACHED */
	}
d231 15
a245 27
tcds_intr_disestablish(ca)
	struct confargs *ca;
{
	if (tcds_slots[ca->ca_slot].ts_handler == tcds_intrnull)
		panic("tcds_intr_disestablish: slot %d missing intr",
		    ca->ca_slot);

	tcds_slots[ca->ca_slot].ts_handler = tcds_intrnull;
	tcds_slots[ca->ca_slot].ts_val = (void *)(long)ca->ca_slot;

	switch (ca->ca_slot) {
	case TCDS_SLOT_SCSI0:
		tcds_dma_disable(0);
		tcds_scsi_disable(0);
		break;

	case TCDS_SLOT_SCSI1:
		tcds_dma_disable(1);
		tcds_scsi_disable(1);
		break;

	default:
		panic("tcds_intr_disestablish: unknown slot number %d",
		    ca->ca_slot);
		/* NOTREACHED */
	}
}
d247 2
a248 4
caddr_t
tcds_cvtaddr(ca)
	struct confargs *ca;
{
d250 2
a251 11
	return
	    (((struct tcds_softc *)ca->ca_bus->ab_dv)->sc_base + ca->ca_offset);
}

int
tcds_matchname(ca, name)
	struct confargs *ca;
	char *name;
{

	return (strcmp(name, ca->ca_name) == 0);
d259 2
a260 1
	panic("uncaught TCDS ASIC intr for slot %ld\n", (long)val);
d264 2
a265 2
tcds_scsi_reset(unit)
	int unit;
a266 2
	struct tcds_softc *sc = tcdscd.cd_devs[0];
	volatile u_int32_t *cir;
d268 2
a269 2
	tcds_dma_disable(unit);
	tcds_scsi_disable(unit);
d271 5
a275 23
	/* XXX: Clear/set IOSLOT/PBS bits. */
	cir = TCDS_REG(sc->sc_base, TCDS_CIR);
	switch (unit) {
	case 0:
		TCDS_CIR_CLR(*cir, TCDS_CIR_SCSI0_RESET);
		wbflush();
		DELAY(1);			/* XXX */
		TCDS_CIR_SET(*cir, TCDS_CIR_SCSI0_RESET);
		wbflush();
		break;

	case 1:
		TCDS_CIR_CLR(*cir, TCDS_CIR_SCSI1_RESET);
		wbflush();
		DELAY(1);			/* XXX */
		TCDS_CIR_SET(*cir, TCDS_CIR_SCSI1_RESET);
		wbflush();
		break;

	default:
		panic("tcds_scsi_disable: unknown unit number\n", unit);
		/* NOTREACHED */
	}
d277 2
a278 2
	tcds_scsi_enable(unit);
	tcds_dma_enable(unit);
d282 3
a284 2
tcds_scsi_enable(unit)
	int unit;
a285 2
	struct tcds_softc *sc = tcdscd.cd_devs[0];
	volatile u_int32_t *imer;
d287 5
a291 23
	imer = TCDS_REG(sc->sc_base, TCDS_IMER);

	/*
	 * XXX
	 * Should we be setting all the "interrupt bits" in the IMER?
	 * Do we need to set a bit in the mask so that SCSI DMA errors
	 * cause interrupts?
	 */
	switch (unit) {
	case 0:
		*imer |= TCDS_IMER_SCSI0_MASK | TCDS_IMER_SCSI0_ENB;
		wbflush();
		break;

	case 1:
		*imer |= TCDS_IMER_SCSI1_MASK | TCDS_IMER_SCSI1_ENB;
		wbflush();
		break;

	default:
		panic("tcds_scsi_enable: unknown unit number\n", unit);
		/* NOTREACHED */
	}
d295 3
a297 2
tcds_scsi_disable(unit)
	int unit;
a298 58
	struct tcds_softc *sc = tcdscd.cd_devs[0];
	volatile u_int32_t *imer;

	imer = TCDS_REG(sc->sc_base, TCDS_IMER);

	switch (unit) {
	case 0:
		*imer &= ~(TCDS_IMER_SCSI0_MASK | TCDS_IMER_SCSI0_ENB);
		wbflush();
		break;

	case 1:
		*imer &= ~(TCDS_IMER_SCSI1_MASK | TCDS_IMER_SCSI1_ENB);
		wbflush();
		break;

	default:
		panic("tcds_scsi_disable: unknown unit number\n", unit);
		/* NOTREACHED */
	}
}

void
tcds_dma_init(dsc, unit)
	struct dma_softc *dsc;
	int unit;
{
	struct tcds_softc *sc = tcdscd.cd_devs[0];

	switch (unit) {
	case 0:
		dsc->sda = TCDS_REG(sc->sc_base, TCDS_SCSI0_DMA_ADDR);
		dsc->dic = TCDS_REG(sc->sc_base, TCDS_SCSI0_DMA_INTR);
		dsc->dud0 = TCDS_REG(sc->sc_base, TCDS_SCSI0_DMA_DUD0);
		dsc->dud1 = TCDS_REG(sc->sc_base, TCDS_SCSI0_DMA_DUD1);
		break;

	case 1:
		dsc->sda = TCDS_REG(sc->sc_base, TCDS_SCSI1_DMA_ADDR);
		dsc->dic = TCDS_REG(sc->sc_base, TCDS_SCSI1_DMA_INTR);
		dsc->dud0 = TCDS_REG(sc->sc_base, TCDS_SCSI1_DMA_DUD0);
		dsc->dud1 = TCDS_REG(sc->sc_base, TCDS_SCSI1_DMA_DUD1);
		break;

	default:
		panic("tcds_dma_init: unknown unit number\n", unit);
		/* NOTREACHED */
	}
}

void
tcds_dma_enable(unit)
	int unit;
{
	struct tcds_softc *sc = tcdscd.cd_devs[0];
	volatile u_int32_t *cir;

	cir = TCDS_REG(sc->sc_base, TCDS_CIR);
d301 5
a305 42
	switch (unit) {
	case 0:
		TCDS_CIR_SET(*cir, TCDS_CIR_SCSI0_DMAENA);
		wbflush();
		break;

	case 1:
		TCDS_CIR_SET(*cir, TCDS_CIR_SCSI1_DMAENA);
		wbflush();
		break;

	default:
		panic("tcds_dma_enable: unknown unit number\n", unit);
		/* NOTREACHED */
	}
}

void
tcds_dma_disable(unit)
	int unit;
{
	struct tcds_softc *sc = tcdscd.cd_devs[0];
	volatile u_int32_t *cir;

	cir = TCDS_REG(sc->sc_base, TCDS_CIR);

	/* XXX Clear/set IOSLOT/PBS bits. */
	switch (unit) {
	case 0:
		TCDS_CIR_CLR(*cir, TCDS_CIR_SCSI0_DMAENA);
		wbflush();
		break;

	case 1:
		TCDS_CIR_CLR(*cir, TCDS_CIR_SCSI1_DMAENA);
		wbflush();
		break;

	default:
		panic("tcds_dma_disable: unknown unit number\n", unit);
		/* NOTREACHED */
	}
d309 3
a311 2
tcds_scsi_isintr(unit, clear)
	int unit, clear;
a312 2
	struct tcds_softc *sc = tcdscd.cd_devs[0];
	volatile u_int32_t *cir, ir;
d314 4
a317 12
	cir = TCDS_REG(sc->sc_base, TCDS_CIR);
	ir = *cir;
	wbflush();

	switch (unit) {
	case 0:
		if (ir & TCDS_CIR_SCSI0_INT) {
			if (clear) {
				TCDS_CIR_CLR(*cir, TCDS_CIR_SCSI0_INT);
				wbflush();
			}
			return (1);
d319 3
a321 17
		break;

	case 1:
		if (ir & TCDS_CIR_SCSI1_INT) {
			if (clear) {
				TCDS_CIR_CLR(*cir, TCDS_CIR_SCSI1_INT);
				wbflush();
			}
			return (1);
		}
		break;

	default:
		panic("tcds_scsi_isintr: unknown unit number\n", unit);
		/* NOTREACHED */
	}
	return (0);
d325 2
a326 2
tcds_scsi_iserr(dsc)
	struct dma_softc *dsc;
a327 6
	struct tcds_softc *sc = tcdscd.cd_devs[0];
	volatile u_int32_t *cir, ir;

	cir = TCDS_REG(sc->sc_base, TCDS_CIR);
	ir = *cir;
	wbflush();
d329 1
a329 5
	if (ir & SCSI_CIR_ERROR) {
		printf("%s: error <CIR = %x>\n", dsc->sc_dev.dv_xname, ir);
		return (1);
	}
	return (0);
a331 4
/*
 * tcds_intr --
 *	TCDS ASIC interrupt handler.
 */
a336 1
	volatile u_int32_t *cir;
d345 1
a345 2
	cir = TCDS_REG(sc->sc_base, TCDS_CIR);
	ir = *cir;
d347 1
a347 1
	TCDS_CIR_CLR(*cir, TCDS_CIR_ALLINTR);
d349 1
a349 1
	MAGIC_READ;
d352 4
a355 4
#define	CHECKINTR(slot, bits)						\
	if (ir & bits) {						\
		(void)(*tcds_slots[slot].ts_handler)			\
		    (tcds_slots[slot].ts_val);				\
d357 2
a358 2
	CHECKINTR(TCDS_SLOT_SCSI0, TCDS_CIR_SCSI0_INT);
	CHECKINTR(TCDS_SLOT_SCSI1, TCDS_CIR_SCSI1_INT);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
