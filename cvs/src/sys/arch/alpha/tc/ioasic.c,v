head	1.17;
access;
symbols
	OPENBSD_6_2:1.17.0.26
	OPENBSD_6_2_BASE:1.17
	OPENBSD_6_1:1.17.0.28
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.24
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.20
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.22
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.14
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.18
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.16
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.12
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.10
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.8
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.6
	OPENBSD_5_0:1.17.0.4
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.6
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.6
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.11.0.8
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.6
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.9
	UBC:1.7.0.16
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.14
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.12
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.10
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.8
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.6
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.8
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.17
date	2010.09.20.06.33.46;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.07.23.01.38;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2008.08.09.16.42.29;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2008.06.26.05.42.09;	author ray;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.06.18.20.05;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.04.12.33.17;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.28.02.28.43;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.13.21.32.17;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.02.22.56.06;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.28;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.01.11.05.11.04;	author millert;	state Exp;
branches
	1.7.6.1
	1.7.16.1;
next	1.6;

1.6
date	97.01.24.19.58.13;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.11.23.21.45.00;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.10.30.22.41.08;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.07.29.23.02.06;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.18.09.45.14;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.26.18.12.01;	author deraadt;	state Exp;
branches;
next	;

1.7.6.1
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	1.7.6.2;

1.7.6.2
date	2003.03.27.23.18.06;	author niklas;	state Exp;
branches;
next	1.7.6.3;

1.7.6.3
date	2003.05.16.00.29.38;	author niklas;	state Exp;
branches;
next	;

1.7.16.1
date	2002.06.11.03.33.41;	author art;	state Exp;
branches;
next	1.7.16.2;

1.7.16.2
date	2003.05.19.21.38.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@/* $OpenBSD: ioasic.c,v 1.16 2009/11/07 23:01:38 miod Exp $ */
/* $NetBSD: ioasic.c,v 1.34 2000/07/18 06:10:06 thorpej Exp $ */

/*-
 * Copyright (c) 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1994, 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Keith Bostic, Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/timeout.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/pte.h>
#include <machine/rpb.h>

#include <dev/tc/tcvar.h>
#include <dev/tc/ioasicreg.h>
#include <dev/tc/ioasicvar.h>
#ifdef DEC_3000_300
#include <alpha/tc/tc_3000_300.h>
#endif

/* Definition of the driver for autoconfig. */
int	ioasicmatch(struct device *, void *, void *);
void	ioasicattach(struct device *, struct device *, void *);

struct cfattach ioasic_ca = {
	sizeof(struct ioasic_softc), ioasicmatch, ioasicattach,
};

struct cfdriver ioasic_cd = {
	NULL, "ioasic", DV_DULL,
};

int	ioasic_intr(void *);
int	ioasic_intrnull(void *);

#define	C(x)	((void *)(u_long)(x))
#define	KV(x)	(ALPHA_PHYS_TO_K0SEG(x))

#define	IOASIC_DEV_LANCE	0
#define	IOASIC_DEV_SCC0		1
#define	IOASIC_DEV_SCC1		2
#define	IOASIC_DEV_ISDN		3

#define	IOASIC_DEV_BOGUS	-1

#define	IOASIC_NCOOKIES		4

struct ioasic_dev ioasic_devs[] = {
	{ "PMAD-BA ", IOASIC_SLOT_3_START, C(IOASIC_DEV_LANCE),
	  IOASIC_INTR_LANCE, },
	{ "z8530   ", IOASIC_SLOT_4_START, C(IOASIC_DEV_SCC0),
	  IOASIC_INTR_SCC_0, },
	{ "z8530   ", IOASIC_SLOT_6_START, C(IOASIC_DEV_SCC1),
	  IOASIC_INTR_SCC_1, },
	{ "TOY_RTC ", IOASIC_SLOT_8_START, C(IOASIC_DEV_BOGUS),
	  0, },
	{ "AMD79c30", IOASIC_SLOT_9_START, C(IOASIC_DEV_ISDN),
	  IOASIC_INTR_ISDN_TXLOAD | IOASIC_INTR_ISDN_RXLOAD,  },
};
int ioasic_ndevs = sizeof(ioasic_devs) / sizeof(ioasic_devs[0]);

struct ioasicintr {
	int	(*iai_func)(void *);
	void	*iai_arg;
	struct evcount iai_count;
} ioasicintrs[IOASIC_NCOOKIES];

tc_addr_t ioasic_base;		/* XXX XXX XXX */

/* There can be only one. */
int ioasicfound;

int
ioasicmatch(parent, cfdata, aux)
	struct device *parent;
	void *cfdata, *aux;
{
	struct tc_attach_args *ta = aux;

	/* Make sure that we're looking for this type of device. */
	if (strncmp("FLAMG-IO", ta->ta_modname, TC_ROM_LLEN))
		return (0);

	/* Check that it can actually exist. */
	if ((cputype != ST_DEC_3000_500) && (cputype != ST_DEC_3000_300))
		panic("ioasicmatch: how did we get here?");

	if (ioasicfound)
		return (0);

	return (1);
}

void
ioasicattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct ioasic_softc *sc = (struct ioasic_softc *)self;
	struct tc_attach_args *ta = aux;
#ifdef DEC_3000_300
	u_long ssr;
#endif
	u_long i, imsk;

	ioasicfound = 1;

	sc->sc_bst = ta->ta_memt; 
	if (bus_space_map(ta->ta_memt, ta->ta_addr,
			0x400000, 0, &sc->sc_bsh)) {
		printf("%s: unable to map device\n", sc->sc_dv.dv_xname);
		return;
	}
	sc->sc_dmat = ta->ta_dmat;

	ioasic_base = sc->sc_base = ta->ta_addr; /* XXX XXX XXX */

#ifdef DEC_3000_300
	if (cputype == ST_DEC_3000_300) {
		ssr = bus_space_read_4(sc->sc_bst, sc->sc_bsh, IOASIC_CSR);
		ssr |= IOASIC_CSR_FASTMODE;
		bus_space_write_4(sc->sc_bst, sc->sc_bsh, IOASIC_CSR, ssr);
		printf(": slow mode\n");
	} else
#endif
		printf(": fast mode\n");

	/*
	 * Turn off all device interrupt bits.
	 * (This does _not_ include 3000/300 TC option slot bits).
	 */
	imsk = bus_space_read_4(sc->sc_bst, sc->sc_bsh, IOASIC_IMSK);
	for (i = 0; i < ioasic_ndevs; i++)
		imsk &= ~ioasic_devs[i].iad_intrbits;
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, IOASIC_IMSK, imsk);

	/*
	 * Set up interrupt handlers.
	 */
	for (i = 0; i < IOASIC_NCOOKIES; i++) {
		ioasicintrs[i].iai_func = ioasic_intrnull;
		ioasicintrs[i].iai_arg = (void *)i;
	}
	tc_intr_establish(parent, ta->ta_cookie, IPL_NONE, ioasic_intr, sc,
	    NULL);

	/*
	 * Try to configure each device.
	 */
	ioasic_attach_devs(sc, ioasic_devs, ioasic_ndevs);
}

void
ioasic_intr_establish(ioa, cookie, level, func, arg, name)
	struct device *ioa;
	void *cookie, *arg;
	int level;
	int (*func)(void *);
	const char *name;
{
	struct ioasic_softc *sc = (void *)ioasic_cd.cd_devs[0];
	u_long dev, i, imsk;

	dev = (u_long)cookie;
#ifdef DIAGNOSTIC
	/* XXX check cookie. */
#endif

	if (ioasicintrs[dev].iai_func != ioasic_intrnull)
		panic("ioasic_intr_establish: cookie %lu twice", dev);

	ioasicintrs[dev].iai_func = func;
	ioasicintrs[dev].iai_arg = arg;
	evcount_attach(&ioasicintrs[dev].iai_count, name, NULL);

	/* Enable interrupts for the device. */
	for (i = 0; i < ioasic_ndevs; i++)
		if (ioasic_devs[i].iad_cookie == cookie)
			break;
	if (i == ioasic_ndevs)
		panic("ioasic_intr_establish: invalid cookie.");

	imsk = bus_space_read_4(sc->sc_bst, sc->sc_bsh, IOASIC_IMSK);
        imsk |= ioasic_devs[i].iad_intrbits;
        bus_space_write_4(sc->sc_bst, sc->sc_bsh, IOASIC_IMSK, imsk);
}

void
ioasic_intr_disestablish(ioa, cookie)
	struct device *ioa;
	void *cookie;
{
	struct ioasic_softc *sc = (void *)ioasic_cd.cd_devs[0];
	u_long dev, i, imsk;

	dev = (u_long)cookie;
#ifdef DIAGNOSTIC
	/* XXX check cookie. */
#endif

	if (ioasicintrs[dev].iai_func == ioasic_intrnull)
		panic("ioasic_intr_disestablish: cookie %lu missing intr", dev);

	/* Enable interrupts for the device. */
	for (i = 0; i < ioasic_ndevs; i++)
		if (ioasic_devs[i].iad_cookie == cookie)
			break;
	if (i == ioasic_ndevs)
		panic("ioasic_intr_disestablish: invalid cookie.");

	imsk = bus_space_read_4(sc->sc_bst, sc->sc_bsh, IOASIC_IMSK);
	imsk &= ~ioasic_devs[i].iad_intrbits;
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, IOASIC_IMSK, imsk);

	ioasicintrs[dev].iai_func = ioasic_intrnull;
	ioasicintrs[dev].iai_arg = (void *)dev;
	evcount_detach(&ioasicintrs[dev].iai_count);
}

int
ioasic_intrnull(val)
	void *val;
{

	panic("ioasic_intrnull: uncaught IOASIC intr for cookie %ld",
	    (u_long)val);
}

/*
 * ASIC interrupt handler.
 */
int
ioasic_intr(val)
	void *val;
{
	register struct ioasic_softc *sc = val;
	register int ifound;
	int gifound;
	u_int32_t sir, osir;

	gifound = 0;
	do {
		ifound = 0;
		tc_syncbus();

		osir = sir =
		    bus_space_read_4(sc->sc_bst, sc->sc_bsh, IOASIC_INTR);

		/* XXX DUPLICATION OF INTERRUPT BIT INFORMATION... */
#define	CHECKINTR(slot, bits, clear)					\
		if (sir & (bits)) {					\
			ifound = 1;					\
			ioasicintrs[slot].iai_count.ec_count++;		\
			(*ioasicintrs[slot].iai_func)			\
			    (ioasicintrs[slot].iai_arg);		\
			if (clear)					\
				sir &= ~(bits);				\
		}
		CHECKINTR(IOASIC_DEV_SCC0, IOASIC_INTR_SCC_0, 0);
		CHECKINTR(IOASIC_DEV_SCC1, IOASIC_INTR_SCC_1, 0);
		CHECKINTR(IOASIC_DEV_LANCE, IOASIC_INTR_LANCE, 0);
		CHECKINTR(IOASIC_DEV_ISDN, IOASIC_INTR_ISDN_TXLOAD |
		    IOASIC_INTR_ISDN_RXLOAD | IOASIC_INTR_ISDN_OVRUN, 1);

		if (sir != osir)
			bus_space_write_4(sc->sc_bst, sc->sc_bsh,
			    IOASIC_INTR, sir);

		gifound |= ifound;
	} while (ifound);

	return (gifound);
}

/*
 * Blink leds
 */

struct {
	int		patpos;
	struct timeout	tmo;
} led_blink_state;

static const uint8_t led_pattern8[] = {
	0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
	0x40, 0x20, 0x10, 0x08, 0x04, 0x02
};

void
ioasic_led_blink(void *unused)
{
	extern int alpha_led_blink;
	vaddr_t rw_csr;
	u_int32_t pattern;
	int display_loadavg;

	if (alpha_led_blink == 0) {
		pattern = 0;	/* all clear */
		led_blink_state.patpos = 0;
	} else {
#ifdef DEC_3000_300
		if (cputype == ST_DEC_3000_300)
			display_loadavg = 0;
		else
#endif
		switch (hwrpb->rpb_variation & SV_ST_MASK) {
		case SV_ST_FLAMINGO:
		case SV_ST_HOTPINK:
		case SV_ST_FLAMINGOPLUS:
		case SV_ST_ULTRA:
		case SV_ST_FLAMINGO45:
			/* 500/800/900, 2 7-segment display, display loadavg */
			display_loadavg = 1;
			break;
		case SV_ST_SANDPIPER:
		case SV_ST_SANDPLUS:
		case SV_ST_SANDPIPER45:
		default:
			/* 400/600/700, 8 leds, display moving pattern */
			display_loadavg = 0;
			break;
		}

		if (display_loadavg)
			pattern = averunnable.ldavg[0] >> FSHIFT;
		else {
			pattern = led_pattern8[led_blink_state.patpos];
			led_blink_state.patpos = 
			    (led_blink_state.patpos + 1) % sizeof(led_pattern8);
		}
	}

	/*
	 * The low 8 bits, controlling the leds, are read-only in the
	 * CSR register, but read-write in its image at CSR + 4.
	 *
	 * On model 300, however, the internal 8 leds are at a different
	 * address, but the (better visible) power supply led is actually
	 * bit 5 in CSR (active low).
	 */
#ifdef DEC_3000_300
	if (cputype == ST_DEC_3000_300) {
		rw_csr = KV(0x1a0000000 + IOASIC_CSR + 4);

		*(volatile uint32_t *)TC_3000_300_LED =
		    (*(volatile uint32_t *)TC_3000_300_LED & ~(0xff << 16)) |
		     (pattern << 16);
		/*
		 * Blink the power supply led 8x slower.  This relies
		 * on led_pattern8[] being a < 16 element array.
		 */
		*(volatile uint32_t *)rw_csr =
		    (*(volatile uint32_t *)rw_csr & ~(1 << 5)) ^
		    ((led_blink_state.patpos >> 3) << 5);
	} else
#endif
	{
		rw_csr = KV(0x1e0000000 + IOASIC_CSR + 4);

		*(volatile uint32_t *)rw_csr =
		    (*(volatile uint32_t *)rw_csr & ~0xff) | pattern;
	}

	if (alpha_led_blink != 0) {
		timeout_set(&led_blink_state.tmo, ioasic_led_blink, NULL);
		timeout_add(&led_blink_state.tmo,
		    (((averunnable.ldavg[0] + FSCALE) * hz) >> (FSHIFT + 3)));
	}
}
@


1.16
log
@Blink leds on the DEC 3000 models (three different led types).
@
text
@d1 1
a1 1
/* $OpenBSD: ioasic.c,v 1.15 2008/08/09 16:42:29 miod Exp $ */
d233 1
a233 1
	evcount_attach(&ioasicintrs[dev].iai_count, name, NULL, &evcount_intr);
@


1.15
log
@Pass a device name to {tc,tcds,ioasic}_intr_establish in order to get
meaningful names associated to the interrupt counters.
@
text
@d1 1
a1 1
/* $OpenBSD: ioasic.c,v 1.14 2008/06/26 05:42:09 ray Exp $ */
d66 1
d76 3
d95 2
a96 1
#define	C(x)	((void *)(x))
d189 1
a189 1
	 * (This does _not_ include 3000/300 TC option slot bits.
d332 96
@


1.14
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ioasic.c,v 1.13 2007/11/06 18:20:05 miod Exp $ */
a119 1
	char	iai_name[16];
a196 4
		snprintf(ioasicintrs[i].iai_name,
		    sizeof ioasicintrs[i].iai_name, "ioasic slot %u", i);
		evcount_attach(&ioasicintrs[i].iai_count,
		    ioasicintrs[i].iai_name, NULL, &evcount_intr);
d198 2
a199 1
	tc_intr_establish(parent, ta->ta_cookie, IPL_NONE, ioasic_intr, sc);
d208 1
a208 1
ioasic_intr_establish(ioa, cookie, level, func, arg)
d213 1
d228 1
d271 1
@


1.13
log
@Get rid of TC_IPL_xxx values and tc_intrlevel_t, and use IPL_xxx and int.
No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: ioasic.c,v 1.12 2006/03/04 12:33:17 miod Exp $ */
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.12
log
@Better names for turbochannel event counters.
@
text
@d1 1
a1 1
/* $OpenBSD: ioasic.c,v 1.11 2004/06/28 02:28:43 aaron Exp $ */
d210 1
a210 1
	tc_intr_establish(parent, ta->ta_cookie, TC_IPL_NONE, ioasic_intr, sc);
d222 1
a222 1
	tc_intrlevel_t level;
@


1.11
log
@Use new event counter API for interrupt counting on alpha.  By me, with some
edits by Theo.  deraadt@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: ioasic.c,v 1.10 2003/05/13 21:32:17 deraadt Exp $ */
d127 1
a166 1
	char *cp;
d205 4
a208 7

		cp = malloc(12, M_DEVBUF, M_NOWAIT);
		if (cp == NULL)
			panic("ioasicattach");
		snprintf(cp, 12, "slot %lu", i);
		evcount_attach(&ioasicintrs[i].iai_count, self->dv_xname, NULL,
		    &evcount_intr);
@


1.10
log
@snprintf
@
text
@d1 1
a1 1
/* $OpenBSD: ioasic.c,v 1.9 2002/05/02 22:56:06 miod Exp $ */
a77 1
#include <machine/intrcnt.h>
d126 1
a126 3
#ifdef EVCNT_COUNTERS
	struct evcnt iai_evcnt;
#endif
a165 1
	const struct evcnt *pevcnt;
a201 1
	pevcnt = tc_intr_evcnt(parent, ta->ta_cookie);
d210 2
a211 4
#ifdef EVCNT_COUNTERS
		evcnt_attach_dynamic(&ioasicintrs[i].iai_evcnt,
		    EVCNT_TYPE_INTR, pevcnt, self->dv_xname, cp);
#endif
a313 6
#ifdef EVCNT_COUNTERS
#define	INCRINTRCNT(slot)	ioasicintrs[slot].iai_evcnt.ev_count++
#else
#define	INCRINTRCNT(slot)	intrcnt[INTRCNT_IOASIC + slot]++
#endif

d318 1
a318 1
			INCRINTRCNT(slot);				\
@


1.9
log
@Big TURBOchannel support catchup from NetBSD, part 1.
A few local changes and tweaks remain.

This bring DEC 3000 machines back in the game, but framebuffers are still
not supported at the moment.

Thanks to ericj@@ and nate@@ for supplying me a DEC 3000 for testing.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d214 1
a214 1
		sprintf(cp, "slot %lu", i);
@


1.8
log
@First round of __P removal in sys
@
text
@d1 39
a39 2
/*	$OpenBSD: ioasic.c,v 1.7 1999/01/11 05:11:04 millert Exp $	*/
/*	$NetBSD: ioasic.c,v 1.10 1996/12/05 01:39:41 cgd Exp $	*/
d72 1
d75 1
a77 1
#ifndef EVCNT_COUNTERS
a78 1
#endif
d81 1
a81 1
#include <alpha/tc/ioasicreg.h>
a83 7
struct ioasic_softc {
	struct	device sc_dv;

	tc_addr_t sc_base;
	void	*sc_cookie;
};

a84 1
#ifdef __BROKEN_INDIRECT_CONFIG
a85 3
#else
int	ioasicmatch(struct device *, struct cfdata *, void *);
#endif
a86 1
int     ioasicprint(void *, const char *);
d110 11
a120 12
struct ioasic_dev {
	char		*iad_modname;
	tc_offset_t	iad_offset;
	void		*iad_cookie;
	u_int32_t	iad_intrbits;
} ioasic_devs[] = {
	/* XXX lance name */
	{ "lance",    0x000c0000, C(IOASIC_DEV_LANCE), IOASIC_INTR_LANCE, },
	{ "z8530   ", 0x00100000, C(IOASIC_DEV_SCC0),  IOASIC_INTR_SCC_0, },
	{ "z8530   ", 0x00180000, C(IOASIC_DEV_SCC1),  IOASIC_INTR_SCC_1, },
	{ "TOY_RTC ", 0x00200000, C(IOASIC_DEV_BOGUS), 0,                 },
	{ "AMD79c30", 0x00240000, C(IOASIC_DEV_ISDN),  IOASIC_INTR_ISDN,  },
d127 3
a136 2
extern int cputype;

d140 1
a140 6
#ifdef __BROKEN_INDIRECT_CONFIG
	void *cfdata;
#else
	struct cfdata *cfdata;
#endif
	void *aux;
d165 6
a170 2
	struct ioasicdev_attach_args ioasicdev;
	u_long i;
d174 9
a182 3
	sc->sc_base = ta->ta_addr;
	ioasic_base = sc->sc_base;			/* XXX XXX XXX */
	sc->sc_cookie = ta->ta_cookie;
d186 3
a188 3
		*(volatile u_int *)IOASIC_REG_CSR(sc->sc_base) |=
		    IOASIC_CSR_FASTMODE;
		tc_mb();
d198 1
d200 2
a201 3
		*(volatile u_int32_t *)IOASIC_REG_IMSK(ioasic_base) &=
			~ioasic_devs[i].iad_intrbits;
	tc_mb();
d206 1
d210 9
d220 1
a220 1
	tc_intr_establish(parent, sc->sc_cookie, TC_IPL_NONE, ioasic_intr, sc);
d222 1
a222 1
        /*
d225 1
a225 34
        for (i = 0; i < ioasic_ndevs; i++) {
		strncpy(ioasicdev.iada_modname, ioasic_devs[i].iad_modname,
			TC_ROM_LLEN);
		ioasicdev.iada_modname[TC_ROM_LLEN] = '\0';
		ioasicdev.iada_offset = ioasic_devs[i].iad_offset;
		ioasicdev.iada_addr = sc->sc_base + ioasic_devs[i].iad_offset;
		ioasicdev.iada_cookie = ioasic_devs[i].iad_cookie;

                /* Tell the autoconfig machinery we've found the hardware. */
                config_found(self, &ioasicdev, ioasicprint);
        }
}

int
ioasicprint(aux, pnp)
	void *aux;
	const char *pnp;
{
	struct ioasicdev_attach_args *d = aux;

        if (pnp)
                printf("%s at %s", d->iada_modname, pnp);
        printf(" offset 0x%lx", (long)d->iada_offset);
        return (UNCONF);
}

int
ioasic_submatch(match, d)
	struct cfdata *match;
	struct ioasicdev_attach_args *d;
{

	return ((match->ioasiccf_offset == d->iada_offset) ||
		(match->ioasiccf_offset == IOASIC_OFFSET_UNKNOWN));
d235 2
a236 1
	u_long dev, i;
d244 1
a244 1
		panic("ioasic_intr_establish: cookie %d twice", dev);
d255 4
a258 3
	*(volatile u_int32_t *)IOASIC_REG_IMSK(ioasic_base) |=
		ioasic_devs[i].iad_intrbits;
	tc_mb();
d266 2
a267 1
	u_long dev, i;
d275 1
a275 1
		panic("ioasic_intr_disestablish: cookie %d missing intr", dev);
d283 4
a286 3
	*(volatile u_int32_t *)IOASIC_REG_IMSK(ioasic_base) &=
		~ioasic_devs[i].iad_intrbits;
	tc_mb();
d302 1
a302 2
 * asic_intr --
 *	ASIC interrupt handler.
d311 1
a311 4
	u_int32_t sir;
	volatile u_int32_t *sirp;

	sirp = (volatile u_int32_t *)IOASIC_REG_INTR(sc->sc_base);
d318 2
a319 1
		sir = *sirp;
d322 2
a323 3
	/* No interrupt counting via evcnt counters */ 
	XXX BREAK HERE XXX
#else /* !EVCNT_COUNTERS */
d325 1
a325 1
#endif /* EVCNT_COUNTERS */ 
d328 2
a329 2
#define	CHECKINTR(slot, bits)						\
		if (sir & bits) {					\
d334 2
d337 9
a345 4
		CHECKINTR(IOASIC_DEV_SCC0, IOASIC_INTR_SCC_0);
		CHECKINTR(IOASIC_DEV_SCC1, IOASIC_INTR_SCC_1);
		CHECKINTR(IOASIC_DEV_LANCE, IOASIC_INTR_LANCE);
		CHECKINTR(IOASIC_DEV_ISDN, IOASIC_INTR_ISDN);
a350 26
}

/* XXX */
char *
ioasic_lance_ether_address()
{

	return (u_char *)IOASIC_SYS_ETHER_ADDRESS(ioasic_base);
}

void
ioasic_lance_dma_setup(v)
	void *v;
{
	volatile u_int32_t *ldp;
	tc_addr_t tca;

	tca = (tc_addr_t)v;

	ldp = (volatile u_int *)IOASIC_REG_LANCE_DMAPTR(ioasic_base);
	*ldp = ((tca << 3) & ~(tc_addr_t)0x1f) | ((tca >> 29) & 0x1f);
	tc_wmb();

	*(volatile u_int32_t *)IOASIC_REG_CSR(ioasic_base) |=
	    IOASIC_CSR_DMAEN_LANCE;
	tc_mb();
@


1.7
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: ioasic.c,v 1.6 1997/01/24 19:58:13 niklas Exp $	*/
d56 1
a56 1
int	ioasicmatch __P((struct device *, void *, void *));
d58 1
a58 1
int	ioasicmatch __P((struct device *, struct cfdata *, void *));
d60 1
a60 1
void	ioasicattach __P((struct device *, struct device *, void *));
d71 2
a72 2
int	ioasic_intr __P((void *));
int	ioasic_intrnull __P((void *));
d101 1
a101 1
	int	(*iai_func) __P((void *));
d226 1
a226 1
	int (*func) __P((void *));
@


1.7.16.1
log
@Sync UBC branch to -current
@
text
@d1 2
a2 39
/* $OpenBSD$ */
/* $NetBSD: ioasic.c,v 1.34 2000/07/18 06:10:06 thorpej Exp $ */

/*-
 * Copyright (c) 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
a34 1
#include <sys/malloc.h>
a36 1
#include <machine/bus.h>
d39 1
d41 1
d44 1
a44 1
#include <dev/tc/ioasicreg.h>
d47 7
d55 7
a61 2
int	ioasicmatch(struct device *, void *, void *);
void	ioasicattach(struct device *, struct device *, void *);
d71 2
a72 2
int	ioasic_intr(void *);
int	ioasic_intrnull(void *);
d85 12
a96 11
struct ioasic_dev ioasic_devs[] = {
	{ "PMAD-BA ", IOASIC_SLOT_3_START, C(IOASIC_DEV_LANCE),
	  IOASIC_INTR_LANCE, },
	{ "z8530   ", IOASIC_SLOT_4_START, C(IOASIC_DEV_SCC0),
	  IOASIC_INTR_SCC_0, },
	{ "z8530   ", IOASIC_SLOT_6_START, C(IOASIC_DEV_SCC1),
	  IOASIC_INTR_SCC_1, },
	{ "TOY_RTC ", IOASIC_SLOT_8_START, C(IOASIC_DEV_BOGUS),
	  0, },
	{ "AMD79c30", IOASIC_SLOT_9_START, C(IOASIC_DEV_ISDN),
	  IOASIC_INTR_ISDN_TXLOAD | IOASIC_INTR_ISDN_RXLOAD,  },
d101 1
a101 1
	int	(*iai_func)(void *);
a102 3
#ifdef EVCNT_COUNTERS
	struct evcnt iai_evcnt;
#endif
d110 2
d115 6
a120 1
	void *cfdata, *aux;
d145 2
a146 6
#ifdef DEC_3000_300
	u_long ssr;
#endif
	u_long i, imsk;
	const struct evcnt *pevcnt;
	char *cp;
d150 3
a152 9
	sc->sc_bst = ta->ta_memt; 
	if (bus_space_map(ta->ta_memt, ta->ta_addr,
			0x400000, 0, &sc->sc_bsh)) {
		printf("%s: unable to map device\n", sc->sc_dv.dv_xname);
		return;
	}
	sc->sc_dmat = ta->ta_dmat;

	ioasic_base = sc->sc_base = ta->ta_addr; /* XXX XXX XXX */
d156 3
a158 3
		ssr = bus_space_read_4(sc->sc_bst, sc->sc_bsh, IOASIC_CSR);
		ssr |= IOASIC_CSR_FASTMODE;
		bus_space_write_4(sc->sc_bst, sc->sc_bsh, IOASIC_CSR, ssr);
a167 1
	imsk = bus_space_read_4(sc->sc_bst, sc->sc_bsh, IOASIC_IMSK);
d169 3
a171 2
		imsk &= ~ioasic_devs[i].iad_intrbits;
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, IOASIC_IMSK, imsk);
a175 1
	pevcnt = tc_intr_evcnt(parent, ta->ta_cookie);
a178 9

		cp = malloc(12, M_DEVBUF, M_NOWAIT);
		if (cp == NULL)
			panic("ioasicattach");
		sprintf(cp, "slot %lu", i);
#ifdef EVCNT_COUNTERS
		evcnt_attach_dynamic(&ioasicintrs[i].iai_evcnt,
		    EVCNT_TYPE_INTR, pevcnt, self->dv_xname, cp);
#endif
d180 1
a180 1
	tc_intr_establish(parent, ta->ta_cookie, TC_IPL_NONE, ioasic_intr, sc);
d182 1
a182 1
	/*
d185 34
a218 1
	ioasic_attach_devs(sc, ioasic_devs, ioasic_ndevs);
d226 1
a226 1
	int (*func)(void *);
d228 1
a228 2
	struct ioasic_softc *sc = (void *)ioasic_cd.cd_devs[0];
	u_long dev, i, imsk;
d236 1
a236 1
		panic("ioasic_intr_establish: cookie %lu twice", dev);
d247 3
a249 4

	imsk = bus_space_read_4(sc->sc_bst, sc->sc_bsh, IOASIC_IMSK);
        imsk |= ioasic_devs[i].iad_intrbits;
        bus_space_write_4(sc->sc_bst, sc->sc_bsh, IOASIC_IMSK, imsk);
d257 1
a257 2
	struct ioasic_softc *sc = (void *)ioasic_cd.cd_devs[0];
	u_long dev, i, imsk;
d265 1
a265 1
		panic("ioasic_intr_disestablish: cookie %lu missing intr", dev);
d273 3
a275 4

	imsk = bus_space_read_4(sc->sc_bst, sc->sc_bsh, IOASIC_IMSK);
	imsk &= ~ioasic_devs[i].iad_intrbits;
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, IOASIC_IMSK, imsk);
d291 2
a292 1
 * ASIC interrupt handler.
d301 4
a304 1
	u_int32_t sir, osir;
d311 1
a311 2
		osir = sir =
		    bus_space_read_4(sc->sc_bst, sc->sc_bsh, IOASIC_INTR);
d314 3
a316 2
#define	INCRINTRCNT(slot)	ioasicintrs[slot].iai_evcnt.ev_count++
#else
d318 1
a318 1
#endif
d321 2
a322 2
#define	CHECKINTR(slot, bits, clear)					\
		if (sir & (bits)) {					\
a326 2
			if (clear)					\
				sir &= ~(bits);				\
d328 4
a331 9
		CHECKINTR(IOASIC_DEV_SCC0, IOASIC_INTR_SCC_0, 0);
		CHECKINTR(IOASIC_DEV_SCC1, IOASIC_INTR_SCC_1, 0);
		CHECKINTR(IOASIC_DEV_LANCE, IOASIC_INTR_LANCE, 0);
		CHECKINTR(IOASIC_DEV_ISDN, IOASIC_INTR_ISDN_TXLOAD |
		    IOASIC_INTR_ISDN_RXLOAD | IOASIC_INTR_ISDN_OVRUN, 1);

		if (sir != osir)
			bus_space_write_4(sc->sc_bst, sc->sc_bsh,
			    IOASIC_INTR, sir);
d337 26
@


1.7.16.2
log
@sync
@
text
@d214 1
a214 1
		snprintf(cp, 12, "slot %lu", i);
@


1.7.6.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 1
a56 1
int	ioasicmatch(struct device *, void *, void *);
d58 1
a58 1
int	ioasicmatch(struct device *, struct cfdata *, void *);
d60 1
a60 1
void	ioasicattach(struct device *, struct device *, void *);
d71 2
a72 2
int	ioasic_intr(void *);
int	ioasic_intrnull(void *);
d101 1
a101 1
	int	(*iai_func)(void *);
d226 1
a226 1
	int (*func)(void *);
@


1.7.6.2
log
@Sync the SMP branch with 3.3
@
text
@d1 2
a2 39
/* $OpenBSD$ */
/* $NetBSD: ioasic.c,v 1.34 2000/07/18 06:10:06 thorpej Exp $ */

/*-
 * Copyright (c) 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
a34 1
#include <sys/malloc.h>
a36 1
#include <machine/bus.h>
d39 1
d41 1
d44 1
a44 1
#include <dev/tc/ioasicreg.h>
d47 7
d55 1
d57 3
d61 1
d85 12
a96 11
struct ioasic_dev ioasic_devs[] = {
	{ "PMAD-BA ", IOASIC_SLOT_3_START, C(IOASIC_DEV_LANCE),
	  IOASIC_INTR_LANCE, },
	{ "z8530   ", IOASIC_SLOT_4_START, C(IOASIC_DEV_SCC0),
	  IOASIC_INTR_SCC_0, },
	{ "z8530   ", IOASIC_SLOT_6_START, C(IOASIC_DEV_SCC1),
	  IOASIC_INTR_SCC_1, },
	{ "TOY_RTC ", IOASIC_SLOT_8_START, C(IOASIC_DEV_BOGUS),
	  0, },
	{ "AMD79c30", IOASIC_SLOT_9_START, C(IOASIC_DEV_ISDN),
	  IOASIC_INTR_ISDN_TXLOAD | IOASIC_INTR_ISDN_RXLOAD,  },
a102 3
#ifdef EVCNT_COUNTERS
	struct evcnt iai_evcnt;
#endif
d110 2
d115 6
a120 1
	void *cfdata, *aux;
d145 2
a146 6
#ifdef DEC_3000_300
	u_long ssr;
#endif
	u_long i, imsk;
	const struct evcnt *pevcnt;
	char *cp;
d150 3
a152 9
	sc->sc_bst = ta->ta_memt; 
	if (bus_space_map(ta->ta_memt, ta->ta_addr,
			0x400000, 0, &sc->sc_bsh)) {
		printf("%s: unable to map device\n", sc->sc_dv.dv_xname);
		return;
	}
	sc->sc_dmat = ta->ta_dmat;

	ioasic_base = sc->sc_base = ta->ta_addr; /* XXX XXX XXX */
d156 3
a158 3
		ssr = bus_space_read_4(sc->sc_bst, sc->sc_bsh, IOASIC_CSR);
		ssr |= IOASIC_CSR_FASTMODE;
		bus_space_write_4(sc->sc_bst, sc->sc_bsh, IOASIC_CSR, ssr);
a167 1
	imsk = bus_space_read_4(sc->sc_bst, sc->sc_bsh, IOASIC_IMSK);
d169 3
a171 2
		imsk &= ~ioasic_devs[i].iad_intrbits;
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, IOASIC_IMSK, imsk);
a175 1
	pevcnt = tc_intr_evcnt(parent, ta->ta_cookie);
a178 9

		cp = malloc(12, M_DEVBUF, M_NOWAIT);
		if (cp == NULL)
			panic("ioasicattach");
		sprintf(cp, "slot %lu", i);
#ifdef EVCNT_COUNTERS
		evcnt_attach_dynamic(&ioasicintrs[i].iai_evcnt,
		    EVCNT_TYPE_INTR, pevcnt, self->dv_xname, cp);
#endif
d180 1
a180 1
	tc_intr_establish(parent, ta->ta_cookie, TC_IPL_NONE, ioasic_intr, sc);
d182 1
a182 1
	/*
d185 34
a218 1
	ioasic_attach_devs(sc, ioasic_devs, ioasic_ndevs);
d228 1
a228 2
	struct ioasic_softc *sc = (void *)ioasic_cd.cd_devs[0];
	u_long dev, i, imsk;
d236 1
a236 1
		panic("ioasic_intr_establish: cookie %lu twice", dev);
d247 3
a249 4

	imsk = bus_space_read_4(sc->sc_bst, sc->sc_bsh, IOASIC_IMSK);
        imsk |= ioasic_devs[i].iad_intrbits;
        bus_space_write_4(sc->sc_bst, sc->sc_bsh, IOASIC_IMSK, imsk);
d257 1
a257 2
	struct ioasic_softc *sc = (void *)ioasic_cd.cd_devs[0];
	u_long dev, i, imsk;
d265 1
a265 1
		panic("ioasic_intr_disestablish: cookie %lu missing intr", dev);
d273 3
a275 4

	imsk = bus_space_read_4(sc->sc_bst, sc->sc_bsh, IOASIC_IMSK);
	imsk &= ~ioasic_devs[i].iad_intrbits;
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, IOASIC_IMSK, imsk);
d291 2
a292 1
 * ASIC interrupt handler.
d301 4
a304 1
	u_int32_t sir, osir;
d311 1
a311 2
		osir = sir =
		    bus_space_read_4(sc->sc_bst, sc->sc_bsh, IOASIC_INTR);
d314 3
a316 2
#define	INCRINTRCNT(slot)	ioasicintrs[slot].iai_evcnt.ev_count++
#else
d318 1
a318 1
#endif
d321 2
a322 2
#define	CHECKINTR(slot, bits, clear)					\
		if (sir & (bits)) {					\
a326 2
			if (clear)					\
				sir &= ~(bits);				\
d328 4
a331 9
		CHECKINTR(IOASIC_DEV_SCC0, IOASIC_INTR_SCC_0, 0);
		CHECKINTR(IOASIC_DEV_SCC1, IOASIC_INTR_SCC_1, 0);
		CHECKINTR(IOASIC_DEV_LANCE, IOASIC_INTR_LANCE, 0);
		CHECKINTR(IOASIC_DEV_ISDN, IOASIC_INTR_ISDN_TXLOAD |
		    IOASIC_INTR_ISDN_RXLOAD | IOASIC_INTR_ISDN_OVRUN, 1);

		if (sir != osir)
			bus_space_write_4(sc->sc_bst, sc->sc_bsh,
			    IOASIC_INTR, sir);
d337 26
@


1.7.6.3
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d214 1
a214 1
		snprintf(cp, 12, "slot %lu", i);
@


1.6
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: ioasic.c,v 1.5 1996/11/23 21:45:00 kstailey Exp $	*/
d286 1
a286 1
	panic("ioasic_intrnull: uncaught IOASIC intr for cookie %ld\n",
@


1.5
log
@added const to second parameter of cfprint_t routines
@
text
@d1 2
a2 2
/*	$OpenBSD: ioasic.c,v 1.4 1996/10/30 22:41:08 niklas Exp $	*/
/*	$NetBSD: ioasic.c,v 1.9 1996/10/13 03:00:32 christos Exp $	*/
d55 1
d57 3
d115 1
d117 3
@


1.4
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioasic.c,v 1.9 1996/10/13 03:00:32 christos Exp $	*/
d57 1
a57 1
int     ioasicprint(void *, /* const */ char *);
d193 1
a193 1
	/* const */ char *pnp;
@


1.3
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: ioasic.c,v 1.4.4.1 1996/06/05 00:39:05 cgd Exp $	*/
/*	$NetBSD: ioasic.c,v 1.4.4.1 1996/06/05 00:39:05 cgd Exp $	*/
d57 1
a57 1
int     ioasicprint(void *, char *);
d193 1
a193 1
	char *pnp;
d291 1
a291 1
	register int i, ifound;
d293 2
a294 2
	u_int32_t sir, junk;
	volatile u_int32_t *sirp, *junkp;
@


1.2
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.1
log
@from netbsd:
machine-independent TurboChannel bus configuration.  These files
deal with stuff like:
        (1) configuring built-in devices,
        (2) looking at TC slots configuring any devices found.
The lists of slots, slot locations, etc. and built-in devices
are provided by machine-dependent code.  Interrupt handling
is also provided by machine-dependent code, but the MD code provides
hooks so that standard names for 'establish' and 'disestablish'
can be used in drivers.

This code requires <machine/tc_machdep.h>, which defines some
portability types specific to the TurboChannel bus code.
@
text
@d1 1
a1 1
/*	$NetBSD: ioasic.c,v 1.1 1995/12/20 00:43:20 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1994, 1995 Carnegie-Mellon University.
d38 3
d57 8
a64 3
struct cfdriver ioasiccd =
    { NULL, "ioasic", ioasicmatch, ioasicattach, DV_DULL,
    sizeof(struct ioasic_softc) };
d86 2
a87 1
	{ "lance   ", 0x000c0000, C(IOASIC_DEV_LANCE), IOASIC_INTR_LANCE, },
d113 1
a113 1
	struct tcdev_attach_args *tcdev = aux;
d116 1
a116 1
	if (strncmp("FLAMG-IO", tcdev->tcda_modname, TC_ROM_LLEN))
d135 1
a135 1
	struct tcdev_attach_args *tcdev = aux;
d141 1
a141 1
	sc->sc_base = tcdev->tcda_addr;
d143 1
a143 1
	sc->sc_cookie = tcdev->tcda_cookie;
d304 7
d315 1
a354 39

#ifdef DEC_3000_300
void
ioasic_intr_300_opt0_enable(enable)
	int enable;
{

	if (enable)
		*(volatile u_int32_t *)IOASIC_REG_IMSK(ioasic_base) |=
			IOASIC_INTR_300_OPT0;
	else
		*(volatile u_int32_t *)IOASIC_REG_IMSK(ioasic_base) &=
			~IOASIC_INTR_300_OPT0;
}

void
ioasic_intr_300_opt1_enable(enable)
	int enable;
{

	if (enable)
		*(volatile u_int32_t *)IOASIC_REG_IMSK(ioasic_base) |=
			IOASIC_INTR_300_OPT1;
	else
		*(volatile u_int32_t *)IOASIC_REG_IMSK(ioasic_base) &=
			~IOASIC_INTR_300_OPT1;
}

void
ioasic_300_opts_isintr(opt0, opt1)
	int *opt0, *opt1;
{
	u_int32_t sir;

	sir = *(volatile u_int32_t *)IOASIC_REG_INTR(ioasic_base);
	*opt0 = sir & IOASIC_INTR_300_OPT0;
	*opt1 = sir & IOASIC_INTR_300_OPT1;
}
#endif
@
