head	1.29;
access;
symbols
	OPENBSD_6_1:1.29.0.28
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.29.0.26
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.22
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.24
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.16
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.20
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.18
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.14
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.12
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.10
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.8
	OPENBSD_5_0:1.29.0.6
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.4
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.22.0.6
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.21.0.4
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.20.0.12
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.10
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.8
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.6
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.4
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.19.0.4
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.16
	UBC:1.10.0.4
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.7.0.18
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.16
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.14
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.12
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.10
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.8
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2010.07.02.17.27.01;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2010.06.28.14.13.26;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2010.06.06.11.26.17;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2010.04.12.12.57.51;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.09.17.53.38;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.31.12.00.05;	author fgsch;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.31.06.40.16;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2008.08.09.16.42.29;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.06.18.20.05;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2004.09.19.21.34.42;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2003.10.03.16.44.49;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.02.23.27.44;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.11.19.20.25;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.27.20.07.06;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.02.22.56.06;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.15.01.20.04;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.28;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.15.20.45.29;	author nordin;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.16.20.50.16;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.25.00.56.10;	author ericj;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	2001.06.25.00.43.07;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.17.04.30.46;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	97.01.24.19.58.15;	author niklas;	state Exp;
branches
	1.7.14.1;
next	1.6;

1.6
date	96.10.30.22.41.11;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.07.29.23.02.11;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.06.18.09.45.16;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.26.18.12.02;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.54.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.50;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.50;	author deraadt;	state Exp;
branches;
next	;

1.7.14.1
date	2001.04.18.16.01.51;	author niklas;	state Exp;
branches;
next	1.7.14.2;

1.7.14.2
date	2001.07.04.10.14.53;	author niklas;	state Exp;
branches;
next	1.7.14.3;

1.7.14.3
date	2002.03.06.00.55.15;	author niklas;	state Exp;
branches;
next	1.7.14.4;

1.7.14.4
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	1.7.14.5;

1.7.14.5
date	2003.03.27.23.18.06;	author niklas;	state Exp;
branches;
next	1.7.14.6;

1.7.14.6
date	2003.06.07.11.11.34;	author ho;	state Exp;
branches;
next	1.7.14.7;

1.7.14.7
date	2004.02.19.09.59.34;	author niklas;	state Exp;
branches;
next	;

1.10.4.1
date	2002.01.31.22.55.06;	author niklas;	state Exp;
branches;
next	1.10.4.2;

1.10.4.2
date	2002.06.11.03.33.41;	author art;	state Exp;
branches;
next	1.10.4.3;

1.10.4.3
date	2003.05.19.21.38.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Move common code for waking up writers on a tty into a function.

ok deraadt matthew millert
@
text
@/* $OpenBSD: scc.c,v 1.28 2010/06/28 14:13:26 deraadt Exp $ */
/* $NetBSD: scc.c,v 1.58 2002/03/17 19:40:27 atatat Exp $ */

/*
 * Copyright (c) 1991,1990,1989,1994,1995,1996 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell and Rick Macklem.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)scc.c	8.2 (Berkeley) 11/30/93
 */

/*
 * Intel 82530 dual usart chip driver. Supports the serial port(s) on the
 * Personal DECstation 5000/xx and DECstation 5000/1xx, plus the keyboard
 * and mouse on the 5000/1xx. (Don't ask me where the A channel signals
 * are on the 5000/xx.)
 *
 * See: Intel MicroCommunications Handbook, Section 2, pg. 155-173, 1992.
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/file.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/device.h>

#include <dev/cons.h>

#include <dev/ic/z8530reg.h>
#include <alpha/tc/sccreg.h>
#include <alpha/tc/sccvar.h>

#include <machine/rpb.h>
#include <machine/conf.h>

#include <dev/tc/tcvar.h>
#include <dev/tc/ioasicreg.h>
#include <dev/tc/ioasicvar.h>

#undef	SCCDEV
#define	SCCDEV		15			/* XXX */

#define raster_console() 1	/* Treat test for cn_screen as true */
#define CONSOLE_ON_UNIT(unit) 0	/* No raster console on Alphas */

#define	NSCCLINE	(NSCC*2)
#define	SCCUNIT(dev)	(minor(dev) >> 1)
#define	SCCLINE(dev)	(minor(dev) & 0x1)

#ifdef DEBUG
int	debugChar;
#endif

int	alpha_donot_kludge_scc;

struct scc_softc {
	struct device sc_dv;
	struct pdma scc_pdma[2];
	struct {
		u_char	wr1;
		u_char	wr3;
		u_char	wr4;
		u_char	wr5;
		u_char	wr14;
	} scc_wreg[2];
	struct tty *scc_tty[2];
	int	scc_softCAR;

	int scc_flags[2];
#define SCC_CHAN_NEEDSDELAY	0x01	/* sw must delay 1.6us between output*/
#define SCC_CHAN_NOMODEM	0x02	/* don't touch modem ctl lines (may
					   be left floating or x-wired */
#define SCC_CHAN_MODEM_CROSSED	0x04	/* modem lines wired to	other channel*/
#define SCC_CHAN_KBDLINE	0x08	/* XXX special-case keyboard lines */
};

/*
 * BRG formula is:
 *				ClockFrequency
 *	BRGconstant =	---------------------------  -  2
 *			2 * BaudRate * ClockDivider
 *
 * Speed selections with Pclk=7.3728MHz, clock x16
 */
const struct speedtab sccspeedtab[] = {
	{ 0,		0,	},
	{ 50,		4606,	},
	{ 75,		3070,	},
	{ 110,		2093,	},
	{ 134.5,	1711,	},
	{ 150,		1534,	},
	{ 200,		1150,	},
	{ 300,		766,	},
	{ 600,		382,	},
	{ 1200,		190,	},
	{ 1800,		126,	},
	{ 2400,		94,	},
	{ 4800,		46,	},
	{ 7200,		30,	},	/* non-POSIX */
	{ 9600,		22,	},
	{ 14400,	14,	},	/* non-POSIX */
	{ 19200,	10,	},
	{ 28800,	6,	},	/* non-POSIX */
	{ 38400,	4,	},	/* non-POSIX */
	{ 57600,	2,	},	/* non-POSIX */
	{ -1,		-1,	},
};

#ifndef	PORTSELECTOR
#define	ISPEED	TTYDEF_SPEED
#define	LFLAG	TTYDEF_LFLAG
#else
#define	ISPEED	B4800
#define	LFLAG	(TTYDEF_LFLAG & ~ECHO)
#endif

/* Definition of the driver for autoconfig. */
int	sccmatch(struct device *, void *, void *);
void	sccattach(struct device *, struct device *, void *);

struct cfattach scc_ca = {
	sizeof (struct scc_softc), sccmatch, sccattach,
};

struct cfdriver scc_cd = {
	NULL, "scc", DV_TTY,
};

cdev_decl(scc);

int		sccGetc(dev_t);
void		sccPutc(dev_t, int);
void		sccPollc(dev_t, int);
int		sccparam(struct tty *, struct termios *);
void		sccstart(struct tty *);

int	sccmctl(struct scc_softc *, int, int, int);
int	cold_sccparam(struct tty *, struct termios *,
		    struct scc_softc *sc, int line);

#ifdef SCC_DEBUG
void	rr(char *, scc_regmap_t *);
#endif
void	scc_modem_intr(dev_t);
void	sccreset(struct scc_softc *);

int	sccintr(void *);
void	scc_alphaintr(int);

/*
 * console variables, for using serial console while still cold and
 * autoconfig has not attached the scc device.
 */
scc_regmap_t *scc_cons_addr = 0;
struct consdev scccons = {
	NULL, NULL, sccGetc, sccPutc, sccPollc, NULL, NODEV, 0
};

/*
 * Test to see if device is present.
 * Return true if found.
 */
int
sccmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	extern struct cfdriver ioasic_cd;		/* XXX */
	struct ioasicdev_attach_args *d = aux;
	struct cfdata *cf = vcf;
	void *sccaddr;

	if (parent->dv_cfdata->cf_driver != &ioasic_cd) {
#ifdef DIAGNOSTIC
		printf("Cannot attach scc on %s\n", parent->dv_xname);
#endif
		return (0);
	}

	/* Make sure that we're looking for this type of device. */
	if ((strncmp(d->iada_modname, "z8530   ", TC_ROM_LLEN) != 0) &&
	    (strncmp(d->iada_modname, "scc", TC_ROM_LLEN)!= 0))
		return (0);

	/*
	 * Check user-specified offset against the ioasic offset.
	 * Allow it to be wildcarded.
	 */
	if (cf->cf_loc[0] != -1 &&
	    cf->cf_loc[0] != d->iada_offset)
		return (0);

	/* Get the address, and check it for validity. */
	sccaddr = (void *)d->iada_addr;
#ifdef SPARSE
	sccaddr = (void *)TC_DENSE_TO_SPARSE((tc_addr_t)sccaddr);
#endif
	if (badaddr(sccaddr, 2))
		return (0);

	return (1);
}

/*
 * Enable ioasic SCC interrupts and scc DMA engine interrupts.
 * XXX does not really belong here.
 */
void
scc_alphaintr(onoff)
	int onoff;
{
	if (onoff) {
		*(volatile u_int *)(ioasic_base + IOASIC_IMSK) |=
		    IOASIC_INTR_SCC_1 | IOASIC_INTR_SCC_0;
#if !defined(DEC_3000_300) && defined(SCC_DMA)
		*(volatile u_int *)(ioasic_base + IOASIC_CSR) |=
		    IOASIC_CSR_DMAEN_T1 | IOASIC_CSR_DMAEN_R1 |
		    IOASIC_CSR_DMAEN_T2 | IOASIC_CSR_DMAEN_R2;
#endif
	} else {
		*(volatile u_int *)(ioasic_base + IOASIC_IMSK) &=
		    ~(IOASIC_INTR_SCC_1 | IOASIC_INTR_SCC_0);
#if !defined(DEC_3000_300) && defined(SCC_DMA)
		*(volatile u_int *)(ioasic_base + IOASIC_CSR) &=
		    ~(IOASIC_CSR_DMAEN_T1 | IOASIC_CSR_DMAEN_R1 |
		    IOASIC_CSR_DMAEN_T2 | IOASIC_CSR_DMAEN_R2);
#endif
	}
	tc_mb();
}

void
sccattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct scc_softc *sc = (struct scc_softc *)self;
	struct ioasicdev_attach_args *d = aux;
	struct pdma *pdp;
	struct tty *tp;
	void *sccaddr;
	int cntr;
	struct termios cterm;
	struct tty ctty;
	int s;
	int unit;

	unit = sc->sc_dv.dv_unit;

	/* Get the address, and check it for validity. */
	sccaddr = (void *)d->iada_addr;
#ifdef SPARSE
	sccaddr = (void *)TC_DENSE_TO_SPARSE((tc_addr_t)sccaddr);
#endif

	/* Register the interrupt handler. */
	ioasic_intr_establish(parent, d->iada_cookie, IPL_TTY,
	    sccintr, (void *)sc, self->dv_xname);

	/*
	 * For a remote console, wait a while for previous output to
	 * complete.
	 */
	if ((cputype == ST_DEC_3000_500 && sc->sc_dv.dv_unit == 1) ||
	    (cputype == ST_DEC_3000_300 && sc->sc_dv.dv_unit == 0))
		DELAY(10000);
	pdp = &sc->scc_pdma[0];

	/* init pseudo DMA structures */
	for (cntr = 0; cntr < 2; cntr++) {
		pdp->p_addr = (void *)sccaddr;
		tp = sc->scc_tty[cntr] = ttymalloc(0);
		pdp->p_arg = (long)tp;
		pdp->p_fcn = (void (*)(struct tty*))0;
		tp->t_dev = (dev_t)((sc->sc_dv.dv_unit << 1) | cntr);
		pdp++;
	}
	/* What's the warning here? Defaulting to softCAR on line 2? */
	sc->scc_softCAR = sc->sc_dv.dv_cfdata->cf_flags | 0x2;	/* XXX */

	/* reset chip, initialize  register-copies in softc */
	sccreset(sc);

	/*
	 * Special handling for consoles.
	 */
	if (1 /* SCCUNIT(cn_tab.cn_dev) == sc->sc_dv.dv_unit */) {
		s = spltty();
		cterm.c_cflag = (TTYDEF_CFLAG & ~(CSIZE | PARENB)) | CS8;
		cterm.c_ospeed = cterm.c_ispeed = 9600;
		(void) cold_sccparam(&ctty, &cterm, sc,
		    SCCLINE((sc->sc_dv.dv_unit == 0) ?
			    SCCCOMM2_PORT : SCCCOMM3_PORT));
		DELAY(1000);
		splx(s);
	}

	/*
	 * XXX
	 * Unit 1 is the remote console, wire it up now.
	 */
	if ((cputype == ST_DEC_3000_500 && sc->sc_dv.dv_unit == 1) ||
	    (cputype == ST_DEC_3000_300 && sc->sc_dv.dv_unit == 0)) {
		if (alpha_donot_kludge_scc)
			printf("\nSWITCHING TO SERIAL CONSOLE!\n");
		cn_tab = &scccons;
		cn_tab->cn_dev = makedev(SCCDEV, sc->sc_dv.dv_unit * 2);

		printf("%s console\n", alpha_donot_kludge_scc ? "\n***" : ":");

		/* wire carrier for console. */
		sc->scc_softCAR |= SCCLINE(cn_tab->cn_dev);
	} else
		printf("\n");
}

/*
 * Reset the chip.
 */
void
sccreset(sc)
	register struct scc_softc *sc;
{
	register scc_regmap_t *regs;
	register u_char val;

	regs = (scc_regmap_t *)sc->scc_pdma[0].p_addr;
	/*
	 * Chip once-only initialization
	 *
	 * NOTE: The wiring we assume is the one on the 3min:
	 *
	 *	out	A-TxD	-->	TxD	keybd or mouse
	 *	in	A-RxD	-->	RxD	keybd or mouse
	 *	out	A-DTR~	-->	DTR	comm
	 *	out	A-RTS~	-->	RTS	comm
	 *	in	A-CTS~	-->	SI	comm
	 *	in	A-DCD~	-->	RI	comm
	 *	in	A-SYNCH~-->	DSR	comm
	 *	out	B-TxD	-->	TxD	comm
	 *	in	B-RxD	-->	RxD	comm
	 *	in	B-RxC	-->	TRxCB	comm
	 *	in	B-TxC	-->	RTxCB	comm
	 *	out	B-RTS~	-->	SS	comm
	 *	in	B-CTS~	-->	CTS	comm
	 *	in	B-DCD~	-->	CD	comm
	 */
	SCC_INIT_REG(regs, SCC_CHANNEL_A);
	SCC_INIT_REG(regs, SCC_CHANNEL_B);

	SCC_WRITE_REG(regs, SCC_CHANNEL_A, SCC_WR9, ZSWR9_HARD_RESET);
	DELAY(50000);	/*enough ? */
	SCC_WRITE_REG(regs, SCC_CHANNEL_A, SCC_WR9, 0);

	/* program the interrupt vector */
	SCC_WRITE_REG(regs, SCC_CHANNEL_A, ZSWR_IVEC, 0xf0);
	SCC_WRITE_REG(regs, SCC_CHANNEL_B, ZSWR_IVEC, 0xf0);
	SCC_WRITE_REG(regs, SCC_CHANNEL_A, SCC_WR9, ZSWR9_VECTOR_INCL_STAT);

	/* receive parameters and control */
	sc->scc_wreg[SCC_CHANNEL_A].wr3 = 0;
	sc->scc_wreg[SCC_CHANNEL_B].wr3 = 0;

	/* timing base defaults */
	sc->scc_wreg[SCC_CHANNEL_A].wr4 = ZSWR4_CLK_X16;
	sc->scc_wreg[SCC_CHANNEL_B].wr4 = ZSWR4_CLK_X16;

	/* enable DTR, RTS and SS */
	sc->scc_wreg[SCC_CHANNEL_B].wr5 = 0;
	sc->scc_wreg[SCC_CHANNEL_A].wr5 = ZSWR5_RTS | ZSWR5_DTR;

	/* baud rates */
	val = ZSWR14_BAUD_ENA | ZSWR14_BAUD_FROM_PCLK;
	sc->scc_wreg[SCC_CHANNEL_B].wr14 = val;
	sc->scc_wreg[SCC_CHANNEL_A].wr14 = val;

	/* interrupt conditions */
	val =	ZSWR1_RIE | ZSWR1_PE_SC | ZSWR1_SIE | ZSWR1_TIE;
	sc->scc_wreg[SCC_CHANNEL_A].wr1 = val;
	sc->scc_wreg[SCC_CHANNEL_B].wr1 = val;
}

int
sccopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	register struct scc_softc *sc;
	register struct tty *tp;
	register int unit, line;
	int s, error = 0;
	int firstopen = 0;

	unit = SCCUNIT(dev);
	if (unit >= scc_cd.cd_ndevs)
		return (ENXIO);
	sc = scc_cd.cd_devs[unit];
	if (!sc)
		return (ENXIO);

	line = SCCLINE(dev);
	if (sc->scc_pdma[line].p_addr == NULL)
		return (ENXIO);
	tp = sc->scc_tty[line];
	if (tp == NULL) {
		tp = sc->scc_tty[line] = ttymalloc(0);
	}
	tp->t_oproc = sccstart;
	tp->t_param = sccparam;
	tp->t_dev = dev;
	if ((tp->t_state & TS_ISOPEN) == 0) {
		ttychars(tp);
		firstopen = 1;
#ifndef PORTSELECTOR
		if (tp->t_ispeed == 0) {
#endif
			tp->t_iflag = TTYDEF_IFLAG;
			tp->t_oflag = TTYDEF_OFLAG;
			tp->t_cflag = TTYDEF_CFLAG;
			tp->t_lflag = LFLAG;
			tp->t_ispeed = tp->t_ospeed = ISPEED;
#ifdef PORTSELECTOR
			tp->t_cflag |= HUPCL;
#else
		}
#endif
		(void) sccparam(tp, &tp->t_termios);
		ttsetwater(tp);
	} else if ((tp->t_state & TS_XCLUDE) && suser(curproc, 0) != 0)
		return (EBUSY);
	(void) sccmctl(sc, SCCLINE(dev), DML_DTR, DMSET);
	s = spltty();
	while (!(flag & O_NONBLOCK) && !(tp->t_cflag & CLOCAL) &&
	    !(tp->t_state & TS_CARR_ON)) {
		tp->t_state |= TS_WOPEN;
		error = ttysleep(tp, (caddr_t)&tp->t_rawq, TTIPRI | PCATCH,
		    ttopen, 0);
		tp->t_state &= ~TS_WOPEN;
		if (error != 0)
			break;
	}
	splx(s);
	if (error)
		return (error);
	error = (*linesw[tp->t_line].l_open)(dev, tp, p);

	return (error);
}

/*ARGSUSED*/
int
sccclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	register struct scc_softc *sc = scc_cd.cd_devs[SCCUNIT(dev)];
	register struct tty *tp;
	register int line;

	line = SCCLINE(dev);
	tp = sc->scc_tty[line];
	if (sc->scc_wreg[line].wr5 & ZSWR5_BREAK) {
		sc->scc_wreg[line].wr5 &= ~ZSWR5_BREAK;
		ttyoutput(0, tp);
	}
	(*linesw[tp->t_line].l_close)(tp, flag, p);
	if ((tp->t_cflag & HUPCL) || (tp->t_state & TS_WOPEN) ||
	    !(tp->t_state & TS_ISOPEN))
		(void) sccmctl(sc, line, 0, DMSET);
	return (ttyclose(tp));
}

int
sccread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	register struct scc_softc *sc;
	register struct tty *tp;

	sc = scc_cd.cd_devs[SCCUNIT(dev)];		/* XXX*/
	tp = sc->scc_tty[SCCLINE(dev)];
	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

int
sccwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	register struct scc_softc *sc;
	register struct tty *tp;

	sc = scc_cd.cd_devs[SCCUNIT(dev)];	/* XXX*/
	tp = sc->scc_tty[SCCLINE(dev)];
	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

struct tty *
scctty(dev)
	dev_t dev;
{
	register struct scc_softc *sc;
	register struct tty *tp;
	register int unit = SCCUNIT(dev);

	if ((unit >= scc_cd.cd_ndevs) || (sc = scc_cd.cd_devs[unit]) == 0)
		return (0);
	tp = sc->scc_tty[SCCLINE(dev)];
	return (tp);
}

/*ARGSUSED*/
int
sccioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	register struct scc_softc *sc;
	register struct tty *tp;
	int error, line;

	line = SCCLINE(dev);
	sc = scc_cd.cd_devs[SCCUNIT(dev)];
	tp = sc->scc_tty[line];
	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);
	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	switch (cmd) {

	case TIOCSBRK:
		sc->scc_wreg[line].wr5 |= ZSWR5_BREAK;
		ttyoutput(0, tp);
		break;

	case TIOCCBRK:
		sc->scc_wreg[line].wr5 &= ~ZSWR5_BREAK;
		ttyoutput(0, tp);
		break;

	case TIOCSDTR:
		(void) sccmctl(sc, line, DML_DTR|DML_RTS, DMBIS);
		break;

	case TIOCCDTR:
		(void) sccmctl(sc, line, DML_DTR|DML_RTS, DMBIC);
		break;

	case TIOCMSET:
		(void) sccmctl(sc, line, *(int *)data, DMSET);
		break;

	case TIOCMBIS:
		(void) sccmctl(sc, line, *(int *)data, DMBIS);
		break;

	case TIOCMBIC:
		(void) sccmctl(sc, line, *(int *)data, DMBIC);
		break;

	case TIOCMGET:
		*(int *)data = sccmctl(sc, line, 0, DMGET);
		break;

	default:
		return (ENOTTY);
	}
	return (0);
}



/*
 * Set line parameters --  tty t_param entry point.
 */
int
sccparam(tp, t)
	register struct tty *tp;
	register struct termios *t;
{
	register struct scc_softc *sc;

	/* Extract the softc and call cold_sccparam to do all the work. */
	sc = scc_cd.cd_devs[SCCUNIT(tp->t_dev)];
	return cold_sccparam(tp, t, sc, SCCLINE(tp->t_dev));
}


/*
 * Do what sccparam() (t_param entry point) does, but callable when cold.
 */
int
cold_sccparam(tp, t, sc, line)
	register struct tty *tp;
	register struct termios *t;
	register struct scc_softc *sc;
	register int line;
{
	register scc_regmap_t *regs;
	register u_char value, wvalue;
	register int cflag = t->c_cflag;
	int ospeed;

	/* Check arguments */
	if (t->c_ispeed && t->c_ispeed != t->c_ospeed)
		return (EINVAL);
	ospeed = ttspeedtab(t->c_ospeed, sccspeedtab);
	if (ospeed < 0)
		return (EINVAL);
	/* and copy to tty */
	tp->t_ispeed = t->c_ispeed;
	tp->t_ospeed = t->c_ospeed;
	tp->t_cflag = cflag;

	/*
	 * Handle console specially.
	 */
	{
		cflag = CS8;
		ospeed = ttspeedtab(9600, sccspeedtab);
	}
	if (ospeed == 0) {
		(void) sccmctl(sc, line, 0, DMSET);	/* hang up line */
		return (0);
	}

	regs = (scc_regmap_t *)sc->scc_pdma[line].p_addr;

	/*
	 * pmax driver used to reset the SCC here. That reset causes the
	 * other channel on the SCC to drop outpur chars: at least that's
	 * what CGD reports for the Alpha.  It's a bug.
	 */
#if 0
	/* reset line */
	if (line == SCC_CHANNEL_A)
		value = ZSWR9_A_RESET;
	else
		value = ZSWR9_B_RESET;
	SCC_WRITE_REG(regs, line, SCC_WR9, value);
	DELAY(25);
#endif

	/* stop bits, normally 1 */
	value = sc->scc_wreg[line].wr4 & 0xf0;
	if (cflag & CSTOPB)
		value |= ZSWR4_TWOSB;
	else
		value |= ZSWR4_ONESB;
	if ((cflag & PARODD) == 0)
		value |= ZSWR4_EVENP;
	if (cflag & PARENB)
		value |= ZSWR4_PARENB;

	/* set it now, remember it must be first after reset */
	sc->scc_wreg[line].wr4 = value;
	SCC_WRITE_REG(regs, line, SCC_WR4, value);

	/* vector again */
	SCC_WRITE_REG(regs, line, ZSWR_IVEC, 0xf0);

	/* clear break, keep rts dtr */
	wvalue = sc->scc_wreg[line].wr5 & (ZSWR5_DTR|ZSWR5_RTS);
	switch (cflag & CSIZE) {
	case CS5:
		value = ZSWR3_RX_5;
		wvalue |= ZSWR5_TX_5;
		break;
	case CS6:
		value = ZSWR3_RX_6;
		wvalue |= ZSWR5_TX_6;
		break;
	case CS7:
		value = ZSWR3_RX_7;
		wvalue |= ZSWR5_TX_7;
		break;
	case CS8:
	default:
		value = ZSWR3_RX_8;
		wvalue |= ZSWR5_TX_8;
	};
	sc->scc_wreg[line].wr3 = value;
	SCC_WRITE_REG(regs, line, SCC_WR3, value);

	sc->scc_wreg[line].wr5 = wvalue;
	SCC_WRITE_REG(regs, line, SCC_WR5, wvalue);

	/*
	 * XXX Does the SCC chip require us to refresh the WR5 register
	 * for the other channel after writing the other, or not?
	 */
#ifdef notdef
	/* XXX */
	{
	int otherline = (line + 1) & 1;
	SCC_WRITE_REG(regs, otherline, SCC_WR5, sc->scc_wreg[otherline].wr5);
	}
#endif

	SCC_WRITE_REG(regs, line, ZSWR_SYNCLO, 0);
	SCC_WRITE_REG(regs, line, ZSWR_SYNCHI, 0);
	SCC_WRITE_REG(regs, line, SCC_WR9, ZSWR9_VECTOR_INCL_STAT);
	SCC_WRITE_REG(regs, line, SCC_WR10, 0);
	value = ZSWR11_RXCLK_BAUD | ZSWR11_TXCLK_BAUD |
		ZSWR11_TRXC_OUT_ENA | ZSWR11_TRXC_BAUD;
	SCC_WRITE_REG(regs, line, SCC_WR11, value);
	SCC_SET_TIMING_BASE(regs, line, ospeed);
	value = sc->scc_wreg[line].wr14;
	SCC_WRITE_REG(regs, line, SCC_WR14, value);

	if (sc->sc_dv.dv_unit == 1) {
		/* On unit one, on the flamingo, modem control is floating! */
		value = ZSWR15_BREAK_IE;
	} else
	{
		value = ZSWR15_BREAK_IE | ZSWR15_CTS_IE | ZSWR15_DCD_IE;
	}
	SCC_WRITE_REG(regs, line, SCC_WR15, value);

	/* and now the enables */
	value = sc->scc_wreg[line].wr3 | ZSWR3_RX_ENABLE;
	SCC_WRITE_REG(regs, line, SCC_WR3, value);
	value = sc->scc_wreg[line].wr5 | ZSWR5_TX_ENABLE;
	sc->scc_wreg[line].wr5 = value;
	SCC_WRITE_REG(regs, line, SCC_WR5, value);

	/* master inter enable */
	value = ZSWR9_MASTER_IE | ZSWR9_VECTOR_INCL_STAT;
	SCC_WRITE_REG(regs, line, SCC_WR9, value);
	SCC_WRITE_REG(regs, line, SCC_WR1, sc->scc_wreg[line].wr1);
	tc_mb();

	scc_alphaintr(1);			/* XXX XXX XXX */

	return (0);
}


/*
 * Check for interrupts from all devices.
 */
int
sccintr(xxxsc)
	void *xxxsc;
{
	register struct scc_softc *sc = (struct scc_softc *)xxxsc;
	register int unit = (long)sc->sc_dv.dv_unit;
	register scc_regmap_t *regs;
	register struct tty *tp;
	register struct pdma *dp;
	register int cc, chan, rr1, rr2, rr3;
	int overrun = 0;

	rr1 = 0;		/* shut up gcc -Wall */
	regs = (scc_regmap_t *)sc->scc_pdma[0].p_addr;
	unit <<= 1;
	for (;;) {
	    SCC_READ_REG(regs, SCC_CHANNEL_B, ZSRR_IVEC, rr2);
	    rr2 = SCC_RR2_STATUS(rr2);
	    /* are we done yet ? */
	    if (rr2 == 6) {	/* strange, distinguished value */
		SCC_READ_REG(regs, SCC_CHANNEL_A, ZSRR_IPEND, rr3);
		if (rr3 == 0)
			return 1;
	    }

	    SCC_WRITE_REG(regs, SCC_CHANNEL_A, SCC_RR0, ZSWR0_CLR_INTR);
	    if ((rr2 == SCC_RR2_A_XMIT_DONE) || (rr2 == SCC_RR2_B_XMIT_DONE)) {
		chan = (rr2 == SCC_RR2_A_XMIT_DONE) ?
			SCC_CHANNEL_A : SCC_CHANNEL_B;
		tp = sc->scc_tty[chan];
		dp = &sc->scc_pdma[chan];
		if (dp->p_mem < dp->p_end) {
			SCC_WRITE_DATA(regs, chan, *dp->p_mem++);
			tc_mb();
		} else {
			tp->t_state &= ~TS_BUSY;
			if (tp->t_state & TS_FLUSH)
				tp->t_state &= ~TS_FLUSH;
			else {
				ndflush(&tp->t_outq, dp->p_mem -
					(caddr_t) tp->t_outq.c_cf);
				dp->p_end = dp->p_mem = tp->t_outq.c_cf;
			}
			(*linesw[tp->t_line].l_start)(tp);
			if (tp->t_outq.c_cc == 0 || !(tp->t_state & TS_BUSY)) {
				SCC_READ_REG(regs, chan, SCC_RR15, cc);
				cc &= ~ZSWR15_TXUEOM_IE;
				SCC_WRITE_REG(regs, chan, SCC_WR15, cc);
				cc = sc->scc_wreg[chan].wr1 & ~ZSWR1_TIE;
				SCC_WRITE_REG(regs, chan, SCC_WR1, cc);
				sc->scc_wreg[chan].wr1 = cc;
				tc_mb();
			}
		}
	    } else if (rr2 == SCC_RR2_A_RECV_DONE ||
		rr2 == SCC_RR2_B_RECV_DONE || rr2 == SCC_RR2_A_RECV_SPECIAL ||
		rr2 == SCC_RR2_B_RECV_SPECIAL) {
		if (rr2 == SCC_RR2_A_RECV_DONE || rr2 == SCC_RR2_A_RECV_SPECIAL)
			chan = SCC_CHANNEL_A;
		else
			chan = SCC_CHANNEL_B;
		tp = sc->scc_tty[chan];
		SCC_READ_DATA(regs, chan, cc);
		if (rr2 == SCC_RR2_A_RECV_SPECIAL ||
			rr2 == SCC_RR2_B_RECV_SPECIAL) {
			SCC_READ_REG(regs, chan, SCC_RR1, rr1);
			SCC_WRITE_REG(regs, chan, SCC_RR0, ZSWR0_RESET_ERRORS);
			if ((rr1 & ZSRR1_DO) && overrun == 0) {
				log(LOG_WARNING, "scc%d,%d: silo overflow\n",
					unit >> 1, chan);
				overrun = 1;
			}
		}

		if (!(tp->t_state & TS_ISOPEN)) {
			wakeup((caddr_t)&tp->t_rawq);
#ifdef PORTSELECTOR
			if (!(tp->t_state & TS_WOPEN))
#endif
				continue;
		}
		if (rr2 == SCC_RR2_A_RECV_SPECIAL ||
			rr2 == SCC_RR2_B_RECV_SPECIAL) {
			if (rr1 & ZSRR1_PE)
				cc |= TTY_PE;
			if (rr1 & ZSRR1_FE)
				cc |= TTY_FE;
		}
		(*linesw[tp->t_line].l_rint)(cc, tp);
	    } else if ((rr2 == SCC_RR2_A_EXT_STATUS) || (rr2 == SCC_RR2_B_EXT_STATUS)) {
		chan = (rr2 == SCC_RR2_A_EXT_STATUS) ?
		    SCC_CHANNEL_A : SCC_CHANNEL_B;
		SCC_WRITE_REG(regs, chan, SCC_RR0, ZSWR0_RESET_STATUS);
		scc_modem_intr(unit | chan);
	    }
	}
	return 0;	/* XXX */
}

void
sccstart(tp)
	register struct tty *tp;
{
	register struct pdma *dp;
	register scc_regmap_t *regs;
	register struct scc_softc *sc;
	register int cc, chan;
	u_char temp;
	int s, sendone;

	sc = scc_cd.cd_devs[SCCUNIT(tp->t_dev)];
	dp = &sc->scc_pdma[SCCLINE(tp->t_dev)];
	regs = (scc_regmap_t *)dp->p_addr;
	s = spltty();
	if (tp->t_state & (TS_TIMEOUT|TS_BUSY|TS_TTSTOP))
		goto out;
	ttwakeupwr(tp);
	if (tp->t_outq.c_cc == 0)
		goto out;
	/* handle console specially */
	if (tp == scctty(makedev(SCCDEV,SCCKBD_PORT)) && raster_console()) {
		while (tp->t_outq.c_cc > 0) {
			cc = getc(&tp->t_outq) & 0x7f;
			cnputc(cc);
		}
		/*
		 * After we flush the output queue we may need to wake
		 * up the process that made the output.
		 */
		ttwakeupwr(tp);
		goto out;
	}
	cc = ndqb(&tp->t_outq, 0);

	tp->t_state |= TS_BUSY;
	dp->p_end = dp->p_mem = tp->t_outq.c_cf;
	dp->p_end += cc;

	/*
	 * Enable transmission and send the first char, as required.
	 */
	chan = SCCLINE(tp->t_dev);
	SCC_READ_REG(regs, chan, SCC_RR0, temp);
	sendone = (temp & ZSRR0_TX_READY);
	SCC_READ_REG(regs, chan, SCC_RR15, temp);
	temp |= ZSWR15_TXUEOM_IE;
	SCC_WRITE_REG(regs, chan, SCC_WR15, temp);
	temp = sc->scc_wreg[chan].wr1 | ZSWR1_TIE;
	SCC_WRITE_REG(regs, chan, SCC_WR1, temp);
	sc->scc_wreg[chan].wr1 = temp;
	if (sendone) {
#ifdef DIAGNOSTIC
		if (cc == 0)
			panic("sccstart: No chars");
#endif
		SCC_WRITE_DATA(regs, chan, *dp->p_mem++);
	}
	tc_mb();
out:
	splx(s);
}

/*
 * Stop output on a line.
 */
/*ARGSUSED*/
int
sccstop(tp, flag)
	register struct tty *tp;
	int flag;
{
	register struct pdma *dp;
	register struct scc_softc *sc;
	register int s;

	sc = scc_cd.cd_devs[SCCUNIT(tp->t_dev)];
	dp = &sc->scc_pdma[SCCLINE(tp->t_dev)];
	s = spltty();
	if (tp->t_state & TS_BUSY) {
		dp->p_end = dp->p_mem;
		if (!(tp->t_state & TS_TTSTOP))
			tp->t_state |= TS_FLUSH;
	}
	splx(s);
	return 0;
}

int
sccmctl(sc, line, bits, how)
	struct scc_softc *sc;
	int line, bits, how;
{
	register scc_regmap_t *regs;
	register int mbits;
	register u_char value;
	int s;

	regs = (scc_regmap_t *)sc->scc_pdma[line].p_addr;
	s = spltty();
	/*
	 * only channel B has modem control, however the DTR and RTS
	 * pins on the comm port are wired to the DTR and RTS A channel
	 * signals.
	 */
	mbits = DML_DTR | DML_DSR | DML_CAR;
	if (line == SCC_CHANNEL_B) {
		if (sc->scc_wreg[SCC_CHANNEL_A].wr5 & ZSWR5_DTR)
			mbits = DML_DTR | DML_DSR;
		else
			mbits = 0;
		SCC_READ_REG_ZERO(regs, SCC_CHANNEL_B, value);
		if (value & ZSRR0_DCD)
			mbits |= DML_CAR;
	}
	switch (how) {
	case DMSET:
		mbits = bits;
		break;

	case DMBIS:
		mbits |= bits;
		break;

	case DMBIC:
		mbits &= ~bits;
		break;

	case DMGET:
		(void) splx(s);
		return (mbits);
	}
	if (line == SCC_CHANNEL_B) {
		if (mbits & DML_DTR)
			sc->scc_wreg[SCC_CHANNEL_A].wr5 |= ZSWR5_DTR;
		else
			sc->scc_wreg[SCC_CHANNEL_A].wr5 &= ~ZSWR5_DTR;
		SCC_WRITE_REG(regs, SCC_CHANNEL_A, SCC_WR5,
			sc->scc_wreg[SCC_CHANNEL_A].wr5);
	}
	if ((mbits & DML_DTR) || (sc->scc_softCAR & (1 << line)))
		sc->scc_tty[line]->t_state |= TS_CARR_ON;
	(void) splx(s);
	return (mbits);
}

/*
 * Check for carrier transition.
 */
void
scc_modem_intr(dev)
	dev_t dev;
{
	register scc_regmap_t *regs;
	register struct scc_softc *sc;
	register struct tty *tp;
	register int car, chan;
	register u_char value;
	int s;

	chan = SCCLINE(dev);
	sc = scc_cd.cd_devs[SCCUNIT(dev)];
	tp = sc->scc_tty[chan];
	regs = (scc_regmap_t *)sc->scc_pdma[chan].p_addr;
	if (chan == SCC_CHANNEL_A)
		return;
	s = spltty();
	if (sc->scc_softCAR & (1 << chan))
		car = 1;
	else {
		SCC_READ_REG_ZERO(regs, chan, value);
		car = value & ZSRR0_DCD;
	}

	/* Break on serial console drops into the debugger */
	if ((value & ZSRR0_BREAK) && CONSOLE_ON_UNIT(sc->sc_dv.dv_unit)) {
#ifdef DDB
		splx(s);		/* spl0()? */
		Debugger();
		return;
#else
		/* XXX maybe fall back to PROM? */
#endif
	}

	splx(s);
}

/*
 * Get a char off the appropriate line via. a busy wait loop.
 */
int
sccGetc(dev)
	dev_t dev;
{
	register scc_regmap_t *regs;
	register int c, line;
	register u_char value;
	int s;

	line = SCCLINE(dev);
	if (cold && scc_cons_addr) {
		regs = scc_cons_addr;
	} else {
		register struct scc_softc *sc;
		sc = scc_cd.cd_devs[SCCUNIT(dev)];
		regs = (scc_regmap_t *)sc->scc_pdma[line].p_addr;
	}

	if (!regs)
		return (0);
	s = splhigh();
	for (;;) {
		SCC_READ_REG(regs, line, SCC_RR0, value);
		if (value & ZSRR0_RX_READY) {
			SCC_READ_REG(regs, line, SCC_RR1, value);
			SCC_READ_DATA(regs, line, c);
			if (value & (ZSRR1_PE | ZSRR1_DO | ZSRR1_FE)) {
				SCC_WRITE_REG(regs, line, SCC_WR0,
				    ZSWR0_RESET_ERRORS);
				SCC_WRITE_REG(regs, SCC_CHANNEL_A, SCC_WR0,
				    ZSWR0_CLR_INTR);
			} else {
				SCC_WRITE_REG(regs, SCC_CHANNEL_A, SCC_WR0,
				    ZSWR0_CLR_INTR);
				splx(s);
				return (c & 0xff);
			}
		} else
			DELAY(10);
	}
}

/*
 * Send a char on a port, via a busy wait loop.
 */
void
sccPutc(dev, c)
	dev_t dev;
	int c;
{
	register scc_regmap_t *regs;
	register int line;
	register u_char value;
	int s;

	s = splhigh();
	line = SCCLINE(dev);
	if (cold && scc_cons_addr) {
		regs = scc_cons_addr;
	} else {
		register struct scc_softc *sc;
		sc = scc_cd.cd_devs[SCCUNIT(dev)];
		regs = (scc_regmap_t *)sc->scc_pdma[line].p_addr;
	}

	/*
	 * Wait for transmitter to be not busy.
	 */
	do {
		SCC_READ_REG(regs, line, SCC_RR0, value);
		if (value & ZSRR0_TX_READY)
			break;
		DELAY(100);
	} while (1);

	/*
	 * Send the char.
	 */
	SCC_WRITE_DATA(regs, line, c);
	tc_mb();
	splx(s);

	return;
}

/*
 * Enable/disable polling mode
 */
void
sccPollc(dev, on)
	dev_t dev;
	int on;
{
}

#ifdef	SCC_DEBUG
void
rr(msg, regs)
	char *msg;
	scc_regmap_t *regs;
{
	u_char value;
	int r0, r1, r2, r3, r10, r15;

	printf("%s: register: %lx\n", msg, regs);
#define	L(reg, r) {							\
	SCC_READ_REG(regs, SCC_CHANNEL_A, reg, value);			\
	r = value;							\
}
	L(SCC_RR0, r0);
	L(SCC_RR1, r1);
	L(ZSRR_IVEC, r2);
	L(ZSRR_IPEND, r3);
	L(SCC_RR10, r10);
	L(SCC_RR15, r15);
	printf("A: 0: %x  1: %x    2(vec): %x  3: %x  10: %x  15: %x\n",
	    r0, r1, r2, r3, r10, r15);
#undef L
#define	L(reg, r) {							\
	SCC_READ_REG(regs, SCC_CHANNEL_B, reg, value);			\
	r = value;							\
}
	L(SCC_RR0, r0);
	L(SCC_RR1, r1);
	L(ZSRR_IVEC, r2);
	L(SCC_RR10, r10);
	L(SCC_RR15, r15);
	printf("B: 0: %x  1: %x  2(state): %x        10: %x  15: %x\n",
	    r0, r1, r2, r10, r15);
}
#endif /* SCC_DEBUG */
@


1.28
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/* $OpenBSD: scc.c,v 1.27 2010/06/06 11:26:17 miod Exp $ */
d926 1
a926 7
	if (tp->t_outq.c_cc <= tp->t_lowat) {
		if (tp->t_state & TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
	}
d939 1
a939 7
		if (tp->t_outq.c_cc <= tp->t_lowat) {
			if (tp->t_state & TS_ASLEEP) {
				tp->t_state &= ~TS_ASLEEP;
				wakeup((caddr_t)&tp->t_outq);
			}
			selwakeup(&tp->t_wsel);
		}
@


1.27
log
@Nuke common.
@
text
@d1 1
a1 1
/* $OpenBSD: scc.c,v 1.26 2010/04/12 12:57:51 tedu Exp $ */
d329 1
a329 1
		tp = sc->scc_tty[cntr] = ttymalloc();
d464 1
a464 1
		tp = sc->scc_tty[line] = ttymalloc();
@


1.26
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: scc.c,v 1.25 2009/11/09 17:53:38 nicm Exp $ */
d109 2
@


1.25
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: scc.c,v 1.24 2009/10/31 12:00:05 fgsch Exp $ */
d501 1
a501 1
	error = (*linesw[tp->t_line].l_open)(dev, tp);
d523 1
a523 1
	(*linesw[tp->t_line].l_close)(tp, flag);
@


1.24
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: scc.c,v 1.23 2009/10/31 06:40:16 deraadt Exp $ */
a929 1
		KNOTE(&tp->t_wsel.si_note, 0);
a948 1
			KNOTE(&tp->t_wsel.si_note, 0);
@


1.23
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/* $OpenBSD: scc.c,v 1.22 2008/08/09 16:42:29 miod Exp $ */
d485 1
a485 1
	} else if ((tp->t_state & TS_XCLUDE) && curproc->p_ucred->cr_uid != 0)
@


1.22
log
@Pass a device name to {tc,tcds,ioasic}_intr_establish in order to get
meaningful names associated to the interrupt counters.
@
text
@d1 1
a1 1
/* $OpenBSD: scc.c,v 1.21 2007/11/06 18:20:05 miod Exp $ */
d930 1
d950 1
@


1.21
log
@Get rid of TC_IPL_xxx values and tc_intrlevel_t, and use IPL_xxx and int.
No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: scc.c,v 1.20 2004/09/19 21:34:42 mickey Exp $ */
d313 1
a313 1
	    sccintr, (void *)sc);
@


1.20
log
@constify speedtabs and make ttspeedtab() take a const struct speedtab *
@
text
@d1 1
a1 1
/* $OpenBSD: scc.c,v 1.19 2003/10/03 16:44:49 miod Exp $ */
d312 1
a312 1
	ioasic_intr_establish(parent, d->iada_cookie, TC_IPL_TTY,
@


1.19
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/* $OpenBSD: scc.c,v 1.18 2003/06/02 23:27:44 millert Exp $ */
d139 1
a139 1
struct speedtab sccspeedtab[] = {
@


1.18
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/* $OpenBSD: scc.c,v 1.17 2003/02/11 19:20:25 mickey Exp $ */
a327 2
		if (cntr == 0)
			tty_attach(tp);
a462 1
		tty_attach(tp);
@


1.17
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/* $OpenBSD: scc.c,v 1.16 2002/05/27 20:07:06 deraadt Exp $ */
d44 1
a44 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.16
log
@left over __P removals
@
text
@d1 1
a1 1
/* $OpenBSD: scc.c,v 1.15 2002/05/02 22:56:06 miod Exp $ */
d141 1
a141 1
 * Speed selections with Pclk=7.3728Mhz, clock x16
@


1.15
log
@Big TURBOchannel support catchup from NetBSD, part 1.
A few local changes and tweaks remain.

This bring DEC 3000 machines back in the game, but framebuffers are still
not supported at the moment.

Thanks to ericj@@ and nate@@ for supplying me a DEC 3000 for testing.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d335 1
a335 1
		pdp->p_fcn = (void (*)__P((struct tty*)))0;
@


1.14
log
@Cosmetic changes only, primarily making comments line up nicely after the
__P removal.
@
text
@d1 2
a2 2
/*	$OpenBSD: scc.c,v 1.13 2002/03/14 01:26:28 millert Exp $	*/
/*	$NetBSD: scc.c,v 1.28 1996/12/05 01:39:43 cgd Exp $	*/
d14 1
a14 1
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS
a66 3
#include "scc.h"

#if NSCC > 0
a80 1
#include <sys/conf.h>
a92 1
#include <machine/autoconf.h>	/* For the badaddr() proto */
d94 1
d97 1
a97 1
#include <alpha/tc/ioasicreg.h>
d103 2
a104 5
/*
 * rcons glass-tty console (as used on pmax) needs lk-201 ASCII input
 * support from the tty drivers. This is ugly and broken and won't
 * compile on Alphas.
 */
a109 4
/* QVSS-compatible in-kernel X input event parser, pointer tracker */
void	(*sccDivertXInput)(int cc);	/* X windows keyboard input routine */
void	(*sccMouseEvent)(int);		/* X windows mouse motion event routine */
void	(*sccMouseButtons)(int);	/* X windows mouse buttons event routine */
a113 8
struct pdma {
        void	*p_addr;
	char	*p_mem;
	char	*p_end;
	int	p_arg;
	void	(*p_fcn)(struct tty *tp);
};

a175 1
#ifdef __BROKEN_INDIRECT_CONFIG
a176 3
#else
int	sccmatch(struct device *, struct cfdata *, void *);
#endif
d189 7
d197 8
a204 4
		    struct scc_softc *sc);
int	sccGetc(dev_t);
void	sccPollc(dev_t, int);
void	sccPutc(dev_t, int);
a205 4
int	sccmctl(dev_t, int, int);
int	sccparam(struct tty *, struct termios *);
void	sccreset(struct scc_softc *);
void	sccstart(struct tty *);
a206 4
void	scc_modem_intr(dev_t);
#ifdef SCC_DEBUG
void	scc_rr(char *, scc_regmap_t *);
#endif
d213 1
a213 2
static struct scc_softc coldcons_softc;
static struct consdev scccons = {
a215 50
void	scc_consinit(dev_t dev, scc_regmap_t *sccaddr);
void	scc_oconsinit(struct scc_softc *, dev_t);


/*
 * Set up a given unit as a serial console device.
 * We need console output when cold, and before any device is configured.
 * Should be callable when cold, to reset the chip and set parameters
 * for a remote (serial) console or kgdb line.
 * XXX
 * As most DECstations only bring out one rs-232 lead from an SCC
 * to the bulkhead, and use the other for mouse and keyboard, we
 * only allow one unit per SCC to be console.
 */
void
scc_consinit(dev, sccaddr)
	dev_t dev;
	scc_regmap_t *sccaddr;
{
	struct scc_softc *sc;
	struct termios cterm;
	struct tty ctty;
	int s;

	/* Save address in case we're cold. */
	if (cold && scc_cons_addr == 0) {
		scc_cons_addr = sccaddr;
		sc = &coldcons_softc;
		coldcons_softc.scc_pdma[0].p_addr = sccaddr;
		coldcons_softc.scc_pdma[1].p_addr = sccaddr;
	} else {
		/* being called from sccattach() to reset console */
		sc = scc_cd.cd_devs[SCCUNIT(dev)];
	}

	/* Reset chip. */
	sccreset(sc);
	/* XXX make sure sccreset() called only once for this chip? */

	/* set console-line parameters */
	s = spltty();
	ctty.t_dev = dev;
	scccons.cn_dev = dev;
	cterm.c_cflag = CS8;
	cterm.c_ospeed = cterm.c_ispeed = 9600;
	(void) cold_sccparam(&ctty, &cterm, sc);
	*cn_tab = scccons;
	DELAY(1000);
	splx(s);
}
d222 1
a222 5
#ifdef __BROKEN_INDIRECT_CONFIG
sccmatch(parent, cfdata, aux)
#else
sccmatch(parent, cf, aux)
#endif
d224 1
a224 6
#ifdef __BROKEN_INDIRECT_CONFIG
	void *cfdata;
#else
	struct cfdata *cf;
#endif
	void *aux;
d226 1
a226 3
#ifdef __BROKEN_INDIRECT_CONFIG
	struct cfdata *cf = cfdata;
#endif
d228 1
d243 6
a248 2
	/* XXX MATCH CFLOC */
	if (cf->cf_unit >= NSCC)
d271 1
a271 1
		*(volatile u_int *)IOASIC_REG_IMSK(ioasic_base) |=
d274 1
a274 1
		*(volatile u_int *)IOASIC_REG_CSR(ioasic_base) |=
d279 1
a279 1
		*(volatile u_int *)IOASIC_REG_IMSK(ioasic_base) &=
d282 1
a282 1
		*(volatile u_int *)IOASIC_REG_CSR(ioasic_base) &=
d305 3
a307 1
	extern int cputype;
a322 5
#ifdef TK_NOTYET
	if (major(cn_tab.cn_dev) == SCCDEV && cn_tab.cn_screen == 0 &&
		SCCUNIT(cn_tab.cn_dev) == cp->pmax_unit)
		DELAY(10000);
#else
a325 1
#endif
d335 1
a335 1
		pdp->p_fcn = (void (*)(struct tty*))0;
d340 1
a340 1
	sc->scc_softCAR = 0x2;		/* XXX */
d348 1
a348 34
	if (0 /* cn_tab.cn_screen */) {
		if (1 /* cn_tab.cn_kbdgetc == sccGetc */) {
			if (sc->sc_dv.dv_unit == 1) {
				s = spltty();
				ctty.t_dev = makedev(SCCDEV, SCCKBD_PORT);
				cterm.c_cflag = CS8;
				cterm.c_ospeed = cterm.c_ispeed = 4800;
				(void) sccparam(&ctty, &cterm);
				DELAY(10000);
#ifdef notyet
				/*
				 * For some reason doing this hangs the 3min
				 * during booting. Fortunately the keyboard
				 * works ok without it.
				 */
				KBDReset(ctty.t_dev, sccPutc);
#endif
				DELAY(10000);
				splx(s);
			} else if (sc->sc_dv.dv_unit == 0) {
				s = spltty();
				ctty.t_dev = makedev(SCCDEV, SCCMOUSE_PORT);
				cterm.c_cflag = CS8 | PARENB | PARODD;
				cterm.c_ospeed = cterm.c_ispeed = 4800;
				(void) sccparam(&ctty, &cterm);
#ifdef TK_NOTYET
				DELAY(10000);
				MouseInit(ctty.t_dev, sccPutc, sccGetc);
				DELAY(10000);
#endif
				splx(s);
			}
		}
	} else if (1 /* SCCUNIT(cn_tab.cn_dev) == sc->sc_dv.dv_unit */) {
a349 2
		ctty.t_dev = makedev(SCCDEV,
		    sc->sc_dv.dv_unit == 0 ? SCCCOMM2_PORT : SCCCOMM3_PORT);
d352 3
a354 1
		(void) sccparam(&ctty, &cterm);
a355 3
#ifdef TK_NOTYET
		cn_tab.cn_disabled = 0;
#endif
d365 2
d370 1
a370 1
		printf(": console\n");
d454 1
a474 1
		tp->t_state |= TS_WOPEN;
d476 1
d494 1
a494 1
	(void) sccmctl(dev, DML_DTR, DMSET);
d499 4
a502 2
		if ((error = ttysleep(tp, (caddr_t)&tp->t_rawq, TTIPRI | PCATCH,
		    ttopen, 0)) != 0)
d508 3
a510 1
	return ((*linesw[tp->t_line].l_open)(dev, tp));
d533 1
a533 1
		(void) sccmctl(dev, 0, DMSET);
d615 1
a615 1
		(void) sccmctl(dev, DML_DTR|DML_RTS, DMBIS);
d619 1
a619 1
		(void) sccmctl(dev, DML_DTR|DML_RTS, DMBIC);
d623 1
a623 1
		(void) sccmctl(dev, *(int *)data, DMSET);
d627 1
a627 1
		(void) sccmctl(dev, *(int *)data, DMBIS);
d631 1
a631 1
		(void) sccmctl(dev, *(int *)data, DMBIC);
d635 1
a635 1
		*(int *)data = sccmctl(dev, 0, DMGET);
d658 1
a658 1
	return cold_sccparam(tp, t, sc);
d666 1
a666 1
cold_sccparam(tp, t, sc)
d670 1
a672 1
	register int line;
a690 11
#ifdef HAVE_RCONS
	if (cn_tab->cn_getc == LKgetc) {
		if (minor(tp->t_dev) == SCCKBD_PORT) {
			cflag = CS8;
			ospeed = ttspeedtab(4800, sccspeedtab);
		} else if (minor(tp->t_dev) == SCCMOUSE_PORT) {
			cflag = CS8 | PARENB | PARODD;
			ospeed = ttspeedtab(4800, sccspeedtab);
		}
	} else if (tp->t_dev == cn_tab->cn_dev)
#endif /*HAVE_RCONS*/
d696 1
a696 1
		(void) sccmctl(tp->t_dev, 0, DMSET);	/* hang up line */
a699 1
	line = SCCLINE(tp->t_dev);
d784 1
a784 2
#ifdef alpha
	if (SCCUNIT(tp->t_dev) == 1) {
a787 1
#endif
a805 1
#ifdef alpha
a806 1
#endif	/*alpha*/
d858 1
a858 4
			if (tp->t_line)
				(*linesw[tp->t_line].l_start)(tp);
			else
				sccstart(tp);
a888 33
		/*
		 * Keyboard needs special treatment.
		 */
		if (tp == scctty(makedev(SCCDEV, SCCKBD_PORT)) /* && cn_tab.cn_screen */) {
#ifdef KADB
			if (cc == LK_DO) {
				spl0();
				kdbpanic();
				return 0;	/* XXX */
			}
#endif
#ifdef DEBUG
			debugChar = cc;
#endif
			if (sccDivertXInput) {
				(*sccDivertXInput)(cc);
				continue;
			}
#ifdef TK_NOTYET
			if ((cc = kbdMapChar(cc)) < 0)
				continue;
#endif
		/*
		 * Now for mousey
		 */
		} else if (tp == scctty(makedev(SCCDEV, SCCMOUSE_PORT)) &&
		    sccMouseButtons) {
#ifdef HAVE_RCONS
			/*XXX*/
			mouseInput(cc);
#endif
			continue;
		}
d941 1
a941 1
	if (tp == scctty(makedev(SCCDEV,SCCKBD_PORT)) /* && cn_tab.cn_screen */) {
d1015 3
a1017 3
sccmctl(dev, bits, how)
	dev_t dev;
	int bits, how;
a1018 1
	register struct scc_softc *sc;
d1020 1
a1020 1
	register int line, mbits;
a1023 2
	sc = scc_cd.cd_devs[SCCUNIT(dev)];
	line = SCCLINE(dev);
d1055 1
a1055 1
		splx(s);
d1068 1
a1068 1
	splx(s);
d1100 8
a1107 13
	/*
	 * The pmax driver follows carrier-detect. The Alpha does not.
	 * XXX Why doesn't the Alpha driver follow carrier-detect?
	 * (in the Alpha driver, this is an "#ifdef notdef").
	 * Is it related to  console handling?
	 */
#ifdef notdef
	if (car) {
		/* carrier present */
		if (!(tp->t_state & TS_CARR_ON))
			(void)(*linesw[tp->t_line].l_modem)(tp, 1);
	} else if (tp->t_state & TS_CARR_ON)
		(void)(*linesw[tp->t_line].l_modem)(tp, 0);
d1109 2
a1136 1

a1137 1

a1172 1

d1214 1
a1214 1
scc_rr(msg, regs)
a1247 1
#endif /* NSCC */
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: scc.c,v 1.12 2002/02/15 20:45:29 nordin Exp $	*/
d118 2
a119 2
void	(*sccDivertXInput)(int cc); /* X windows keyboard input routine */
void	(*sccMouseEvent)(int);	/* X windows mouse motion event routine */
@


1.12
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scc.c,v 1.11 2002/01/16 20:50:16 miod Exp $	*/
d118 3
a120 3
void	(*sccDivertXInput) __P((int cc)); /* X windows keyboard input routine */
void	(*sccMouseEvent) __P((int));	/* X windows mouse motion event routine */
void	(*sccMouseButtons) __P((int));	/* X windows mouse buttons event routine */
d130 1
a130 1
	void	(*p_fcn) __P((struct tty *tp));
d196 1
a196 1
int	sccmatch  __P((struct device *, void *, void *));
d198 1
a198 1
int	sccmatch  __P((struct device *, struct cfdata *, void *));
d200 1
a200 1
void	sccattach __P((struct device *, struct device *, void *));
d212 12
a223 12
int	cold_sccparam __P((struct tty *, struct termios *,
		    struct scc_softc *sc));
int	sccGetc __P((dev_t));
void	sccPollc __P((dev_t, int));
void	sccPutc __P((dev_t, int));
int	sccintr __P((void *));
int	sccmctl __P((dev_t, int, int));
int	sccparam __P((struct tty *, struct termios *));
void	sccreset __P((struct scc_softc *));
void	sccstart __P((struct tty *));
void	scc_alphaintr __P((int));
void	scc_modem_intr __P((dev_t));
d225 1
a225 1
void	scc_rr __P((char *, scc_regmap_t *));
d237 2
a238 2
void	scc_consinit __P((dev_t dev, scc_regmap_t *sccaddr));
void	scc_oconsinit __P((struct scc_softc *, dev_t));
d416 1
a416 1
		pdp->p_fcn = (void (*)__P((struct tty*)))0;
@


1.11
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: scc.c,v 1.10 2001/06/25 00:56:10 ericj Exp $	*/
d1220 1
a1220 1
		(void) splx(s);
d1233 1
a1233 1
	(void) splx(s);
@


1.10
log
@
remove dependency on pmax tree. cleanup a little while here
@
text
@d1 1
a1 1
/*	$OpenBSD: scc.c,v 1.9 2001/06/25 00:43:07 mickey Exp $	*/
a82 1
#include <sys/map.h>
@


1.10.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: scc.c,v 1.11 2002/01/16 20:50:16 miod Exp $	*/
d83 1
@


1.10.4.2
log
@Sync UBC branch to -current
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* $NetBSD: scc.c,v 1.58 2002/03/17 19:40:27 atatat Exp $ */
d14 1
a14 1
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
d67 3
d84 1
d97 1
a98 1
#include <machine/conf.h>
d101 1
a101 1
#include <dev/tc/ioasicreg.h>
d107 5
a111 2
#define raster_console() 1	/* Treat test for cn_screen as true */
#define CONSOLE_ON_UNIT(unit) 0	/* No raster console on Alphas */
d117 4
d125 8
d195 6
a200 2
int	sccmatch(struct device *, void *, void *);
void	sccattach(struct device *, struct device *, void *);
d212 12
a223 10
int		sccGetc(dev_t);
void		sccPutc(dev_t, int);
void		sccPollc(dev_t, int);
int		sccparam(struct tty *, struct termios *);
void		sccstart(struct tty *);

int	sccmctl(struct scc_softc *, int, int, int);
int	cold_sccparam(struct tty *, struct termios *,
		    struct scc_softc *sc, int line);

d225 1
a225 1
void	rr(char *, scc_regmap_t *);
a226 5
void	scc_modem_intr(dev_t);
void	sccreset(struct scc_softc *);

int	sccintr(void *);
void	scc_alphaintr(int);
d233 2
a234 1
struct consdev scccons = {
d237 50
d293 5
a297 1
sccmatch(parent, vcf, aux)
d299 6
a304 1
	void *vcf, *aux;
d306 3
a308 1
	extern struct cfdriver ioasic_cd;		/* XXX */
a309 1
	struct cfdata *cf = vcf;
d324 2
a325 6
	/*
	 * Check user-specified offset against the ioasic offset.
	 * Allow it to be wildcarded.
	 */
	if (cf->cf_loc[0] != -1 &&
	    cf->cf_loc[0] != d->iada_offset)
d348 1
a348 1
		*(volatile u_int *)(ioasic_base + IOASIC_IMSK) |=
d351 1
a351 1
		*(volatile u_int *)(ioasic_base + IOASIC_CSR) |=
d356 1
a356 1
		*(volatile u_int *)(ioasic_base + IOASIC_IMSK) &=
d359 1
a359 1
		*(volatile u_int *)(ioasic_base + IOASIC_CSR) &=
d382 1
a382 3
	int unit;

	unit = sc->sc_dv.dv_unit;
d398 5
d406 1
d416 1
a416 1
		pdp->p_fcn = (void (*)(struct tty*))0;
d421 1
a421 1
	sc->scc_softCAR = sc->sc_dv.dv_cfdata->cf_flags | 0x2;	/* XXX */
d429 34
a462 1
	if (1 /* SCCUNIT(cn_tab.cn_dev) == sc->sc_dv.dv_unit */) {
d464 2
d468 1
a468 3
		(void) cold_sccparam(&ctty, &cterm, sc,
		    SCCLINE((sc->sc_dv.dv_unit == 0) ?
			    SCCCOMM2_PORT : SCCCOMM3_PORT));
d470 3
a481 2
		if (alpha_donot_kludge_scc)
			printf("\nSWITCHING TO SERIAL CONSOLE!\n");
d485 1
a485 1
		printf("%s console\n", alpha_donot_kludge_scc ? "\n***" : ":");
a568 1
	int firstopen = 0;
d589 1
a590 1
		firstopen = 1;
d608 1
a608 1
	(void) sccmctl(sc, SCCLINE(dev), DML_DTR, DMSET);
d613 2
a614 4
		error = ttysleep(tp, (caddr_t)&tp->t_rawq, TTIPRI | PCATCH,
		    ttopen, 0);
		tp->t_state &= ~TS_WOPEN;
		if (error != 0)
d620 1
a620 3
	error = (*linesw[tp->t_line].l_open)(dev, tp);

	return (error);
d643 1
a643 1
		(void) sccmctl(sc, line, 0, DMSET);
d725 1
a725 1
		(void) sccmctl(sc, line, DML_DTR|DML_RTS, DMBIS);
d729 1
a729 1
		(void) sccmctl(sc, line, DML_DTR|DML_RTS, DMBIC);
d733 1
a733 1
		(void) sccmctl(sc, line, *(int *)data, DMSET);
d737 1
a737 1
		(void) sccmctl(sc, line, *(int *)data, DMBIS);
d741 1
a741 1
		(void) sccmctl(sc, line, *(int *)data, DMBIC);
d745 1
a745 1
		*(int *)data = sccmctl(sc, line, 0, DMGET);
d768 1
a768 1
	return cold_sccparam(tp, t, sc, SCCLINE(tp->t_dev));
d776 1
a776 1
cold_sccparam(tp, t, sc, line)
a779 1
	register int line;
d782 1
d801 11
d817 1
a817 1
		(void) sccmctl(sc, line, 0, DMSET);	/* hang up line */
d821 1
d906 2
a907 1
	if (sc->sc_dv.dv_unit == 1) {
d911 1
d930 1
d932 1
d984 4
a987 1
			(*linesw[tp->t_line].l_start)(tp);
d1018 33
d1103 1
a1103 1
	if (tp == scctty(makedev(SCCDEV,SCCKBD_PORT)) && raster_console()) {
d1177 3
a1179 3
sccmctl(sc, line, bits, how)
	struct scc_softc *sc;
	int line, bits, how;
d1181 1
d1183 1
a1183 1
	register int mbits;
d1187 2
d1265 13
a1277 8
	/* Break on serial console drops into the debugger */
	if ((value & ZSRR0_BREAK) && CONSOLE_ON_UNIT(sc->sc_dv.dv_unit)) {
#ifdef DDB
		splx(s);		/* spl0()? */
		Debugger();
		return;
#else
		/* XXX maybe fall back to PROM? */
a1278 2
	}

d1305 1
d1307 1
d1343 1
d1385 1
a1385 1
rr(msg, regs)
d1419 1
@


1.10.4.3
log
@sync
@
text
@d141 1
a141 1
 * Speed selections with Pclk=7.3728MHz, clock x16
@


1.9
log
@cold is in systm now
@
text
@d1 1
a1 1
/*	$OpenBSD: scc.c,v 1.8 2001/04/17 04:30:46 aaron Exp $	*/
d68 1
a93 4
#include <pmax/include/pmioctl.h>

#include <pmax/dev/device.h>
#include <pmax/dev/pdma.h>
a96 3
#if 0
#include <pmax/dev/fbreg.h>
#endif
a112 4
#ifdef pmax
#define HAVE_RCONS
extern int pending_remcons;
#endif
d126 8
a281 4
#ifdef pmax
	/* XXX -- why on pmax, not on Alpha? */
	cterm.c_cflag  |= CLOCAL;
#endif
a288 24
#ifndef alpha
void
scc_oconsinit(sc, dev)
	struct scc_softc *sc;
	dev_t dev;
{
	struct termios cterm;
	struct tty ctty;
	int s;

	s = spltty();
	ctty.t_dev = dev;
	cterm.c_cflag = CS8;
#ifdef pmax
	/* XXX -- why on pmax, not on Alpha? */
	cterm.c_cflag  |= CLOCAL;
#endif
	cterm.c_ospeed = cterm.c_ispeed = 9600;
	(void) sccparam(&ctty, &cterm);
	DELAY(1000);
	splx(s);
}
#endif

a339 1
#ifdef alpha
a366 1
#endif /* alpha */
a435 4
#ifdef pmax
				/* XXX -- why on pmax, not on Alpha? */
				cterm.c_cflag |= CLOCAL;
#endif /* pmax */
a974 3
#ifdef pmax	/* Alpha handles the 1.6 msec settle time in hardware */
			DELAY(2);
#endif
a1145 3
#ifdef pmax /* Alpha handles the 1.6 msec settle time in hardware */
		DELAY(2);
#endif
d1306 1
a1306 2
#ifdef pmax
	/*s = spltty(); */	/* XXX  why different spls? */
d1308 1
a1308 3
#else
	s = splhigh();
#endif
a1342 3
#ifdef pmax
	s = spltty();	/* XXX  why different spls? */
#else
d1344 1
a1344 1
#endif
@


1.8
log
@Implement cnbell(), an optional entrypoint that rings the console bell; from
NetBSD. deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: scc.c,v 1.7 1997/01/24 19:58:15 niklas Exp $	*/
a234 1
extern  int cold;
@


1.7
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: scc.c,v 1.6 1996/10/30 22:41:11 niklas Exp $	*/
d239 1
a239 1
	NULL, NULL, sccGetc, sccPutc, sccPollc, NODEV, 0
@


1.7.14.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: scc.c,v 1.8 2001/04/17 04:30:46 aaron Exp $	*/
d239 1
a239 1
	NULL, NULL, sccGetc, sccPutc, sccPollc, NULL, NODEV, 0
@


1.7.14.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: scc.c,v 1.7.14.1 2001/04/18 16:01:51 niklas Exp $	*/
a67 1

d93 4
d100 3
d119 4
a135 8
struct pdma {
        void	*p_addr;
	char	*p_mem;
	char	*p_end;
	int	p_arg;
	void	(*p_fcn) __P((struct tty *tp));
};

d235 1
d285 4
d296 24
d371 1
d399 1
d469 4
d1012 3
d1186 3
d1349 4
a1352 1

d1354 1
a1354 1

d1389 3
d1393 1
a1393 1

@


1.7.14.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d83 1
d1221 1
a1221 1
		splx(s);
d1234 1
a1234 1
	splx(s);
@


1.7.14.4
log
@Merge in -current from about a week ago
@
text
@d118 3
a120 3
void	(*sccDivertXInput)(int cc);	/* X windows keyboard input routine */
void	(*sccMouseEvent)(int);		/* X windows mouse motion event routine */
void	(*sccMouseButtons)(int);	/* X windows mouse buttons event routine */
d130 1
a130 1
	void	(*p_fcn)(struct tty *tp);
d196 1
a196 1
int	sccmatch(struct device *, void *, void *);
d198 1
a198 1
int	sccmatch(struct device *, struct cfdata *, void *);
d200 1
a200 1
void	sccattach(struct device *, struct device *, void *);
d212 12
a223 12
int	cold_sccparam(struct tty *, struct termios *,
		    struct scc_softc *sc);
int	sccGetc(dev_t);
void	sccPollc(dev_t, int);
void	sccPutc(dev_t, int);
int	sccintr(void *);
int	sccmctl(dev_t, int, int);
int	sccparam(struct tty *, struct termios *);
void	sccreset(struct scc_softc *);
void	sccstart(struct tty *);
void	scc_alphaintr(int);
void	scc_modem_intr(dev_t);
d225 1
a225 1
void	scc_rr(char *, scc_regmap_t *);
d237 2
a238 2
void	scc_consinit(dev_t dev, scc_regmap_t *sccaddr);
void	scc_oconsinit(struct scc_softc *, dev_t);
d416 1
a416 1
		pdp->p_fcn = (void (*)(struct tty*))0;
@


1.7.14.5
log
@Sync the SMP branch with 3.3
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* $NetBSD: scc.c,v 1.58 2002/03/17 19:40:27 atatat Exp $ */
d14 1
a14 1
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
d67 3
d84 1
d97 1
a98 1
#include <machine/conf.h>
d101 1
a101 1
#include <dev/tc/ioasicreg.h>
d107 5
a111 2
#define raster_console() 1	/* Treat test for cn_screen as true */
#define CONSOLE_ON_UNIT(unit) 0	/* No raster console on Alphas */
d117 4
d125 8
d160 1
a160 1
 * Speed selections with Pclk=7.3728MHz, clock x16
d195 1
d197 3
a211 7
int		sccGetc(dev_t);
void		sccPutc(dev_t, int);
void		sccPollc(dev_t, int);
int		sccparam(struct tty *, struct termios *);
void		sccstart(struct tty *);

int	sccmctl(struct scc_softc *, int, int, int);
d213 11
a223 2
		    struct scc_softc *sc, int line);

d225 1
a225 1
void	rr(char *, scc_regmap_t *);
a226 5
void	scc_modem_intr(dev_t);
void	sccreset(struct scc_softc *);

int	sccintr(void *);
void	scc_alphaintr(int);
d233 2
a234 1
struct consdev scccons = {
d237 50
d293 5
a297 1
sccmatch(parent, vcf, aux)
d299 6
a304 1
	void *vcf, *aux;
d306 3
a308 1
	extern struct cfdriver ioasic_cd;		/* XXX */
a309 1
	struct cfdata *cf = vcf;
d324 2
a325 6
	/*
	 * Check user-specified offset against the ioasic offset.
	 * Allow it to be wildcarded.
	 */
	if (cf->cf_loc[0] != -1 &&
	    cf->cf_loc[0] != d->iada_offset)
d348 1
a348 1
		*(volatile u_int *)(ioasic_base + IOASIC_IMSK) |=
d351 1
a351 1
		*(volatile u_int *)(ioasic_base + IOASIC_CSR) |=
d356 1
a356 1
		*(volatile u_int *)(ioasic_base + IOASIC_IMSK) &=
d359 1
a359 1
		*(volatile u_int *)(ioasic_base + IOASIC_CSR) &=
d382 1
a382 3
	int unit;

	unit = sc->sc_dv.dv_unit;
d398 5
d406 1
d421 1
a421 1
	sc->scc_softCAR = sc->sc_dv.dv_cfdata->cf_flags | 0x2;	/* XXX */
d429 34
a462 1
	if (1 /* SCCUNIT(cn_tab.cn_dev) == sc->sc_dv.dv_unit */) {
d464 2
d468 1
a468 3
		(void) cold_sccparam(&ctty, &cterm, sc,
		    SCCLINE((sc->sc_dv.dv_unit == 0) ?
			    SCCCOMM2_PORT : SCCCOMM3_PORT));
d470 3
a481 2
		if (alpha_donot_kludge_scc)
			printf("\nSWITCHING TO SERIAL CONSOLE!\n");
d485 1
a485 1
		printf("%s console\n", alpha_donot_kludge_scc ? "\n***" : ":");
a568 1
	int firstopen = 0;
d589 1
a590 1
		firstopen = 1;
d608 1
a608 1
	(void) sccmctl(sc, SCCLINE(dev), DML_DTR, DMSET);
d613 2
a614 4
		error = ttysleep(tp, (caddr_t)&tp->t_rawq, TTIPRI | PCATCH,
		    ttopen, 0);
		tp->t_state &= ~TS_WOPEN;
		if (error != 0)
d620 1
a620 3
	error = (*linesw[tp->t_line].l_open)(dev, tp);

	return (error);
d643 1
a643 1
		(void) sccmctl(sc, line, 0, DMSET);
d725 1
a725 1
		(void) sccmctl(sc, line, DML_DTR|DML_RTS, DMBIS);
d729 1
a729 1
		(void) sccmctl(sc, line, DML_DTR|DML_RTS, DMBIC);
d733 1
a733 1
		(void) sccmctl(sc, line, *(int *)data, DMSET);
d737 1
a737 1
		(void) sccmctl(sc, line, *(int *)data, DMBIS);
d741 1
a741 1
		(void) sccmctl(sc, line, *(int *)data, DMBIC);
d745 1
a745 1
		*(int *)data = sccmctl(sc, line, 0, DMGET);
d768 1
a768 1
	return cold_sccparam(tp, t, sc, SCCLINE(tp->t_dev));
d776 1
a776 1
cold_sccparam(tp, t, sc, line)
a779 1
	register int line;
d782 1
d801 11
d817 1
a817 1
		(void) sccmctl(sc, line, 0, DMSET);	/* hang up line */
d821 1
d906 2
a907 1
	if (sc->sc_dv.dv_unit == 1) {
d911 1
d930 1
d932 1
d984 4
a987 1
			(*linesw[tp->t_line].l_start)(tp);
d1018 33
d1103 1
a1103 1
	if (tp == scctty(makedev(SCCDEV,SCCKBD_PORT)) && raster_console()) {
d1177 3
a1179 3
sccmctl(sc, line, bits, how)
	struct scc_softc *sc;
	int line, bits, how;
d1181 1
d1183 1
a1183 1
	register int mbits;
d1187 2
d1220 1
a1220 1
		(void) splx(s);
d1233 1
a1233 1
	(void) splx(s);
d1265 13
a1277 8
	/* Break on serial console drops into the debugger */
	if ((value & ZSRR0_BREAK) && CONSOLE_ON_UNIT(sc->sc_dv.dv_unit)) {
#ifdef DDB
		splx(s);		/* spl0()? */
		Debugger();
		return;
#else
		/* XXX maybe fall back to PROM? */
a1278 2
	}

d1305 1
d1307 1
d1343 1
d1385 1
a1385 1
rr(msg, regs)
d1419 1
@


1.7.14.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: scc.c,v 1.7.14.5 2003/03/27 23:18:06 niklas Exp $ */
d44 5
a48 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.14.7
log
@Merge of -current from two weeks ago into the SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d328 2
d465 1
@


1.6
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 2
a2 2
/*	$OpenBSD: scc.c,v 1.26 1996/10/16 05:07:57 jonathan Exp $	*/
/*	$NetBSD: scc.c,v 1.26 1996/10/16 05:07:57 jonathan Exp $	*/
a110 2
extern void ttrstrt	__P((void *));

d198 7
a204 4
static int	sccmatch  __P((struct device * parent, void *cfdata,
		    void *aux));
static void	sccattach __P((struct device *parent, struct device *self,
		    void *aux));
d213 3
a215 14
int		sccopen __P((dev_t, int, int, struct proc *));
int		sccclose __P((dev_t, int, int, struct proc *));
int		sccread __P((dev_t, struct uio *, int));
int		sccwrite __P((dev_t, struct uio *, int));
struct tty	*scctty __P((dev_t));
int		sccioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
void		sccstop __P((struct tty *, int));
int		sccGetc __P((dev_t));
void		sccPutc __P((dev_t, int));
void		sccPollc __P((dev_t, int));
int		sccparam __P((struct tty *, struct termios *));
void		sccstart __P((struct tty *));
int		sccmctl __P((dev_t, int, int));
static int	cold_sccparam __P((struct tty *, struct termios *,
d217 10
a226 1

d228 1
a228 1
static void	rr __P((char *, scc_regmap_t *));
a229 6
static void	scc_modem_intr __P((dev_t));
static void	sccreset __P((struct scc_softc *));

int	sccintr __P((void *));
void	scc_alphaintr __P((int));

d241 2
a242 2
void		scc_consinit __P((dev_t dev, scc_regmap_t *sccaddr));
void		scc_oconsinit __P((struct scc_softc *, dev_t));
d296 1
d318 1
d325 1
d327 3
d331 1
d333 3
d338 1
d340 1
d534 1
a534 1
static void
d813 1
a813 1
static int
d1001 1
a1001 1
			return 0;	/* XXX */
d1199 1
a1199 1
void
d1217 1
d1284 1
a1284 1
static void
d1434 2
a1435 2
static void
rr(msg, regs)
@


1.5
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: scc.c,v 1.16.4.2 1996/06/03 19:44:41 cgd Exp $	*/
/*	$NetBSD: scc.c,v 1.16.4.2 1996/06/03 19:44:41 cgd Exp $	*/
d4 1
a4 1
/* 
d7 1
a7 1
 * 
d13 2
a14 2
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS 
d17 1
a17 1
 * 
d19 1
a19 1
 * 
d24 1
a24 1
 * 
d104 1
d116 11
a126 1
#define	NSCCLINE 	(NSCC*2)
d130 4
a133 4
struct	tty *scc_tty[NSCCLINE];
void	(*sccDivertXInput)();	/* X windows keyboard input routine */
void	(*sccMouseEvent)();	/* X windows mouse motion event routine */
void	(*sccMouseButtons)();	/* X windows mouse buttons event routine */
d148 1
d150 7
d162 1
a162 1
 *	BRGconstant = 	---------------------------  -  2
d181 1
d183 1
d185 3
a187 1
	{ 38400,	4,	},
d200 4
a203 3
static int      sccmatch(struct device *, void *, void *);
static void     sccattach(struct device *, struct device *, void *);

d212 7
d225 2
d237 88
d327 1
a327 1
 * Return true if found and initialized ok.
d339 6
a344 1
	/* XXX BUS TYPE? */
d347 2
a348 1
	if (strncmp(d->iada_modname, "z8530   ", TC_ROM_LLEN))
d366 5
d392 1
a392 1
	wbflush();
d394 1
d398 3
a400 3
        struct device *parent;
        struct device *self;
        void *aux;
d408 3
a410 3
        struct termios cterm;
        struct tty ctty;
        int s;
d421 1
a421 1
	    sccintr, (void *)(long)sc->sc_dv.dv_unit);
d441 1
a441 1
		tp = scc_tty[sc->sc_dv.dv_unit * 2 + cntr] = ttymalloc();
d445 1
a445 1
		pdp->p_fcn = (void (*)())0;
d449 1
d452 1
a452 1
	/* reset chip */
d455 16
a470 12
        /*
         * Special handling for consoles.
         */
        if (0 /* cn_tab.cn_screen */) {
                if (1 /* cn_tab.cn_kbdgetc == sccGetc */) {
                        if (sc->sc_dv.dv_unit == 1) {
                                s = spltty();
                                ctty.t_dev = makedev(SCCDEV, SCCKBD_PORT);
                                cterm.c_cflag = CS8;
                                cterm.c_ospeed = cterm.c_ispeed = 4800;
                                (void) sccparam(&ctty, &cterm);
                                DELAY(10000);
d472 15
a486 15
                                /*
                                 * For some reason doing this hangs the 3min
                                 * during booting. Fortunately the keyboard
                                 * works ok without it.
                                 */
                                KBDReset(ctty.t_dev, sccPutc);
#endif
                                DELAY(10000);
                                splx(s);
                        } else if (sc->sc_dv.dv_unit == 0) {
                                s = spltty();
                                ctty.t_dev = makedev(SCCDEV, SCCMOUSE_PORT);
                                cterm.c_cflag = CS8 | PARENB | PARODD;
                               cterm.c_ospeed = cterm.c_ispeed = 4800;
                               (void) sccparam(&ctty, &cterm);
d488 15
a502 15
                                DELAY(10000);
                                MouseInit(ctty.t_dev, sccPutc, sccGetc);
                                DELAY(10000);
#endif
                                splx(s);
                        }
                }
        } else if (1 /* SCCUNIT(cn_tab.cn_dev) == sc->sc_dv.dv_unit */) {
                s = spltty();
                ctty.t_dev = makedev(SCCDEV,
                    sc->sc_dv.dv_unit == 0 ? SCCCOMM2_PORT : SCCCOMM3_PORT);
                cterm.c_cflag = (TTYDEF_CFLAG & ~(CSIZE | PARENB)) | CS8;
                cterm.c_ospeed = cterm.c_ispeed = 9600;
                (void) sccparam(&ctty, &cterm);
                DELAY(1000);
d504 1
a504 1
                cn_tab.cn_disabled = 0;
d506 2
a507 2
                splx(s);
        }
a514 3
		static struct consdev scccons = {
		    NULL, NULL, sccGetc, sccPutc, sccPollc, NODEV, 0
		};
d613 1
a613 1
	tp = scc_tty[minor(dev)];
d615 1
a615 1
		tp = scc_tty[minor(dev)] = ttymalloc();
d644 1
a644 1
	       !(tp->t_state & TS_CARR_ON)) {
a666 1
	tp = scc_tty[minor(dev)];
d668 1
d686 1
d689 2
a690 1
	tp = scc_tty[minor(dev)];
d700 1
d703 2
a704 1
	tp = scc_tty[minor(dev)];
d712 3
a714 1
        struct tty *tp = scc_tty[minor(dev)];		/* XXX */
d716 4
a719 1
        return (tp);
d735 3
a737 1
	tp = scc_tty[minor(dev)];
a744 2
	line = SCCLINE(dev);
	sc = scc_cd.cd_devs[SCCUNIT(dev)];
d787 5
d798 16
d820 3
a822 2
        if (t->c_ispeed && t->c_ispeed != t->c_ospeed)
                return (EINVAL);
d824 6
a829 6
        if (ospeed < 0)
                return (EINVAL);
        /* and copy to tty */
        tp->t_ispeed = t->c_ispeed;
        tp->t_ospeed = t->c_ospeed;
        tp->t_cflag = cflag;
d834 2
a835 1
	if (0 /* cn_tab.cn_screen */) {
d843 3
a845 1
	} else /* if (tp->t_dev == cn_tab.cn_dev) */ {
a853 1
	sc = scc_cd.cd_devs[SCCUNIT(tp->t_dev)];
d857 5
d891 1
a891 1
	wvalue = sc->scc_wreg[line].wr5 & (ZSWR5_DTR | ZSWR5_RTS);
d916 4
d922 2
a923 1
	{int otherline = (line + 1) & 1;
d938 3
a940 3
	if (SCCUNIT(tp->t_dev) != 1) {
		value = ZSWR15_BREAK_IE | ZSWR15_CTS_IE | ZSWR15_DCD_IE;
	} else {
d943 4
d961 1
d963 1
d965 1
d970 1
d975 2
a976 2
sccintr(xxxunit)
	void *xxxunit;
d978 2
a979 1
	register int unit = (long)xxxunit;
a982 1
	register struct scc_softc *sc;
d986 1
a986 1
	sc = scc_cd.cd_devs[unit];
d996 1
a996 1
			return;
d1003 1
a1003 1
		tp = scc_tty[unit | chan];
d1007 4
a1010 1
			wbflush();
d1031 1
a1031 1
				wbflush();
d1041 1
a1041 1
		tp = scc_tty[unit | chan];
d1057 1
a1057 1
		if (tp == scc_tty[SCCKBD_PORT] /* && cn_tab.cn_screen */) {
d1062 1
a1062 1
				return;
d1079 5
a1083 34
		} else if (tp == scc_tty[SCCMOUSE_PORT] && sccMouseButtons) {
#if 0
			register MouseReport *mrp;
			static MouseReport currentRep;

			mrp = &currentRep;
			mrp->byteCount++;
			if (cc & MOUSE_START_FRAME) {
				/*
				 * The first mouse report byte (button state).
				 */
				mrp->state = cc;
				if (mrp->byteCount > 1)
					mrp->byteCount = 1;
			} else if (mrp->byteCount == 2) {
				/*
				 * The second mouse report byte (delta x).
				 */
				mrp->dx = cc;
			} else if (mrp->byteCount == 3) {
				/*
				 * The final mouse report byte (delta y).
				 */
				mrp->dy = cc;
				mrp->byteCount = 0;
				if (mrp->dx != 0 || mrp->dy != 0) {
					/*
					 * If the mouse moved,
					 * post a motion event.
					 */
					(*sccMouseEvent)(mrp);
				}
				(*sccMouseButtons)(mrp);
			}
d1104 1
a1104 1
			SCC_CHANNEL_A : SCC_CHANNEL_B;
d1109 1
d1139 1
a1139 1
	if (tp == scc_tty[SCCKBD_PORT] /* && cn_tab.cn_screen */) {
a1156 13
#if 0
	if (tp->t_flags & (RAW|LITOUT))
		cc = ndqb(&tp->t_outq, 0);
	else {
		cc = ndqb(&tp->t_outq, 0200);
		if (cc == 0) {
			cc = getc(&tp->t_outq);
			timeout(ttrstrt, (void *)tp, (cc & 0x7f) + 6);
			tp->t_state |= TS_TIMEOUT;
			goto out;
		}
	}
#else
d1158 1
a1158 1
#endif
d1181 3
d1185 1
a1185 1
	wbflush();
d1194 1
a1194 1
int
a1211 2

	return 0;				/* XXX should be void */
d1270 1
a1270 1
		scc_tty[minor(dev)]->t_state |= TS_CARR_ON;
d1289 1
d1291 1
a1291 2
	tp = scc_tty[minor(dev)];
	chan = SCCLINE(dev);
d1302 7
a1329 1
	struct scc_softc *sc;
d1333 8
a1340 2
	sc = scc_cd.cd_devs[SCCUNIT(dev)];
	regs = (scc_regmap_t *)sc->scc_pdma[line].p_addr;
d1343 4
d1348 1
a1380 1
	struct scc_softc *sc;
d1383 3
d1387 1
d1389 7
a1395 2
	sc = scc_cd.cd_devs[SCCUNIT(dev)];
	regs = (scc_regmap_t *)sc->scc_pdma[line].p_addr;
d1411 1
a1411 1
	wbflush();
d1462 1
a1462 1
#endif
@


1.4
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.3
log
@from netbsd:
machine-independent TurboChannel bus configuration.  These files
deal with stuff like:
        (1) configuring built-in devices,
        (2) looking at TC slots configuring any devices found.
The lists of slots, slot locations, etc. and built-in devices
are provided by machine-dependent code.  Interrupt handling
is also provided by machine-dependent code, but the MD code provides
hooks so that standard names for 'establish' and 'disestablish'
can be used in drivers.

This code requires <machine/tc_machdep.h>, which defines some
portability types specific to the TurboChannel bus code.
@
text
@d1 1
a1 1
/*	$NetBSD: scc.c,v 1.11 1995/12/20 00:43:24 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1991,1990,1989,1994,1995 Carnegie Mellon University
d66 1
a66 1
#include <scc.h>
d178 8
a185 2
struct cfdriver scccd =
    { NULL, "scc", sccmatch, sccattach, DV_TTY, sizeof (struct scc_softc) };
d308 2
d360 1
a360 1
                cterm.c_cflag = CS8;
d468 1
a468 1
	if (unit >= scccd.cd_ndevs)
d470 1
a470 1
	sc = scccd.cd_devs[unit];
d478 1
a478 1
	if (tp == NULL)
d480 2
d527 1
a527 1
	register struct scc_softc *sc = scccd.cd_devs[SCCUNIT(dev)];
d599 1
a599 1
	sc = scccd.cd_devs[SCCUNIT(dev)];
d684 1
a684 1
	sc = scccd.cd_devs[SCCUNIT(tp->t_dev)];
d799 1
a799 1
	sc = scccd.cd_devs[unit];
d961 1
a961 1
	sc = scccd.cd_devs[SCCUNIT(tp->t_dev)];
d995 1
d1007 3
d1051 1
a1051 1
	sc = scccd.cd_devs[SCCUNIT(tp->t_dev)];
d1075 1
a1075 1
	sc = scccd.cd_devs[SCCUNIT(dev)];
d1139 1
a1139 1
	sc = scccd.cd_devs[SCCUNIT(dev)];
d1177 1
a1177 1
	sc = scccd.cd_devs[SCCUNIT(dev)];
d1219 1
a1219 1
	sc = scccd.cd_devs[SCCUNIT(dev)];
@


1.2
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: scc.c,v 1.10 1995/11/23 02:41:29 cgd Exp $	*/
a102 1
#include <machine/autoconf.h>
d105 3
a107 2
#include <alpha/tc/asic.h>
#include <alpha/tc/tc.h>
d208 1
a208 1
	struct confargs *ca = aux;
d214 1
a214 1
	if (!BUS_MATCHNAME(ca, "scc"))
d222 1
a222 1
	sccaddr = BUS_CVTADDR(ca);
d224 1
a224 1
	sccaddr = TC_DENSE_TO_SPARSE(sccaddr);
d237 2
a238 2
		*(volatile u_int *)ASIC_REG_IMSK(asic_base) |=
		    ASIC_INTR_SCC_1 | ASIC_INTR_SCC_0;
d240 3
a242 3
		*(volatile u_int *)ASIC_REG_CSR(asic_base) |=
		    ASIC_CSR_DMAEN_T1 | ASIC_CSR_DMAEN_R1 |
		    ASIC_CSR_DMAEN_T2 | ASIC_CSR_DMAEN_R2;
d245 2
a246 2
		*(volatile u_int *)ASIC_REG_IMSK(asic_base) &=
		    ~(ASIC_INTR_SCC_1 | ASIC_INTR_SCC_0);
d248 3
a250 3
		*(volatile u_int *)ASIC_REG_CSR(asic_base) &=
		    ~(ASIC_CSR_DMAEN_T1 | ASIC_CSR_DMAEN_R1 |
		    ASIC_CSR_DMAEN_T2 | ASIC_CSR_DMAEN_R2);
d263 1
a263 1
	struct confargs *ca = aux;
d274 1
a274 1
	sccaddr = BUS_CVTADDR(ca);
d276 1
a276 1
	sccaddr = TC_DENSE_TO_SPARSE(sccaddr);
d280 2
a281 1
	BUS_INTR_ESTABLISH(ca, sccintr, (void *)(long)sc->sc_dv.dv_unit);
d769 1
a769 1
	scc_alphaintr(1);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: scc.c,v 1.9 1995/08/03 00:52:17 cgd Exp $	*/
d99 1
d101 1
d879 1
d912 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
