head	1.19;
access;
symbols
	OPENBSD_6_0:1.19.0.6
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.4
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.18.0.14
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.18
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.16
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.12
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.10
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.8
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.6
	OPENBSD_5_0:1.18.0.4
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.15.0.8
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.4
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.6
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.14.0.4
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.13.0.6
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.12.0.8
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.6
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.10
	UBC:1.7.0.16
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.14
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.12
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.10
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.8
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.6
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.8
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2015.05.19.20.28.14;	author miod;	state Exp;
branches;
next	1.18;
commitid	YdrkA6WJKqXchmio;

1.18
date	2010.09.22.12.36.32;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2010.09.22.11.44.01;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	2010.09.20.06.33.46;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	2008.08.09.16.42.29;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2007.11.06.18.20.05;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.04.12.33.17;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.28.02.28.43;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.13.21.32.17;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.02.22.56.06;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.03.15.51;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.28;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.01.11.05.11.04;	author millert;	state Exp;
branches
	1.7.6.1
	1.7.16.1;
next	1.6;

1.6
date	97.01.24.19.58.18;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.10.30.22.41.18;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.07.29.23.02.23;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.06.18.09.45.23;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.26.18.12.06;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.50;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.50;	author deraadt;	state Exp;
branches;
next	;

1.7.6.1
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	1.7.6.2;

1.7.6.2
date	2003.03.27.23.18.06;	author niklas;	state Exp;
branches;
next	1.7.6.3;

1.7.6.3
date	2003.05.16.00.29.38;	author niklas;	state Exp;
branches;
next	;

1.7.16.1
date	2002.06.11.03.33.41;	author art;	state Exp;
branches;
next	1.7.16.2;

1.7.16.2
date	2003.05.19.21.38.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Move acquisition of the kernel lock deeper in the interrupt path, and make
sure clock interrupts do not attempt to acquire it.
This will also eventually allow for IPL_MPSAFE interrupts on alpha.

Tested by dlg@@ and I.
@
text
@/* $OpenBSD: tc_3000_500.c,v 1.18 2010/09/22 12:36:32 miod Exp $ */
/* $NetBSD: tc_3000_500.c,v 1.24 2001/07/27 00:25:21 thorpej Exp $ */

/*
 * Copyright (c) 1994, 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <machine/autoconf.h>
#include <machine/pte.h>
#include <machine/rpb.h>

#include <dev/tc/tcvar.h>
#include <alpha/tc/tc_conf.h>
#include <alpha/tc/tc_3000_500.h>

#include "wsdisplay.h"
#include "sfb.h"

#if NSFB > 0
extern int	sfb_cnattach(tc_addr_t);
#endif

int	tc_3000_500_intrnull(void *);
int	tc_3000_500_fb_cnattach(u_int64_t);

#define C(x)	((void *)(u_long)x)
#define	KV(x)	(ALPHA_PHYS_TO_K0SEG(x))

struct tc_slotdesc tc_3000_500_slots[] = {
	{ KV(0x100000000), C(TC_3000_500_DEV_OPT0), },	/* 0 - opt slot 0 */
	{ KV(0x120000000), C(TC_3000_500_DEV_OPT1), },	/* 1 - opt slot 1 */
	{ KV(0x140000000), C(TC_3000_500_DEV_OPT2), },	/* 2 - opt slot 2 */
	{ KV(0x160000000), C(TC_3000_500_DEV_OPT3), },	/* 3 - opt slot 3 */
	{ KV(0x180000000), C(TC_3000_500_DEV_OPT4), },	/* 4 - opt slot 4 */
	{ KV(0x1a0000000), C(TC_3000_500_DEV_OPT5), },	/* 5 - opt slot 5 */
	{ KV(0x1c0000000), C(TC_3000_500_DEV_BOGUS), },	/* 6 - TCDS ASIC */
	{ KV(0x1e0000000), C(TC_3000_500_DEV_BOGUS), },	/* 7 - IOCTL ASIC */
};
int tc_3000_500_nslots =
    sizeof(tc_3000_500_slots) / sizeof(tc_3000_500_slots[0]);

struct tc_builtin tc_3000_500_graphics_builtins[] = {
	{ "FLAMG-IO",	7, 0x00000000, C(TC_3000_500_DEV_IOASIC),	},
	{ "PMAGB-BA",	7, 0x02000000, C(TC_3000_500_DEV_CXTURBO),	},
	{ "PMAZ-DS ",	6, 0x00000000, C(TC_3000_500_DEV_TCDS),		},
};
int tc_3000_500_graphics_nbuiltins = sizeof(tc_3000_500_graphics_builtins) /
    sizeof(tc_3000_500_graphics_builtins[0]);

struct tc_builtin tc_3000_500_nographics_builtins[] = {
	{ "FLAMG-IO",	7, 0x00000000, C(TC_3000_500_DEV_IOASIC),	},
	{ "PMAZ-DS ",	6, 0x00000000, C(TC_3000_500_DEV_TCDS),		},
};
int tc_3000_500_nographics_nbuiltins = sizeof(tc_3000_500_nographics_builtins) /
    sizeof(tc_3000_500_nographics_builtins[0]);

u_int32_t tc_3000_500_intrbits[TC_3000_500_NCOOKIES] = {
	TC_3000_500_IR_OPT0,
	TC_3000_500_IR_OPT1,
	TC_3000_500_IR_OPT2,
	TC_3000_500_IR_OPT3,
	TC_3000_500_IR_OPT4,
	TC_3000_500_IR_OPT5,
	TC_3000_500_IR_TCDS,
	TC_3000_500_IR_IOASIC,
	TC_3000_500_IR_CXTURBO,
};

struct tcintr {
	int	(*tci_func)(void *);
	void	*tci_arg;
	int	tci_level;
	struct evcount tci_count;
} tc_3000_500_intr[TC_3000_500_NCOOKIES];

u_int32_t tc_3000_500_imask;	/* intrs we want to ignore; mirrors IMR. */

void
tc_3000_500_intr_setup()
{
	u_long i;

	/*
	 * Disable all slot interrupts.  Note that this cannot
	 * actually disable CXTurbo, TCDS, and IOASIC interrupts.
	 */
	tc_3000_500_imask = *(volatile u_int32_t *)TC_3000_500_IMR_READ;
	for (i = 0; i < TC_3000_500_NCOOKIES; i++)
		tc_3000_500_imask |= tc_3000_500_intrbits[i];
	*(volatile u_int32_t *)TC_3000_500_IMR_WRITE = tc_3000_500_imask;
	tc_mb();

        /*
	 * Set up interrupt handlers.
	 */
        for (i = 0; i < TC_3000_500_NCOOKIES; i++) {
		tc_3000_500_intr[i].tci_func = tc_3000_500_intrnull;
		tc_3000_500_intr[i].tci_arg = (void *)i;
		tc_3000_500_intr[i].tci_level = IPL_HIGH;
        }
}

void
tc_3000_500_intr_establish(tcadev, cookie, level, func, arg, name)
	struct device *tcadev;
	void *cookie, *arg;
	int level;
	int (*func)(void *);
	const char *name;
{
	u_long dev = (u_long)cookie;

#ifdef DIAGNOSTIC
	/* XXX bounds-check cookie. */
#endif

	if (tc_3000_500_intr[dev].tci_func != tc_3000_500_intrnull)
		panic("tc_3000_500_intr_establish: cookie %lu twice", dev);

	tc_3000_500_intr[dev].tci_func = func;
	tc_3000_500_intr[dev].tci_arg = arg;
	tc_3000_500_intr[dev].tci_level = level;
	if (name != NULL)
		evcount_attach(&tc_3000_500_intr[dev].tci_count, name, NULL);

	tc_3000_500_imask &= ~tc_3000_500_intrbits[dev];
	*(volatile u_int32_t *)TC_3000_500_IMR_WRITE = tc_3000_500_imask;
	tc_mb();
}

void
tc_3000_500_intr_disestablish(tcadev, cookie, name)
	struct device *tcadev;
	void *cookie;
	const char *name;
{
	u_long dev = (u_long)cookie;

#ifdef DIAGNOSTIC
	/* XXX bounds-check cookie. */
#endif

	if (tc_3000_500_intr[dev].tci_func == tc_3000_500_intrnull)
		panic("tc_3000_500_intr_disestablish: cookie %lu bad intr",
		    dev);

	tc_3000_500_imask |= tc_3000_500_intrbits[dev];
	*(volatile u_int32_t *)TC_3000_500_IMR_WRITE = tc_3000_500_imask;
	tc_mb();

	tc_3000_500_intr[dev].tci_func = tc_3000_500_intrnull;
	tc_3000_500_intr[dev].tci_arg = (void *)dev;
	tc_3000_500_intr[dev].tci_level = IPL_HIGH;
	if (name != NULL)
		evcount_detach(&tc_3000_500_intr[dev].tci_count);
}

int
tc_3000_500_intrnull(val)
	void *val;
{

	panic("tc_3000_500_intrnull: uncaught TC intr for cookie %ld",
	    (u_long)val);
}

void
tc_3000_500_iointr(arg, vec)
        void *arg;
        unsigned long vec;
{
        u_int32_t ir;
	int ifound;

	do {
		tc_syncbus();
		ir = *(volatile u_int32_t *)TC_3000_500_IR_CLEAR;

		/* Ignore interrupts that we haven't enabled. */
		ir &= ~(tc_3000_500_imask & 0x1ff);

		ifound = 0;

#ifdef MULTIPROCESSOR
#define	INTRLOCK(slot)							\
		if (tc_3000_500_intr[slot].tci_level < IPL_CLOCK)	\
			__mp_lock(&kernel_lock)
#define	INTRUNLOCK(slot)						\
		if (tc_3000_500_intr[slot].tci_level < IPL_CLOCK)	\
			__mp_unlock(&kernel_lock)
#else
#define	INTRLOCK(slot)		do { } while (0)
#define	INTRUNLOCK(slot)	do { } while (0)
#endif
#define	CHECKINTR(slot)							\
		if (ir & tc_3000_500_intrbits[slot]) {			\
			ifound = 1;					\
			INTRLOCK(slot);					\
			(*tc_3000_500_intr[slot].tci_func)		\
			    (tc_3000_500_intr[slot].tci_arg);		\
			tc_3000_500_intr[slot].tci_count.ec_count++;	\
			INTRUNLOCK(slot);					\
		}

		/* Do them in order of priority; highest slot # first. */
		CHECKINTR(TC_3000_500_DEV_CXTURBO);
		CHECKINTR(TC_3000_500_DEV_IOASIC);
		CHECKINTR(TC_3000_500_DEV_TCDS);
		CHECKINTR(TC_3000_500_DEV_OPT5);
		CHECKINTR(TC_3000_500_DEV_OPT4);
		CHECKINTR(TC_3000_500_DEV_OPT3);
		CHECKINTR(TC_3000_500_DEV_OPT2);
		CHECKINTR(TC_3000_500_DEV_OPT1);
		CHECKINTR(TC_3000_500_DEV_OPT0);

#undef INTRUNLOCK
#undef INTRLOCK
#undef CHECKINTR

#ifdef DIAGNOSTIC
#define PRINTINTR(msg, bits)						\
	if (ir & bits)							\
		printf(msg);

		PRINTINTR("Second error occurred\n", TC_3000_500_IR_ERR2);
		PRINTINTR("DMA buffer error\n", TC_3000_500_IR_DMABE);
		PRINTINTR("DMA cross 2K boundary\n", TC_3000_500_IR_DMA2K);
		PRINTINTR("TC reset in progress\n", TC_3000_500_IR_TCRESET);
		PRINTINTR("TC parity error\n", TC_3000_500_IR_TCPAR);
		PRINTINTR("DMA tag error\n", TC_3000_500_IR_DMATAG);
		PRINTINTR("Single-bit error\n", TC_3000_500_IR_DMASBE);
		PRINTINTR("Double-bit error\n", TC_3000_500_IR_DMADBE);
		PRINTINTR("TC I/O timeout\n", TC_3000_500_IR_TCTIMEOUT);
		PRINTINTR("DMA block too long\n", TC_3000_500_IR_DMABLOCK);
		PRINTINTR("Invalid I/O address\n", TC_3000_500_IR_IOADDR);
		PRINTINTR("DMA scatter/gather invalid\n", TC_3000_500_IR_DMASG);
		PRINTINTR("Scatter/gather parity error\n",
		    TC_3000_500_IR_SGPAR);

#undef PRINTINTR
#endif
	} while (ifound);
}

#if NWSDISPLAY > 0
/*
 * tc_3000_500_fb_cnattach --
 *	Attempt to map the CTB output device to a slot and attach the
 * framebuffer as the output side of the console.
 */
int
tc_3000_500_fb_cnattach(turbo_slot)
	u_int64_t turbo_slot;
{
	u_int32_t output_slot;

	output_slot = turbo_slot & 0xffffffff;

	if (output_slot >= tc_3000_500_nslots) {
		return EINVAL;
	}

	if (hwrpb->rpb_variation & SV_GRAPHICS) {
		if (output_slot == 0) {
#if NSFB > 0
			sfb_cnattach(KV(0x1e0000000) + 0x02000000);
			return 0;
#else
			return ENXIO;
#endif
		}
	} else {
		/*
		 * Slots 0-2 in the tc_3000_500_slots array are only
		 * on the 500 models that also have the CXTurbo
		 * (500/800/900) and a total of 6 TC slots.  For the
		 * 400/600/700, slots 0-2 are in table locations 3-5, so
		 * offset the CTB slot by 3 to get the address in our table.
		 */
		output_slot += 3;
	}
	return tc_fb_cnattach(tc_3000_500_slots[output_slot-1].tcs_addr);
}
#endif /* NWSDISPLAY */

#if 0
/*
 * tc_3000_500_ioslot --
 *	Set the PBS bits for devices on the TC.
 */
void
tc_3000_500_ioslot(slot, flags, set)
	u_int32_t slot, flags;
	int set;
{
	volatile u_int32_t *iosp;
	u_int32_t ios;
	int s;
	
	iosp = (volatile u_int32_t *)TC_3000_500_IOSLOT;
	ios = *iosp;
	flags <<= (slot * 3);
	if (set)
		ios |= flags;
	else
		ios &= ~flags;
	s = splhigh();
	*iosp = ios;
	tc_mb();
	splx(s);
}
#endif
@


1.18
log
@Revert previous and let drivers register counterless interrupts;
tc_intr_disestablish() prototype is changed to carry information whether the
counter needs to be detached or not.

This does not matter much since no driver ever calls tc_intr_disestablish().
@
text
@d1 1
a1 1
/* $OpenBSD: tc_3000_500.c,v 1.17 2010/09/22 11:44:01 matthew Exp $ */
d100 1
d127 1
d150 1
d181 1
a202 11
#ifdef DIAGNOSTIC
	int s;
	if (vec != 0x800)
		panic("INVALID ASSUMPTION: vec 0x%lx, not 0x800", vec);
	s = splhigh();
	if (s != ALPHA_PSL_IPL_IO)
		panic("INVALID ASSUMPTION: IPL %d, not %d", s,
		    ALPHA_PSL_IPL_IO);
	splx(s);
#endif

d212 11
d226 1
a226 1
			tc_3000_500_intr[slot].tci_count.ec_count++;	\
d229 2
d232 1
d243 3
d252 1
d267 1
@


1.17
log
@Switch to unconditionally attaching evcounts on TurboChannel
interrupts, since inspecting the code, they seem to always attach
anyway.  This fixes compiler fallout from my evcount simplification.

build error reported by naddy@@; "seems sensible" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: tc_3000_500.c,v 1.16 2010/09/20 06:33:46 matthew Exp $ */
a138 2
	KASSERT(name != NULL);

d148 2
a149 1
	evcount_attach(&tc_3000_500_intr[dev].tci_count, name, NULL);
d157 1
a157 1
tc_3000_500_intr_disestablish(tcadev, cookie)
d160 1
d178 2
a179 1
	evcount_detach(&tc_3000_500_intr[dev].tci_count);
@


1.16
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: tc_3000_500.c,v 1.15 2008/08/09 16:42:29 miod Exp $ */
d139 2
d150 1
a150 3
	if (name != NULL)
		evcount_attach(&tc_3000_500_intr[dev].tci_count,
		    name, NULL);
d178 1
a178 2
	if (tc_3000_500_intr[dev].tci_count.ec_parent != NULL)
		evcount_detach(&tc_3000_500_intr[dev].tci_count);
@


1.15
log
@Pass a device name to {tc,tcds,ioasic}_intr_establish in order to get
meaningful names associated to the interrupt counters.
@
text
@d1 1
a1 1
/* $OpenBSD: tc_3000_500.c,v 1.14 2007/11/06 18:20:05 miod Exp $ */
d150 1
a150 1
		    name, NULL, &evcount_intr);
@


1.14
log
@Get rid of TC_IPL_xxx values and tc_intrlevel_t, and use IPL_xxx and int.
No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: tc_3000_500.c,v 1.13 2006/03/04 12:33:17 miod Exp $ */
a50 6
void	tc_3000_500_intr_setup(void);
void	tc_3000_500_intr_establish(struct device *, void *,
	    int, int (*)(void *), void *);
void	tc_3000_500_intr_disestablish(struct device *, void *);
void	tc_3000_500_iointr(void *, unsigned long);

a100 1
	char	tci_name[12];
a125 4
		snprintf(tc_3000_500_intr[i].tci_name,
		    sizeof tc_3000_500_intr[i].tci_name, "tc slot %u", i);
		evcount_attach(&tc_3000_500_intr[i].tci_count,
		    tc_3000_500_intr[i].tci_name, NULL, &evcount_intr);
d130 1
a130 1
tc_3000_500_intr_establish(tcadev, cookie, level, func, arg)
d135 1
d148 3
d178 2
@


1.13
log
@Better names for turbochannel event counters.
@
text
@d1 1
a1 1
/* $OpenBSD: tc_3000_500.c,v 1.12 2004/06/28 02:28:43 aaron Exp $ */
d53 1
a53 1
	    tc_intrlevel_t, int (*)(void *), void *);
d144 1
a144 1
	tc_intrlevel_t level;
@


1.12
log
@Use new event counter API for interrupt counting on alpha.  By me, with some
edits by Theo.  deraadt@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: tc_3000_500.c,v 1.11 2003/05/13 21:32:17 deraadt Exp $ */
d107 1
a114 1
	char *cp;
d133 4
a136 7

		cp = malloc(12, M_DEVBUF, M_NOWAIT);
		if (cp == NULL)
			panic("tc_3000_500_intr_setup");
		snprintf(cp, 12, "slot %lu", i);
		evcount_attach(&tc_3000_500_intr[i].tci_count, "tc", NULL,
		    &evcount_intr);
@


1.11
log
@snprintf
@
text
@d1 1
a1 1
/* $OpenBSD: tc_3000_500.c,v 1.10 2002/05/02 22:56:06 miod Exp $ */
a38 1
#include <machine/intrcnt.h>
d106 1
a106 1
	struct evcnt tci_evcnt;
d138 2
a139 4
#ifdef EVCNT_COUNTERS
		evcnt_attach_dynamic(&tc_3000_500_intr[i].tci_evcnt,
		    EVCNT_TYPE_INTR, NULL, "tc", cp);
#endif
a142 14
const struct evcnt *
tc_3000_500_intr_evcnt(tcadev, cookie)
	struct device *tcadev;
	void *cookie;
{
	u_long dev = (u_long)cookie;

#ifdef DIAGNOSTIC
	/* XXX bounds-check cookie. */
#endif

	return (&tc_3000_500_intr[dev].tci_evcnt);
}

a226 6
#ifdef EVCNT_COUNTERS
#define	INCRINTRCNT(slot)	tc_3000_500_intr[slot].tci_evcnt.ev_count++
#else
#define	INCRINTRCNT(slot)	intrcnt[INTRCNT_KN15 + slot]++
#endif

d230 1
a230 1
			INCRINTRCNT(slot);				\
@


1.10
log
@Big TURBOchannel support catchup from NetBSD, part 1.
A few local changes and tweaks remain.

This bring DEC 3000 machines back in the game, but framebuffers are still
not supported at the moment.

Thanks to ericj@@ and nate@@ for supplying me a DEC 3000 for testing.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d138 1
a138 1
		sprintf(cp, "slot %lu", i);
@


1.9
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 2
a2 2
/*	$OpenBSD: tc_3000_500.c,v 1.8 2002/03/14 01:26:28 millert Exp $	*/
/*	$NetBSD: tc_3000_500.c,v 1.12 1996/11/15 23:59:00 cgd Exp $	*/
d34 1
d38 1
a38 1
#ifndef EVCNT_COUNTERS
a39 1
#endif
d45 7
d59 1
d107 1
d115 1
d134 9
d146 14
d174 1
a174 1
		panic("tc_3000_500_intr_establish: cookie %d twice", dev);
d196 1
a196 1
		panic("tc_3000_500_intr_disestablish: cookie %d bad intr",
d217 2
a218 2
tc_3000_500_iointr(framep, vec)
        void *framep;
d245 2
a246 3
	/* No interrupt counting via evcnt counters */ 
	XXX BREAK HERE XXX
#else /* !EVCNT_COUNTERS */
d248 1
a248 1
#endif /* EVCNT_COUNTERS */ 
d291 41
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: tc_3000_500.c,v 1.7 1999/01/11 05:11:04 millert Exp $	*/
d46 2
a47 2
void	tc_3000_500_intr_establish __P((struct device *, void *,
	    tc_intrlevel_t, int (*)(void *), void *));
@


1.7
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: tc_3000_500.c,v 1.6 1997/01/24 19:58:18 niklas Exp $	*/
d45 1
a45 1
void	tc_3000_500_intr_setup __P((void));
d48 2
a49 2
void	tc_3000_500_intr_disestablish __P((struct device *, void *));
void	tc_3000_500_iointr __P((void *, unsigned long));
d51 1
a51 1
int	tc_3000_500_intrnull __P((void *));
d97 1
a97 1
	int	(*tci_func) __P((void *));
d132 1
a132 1
	int (*func) __P((void *));
@


1.7.16.1
log
@Sync UBC branch to -current
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* $NetBSD: tc_3000_500.c,v 1.24 2001/07/27 00:25:21 thorpej Exp $ */
a33 1
#include <sys/malloc.h>
d37 1
a37 1
#include <machine/rpb.h>
d39 1
d45 5
a49 12
#include "wsdisplay.h"
#include "sfb.h"

#if NSFB > 0
extern int	sfb_cnattach(tc_addr_t);
#endif

void	tc_3000_500_intr_setup(void);
void	tc_3000_500_intr_establish(struct device *, void *,
	    tc_intrlevel_t, int (*)(void *), void *);
void	tc_3000_500_intr_disestablish(struct device *, void *);
void	tc_3000_500_iointr(void *, unsigned long);
d51 1
a51 2
int	tc_3000_500_intrnull(void *);
int	tc_3000_500_fb_cnattach(u_int64_t);
d97 1
a97 1
	int	(*tci_func)(void *);
a98 1
	struct evcnt tci_evcnt;
a105 1
	char *cp;
a123 9

		cp = malloc(12, M_DEVBUF, M_NOWAIT);
		if (cp == NULL)
			panic("tc_3000_500_intr_setup");
		sprintf(cp, "slot %lu", i);
#ifdef EVCNT_COUNTERS
		evcnt_attach_dynamic(&tc_3000_500_intr[i].tci_evcnt,
		    EVCNT_TYPE_INTR, NULL, "tc", cp);
#endif
a126 14
const struct evcnt *
tc_3000_500_intr_evcnt(tcadev, cookie)
	struct device *tcadev;
	void *cookie;
{
	u_long dev = (u_long)cookie;

#ifdef DIAGNOSTIC
	/* XXX bounds-check cookie. */
#endif

	return (&tc_3000_500_intr[dev].tci_evcnt);
}

d132 1
a132 1
	int (*func)(void *);
d141 1
a141 1
		panic("tc_3000_500_intr_establish: cookie %lu twice", dev);
d163 1
a163 1
		panic("tc_3000_500_intr_disestablish: cookie %lu bad intr",
d184 2
a185 2
tc_3000_500_iointr(arg, vec)
        void *arg;
d212 3
a214 2
#define	INCRINTRCNT(slot)	tc_3000_500_intr[slot].tci_evcnt.ev_count++
#else
d216 1
a216 1
#endif
a258 41

#if NWSDISPLAY > 0
/*
 * tc_3000_500_fb_cnattach --
 *	Attempt to map the CTB output device to a slot and attach the
 * framebuffer as the output side of the console.
 */
int
tc_3000_500_fb_cnattach(turbo_slot)
	u_int64_t turbo_slot;
{
	u_int32_t output_slot;

	output_slot = turbo_slot & 0xffffffff;

	if (output_slot >= tc_3000_500_nslots) {
		return EINVAL;
	}

	if (hwrpb->rpb_variation & SV_GRAPHICS) {
		if (output_slot == 0) {
#if NSFB > 0
			sfb_cnattach(KV(0x1e0000000) + 0x02000000);
			return 0;
#else
			return ENXIO;
#endif
		}
	} else {
		/*
		 * Slots 0-2 in the tc_3000_500_slots array are only
		 * on the 500 models that also have the CXTurbo
		 * (500/800/900) and a total of 6 TC slots.  For the
		 * 400/600/700, slots 0-2 are in table locations 3-5, so
		 * offset the CTB slot by 3 to get the address in our table.
		 */
		output_slot += 3;
	}
	return tc_fb_cnattach(tc_3000_500_slots[output_slot-1].tcs_addr);
}
#endif /* NWSDISPLAY */
@


1.7.16.2
log
@sync
@
text
@d138 1
a138 1
		snprintf(cp, 12, "slot %lu", i);
@


1.7.6.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 5
a49 5
void	tc_3000_500_intr_setup(void);
void	tc_3000_500_intr_establish(struct device *, void *,
	    tc_intrlevel_t, int (*)(void *), void *);
void	tc_3000_500_intr_disestablish(struct device *, void *);
void	tc_3000_500_iointr(void *, unsigned long);
d51 1
a51 1
int	tc_3000_500_intrnull(void *);
d97 1
a97 1
	int	(*tci_func)(void *);
d132 1
a132 1
	int (*func)(void *);
@


1.7.6.2
log
@Sync the SMP branch with 3.3
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* $NetBSD: tc_3000_500.c,v 1.24 2001/07/27 00:25:21 thorpej Exp $ */
a33 1
#include <sys/malloc.h>
d37 1
a37 1
#include <machine/rpb.h>
d39 1
a44 7
#include "wsdisplay.h"
#include "sfb.h"

#if NSFB > 0
extern int	sfb_cnattach(tc_addr_t);
#endif

a51 1
int	tc_3000_500_fb_cnattach(u_int64_t);
a98 1
	struct evcnt tci_evcnt;
a105 1
	char *cp;
a123 9

		cp = malloc(12, M_DEVBUF, M_NOWAIT);
		if (cp == NULL)
			panic("tc_3000_500_intr_setup");
		sprintf(cp, "slot %lu", i);
#ifdef EVCNT_COUNTERS
		evcnt_attach_dynamic(&tc_3000_500_intr[i].tci_evcnt,
		    EVCNT_TYPE_INTR, NULL, "tc", cp);
#endif
a126 14
const struct evcnt *
tc_3000_500_intr_evcnt(tcadev, cookie)
	struct device *tcadev;
	void *cookie;
{
	u_long dev = (u_long)cookie;

#ifdef DIAGNOSTIC
	/* XXX bounds-check cookie. */
#endif

	return (&tc_3000_500_intr[dev].tci_evcnt);
}

d141 1
a141 1
		panic("tc_3000_500_intr_establish: cookie %lu twice", dev);
d163 1
a163 1
		panic("tc_3000_500_intr_disestablish: cookie %lu bad intr",
d184 2
a185 2
tc_3000_500_iointr(arg, vec)
        void *arg;
d212 3
a214 2
#define	INCRINTRCNT(slot)	tc_3000_500_intr[slot].tci_evcnt.ev_count++
#else
d216 1
a216 1
#endif
a258 41

#if NWSDISPLAY > 0
/*
 * tc_3000_500_fb_cnattach --
 *	Attempt to map the CTB output device to a slot and attach the
 * framebuffer as the output side of the console.
 */
int
tc_3000_500_fb_cnattach(turbo_slot)
	u_int64_t turbo_slot;
{
	u_int32_t output_slot;

	output_slot = turbo_slot & 0xffffffff;

	if (output_slot >= tc_3000_500_nslots) {
		return EINVAL;
	}

	if (hwrpb->rpb_variation & SV_GRAPHICS) {
		if (output_slot == 0) {
#if NSFB > 0
			sfb_cnattach(KV(0x1e0000000) + 0x02000000);
			return 0;
#else
			return ENXIO;
#endif
		}
	} else {
		/*
		 * Slots 0-2 in the tc_3000_500_slots array are only
		 * on the 500 models that also have the CXTurbo
		 * (500/800/900) and a total of 6 TC slots.  For the
		 * 400/600/700, slots 0-2 are in table locations 3-5, so
		 * offset the CTB slot by 3 to get the address in our table.
		 */
		output_slot += 3;
	}
	return tc_fb_cnattach(tc_3000_500_slots[output_slot-1].tcs_addr);
}
#endif /* NWSDISPLAY */
@


1.7.6.3
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d138 1
a138 1
		snprintf(cp, 12, "slot %lu", i);
@


1.6
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: tc_3000_500.c,v 1.5 1996/10/30 22:41:18 niklas Exp $	*/
d179 1
a179 1
	panic("tc_3000_500_intrnull: uncaught TC intr for cookie %ld\n",
@


1.5
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 2
a2 2
/*	$OpenBSD: tc_3000_500.c,v 1.11 1996/10/13 03:00:38 christos Exp $	*/
/*	$NetBSD: tc_3000_500.c,v 1.11 1996/10/13 03:00:38 christos Exp $	*/
d69 1
a69 1
struct tc_builtin tc_3000_500_builtins[] = {
d74 9
a82 2
int tc_3000_500_nbuiltins =
    sizeof(tc_3000_500_builtins) / sizeof(tc_3000_500_builtins[0]);
@


1.4
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: tc_3000_500.c,v 1.4.4.3 1996/06/13 18:35:35 cgd Exp $	*/
/*	$NetBSD: tc_3000_500.c,v 1.4.4.3 1996/06/13 18:35:35 cgd Exp $	*/
d32 1
d49 1
a49 1
void	tc_3000_500_iointr __P((void *, int));
d54 1
a54 1
#define	KV(x)	(phystok0seg(x))
d179 1
a179 1
        int vec;
d187 1
a187 1
		panic("INVALID ASSUMPTION: vec %x, not 0x800", vec);
d189 3
a191 2
	if (s != PSL_IPL_IO)
		panic("INVALID ASSUMPTION: IPL %d, not %d", s, PSL_IPL_IO);
d253 1
d279 1
@


1.3
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.2
log
@from netbsd:
machine-independent TurboChannel bus configuration.  These files
deal with stuff like:
        (1) configuring built-in devices,
        (2) looking at TC slots configuring any devices found.
The lists of slots, slot locations, etc. and built-in devices
are provided by machine-dependent code.  Interrupt handling
is also provided by machine-dependent code, but the MD code provides
hooks so that standard names for 'establish' and 'disestablish'
can be used in drivers.

This code requires <machine/tc_machdep.h>, which defines some
portability types specific to the TurboChannel bus code.
@
text
@d1 1
a1 1
/*	$NetBSD: tc_3000_500.c,v 1.3 1995/12/20 00:43:30 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1994, 1995 Carnegie-Mellon University.
d35 3
d92 2
a97 1
	u_int32_t imr;
d100 2
a101 1
	 * Disable all slot interrupts.
d103 1
a103 1
	imr = *(volatile u_int32_t *)TC_3000_500_IMR_READ;
d105 2
a106 2
		imr |= tc_3000_500_intrbits[i];
	*(volatile u_int32_t *)TC_3000_500_IMR_WRITE = imr;
a125 1
	u_int32_t imr;
d137 2
a138 3
	imr = *(volatile u_int32_t *)TC_3000_500_IMR_READ;
	imr &= ~tc_3000_500_intrbits[dev];
	*(volatile u_int32_t *)TC_3000_500_IMR_WRITE = imr;
a147 1
	u_int32_t imr;
d157 2
a158 3
	imr = *(volatile u_int32_t *)TC_3000_500_IMR_READ;
	imr |= tc_3000_500_intrbits[dev];
	*(volatile u_int32_t *)TC_3000_500_IMR_WRITE = imr;
d196 3
d200 8
d211 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: tc_3000_500.c,v 1.2 1995/08/03 00:52:36 cgd Exp $	*/
d36 2
a37 1
#include <alpha/tc/tc.h>
a39 1
/* XXX ESTABLISH, DISESTABLISH */
d41 3
a43 3
void	tc_3000_500_intr_establish
	    __P((struct confargs *, intr_handler_t, void *));
void	tc_3000_500_intr_disestablish __P((struct confargs *));
a44 1
int	tc_3000_500_getdev __P((struct confargs *));
d46 14
a59 13
#define	KV(x)	((caddr_t)phystok0seg(x))
#define	TC_3000_500_NSLOTS	8
#define	TC_3000_500_MAXDEVS	9

static struct tc_slot_desc dec_3000_500_slots[TC_3000_500_NSLOTS] = {
	{ KV(0x100000000), },		/* slot 0 - TC option slot 0 */
	{ KV(0x120000000), },		/* slot 1 - TC option slot 1 */
	{ KV(0x140000000), },		/* slot 2 - TC option slot 2 */
	{ KV(0x160000000), },		/* slot 3 - TC option slot 3 */
	{ KV(0x180000000), },		/* slot 4 - TC option slot 4 */
	{ KV(0x1a0000000), },		/* slot 5 - TC option slot 5 */
	{ KV(0x1c0000000), },		/* slot 6 - TCDS ASIC on cpu board */
	{ KV(0x1e0000000), },		/* slot 7 - IOCTL ASIC on cpu board */
d61 2
d64 4
a67 10
static struct confargs dec_3000_500_devs[TC_3000_500_MAXDEVS] = {
	{ "IOCTL   ",	7, 0x00000000,	},
	{ "PMAGB-BA",	7, 0x02000000,	},
	{ "PMAZ-DS ",	6, 0x00000000,	},
	{ NULL,		5, 0x0,		},
	{ NULL,		4, 0x0,		},
	{ NULL,		3, 0x0,		},
	{ NULL,		2, 0x0,		},
	{ NULL,		1, 0x0,		},
	{ NULL,		0, 0x0,		},
d69 2
d72 10
a81 18
/* Indices into the struct confargs array. */
#define	TC_3000_500_DEV_IOCTL	0
#define	TC_3000_500_DEV_CXTURBO	1
#define	TC_3000_500_DEV_TCDS	2
#define	TC_3000_500_DEV_OPT5	3
#define	TC_3000_500_DEV_OPT4	4
#define	TC_3000_500_DEV_OPT3	5
#define	TC_3000_500_DEV_OPT2	6
#define	TC_3000_500_DEV_OPT1	7
#define	TC_3000_500_DEV_OPT0	8

struct tc_cpu_desc dec_3000_500_cpu = {
	dec_3000_500_slots, TC_3000_500_NSLOTS,
	dec_3000_500_devs, TC_3000_500_MAXDEVS,
	tc_3000_500_intr_setup,
	tc_3000_500_intr_establish,
	tc_3000_500_intr_disestablish,
	tc_3000_500_iointr,
d84 4
a87 2
intr_handler_t	tc_3000_500_intrhand[TC_3000_500_MAXDEVS];
void		*tc_3000_500_intrval[TC_3000_500_MAXDEVS];
d92 2
a93 1
	int i;
d95 8
a102 5
        /* Set up interrupt handlers. */
        for (i = 0; i < TC_3000_500_MAXDEVS; i++) {
                tc_3000_500_intrhand[i] = tc_intrnull;
                tc_3000_500_intrval[i] = (void *)(long)i;
        }
d104 2
a105 9
	/*
	 * XXX
	 * The System Programmer's Manual (3-15) says IMR entries for option
	 * slots are initialized to 0.  I think this is wrong, and that they
	 * are initialized to 1, i.e. the option slots are disabled.  Enable
	 * them.
	 *
	 * XXX
	 * The MACH code appears to enable them by setting them to 1.  !?!?!
d107 4
a110 2
	*(volatile u_int32_t *)TC_3000_500_IMR_WRITE = 0;
	wbflush();
d114 5
a118 4
tc_3000_500_intr_establish(ca, handler, val)
	struct confargs *ca;
	int (*handler) __P((void *));
	void *val;
d120 2
a121 1
	int dev = tc_3000_500_getdev(ca);
d124 1
a124 2
	if (dev == -1)
		panic("tc_3000_500_intr_establish: dev == -1");
d127 2
a128 2
	if (tc_3000_500_intrhand[dev] != tc_intrnull)
		panic("tc_3000_500_intr_establish: dev %d twice", dev);
d130 2
a131 2
	tc_3000_500_intrhand[dev] = handler;
	tc_3000_500_intrval[dev] = val;
d133 4
a136 1
	/* XXX ENABLE INTERRUPT MASK FOR DEV */
d140 3
a142 2
tc_3000_500_intr_disestablish(ca)
	struct confargs *ca;
d144 2
a145 1
	int dev = tc_3000_500_getdev(ca);
d148 1
a148 2
	if (dev == -1)
		panic("tc_3000_500_intr_disestablish: somebody goofed");
d151 2
a152 2
	if (tc_3000_500_intrhand[dev] == tc_intrnull)
		panic("tc_3000_500_intr_disestablish: dev %d missing intr",
d155 13
a167 2
	tc_3000_500_intrhand[dev] = tc_intrnull;
	tc_3000_500_intrval[dev] = (void *)(long)dev;
d169 2
a170 1
	/* XXX DISABLE INTERRUPT MASK FOR DEV */
d192 1
a192 2
		MAGIC_READ;
		wbflush();
a193 1
		wbflush();
d196 2
a197 2
#define	CHECKINTR(slot, bits)						\
		if (ir & bits) {					\
d199 2
a200 2
			(*tc_3000_500_intrhand[slot])			\
			    (tc_3000_500_intrval[slot]);		\
d203 9
a211 9
		CHECKINTR(TC_3000_500_DEV_CXTURBO, TC_3000_500_IR_CXTURBO);
		CHECKINTR(TC_3000_500_DEV_IOCTL, TC_3000_500_IR_IOCTL);
		CHECKINTR(TC_3000_500_DEV_TCDS, TC_3000_500_IR_TCDS);
		CHECKINTR(TC_3000_500_DEV_OPT5, TC_3000_500_IR_OPT5);
		CHECKINTR(TC_3000_500_DEV_OPT4, TC_3000_500_IR_OPT4);
		CHECKINTR(TC_3000_500_DEV_OPT3, TC_3000_500_IR_OPT3);
		CHECKINTR(TC_3000_500_DEV_OPT2, TC_3000_500_IR_OPT2);
		CHECKINTR(TC_3000_500_DEV_OPT1, TC_3000_500_IR_OPT1);
		CHECKINTR(TC_3000_500_DEV_OPT0, TC_3000_500_IR_OPT0);
a236 15
int
tc_3000_500_getdev(ca)
	struct confargs *ca;
{
	int i;

	for (i = 0; i < TC_3000_500_MAXDEVS; i++)
		if (ca->ca_slot == dec_3000_500_devs[i].ca_slot &&
		    ca->ca_offset == dec_3000_500_devs[i].ca_offset &&
		    !strncmp(ca->ca_name, dec_3000_500_devs[i].ca_name))
			return (i);

	return (-1);
}

d259 1
a259 1
	wbflush();
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
