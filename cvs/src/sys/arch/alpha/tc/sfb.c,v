head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.6
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.4
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.21.0.12
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.8
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.10
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.6
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.20.0.12
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.10
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.8
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.6
	OPENBSD_5_0:1.20.0.4
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.19.0.6
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.18.0.10
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.8
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.6
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.14.0.16
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.14
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.12
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.10
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.8
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.14
	UBC:1.12.0.6
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.4
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.8
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.6
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.4
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.22
date	2017.01.15.20.22.33;	author fcambus;	state Exp;
branches;
next	1.21;
commitid	tX0dEKV2WbrIyiOY;

1.21
date	2013.10.20.20.07.22;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2010.12.26.15.40.58;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.18;

1.18
date	2006.11.29.12.13.51;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.07.12.15.36.04;	author martin;	state Exp;
branches;
next	1.16;

1.16
date	2006.01.02.05.21.28;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.28.19.10.26;	author martin;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.03.15.51;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.28;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.01.18.05.30;	author art;	state Exp;
branches
	1.12.6.1;
next	1.11;

1.11
date	2000.08.04.16.45.47;	author ericj;	state Exp;
branches;
next	1.10;

1.10
date	98.11.21.18.13.04;	author millert;	state Exp;
branches
	1.10.6.1;
next	1.9;

1.9
date	97.11.06.12.27.06;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.07.31.13.40.03;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.01.24.19.58.17;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.12.08.00.20.56;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.11.23.21.45.01;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.11.12.20.29.43;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.10.30.22.41.14;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.07.29.23.02.16;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.06.18.09.45.18;	author deraadt;	state Exp;
branches;
next	;

1.10.6.1
date	2001.04.18.16.01.51;	author niklas;	state Exp;
branches;
next	1.10.6.2;

1.10.6.2
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	;

1.12.6.1
date	2002.06.11.03.33.41;	author art;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Harmonize the way frame buffer drivers display resolution and color
depth when attaching.

OK visa@@, deraadt@@
@
text
@/*	$OpenBSD: sfb.c,v 1.21 2013/10/20 20:07:22 miod Exp $	*/
/*	$NetBSD: sfb.c,v 1.7 1996/12/05 01:39:44 cgd Exp $	*/

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/conf.h>
#include <sys/ioctl.h>

#include <uvm/uvm_extern.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/tc/tcvar.h>
#include <machine/sfbreg.h>
#include <alpha/tc/sfbvar.h>

#include <dev/rcons/raster.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/wscons/wsdisplayvar.h>
#include <machine/fbio.h>

#include <machine/autoconf.h>
#include <machine/pte.h>

int	sfbmatch(struct device *, void *, void *);
void	sfbattach(struct device *, struct device *, void *);

struct cfattach sfb_ca = {
	sizeof(struct sfb_softc), sfbmatch, sfbattach,
};

struct cfdriver sfb_cd = {
	NULL, "sfb", DV_DULL,
};

void	sfb_getdevconfig(tc_addr_t dense_addr, struct sfb_devconfig *dc);
struct sfb_devconfig sfb_console_dc;
tc_addr_t sfb_consaddr;

struct wsdisplay_emulops sfb_emulfuncs = {
        rcons_cursor,                        /* could use hardware cursor; punt */
        rcons_mapchar,
        rcons_putchar,
        rcons_copycols,
        rcons_erasecols,
        rcons_copyrows,
        rcons_eraserows,
        rcons_alloc_attr
};

struct wsscreen_descr sfb_stdscreen = {
        "std",
        0, 0,        /* will be filled in -- XXX shouldn't, it's global */
        &sfb_emulfuncs,
        0, 0
};
const struct wsscreen_descr *_sfb_scrlist[] = {
        &sfb_stdscreen,
        /* XXX other formats, graphics screen? */
};

struct wsscreen_list sfb_screenlist = {
        sizeof(_sfb_scrlist) / sizeof(struct wsscreen_descr *), _sfb_scrlist
};

int	sfbioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	sfbmmap(void *, off_t, int);

static int      sfb_alloc_screen(void *, const struct wsscreen_descr *,
		    void **, int *, int *, long *);
static void     sfb_free_screen(void *, void *);
static int      sfb_show_screen(void *, void *, int,
		    void (*) (void *, int, int), void *);

#if 0
void	sfb_blank(struct sfb_devconfig *);
void	sfb_unblank(struct sfb_devconfig *);
#endif

struct wsdisplay_accessops sfb_accessops = {
        .ioctl = sfbioctl,
        .mmap = sfbmmap,
        .alloc_screen = sfb_alloc_screen,
        .free_screen = sfb_free_screen,
        .show_screen = sfb_show_screen
};

int
sfbmatch(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct tc_attach_args *ta = aux;

	if (strncmp("PMAGB-BA", ta->ta_modname, TC_ROM_LLEN) != 0)
		return (0);

	return (10);
}

void
sfb_getdevconfig(dense_addr, dc)
	tc_addr_t dense_addr;
	struct sfb_devconfig *dc;
{
	struct raster *rap;
	struct rcons *rcp;
	char *regp, *ramdacregp;
	int i;

	dc->dc_vaddr = dense_addr;
	dc->dc_paddr = ALPHA_K0SEG_TO_PHYS(dc->dc_vaddr);	/* XXX */
	dc->dc_size = SFB_SIZE;

	regp = (char *)dc->dc_vaddr + SFB_ASIC_OFFSET;
	ramdacregp = (char *)dc->dc_vaddr + SFB_RAMDAC_OFFSET;

	dc->dc_wid =
	    (*(volatile u_int32_t *)(regp + SFB_ASIC_VIDEO_HSETUP) & 0x1ff) * 4;
	dc->dc_ht =
	    (*(volatile u_int32_t *)(regp + SFB_ASIC_VIDEO_VSETUP) & 0x7ff);

	switch (*(volatile u_int32_t *)(regp + SFB_ASIC_DEEP)) {
	case 0:
	case 1:					/* XXX by the book; wrong? */
		dc->dc_depth = 8;		/* 8 plane */
		break;
	case 2:
		dc->dc_depth = 16;		/* 16 plane */
		break;
	case 4:
		dc->dc_depth = 32;		/* 32 plane */
		break;
	default:
		dc->dc_depth = 8;		/* XXX can't happen? */
		break;
	}

	dc->dc_rowbytes = dc->dc_wid * (dc->dc_depth / 8);

	dc->dc_videobase = dc->dc_vaddr + SFB_FB_OFFSET +
	    ((*(volatile u_int32_t *)(regp + SFB_ASIC_VIDEO_BASE)) *
	     4096 * (dc->dc_depth / 8));
	
	(*(volatile u_int32_t *)(regp + SFB_ASIC_MODE)) = 0;
	tc_wmb();
	(*(volatile u_int32_t *)(regp + SFB_ASIC_VIDEO_VALID)) = 1;
	tc_wmb();

	/*
	 * Set all bits in the pixel mask, to enable writes to all pixels.
	 * It seems that the console firmware clears some of them
	 * under some circumstances, which causes cute vertical stripes.
	 */
	(*(volatile u_int32_t *)(regp + SFB_ASIC_PIXELMASK)) = 0xffffffff;
	tc_wmb();
	(*(volatile u_int32_t *)(regp + SFB_ASIC_PLANEMASK)) = 0xffffffff;
	tc_wmb();

	/* Initialize the RAMDAC/colormap */
	/* start XXX XXX XXX */
	(*(volatile u_int32_t *)(ramdacregp + SFB_RAMDAC_ADDRLOW)) = 0;
	(*(volatile u_int32_t *)(ramdacregp + SFB_RAMDAC_ADDRHIGH)) = 0;
	tc_wmb();
	for (i = 0; i < 256; i++) {
		(*(volatile u_int32_t *)(ramdacregp + SFB_RAMDAC_CMAPDATA)) =
		    i ? 0xff : 0;
		tc_wmb();
		(*(volatile u_int32_t *)(ramdacregp + SFB_RAMDAC_CMAPDATA)) =
		    i ? 0xff : 0;
		tc_wmb();
		(*(volatile u_int32_t *)(ramdacregp + SFB_RAMDAC_CMAPDATA)) =
		    i ? 0xff : 0;
		tc_wmb();
	}
	/* end XXX XXX XXX */
	
	/* clear the screen */
	for (i = 0; i < dc->dc_ht * dc->dc_rowbytes; i += sizeof(u_int32_t))
		*(u_int32_t *)(dc->dc_videobase + i) = 0x00000000;

	/* initialize the raster */
	rap = &dc->dc_raster;
	rap->width = dc->dc_wid;
	rap->height = dc->dc_ht;
	rap->depth = 8;
	rap->linelongs = dc->dc_rowbytes / sizeof(u_int32_t);
	rap->pixels = (u_int32_t *)dc->dc_videobase;

	/* initialize the raster console blitter */
	rcp = &dc->dc_rcons;
	rcp->rc_sp = rap;
	rcp->rc_crow = rcp->rc_ccol = -1;
	rcp->rc_crowp = &rcp->rc_crow;
	rcp->rc_ccolp = &rcp->rc_ccol;
	rcons_init(rcp, 34, 80);

        sfb_stdscreen.nrows = dc->dc_rcons.rc_maxrow;
        sfb_stdscreen.ncols = dc->dc_rcons.rc_maxcol;
}

void
sfbattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct sfb_softc *sc = (struct sfb_softc *)self;
	struct tc_attach_args *ta = aux;
	struct wsemuldisplaydev_attach_args waa;
	int console;

	console = (ta->ta_addr == sfb_consaddr);
	if (console) {
		sc->sc_dc = &sfb_console_dc;
		sc->nscreens = 1;
	} else {
		sc->sc_dc = (struct sfb_devconfig *)
		    malloc(sizeof(struct sfb_devconfig), M_DEVBUF, M_WAITOK);
		sfb_getdevconfig(ta->ta_addr, sc->sc_dc);
	}
	if (sc->sc_dc->dc_vaddr == NULL) {
		printf(": can't map mem space\n");
		return;
	}
	printf(": %dx%d, %dbpp\n", sc->sc_dc->dc_wid, sc->sc_dc->dc_ht,
	    sc->sc_dc->dc_depth);

#if 0
	x = (char *)ta->ta_addr + SFB_ASIC_OFFSET;
	printf("%s: Video Base Address = 0x%x\n", self->dv_xname,
	    *(u_int32_t *)(x + SFB_ASIC_VIDEO_BASE));
	printf("%s: Horizontal Setup = 0x%x\n", self->dv_xname,
	    *(u_int32_t *)(x + SFB_ASIC_VIDEO_HSETUP));
	printf("%s: Vertical Setup = 0x%x\n", self->dv_xname,
	    *(u_int32_t *)(x + SFB_ASIC_VIDEO_VSETUP));
#endif

        waa.console = console;
        waa.scrdata = &sfb_screenlist;
        waa.accessops = &sfb_accessops;
        waa.accesscookie = sc;
	waa.defaultscreens = 0;

        config_found(self, &waa, wsemuldisplaydevprint);
}

int
sfbioctl(v, cmd, data, flag, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	struct sfb_softc *sc = v;
	struct sfb_devconfig *dc = sc->sc_dc;

	switch (cmd) {
	case FBIOGTYPE:
#define fbt ((struct fbtype *)data)
		fbt->fb_type = FBTYPE_SFB;
		fbt->fb_height = sc->sc_dc->dc_ht;
		fbt->fb_width = sc->sc_dc->dc_wid;
		fbt->fb_depth = sc->sc_dc->dc_depth;
		fbt->fb_cmsize = 256;		/* XXX ??? */
		fbt->fb_size = sc->sc_dc->dc_size;
#undef fbt
		return (0);

#if 0
	case FBIOPUTCMAP:
		return (*tgar->tgar_set_cmap)(dc, (struct fbcmap *)data);

	case FBIOGETCMAP:
		return (*tgar->tgar_get_cmap)(dc, (struct fbcmap *)data);
#endif

	case FBIOGATTR:
		return (ENOTTY);			/* XXX ? */

#if 0
	case FBIOSVIDEO:
		if (*(int *)data == FBVIDEO_OFF)
			sfb_blank(sc->sc_dc);
		else
			sfb_unblank(sc->sc_dc);
		return (0);
#endif

	case FBIOGVIDEO:
		*(int *)data = dc->dc_blanked ? FBVIDEO_OFF : FBVIDEO_ON;
		return (0);

#if 0
	case FBIOSCURSOR:
		return (*tgar->tgar_set_cursor)(dc, (struct fbcursor *)data);

	case FBIOGCURSOR:
		return (*tgar->tgar_get_cursor)(dc, (struct fbcursor *)data);

	case FBIOSCURPOS:
		return (*tgar->tgar_set_curpos)(dc, (struct fbcurpos *)data);

	case FBIOGCURPOS:
		return (*tgar->tgar_get_curpos)(dc, (struct fbcurpos *)data);

	case FBIOGCURMAX:
		return (*tgar->tgar_get_curmax)(dc, (struct fbcurpos *)data);
#endif
	}
	return (-1);
}

paddr_t
sfbmmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
{
	struct sfb_softc *sc = v;

	if (offset >= SFB_SIZE || offset < 0)
		return (-1);
	return sc->sc_dc->dc_paddr + offset;
}

int
sfb_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
        void *v;
        const struct wsscreen_descr *type;
        void **cookiep;
        int *curxp, *curyp;
	long *attrp;
{
        struct sfb_softc *sc = v;
	long defattr;

        if (sc->nscreens > 0)
                return (ENOMEM);

        *cookiep = &sc->sc_dc->dc_rcons; /* one and only for now */
        *curxp = 0;
        *curyp = 0;
	rcons_alloc_attr(&sc->sc_dc->dc_rcons, 0, 0, 0, &defattr);
	*attrp = defattr;
	sc->nscreens++;
        return (0);
}

void
sfb_free_screen(v, cookie)
        void *v;
        void *cookie;
{
        struct sfb_softc *sc = v;

        if (sc->sc_dc == &sfb_console_dc)
                panic("sfb_free_screen: console");

        sc->nscreens--;
}

int
sfb_show_screen(v, cookie, waitok, cb, cbarg)
        void *v;
        void *cookie;
        int waitok;
        void (*cb)(void *, int, int);
        void *cbarg;
{

        return (0);
}

#if 0
int
sfb_cnattach(addr)
        tc_addr_t addr;
{
        struct sfb_devconfig *dcp = &sfb_console_dc;
	long defattr;

        sfb_getdevconfig(addr, dcp);
	
	rcons_alloc_attr(&dcp->dc_rcons, 0, 0, 0, &defattr);

        wsdisplay_cnattach(&sfb_stdscreen, &dcp->dc_rcons,
                           0, 0, defattr);
        sfb_consaddr = addr;
        return(0);
}
#endif

#if 0
/*
 * Functions to blank and unblank the display.
 */
void
sfb_blank(dc)
	struct sfb_devconfig *dc;
{
	char *regp = (char *)dc->dc_vaddr + SFB_ASIC_OFFSET;

	if (!dc->dc_blanked) {
		dc->dc_blanked = 1;
	    	*(volatile u_int32_t *)(regp + SFB_ASIC_VIDEO_VALID) = 0;
		tc_wmb();
	}
}

void
sfb_unblank(dc)
	struct sfb_devconfig *dc;
{
	char *regp = (char *)dc->dc_vaddr + SFB_ASIC_OFFSET;
	
	if (dc->dc_blanked) {
		dc->dc_blanked = 0;
	    	*(volatile u_int32_t *)(regp + SFB_ASIC_VIDEO_VALID) = 1;
		tc_wmb();
	}
}
#endif
@


1.21
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sfb.c,v 1.20 2010/12/26 15:40:58 miod Exp $	*/
d258 1
a258 1
	printf(": %d x %d, %dbpp\n", sc->sc_dc->dc_wid, sc->sc_dc->dc_ht,
@


1.20
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: sfb.c,v 1.19 2009/03/29 21:53:52 sthen Exp $	*/
d113 5
a117 5
        sfbioctl,
        sfbmmap,
        sfb_alloc_screen,
        sfb_free_screen,
        sfb_show_screen,
@


1.19
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: sfb.c,v 1.18 2006/11/29 12:13:51 miod Exp $	*/
d357 1
a357 1
	return atop(sc->sc_dc->dc_paddr + offset);
@


1.18
log
@Add a new member to struct wsemuldisplaydev_attach_args, for a frame buffer
driver to be able to tell how many wscons screens to attach to it,
instead of WSDISPLAY_DEFAULTSCREENS which is a global setting.
@
text
@d1 1
a1 1
/*	$OpenBSD: sfb.c,v 1.17 2006/07/12 15:36:04 martin Exp $	*/
d255 1
a255 1
		printf(": couldn't map memory space; punt!\n");
@


1.17
log
@include uvm_extern.h for atop()
@
text
@d1 1
a1 1
/*	$OpenBSD: sfb.c,v 1.16 2006/01/02 05:21:28 brad Exp $	*/
d275 1
@


1.16
log
@remove last traces of __BROKEN_INDIRECT_CONFIG.

Thanks to aanriot@@ and Michael Knudsen for checking that alpha/i386/macppc
kernels still compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: sfb.c,v 1.15 2005/10/28 19:10:26 martin Exp $	*/
d39 2
@


1.15
log
@no more Mach-macros
@
text
@d1 1
a1 1
/*	$OpenBSD: sfb.c,v 1.14 2002/03/14 03:15:51 millert Exp $	*/
a54 1
#ifdef __BROKEN_INDIRECT_CONFIG
a55 3
#else
int	sfbmatch(struct device *, struct cfdata *, void *);
#endif
a120 1
#ifdef __BROKEN_INDIRECT_CONFIG
a121 3
#else
	struct cfdata *match;
#endif
@


1.14
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: sfb.c,v 1.13 2002/03/14 01:26:28 millert Exp $	*/
d362 1
a362 1
	return alpha_btop(sc->sc_dc->dc_paddr + offset);
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sfb.c,v 1.12 2001/02/01 18:05:30 art Exp $	*/
d104 1
a104 1
                                      void **, int *, int *, long *);
d106 2
a107 2
static int      sfb_show_screen __P((void *, void *, int,
                                     void (*) (void *, int, int), void *));
@


1.12
log
@Adapt to recent wscons changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: sfb.c,v 1.11 2000/08/04 16:45:47 ericj Exp $	*/
d56 1
a56 1
int	sfbmatch __P((struct device *, void *, void *));
d58 1
a58 1
int	sfbmatch __P((struct device *, struct cfdata *, void *));
d60 1
a60 1
void	sfbattach __P((struct device *, struct device *, void *));
d70 1
a70 1
void	sfb_getdevconfig __P((tc_addr_t dense_addr, struct sfb_devconfig *dc));
d100 2
a101 2
int	sfbioctl __P((void *, u_long, caddr_t, int, struct proc *));
paddr_t	sfbmmap __P((void *, off_t, int));
d103 3
a105 3
static int      sfb_alloc_screen __P((void *, const struct wsscreen_descr *,
                                      void **, int *, int *, long *));
static void     sfb_free_screen __P((void *, void *));
d110 2
a111 2
void	sfb_blank __P((struct sfb_devconfig *));
void	sfb_unblank __P((struct sfb_devconfig *));
d406 1
a406 1
        void (*cb) __P((void *, int, int));
@


1.12.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sfb.c,v 1.12 2001/02/01 18:05:30 art Exp $	*/
d56 1
a56 1
int	sfbmatch(struct device *, void *, void *);
d58 1
a58 1
int	sfbmatch(struct device *, struct cfdata *, void *);
d60 1
a60 1
void	sfbattach(struct device *, struct device *, void *);
d70 1
a70 1
void	sfb_getdevconfig(tc_addr_t dense_addr, struct sfb_devconfig *dc);
d100 2
a101 2
int	sfbioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	sfbmmap(void *, off_t, int);
d103 5
a107 5
static int      sfb_alloc_screen(void *, const struct wsscreen_descr *,
		    void **, int *, int *, long *);
static void     sfb_free_screen(void *, void *);
static int      sfb_show_screen(void *, void *, int,
		    void (*) (void *, int, int), void *);
d110 2
a111 2
void	sfb_blank(struct sfb_devconfig *);
void	sfb_unblank(struct sfb_devconfig *);
d406 1
a406 1
        void (*cb)(void *, int, int);
@


1.11
log
@
convert sfb and cfb to use new wscons; from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: sfb.c,v 1.10 1998/11/21 18:13:04 millert Exp $	*/
d101 1
a101 1
int	sfbmmap __P((void *, off_t, int));
d352 1
a352 1
int
@


1.10
log
@when mmap'ing check for offset >= size, not just > size and disallow negative offsets; mrg@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: sfb.c,v 1.9 1997/11/06 12:27:06 niklas Exp $	*/
a45 3
#if 0
#include <alpha/tc/bt459reg.h>
#endif
d49 1
a49 1
#include <dev/wscons/wsconsvar.h>
a60 1
int	sfbprint __P((void *, const char *));
d72 23
d96 2
a97 8
struct wscons_emulfuncs sfb_emulfuncs = {
	rcons_cursor,			/* could use hardware cursor; punt */
	rcons_putstr,
	rcons_copycols,
	rcons_erasecols,
	rcons_copyrows,
	rcons_eraserows,
	rcons_setattr,
d103 6
d114 8
d236 3
d248 1
a248 2
	struct wscons_attach_args waa;
	struct wscons_odev_spec *wo;
d251 2
a252 2
	console = 0;					/* XXX */
	if (console)
d254 2
a255 1
	else {
d277 4
a280 23
	waa.waa_isconsole = console;
	wo = &waa.waa_odev_spec;

	wo->wo_emulfuncs = &sfb_emulfuncs;
	wo->wo_emulfuncs_cookie = &sc->sc_dc->dc_rcons;

	wo->wo_ioctl = sfbioctl;
	wo->wo_mmap = sfbmmap;
	wo->wo_miscfuncs_cookie = sc;

	wo->wo_nrows = sc->sc_dc->dc_rcons.rc_maxrow;
	wo->wo_ncols = sc->sc_dc->dc_rcons.rc_maxcol;
	wo->wo_crow = 0;
	wo->wo_ccol = 0;

	config_found(self, &waa, sfbprint);
}

int
sfbprint(aux, pnp)
	void *aux;
	const char *pnp;
{
d282 1
a282 3
	if (pnp)
		printf("wscons at %s", pnp);
	return (UNCONF);
d365 23
a387 1
#if 0
d389 3
a391 4
tga_console(bc, pc, bus, device, function)
	bus_chipset_tag_t bc;
	pci_chipset_tag_t pc;
	int bus, device, function;
d393 1
a393 2
	struct tga_devconfig *dcp = &tga_console_dc;
	struct wscons_odev_spec wo;
d395 2
a396 1
	tga_getdevconfig(bc, pc, pci_make_tag(pc, bus, device, function), dcp);
d398 2
a399 7
	/* sanity checks */
	if (dcp->dc_vaddr == NULL)
		panic("tga_console(%d, %d): couldn't map memory space",
		    device, function);
	if (dcp->dc_tgaconf == NULL)
		panic("tga_console(%d, %d): unknown board configuration",
		    device, function);
d401 19
a419 6
	/*
	 * Initialize the RAMDAC but DO NOT allocate any private storage.
	 * Initialization includes disabling cursor, setting a sane
	 * colormap, etc.  It will be reinitialized in tgaattach().
	 */
	(*dcp->dc_tgaconf->tgac_ramdac->tgar_init)(dcp, 0);
d421 3
a423 7
	wo.wo_ef = &tga_emulfuncs;
	wo.wo_efa = &dcp->dc_rcons;
	wo.wo_nrows = dcp->dc_rcons.rc_maxrow;
	wo.wo_ncols = dcp->dc_rcons.rc_maxcol;
	wo.wo_crow = 0;
	wo.wo_ccol = 0;
	/* ioctl and mmap are unused until real attachment. */
d425 4
a428 1
	wscons_attach_console(&wo);
@


1.10.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: sfb.c,v 1.12 2001/02/01 18:05:30 art Exp $	*/
d46 3
d52 1
a52 1
#include <dev/wscons/wsdisplayvar.h>
d64 1
a75 23
tc_addr_t sfb_consaddr;

struct wsdisplay_emulops sfb_emulfuncs = {
        rcons_cursor,                        /* could use hardware cursor; punt */
        rcons_mapchar,
        rcons_putchar,
        rcons_copycols,
        rcons_erasecols,
        rcons_copyrows,
        rcons_eraserows,
        rcons_alloc_attr
};

struct wsscreen_descr sfb_stdscreen = {
        "std",
        0, 0,        /* will be filled in -- XXX shouldn't, it's global */
        &sfb_emulfuncs,
        0, 0
};
const struct wsscreen_descr *_sfb_scrlist[] = {
        &sfb_stdscreen,
        /* XXX other formats, graphics screen? */
};
d77 8
a84 2
struct wsscreen_list sfb_screenlist = {
        sizeof(_sfb_scrlist) / sizeof(struct wsscreen_descr *), _sfb_scrlist
d88 1
a88 7
paddr_t	sfbmmap __P((void *, off_t, int));

static int      sfb_alloc_screen __P((void *, const struct wsscreen_descr *,
                                      void **, int *, int *, long *));
static void     sfb_free_screen __P((void *, void *));
static int      sfb_show_screen __P((void *, void *, int,
                                     void (*) (void *, int, int), void *));
a94 8
struct wsdisplay_accessops sfb_accessops = {
        sfbioctl,
        sfbmmap,
        sfb_alloc_screen,
        sfb_free_screen,
        sfb_show_screen,
};

a208 3

        sfb_stdscreen.nrows = dc->dc_rcons.rc_maxrow;
        sfb_stdscreen.ncols = dc->dc_rcons.rc_maxcol;
d218 2
a219 1
	struct wsemuldisplaydev_attach_args waa;
d222 2
a223 2
	console = (ta->ta_addr == sfb_consaddr);
	if (console) {
d225 1
a225 2
		sc->nscreens = 1;
	} else {
d247 23
a269 4
        waa.console = console;
        waa.scrdata = &sfb_screenlist;
        waa.accessops = &sfb_accessops;
        waa.accesscookie = sc;
d271 3
a273 1
        config_found(self, &waa, wsemuldisplaydevprint);
d343 1
a343 1
paddr_t
d356 1
a356 23
int
sfb_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
        void *v;
        const struct wsscreen_descr *type;
        void **cookiep;
        int *curxp, *curyp;
	long *attrp;
{
        struct sfb_softc *sc = v;
	long defattr;

        if (sc->nscreens > 0)
                return (ENOMEM);

        *cookiep = &sc->sc_dc->dc_rcons; /* one and only for now */
        *curxp = 0;
        *curyp = 0;
	rcons_alloc_attr(&sc->sc_dc->dc_rcons, 0, 0, 0, &defattr);
	*attrp = defattr;
	sc->nscreens++;
        return (0);
}

d358 4
a361 3
sfb_free_screen(v, cookie)
        void *v;
        void *cookie;
d363 2
a364 1
        struct sfb_softc *sc = v;
d366 1
a366 2
        if (sc->sc_dc == &sfb_console_dc)
                panic("sfb_free_screen: console");
d368 7
a374 2
        sc->nscreens--;
}
d376 6
a381 8
int
sfb_show_screen(v, cookie, waitok, cb, cbarg)
        void *v;
        void *cookie;
        int waitok;
        void (*cb) __P((void *, int, int));
        void *cbarg;
{
d383 7
a389 14
        return (0);
}

#if 0
int
sfb_cnattach(addr)
        tc_addr_t addr;
{
        struct sfb_devconfig *dcp = &sfb_console_dc;
	long defattr;

        sfb_getdevconfig(addr, dcp);
	
	rcons_alloc_attr(&dcp->dc_rcons, 0, 0, 0, &defattr);
d391 1
a391 4
        wsdisplay_cnattach(&sfb_stdscreen, &dcp->dc_rcons,
                           0, 0, defattr);
        sfb_consaddr = addr;
        return(0);
@


1.10.6.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 1
a56 1
int	sfbmatch(struct device *, void *, void *);
d58 1
a58 1
int	sfbmatch(struct device *, struct cfdata *, void *);
d60 1
a60 1
void	sfbattach(struct device *, struct device *, void *);
d70 1
a70 1
void	sfb_getdevconfig(tc_addr_t dense_addr, struct sfb_devconfig *dc);
d100 2
a101 2
int	sfbioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	sfbmmap(void *, off_t, int);
d103 5
a107 5
static int      sfb_alloc_screen(void *, const struct wsscreen_descr *,
		    void **, int *, int *, long *);
static void     sfb_free_screen(void *, void *);
static int      sfb_show_screen(void *, void *, int,
		    void (*) (void *, int, int), void *);
d110 2
a111 2
void	sfb_blank(struct sfb_devconfig *);
void	sfb_unblank(struct sfb_devconfig *);
d406 1
a406 1
        void (*cb)(void *, int, int);
@


1.9
log
@Add some missing things for the MI vga driver.  Move wscons to an MI place as
well.  $OpenBSD$ tagging
@
text
@d1 1
a1 1
/*	$OpenBSD: sfb.c,v 1.8 1997/07/31 13:40:03 kstailey Exp $	*/
d351 2
a352 2
	if (offset > SFB_SIZE)
		return -1;
@


1.8
log
@text video attributes, tested only on vga, send me E-mail if it breaks something, thx.
@
text
@d1 1
a1 1
/*	$OpenBSD: sfb.c,v 1.7 1997/01/24 19:58:17 niklas Exp $	*/
d51 2
a52 2
#include <alpha/wscons/wscons_raster.h>
#include <alpha/wscons/wsconsvar.h>
@


1.7
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: sfb.c,v 1.6 1996/12/08 00:20:56 niklas Exp $	*/
d84 1
@


1.6
log
@Merge to NetBSD 961107, i.e. mostly new bus.h
@
text
@d1 2
a2 2
/*	$OpenBSD: sfb.c,v 1.5 1996/11/23 21:45:01 kstailey Exp $	*/
/*	$NetBSD: sfb.c,v 1.5 1996/10/13 03:00:35 christos Exp $	*/
d58 1
d60 3
d86 2
a87 2
int	sfbioctl __P((struct device *, u_long, caddr_t, int, struct proc *));
int	sfbmmap __P((struct device *, off_t, int));
d97 6
a102 1
	void *match, *aux;
d248 8
a255 2
	wo->wo_ef = &sfb_emulfuncs;
	wo->wo_efa = &sc->sc_dc->dc_rcons;
a259 2
	wo->wo_ioctl = sfbioctl;
	wo->wo_mmap = sfbmmap;
d276 2
a277 2
sfbioctl(dev, cmd, data, flag, p)
	struct device *dev;
d283 1
a283 1
	struct sfb_softc *sc = (struct sfb_softc *)dev;
d343 2
a344 2
sfbmmap(dev, offset, prot)
	struct device *dev;
d348 1
a348 1
	struct sfb_softc *sc = (struct sfb_softc *)dev;
@


1.5
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: sfb.c,v 1.4 1996/11/12 20:29:43 niklas Exp $	*/
d40 1
a40 1
#include <machine/bus.old.h>
@


1.4
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$OpenBSD: sfb.c,v 1.3 1996/10/30 22:41:14 niklas Exp $	*/
d60 1
a60 1
int	sfbprint __P((void *, /* const */ char *));
d254 1
a254 1
	/* const */ char *pnp;
@


1.3
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: sfb.c,v 1.5 1996/10/13 03:00:35 christos Exp $	*/
d40 1
a40 1
#include <machine/bus.h>
@


1.2
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: sfb.c,v 1.1 1996/05/01 21:15:50 cgd Exp $	*/
/*	$NetBSD: sfb.c,v 1.1 1996/05/01 21:15:50 cgd Exp $	*/
d60 1
a60 1
int	sfbprint __P((void *, char *));
a94 1
	struct cfdata *cf = match;
d114 1
a114 1
	dc->dc_paddr = k0segtophys(dc->dc_vaddr);		/* XXX */
a210 1
	char *x;
d254 1
a254 1
	char *pnp;
@


1.1
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@
