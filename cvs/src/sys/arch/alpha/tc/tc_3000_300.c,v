head	1.18;
access;
symbols
	OPENBSD_6_1:1.18.0.10
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.6
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.4
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.17.0.14
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.18
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.16
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.12
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.10
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.8
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.6
	OPENBSD_5_0:1.17.0.4
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.14.0.8
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.4
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.6
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.11.0.8
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.6
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.9
	UBC:1.6.0.16
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.14
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.12
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.10
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.8
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.6
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.4
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2015.05.19.20.28.14;	author miod;	state Exp;
branches;
next	1.17;
commitid	YdrkA6WJKqXchmio;

1.17
date	2010.09.22.12.36.32;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2010.09.22.11.44.01;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	2010.09.20.06.33.46;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	2008.08.09.16.42.29;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.06.18.20.05;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.04.12.33.17;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.28.02.28.43;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.13.21.32.17;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.02.22.56.06;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.03.15.51;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.28;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.01.11.05.11.04;	author millert;	state Exp;
branches
	1.6.6.1
	1.6.16.1;
next	1.5;

1.5
date	96.10.30.22.41.16;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.07.29.23.02.19;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.06.18.09.45.20;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.26.18.12.04;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.50;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.50;	author deraadt;	state Exp;
branches;
next	;

1.6.6.1
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	1.6.6.2;

1.6.6.2
date	2003.03.27.23.18.06;	author niklas;	state Exp;
branches;
next	1.6.6.3;

1.6.6.3
date	2003.05.16.00.29.38;	author niklas;	state Exp;
branches;
next	;

1.6.16.1
date	2002.06.11.03.33.41;	author art;	state Exp;
branches;
next	1.6.16.2;

1.6.16.2
date	2003.05.19.21.38.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Move acquisition of the kernel lock deeper in the interrupt path, and make
sure clock interrupts do not attempt to acquire it.
This will also eventually allow for IPL_MPSAFE interrupts on alpha.

Tested by dlg@@ and I.
@
text
@/* $OpenBSD: tc_3000_300.c,v 1.17 2010/09/22 12:36:32 miod Exp $ */
/* $NetBSD: tc_3000_300.c,v 1.26 2001/07/27 00:25:21 thorpej Exp $ */

/*
 * Copyright (c) 1994, 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <machine/autoconf.h>
#include <machine/pte.h>

#include <dev/tc/tcvar.h>
#include <dev/tc/ioasicreg.h>
#include <alpha/tc/tc_conf.h>
#include <alpha/tc/tc_3000_300.h>

#include "wsdisplay.h"
#include "sfb.h"

#if NSFB > 0
extern int	sfb_cnattach(tc_addr_t);
#endif

int	tc_3000_300_intrnull(void *);

#define	C(x)	((void *)(u_long)x)
#define	KV(x)	(ALPHA_PHYS_TO_K0SEG(x))

/*
 * We have to read and modify the IOASIC registers directly, because
 * the TC option slot interrupt request and mask bits are stored there,
 * and the ioasic code isn't initted when we need to frob some interrupt
 * bits.
 */
#define	DEC_3000_300_IOASIC_ADDR	KV(0x1a0000000)

struct tc_slotdesc tc_3000_300_slots[] = {
	{ KV(0x100000000), C(TC_3000_300_DEV_OPT0), },	/* 0 - opt slot 0 */
	{ KV(0x120000000), C(TC_3000_300_DEV_OPT1), },	/* 1 - opt slot 1 */
	{ KV(0x140000000), C(TC_3000_300_DEV_BOGUS), }, /* 2 - unused */
	{ KV(0x160000000), C(TC_3000_300_DEV_BOGUS), }, /* 3 - unused */
	{ KV(0x180000000), C(TC_3000_300_DEV_BOGUS), },	/* 4 - TCDS ASIC */
	{ KV(0x1a0000000), C(TC_3000_300_DEV_BOGUS), }, /* 5 - IOCTL ASIC */
	{ KV(0x1c0000000), C(TC_3000_300_DEV_BOGUS), }, /* 6 - CXTurbo */
};
int tc_3000_300_nslots =
    sizeof(tc_3000_300_slots) / sizeof(tc_3000_300_slots[0]);

struct tc_builtin tc_3000_300_builtins[] = {
	{ "PMAGB-BA",	6, 0x02000000, C(TC_3000_300_DEV_CXTURBO),	},
	{ "FLAMG-IO",	5, 0x00000000, C(TC_3000_300_DEV_IOASIC),	},
	{ "PMAZ-DS ",	4, 0x00000000, C(TC_3000_300_DEV_TCDS),		},
};
int tc_3000_300_nbuiltins =
    sizeof(tc_3000_300_builtins) / sizeof(tc_3000_300_builtins[0]);

struct tcintr {
	int	(*tci_func)(void *);
	void	*tci_arg;
	int	tci_level;
	struct evcount tci_count;
} tc_3000_300_intr[TC_3000_300_NCOOKIES];

void
tc_3000_300_intr_setup()
{
	volatile u_int32_t *imskp;
	u_long i;

	/*
	 * Disable all interrupts that we can (can't disable builtins).
	 */
	imskp = (volatile u_int32_t *)(DEC_3000_300_IOASIC_ADDR + IOASIC_IMSK);
	*imskp &= ~(IOASIC_INTR_300_OPT0 | IOASIC_INTR_300_OPT1);

	/*
	 * Set up interrupt handlers.
	 */
	for (i = 0; i < TC_3000_300_NCOOKIES; i++) {
                tc_3000_300_intr[i].tci_func = tc_3000_300_intrnull;
                tc_3000_300_intr[i].tci_arg = (void *)i;
                tc_3000_300_intr[i].tci_level = IPL_HIGH;
	}
}

void
tc_3000_300_intr_establish(tcadev, cookie, level, func, arg, name)
	struct device *tcadev;
	void *cookie, *arg;
	int level;
	int (*func)(void *);
	const char *name;
{
	volatile u_int32_t *imskp;
	u_long dev = (u_long)cookie;

#ifdef DIAGNOSTIC
	/* XXX bounds-check cookie. */
#endif

	if (tc_3000_300_intr[dev].tci_func != tc_3000_300_intrnull)
		panic("tc_3000_300_intr_establish: cookie %lu twice", dev);

	tc_3000_300_intr[dev].tci_func = func;
	tc_3000_300_intr[dev].tci_arg = arg;
	tc_3000_300_intr[dev].tci_level = level;
	if (name != NULL)
		evcount_attach(&tc_3000_300_intr[dev].tci_count, name, NULL);

	imskp = (volatile u_int32_t *)(DEC_3000_300_IOASIC_ADDR + IOASIC_IMSK);
	switch (dev) {
	case TC_3000_300_DEV_OPT0:
		*imskp |= IOASIC_INTR_300_OPT0;
		break;
	case TC_3000_300_DEV_OPT1:
		*imskp |= IOASIC_INTR_300_OPT1;
		break;
	default:
		/* interrupts for builtins always enabled */
		break;
	}
}

void
tc_3000_300_intr_disestablish(tcadev, cookie, name)
	struct device *tcadev;
	void *cookie;
	const char *name;
{
	volatile u_int32_t *imskp;
	u_long dev = (u_long)cookie;

#ifdef DIAGNOSTIC
	/* XXX bounds-check cookie. */
#endif

	if (tc_3000_300_intr[dev].tci_func == tc_3000_300_intrnull)
		panic("tc_3000_300_intr_disestablish: cookie %lu bad intr",
		    dev);

	imskp = (volatile u_int32_t *)(DEC_3000_300_IOASIC_ADDR + IOASIC_IMSK);
	switch (dev) {
	case TC_3000_300_DEV_OPT0:
		*imskp &= ~IOASIC_INTR_300_OPT0;
		break;
	case TC_3000_300_DEV_OPT1:
		*imskp &= ~IOASIC_INTR_300_OPT1;
		break;
	default:
		/* interrupts for builtins always enabled */
		break;
	}

	tc_3000_300_intr[dev].tci_func = tc_3000_300_intrnull;
	tc_3000_300_intr[dev].tci_arg = (void *)dev;
	tc_3000_300_intr[dev].tci_level = IPL_HIGH;
	if (name != NULL)
		evcount_detach(&tc_3000_300_intr[dev].tci_count);
}

int
tc_3000_300_intrnull(val)
	void *val;
{

	panic("tc_3000_300_intrnull: uncaught TC intr for cookie %ld",
	    (u_long)val);
}

void
tc_3000_300_iointr(arg, vec)
	void *arg;
	unsigned long vec;
{
	u_int32_t tcir, ioasicir, ioasicimr;
	int ifound;

	do {
		tc_syncbus();

		/* find out what interrupts/errors occurred */
		tcir = *(volatile u_int32_t *)TC_3000_300_IR;
		ioasicir = *(volatile u_int32_t *)
		    (DEC_3000_300_IOASIC_ADDR + IOASIC_INTR);
		ioasicimr = *(volatile u_int32_t *)
		    (DEC_3000_300_IOASIC_ADDR + IOASIC_IMSK);
		tc_mb();

		/* Ignore interrupts that aren't enabled out. */
		ioasicir &= ioasicimr;

		/* clear the interrupts/errors we found. */
		*(volatile u_int32_t *)TC_3000_300_IR = tcir;
		/* XXX can't clear TC option slot interrupts here? */
		tc_wmb();

		ifound = 0;

#ifdef MULTIPROCESSOR
#define	INTRLOCK(slot)							\
		if (tc_3000_300_intr[slot].tci_level < IPL_CLOCK)	\
			__mp_lock(&kernel_lock)
#define	INTRUNLOCK(slot)						\
		if (tc_3000_300_intr[slot].tci_level < IPL_CLOCK)	\
			__mp_unlock(&kernel_lock)
#else
#define	INTRLOCK(slot)		do { } while (0)
#define	INTRUNLOCK(slot)	do { } while (0)
#endif
#define	CHECKINTR(slot, flag)						\
		if (flag) {						\
			ifound = 1;					\
			INTRLOCK(slot);					\
			(*tc_3000_300_intr[slot].tci_func)		\
			    (tc_3000_300_intr[slot].tci_arg);		\
			tc_3000_300_intr[slot].tci_count.ec_count++;	\
			INTRUNLOCK(slot);				\
		}

		/* Do them in order of priority; highest slot # first. */
		CHECKINTR(TC_3000_300_DEV_CXTURBO,
		    tcir & TC_3000_300_IR_CXTURBO);
		CHECKINTR(TC_3000_300_DEV_IOASIC,
		    (tcir & TC_3000_300_IR_IOASIC) &&
	            (ioasicir & ~(IOASIC_INTR_300_OPT1|IOASIC_INTR_300_OPT0)));
		CHECKINTR(TC_3000_300_DEV_TCDS, tcir & TC_3000_300_IR_TCDS);
		CHECKINTR(TC_3000_300_DEV_OPT1,
		    ioasicir & IOASIC_INTR_300_OPT1);
		CHECKINTR(TC_3000_300_DEV_OPT0,
		    ioasicir & IOASIC_INTR_300_OPT0);

#undef INTRUNLOCK
#undef INTRLOCK
#undef CHECKINTR

#ifdef DIAGNOSTIC
#define PRINTINTR(msg, bits)						\
	if (tcir & bits)						\
		printf(msg);

		PRINTINTR("BCache tag parity error\n",
		    TC_3000_300_IR_BCTAGPARITY);
		PRINTINTR("TC overrun error\n", TC_3000_300_IR_TCOVERRUN);
		PRINTINTR("TC I/O timeout\n", TC_3000_300_IR_TCTIMEOUT);
		PRINTINTR("Bcache parity error\n",
		    TC_3000_300_IR_BCACHEPARITY);
		PRINTINTR("Memory parity error\n", TC_3000_300_IR_MEMPARITY);

#undef PRINTINTR
#endif
	} while (ifound);
}

#if NWSDISPLAY > 0
/*
 * tc_3000_300_fb_cnattach --
 *	Attempt to map the CTB output device to a slot and attach the
 * framebuffer as the output side of the console.
 */
int
tc_3000_300_fb_cnattach(turbo_slot)
	u_int64_t turbo_slot;
{
	u_int32_t output_slot;

	output_slot = turbo_slot & 0xffffffff;

	if (output_slot >= tc_3000_300_nslots) {
		return EINVAL;
	}

	if (output_slot == 0) {
#if NSFB > 0
		sfb_cnattach(KV(0x1c0000000) + 0x02000000);
		return 0;
#else
		return ENXIO;
#endif
	}

	return tc_fb_cnattach(tc_3000_300_slots[output_slot-1].tcs_addr);
}
#endif /* NWSDISPLAY */
@


1.17
log
@Revert previous and let drivers register counterless interrupts;
tc_intr_disestablish() prototype is changed to carry information whether the
counter needs to be detached or not.

This does not matter much since no driver ever calls tc_intr_disestablish().
@
text
@d1 1
a1 1
/* $OpenBSD: tc_3000_300.c,v 1.16 2010/09/22 11:44:01 matthew Exp $ */
d87 1
d109 1
d133 1
d183 1
a204 11
#ifdef DIAGNOSTIC
	int s;
	if (vec != 0x800)
		panic("INVALID ASSUMPTION: vec 0x%lx, not 0x800", vec);
	s = splhigh();
	if (s != ALPHA_PSL_IPL_IO)
		panic("INVALID ASSUMPTION: IPL %d, not %d", s,
		    ALPHA_PSL_IPL_IO);
	splx(s);
#endif

d226 11
d240 1
a240 1
			tc_3000_300_intr[slot].tci_count.ec_count++;	\
d243 2
d246 1
d258 3
d267 1
d275 1
@


1.16
log
@Switch to unconditionally attaching evcounts on TurboChannel
interrupts, since inspecting the code, they seem to always attach
anyway.  This fixes compiler fallout from my evcount simplification.

build error reported by naddy@@; "seems sensible" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: tc_3000_300.c,v 1.15 2010/09/20 06:33:46 matthew Exp $ */
a121 2
	KASSERT(name != NULL);

d131 2
a132 1
	evcount_attach(&tc_3000_300_intr[dev].tci_count, name, NULL);
d149 1
a149 1
tc_3000_300_intr_disestablish(tcadev, cookie)
d152 1
d180 2
a181 1
	evcount_detach(&tc_3000_300_intr[dev].tci_count);
@


1.15
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: tc_3000_300.c,v 1.14 2008/08/09 16:42:29 miod Exp $ */
d122 2
d133 1
a133 3
	if (name != NULL)
		evcount_attach(&tc_3000_300_intr[dev].tci_count,
		    name, NULL);
d180 1
a180 2
	if (tc_3000_300_intr[dev].tci_count.ec_parent != NULL)
		evcount_detach(&tc_3000_300_intr[dev].tci_count);
@


1.14
log
@Pass a device name to {tc,tcds,ioasic}_intr_establish in order to get
meaningful names associated to the interrupt counters.
@
text
@d1 1
a1 1
/* $OpenBSD: tc_3000_300.c,v 1.13 2007/11/06 18:20:05 miod Exp $ */
d133 1
a133 1
		    name, NULL, &evcount_intr);
@


1.13
log
@Get rid of TC_IPL_xxx values and tc_intrlevel_t, and use IPL_xxx and int.
No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: tc_3000_300.c,v 1.12 2006/03/04 12:33:17 miod Exp $ */
a87 1
	char	tci_name[12];
a107 4
		snprintf(tc_3000_300_intr[i].tci_name,
		    sizeof tc_3000_300_intr[i].tci_name, "tc slot %u", i);
		evcount_attach(&tc_3000_300_intr[i].tci_count,
		    tc_3000_300_intr[i].tci_name, NULL, &evcount_intr);
d112 1
a112 1
tc_3000_300_intr_establish(tcadev, cookie, level, func, arg)
d117 1
d131 3
d180 2
@


1.12
log
@Better names for turbochannel event counters.
@
text
@d1 1
a1 1
/* $OpenBSD: tc_3000_300.c,v 1.11 2004/06/28 02:28:43 aaron Exp $ */
d120 1
a120 1
	tc_intrlevel_t level;
@


1.11
log
@Use new event counter API for interrupt counting on alpha.  By me, with some
edits by Theo.  deraadt@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: tc_3000_300.c,v 1.10 2003/05/13 21:32:17 deraadt Exp $ */
d88 1
a94 1
	char *cp;
d109 4
a112 7
		
		cp = malloc(12, M_DEVBUF, M_NOWAIT);
		if (cp == NULL)
			panic("tc_3000_300_intr_setup");
		snprintf(cp, 12, "slot %lu", i);
		evcount_attach(&tc_3000_300_intr[i].tci_count, "tc", NULL,
		    &evcount_intr);
@


1.10
log
@snprintf
@
text
@d1 1
a1 1
/* $OpenBSD: tc_3000_300.c,v 1.9 2002/05/02 22:56:06 miod Exp $ */
a37 1
#include <machine/intrcnt.h>
d87 1
a87 1
	struct evcnt tci_evcnt;
d114 2
a115 4
#ifdef EVCNT_COUNTERS
		evcnt_attach_dynamic(&tc_3000_300_intr[i].tci_evcnt,
		    EVCNT_TYPE_INTR, NULL, "tc", cp);
#endif
a118 14
const struct evcnt *
tc_3000_300_intr_evcnt(tcadev, cookie)
	struct device *tcadev;
	void *cookie;
{
	u_long dev = (u_long)cookie;

#ifdef DIAGNOSTIC
	/* XXX bounds-check cookie. */
#endif

	return (&tc_3000_300_intr[dev].tci_evcnt);
}

a234 6
#ifdef EVCNT_COUNTERS
#define	INCRINTRCNT(slot)	tc_3000_300_intr[slot].tci_evcnt.ev_count++
#else
#define	INCRINTRCNT(slot)	intrcnt[INTRCNT_KN16 + slot]++
#endif

d238 1
a238 1
			INCRINTRCNT(slot);				\
@


1.9
log
@Big TURBOchannel support catchup from NetBSD, part 1.
A few local changes and tweaks remain.

This bring DEC 3000 machines back in the game, but framebuffers are still
not supported at the moment.

Thanks to ericj@@ and nate@@ for supplying me a DEC 3000 for testing.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d114 1
a114 1
		sprintf(cp, "slot %lu", i);
@


1.8
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 2
a2 2
/*	$OpenBSD: tc_3000_300.c,v 1.7 2002/03/14 01:26:28 millert Exp $	*/
/*	$NetBSD: tc_3000_300.c,v 1.12 1996/10/13 03:00:37 christos Exp $	*/
d34 1
a37 1
#ifndef EVCNT_COUNTERS
a38 1
#endif
d41 1
a43 1
#include <alpha/tc/ioasicreg.h>
d45 6
a50 5
void	tc_3000_300_intr_setup(void);
void	tc_3000_300_intr_establish(struct device *, void *,
	    tc_intrlevel_t, int (*)(void *), void *);
void	tc_3000_300_intr_disestablish(struct device *, void *);
void	tc_3000_300_iointr(void *, unsigned long);
d68 5
a72 3
	{ KV(0x180000000), C(TC_3000_300_DEV_BOGUS), },	/* 2 - TCDS ASIC */
	{ KV(0x1a0000000), C(TC_3000_300_DEV_BOGUS), },	/* 3 - IOCTL ASIC */
	{ KV(0x1c0000000), C(TC_3000_300_DEV_CXTURBO), }, /* 4 - CXTurbo */
d78 3
a80 3
	{ "PMAGB-BA",	4, 0x02000000, C(TC_3000_300_DEV_CXTURBO),	},
	{ "FLAMG-IO",	3, 0x00000000, C(TC_3000_300_DEV_IOASIC),	},
	{ "PMAZ-DS ",	2, 0x00000000, C(TC_3000_300_DEV_TCDS),		},
d88 1
d95 1
d101 1
a101 1
	imskp = (volatile u_int32_t *)IOASIC_REG_IMSK(DEC_3000_300_IOASIC_ADDR);
d110 9
d122 14
d151 1
a151 1
		panic("tc_3000_300_intr_establish: cookie %d twice", dev);
d156 1
a156 1
	imskp = (volatile u_int32_t *)IOASIC_REG_IMSK(DEC_3000_300_IOASIC_ADDR);
d183 1
a183 1
		panic("tc_3000_300_intr_disestablish: cookie %d bad intr",
d186 1
a186 1
	imskp = (volatile u_int32_t *)IOASIC_REG_IMSK(DEC_3000_300_IOASIC_ADDR);
d213 2
a214 2
tc_3000_300_iointr(framep, vec)
	void *framep;
d237 1
a237 1
		    IOASIC_REG_INTR(DEC_3000_300_IOASIC_ADDR);
d239 1
a239 1
		    IOASIC_REG_IMSK(DEC_3000_300_IOASIC_ADDR);
d253 2
a254 3
	/* No interrupt counting via evcnt counters */
	XXX BREAK HERE XXX
#else /* !EVCNT_COUNTERS */
d256 1
a256 1
#endif /* EVCNT_COUNTERS */
d293 31
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: tc_3000_300.c,v 1.6 1999/01/11 05:11:04 millert Exp $	*/
d47 2
a48 2
void	tc_3000_300_intr_establish __P((struct device *, void *,
	    tc_intrlevel_t, int (*)(void *), void *));
@


1.6
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: tc_3000_300.c,v 1.5 1996/10/30 22:41:16 niklas Exp $	*/
d46 1
a46 1
void	tc_3000_300_intr_setup __P((void));
d49 2
a50 2
void	tc_3000_300_intr_disestablish __P((struct device *, void *));
void	tc_3000_300_iointr __P((void *, unsigned long));
d52 1
a52 1
int	tc_3000_300_intrnull __P((void *));
d84 1
a84 1
	int	(*tci_func) __P((void *));
d114 1
a114 1
	int (*func) __P((void *));
@


1.6.16.1
log
@Sync UBC branch to -current
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* $NetBSD: tc_3000_300.c,v 1.26 2001/07/27 00:25:21 thorpej Exp $ */
a33 1
#include <sys/malloc.h>
d37 1
d39 1
a41 1
#include <dev/tc/ioasicreg.h>
d44 1
d46 5
a50 6
#include "wsdisplay.h"
#include "sfb.h"

#if NSFB > 0
extern int	sfb_cnattach(tc_addr_t);
#endif
d52 1
a52 1
int	tc_3000_300_intrnull(void *);
d68 3
a70 5
	{ KV(0x140000000), C(TC_3000_300_DEV_BOGUS), }, /* 2 - unused */
	{ KV(0x160000000), C(TC_3000_300_DEV_BOGUS), }, /* 3 - unused */
	{ KV(0x180000000), C(TC_3000_300_DEV_BOGUS), },	/* 4 - TCDS ASIC */
	{ KV(0x1a0000000), C(TC_3000_300_DEV_BOGUS), }, /* 5 - IOCTL ASIC */
	{ KV(0x1c0000000), C(TC_3000_300_DEV_BOGUS), }, /* 6 - CXTurbo */
d76 3
a78 3
	{ "PMAGB-BA",	6, 0x02000000, C(TC_3000_300_DEV_CXTURBO),	},
	{ "FLAMG-IO",	5, 0x00000000, C(TC_3000_300_DEV_IOASIC),	},
	{ "PMAZ-DS ",	4, 0x00000000, C(TC_3000_300_DEV_TCDS),		},
d84 1
a84 1
	int	(*tci_func)(void *);
a85 1
	struct evcnt tci_evcnt;
a91 1
	char *cp;
d97 1
a97 1
	imskp = (volatile u_int32_t *)(DEC_3000_300_IOASIC_ADDR + IOASIC_IMSK);
a105 9
		
		cp = malloc(12, M_DEVBUF, M_NOWAIT);
		if (cp == NULL)
			panic("tc_3000_300_intr_setup");
		sprintf(cp, "slot %lu", i);
#ifdef EVCNT_COUNTERS
		evcnt_attach_dynamic(&tc_3000_300_intr[i].tci_evcnt,
		    EVCNT_TYPE_INTR, NULL, "tc", cp);
#endif
a108 14
const struct evcnt *
tc_3000_300_intr_evcnt(tcadev, cookie)
	struct device *tcadev;
	void *cookie;
{
	u_long dev = (u_long)cookie;

#ifdef DIAGNOSTIC
	/* XXX bounds-check cookie. */
#endif

	return (&tc_3000_300_intr[dev].tci_evcnt);
}

d114 1
a114 1
	int (*func)(void *);
d124 1
a124 1
		panic("tc_3000_300_intr_establish: cookie %lu twice", dev);
d129 1
a129 1
	imskp = (volatile u_int32_t *)(DEC_3000_300_IOASIC_ADDR + IOASIC_IMSK);
d156 1
a156 1
		panic("tc_3000_300_intr_disestablish: cookie %lu bad intr",
d159 1
a159 1
	imskp = (volatile u_int32_t *)(DEC_3000_300_IOASIC_ADDR + IOASIC_IMSK);
d186 2
a187 2
tc_3000_300_iointr(arg, vec)
	void *arg;
d210 1
a210 1
		    (DEC_3000_300_IOASIC_ADDR + IOASIC_INTR);
d212 1
a212 1
		    (DEC_3000_300_IOASIC_ADDR + IOASIC_IMSK);
d226 3
a228 2
#define	INCRINTRCNT(slot)	tc_3000_300_intr[slot].tci_evcnt.ev_count++
#else
d230 1
a230 1
#endif
a266 31

#if NWSDISPLAY > 0
/*
 * tc_3000_300_fb_cnattach --
 *	Attempt to map the CTB output device to a slot and attach the
 * framebuffer as the output side of the console.
 */
int
tc_3000_300_fb_cnattach(turbo_slot)
	u_int64_t turbo_slot;
{
	u_int32_t output_slot;

	output_slot = turbo_slot & 0xffffffff;

	if (output_slot >= tc_3000_300_nslots) {
		return EINVAL;
	}

	if (output_slot == 0) {
#if NSFB > 0
		sfb_cnattach(KV(0x1c0000000) + 0x02000000);
		return 0;
#else
		return ENXIO;
#endif
	}

	return tc_fb_cnattach(tc_3000_300_slots[output_slot-1].tcs_addr);
}
#endif /* NWSDISPLAY */
@


1.6.16.2
log
@sync
@
text
@d114 1
a114 1
		snprintf(cp, 12, "slot %lu", i);
@


1.6.6.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 5
a50 5
void	tc_3000_300_intr_setup(void);
void	tc_3000_300_intr_establish(struct device *, void *,
	    tc_intrlevel_t, int (*)(void *), void *);
void	tc_3000_300_intr_disestablish(struct device *, void *);
void	tc_3000_300_iointr(void *, unsigned long);
d52 1
a52 1
int	tc_3000_300_intrnull(void *);
d84 1
a84 1
	int	(*tci_func)(void *);
d114 1
a114 1
	int (*func)(void *);
@


1.6.6.2
log
@Sync the SMP branch with 3.3
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* $NetBSD: tc_3000_300.c,v 1.26 2001/07/27 00:25:21 thorpej Exp $ */
a33 1
#include <sys/malloc.h>
d37 1
d39 1
a41 1
#include <dev/tc/ioasicreg.h>
d44 1
d46 5
a50 6
#include "wsdisplay.h"
#include "sfb.h"

#if NSFB > 0
extern int	sfb_cnattach(tc_addr_t);
#endif
d68 3
a70 5
	{ KV(0x140000000), C(TC_3000_300_DEV_BOGUS), }, /* 2 - unused */
	{ KV(0x160000000), C(TC_3000_300_DEV_BOGUS), }, /* 3 - unused */
	{ KV(0x180000000), C(TC_3000_300_DEV_BOGUS), },	/* 4 - TCDS ASIC */
	{ KV(0x1a0000000), C(TC_3000_300_DEV_BOGUS), }, /* 5 - IOCTL ASIC */
	{ KV(0x1c0000000), C(TC_3000_300_DEV_BOGUS), }, /* 6 - CXTurbo */
d76 3
a78 3
	{ "PMAGB-BA",	6, 0x02000000, C(TC_3000_300_DEV_CXTURBO),	},
	{ "FLAMG-IO",	5, 0x00000000, C(TC_3000_300_DEV_IOASIC),	},
	{ "PMAZ-DS ",	4, 0x00000000, C(TC_3000_300_DEV_TCDS),		},
a85 1
	struct evcnt tci_evcnt;
a91 1
	char *cp;
d97 1
a97 1
	imskp = (volatile u_int32_t *)(DEC_3000_300_IOASIC_ADDR + IOASIC_IMSK);
a105 9
		
		cp = malloc(12, M_DEVBUF, M_NOWAIT);
		if (cp == NULL)
			panic("tc_3000_300_intr_setup");
		sprintf(cp, "slot %lu", i);
#ifdef EVCNT_COUNTERS
		evcnt_attach_dynamic(&tc_3000_300_intr[i].tci_evcnt,
		    EVCNT_TYPE_INTR, NULL, "tc", cp);
#endif
a108 14
const struct evcnt *
tc_3000_300_intr_evcnt(tcadev, cookie)
	struct device *tcadev;
	void *cookie;
{
	u_long dev = (u_long)cookie;

#ifdef DIAGNOSTIC
	/* XXX bounds-check cookie. */
#endif

	return (&tc_3000_300_intr[dev].tci_evcnt);
}

d124 1
a124 1
		panic("tc_3000_300_intr_establish: cookie %lu twice", dev);
d129 1
a129 1
	imskp = (volatile u_int32_t *)(DEC_3000_300_IOASIC_ADDR + IOASIC_IMSK);
d156 1
a156 1
		panic("tc_3000_300_intr_disestablish: cookie %lu bad intr",
d159 1
a159 1
	imskp = (volatile u_int32_t *)(DEC_3000_300_IOASIC_ADDR + IOASIC_IMSK);
d186 2
a187 2
tc_3000_300_iointr(arg, vec)
	void *arg;
d210 1
a210 1
		    (DEC_3000_300_IOASIC_ADDR + IOASIC_INTR);
d212 1
a212 1
		    (DEC_3000_300_IOASIC_ADDR + IOASIC_IMSK);
d226 3
a228 2
#define	INCRINTRCNT(slot)	tc_3000_300_intr[slot].tci_evcnt.ev_count++
#else
d230 1
a230 1
#endif
a266 31

#if NWSDISPLAY > 0
/*
 * tc_3000_300_fb_cnattach --
 *	Attempt to map the CTB output device to a slot and attach the
 * framebuffer as the output side of the console.
 */
int
tc_3000_300_fb_cnattach(turbo_slot)
	u_int64_t turbo_slot;
{
	u_int32_t output_slot;

	output_slot = turbo_slot & 0xffffffff;

	if (output_slot >= tc_3000_300_nslots) {
		return EINVAL;
	}

	if (output_slot == 0) {
#if NSFB > 0
		sfb_cnattach(KV(0x1c0000000) + 0x02000000);
		return 0;
#else
		return ENXIO;
#endif
	}

	return tc_fb_cnattach(tc_3000_300_slots[output_slot-1].tcs_addr);
}
#endif /* NWSDISPLAY */
@


1.6.6.3
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d114 1
a114 1
		snprintf(cp, 12, "slot %lu", i);
@


1.5
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: tc_3000_300.c,v 1.12 1996/10/13 03:00:37 christos Exp $	*/
d181 1
a181 1
	panic("tc_3000_300_intrnull: uncaught TC intr for cookie %ld\n",
@


1.4
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: tc_3000_300.c,v 1.7.4.1 1996/06/05 00:39:06 cgd Exp $	*/
/*	$NetBSD: tc_3000_300.c,v 1.7.4.1 1996/06/05 00:39:06 cgd Exp $	*/
d32 1
d50 1
a50 1
void	tc_3000_300_iointr __P((void *, int));
d55 1
a55 1
#define	KV(x)	(phystok0seg(x))
d188 1
a188 1
	int vec;
d191 1
a191 1
	int opt0intr, opt1intr, ifound;
d196 1
a196 1
		panic("INVALID ASSUMPTION: vec %x, not 0x800", vec);
d198 3
a200 2
	if (s != PSL_IPL_IO)
		panic("INVALID ASSUMPTION: IPL %d, not %d", s, PSL_IPL_IO);
@


1.3
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.2
log
@from netbsd:
machine-independent TurboChannel bus configuration.  These files
deal with stuff like:
        (1) configuring built-in devices,
        (2) looking at TC slots configuring any devices found.
The lists of slots, slot locations, etc. and built-in devices
are provided by machine-dependent code.  Interrupt handling
is also provided by machine-dependent code, but the MD code provides
hooks so that standard names for 'establish' and 'disestablish'
can be used in drivers.

This code requires <machine/tc_machdep.h>, which defines some
portability types specific to the TurboChannel bus code.
@
text
@d1 1
a1 1
/*	$NetBSD: tc_3000_300.c,v 1.4 1995/12/20 00:43:27 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1994, 1995 Carnegie-Mellon University.
d35 3
d42 1
d55 8
a85 5
/* XXX */
void	ioasic_intr_300_opt0_enable __P((int));
void	ioasic_intr_300_opt1_enable __P((int));
void	ioasic_300_opts_isintr __P((int *, int *));

d89 1
d93 1
a93 1
	 * Sisable all interrupts that we can (can't disable builtins).
d95 2
a96 2
	ioasic_intr_300_opt0_enable(0);
	ioasic_intr_300_opt1_enable(0);
d114 1
d127 1
d130 1
a130 1
		ioasic_intr_300_opt0_enable(1);
d133 1
a133 1
		ioasic_intr_300_opt1_enable(1);
d146 1
d157 1
d160 1
a160 1
		ioasic_intr_300_opt0_enable(0);
d163 1
a163 1
		ioasic_intr_300_opt1_enable(0);
d188 1
a188 1
	u_int32_t ir;
d205 5
a209 2
		ir = *(volatile u_int32_t *)TC_3000_300_IR;
		ioasic_300_opts_isintr(&opt0intr, &opt1intr);
d212 3
d216 1
a216 1
		*(volatile u_int32_t *)TC_3000_300_IR = ir;
d221 8
d230 1
a230 1
		if (flag) {					\
d232 1
d237 10
a246 5
		CHECKINTR(TC_3000_300_DEV_CXTURBO, ir & TC_3000_300_IR_CXTURBO);
		CHECKINTR(TC_3000_300_DEV_IOASIC, ir & TC_3000_300_IR_IOASIC);
		CHECKINTR(TC_3000_300_DEV_TCDS, ir & TC_3000_300_IR_TCDS);
		CHECKINTR(TC_3000_300_DEV_OPT1, opt1intr);
		CHECKINTR(TC_3000_300_DEV_OPT0, opt0intr);
d251 1
a251 1
	if (ir & bits)							\
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: tc_3000_300.c,v 1.3 1995/08/03 00:52:29 cgd Exp $	*/
d36 2
a37 1
#include <alpha/tc/tc.h>
a39 1
/* XXX ESTABLISH, DISESTABLISH */
d41 3
a43 3
void	tc_3000_300_intr_establish
	    __P((struct confargs *, intr_handler_t, void *));
void	tc_3000_300_intr_disestablish __P((struct confargs *));
a44 1
int	tc_3000_300_getdev __P((struct confargs *));
d46 4
a49 11
#define	KV(x)	((caddr_t)phystok0seg(x))
#define	TC_3000_300_NSLOTS	5
#define	TC_3000_300_MAXDEVS	5

static struct tc_slot_desc dec_3000_300_slots[TC_3000_300_NSLOTS] = {
	{ KV(0x100000000), },		/* slot 0 - TC option slot 0 */
	{ KV(0x120000000), },		/* slot 1 - TC option slot 1 */
	{ KV(0x180000000), },		/* slot 2 - TCDS ASIC on cpu board */
	{ KV(0x1a0000000), },		/* slot 3 - IOCTL ASIC on cpu board */
	{ KV(0x1c0000000), },		/* slot 4 - CXTurbo on cpu board */
};
d51 6
a56 6
static struct confargs dec_3000_300_devs[TC_3000_300_MAXDEVS] = {
	{ "PMAGB-BA",	4, 0x02000000,	},
	{ "IOCTL   ",	3, 0x00000000,	},
	{ "PMAZ-DS ",	2, 0x00000000,	},
	{ NULL,		1, 0x0,		},
	{ NULL,		0, 0x0,		},
d58 2
d61 4
a64 14
/* Indices into the struct confargs array. */
#define	TC_3000_300_DEV_CXTURBO	0
#define	TC_3000_300_DEV_IOCTL	1
#define	TC_3000_300_DEV_TCDS	2
#define	TC_3000_300_DEV_OPT1	3
#define	TC_3000_300_DEV_OPT0	4

struct tc_cpu_desc dec_3000_300_cpu = {
	dec_3000_300_slots, TC_3000_300_NSLOTS,
	dec_3000_300_devs, TC_3000_300_MAXDEVS,
	tc_3000_300_intr_setup,
	tc_3000_300_intr_establish,
	tc_3000_300_intr_disestablish,
	tc_3000_300_iointr,
d66 2
d69 9
a77 2
intr_handler_t	tc_3000_300_intrhand[TC_3000_300_MAXDEVS];
void		*tc_3000_300_intrval[TC_3000_300_MAXDEVS];
d82 1
a82 1
	int i;
d84 12
a95 4
	/* Set up interrupt handlers. */
	for (i = 0; i < TC_3000_300_MAXDEVS; i++) {
		tc_3000_300_intrhand[i] = tc_intrnull;
		tc_3000_300_intrval[i] = (void *)(long)i;
d100 5
a104 4
tc_3000_300_intr_establish(ca, handler, val)
	struct confargs *ca;
	int (*handler) __P((void *));
	void *val;
d106 1
a106 1
	int dev = tc_3000_300_getdev(ca);
d109 1
a109 2
	if (dev == -1)
		panic("tc_3000_300_intr_establish: dev == -1");
d112 2
a113 2
	if (tc_3000_300_intrhand[dev] != tc_intrnull)
		panic("tc_3000_300_intr_establish: dev %d twice", dev);
d115 2
a116 2
	tc_3000_300_intrhand[dev] = handler;
	tc_3000_300_intrval[dev] = val;
d118 11
a128 1
	/* XXX ENABLE INTERRUPT MASK FOR DEV */
d132 3
a134 2
tc_3000_300_intr_disestablish(ca)
	struct confargs *ca;
d136 1
a136 1
	int dev = tc_3000_300_getdev(ca);
d139 1
a139 2
	if (dev == -1)
		panic("tc_3000_300_intr_disestablish: somebody goofed");
d142 2
a143 2
	if (tc_3000_300_intrhand[dev] == tc_intrnull)
		panic("tc_3000_300_intr_disestablish: dev %d missing intr",
d146 11
a156 2
	tc_3000_300_intrhand[dev] = tc_intrnull;
	tc_3000_300_intrval[dev] = (void *)(long)dev;
d158 11
a168 1
	/* XXX DISABLE INTERRUPT MASK FOR DEV */
d177 1
a177 1
	int ifound;
d190 1
a190 2
		MAGIC_READ;
		wbflush();
d194 2
a195 1
		wbflush();
d199 2
a200 1
		wbflush();
d203 2
a204 2
#define	CHECKINTR(slot, bits)						\
		if (ir & bits) {					\
d206 2
a207 2
			(*tc_3000_300_intrhand[slot])			\
			    (tc_3000_300_intrval[slot]);		\
d210 5
a214 10
		CHECKINTR(TC_3000_300_DEV_CXTURBO, TC_3000_300_IR_CXTURBO);
		CHECKINTR(TC_3000_300_DEV_IOCTL, TC_3000_300_IR_IOCTL);
		CHECKINTR(TC_3000_300_DEV_TCDS, TC_3000_300_IR_TCDS);
#if 0
		CHECKINTR(TC_3000_300_DEV_OPT1, TC_3000_300_IR_OPT1);
		CHECKINTR(TC_3000_300_DEV_OPT0, TC_3000_300_IR_OPT0);
#else
		/* XXX XXX XXX CHECK OPTION SLOT INTERRUPTS!!! */
		/* XXX XXX XXX THEIR BITS LIVE IN ANOTHER REG. */
#endif
a216 1

a230 15
}

int
tc_3000_300_getdev(ca)
	struct confargs *ca;
{
	int i;

	for (i = 0; i < TC_3000_300_MAXDEVS; i++)
		if (ca->ca_slot == dec_3000_300_devs[i].ca_slot &&
		    ca->ca_offset == dec_3000_300_devs[i].ca_offset &&
		    !strncmp(ca->ca_name, dec_3000_300_devs[i].ca_name))
			return (i);

	return (-1);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
