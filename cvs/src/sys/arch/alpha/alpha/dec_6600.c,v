head	1.14;
access;
symbols
	OPENBSD_6_2:1.14.0.12
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.14
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.10
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.6
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.8
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.13.0.16
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.12
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.9.0.6
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.4
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.8.0.6
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.4
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.6
	UBC:1.4.0.2
	UBC_BASE:1.4
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.14
date	2014.05.08.20.46.49;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2010.11.23.04.07.55;	author shadchin;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.26.20.17.26;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.17.18.30.05;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2008.07.16.20.03.20;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.09.21.55.12;	author martin;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.06.21.53.59;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.25.21.33.19;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.26;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.12.14.00.44.59;	author nate;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.12.13.19.13.22;	author nate;	state Exp;
branches;
next	1.2;

1.2
date	2000.11.16.23.32.20;	author ericj;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.11.16.04.50.17;	author ericj;	state Exp;
branches;
next	;

1.2.2.1
date	2001.04.18.16.00.17;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2002.03.06.00.24.08;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2002.03.28.10.06.12;	author niklas;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2003.03.27.23.18.05;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2002.06.11.03.33.39;	author art;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2002.10.29.00.28.00;	author art;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Format string fixes for alpha kernels, and remove -Wno-format
@
text
@/* $OpenBSD: dec_6600.c,v 1.13 2010/11/23 04:07:55 shadchin Exp $ */
/* $NetBSD: dec_6600.c,v 1.7 2000/06/20 03:48:54 matt Exp $ */

/*
 * Copyright (c) 2009 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 1995, 1996, 1997 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/termios.h>
#include <dev/cons.h>

#include <machine/rpb.h>
#include <machine/autoconf.h>
#include <machine/cpuconf.h>
#include <machine/bus.h>
#include <machine/logout.h>

#include <dev/ic/comreg.h>
#include <dev/ic/comvar.h>

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>
#include <dev/ic/i8042reg.h>
#include <dev/ic/pckbcvar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>

#include <alpha/pci/tsreg.h>
#include <alpha/pci/tsvar.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <dev/ata/atavar.h>

#include "pckbd.h"

#ifndef CONSPEED
#define CONSPEED TTYDEF_SPEED
#endif

#define	DR_VERBOSE(f) while (0)

static int comcnrate __attribute__((unused)) = CONSPEED;

void dec_6600_init(void);
static void dec_6600_cons_init(void);
static void dec_6600_device_register(struct device *, void *);
static void dec_6600_mcheck_handler(unsigned long, struct trapframe *,
	    unsigned long, unsigned long);
#ifndef SMALL_KERNEL
static void dec_6600_environmental_mcheck(unsigned long, struct trapframe *,
	    unsigned long, unsigned long);
static void dec_6600_mcheck(unsigned long, struct trapframe *, unsigned long,
	    unsigned long);
static void dec_6600_print_syndrome(int, unsigned long);
#endif

void
dec_6600_init()
{

	platform.family = "6600";

	if ((platform.model = alpha_dsr_sysname()) == NULL) {
		/* XXX Don't know the system variations, yet. */
		platform.model = alpha_unknown_sysname();
	}

	platform.iobus = "tsc";
	platform.cons_init = dec_6600_cons_init;
	platform.device_register = dec_6600_device_register;
	platform.mcheck_handler = dec_6600_mcheck_handler;
	STQP(TS_C_DIM0) = 0UL;
	STQP(TS_C_DIM1) = 0UL;
}

static void
dec_6600_cons_init()
{
	struct ctb *ctb;
	u_int64_t ctbslot;
	struct tsp_config *tsp;

	ctb = (struct ctb *)(((caddr_t)hwrpb) + hwrpb->rpb_ctb_off);
	ctbslot = ctb->ctb_turboslot;

	/* Console hose defaults to hose 0. */
	tsp_console_hose = 0;

	tsp = tsp_init(0, tsp_console_hose);

	switch (ctb->ctb_term_type) {
	case CTB_PRINTERPORT: 
		/* serial console ... */
		/* XXX */
		{
			/*
			 * Delay to allow PROM putchars to complete.
			 * FIFO depth * character time,
			 * character time = (1000000 / (defaultrate / 10))
			 */
			DELAY(160000000 / comcnrate);

			if(comcnattach(&tsp->pc_iot, 0x3f8, comcnrate,
			    COM_FREQ,
			    (TTYDEF_CFLAG & ~(CSIZE | PARENB)) | CS8))
				panic("can't init serial console");

			break;
		}

	case CTB_GRAPHICS:
#if NPCKBD > 0
		/* display console ... */
		/* XXX */
		(void) pckbc_cnattach(&tsp->pc_iot, IO_KBD, KBCMDP, 0);

		if (CTB_TURBOSLOT_TYPE(ctbslot) ==
		    CTB_TURBOSLOT_TYPE_ISA)
			isa_display_console(&tsp->pc_iot, &tsp->pc_memt);
		else {
			/* The display PCI might be different */
			tsp_console_hose = CTB_TURBOSLOT_HOSE(ctbslot);
			tsp = tsp_init(0, tsp_console_hose);
			pci_display_console(&tsp->pc_iot, &tsp->pc_memt,
			    &tsp->pc_pc, CTB_TURBOSLOT_BUS(ctbslot),
			    CTB_TURBOSLOT_SLOT(ctbslot), 0);
		}
#else
		panic("not configured to use display && keyboard console");
#endif
		break;

	default:
		printf("ctb_term_type = 0x%lx ctb_turboslot = 0x%lx"
		    " hose = %ld\n",
		    (unsigned long)ctb->ctb_term_type,
		    (unsigned long)ctbslot,
		    (unsigned long)CTB_TURBOSLOT_HOSE(ctbslot));

		panic("consinit: unknown console type %lu",
		    (unsigned long)ctb->ctb_term_type);
	}
}

static void
dec_6600_device_register(dev, aux)
	struct device *dev;
	void *aux;
{
	static int found, initted, diskboot, netboot;
	static struct device *primarydev, *pcidev, *ctrlrdev;
	struct bootdev_data *b = bootdev_data;
	struct device *parent = dev->dv_parent;
	struct cfdata *cf = dev->dv_cfdata;
	struct cfdriver *cd = cf->cf_driver;

	if (found)
		return;

	if (!initted) {
		diskboot = (strncasecmp(b->protocol, "SCSI", 4) == 0) ||
		    (strncasecmp(b->protocol, "IDE", 3) == 0);
		netboot = (strncasecmp(b->protocol, "BOOTP", 5) == 0) ||
		    (strncasecmp(b->protocol, "MOP", 3) == 0);
		DR_VERBOSE(printf("diskboot = %d, netboot = %d\n", diskboot,
		    netboot));
		initted = 1;
	}

	if (primarydev == NULL) {
		if (strcmp(cd->cd_name, "tsp"))
			return;
		else {
			struct tsp_attach_args *tsp = aux;

			if (b->bus != tsp->tsp_slot)
				return;
			primarydev = dev;
			DR_VERBOSE(printf("\nprimarydev = %s\n",
			    dev->dv_xname));
			return;
		}
	}

	if (pcidev == NULL) {
		if (strcmp(cd->cd_name, "pci"))
			return;
		/*
		 * Try to find primarydev anywhere in the ancestry.  This is
		 * necessary if the PCI bus is hidden behind a bridge.
		 */
		while (parent) {
			if (parent == primarydev)
				break;
			parent = parent->dv_parent;
		}
		if (!parent)
			return;
		else {
			struct pcibus_attach_args *pba = aux;

			if ((b->slot / 1000) != pba->pba_bus)
				return;
	
			pcidev = dev;
			DR_VERBOSE(printf("\npcidev = %s\n", dev->dv_xname));
			return;
		}
	}

	if (ctrlrdev == NULL) {
		if (parent != pcidev)
			return;
		else {
			struct pci_attach_args *pa = aux;
			int slot;

			slot = pa->pa_bus * 1000 + pa->pa_function * 100 +
			    pa->pa_device;
			if (b->slot != slot)
				return;
	
			if (netboot) {
				booted_device = dev;
				DR_VERBOSE(printf("\nbooted_device = %s\n",
				    dev->dv_xname));
				found = 1;
			} else {
				ctrlrdev = dev;
				DR_VERBOSE(printf("\nctrlrdev = %s\n",
				    dev->dv_xname));
			}
			return;
		}
	}

	if (!diskboot)
		return;

	if (!strcmp(cd->cd_name, "sd") || !strcmp(cd->cd_name, "st") ||
	    !strcmp(cd->cd_name, "cd")) {
		struct scsi_attach_args *sa = aux;
		struct scsi_link *periph = sa->sa_sc_link;
		int unit;

		if (parent->dv_parent != ctrlrdev)
			return;

		unit = periph->target * 100 + periph->lun;
		if (b->unit != unit)
                        return;

		/* we've found it! */
		booted_device = dev;
		DR_VERBOSE(printf("\nbooted_device = %s\n", dev->dv_xname));
		found = 1;
	}

	/*
	 * Support to boot from IDE drives.
	 */
	if (!strcmp(cd->cd_name, "wd")) {
		struct ata_atapi_attach *aa_link = aux;

		if ((strcmp("pciide", parent->dv_cfdata->cf_driver->cd_name) != 0))
			return;
		if (parent != ctrlrdev)
			return;

		DR_VERBOSE(printf("\nAtapi info: drive: %d, channel %d\n",
		    aa_link->aa_drv_data->drive, aa_link->aa_channel));
		DR_VERBOSE(printf("Bootdev info: unit: %d, channel: %d\n",
		    b->unit, b->channel));
		if (b->unit != aa_link->aa_drv_data->drive ||
		    b->channel != aa_link->aa_channel)
			return;

		/* we've found it! */
		booted_device = dev;
		DR_VERBOSE(printf("booted_device = %s\n", dev->dv_xname));
		found = 1;
	}
}

#ifndef SMALL_KERNEL
static void
dec_6600_environmental_mcheck(unsigned long mces, struct trapframe *framep,
    unsigned long vector, unsigned long logout)
{
	mc_hdr_ev6 *hdr = (mc_hdr_ev6 *)logout;
	mc_env_ev6 *env = (mc_env_ev6 *)(logout + hdr->la_system_offset);
	int silent = 0;
	int itemno;

	/*
	 * Note that we do not check for an expected machine check,
	 * since software is not supposed to trigger an environmental
	 * machine check, and there might be an environmental change
	 * just before our expected machine check occurs.
	 */

	/*
	 * Most environmental changes are handled at the RMC level,
	 * and we are either not notified (e.g. PCI door open) or
	 * drastic action is taken (e.g. the RMC will power down the
	 * system immediately if the CPU door is open).
	 *
	 * The only events we seem to be notified of are power supply
	 * failures.
	 */

	/* display CPU failures */
	for (itemno = 0; itemno < 4; itemno++) {
		if ((env->cpuir & EV6_ENV_CPUIR_CPU_ENABLE(itemno)) != 0 &&
		    (env->cpuir & EV6_ENV_CPUIR_CPU_FAIL(itemno)) != 0) {
			printf("CPU%d FAILURE\n", itemno);
			silent = 1;
		}
	}

	/* display PSU failures */
	if (env->smir & EV6_ENV_SMIR_PSU_FAILURE) {
		for (itemno = 0; itemno < 3; itemno++) {
			if ((env->psir & EV6_ENV_PSIR_PSU_FAIL(itemno)) != 0) {
				if ((env->psir &
				    EV6_ENV_PSIR_PSU_ENABLE(itemno)) != 0)
					printf("PSU%d FAILURE\n", itemno);
				else
					printf("PSU%d DISABLED\n", itemno);
			} else {
				if ((env->psir &
				    EV6_ENV_PSIR_PSU_ENABLE(itemno)) != 0)
					printf("PSU%d ENABLED\n", itemno);
			}
		}
		silent = 1;
	}

	/* if we could not print a summary, display everything */
	if (silent == 0) {
		printf("      Processor Environmental Machine Check, "
		    "Code 0x%x\n", hdr->mcheck_code);

		printf("Flags\t%016lx\n", (unsigned long)env->flags);
		printf("DIR\t%016lx\n", (unsigned long)env->c_dir);
		printf("SMIR\t%016lx\n", (unsigned long)env->smir);
		printf("CPUIR\t%016lx\n", (unsigned long)env->cpuir);
		printf("PSIR\t%016lx\n", (unsigned long)env->psir);
		printf("LM78_ISR\t%016lx\n", (unsigned long)env->lm78_isr);
		printf("Doors\t%016lx\n", (unsigned long)env->doors);
		printf("Temp Warning\t%016lx\n",
		    (unsigned long)env->temp_warning);
		printf("Fan Control\t%016lx\n",
		    (unsigned long)env->fan_control);
		printf("Fatal Power Down\t%016lx\n",
		    (unsigned long)env->fatal_power_down);
	}

	/*
	 * Apparently, these checks occur with MCES == 0, which
	 * is supposed to be an uncorrectable machine check.
	 *
	 * Until I know of a better way to tell recoverable and
	 * unrecoverable environmental checks apart, I'll use
	 * the fatal power down code to discriminate.
	 */
	if (mces == 0 && env->fatal_power_down == 0)
		return;
	else
		machine_check(mces, framep, vector, logout);
}

/*
 * Expected syndrome values per faulting bit
 */
static const uint8_t ev6_syndrome[64 + 8] = {
	0xce, 0xcb, 0xd3, 0xd5, 0xd6, 0xd9, 0xda, 0xdc,
	0x23, 0x25, 0x26, 0x29, 0x2a, 0x2c, 0x31, 0x34,
	0x0e, 0x0b, 0x13, 0x15, 0x16, 0x19, 0x1a, 0x1c,
	0xe3, 0xe5, 0xe6, 0xe9, 0xea, 0xec, 0xf1, 0xf4,
	0x4f, 0x4a, 0x52, 0x54, 0x57, 0x58, 0x5b, 0x5d,
	0xa2, 0xa4, 0xa7, 0xa8, 0xab, 0xad, 0xb0, 0xb5,
	0x8f, 0x8a, 0x92, 0x94, 0x97, 0x98, 0x9b, 0x9d,
	0x62, 0x64, 0x67, 0x68, 0x6b, 0x6d, 0x70, 0x75,
	0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80
};

static void
dec_6600_print_syndrome(int sno, unsigned long syndrome)
{
	unsigned int bitno;

	syndrome &= 0xff;
	printf("Syndrome bits %d\t%02lx ", sno, syndrome);
	for (bitno = 0; bitno < nitems(ev6_syndrome); bitno++)
		if (syndrome == ev6_syndrome[bitno])
			break;

	if (bitno < 64)
		printf("(%d)\n", bitno);
	else if (bitno < nitems(ev6_syndrome))
		printf("(CB%d)\n", bitno - 64);
	else
		printf("(unknown)\n");
}

static void
dec_6600_mcheck(unsigned long mces, struct trapframe *framep,
    unsigned long vector, unsigned long logout)
{
	mc_hdr_ev6 *hdr = (mc_hdr_ev6 *)logout;
	struct mchkinfo *mcp;

	/*
	 * If we expected a machine check, don't decode it.
	 */
	mcp = &curcpu()->ci_mcinfo;
	if (mcp->mc_expected) {
		machine_check(mces, framep, vector, logout);
		return;
	}

	printf("      Processor Machine Check (%lx), Code 0x%x\n",
	    vector, hdr->mcheck_code);

	if (vector == ALPHA_SYS_MCHECK) {
#ifdef notyet
		mc_sys_ev6 *sys = (mc_sys_ev6 *)(logout + hdr->la_system_offset);
#endif
		/* XXX Decode and report P-Chip errors */
	} else /* ALPHA_PROC_MCHECK */ {
		mc_cpu_ev6 *cpu = (mc_cpu_ev6 *)(logout + hdr->la_cpu_offset);
		size_t cpu_size = hdr->la_system_offset - hdr->la_cpu_offset;

		printf("Dcache status\t0x%05lx\n",
		    (unsigned long)cpu->dc_stat & EV6_DC_STAT_MASK);
		dec_6600_print_syndrome(0, cpu->c_syndrome_0);
		dec_6600_print_syndrome(1, cpu->c_syndrome_1);
		/* C_STAT */
		printf("C_STAT\t");
		switch (cpu->c_stat & EV6_C_STAT_MASK) {
		case EV6_C_STAT_DBL_ISTREAM_BC_ECC_ERR:
			printf("Bcache instruction stream double ECC error\n");
			break;
		case EV6_C_STAT_DBL_ISTREAM_MEM_ECC_ERR:
			printf("Memory instruction stream double ECC error\n");
			break;
		case EV6_C_STAT_DBL_DSTREAM_BC_ECC_ERR:
			printf("Bcache data stream double ECC error\n");
			break;
		case EV6_C_STAT_DBL_DSTREAM_MEM_ECC_ERR:
			printf("Memory data stream double ECC error\n");
			break;
		case EV6_C_STAT_SNGL_ISTREAM_BC_ECC_ERR:
			printf("Bcache instruction stream single ECC error\n");
			break;
		case EV6_C_STAT_SNGL_ISTREAM_MEM_ECC_ERR:
			printf("Memory instruction stream single ECC error\n");
			break;
		case EV6_C_STAT_SNGL_BC_PROBE_HIT_ERR:
		case EV6_C_STAT_SNGL_BC_PROBE_HIT_ERR2:
			printf("Bcache probe hit error\n");
			break;
		case EV6_C_STAT_SNGL_DSTREAM_DC_ECC_ERR:
			printf("Dcache data stream single ECC error\n");
			break;
		case EV6_C_STAT_SNGL_DSTREAM_BC_ECC_ERR:
			printf("Bcache data stream single ECC error\n");
			break;
		case EV6_C_STAT_SNGL_DSTREAM_MEM_ECC_ERR:
			printf("Memory data stream single ECC error\n");
			break;
		case EV6_C_STAT_SNGL_DC_DUPLICATE_TAG_PERR:
			printf("Dcache duplicate tag error\n");
			break;
		case EV6_C_STAT_SNGL_BC_TAG_PERR:
			printf("Bcache tag error\n");
			break;
		case EV6_C_STAT_NO_ERROR:
			if (cpu->dc_stat & EV6_DC_STAT_STORE_DATA_ECC_ERROR) {
				printf("Bcache/Dcache victim read ECC error\n");
				break;
			}
			/* FALLTHROUGH */
		default:
			printf("%02lx\n", (unsigned long)cpu->c_stat);
			break;
		}
		/* C_ADDR */
		printf("Error address\t");
		if ((cpu->c_stat & EV6_C_STAT_MASK) ==
		    EV6_C_STAT_SNGL_DSTREAM_DC_ECC_ERR)
			printf("0xXXXXXXXXXXX%05lx\n",
			    (unsigned long)cpu->c_addr & 0xfffc0);
		else
			printf("0x%016lx\n",
			    (unsigned long)cpu->c_addr & 0xffffffffffffffc0);

		if (cpu_size > offsetof(mc_cpu_ev6, exc_addr)) {
			printf("Exception address\t0x%016lx%s\n",
			    (unsigned long)cpu->exc_addr & 0xfffffffffffffffc,
			    cpu->exc_addr & 1 ? " in PAL mode" : "");
			/* other fields are not really informative */
		}
	}

	machine_check(mces, framep, vector, logout);
}
#endif

static void
dec_6600_mcheck_handler(unsigned long mces, struct trapframe *framep,
    unsigned long vector, unsigned long param)
{
#ifdef SMALL_KERNEL
	/*
	 * Even though we can not afford the machine check
	 * analysis code, we need to ignore environmental
	 * changes.
	 */
	if (vector == ALPHA_ENV_MCHECK)
		return;

	machine_check(mces, framep, vector, param);
#else
	switch (vector) {
	case ALPHA_ENV_MCHECK:
		dec_6600_environmental_mcheck(mces, framep, vector, param);
		break;
	case ALPHA_PROC_MCHECK:
	case ALPHA_SYS_MCHECK:
		dec_6600_mcheck(mces, framep, vector, param);
		break;
	default:
		machine_check(mces, framep, vector, param);
		break;
	}
#endif
}
@


1.13
log
@removed slot argument of function pckbc_cnattach
because it is always PCKBC_KBD_SLOT

ok krw@@, miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: dec_6600.c,v 1.12 2009/10/26 20:17:26 deraadt Exp $ */
d176 4
a179 2
		    " hose = %ld\n", ctb->ctb_term_type, ctbslot,
		    CTB_TURBOSLOT_HOSE(ctbslot));
d181 2
a182 2
		panic("consinit: unknown console type %ld",
		    ctb->ctb_term_type);
d385 13
a397 10
		printf("Flags\t%016x\n", env->flags);
		printf("DIR\t%016x\n", env->c_dir);
		printf("SMIR\t%016x\n", env->smir);
		printf("CPUIR\t%016x\n", env->cpuir);
		printf("PSIR\t%016x\n", env->psir);
		printf("LM78_ISR\t%016x\n", env->lm78_isr);
		printf("Doors\t%016x\n", env->doors);
		printf("Temp Warning\t%016x\n", env->temp_warning);
		printf("Fan Control\t%016x\n", env->fan_control);
		printf("Fatal Power Down\t%016x\n", env->fatal_power_down);
d435 1
a435 1
	printf("Syndrome bits %d\t%02x ", sno, syndrome);
d476 2
a477 2
		printf("Dcache status\t0x%05x\n",
		    cpu->dc_stat & EV6_DC_STAT_MASK);
d527 1
a527 1
			printf("%02x\n", cpu->c_stat);
d534 2
a535 1
			printf("0xXXXXXXXXXXX%05x\n", cpu->c_addr & 0xfffc0);
d537 2
a538 1
			printf("0x%016x\n", cpu->c_addr & 0xffffffffffffffc0);
d541 2
a542 2
			printf("Exception address\t0x%016x%s\n",
			    cpu->exc_addr & 0xfffffffffffffffc,
@


1.12
log
@Do not do strncmp comparisons on dv_xname because longer device names which
look similar could arrive in the future.  Instead, compare directly against
dv_cfdata->cf_driver->cd_name
Issue originally spotted by miod
@
text
@d1 1
a1 1
/* $OpenBSD: dec_6600.c,v 1.11 2009/01/17 18:30:05 miod Exp $ */
d156 1
a156 2
		(void) pckbc_cnattach(&tsp->pc_iot, IO_KBD, KBCMDP,
		    PCKBC_KBD_SLOT, 0);
@


1.11
log
@Recognize environmental change machine checks on ES40, and report what
happens instead of panicing; while there, start providing more details
for ev6 processor machine checks as well.

This allows power supplies to be unplugged and exchanged while the system
is running, without causing the kernel to crash.
@
text
@d1 1
a1 1
/* $OpenBSD: dec_6600.c,v 1.10 2008/07/16 20:03:20 miod Exp $ */
d305 1
a305 1
		if ((strncmp("pciide", parent->dv_xname, 6) != 0))
@


1.10
log
@Add a new parameter to pckbc_cnattach(): flags to put in the pckbc bowels.
For now, only one such flag is defined, PCKBC_CANT_TRANSLATE. It hints
pckbc that the device does not behave correctly to the ``set translation''
commands.

Set this flag if we are running on a Tadpole Ultrabook machine, which needs it.
This makes the built-in keyboard work correctly on this laptop (with the
help of the software translation pckbd diff).

tested & ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: dec_6600.c,v 1.9 2006/11/28 16:56:50 dlg Exp $ */
d5 15
d56 1
d88 9
d112 1
d323 251
@


1.9
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dec_6600.c,v 1.8 2005/05/09 21:55:12 martin Exp $ */
d131 1
a131 1
		    PCKBC_KBD_SLOT);
@


1.8
log
@fixes and updates for root device detection from NetBSD:

- remove unneeded checks and variables
- use strncasecmp() to check b->protocol because the case is dependant on the
  firmware revision
- check logical unit numbers
- consistently check PCI function numbers
- on the 6600 models check which PCI hierarchy is looked at
- makes root device detection on DS20 (6600) work

testing by claudio, xsa and miod; ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: dec_6600.c,v 1.7 2004/07/06 21:53:59 deraadt Exp $ */
d256 1
a256 1
		struct scsibus_attach_args *sa = aux;
@


1.7
log
@assert is dumb dumb dumb; no objection from miod
@
text
@d1 1
a1 1
/* $OpenBSD: dec_6600.c,v 1.6 2002/06/25 21:33:19 miod Exp $ */
d164 2
a165 2
	static int found, initted, scsiboot, ideboot, netboot;
	static struct device *primarydev, *pcidev, *scsidev;
d175 6
a180 11
		scsiboot = (strcmp(b->protocol, "SCSI") == 0);
		netboot = (strcmp(b->protocol, "BOOTP") == 0) ||
		    (strcmp(b->protocol, "MOP") == 0);
		/*
		 * Add an extra check to boot from ide drives:
		 * Newer SRM firmware use the protocol identifier IDE,
		 * older SRM firmware use the protocol identifier SCSI.
		 */
		ideboot = (strcmp(b->protocol, "IDE") == 0);
		DR_VERBOSE(printf("scsiboot = %d, ideboot = %d, netboot = %d\n",
		    scsiboot, ideboot, netboot));
d183 1
d194 1
a194 1
			    primarydev->dv_xname));
d198 1
d200 1
a200 1
		if (parent != primarydev)
d202 10
a211 1
		if (strcmp(cd->cd_name, "pci"))
d220 1
a220 2
			DR_VERBOSE(printf("\npcidev = %s\n",
			    pcidev->dv_xname));
d224 2
a225 1
	if ((ideboot || scsiboot) && (scsidev == NULL)) {
d230 1
d232 3
a234 3
			if (b->slot % 1000 / 100 != pa->pa_function)
				return;
			if (b->slot % 100 != pa->pa_device)
d237 10
a246 3
			scsidev = dev;
			DR_VERBOSE(printf("\nscsidev = %s\n",
			    scsidev->dv_xname));
d250 6
a255 4
	if ((ideboot || scsiboot) &&
	    (!strcmp(cd->cd_name, "sd") ||
	     !strcmp(cd->cd_name, "st") ||
	     !strcmp(cd->cd_name, "cd"))) {
d257 2
d260 1
a260 1
		if (parent->dv_parent != scsidev)
d263 2
a264 1
		if (b->unit / 100 != sa->sa_sc_link->target)
a266 17

		/* XXX LUN! */

		switch (b->boot_dev_type) {
		case 0:
			if (strcmp(cd->cd_name, "sd") &&
			    strcmp(cd->cd_name, "cd"))
				return;
			break;
		case 1:
			if (strcmp(cd->cd_name, "st"))
				return;
			break;
		default:
			return;
		}

d269 1
a269 2
		DR_VERBOSE(printf("\nbooted_device = %s\n",
		    booted_device->dv_xname));
d276 1
a276 1
	if ((ideboot || scsiboot) && !strcmp(cd->cd_name, "wd")) {
d278 4
a281 1
		if ((strncmp("pciide", parent->dv_xname, 6) != 0)) {
d283 1
a283 4
		} else {
			if (parent != scsidev)
				return;
		}
d294 1
a294 2
		DR_VERBOSE(printf("booted_device = %s\n",
		    booted_device->dv_xname));
a295 18
	}
	if (netboot) {
		if (parent != pcidev)
			return;
		else {
			struct pci_attach_args *pa = aux;

			if (b->slot % 1000 / 100 != pa->pa_function)
				return;
			if ((b->slot % 100) != pa->pa_device)
				return;
	
			booted_device = dev;
			DR_VERBOSE(printf("\nbooted_device = %s\n",
			    booted_device->dv_xname));
			found = 1;
			return;
		}
@


1.6
log
@No \n at the end of a panic() message... I thought all occurences had been
squashed already.
@
text
@d1 1
a1 1
/* $OpenBSD: dec_6600.c,v 1.5 2002/03/14 01:26:26 millert Exp $ */
a108 1
		assert(CTB_TURBOSLOT_HOSE(ctbslot) == 0);
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: dec_6600.c,v 1.4 2001/12/14 00:44:59 nate Exp $ */
d155 1
a155 1
		panic("consinit: unknown console type %ld\n",
@


1.4
log
@Don't use a single static struct alpha_bus_space since there are machines
that can have more than one system bus attached to mainbus
@
text
@d1 1
a1 1
/* $OpenBSD: dec_6600.c,v 1.3 2001/12/13 19:13:22 nate Exp $ */
d69 3
a71 3
void dec_6600_init __P((void));
static void dec_6600_cons_init __P((void));
static void dec_6600_device_register __P((struct device *, void *));
@


1.4.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: dec_6600.c,v 1.4 2001/12/14 00:44:59 nate Exp $ */
d69 3
a71 3
void dec_6600_init(void);
static void dec_6600_cons_init(void);
static void dec_6600_device_register(struct device *, void *);
@


1.4.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: dec_6600.c,v 1.4.2.1 2002/06/11 03:33:39 art Exp $ */
d155 1
a155 1
		panic("consinit: unknown console type %ld",
@


1.3
log
@Get rid of magic numbers
@
text
@d1 1
a1 1
/* $OpenBSD: dec_6600.c,v 1.2 2000/11/16 23:32:20 ericj Exp $ */
d119 1
a119 1
			if(comcnattach(tsp->pc_iot, 0x3f8, comcnrate,
d131 1
a131 1
		(void) pckbc_cnattach(tsp->pc_iot, IO_KBD, KBCMDP,
d136 1
a136 1
			isa_display_console(tsp->pc_iot, tsp->pc_memt);
d141 1
a141 1
			pci_display_console(tsp->pc_iot, tsp->pc_memt,
@


1.2
log
@
allow the console to attach on the rest of the alpha's we support.
@
text
@d1 1
a1 1
/* $OpenBSD: dec_6600.c,v 1.1 2000/11/16 04:50:17 ericj Exp $ */
d107 1
a107 1
	case 2: 
d127 1
a127 1
	case 3:
@


1.2.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/* $OpenBSD: dec_6600.c,v 1.2 2000/11/16 23:32:20 ericj Exp $ */
@


1.2.2.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d107 1
a107 1
	case CTB_PRINTERPORT: 
d119 1
a119 1
			if(comcnattach(&tsp->pc_iot, 0x3f8, comcnrate,
d127 1
a127 1
	case CTB_GRAPHICS:
d131 1
a131 1
		(void) pckbc_cnattach(&tsp->pc_iot, IO_KBD, KBCMDP,
d136 1
a136 1
			isa_display_console(&tsp->pc_iot, &tsp->pc_memt);
d141 1
a141 1
			pci_display_console(&tsp->pc_iot, &tsp->pc_memt,
@


1.2.2.3
log
@Merge in -current from about a week ago
@
text
@d69 3
a71 3
void dec_6600_init(void);
static void dec_6600_cons_init(void);
static void dec_6600_device_register(struct device *, void *);
@


1.2.2.4
log
@Sync the SMP branch with 3.3
@
text
@d155 1
a155 1
		panic("consinit: unknown console type %ld",
@


1.1
log
@
initial support for 21264 systems.
from NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a58 1
#if 0
a59 1
#endif
d131 1
a131 1
		(void) pckbc_cnattach(&tsp->pc_iot, IO_KBD, KBCMDP,
d136 1
a136 1
			isa_display_console(&tsp->pc_iot, &tsp->pc_memt);
d141 1
a141 1
			pci_display_console(&tsp->pc_iot, &tsp->pc_memt,
@

