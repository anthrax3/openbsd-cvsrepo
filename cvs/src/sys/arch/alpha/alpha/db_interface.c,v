head	1.23;
access;
symbols
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.22.0.6
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.2
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.21.0.6
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.8
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.4
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.17.0.12
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.10
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.8
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.6
	OPENBSD_5_0:1.17.0.4
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.16.0.28
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.24
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.26
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.22
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.20
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.18
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.16
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.14
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.12
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.10
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.8
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.6
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.4
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.14
	UBC:1.13.0.2
	UBC_BASE:1.13
	OPENBSD_3_0:1.12.0.4
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.9.0.6
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.4
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.2
	SMP_BASE:1.9
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.10
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.8
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.6
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8;
locks; strict;
comment	@ * @;


1.23
date	2017.04.30.16.45.45;	author mpi;	state Exp;
branches;
next	1.22;
commitid	2Gtqjzrin9LL2yHk;

1.22
date	2016.04.27.11.03.24;	author mpi;	state Exp;
branches;
next	1.21;
commitid	QLDpQBW1KLbDishX;

1.21
date	2014.07.13.12.11.01;	author jasper;	state Exp;
branches;
next	1.20;
commitid	XHZxhpAa5R1Ymp1z;

1.20
date	2014.03.29.18.09.28;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2014.01.30.20.10.24;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2014.01.26.17.40.09;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2010.11.27.19.57.23;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.22.17.47.01;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.19.19.32.44;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.26.26;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.06.19.53.13;	author miod;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.03.04.19.19.43;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.08.21.27.08;	author ericj;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.08.16.00.57;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.03.19.19.41;	author deraadt;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	97.07.23.23.31.11;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	97.07.19.20.54.28;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	97.07.09.09.11.54;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.07.09.09.06.19;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.07.09.07.57.10;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.07.08.20.30.02;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.07.06.17.19.25;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.07.06.16.31.13;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2001.04.18.16.00.12;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2001.11.13.21.00.48;	author niklas;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2002.03.28.10.06.12;	author niklas;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2003.03.27.22.29.47;	author niklas;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2004.02.19.09.59.33;	author niklas;	state Exp;
branches;
next	;

1.13.2.1
date	2002.06.11.03.33.39;	author art;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2003.05.19.21.38.52;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@/* $OpenBSD: db_interface.c,v 1.22 2016/04/27 11:03:24 mpi Exp $ */
/* $NetBSD: db_interface.c,v 1.8 1999/10/12 17:08:57 jdolecek Exp $ */

/* 
 * Mach Operating System
 * Copyright (c) 1992,1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS ``AS IS''
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 *
 *	db_interface.c,v 2.4 1991/02/05 17:11:13 mrt (CMU)
 */

/*
 * Parts of this file are derived from Mach 3:
 *
 *	File: alpha_instruction.c
 *	Author: Alessandro Forin, Carnegie Mellon University
 *	Date:	6/92
 */

/*
 * Interface to DDB.
 *
 * Modified for NetBSD/alpha by:
 *
 *	Christopher G. Demetriou, Carnegie Mellon University
 *
 *	Jason R. Thorpe, Numerical Aerospace Simulation Facility,
 *	NASA Ames Research Center
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/reboot.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>

#include <dev/cons.h>

#include <machine/db_machdep.h>
#include <machine/pal.h>
#include <machine/prom.h>

#include <alpha/alpha/db_instruction.h>

#include <ddb/db_sym.h>
#include <ddb/db_command.h>
#include <ddb/db_extern.h>
#include <ddb/db_access.h>
#include <ddb/db_output.h>
#include <ddb/db_variables.h>
#include <ddb/db_interface.h>


extern label_t	*db_recover;

#if 0
extern char *trap_type[];
extern int trap_types;
#endif

db_regs_t ddb_regs;

#if defined(MULTIPROCESSOR)
void	db_mach_cpu(db_expr_t, int, db_expr_t, char *);
#endif

struct db_command db_machine_command_table[] = {
#if defined(MULTIPROCESSOR)
	{ "ddbcpu",	db_mach_cpu,	0,	NULL },
#endif
	{ NULL,		NULL,		0,	NULL }
};

int	db_active = 0;

struct db_variable db_regs[] = {
	{	"v0",	&ddb_regs.tf_regs[FRAME_V0],	FCN_NULL	},
	{	"t0",	&ddb_regs.tf_regs[FRAME_T0],	FCN_NULL	},
	{	"t1",	&ddb_regs.tf_regs[FRAME_T1],	FCN_NULL	},
	{	"t2",	&ddb_regs.tf_regs[FRAME_T2],	FCN_NULL	},
	{	"t3",	&ddb_regs.tf_regs[FRAME_T3],	FCN_NULL	},
	{	"t4",	&ddb_regs.tf_regs[FRAME_T4],	FCN_NULL	},
	{	"t5",	&ddb_regs.tf_regs[FRAME_T5],	FCN_NULL	},
	{	"t6",	&ddb_regs.tf_regs[FRAME_T6],	FCN_NULL	},
	{	"t7",	&ddb_regs.tf_regs[FRAME_T7],	FCN_NULL	},
	{	"s0",	&ddb_regs.tf_regs[FRAME_S0],	FCN_NULL	},
	{	"s1",	&ddb_regs.tf_regs[FRAME_S1],	FCN_NULL	},
	{	"s2",	&ddb_regs.tf_regs[FRAME_S2],	FCN_NULL	},
	{	"s3",	&ddb_regs.tf_regs[FRAME_S3],	FCN_NULL	},
	{	"s4",	&ddb_regs.tf_regs[FRAME_S4],	FCN_NULL	},
	{	"s5",	&ddb_regs.tf_regs[FRAME_S5],	FCN_NULL	},
	{	"s6",	&ddb_regs.tf_regs[FRAME_S6],	FCN_NULL	},
	{	"a0",	&ddb_regs.tf_regs[FRAME_A0],	FCN_NULL	},
	{	"a1",	&ddb_regs.tf_regs[FRAME_A1],	FCN_NULL	},
	{	"a2",	&ddb_regs.tf_regs[FRAME_A2],	FCN_NULL	},
	{	"a3",	&ddb_regs.tf_regs[FRAME_A3],	FCN_NULL	},
	{	"a4",	&ddb_regs.tf_regs[FRAME_A4],	FCN_NULL	},
	{	"a5",	&ddb_regs.tf_regs[FRAME_A5],	FCN_NULL	},
	{	"t8",	&ddb_regs.tf_regs[FRAME_T8],	FCN_NULL	},
	{	"t9",	&ddb_regs.tf_regs[FRAME_T9],	FCN_NULL	},
	{	"t10",	&ddb_regs.tf_regs[FRAME_T10],	FCN_NULL	},
	{	"t11",	&ddb_regs.tf_regs[FRAME_T11],	FCN_NULL	},
	{	"ra",	&ddb_regs.tf_regs[FRAME_RA],	FCN_NULL	},
	{	"t12",	&ddb_regs.tf_regs[FRAME_T12],	FCN_NULL	},
	{	"at",	&ddb_regs.tf_regs[FRAME_AT],	FCN_NULL	},
	{	"gp",	&ddb_regs.tf_regs[FRAME_GP],	FCN_NULL	},
	{	"sp",	&ddb_regs.tf_regs[FRAME_SP],	FCN_NULL	},
	{	"pc",	&ddb_regs.tf_regs[FRAME_PC],	FCN_NULL	},
	{	"ps",	&ddb_regs.tf_regs[FRAME_PS],	FCN_NULL	},
	{	"ai",	&ddb_regs.tf_regs[FRAME_T11],	FCN_NULL	},
	{	"pv",	&ddb_regs.tf_regs[FRAME_T12],	FCN_NULL	},
};
struct db_variable *db_eregs = db_regs + nitems(db_regs);

/*
 * ddb_trap - field a kernel trap
 */
int
ddb_trap(a0, a1, a2, entry, regs)
	unsigned long a0, a1, a2, entry;
	db_regs_t *regs;
{
	struct cpu_info *ci = curcpu();
	int s;

	if (entry != ALPHA_KENTRY_IF ||
	    (a0 != ALPHA_IF_CODE_BPT && a0 != ALPHA_IF_CODE_BUGCHK)) {
		if (db_recover != 0) {
			/* This will longjmp back into db_command_loop() */
			db_error("Caught exception in ddb.\n");
			/* NOTREACHED */
		}

		/*
		 * Tell caller "We did NOT handle the trap."
		 * Caller should panic, or whatever.
		 */
		return (0);
	}

	/*
	 * alpha_debug() switches us to the debugger stack.
	 */

	ci->ci_db_regs = regs;
	ddb_regs = *regs;

	s = splhigh();

	db_active++;
	cnpollc(TRUE);		/* Set polling mode, unblank video */

	db_trap(entry, a0);	/* Where the work happens */

	cnpollc(FALSE);		/* Resume interrupt mode */
	db_active--;

	splx(s);

	*regs = ddb_regs;

	/*
	 * Tell caller "We HAVE handled the trap."
	 */
	return (1);
}

/*
 * Read bytes from kernel address space for debugger.
 */
void
db_read_bytes(addr, size, data)
	vaddr_t		addr;
	register size_t	size;
	register char	*data;
{
	register char	*src;

	src = (char *)addr;
	while (size-- > 0)
		*data++ = *src++;
}

/*
 * Write bytes to kernel address space for debugger.
 */
void
db_write_bytes(addr, size, data)
	vaddr_t		addr;
	register size_t	size;
	register char	*data;
{
	register char	*dst;

	dst = (char *)addr;
	while (size-- > 0)
		*dst++ = *data++;
	alpha_pal_imb();
}

void
db_enter()
{

	__asm volatile("call_pal 0x81");		/* bugchk */
}

/*
 * Map Alpha register numbers to trapframe/db_regs_t offsets.
 */
static int reg_to_frame[32] = {
	FRAME_V0,
	FRAME_T0,
	FRAME_T1,
	FRAME_T2,
	FRAME_T3,
	FRAME_T4,
	FRAME_T5,
	FRAME_T6,
	FRAME_T7,

	FRAME_S0,
	FRAME_S1,
	FRAME_S2,
	FRAME_S3,
	FRAME_S4,
	FRAME_S5,
	FRAME_S6,

	FRAME_A0,
	FRAME_A1,
	FRAME_A2,
	FRAME_A3,
	FRAME_A4,
	FRAME_A5,

	FRAME_T8,
	FRAME_T9,
	FRAME_T10,
	FRAME_T11,
	FRAME_RA,
	FRAME_T12,
	FRAME_AT,
	FRAME_GP,
	FRAME_SP,
	-1,		/* zero */
};

u_long
db_register_value(regs, regno)
	db_regs_t *regs;
	int regno;
{

	if (regno > 31 || regno < 0) {
		db_printf(" **** STRANGE REGISTER NUMBER %d **** ", regno);
		return (0);
	}

	if (regno == 31)
		return (0);

	return (regs->tf_regs[reg_to_frame[regno]]);
}

/*
 * Support functions for software single-step.
 */

boolean_t
db_inst_call(ins)
	int ins;
{
	alpha_instruction insn;

	insn.bits = ins;
	return ((insn.branch_format.opcode == op_bsr) ||
	    ((insn.jump_format.opcode == op_j) &&
	     (insn.jump_format.action & 1)));
}

boolean_t
db_inst_return(ins)
	int ins;
{
	alpha_instruction insn;

	insn.bits = ins;
	return ((insn.jump_format.opcode == op_j) &&
	    (insn.jump_format.action == op_ret));
}

boolean_t
db_inst_trap_return(ins)
	int ins;
{
	alpha_instruction insn;

	insn.bits = ins;
	return ((insn.pal_format.opcode == op_pal) &&
	    (insn.pal_format.function == PAL_OSF1_rti));
}

boolean_t
db_inst_branch(ins)
	int ins;
{
	alpha_instruction insn;

	insn.bits = ins;
	switch (insn.branch_format.opcode) {
	case op_j:
	case op_br:
	case op_fbeq:
	case op_fblt:
	case op_fble:
	case op_fbne:
	case op_fbge:
	case op_fbgt:
	case op_blbc:
	case op_beq:
	case op_blt:
	case op_ble:
	case op_blbs:
	case op_bne:
	case op_bge:
	case op_bgt:
		return (TRUE);
	}

	return (FALSE);
}

boolean_t
db_inst_unconditional_flow_transfer(ins)
	int ins;
{
	alpha_instruction insn;

	insn.bits = ins;
	switch (insn.branch_format.opcode) {
	case op_j:
	case op_br:
		return (TRUE);

	case op_pal:
		switch (insn.pal_format.function) {
		case PAL_OSF1_retsys:
		case PAL_OSF1_rti:
		case PAL_OSF1_callsys:
			return (TRUE);
		}
	}

	return (FALSE);
}

#if 0
boolean_t
db_inst_spill(ins, regn)
	int ins, regn;
{
	alpha_instruction insn;

	insn.bits = ins;
	return ((insn.mem_format.opcode == op_stq) &&
	    (insn.mem_format.rd == regn));
}
#endif

boolean_t
db_inst_load(ins)
	int ins;
{
	alpha_instruction insn;

	insn.bits = ins;
	
	/* Loads. */
	if (insn.mem_format.opcode == op_ldbu ||
	    insn.mem_format.opcode == op_ldq_u ||
	    insn.mem_format.opcode == op_ldwu)
		return (TRUE);
	if ((insn.mem_format.opcode >= op_ldf) &&
	    (insn.mem_format.opcode <= op_ldt))
		return (TRUE);
	if ((insn.mem_format.opcode >= op_ldl) &&
	    (insn.mem_format.opcode <= op_ldq_l))
		return (TRUE);

	/* Prefetches. */
	if (insn.mem_format.opcode == op_special) {
		/* Note: MB is treated as a store. */
		if ((insn.mem_format.displacement == (short)op_fetch) ||
		    (insn.mem_format.displacement == (short)op_fetch_m))
			return (TRUE);
	}

	return (FALSE);
}

db_addr_t
db_branch_taken(ins, pc, regs)
	int ins;
	db_addr_t pc;
	db_regs_t *regs;
{
	long signed_immediate;
	alpha_instruction insn;
	db_addr_t newpc;

	insn.bits = ins;
	switch (insn.branch_format.opcode) {
	/*
	 * Jump format: target PC is (contents of instruction's "RB") & ~3.
	 */
	case op_j:
		newpc = db_register_value(regs, insn.jump_format.rb) & ~3;
		break;

	/*
	 * Branch format: target PC is
	 *	(new PC) + (4 * sign-ext(displacement)).
	 */
	case op_br:
	case op_fbeq:
	case op_fblt:
	case op_fble:
	case op_bsr:
	case op_fbne:
	case op_fbge:
	case op_fbgt:
	case op_blbc:
	case op_beq:
	case op_blt:
	case op_ble:
	case op_blbs:
	case op_bne:
	case op_bge:
	case op_bgt:
		signed_immediate = insn.branch_format.displacement;
		newpc = (pc + 4) + (signed_immediate << 2);
		break;

	default:
		printf("DDB: db_inst_branch_taken on non-branch!\n");
		newpc = pc;	/* XXX */
	}

	return (newpc);
}

/*
 * Validate an address for use as a breakpoint.  We cannot let some
 * addresses have breakpoints as the ddb code itself uses that codepath.
 * Recursion and kernel stack space exhaustion will follow.
 */
int
db_valid_breakpoint(addr)
	db_addr_t addr;
{
	char *name;
	db_expr_t offset;

	db_find_sym_and_offset(addr, &name, &offset);
	if (name && strcmp(name, "alpha_pal_swpipl") == 0)
		return (0);
	return (1);
}

db_addr_t
next_instr_address(pc, branch)
	db_addr_t pc;
	int branch;
{
	if (!branch)
		return (pc + sizeof(int));
	return (branch_taken(*(u_int *)pc, pc, getreg_val, &ddb_regs));
}

#if defined(MULTIPROCESSOR)
void
db_mach_cpu(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	struct cpu_info *ci;
	CPU_INFO_ITERATOR cii;

	if (have_addr == 0) {
		db_printf("addr               dev   id flg mtx ipis "
		    "curproc            fpcurproc\n");
		CPU_INFO_FOREACH(cii, ci)
			db_printf("%p %-5s %02lu %03lx %03d %04lx %p %p\n",
			    ci, ci->ci_dev->dv_xname, ci->ci_cpuid,
			    ci->ci_flags, ci->ci_mutex_level, ci->ci_ipis,
			    ci->ci_curproc, ci->ci_fpcurproc);
		return;
	}

	if (addr < 0 || addr >= ALPHA_MAXPROCS) {
		db_printf("CPU %ld out of range\n", addr);
		return;
	}

	ci = cpu_info[addr];
	if (ci == NULL) {
		db_printf("CPU %ld is not configured\n", addr);
		return;
	}

	if (ci != curcpu()) {
		if ((ci->ci_flags & CPUF_PAUSED) == 0) {
			db_printf("CPU %ld not paused\n", addr);
			return;
		}
	}

	if (ci->ci_db_regs == NULL) {
		db_printf("CPU %ld has no register state\n", addr);
		return;
	}

	db_printf("Using CPU %ld\n", addr);
	ddb_regs = *ci->ci_db_regs;	/* struct copy */
}
#endif /* MULTIPROCESSOR */

void
db_machine_init()
{
	db_machine_commands_install(db_machine_command_table);
}
@


1.22
log
@Stop using DDB_REGS.

ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: db_interface.c,v 1.21 2014/07/13 12:11:01 jasper Exp $ */
d223 1
a223 1
Debugger()
@


1.21
log
@use nitems() instead of handrolling something identical

ok mpi@@ sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: db_interface.c,v 1.20 2014/03/29 18:09:28 guenther Exp $ */
d499 1
a499 1
	return (branch_taken(*(u_int *)pc, pc, getreg_val, DDB_REGS));
@


1.20
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: db_interface.c,v 1.19 2014/01/30 20:10:24 miod Exp $ */
d134 1
a134 1
struct db_variable *db_eregs = db_regs + sizeof(db_regs)/sizeof(db_regs[0]);
@


1.19
log
@Narrow ci_flags to be able to print ci_mutex_level in the `machine ddbcpu'
output.
@
text
@d1 1
a1 1
/* $OpenBSD: db_interface.c,v 1.18 2014/01/26 17:40:09 miod Exp $ */
d226 1
a226 1
	__asm __volatile("call_pal 0x81");		/* bugchk */
@


1.18
log
@Work in progress work towards SMP, heavily based upon NetBSD. The MP kernel
will boot multiuser, but will deadlock under load, and I can't find my
mistake yet.
@
text
@d1 1
a1 1
/* $OpenBSD: db_interface.c,v 1.17 2010/11/27 19:57:23 miod Exp $ */
d510 1
a510 1
		db_printf("addr               dev   id flags    ipis "
d513 1
a513 1
			db_printf("%p %-5s %02lu %08lx %04lx %p %p\n",
d515 2
a516 2
			    ci->ci_flags, ci->ci_ipis, ci->ci_curproc,
			    ci->ci_fpcurproc);
@


1.17
log
@Remove ddb single-step load and store counters. Most platforms do not
implement them, and they are of questionable usefulness.
@
text
@d1 1
a1 1
/* $OpenBSD: db_interface.c,v 1.16 2004/01/22 17:47:01 miod Exp $ */
d84 11
d144 1
d166 1
d500 52
@


1.16
log
@Nuke ddb_regs common.
@
text
@d1 1
a1 1
/* $OpenBSD: db_interface.c,v 1.15 2003/02/19 19:32:44 miod Exp $ */
a403 29
			return (TRUE);
	}

	return (FALSE);
}

boolean_t
db_inst_store(ins)
	int ins;
{
	alpha_instruction insn;

	insn.bits = ins;

	/* Stores. */
	if (insn.mem_format.opcode == op_stw ||
	    insn.mem_format.opcode == op_stb ||
	    insn.mem_format.opcode == op_stq_u)
		return (TRUE);
	if ((insn.mem_format.opcode >= op_stf) &&
	    (insn.mem_format.opcode <= op_stt))
		return (TRUE);
	if ((insn.mem_format.opcode >= op_stl) &&
	    (insn.mem_format.opcode <= op_stq_c))
		return (TRUE);

	/* Barriers. */
	if (insn.mem_format.opcode == op_special) {
		if (insn.mem_format.displacement == op_mb)
@


1.15
log
@Remove ddb machine commands, they are already available as "bo ha" and "bo re".
@
text
@d1 1
a1 1
/* $OpenBSD: db_interface.c,v 1.14 2002/03/14 01:26:26 millert Exp $ */
d81 2
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: db_interface.c,v 1.13 2001/11/06 19:53:13 miod Exp $ */
a83 9
void	db_mach_halt(db_expr_t, int, db_expr_t, char *);
void	db_mach_reboot(db_expr_t, int, db_expr_t, char *);

struct db_command db_machine_cmds[] = {
	{ "halt",	db_mach_halt,	0,	0 },
	{ "reboot",	db_mach_reboot,	0,	0 },
	{ (char *)0, },
};

a211 42
}

/*
 * This is called before ddb_init() to install the
 * machine-specific command table.  (see machdep.c)
 */
void
db_machine_init()
{

#if 0
	db_machine_commands_install(db_machine_cmds);
#endif
}

/*
 * Alpha-specific ddb commands:
 *
 *	halt		set halt bit in rpb and halt
 *	reboot		set reboot bit in rpb and halt
 */

void
db_mach_halt(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
{

	prom_halt(1);
}

void
db_mach_reboot(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
{

	prom_halt(0);
@


1.13
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/* $OpenBSD: db_interface.c,v 1.12 2001/03/04 19:19:43 niklas Exp $ */
d84 2
a85 2
void	db_mach_halt __P((db_expr_t, int, db_expr_t, char *));
void	db_mach_reboot __P((db_expr_t, int, db_expr_t, char *));
@


1.13.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: db_interface.c,v 1.13 2001/11/06 19:53:13 miod Exp $ */
d84 2
a85 2
void	db_mach_halt(db_expr_t, int, db_expr_t, char *);
void	db_mach_reboot(db_expr_t, int, db_expr_t, char *);
@


1.13.2.2
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d84 9
d221 42
@


1.12
log
@Revert to our old traceback code, with heuristic argument printout.
@
text
@d1 1
a1 1
/* $OpenBSD: db_interface.c,v 1.11 2000/11/08 21:27:08 ericj Exp $ */
d56 1
a56 1
#include <vm/vm.h>
@


1.11
log
@tag the rest of alpha tree
@
text
@d1 1
a1 1
/* $OpenBSD: db_interface.c,v 1.8 1999/10/12 17:08:57 jdolecek Exp $ */
d231 1
d233 1
d537 28
@


1.10
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
@


1.9
log
@check db_panic in kdb_trap() as well; similar to i386 fix from assar
@
text
@d1 29
a29 1
/*	$OpenBSD: db_interface.c,v 1.8 1997/07/23 23:31:11 niklas Exp $	*/
d32 1
a32 1
 * Copyright (c) 1997 Niklas Hallqvist.  All rights reserverd.
d34 9
a42 13
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Niklas Hallqvist.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d44 4
a47 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
a49 1
#include <sys/types.h>
d51 2
d57 2
d60 4
a63 1
#include <machine/frame.h>
d65 3
a68 1
#include <ddb/db_command.h>
a69 3
#include <ddb/db_run.h>
#include <ddb/db_sym.h>
#include <ddb/db_var.h>
d71 9
a79 1
#include <ddb/db_extern.h>
d81 1
a81 1
#include <dev/cons.h>
d83 2
a84 3
extern label_t *db_recover;
extern char    *trap_type[];
extern int	trap_types;
d86 5
a90 1
void kdbprinttrap __P((int, int));
a91 4
/*
 * These entries must be in the same order as the CPU registers.
 * You can add things at the end.
 */
d93 35
a127 33
	{ "v0", (long *)&ddb_regs.tf_regs[FRAME_V0], FCN_NULL, },	/*0*/
	{ "t0", (long *)&ddb_regs.tf_regs[FRAME_T0], FCN_NULL, },	/*1*/
	{ "t1", (long *)&ddb_regs.tf_regs[FRAME_T1], FCN_NULL, },	/*2*/
	{ "t2", (long *)&ddb_regs.tf_regs[FRAME_T2], FCN_NULL, },	/*3*/
	{ "t3", (long *)&ddb_regs.tf_regs[FRAME_T3], FCN_NULL, },	/*4*/
	{ "t4", (long *)&ddb_regs.tf_regs[FRAME_T4], FCN_NULL, },	/*5*/
	{ "t5", (long *)&ddb_regs.tf_regs[FRAME_T5], FCN_NULL, },	/*6*/
	{ "t6", (long *)&ddb_regs.tf_regs[FRAME_T6], FCN_NULL, },	/*7*/
	{ "t7", (long *)&ddb_regs.tf_regs[FRAME_T7], FCN_NULL, },	/*8*/
	{ "s0", (long *)&ddb_regs.tf_regs[FRAME_S0], FCN_NULL, },	/*9*/
	{ "s1", (long *)&ddb_regs.tf_regs[FRAME_S1], FCN_NULL, },	/*10*/
	{ "s2", (long *)&ddb_regs.tf_regs[FRAME_S2], FCN_NULL, },	/*11*/
	{ "s3", (long *)&ddb_regs.tf_regs[FRAME_S3], FCN_NULL, },	/*12*/
	{ "s4", (long *)&ddb_regs.tf_regs[FRAME_S4], FCN_NULL, },	/*13*/
	{ "s5", (long *)&ddb_regs.tf_regs[FRAME_S5], FCN_NULL, },	/*14*/
	{ "s6", (long *)&ddb_regs.tf_regs[FRAME_S6], FCN_NULL, },	/*15*/
	{ "a0", (long *)&ddb_regs.tf_regs[FRAME_A0], FCN_NULL, },	/*16*/
	{ "a1", (long *)&ddb_regs.tf_regs[FRAME_A1], FCN_NULL, },	/*17*/
	{ "a2", (long *)&ddb_regs.tf_regs[FRAME_A2], FCN_NULL, },	/*18*/
	{ "a3", (long *)&ddb_regs.tf_regs[FRAME_A3], FCN_NULL, },	/*19*/
	{ "a4", (long *)&ddb_regs.tf_regs[FRAME_A4], FCN_NULL, },	/*20*/
	{ "a5", (long *)&ddb_regs.tf_regs[FRAME_A5], FCN_NULL, },	/*21*/
	{ "t8", (long *)&ddb_regs.tf_regs[FRAME_T8], FCN_NULL, },	/*22*/
	{ "t9", (long *)&ddb_regs.tf_regs[FRAME_T9], FCN_NULL, },	/*23*/
	{ "t10", (long *)&ddb_regs.tf_regs[FRAME_T10], FCN_NULL, },	/*24*/
	{ "t11", (long *)&ddb_regs.tf_regs[FRAME_T11], FCN_NULL, },	/*25*/
	{ "ra", (long *)&ddb_regs.tf_regs[FRAME_RA], FCN_NULL, },	/*26*/
	{ "t12", (long *)&ddb_regs.tf_regs[FRAME_T12], FCN_NULL, },	/*27*/
	{ "at", (long *)&ddb_regs.tf_regs[FRAME_AT], FCN_NULL, },	/*28*/
	{ "gp", (long *)&ddb_regs.tf_regs[FRAME_GP], FCN_NULL, },	/*29*/
	{ "sp", (long *)&ddb_regs.tf_regs[FRAME_SP], FCN_NULL, },	/*30*/
	{ "pc", (long *)&ddb_regs.tf_regs[FRAME_PC], FCN_NULL, },	/*not*/
	{ "ps", (long *)&ddb_regs.tf_regs[FRAME_PS], FCN_NULL, },	/*not*/
a128 1

a129 1
int	db_active = 0;
d131 7
a137 2
void
Debugger()
d139 41
a179 1
  	__asm__ ("bpt");
d187 3
a189 3
	vm_offset_t addr;
	size_t size;
	char *data;
d191 1
a191 1
	char *src = (char*)addr;
d193 2
a194 2
	while (size > 0) {
		--size;
a195 1
	}
d203 3
a205 3
	vm_offset_t addr;
	size_t size;
	char *data;
d207 1
a207 1
	char *dst = (char *)addr;
d209 2
a210 2
	while (size > 0) {
		--size;
a211 1
	}
a214 3
/*
 * Print trap reason.
 */
d216 1
a216 2
kdbprinttrap(type, code)
	int type, code;
d218 2
a219 6
	db_printf("kernel: ");
	if (type >= trap_types || type < 0)
		db_printf("type %d", type);
	else
		db_printf("%s", trap_type[type]);
	db_printf(" trap, code=%x\n", code);
d223 2
a224 1
 *  kdb_trap - field a BPT trap
d226 2
a227 4
int
kdb_trap(type, code, regs)
	int type, code;
	db_regs_t *regs;
a228 1
	int s;
d230 2
a231 9
	switch (type) {
	case -1:			/* keyboard interrupt */
		break;
	case ALPHA_KENTRY_IF:		/* breakpoint */
		if (code == ALPHA_IF_CODE_BPT)
			break;
	default:
		if (!db_panic)
			return (0);
d233 6
a238 6
		kdbprinttrap(type, code);
		if (db_recover != 0) {
			db_error("Faulted in DDB; continuing...\n");
			/*NOTREACHED*/
		}
	}
d240 7
a246 1
	/* XXX Should switch to kdb`s own stack here. */
d248 2
a249 1
	ddb_regs = *regs;
d251 7
a257 7
	s = splhigh();
	db_active++;
	cnpollc(TRUE);
	db_trap(type, code);
	cnpollc(FALSE);
	db_active--;
	splx(s);
d259 1
a259 2
	*regs = ddb_regs;
	return (1);
d262 43
a304 2
register_t
getreg_val(regs, reg)
d306 1
a306 1
	int reg;
d308 10
a317 1
	return ((register_t)*db_regs[reg].valuep);
d320 66
a385 7
/* XXX Where do jsr_coroutine fit in?  We do not use it anyhow so... */
int
inst_call(ins)
	u_int ins;
{
	return ((ins & 0xfc000000) == 0xd0000000 ||	/* bsr */
	    (ins & 0xfc00c000) == 0x68004000);		/* jsr */
d388 22
a409 7
int
inst_branch(ins)
	u_int ins;
{
	return ((ins & 0xc0000000) == 0xc0000000 &&	/* 30 - 3F */
	    !((ins & 0xfc000000) == 0xd0000000 ||	/* but !34 (bsr) */
	    (ins & 0xfc00c000) == 0x68000000));		/* nor jmp */
d412 40
a451 5
int
inst_load(ins)
	u_int ins;
{
	char *nm = opcode[ins >> 26].opc_name;
d453 1
a453 1
	return (nm[0] == 'l' && nm[1] == 'd');
d456 25
a480 5
int
inst_store(ins)
	u_int ins;
{
	char *nm = opcode[ins >> 26].opc_name;
d482 1
a482 1
	return (nm[0] == 's' && nm[1] == 't');
d486 2
a487 2
branch_taken(ins, pc, getreg, regs)
	u_int ins;
a488 1
	register_t (*getreg) __P((db_regs_t *, int));
d491 12
a502 1
	int offset;
d504 23
a526 8
	if (opcode[ins >> 26].opc_fmt == OPC_BR) {
		offset = ins & 0xfffff;
		if (offset & 0x80000)
			offset = offset - 0x100000;
		return (pc + sizeof(int) + offset * sizeof(int));
	} else
		return (db_addr_t)(*getreg)(regs, (ins >> 16) & 0x1f);
}
d528 4
a531 21
db_addr_t
next_instr_address(pc, branch)
	db_addr_t pc;
	int branch;
{
	if (!branch)
		return (pc + sizeof(int));
	return (branch_taken(*(u_int *)pc, pc, getreg_val, DDB_REGS));
}

/*
 * Validate an address for use as a breakpoint.  We cannot let some
 * addresses have breakpoints as the ddb code itself uses that codepath.
 * Recursion and kernel stack space exhaustion will follow.
 */
int
db_valid_breakpoint(addr)
	db_addr_t addr;
{
	char *name;
	db_expr_t offset;
d533 1
a533 4
	db_find_sym_and_offset(addr, &name, &offset);
	if (name && strcmp(name, "alpha_pal_swpipl") == 0)
		return (0);
	return (1);
@


1.9.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 30
/* $OpenBSD: db_interface.c,v 1.12 2001/03/04 19:19:43 niklas Exp $ */
/* $NetBSD: db_interface.c,v 1.8 1999/10/12 17:08:57 jdolecek Exp $ */

/* 
 * Mach Operating System
 * Copyright (c) 1992,1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS ``AS IS''
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 *
 *	db_interface.c,v 2.4 1991/02/05 17:11:13 mrt (CMU)
 */
d4 1
a4 1
 * Parts of this file are derived from Mach 3:
d6 13
a18 9
 *	File: alpha_instruction.c
 *	Author: Alessandro Forin, Carnegie Mellon University
 *	Date:	6/92
 */

/*
 * Interface to DDB.
 *
 * Modified for NetBSD/alpha by:
d20 10
a29 4
 *	Christopher G. Demetriou, Carnegie Mellon University
 *
 *	Jason R. Thorpe, Numerical Aerospace Simulation Facility,
 *	NASA Ames Research Center
d32 1
a33 2
#include <sys/proc.h>
#include <sys/reboot.h>
a37 2
#include <dev/cons.h>

d39 1
a39 2
#include <machine/pal.h>
#include <machine/prom.h>
d41 1
a41 3
#include <alpha/alpha/db_instruction.h>

#include <ddb/db_sym.h>
a42 2
#include <ddb/db_extern.h>
#include <ddb/db_access.h>
d44 3
d48 1
a48 1
#include <ddb/db_interface.h>
d50 1
d52 3
a54 1
extern label_t	*db_recover;
d56 1
a56 4
#if 0
extern char *trap_type[];
extern int trap_types;
#endif
d58 38
a95 9
int	db_active = 0;

void	db_mach_halt __P((db_expr_t, int, db_expr_t, char *));
void	db_mach_reboot __P((db_expr_t, int, db_expr_t, char *));

struct db_command db_machine_cmds[] = {
	{ "halt",	db_mach_halt,	0,	0 },
	{ "reboot",	db_mach_reboot,	0,	0 },
	{ (char *)0, },
a97 37
struct db_variable db_regs[] = {
	{	"v0",	&ddb_regs.tf_regs[FRAME_V0],	FCN_NULL	},
	{	"t0",	&ddb_regs.tf_regs[FRAME_T0],	FCN_NULL	},
	{	"t1",	&ddb_regs.tf_regs[FRAME_T1],	FCN_NULL	},
	{	"t2",	&ddb_regs.tf_regs[FRAME_T2],	FCN_NULL	},
	{	"t3",	&ddb_regs.tf_regs[FRAME_T3],	FCN_NULL	},
	{	"t4",	&ddb_regs.tf_regs[FRAME_T4],	FCN_NULL	},
	{	"t5",	&ddb_regs.tf_regs[FRAME_T5],	FCN_NULL	},
	{	"t6",	&ddb_regs.tf_regs[FRAME_T6],	FCN_NULL	},
	{	"t7",	&ddb_regs.tf_regs[FRAME_T7],	FCN_NULL	},
	{	"s0",	&ddb_regs.tf_regs[FRAME_S0],	FCN_NULL	},
	{	"s1",	&ddb_regs.tf_regs[FRAME_S1],	FCN_NULL	},
	{	"s2",	&ddb_regs.tf_regs[FRAME_S2],	FCN_NULL	},
	{	"s3",	&ddb_regs.tf_regs[FRAME_S3],	FCN_NULL	},
	{	"s4",	&ddb_regs.tf_regs[FRAME_S4],	FCN_NULL	},
	{	"s5",	&ddb_regs.tf_regs[FRAME_S5],	FCN_NULL	},
	{	"s6",	&ddb_regs.tf_regs[FRAME_S6],	FCN_NULL	},
	{	"a0",	&ddb_regs.tf_regs[FRAME_A0],	FCN_NULL	},
	{	"a1",	&ddb_regs.tf_regs[FRAME_A1],	FCN_NULL	},
	{	"a2",	&ddb_regs.tf_regs[FRAME_A2],	FCN_NULL	},
	{	"a3",	&ddb_regs.tf_regs[FRAME_A3],	FCN_NULL	},
	{	"a4",	&ddb_regs.tf_regs[FRAME_A4],	FCN_NULL	},
	{	"a5",	&ddb_regs.tf_regs[FRAME_A5],	FCN_NULL	},
	{	"t8",	&ddb_regs.tf_regs[FRAME_T8],	FCN_NULL	},
	{	"t9",	&ddb_regs.tf_regs[FRAME_T9],	FCN_NULL	},
	{	"t10",	&ddb_regs.tf_regs[FRAME_T10],	FCN_NULL	},
	{	"t11",	&ddb_regs.tf_regs[FRAME_T11],	FCN_NULL	},
	{	"ra",	&ddb_regs.tf_regs[FRAME_RA],	FCN_NULL	},
	{	"t12",	&ddb_regs.tf_regs[FRAME_T12],	FCN_NULL	},
	{	"at",	&ddb_regs.tf_regs[FRAME_AT],	FCN_NULL	},
	{	"gp",	&ddb_regs.tf_regs[FRAME_GP],	FCN_NULL	},
	{	"sp",	&ddb_regs.tf_regs[FRAME_SP],	FCN_NULL	},
	{	"pc",	&ddb_regs.tf_regs[FRAME_PC],	FCN_NULL	},
	{	"ps",	&ddb_regs.tf_regs[FRAME_PS],	FCN_NULL	},
	{	"ai",	&ddb_regs.tf_regs[FRAME_T11],	FCN_NULL	},
	{	"pv",	&ddb_regs.tf_regs[FRAME_T12],	FCN_NULL	},
};
d99 1
d101 2
a102 7
/*
 * ddb_trap - field a kernel trap
 */
int
ddb_trap(a0, a1, a2, entry, regs)
	unsigned long a0, a1, a2, entry;
	db_regs_t *regs;
d104 1
a104 41
	int s;

	if (entry != ALPHA_KENTRY_IF ||
	    (a0 != ALPHA_IF_CODE_BPT && a0 != ALPHA_IF_CODE_BUGCHK)) {
		if (db_recover != 0) {
			/* This will longjmp back into db_command_loop() */
			db_error("Caught exception in ddb.\n");
			/* NOTREACHED */
		}

		/*
		 * Tell caller "We did NOT handle the trap."
		 * Caller should panic, or whatever.
		 */
		return (0);
	}

	/*
	 * alpha_debug() switches us to the debugger stack.
	 */

	ddb_regs = *regs;

	s = splhigh();

	db_active++;
	cnpollc(TRUE);		/* Set polling mode, unblank video */

	db_trap(entry, a0);	/* Where the work happens */

	cnpollc(FALSE);		/* Resume interrupt mode */
	db_active--;

	splx(s);

	*regs = ddb_regs;

	/*
	 * Tell caller "We HAVE handled the trap."
	 */
	return (1);
d112 3
a114 3
	vaddr_t		addr;
	register size_t	size;
	register char	*data;
d116 1
a116 1
	register char	*src;
d118 2
a119 2
	src = (char *)addr;
	while (size-- > 0)
d121 1
d129 3
a131 3
	vaddr_t		addr;
	register size_t	size;
	register char	*data;
d133 1
a133 1
	register char	*dst;
d135 2
a136 2
	dst = (char *)addr;
	while (size-- > 0)
d138 1
d142 3
d146 2
a147 1
Debugger()
d149 6
a154 2

	__asm __volatile("call_pal 0x81");		/* bugchk */
d158 1
a158 2
 * This is called before ddb_init() to install the
 * machine-specific command table.  (see machdep.c)
d160 4
a163 2
void
db_machine_init()
d165 1
d167 9
a175 4
#if 0
	db_machine_commands_install(db_machine_cmds);
#endif
}
d177 6
a182 6
/*
 * Alpha-specific ddb commands:
 *
 *	halt		set halt bit in rpb and halt
 *	reboot		set reboot bit in rpb and halt
 */
d184 1
a184 7
void
db_mach_halt(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
{
d186 1
a186 2
	prom_halt(1);
}
d188 7
a194 7
void
db_mach_reboot(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
{
d196 2
a197 1
	prom_halt(0);
d200 2
a201 43
/*
 * Map Alpha register numbers to trapframe/db_regs_t offsets.
 */
static int reg_to_frame[32] = {
	FRAME_V0,
	FRAME_T0,
	FRAME_T1,
	FRAME_T2,
	FRAME_T3,
	FRAME_T4,
	FRAME_T5,
	FRAME_T6,
	FRAME_T7,

	FRAME_S0,
	FRAME_S1,
	FRAME_S2,
	FRAME_S3,
	FRAME_S4,
	FRAME_S5,
	FRAME_S6,

	FRAME_A0,
	FRAME_A1,
	FRAME_A2,
	FRAME_A3,
	FRAME_A4,
	FRAME_A5,

	FRAME_T8,
	FRAME_T9,
	FRAME_T10,
	FRAME_T11,
	FRAME_RA,
	FRAME_T12,
	FRAME_AT,
	FRAME_GP,
	FRAME_SP,
	-1,		/* zero */
};

u_long
db_register_value(regs, regno)
d203 1
a203 1
	int regno;
d205 1
a205 10

	if (regno > 31 || regno < 0) {
		db_printf(" **** STRANGE REGISTER NUMBER %d **** ", regno);
		return (0);
	}

	if (regno == 31)
		return (0);

	return (regs->tf_regs[reg_to_frame[regno]]);
d208 7
a214 66
/*
 * Support functions for software single-step.
 */

boolean_t
db_inst_call(ins)
	int ins;
{
	alpha_instruction insn;

	insn.bits = ins;
	return ((insn.branch_format.opcode == op_bsr) ||
	    ((insn.jump_format.opcode == op_j) &&
	     (insn.jump_format.action & 1)));
}

boolean_t
db_inst_return(ins)
	int ins;
{
	alpha_instruction insn;

	insn.bits = ins;
	return ((insn.jump_format.opcode == op_j) &&
	    (insn.jump_format.action == op_ret));
}

boolean_t
db_inst_trap_return(ins)
	int ins;
{
	alpha_instruction insn;

	insn.bits = ins;
	return ((insn.pal_format.opcode == op_pal) &&
	    (insn.pal_format.function == PAL_OSF1_rti));
}

boolean_t
db_inst_branch(ins)
	int ins;
{
	alpha_instruction insn;

	insn.bits = ins;
	switch (insn.branch_format.opcode) {
	case op_j:
	case op_br:
	case op_fbeq:
	case op_fblt:
	case op_fble:
	case op_fbne:
	case op_fbge:
	case op_fbgt:
	case op_blbc:
	case op_beq:
	case op_blt:
	case op_ble:
	case op_blbs:
	case op_bne:
	case op_bge:
	case op_bgt:
		return (TRUE);
	}

	return (FALSE);
d217 7
a223 22
boolean_t
db_inst_unconditional_flow_transfer(ins)
	int ins;
{
	alpha_instruction insn;

	insn.bits = ins;
	switch (insn.branch_format.opcode) {
	case op_j:
	case op_br:
		return (TRUE);

	case op_pal:
		switch (insn.pal_format.function) {
		case PAL_OSF1_retsys:
		case PAL_OSF1_rti:
		case PAL_OSF1_callsys:
			return (TRUE);
		}
	}

	return (FALSE);
d226 5
a230 40
#if 0
boolean_t
db_inst_spill(ins, regn)
	int ins, regn;
{
	alpha_instruction insn;

	insn.bits = ins;
	return ((insn.mem_format.opcode == op_stq) &&
	    (insn.mem_format.rd == regn));
}
#endif

boolean_t
db_inst_load(ins)
	int ins;
{
	alpha_instruction insn;

	insn.bits = ins;
	
	/* Loads. */
	if (insn.mem_format.opcode == op_ldbu ||
	    insn.mem_format.opcode == op_ldq_u ||
	    insn.mem_format.opcode == op_ldwu)
		return (TRUE);
	if ((insn.mem_format.opcode >= op_ldf) &&
	    (insn.mem_format.opcode <= op_ldt))
		return (TRUE);
	if ((insn.mem_format.opcode >= op_ldl) &&
	    (insn.mem_format.opcode <= op_ldq_l))
		return (TRUE);

	/* Prefetches. */
	if (insn.mem_format.opcode == op_special) {
		/* Note: MB is treated as a store. */
		if ((insn.mem_format.displacement == (short)op_fetch) ||
		    (insn.mem_format.displacement == (short)op_fetch_m))
			return (TRUE);
	}
d232 1
a232 1
	return (FALSE);
d235 5
a239 25
boolean_t
db_inst_store(ins)
	int ins;
{
	alpha_instruction insn;

	insn.bits = ins;

	/* Stores. */
	if (insn.mem_format.opcode == op_stw ||
	    insn.mem_format.opcode == op_stb ||
	    insn.mem_format.opcode == op_stq_u)
		return (TRUE);
	if ((insn.mem_format.opcode >= op_stf) &&
	    (insn.mem_format.opcode <= op_stt))
		return (TRUE);
	if ((insn.mem_format.opcode >= op_stl) &&
	    (insn.mem_format.opcode <= op_stq_c))
		return (TRUE);

	/* Barriers. */
	if (insn.mem_format.opcode == op_special) {
		if (insn.mem_format.displacement == op_mb)
			return (TRUE);
	}
d241 1
a241 1
	return (FALSE);
d245 2
a246 2
db_branch_taken(ins, pc, regs)
	int ins;
d248 1
d251 1
a251 12
	long signed_immediate;
	alpha_instruction insn;
	db_addr_t newpc;

	insn.bits = ins;
	switch (insn.branch_format.opcode) {
	/*
	 * Jump format: target PC is (contents of instruction's "RB") & ~3.
	 */
	case op_j:
		newpc = db_register_value(regs, insn.jump_format.rb) & ~3;
		break;
d253 8
a260 23
	/*
	 * Branch format: target PC is
	 *	(new PC) + (4 * sign-ext(displacement)).
	 */
	case op_br:
	case op_fbeq:
	case op_fblt:
	case op_fble:
	case op_bsr:
	case op_fbne:
	case op_fbge:
	case op_fbgt:
	case op_blbc:
	case op_beq:
	case op_blt:
	case op_ble:
	case op_blbs:
	case op_bne:
	case op_bge:
	case op_bgt:
		signed_immediate = insn.branch_format.displacement;
		newpc = (pc + 4) + (signed_immediate << 2);
		break;
d262 8
a269 6
	default:
		printf("DDB: db_inst_branch_taken on non-branch!\n");
		newpc = pc;	/* XXX */
	}

	return (newpc);
a287 10
}

db_addr_t
next_instr_address(pc, branch)
	db_addr_t pc;
	int branch;
{
	if (!branch)
		return (pc + sizeof(int));
	return (branch_taken(*(u_int *)pc, pc, getreg_val, DDB_REGS));
@


1.9.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d56 1
a56 1
#include <uvm/uvm_extern.h>
@


1.9.2.3
log
@Merge in -current from about a week ago
@
text
@d84 2
a85 2
void	db_mach_halt(db_expr_t, int, db_expr_t, char *);
void	db_mach_reboot(db_expr_t, int, db_expr_t, char *);
@


1.9.2.4
log
@Sync the SMP branch with 3.3
@
text
@d84 9
d221 42
@


1.9.2.5
log
@Merge of -current from two weeks ago into the SMP branch
@
text
@a81 2
db_regs_t ddb_regs;

@


1.8
log
@Pretty + validation routine for breakpoints
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.7 1997/07/19 20:54:28 niklas Exp $	*/
d46 1
d174 3
@


1.7
log
@Lots! Single-stepping support is probably the most important change.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.6 1997/07/09 09:11:54 deraadt Exp $	*/
d157 1
a157 1
 *  kdb_trap - field a TRACE or BPT trap
a182 4
#if 0
	db_printf("db_regs at %p\n", regs);
	ddb_regs.tf_regs[FRAME_SP] = (u_long)regs + FRAME_SIZE*8;
#endif
d266 18
@


1.6
log
@indicate that the register array is in physical order
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.5 1997/07/09 09:06:19 deraadt Exp $	*/
d33 1
d36 2
d44 1
d62 33
a94 33
	{ "v0", (long *)&ddb_regs.tf_regs[FRAME_V0], FCN_NULL, },	/* 0 */
	{ "t0", (long *)&ddb_regs.tf_regs[FRAME_T0], FCN_NULL, },	/* 1 */
	{ "t1", (long *)&ddb_regs.tf_regs[FRAME_T1], FCN_NULL, },	/* 2 */
	{ "t2", (long *)&ddb_regs.tf_regs[FRAME_T2], FCN_NULL, },	/* 3 */
	{ "t3", (long *)&ddb_regs.tf_regs[FRAME_T3], FCN_NULL, },	/* 4 */
	{ "t4", (long *)&ddb_regs.tf_regs[FRAME_T4], FCN_NULL, },	/* 5 */
	{ "t5", (long *)&ddb_regs.tf_regs[FRAME_T5], FCN_NULL, },	/* 6 */
	{ "t6", (long *)&ddb_regs.tf_regs[FRAME_T6], FCN_NULL, },	/* 7 */
	{ "t7", (long *)&ddb_regs.tf_regs[FRAME_T7], FCN_NULL, },	/* 8 */
	{ "s0", (long *)&ddb_regs.tf_regs[FRAME_S0], FCN_NULL, },	/* 9 */
	{ "s1", (long *)&ddb_regs.tf_regs[FRAME_S1], FCN_NULL, },	/* 10 */
	{ "s2", (long *)&ddb_regs.tf_regs[FRAME_S2], FCN_NULL, },	/* 11 */
	{ "s3", (long *)&ddb_regs.tf_regs[FRAME_S3], FCN_NULL, },	/* 12 */
	{ "s4", (long *)&ddb_regs.tf_regs[FRAME_S4], FCN_NULL, },	/* 13 */
	{ "s5", (long *)&ddb_regs.tf_regs[FRAME_S5], FCN_NULL, },	/* 14 */
	{ "s6", (long *)&ddb_regs.tf_regs[FRAME_S6], FCN_NULL, },	/* 15 */
	{ "a0", (long *)&ddb_regs.tf_regs[FRAME_A0], FCN_NULL, },	/* 16 */
	{ "a1", (long *)&ddb_regs.tf_regs[FRAME_A1], FCN_NULL, },	/* 17 */
	{ "a2", (long *)&ddb_regs.tf_regs[FRAME_A2], FCN_NULL, },	/* 18 */
	{ "a3", (long *)&ddb_regs.tf_regs[FRAME_A3], FCN_NULL, },	/* 19 */
	{ "a4", (long *)&ddb_regs.tf_regs[FRAME_A4], FCN_NULL, },	/* 20 */
	{ "a5", (long *)&ddb_regs.tf_regs[FRAME_A5], FCN_NULL, },	/* 21 */
	{ "t8", (long *)&ddb_regs.tf_regs[FRAME_T8], FCN_NULL, },	/* 22 */
	{ "t9", (long *)&ddb_regs.tf_regs[FRAME_T9], FCN_NULL, },	/* 23 */
	{ "t10", (long *)&ddb_regs.tf_regs[FRAME_T10], FCN_NULL, },	/* 24 */
	{ "t11", (long *)&ddb_regs.tf_regs[FRAME_T11], FCN_NULL, },	/* 25 */
	{ "ra", (long *)&ddb_regs.tf_regs[FRAME_RA], FCN_NULL, },	/* 26 */
	{ "t12", (long *)&ddb_regs.tf_regs[FRAME_T12], FCN_NULL, },	/* 27 */
	{ "at", (long *)&ddb_regs.tf_regs[FRAME_AT], FCN_NULL, },	/* 28 */
	{ "gp", (long *)&ddb_regs.tf_regs[FRAME_GP], FCN_NULL, },	/* 29 */
	{ "sp", (long *)&ddb_regs.tf_regs[FRAME_SP], FCN_NULL, },	/* 30 */
	{ "pc", (long *)&ddb_regs.tf_regs[FRAME_PC], FCN_NULL, },	/* not */
	{ "ps", (long *)&ddb_regs.tf_regs[FRAME_PS], FCN_NULL, },	/* not */
d138 1
a166 1
	case ALPHA_IF_CODE_BPT:		/* breakpoint */
d169 3
d182 2
d185 2
a186 2
	ddb_regs = *regs;
	ddb_regs.tf_regs[FRAME_SP] = (u_long)regs + FRAME_SW_SIZE*8;
d196 38
a233 1
	/* XXX set regs from ddb_regs here */
d235 35
a269 1
	return (1);
@


1.5
log
@comment register numbers; also pc/ps are not $31, not in the least...
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.4 1997/07/09 07:57:10 deraadt Exp $	*/
d53 4
@


1.4
log
@rearrange registers in numerical order
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.3 1997/07/08 20:30:02 niklas Exp $	*/
d54 33
a86 33
	{ "v0", (long *)&ddb_regs.tf_regs[FRAME_V0], FCN_NULL, },
	{ "t0", (long *)&ddb_regs.tf_regs[FRAME_T0], FCN_NULL, },
	{ "t1", (long *)&ddb_regs.tf_regs[FRAME_T1], FCN_NULL, },
	{ "t2", (long *)&ddb_regs.tf_regs[FRAME_T2], FCN_NULL, },
	{ "t3", (long *)&ddb_regs.tf_regs[FRAME_T3], FCN_NULL, },
	{ "t4", (long *)&ddb_regs.tf_regs[FRAME_T4], FCN_NULL, },
	{ "t5", (long *)&ddb_regs.tf_regs[FRAME_T5], FCN_NULL, },
	{ "t6", (long *)&ddb_regs.tf_regs[FRAME_T6], FCN_NULL, },
	{ "t7", (long *)&ddb_regs.tf_regs[FRAME_T7], FCN_NULL, },
	{ "s0", (long *)&ddb_regs.tf_regs[FRAME_S0], FCN_NULL, },
	{ "s1", (long *)&ddb_regs.tf_regs[FRAME_S1], FCN_NULL, },
	{ "s2", (long *)&ddb_regs.tf_regs[FRAME_S2], FCN_NULL, },
	{ "s3", (long *)&ddb_regs.tf_regs[FRAME_S3], FCN_NULL, },
	{ "s4", (long *)&ddb_regs.tf_regs[FRAME_S4], FCN_NULL, },
	{ "s5", (long *)&ddb_regs.tf_regs[FRAME_S5], FCN_NULL, },
	{ "s6", (long *)&ddb_regs.tf_regs[FRAME_S6], FCN_NULL, },
	{ "a0", (long *)&ddb_regs.tf_regs[FRAME_A0], FCN_NULL, },
	{ "a1", (long *)&ddb_regs.tf_regs[FRAME_A1], FCN_NULL, },
	{ "a2", (long *)&ddb_regs.tf_regs[FRAME_A2], FCN_NULL, },
	{ "a3", (long *)&ddb_regs.tf_regs[FRAME_A3], FCN_NULL, },
	{ "a4", (long *)&ddb_regs.tf_regs[FRAME_A4], FCN_NULL, },
	{ "a5", (long *)&ddb_regs.tf_regs[FRAME_A5], FCN_NULL, },
	{ "t8", (long *)&ddb_regs.tf_regs[FRAME_T8], FCN_NULL, },
	{ "t9", (long *)&ddb_regs.tf_regs[FRAME_T9], FCN_NULL, },
	{ "t10", (long *)&ddb_regs.tf_regs[FRAME_T10], FCN_NULL, },
	{ "t11", (long *)&ddb_regs.tf_regs[FRAME_T11], FCN_NULL, },
	{ "ra", (long *)&ddb_regs.tf_regs[FRAME_RA], FCN_NULL, },
	{ "t12", (long *)&ddb_regs.tf_regs[FRAME_T12], FCN_NULL, },
	{ "at", (long *)&ddb_regs.tf_regs[FRAME_AT], FCN_NULL, },
	{ "gp", (long *)&ddb_regs.tf_regs[FRAME_GP], FCN_NULL, },
	{ "sp", (long *)&ddb_regs.tf_regs[FRAME_SP], FCN_NULL, },
	{ "ps", (long *)&ddb_regs.tf_regs[FRAME_PS], FCN_NULL, },
	{ "pc", (long *)&ddb_regs.tf_regs[FRAME_PC], FCN_NULL, },
@


1.3
log
@Fix copyright. Remove unused cruft.  Natural reg ordering.  SP setting from
Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.2 1997/07/06 17:19:25 niklas Exp $	*/
a54 13
	{ "a0", (long *)&ddb_regs.tf_regs[FRAME_A0], FCN_NULL, },
	{ "a1", (long *)&ddb_regs.tf_regs[FRAME_A1], FCN_NULL, },
	{ "a2", (long *)&ddb_regs.tf_regs[FRAME_A2], FCN_NULL, },
	{ "a3", (long *)&ddb_regs.tf_regs[FRAME_A3], FCN_NULL, },
	{ "a4", (long *)&ddb_regs.tf_regs[FRAME_A4], FCN_NULL, },
	{ "a5", (long *)&ddb_regs.tf_regs[FRAME_A5], FCN_NULL, },
	{ "s0", (long *)&ddb_regs.tf_regs[FRAME_S0], FCN_NULL, },
	{ "s1", (long *)&ddb_regs.tf_regs[FRAME_S1], FCN_NULL, },
	{ "s2", (long *)&ddb_regs.tf_regs[FRAME_S2], FCN_NULL, },
	{ "s3", (long *)&ddb_regs.tf_regs[FRAME_S3], FCN_NULL, },
	{ "s4", (long *)&ddb_regs.tf_regs[FRAME_S4], FCN_NULL, },
	{ "s5", (long *)&ddb_regs.tf_regs[FRAME_S5], FCN_NULL, },
	{ "s6", (long *)&ddb_regs.tf_regs[FRAME_S6], FCN_NULL, },
d63 13
d80 1
d84 2
a86 3
	{ "ps", (long *)&ddb_regs.tf_regs[FRAME_PS], FCN_NULL, },
	{ "ra", (long *)&ddb_regs.tf_regs[FRAME_RA], FCN_NULL, },
	{ "sp", (long *)&ddb_regs.tf_regs[FRAME_SP], FCN_NULL, },
@


1.2
log
@Fix the register saving when entering the debugger.  Present the trap in
clear text too.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.1 1997/07/06 16:31:13 niklas Exp $	*/
d16 3
a18 5
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d20 10
a29 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d55 13
a75 10
	{ "s0", (long *)&ddb_regs.tf_regs[FRAME_S0], FCN_NULL, },
	{ "s1", (long *)&ddb_regs.tf_regs[FRAME_S1], FCN_NULL, },
	{ "s2", (long *)&ddb_regs.tf_regs[FRAME_S2], FCN_NULL, },
	{ "s3", (long *)&ddb_regs.tf_regs[FRAME_S3], FCN_NULL, },
	{ "s4", (long *)&ddb_regs.tf_regs[FRAME_S4], FCN_NULL, },
	{ "s5", (long *)&ddb_regs.tf_regs[FRAME_S5], FCN_NULL, },
	{ "s6", (long *)&ddb_regs.tf_regs[FRAME_S6], FCN_NULL, },
	{ "a3", (long *)&ddb_regs.tf_regs[FRAME_A3], FCN_NULL, },
	{ "a4", (long *)&ddb_regs.tf_regs[FRAME_A4], FCN_NULL, },
	{ "a5", (long *)&ddb_regs.tf_regs[FRAME_A5], FCN_NULL, },
a79 1
	{ "ra", (long *)&ddb_regs.tf_regs[FRAME_RA], FCN_NULL, },
d82 4
a86 6
	{ "ps", (long *)&ddb_regs.tf_regs[FRAME_PS], FCN_NULL, },
	{ "pc", (long *)&ddb_regs.tf_regs[FRAME_PC], FCN_NULL, },
	{ "gp", (long *)&ddb_regs.tf_regs[FRAME_GP], FCN_NULL, },
	{ "a0", (long *)&ddb_regs.tf_regs[FRAME_A0], FCN_NULL, },
	{ "a1", (long *)&ddb_regs.tf_regs[FRAME_A1], FCN_NULL, },
	{ "a2", (long *)&ddb_regs.tf_regs[FRAME_A2], FCN_NULL, },
d171 1
d173 1
a173 9
#if 0 /* XXX leave this until later */
	if (KERNELMODE(regs->tf_cs, regs->tf_eflags)) {
		/*
		 * Kernel mode - esp and ss not saved
		 */
		ddb_regs.tf_esp = (int)&regs->tf_esp;	/* kernel stack pointer */
		asm("movw %%ss,%w0" : "=r" (ddb_regs.tf_ss));
	}
#endif
d183 1
a183 19
#if 0 /* XXX save until later... */
	regs->tf_es     = ddb_regs.tf_es;
	regs->tf_ds     = ddb_regs.tf_ds;
	regs->tf_edi    = ddb_regs.tf_edi;
	regs->tf_esi    = ddb_regs.tf_esi;
	regs->tf_ebp    = ddb_regs.tf_ebp;
	regs->tf_ebx    = ddb_regs.tf_ebx;
	regs->tf_edx    = ddb_regs.tf_edx;
	regs->tf_ecx    = ddb_regs.tf_ecx;
	regs->tf_eax    = ddb_regs.tf_eax;
	regs->tf_eip    = ddb_regs.tf_eip;
	regs->tf_cs     = ddb_regs.tf_cs;
	regs->tf_eflags = ddb_regs.tf_eflags;
	if (!KERNELMODE(regs->tf_cs, regs->tf_eflags)) {
		/* ring transit - saved esp and ss valid */
		regs->tf_esp    = ddb_regs.tf_esp;
		regs->tf_ss     = ddb_regs.tf_ss;
	}
#endif
@


1.1
log
@DDB support (much not yet implemented).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 3
a52 1
extern label_t	*db_recover;
a142 1
#if 0
a143 1
#endif
a144 1
#if 0
a146 1
#endif
d174 1
a175 1
	ddb_regs = *regs;
@
