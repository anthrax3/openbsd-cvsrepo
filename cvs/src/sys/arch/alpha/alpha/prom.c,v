head	1.16;
access;
symbols
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.8
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.4
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.13.0.54
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.52
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.48
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.46
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.44
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.42
	OPENBSD_5_0:1.13.0.40
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.38
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.36
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.32
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.34
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.30
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.28
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.26
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.24
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.22
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.20
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.18
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.16
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.14
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.12
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.10
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.8
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.6
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.13
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.11.0.4
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.16
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.14
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.12
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2014.12.18.10.50.02;	author dlg;	state Exp;
branches;
next	1.15;
commitid	SSZHOrUvtGihp08f;

1.15
date	2014.12.18.10.46.45;	author dlg;	state Exp;
branches;
next	1.14;
commitid	CgVK4OvgLNRgLXNN;

1.14
date	2014.12.18.10.45.29;	author dlg;	state Exp;
branches;
next	1.13;
commitid	zg1bM1PjCP9I7uhL;

1.13
date	2002.03.14.01.26.26;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.06.19.53.13;	author miod;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.04.17.04.30.45;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.06.04.42.05;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.20.20.27.40;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.08.19.16.59;	author ericj;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.08.16.01.03;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.08.11.57.21;	author art;	state Exp;
branches;
next	1.5;

1.5
date	97.01.24.19.56.42;	author niklas;	state Exp;
branches
	1.5.14.1;
next	1.4;

1.4
date	96.10.30.22.38.23;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.07.29.22.57.57;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.18.09.42.29;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.40;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.40;	author deraadt;	state Exp;
branches;
next	;

1.5.14.1
date	2001.04.18.16.00.29;	author niklas;	state Exp;
branches;
next	1.5.14.2;

1.5.14.2
date	2001.11.13.21.00.49;	author niklas;	state Exp;
branches;
next	1.5.14.3;

1.5.14.3
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2002.06.11.03.33.39;	author art;	state Exp;
branches;
next	;


desc
@@


1.16
log
@ansi function prototypes. no functional change.
@
text
@/* $OpenBSD: prom.c,v 1.15 2014/12/18 10:46:45 dlg Exp $ */
/* $NetBSD: prom.c,v 1.39 2000/03/06 21:36:05 thorpej Exp $ */

/* 
 * Copyright (c) 1992, 1994, 1995, 1996 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <uvm/uvm_extern.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/mutex.h>

#include <machine/cpu.h>
#include <machine/rpb.h>
#define	ENABLEPROM
#include <machine/prom.h>

#include <dev/cons.h>

/* XXX this is to fake out the console routines, while booting. */
struct consdev promcons = { NULL, NULL, promcngetc, promcnputc,
			    nullcnpollc, NULL, makedev(23,0), 1 };

struct rpb	*hwrpb;
int		alpha_console;

extern struct prom_vec prom_dispatch_v;

struct mutex prom_lock = MUTEX_INITIALIZER(IPL_HIGH);

void	prom_enter(void);
void	prom_leave(void);

#ifdef _PMAP_MAY_USE_PROM_CONSOLE
int		prom_mapped = 1;	/* Is PROM still mapped? */

pt_entry_t	prom_pte, saved_pte[1];	/* XXX */
static pt_entry_t *prom_lev1map(void);

static pt_entry_t *
prom_lev1map()
{
	struct alpha_pcb *apcb;

	/*
	 * Find the level 1 map that we're currently running on.
	 */
	apcb = (struct alpha_pcb *)ALPHA_PHYS_TO_K0SEG(curpcb);

	return ((pt_entry_t *)ALPHA_PHYS_TO_K0SEG(apcb->apcb_ptbr << PGSHIFT));
}
#endif /* _PMAP_MAY_USE_PROM_CONSOLE */

void
init_prom_interface(struct rpb *rpb)
{
	struct crb *c;

	c = (struct crb *)((char *)rpb + rpb->rpb_crb_off);

	prom_dispatch_v.routine_arg = c->crb_v_dispatch;
	prom_dispatch_v.routine = c->crb_v_dispatch->entry_va;
}

void
init_bootstrap_console()
{
	char buf[4];

	init_prom_interface(hwrpb);

	prom_getenv(PROM_E_TTY_DEV, buf, 4);
	alpha_console = buf[0] - '0';

	/* XXX fake out the console routines, for now */
	cn_tab = &promcons;
}

#ifdef _PMAP_MAY_USE_PROM_CONSOLE
static void prom_cache_sync(void);
#endif

void
prom_enter(void)
{
	mtx_enter(&prom_lock);

#ifdef _PMAP_MAY_USE_PROM_CONSOLE
	/*
	 * If we have not yet switched out of the PROM's context
	 * (i.e. the first one after alpha_init()), then the PROM
	 * is still mapped, regardless of the `prom_mapped' setting.
	 */
	if (prom_mapped == 0 && curpcb != 0) {
		if (!pmap_uses_prom_console())
			panic("prom_enter");
		{
			pt_entry_t *lev1map;

			lev1map = prom_lev1map();	/* XXX */
			saved_pte[0] = lev1map[0];	/* XXX */
			lev1map[0] = prom_pte;		/* XXX */
		}
		prom_cache_sync();			/* XXX */
	}
#endif
}

void
prom_leave(void)
{
#ifdef _PMAP_MAY_USE_PROM_CONSOLE
	/*
	 * See comment above.
	 */
	if (prom_mapped == 0 && curpcb != 0) {
		if (!pmap_uses_prom_console())
			panic("prom_leave");
		{
			pt_entry_t *lev1map;

			lev1map = prom_lev1map();	/* XXX */
			lev1map[0] = saved_pte[0];	/* XXX */
		}
		prom_cache_sync();			/* XXX */
	}
#endif

	mtx_leave(&prom_lock);
}

#ifdef _PMAP_MAY_USE_PROM_CONSOLE
static void
prom_cache_sync(void)
{
	ALPHA_TBIA();
	alpha_pal_imb();
}
#endif

/*
 * promcnputc:
 *
 * Remap char before passing off to prom.
 *
 * Prom only takes 32 bit addresses. Copy char somewhere prom can
 * find it. This routine will stop working after pmap_rid_of_console 
 * is called in alpha_init. This is due to the hard coded address
 * of the console area.
 */
void
promcnputc(dev_t dev, int c)
{
	prom_return_t ret;
	unsigned char *to = (unsigned char *)0x20000000;

	prom_enter();	/* lock and map prom */
	*to = c;

	do {
		ret.bits = prom_putstr(alpha_console, to, 1);
	} while ((ret.u.retval & 1) == 0);

	prom_leave();		/* unmap prom and unlock */
}

/*
 * promcngetc:
 *
 * Wait for the prom to get a real char and pass it back.
 */
int
promcngetc(dev_t dev)
{
	prom_return_t ret;

	for (;;) {
		prom_enter();
		ret.bits = prom_getc(alpha_console);
		prom_leave();
		if (ret.u.status == 0 || ret.u.status == 1)
			return (ret.u.retval);
	}
}

/*
 * promcnlookc:
 *
 * See if prom has a real char and pass it back.
 */
int
promcnlookc(dev_t dev, char *cp)
{
	prom_return_t ret;

	prom_enter();
	ret.bits = prom_getc(alpha_console);
	prom_leave();
	if (ret.u.status == 0 || ret.u.status == 1) {
		*cp = ret.u.retval;
		return 1;
	} else
		return 0;
}

int
prom_getenv(int id, char *buf, int len)
{
	unsigned char *to = (unsigned char *)0x20000000;
	prom_return_t ret;

	prom_enter();
	ret.bits = prom_getenv_disp(id, to, len);
	bcopy(to, buf, len);
	prom_leave();

	if (ret.u.status & 0x4)
		ret.u.retval = 0;
	buf[ret.u.retval] = '\0';

	return (ret.bits);
}

void
prom_halt(int halt)
{
	struct pcs *p;

	/*
	 * Turn off interrupts, for sanity.
	 */
	(void) splhigh();

	/*
	 * Set "boot request" part of the CPU state depending on what
	 * we want to happen when we halt.
	 */
	p = LOCATE_PCS(hwrpb, hwrpb->rpb_primary_cpu_id);
	p->pcs_flags &= ~(PCS_RC | PCS_HALT_REQ);
	if (halt)
		p->pcs_flags |= PCS_HALT_STAY_HALTED;
	else
		p->pcs_flags |= PCS_HALT_WARM_BOOT;

	/*
	 * Halt the machine.
	 */
	alpha_pal_halt();
}

u_int64_t
hwrpb_checksum()
{
	u_int64_t *p, sum;
	int i;

	for (i = 0, p = (u_int64_t *)hwrpb, sum = 0;
	    i < (offsetof(struct rpb, rpb_checksum) / sizeof (u_int64_t));
	    i++, p++)
		sum += *p;

	return (sum);
}

void
hwrpb_primary_init()
{
	struct pcs *p;

	p = LOCATE_PCS(hwrpb, hwrpb->rpb_primary_cpu_id);

	/* Initialize the primary's HWPCB and the Virtual Page Table Base. */
	bcopy(&proc0.p_addr->u_pcb.pcb_hw, p->pcs_hwpcb,
	    sizeof proc0.p_addr->u_pcb.pcb_hw);
	hwrpb->rpb_vptb = VPTBASE;

	hwrpb->rpb_checksum = hwrpb_checksum();
}

void
hwrpb_restart_setup()
{
	struct pcs *p;

	/* Clear bootstrap-in-progress flag since we're done bootstrapping */
	p = LOCATE_PCS(hwrpb, hwrpb->rpb_primary_cpu_id);
	p->pcs_flags &= ~PCS_BIP;

	/* when 'c'ontinuing from console halt, do a dump */
	hwrpb->rpb_rest_term = (u_int64_t)&XentRestart;
	hwrpb->rpb_rest_term_val = 0x1;

	hwrpb->rpb_checksum = hwrpb_checksum();

	p->pcs_flags |= (PCS_RC | PCS_CV);
}

u_int64_t
console_restart(struct trapframe *framep)
{
	struct pcs *p;

	/* Clear restart-capable flag, since we can no longer restart. */
	p = LOCATE_PCS(hwrpb, hwrpb->rpb_primary_cpu_id);
	p->pcs_flags &= ~PCS_RC;

	/* Fill in the missing frame slots */

	framep->tf_regs[FRAME_PS] = p->pcs_halt_ps;
	framep->tf_regs[FRAME_PC] = p->pcs_halt_pc;
	framep->tf_regs[FRAME_T11] = p->pcs_halt_r25;
	framep->tf_regs[FRAME_RA] = p->pcs_halt_r26;
	framep->tf_regs[FRAME_T12] = p->pcs_halt_r27;

	panic("user requested console halt");

	return (1);
}
@


1.15
log
@white space tweaks, no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: prom.c,v 1.14 2014/12/18 10:45:29 dlg Exp $ */
d78 1
a78 2
init_prom_interface(rpb)
	struct rpb *rpb;
d175 1
a175 3
promcnputc(dev, c)
	dev_t dev;
	int c;
d196 1
a196 2
promcngetc(dev)
	dev_t dev;
d215 1
a215 3
promcnlookc(dev, cp)
	dev_t dev;
	char *cp;
d230 1
a230 3
prom_getenv(id, buf, len)
	int id, len;
	char *buf;
d248 1
a248 2
prom_halt(halt)
	int halt;
d322 1
a322 2
console_restart(framep)
	struct trapframe *framep;
@


1.14
log
@replace splhigh and a simplelock with a mutex.

slight tweak and testing by deraadt@@
ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: prom.c,v 1.13 2002/03/14 01:26:26 millert Exp $ */
d85 2
a86 2
        prom_dispatch_v.routine_arg = c->crb_v_dispatch;
        prom_dispatch_v.routine = c->crb_v_dispatch->entry_va;
d180 1
a180 1
        prom_return_t ret;
d202 1
a202 1
        prom_return_t ret;
d204 1
a204 1
        for (;;) {
d206 1
a206 1
                ret.bits = prom_getc(alpha_console);
d208 3
a210 3
                if (ret.u.status == 0 || ret.u.status == 1)
                        return (ret.u.retval);
        }
d223 1
a223 1
        prom_return_t ret;
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: prom.c,v 1.12 2001/11/06 19:53:13 miod Exp $ */
a31 1
#include <sys/lock.h>
d34 1
d52 4
a55 1
struct simplelock prom_slock;
a86 2

	simple_lock_init(&prom_slock);
d107 2
a108 2
int
prom_enter()
d110 1
a110 4
	int s;

	s = splhigh();
	simple_lock(&prom_slock);
a130 1
	return s;
d134 1
a134 2
prom_leave(s)
	int s;
a135 1

d152 2
a153 2
	simple_unlock(&prom_slock);
	splx(s);
a181 1
	int s;
d183 1
a183 1
	s = prom_enter();	/* splhigh() and map prom */
d190 1
a190 1
	prom_leave(s);		/* unmap prom and splx(s) */
a202 1
	int s;
d205 1
a205 1
		s = prom_enter();
d207 1
a207 1
		prom_leave(s);
a223 1
	int s;
d225 1
a225 1
	s = prom_enter();
d227 1
a227 1
	prom_leave(s);
a241 1
	int s;
d243 1
a243 1
	s = prom_enter();
d246 1
a246 1
	prom_leave(s);
@


1.12
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/* $OpenBSD: prom.c,v 1.11 2001/04/17 04:30:45 aaron Exp $ */
d58 1
a58 1
static pt_entry_t *prom_lev1map __P((void));
d103 1
a103 1
static void prom_cache_sync __P((void));
d163 1
a163 1
prom_cache_sync __P((void))
@


1.12.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: prom.c,v 1.12 2001/11/06 19:53:13 miod Exp $ */
d58 1
a58 1
static pt_entry_t *prom_lev1map(void);
d103 1
a103 1
static void prom_cache_sync(void);
d163 1
a163 1
prom_cache_sync(void)
@


1.11
log
@Implement cnbell(), an optional entrypoint that rings the console bell; from
NetBSD. deraadt@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: prom.c,v 1.10 2001/04/06 04:42:05 csapuntz Exp $ */
d31 1
a31 1
#include <vm/vm.h>
@


1.10
log
@

Move offsetof define into sys/param.h
@
text
@d1 1
a1 1
/* $OpenBSD: prom.c,v 1.9 2001/01/20 20:27:40 art Exp $ */
d45 1
a45 1
			    nullcnpollc, makedev(23,0), 1 };
@


1.9
log
@No need to include machine/alpha.h here.
@
text
@d1 1
a1 1
/* $OpenBSD: prom.c,v 1.8 2000/11/08 19:16:59 ericj Exp $ */
a297 3
#ifndef offsetof
#define offsetof(type, member)  ((size_t)(&((type *)0)->member)) /* XXX */
#endif
@


1.8
log
@add tags
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a37 1
#include <machine/alpha.h>
@


1.7
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
@


1.6
log
@&vm_pmap -> vm_map.pmap
@
text
@d1 1
a1 2
/*	$OpenBSD: prom.c,v 1.5 1997/01/24 19:56:42 niklas Exp $	*/
/*	$NetBSD: prom.c,v 1.12 1996/11/13 21:13:11 cgd Exp $	*/
d30 2
d35 1
d37 2
a39 4
#ifdef NEW_PMAP
#include <vm/vm.h>
#include <vm/pmap.h>
#endif
a42 2
u_int64_t hwrpb_checksum __P((void));

d49 6
d57 7
a63 1
extern struct prom_vec prom_dispatch_v;
d65 4
a68 1
pt_entry_t	*rom_ptep, rom_pte, saved_pte;	/* XXX */
d70 3
a72 3
#ifdef NEW_PMAP
#define	rom_ptep   (curproc ? &curproc->p_vmspace->vm_map.pmap->dir[0] : rom_ptep)
#endif
d75 2
a76 1
init_prom_interface()
a78 1
	char buf[4];
d80 1
a80 1
	c = (struct crb*)((char*)hwrpb + hwrpb->rpb_crb_off);
d85 10
d102 68
d186 1
a186 1
	u_char *to = (u_char *)0x20000000;
d189 1
a189 11
#ifdef notdef /* XXX */
	if (!prom_mapped)
		return;
#endif

	s = splhigh();
	if (!prom_mapped) {					/* XXX */
		saved_pte = *rom_ptep;				/* XXX */
		*rom_ptep = rom_pte;				/* XXX */
		ALPHA_TBIA();					/* XXX */
	}							/* XXX */
d196 1
a196 5
	if (!prom_mapped) {					/* XXX */
		*rom_ptep = saved_pte;				/* XXX */
		ALPHA_TBIA();					/* XXX */
	}							/* XXX */
	splx(s);
a210 5
#ifdef notdef /* XXX */
	if (!prom_mapped)
		return (-1);
#endif

d212 1
a212 6
		s = splhigh();
		if (!prom_mapped) {				/* XXX */
			saved_pte = *rom_ptep;			/* XXX */
			*rom_ptep = rom_pte;			/* XXX */
			ALPHA_TBIA();				/* XXX */
		}						/* XXX */
d214 1
a214 5
		if (!prom_mapped) {				/* XXX */
			*rom_ptep = saved_pte;			/* XXX */
			ALPHA_TBIA();				/* XXX */
		}						/* XXX */
		splx(s);
d233 1
a233 11
#ifdef notdef /* XXX */
	if (!prom_mapped)
		return (-1);
#endif

	s = splhigh();
	if (!prom_mapped) {					/* XXX */
		saved_pte = *rom_ptep;				/* XXX */
		*rom_ptep = rom_pte;				/* XXX */
		ALPHA_TBIA();					/* XXX */
	}							/* XXX */
d235 1
a235 5
	if (!prom_mapped) {					/* XXX */
		*rom_ptep = saved_pte;				/* XXX */
		ALPHA_TBIA();					/* XXX */
	}
	splx(s);
d252 1
a252 11
#ifdef notdef /* XXX */
	if (!prom_mapped)
		return (-1);
#endif

	s = splhigh();
	if (!prom_mapped) {					/* XXX */
		saved_pte = *rom_ptep;				/* XXX */
		*rom_ptep = rom_pte;				/* XXX */
		ALPHA_TBIA();					/* XXX */
	}							/* XXX */
d255 1
a255 5
	if (!prom_mapped) {					/* XXX */
		*rom_ptep = saved_pte;				/* XXX */
		ALPHA_TBIA();					/* XXX */
	}							/* XXX */
	splx(s);
d279 1
a279 1
	p = (struct pcs *)((char *)hwrpb + hwrpb->rpb_pcs_off);
d298 3
a300 2
#define	offsetof(type, member)	((size_t)(&((type *)0)->member)) /* XXX */

d310 1
a310 1
hwrpb_restart_setup()
d314 1
a314 3
	/* Clear bootstrap-in-progress flag since we're done bootstrapping */
	p = (struct pcs *)((char *)hwrpb + hwrpb->rpb_pcs_off);
	p->pcs_flags &= ~PCS_BIP;
d316 1
d321 12
a336 6
#if 0
	/* don't know what this is really used by, so don't mess with it. */
	hwrpb->rpb_restart = (u_int64_t)&XentRestart;
	hwrpb->rpb_restart_val = 0x2;
#endif

d343 2
a344 2
console_restart(ra, ai, pv)
	u_int64_t ra, ai, pv;
d349 1
a349 1
	p = (struct pcs *)((char *)hwrpb + hwrpb->rpb_pcs_off);
d351 8
@


1.5
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: prom.c,v 1.4 1996/10/30 22:38:23 niklas Exp $	*/
d58 1
a58 1
#define	rom_ptep   (curproc ? &curproc->p_vmspace->vm_pmap.dir[0] : rom_ptep)
@


1.5.14.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 2
/* $OpenBSD: prom.c,v 1.11 2001/04/17 04:30:45 aaron Exp $ */
/* $NetBSD: prom.c,v 1.39 2000/03/06 21:36:05 thorpej Exp $ */
a30 2
#include <vm/vm.h>
#include <sys/lock.h>
a33 1
#include <machine/cpu.h>
a34 1
#define	ENABLEPROM
d36 4
d43 2
d47 1
a47 1
			    nullcnpollc, NULL, makedev(23,0), 1 };
d51 1
d55 1
a55 1
struct simplelock prom_slock;
d57 3
a59 19
#ifdef _PMAP_MAY_USE_PROM_CONSOLE
int		prom_mapped = 1;	/* Is PROM still mapped? */

pt_entry_t	prom_pte, saved_pte[1];	/* XXX */
static pt_entry_t *prom_lev1map __P((void));

static pt_entry_t *
prom_lev1map()
{
	struct alpha_pcb *apcb;

	/*
	 * Find the level 1 map that we're currently running on.
	 */
	apcb = (struct alpha_pcb *)ALPHA_PHYS_TO_K0SEG(curpcb);

	return ((pt_entry_t *)ALPHA_PHYS_TO_K0SEG(apcb->apcb_ptbr << PGSHIFT));
}
#endif /* _PMAP_MAY_USE_PROM_CONSOLE */
d62 1
a62 2
init_prom_interface(rpb)
	struct rpb *rpb;
d65 1
d67 1
a67 1
	c = (struct crb *)((char *)rpb + rpb->rpb_crb_off);
a71 10
	simple_lock_init(&prom_slock);
}

void
init_bootstrap_console()
{
	char buf[4];

	init_prom_interface(hwrpb);

a78 68
#ifdef _PMAP_MAY_USE_PROM_CONSOLE
static void prom_cache_sync __P((void));
#endif

int
prom_enter()
{
	int s;

	s = splhigh();
	simple_lock(&prom_slock);

#ifdef _PMAP_MAY_USE_PROM_CONSOLE
	/*
	 * If we have not yet switched out of the PROM's context
	 * (i.e. the first one after alpha_init()), then the PROM
	 * is still mapped, regardless of the `prom_mapped' setting.
	 */
	if (prom_mapped == 0 && curpcb != 0) {
		if (!pmap_uses_prom_console())
			panic("prom_enter");
		{
			pt_entry_t *lev1map;

			lev1map = prom_lev1map();	/* XXX */
			saved_pte[0] = lev1map[0];	/* XXX */
			lev1map[0] = prom_pte;		/* XXX */
		}
		prom_cache_sync();			/* XXX */
	}
#endif
	return s;
}

void
prom_leave(s)
	int s;
{

#ifdef _PMAP_MAY_USE_PROM_CONSOLE
	/*
	 * See comment above.
	 */
	if (prom_mapped == 0 && curpcb != 0) {
		if (!pmap_uses_prom_console())
			panic("prom_leave");
		{
			pt_entry_t *lev1map;

			lev1map = prom_lev1map();	/* XXX */
			lev1map[0] = saved_pte[0];	/* XXX */
		}
		prom_cache_sync();			/* XXX */
	}
#endif
	simple_unlock(&prom_slock);
	splx(s);
}

#ifdef _PMAP_MAY_USE_PROM_CONSOLE
static void
prom_cache_sync __P((void))
{
	ALPHA_TBIA();
	alpha_pal_imb();
}
#endif

d95 1
a95 1
	unsigned char *to = (unsigned char *)0x20000000;
d98 11
a108 1
	s = prom_enter();	/* splhigh() and map prom */
d115 5
a119 1
	prom_leave(s);		/* unmap prom and splx(s) */
d134 5
d140 6
a145 1
		s = prom_enter();
d147 5
a151 1
		prom_leave(s);
d170 11
a180 1
	s = prom_enter();
d182 5
a186 1
	prom_leave(s);
d203 11
a213 1
	s = prom_enter();
d216 5
a220 1
	prom_leave(s);
d244 1
a244 1
	p = LOCATE_PCS(hwrpb, hwrpb->rpb_primary_cpu_id);
d263 2
d274 1
a274 1
hwrpb_primary_init()
d278 3
a280 1
	p = LOCATE_PCS(hwrpb, hwrpb->rpb_primary_cpu_id);
a281 1
	/* Initialize the primary's HWPCB and the Virtual Page Table Base. */
a285 12
	hwrpb->rpb_checksum = hwrpb_checksum();
}

void
hwrpb_restart_setup()
{
	struct pcs *p;

	/* Clear bootstrap-in-progress flag since we're done bootstrapping */
	p = LOCATE_PCS(hwrpb, hwrpb->rpb_primary_cpu_id);
	p->pcs_flags &= ~PCS_BIP;

d290 6
d302 2
a303 2
console_restart(framep)
	struct trapframe *framep;
d308 1
a308 1
	p = LOCATE_PCS(hwrpb, hwrpb->rpb_primary_cpu_id);
a309 8

	/* Fill in the missing frame slots */

	framep->tf_regs[FRAME_PS] = p->pcs_halt_ps;
	framep->tf_regs[FRAME_PC] = p->pcs_halt_pc;
	framep->tf_regs[FRAME_T11] = p->pcs_halt_r25;
	framep->tf_regs[FRAME_RA] = p->pcs_halt_r26;
	framep->tf_regs[FRAME_T12] = p->pcs_halt_r27;
@


1.5.14.2
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d31 1
a31 1
#include <uvm/uvm_extern.h>
@


1.5.14.3
log
@Merge in -current from about a week ago
@
text
@d58 1
a58 1
static pt_entry_t *prom_lev1map(void);
d103 1
a103 1
static void prom_cache_sync(void);
d163 1
a163 1
prom_cache_sync(void)
@


1.4
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 2
a2 2
/*	$OpenBSD: prom.c,v 1.11 1996/10/16 00:00:40 cgd Exp $	*/
/*	$NetBSD: prom.c,v 1.11 1996/10/16 00:00:40 cgd Exp $	*/
d30 1
a32 1
#include <sys/systm.h>
a42 3
/* XXX this is to fake out the console routines, while booting. */
void promcnputc __P((dev_t, int));
int promcngetc __P((dev_t));
a43 1
long console_restart __P((u_int64_t, u_int64_t, u_int64_t));
d45 1
d70 1
a70 1
        prom_dispatch_v.routine = c->crb_v_dispatch->code;
d112 1
a112 1
		ret.bits = prom_dispatch(PROM_R_PUTS, alpha_console, to, 1);
d146 1
a146 1
                ret.bits = prom_dispatch(PROM_R_GETC, alpha_console, 0, 0);
d181 1
a181 1
	ret.bits = prom_dispatch(PROM_R_GETC, alpha_console, 0, 0);
d214 1
a214 1
	ret.bits = prom_dispatch(PROM_R_GETENV, id, to, len);
a272 2
void XentRestart __P((void));

d274 1
a274 1
hwrbp_restart_setup()
d287 1
a287 1
	hwrpb->rpb_rest_term = (long (*) __P((long)))&XentRestart;
d292 1
a292 1
	hwrpb->rpb_restart = (long (*) __P((long)))&XentRestart;
d301 1
a301 1
long
@


1.3
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: prom.c,v 1.5.4.2 1996/06/13 18:35:21 cgd Exp $	*/
/*	$NetBSD: prom.c,v 1.5.4.2 1996/06/13 18:35:21 cgd Exp $	*/
d30 3
d36 4
a39 1
#include <machine/pte.h>
d46 3
d60 4
d98 1
a98 1
	unsigned char *to = (unsigned char *)0x20000000;
d110 1
a110 1
		TBIA();						/* XXX */
d120 1
a120 1
		TBIA();						/* XXX */
d147 1
a147 1
			TBIA();					/* XXX */
d149 1
a149 1
                ret.bits = prom_dispatch(PROM_R_GETC, alpha_console);
d152 1
a152 1
			TBIA();					/* XXX */
d182 1
a182 1
		TBIA();						/* XXX */
d184 1
a184 1
	ret.bits = prom_dispatch(PROM_R_GETC, alpha_console);
d187 1
a187 1
		TBIA();						/* XXX */
d215 1
a215 1
		TBIA();						/* XXX */
d221 1
a221 1
		TBIA();						/* XXX */
d248 1
a248 2
	/* XXX BIP should have been cleared long ago. */
	p->pcs_flags &= ~(PCS_RC | PCS_HALT_REQ | PCS_BIP);
d257 62
a318 1
	pal_halt();
@


1.2
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: prom.c,v 1.4 1995/08/03 00:58:33 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1992, 1994, 1995 Carnegie Mellon University
d210 5
d234 2
a235 1
	p->pcs_flags &= ~(PCS_RC | PCS_HALT_REQ);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
