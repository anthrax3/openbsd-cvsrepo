head	1.32;
access;
symbols
	OPENBSD_6_2:1.32.0.2
	OPENBSD_6_2_BASE:1.32
	OPENBSD_6_1:1.32.0.4
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.28.0.6
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.4
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.25.0.18
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.16
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.12
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.10
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.8
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.6
	OPENBSD_5_0:1.25.0.4
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.2
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.23.0.4
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.6
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.2
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.22.0.4
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.2
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.21.0.6
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.4
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.10
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.8
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.6
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.4
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.16.0.4
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.17
	UBC:1.16.0.2
	UBC_BASE:1.16
	OPENBSD_3_0:1.13.0.4
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.9.0.4
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.2
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.8.0.6
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.32
date	2016.09.27.05.01.29;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	ywCXtlQvdUhxVZCv;

1.31
date	2016.09.25.15.23.36;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	YxqfPf79WCjoxCH9;

1.30
date	2016.08.15.22.01.59;	author tedu;	state Exp;
branches;
next	1.29;
commitid	hzJmUc5FH2irhNvz;

1.29
date	2016.08.01.15.58.22;	author tedu;	state Exp;
branches;
next	1.28;
commitid	0APfmV8i34pDgCWZ;

1.28
date	2015.05.28.20.53.05;	author jcs;	state Exp;
branches;
next	1.27;
commitid	mm0ThjDof6ifWCwA;

1.27
date	2015.02.10.22.44.35;	author miod;	state Exp;
branches;
next	1.26;
commitid	lsrmQ0A4gY4UmdnD;

1.26
date	2015.02.10.21.56.08;	author miod;	state Exp;
branches;
next	1.25;
commitid	C5iGb36LQxjM60Q3;

1.25
date	2010.12.26.15.40.58;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2010.04.21.03.03.25;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2008.11.05.06.32.47;	author matthieu;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.22.16.21.32;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2006.04.13.14.41.08;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2005.10.28.19.10.26;	author martin;	state Exp;
branches;
next	1.19;

1.19
date	2003.08.15.20.32.12;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.02.23.27.43;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.24.17.21.45;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.06.19.53.13;	author miod;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.11.01.14.32.01;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.01.12.13.45;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.20.20.29.53;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2000.11.08.19.16.59;	author ericj;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.08.16.01.01;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.05.18.30.32;	author ericj;	state Exp;
branches;
next	1.9;

1.9
date	99.11.22.19.21.55;	author matthieu;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	98.08.31.17.42.25;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.06.05.23.21.11;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.01.24.19.56.39;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.10.30.22.38.17;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.07.29.22.57.49;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.06.18.09.42.25;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.52.42;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.40;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.40;	author deraadt;	state Exp;
branches;
next	;

1.9.2.1
date	2001.04.18.16.00.24;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2001.11.13.21.00.48;	author niklas;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2003.03.27.23.18.06;	author niklas;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2003.06.07.11.11.33;	author ho;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2004.02.19.09.59.33;	author niklas;	state Exp;
branches;
next	;

1.16.2.1
date	2002.10.29.00.28.00;	author art;	state Exp;
branches;
next	;


desc
@@


1.32
log
@typo
@
text
@/* $OpenBSD: mem.c,v 1.31 2016/09/25 15:23:36 deraadt Exp $ */
/* $NetBSD: mem.c,v 1.26 2000/03/29 03:48:20 simonb Exp $ */

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)mem.c	8.3 (Berkeley) 1/12/94
 */

/*
 * Memory special file
 */

#include <sys/param.h>
#include <sys/buf.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/uio.h>
#include <sys/malloc.h>
#include <sys/msgbuf.h>
#include <sys/mman.h>
#include <sys/conf.h>

#include <machine/cpu.h>

#include <uvm/uvm_extern.h>

#define mmread  mmrw
#define mmwrite mmrw
cdev_decl(mm);

caddr_t zeropage;

/* open counter for aperture */
#ifdef APERTURE
static int ap_open_count = 0;
extern int allowaperture;
#endif

int
mmopen(dev_t dev, int flag, int mode, struct proc *p)
{
	extern int allowkmem;

	switch (minor(dev)) {
	case 0:
	case 1:
		if (securelevel <= 0 || allowkmem)
			break;
		return (EPERM);
	case 2:
	case 12:
		break;
#ifdef APERTURE
	case 4:
	        if (suser(p, 0) != 0 || !allowaperture)
			return (EPERM);

		/* authorize only one simultaneous open() unless
		 * allowaperture=3 */
		if (ap_open_count > 0 && allowaperture < 3)
			return (EPERM);
		ap_open_count++;
		break;
#endif
	default:
		return (ENXIO);
	}
	return (0);
}

int
mmclose(dev_t dev, int flag, int mode, struct proc *p)
{

#ifdef APERTURE
	if (minor(dev) == 4)
		ap_open_count = 0;
#endif
	return (0);
}

int
mmrw(dev_t dev, struct uio *uio, int flags)
{
	vaddr_t o, v;
	size_t c;
	struct iovec *iov;
	int error = 0, rw;
	extern int msgbufmapped;

	while (uio->uio_resid > 0 && !error) {
		iov = uio->uio_iov;
		if (iov->iov_len == 0) {
			uio->uio_iov++;
			uio->uio_iovcnt--;
			if (uio->uio_iovcnt < 0)
				panic("mmrw");
			continue;
		}
		switch (minor(dev)) {

		/* minor device 0 is physical memory */
		case 0:
			v = uio->uio_offset;
kmemphys:
			if (v >= ALPHA_K0SEG_TO_PHYS((vaddr_t)msgbufp)) {
				if (msgbufmapped == 0) {
					printf("Message Buf not Mapped\n");
					error = EFAULT;
					break;
				}
			}

			/* Allow reads only in RAM. */
			rw = (uio->uio_rw == UIO_READ) ? PROT_READ : PROT_WRITE;
			if ((alpha_pa_access(v) & rw) != rw) {
				error = EFAULT;
				break;
			}

			o = uio->uio_offset & PGOFSET;
			c = ulmin(uio->uio_resid, PAGE_SIZE - o);
			error =
			    uiomove((caddr_t)ALPHA_PHYS_TO_K0SEG(v), c, uio);
			break;

/* minor device 1 is kernel memory */
		case 1:
			v = uio->uio_offset;

			if (v >= ALPHA_K0SEG_BASE && v <= ALPHA_K0SEG_END) {
				v = ALPHA_K0SEG_TO_PHYS(v);
				goto kmemphys;
			}

			c = ulmin(iov->iov_len, MAXPHYS);
			if (!uvm_kernacc((caddr_t)v, c,
			    uio->uio_rw == UIO_READ ? B_READ : B_WRITE))
				return (EFAULT);
			error = uiomove((caddr_t)v, c, uio);
			break;

		/* minor device 2 is /dev/null */
		case 2:
			if (uio->uio_rw == UIO_WRITE)
				uio->uio_resid = 0;
			return (0);

		/* minor device 12 is /dev/zero */
		case 12:
			if (uio->uio_rw == UIO_WRITE) {
				uio->uio_resid = 0;
				return (0);
			}
			/*
			 * On the first call, allocate and zero a page
			 * of memory for use with /dev/zero.
			 */
			if (zeropage == NULL)
				zeropage = malloc(PAGE_SIZE, M_TEMP,
				    M_WAITOK | M_ZERO);
			c = ulmin(iov->iov_len, PAGE_SIZE);
			error = uiomove(zeropage, c, uio);
			break;

		default:
			return (ENXIO);
		}
	}
	return (error);
}

paddr_t
mmmmap(dev_t dev, off_t off, int prot)
{
	switch (minor(dev)) {
	case 0:
		/*
		 * /dev/mem is the only one that makes sense through this
		 * interface.  For /dev/kmem any physaddr we return here
		 * could be transient and hence incorrect or invalid at
		 * a later time.  /dev/null just doesn't make any sense
		 * and /dev/zero is a hack that is handled via the default
		 * pager in mmap().
		 */

		/*
		 * Allow access only in RAM.
		 */
		if ((prot & alpha_pa_access(atop(off))) != prot)
			return (-1);
		return off;
		
#ifdef APERTURE
	case 4:
		/* minor device 4 is aperture driver */
		switch (allowaperture) {
		case 1:
			if ((prot & alpha_pa_access(atop(off))) != prot)
				return (-1);
			return off;
		default:
			return -1;
		}
#endif
	default:
		return -1;
	}
}

int
mmioctl(dev_t dev, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	return (EOPNOTSUPP);
}
@


1.31
log
@Make a move towards ending 4 decades of kernel snooping.

Add sysctl kern.allowkmem (default 0) which controls the ability to open
/dev/mem or /dev/kmem at securelevel > 0.  Over 15 years we converted 99%
of utilities in the tree to operate on sysctl-nodes (either by themselves
or via code hiding in the guts of -lkvm).

pstat -d and -v & procmap are affected and continued use of them will
require kern.allowkmem=1 in /etc/sysctl.conf.  acpidump (and it's
buddy sendbug) are affected, but we'll work out a solution soon.

There will be some impact in ports.

ok kettenis guenther
@
text
@d1 1
a1 1
/* $OpenBSD: mem.c,v 1.30 2016/08/15 22:01:59 tedu Exp $ */
a80 1
	}
@


1.30
log
@normalize some comments
@
text
@d1 1
a1 1
/* $OpenBSD: mem.c,v 1.29 2016/08/01 15:58:22 tedu Exp $ */
d73 1
d78 4
d83 2
a84 1
		return (0);
d95 1
a95 1
		return (0);
a96 2
	case 12:
		return (0);
d100 1
@


1.29
log
@bring the light of ansi to a few more files
@
text
@d1 1
a1 1
/* $OpenBSD: mem.c,v 1.28 2015/05/28 20:53:05 jcs Exp $ */
d87 1
a87 1
			return(EPERM);
d129 1
a129 1
/* minor device 0 is physical memory */
d170 1
a170 1
/* minor device 2 is EOF/rathole */
d176 1
a176 1
/* minor device 12 (/dev/zero) is source of nulls on read, rathole on write */
d205 12
a216 12
	/*
	 * /dev/mem is the only one that makes sense through this
	 * interface.  For /dev/kmem any physaddr we return here
	 * could be transient and hence incorrect or invalid at
	 * a later time.  /dev/null just doesn't make any sense
	 * and /dev/zero is a hack that is handled via the default
	 * pager in mmap().
	 */

	/*
	 * Allow access only in RAM.
	 */
@


1.28
log
@when machdep.allowaperture sysctl is set to 3, allow concurrent access
@
text
@d1 1
a1 1
/* $OpenBSD: mem.c,v 1.27 2015/02/10 22:44:35 miod Exp $ */
a69 1
/*ARGSUSED*/
d71 1
a71 4
mmopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
a97 1
/*ARGSUSED*/
d99 1
a99 4
mmclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
a108 1
/*ARGSUSED*/
d110 1
a110 4
mmrw(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d201 1
a201 4
mmmmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
d239 1
a239 6
mmioctl(dev, cmd, data, flags, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
@


1.27
log
@Convert to uiomove().
ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: mem.c,v 1.25 2010/12/26 15:40:58 miod Exp $ */
a66 1
static pid_t ap_open_pid = -1;
d88 3
a90 2
		/* authorize only one simultaneous open() from the same pid */
		if (ap_open_count > 0 && p->p_pid != ap_open_pid)
a92 1
		ap_open_pid = p->p_pid;
d111 1
a111 1
	if (minor(dev) == 4) {
a112 2
		ap_open_pid = -1;
	}
@


1.26
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d127 3
a129 3
	register vaddr_t o, v;
	register int c;
	register struct iovec *iov;
d164 1
a164 1
			c = min(uio->uio_resid, (int)(PAGE_SIZE - o));
d166 1
a166 1
			    uiomovei((caddr_t)ALPHA_PHYS_TO_K0SEG(v), c, uio);
d178 1
a178 1
			c = min(iov->iov_len, MAXPHYS);
d182 1
a182 1
			error = uiomovei((caddr_t)v, c, uio);
d204 2
a205 2
			c = min(iov->iov_len, PAGE_SIZE);
			error = uiomovei(zeropage, c, uio);
@


1.25
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/* $OpenBSD: mem.c,v 1.24 2010/04/21 03:03:25 deraadt Exp $ */
d166 1
a166 1
			    uiomove((caddr_t)ALPHA_PHYS_TO_K0SEG(v), c, uio);
d182 1
a182 1
			error = uiomove((caddr_t)v, c, uio);
d205 1
a205 1
			error = uiomove(zeropage, c, uio);
@


1.24
log
@more cleanup to cope with the change that tries to make proc.h not act
like it is everything.h
ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: mem.c,v 1.23 2008/11/05 06:32:47 matthieu Exp $ */
d237 1
a237 1
		return (atop(off));
d246 1
a246 1
			return atop(off);
@


1.23
log
@since mmclose() is only called once for the final close,
set ap_open_count = 0 in mmclose() instread of decrementing it.
ok miod@@, oga@@.
@
text
@d1 1
a1 1
/* $OpenBSD: mem.c,v 1.22 2007/09/22 16:21:32 krw Exp $ */
d47 1
@


1.22
log
@M_ZERO -> bzero.

ok art@@
@
text
@d1 1
a1 1
/* $OpenBSD: mem.c,v 1.21 2006/04/13 14:41:08 brad Exp $ */
d112 1
a112 1
		ap_open_count--;
@


1.21
log
@Use PAGE_SIZE rather than NBPG.

From NetBSD

ok martin@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: mem.c,v 1.20 2005/10/28 19:10:26 martin Exp $ */
d200 3
a202 5
			if (zeropage == NULL) {
				zeropage = (caddr_t)
				    malloc(PAGE_SIZE, M_TEMP, M_WAITOK);
				bzero(zeropage, PAGE_SIZE);
			}
@


1.20
log
@no more Mach-macros
@
text
@d1 1
a1 1
/* $OpenBSD: mem.c,v 1.19 2003/08/15 20:32:12 tedu Exp $ */
d163 1
a163 1
			c = min(uio->uio_resid, (int)(NBPG - o));
d202 2
a203 2
				    malloc(NBPG, M_TEMP, M_WAITOK);
				bzero(zeropage, NBPG);
d205 1
a205 1
			c = min(iov->iov_len, NBPG);
@


1.19
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: mem.c,v 1.18 2003/06/02 23:27:43 millert Exp $ */
d238 1
a238 1
		return (alpha_btop(off));
d247 1
a247 1
			return alpha_btop(off);
@


1.18
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/* $OpenBSD: mem.c,v 1.17 2002/08/24 17:21:45 matthieu Exp $ */
d85 1
a85 1
	        if (suser(p->p_ucred, &p->p_acflag) != 0 || !allowaperture)
@


1.17
log
@aperture driver for alpha. It works here the same as on i386
to allow access to VGA card's memory by mmapping /dev/xf86.
The macdep.allowaperture does also control /dev/pci access.
Ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: mem.c,v 1.16 2001/11/06 19:53:13 miod Exp $ */
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.16
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/* $OpenBSD: mem.c,v 1.15 2001/11/01 14:32:01 art Exp $ */
d67 7
d83 20
a102 7
		case 0:
		case 1:
		case 2:
		case 12:
			return (0);
		default:
			return (ENXIO);
d114 6
d226 2
a235 2
	if (minor(dev) != 0)
		return (-1);
d240 19
a258 3
	if ((prot & alpha_pa_access(atop(off))) != prot)
		return (-1);
	return (alpha_btop(off));
@


1.16.2.1
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: mem.c,v 1.16 2001/11/06 19:53:13 miod Exp $ */
a66 7
/* open counter for aperture */
#ifdef APERTURE
static int ap_open_count = 0;
static pid_t ap_open_pid = -1;
extern int allowaperture;
#endif

d76 7
a82 20
	case 0:
	case 1:
	case 2:
		return (0);
#ifdef APERTURE
	case 4:
	        if (suser(p->p_ucred, &p->p_acflag) != 0 || !allowaperture)
			return (EPERM);

		/* authorize only one simultaneous open() from the same pid */
		if (ap_open_count > 0 && p->p_pid != ap_open_pid)
			return(EPERM);
		ap_open_count++;
		ap_open_pid = p->p_pid;
		return (0);
#endif
	case 12:
		return (0);
	default:
		return (ENXIO);
a93 6
#ifdef APERTURE
	if (minor(dev) == 4) {
		ap_open_count--;
		ap_open_pid = -1;
	}
#endif
a199 2
	switch (minor(dev)) {
	case 0:
d208 2
d214 3
a216 19
		if ((prot & alpha_pa_access(atop(off))) != prot)
			return (-1);
		return (alpha_btop(off));
		
#ifdef APERTURE
	case 4:
		/* minor device 4 is aperture driver */
		switch (allowaperture) {
		case 1:
			if ((prot & alpha_pa_access(atop(off))) != prot)
				return (-1);
			return alpha_btop(off);
		default:
			return -1;
		}
#endif
	default:
		return -1;
	}
@


1.15
log
@Unnecessary cast.
@
text
@d1 1
a1 1
/* $OpenBSD: mem.c,v 1.13 2001/01/20 20:29:53 art Exp $ */
a57 2

#include <vm/vm.h>
@


1.14
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d216 1
a216 1
	if ((prot & alpha_pa_access(atop((paddr_t)off))) != prot)
@


1.13
log
@No need to include machine/alpha.h here.
@
text
@d1 1
a1 1
/* $OpenBSD: mem.c,v 1.12 2000/11/08 19:16:59 ericj Exp $ */
d196 1
a196 1
int
d199 1
a199 1
	int off;			/* XXX */
@


1.12
log
@add tags
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a57 1
#include <machine/alpha.h>
@


1.11
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
@


1.10
log
@make dmesg work on alpha
@
text
@d1 1
a1 2
/*	$OpenBSD: mem.c,v 1.9 1999/11/22 19:21:55 matthieu Exp $	*/
/*	$NetBSD: mem.c,v 1.10 1996/11/13 21:13:10 cgd Exp $	*/
a47 1
#include <sys/conf.h>
d52 3
d57 1
d61 2
a67 1
extern int firstusablepage, lastusablepage;
d106 1
a106 1
	register vm_offset_t o, v;
d109 2
a110 1
	int error = 0;
d112 1
a112 1
	while (uio->uio_resid > 0 && error == 0) {
d127 15
a141 4
			/* allow reads only in RAM (except for DEBUG) */
			if (v < ctob(firstusablepage) ||
			    v > ctob(lastusablepage + 1 + btoc(MSGBUFSIZE)))
				return (EFAULT);
d146 1
a146 1
			continue;
d158 1
a158 1
			if (!kernacc((caddr_t)v, c,
d162 1
a162 1
			continue;
d164 1
a164 1
/* minor device 2 is EOF/RATHOLE */
d173 2
a174 2
				c = iov->iov_len;
				break;
a178 3
			 *
			 * XXX on the alpha we already know where there
			 * is a global zeroed page, the null segment table.
a180 4
#if (CLBYTES == NBPG) && !defined(NEW_PMAP)
				extern caddr_t Segtabzero;
				zeropage = Segtabzero;
#else
d182 2
a183 3
				    malloc(CLBYTES, M_TEMP, M_WAITOK);
				bzero(zeropage, CLBYTES);
#endif
d185 1
a185 1
			c = min(iov->iov_len, CLBYTES);
d187 1
a187 1
			continue;
a191 6
		if (error)
			break;
		iov->iov_base += c;
		iov->iov_len -= c;
		uio->uio_offset += c;
		uio->uio_resid -= c;
d212 1
d216 1
a216 2
	if (off < ctob(firstusablepage) ||
	    off >= ctob(lastusablepage + 1))
@


1.9
log
@add empty mmioctl() implementation for new /dev/mem interface for all
architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.8 1998/08/31 17:42:25 millert Exp $	*/
d125 1
a125 1
			    v > ctob(lastusablepage + 1))
@


1.9.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 2
/* $OpenBSD: mem.c,v 1.13 2001/01/20 20:29:53 art Exp $ */
/* $NetBSD: mem.c,v 1.26 2000/03/29 03:48:20 simonb Exp $ */
d49 1
a53 3
#include <sys/msgbuf.h>
#include <sys/mman.h>
#include <sys/conf.h>
a58 2
#include <uvm/uvm_extern.h>

d64 1
d103 1
a103 1
	register vaddr_t o, v;
d106 1
a106 2
	int error = 0, rw;
	extern int msgbufmapped;
d108 1
a108 1
	while (uio->uio_resid > 0 && !error) {
d123 4
a126 15
			if (v >= ALPHA_K0SEG_TO_PHYS((vaddr_t)msgbufp)) {
				if (msgbufmapped == 0) {
					printf("Message Buf not Mapped\n");
					error = EFAULT;
					break;
				}
			}

			/* Allow reads only in RAM. */
			rw = (uio->uio_rw == UIO_READ) ? PROT_READ : PROT_WRITE;
			if ((alpha_pa_access(v) & rw) != rw) {
				error = EFAULT;
				break;
			}

d131 1
a131 1
			break;
d143 1
a143 1
			if (!uvm_kernacc((caddr_t)v, c,
d147 1
a147 1
			break;
d149 1
a149 1
/* minor device 2 is EOF/rathole */
d158 2
a159 2
				uio->uio_resid = 0;
				return (0);
d164 3
d169 4
d174 3
a176 2
				    malloc(NBPG, M_TEMP, M_WAITOK);
				bzero(zeropage, NBPG);
d178 1
a178 1
			c = min(iov->iov_len, NBPG);
d180 1
a180 1
			break;
d185 6
a210 1

d214 2
a215 1
	if ((prot & alpha_pa_access(atop((paddr_t)off))) != prot)
@


1.9.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d59 2
d196 1
a196 1
paddr_t
d199 1
a199 1
	off_t off;
d216 1
a216 1
	if ((prot & alpha_pa_access(atop(off))) != prot)
@


1.9.2.3
log
@Sync the SMP branch with 3.3
@
text
@a66 7
/* open counter for aperture */
#ifdef APERTURE
static int ap_open_count = 0;
static pid_t ap_open_pid = -1;
extern int allowaperture;
#endif

d76 7
a82 20
	case 0:
	case 1:
	case 2:
		return (0);
#ifdef APERTURE
	case 4:
	        if (suser(p->p_ucred, &p->p_acflag) != 0 || !allowaperture)
			return (EPERM);

		/* authorize only one simultaneous open() from the same pid */
		if (ap_open_count > 0 && p->p_pid != ap_open_pid)
			return(EPERM);
		ap_open_count++;
		ap_open_pid = p->p_pid;
		return (0);
#endif
	case 12:
		return (0);
	default:
		return (ENXIO);
a93 6
#ifdef APERTURE
	if (minor(dev) == 4) {
		ap_open_count--;
		ap_open_pid = -1;
	}
#endif
a199 2
	switch (minor(dev)) {
	case 0:
d208 2
d214 3
a216 19
		if ((prot & alpha_pa_access(atop(off))) != prot)
			return (-1);
		return (alpha_btop(off));
		
#ifdef APERTURE
	case 4:
		/* minor device 4 is aperture driver */
		switch (allowaperture) {
		case 1:
			if ((prot & alpha_pa_access(atop(off))) != prot)
				return (-1);
			return alpha_btop(off);
		default:
			return -1;
		}
#endif
	default:
		return -1;
	}
@


1.9.2.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: mem.c,v 1.9.2.3 2003/03/27 23:18:06 niklas Exp $ */
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.9.2.5
log
@Merge of -current from two weeks ago into the SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d85 1
a85 1
	        if (suser(p, 0) != 0 || !allowaperture)
@


1.8
log
@Return ENXIO on open of /dev/mem minor devs that don't exist
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.7 1997/06/05 23:21:11 deraadt Exp $	*/
d218 11
@


1.7
log
@fix DEBUG thing
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.6 1997/01/24 19:56:39 niklas Exp $	*/
d74 9
a82 1
	return (0);
@


1.6
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.5 1996/10/30 22:38:17 niklas Exp $	*/
a114 1
#ifndef DEBUG
d117 1
a117 1
			    v >= ctob(lastusablepage + 1))
a118 1
#endif
@


1.5
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 2
a2 2
/*	$OpenBSD: mem.c,v 1.9 1996/08/20 23:00:25 cgd Exp $	*/
/*	$NetBSD: mem.c,v 1.9 1996/08/20 23:00:25 cgd Exp $	*/
d59 4
a65 5
int mmopen __P((dev_t, int, int, struct proc *));
int mmclose __P((dev_t, int, int, struct proc *));
int mmrw __P((dev_t, struct uio *, int));
int mmmmap __P((dev_t, vm_offset_t, int));

d192 1
a192 1
	vm_offset_t off;
@


1.4
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: mem.c,v 1.6 1996/04/12 02:06:21 cgd Exp $	*/
/*	$NetBSD: mem.c,v 1.6 1996/04/12 02:06:21 cgd Exp $	*/
d62 5
d69 1
a69 1
mmopen(dev, flag, mode)
d72 1
d80 1
a80 1
mmclose(dev, flag, mode)
d83 1
d90 1
d124 2
a125 1
			error = uiomove((caddr_t)phystok0seg(v), c, uio);
d132 2
a133 2
			if (v >= K0SEG_BEGIN && v < K0SEG_END) {
				v = k0segtophys(v);
d164 1
a164 1
#if CLBYTES == NBPG
@


1.3
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.2
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: mem.c,v 1.5 1995/11/23 02:34:21 cgd Exp $	*/
d115 1
a115 1
			error = uiomove(phystok0seg(v), c, uio);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: mem.c,v 1.4 1995/06/28 02:45:13 cgd Exp $	*/
d106 1
d121 6
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
