head	1.83;
access;
symbols
	OPENBSD_6_0:1.81.0.2
	OPENBSD_6_0_BASE:1.81
	OPENBSD_5_9:1.80.0.2
	OPENBSD_5_9_BASE:1.80
	OPENBSD_5_8:1.80.0.4
	OPENBSD_5_8_BASE:1.80
	OPENBSD_5_7:1.77.0.2
	OPENBSD_5_7_BASE:1.77
	OPENBSD_5_6:1.75.0.4
	OPENBSD_5_6_BASE:1.75
	OPENBSD_5_5:1.69.0.4
	OPENBSD_5_5_BASE:1.69
	OPENBSD_5_4:1.64.0.4
	OPENBSD_5_4_BASE:1.64
	OPENBSD_5_3:1.64.0.2
	OPENBSD_5_3_BASE:1.64
	OPENBSD_5_2:1.60.0.2
	OPENBSD_5_2_BASE:1.60
	OPENBSD_5_1_BASE:1.59
	OPENBSD_5_1:1.59.0.2
	OPENBSD_5_0:1.58.0.2
	OPENBSD_5_0_BASE:1.58
	OPENBSD_4_9:1.57.0.2
	OPENBSD_4_9_BASE:1.57
	OPENBSD_4_8:1.56.0.2
	OPENBSD_4_8_BASE:1.56
	OPENBSD_4_7:1.55.0.6
	OPENBSD_4_7_BASE:1.55
	OPENBSD_4_6:1.55.0.8
	OPENBSD_4_6_BASE:1.55
	OPENBSD_4_5:1.55.0.4
	OPENBSD_4_5_BASE:1.55
	OPENBSD_4_4:1.55.0.2
	OPENBSD_4_4_BASE:1.55
	OPENBSD_4_3:1.54.0.4
	OPENBSD_4_3_BASE:1.54
	OPENBSD_4_2:1.54.0.2
	OPENBSD_4_2_BASE:1.54
	OPENBSD_4_1:1.52.0.2
	OPENBSD_4_1_BASE:1.52
	OPENBSD_4_0:1.51.0.2
	OPENBSD_4_0_BASE:1.51
	OPENBSD_3_9:1.49.0.2
	OPENBSD_3_9_BASE:1.49
	OPENBSD_3_8:1.46.0.2
	OPENBSD_3_8_BASE:1.46
	OPENBSD_3_7:1.44.0.2
	OPENBSD_3_7_BASE:1.44
	OPENBSD_3_6:1.43.0.4
	OPENBSD_3_6_BASE:1.43
	SMP_SYNC_A:1.43
	SMP_SYNC_B:1.43
	OPENBSD_3_5:1.43.0.2
	OPENBSD_3_5_BASE:1.43
	OPENBSD_3_4:1.41.0.2
	OPENBSD_3_4_BASE:1.41
	UBC_SYNC_A:1.40
	OPENBSD_3_3:1.39.0.2
	OPENBSD_3_3_BASE:1.39
	OPENBSD_3_2:1.38.0.2
	OPENBSD_3_2_BASE:1.38
	OPENBSD_3_1:1.32.0.2
	OPENBSD_3_1_BASE:1.32
	UBC_SYNC_B:1.38
	UBC:1.29.0.2
	UBC_BASE:1.29
	OPENBSD_3_0:1.26.0.2
	OPENBSD_3_0_BASE:1.26
	OPENBSD_2_9:1.25.0.2
	OPENBSD_2_9_BASE:1.25
	OPENBSD_2_8:1.19.0.2
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.18.0.12
	OPENBSD_2_7_BASE:1.18
	SMP:1.18.0.10
	SMP_BASE:1.18
	kame_19991208:1.18
	OPENBSD_2_6:1.18.0.8
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.18.0.6
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.18.0.4
	OPENBSD_2_4_BASE:1.18
	OPENBSD_2_3:1.18.0.2
	OPENBSD_2_3_BASE:1.18
	OPENBSD_2_2:1.15.0.2
	OPENBSD_2_2_BASE:1.15
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.83
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.82;
commitid	CHRb0fCqa8XxUAMH;

1.82
date	2016.10.08.05.49.08;	author guenther;	state Exp;
branches;
next	1.81;
commitid	z63v1DilayzHcfkw;

1.81
date	2016.03.30.15.39.46;	author afresh1;	state Exp;
branches;
next	1.80;
commitid	AEwJ5MlE20muUoPp;

1.80
date	2015.06.23.12.29.46;	author deraadt;	state Exp;
branches;
next	1.79;
commitid	H7659T356IZbW0c8;

1.79
date	2015.06.05.16.59.10;	author deraadt;	state Exp;
branches;
next	1.78;
commitid	TPgQEmzdUR7w5M1P;

1.78
date	2015.06.05.16.45.24;	author deraadt;	state Exp;
branches;
next	1.77;
commitid	W2uKClkgPBDKjRAB;

1.77
date	2014.12.24.21.15.30;	author miod;	state Exp;
branches;
next	1.76;
commitid	P18WFM2toJUP4FVw;

1.76
date	2014.11.16.12.30.52;	author deraadt;	state Exp;
branches;
next	1.75;
commitid	yv0ECmCdICvq576h;

1.75
date	2014.07.02.18.37.33;	author miod;	state Exp;
branches;
next	1.74;
commitid	67iah2C8h4RSjvdf;

1.74
date	2014.05.11.00.12.43;	author guenther;	state Exp;
branches;
next	1.73;

1.73
date	2014.05.10.05.33.00;	author guenther;	state Exp;
branches;
next	1.72;

1.72
date	2014.04.18.11.51.16;	author guenther;	state Exp;
branches;
next	1.71;

1.71
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.70;

1.70
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.69;

1.69
date	2014.02.06.05.14.12;	author miod;	state Exp;
branches;
next	1.68;

1.68
date	2014.02.04.21.52.43;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2014.02.01.21.25.07;	author miod;	state Exp;
branches;
next	1.66;

1.66
date	2014.01.26.17.40.09;	author miod;	state Exp;
branches;
next	1.65;

1.65
date	2014.01.06.20.27.44;	author miod;	state Exp;
branches;
next	1.64;

1.64
date	2012.12.31.06.46.13;	author guenther;	state Exp;
branches;
next	1.63;

1.63
date	2012.11.02.19.10.51;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2012.11.01.21.09.17;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2012.08.07.05.16.53;	author guenther;	state Exp;
branches;
next	1.60;

1.60
date	2012.04.11.14.38.55;	author mikeb;	state Exp;
branches;
next	1.59;

1.59
date	2011.11.16.20.50.17;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2011.04.03.14.56.27;	author guenther;	state Exp;
branches;
next	1.57;

1.57
date	2010.10.27.20.20.38;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2010.06.30.20.38.49;	author tedu;	state Exp;
branches;
next	1.55;

1.55
date	2008.06.26.05.42.08;	author ray;	state Exp;
branches;
next	1.54;

1.54
date	2007.04.12.14.38.36;	author martin;	state Exp;
branches;
next	1.53;

1.53
date	2007.03.15.10.22.29;	author art;	state Exp;
branches;
next	1.52;

1.52
date	2006.12.24.20.30.33;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2006.06.19.20.23.53;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2006.03.19.22.00.29;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2005.12.25.00.22.45;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2005.09.15.21.14.25;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2005.09.15.21.09.27;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2005.04.28.17.19.27;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2005.04.21.04.39.34;	author mickey;	state Exp;
branches;
next	1.44;

1.44
date	2004.12.06.20.12.21;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2003.11.13.08.19.20;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2003.10.18.20.14.40;	author jmc;	state Exp;
branches;
next	1.41;

1.41
date	2003.08.10.00.03.21;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2003.05.10.21.11.11;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2003.01.09.22.27.03;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2002.07.24.00.33.49;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2002.06.28.16.50.38;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2002.06.23.03.03.15;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2002.05.16.21.11.10;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2002.04.29.00.30.36;	author pvalchev;	state Exp;
branches;
next	1.33;

1.33
date	2002.04.28.20.55.14;	author pvalchev;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.16.03.21.28;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.14.01.26.26;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.12.11.58.14;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2001.11.28.16.13.27;	author art;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2001.11.28.13.47.37;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2001.11.06.19.53.13;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2001.07.09.18.55.21;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.20.20.27.40;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2000.11.16.18.38.34;	author ericj;	state Exp;
branches;
next	1.23;

1.23
date	2000.11.15.07.50.42;	author nate;	state Exp;
branches;
next	1.22;

1.22
date	2000.11.10.18.15.33;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2000.11.08.19.16.59;	author ericj;	state Exp;
branches;
next	1.20;

1.20
date	2000.11.08.16.01.03;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.08.22.25.16;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	98.03.01.15.00.59;	author niklas;	state Exp;
branches
	1.18.10.1;
next	1.17;

1.17
date	97.11.17.01.26.38;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.11.17.01.16.34;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.07.24.05.57.53;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	97.07.19.21.05.04;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	97.07.06.17.18.50;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	97.07.06.16.23.48;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	97.02.12.14.57.02;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.02.09.14.18.42;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.02.06.12.37.56;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.02.06.12.13.37;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	97.02.03.13.09.16;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.01.24.19.56.46;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.10.30.22.38.29;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.07.29.22.58.06;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.01.12.16.45.00;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.52.47;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.40;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.40;	author deraadt;	state Exp;
branches;
next	;

1.18.10.1
date	2001.04.18.16.00.32;	author niklas;	state Exp;
branches;
next	1.18.10.2;

1.18.10.2
date	2001.10.31.02.52.44;	author nate;	state Exp;
branches;
next	1.18.10.3;

1.18.10.3
date	2001.11.13.21.00.49;	author niklas;	state Exp;
branches;
next	1.18.10.4;

1.18.10.4
date	2001.12.05.00.39.08;	author niklas;	state Exp;
branches;
next	1.18.10.5;

1.18.10.5
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	1.18.10.6;

1.18.10.6
date	2003.03.27.23.18.06;	author niklas;	state Exp;
branches;
next	1.18.10.7;

1.18.10.7
date	2003.05.13.19.41.02;	author ho;	state Exp;
branches;
next	1.18.10.8;

1.18.10.8
date	2004.02.19.09.59.33;	author niklas;	state Exp;
branches;
next	;

1.29.2.1
date	2002.06.11.03.33.39;	author art;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2002.10.29.00.28.00;	author art;	state Exp;
branches;
next	1.29.2.3;

1.29.2.3
date	2003.05.19.21.38.52;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.83
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@/* $OpenBSD: trap.c,v 1.82 2016/10/08 05:49:08 guenther Exp $ */
/* $NetBSD: trap.c,v 1.52 2000/05/24 16:48:33 thorpej Exp $ */

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1999 Christopher G. Demetriou.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1994, 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/user.h>
#include <sys/syscall.h>
#include <sys/syscall_mi.h>
#include <sys/buf.h>
#ifndef NO_IEEE
#include <sys/device.h>
#endif
#include <sys/ptrace.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/reg.h>
#ifdef DDB
#include <machine/db_machdep.h>
#endif
#include <alpha/alpha/db_instruction.h>

#ifndef SMALL_KERNEL

unsigned long	Sfloat_to_reg(unsigned int);
unsigned int	reg_to_Sfloat(unsigned long);
unsigned long	Tfloat_reg_cvt(unsigned long);
#ifdef FIX_UNALIGNED_VAX_FP
unsigned long	Ffloat_to_reg(unsigned int);
unsigned int	reg_to_Ffloat(unsigned long);
unsigned long	Gfloat_reg_cvt(unsigned long);
#endif

int		unaligned_fixup(unsigned long, unsigned long,
		    unsigned long, struct proc *);
#endif	/* SMALL_KERNEL */

int		handle_opdec(struct proc *p, u_int64_t *ucodep);

#ifndef NO_IEEE
struct device fpevent_use;
struct device fpevent_reuse;
#endif

void	printtrap(const unsigned long, const unsigned long, const unsigned long,
	    const unsigned long, struct trapframe *, int, int);

/*
 * Initialize the trap vectors for the current processor.
 */
void
trap_init()
{

	/*
	 * Point interrupt/exception vectors to our own.
	 */
	alpha_pal_wrent(XentInt, ALPHA_KENTRY_INT); 
	alpha_pal_wrent(XentArith, ALPHA_KENTRY_ARITH);
	alpha_pal_wrent(XentMM, ALPHA_KENTRY_MM);
	alpha_pal_wrent(XentIF, ALPHA_KENTRY_IF);
	alpha_pal_wrent(XentUna, ALPHA_KENTRY_UNA); 
	alpha_pal_wrent(XentSys, ALPHA_KENTRY_SYS);

	/*
	 * Clear pending machine checks and error reports, and enable
	 * system- and processor-correctable error reporting.
	 */
	alpha_pal_wrmces(alpha_pal_rdmces() & 
	    ~(ALPHA_MCES_DSC|ALPHA_MCES_DPC));
}

void
printtrap(const unsigned long a0, const unsigned long a1,
    const unsigned long a2, const unsigned long entry, struct trapframe *framep,
    int isfatal, int user)
{
	char ubuf[64];
	const char *entryname;

	switch (entry) {
	case ALPHA_KENTRY_INT:
		entryname = "interrupt";
		break;
	case ALPHA_KENTRY_ARITH:
		entryname = "arithmetic trap";
		break;
	case ALPHA_KENTRY_MM:
		entryname = "memory management fault";
		break;
	case ALPHA_KENTRY_IF:
		entryname = "instruction fault";
		break;
	case ALPHA_KENTRY_UNA:
		entryname = "unaligned access fault";
		break;
	case ALPHA_KENTRY_SYS:
		entryname = "system call";
		break;
	default:
		snprintf(ubuf, sizeof ubuf, "type %lx", entry);
		entryname = (const char *) ubuf;
		break;
	}

	printf("\n");
	printf("%s %s trap:\n", isfatal? "fatal" : "handled",
	       user ? "user" : "kernel");
	printf("\n");
	printf("    trap entry = 0x%lx (%s)\n", entry, entryname);
	printf("    a0         = 0x%lx\n", a0);
	printf("    a1         = 0x%lx\n", a1);
	printf("    a2         = 0x%lx\n", a2);
	printf("    pc         = 0x%lx\n", framep->tf_regs[FRAME_PC]);
	printf("    ra         = 0x%lx\n", framep->tf_regs[FRAME_RA]);
	printf("    curproc    = %p\n", curproc);
	if (curproc != NULL)
		printf("        pid = %d, comm = %s\n",
		    curproc->p_p->ps_pid, curproc->p_p->ps_comm);
	printf("\n");
}

/*
 * Trap is called from locore to handle most types of processor traps.
 * System calls are broken out for efficiency and ASTs are broken out
 * to make the code a bit cleaner and more representative of the
 * Alpha architecture.
 */
/*ARGSUSED*/
void
trap(a0, a1, a2, entry, framep)
	const unsigned long a0, a1, a2, entry;
	struct trapframe *framep;
{
	struct proc *p;
	int i;
	u_int64_t ucode;
	int user;
#if defined(DDB)
	int call_debugger = 1;
#endif
	caddr_t v;
	int typ;
	union sigval sv;
	vm_prot_t ftype;
	unsigned long onfault;

	atomic_add_int(&uvmexp.traps, 1);
	p = curproc;
	ucode = 0;
	v = 0;
	user = (framep->tf_regs[FRAME_PS] & ALPHA_PSL_USERMODE) != 0;
	if (user) {
		p->p_md.md_tf = framep;
		refreshcreds(p);
	}

	switch (entry) {
	case ALPHA_KENTRY_UNA:
		/*
		 * If user-land, do whatever fixups, printing, and
		 * signalling is appropriate (based on system-wide
		 * and per-process unaligned-access-handling flags).
		 */
		if (user) {
#ifndef SMALL_KERNEL
			KERNEL_LOCK();
			i = unaligned_fixup(a0, a1, a2, p);
			KERNEL_UNLOCK();
			if (i == 0)
				goto out;
#endif

			ucode = ILL_ILLADR;
			v = (caddr_t)a0;
			break;
		}

		/*
		 * Unaligned access from kernel mode is always an error,
		 * EVEN IF A COPY FAULT HANDLER IS SET!
		 *
		 * It's an error if a copy fault handler is set because
		 * the various routines which do user-initiated copies
		 * do so in a bcopy-like manner.  In other words, the
		 * kernel never assumes that pointers provided by the
		 * user are properly aligned, and so if the kernel
		 * does cause an unaligned access it's a kernel bug.
		 */
		goto dopanic;

	case ALPHA_KENTRY_ARITH:
		/*
		 * Resolve trap shadows, interpret FP ops requiring infinities,
		 * NaNs, or denorms, and maintain FPCR corrections.
		 */
		if (user) {
#ifndef NO_IEEE
			i = alpha_fp_complete(a0, a1, p, &ucode);
			if (i == 0)
				goto out;
#else
			i = SIGFPE;
			ucode = FPE_FLTINV;
#endif
			v = (caddr_t)framep->tf_regs[FRAME_PC];
			break;
		}

		/* Always fatal in kernel.  Should never happen. */
		goto dopanic;

	case ALPHA_KENTRY_IF:
		/*
		 * These are always fatal in kernel, and should never
		 * happen.  (Debugger entry is handled in XentIF.)
		 */
		if (!user) {
#if defined(DDB)
			/*
			 * ...unless a debugger is configured.  It will
			 * inform us if the trap was handled.
			 */
			if (alpha_debug(a0, a1, a2, entry, framep))
				goto out;

			/*
			 * Debugger did NOT handle the trap, don't
			 * call the debugger again!
			 */
			call_debugger = 0;
#endif
			goto dopanic;
		}
		i = 0;
		switch (a0) {
		case ALPHA_IF_CODE_GENTRAP:
			if (framep->tf_regs[FRAME_A0] == -2) { /* weird! */
				i = SIGFPE;
				ucode =  a0;	/* exception summary */
				break;
			}
			/* FALLTHROUGH */
		case ALPHA_IF_CODE_BPT:
		case ALPHA_IF_CODE_BUGCHK:
#ifdef PTRACE
			if (p->p_md.md_flags & (MDP_STEP1|MDP_STEP2)) {
				KERNEL_LOCK();
				process_sstep(p, 0);
				KERNEL_UNLOCK();
				p->p_md.md_tf->tf_regs[FRAME_PC] -= 4;
			}
#endif
			ucode = a0;		/* trap type */
			i = SIGTRAP;
			break;

		case ALPHA_IF_CODE_OPDEC:
			KERNEL_LOCK();
			i = handle_opdec(p, &ucode);
			KERNEL_UNLOCK();
			if (i == 0)
				goto out;
			break;

		case ALPHA_IF_CODE_FEN:
			alpha_enable_fp(p, 0);
			goto out;

		default:
			printf("trap: unknown IF type 0x%lx\n", a0);
			goto dopanic;
		}
		v = (caddr_t)framep->tf_regs[FRAME_PC];
		break;

	case ALPHA_KENTRY_MM:
		switch (a1) {
		case ALPHA_MMCSR_FOR:
		case ALPHA_MMCSR_FOE:
		case ALPHA_MMCSR_FOW:
			KERNEL_LOCK();
			if (pmap_emulate_reference(p, a0, user, a1)) {
				ftype = PROT_EXEC;
				goto do_fault;
			}
			KERNEL_UNLOCK();
			goto out;

		case ALPHA_MMCSR_INVALTRANS:
		case ALPHA_MMCSR_ACCESS:
	    	    {
			vaddr_t va;
			struct vmspace *vm = NULL;
			struct vm_map *map;
			int rv;
			extern struct vm_map *kernel_map;

			switch (a2) {
			case -1:		/* instruction fetch fault */
				ftype = PROT_EXEC;
				break;
			case 0:			/* load instruction */
				ftype = PROT_READ;
				break;
			case 1:			/* store instruction */
				ftype = PROT_READ | PROT_WRITE;
				break;
			}
	
			KERNEL_LOCK();
do_fault:
			/*
			 * It is only a kernel address space fault iff:
			 *	1. !user and
			 *	2. pcb_onfault not set or
			 *	3. pcb_onfault set but kernel space data fault
			 * The last can occur during an exec() copyin where the
			 * argument space is lazy-allocated.
			 */
			if (!user && (a0 >= VM_MIN_KERNEL_ADDRESS ||
			    p->p_addr->u_pcb.pcb_onfault == 0)) {
				vm = NULL;
				map = kernel_map;
			} else {
				vm = p->p_vmspace;
				map = &vm->vm_map;
			}
	
			va = trunc_page((vaddr_t)a0);
			onfault = p->p_addr->u_pcb.pcb_onfault;
			p->p_addr->u_pcb.pcb_onfault = 0;
			rv = uvm_fault(map, va, 0, ftype);
			p->p_addr->u_pcb.pcb_onfault = onfault;

			/*
			 * If this was a stack access we keep track of the
			 * maximum accessed stack size.  Also, if vm_fault
			 * gets a protection failure it is due to accessing
			 * the stack region outside the current limit and
			 * we need to reflect that as an access error.
			 */
			if (map != kernel_map &&
			    (caddr_t)va >= vm->vm_maxsaddr) {
				if (rv == 0) {
					uvm_grow(p, va);
				} else if (rv == EACCES)
					rv = EFAULT;
			}
			if (rv == 0) {
				KERNEL_UNLOCK();
				goto out;
			}

			if (!user) {
				/* Check for copyin/copyout fault */
				if (p->p_addr->u_pcb.pcb_onfault != 0) {
					framep->tf_regs[FRAME_PC] =
					    p->p_addr->u_pcb.pcb_onfault;
					KERNEL_UNLOCK();
					goto out;
				}
				KERNEL_UNLOCK();
				goto dopanic;
			}
			KERNEL_UNLOCK();
			ucode = ftype;
			v = (caddr_t)a0;
			typ = SEGV_MAPERR;
			if (rv == ENOMEM) {
				printf("UVM: pid %u (%s), uid %d killed: "
				   "out of swap\n", p->p_p->ps_pid,
				   p->p_p->ps_comm,
				   p->p_ucred ? (int)p->p_ucred->cr_uid : -1);
				i = SIGKILL;
			} else {
				i = SIGSEGV;
			}
			break;
		    }

		default:
			printf("trap: unknown MMCSR value 0x%lx\n", a1);
			goto dopanic;
		}
		break;

	default:
		goto dopanic;
	}

#ifdef DEBUG
	printtrap(a0, a1, a2, entry, framep, 1, user);
#endif
	sv.sival_ptr = v;
	KERNEL_LOCK();
	trapsignal(p, i, ucode, typ, sv);
	KERNEL_UNLOCK();
out:
	if (user) {
		/* Do any deferred user pmap operations. */
		PMAP_USERRET(vm_map_pmap(&p->p_vmspace->vm_map));

		userret(p);
	}
	return;

dopanic:
	printtrap(a0, a1, a2, entry, framep, 1, user);
	/* XXX dump registers */

#if defined(DDB)
	if (call_debugger && alpha_debug(a0, a1, a2, entry, framep)) {
		/*
		 * The debugger has handled the trap; just return.
		 */
		goto out;
	}
#endif

	panic("trap");
}

/*
 * Process a system call.
 *
 * System calls are strange beasts.  They are passed the syscall number
 * in v0, and the arguments in the registers (as normal).  They return
 * an error flag in a3 (if a3 != 0 on return, the syscall had an error),
 * and the return value (if any) in v0.
 *
 * The assembly stub takes care of moving the call number into a register
 * we can get to, and moves all of the argument registers into their places
 * in the trap frame.  On return, it restores the callee-saved registers,
 * a3, and v0 from the frame before returning to the user process.
 */
void
syscall(code, framep)
	u_int64_t code;
	struct trapframe *framep;
{
	struct sysent *callp;
	struct proc *p;
	int error, numsys;
	u_int64_t opc;
	u_long rval[2];
	u_long args[10];					/* XXX */
	u_int hidden, nargs;

	atomic_add_int(&uvmexp.syscalls, 1);
	p = curproc;
	p->p_md.md_tf = framep;
	opc = framep->tf_regs[FRAME_PC] - 4;

	callp = p->p_p->ps_emul->e_sysent;
	numsys = p->p_p->ps_emul->e_nsysent;

	switch(code) {
	case SYS_syscall:
	case SYS___syscall:
		/*
		 * syscall() and __syscall() are handled the same on
		 * the alpha, as everything is 64-bit aligned, anyway.
		 */
		code = framep->tf_regs[FRAME_A0];
		hidden = 1;
		break;
	default:
		hidden = 0;
	}

	error = 0;
	if (code < numsys)
		callp += code;
	else
		callp += p->p_p->ps_emul->e_nosys;

	nargs = callp->sy_narg + hidden;
	switch (nargs) {
	default:
		if (nargs > 10)		/* XXX */
			panic("syscall: too many args (%d)", nargs);
		if ((error = copyin((caddr_t)(alpha_pal_rdusp()), &args[6],
		    (nargs - 6) * sizeof(u_long))))
			goto bad;
	case 6:	
		args[5] = framep->tf_regs[FRAME_A5];
	case 5:	
		args[4] = framep->tf_regs[FRAME_A4];
	case 4:	
		args[3] = framep->tf_regs[FRAME_A3];
	case 3:	
		args[2] = framep->tf_regs[FRAME_A2];
	case 2:	
		args[1] = framep->tf_regs[FRAME_A1];
	case 1:	
		args[0] = framep->tf_regs[FRAME_A0];
	case 0:
		break;
	}

	rval[0] = 0;
	rval[1] = 0;

	error = mi_syscall(p, code, callp, args + hidden, rval);

	switch (error) {
	case 0:
		framep->tf_regs[FRAME_V0] = rval[0];
		framep->tf_regs[FRAME_A4] = rval[1];
		framep->tf_regs[FRAME_A3] = 0;
		break;
	case ERESTART:
		framep->tf_regs[FRAME_PC] = opc;
		break;
	case EJUSTRETURN:
		break;
	default:
	bad:
		framep->tf_regs[FRAME_V0] = error;
		framep->tf_regs[FRAME_A3] = 1;
		break;
	}

	/* Do any deferred user pmap operations. */
	PMAP_USERRET(vm_map_pmap(&p->p_vmspace->vm_map));

	mi_syscall_return(p, code, error, rval);
}

/*
 * Process the tail end of a fork() for the child.
 */
void
child_return(arg)
	void *arg;
{
	struct proc *p = arg;
	struct trapframe *framep = p->p_md.md_tf;

	/*
	 * Return values in the frame set by cpu_fork().
	 */
	framep->tf_regs[FRAME_V0] = 0;
	framep->tf_regs[FRAME_A4] = 0;
	framep->tf_regs[FRAME_A3] = 0;

	KERNEL_UNLOCK();

	/* Do any deferred user pmap operations. */
	PMAP_USERRET(vm_map_pmap(&p->p_vmspace->vm_map));

	mi_child_return(p);
}

/*
 * Set the float-point enable for the current process, and return
 * the FPU context to the named process. If check == 0, it is an
 * error for the named process to already be fpcurproc.
 */
void
alpha_enable_fp(struct proc *p, int check)
{
	struct cpu_info *ci = curcpu();
#if defined(MULTIPROCESSOR)
	int s;
#endif

	if (check && ci->ci_fpcurproc == p) {
		alpha_pal_wrfen(1);
		return;
	}
	if (ci->ci_fpcurproc == p)
		panic("trap: fp disabled for fpcurproc == %p", p);

	if (ci->ci_fpcurproc != NULL)
		fpusave_cpu(ci, 1);

	KDASSERT(ci->ci_fpcurproc == NULL);

#if defined(MULTIPROCESSOR)
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 1);
#else
	KDASSERT(p->p_addr->u_pcb.pcb_fpcpu == NULL);
#endif

#if defined(MULTIPROCESSOR)
	/* Need to block IPIs */
	s = splipi();
#endif
	p->p_addr->u_pcb.pcb_fpcpu = ci;
	ci->ci_fpcurproc = p;
	atomic_add_int(&uvmexp.fpswtch, 1);

	p->p_md.md_flags |= MDP_FPUSED;
	alpha_pal_wrfen(1);
	restorefpstate(&p->p_addr->u_pcb.pcb_fp);
	alpha_pal_wrfen(0);

#if defined(MULTIPROCESSOR)
	alpha_pal_swpipl(s);
#endif
}

/*
 * Process an asynchronous software trap.
 * This is relatively easy.
 */
void
ast(framep)
	struct trapframe *framep;
{
	struct cpu_info *ci = curcpu();
	struct proc *p = ci->ci_curproc;

	p->p_md.md_tf = framep;
	p->p_md.md_astpending = 0;

#ifdef DIAGNOSTIC
	if ((framep->tf_regs[FRAME_PS] & ALPHA_PSL_USERMODE) == 0)
		panic("ast and not user");
#endif

	atomic_add_int(&uvmexp.softs, 1);
	mi_ast(p, ci->ci_want_resched);

	/* Do any deferred user pmap operations. */
	PMAP_USERRET(vm_map_pmap(&p->p_vmspace->vm_map));

	userret(p);
}

/*
 * Unaligned access handler.  It's not clear that this can get much slower...
 *
 */

const static int reg_to_framereg[32] = {
	FRAME_V0,	FRAME_T0,	FRAME_T1,	FRAME_T2,
	FRAME_T3,	FRAME_T4,	FRAME_T5,	FRAME_T6,
	FRAME_T7,	FRAME_S0,	FRAME_S1,	FRAME_S2,
	FRAME_S3,	FRAME_S4,	FRAME_S5,	FRAME_S6,
	FRAME_A0,	FRAME_A1,	FRAME_A2,	FRAME_A3,
	FRAME_A4,	FRAME_A5,	FRAME_T8,	FRAME_T9,
	FRAME_T10,	FRAME_T11,	FRAME_RA,	FRAME_T12,
	FRAME_AT,	FRAME_GP,	FRAME_SP,	-1,
};

#define	irp(p, reg)							\
	((reg_to_framereg[(reg)] == -1) ? NULL :			\
	    &(p)->p_md.md_tf->tf_regs[reg_to_framereg[(reg)]])

#ifndef SMALL_KERNEL

#define	frp(p, reg)							\
	(&(p)->p_addr->u_pcb.pcb_fp.fpr_regs[(reg)])

#define	dump_fp_regs()							\
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)				\
		fpusave_proc(p, 1);

#define	unaligned_load(storage, ptrf, mod)				\
	if (copyin((caddr_t)va, &(storage), sizeof (storage)) != 0) {	\
		p->p_md.md_tf->tf_regs[FRAME_PC] -= 4;			\
		signal = SIGSEGV;					\
		goto out;						\
	}								\
	signal = 0;							\
	if ((regptr = ptrf(p, reg)) != NULL)				\
		*regptr = mod (storage);

#define	unaligned_store(storage, ptrf, mod)				\
	if ((regptr = ptrf(p, reg)) != NULL)				\
		(storage) = mod (*regptr);				\
	else								\
		(storage) = 0;						\
	if (copyout(&(storage), (caddr_t)va, sizeof (storage)) != 0) {	\
		p->p_md.md_tf->tf_regs[FRAME_PC] -= 4;			\
		signal = SIGSEGV;					\
		goto out;						\
	}								\
	signal = 0;

#define	unaligned_load_integer(storage)					\
	unaligned_load(storage, irp, )

#define	unaligned_store_integer(storage)				\
	unaligned_store(storage, irp, )

#define	unaligned_load_floating(storage, mod)				\
	dump_fp_regs();							\
	unaligned_load(storage, frp, mod)

#define	unaligned_store_floating(storage, mod)				\
	dump_fp_regs();							\
	unaligned_store(storage, frp, mod)

unsigned long
Sfloat_to_reg(s)
	unsigned int s;
{
	unsigned long sign, expn, frac;
	unsigned long result;

	sign = (s & 0x80000000) >> 31;
	expn = (s & 0x7f800000) >> 23;
	frac = (s & 0x007fffff) >>  0;

	/* map exponent part, as appropriate. */
	if (expn == 0xff)
		expn = 0x7ff;
	else if ((expn & 0x80) != 0)
		expn = (0x400 | (expn & ~0x80));
	else if ((expn & 0x80) == 0 && expn != 0)
		expn = (0x380 | (expn & ~0x80));

	result = (sign << 63) | (expn << 52) | (frac << 29);
	return (result);
}

unsigned int
reg_to_Sfloat(r)
	unsigned long r;
{
	unsigned long sign, expn, frac;
	unsigned int result;

	sign = (r & 0x8000000000000000) >> 63;
	expn = (r & 0x7ff0000000000000) >> 52;
	frac = (r & 0x000fffffe0000000) >> 29;

	/* map exponent part, as appropriate. */
	expn = (expn & 0x7f) | ((expn & 0x400) != 0 ? 0x80 : 0x00);

	result = (sign << 31) | (expn << 23) | (frac << 0);
	return (result);
}

/*
 * Conversion of T floating datums to and from register format
 * requires no bit reordering whatsoever.
 */
unsigned long
Tfloat_reg_cvt(input)
	unsigned long input;
{

	return (input);
}

#ifdef FIX_UNALIGNED_VAX_FP
unsigned long
Ffloat_to_reg(f)
	unsigned int f;
{
	unsigned long sign, expn, frlo, frhi;
	unsigned long result;

	sign = (f & 0x00008000) >> 15;
	expn = (f & 0x00007f80) >>  7;
	frhi = (f & 0x0000007f) >>  0;
	frlo = (f & 0xffff0000) >> 16;

	/* map exponent part, as appropriate. */
	if ((expn & 0x80) != 0)
		expn = (0x400 | (expn & ~0x80));
	else if ((expn & 0x80) == 0 && expn != 0)
		expn = (0x380 | (expn & ~0x80));

	result = (sign << 63) | (expn << 52) | (frhi << 45) | (frlo << 29);
	return (result);
}

unsigned int
reg_to_Ffloat(r)
	unsigned long r;
{
	unsigned long sign, expn, frhi, frlo;
	unsigned int result;

	sign = (r & 0x8000000000000000) >> 63;
	expn = (r & 0x7ff0000000000000) >> 52;
	frhi = (r & 0x000fe00000000000) >> 45;
	frlo = (r & 0x00001fffe0000000) >> 29;

	/* map exponent part, as appropriate. */
	expn = (expn & 0x7f) | ((expn & 0x400) != 0 ? 0x80 : 0x00);

	result = (sign << 15) | (expn << 7) | (frhi << 0) | (frlo << 16);
	return (result);
}

/*
 * Conversion of G floating datums to and from register format is
 * symmetrical.  Just swap shorts in the quad...
 */
unsigned long
Gfloat_reg_cvt(input)
	unsigned long input;
{
	unsigned long a, b, c, d;
	unsigned long result;

	a = (input & 0x000000000000ffff) >> 0;
	b = (input & 0x00000000ffff0000) >> 16;
	c = (input & 0x0000ffff00000000) >> 32;
	d = (input & 0xffff000000000000) >> 48;

	result = (a << 48) | (b << 32) | (c << 16) | (d << 0);
	return (result);
}
#endif /* FIX_UNALIGNED_VAX_FP */

struct unaligned_fixup_data {
	const char *type;	/* opcode name */
	int fixable;		/* fixable, 0 if fixup not supported */
	int size;		/* size, 0 if unknown */
};

#define	UNKNOWN()	{ "0x%lx", 0, 0 }
#define	FIX_LD(n,s)	{ n, 1, s }
#define	FIX_ST(n,s)	{ n, 1, s }
#define	NOFIX_LD(n,s)	{ n, 0, s }
#define	NOFIX_ST(n,s)	{ n, 0, s }

int
unaligned_fixup(va, opcode, reg, p)
	unsigned long va, opcode, reg;
	struct proc *p;
{
	const struct unaligned_fixup_data tab_unknown[1] = {
		UNKNOWN(),
	};
	const struct unaligned_fixup_data tab_0c[0x02] = {
		FIX_LD("ldwu", 2),	FIX_ST("stw", 2),
	};
	const struct unaligned_fixup_data tab_20[0x10] = {
#ifdef FIX_UNALIGNED_VAX_FP
		FIX_LD("ldf", 4),	FIX_LD("ldg", 8),
#else
		NOFIX_LD("ldf", 4),	NOFIX_LD("ldg", 8),
#endif
		FIX_LD("lds", 4),	FIX_LD("ldt", 8),
#ifdef FIX_UNALIGNED_VAX_FP
		FIX_ST("stf", 4),	FIX_ST("stg", 8),
#else
		NOFIX_ST("stf", 4),	NOFIX_ST("stg", 8),
#endif
		FIX_ST("sts", 4),	FIX_ST("stt", 8),
		FIX_LD("ldl", 4),	FIX_LD("ldq", 8),
		NOFIX_LD("ldl_c", 4),	NOFIX_LD("ldq_c", 8),
		FIX_ST("stl", 4),	FIX_ST("stq", 8),
		NOFIX_ST("stl_c", 4),	NOFIX_ST("stq_c", 8),
	};
	const struct unaligned_fixup_data *selected_tab;
	int doprint, dofix, dosigbus, signal;
	unsigned long *regptr, longdata;
	int intdata;		/* signed to get extension when storing */
	u_int16_t worddata;	/* unsigned to _avoid_ extension */

	/*
	 * Read USP into frame in case it's the register to be modified.
	 * This keeps us from having to check for it in lots of places
	 * later.
	 */
	p->p_md.md_tf->tf_regs[FRAME_SP] = alpha_pal_rdusp();

	/*
	 * Figure out what actions to take.
	 *
	 * XXX In the future, this should have a per-process component
	 * as well.
	 */
	doprint = alpha_unaligned_print;
	dofix = alpha_unaligned_fix;
	dosigbus = alpha_unaligned_sigbus;

	/*
	 * Find out which opcode it is.  Arrange to have the opcode
	 * printed if it's an unknown opcode.
	 */
	if (opcode >= 0x0c && opcode <= 0x0d)
		selected_tab = &tab_0c[opcode - 0x0c];
	else if (opcode >= 0x20 && opcode <= 0x2f)
		selected_tab = &tab_20[opcode - 0x20];
	else
		selected_tab = tab_unknown;

	/*
	 * If we're supposed to be noisy, squawk now.
	 */
	if (doprint) {
		uprintf(
		"pid %u (%s): unaligned access: va=0x%lx pc=0x%lx ra=0x%lx op=",
		    p->p_p->ps_pid, p->p_p->ps_comm, va,
		    p->p_md.md_tf->tf_regs[FRAME_PC] - 4,
		    p->p_md.md_tf->tf_regs[FRAME_RA]);
		uprintf(selected_tab->type,opcode);
		uprintf("\n");
	}

	/*
	 * If we should try to fix it and know how, give it a shot.
	 *
	 * We never allow bad data to be unknowingly used by the
	 * user process.  That is, if we decide not to fix up an
	 * access we cause a SIGBUS rather than letting the user
	 * process go on without warning.
	 *
	 * If we're trying to do a fixup, we assume that things
	 * will be botched.  If everything works out OK, 
	 * unaligned_{load,store}_* clears the signal flag.
	 */
	signal = SIGBUS;
	if (dofix && selected_tab->fixable) {
		switch (opcode) {
		case 0x0c:			/* ldwu */
			/* XXX ONLY WORKS ON LITTLE-ENDIAN ALPHA */
			unaligned_load_integer(worddata);
			break;

		case 0x0d:			/* stw */
			/* XXX ONLY WORKS ON LITTLE-ENDIAN ALPHA */
			unaligned_store_integer(worddata);
			break;

#ifdef FIX_UNALIGNED_VAX_FP
		case 0x20:			/* ldf */
			unaligned_load_floating(intdata, Ffloat_to_reg);
			break;

		case 0x21:			/* ldg */
			unaligned_load_floating(longdata, Gfloat_reg_cvt);
			break;
#endif

		case 0x22:			/* lds */
			unaligned_load_floating(intdata, Sfloat_to_reg);
			break;

		case 0x23:			/* ldt */
			unaligned_load_floating(longdata, Tfloat_reg_cvt);
			break;

#ifdef FIX_UNALIGNED_VAX_FP
		case 0x24:			/* stf */
			unaligned_store_floating(intdata, reg_to_Ffloat);
			break;

		case 0x25:			/* stg */
			unaligned_store_floating(longdata, Gfloat_reg_cvt);
			break;
#endif

		case 0x26:			/* sts */
			unaligned_store_floating(intdata, reg_to_Sfloat);
			break;

		case 0x27:			/* stt */
			unaligned_store_floating(longdata, Tfloat_reg_cvt);
			break;

		case 0x28:			/* ldl */
			unaligned_load_integer(intdata);
			break;

		case 0x29:			/* ldq */
			unaligned_load_integer(longdata);
			break;

		case 0x2c:			/* stl */
			unaligned_store_integer(intdata);
			break;

		case 0x2d:			/* stq */
			unaligned_store_integer(longdata);
			break;

#ifdef DIAGNOSTIC
		default:
			panic("unaligned_fixup: can't get here");
#endif
		}
	} 

	/*
	 * Force SIGBUS if requested.
	 */
	if (dosigbus)
		signal = SIGBUS;

out:
	/*
	 * Write back USP.
	 */
	alpha_pal_wrusp(p->p_md.md_tf->tf_regs[FRAME_SP]);

	return (signal);
}

#endif	/* SMALL_KERNEL */

/*
 * Reserved/unimplemented instruction (opDec fault) handler
 *
 * Argument is the process that caused it.  No useful information
 * is passed to the trap handler other than the fault type.  The
 * address of the instruction that caused the fault is 4 less than
 * the PC stored in the trap frame.
 *
 * If the instruction is emulated successfully, this function returns 0.
 * Otherwise, this function returns the signal to deliver to the process,
 * and fills in *ucodep with the code to be delivered.
 */
int
handle_opdec(p, ucodep)
	struct proc *p;
	u_int64_t *ucodep;
{
	alpha_instruction inst;
	register_t *regptr, memaddr;
	u_int64_t inst_pc;
	int sig;

	/*
	 * Read USP into frame in case it's going to be used or modified.
	 * This keeps us from having to check for it in lots of places
	 * later.
	 */
	p->p_md.md_tf->tf_regs[FRAME_SP] = alpha_pal_rdusp();

	inst_pc = memaddr = p->p_md.md_tf->tf_regs[FRAME_PC] - 4;
	if (copyin((caddr_t)inst_pc, &inst, sizeof (inst)) != 0) {
		/*
		 * really, this should never happen, but in case it
		 * does we handle it.
		 */
		printf("WARNING: handle_opdec() couldn't fetch instruction\n");
		goto sigsegv;
	}

	switch (inst.generic_format.opcode) {
	case op_ldbu:
	case op_ldwu:
	case op_stw:
	case op_stb:
		regptr = irp(p, inst.mem_format.rb);
		if (regptr != NULL)
			memaddr = *regptr;
		else
			memaddr = 0;
		memaddr += inst.mem_format.displacement;

		regptr = irp(p, inst.mem_format.ra);

		if (inst.mem_format.opcode == op_ldwu ||
		    inst.mem_format.opcode == op_stw) {
			if (memaddr & 0x01) {
#ifndef SMALL_KERNEL
				sig = unaligned_fixup(memaddr,
				    inst.mem_format.opcode,
				    inst.mem_format.ra, p);
				if (sig)
					goto unaligned_fixup_sig;
#else
				goto sigill;
#endif
				break;
			}
		}

		if (inst.mem_format.opcode == op_ldbu) {
			u_int8_t b;

			/* XXX ONLY WORKS ON LITTLE-ENDIAN ALPHA */
			if (copyin((caddr_t)memaddr, &b, sizeof (b)) != 0)
				goto sigsegv;
			if (regptr != NULL)
				*regptr = b;
		} else if (inst.mem_format.opcode == op_ldwu) {
			u_int16_t w;

			/* XXX ONLY WORKS ON LITTLE-ENDIAN ALPHA */
			if (copyin((caddr_t)memaddr, &w, sizeof (w)) != 0)
				goto sigsegv;
			if (regptr != NULL)
				*regptr = w;
		} else if (inst.mem_format.opcode == op_stw) {
			u_int16_t w;

			/* XXX ONLY WORKS ON LITTLE-ENDIAN ALPHA */
			w = (regptr != NULL) ? *regptr : 0;
			if (copyout(&w, (caddr_t)memaddr, sizeof (w)) != 0)
				goto sigsegv;
		} else if (inst.mem_format.opcode == op_stb) {
			u_int8_t b;

			/* XXX ONLY WORKS ON LITTLE-ENDIAN ALPHA */
			b = (regptr != NULL) ? *regptr : 0;
			if (copyout(&b, (caddr_t)memaddr, sizeof (b)) != 0)
				goto sigsegv;
		}
		break;

	case op_intmisc:
		if (inst.operate_generic_format.function == op_sextb &&
		    inst.operate_generic_format.ra == 31) {
			int8_t b;

			if (inst.operate_generic_format.is_lit) {
				b = inst.operate_lit_format.literal;
			} else {
				if (inst.operate_reg_format.sbz != 0)
					goto sigill;
				regptr = irp(p, inst.operate_reg_format.rb);
				b = (regptr != NULL) ? *regptr : 0;
			}

			regptr = irp(p, inst.operate_generic_format.rc);
			if (regptr != NULL)
				*regptr = b;
			break;
		}
		if (inst.operate_generic_format.function == op_sextw &&
		    inst.operate_generic_format.ra == 31) {
			int16_t w;

			if (inst.operate_generic_format.is_lit) {
				w = inst.operate_lit_format.literal;
			} else {
				if (inst.operate_reg_format.sbz != 0)
					goto sigill;
				regptr = irp(p, inst.operate_reg_format.rb);
				w = (regptr != NULL) ? *regptr : 0;
			}

			regptr = irp(p, inst.operate_generic_format.rc);
			if (regptr != NULL)
				*regptr = w;
			break;
		}
		goto sigill;

#ifndef NO_IEEE
	/* case op_fix_float: */
	/* case op_vax_float: */
	case op_ieee_float:
	/* case op_any_float: */
		/*
		 * EV4 processors do not implement dynamic rounding
		 * instructions at all.
		 */
		if (cpu_implver <= ALPHA_IMPLVER_EV4) {
			sig = alpha_fp_complete_at(inst_pc, p, ucodep);
			if (sig)
				return sig;
			break;
		}
		goto sigill;
#endif

	default:
		goto sigill;
	}

	/*
	 * Write back USP.  Note that in the error cases below,
	 * nothing will have been successfully modified so we don't
	 * have to write it out.
	 */
	alpha_pal_wrusp(p->p_md.md_tf->tf_regs[FRAME_SP]);

	return (0);

sigill:
	*ucodep = ALPHA_IF_CODE_OPDEC;			/* trap type */
	return (SIGILL);

sigsegv:
	sig = SIGSEGV;
	p->p_md.md_tf->tf_regs[FRAME_PC] = inst_pc;	/* re-run instr. */
#ifndef SMALL_KERNEL
unaligned_fixup_sig:
#endif
	*ucodep = memaddr;				/* faulting address */
	return (sig);
}
@


1.82
log
@Various printf claim to report the PID, so actually report that and not the TID

Build testing assistance from deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.81 2016/03/30 15:39:46 afresh1 Exp $ */
d209 1
a209 1
		    curproc->p_p->ps_pid, curproc->p_comm);
d462 2
a463 1
				   "out of swap\n", p->p_p->ps_pid, p->p_comm,
d986 1
a986 1
		    p->p_p->ps_pid, p->p_comm, va,
@


1.81
log
@Better support for alphas without all IEEE-mode instructions

From Miod Vallat

I trust miod deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.80 2015/06/23 12:29:46 deraadt Exp $ */
d208 2
a209 2
		printf("        pid = %d, comm = %s\n", curproc->p_pid,
		       curproc->p_comm);
d462 2
a463 2
			           "out of swap\n", p->p_pid, p->p_comm,
			           p->p_ucred ? (int)p->p_ucred->cr_uid : -1);
d985 1
a985 1
		    p->p_pid, p->p_comm, va,
@


1.80
log
@delete more p==NULL checks; discussed with miod, kettenis, dlg before
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.79 2015/06/05 16:59:10 deraadt Exp $ */
d1233 18
@


1.79
log
@Do not unconditionally clear pcb_onfault after a uvm_fault.  That will
permit the active copyout/copyin to continue work on subsequent faulting
pages and not misinterpret & fault them as kernel bcopy against userland
addresses.  Old bug -- fall of 1996.  This should fix getentropy issues
on MP systems which have become more apparent recently, probably due to
some combo of increased ASLR with unlocked getentropy happening very soon
after vfork/fork...
ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.78 2015/06/05 16:45:24 deraadt Exp $ */
d412 1
a412 1
			    p == NULL || p->p_addr->u_pcb.pcb_onfault == 0)) {
d436 1
a436 2
					if (p != NULL)
					    uvm_grow(p, va);
@


1.78
log
@these days, curproc is never NULL, so skip those checks.
Discussed with kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.77 2014/12/24 21:15:30 miod Exp $ */
a450 1
					p->p_addr->u_pcb.pcb_onfault = 0;
@


1.77
log
@Partially revert 1.46 and print more details when panicing at the end of
trap(). This is expected to reduce loss of hair. ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.76 2014/11/16 12:30:52 deraadt Exp $ */
d421 2
a422 4
			if (p != NULL) {
				onfault = p->p_addr->u_pcb.pcb_onfault;
				p->p_addr->u_pcb.pcb_onfault = 0;
			}
d424 2
a425 2
			if (p != NULL)
				p->p_addr->u_pcb.pcb_onfault = onfault;
d448 1
a448 2
				if (p != NULL &&
				    p->p_addr->u_pcb.pcb_onfault != 0) {
@


1.76
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.75 2014/07/02 18:37:33 miod Exp $ */
d135 3
a137 4
#ifdef DEBUG
static void printtrap(const unsigned long, const unsigned long,
      const unsigned long, const unsigned long, struct trapframe *, int, int);
#endif /* DEBUG */
d163 4
a166 6
#ifdef DEBUG
static void
printtrap(a0, a1, a2, entry, framep, isfatal, user)
	const unsigned long a0, a1, a2, entry;
	struct trapframe *framep;
	int isfatal, user;
a211 1
#endif /* DEBUG */
a502 1
#ifdef DEBUG
a503 1
#endif
@


1.75
log
@Make sure the kernel lock is held when invoking process_domem(); fixes
ptrace operation on MP kernels.
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.74 2014/05/11 00:12:43 guenther Exp $ */
d378 1
a378 1
				ftype = VM_PROT_EXECUTE;
d395 1
a395 1
				ftype = VM_PROT_EXECUTE;
d398 1
a398 1
				ftype = VM_PROT_READ;
d401 1
a401 1
				ftype = VM_PROT_READ|VM_PROT_WRITE;
@


1.74
log
@Move the increment of uvmexp.softs back to the caller of mi_ast():
it needs to be done atomicly on some MP archs and we don't have
atomic_add_int() everywhere yet.  Also, mi_ast() was meant to be inline.

noted by miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.73 2014/05/10 05:33:00 guenther Exp $ */
d342 1
d344 1
@


1.73
log
@Factor out the common ast bits into mi_ast()

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.72 2014/04/18 11:51:16 guenther Exp $ */
d723 1
@


1.72
log
@Have each thread keeps its own (counted!) reference to the process's ucreds
to avoid possible use-after-free references when swapping ids in threaded
processes.  "Do I have the right creds?" checks are always made with the
threads creds.

Inspired by FreeBSD and NetBSD
"right time" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.71 2014/03/30 21:54:48 guenther Exp $ */
d723 1
a723 10
	atomic_add_int(&uvmexp.softs, 1);

	if (p->p_flag & P_OWEUPC) {
		KERNEL_LOCK();
		ADDUPROF(p);
		KERNEL_UNLOCK();
	}

	if (ci->ci_want_resched)
		preempt(NULL);
@


1.71
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.70 2014/03/26 05:23:42 guenther Exp $ */
d247 1
a247 1
	if (user)
d249 2
@


1.70
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.69 2014/02/06 05:14:12 miod Exp $ */
d466 3
a468 4
				printf("UVM: pid %u (%s), uid %u killed: "
				       "out of swap\n", p->p_pid, p->p_comm,
				       p->p_cred && p->p_ucred ?
				       p->p_ucred->cr_uid : -1);
@


1.69
log
@Fix an MP race in the fpu context saving code; from NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.68 2014/02/04 21:52:43 miod Exp $ */
d552 2
a553 2
	callp = p->p_emul->e_sysent;
	numsys = p->p_emul->e_nsysent;
d573 1
a573 1
		callp += p->p_emul->e_nosys;
@


1.68
log
@Restore spl (lowering it) with alpha_pal_swpipl() instead of splx() in the
code paths which can be run from ipi handlers, to avoid running soft interrupt
handlers if lowering ipl to 0. Soft interrupts will be processed upon returning
from the ipi interrupt anyway.
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.67 2014/02/01 21:25:07 miod Exp $ */
a357 1
			alpha_pal_wrfen(0);
a690 3
#if defined(MULTIPROCESSOR)
	alpha_pal_swpipl(s);
#endif
d696 5
@


1.67
log
@Use splipi() instead of splhigh() to protect lazy fpu saving code.
In MP kernel, replace a TOCTTOU-vulnerable assert with a ``loop until we have
achieved our goals'' logic.
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.66 2014/01/26 17:40:09 miod Exp $ */
d693 1
a693 1
	splx(s);
@


1.66
log
@Work in progress work towards SMP, heavily based upon NetBSD. The MP kernel
will boot multiuser, but will deadlock under load, and I can't find my
mistake yet.
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.65 2014/01/06 20:27:44 miod Exp $ */
d688 1
a688 1
	s = splhigh();
@


1.65
log
@Put PG_EXEC and PG_FOE into the PG_PROT mask, and make sure the default
pte protection masks, as initialized in alpha_protection_init(), set PG_FOE
by default when VM_PROT_EXECUTE is not set.

Also, change pmap_emulate_reference() to only clear PG_FOE if the affected
pte has executable permission.

This allows various pmap_pte_exec() checks (added to explicitely set PG_FOE)
to be removed.

All tests of regress/sys/kern/noexec now reliably pass on EV5. EV6 systems
still see spurious (but no longer 100% reproduceable) failures of the `catch
a signal' tests, which is likely caused by the effect of mprotect() removing
execute permission not taking effect correctly, despite PAL IMB being issued
(and no, this is not caused by the previous pmap_changebit() change), to be
investigated.
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.64 2012/12/31 06:46:13 guenther Exp $ */
d242 1
a242 1
	uvmexp.traps++;
d259 4
a262 1
			if ((i = unaligned_fixup(a0, a1, a2, p)) == 0)
d349 4
a352 1
			if ((i = handle_opdec(p, &ucode)) == 0)
d373 1
d378 1
d383 1
a383 1
	    	{
d402 1
d445 1
d456 1
d459 1
d462 1
d492 1
d494 1
d548 1
a548 1
	uvmexp.syscalls++;
d646 2
d663 3
d686 4
d692 4
a695 1
	uvmexp.fpswtch++;
d721 1
a721 1
	uvmexp.softs++;
d724 1
d726 1
@


1.64
log
@Remove emulation errno mapping code from platforms that no longer have
non-native emulations.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.63 2012/11/02 19:10:51 miod Exp $ */
d368 1
a368 2
				/* XXX - stupid API right now. */
				ftype = VM_PROT_EXECUTE|VM_PROT_READ;
d384 1
a384 1
				ftype = VM_PROT_EXECUTE|VM_PROT_READ;
@


1.63
log
@typo
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.62 2012/11/01 21:09:17 miod Exp $ */
a603 2
		if (p->p_emul->e_errno)
			error = p->p_emul->e_errno[error];
@


1.62
log
@Switch alpha to per-process astpending.
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.61 2012/08/07 05:16:53 guenther Exp $ */
d690 1
a690 1
	p->p_md.md_astepending = 0;
@


1.61
log
@Move the common bits of syscall invocation and return handling into
an MI file, <sys/syscall_mi.h>, correcting inconsistencies and the
handling when copyin() of arguments fails.

Tested on i386, amd64, sparc64, and alpha (thanks naddy@@)
Any issues with other platforms will be fixed in tree.

header name from millert@@; ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.60 2012/04/11 14:38:55 mikeb Exp $ */
d247 1
a247 1
	if (user)  {
a248 9
#if	0
/* This is to catch some weird stuff on the UDB (mj) */
		if (framep->tf_regs[FRAME_PC] > 0 && 
		    framep->tf_regs[FRAME_PC] < 0x120000000) {
			printf("PC Out of Whack\n");
			printtrap(a0, a1, a2, entry, framep, 1, user);
		}
#endif
	}
d686 2
a687 3
	struct proc *p;

	curcpu()->ci_astpending = 0;
a688 1
	p = curproc;
d690 1
d703 1
a703 1
	if (curcpu()->ci_want_resched)
@


1.60
log
@The first ktrace record for a newly spawned thread is a return
from a fork syscall done by the parent.  Use __tfork, not rfork
here to match the ktrace records for the parent (CALL __tfork,
RET __tfork).  ok guenther
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.59 2011/11/16 20:50:17 deraadt Exp $ */
d97 1
a101 3
#ifdef KTRACE
#include <sys/ktrace.h>
#endif
a103 3
#include "systrace.h"
#include <dev/systrace.h>

d576 3
a578 2
		error = copyin((caddr_t)(alpha_pal_rdusp()), &args[6],
		    (nargs - 6) * sizeof(u_long));
d594 5
a598 17
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSCALL))
		ktrsyscall(p, code, callp->sy_argsize, args + hidden);
#endif
#ifdef SYSCALL_DEBUG
	scdebug_call(p, code, args + hidden);
#endif
	if (error == 0) {
		rval[0] = 0;
		rval[1] = 0;
#if NSYSTRACE > 0
		if (ISSET(p->p_flag, P_SYSTRACE))
			error = systrace_redirect(code, p, args + hidden, rval);
		else
#endif
			error = (*callp->sy_call)(p, args + hidden, rval);
	}
d612 1
a619 3
#ifdef SYSCALL_DEBUG
	scdebug_ret(p, code, error, rval);
#endif
d623 1
a623 5
	userret(p);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, code, error, rval[0]);
#endif
d646 1
a646 8
	userret(p);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p,
		    (p->p_flag & P_THREAD) ? SYS___tfork :
		    (p->p_p->ps_flags & PS_PPWAIT) ? SYS_vfork : SYS_fork,
		    0, 0);
#endif
@


1.59
log
@Make userret() MI.  On architectures which jammed stuff into it in the
past, pull that code out seperately.
ok guenther miod
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.58 2011/04/03 14:56:27 guenther Exp $ */
d672 1
a672 1
		    (p->p_flag & P_THREAD) ? SYS_rfork :
@


1.58
log
@Move PPWAIT flag from struct proc to process, so that rthreads in
a vforked child behave correctly.  Have the parent in a vfork()
wait on a (different) flag in *its* process instead of the child
to prevent a possible use-after-free.  When ktracing the child
return from a fork, call it rfork if an rthread was created.

ok blambert@@
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.57 2010/10/27 20:20:38 miod Exp $ */
a117 2
void		userret(struct proc *);

a168 19
/*
 * Define the code needed before returning to user mode, for
 * trap and syscall.
 */
void
userret(struct proc *p)
{
	int sig;

	/* Do any deferred user pmap operations. */
	PMAP_USERRET(vm_map_pmap(&p->p_vmspace->vm_map));

	/* take pending signals */
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);

	curcpu()->ci_schedstate.spc_curpriority = p->p_priority = p->p_usrpri;
}

d496 4
a499 1
	if (user)
d501 1
d638 3
d665 3
d744 3
@


1.57
log
@Report proper pc address in siginfo; found the hard way by naddy@@ and gcc 4.
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.56 2010/06/30 20:38:49 tedu Exp $ */
d683 3
a685 1
		    (p->p_flag & P_PPWAIT) ? SYS_vfork : SYS_fork, 0, 0);
@


1.56
log
@remove compat_osf1 support from the kernel
ok deraadt miod
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.55 2008/06/26 05:42:08 ray Exp $ */
d271 1
d298 2
a299 1
			ucode = a0;		/* VA */
d328 1
a328 1
			ucode = a0;
d330 1
d394 1
@


1.55
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.54 2007/04/12 14:38:36 martin Exp $ */
a117 4
#ifdef COMPAT_OSF1
#include <compat/osf1/osf1_syscall.h>
#endif

a559 3
#ifdef COMPAT_OSF1
	extern struct emul emul_osf1;
#endif
a568 13
#ifdef COMPAT_OSF1
	if (p->p_emul == &emul_osf1) 
		switch (code) {
		case OSF1_SYS_syscall:
			/* OSF/1 syscall() */
			code = framep->tf_regs[FRAME_A0];
			hidden = 1;
			break;
		default:
			hidden = 0;
		}
	else
#endif
@


1.54
log
@__HAVE_CPUINFO for alpha, with bits from netbsd

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.53 2007/03/15 10:22:29 art Exp $ */
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.53
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.52 2006/12/24 20:30:33 miod Exp $ */
d198 1
a198 1
	curpriority = p->p_priority = p->p_usrpri;
@


1.52
log
@Define PROC_PC. Then, since profiling information is being reported in
statclock(), do not bother doing this in userret() anymore. As a result,
userret() does not need its pc and ticks arguments, simplify.
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.51 2006/06/19 20:23:53 miod Exp $ */
a770 1
		p->p_flag &= ~P_OWEUPC;
@


1.51
log
@Reset pcb_onfault around uvm_fault() calls.
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.50 2006/03/19 22:00:29 miod Exp $ */
d129 1
a129 1
void		userret(struct proc *, u_int64_t, u_quad_t);
d187 1
a187 4
userret(p, pc, oticks)
	register struct proc *p;
	u_int64_t pc;
	u_quad_t oticks;
a189 1
	struct cpu_info *ci = curcpu();
a196 22
	p->p_priority = p->p_usrpri;
	if (ci->ci_want_resched) {
		/*
		 * We are being preempted.
		 */
		preempt(NULL);

		ci = curcpu();

		PMAP_USERRET(vm_map_pmap(&p->p_vmspace->vm_map));
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
	}

	/*
	 * If profiling, charge recent system time to the trapped pc.
	 */
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, pc, (int)(p->p_sticks - oticks) * psratio);
	}
d198 1
a198 1
	curpriority = p->p_priority;
a268 1
	u_quad_t sticks;
a283 1
		sticks = p->p_sticks;
a292 2
	} else {
		sticks = 0;		/* XXX bogus -Wuninitialized warning */
d525 1
a525 1
		userret(p, framep->tf_regs[FRAME_PC], sticks);
a567 1
	u_quad_t sticks;
a574 4
#if notdef				/* can't happen, ever. */
	if ((framep->tf_regs[FRAME_PS] & ALPHA_PSL_USERMODE) == 0)
		panic("syscall");
#endif
a578 1
	sticks = p->p_sticks;
d678 1
a678 1
	userret(p, framep->tf_regs[FRAME_PC], sticks);
d702 1
a702 1
	userret(p, framep->tf_regs[FRAME_PC], 0);
d756 1
a756 2
	register struct proc *p;
	u_quad_t sticks;
a760 1
	sticks = p->p_sticks;
d763 1
d766 1
d775 4
a778 1
	userret(p, framep->tf_regs[FRAME_PC], sticks);
@


1.50
log
@Do not compile misaligned access recovery code if option SMALL_KERNEL;
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.49 2005/12/25 00:22:45 miod Exp $ */
d292 2
a293 2
	register struct proc *p;
	register int i;
d304 1
d477 2
a478 1
			    p == NULL || p->p_addr->u_pcb.pcb_onfault == 0))
d480 1
a480 1
			else {
d486 4
d491 2
@


1.49
log
@Ensure child_return() leaves registers the same way a successfull system
call would.
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.48 2005/09/15 21:14:25 miod Exp $ */
d131 2
d144 2
d332 1
d335 1
d810 1
d826 2
d1174 2
d1232 1
d1238 3
d1337 1
d1339 1
@


1.48
log
@In syscall(), do not recompute the struct proc * after the syscall has
succeeded. This used to be necessary for fork(), when returning in the child,
but we return in the child in child_return() which does TRT.

ok art@@
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.47 2005/09/15 21:09:27 miod Exp $ */
d715 1
d720 3
d724 1
a724 1
	userret(p, p->p_md.md_tf->tf_regs[FRAME_PC], 0);
@


1.47
log
@Change child_return() to record a proper ktrace record for vfork child
processes.

ok art@@ uwe@@ (some time ago)
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.46 2005/04/28 17:19:27 deraadt Exp $ */
a696 5
        /*
         * Reinitialize proc pointer `p' as it may be different
         * if this is a child returning from fork syscall.
         */
	p = curproc;
a699 1

@


1.46
log
@shrink extra verbose crud
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.45 2005/04/21 04:39:34 mickey Exp $ */
d729 2
a730 1
		ktrsysret(p, SYS_fork, 0, 0);
@


1.45
log
@count fpu lazy context switches; deraadt@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.44 2004/12/06 20:12:21 miod Exp $ */
d149 1
d152 1
a152 1

d223 1
d274 1
d545 1
d547 1
a547 1

@


1.44
log
@Use uvm_grow() to account for stack growth, rather than home-grown code
or nothing.
Inspired by a similar recent change in NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.43 2003/11/13 08:19:20 miod Exp $ */
d760 1
@


1.43
log
@More leftovers after uvm_useracc() removal; from NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.42 2003/10/18 20:14:40 jmc Exp $ */
d484 1
a484 2
			    (caddr_t)va >= vm->vm_maxsaddr &&
			    va < USRSTACK) {
d486 2
a487 6
					unsigned nss;
	
					nss = btoc(USRSTACK -
					    (unsigned long)va);
					if (nss > vm->vm_ssize)
						vm->vm_ssize = nss;
@


1.42
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.41 2003/08/10 00:03:21 miod Exp $ */
a982 1
	int acc;		/* useracc type; B_READ or B_WRITE */
d985 5
a989 5
#define	UNKNOWN()	{ "0x%lx", 0, 0, 0 }
#define	FIX_LD(n,s)	{ n, 1, s, B_READ }
#define	FIX_ST(n,s)	{ n, 1, s, B_WRITE }
#define	NOFIX_LD(n,s)	{ n, 0, s, B_READ }
#define	NOFIX_ST(n,s)	{ n, 0, s, B_WRITE }
@


1.41
log
@Do not trust and use uvm_useracc, but rather always check copy{in,out} for
failure and act appropriately.
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.40 2003/05/10 21:11:11 deraadt Exp $ */
d395 1
a395 1
			/* FALLTHROUTH */
@


1.40
log
@string cleaning; ok beck dhartmei
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.39 2003/01/09 22:27:03 miod Exp $ */
d828 5
a832 2
	if (copyin((caddr_t)va, &(storage), sizeof (storage)) != 0)	\
		break;							\
d842 5
a846 2
	if (copyout(&(storage), (caddr_t)va, sizeof (storage)) != 0)	\
		break;							\
a1053 15

	/*
	 * See if the user can access the memory in question.
	 * If it's an unknown opcode, we don't know whether to
	 * read or write, so we don't check.
	 *
	 * We adjust the PC backwards so that the instruction will
	 * be re-run.
	 */
	if (selected_tab->size != 0 &&
	   !uvm_useracc((caddr_t)va, selected_tab->size, selected_tab->acc)) {
		p->p_md.md_tf->tf_regs[FRAME_PC] -= 4;
		signal = SIGSEGV;
		goto out;
	}
@


1.39
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.38 2002/07/24 00:33:49 art Exp $ */
d251 1
a251 1
		sprintf(ubuf, "type %lx", entry);
@


1.38
log
@Pretty nasty hack to make non-exec mappings work.
Instead of using FOE for just emulating references, we also keep track
of a pages executability and don't remove the FOE bit if the page
is not executable.

This is implmented with horrible hacks. Maybe when I have time, I'll
reimplment the whole pmap to allow this without ugly hacks (read: probably
not this decade).

The stack on alpha is now non-exec.
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.37 2002/06/28 16:50:38 art Exp $ */
a457 18
			/*
			 * If it was caused by fuswintr or suswintr,
			 * just punt.  Note that we check the faulting
			 * address against the address accessed by
			 * [fs]uswintr, in case another fault happens
			 * when they are running.
			 */
			if (!user &&
			    p != NULL &&
			    p->p_addr->u_pcb.pcb_onfault ==
			      (unsigned long)fswintrberr &&
			    p->p_addr->u_pcb.pcb_accessaddr == a0) {
				framep->tf_regs[FRAME_PC] =
				    p->p_addr->u_pcb.pcb_onfault;
				p->p_addr->u_pcb.pcb_onfault = 0;
				goto out;
			}

@


1.37
log
@The IEEE fp stuff changed the rules for how fpu should be enabled.
We kept too much of the old code in trap handling.

This should fix floppies and bsd.rd on some machines.
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.36 2002/06/23 03:03:15 deraadt Exp $ */
d296 1
a427 3
			pmap_emulate_reference(p, a0, user, 0);
			goto out;

d429 5
a433 1
			pmap_emulate_reference(p, a0, user, 1);
a441 1
			vm_prot_t ftype;
d445 13
a489 14
			}
	
			switch (a2) {
			case -1:		/* instruction fetch fault */
			case 0:			/* load instruction */
				ftype = VM_PROT_READ;
				break;
			case 1:			/* store instruction */
				ftype = VM_PROT_WRITE;
				break;
#ifdef DIAGNOSTIC
			default:		/* XXX gcc -Wuninitialized */
				goto dopanic;
#endif
@


1.36
log
@uid_t is unsigned
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.35 2002/05/16 21:11:10 miod Exp $ */
a412 1
#ifndef NO_IEEE
a414 20
#else
			/*
			 * on exit from the kernel, if proc == fpcurproc,
			 * FP is enabled.
			 */
			if (fpcurproc == p) {
				printf("trap: fp disabled for fpcurproc == %p",
				    p);
				goto dopanic;
			}

			alpha_pal_wrfen(1);
			if (fpcurproc)
				savefpstate(&fpcurproc->p_addr->u_pcb.pcb_fp);
			fpcurproc = p;
			restorefpstate(&fpcurproc->p_addr->u_pcb.pcb_fp);
			alpha_pal_wrfen(0);

			p->p_md.md_flags |= MDP_FPUSED;
#endif
a751 1
#ifndef NO_IEEE
a787 1
#endif
@


1.35
log
@Add systrace support to all the remaining architectures.

Tested by various people on various platforms, I'm willing to fix any
breakage this causes.

ok niels@@ deraadt@@ and mickey@@ (after his comments were applied)
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.34 2002/04/29 00:30:36 pvalchev Exp $ */
d554 1
a554 1
				printf("UVM: pid %d (%s), uid %d killed: "
d1110 1
a1110 1
		"pid %d (%s): unaligned access: va=0x%lx pc=0x%lx ra=0x%lx op=",
@


1.34
log
@wierd -> weird in comment
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.33 2002/04/28 20:55:14 pvalchev Exp $ */
d113 3
d710 6
a715 1
		error = (*callp->sy_call)(p, args + hidden, rval);
@


1.33
log
@IEEE 754 floating point completion code, and implementation of the
FP_C (Floating Point Control Quadword).

From ross@@NetBSD.  Added a way to disable it with option NO_IEEE,
which appears on the ramdisks to save space.  This affects only
programs compiled with -mieee, and what it essentially does is
enabling infinities and NaNs, instead of generating SIGFPE on
division by zero, overflow, etc.
ok art, deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.32 2002/03/16 03:21:28 art Exp $ */
d302 1
a302 1
/* This is to catch some wierd stuff on the UDB (mj) */
@


1.32
log
@PTRACE fallout.
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.31 2002/03/14 01:26:26 millert Exp $ */
d105 3
d120 1
a120 1
#include <alpha/alpha/db_instruction.h>		/* for handle_opdec() */
d141 5
d342 3
a344 4
		/* 
		 * If user-land, just give a SIGFPE.  Should do
		 * software completion and IEEE handling, if the
		 * user has requested that.
d347 3
a349 5
#ifdef COMPAT_OSF1
			extern struct emul emul_osf1;

			/* just punt on OSF/1.  XXX THIS IS EVIL */
			if (p->p_emul == &emul_osf1) 
d351 3
a354 2
			i = SIGFPE;
			ucode =  a0;		/* exception summary */
d410 4
d423 1
a423 1
	
d432 1
d765 39
d857 2
a858 6
	if (p == fpcurproc) {						\
		alpha_pal_wrfen(1);					\
		savefpstate(&fpcurproc->p_addr->u_pcb.pcb_fp);		\
		alpha_pal_wrfen(0);					\
		fpcurproc = NULL;					\
	}
a1004 3

extern int	alpha_unaligned_print, alpha_unaligned_fix;
extern int	alpha_unaligned_sigbus;
@


1.31
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.30 2002/03/12 11:58:14 art Exp $ */
d388 1
d393 1
@


1.30
log
@Emulate ptrace(PT_STEP in software.
More or less directly from FreeBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.29 2001/11/28 16:13:27 art Exp $ */
d123 1
a123 1
void		userret __P((struct proc *, u_int64_t, u_quad_t));
d125 3
a127 3
unsigned long	Sfloat_to_reg __P((unsigned int));
unsigned int	reg_to_Sfloat __P((unsigned long));
unsigned long	Tfloat_reg_cvt __P((unsigned long));
d129 3
a131 3
unsigned long	Ffloat_to_reg __P((unsigned int));
unsigned int	reg_to_Ffloat __P((unsigned long));
unsigned long	Gfloat_reg_cvt __P((unsigned long));
d134 2
a135 2
int		unaligned_fixup __P((unsigned long, unsigned long,
		    unsigned long, struct proc *));
d138 2
a139 2
static void printtrap __P((const unsigned long, const unsigned long,
      const unsigned long, const unsigned long, struct trapframe *, int, int));
@


1.29
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.28 2001/11/28 13:47:37 art Exp $ */
d108 1
d388 4
@


1.29.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.29 2001/11/28 16:13:27 art Exp $ */
a104 3
#ifndef NO_IEEE
#include <sys/device.h>
#endif
a107 4
#include <sys/ptrace.h>

#include "systrace.h"
#include <dev/systrace.h>
d116 1
a116 1
#include <alpha/alpha/db_instruction.h>
d122 1
a122 1
void		userret(struct proc *, u_int64_t, u_quad_t);
d124 3
a126 3
unsigned long	Sfloat_to_reg(unsigned int);
unsigned int	reg_to_Sfloat(unsigned long);
unsigned long	Tfloat_reg_cvt(unsigned long);
d128 3
a130 3
unsigned long	Ffloat_to_reg(unsigned int);
unsigned int	reg_to_Ffloat(unsigned long);
unsigned long	Gfloat_reg_cvt(unsigned long);
d133 2
a134 2
int		unaligned_fixup(unsigned long, unsigned long,
		    unsigned long, struct proc *);
d137 2
a138 7
#ifndef NO_IEEE
struct device fpevent_use;
struct device fpevent_reuse;
#endif

static void printtrap(const unsigned long, const unsigned long,
      const unsigned long, const unsigned long, struct trapframe *, int, int);
d293 1
a293 1
/* This is to catch some weird stuff on the UDB (mj) */
d333 4
a336 3
		/*
		 * Resolve trap shadows, interpret FP ops requiring infinities,
		 * NaNs, or denorms, and maintain FPCR corrections.
d339 5
a343 3
#ifndef NO_IEEE
			i = alpha_fp_complete(a0, a1, p, &ucode);
			if (i == 0)
d345 1
a345 1
#else
d347 1
a347 2
			ucode = a0;
#endif
a386 6
#ifdef PTRACE
			if (p->p_md.md_flags & (MDP_STEP1|MDP_STEP2)) {
				process_sstep(p, 0);
				p->p_md.md_tf->tf_regs[FRAME_PC] -= 4;
			}
#endif
a396 4
#ifndef NO_IEEE
			alpha_enable_fp(p, 0);
			alpha_pal_wrfen(0);
#else
d406 1
a406 1

a414 1
#endif
d689 1
a689 6
#if NSYSTRACE > 0
		if (ISSET(p->p_flag, P_SYSTRACE))
			error = systrace_redirect(code, p, args + hidden, rval);
		else
#endif
			error = (*callp->sy_call)(p, args + hidden, rval);
a746 39
#ifndef NO_IEEE
/*
 * Set the float-point enable for the current process, and return
 * the FPU context to the named process. If check == 0, it is an
 * error for the named process to already be fpcurproc.
 */
void
alpha_enable_fp(struct proc *p, int check)
{
	struct cpu_info *ci = curcpu();

	if (check && ci->ci_fpcurproc == p) {
		alpha_pal_wrfen(1);
		return;
	}
	if (ci->ci_fpcurproc == p)
		panic("trap: fp disabled for fpcurproc == %p", p);

	if (ci->ci_fpcurproc != NULL)
		fpusave_cpu(ci, 1);

	KDASSERT(ci->ci_fpcurproc == NULL);

#if defined(MULTIPROCESSOR)
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 1);
#else
	KDASSERT(p->p_addr->u_pcb.pcb_fpcpu == NULL);
#endif

	p->p_addr->u_pcb.pcb_fpcpu = ci;
	ci->ci_fpcurproc = p;

	p->p_md.md_flags |= MDP_FPUSED;
	alpha_pal_wrfen(1);
	restorefpstate(&p->p_addr->u_pcb.pcb_fp);
}
#endif

d800 6
a805 2
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)				\
		fpusave_proc(p, 1);
d952 3
@


1.29.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.29.2.1 2002/06/11 03:33:39 art Exp $ */
a295 1
	vm_prot_t ftype;
d413 1
d416 20
d448 3
d452 1
a452 5
			if (pmap_emulate_reference(p, a0, user, a1)) {
				/* XXX - stupid API right now. */
				ftype = VM_PROT_EXECUTE|VM_PROT_READ;
				goto do_fault;
			}
d461 1
a464 13
			switch (a2) {
			case -1:		/* instruction fetch fault */
				ftype = VM_PROT_EXECUTE|VM_PROT_READ;
				break;
			case 0:			/* load instruction */
				ftype = VM_PROT_READ;
				break;
			case 1:			/* store instruction */
				ftype = VM_PROT_READ|VM_PROT_WRITE;
				break;
			}
	
do_fault:
d499 14
d554 1
a554 1
				printf("UVM: pid %u (%s), uid %u killed: "
d773 1
d810 1
d1110 1
a1110 1
		"pid %u (%s): unaligned access: va=0x%lx pc=0x%lx ra=0x%lx op=",
@


1.29.2.3
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d251 1
a251 1
		snprintf(ubuf, sizeof ubuf, "type %lx", entry);
d458 18
@


1.28
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.27 2001/11/06 19:53:13 miod Exp $ */
d437 3
a439 3
			register vaddr_t va;
			register struct vmspace *vm = NULL;
			register vm_map_t map;
d442 1
a442 1
			extern vm_map_t kernel_map;
@


1.27
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.26 2001/07/09 18:55:21 millert Exp $ */
d504 1
a504 1
				if (rv == KERN_SUCCESS) {
d511 2
a512 2
				} else if (rv == KERN_PROTECTION_FAILURE)
					rv = KERN_INVALID_ADDRESS;
d514 1
a514 1
			if (rv == KERN_SUCCESS) {
d532 1
a532 1
			if (rv == KERN_RESOURCE_SHORTAGE) {
@


1.26
log
@Make quad types on alpha be "long long" not "long".  This means that
printf's "%lld" can be used with a quad_t or int64_t without a bogus cast.
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.25 2001/01/20 20:27:40 art Exp $ */
a108 1
#include <vm/vm.h>
@


1.25
log
@No need to include machine/alpha.h here.
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.24 2000/11/16 18:38:34 ericj Exp $ */
d605 2
a606 2
	u_int64_t rval[2];
	u_int64_t args[10];					/* XXX */
d664 1
a664 1
		    (nargs - 6) * sizeof(u_int64_t));
@


1.24
log
@revert previous commit which didnt compile
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.23 2000/11/15 07:50:42 nate Exp $ */
a113 1
#include <machine/alpha.h>
@


1.23
log
@Point to the right variable for ktrace
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.22 2000/11/10 18:15:33 art Exp $ */
d683 1
a683 1
		ktrsyscall(p->p_tracep, code, callp->sy_argsize, args + hidden);
d725 1
a725 1
		ktrsysret(p->p_tracep, code, error, rval[0]);
d745 1
a745 1
		ktrsysret(p->p_tracep, SYS_fork, 0, 0);
@


1.22
log
@Change the ktrace interface functions from taking the trace vnode to taking the
traced proc. The vnode is in the proc and all functions need the proc.
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.21 2000/11/08 19:16:59 ericj Exp $ */
d683 1
a683 1
		ktrsyscall(p, code, callp->sy_argsize, args + hidden);
d725 1
a725 1
		ktrsysret(p, code, error, rval[0]);
d745 1
a745 1
		ktrsysret(p, SYS_fork, 0, 0);
@


1.21
log
@add tags
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d683 1
a683 1
		ktrsyscall(p->p_tracep, code, callp->sy_argsize, args + hidden);
d725 1
a725 1
		ktrsysret(p->p_tracep, code, error, rval[0]);
d745 1
a745 1
		ktrsysret(p->p_tracep, SYS_fork, 0, 0);
@


1.20
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
@


1.19
log
@Add explicit inclusions of signalvar.h to files actually using syms defined
there but relying on an indirect inclusion
@
text
@d1 68
a68 2
/*	$OpenBSD: trap.c,v 1.19 2000/06/08 21:11:53 niklas Exp $	*/
/*	$NetBSD: trap.c,v 1.19 1996/11/27 01:28:30 cgd Exp $	*/
d108 3
d113 1
a113 1

d117 1
a122 13
static __inline void userret __P((struct proc *, u_int64_t, u_quad_t));
void trap __P((const u_long, const u_long, const u_long, const u_long,
     struct trapframe *));
int unaligned_fixup __P((u_long, u_long, u_long, struct proc *));
void syscall __P((u_int64_t, struct trapframe *));
void child_return __P((struct proc *));
void ast __P((struct trapframe *));
u_long Sfloat_to_reg __P((u_int));
u_int reg_to_Sfloat __P((u_long));
u_long Tfloat_reg_cvt __P((u_long));

struct proc *fpcurproc;		/* current user of the FPU */

d136 29
d176 5
a180 1
	int sig, s;
d186 1
a186 1
	if (want_resched) {
d188 1
a188 6
		 * Since we are curproc, a clock interrupt could
		 * change our priority without changing run queues
		 * (the running process is not kept on a run queue).
		 * If this happened after we setrunqueue ourselves but
		 * before we switch()'ed, we might not be on the queue
		 * indicated by our priority.
d190 5
a194 5
		s = splstatclock();
		setrunqueue(p);
		p->p_stats->p_ru.ru_nivcsw++;
		mi_switch();
		splx(s);
d211 50
a260 9
char	*trap_type[] = {
	"interrupt",			/*  0 ALPHA_KENTRY_INT */
	"arithmetic trap",		/*  1 ALPHA_KENTRY_ARITH */
	"memory management fault",	/*  2 ALPHA_KENTRY_MM */
	"instruction fault",		/*  3 ALPHA_KENTRY_IF */
	"unaligned access fault",	/*  4 ALPHA_KENTRY_UNA */
	"system call",			/*  5 ALPHA_KENTRY_SYS */
};
int	trap_types = sizeof trap_type / sizeof trap_type[0];
d276 1
a276 1
	u_long ucode;
d278 4
a282 1
	int user;
d286 1
a286 1
	cnt.v_trap++;
a287 1
	v = 0;
a289 3
#ifdef DDB
	framep->tf_regs[FRAME_SP] = (long)framep + FRAME_SIZE*8;
#endif
d293 8
d302 1
a302 3
#ifdef DIAGNOSTIC
		sticks = 0xdeadbeef;		/* XXX for -Wuninitialized */
#endif
d316 1
a316 6
			ucode = VM_PROT_NONE;	/* XXX determine */
			v = (caddr_t)a0;
			if (i == SIGBUS)
				typ = BUS_ADRALN;
			else
				typ = SEGV_MAPERR;
d331 1
a331 1
		goto we_re_toast;
d340 9
a348 4
sigfpe:			i = SIGFPE;
			v = NULL;		/* XXX determine */
			ucode = a0;		/* exception summary */
			typ = FPE_FLTINV;	/* XXX? */
d353 1
a353 1
		goto we_re_toast;
d358 1
a358 1
		 * happen, unless they're breakpoints of course.
d360 8
a367 2
		if (!user)
			goto we_re_toast;
d369 9
d380 6
a385 2
			if (framep->tf_regs[FRAME_A0] == -2) /* weird! */
				goto sigfpe;
d388 1
a388 3
			/* XXX what is the address?  Guess on a1 for now */
			v = (caddr_t)a1;
			ucode = 0;		/* XXX determine */
a389 1
			typ = TRAP_BRKPT;
d393 2
a394 14
			/* XXX what is the address?  Guess on a1 for now */
			v = (caddr_t)a1;
			ucode = 0;		/* XXX determine */
#ifdef NEW_PMAP
{
int instr;
printf("REAL SIGILL: PC = 0x%lx, RA = 0x%lx\n", framep->tf_regs[FRAME_PC], framep->tf_regs[FRAME_RA]);
printf("INSTRUCTION (%d) = 0x%lx\n", copyin((void*)framep->tf_regs[FRAME_PC] - 4, &instr, 4), instr);
regdump(framep);
panic("foo");
}
#endif
			i = SIGILL;
			typ = ILL_ILLOPC;
d405 1
a405 1
				goto we_re_toast;
d420 1
a420 1
			goto we_re_toast;
a424 3
#ifdef NEW_PMAP
		printf("mmfault: 0x%lx, 0x%lx, %d\n", a0, a1, a2);
#endif
a427 3
#ifdef NEW_PMAP
			printf("mmfault for/foe in\n");
#endif
a428 3
#ifdef NEW_PMAP
			printf("mmfault for/foe out\n");
#endif
a431 3
#ifdef NEW_PMAP
			printf("mmfault fow in\n");
#endif
a432 3
#ifdef NEW_PMAP
			printf("mmfault fow out\n");
#endif
d438 2
a439 2
			register vm_offset_t va;
			register struct vmspace *vm;
a444 3
#ifdef NEW_PMAP
			printf("mmfault invaltrans/access in\n");
#endif
a456 3
#ifdef NEW_PMAP
				printf("mmfault nfintr in\n");
#endif
a459 3
#ifdef NEW_PMAP
				printf("mmfault nfintr out\n");
#endif
d489 1
a489 1
				goto we_re_toast;
d493 2
a494 8
			va = trunc_page((vm_offset_t)a0);
#ifdef NEW_PMAP
			printf("mmfault going to vm_fault\n");
#endif
			rv = vm_fault(map, va, ftype, FALSE);
#ifdef NEW_PMAP
			printf("mmfault back from vm_fault\n");
#endif
d503 2
a504 1
			    (caddr_t)va >= vm->vm_maxsaddr) {
d508 2
a509 2
					nss = clrnd(btoc(USRSTACK -
					    (unsigned long)va));
a515 3
#ifdef NEW_PMAP
				printf("mmfault vm_fault success\n");
#endif
a519 3
#ifdef NEW_PMAP
				printf("mmfault check copyfault\n");
#endif
d528 1
a528 1
				goto we_re_toast;
d530 1
a531 2
			ucode = ftype;
			i = SIGSEGV;
d533 9
d547 1
a547 1
			goto we_re_toast;
a551 5
	we_re_toast:
#ifdef DDB
		if (kdb_trap(entry, a0, framep))
			return;
#endif
d555 3
d566 1
a566 2
	{
		const char *entryname = "???";
d568 1
a568 2
		if (entry > 0 && entry < trap_types)
			entryname = trap_type[entry];
d570 6
a575 14
		printf("\n");
		printf("fatal %s trap:\n", user ? "user" : "kernel");
		printf("\n");
		printf("    trap entry = 0x%lx (%s)\n", entry, entryname);
		printf("    a0         = 0x%lx\n", a0);
		printf("    a1         = 0x%lx\n", a1);
		printf("    a2         = 0x%lx\n", a2);
		printf("    pc         = 0x%lx\n", framep->tf_regs[FRAME_PC]);
		printf("    ra         = 0x%lx\n", framep->tf_regs[FRAME_RA]);
		printf("    curproc    = %p\n", curproc);
		if (curproc != NULL)
			printf("        pid = %d, comm = %s\n", curproc->p_pid,
			    curproc->p_comm);
		printf("\n");
d577 1
a577 3

	/* XXX dump registers */
	/* XXX kernel debugger */
d613 1
a613 1
	if ((framep->tf_regs[FRAME_PS] & ALPHA_PSL_USERMODE) == 0) {
d616 1
a616 1
	cnt.v_syscall++;
a685 3
#ifdef NEW_PMAP
	printf("called from 0x%lx, ra 0x%lx\n", framep->tf_regs[FRAME_PC], framep->tf_regs[FRAME_RA]);
#endif
d705 2
a718 3
#ifdef NEW_PMAP
	printf("outgoing pc 0x%lx, ra 0x%lx\n", framep->tf_regs[FRAME_PC], framep->tf_regs[FRAME_RA]);
#endif
d732 2
a733 2
child_return(p)
	struct proc *p;
d735 1
d759 2
d768 1
a768 1
	cnt.v_soft++;
a769 1
	astpending = 0;
d809 1
a809 4
	if (copyin((caddr_t)va, &(storage), sizeof (storage)) == 0 &&	\
	    (regptr = ptrf(p, reg)) != NULL)				\
		signal = 0;						\
	else								\
d811 3
a813 1
	*regptr = mod (storage);
d816 5
a820 1
	if ((regptr = ptrf(p, reg)) == NULL)				\
d822 1
a822 5
	(storage) = mod (*regptr);					\
	if (copyout(&(storage), (caddr_t)va, sizeof (storage)) == 0)	\
		signal = 0;						\
	else								\
		break;
d957 13
d975 7
a981 9
	int doprint, dofix, dosigbus;
	int signal, size;
	const char *type;
	unsigned long *regptr, longdata;
	int intdata;		/* signed to get extension when storing */
	struct {
		const char *type;	/* opcode name */
		int size;		/* size, 0 if fixup not supported */
	} tab[0x10] = {
d983 1
a983 1
		{ "ldf",	4 },	{ "ldg",	8 },
d985 1
a985 1
		{ "ldf",	0 },	{ "ldg",	0 },
d987 1
a987 1
		{ "lds",	4 },	{ "ldt",	8 },
d989 1
a989 1
		{ "stf",	4 },	{ "stg",	8 },
d991 1
a991 1
		{ "stf",	0 },	{ "stg",	0 },
d993 5
a997 5
		{ "sts",	4 },	{ "stt",	8 },
		{ "ldl",	4 },	{ "ldq",	8 },
		{ "ldl_l",	0 },	{ "ldq_l",	0 },	/* can't fix */
		{ "stl",	4 },	{ "stq",	8 },
		{ "stl_c",	0 },	{ "stq_c",	0 },	/* can't fix */
d999 12
a1010 1
	int typ;
d1026 6
a1031 7
	if (opcode >= 0x20 && opcode <= 0x2f) {
		type = tab[opcode - 0x20].type;
		size = tab[opcode - 0x20].size;
	} else {
		type = "0x%lx";
		size = 0;
	}
d1035 5
a1039 2
	 * Even if it's an unknown opcode, SEGV if the access
	 * should have failed.
d1041 3
a1043 1
	if (!useracc((caddr_t)va, size ? size : 1, B_WRITE)) {
d1052 6
a1057 4
		uprintf("pid %d (%s): unaligned access: va=0x%lx pc=0x%lx ra=0x%lx op=",
		    p->p_pid, p->p_comm, va, p->p_md.md_tf->tf_regs[FRAME_PC],
		    p->p_md.md_tf->tf_regs[FRAME_PC]);
		uprintf(type, opcode);
d1074 1
a1074 2
	typ = BUS_ADRALN;
	if (dofix && size != 0) {
d1076 10
d1152 5
d1158 162
@


1.18
log
@GCC 2.8 type safety
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17 1997/11/17 01:26:38 deraadt Exp $	*/
d34 1
@


1.18.10.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 69
/* $OpenBSD: trap.c,v 1.25 2001/01/20 20:27:40 art Exp $ */
/* $NetBSD: trap.c,v 1.52 2000/05/24 16:48:33 thorpej Exp $ */

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1999 Christopher G. Demetriou.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
a33 1
#include <sys/signalvar.h>
a40 3
#include <vm/vm.h>
#include <uvm/uvm_extern.h>

d43 1
a46 1
#include <alpha/alpha/db_instruction.h>		/* for handle_opdec() */
d52 13
a77 29
int		handle_opdec(struct proc *p, u_int64_t *ucodep);

static void printtrap __P((const unsigned long, const unsigned long,
      const unsigned long, const unsigned long, struct trapframe *, int, int));

/*
 * Initialize the trap vectors for the current processor.
 */
void
trap_init()
{

	/*
	 * Point interrupt/exception vectors to our own.
	 */
	alpha_pal_wrent(XentInt, ALPHA_KENTRY_INT); 
	alpha_pal_wrent(XentArith, ALPHA_KENTRY_ARITH);
	alpha_pal_wrent(XentMM, ALPHA_KENTRY_MM);
	alpha_pal_wrent(XentIF, ALPHA_KENTRY_IF);
	alpha_pal_wrent(XentUna, ALPHA_KENTRY_UNA); 
	alpha_pal_wrent(XentSys, ALPHA_KENTRY_SYS);

	/*
	 * Clear pending machine checks and error reports, and enable
	 * system- and processor-correctable error reporting.
	 */
	alpha_pal_wrmces(alpha_pal_rdmces() & 
	    ~(ALPHA_MCES_DSC|ALPHA_MCES_DPC));
}
d89 1
a89 5
	int sig;
	struct cpu_info *ci = curcpu();

	/* Do any deferred user pmap operations. */
	PMAP_USERRET(vm_map_pmap(&p->p_vmspace->vm_map));
d95 1
a95 1
	if (ci->ci_want_resched) {
d97 6
a102 1
		 * We are being preempted.
d104 5
a108 5
		preempt(NULL);

		ci = curcpu();

		PMAP_USERRET(vm_map_pmap(&p->p_vmspace->vm_map));
d125 9
a133 50
static void
printtrap(a0, a1, a2, entry, framep, isfatal, user)
	const unsigned long a0, a1, a2, entry;
	struct trapframe *framep;
	int isfatal, user;
{
	char ubuf[64];
	const char *entryname;

	switch (entry) {
	case ALPHA_KENTRY_INT:
		entryname = "interrupt";
		break;
	case ALPHA_KENTRY_ARITH:
		entryname = "arithmetic trap";
		break;
	case ALPHA_KENTRY_MM:
		entryname = "memory management fault";
		break;
	case ALPHA_KENTRY_IF:
		entryname = "instruction fault";
		break;
	case ALPHA_KENTRY_UNA:
		entryname = "unaligned access fault";
		break;
	case ALPHA_KENTRY_SYS:
		entryname = "system call";
		break;
	default:
		sprintf(ubuf, "type %lx", entry);
		entryname = (const char *) ubuf;
		break;
	}

	printf("\n");
	printf("%s %s trap:\n", isfatal? "fatal" : "handled",
	       user ? "user" : "kernel");
	printf("\n");
	printf("    trap entry = 0x%lx (%s)\n", entry, entryname);
	printf("    a0         = 0x%lx\n", a0);
	printf("    a1         = 0x%lx\n", a1);
	printf("    a2         = 0x%lx\n", a2);
	printf("    pc         = 0x%lx\n", framep->tf_regs[FRAME_PC]);
	printf("    ra         = 0x%lx\n", framep->tf_regs[FRAME_RA]);
	printf("    curproc    = %p\n", curproc);
	if (curproc != NULL)
		printf("        pid = %d, comm = %s\n", curproc->p_pid,
		       curproc->p_comm);
	printf("\n");
}
d149 1
a149 1
	u_int64_t ucode;
d151 1
a152 4
#if defined(DDB)
	int call_debugger = 1;
#endif
	caddr_t v;
d156 1
a156 1
	uvmexp.traps++;
d158 1
d161 3
d167 3
a169 7
#if	0
/* This is to catch some wierd stuff on the UDB (mj) */
		if (framep->tf_regs[FRAME_PC] > 0 && 
		    framep->tf_regs[FRAME_PC] < 0x120000000) {
			printf("PC Out of Whack\n");
			printtrap(a0, a1, a2, entry, framep, 1, user);
		}
a170 2
	} else {
		sticks = 0;		/* XXX bogus -Wuninitialized warning */
d184 6
a189 1
			ucode = a0;		/* VA */
d204 1
a204 1
		goto dopanic;
d213 4
a216 9
#ifdef COMPAT_OSF1
			extern struct emul emul_osf1;

			/* just punt on OSF/1.  XXX THIS IS EVIL */
			if (p->p_emul == &emul_osf1) 
				goto out;
#endif
			i = SIGFPE;
			ucode =  a0;		/* exception summary */
d221 1
a221 1
		goto dopanic;
d226 1
a226 1
		 * happen.  (Debugger entry is handled in XentIF.)
d228 2
a229 8
		if (!user) {
#if defined(DDB)
			/*
			 * ...unless a debugger is configured.  It will
			 * inform us if the trap was handled.
			 */
			if (alpha_debug(a0, a1, a2, entry, framep))
				goto out;
a230 9
			/*
			 * Debugger did NOT handle the trap, don't
			 * call the debugger again!
			 */
			call_debugger = 0;
#endif
			goto dopanic;
		}
		i = 0;
d233 2
a234 6
			if (framep->tf_regs[FRAME_A0] == -2) { /* weird! */
				i = SIGFPE;
				ucode =  a0;	/* exception summary */
				break;
			}
			/* FALLTHROUTH */
d237 3
a239 1
			ucode = a0;		/* trap type */
d241 1
d245 14
a258 2
			if ((i = handle_opdec(p, &ucode)) == 0)
				goto out;
d269 1
a269 1
				goto dopanic;
d284 1
a284 1
			goto dopanic;
d289 3
d295 3
d299 3
d305 3
d309 3
d317 2
a318 2
			register vaddr_t va;
			register struct vmspace *vm = NULL;
d324 3
d339 3
d345 3
d377 1
a377 1
				goto dopanic;
d381 8
a388 2
			va = trunc_page((vaddr_t)a0);
			rv = uvm_fault(map, va, 0, ftype);
d397 1
a397 2
			    (caddr_t)va >= vm->vm_maxsaddr &&
			    va < USRSTACK) {
d401 2
a402 2
					nss = btoc(USRSTACK -
					    (unsigned long)va);
d409 3
d416 3
d427 1
a427 1
				goto dopanic;
d429 1
d431 1
a431 1
			v = (caddr_t)a0;
a432 9
			if (rv == KERN_RESOURCE_SHORTAGE) {
				printf("UVM: pid %d (%s), uid %d killed: "
				       "out of swap\n", p->p_pid, p->p_comm,
				       p->p_cred && p->p_ucred ?
				       p->p_ucred->cr_uid : -1);
				i = SIGKILL;
			} else {
				i = SIGSEGV;
			}
d438 1
a438 1
			goto dopanic;
d443 5
a450 3
#ifdef DEBUG
	printtrap(a0, a1, a2, entry, framep, 1, user);
#endif
d459 2
a460 1
	printtrap(a0, a1, a2, entry, framep, 1, user);
d462 2
a463 1
	/* XXX dump registers */
d465 14
a478 6
#if defined(DDB)
	if (call_debugger && alpha_debug(a0, a1, a2, entry, framep)) {
		/*
		 * The debugger has handled the trap; just return.
		 */
		goto out;
d480 3
a482 1
#endif
d518 1
a518 1
	if ((framep->tf_regs[FRAME_PS] & ALPHA_PSL_USERMODE) == 0)
d521 1
a521 1
	uvmexp.syscalls++;
d587 1
a587 1
		ktrsyscall(p, code, callp->sy_argsize, args + hidden);
d591 3
a612 2
		if (p->p_emul->e_errno)
			error = p->p_emul->e_errno[error];
d625 3
d633 1
a633 1
		ktrsysret(p, code, error, rval[0]);
d641 2
a642 2
child_return(arg)
	void *arg;
a643 1
	struct proc *p = arg;
d652 1
a652 1
		ktrsysret(p, SYS_fork, 0, 0);
a666 2
	curcpu()->ci_astpending = 0;

d674 1
a674 1
	uvmexp.softs++;
d676 1
d716 4
a719 1
	if (copyin((caddr_t)va, &(storage), sizeof (storage)) != 0)	\
d721 1
a721 3
	signal = 0;							\
	if ((regptr = ptrf(p, reg)) != NULL)				\
		*regptr = mod (storage);
d724 5
a728 2
	if ((regptr = ptrf(p, reg)) != NULL)				\
		(storage) = mod (*regptr);				\
d730 1
a730 4
		(storage) = 0;						\
	if (copyout(&(storage), (caddr_t)va, sizeof (storage)) != 0)	\
		break;							\
	signal = 0;
a864 13
struct unaligned_fixup_data {
	const char *type;	/* opcode name */
	int fixable;		/* fixable, 0 if fixup not supported */
	int size;		/* size, 0 if unknown */
	int acc;		/* useracc type; B_READ or B_WRITE */
};

#define	UNKNOWN()	{ "0x%lx", 0, 0, 0 }
#define	FIX_LD(n,s)	{ n, 1, s, B_READ }
#define	FIX_ST(n,s)	{ n, 1, s, B_WRITE }
#define	NOFIX_LD(n,s)	{ n, 0, s, B_READ }
#define	NOFIX_ST(n,s)	{ n, 0, s, B_WRITE }

d870 9
a878 7
	const struct unaligned_fixup_data tab_unknown[1] = {
		UNKNOWN(),
	};
	const struct unaligned_fixup_data tab_0c[0x02] = {
		FIX_LD("ldwu", 2),	FIX_ST("stw", 2),
	};
	const struct unaligned_fixup_data tab_20[0x10] = {
d880 1
a880 1
		FIX_LD("ldf", 4),	FIX_LD("ldg", 8),
d882 1
a882 1
		NOFIX_LD("ldf", 4),	NOFIX_LD("ldg", 8),
d884 1
a884 1
		FIX_LD("lds", 4),	FIX_LD("ldt", 8),
d886 1
a886 1
		FIX_ST("stf", 4),	FIX_ST("stg", 8),
d888 1
a888 1
		NOFIX_ST("stf", 4),	NOFIX_ST("stg", 8),
d890 5
a894 5
		FIX_ST("sts", 4),	FIX_ST("stt", 8),
		FIX_LD("ldl", 4),	FIX_LD("ldq", 8),
		NOFIX_LD("ldl_c", 4),	NOFIX_LD("ldq_c", 8),
		FIX_ST("stl", 4),	FIX_ST("stq", 8),
		NOFIX_ST("stl_c", 4),	NOFIX_ST("stq_c", 8),
d896 1
a896 12
	const struct unaligned_fixup_data *selected_tab;
	int doprint, dofix, dosigbus, signal;
	unsigned long *regptr, longdata;
	int intdata;		/* signed to get extension when storing */
	u_int16_t worddata;	/* unsigned to _avoid_ extension */

	/*
	 * Read USP into frame in case it's the register to be modified.
	 * This keeps us from having to check for it in lots of places
	 * later.
	 */
	p->p_md.md_tf->tf_regs[FRAME_SP] = alpha_pal_rdusp();
d912 7
a918 6
	if (opcode >= 0x0c && opcode <= 0x0d)
		selected_tab = &tab_0c[opcode - 0x0c];
	else if (opcode >= 0x20 && opcode <= 0x2f)
		selected_tab = &tab_20[opcode - 0x20];
	else
		selected_tab = tab_unknown;
d922 2
a923 5
	 * If it's an unknown opcode, we don't know whether to
	 * read or write, so we don't check.
	 *
	 * We adjust the PC backwards so that the instruction will
	 * be re-run.
d925 1
a925 3
	if (selected_tab->size != 0 &&
	   !uvm_useracc((caddr_t)va, selected_tab->size, selected_tab->acc)) {
		p->p_md.md_tf->tf_regs[FRAME_PC] -= 4;
d934 4
a937 6
		uprintf(
		"pid %d (%s): unaligned access: va=0x%lx pc=0x%lx ra=0x%lx op=",
		    p->p_pid, p->p_comm, va,
		    p->p_md.md_tf->tf_regs[FRAME_PC] - 4,
		    p->p_md.md_tf->tf_regs[FRAME_RA]);
		uprintf(selected_tab->type,opcode);
d954 2
a955 1
	if (dofix && selected_tab->fixable) {
a956 10
		case 0x0c:			/* ldwu */
			/* XXX ONLY WORKS ON LITTLE-ENDIAN ALPHA */
			unaligned_load_integer(worddata);
			break;

		case 0x0d:			/* stw */
			/* XXX ONLY WORKS ON LITTLE-ENDIAN ALPHA */
			unaligned_store_integer(worddata);
			break;

a1022 5
	/*
	 * Write back USP.
	 */
	alpha_pal_wrusp(p->p_md.md_tf->tf_regs[FRAME_SP]);

a1023 162
}

/*
 * Reserved/unimplemented instruction (opDec fault) handler
 *
 * Argument is the process that caused it.  No useful information
 * is passed to the trap handler other than the fault type.  The
 * address of the instruction that caused the fault is 4 less than
 * the PC stored in the trap frame.
 *
 * If the instruction is emulated successfully, this function returns 0.
 * Otherwise, this function returns the signal to deliver to the process,
 * and fills in *ucodep with the code to be delivered.
 */
int
handle_opdec(p, ucodep)
	struct proc *p;
	u_int64_t *ucodep;
{
	alpha_instruction inst;
	register_t *regptr, memaddr;
	u_int64_t inst_pc;
	int sig;

	/*
	 * Read USP into frame in case it's going to be used or modified.
	 * This keeps us from having to check for it in lots of places
	 * later.
	 */
	p->p_md.md_tf->tf_regs[FRAME_SP] = alpha_pal_rdusp();

	inst_pc = memaddr = p->p_md.md_tf->tf_regs[FRAME_PC] - 4;
	if (copyin((caddr_t)inst_pc, &inst, sizeof (inst)) != 0) {
		/*
		 * really, this should never happen, but in case it
		 * does we handle it.
		 */
		printf("WARNING: handle_opdec() couldn't fetch instruction\n");
		goto sigsegv;
	}

	switch (inst.generic_format.opcode) {
	case op_ldbu:
	case op_ldwu:
	case op_stw:
	case op_stb:
		regptr = irp(p, inst.mem_format.rb);
		if (regptr != NULL)
			memaddr = *regptr;
		else
			memaddr = 0;
		memaddr += inst.mem_format.displacement;

		regptr = irp(p, inst.mem_format.ra);

		if (inst.mem_format.opcode == op_ldwu ||
		    inst.mem_format.opcode == op_stw) {
			if (memaddr & 0x01) {
				sig = unaligned_fixup(memaddr,
				    inst.mem_format.opcode,
				    inst.mem_format.ra, p);
				if (sig)
					goto unaligned_fixup_sig;
				break;
			}
		}

		if (inst.mem_format.opcode == op_ldbu) {
			u_int8_t b;

			/* XXX ONLY WORKS ON LITTLE-ENDIAN ALPHA */
			if (copyin((caddr_t)memaddr, &b, sizeof (b)) != 0)
				goto sigsegv;
			if (regptr != NULL)
				*regptr = b;
		} else if (inst.mem_format.opcode == op_ldwu) {
			u_int16_t w;

			/* XXX ONLY WORKS ON LITTLE-ENDIAN ALPHA */
			if (copyin((caddr_t)memaddr, &w, sizeof (w)) != 0)
				goto sigsegv;
			if (regptr != NULL)
				*regptr = w;
		} else if (inst.mem_format.opcode == op_stw) {
			u_int16_t w;

			/* XXX ONLY WORKS ON LITTLE-ENDIAN ALPHA */
			w = (regptr != NULL) ? *regptr : 0;
			if (copyout(&w, (caddr_t)memaddr, sizeof (w)) != 0)
				goto sigsegv;
		} else if (inst.mem_format.opcode == op_stb) {
			u_int8_t b;

			/* XXX ONLY WORKS ON LITTLE-ENDIAN ALPHA */
			b = (regptr != NULL) ? *regptr : 0;
			if (copyout(&b, (caddr_t)memaddr, sizeof (b)) != 0)
				goto sigsegv;
		}
		break;

	case op_intmisc:
		if (inst.operate_generic_format.function == op_sextb &&
		    inst.operate_generic_format.ra == 31) {
			int8_t b;

			if (inst.operate_generic_format.is_lit) {
				b = inst.operate_lit_format.literal;
			} else {
				if (inst.operate_reg_format.sbz != 0)
					goto sigill;
				regptr = irp(p, inst.operate_reg_format.rb);
				b = (regptr != NULL) ? *regptr : 0;
			}

			regptr = irp(p, inst.operate_generic_format.rc);
			if (regptr != NULL)
				*regptr = b;
			break;
		}
		if (inst.operate_generic_format.function == op_sextw &&
		    inst.operate_generic_format.ra == 31) {
			int16_t w;

			if (inst.operate_generic_format.is_lit) {
				w = inst.operate_lit_format.literal;
			} else {
				if (inst.operate_reg_format.sbz != 0)
					goto sigill;
				regptr = irp(p, inst.operate_reg_format.rb);
				w = (regptr != NULL) ? *regptr : 0;
			}

			regptr = irp(p, inst.operate_generic_format.rc);
			if (regptr != NULL)
				*regptr = w;
			break;
		}
		goto sigill;

	default:
		goto sigill;
	}

	/*
	 * Write back USP.  Note that in the error cases below,
	 * nothing will have been successfully modified so we don't
	 * have to write it out.
	 */
	alpha_pal_wrusp(p->p_md.md_tf->tf_regs[FRAME_SP]);

	return (0);

sigill:
	*ucodep = ALPHA_IF_CODE_OPDEC;			/* trap type */
	return (SIGILL);

sigsegv:
	sig = SIGSEGV;
	p->p_md.md_tf->tf_regs[FRAME_PC] = inst_pc;	/* re-run instr. */
unaligned_fixup_sig:
	*ucodep = memaddr;				/* faulting address */
	return (sig);
@


1.18.10.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.18.10.1 2001/04/18 16:00:32 niklas Exp $ */
d605 2
a606 2
	u_long rval[2];
	u_long args[10];					/* XXX */
d664 1
a664 1
		    (nargs - 6) * sizeof(u_long));
@


1.18.10.3
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d109 1
@


1.18.10.4
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.18.10.3 2001/11/13 21:00:49 niklas Exp $ */
d437 3
a439 3
			vaddr_t va;
			struct vmspace *vm = NULL;
			struct vm_map *map;
d442 1
a442 1
			extern struct vm_map *kernel_map;
d504 1
a504 1
				if (rv == 0) {
d511 2
a512 2
				} else if (rv == EACCES)
					rv = EFAULT;
d514 1
a514 1
			if (rv == 0) {
d532 1
a532 1
			if (rv == ENOMEM) {
@


1.18.10.5
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a107 1
#include <sys/ptrace.h>
d122 1
a122 1
void		userret(struct proc *, u_int64_t, u_quad_t);
d124 3
a126 3
unsigned long	Sfloat_to_reg(unsigned int);
unsigned int	reg_to_Sfloat(unsigned long);
unsigned long	Tfloat_reg_cvt(unsigned long);
d128 3
a130 3
unsigned long	Ffloat_to_reg(unsigned int);
unsigned int	reg_to_Ffloat(unsigned long);
unsigned long	Gfloat_reg_cvt(unsigned long);
d133 2
a134 2
int		unaligned_fixup(unsigned long, unsigned long,
		    unsigned long, struct proc *);
d137 2
a138 2
static void printtrap(const unsigned long, const unsigned long,
      const unsigned long, const unsigned long, struct trapframe *, int, int);
a386 6
#ifdef PTRACE
			if (p->p_md.md_flags & (MDP_STEP1|MDP_STEP2)) {
				process_sstep(p, 0);
				p->p_md.md_tf->tf_regs[FRAME_PC] -= 4;
			}
#endif
@


1.18.10.6
log
@Sync the SMP branch with 3.3
@
text
@a104 3
#ifndef NO_IEEE
#include <sys/device.h>
#endif
a109 3
#include "systrace.h"
#include <dev/systrace.h>

d117 1
a117 1
#include <alpha/alpha/db_instruction.h>
a137 5
#ifndef NO_IEEE
struct device fpevent_use;
struct device fpevent_reuse;
#endif

a284 1
	vm_prot_t ftype;
d294 1
a294 1
/* This is to catch some weird stuff on the UDB (mj) */
d334 4
a337 3
		/*
		 * Resolve trap shadows, interpret FP ops requiring infinities,
		 * NaNs, or denorms, and maintain FPCR corrections.
d340 5
a344 3
#ifndef NO_IEEE
			i = alpha_fp_complete(a0, a1, p, &ucode);
			if (i == 0)
d346 1
a346 1
#else
d348 1
a348 2
			ucode = a0;
#endif
d404 15
a418 1
			alpha_enable_fp(p, 0);
d420 2
d434 3
d438 1
a438 5
			if (pmap_emulate_reference(p, a0, user, a1)) {
				/* XXX - stupid API right now. */
				ftype = VM_PROT_EXECUTE|VM_PROT_READ;
				goto do_fault;
			}
d447 1
d451 16
a466 10
			switch (a2) {
			case -1:		/* instruction fetch fault */
				ftype = VM_PROT_EXECUTE|VM_PROT_READ;
				break;
			case 0:			/* load instruction */
				ftype = VM_PROT_READ;
				break;
			case 1:			/* store instruction */
				ftype = VM_PROT_READ|VM_PROT_WRITE;
				break;
d468 1
a468 2
	
do_fault:
d485 14
d540 1
a540 1
				printf("UVM: pid %u (%s), uid %u killed: "
d696 1
a696 6
#if NSYSTRACE > 0
		if (ISSET(p->p_flag, P_SYSTRACE))
			error = systrace_redirect(code, p, args + hidden, rval);
		else
#endif
			error = (*callp->sy_call)(p, args + hidden, rval);
a754 37
 * Set the float-point enable for the current process, and return
 * the FPU context to the named process. If check == 0, it is an
 * error for the named process to already be fpcurproc.
 */
void
alpha_enable_fp(struct proc *p, int check)
{
	struct cpu_info *ci = curcpu();

	if (check && ci->ci_fpcurproc == p) {
		alpha_pal_wrfen(1);
		return;
	}
	if (ci->ci_fpcurproc == p)
		panic("trap: fp disabled for fpcurproc == %p", p);

	if (ci->ci_fpcurproc != NULL)
		fpusave_cpu(ci, 1);

	KDASSERT(ci->ci_fpcurproc == NULL);

#if defined(MULTIPROCESSOR)
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 1);
#else
	KDASSERT(p->p_addr->u_pcb.pcb_fpcpu == NULL);
#endif

	p->p_addr->u_pcb.pcb_fpcpu = ci;
	ci->ci_fpcurproc = p;

	p->p_md.md_flags |= MDP_FPUSED;
	alpha_pal_wrfen(1);
	restorefpstate(&p->p_addr->u_pcb.pcb_fp);
}

/*
d807 6
a812 2
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)				\
		fpusave_proc(p, 1);
d960 3
d1059 1
a1059 1
		"pid %u (%s): unaligned access: va=0x%lx pc=0x%lx ra=0x%lx op=",
@


1.18.10.7
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/* $OpenBSD: trap.c,v 1.18.10.6 2003/03/27 23:18:06 niklas Exp $ */
d251 1
a251 1
		snprintf(ubuf, sizeof ubuf, "type %lx", entry);
@


1.18.10.8
log
@Merge of -current from two weeks ago into the SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d395 1
a395 1
			/* FALLTHROUGH */
d828 2
a829 5
	if (copyin((caddr_t)va, &(storage), sizeof (storage)) != 0) {	\
		p->p_md.md_tf->tf_regs[FRAME_PC] -= 4;			\
		signal = SIGSEGV;					\
		goto out;						\
	}								\
d839 2
a840 5
	if (copyout(&(storage), (caddr_t)va, sizeof (storage)) != 0) {	\
		p->p_md.md_tf->tf_regs[FRAME_PC] -= 4;			\
		signal = SIGSEGV;					\
		goto out;						\
	}								\
d977 1
d980 5
a984 5
#define	UNKNOWN()	{ "0x%lx", 0, 0 }
#define	FIX_LD(n,s)	{ n, 1, s }
#define	FIX_ST(n,s)	{ n, 1, s }
#define	NOFIX_LD(n,s)	{ n, 0, s }
#define	NOFIX_ST(n,s)	{ n, 0, s }
d1048 15
@


1.17
log
@simpler
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16 1997/11/17 01:16:34 deraadt Exp $	*/
d154 1
d451 2
a452 1
	trapsignal(p, i, ucode, typ, v);
@


1.16
log
@do not use %:
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.15 1997/07/24 05:57:53 niklas Exp $	*/
d914 1
a914 1
		type = NULL;
d935 2
a936 4
		if (type)
			uprintf("%s\n", type);
		else
			uprintf("%#lx\n", opcode);
@


1.15
log
@comment clarification
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.14 1997/07/19 21:05:04 niklas Exp $	*/
d914 1
a914 1
		type = "0x%lx";
d932 1
a932 1
		uprintf("pid %d (%s): unaligned access: va=0x%lx pc=0x%lx ra=0x%lx op=%:\n",
d934 5
a938 1
		    p->p_md.md_tf->tf_regs[FRAME_PC], type, opcode);
@


1.14
log
@If we are using DDB, be sure to setup the SP entry of the trapframe.
Feed the trapcode to DDB.  a0 is not the address of the instruction fault,
maybe a1 is?
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.13 1997/07/06 17:18:50 niklas Exp $	*/
d225 1
a225 1
		 * happen.
@


1.13
log
@Use a string array to get the name of a trap
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.12 1997/07/06 16:23:48 niklas Exp $	*/
d160 3
d236 2
a237 2
			/* XXX is a0 trap type or address? */
			v = (caddr_t)a0;
d244 2
a245 2
			/* XXX is a0 trap type or address? */
			v = (caddr_t)a0;
d444 1
a444 1
		if (kdb_trap(entry, 0, framep))
@


1.12
log
@Make traps go into DDB if configured
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11 1997/02/12 14:57:02 deraadt Exp $	*/
d125 10
d455 1
a455 1
		const char *entryname;
d457 2
a458 23
		switch (entry) {
		case ALPHA_KENTRY_INT:
			entryname = "interrupt";
			break;
		case ALPHA_KENTRY_ARITH:
			entryname = "arithmetic trap";
			break;
		case ALPHA_KENTRY_MM:
			entryname = "memory management fault";
			break;
		case ALPHA_KENTRY_IF:
			entryname = "instruction fault";
			break;
		case ALPHA_KENTRY_UNA:
			entryname = "unaligned access fault";
			break;
		case ALPHA_KENTRY_SYS:
			entryname = "system call";
			break;
		default:
			entryname = "???";
			break;
		}
@


1.11
log
@fix typecast; janjaap@@stack.nl
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.10 1997/02/09 14:18:42 deraadt Exp $	*/
d44 4
d190 1
a190 1
		goto dopanic;
d207 1
a207 1
		goto dopanic;
d215 1
a215 1
			goto dopanic;
d255 1
a255 1
				goto dopanic;
d270 1
a270 1
			goto dopanic;
d363 1
a363 1
				goto dopanic;
d413 1
a413 1
				goto dopanic;
d424 1
a424 1
			goto dopanic;
d429 5
@


1.10
log
@shadowed variable caused si_addr to be incorrect
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.9 1997/02/06 12:37:56 niklas Exp $	*/
d411 1
a411 1
			v = a0;
@


1.9
log
@From theo: use VM_PROT_* types and pass address nicely
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.8 1997/02/06 12:13:37 niklas Exp $	*/
d137 1
a137 1
	caddr_t va;
d143 1
a143 1
	va = 0;
d167 1
a167 1
			va = (caddr_t)a0;
d196 1
a196 1
			va = NULL;		/* XXX determine */
d220 1
a220 1
			va = (caddr_t)a0;
d228 1
a228 1
			va = (caddr_t)a0;
d411 1
a411 1
			va = a0;
d428 1
a428 1
	trapsignal(p, i, ucode, typ, va);
@


1.8
log
@Fixed some missing declarations and such.  Still sth to fix for Theo :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.7 1997/02/03 13:09:16 deraadt Exp $	*/
d135 1
a135 1
	u_int64_t ucode;
d137 1
d143 1
d166 2
a167 1
			ucode = a0;		/* VA */
d196 1
d219 3
a221 1
			ucode = a0;		/* trap type */
d227 3
a229 1
			ucode = a0;		/* trap type */
d411 2
a412 1
			ucode = a0;
d428 1
a428 1
	trapsignal(p, i, ucode, typ, (union sigval)ucode);
@


1.7
log
@initial cut at siginfo
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.6 1997/01/24 19:56:46 niklas Exp $	*/
d138 1
d193 1
a193 1
			vv = ucode = a0;	/* exception summary */
d419 1
a419 1
	trapsignal(p, i, ucode, typ, ucode);
d884 1
@


1.6
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.5 1996/10/30 22:38:29 niklas Exp $	*/
d164 4
d192 2
a193 1
			ucode =  a0;		/* exception summary */
d216 1
d231 1
d404 1
d418 1
a418 1
	trapsignal(p, i, ucode);
d938 1
@


1.5
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 2
a2 2
/*	$OpenBSD: trap.c,v 1.16 1996/10/13 02:59:48 christos Exp $	*/
/*	$NetBSD: trap.c,v 1.16 1996/10/13 02:59:48 christos Exp $	*/
d5 1
a5 1
 * Copyright (c) 1994, 1995 Carnegie-Mellon University.
d61 14
d79 1
a79 1
static __inline void
d142 2
a143 2
	if ((framep->tf_regs[FRAME_PS] & ALPHA_PSL_USERMODE) != 0) {
		user = 1;
d146 5
a150 2
	} else
		user = 0;
a287 1
			extern int fswintrberr __P((void));
d341 4
d417 42
a458 14
	printf("\n");
	printf("fatal %s trap:\n", user ? "user" : "kernel");
	printf("\n");
	printf("    trap entry = 0x%lx\n", entry);
	printf("    a0         = 0x%lx\n", a0);
	printf("    a1         = 0x%lx\n", a1);
	printf("    a2         = 0x%lx\n", a2);
	printf("    pc         = 0x%lx\n", framep->tf_regs[FRAME_PC]);
	printf("    ra         = 0x%lx\n", framep->tf_regs[FRAME_RA]);
	printf("    curproc    = %p\n", curproc);
	if (curproc != NULL)
		printf("        pid = %d, comm = %s\n", curproc->p_pid,
		    curproc->p_comm);
	printf("\n");
@


1.4
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: trap.c,v 1.5 1995/11/23 02:34:37 cgd Exp $	*/
/*	$NetBSD: trap.c,v 1.5 1995/11/23 02:34:37 cgd Exp $	*/
d36 1
a42 1
#include <machine/trap.h>
d48 11
d108 4
a111 3
 * Trap is called from locore to handle most types of processor traps,
 * including events such as simulated software interrupts/AST's.
 * System calls are broken out for efficiency.
d114 3
a116 4
trap(type, code, v, framep)
	unsigned long type;
	unsigned long code;
	register unsigned long v;
a118 1
	extern char fswintr[];
d123 1
d128 2
a129 2
	if (USERMODE(framep->tf_ps)) {
		type |= T_USER;
d132 13
a144 8
	}
#ifdef DDB
	if (type == T_BPT) {
		if (kdb_trap(type, framep))
			return;
	}
#endif
	switch (type) {
d146 3
a148 20
	default:
dopanic:
		printf("trap type %ld, code = 0x%lx, v = 0x%lx\n", type,
		    code, v);
		printf("pc = 0x%lx\n", framep->tf_pc);
		printf("curproc = 0x%lx\n", curproc);
		if (curproc != NULL)
			printf("curproc->p_pid = 0x%d\n", curproc->p_pid);

#ifdef DDB
		if (kdb_trap(type, framep))
			return;
#endif
		regdump(framep);
		type &= ~T_USER;
#ifdef XXX
		if ((unsigned)type < trap_types)
			panic(trap_type[type]);
#endif
		panic("trap");
d150 11
a160 2
	case T_ASTFLT:
		/* oops.  this can't happen. */
d163 10
a172 15
	case T_ASTFLT|T_USER:
		astpending = 0;
		cnt.v_soft++;
		if (p->p_flag & P_OWEUPC) {
			p->p_flag &= ~P_OWEUPC;
			ADDUPROF(p);
		}
		goto out;

	case T_UNAFLT:			/* Always an error of some kind. */
		if (p == NULL || p->p_addr->u_pcb.pcb_onfault == NULL)
			goto dopanic;
		else {
			framep->tf_pc = (u_int64_t)p->p_addr->u_pcb.pcb_onfault;
			p->p_addr->u_pcb.pcb_onfault = NULL;
a173 1
		goto out;
d175 2
a176 4
	case T_UNAFLT|T_USER:		/* "Here, have a SIGBUS instead!" */
		i = SIGBUS;
		ucode = v;
		break;
d178 1
a178 6
	case T_ARITHFLT|T_USER:
sigfpe:		i = SIGFPE;
		ucode = v;
		break;

	case T_FPDISABLED|T_USER:
d180 2
a181 2
		 * on exit from the kernel, if proc == fpcurproc, FP is
		 * enabled.
d183 2
a184 2
		if (fpcurproc == p)
			panic("fp disabled for fpcurproc == %lx", p);
d186 9
a194 6
		pal_wrfen(1);
		if (fpcurproc)
			savefpstate(&fpcurproc->p_addr->u_pcb.pcb_fp);
		fpcurproc = p;
		restorefpstate(&fpcurproc->p_addr->u_pcb.pcb_fp);
		pal_wrfen(0);
d196 31
a226 2
		p->p_md.md_flags |= MDP_FPUSED;
		goto out;
d228 2
a229 8
	case T_GENTRAP|T_USER:
		if (framep->tf_a0 == -2)		/* weird! */
			goto sigfpe;
	case T_BPT|T_USER:
	case T_BUGCHK|T_USER:
		ucode = code;
		i = SIGTRAP;
		break;
d231 4
a234 3
	case T_OPDEC|T_USER:
		ucode = code;
		i = SIGILL;
d237 14
a250 18
	case T_INVALTRANS:
	case T_INVALTRANS|T_USER:
	case T_ACCESS:
	case T_ACCESS|T_USER:
	    {
		register vm_offset_t va;
		register struct vmspace *vm;
		register vm_map_t map;
		vm_prot_t ftype;
		int rv;
		extern int fswintrberr();
		extern vm_map_t kernel_map;

		/* if it was caused by fuswintr or suswintr, just punt. */
		if ((type & T_USER) == 0 && p != NULL &&
		    p->p_addr->u_pcb.pcb_onfault == (caddr_t)fswintrberr) {
			framep->tf_pc = (u_int64_t)p->p_addr->u_pcb.pcb_onfault;
			p->p_addr->u_pcb.pcb_onfault = NULL;
a251 1
		}
d253 9
a261 15
		/*
		 * It is only a kernel address space fault iff:
		 *	1. (type & T_USER) == 0  and
		 *	2. pcb_onfault not set or
		 *	3. pcb_onfault set but kernel space data fault
		 * The last can occur during an exec() copyin where the
		 * argument space is lazy-allocated.
		 */
		if ((type & T_USER) == 0 && (v >= VM_MIN_KERNEL_ADDRESS ||
		    p == NULL || p->p_addr->u_pcb.pcb_onfault == NULL))
			map = kernel_map;
		else {
			vm = p->p_vmspace;
			map = &vm->vm_map;
		}
d263 37
a299 9
		switch (code) {
		case -1:		/* instruction fetch fault */
		case 0:			/* load instruction */
			ftype = VM_PROT_READ;
			break;
		case 1:			/* store instruction */
			ftype = VM_PROT_WRITE;
			break;
		}
d301 56
a356 6
		va = trunc_page((vm_offset_t)v);
		rv = vm_fault(map, va, ftype, FALSE);
#ifdef VMFAULT_TRACE
		printf("vm_fault(0x%lx (pmap 0x%lx), 0x%lx (0x%lx), 0x%lx, %d) -> 0x%lx at pc 0x%lx\n",
		    map, map == kernel_map ? pmap_kernel() : &vm->vm_pmap,
		    va, v, ftype, FALSE, rv, framep->tf_pc);
d358 2
a359 10
		/*
		 * If this was a stack access we keep track of the maximum
		 * accessed stack size.  Also, if vm_fault gets a protection
		 * failure it is due to accessing the stack region outside
		 * the current limit and we need to reflect that as an access
		 * error.
		 */
		if (map != kernel_map && (caddr_t)va >= vm->vm_maxsaddr) {
			if (rv == KERN_SUCCESS) {
				unsigned nss;
d361 13
a373 15
				nss = clrnd(btoc(USRSTACK-(unsigned)va));
				if (nss > vm->vm_ssize)
					vm->vm_ssize = nss;
			} else if (rv == KERN_PROTECTION_FAILURE)
				rv = KERN_INVALID_ADDRESS;
		}
		if (rv == KERN_SUCCESS)
			goto out;
		if (!USERMODE(framep->tf_ps)) {
			if (p != NULL &&
			    p->p_addr->u_pcb.pcb_onfault != NULL) {
				framep->tf_pc =
				    (u_int64_t)p->p_addr->u_pcb.pcb_onfault;
				p->p_addr->u_pcb.pcb_onfault = NULL;
				goto out;
d375 7
a383 2
		ucode = v;
		i = SIGSEGV;
a384 1
	    }
d386 2
a387 11
	case T_FOR:
	case T_FOR|T_USER:
	case T_FOE:
	case T_FOE|T_USER:
		pmap_emulate_reference(p, v, (type & T_USER) != 0, 0);
		goto out;

	case T_FOW:
	case T_FOW|T_USER:
		pmap_emulate_reference(p, v, (type & T_USER) != 0, 1);
		goto out;
d392 24
a415 3
	if ((type & T_USER) == 0)
		return;
	userret(p, framep->tf_pc, sticks);
d449 1
a449 1
	if (!USERMODE(framep->tf_ps))
d455 1
a455 1
	opc = framep->tf_pc - 4;
a460 1

d466 1
a466 1
			code = framep->tf_a0;
d481 1
a481 1
		code = framep->tf_a0;
d499 1
a499 1
		error = copyin((caddr_t)(framep->tf_regs[FRAME_SP]), &args[6],
d508 1
a508 1
		args[2] = framep->tf_a2;
d510 1
a510 1
		args[1] = framep->tf_a1;
d512 1
a512 1
		args[0] = framep->tf_a0;
d522 3
d539 1
a539 1
		framep->tf_pc = opc;
d556 3
d561 1
a561 1
	userret(p, framep->tf_pc, sticks);
d580 1
a580 1
	userret(p, p->p_md.md_tf->tf_pc, 0);
d585 366
@


1.3
log
@SIGBUS is an alignment fault. SIGSEGV is an access violation
@
text
@d1 1
@


1.2
log
@update to netbsd
@
text
@d298 1
a298 1
		i = (rv == KERN_PROTECTION_FAILURE) ? SIGBUS : SIGSEGV;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: trap.c,v 1.4 1995/06/28 02:45:21 cgd Exp $	*/
d122 1
a122 1
	if (type == T_TRACE || type == T_BREAKPOINT) {
d205 4
d211 1
a211 1
                i = SIGILL;
a217 8
#ifdef notdef				/* None of these should happen. */
	case T_FOR:
	case T_FOR|T_USER:
	case T_FOE:
	case T_FOE|T_USER:
	case T_FOW:
	case T_FOW|T_USER:
#endif
d301 12
d460 1
a460 1
	userret(p, framep, sticks, (u_int)0, 0);
d464 19
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

