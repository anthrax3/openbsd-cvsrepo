head	1.22;
access;
symbols
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.2
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.21.0.14
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.16
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.8
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.12
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.10
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.6
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.4
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.2
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.6
	OPENBSD_5_0:1.20.0.4
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.18.0.10
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.12
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.8
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.6
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.4
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.14.0.12
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.10
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.8
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.6
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.12
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.10
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.8
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.11.0.6
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.4
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.9.0.8
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.6
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.4
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.6
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.4
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2016.02.26.02.07.03;	author mmcc;	state Exp;
branches;
next	1.21;
commitid	e3HpB3TXFIDIGGuz;

1.21
date	2012.03.23.15.51.25;	author guenther;	state Exp;
branches;
next	1.20;

1.20
date	2010.09.20.06.33.46;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	2010.06.30.20.38.49;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2007.04.30.04.35.05;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.25.09.27.01;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2007.04.25.09.07.02;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2007.04.23.10.07.43;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2004.06.28.02.28.42;	author aaron;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.18.20.14.40;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.23.27.43;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.26.19.41.21;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.08.16.00.56;	author art;	state Exp;
branches;
next	1.9;

1.9
date	99.09.25.16.23.49;	author pjanzen;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	98.03.01.13.42.19;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	97.01.24.19.56.19;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.10.30.22.37.58;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.07.29.22.57.13;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.06.18.09.42.04;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.26.18.13.48;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.52.31;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.39;	author deraadt;	state Exp;
branches;
next	;

1.9.4.1
date	2001.04.18.16.00.09;	author niklas;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2003.06.07.11.11.33;	author ho;	state Exp;
branches;
next	1.9.4.3;

1.9.4.3
date	2004.02.19.09.59.33;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Make alpha and sh 2038-safe. Now that we have 64-bit time_t, we don't
need to ignore the hardware clock when it reports a year > 2037. Irony
noted.

both ok millert, alpha ok deraadt
@
text
@/*	$OpenBSD: clock.c,v 1.21 2012/03/23 15:51:25 guenther Exp $	*/
/*	$NetBSD: clock.c,v 1.29 2000/06/05 21:47:10 thorpej Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department and Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah Hdr: clock.c 1.18 91/01/21
 *
 *	@@(#)clock.c	8.1 (Berkeley) 6/10/93
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/evcount.h>
#include <sys/timetc.h>

#include <dev/clock_subr.h>

#include <machine/rpb.h>
#include <machine/autoconf.h>
#include <machine/cpuconf.h>

#include <alpha/alpha/clockvar.h>

#define MINYEAR 1998 /* "today" */
#define UNIX_YEAR_OFFSET 0
 
extern int schedhz;

struct device *clockdev;
const struct clockfns *clockfns;
int clockinitted;
struct evcount clk_count;
int clk_irq = 0;

u_int rpcc_get_timecount(struct timecounter *);
struct timecounter rpcc_timecounter = {
	rpcc_get_timecount, NULL, ~0u, 0, "rpcc", 0, NULL
};

void
clockattach(dev, fns)
	struct device *dev;
	const struct clockfns *fns;
{

	/*
	 * Just bookkeeping.
	 */
	printf("\n");

	if (clockfns != NULL)
		panic("clockattach: multiple clocks");
	clockdev = dev;
	clockfns = fns;
}

/*
 * Machine-dependent clock routines.
 *
 * Startrtclock restarts the real-time clock, which provides
 * hardclock interrupts to kern_clock.c.
 *
 * Inittodr initializes the time of day hardware which provides
 * date functions.  Its primary function is to use some file
 * system information in case the hardware clock lost state.
 *
 * Resettodr restores the time of day hardware after a time change.
 */

/*
 * Start the real-time and statistics clocks. Leave stathz 0 since there
 * are no other timers available.
 */
void
cpu_initclocks(void)
{
	u_int32_t cycles_per_sec;
	struct clocktime ct;
	u_int32_t first_rpcc, second_rpcc; /* only lower 32 bits are valid */
	int first_sec;

	if (clockfns == NULL)
		panic("cpu_initclocks: no clock attached");

	tick = 1000000 / hz;	/* number of microseconds between interrupts */

	/*
	 * Establish the clock interrupt; it's a special case.
	 *
	 * We establish the clock interrupt this late because if
	 * we do it at clock attach time, we may have never been at
	 * spl0() since taking over the system.  Some versions of
	 * PALcode save a clock interrupt, which would get delivered
	 * when we spl0() in autoconf.c.  If established the clock
	 * interrupt handler earlier, that interrupt would go to
	 * hardclock, which would then fall over because the pointer
	 * to the virtual timers wasn't set at that time.
	 */
	platform.clockintr = hardclock;
	schedhz = 16;

	evcount_attach(&clk_count, "clock", &clk_irq);

	/*
	 * Get the clock started.
	 */
	(*clockfns->cf_init)(clockdev);

	/*
	 * Calibrate the cycle counter frequency.
	 */
	(*clockfns->cf_get)(clockdev, 0, &ct);
	first_sec = ct.sec;

	/* Let the clock tick one second. */
	do {
		first_rpcc = alpha_rpcc();
		(*clockfns->cf_get)(clockdev, 0, &ct);
	} while (ct.sec == first_sec);
	first_sec = ct.sec;
	/* Let the clock tick one more second. */
	do {
		second_rpcc = alpha_rpcc();
		(*clockfns->cf_get)(clockdev, 0, &ct);
	} while (ct.sec == first_sec);

	cycles_per_sec = second_rpcc - first_rpcc;

	rpcc_timecounter.tc_frequency = cycles_per_sec;

	tc_init(&rpcc_timecounter);
}

/*
 * We assume newhz is either stathz or profhz, and that neither will
 * change after being set up above.  Could recalculate intervals here
 * but that would be a drag.
 */
void
setstatclockrate(newhz)
	int newhz;
{

	/* nothing we can do */
}

/*
 * Initialize the time of day register, based on the time base which is, e.g.
 * from a filesystem.  Base provides the time to within six months,
 * and the time of year clock (if any) provides the rest.
 */
void
inittodr(time_t base)
{
	struct clocktime ct;
	int year;
	struct clock_ymdhms dt;
	time_t deltat;
	int badbase;
	struct timespec ts;

	ts.tv_sec = ts.tv_nsec = 0;

	if (base < (MINYEAR-1970)*SECYR) {
		printf("WARNING: preposterous time in file system");
		/* read the system clock anyway */
		base = (MINYEAR-1970)*SECYR;
		badbase = 1;
	} else
		badbase = 0;

	(*clockfns->cf_get)(clockdev, base, &ct);
#ifdef DEBUG
	printf("readclock: %d/%d/%d/%d/%d/%d", ct.year, ct.mon, ct.day,
	       ct.hour, ct.min, ct.sec);
#endif
	clockinitted = 1;

	year = 1900 + UNIX_YEAR_OFFSET + ct.year;
	if (year < 1970)
		year += 100;
	/* simple sanity checks */
	if (year < MINYEAR || ct.mon < 1 || ct.mon > 12 || ct.day < 1 ||
	    ct.day > 31 || ct.hour > 23 || ct.min > 59 || ct.sec > 59) {
		/*
		 * Believe the time in the file system for lack of
		 * anything better, resetting the TODR.
		 */
		ts.tv_sec = base;
		if (!badbase) {
			printf("WARNING: preposterous clock chip time\n");
			resettodr();
		}
		goto bad;
	}

	dt.dt_year = year;
	dt.dt_mon = ct.mon;
	dt.dt_day = ct.day;
	dt.dt_hour = ct.hour;
	dt.dt_min = ct.min;
	dt.dt_sec = ct.sec;
	ts.tv_sec = clock_ymdhms_to_secs(&dt);
#ifdef DEBUG
	printf("=>%ld (%d)\n", ts.tv_sec, base);
#endif

	if (!badbase) {
		/*
		 * See if we gained/lost two or more days;
		 * if so, assume something is amiss.
		 */
		deltat = ts.tv_sec - base;
		if (deltat < 0)
			deltat = -deltat;
		if (deltat < 2 * SECDAY) {
			tc_setclock(&ts);
			return;
		}
		printf("WARNING: clock %s %ld days",
		    ts.tv_sec < base ? "lost" : "gained",
		    (long)deltat / SECDAY);
	}
bad:
	tc_setclock(&ts);
	printf(" -- CHECK AND RESET THE DATE!\n");
}

/*
 * Reset the TODR based on the time value; used when the TODR
 * has a preposterous value and also when the time is reset
 * by the stime system call.  Also called when the TODR goes past
 * TODRZERO + 100*(SECYEAR+2*SECDAY) (e.g. on Jan 2 just after midnight)
 * to wrap the TODR around.
 */
void
resettodr()
{
	struct clock_ymdhms dt;
	struct clocktime ct;

	if (!clockinitted)
		return;

	clock_secs_to_ymdhms(time_second, &dt);

	/* rt clock wants 2 digits */
	ct.year = (dt.dt_year - UNIX_YEAR_OFFSET) % 100;
	ct.mon = dt.dt_mon;
	ct.day = dt.dt_day;
	ct.hour = dt.dt_hour;
	ct.min = dt.dt_min;
	ct.sec = dt.dt_sec;
	ct.dow = dt.dt_wday;
#ifdef DEBUG
	printf("setclock: %d/%d/%d/%d/%d/%d\n", ct.year, ct.mon, ct.day,
	       ct.hour, ct.min, ct.sec);
#endif

	(*clockfns->cf_set)(clockdev, &ct);
}

u_int
rpcc_get_timecount(struct timecounter *tc)
{
	return alpha_rpcc();
}
@


1.21
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.20 2010/09/20 06:33:46 matthew Exp $	*/
d215 2
a216 3
	/* simple sanity checks (2037 = time_t overflow) */
	if (year < MINYEAR || year > 2037 ||
	    ct.mon < 1 || ct.mon > 12 || ct.day < 1 ||
@


1.20
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.19 2010/06/30 20:38:49 tedu Exp $	*/
d129 2
a130 2
	 * hardclock, which would then fall over because p->p_stats
	 * isn't set at that time.
@


1.19
log
@remove compat_osf1 support from the kernel
ok deraadt miod
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.18 2007/04/30 04:35:05 miod Exp $	*/
d135 1
a135 1
	evcount_attach(&clk_count, "clock", (void *)&clk_irq, &evcount_intr);
@


1.18
log
@Fix dmesg nit.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.17 2007/04/25 09:27:01 art Exp $	*/
a57 10
#ifdef CLOCK_COMPAT_OSF1
/*
 * According to OSF/1's /usr/sys/include/arch/alpha/clock.h,
 * the console adjusts the RTC years 13..19 to 93..99 and
 * 20..40 to 00..20. (historical reasons?)
 * DEC Unix uses an offset to the year to stay outside
 * the dangerous area for the next couple of years.
 */
#define UNIX_YEAR_OFFSET 52 /* 41=>1993, 12=>2064 */
#else
a58 1
#endif
@


1.17
log
@Yet another case that forgot to set the time.
pointed out by and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.16 2007/04/25 09:07:02 art Exp $	*/
d261 7
a267 4
		if (deltat >= 2 * SECDAY)
			printf("WARNING: clock %s %ld days",
			    ts.tv_sec < base ? "lost" : "gained",
			    (long)deltat / SECDAY);
@


1.16
log
@Set the time even when the clock chip is bad.

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.15 2007/04/23 10:07:43 art Exp $	*/
d261 4
a264 5
		if (deltat < 2 * SECDAY)
			return;
		printf("WARNING: clock %s %ld days",
		    ts.tv_sec < base ? "lost" : "gained",
		    (long)deltat / SECDAY);
@


1.15
log
@Switch alpha to timecounters.

We use rpcc for the clock. We don't try to get the frequency from the
hwrpb, since from experience we know that it's very unreliable and
can be several % off from the real frequency. Instead we calibrate
the timecounter frequency by using the clock device and count the
number of cycles between two second ticks of the clocks.

This is not perfect, but still much better than what we had before.
We'll have to add an i8254 clock for MP though.

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.14 2004/06/28 02:28:42 aaron Exp $	*/
d267 1
a268 1
bad:
@


1.14
log
@Use new event counter API for interrupt counting on alpha.  By me, with some
edits by Theo.  deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.13 2003/10/18 20:14:40 jmc Exp $	*/
d47 1
d79 5
d119 1
a119 1
cpu_initclocks()
d121 5
a129 8
	tickfix = 1000000 - (hz * tick);
	if (tickfix) {
		int ftp;

		ftp = min(ffs(tickfix), ffs(hz));
		tickfix >>= (ftp - 1);
		tickfixinterval = hz >> (ftp - 1);
        }
d152 24
d197 1
a197 2
inittodr(base)
	time_t base;
d204 3
d234 1
a234 1
		time.tv_sec = base;
d248 1
a248 1
	time.tv_sec = clock_ymdhms_to_secs(&dt);
d250 1
a250 1
	printf("=>%ld (%d)\n", time.tv_sec, base);
d258 1
a258 1
		deltat = time.tv_sec - base;
d264 1
a264 1
		    time.tv_sec < base ? "lost" : "gained",
d267 1
d288 1
a288 1
	clock_secs_to_ymdhms(time.tv_sec, &dt);
d304 6
@


1.13
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.12 2003/06/02 23:27:43 millert Exp $	*/
d46 1
d75 2
a92 3
#ifdef EVCNT_COUNTERS
	evcnt_attach(dev, "intr", &clock_intr_evcnt);
#endif
d142 2
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.11 2000/11/26 19:41:21 millert Exp $	*/
d103 1
a103 1
 * system information in case the hardare clock lost state.
d163 1
a163 1
 * Initialze the time of day register, based on the time base which is, e.g.
@


1.11
log
@alpha clock fixes from NetBSD
Fixes ' no more 'WARNING: preposterous clock chip time' on 164SX
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.10 2000/11/08 16:00:56 art Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.10
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 2
a2 2
/*	$OpenBSD: clock.c,v 1.9 1999/09/25 16:23:49 pjanzen Exp $	*/
/*	$NetBSD: clock.c,v 1.14 1996/11/23 06:31:57 cgd Exp $	*/
d51 2
d59 14
a72 7
#define	SECMIN	((unsigned)60)			/* seconds per minute */
#define	SECHOUR	((unsigned)(60*SECMIN))		/* seconds per hour */
#define	SECDAY	((unsigned)(24*SECHOUR))	/* seconds per day */
#define	SECYR	((unsigned)(365*SECDAY))	/* seconds per common year */

#define	LEAPYEAR(year)	(((year) % 4) == 0)

a121 1
	hz = 1024;		/* 1024 Hz clock */
a166 8
 * This code is defunct after 2099.
 * Will Unix still be here then??
 */
static short dayyr[12] = {
	0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334
};

/*
a174 1
	register int days, yr;
d176 2
d181 1
a181 1
	if (base < 5*SECYR) {
d184 1
a184 1
		base = 6*SECYR + 186*SECDAY + SECDAY/2;
d190 4
d196 6
a201 2
	/* simple sanity checks */
	if (ct.year < 70 || ct.mon < 1 || ct.mon > 12 || ct.day < 1 ||
d214 11
a224 9
	days = 0;
	for (yr = 70; yr < ct.year; yr++)
		days += LEAPYEAR(yr) ? 366 : 365;
	days += dayyr[ct.mon - 1] + ct.day - 1;
	if (LEAPYEAR(yr) && ct.mon > 2)
		days++;
	/* now have days since Jan 1, 1970; the rest is easy... */
	time.tv_sec =
	    days * SECDAY + ct.hour * SECHOUR + ct.min * SECMIN + ct.sec;
d236 3
a238 2
		printf("WARNING: clock %s %d days",
		    time.tv_sec < base ? "lost" : "gained", deltat / SECDAY);
d254 1
a254 1
	register int t, t2;
d260 1
a260 12
	/* compute the day of week. */
	t2 = time.tv_sec / SECDAY;
	ct.dow = (t2 + 4) % 7;	/* 1/1/1970 was thursday */

	/* compute the year */
	ct.year = 69;
	t = t2;			/* XXX ? */
	while (t2 >= 0) {	/* whittle off years */
		t = t2;
		ct.year++;
		t2 -= LEAPYEAR(ct.year) ? 366 : 365;
	}
d262 12
a273 16
	/* t = month + day; separate */
	t2 = LEAPYEAR(ct.year);
	for (ct.mon = 1; ct.mon < 12; ct.mon++)
		if (t < dayyr[ct.mon] + (t2 && ct.mon > 1))
			break;

	ct.day = t - dayyr[ct.mon - 1] + 1;
	if (t2 && ct.mon > 2)
		ct.day--;

	/* the rest is easy */
	t = time.tv_sec % SECDAY;
	ct.hour = t / SECHOUR;
	t %= 3600;
	ct.min = t / SECMIN;
	ct.sec = t % SECMIN;
@


1.9
log
@alpha-specific part of ross@@netbsd's NetBSD scheduler fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.8 1998/03/01 13:42:19 niklas Exp $	*/
d53 1
d136 1
a136 1
	set_clockintr();
@


1.9.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 2
/*	$OpenBSD: clock.c,v 1.11 2000/11/26 19:41:21 millert Exp $	*/
/*	$NetBSD: clock.c,v 1.29 2000/06/05 21:47:10 thorpej Exp $	*/
a50 2
#include <dev/clock_subr.h>

a52 1
#include <machine/cpuconf.h>
d56 7
a62 14
#define MINYEAR 1998 /* "today" */
#ifdef CLOCK_COMPAT_OSF1
/*
 * According to OSF/1's /usr/sys/include/arch/alpha/clock.h,
 * the console adjusts the RTC years 13..19 to 93..99 and
 * 20..40 to 00..20. (historical reasons?)
 * DEC Unix uses an offset to the year to stay outside
 * the dangerous area for the next couple of years.
 */
#define UNIX_YEAR_OFFSET 52 /* 41=>1993, 12=>2064 */
#else
#define UNIX_YEAR_OFFSET 0
#endif
 
d112 1
d135 1
a135 1
	platform.clockintr = hardclock;
d158 8
d174 1
a175 2
	int year;
	struct clock_ymdhms dt;
d179 1
a179 1
	if (base < (MINYEAR-1970)*SECYR) {
d182 1
a182 1
		base = (MINYEAR-1970)*SECYR;
a187 4
#ifdef DEBUG
	printf("readclock: %d/%d/%d/%d/%d/%d", ct.year, ct.mon, ct.day,
	       ct.hour, ct.min, ct.sec);
#endif
d190 2
a191 6
	year = 1900 + UNIX_YEAR_OFFSET + ct.year;
	if (year < 1970)
		year += 100;
	/* simple sanity checks (2037 = time_t overflow) */
	if (year < MINYEAR || year > 2037 ||
	    ct.mon < 1 || ct.mon > 12 || ct.day < 1 ||
d204 9
a212 11

	dt.dt_year = year;
	dt.dt_mon = ct.mon;
	dt.dt_day = ct.day;
	dt.dt_hour = ct.hour;
	dt.dt_min = ct.min;
	dt.dt_sec = ct.sec;
	time.tv_sec = clock_ymdhms_to_secs(&dt);
#ifdef DEBUG
	printf("=>%ld (%d)\n", time.tv_sec, base);
#endif
d224 2
a225 3
		printf("WARNING: clock %s %ld days",
		    time.tv_sec < base ? "lost" : "gained",
		    (long)deltat / SECDAY);
d241 1
a241 1
	struct clock_ymdhms dt;
d247 12
a258 1
	clock_secs_to_ymdhms(time.tv_sec, &dt);
d260 16
a275 12
	/* rt clock wants 2 digits */
	ct.year = (dt.dt_year - UNIX_YEAR_OFFSET) % 100;
	ct.mon = dt.dt_mon;
	ct.day = dt.dt_day;
	ct.hour = dt.dt_hour;
	ct.min = dt.dt_min;
	ct.sec = dt.dt_sec;
	ct.dow = dt.dt_wday;
#ifdef DEBUG
	printf("setclock: %d/%d/%d/%d/%d/%d\n", ct.year, ct.mon, ct.day,
	       ct.hour, ct.min, ct.sec);
#endif
@


1.9.4.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.9.4.1 2001/04/18 16:00:09 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.9.4.3
log
@Merge of -current from two weeks ago into the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d103 1
a103 1
 * system information in case the hardware clock lost state.
d163 1
a163 1
 * Initialize the time of day register, based on the time base which is, e.g.
@


1.8
log
@unused decl removed
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.7 1997/01/24 19:56:19 niklas Exp $	*/
d63 2
d136 1
@


1.7
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.6 1996/10/30 22:37:58 niklas Exp $	*/
a106 2
	extern int tickadj;

@


1.6
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 2
a2 2
/*	$OpenBSD: clock.c,v 1.13 1996/10/13 02:59:25 christos Exp $	*/
/*	$NetBSD: clock.c,v 1.13 1996/10/13 02:59:25 christos Exp $	*/
d74 1
a74 1
	 * establish the clock interrupt; it's a special case
a75 4
	set_clockintr();
#ifdef EVCNT_COUNTERS
	evcnt_attach(self, "intr", &clock_intr_evcnt);
#endif
d82 3
d122 14
@


1.5
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: clock.c,v 1.10 1996/04/23 15:26:06 cgd Exp $	*/
/*	$NetBSD: clock.c,v 1.10 1996/04/23 15:26:06 cgd Exp $	*/
d52 1
a108 2
	struct clock_softc *csc;
	int fractick;
d162 2
a163 2
	long deltat;
	int badbase, s;
a228 1
	int s;
d239 1
@


1.4
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.3
log
@from netbsd:
deal with renaming of asic to ioasic, and other new-tc-config changes
@
text
@d1 1
a1 1
/*	$NetBSD: clock.c,v 1.6 1995/12/20 00:38:53 cgd Exp $	*/
a53 26
#include "ioasic.h"
#if NIOASIC
#include <dev/tc/tcreg.h>
#include <dev/tc/tcvar.h>
#include <dev/tc/ioasicvar.h>			/* XXX */
#endif

#include "isa.h"
#if NISA
#include <dev/isa/isavar.h>			/* XXX */
#endif

/* Definition of the driver for autoconfig. */
static int	clockmatch __P((struct device *, void *, void *));
static void	clockattach __P((struct device *, struct device *, void *));
struct cfdriver clockcd =
    { NULL, "clock", clockmatch, clockattach, DV_DULL,
	sizeof(struct clock_softc) };

#if defined(DEC_3000_500) || defined(DEC_3000_300) || \
    defined(DEC_2000_300) || defined(DEC_2100_A50) || \
    defined(DEC_KN20AA)
void	mcclock_attach __P((struct device *parent,
	    struct device *self, void *aux));
#endif

d61 3
a63 8
static int
clockmatch(parent, cfdata, aux)
	struct device *parent;
	void *cfdata;
	void *aux;
{
	struct cfdata *cf = cfdata;
	struct confargs *ca = aux;
d65 4
a68 31
#if NIOASIC
	if (parent->dv_cfdata->cf_driver == &ioasiccd) {
		struct ioasicdev_attach_args *d = aux;

		if (strncmp("TOY_RTC ", d->iada_modname, TC_ROM_LLEN))
			return (0);
	} else
#endif
#if NISA
	if ((parent->dv_cfdata->cf_driver == &isacd)) {
		struct isadev_attach_args *ida = aux;

		/* XXX XXX XXX */
		if (ida->ida_port[0] != 0x70 && ida->ida_port[0] != -1)
			return (0);

		ida->ida_port[0] = 0x70;		/* XXX */
		ida->ida_nports[0] = 2;			/* XXX */
		ida->ida_iosiz[0] = 0;
	} else
#endif
		return (0);

	return (1);
}

static void
clockattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
a71 7
	 * XXX deal with other clock type, if the system
	 * XXX supports the other clock.  get systype
	 * from RPB.
	 */
	mcclock_attach(parent, self, aux);

	/*
d78 1
d80 4
a83 1
	printf("\n");
d103 1
d110 1
a110 2
	if (clockcd.cd_devs == NULL ||
	    (csc = (struct clock_softc *)clockcd.cd_devs[0]) == NULL)
d127 1
a127 1
	(*csc->sc_init)(csc);
a159 1
	struct clock_softc *csc = (struct clock_softc *)clockcd.cd_devs[0];
d173 2
a174 3
	(*csc->sc_get)(csc, base, &ct);

	csc->sc_initted = 1;
a226 1
	struct clock_softc *csc = (struct clock_softc *)clockcd.cd_devs[0];
d231 1
a231 1
	if (!csc->sc_initted)
d263 1
a263 13
	(*csc->sc_set)(csc, &ct);
}

/*
 * Wait "n" microseconds.  This doesn't belong here.  XXX.
 */
delay(n)
	int n;
{
	register long N = cycles_per_usec * (n);

	while (N > 0)
		N -= 3;
@


1.2
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: clock.c,v 1.5 1995/11/23 02:33:41 cgd Exp $	*/
a50 1
#include <machine/autoconf.h>
d54 5
a58 3
#include "asic.h"
#if NASIC
#include <alpha/tc/asic.h>			/* XXX */
a94 2
#if NASIC
	extern struct cfdriver asiccd;
d96 3
a98 4
	if (parent->dv_cfdata->cf_driver == &asiccd) {
		/* make sure that we're looking for this type of device. */
		if (!BUS_MATCHNAME(ca, "dallas_rtc"))
			return (0);
d100 1
a100 1
		if (cf->cf_unit >= 1)
d106 1
a106 5

		/* Just say yes.  XXX */

		if (cf->cf_unit >= 1)
			return 0;
d109 2
a110 2
		{
			struct isadev_attach_args *ida = aux;
d112 3
a114 8
			if (ida->ida_port[0] != 0x70 &&		/* XXX */
			    ida->ida_port[0] != -1)		/* XXX */
				return (0);

			ida->ida_port[0] = 0x70;		/* XXX */
			ida->ida_nports[0] = 2;			/* XXX */
			ida->ida_iosiz[0] = 0;
		}
a332 1
void
d336 4
a339 1
	DELAY(n);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: clock.c,v 1.4 1995/08/03 00:53:34 cgd Exp $	*/
d50 1
a51 1
#include <machine/rpb.h>
d54 3
d58 4
d63 1
d73 2
a74 1
    defined(DEC_2000_300) || defined(DEC_2100_A50)
d94 2
d97 1
a97 10
	/* See how many clocks this system has */	
	switch (hwrpb->rpb_type) {
#if defined(DEC_3000_500) || defined(DEC_3000_300)

#if defined(DEC_3000_500)
	case ST_DEC_3000_500:
#endif
#if defined(DEC_3000_300)
	case ST_DEC_3000_300:
#endif
d104 1
a104 2

		break;
d106 2
a108 2
#if defined(DEC_2100_A50)
	case ST_DEC_2100_A50:
d116 1
a116 1
			struct isa_attach_args *ia = aux;
d118 2
a119 2
			if (ia->ia_iobase != 0x70 &&		/* XXX */
			    ia->ia_iobase != -1)		/* XXX */
d122 3
a124 3
			ia->ia_iobase = 0x70;			/* XXX */
			ia->ia_iosize = 2;			/* XXX */
			ia->ia_msize = 0;
d126 1
a126 7

		break;
#endif

#if defined(DEC_2000_300)
	case ST_DEC_2000_300:
		panic("clockmatch on jensen");
d128 1
a128 4

	default:
		panic("unknown CPU");
	}
d140 6
a145 23
	switch (hwrpb->rpb_type) {
#if defined(DEC_3000_500) || defined(DEC_3000_300) || \
    defined(DEC_2000_300) || defined(DEC_2100_A50)
#if defined(DEC_3000_500)
	case ST_DEC_3000_500:
#endif
#if defined(DEC_2000_300)
	case ST_DEC_2000_300:
#endif
#if defined(DEC_3000_300)
	case ST_DEC_3000_300:
#endif
#if defined(DEC_2100_A50)
	case ST_DEC_2100_A50:
#endif
		mcclock_attach(parent, self, aux);
		break;
#endif /* defined(at least one of lots of system types) */

	default:
		panic("clockattach: it didn't get here.  really.");
	}

d150 4
a153 1
	set_clockintr(hardclock);
d178 1
a178 1
	struct clock_softc *csc = (struct clock_softc *)clockcd.cd_devs[0];
d180 4
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

