head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.12
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.10
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.6
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.8
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.12.0.32
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.28
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.26
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.24
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.22
	OPENBSD_5_0:1.12.0.20
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.18
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.16
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.12
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.14
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.10
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.8
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.6
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.4
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.11.0.18
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.16
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.14
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.12
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.10
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.8
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.6
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.11
	UBC:1.8.0.6
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.5.0.18
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.16
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.14
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.12
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2014.05.08.20.46.49;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.25.21.33.19;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.02.22.56.06;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.26;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.08.21.48.43;	author art;	state Exp;
branches
	1.8.6.1;
next	1.7;

1.7
date	2000.11.08.19.16.58;	author ericj;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.08.16.00.59;	author art;	state Exp;
branches;
next	1.5;

1.5
date	97.01.24.19.56.24;	author niklas;	state Exp;
branches
	1.5.14.1;
next	1.4;

1.4
date	96.10.30.22.38.03;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.07.29.22.57.23;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.18.09.42.08;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.39;	author deraadt;	state Exp;
branches;
next	;

1.5.14.1
date	2001.04.18.16.00.14;	author niklas;	state Exp;
branches;
next	1.5.14.2;

1.5.14.2
date	2002.03.28.10.06.12;	author niklas;	state Exp;
branches;
next	1.5.14.3;

1.5.14.3
date	2003.03.27.23.18.05;	author niklas;	state Exp;
branches;
next	;

1.8.6.1
date	2002.06.11.03.33.39;	author art;	state Exp;
branches;
next	1.8.6.2;

1.8.6.2
date	2002.10.29.00.28.00;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Format string fixes for alpha kernels, and remove -Wno-format
@
text
@/* $OpenBSD: dec_3000_300.c,v 1.12 2006/11/28 16:56:50 dlg Exp $ */
/* $NetBSD: dec_3000_300.c,v 1.30 2000/05/22 20:13:32 thorpej Exp $ */

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 * Additional Copyright (c) 1997 by Matthew Jacob for NASA/Ames Research Center
 */


#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/termios.h>
#include <sys/conf.h>

#include <machine/rpb.h>
#include <machine/autoconf.h>
#include <machine/cpuconf.h>

#include <dev/tc/tcvar.h>
#include <dev/tc/tcdsvar.h>
#include <alpha/tc/tc_3000_300.h>
#ifndef NEW_SCC_DRIVER
#include <alpha/tc/sccvar.h>
#endif

#if 0
#include <machine/z8530var.h>
#include <dev/dec/zskbdvar.h>
#endif

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include "wsdisplay.h"

void dec_3000_300_init(void);
static void dec_3000_300_cons_init(void);
static void dec_3000_300_device_register(struct device *, void *);

const struct alpha_variation_table dec_3000_300_variations[] = {
	{ SV_ST_PELICAN, "DEC 3000/300 (\"Pelican\")" },
	{ SV_ST_PELICA, "DEC 3000/300L (\"Pelica\")" },
	{ SV_ST_PELICANPLUS, "DEC 3000/300X (\"Pelican+\")" },
	{ SV_ST_PELICAPLUS, "DEC 3000/300LX (\"Pelica+\")" },
	{ 0, NULL },
};

void
dec_3000_300_init()
{
	u_int64_t variation;

	platform.family = "DEC 3000/300 (\"Pelican\")";

	if ((platform.model = alpha_dsr_sysname()) == NULL) {
		variation = hwrpb->rpb_variation & SV_ST_MASK;
		if ((platform.model = alpha_variation_name(variation,
		    dec_3000_300_variations)) == NULL)
			platform.model = alpha_unknown_sysname();
	}

	platform.iobus = "tcasic";
	platform.cons_init = dec_3000_300_cons_init;
	platform.device_register = dec_3000_300_device_register;
}

static void
dec_3000_300_cons_init()
{
	struct ctb *ctb;

	ctb = (struct ctb *)(((caddr_t)hwrpb) + hwrpb->rpb_ctb_off);

#ifndef NEW_SCC_DRIVER
	switch (ctb->ctb_term_type) {
	case CTB_GRAPHICS:
#if 0
		alpha_donot_kludge_scc = 1;
#endif
		return;
	case CTB_PRINTERPORT:
		return;
	default:
		goto badconsole;
	}
#else
	switch (ctb->ctb_term_type) {
	case CTB_GRAPHICS:
#if NWSDISPLAY > 0
		/* display console ... */
		if (zs_ioasic_lk201_cnattach(0x1a0000000, 0x00180000, 0) == 0 &&
		    tc_3000_300_fb_cnattach(
		     CTB_TURBOSLOT_SLOT(ctb->ctb_turboslot)) == 0) {
			break;
		}
#endif
		printf("consinit: Unable to init console on keyboard and ");
		printf("TURBOchannel slot 0x%lx.\n", ctb->ctb_turboslot);
		printf("Using serial console.\n");
		/* FALLTHROUGH */

	case CTB_PRINTERPORT:
		/* serial console ... */
		/*
		 * XXX This could stand some cleanup...
		 */
		{
			/*
			 * Delay to allow PROM putchars to complete.
			 * FIFO depth * character time.
			 * character time = (1000000 / (defaultrate / 10))
			 */
			DELAY(160000000 / 9600);	/* XXX */

			/*
			 * Console is channel B of the first SCC.
			 * XXX Should use ctb_line_off to get the
			 * XXX line parameters.
			 */
			if (zs_ioasic_cnattach(0x1a0000000, 0x00100000, 1,
			    9600, (TTYDEF_CFLAG & ~(CSIZE | PARENB)) | CS8))
				panic("can't init serial console");
			break;
		}

	default:
		goto badconsole;
	}
#endif
	return;
badconsole:
	printf("ctb->ctb_term_type = 0x%lx\n",
	    (unsigned long)ctb->ctb_term_type);
	printf("ctb->ctb_turboslot = 0x%lx\n",
	    (unsigned long)ctb->ctb_turboslot);

	panic("consinit: unknown console type %lu",
	    (unsigned long)ctb->ctb_term_type);
}

static void
dec_3000_300_device_register(dev, aux)
	struct device *dev;
	void *aux;
{
	static int found, initted, scsiboot, netboot;
	static struct device *scsidev;
	static struct device *tcdsdev;
	struct bootdev_data *b = bootdev_data;
	struct device *parent = dev->dv_parent;
	struct cfdata *cf = dev->dv_cfdata;
	struct cfdriver *cd = cf->cf_driver;

	if (found)
		return;

	if (!initted) {
		scsiboot = (strcmp(b->protocol, "SCSI") == 0);
		netboot = (strcmp(b->protocol, "BOOTP") == 0) ||
		    (strcmp(b->protocol, "MOP") == 0);
#if 0
		printf("scsiboot = %d, netboot = %d\n", scsiboot, netboot);
#endif
		initted = 1;
	}

	/*
	 * for scsi boot, we look for "tcds", make sure it has the
	 * right slot number, then find the "asc" on this tcds that
	 * as the right channel.  then we find the actual scsi
	 * device we came from.  note: no SCSI LUN support (yet).
	 */
	if (scsiboot && (strcmp(cd->cd_name, "tcds") == 0)) {
		struct tc_attach_args *tcargs = aux;

		if (b->slot != tcargs->ta_slot)
			return;

		tcdsdev = dev;
#if 0
		printf("\ntcdsdev = %s\n", dev->dv_xname);
#endif
	}
	if (scsiboot && tcdsdev &&
	    (strcmp(cd->cd_name, "asc") == 0)) {
		struct tcdsdev_attach_args *ta = aux;

		if (parent != (struct device *)tcdsdev)
			return;

		if (ta->tcdsda_chip != b->channel)
			return;

		scsidev = dev;
#if 0
		printf("\nscsidev = %s\n", dev->dv_xname);
#endif
	}

	if (scsiboot && scsidev &&
	    (strcmp(cd->cd_name, "sd") == 0 ||
	     strcmp(cd->cd_name, "st") == 0 ||
	     strcmp(cd->cd_name, "cd") == 0)) {
		struct scsi_attach_args *sa = aux;

		if (parent->dv_parent != scsidev)
			return;

		if (b->unit / 100 != sa->sa_sc_link->target)
			return;

		/* XXX LUN! */

		switch (b->boot_dev_type) {
		case 0:
			if (strcmp(cd->cd_name, "sd") &&
			    strcmp(cd->cd_name, "cd"))
				return;
			break;
		case 1:
			if (strcmp(cd->cd_name, "st"))
				return;
			break;
		default:
			return;
		}

		/* we've found it! */
		booted_device = dev;
#if 0
		printf("\nbooted_device = %s\n", booted_device->dv_xname);
#endif
		found = 1;
	}

	if (netboot) {
                if (b->slot == 5 && strcmp(cd->cd_name, "le") == 0 &&
		    strcmp(parent->dv_cfdata->cf_driver->cd_name, "ioasic")
		     == 0) {
			/*
			 * no need to check ioasic_attach_args, since only
			 * one le on ioasic.
			 */

			booted_device = dev;
#if 0
			printf("\nbooted_device = %s\n", booted_device->dv_xname);
#endif
			found = 1;
			return;
		}

		/*
		 * XXX GENERIC SUPPORT FOR TC NETWORK BOARDS
		 */
        }
}
@


1.12
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dec_3000_300.c,v 1.11 2002/06/25 21:33:19 miod Exp $ */
d159 4
a162 2
	printf("ctb->ctb_term_type = 0x%lx\n", ctb->ctb_term_type);
	printf("ctb->ctb_turboslot = 0x%lx\n", ctb->ctb_turboslot);
d165 1
a165 1
	    ctb->ctb_term_type);
@


1.11
log
@No \n at the end of a panic() message... I thought all occurences had been
squashed already.
@
text
@d1 1
a1 1
/* $OpenBSD: dec_3000_300.c,v 1.10 2002/05/02 22:56:06 miod Exp $ */
d229 1
a229 1
		struct scsibus_attach_args *sa = aux;
@


1.10
log
@Big TURBOchannel support catchup from NetBSD, part 1.
A few local changes and tweaks remain.

This bring DEC 3000 machines back in the game, but framebuffers are still
not supported at the moment.

Thanks to ericj@@ and nate@@ for supplying me a DEC 3000 for testing.
@
text
@d1 1
a1 1
/* $OpenBSD: dec_3000_300.c,v 1.9 2002/03/14 01:26:26 millert Exp $ */
d162 1
a162 1
	panic("consinit: unknown console type %lu\n",
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: dec_3000_300.c,v 1.8 2000/11/08 21:48:43 art Exp $ */
d47 1
a47 1
#include <alpha/tc/tcdsvar.h>
d216 1
a216 1
		if (ta->tcdsda_slot != b->channel)
@


1.8
log
@no need to extern booted_device everywhere.
@
text
@d1 1
a1 1
/* $OpenBSD: dec_3000_300.c,v 1.7 2000/11/08 19:16:58 ericj Exp $ */
d63 3
a65 3
void dec_3000_300_init __P((void));
static void dec_3000_300_cons_init __P((void));
static void dec_3000_300_device_register __P((struct device *, void *));
@


1.8.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: dec_3000_300.c,v 1.8 2000/11/08 21:48:43 art Exp $ */
d47 1
a47 1
#include <dev/tc/tcdsvar.h>
d63 3
a65 3
void dec_3000_300_init(void);
static void dec_3000_300_cons_init(void);
static void dec_3000_300_device_register(struct device *, void *);
d216 1
a216 1
		if (ta->tcdsda_chip != b->channel)
@


1.8.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: dec_3000_300.c,v 1.8.6.1 2002/06/11 03:33:39 art Exp $ */
d162 1
a162 1
	panic("consinit: unknown console type %lu",
@


1.7
log
@add tags
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a177 1
	extern struct device *booted_device;
@


1.6
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
@


1.5
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 2
/*	$OpenBSD: dec_3000_300.c,v 1.4 1996/10/30 22:38:03 niklas Exp $	*/
/*	$NetBSD: dec_3000_300.c,v 1.10 1996/11/12 05:14:30 cgd Exp $	*/
d30 5
d38 3
a41 1

d46 5
d52 4
a55 1
#include <alpha/tc/tcdsvar.h>
d60 1
a60 4
char *dec_3000_300_modelname __P((void));
void dec_3000_300_cons_init __P((void));
const char *dec_3000_300_iobus_name __P((void));
void dec_3000_300_device_register __P((struct device *, void *));
d62 11
a72 1
cpu_decl(dec_3000_300);
d74 2
a75 2
const char *
dec_3000_300_model_name()
d77 1
d79 1
a79 3
	switch (hwrpb->rpb_variation & SV_ST_MASK) {
	case SV_ST_PELICAN:
		return "DEC 3000/300 (\"Pelican\")";
d81 11
a91 2
	case SV_ST_PELICA:
		return "DEC 3000/300L (\"Pelica\")";
d93 4
a96 2
	case SV_ST_PELICANPLUS:
		return "DEC 3000/300X (\"Pelican+\")";
d98 1
a98 2
	case SV_ST_PELICAPLUS:
		return "DEC 3000/300LX (\"Pelica+\")";
d100 9
d110 1
a110 3
		printf("unknown system variation %lx\n",
		    hwrpb->rpb_variation & SV_ST_MASK);
		return NULL;
d112 39
a150 1
}
d152 8
a159 4
void
dec_3000_300_cons_init()
{
}
d161 2
a162 4
const char *
dec_3000_300_iobus_name()
{
	return ("tcasic");
d165 1
a165 1
void
d172 1
d177 1
d184 2
a185 1
		netboot = (strcmp(b->protocol, "BOOTP") == 0);
d189 1
a189 1
		initted =1;
d192 11
a202 5
	if (scsiboot && (strcmp(cd->cd_name, "esp") == 0)) {
		if (b->slot == 4 &&
		    strcmp(parent->dv_cfdata->cf_driver->cd_name, "tcds")
		      == 0) {
			struct tcdsdev_attach_args *tcdsdev = aux;
d204 1
a204 2
			if (tcdsdev->tcdsda_slot == b->channel) {
				scsidev = dev;
d206 16
a221 1
				printf("\nscsidev = %s\n", dev->dv_xname);
a222 2
			}
		}
d225 1
a225 1
	if (scsiboot &&
a229 3

		if (scsidev == NULL)
			return;
@


1.5.14.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 2
/* $OpenBSD: dec_3000_300.c,v 1.8 2000/11/08 21:48:43 art Exp $ */
/* $NetBSD: dec_3000_300.c,v 1.30 2000/05/22 20:13:32 thorpej Exp $ */
a30 5
/*
 * Additional Copyright (c) 1997 by Matthew Jacob for NASA/Ames Research Center
 */


d34 1
a34 2
#include <sys/termios.h>
#include <sys/conf.h>
a35 1
#include <machine/rpb.h>
d40 1
a41 9
#include <alpha/tc/tc_3000_300.h>
#ifndef NEW_SCC_DRIVER
#include <alpha/tc/sccvar.h>
#endif

#if 0
#include <machine/z8530var.h>
#include <dev/dec/zskbdvar.h>
#endif
d46 4
a49 1
#include "wsdisplay.h"
d51 1
a51 11
void dec_3000_300_init __P((void));
static void dec_3000_300_cons_init __P((void));
static void dec_3000_300_device_register __P((struct device *, void *));

const struct alpha_variation_table dec_3000_300_variations[] = {
	{ SV_ST_PELICAN, "DEC 3000/300 (\"Pelican\")" },
	{ SV_ST_PELICA, "DEC 3000/300L (\"Pelica\")" },
	{ SV_ST_PELICANPLUS, "DEC 3000/300X (\"Pelican+\")" },
	{ SV_ST_PELICAPLUS, "DEC 3000/300LX (\"Pelica+\")" },
	{ 0, NULL },
};
d53 2
a54 2
void
dec_3000_300_init()
a55 1
	u_int64_t variation;
d57 3
a59 1
	platform.family = "DEC 3000/300 (\"Pelican\")";
d61 2
a62 11
	if ((platform.model = alpha_dsr_sysname()) == NULL) {
		variation = hwrpb->rpb_variation & SV_ST_MASK;
		if ((platform.model = alpha_variation_name(variation,
		    dec_3000_300_variations)) == NULL)
			platform.model = alpha_unknown_sysname();
	}

	platform.iobus = "tcasic";
	platform.cons_init = dec_3000_300_cons_init;
	platform.device_register = dec_3000_300_device_register;
}
d64 2
a65 4
static void
dec_3000_300_cons_init()
{
	struct ctb *ctb;
d67 2
a68 1
	ctb = (struct ctb *)(((caddr_t)hwrpb) + hwrpb->rpb_ctb_off);
a69 9
#ifndef NEW_SCC_DRIVER
	switch (ctb->ctb_term_type) {
	case CTB_GRAPHICS:
#if 0
		alpha_donot_kludge_scc = 1;
#endif
		return;
	case CTB_PRINTERPORT:
		return;
d71 3
a73 1
		goto badconsole;
d75 1
a75 39
#else
	switch (ctb->ctb_term_type) {
	case CTB_GRAPHICS:
#if NWSDISPLAY > 0
		/* display console ... */
		if (zs_ioasic_lk201_cnattach(0x1a0000000, 0x00180000, 0) == 0 &&
		    tc_3000_300_fb_cnattach(
		     CTB_TURBOSLOT_SLOT(ctb->ctb_turboslot)) == 0) {
			break;
		}
#endif
		printf("consinit: Unable to init console on keyboard and ");
		printf("TURBOchannel slot 0x%lx.\n", ctb->ctb_turboslot);
		printf("Using serial console.\n");
		/* FALLTHROUGH */

	case CTB_PRINTERPORT:
		/* serial console ... */
		/*
		 * XXX This could stand some cleanup...
		 */
		{
			/*
			 * Delay to allow PROM putchars to complete.
			 * FIFO depth * character time.
			 * character time = (1000000 / (defaultrate / 10))
			 */
			DELAY(160000000 / 9600);	/* XXX */

			/*
			 * Console is channel B of the first SCC.
			 * XXX Should use ctb_line_off to get the
			 * XXX line parameters.
			 */
			if (zs_ioasic_cnattach(0x1a0000000, 0x00100000, 1,
			    9600, (TTYDEF_CFLAG & ~(CSIZE | PARENB)) | CS8))
				panic("can't init serial console");
			break;
		}
d77 4
a80 8
	default:
		goto badconsole;
	}
#endif
	return;
badconsole:
	printf("ctb->ctb_term_type = 0x%lx\n", ctb->ctb_term_type);
	printf("ctb->ctb_turboslot = 0x%lx\n", ctb->ctb_turboslot);
d82 4
a85 2
	panic("consinit: unknown console type %lu\n",
	    ctb->ctb_term_type);
d88 1
a88 1
static void
a94 1
	static struct device *tcdsdev;
d105 1
a105 2
		netboot = (strcmp(b->protocol, "BOOTP") == 0) ||
		    (strcmp(b->protocol, "MOP") == 0);
d109 1
a109 1
		initted = 1;
d112 5
a116 11
	/*
	 * for scsi boot, we look for "tcds", make sure it has the
	 * right slot number, then find the "asc" on this tcds that
	 * as the right channel.  then we find the actual scsi
	 * device we came from.  note: no SCSI LUN support (yet).
	 */
	if (scsiboot && (strcmp(cd->cd_name, "tcds") == 0)) {
		struct tc_attach_args *tcargs = aux;

		if (b->slot != tcargs->ta_slot)
			return;
d118 2
a119 1
		tcdsdev = dev;
d121 1
a121 1
		printf("\ntcdsdev = %s\n", dev->dv_xname);
d123 2
a125 6
	if (scsiboot && tcdsdev &&
	    (strcmp(cd->cd_name, "asc") == 0)) {
		struct tcdsdev_attach_args *ta = aux;

		if (parent != (struct device *)tcdsdev)
			return;
d127 1
a127 10
		if (ta->tcdsda_slot != b->channel)
			return;

		scsidev = dev;
#if 0
		printf("\nscsidev = %s\n", dev->dv_xname);
#endif
	}

	if (scsiboot && scsidev &&
d132 3
@


1.5.14.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d63 3
a65 3
void dec_3000_300_init(void);
static void dec_3000_300_cons_init(void);
static void dec_3000_300_device_register(struct device *, void *);
@


1.5.14.3
log
@Sync the SMP branch with 3.3
@
text
@d47 1
a47 1
#include <dev/tc/tcdsvar.h>
d162 1
a162 1
	panic("consinit: unknown console type %lu",
d216 1
a216 1
		if (ta->tcdsda_chip != b->channel)
@


1.4
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 2
a2 2
/*	$OpenBSD: dec_3000_300.c,v 1.9 1996/10/13 02:59:30 christos Exp $	*/
/*	$NetBSD: dec_3000_300.c,v 1.9 1996/10/13 02:59:30 christos Exp $	*/
d37 1
d47 2
a48 1
void dec_3000_300_consinit __P((void));
d51 4
a54 2
char *
dec_3000_300_modelname()
d78 6
a83 1
dec_3000_300_consinit()
d85 1
@


1.3
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: dec_3000_300.c,v 1.2.6.2 1996/06/13 18:35:12 cgd Exp $	*/
/*	$NetBSD: dec_3000_300.c,v 1.2.6.2 1996/06/13 18:35:12 cgd Exp $	*/
d45 4
a75 1

d83 1
a83 1
	static int found;
d93 10
a102 1
	if (strcmp(cd->cd_name, "esp") == 0) {
d115 6
a120 3
	} else if (strcmp(cd->cd_name, "sd") == 0 ||
	    strcmp(cd->cd_name, "st") == 0 ||
	    strcmp(cd->cd_name, "cd") == 0) {
d155 22
@


1.2
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: dec_3000_300.c,v 1.2 1995/08/03 01:12:21 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1995 Carnegie-Mellon University.
d31 2
d35 9
d69 1
a69 2
dec_3000_300_consinit(constype)
	char *constype;
d74 4
a77 3
dev_t
dec_3000_300_bootdev(booted_dev)
	char *booted_dev;
d79 60
a138 2

	panic("gack.");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
