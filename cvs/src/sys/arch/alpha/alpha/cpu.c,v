head	1.42;
access;
symbols
	OPENBSD_6_1:1.42.0.4
	OPENBSD_6_1_BASE:1.42
	OPENBSD_6_0:1.40.0.2
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.38.0.6
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.38.0.2
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.36.0.4
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.29.0.6
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.4
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.2
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.6
	OPENBSD_5_0:1.28.0.4
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.23.0.4
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.22.0.4
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.21.0.8
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.6
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.4
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.19.0.8
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.6
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.14
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.6.0.18
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.16
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.14
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.12
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.10
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.8
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.42
date	2016.10.27.09.46.14;	author dlg;	state Exp;
branches;
next	1.41;
commitid	pikxHZmh7a04C6zx;

1.41
date	2016.10.27.05.36.35;	author dlg;	state Exp;
branches;
next	1.40;
commitid	0pXwPBepwc9f2wUl;

1.40
date	2016.05.15.23.37.42;	author guenther;	state Exp;
branches;
next	1.39;
commitid	Hg9xYq6uyjPNjU8k;

1.39
date	2015.08.15.19.04.31;	author miod;	state Exp;
branches;
next	1.38;
commitid	4f2Fz7pQCTWJYfIy;

1.38
date	2015.01.04.18.52.46;	author miod;	state Exp;
branches;
next	1.37;
commitid	VTLl5NL5JZAbozMz;

1.37
date	2014.12.17.15.23.40;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	m1QU4zfUVMSJqLJo;

1.36
date	2014.05.08.20.46.49;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2014.03.29.18.09.28;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2014.02.03.18.42.05;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2014.02.01.21.17.32;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2014.01.26.17.40.09;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2014.01.19.12.45.35;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2013.12.22.18.53.14;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2012.07.09.09.07.25;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2010.11.28.20.57.09;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2010.03.31.19.46.25;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2010.02.20.12.39.41;	author sobrado;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.02.17.55.52;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2009.08.11.18.43.33;	author blambert;	state Exp;
branches;
next	1.23;

1.23
date	2009.04.14.16.01.04;	author oga;	state Exp;
branches;
next	1.22;

1.22
date	2008.06.26.05.42.08;	author ray;	state Exp;
branches;
next	1.21;

1.21
date	2006.08.17.22.22.08;	author mk;	state Exp;
branches;
next	1.20;

1.20
date	2006.08.13.13.38.17;	author mk;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.13.21.49.11;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	2004.06.08.20.13.21;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.13.06.21.09;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.22.19.59.37;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2003.05.11.19.41.08;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.10.07.18.35.56;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2002.10.06.22.06.15;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.26.26;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.06.19.53.13;	author miod;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.04.15.05.54.39;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.20.20.25.22;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.08.19.16.58;	author ericj;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.08.16.00.56;	author art;	state Exp;
branches;
next	1.6;

1.6
date	97.01.24.19.56.20;	author niklas;	state Exp;
branches
	1.6.14.1;
next	1.5;

1.5
date	96.10.30.22.38.01;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.07.29.22.57.18;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.06.18.09.42.06;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.52.32;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.39;	author deraadt;	state Exp;
branches;
next	;

1.6.14.1
date	2001.04.18.16.00.09;	author niklas;	state Exp;
branches;
next	1.6.14.2;

1.6.14.2
date	2001.11.13.21.00.48;	author niklas;	state Exp;
branches;
next	1.6.14.3;

1.6.14.3
date	2002.03.12.11.54.17;	author ho;	state Exp;
branches;
next	1.6.14.4;

1.6.14.4
date	2002.03.28.10.06.12;	author niklas;	state Exp;
branches;
next	1.6.14.5;

1.6.14.5
date	2003.05.13.19.41.02;	author ho;	state Exp;
branches;
next	1.6.14.6;

1.6.14.6
date	2004.02.19.09.59.33;	author niklas;	state Exp;
branches;
next	1.6.14.7;

1.6.14.7
date	2004.06.08.21.07.17;	author niklas;	state Exp;
branches;
next	;

1.11.2.1
date	2002.06.11.03.33.39;	author art;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.10.29.00.28.00;	author art;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2003.05.19.21.38.52;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.42
log
@revert 1.41 now that subr_percpu is using ncpusfound instead of ncpus.
@
text
@/* $OpenBSD: cpu.c,v 1.40 2016/05/15 23:37:42 guenther Exp $ */
/* $NetBSD: cpu.c,v 1.44 2000/05/23 05:12:53 thorpej Exp $ */

/*-
 * Copyright (c) 1998, 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1994, 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */


#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <dev/rndvar.h>

#include <uvm/uvm_extern.h>

#include <machine/atomic.h>
#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/rpb.h>
#include <machine/prom.h>

struct cpu_info cpu_info_primary;
struct cpu_info *cpu_info_list = &cpu_info_primary;

#if defined(MULTIPROCESSOR)
#include <sys/malloc.h>

/*
 * Array of CPU info structures.  Must be statically-allocated because
 * curproc, etc. are used early.
 */
struct cpu_info *cpu_info[ALPHA_MAXPROCS];

/* Bitmask of CPUs booted, currently running, and paused. */
volatile u_long cpus_booted;
volatile u_long cpus_running;
volatile u_long cpus_paused;

void	cpu_boot_secondary(struct cpu_info *);
#endif /* MULTIPROCESSOR */

/*
 * The Implementation Version and the Architecture Mask must be
 * consistent across all CPUs in the system, so we set it for the
 * primary and announce the AMASK extensions if they exist.
 *
 * Note, we invert the AMASK so that if a bit is set, it means "has
 * extension".
 */
u_long	cpu_implver, cpu_amask;

/* Definition of the driver for autoconfig. */
int	cpumatch(struct device *, void *, void *);
void	cpuattach(struct device *, struct device *, void *);

struct cfattach cpu_ca = {
	sizeof(struct device), cpumatch, cpuattach
};

struct cfdriver cpu_cd = {
	NULL, "cpu", DV_DULL
};

void	cpu_announce_extensions(struct cpu_info *);

static const char *ev4minor[] = {
	"pass 2 or 2.1", "pass 3", 0
}, *lcaminor[] = {
	"",
	"21066 pass 1 or 1.1", "21066 pass 2",
	"21068 pass 1 or 1.1", "21068 pass 2",
	"21066A pass 1", "21068A pass 1", 0
}, *ev5minor[] = {
	"", "pass 2, rev BA or 2.2, rev CA", "pass 2.3, rev DA or EA",
	"pass 3", "pass 3.2", "pass 4", 0
}, *ev45minor[] = {
	"", "pass 1", "pass 1.1", "pass 2", 0
}, *ev56minor[] = {
	"", "pass 1", "pass 2", 0
}, *ev6minor[] = {
	"", "pass 1", "pass 2 or 2.1", "pass 2.2", "pass 2.3", "pass 3",
	"pass 2.4", "pass 2.5", 0
}, *pca56minor[] = {
	"", "pass 1", 0
}, *pca57minor[] = {
	"", "pass 1", 0
}, *ev67minor[] = {
	"", "pass 1", "pass 2.1", "pass 2.2", "pass 2.1.1",
	"pass 2.2.1", "pass 2.3 or 2.4", "pass 2.1.2", "pass 2.2.2",
	"pass 2.2.3 or 2.2.5", "pass 2.2.4", "pass 2.5", "pass 2.4.1",
	"pass 2.5.1", "pass 2.6", 0
}, *ev68cbminor[] = {
	/* what is the value for pass 2.3? */
	"", "", "", "", "",
	"pass 2.4", "pass 4.0", 0
};

struct cputable_struct {
	int	cpu_major_code;
	const char *cpu_major_name;
	const char **cpu_minor_names;
} cpunametable[] = {
	{ PCS_PROC_EV3,		"EV3",		0		},
	{ PCS_PROC_EV4,		"21064",	ev4minor	},
	{ PCS_PROC_SIMULATION,	"Sim",		0		},
	{ PCS_PROC_LCA4,	"LCA",		lcaminor	},
	{ PCS_PROC_EV5,		"21164",	ev5minor	},
	{ PCS_PROC_EV45,	"21064A",	ev45minor	},
	{ PCS_PROC_EV56,	"21164A",	ev56minor	},
	{ PCS_PROC_EV6,		"21264",	ev6minor	},
	{ PCS_PROC_PCA56,	"PCA56",	pca56minor	},
	{ PCS_PROC_PCA57,	"PCA57",	pca57minor	},
	{ PCS_PROC_EV67,	"21264A",	ev67minor	},
	{ PCS_PROC_EV68CB,	"21264C",	ev68cbminor	},
	{ PCS_PROC_EV68AL,	"21264B",	NULL		},
	{ PCS_PROC_EV68CX,	"21264D",	NULL		},
};

/*
 * The following is an attempt to map out how booting secondary CPUs
 * works.
 *
 * As we find processors during the autoconfiguration sequence, all
 * processors have idle stacks and PCBs created for them, including
 * the primary (although the primary idles on proc0's PCB until its
 * idle PCB is created).
 *
 * As one of the last steps in booting, main() calls, on proc0's
 * context, cpu_boot_secondary_processors().  This is our key to
 * actually spin up the additional processors we've found.  We
 * run through our cpu_info[] array looking for secondary processors
 * with idle PCBs, and spin them up.
 *
 * The spinup involves switching the secondary processor to the
 * OSF/1 PALcode, setting the entry point to cpu_spinup_trampoline(),
 * and sending a "START" message to the secondary's console.
 *
 * Upon successful processor bootup, the cpu_spinup_trampoline will call
 * cpu_hatch(), which will print a message indicating that the processor
 * is running, and will set the "hatched" flag in its softc.  At the end
 * of cpu_hatch() is a spin-forever loop; we do not yet attempt to schedule
 * anything on secondary CPUs.
 */

int
cpumatch(struct device *parent, void *cfdata, void *aux)
{
	struct mainbus_attach_args *ma = aux;

	/* make sure that we're looking for a CPU. */
	if (strcmp(ma->ma_name, cpu_cd.cd_name) != 0)
		return (0);

#ifndef MULTIPROCESSOR
	/* Only attach the boot processor. */
	if (ma->ma_slot != hwrpb->rpb_primary_cpu_id)
		return (0);
#endif

	return (1);
}

void
cpuattach(struct device *parent, struct device *dev, void *aux)
{
	struct mainbus_attach_args *ma = aux;
	struct cpu_info *ci;
	int i;
	const char **s;
	struct pcs *p;
#ifdef DEBUG
	int needcomma;
#endif
	u_int32_t major, minor;
#if defined(MULTIPROCESSOR)
	extern paddr_t avail_start, avail_end;
	struct pcb *pcb;
	struct pglist mlist;
	int error;
#endif

	p = LOCATE_PCS(hwrpb, ma->ma_slot);
	major = PCS_CPU_MAJORTYPE(p);
	minor = PCS_CPU_MINORTYPE(p);

	printf(": ID %d%s, ", ma->ma_slot,
	    ma->ma_slot == hwrpb->rpb_primary_cpu_id ? " (primary)" : "");

	for (i = 0; i < sizeof cpunametable / sizeof cpunametable[0]; ++i) {
		if (cpunametable[i].cpu_major_code == major) {
			printf("%s-%d", cpunametable[i].cpu_major_name, minor);
			s = cpunametable[i].cpu_minor_names;
			for (i = 0; s && s[i]; ++i) {
				if (i == minor && strlen(s[i]) != 0) {
					printf(" (%s)", s[i]);
					goto recognized;
				}
			}
			printf(" (unknown minor type %d)", minor);
			goto recognized;
		}
	}
	printf("UNKNOWN CPU TYPE (%d:%d)", major, minor);

recognized:
	printf("\n");

#ifdef DEBUG
	if (p->pcs_proc_var != 0) {
		printf("%s: ", dev->dv_xname);

		needcomma = 0;
		if (p->pcs_proc_var & PCS_VAR_VAXFP) {
			printf("VAX FP support");
			needcomma = 1;
		}
		if (p->pcs_proc_var & PCS_VAR_IEEEFP) {
			printf("%sIEEE FP support", needcomma ? ", " : "");
			needcomma = 1;
		}
		if (p->pcs_proc_var & PCS_VAR_PE) {
			printf("%sPrimary Eligible", needcomma ? ", " : "");
			needcomma = 1;
		}
		if (p->pcs_proc_var & PCS_VAR_RESERVED)
			printf("%sreserved bits: 0x%lx", needcomma ? ", " : "",
			    p->pcs_proc_var & PCS_VAR_RESERVED);
		printf("\n");
	}
#endif

#if defined(MULTIPROCESSOR)
	if (ma->ma_slot > ALPHA_WHAMI_MAXID) {
		printf("%s: processor ID too large, ignoring\n", dev->dv_xname);
		return;
	}
#endif /* MULTIPROCESSOR */

#if defined(MULTIPROCESSOR)
	if (ma->ma_slot == hwrpb->rpb_primary_cpu_id)
		ci = &cpu_info_primary;
	else
		ci = malloc(sizeof(*ci), M_DEVBUF, M_WAITOK | M_ZERO);

	cpu_info[ma->ma_slot] = ci;
#else
	ci = &cpu_info_primary;
#endif
	ci->ci_cpuid = ma->ma_slot;
	ci->ci_dev = dev;

#if defined(MULTIPROCESSOR)
	/*
	 * Make sure the processor is available for use.
	 */
	if ((p->pcs_flags & PCS_PA) == 0) {
		if (ma->ma_slot == hwrpb->rpb_primary_cpu_id)
			panic("cpu_attach: primary not available?!");
		printf("%s: processor not available for use\n", dev->dv_xname);
		return;
	}

	/* Make sure the processor has valid PALcode. */
	if ((p->pcs_flags & PCS_PV) == 0) {
		if (ma->ma_slot == hwrpb->rpb_primary_cpu_id)
			panic("cpu_attach: primary has invalid PALcode?!");
		printf("%s: PALcode not valid\n", ci->ci_dev->dv_xname);
		return;
	}

	/*
	 * Allocate UPAGES contiguous pages for the idle PCB and stack.
	 */
	TAILQ_INIT(&mlist);
	error = uvm_pglistalloc(USPACE, avail_start, avail_end - 1, 0, 0,
	    &mlist, 1, UVM_PLA_WAITOK);
	if (error != 0) {
		if (ma->ma_slot == hwrpb->rpb_primary_cpu_id) {
			panic("cpu_attach: unable to allocate idle stack for"
			    " primary");
		}
		printf("%s: unable to allocate idle stack\n", dev->dv_xname);
		return;
	}

	ci->ci_idle_pcb_paddr = VM_PAGE_TO_PHYS(TAILQ_FIRST(&mlist));
	pcb = ci->ci_idle_pcb = (struct pcb *)
	    ALPHA_PHYS_TO_K0SEG(ci->ci_idle_pcb_paddr);
	memset(pcb, 0, USPACE);

	/*
	 * Initialize the idle stack pointer, reserving space for an
	 * (empty) trapframe (XXX is the trapframe really necessary?)
	 */
	pcb->pcb_hw.apcb_ksp =
	    (u_int64_t)pcb + USPACE - sizeof(struct trapframe);

	/*
	 * Initialize the idle PCB.
	 */
	pcb->pcb_hw.apcb_asn = proc0.p_addr->u_pcb.pcb_hw.apcb_asn;
	pcb->pcb_hw.apcb_ptbr = proc0.p_addr->u_pcb.pcb_hw.apcb_ptbr;
#if 0
	printf("%s: hwpcb ksp = 0x%lx\n", dev->dv_xname,
	    pcb->pcb_hw.apcb_ksp);
	printf("%s: hwpcb ptbr = 0x%lx\n", dev->dv_xname,
	    pcb->pcb_hw.apcb_ptbr);
#endif
#endif /* MULTIPROCESSOR */

	/*
	 * If we're the primary CPU, no more work to do; we're already
	 * running!
	 */
	if (ma->ma_slot == hwrpb->rpb_primary_cpu_id) {
		cpu_announce_extensions(ci);
#if defined(MULTIPROCESSOR)
		ci->ci_flags |= CPUF_PRIMARY | CPUF_RUNNING;
		atomic_setbits_ulong(&cpus_booted, (1UL << ma->ma_slot));
		atomic_setbits_ulong(&cpus_running, (1UL << ma->ma_slot));
#endif /* MULTIPROCESSOR */
	} else {
#if defined(MULTIPROCESSOR)
		/*
		 * Boot the secondary processor.  It will announce its
		 * extensions, and then spin up until we tell it to go
		 * on its merry way.
		 */
		cpu_boot_secondary(ci);
#endif /* MULTIPROCESSOR */
	}
}

void
cpu_announce_extensions(struct cpu_info *ci)
{
	u_long implver, amask = 0;

	implver = alpha_implver();
	if (implver >= ALPHA_IMPLVER_EV5)
		amask = (~alpha_amask(ALPHA_AMASK_ALL)) & ALPHA_AMASK_ALL;

	if (ci->ci_cpuid == hwrpb->rpb_primary_cpu_id) {
		cpu_implver = implver;
		cpu_amask = amask;
	} else {
		if (implver < cpu_implver)
			printf("%s: WARNING: IMPLVER %lu < %lu\n",
			    ci->ci_dev->dv_xname, implver, cpu_implver);

		/*
		 * Cap the system architecture mask to the intersection
		 * of features supported by all processors in the system.
		 */
		cpu_amask &= amask;
	}

	if (amask) {
		printf("%s: architecture extensions: %lb\n",
		    ci->ci_dev->dv_xname, amask, ALPHA_AMASK_BITS);
	}
}

#if defined(MULTIPROCESSOR)
void
cpu_boot_secondary_processors(void)
{
	struct cpu_info *ci;
	u_long i;

	for (i = 0; i < ALPHA_MAXPROCS; i++) {
		ci = cpu_info[i];
		if (ci == NULL || ci->ci_idle_pcb == NULL)
			continue;
		if (ci->ci_flags & CPUF_PRIMARY)
			continue;
		if ((cpus_booted & (1UL << i)) == 0)
			continue;

		/*
		 * Link the processor into the list, and launch it.
		 */
		ci->ci_next = cpu_info_list->ci_next;
		cpu_info_list->ci_next = ci;
		atomic_setbits_ulong(&ci->ci_flags, CPUF_RUNNING);
		atomic_setbits_ulong(&cpus_running, (1UL << i));
		ncpus++;
	}

	/*
	 * Reset the HWRPB to prevent processors resetting from
	 * running through the hatching code again.
	 */
	hwrpb->rpb_restart = (u_int64_t) cpu_halt;
	hwrpb->rpb_checksum = hwrpb_checksum();
}

void
cpu_boot_secondary(struct cpu_info *ci)
{
	long timeout;
	struct pcs *pcsp, *primary_pcsp;
	struct pcb *pcb;
	u_long cpumask;

	pcb = ci->ci_idle_pcb;
	primary_pcsp = LOCATE_PCS(hwrpb, hwrpb->rpb_primary_cpu_id);
	pcsp = LOCATE_PCS(hwrpb, ci->ci_cpuid);
	cpumask = (1UL << ci->ci_cpuid);

	/*
	 * Set up the PCS's HWPCB to match ours.
	 */
	memcpy(pcsp->pcs_hwpcb, &pcb->pcb_hw, sizeof(pcb->pcb_hw));

	/*
	 * Set up the HWRPB to restart the secondary processor
	 * with our spin-up trampoline.
	 */
	hwrpb->rpb_restart = (u_int64_t) cpu_spinup_trampoline;
	hwrpb->rpb_restart_val = (u_int64_t) ci;
	hwrpb->rpb_checksum = hwrpb_checksum();

	/*
	 * Configure the CPU to start in OSF/1 PALcode by copying
	 * the primary CPU's PALcode revision info to the secondary
	 * CPUs PCS.
	 */
	memcpy(&pcsp->pcs_pal_rev, &primary_pcsp->pcs_pal_rev,
	    sizeof(pcsp->pcs_pal_rev));
	pcsp->pcs_flags |= (PCS_CV|PCS_RC);
	pcsp->pcs_flags &= ~PCS_BIP;

	/* Make sure the secondary console sees all this. */
	alpha_mb();

	/* Send a "START" command to the secondary CPU's console. */
	if (cpu_iccb_send(ci->ci_cpuid, "START\r\n")) {
		printf("%s: unable to issue `START' command\n",
		    ci->ci_dev->dv_xname);
		return;
	}

	/* Wait for the processor to boot. */
	for (timeout = 10000; timeout != 0; timeout--) {
		alpha_mb();
		if (pcsp->pcs_flags & PCS_BIP)
			break;
		delay(1000);
	}
	if (timeout == 0)
		printf("%s: processor failed to boot\n", ci->ci_dev->dv_xname);

	/*
	 * ...and now wait for verification that it's running kernel
	 * code.
	 */
	for (timeout = 10000; timeout != 0; timeout--) {
		alpha_mb();
		if (cpus_booted & cpumask)
			break;
		delay(1000);
	}
	if (timeout == 0)
		printf("%s: processor failed to hatch\n", ci->ci_dev->dv_xname);
}

void
cpu_pause_resume(u_long cpu_id, int pause)
{
	u_long cpu_mask = (1UL << cpu_id);

	if (pause) {
		atomic_setbits_ulong(&cpus_paused, cpu_mask);
		alpha_send_ipi(cpu_id, ALPHA_IPI_PAUSE);
	} else
		atomic_clearbits_ulong(&cpus_paused, cpu_mask);
}

void
cpu_pause_resume_all(int pause)
{
	struct cpu_info *ci, *self = curcpu();
	CPU_INFO_ITERATOR cii;

	CPU_INFO_FOREACH(cii, ci) {
		if (ci == self)
			continue;
		cpu_pause_resume(ci->ci_cpuid, pause);
	}
}

void
cpu_halt(void)
{
	struct cpu_info *ci = curcpu();
	u_long cpu_id = cpu_number();
	struct pcs *pcsp = LOCATE_PCS(hwrpb, cpu_id);

	printf("%s: shutting down...\n", ci->ci_dev->dv_xname);

	pcsp->pcs_flags &= ~(PCS_RC | PCS_HALT_REQ);
	pcsp->pcs_flags |= PCS_HALT_STAY_HALTED;

	atomic_clearbits_ulong(&cpus_running, (1UL << cpu_id));
	atomic_clearbits_ulong(&cpus_booted, (1U << cpu_id));

	alpha_pal_halt();
	/* NOTREACHED */
}

void
cpu_hatch(struct cpu_info *ci)
{
	u_long cpu_id = cpu_number();
	u_long cpumask = (1UL << cpu_id);
	int s;

	/* Mark the kernel pmap active on this processor. */
	atomic_setbits_ulong(&pmap_kernel()->pm_cpus, cpumask);

	/* Initialize trap vectors for this processor. */
	trap_init();

	/* Yahoo!  We're running kernel code!  Announce it! */
	cpu_announce_extensions(ci);

	atomic_setbits_ulong(&cpus_booted, cpumask);

	/*
	 * Spin here until we're told we can start.
	 */
	while ((cpus_running & cpumask) == 0)
		/* spin */ ;

	/*
	 * Invalidate the TLB and sync the I-stream before we
	 * jump into the kernel proper.  We have to do this
	 * because we haven't been getting IPIs while we've
	 * been spinning.
	 */
	ALPHA_TBIA();
	alpha_pal_imb();

	KERNEL_LOCK();
	sched_init_cpu(ci);
	nanouptime(&ci->ci_schedstate.spc_runtime);
	ci->ci_curproc = ci->ci_fpcurproc = NULL;
	ci->ci_randseed = (arc4random() & 0x7fffffff) + 1;
	KERNEL_UNLOCK();

	(void) alpha_pal_swpipl(ALPHA_PSL_IPL_0);
	SCHED_LOCK(s);
	cpu_switchto(NULL, sched_chooseproc());
	/* NOTREACHED */
}

int
cpu_iccb_send(cpuid_t cpu_id, const char *msg)
{
	struct pcs *pcsp = LOCATE_PCS(hwrpb, cpu_id);
	int timeout;
	u_long cpumask = (1UL << cpu_id);

	/* Wait for the ICCB to become available. */
	for (timeout = 10000; timeout != 0; timeout--) {
		alpha_mb();
		if ((hwrpb->rpb_rxrdy & cpumask) == 0)
			break;
		delay(1000);
	}
	if (timeout == 0)
		return (EIO);

	/*
	 * Copy the message into the ICCB, and tell the secondary console
	 * that it's there.  The atomic operation performs a memory barrier.
	 */
	strlcpy(pcsp->pcs_iccb.iccb_rxbuf, msg,
	    sizeof pcsp->pcs_iccb.iccb_rxbuf);
	pcsp->pcs_iccb.iccb_rxlen = strlen(msg);
	/* XXX cast to volatile */
	atomic_setbits_ulong((volatile u_long *)&hwrpb->rpb_rxrdy, cpumask);
	alpha_mb();

	/* Wait for the message to be received. */
	for (timeout = 10000; timeout != 0; timeout--) {
		alpha_mb();
		if ((hwrpb->rpb_rxrdy & cpumask) == 0)
			break;
		delay(1000);
	}
	if (timeout == 0)
		return (EIO);

	return (0);
}

void
cpu_iccb_receive(void)
{
#if 0	/* Don't bother... we don't get any important messages anyhow. */
	u_int64_t txrdy;
	char *cp1, *cp2, buf[80];
	struct pcs *pcsp;
	u_int cnt;
	cpuid_t cpu_id;

	txrdy = hwrpb->rpb_txrdy;

	for (cpu_id = 0; cpu_id < hwrpb->rpb_pcs_cnt; cpu_id++) {
		if (txrdy & (1UL << cpu_id)) {
			pcsp = LOCATE_PCS(hwrpb, cpu_id);
			printf("Inter-console message from CPU %lu "
			    "HALT REASON = 0x%lx, FLAGS = 0x%lx\n",
			    cpu_id, pcsp->pcs_halt_reason, pcsp->pcs_flags);
			
			cnt = pcsp->pcs_iccb.iccb_txlen;
			if (cnt >= 80) {
				printf("Malformed inter-console message\n");
				continue;
			}
			cp1 = pcsp->pcs_iccb.iccb_txbuf;
			cp2 = buf;
			while (cnt--) {
				if (*cp1 != '\r' && *cp1 != '\n')
					*cp2++ = *cp1;
				cp1++;
			}
			*cp2 = '\0';
			printf("Message from CPU %lu: %s\n", cpu_id, buf);
		}
	}
#endif /* 0 */
	hwrpb->rpb_txrdy = 0;
	alpha_mb();
}

void
cpu_unidle(struct cpu_info *ci)
{
	if (ci != curcpu())
		alpha_send_ipi(ci->ci_cpuid, ALPHA_IPI_AST);
}
#endif /* MULTIPROCESSOR */
@


1.41
log
@increment ncpus when a cpu is attached, not when its booted.

fixes percpu allocations, like visa@@ just did on mips64.
@
text
@d297 1
a297 1
	else {
a298 2
		ncpus++;
	}
d442 1
@


1.40
log
@Implement TCB_{GET,SET} using PAL_{rd,wr}unique.
Inline asm from NetBSD

testing deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.39 2015/08/15 19:04:31 miod Exp $ */
d297 1
a297 1
	else
d299 2
a443 1
		ncpus++;
@


1.39
log
@When resetting the hwrpb after a succesfull secondary processor spinup,
make its start routine point to cpu_halt, just in case.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.38 2015/01/04 18:52:46 miod Exp $ */
d350 1
a350 1
	pcb->pcb_hw.apcb_ksp = pcb->pcb_hw.apcb_backup_ksp =
@


1.38
log
@EV68CB pass 2.4 is numeric revision 5, as reported by SRM.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.37 2014/12/17 15:23:40 deraadt Exp $ */
d449 1
a449 1
	hwrpb->rpb_restart = 0;
a550 1
#if 0
a551 1
#endif
a554 1
#if 0
a555 1
#endif
@


1.37
log
@remove simplelocks
ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.36 2014/05/08 20:46:49 miod Exp $ */
d148 3
a150 3
	/* what are the values for pass 2.3 and pass 2.4? */
	"", "", "", "", "", "",
	"pass 4.0", 0
@


1.36
log
@Format string fixes for alpha kernels, and remove -Wno-format
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.35 2014/03/29 18:09:28 guenther Exp $ */
a300 1
	simple_lock_init(&ci->ci_slock);
@


1.35
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.34 2014/02/03 18:42:05 miod Exp $ */
d415 1
a415 1
		printf("%s: architecture extensions: %b\n",
@


1.34
log
@Make sure sched_init_cpu() on the secondary processors is invoked with the
kernel lock held.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.33 2014/02/01 21:17:32 miod Exp $ */
d90 3
a92 3
__volatile u_long cpus_booted;
__volatile u_long cpus_running;
__volatile u_long cpus_paused;
d642 2
a643 2
	/* XXX cast to __volatile */
	atomic_setbits_ulong((__volatile u_long *)&hwrpb->rpb_rxrdy, cpumask);
@


1.33
log
@Reset the hwrpb cpu start address after booting the secondaries, in order to
give dire kernel panics a better chance to reach the SRM.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.32 2014/01/26 17:40:09 miod Exp $ */
d605 1
d610 1
@


1.32
log
@Work in progress work towards SMP, heavily based upon NetBSD. The MP kernel
will boot multiuser, but will deadlock under load, and I can't find my
mistake yet.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.31 2014/01/19 12:45:35 deraadt Exp $ */
d445 7
@


1.31
log
@Initialize ci_randseed better using arc4random() + a trick.  Remove the
libkern srandom() API since it is not suitable for this use.
ok kettenis miod
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.30 2013/12/22 18:53:14 miod Exp $ */
d77 3
a81 1
#include <sys/kthread.h>
d87 1
a87 1
struct cpu_info cpu_info[ALPHA_MAXPROCS];
d89 2
a90 1
/* Bitmask of CPUs currently running. */
d92 1
a94 2
#else /* MULTIPROCESSOR */
struct cpu_info cpu_info_store;
d119 2
a152 1

d201 1
a201 4
cpumatch(parent, cfdata, aux)
	struct device *parent;
	void *cfdata;
	void *aux;
d219 1
a219 4
cpuattach(parent, dev, aux)
	struct device *parent;
	struct device *dev;
	void *aux;
d222 1
a232 1
	struct cpu_info *ci;
a262 11
	if (ma->ma_slot == hwrpb->rpb_primary_cpu_id) {
		cpu_implver = alpha_implver();
		if (cpu_implver >= ALPHA_IMPLVER_EV5)
			cpu_amask =
			    (~alpha_amask(ALPHA_AMASK_ALL)) & ALPHA_AMASK_ALL;
		if (cpu_amask) {
			printf("%s: architecture extensions: %b\n",
			    dev->dv_xname, cpu_amask, ALPHA_AMASK_BITS);
		}
	}

d292 1
d294 7
a300 1
	ci = &cpu_info[ma->ma_slot];
d302 3
a306 8
#endif /* MULTIPROCESSOR */

	/*
	 * Though we could (should?) attach the LCA cpus' PCI
	 * bus here there is no good reason to do so, and
	 * the bus attachment code is easier to understand
	 * and more compact if done the 'normal' way.
	 */
d351 1
a351 1
	pcb->pcb_hw.apcb_ksp =
a356 1
	pcb->pcb_hw.apcb_backup_ksp = pcb->pcb_hw.apcb_ksp;
d360 1
a360 1
	printf("%s: hwpcb ksp = 0x%lx\n", sc->sc_dev.dv_xname,
d362 1
a362 1
	printf("%s: hwpcb ptbr = 0x%lx\n", sc->sc_dev.dv_xname,
d365 1
d372 4
a375 1
		ci->ci_flags |= CPUF_PRIMARY;
d377 40
a417 1
#endif /* MULTIPROCESSOR */
d422 1
a422 1
cpu_boot_secondary_processors()
d428 2
a429 2
		ci = &cpu_info[i];
		if (ci->ci_idle_pcb == NULL)
d433 2
a434 1
		ci->ci_randseed = (arc4random() & 0x7fffffff) + 1;
d436 8
a443 2
		/* This processor is all set up; boot it! */
		cpu_boot_secondary(ci);
d448 1
a448 2
cpu_boot_secondary(ci)
	struct cpu_info *ci;
a477 1

a479 1

d509 1
a509 1
		if (cpus_running & cpumask)
d518 1
a518 2
cpu_halt_secondary(cpu_id)
	u_long cpu_id;
d520 21
a540 2
	long timeout;
	u_long cpumask = (1UL << cpu_id);
d542 5
a546 4
#ifdef DIAGNOSTIC
	if (cpu_id >= hwrpb->rpb_pcs_cnt ||
	    cpu_info[cpu_id].ci_dev == NULL)
		panic("cpu_halt_secondary: bogus cpu_id");
d548 2
d551 3
a553 5
	alpha_mb();
	if ((cpus_running & cpumask) == 0) {
		/* Processor not running. */
		return;
	}
d555 2
a556 2
	/* Send the HALT IPI to the secondary. */
	alpha_send_ipi(cpu_id, ALPHA_IPI_HALT);
d558 2
a559 7
	/* ...and wait for it to shut down. */
	for (timeout = 10000; timeout != 0; timeout--) {
		alpha_mb();
		if ((cpus_running & cpumask) == 0)
			return;
		delay(1000);
	}
d561 2
a562 3
	/* Erk, secondary failed to halt. */
	printf("WARNING: %s (ID %lu) failed to halt\n",
	    cpu_info[cpu_id].ci_dev->dv_xname, cpu_id);
d566 1
a566 2
cpu_hatch(ci)
	struct cpu_info *ci;
d568 3
a570 4
	u_long cpumask = (1UL << ci->ci_cpuid);

	/* Set our `curpcb' to reflect our context. */
	curpcb = ci->ci_idle_pcb_paddr;
d579 9
a587 3
	printf("%s: processor ID %lu running\n", ci->ci_dev->dv_xname,
	    alpha_pal_whami());
	atomic_setbits_ulong(&cpus_running, cpumask);
d590 4
a593 4
	 * Lower interrupt level so that we can get IPIs.  Don't use
	 * spl0() because we don't want to hassle w/ software interrupts
	 * right now.  Note that interrupt() prevents the secondaries
	 * from servicing DEVICE and CLOCK interrupts.
d595 8
d604 3
a606 4

	/* Ok, so all we do is spin for now... */
	for (;;)
		/* nothing */ ;
d610 1
a610 3
cpu_iccb_send(cpu_id, msg)
	cpuid_t cpu_id;
	const char *msg;
d635 1
d651 1
a651 1
cpu_iccb_receive()
d688 7
@


1.30
log
@Only attach cpu0 on single-processor kernels, to match the expected behaviour.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.29 2012/07/09 09:07:25 deraadt Exp $ */
d67 1
d403 1
a403 1
		ci->ci_randseed = random();
@


1.29
log
@Do not re-initialize ci_randseed on the primary cpu
ok kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.28 2010/11/28 20:57:09 miod Exp $ */
d208 5
a212 2
	/* XXX CHECK SLOT? */
	/* XXX CHECK PRIMARY? */
@


1.28
log
@Do not declare a struct cfdriver and initialize it, and then write `extern
struct cfdriver' the bloody same struct.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.27 2010/03/31 19:46:25 miod Exp $ */
d399 1
@


1.27
log
@Make sure the boundaries of uvm_pglistalloc() calls are set up with low
being page-aligned, and high being end of page (i.e.
high & PAGE_MASK == PAGE_MASK) everywhere, for consistency. Future code
will depend on this.
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.26 2010/02/20 12:39:41 sobrado Exp $ */
a114 2

extern struct cfdriver cpu_cd;
@


1.26
log
@minor tweak to improve consistency with other drivers; startup
messages are usually lower case (exceptions are manufacturer codenames
as "Pentium" or "Horse").
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.25 2009/10/02 17:55:52 miod Exp $ */
d341 1
a341 1
	error = uvm_pglistalloc(USPACE, avail_start, avail_end, 0, 0,
@


1.25
log
@Some 21264CB pass information, from information provided by Sergey Prysiazhnyi.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.24 2009/08/11 18:43:33 blambert Exp $ */
d270 1
a270 1
			printf("%s: Architecture extensions: %b\n",
@


1.24
log
@uvm_scheduler() sounds important, but ``while(1) tsleep()'' is kinda lame

inline the loop in the one place it exists, and remove it from uvm

adjust a comment mentioning it accordingly

originally inspired by a diff fixing a comment from oga@@

ok art@@ beck@@ miod@@ oga@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.23 2009/04/14 16:01:04 oga Exp $ */
d144 4
d167 1
a167 1
	{ PCS_PROC_EV68CB,	"21264C",	NULL		},
d245 1
a245 1
	for(i = 0; i < sizeof cpunametable / sizeof cpunametable[0]; ++i) {
d249 1
a249 1
			for(i = 0; s && s[i]; ++i) {
@


1.23
log
@Convert the waitok field of uvm_pglistalloc to "flags", more will be added soon.

For the possibility of sleeping, the first two flags are UVM_PLA_WAITOK
and UVM_PLA_NOWAIT. It is an error not to show intention, so assert that
one of the two is provided. Switch over every caller in the tree to
using the appropriate flag.

ok art@@, ariane@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.22 2008/06/26 05:42:08 ray Exp $ */
d177 1
a177 1
 * Right before calling uvm_scheduler(), main() calls, on proc0's
@


1.22
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.21 2006/08/17 22:22:08 mk Exp $ */
d338 1
a338 1
	    &mlist, 1, 1);
@


1.21
log
@fix tyop.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.20 2006/08/13 13:38:17 mk Exp $ */
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.20
log
@Fix EV6 processor minor type:  0 is reserved and thus all entries were
off by one.

Also add a bunch of minor types for EV6 and tables for PCA57 and EV67.

The present tables should now be complete as per Alpha Architecture
Reference Manual v4.

ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.19 2004/06/13 21:49:11 niklas Exp $ */
d186 1
a186 1
 * actually spin up the additional processor's we've found.  We
@


1.19
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d140 2
a141 1
	"pass 1", "pass 2", "pass 2.2", "pass 2.3", "pass 3", 0
d144 7
d153 1
d168 2
a169 2
	{ PCS_PROC_PCA57,	"PCA57",	NULL		},
	{ PCS_PROC_EV67,	"21264A",	NULL		},
@


1.18
log
@Use cpuid_t whenever possible, rather than an angry combination of long
there and u_long elsewhere.

ok marc@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.17 2004/01/13 06:21:09 deraadt Exp $ */
d568 2
a569 1
	atomic_setbits_ulong(&hwrpb->rpb_rxrdy, cpumask);
@


1.17
log
@grog EV68
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.16 2003/12/22 19:59:37 jmc Exp $ */
d544 1
a544 1
	long cpu_id;
d591 1
a591 1
	long cpu_id;
@


1.16
log
@typos from Jared Yanovich;
note: i only committed some of these.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.15 2003/05/11 19:41:08 deraadt Exp $ */
d161 3
@


1.15
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.14 2002/10/07 18:35:56 mickey Exp $ */
d292 1
a292 1
		printf("%s: procssor ID too large, ignoring\n", dev->dv_xname);
@


1.14
log
@this removes the functionality of adding allocated
pages into the queue already containing allocated pages.
breaks i386:setup_buffers() because of this.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.13 2002/10/06 22:06:15 art Exp $ */
d562 2
a563 1
	strcpy(pcsp->pcs_iccb.iccb_rxbuf, msg);
@


1.13
log
@No more need to initialize the result list before uvm_pglistalloc.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.12 2002/03/14 01:26:26 millert Exp $ */
d331 1
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.11 2001/11/06 19:53:13 miod Exp $ */
a330 1
	TAILQ_INIT(&mlist);
@


1.11
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.10 2001/04/15 05:54:39 art Exp $ */
d96 1
a96 1
void	cpu_boot_secondary __P((struct cpu_info *));
@


1.11.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.11 2001/11/06 19:53:13 miod Exp $ */
d96 1
a96 1
void	cpu_boot_secondary(struct cpu_info *);
@


1.11.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.11.2.1 2002/06/11 03:33:39 art Exp $ */
@


1.11.2.3
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d562 1
a562 2
	strlcpy(pcsp->pcs_iccb.iccb_rxbuf, msg,
	    sizeof pcsp->pcs_iccb.iccb_rxbuf);
@


1.10
log
@Prettier printing of cpu models and more models.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.9 2001/01/20 20:25:22 art Exp $ */
d75 1
a75 1
#include <vm/vm.h>
@


1.9
log
@No need to include machine/alpha.h here.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.8 2000/11/08 19:16:58 ericj Exp $ */
d125 1
a125 1
static char *ev4minor[] = {
d147 2
a148 2
	char	*cpu_major_name;
	char	**cpu_minor_names;
d158 3
a160 1
	{ PCS_PROC_PCA56,	"PCA56",	pca56minor	}
d215 1
a215 1
	char **s;
d242 1
a242 1
					printf(" (%s)\n", s[i]);
d246 1
a246 1
			printf(" (unknown minor type %d)\n", minor);
d253 1
a430 5
	/*
	 * XXX Until I can update the boot block on my test system.
	 * XXX --thorpej
	 */
#if 0
d433 1
a433 4
#else
	memcpy(&pcsp->pcs_pal_rev, &pcsp->pcs_palrevisions[PALvar_OSF1],
	    sizeof(pcsp->pcs_pal_rev));
#endif
@


1.8
log
@add tags
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a81 1
#include <machine/alpha.h>
@


1.7
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
@


1.6
log
@Sync with NetBSD 961207
@
text
@d1 38
a38 2
/*	$OpenBSD: cpu.c,v 1.5 1996/10/30 22:38:01 niklas Exp $	*/
/*	$NetBSD: cpu.c,v 1.16 1996/12/05 01:39:27 cgd Exp $	*/
d67 1
d71 4
d76 1
d78 1
d80 30
a111 1
#ifdef __BROKEN_INDIRECT_CONFIG
d113 1
a113 4
#else
int	cpumatch(struct device *, struct cfdata *, void *);
#endif
void	cpuattach __P((struct device *, struct device *, void *));
d123 64
a189 1
#ifdef __BROKEN_INDIRECT_CONFIG
a190 3
#else
	struct cfdata *cfdata;
#endif
d193 1
a193 1
	struct confargs *ca = aux;
d196 1
a196 1
	if (strcmp(ca->ca_name, cpu_cd.cd_name) != 0)
d199 3
d211 5
a215 1
        struct pcs *p;
d217 1
d219 7
d227 19
a245 23
        p = (struct pcs*)((char *)hwrpb + hwrpb->rpb_pcs_off +
	    (dev->dv_unit * hwrpb->rpb_pcs_size));
	major = (p->pcs_proc_type & PCS_PROC_MAJOR) >> PCS_PROC_MAJORSHIFT;
	minor = (p->pcs_proc_type & PCS_PROC_MINOR) >> PCS_PROC_MINORSHIFT;

	printf(": ");
	switch (major) {
	case PCS_PROC_EV3:
		printf("EV3 (minor type 0x%x)", minor);
		break;

	case PCS_PROC_EV4:
		printf("21064 ");
		switch (minor) {
		case 0:
			printf("(pass 2 or 2.1)");
			break;
		case 1:
			printf("(pass 3)");
			break;
		default:
			printf("(unknown minor type 0x%x)", minor);
			break;
d247 2
a248 1
		break;
d250 1
a250 113
	case PCS_PROC_SIMULATION:
		printf("simulation (minor type 0x%x)", minor);
		break;

	case PCS_PROC_LCA4:
		switch (minor) {
		case 0:
			printf("LCA family (reserved minor type)");
			break;
		case 1:
			printf("21066 (pass 1 or 1.1)");
			break;
		case 2:
			printf("21066 (pass 2)");
			break;
		case 3:
			printf("21068 (pass 1 or 1.1)");
			break;
		case 4:
			printf("21068 (pass 2)");
			break;
		case 5:
			printf("21066A (pass 1)");
			break;
		case 6:
			printf("21068A (pass 1)");
			break;
		default:
			printf("LCA family (unknown minor type 0x%x)", minor);
			break;
		}
		break;

	case PCS_PROC_EV5:
		printf("21164 ");
		switch (minor) {
		case 0:
			printf("(reserved minor type/pass 1)");
			break;
		case 1:
			printf("(pass 2 or 2.2)");
			break;
		case 2:
			printf("(pass 2.3)");
			break;
		case 3:
			printf("(pass 3)");
			break;
		case 4:
			printf("(pass 3.2)");
			break;
		case 5:
			printf("(pass 4)");
			break;
		default:
			printf("(unknown minor type 0x%x)", minor);
			break;
		}
		break;

	case PCS_PROC_EV45:
		printf("21064A ");
		switch (minor) {
		case 0:
			printf("(reserved minor type)");
			break;
		case 1:
			printf("(pass 1)");
			break;
		case 2:
			printf("(pass 1.1)");
			break;
		case 3:
			printf("(pass 2)");
			break;
		default:
			printf("(unknown minor type 0x%x)", minor);
			break;
		}
		break;

	case PCS_PROC_EV56:
		printf("21164A ");
		switch (minor) {
		case 0:
			printf("(reserved minor type)");
			break;
		case 1:
			printf("(pass 1)");
			break;
		case 2:
			printf("(pass 2)");
			break;
		default:
			printf("(unknown minor type 0x%x)", minor);
			break;
		}
		break;

	case PCS_PROC_EV6:
		printf("21264 ");
		switch (minor) {
		case 0:
			printf("(reserved minor type)");
			break;
		case 1:
			printf("(pass 1)");
			break;
		default:
			printf("(unknown minor type 0x%x)", minor);
			break;
		}
		break;
d252 8
a259 12
	case PCS_PROC_PCA56:
		printf("21164PC ");
		switch (minor) {
		case 0:
			printf("(reserved minor type)");
			break;
		case 1:
			printf("(pass 1)");
			break;
		default:
			printf("(unknown minor type 0x%x)", minor);
			break;
a260 5
		break;

	default:
		printf("UNKNOWN CPU TYPE (0x%x:0x%x)", major, minor);
		break;
a261 1
	printf("\n");
d263 1
a263 1
	/* XXX SHOULD CHECK ARCHITECTURE MASK, TOO */
d265 1
a265 1
		printf("cpu%d: ", dev->dv_unit);
d285 13
d305 317
d623 1
@


1.6.14.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 39
/* $OpenBSD: cpu.c,v 1.10 2001/04/15 05:54:39 art Exp $ */
/* $NetBSD: cpu.c,v 1.44 2000/05/23 05:12:53 thorpej Exp $ */

/*-
 * Copyright (c) 1998, 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
a30 1

a33 4
#include <sys/proc.h>
#include <sys/user.h>

#include <vm/vm.h>
a34 1
#include <machine/atomic.h>
a35 1
#include <machine/cpu.h>
a36 29
#include <machine/prom.h>

#if defined(MULTIPROCESSOR)
#include <sys/malloc.h>
#include <sys/kthread.h>

/*
 * Array of CPU info structures.  Must be statically-allocated because
 * curproc, etc. are used early.
 */
struct cpu_info cpu_info[ALPHA_MAXPROCS];

/* Bitmask of CPUs currently running. */
__volatile u_long cpus_running;

void	cpu_boot_secondary __P((struct cpu_info *));
#else /* MULTIPROCESSOR */
struct cpu_info cpu_info_store;
#endif /* MULTIPROCESSOR */

/*
 * The Implementation Version and the Architecture Mask must be
 * consistent across all CPUs in the system, so we set it for the
 * primary and announce the AMASK extensions if they exist.
 *
 * Note, we invert the AMASK so that if a bit is set, it means "has
 * extension".
 */
u_long	cpu_implver, cpu_amask;
d39 1
d41 4
a44 1
void	cpuattach(struct device *, struct device *, void *);
a53 66
extern struct cfdriver cpu_cd;

static const char *ev4minor[] = {
	"pass 2 or 2.1", "pass 3", 0
}, *lcaminor[] = {
	"",
	"21066 pass 1 or 1.1", "21066 pass 2",
	"21068 pass 1 or 1.1", "21068 pass 2",
	"21066A pass 1", "21068A pass 1", 0
}, *ev5minor[] = {
	"", "pass 2, rev BA or 2.2, rev CA", "pass 2.3, rev DA or EA",
	"pass 3", "pass 3.2", "pass 4", 0
}, *ev45minor[] = {
	"", "pass 1", "pass 1.1", "pass 2", 0
}, *ev56minor[] = {
	"", "pass 1", "pass 2", 0
}, *ev6minor[] = {
	"pass 1", "pass 2", "pass 2.2", "pass 2.3", "pass 3", 0
}, *pca56minor[] = {
	"", "pass 1", 0
};

struct cputable_struct {
	int	cpu_major_code;
	const char *cpu_major_name;
	const char **cpu_minor_names;
} cpunametable[] = {
	{ PCS_PROC_EV3,		"EV3",		0		},
	{ PCS_PROC_EV4,		"21064",	ev4minor	},
	{ PCS_PROC_SIMULATION,	"Sim",		0		},
	{ PCS_PROC_LCA4,	"LCA",		lcaminor	},
	{ PCS_PROC_EV5,		"21164",	ev5minor	},
	{ PCS_PROC_EV45,	"21064A",	ev45minor	},
	{ PCS_PROC_EV56,	"21164A",	ev56minor	},
	{ PCS_PROC_EV6,		"21264",	ev6minor	},
	{ PCS_PROC_PCA56,	"PCA56",	pca56minor	},
	{ PCS_PROC_PCA57,	"PCA57",	NULL		},
	{ PCS_PROC_EV67,	"21264A",	NULL		},
};

/*
 * The following is an attempt to map out how booting secondary CPUs
 * works.
 *
 * As we find processors during the autoconfiguration sequence, all
 * processors have idle stacks and PCBs created for them, including
 * the primary (although the primary idles on proc0's PCB until its
 * idle PCB is created).
 *
 * Right before calling uvm_scheduler(), main() calls, on proc0's
 * context, cpu_boot_secondary_processors().  This is our key to
 * actually spin up the additional processor's we've found.  We
 * run through our cpu_info[] array looking for secondary processors
 * with idle PCBs, and spin them up.
 *
 * The spinup involves switching the secondary processor to the
 * OSF/1 PALcode, setting the entry point to cpu_spinup_trampoline(),
 * and sending a "START" message to the secondary's console.
 *
 * Upon successful processor bootup, the cpu_spinup_trampoline will call
 * cpu_hatch(), which will print a message indicating that the processor
 * is running, and will set the "hatched" flag in its softc.  At the end
 * of cpu_hatch() is a spin-forever loop; we do not yet attempt to schedule
 * anything on secondary CPUs.
 */

d57 1
d59 3
d64 1
a64 1
	struct mainbus_attach_args *ma = aux;
d67 1
a67 1
	if (strcmp(ma->ma_name, cpu_cd.cd_name) != 0)
a69 3
	/* XXX CHECK SLOT? */
	/* XXX CHECK PRIMARY? */

d79 1
a79 5
	struct mainbus_attach_args *ma = aux;
	int i;
	const char **s;
	struct pcs *p;
#ifdef DEBUG
a80 1
#endif
a81 7
#if defined(MULTIPROCESSOR)
	extern paddr_t avail_start, avail_end;
	struct pcb *pcb;
	struct cpu_info *ci;
	struct pglist mlist;
	int error;
#endif
d83 122
a204 19
	p = LOCATE_PCS(hwrpb, ma->ma_slot);
	major = PCS_CPU_MAJORTYPE(p);
	minor = PCS_CPU_MINORTYPE(p);

	printf(": ID %d%s, ", ma->ma_slot,
	    ma->ma_slot == hwrpb->rpb_primary_cpu_id ? " (primary)" : "");

	for(i = 0; i < sizeof cpunametable / sizeof cpunametable[0]; ++i) {
		if (cpunametable[i].cpu_major_code == major) {
			printf("%s-%d", cpunametable[i].cpu_major_name, minor);
			s = cpunametable[i].cpu_minor_names;
			for(i = 0; s && s[i]; ++i) {
				if (i == minor && strlen(s[i]) != 0) {
					printf(" (%s)", s[i]);
					goto recognized;
				}
			}
			printf(" (unknown minor type %d)", minor);
			goto recognized;
d206 1
a206 2
	}
	printf("UNKNOWN CPU TYPE (%d:%d)", major, minor);
d208 14
a221 2
recognized:
	printf("\n");
d223 12
a234 8
	if (ma->ma_slot == hwrpb->rpb_primary_cpu_id) {
		cpu_implver = alpha_implver();
		if (cpu_implver >= ALPHA_IMPLVER_EV5)
			cpu_amask =
			    (~alpha_amask(ALPHA_AMASK_ALL)) & ALPHA_AMASK_ALL;
		if (cpu_amask) {
			printf("%s: Architecture extensions: %b\n",
			    dev->dv_xname, cpu_amask, ALPHA_AMASK_BITS);
d236 5
d242 1
d244 1
a244 1
#ifdef DEBUG
d246 1
a246 1
		printf("%s: ", dev->dv_xname);
a265 13
#endif

#if defined(MULTIPROCESSOR)
	if (ma->ma_slot > ALPHA_WHAMI_MAXID) {
		printf("%s: procssor ID too large, ignoring\n", dev->dv_xname);
		return;
	}

	ci = &cpu_info[ma->ma_slot];
	simple_lock_init(&ci->ci_slock);
	ci->ci_cpuid = ma->ma_slot;
	ci->ci_dev = dev;
#endif /* MULTIPROCESSOR */
a272 309

#if defined(MULTIPROCESSOR)
	/*
	 * Make sure the processor is available for use.
	 */
	if ((p->pcs_flags & PCS_PA) == 0) {
		if (ma->ma_slot == hwrpb->rpb_primary_cpu_id)
			panic("cpu_attach: primary not available?!");
		printf("%s: processor not available for use\n", dev->dv_xname);
		return;
	}

	/* Make sure the processor has valid PALcode. */
	if ((p->pcs_flags & PCS_PV) == 0) {
		if (ma->ma_slot == hwrpb->rpb_primary_cpu_id)
			panic("cpu_attach: primary has invalid PALcode?!");
		printf("%s: PALcode not valid\n", ci->ci_dev->dv_xname);
		return;
	}

	/*
	 * Allocate UPAGES contiguous pages for the idle PCB and stack.
	 */
	TAILQ_INIT(&mlist);
	error = uvm_pglistalloc(USPACE, avail_start, avail_end, 0, 0,
	    &mlist, 1, 1);
	if (error != 0) {
		if (ma->ma_slot == hwrpb->rpb_primary_cpu_id) {
			panic("cpu_attach: unable to allocate idle stack for"
			    " primary");
		}
		printf("%s: unable to allocate idle stack\n", dev->dv_xname);
		return;
	}

	ci->ci_idle_pcb_paddr = VM_PAGE_TO_PHYS(TAILQ_FIRST(&mlist));
	pcb = ci->ci_idle_pcb = (struct pcb *)
	    ALPHA_PHYS_TO_K0SEG(ci->ci_idle_pcb_paddr);
	memset(pcb, 0, USPACE);

	/*
	 * Initialize the idle stack pointer, reserving space for an
	 * (empty) trapframe (XXX is the trapframe really necessary?)
	 */
	pcb->pcb_hw.apcb_ksp =
	    (u_int64_t)pcb + USPACE - sizeof(struct trapframe);

	/*
	 * Initialize the idle PCB.
	 */
	pcb->pcb_hw.apcb_backup_ksp = pcb->pcb_hw.apcb_ksp;
	pcb->pcb_hw.apcb_asn = proc0.p_addr->u_pcb.pcb_hw.apcb_asn;
	pcb->pcb_hw.apcb_ptbr = proc0.p_addr->u_pcb.pcb_hw.apcb_ptbr;
#if 0
	printf("%s: hwpcb ksp = 0x%lx\n", sc->sc_dev.dv_xname,
	    pcb->pcb_hw.apcb_ksp);
	printf("%s: hwpcb ptbr = 0x%lx\n", sc->sc_dev.dv_xname,
	    pcb->pcb_hw.apcb_ptbr);
#endif

	/*
	 * If we're the primary CPU, no more work to do; we're already
	 * running!
	 */
	if (ma->ma_slot == hwrpb->rpb_primary_cpu_id) {
		ci->ci_flags |= CPUF_PRIMARY;
		atomic_setbits_ulong(&cpus_running, (1UL << ma->ma_slot));
	}
#endif /* MULTIPROCESSOR */
}

#if defined(MULTIPROCESSOR)
void
cpu_boot_secondary_processors()
{
	struct cpu_info *ci;
	u_long i;

	for (i = 0; i < ALPHA_MAXPROCS; i++) {
		ci = &cpu_info[i];
		if (ci->ci_idle_pcb == NULL)
			continue;
		if (ci->ci_flags & CPUF_PRIMARY)
			continue;

		/* This processor is all set up; boot it! */
		cpu_boot_secondary(ci);
	}
}

void
cpu_boot_secondary(ci)
	struct cpu_info *ci;
{
	long timeout;
	struct pcs *pcsp, *primary_pcsp;
	struct pcb *pcb;
	u_long cpumask;

	pcb = ci->ci_idle_pcb;
	primary_pcsp = LOCATE_PCS(hwrpb, hwrpb->rpb_primary_cpu_id);
	pcsp = LOCATE_PCS(hwrpb, ci->ci_cpuid);
	cpumask = (1UL << ci->ci_cpuid);

	/*
	 * Set up the PCS's HWPCB to match ours.
	 */
	memcpy(pcsp->pcs_hwpcb, &pcb->pcb_hw, sizeof(pcb->pcb_hw));

	/*
	 * Set up the HWRPB to restart the secondary processor
	 * with our spin-up trampoline.
	 */
	hwrpb->rpb_restart = (u_int64_t) cpu_spinup_trampoline;
	hwrpb->rpb_restart_val = (u_int64_t) ci;
	hwrpb->rpb_checksum = hwrpb_checksum();

	/*
	 * Configure the CPU to start in OSF/1 PALcode by copying
	 * the primary CPU's PALcode revision info to the secondary
	 * CPUs PCS.
	 */

	memcpy(&pcsp->pcs_pal_rev, &primary_pcsp->pcs_pal_rev,
	    sizeof(pcsp->pcs_pal_rev));

	pcsp->pcs_flags |= (PCS_CV|PCS_RC);
	pcsp->pcs_flags &= ~PCS_BIP;

	/* Make sure the secondary console sees all this. */
	alpha_mb();

	/* Send a "START" command to the secondary CPU's console. */
	if (cpu_iccb_send(ci->ci_cpuid, "START\r\n")) {
		printf("%s: unable to issue `START' command\n",
		    ci->ci_dev->dv_xname);
		return;
	}

	/* Wait for the processor to boot. */
	for (timeout = 10000; timeout != 0; timeout--) {
		alpha_mb();
		if (pcsp->pcs_flags & PCS_BIP)
			break;
		delay(1000);
	}
	if (timeout == 0)
		printf("%s: processor failed to boot\n", ci->ci_dev->dv_xname);

	/*
	 * ...and now wait for verification that it's running kernel
	 * code.
	 */
	for (timeout = 10000; timeout != 0; timeout--) {
		alpha_mb();
		if (cpus_running & cpumask)
			break;
		delay(1000);
	}
	if (timeout == 0)
		printf("%s: processor failed to hatch\n", ci->ci_dev->dv_xname);
}

void
cpu_halt_secondary(cpu_id)
	u_long cpu_id;
{
	long timeout;
	u_long cpumask = (1UL << cpu_id);

#ifdef DIAGNOSTIC
	if (cpu_id >= hwrpb->rpb_pcs_cnt ||
	    cpu_info[cpu_id].ci_dev == NULL)
		panic("cpu_halt_secondary: bogus cpu_id");
#endif

	alpha_mb();
	if ((cpus_running & cpumask) == 0) {
		/* Processor not running. */
		return;
	}

	/* Send the HALT IPI to the secondary. */
	alpha_send_ipi(cpu_id, ALPHA_IPI_HALT);

	/* ...and wait for it to shut down. */
	for (timeout = 10000; timeout != 0; timeout--) {
		alpha_mb();
		if ((cpus_running & cpumask) == 0)
			return;
		delay(1000);
	}

	/* Erk, secondary failed to halt. */
	printf("WARNING: %s (ID %lu) failed to halt\n",
	    cpu_info[cpu_id].ci_dev->dv_xname, cpu_id);
}

void
cpu_hatch(ci)
	struct cpu_info *ci;
{
	u_long cpumask = (1UL << ci->ci_cpuid);

	/* Set our `curpcb' to reflect our context. */
	curpcb = ci->ci_idle_pcb_paddr;

	/* Mark the kernel pmap active on this processor. */
	atomic_setbits_ulong(&pmap_kernel()->pm_cpus, cpumask);

	/* Initialize trap vectors for this processor. */
	trap_init();

	/* Yahoo!  We're running kernel code!  Announce it! */
	printf("%s: processor ID %lu running\n", ci->ci_dev->dv_xname,
	    alpha_pal_whami());
	atomic_setbits_ulong(&cpus_running, cpumask);

	/*
	 * Lower interrupt level so that we can get IPIs.  Don't use
	 * spl0() because we don't want to hassle w/ software interrupts
	 * right now.  Note that interrupt() prevents the secondaries
	 * from servicing DEVICE and CLOCK interrupts.
	 */
	(void) alpha_pal_swpipl(ALPHA_PSL_IPL_0);

	/* Ok, so all we do is spin for now... */
	for (;;)
		/* nothing */ ;
}

int
cpu_iccb_send(cpu_id, msg)
	long cpu_id;
	const char *msg;
{
	struct pcs *pcsp = LOCATE_PCS(hwrpb, cpu_id);
	int timeout;
	u_long cpumask = (1UL << cpu_id);

	/* Wait for the ICCB to become available. */
	for (timeout = 10000; timeout != 0; timeout--) {
		alpha_mb();
		if ((hwrpb->rpb_rxrdy & cpumask) == 0)
			break;
		delay(1000);
	}
	if (timeout == 0)
		return (EIO);

	/*
	 * Copy the message into the ICCB, and tell the secondary console
	 * that it's there.  The atomic operation performs a memory barrier.
	 */
	strcpy(pcsp->pcs_iccb.iccb_rxbuf, msg);
	pcsp->pcs_iccb.iccb_rxlen = strlen(msg);
	atomic_setbits_ulong(&hwrpb->rpb_rxrdy, cpumask);

	/* Wait for the message to be received. */
	for (timeout = 10000; timeout != 0; timeout--) {
		alpha_mb();
		if ((hwrpb->rpb_rxrdy & cpumask) == 0)
			break;
		delay(1000);
	}
	if (timeout == 0)
		return (EIO);

	return (0);
}

void
cpu_iccb_receive()
{
#if 0	/* Don't bother... we don't get any important messages anyhow. */
	u_int64_t txrdy;
	char *cp1, *cp2, buf[80];
	struct pcs *pcsp;
	u_int cnt;
	long cpu_id;

	txrdy = hwrpb->rpb_txrdy;

	for (cpu_id = 0; cpu_id < hwrpb->rpb_pcs_cnt; cpu_id++) {
		if (txrdy & (1UL << cpu_id)) {
			pcsp = LOCATE_PCS(hwrpb, cpu_id);
			printf("Inter-console message from CPU %lu "
			    "HALT REASON = 0x%lx, FLAGS = 0x%lx\n",
			    cpu_id, pcsp->pcs_halt_reason, pcsp->pcs_flags);
			
			cnt = pcsp->pcs_iccb.iccb_txlen;
			if (cnt >= 80) {
				printf("Malformed inter-console message\n");
				continue;
			}
			cp1 = pcsp->pcs_iccb.iccb_txbuf;
			cp2 = buf;
			while (cnt--) {
				if (*cp1 != '\r' && *cp1 != '\n')
					*cp2++ = *cp1;
				cp1++;
			}
			*cp2 = '\0';
			printf("Message from CPU %lu: %s\n", cpu_id, buf);
		}
	}
#endif /* 0 */
	hwrpb->rpb_txrdy = 0;
	alpha_mb();
a273 1
#endif /* MULTIPROCESSOR */
@


1.6.14.2
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d75 1
a75 1
#include <uvm/uvm_extern.h>
@


1.6.14.3
log
@A bit on the way to make GENERIC compile in the SMP branch.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.6.14.2 2001/11/13 21:00:48 niklas Exp $ */
d564 1
a564 2
	/* XXX cast to __volatile */
	atomic_setbits_ulong((__volatile u_long *)&hwrpb->rpb_rxrdy, cpumask);
@


1.6.14.4
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d96 1
a96 1
void	cpu_boot_secondary(struct cpu_info *);
@


1.6.14.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.c,v 1.6.14.4 2002/03/28 10:06:12 niklas Exp $ */
d562 1
a562 2
	strlcpy(pcsp->pcs_iccb.iccb_rxbuf, msg,
	    sizeof pcsp->pcs_iccb.iccb_rxbuf);
@


1.6.14.6
log
@Merge of -current from two weeks ago into the SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a160 3
	{ PCS_PROC_EV68CB,	"21264C",	NULL		},
	{ PCS_PROC_EV68AL,	"21264B",	NULL		},
	{ PCS_PROC_EV68CX,	"21264D",	NULL		},
d292 1
a292 1
		printf("%s: processor ID too large, ignoring\n", dev->dv_xname);
@


1.6.14.7
log
@sync to head
@
text
@d544 1
a544 1
	cpuid_t cpu_id;
d592 1
a592 1
	cpuid_t cpu_id;
@


1.5
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 2
a2 2
/*	$OpenBSD: cpu.c,v 1.12 1996/10/13 02:59:26 christos Exp $	*/
/*	$NetBSD: cpu.c,v 1.12 1996/10/13 02:59:26 christos Exp $	*/
d39 5
a43 1
int	cpumatch __P((struct device *, void *, void *));
d57 1
d59 3
d80 1
a80 16
	char *cpu_major[] = {
		"UNKNOWN MAJOR TYPE (0)",
		"EV3",				/* PCS_PROC_EV3 */
		"21064 (EV4)",			/* PCS_PROC_EV4 */
		"Simulator",			/* PCS_PROC_SIMULATOR */
		"21066/21068 (LCA4)",		/* PCS_PROC_LCA4 */
		"21164 (EV5)",			/* PCS_PROC_EV5 */
		"21064A (EV45)",		/* PCS_PROC_EV45 */
	};
	int ncpu_major = sizeof(cpu_major) / sizeof(cpu_major[0]);
	char *dc21064_cpu_minor[] = {
		"Pass 2 or 2.1",
		"Pass 3",
	};
	int ndc21064_cpu_minor =
	    sizeof(dc21064_cpu_minor) / sizeof(dc21064_cpu_minor[0]);
a81 1
	int needcomma;
d85 3
d89 4
d94 14
a107 2
	major = (p->pcs_proc_type & PCS_PROC_MAJOR) >> PCS_PROC_MAJORSHIFT;
	minor = (p->pcs_proc_type & PCS_PROC_MINOR) >> PCS_PROC_MINORSHIFT;
d109 3
a111 4
	if (major < ncpu_major)
		printf("%s", cpu_major[major]);
	else
		printf("UNKNOWN MAJOR TYPE (%d)", major);
d113 28
a140 1
	printf(", ");
d142 25
a166 6
	switch (major) {
	case PCS_PROC_EV4:
		if (minor < ndc21064_cpu_minor)
			printf("%s", dc21064_cpu_minor[minor]);
		else
			printf("UNKNOWN MINOR TYPE (%d)", minor);
d170 36
a205 2
	case PCS_PROC_EV5:
		printf("Pass %d", minor + 1);
d208 14
a221 3
	default:
		printf("UNKNOWN MINOR TYPE (%d)", minor);
	}
d223 14
a236 2
	if (p->pcs_proc_revision[0] != 0) {		/* XXX bad test? */
		printf(", ");
d238 3
a240 3
		printf("Revision %c%c%c%c", p->pcs_proc_revision[0],
		    p->pcs_proc_revision[1], p->pcs_proc_revision[2],
		    p->pcs_proc_revision[3]);
a241 1

d244 1
d268 1
a268 1
	 * Though we could (should?) attach the LCA's PCI
@


1.4
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: cpu.c,v 1.9 1996/04/29 16:36:19 cgd Exp $	*/
/*	$NetBSD: cpu.c,v 1.9 1996/04/29 16:36:19 cgd Exp $	*/
d32 1
d39 2
a40 2
static int	cpumatch(struct device *, void *, void *);
static void	cpuattach(struct device *, struct device *, void *);
d50 1
a50 3
static int	cpuprint __P((void *, char *pnp));

static int
a55 1
	struct cfdata *cf = cfdata;
d65 1
a65 1
static void
d89 1
a89 1
	int needcomma, needrev, i;
a159 12
}

static int
cpuprint(aux, pnp)
	void *aux;
	char *pnp;
{
	register struct confargs *ca = aux;

	if (pnp)
		printf("%s at %s", ca->ca_name, pnp);
	return (UNCONF);
@


1.3
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.2
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: cpu.c,v 1.4 1995/11/23 02:33:48 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1994, 1995 Carnegie-Mellon University.
d39 8
a46 2
struct cfdriver cpucd =
    { NULL, "cpu", cpumatch, cpuattach, DV_DULL, sizeof (struct device) };
d60 1
a60 1
	if (strcmp(ca->ca_name, cpucd.cd_name) != 0)
d76 1
a76 1
		"EV4 (21064)",			/* PCS_PROC_EV4 */
d78 3
a80 3
		"LCA4 (21066/21068)",		/* PCS_PROC_LCA4 */
		"EV5 (21164)",			/* PCS_PROC_EV5 */
		"EV45 (21064A)",		/* PCS_PROC_EV45 */
d145 2
a146 2
		if (p->pcs_proc_var & PCS_VAR_IOACCESS) {
			printf("%shas I/O access", needcomma ? ", " : "");
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: cpu.c,v 1.3 1995/06/28 02:45:01 cgd Exp $	*/
d76 2
a77 1
	char *cpu_minor[] = {
d81 2
a82 2
	int ncpu_major = sizeof(cpu_major) / sizeof(cpu_major[0]);
	int ncpu_minor = sizeof(cpu_minor) / sizeof(cpu_minor[0]);
d100 14
a113 3
	if (minor < ncpu_minor)
		printf("%s", cpu_minor[minor]);
	else
d115 1
d149 6
a154 14
	if (major == PCS_PROC_LCA4) {
		struct confargs nca;

		/*
		 * If the processor is an LCA, then it's got the PCI
		 * bus interface built in.  Attach it here. (!!!)
		 */
		nca.ca_name = "lca";
		nca.ca_slot = 0;
		nca.ca_offset = 0;
		nca.ca_bus = NULL;
		if (!config_found(dev, &nca, cpuprint))
			panic("cpuattach: couldn't attach LCA bus interface");
	}
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
