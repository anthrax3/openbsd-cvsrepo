head	1.20;
access;
symbols
	OPENBSD_6_2:1.20.0.2
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.19.0.4
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.16.0.8
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.10
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.6
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.12
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.10
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.8
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.6
	OPENBSD_5_0:1.15.0.4
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.14.0.28
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.24
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.26
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.22
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.20
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.18
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.16
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.14
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.12
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.10
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.8
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.6
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.12
	UBC:1.8.0.2
	UBC_BASE:1.8
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.4.0.16
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.14
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.12
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4;
locks; strict;
comment	@ * @;


1.20
date	2017.09.08.05.36.51;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	uRv5pa9QDlZaYgwD;

1.19
date	2016.09.19.21.18.35;	author jasper;	state Exp;
branches;
next	1.18;
commitid	504EMnf4FZsQ0Gj3;

1.18
date	2016.09.19.17.59.18;	author jasper;	state Exp;
branches;
next	1.17;
commitid	34nXrfiWjgfvT3XN;

1.17
date	2016.04.27.11.03.24;	author mpi;	state Exp;
branches;
next	1.16;
commitid	QLDpQBW1KLbDishX;

1.16
date	2014.01.30.20.11.14;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2010.11.27.19.57.23;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.18.20.14.40;	author jmc;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.03.21.09.01;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.18.17.55.50;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.18.09.49.16;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.16.13.01.41;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.26;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.06.19.53.13;	author miod;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.03.04.19.19.42;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.08.19.16.58;	author ericj;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.08.16.00.57;	author art;	state Exp;
branches;
next	1.4;

1.4
date	97.07.23.23.29.45;	author niklas;	state Exp;
branches
	1.4.12.1;
next	1.3;

1.3
date	97.07.20.06.58.57;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.07.08.20.33.40;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.07.06.16.31.14;	author niklas;	state Exp;
branches;
next	;

1.4.12.1
date	2001.04.18.16.00.12;	author niklas;	state Exp;
branches;
next	1.4.12.2;

1.4.12.2
date	2001.11.13.21.00.48;	author niklas;	state Exp;
branches;
next	1.4.12.3;

1.4.12.3
date	2002.03.28.10.06.12;	author niklas;	state Exp;
branches;
next	1.4.12.4;

1.4.12.4
date	2003.03.27.22.29.47;	author niklas;	state Exp;
branches;
next	1.4.12.5;

1.4.12.5
date	2003.06.07.11.11.33;	author ho;	state Exp;
branches;
next	1.4.12.6;

1.4.12.6
date	2004.02.19.09.59.33;	author niklas;	state Exp;
branches;
next	;

1.8.2.1
date	2002.06.11.03.33.39;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: db_trace.c,v 1.19 2016/09/19 21:18:35 jasper Exp $	*/

/*
 * Copyright (c) 1997 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1997 Theo de Raadt.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>

#include <machine/db_machdep.h>
#include <machine/frame.h>

#include <ddb/db_access.h>
#include <ddb/db_command.h>
#include <ddb/db_output.h>
#include <ddb/db_sym.h>
#include <ddb/db_variables.h>
#include <ddb/db_extern.h>
#include <ddb/db_interface.h>

extern int	etext;

struct opcode opcode[] = {
	{ OPC_PAL, "call_pal", 0 },	/* 00 */
	{ OPC_RES, "opc01", 0 },	/* 01 */
	{ OPC_RES, "opc02", 0 },	/* 02 */
	{ OPC_RES, "opc03", 0 },	/* 03 */
	{ OPC_RES, "opc04", 0 },	/* 04 */
	{ OPC_RES, "opc05", 0 },	/* 05 */
	{ OPC_RES, "opc06", 0 },	/* 06 */
	{ OPC_RES, "opc07", 0 },	/* 07 */
	{ OPC_MEM, "lda", 1 },		/* 08 */
	{ OPC_MEM, "ldah", 1 },		/* 09 */
	{ OPC_RES, "opc0a", 0 },	/* 0A */
	{ OPC_MEM, "ldq_u", 1 },	/* 0B */
	{ OPC_RES, "opc0c", 0 },	/* 0C */
	{ OPC_RES, "opc0d", 0 },	/* 0D */
	{ OPC_RES, "opc0e", 0 },	/* 0E */
	{ OPC_MEM, "stq_u", 1 },	/* 0F */
	{ OPC_OP, "inta", 0 },		/* 10 */
	{ OPC_OP, "intl", 0 },		/* 11 */
	{ OPC_OP, "ints", 0 },		/* 12 */
	{ OPC_OP, "intm", 0 },		/* 13 */
	{ OPC_RES, "opc14", 0 },	/* 14 */
	{ OPC_OP, "fltv", 1 },		/* 15 */
	{ OPC_OP, "flti", 1 },		/* 16 */
	{ OPC_OP, "fltl", 1 },		/* 17 */
	{ OPC_MEM, "misc", 0 },		/* 18 */
	{ OPC_PAL, "pal19", 0 },	/* 19 */
	{ OPC_MEM, "jsr", 0 },		/* 1A */
	{ OPC_PAL, "pal1b", 0 },	/* 1B */
	{ OPC_RES, "opc1c", 0 },	/* 1C */
	{ OPC_PAL, "pal1d", 0 },	/* 1D */
	{ OPC_PAL, "pal1e", 0 },	/* 1E */
	{ OPC_PAL, "pal1f", 0 },	/* 1F */
	{ OPC_MEM, "ldf", 1 },		/* 20 */
	{ OPC_MEM, "ldg", 1 },		/* 21 */
	{ OPC_MEM, "lds", 1 },		/* 22 */
	{ OPC_MEM, "ldt", 1 },		/* 23 */
	{ OPC_MEM, "stf", 1 },		/* 24 */
	{ OPC_MEM, "stg", 1 },		/* 25 */
	{ OPC_MEM, "sts", 1 },		/* 26 */
	{ OPC_MEM, "stt", 1 },		/* 27 */
	{ OPC_MEM, "ldl", 1 },		/* 28 */
	{ OPC_MEM, "ldq", 1 },		/* 29 */
	{ OPC_MEM, "ldl_l", 1 },	/* 2A */
	{ OPC_MEM, "ldq_l", 1 },	/* 2B */
	{ OPC_MEM, "stl", 1 },		/* 2C */
	{ OPC_MEM, "stq", 1 },		/* 2D */
	{ OPC_MEM, "stl_c", 1 },	/* 2E */
	{ OPC_MEM, "stq_c", 1 },	/* 2F */
	{ OPC_BR, "br", 1 },		/* 30 */
	{ OPC_BR, "fbeq", 1 },		/* 31 */
	{ OPC_BR, "fblt", 1 },		/* 32 */
	{ OPC_BR, "fble", 1 },		/* 33 */
	{ OPC_BR, "bsr", 1 },		/* 34 */
	{ OPC_BR, "fbne", 1 },		/* 35 */
	{ OPC_BR, "fbge", 1 },		/* 36 */
	{ OPC_BR, "fbgt", 1 },		/* 37 */
	{ OPC_BR, "blbc", 1 },		/* 38 */
	{ OPC_BR, "beq", 1 },		/* 39 */
	{ OPC_BR, "blt", 1 },		/* 3A */
	{ OPC_BR, "ble", 1 },		/* 3B */
	{ OPC_BR, "blbs", 1 },		/* 3C */
	{ OPC_BR, "bne", 1 },		/* 3D */
	{ OPC_BR, "bge", 1 },		/* 3E */
	{ OPC_BR, "bgt", 1 },		/* 3F */
};

static __inline int sext(u_int);
static __inline int rega(u_int);
static __inline int regb(u_int);
static __inline int regc(u_int);
static __inline int disp(u_int);

static __inline int
sext(x)
	u_int x;
{
	return ((x & 0x8000) ? -(-x & 0xffff) : (x & 0xffff));
}

static __inline int
rega(x)
	u_int x;
{
	return ((x >> 21) & 0x1f);
}

static __inline int
regb(x)
	u_int x;
{
	return ((x >> 16) & 0x1f);
}

static __inline int
regc(x)
	u_int x;
{
	return (x & 0x1f);
}

static __inline int
disp(x)
	u_int x;
{
	return (sext(x & 0xffff));
}

/*
 * XXX There are a couple of problems with this code:
 *
 *	The argument list printout code is likely to get confused.
 *
 *	It relies on the conventions of gcc code generation.
 *
 *	It uses heuristics to calculate the framesize, and might get it wrong.
 *
 *	It doesn't yet use the framepointer if available.
 *
 *	The address argument can only be used for pointing at trapframes
 *	since a frame pointer of its own serves no good on the alpha,
 *	you need a pc value too.
 *
 *	The heuristics used for tracing through a trap relies on having
 *	symbols available.
 */
void
db_stack_trace_print(db_expr_t addr, int have_addr, db_expr_t count,
    char *modif, int (*pr)(const char *, ...))
{
	u_long		*frame;
	int		i, framesize;
	db_addr_t	pc, ra;
	u_int		inst;
	char		*name;
	db_expr_t	offset;
	db_regs_t	*regs;
	u_long		*slot[32];

	bzero(slot, sizeof(slot));
	if (count == -1)
		count = 65535;

	if (have_addr) {
		(*pr)("alpha trace requires a trap frame... giving up.\n");
		return;
	}
	regs = &ddb_regs;
trapframe:
	/* remember where various registers are stored */
	for (i = 0; i < 31; i++)
		slot[i] = &regs->tf_regs[0] +
		    ((u_long *)db_regs[i].valuep - &ddb_regs.tf_regs[0]);
	frame = (u_long *)regs->tf_regs[FRAME_SP];
	pc = (db_addr_t)regs->tf_regs[FRAME_PC];
	ra = (db_addr_t)regs->tf_regs[FRAME_RA];

	while (count-- && pc >= (db_addr_t)KERNBASE && pc < (db_addr_t)&etext) {
		db_find_sym_and_offset(pc, &name, &offset);
		if (!name) {
			name = "?";
			/* Limit the search for procedure start */
			offset = 65536;
		}
		(*pr)("%s(", name);

		framesize = 0;
		for (i = sizeof (int); i <= offset; i += sizeof (int)) {
			inst = *(u_int *)(pc - i);

			/*
			 * If by chance we don't have any symbols we have to
			 * get out somehow anyway.  Check for the preceding
			 * procedure return in that case.
			 */
			if (name[0] == '?' && inst_return(inst))
				break;

			/*
			 * Disassemble to get the needed info for the frame.
			 */
			if ((inst & 0xffff0000) == 0x23de0000)
				/* lda sp,n(sp) */
				framesize -= disp(inst) / sizeof (u_long);
			else if ((inst & 0xfc1f0000) == 0xb41e0000)
				/* stq X,n(sp) */
				slot[rega(inst)] =
				    frame + disp(inst) / sizeof (u_long);
			else if ((inst & 0xfc000fe0) == 0x44000400 &&
			    rega(inst) == regb(inst)) {
				/* bis X,X,Y (aka mov X,Y) */
				/* zero is hardwired */
				if (rega(inst) != 31)
					slot[rega(inst)] = slot[regc(inst)];
				slot[regc(inst)] = 0;
				/*
				 * XXX In here we might special case a frame
				 * pointer setup, i.e. mov sp, fp.
				 */
			} else if (db_inst_load(inst))
				/* clobbers a register */
				slot[rega(inst)] = 0;
			else if (opcode[inst >> 26].opc_fmt == OPC_OP)
				/* clobbers a register */
				slot[regc(inst)] = 0;
			/*
			 * XXX Recognize more reg clobbering instructions and
			 * set slot[reg] = 0 then too.
			 */
		}

		/*
		 * Try to print the 6 quads that might hold the args.
		 * We print 6 of them even if there are fewer, cause we don't
		 * know the number.  Maybe we could skip the last ones
		 * that never got used.  If we cannot know the value, print
		 * a question mark.
		 */
		for (i = 0; i < 6; i++) {
			if (i > 0)
				(*pr)(", ");
			if (slot[16 + i])
				(*pr)("%lx", *slot[16 + i]);
			else
				(*pr)("?");
		}

#if 0
		/*
		 * XXX This will go eventually when I trust the argument
		 * printout heuristics.
		 *
		 * Print the stack frame contents.
		 */
		(*pr)(") [%p: ", frame);
		if (framesize > 1) {
			for (i = 0; i < framesize - 1; i++)
				(*pr)("%lx, ", frame[i]);
			(*pr)("%lx", frame[i]);
		}
		(*pr)("] at ");
#else
		(*pr)(") at ");
#endif
		db_printsym(pc, DB_STGY_PROC, pr);
		(*pr)("\n");

		/*
		 * If we are looking at a Xent* routine we are in a trap
		 * context.
		 */
		if (strncmp(name, "Xent", sizeof("Xent") - 1) == 0) {
			regs = (db_regs_t *)frame;
			goto trapframe;
		}

		/* Look for the return address if recorded.  */
		if (slot[26])
			ra = *(db_addr_t *)slot[26];
		else
			break;

		/* Advance to the next frame, if any.  */
		frame += framesize;
		if (ra == pc)
			break;
		pc = ra;
	}
}
@


1.19
log
@ansify function definitions

ok guenther@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.18 2016/09/19 17:59:18 jasper Exp $	*/
a27 1
#include <sys/types.h>
@


1.18
log
@fix whitespace at EOL
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.17 2016/04/27 11:03:24 mpi Exp $	*/
d174 2
a175 6
db_stack_trace_print(addr, have_addr, count, modif, pr)
	db_expr_t       addr;
	int             have_addr;
	db_expr_t       count;
	char            *modif;
	int		(*pr)(const char *, ...);
@


1.17
log
@Stop using DDB_REGS.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.16 2014/01/30 20:11:14 miod Exp $	*/
d220 1
a220 1
	
@


1.16
log
@Abort traceback when a new ra has not been found, instead of looping on it
and printing the same traceback line several times.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.15 2010/11/27 19:57:23 miod Exp $	*/
d198 1
a198 1
	regs = DDB_REGS;
@


1.15
log
@Remove ddb single-step load and store counters. Most platforms do not
implement them, and they are of questionable usefulness.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.14 2003/10/18 20:14:40 jmc Exp $	*/
d313 1
a313 1
		/* Advance to the next frame.  */
d315 2
@


1.14
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.13 2003/06/03 21:09:01 deraadt Exp $	*/
d250 1
a250 1
			} else if (inst_load(inst))
@


1.13
log
@terms 3 & 4 cleanup based on "terms" file
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.12 2002/05/18 17:55:50 art Exp $	*/
d4 2
a5 2
 * Copyright (c) 1997 Niklas Hallqvist.  All rights reserverd.
 * Copyright (c) 1997 Theo de Raadt.  All rights reserverd.
@


1.12
log
@Until we start supporting various modifiers to trace, we have
to treat the 'addr' the same way on all archs. This means that alpha can't do anything with the
addr because we need a complete trap frame to be able to print a trace.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.11 2002/05/18 09:49:16 art Exp $	*/
a14 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Niklas Hallqvist and
 *	Theo de Raadt.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.11
log
@Rename the MD db_stack_trace_cmd to db_stack_trace_print. Add an argument
that specifies which printf funciton it should use. Implement
db_stack_trace_cmd in MI code.

Thanks to miod@@ for all the tests.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.10 2002/05/16 13:01:41 art Exp $	*/
d200 5
a204 1
	regs = have_addr ? (db_regs_t *)addr : DDB_REGS;
@


1.10
log
@Add a an argument to db_printsym that specifies the printf function
we'll use for printing the information.
miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.9 2002/03/14 01:26:26 millert Exp $	*/
d180 1
a180 1
db_stack_trace_cmd(addr, have_addr, count, modif)
d185 1
d217 1
a217 1
		db_printf("%s(", name);
d273 1
a273 1
				db_printf(", ");
d275 1
a275 1
				db_printf("%lx", *slot[16 + i]);
d277 1
a277 1
				db_printf("?");
d287 1
a287 1
		db_printf(") [%p: ", frame);
d290 2
a291 2
				db_printf("%lx, ", frame[i]);
			db_printf("%lx", frame[i]);
d293 1
a293 1
		db_printf("] at ");
d295 1
a295 1
		db_printf(") at ");
d297 2
a298 2
		db_printsym(pc, DB_STGY_PROC, db_printf);
		db_printf("\n");
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.8 2001/11/06 19:53:13 miod Exp $	*/
d296 1
a296 1
		db_printsym(pc, DB_STGY_PROC);
@


1.8
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.7 2001/03/04 19:19:42 niklas Exp $	*/
d120 5
a124 5
static __inline int sext __P((u_int));
static __inline int rega __P((u_int));
static __inline int regb __P((u_int));
static __inline int regc __P((u_int));
static __inline int disp __P((u_int));
@


1.8.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.8 2001/11/06 19:53:13 miod Exp $	*/
d120 5
a124 5
static __inline int sext(u_int);
static __inline int rega(u_int);
static __inline int regb(u_int);
static __inline int regc(u_int);
static __inline int disp(u_int);
d180 1
a180 1
db_stack_trace_print(addr, have_addr, count, modif, pr)
a184 1
	int		(*pr)(const char *, ...);
d199 1
a199 5
	if (have_addr) {
		(*pr)("alpha trace requires a trap frame... giving up.\n");
		return;
	}
	regs = DDB_REGS;
d216 1
a216 1
		(*pr)("%s(", name);
d272 1
a272 1
				(*pr)(", ");
d274 1
a274 1
				(*pr)("%lx", *slot[16 + i]);
d276 1
a276 1
				(*pr)("?");
d286 1
a286 1
		(*pr)(") [%p: ", frame);
d289 2
a290 2
				(*pr)("%lx, ", frame[i]);
			(*pr)("%lx", frame[i]);
d292 1
a292 1
		(*pr)("] at ");
d294 1
a294 1
		(*pr)(") at ");
d296 2
a297 2
		db_printsym(pc, DB_STGY_PROC, pr);
		(*pr)("\n");
@


1.7
log
@Revert to our old traceback code, with heuristic argument printout.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.4 1997/07/23 23:29:45 niklas Exp $	*/
d38 1
a38 1
#include <vm/vm.h>
@


1.6
log
@add tags
@
text
@d1 1
a1 2
/* $OpenBSD$ */
/* $NetBSD: db_trace.c,v 1.6 2000/05/26 03:34:24 jhawk Exp $ */
d3 3
a5 10
/*-
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Ross Harvey.
d17 4
a20 5
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d22 10
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
d34 1
d37 3
a39 2
#include <sys/proc.h>
#include <sys/user.h>
d41 1
a42 3
#include <alpha/alpha/db_instruction.h>

#include <ddb/db_sym.h> 
d44 3
d48 1
a48 1
#include <ddb/db_output.h>
d51 67
a117 7
/*
 * Information about the `standard' Alpha function prologue.
 */
struct prologue_info {
	int	pi_reg_offset[32]; /* offset of registers in stack frame */
	u_int32_t pi_regmask;	   /* which registers are in frame */
	int	pi_frame_size;	   /* frame size */
d120 41
d162 3
a164 1
 * We use several symbols to take special action:
d166 1
a166 1
 *	Trap vectors, which use a different (fixed-size) stack frame:
d168 10
a177 6
 *		XentArith
 *		XentIF
 *		XentInt
 *		XentMM
 *		XentSys
 *		XentUna
a178 21

static struct special_symbol {
	void (*ss_val) __P((void));
	const char *ss_note;
} special_symbols[] = {
	{ (void (*)(void))&XentArith,	"arithmetic trap" },
	{ (void (*)(void))&XentIF,	"instruction fault" },
	{ (void (*)(void))&XentInt,	"interrupt" },
	{ (void (*)(void))&XentMM,	"memory management fault" },
	{ (void (*)(void))&XentSys,	"syscall" },
	{ (void (*)(void))&XentUna,	"unaligned access fault" },
	{ (void (*)(void))&XentRestart,	"console restart" },
	{ NULL }
};

static void decode_prologue __P((db_addr_t, db_addr_t, struct prologue_info *,
    int (*)(const char *, ...)));
static void decode_syscall __P((int, struct proc *,
    int (*)(const char *, ...)));
static int sym_is_trapsymbol __P((void *));

d181 4
a184 4
	db_expr_t addr;
	boolean_t have_addr;
	db_expr_t count;
	char *modif;
d186 29
a214 45
	db_addr_t callpc, frame, symval;
	struct prologue_info pi;
	void *symval_f;
	db_expr_t diff;
	db_sym_t sym;
	int i;
	u_long tfps;
	char *symname;
	struct pcb *pcbp;
	char c, *cp = modif;
	struct trapframe *tf;
	boolean_t ra_from_tf;
	boolean_t ra_from_pcb;
	u_long last_ipl = ~0L;
	struct proc *p = NULL;
	boolean_t trace_thread = FALSE;
	boolean_t have_trapframe = FALSE;

	while ((c = *cp++) != 0)
		trace_thread |= c == 't';

	if (!have_addr) {
		p = curproc;
		addr = DDB_REGS->tf_regs[FRAME_SP] - FRAME_SIZE * 8;
		tf = (struct trapframe *)addr;
		have_trapframe = 1;
	} else {
		if (trace_thread) {
			db_printf("trace: pid %d ", (int)addr);
			p = pfind(addr);
			if (p == NULL) {
				db_printf("not found\n");
				return;
			}	
			if ((p->p_flag & P_INMEM) == 0) {
				db_printf("swapped out\n");
				return;
			}
			pcbp = &p->p_addr->u_pcb;
			addr = (db_expr_t)pcbp->pcb_hw.apcb_ksp;
			callpc = pcbp->pcb_context[7];
			db_printf("at 0x%lx\n", addr);
		} else {
			db_printf("alpha trace requires known PC =eject=\n");
			return;
d216 1
a216 2
		frame = addr;
	}
d218 11
a228 10
	while (count--) {
		if (have_trapframe) {
			frame = (db_addr_t)tf + FRAME_SIZE * 8;
			callpc = tf->tf_regs[FRAME_PC];
			ra_from_tf = TRUE;
			have_trapframe = 0;
		}
		sym = db_search_symbol(callpc, DB_STGY_ANY, &diff);
		if (sym == DB_SYM_NULL)
			break;
d230 31
a260 7
		db_symbol_values(sym, &symname, (db_expr_t *)&symval);
		symval_f = (void *)symval;

		if (callpc < symval) {
			db_printf("symbol botch: callpc 0x%lx < "
			    "func 0x%lx (%s)\n", callpc, symval, symname);
			return;
d264 5
a268 25
		 * XXX Printing out arguments is Hard.  We'd have to
		 * keep lots of state as we traverse the frame, figuring
		 * out where the arguments to the function are stored
		 * on the stack.
		 *
		 * Even worse, they may be stored to the stack _after_
		 * being modified in place; arguments are passed in
		 * registers.
		 *
		 * So, in order for this to work reliably, we pretty much
		 * have to have a kernel built with `cc -g':
		 *
		 *	- The debugging symbols would tell us where the
		 *	  arguments are, how many there are, if there were
		 *	  any passed on the stack, etc.
		 *
		 *	- Presumably, the compiler would be careful to
		 *	  store the argument registers on the stack before
		 *	  modifying the registers, so that a debugger could
		 *	  know what those values were upon procedure entry.
		 *
		 * Because of this, we don't bother.  We've got most of the
		 * benefit of back tracking without the arguments, and we
		 * could get the arguments if we use a remote source-level
		 * debugger (for serious debugging).
d270 8
a277 3
		db_printf("%s() at ", symname);
		db_printsym(callpc, DB_STGY_PROC);
		db_printf("\n");
d279 1
d281 4
a284 2
		 * If we are in a trap vector, frame points to a
		 * trapframe.
d286 5
a290 23
		if (sym_is_trapsymbol(symval_f)) {
			tf = (struct trapframe *)frame;

			for (i = 0; special_symbols[i].ss_val != NULL; ++i)
				if (symval_f == special_symbols[i].ss_val)
					db_printf("--- %s",
					    special_symbols[i].ss_note);

			tfps = tf->tf_regs[FRAME_PS];
			if (symval_f == &XentSys)
				decode_syscall(tf->tf_regs[FRAME_V0], p, db_printf);
			if ((tfps & ALPHA_PSL_IPL_MASK) != last_ipl) {
				last_ipl = tfps & ALPHA_PSL_IPL_MASK;
				if (symval_f != &XentSys)
					db_printf(" (from ipl %ld)", last_ipl);
			}
			db_printf(" ---\n");
			if (tfps & ALPHA_PSL_USERMODE) {
				db_printf("--- user mode ---\n");
				break;	/* Terminate search.  */
			}
			have_trapframe = 1;
			continue;
d292 6
d300 2
a301 4
		 * This is a bit trickier; we must decode the function
		 * prologue to find the saved RA.
		 *
		 * XXX How does this interact w/ alloca()?!
d303 3
a305 89
		decode_prologue(callpc, symval, &pi, db_printf);
		if ((pi.pi_regmask & (1 << 26)) == 0) {
			/*
			 * No saved RA found.  We might have RA from
			 * the trap frame, however (e.g trap occurred
			 * in a leaf call).  If not, we've found the
			 * root of the call graph.
			 */
			if (ra_from_tf)
				callpc = tf->tf_regs[FRAME_RA];
			else {
				db_printf("--- root of call graph ---\n");
				break;
			}
		} else
			callpc = *(u_long *)(frame + pi.pi_reg_offset[26]);
		ra_from_tf = ra_from_pcb = FALSE;
#if 0
		/*
		 * The call was actually made at RA - 4; the PC is
		 * updated before being stored in RA.
		 */
		callpc -= 4;
#endif
		frame += pi.pi_frame_size;
	}
}

/*
 * Decode the function prologue for the function we're in, and note
 * which registers are stored where, and how large the stack frame is.
 */
static void
decode_prologue(callpc, func, pi, pr)
	db_addr_t callpc, func;
	struct prologue_info *pi;
	int (*pr) __P((const char *, ...));
{
	long signed_immediate;
	alpha_instruction ins;
	db_expr_t pc;

	pi->pi_regmask = 0;
	pi->pi_frame_size = 0;

#define	CHECK_FRAMESIZE							\
do {									\
	if (pi->pi_frame_size != 0) {					\
		(*pr)("frame size botch: adjust register offsets?\n"); \
	}								\
} while (0)

	for (pc = func; pc < callpc; pc += sizeof(alpha_instruction)) {
		ins.bits = *(unsigned int *)pc;

		if (ins.mem_format.opcode == op_lda &&
		    ins.mem_format.ra == 30 &&
		    ins.mem_format.rb == 30) {
			/*
			 * GCC 2.7-style stack adjust:
			 *
			 *	lda	sp, -64(sp)
			 */
			signed_immediate = (long)ins.mem_format.displacement;
#if 1
			if (signed_immediate > 0)
				(*pr)("prologue botch: displacement %ld\n",
				    signed_immediate);
#endif
			CHECK_FRAMESIZE;
			pi->pi_frame_size += -signed_immediate;
		} else if (ins.operate_lit_format.opcode == op_arit &&
			   ins.operate_lit_format.function == op_subq &&
			   ins.operate_lit_format.ra == 30 &&
			   ins.operate_lit_format.rc == 30) {
			/*
			 * EGCS-style stack adjust:
			 *
			 *	subq	sp, 64, sp
			 */
			CHECK_FRAMESIZE;
			pi->pi_frame_size += ins.operate_lit_format.literal;
		} else if (ins.mem_format.opcode == op_stq &&
			   ins.mem_format.rb == 30 &&
			   ins.mem_format.ra != 31) {
			/* Store of (non-zero) register onto the stack. */
			signed_immediate = (long)ins.mem_format.displacement;
			pi->pi_regmask |= 1 << ins.mem_format.ra;
			pi->pi_reg_offset[ins.mem_format.ra] = signed_immediate;
a306 2
	}
}
d308 5
a312 5
static int
sym_is_trapsymbol(v)
	void *v;
{
	int i;
d314 3
a316 28
	for (i = 0; special_symbols[i].ss_val != NULL; ++i)
		if (v == special_symbols[i].ss_val)
			return 1;
	return 0;
}

static void
decode_syscall(number, p, pr)
	int number;
	struct proc *p;
	int (*pr) __P((const char *, ...));
{
	db_sym_t sym;
	db_expr_t diff;
	char *symname, *ename;
	int (*f) __P((struct proc *, void *, register_t *));

	(*pr)(" (%d", number); /* ) */
	if (!p)
		goto out;
	if (0 <= number && number < p->p_emul->e_nsysent) {
		ename = p->p_emul->e_name;
		f = p->p_emul->e_sysent[number].sy_call;
		sym = db_search_symbol((db_addr_t)f, DB_STGY_ANY, &diff);
		if (sym == DB_SYM_NULL || diff != 0)
			goto out;
		db_symbol_values(sym, &symname, NULL);
		(*pr)(", %s.%s", ename, symname);
a317 3
out:
	(*pr)(")");
	return;
@


1.5
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
@


1.4
log
@Argument lists as good as I can guess at the moment
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.3 1997/07/20 06:58:57 niklas Exp $	*/
d3 10
a12 3
/*
 * Copyright (c) 1997 Niklas Hallqvist.  All rights reserverd.
 * Copyright (c) 1997 Theo de Raadt.  All rights reserverd.
d24 17
a40 15
 *	This product includes software developed by Niklas Hallqvist and
 *	Theo de Raadt.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
a42 1
#include <sys/types.h>
d45 3
d49 1
a49 4
#include <vm/vm.h>

#include <machine/db_machdep.h>
#include <machine/frame.h>
d51 1
d53 1
a53 1
#include <ddb/db_command.h>
a54 3
#include <ddb/db_sym.h>
#include <ddb/db_variables.h>
#include <ddb/db_extern.h>
d57 8
a64 42
extern int	etext;

static __inline int sext __P((u_int));
static __inline int rega __P((u_int));
static __inline int regb __P((u_int));
static __inline int regc __P((u_int));
static __inline int disp __P((u_int));

static __inline int
sext(x)
	u_int x;
{
	return ((x & 0x8000) ? -(-x & 0xffff) : (x & 0xffff));
}

static __inline int
rega(x)
	u_int x;
{
	return ((x >> 21) & 0x1f);
}

static __inline int
regb(x)
	u_int x;
{
	return ((x >> 16) & 0x1f);
}

static __inline int
regc(x)
	u_int x;
{
	return (x & 0x1f);
}

static __inline int
disp(x)
	u_int x;
{
	return (sext(x & 0xffff));
}
d67 1
a67 9
 * XXX There are a couple of problems with this code:
 *
 *	The argument list printout code is likely to get confused.
 *
 *	It relies on the conventions of gcc code generation.
 *
 *	It uses heuristics to calculate the framesize, and might get it wrong.
 *
 *	It doesn't yet use the framepointer if available.
d69 1
a69 3
 *	The address argument can only be used for pointing at trapframes
 *	since a frame pointer of its own serves no good on the alpha,
 *	you need a pc value too.
d71 6
a76 2
 *	The heuristics used for tracing through a trap relies on having
 *	symbols available.
d78 21
d101 4
a104 4
	db_expr_t       addr;
	int             have_addr;
	db_expr_t       count;
	char            *modif;
d106 45
a150 29
	u_long		*frame;
	int		i, framesize;
	db_addr_t	pc, ra;
	u_int		inst;
	char		*name;
	db_expr_t	offset;
	db_regs_t	*regs;
	u_long		*slot[32];

	bzero(slot, sizeof(slot));
	if (count == -1)
		count = 65535;

	regs = have_addr ? (db_regs_t *)addr : DDB_REGS;
trapframe:
	/* remember where various registers are stored */
	for (i = 0; i < 31; i++)
		slot[i] = &regs->tf_regs[0] +
		    ((u_long *)db_regs[i].valuep - &ddb_regs.tf_regs[0]);
	frame = (u_long *)regs->tf_regs[FRAME_SP];
	pc = (db_addr_t)regs->tf_regs[FRAME_PC];
	ra = (db_addr_t)regs->tf_regs[FRAME_RA];

	while (count-- && pc >= (db_addr_t)KERNBASE && pc < (db_addr_t)&etext) {
		db_find_sym_and_offset(pc, &name, &offset);
		if (!name) {
			name = "?";
			/* Limit the search for procedure start */
			offset = 65536;
d152 2
a153 1
		db_printf("%s(", name);
d155 19
a173 11
		framesize = 0;
		for (i = sizeof (int); i <= offset; i += sizeof (int)) {
			inst = *(u_int *)(pc - i);
	
			/*
			 * If by chance we don't have any symbols we have to
			 * get out somehow anyway.  Check for the preceding
			 * procedure return in that case.
			 */
			if (name[0] == '?' && inst_return(inst))
				break;
d175 30
a204 32
			/*
			 * Disassemble to get the needed info for the frame.
			 */
			if ((inst & 0xffff0000) == 0x23de0000)
				/* lda sp,n(sp) */
				framesize -= disp(inst) / sizeof (u_long);
			else if ((inst & 0xfc1f0000) == 0xb41e0000)
				/* stq X,n(sp) */
				slot[rega(inst)] =
				    frame + disp(inst) / sizeof (u_long);
			else if ((inst & 0xfc000fe0) == 0x44000400 &&
			    rega(inst) == regb(inst)) {
				/* bis X,X,Y (aka mov X,Y) */
				/* zero is hardwired */
				if (rega(inst) != 31)
					slot[rega(inst)] = slot[regc(inst)];
				slot[regc(inst)] = 0;
				/*
				 * XXX In here we might special case a frame
				 * pointer setup, i.e. mov sp, fp.
				 */
			} else if (inst_load(inst))
				/* clobbers a register */
				slot[rega(inst)] = 0;
			else if (opcode[inst >> 26].opc_fmt == OPC_OP)
				/* clobbers a register */
				slot[regc(inst)] = 0;
			/*
			 * XXX Recognize more reg clobbering instructions and
			 * set slot[reg] = 0 then too.
			 */
		}
d207 2
a208 5
		 * Try to print the 6 quads that might hold the args.
		 * We print 6 of them even if there are fewer, cause we don't
		 * know the number.  Maybe we could skip the last ones
		 * that never got used.  If we cannot know the value, print
		 * a question mark.
d210 23
a232 7
		for (i = 0; i < 6; i++) {
			if (i > 0)
				db_printf(", ");
			if (slot[16 + i])
				db_printf("%lx", *slot[16 + i]);
			else
				db_printf("?");
d235 23
d260 2
a261 4
		 * XXX This will go eventually when I trust the argument
		 * printout heuristics.
		 *
		 * Print the stack frame contents.
d263 1
a263 9
		db_printf(") [%p: ", frame);
		if (framesize > 1) {
			for (i = 0; i < framesize - 1; i++)
				db_printf("%lx, ", frame[i]);
			db_printf("%lx", frame[i]);
		}
		db_printf("] at ");
#else
		db_printf(") at ");
d265 3
a267 2
		db_printsym(pc, DB_STGY_PROC);
		db_printf("\n");
d269 61
a329 7
		/*
		 * If we are looking at a Xent* routine we are in a trap
		 * context.
		 */
		if (strncmp(name, "Xent", sizeof("Xent") - 1) == 0) {
			regs = (db_regs_t *)frame;
			goto trapframe;
d331 2
d334 34
a367 7
		/* Look for the return address if recorded.  */
		if (slot[26])
			ra = *(db_addr_t *)slot[26];

		/* Advance to the next frame.  */
		frame += framesize;
		pc = ra;
d369 3
@


1.4.12.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.7 2001/03/04 19:19:42 niklas Exp $	*/
a52 67
struct opcode opcode[] = {
	{ OPC_PAL, "call_pal", 0 },	/* 00 */
	{ OPC_RES, "opc01", 0 },	/* 01 */
	{ OPC_RES, "opc02", 0 },	/* 02 */
	{ OPC_RES, "opc03", 0 },	/* 03 */
	{ OPC_RES, "opc04", 0 },	/* 04 */
	{ OPC_RES, "opc05", 0 },	/* 05 */
	{ OPC_RES, "opc06", 0 },	/* 06 */
	{ OPC_RES, "opc07", 0 },	/* 07 */
	{ OPC_MEM, "lda", 1 },		/* 08 */
	{ OPC_MEM, "ldah", 1 },		/* 09 */
	{ OPC_RES, "opc0a", 0 },	/* 0A */
	{ OPC_MEM, "ldq_u", 1 },	/* 0B */
	{ OPC_RES, "opc0c", 0 },	/* 0C */
	{ OPC_RES, "opc0d", 0 },	/* 0D */
	{ OPC_RES, "opc0e", 0 },	/* 0E */
	{ OPC_MEM, "stq_u", 1 },	/* 0F */
	{ OPC_OP, "inta", 0 },		/* 10 */
	{ OPC_OP, "intl", 0 },		/* 11 */
	{ OPC_OP, "ints", 0 },		/* 12 */
	{ OPC_OP, "intm", 0 },		/* 13 */
	{ OPC_RES, "opc14", 0 },	/* 14 */
	{ OPC_OP, "fltv", 1 },		/* 15 */
	{ OPC_OP, "flti", 1 },		/* 16 */
	{ OPC_OP, "fltl", 1 },		/* 17 */
	{ OPC_MEM, "misc", 0 },		/* 18 */
	{ OPC_PAL, "pal19", 0 },	/* 19 */
	{ OPC_MEM, "jsr", 0 },		/* 1A */
	{ OPC_PAL, "pal1b", 0 },	/* 1B */
	{ OPC_RES, "opc1c", 0 },	/* 1C */
	{ OPC_PAL, "pal1d", 0 },	/* 1D */
	{ OPC_PAL, "pal1e", 0 },	/* 1E */
	{ OPC_PAL, "pal1f", 0 },	/* 1F */
	{ OPC_MEM, "ldf", 1 },		/* 20 */
	{ OPC_MEM, "ldg", 1 },		/* 21 */
	{ OPC_MEM, "lds", 1 },		/* 22 */
	{ OPC_MEM, "ldt", 1 },		/* 23 */
	{ OPC_MEM, "stf", 1 },		/* 24 */
	{ OPC_MEM, "stg", 1 },		/* 25 */
	{ OPC_MEM, "sts", 1 },		/* 26 */
	{ OPC_MEM, "stt", 1 },		/* 27 */
	{ OPC_MEM, "ldl", 1 },		/* 28 */
	{ OPC_MEM, "ldq", 1 },		/* 29 */
	{ OPC_MEM, "ldl_l", 1 },	/* 2A */
	{ OPC_MEM, "ldq_l", 1 },	/* 2B */
	{ OPC_MEM, "stl", 1 },		/* 2C */
	{ OPC_MEM, "stq", 1 },		/* 2D */
	{ OPC_MEM, "stl_c", 1 },	/* 2E */
	{ OPC_MEM, "stq_c", 1 },	/* 2F */
	{ OPC_BR, "br", 1 },		/* 30 */
	{ OPC_BR, "fbeq", 1 },		/* 31 */
	{ OPC_BR, "fblt", 1 },		/* 32 */
	{ OPC_BR, "fble", 1 },		/* 33 */
	{ OPC_BR, "bsr", 1 },		/* 34 */
	{ OPC_BR, "fbne", 1 },		/* 35 */
	{ OPC_BR, "fbge", 1 },		/* 36 */
	{ OPC_BR, "fbgt", 1 },		/* 37 */
	{ OPC_BR, "blbc", 1 },		/* 38 */
	{ OPC_BR, "beq", 1 },		/* 39 */
	{ OPC_BR, "blt", 1 },		/* 3A */
	{ OPC_BR, "ble", 1 },		/* 3B */
	{ OPC_BR, "blbs", 1 },		/* 3C */
	{ OPC_BR, "bne", 1 },		/* 3D */
	{ OPC_BR, "bge", 1 },		/* 3E */
	{ OPC_BR, "bgt", 1 },		/* 3F */
};

a243 2
		else
			break;
@


1.4.12.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 1
a38 1
#include <uvm/uvm_extern.h>
@


1.4.12.3
log
@Merge in -current from about a week ago
@
text
@d120 5
a124 5
static __inline int sext(u_int);
static __inline int rega(u_int);
static __inline int regb(u_int);
static __inline int regc(u_int);
static __inline int disp(u_int);
@


1.4.12.4
log
@Sync the SMP branch with 3.3
@
text
@d180 1
a180 1
db_stack_trace_print(addr, have_addr, count, modif, pr)
a184 1
	int		(*pr)(const char *, ...);
d199 1
a199 5
	if (have_addr) {
		(*pr)("alpha trace requires a trap frame... giving up.\n");
		return;
	}
	regs = DDB_REGS;
d216 1
a216 1
		(*pr)("%s(", name);
d272 1
a272 1
				(*pr)(", ");
d274 1
a274 1
				(*pr)("%lx", *slot[16 + i]);
d276 1
a276 1
				(*pr)("?");
d286 1
a286 1
		(*pr)(") [%p: ", frame);
d289 2
a290 2
				(*pr)("%lx, ", frame[i]);
			(*pr)("%lx", frame[i]);
d292 1
a292 1
		(*pr)("] at ");
d294 1
a294 1
		(*pr)(") at ");
d296 2
a297 2
		db_printsym(pc, DB_STGY_PROC, pr);
		(*pr)("\n");
@


1.4.12.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.4.12.4 2003/03/27 22:29:47 niklas Exp $	*/
d15 6
@


1.4.12.6
log
@Merge of -current from two weeks ago into the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 2
a5 2
 * Copyright (c) 1997 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1997 Theo de Raadt.  All rights reserved.
@


1.3
log
@My me and Theo: stack tracebacks!  It even traces through traps and interrupts
if symbols are available.  The biggest drawback is that it will not show
function arguments.  Instead we show the stack frame.  Have fun!
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.2 1997/07/08 20:33:40 niklas Exp $	*/
d53 41
d97 1
a97 2
 *	The argument lists are *not* printed, rather we print the contents
 *	of the stack frame slots.
d120 1
a120 1
	int		i, framesize, ra_index;
d126 1
d128 1
d134 4
a140 1
db_printf("%p %p %lx %lx\n", regs, frame, pc, ra);
d152 1
a152 2
		ra_index = -1;
		for (i = sizeof(int); i <= offset; i += sizeof(int)) {
d164 1
a164 2
			 * Disassemble to get the needed info for the frame 
			 * size calculation.
d167 23
a189 11
				/* lda sp,-n(sp) */
				if (inst & 0x8000)
					framesize += (-inst) & 0xffff;
				else
					framesize -= inst & 0x7fff;
			else if ((inst & 0xffff8000) == 0xb75e0000)
				/* stq ra,+n(sp) */
				ra_index = (inst & 0x7fff) >> 3;
			else if (inst == 0x47de040f) {
				/* XXX bis sp,sp,fp : has an fp register */
			}
d191 2
a192 1
			 * XXX recognize argument saving instructions too.
d197 21
a217 3
		 * Print the stack THINGS.  It's practically impossible
		 * to get at the arguments without *lots* of work, and even
		 * then it might not be possible at all.
d219 3
a221 2
		if ((framesize >> 3) > 1) {
			for (i = 0; i < (framesize >> 3) - 1; i++)
d225 2
d228 1
d240 7
a246 3
		if (ra_index >= 0)
			ra = (db_addr_t)frame[ra_index];
		frame = (u_long *)((vm_offset_t)frame + framesize);
@


1.2
log
@Copyright.  Backtrace for non-optimized code from Theo.  Will get replaced
son enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.1 1997/07/06 16:31:14 niklas Exp $	*/
d5 1
d17 2
a18 1
 *	This product includes software developed by Niklas Hallqvist.
d35 1
d38 2
d41 1
d51 2
d54 17
a70 2
 * XXX This is not yet functional on optimized code.
 * However it might be useful for you if you turn off debugging.
d80 6
a85 2
	int		i;
	db_addr_t	pc;
d90 49
a138 9
	if (!have_addr)
		frame = (u_long *)ddb_regs.tf_regs[FRAME_SP];
	else
		frame = (u_long *)addr;

	while (count--) {
		db_printf("frame %p: \n", frame);
		pc = frame[0];
		db_printf("%lx(", pc);
d141 3
a143 1
		 * Print first possible arguments... like 6 of 'em.
d145 5
a149 2
		for (i = 0; i < 6; i++)
			db_printf("%lx, ", frame[2+i]);
d154 12
a165 1
		frame = (u_long *)frame[1];
@


1.1
log
@DDB support (much not yet implemented).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d16 3
a18 5
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d20 10
a29 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d37 6
d45 4
d56 28
a83 1
	printf("trace not implemented yet\n");
@
