head	1.17;
access;
symbols
	OPENBSD_6_2:1.17.0.4
	OPENBSD_6_2_BASE:1.17
	OPENBSD_6_1:1.16.0.30
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.26
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.22
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.24
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.16
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.20
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.18
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.14
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.12
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.10
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.8
	OPENBSD_5_0:1.16.0.6
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.4
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.9.0.18
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.14
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.12
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.10
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.8
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.6
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.4
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.8.0.8
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.7.0.8
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.6.0.6
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.5.0.18
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.16
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.14
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.12
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2017.09.08.05.36.51;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	uRv5pa9QDlZaYgwD;

1.16
date	2010.07.02.17.27.01;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.28.14.13.25;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.13;

1.13
date	2010.04.12.12.57.51;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2009.11.09.17.53.38;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.31.12.00.05;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.31.06.40.14;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.21.18.16.36;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.03.16.44.46;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.26;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.03.12.10.40;	author art;	state Exp;
branches
	1.6.6.1;
next	1.5;

1.5
date	97.01.24.19.56.43;	author niklas;	state Exp;
branches
	1.5.14.1;
next	1.4;

1.4
date	96.10.30.22.38.25;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.07.29.22.58.00;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.18.09.42.31;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.40;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.40;	author deraadt;	state Exp;
branches;
next	;

1.5.14.1
date	2001.04.18.16.00.31;	author niklas;	state Exp;
branches;
next	1.5.14.2;

1.5.14.2
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	1.5.14.3;

1.5.14.3
date	2004.02.19.09.59.33;	author niklas;	state Exp;
branches;
next	;

1.6.6.1
date	2002.06.11.03.33.39;	author art;	state Exp;
branches;
next	;


desc
@@


1.17
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: promcons.c,v 1.16 2010/07/02 17:27:01 nicm Exp $	*/
/*	$NetBSD: promcons.c,v 1.5 1996/11/13 22:20:55 cgd Exp $	*/

/*
 * Copyright (c) 1994, 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/selinfo.h>
#include <sys/tty.h>
#include <sys/proc.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/device.h>
#include <sys/timeout.h>

#include <dev/cons.h>

#include <machine/rpb.h>
#include <machine/prom.h>

static struct  tty *prom_tty[1];
static struct  timeout prom_to;

void promstart(struct tty *);
void promtimeout(void *);
int promparam(struct tty *, struct termios *);
cdev_decl(prom);
cons_decl(prom);

int
promopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	int unit = minor(dev);
	struct tty *tp;
	int s;
	int error = 0, setuptimeout = 0;
 
	if (unit >= 1)
		return ENXIO;

	s = spltty();

	if (prom_tty[unit] == NULL) {
		tp = prom_tty[unit] = ttymalloc(0);
	} else
		tp = prom_tty[unit];

	tp->t_oproc = promstart;
	tp->t_param = promparam;
	tp->t_dev = dev;
	if ((tp->t_state & TS_ISOPEN) == 0) {
		tp->t_state |= TS_WOPEN|TS_CARR_ON;
		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_cflag = TTYDEF_CFLAG|CLOCAL;
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_ispeed = tp->t_ospeed = 9600;
		ttsetwater(tp);

		setuptimeout = 1;
	} else if (tp->t_state&TS_XCLUDE && suser(p, 0) != 0) {
		splx(s);
		return EBUSY;
	}

	splx(s);

	error = (*linesw[tp->t_line].l_open)(dev, tp, p);
	if (error == 0 && setuptimeout) {
		timeout_set(&prom_to, promtimeout, tp);
		timeout_add(&prom_to, 1);
	}
	return error;
}
 
int
promclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	int unit = minor(dev);
	struct tty *tp = prom_tty[unit];

	timeout_del(&prom_to);
	(*linesw[tp->t_line].l_close)(tp, flag, p);
	ttyclose(tp);
	return 0;
}
 
int
promread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	struct tty *tp = prom_tty[minor(dev)];

	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}
 
int
promwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	struct tty *tp = prom_tty[minor(dev)];
 
	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}
 
int
promioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int unit = minor(dev);
	struct tty *tp = prom_tty[unit];
	int error;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return error;
	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return error;

	return ENOTTY;
}

int
promparam(tp, t)
	struct tty *tp;
	struct termios *t;
{

	return 0;
}

void
promstart(tp)
	struct tty *tp;
{
	int s;

	s = spltty();
	if (tp->t_state & (TS_TTSTOP | TS_BUSY))
		goto out;
	ttwakeupwr(tp);
	tp->t_state |= TS_BUSY;
	while (tp->t_outq.c_cc != 0)
		promcnputc(tp->t_dev, getc(&tp->t_outq));
	tp->t_state &= ~TS_BUSY;
out:
	splx(s);
}

/*
 * Stop output on a line.
 */
int
promstop(tp, flag)
	struct tty *tp;
	int flag;
{
	int s;

	s = spltty();
	if (tp->t_state & TS_BUSY)
		if ((tp->t_state & TS_TTSTOP) == 0)
			tp->t_state |= TS_FLUSH;
	splx(s);
	return 0;
}

void
promtimeout(v)
	void *v;
{
	struct tty *tp = v;
	u_char c;

	while (promcnlookc(tp->t_dev, &c)) {
		if (tp->t_state & TS_ISOPEN)
			(*linesw[tp->t_line].l_rint)(c, tp);
	}
	timeout_add(&prom_to, 1);
}

struct tty *
promtty(dev)
	dev_t dev;
{

	if (minor(dev) != 0)
		panic("promtty: bogus");

	return prom_tty[0];
}
@


1.16
log
@Move common code for waking up writers on a tty into a function.

ok deraadt matthew millert
@
text
@d1 1
a1 1
/*	$OpenBSD: promcons.c,v 1.15 2010/06/28 14:13:25 deraadt Exp $	*/
a41 1
#include <sys/types.h>
@


1.15
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: promcons.c,v 1.14 2010/06/26 23:24:43 guenther Exp $	*/
d187 1
a187 7
	if (tp->t_outq.c_cc <= tp->t_lowat) {
		if (tp->t_state & TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
	}
@


1.14
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: promcons.c,v 1.13 2010/04/12 12:57:51 tedu Exp $	*/
d77 1
a77 1
		tp = prom_tty[unit] = ttymalloc();
@


1.13
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: promcons.c,v 1.12 2009/11/09 17:53:38 nicm Exp $	*/
a36 1
#include <sys/user.h>
@


1.12
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: promcons.c,v 1.11 2009/10/31 12:00:05 fgsch Exp $	*/
d103 1
a103 1
	error = (*linesw[tp->t_line].l_open)(dev, tp);
d121 1
a121 1
	(*linesw[tp->t_line].l_close)(tp, flag);
@


1.11
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: promcons.c,v 1.10 2009/10/31 06:40:14 deraadt Exp $	*/
a193 1
		KNOTE(&tp->t_wsel.si_note, 0);
@


1.10
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: promcons.c,v 1.9 2005/11/21 18:16:36 millert Exp $	*/
d96 1
a96 1
	} else if (tp->t_state&TS_XCLUDE && p->p_ucred->cr_uid != 0) {
@


1.9
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: promcons.c,v 1.8 2003/10/03 16:44:46 miod Exp $	*/
d194 1
@


1.8
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: promcons.c,v 1.7 2002/03/14 01:26:26 millert Exp $	*/
d34 1
a34 1
#include <sys/select.h>
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: promcons.c,v 1.6 2001/02/03 12:10:40 art Exp $	*/
d77 1
a77 1
	if (!prom_tty[unit]) {
a78 1
		tty_attach(tp);
@


1.6
log
@New timeouts.
@
text
@d1 1
a1 1
/*	$OpenBSD: promcons.c,v 1.5 1997/01/24 19:56:43 niklas Exp $	*/
d55 3
a57 3
void promstart __P((struct tty *));
void promtimeout __P((void *));
int promparam __P((struct tty *, struct termios *));
@


1.6.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: promcons.c,v 1.6 2001/02/03 12:10:40 art Exp $	*/
d55 3
a57 3
void promstart(struct tty *);
void promtimeout(void *);
int promparam(struct tty *, struct termios *);
@


1.5
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: promcons.c,v 1.4 1996/10/30 22:38:25 niklas Exp $	*/
d45 1
d53 1
d105 4
a108 2
	if (error == 0 && setuptimeout)
		timeout(promtimeout, tp, 1);
d121 1
a121 1
	untimeout(promtimeout, tp);
d233 1
a233 1
	timeout(promtimeout, tp, 1);
@


1.5.14.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: promcons.c,v 1.6 2001/02/03 12:10:40 art Exp $	*/
a44 1
#include <sys/timeout.h>
a51 1
static struct  timeout prom_to;
d103 2
a104 4
	if (error == 0 && setuptimeout) {
		timeout_set(&prom_to, promtimeout, tp);
		timeout_add(&prom_to, 1);
	}
d117 1
a117 1
	timeout_del(&prom_to);
d229 1
a229 1
	timeout_add(&prom_to, 1);
@


1.5.14.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d55 3
a57 3
void promstart(struct tty *);
void promtimeout(void *);
int promparam(struct tty *, struct termios *);
@


1.5.14.3
log
@Merge of -current from two weeks ago into the SMP branch
@
text
@d77 1
a77 1
	if (prom_tty[unit] == NULL) {
d79 1
@


1.4
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 2
a2 2
/*	$OpenBSD: promcons.c,v 1.3 1996/05/30 18:44:30 cgd Exp $	*/
/*	$NetBSD: promcons.c,v 1.3 1996/05/30 18:44:30 cgd Exp $	*/
d5 1
a5 1
 * Copyright (c) 1994, 1995 Carnegie-Mellon University.
@


1.3
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: promcons.c,v 1.2.6.1 1996/06/03 18:54:31 cgd Exp $	*/
/*	$NetBSD: promcons.c,v 1.2.6.1 1996/06/03 18:54:31 cgd Exp $	*/
d46 5
d53 5
a57 2
void promstart(), promtimeout();
int promparam();
a65 1
	u_short iobase;
d203 1
a203 1
void
d206 1
d215 1
d219 2
a220 2
promtimeout(tp)
	struct tty *tp;
d222 1
@


1.2
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: promcons.c,v 1.2 1995/06/28 02:45:19 cgd Exp $	*/
d67 1
a67 1
	if (!prom_tty[unit])
d69 2
a70 1
	else
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
