head	1.177;
access;
symbols
	OPENBSD_6_0:1.174.0.2
	OPENBSD_6_0_BASE:1.174
	OPENBSD_5_9:1.171.0.2
	OPENBSD_5_9_BASE:1.171
	OPENBSD_5_8:1.170.0.4
	OPENBSD_5_8_BASE:1.170
	OPENBSD_5_7:1.169.0.2
	OPENBSD_5_7_BASE:1.169
	OPENBSD_5_6:1.164.0.4
	OPENBSD_5_6_BASE:1.164
	OPENBSD_5_5:1.149.0.4
	OPENBSD_5_5_BASE:1.149
	OPENBSD_5_4:1.141.0.2
	OPENBSD_5_4_BASE:1.141
	OPENBSD_5_3:1.140.0.2
	OPENBSD_5_3_BASE:1.140
	OPENBSD_5_2:1.135.0.4
	OPENBSD_5_2_BASE:1.135
	OPENBSD_5_1_BASE:1.135
	OPENBSD_5_1:1.135.0.2
	OPENBSD_5_0:1.134.0.2
	OPENBSD_5_0_BASE:1.134
	OPENBSD_4_9:1.128.0.2
	OPENBSD_4_9_BASE:1.128
	OPENBSD_4_8:1.127.0.2
	OPENBSD_4_8_BASE:1.127
	OPENBSD_4_7:1.121.0.2
	OPENBSD_4_7_BASE:1.121
	OPENBSD_4_6:1.117.0.6
	OPENBSD_4_6_BASE:1.117
	OPENBSD_4_5:1.117.0.2
	OPENBSD_4_5_BASE:1.117
	OPENBSD_4_4:1.116.0.2
	OPENBSD_4_4_BASE:1.116
	OPENBSD_4_3:1.113.0.2
	OPENBSD_4_3_BASE:1.113
	OPENBSD_4_2:1.110.0.2
	OPENBSD_4_2_BASE:1.110
	OPENBSD_4_1:1.104.0.2
	OPENBSD_4_1_BASE:1.104
	OPENBSD_4_0:1.103.0.2
	OPENBSD_4_0_BASE:1.103
	OPENBSD_3_9:1.96.0.2
	OPENBSD_3_9_BASE:1.96
	OPENBSD_3_8:1.92.0.2
	OPENBSD_3_8_BASE:1.92
	OPENBSD_3_7:1.90.0.2
	OPENBSD_3_7_BASE:1.90
	OPENBSD_3_6:1.89.0.2
	OPENBSD_3_6_BASE:1.89
	SMP_SYNC_A:1.87
	SMP_SYNC_B:1.87
	OPENBSD_3_5:1.86.0.2
	OPENBSD_3_5_BASE:1.86
	OPENBSD_3_4:1.83.0.2
	OPENBSD_3_4_BASE:1.83
	UBC_SYNC_A:1.81
	OPENBSD_3_3:1.79.0.2
	OPENBSD_3_3_BASE:1.79
	OPENBSD_3_2:1.77.0.2
	OPENBSD_3_2_BASE:1.77
	OPENBSD_3_1:1.69.0.2
	OPENBSD_3_1_BASE:1.69
	UBC_SYNC_B:1.77
	UBC:1.61.0.2
	UBC_BASE:1.61
	OPENBSD_3_0:1.55.0.2
	OPENBSD_3_0_BASE:1.55
	OPENBSD_2_9:1.42.0.2
	OPENBSD_2_9_BASE:1.42
	OPENBSD_2_8:1.33.0.4
	OPENBSD_2_8_BASE:1.33
	OPENBSD_2_7:1.33.0.2
	OPENBSD_2_7_BASE:1.33
	SMP:1.30.0.2
	SMP_BASE:1.30
	kame_19991208:1.29
	OPENBSD_2_6:1.28.0.2
	OPENBSD_2_6_BASE:1.28
	OPENBSD_2_5:1.26.0.2
	OPENBSD_2_5_BASE:1.26
	OPENBSD_2_4:1.24.0.6
	OPENBSD_2_4_BASE:1.24
	OPENBSD_2_3:1.24.0.4
	OPENBSD_2_3_BASE:1.24
	OPENBSD_2_2:1.24.0.2
	OPENBSD_2_2_BASE:1.24
	OPENBSD_2_1:1.18.0.2
	OPENBSD_2_1_BASE:1.18
	OPENBSD_2_0:1.10.0.2
	OPENBSD_2_0_BASE:1.10
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.177
date	2017.01.13.09.18.11;	author fcambus;	state Exp;
branches;
next	1.176;
commitid	C556oRR1TXBPfD4D;

1.176
date	2016.10.09.11.25.39;	author tom;	state Exp;
branches;
next	1.175;
commitid	DfYvEDcFmu1LY9q1;

1.175
date	2016.09.18.14.28.04;	author deraadt;	state Exp;
branches;
next	1.174;
commitid	jG8VZuxIYy3qe4Ce;

1.174
date	2016.05.21.00.56.41;	author deraadt;	state Exp;
branches;
next	1.173;
commitid	oWpLaBOdDMvIxei3;

1.173
date	2016.05.11.17.59.58;	author deraadt;	state Exp;
branches;
next	1.172;
commitid	YaTOMHwXUS3anqz3;

1.172
date	2016.05.10.18.39.40;	author deraadt;	state Exp;
branches;
next	1.171;
commitid	qfOifNidEGDB2jL1;

1.171
date	2015.10.21.07.59.17;	author mpi;	state Exp;
branches;
next	1.170;
commitid	XglPgGQ8qaiL0M4l;

1.170
date	2015.07.03.11.36.19;	author miod;	state Exp;
branches;
next	1.169;
commitid	PRtwKA5aDOh0l3HG;

1.169
date	2015.02.11.01.14.16;	author dlg;	state Exp;
branches;
next	1.168;
commitid	Ux4VreHEmKtji4DY;

1.168
date	2015.02.09.08.48.23;	author miod;	state Exp;
branches;
next	1.167;
commitid	nHILVH7gnv1xZfAl;

1.167
date	2014.12.10.15.29.52;	author mikeb;	state Exp;
branches;
next	1.166;
commitid	qHQiR2HLROzvZr7B;

1.166
date	2014.11.16.12.30.52;	author deraadt;	state Exp;
branches;
next	1.165;
commitid	yv0ECmCdICvq576h;

1.165
date	2014.09.20.09.28.24;	author kettenis;	state Exp;
branches;
next	1.164;
commitid	IFRB8AkvBMXMTAKW;

1.164
date	2014.07.21.17.25.47;	author uebayasi;	state Exp;
branches;
next	1.163;
commitid	7QO4UJr3EKVAMc8t;

1.163
date	2014.07.20.18.24.34;	author deraadt;	state Exp;
branches;
next	1.162;
commitid	Egfn3Q0Hi0Ir68VJ;

1.162
date	2014.07.13.22.53.38;	author uebayasi;	state Exp;
branches;
next	1.161;
commitid	wsdp3qtXGjMj98oD;

1.161
date	2014.07.13.22.13.06;	author uebayasi;	state Exp;
branches;
next	1.160;
commitid	qYPOd6Qi4aRBKldK;

1.160
date	2014.07.10.21.46.02;	author mpi;	state Exp;
branches;
next	1.159;
commitid	iYq3Z1ZWDKR3sS9G;

1.159
date	2014.07.10.20.15.26;	author uebayasi;	state Exp;
branches;
next	1.158;
commitid	YzvTa4t6mddz7Mh4;

1.158
date	2014.07.10.13.34.32;	author uebayasi;	state Exp;
branches;
next	1.157;
commitid	xpsLTYRIkonFtkr1;

1.157
date	2014.07.10.12.13.48;	author uebayasi;	state Exp;
branches;
next	1.156;
commitid	aofvn6ceiucgjg4N;

1.156
date	2014.05.31.15.49.28;	author mpi;	state Exp;
branches;
next	1.155;
commitid	eA4Y0YE1IUzj6hpW;

1.155
date	2014.05.30.13.46.16;	author mpi;	state Exp;
branches;
next	1.154;

1.154
date	2014.05.25.13.57.48;	author deraadt;	state Exp;
branches;
next	1.153;

1.153
date	2014.05.08.20.46.49;	author miod;	state Exp;
branches;
next	1.152;

1.152
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.151;

1.151
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.150;

1.150
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.149;

1.149
date	2014.02.18.19.37.32;	author miod;	state Exp;
branches;
next	1.148;

1.148
date	2014.02.04.21.52.42;	author miod;	state Exp;
branches;
next	1.147;

1.147
date	2014.02.01.21.25.06;	author miod;	state Exp;
branches;
next	1.146;

1.146
date	2014.01.26.17.40.09;	author miod;	state Exp;
branches;
next	1.145;

1.145
date	2013.12.22.18.52.34;	author miod;	state Exp;
branches;
next	1.144;

1.144
date	2013.11.10.19.23.14;	author guenther;	state Exp;
branches;
next	1.143;

1.143
date	2013.10.17.08.02.14;	author deraadt;	state Exp;
branches;
next	1.142;

1.142
date	2013.09.28.12.40.28;	author miod;	state Exp;
branches;
next	1.141;

1.141
date	2013.06.11.16.42.06;	author deraadt;	state Exp;
branches;
next	1.140;

1.140
date	2012.12.02.07.03.30;	author guenther;	state Exp;
branches;
next	1.139;

1.139
date	2012.11.01.21.09.17;	author miod;	state Exp;
branches;
next	1.138;

1.138
date	2012.10.20.19.08.38;	author deraadt;	state Exp;
branches;
next	1.137;

1.137
date	2012.10.08.21.47.45;	author deraadt;	state Exp;
branches;
next	1.136;

1.136
date	2012.08.22.13.33.32;	author okan;	state Exp;
branches;
next	1.135;

1.135
date	2011.11.25.05.23.40;	author miod;	state Exp;
branches;
next	1.134;

1.134
date	2011.07.05.04.48.01;	author guenther;	state Exp;
branches;
next	1.133;

1.133
date	2011.06.26.22.39.58;	author deraadt;	state Exp;
branches;
next	1.132;

1.132
date	2011.06.05.19.41.06;	author deraadt;	state Exp;
branches;
next	1.131;

1.131
date	2011.05.30.22.25.20;	author oga;	state Exp;
branches;
next	1.130;

1.130
date	2011.04.18.21.44.55;	author guenther;	state Exp;
branches;
next	1.129;

1.129
date	2011.04.15.04.52.39;	author guenther;	state Exp;
branches;
next	1.128;

1.128
date	2010.11.28.21.00.03;	author miod;	state Exp;
branches;
next	1.127;

1.127
date	2010.06.30.20.38.49;	author tedu;	state Exp;
branches;
next	1.126;

1.126
date	2010.06.27.13.28.44;	author miod;	state Exp;
branches;
next	1.125;

1.125
date	2010.06.27.05.06.20;	author beck;	state Exp;
branches;
next	1.124;

1.124
date	2010.06.27.03.03.48;	author thib;	state Exp;
branches;
next	1.123;

1.123
date	2010.06.10.17.54.13;	author deraadt;	state Exp;
branches;
next	1.122;

1.122
date	2010.06.09.15.44.15;	author miod;	state Exp;
branches;
next	1.121;

1.121
date	2009.11.07.23.01.36;	author miod;	state Exp;
branches;
next	1.120;

1.120
date	2009.08.11.19.17.14;	author miod;	state Exp;
branches;
next	1.119;

1.119
date	2009.08.11.18.46.30;	author miod;	state Exp;
branches;
next	1.118;

1.118
date	2009.08.09.10.40.17;	author blambert;	state Exp;
branches;
next	1.117;

1.117
date	2009.02.04.17.19.16;	author miod;	state Exp;
branches;
next	1.116;

1.116
date	2008.06.27.17.22.12;	author miod;	state Exp;
branches;
next	1.115;

1.115
date	2008.06.26.05.42.08;	author ray;	state Exp;
branches;
next	1.114;

1.114
date	2008.04.09.16.58.10;	author deraadt;	state Exp;
branches;
next	1.113;

1.113
date	2007.10.10.15.53.51;	author art;	state Exp;
branches;
next	1.112;

1.112
date	2007.09.15.10.10.37;	author martin;	state Exp;
branches;
next	1.111;

1.111
date	2007.08.25.21.49.05;	author kettenis;	state Exp;
branches;
next	1.110;

1.110
date	2007.06.06.17.15.11;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2007.05.29.20.36.47;	author deraadt;	state Exp;
branches;
next	1.108;

1.108
date	2007.05.26.20.26.50;	author pedro;	state Exp;
branches;
next	1.107;

1.107
date	2007.04.23.10.07.43;	author art;	state Exp;
branches;
next	1.106;

1.106
date	2007.04.18.16.53.19;	author martin;	state Exp;
branches;
next	1.105;

1.105
date	2007.04.13.08.31.50;	author martin;	state Exp;
branches;
next	1.104;

1.104
date	2007.02.26.21.30.16;	author miod;	state Exp;
branches;
next	1.103;

1.103
date	2006.07.12.15.32.57;	author martin;	state Exp;
branches;
next	1.102;

1.102
date	2006.06.20.14.06.01;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	2006.06.15.20.08.29;	author brad;	state Exp;
branches;
next	1.100;

1.100
date	2006.06.07.21.50.52;	author miod;	state Exp;
branches;
next	1.99;

1.99
date	2006.04.13.14.41.08;	author brad;	state Exp;
branches;
next	1.98;

1.98
date	2006.03.18.12.03.33;	author miod;	state Exp;
branches;
next	1.97;

1.97
date	2006.03.15.21.03.33;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2006.01.17.20.28.59;	author miod;	state Exp;
branches;
next	1.95;

1.95
date	2005.11.23.01.59.02;	author martin;	state Exp;
branches;
next	1.94;

1.94
date	2005.11.12.18.39.19;	author martin;	state Exp;
branches;
next	1.93;

1.93
date	2005.10.17.18.34.22;	author miod;	state Exp;
branches;
next	1.92;

1.92
date	2005.06.17.21.54.14;	author miod;	state Exp;
branches;
next	1.91;

1.91
date	2005.04.28.17.19.27;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2004.11.02.21.20.56;	author miod;	state Exp;
branches;
next	1.89;

1.89
date	2004.07.06.21.53.59;	author deraadt;	state Exp;
branches;
next	1.88;

1.88
date	2004.07.04.01.13.05;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2004.06.08.18.09.31;	author marc;	state Exp;
branches;
next	1.86;

1.86
date	2004.03.10.23.02.53;	author tom;	state Exp;
branches;
next	1.85;

1.85
date	2004.01.22.17.47.27;	author miod;	state Exp;
branches;
next	1.84;

1.84
date	2003.11.08.06.11.11;	author nordin;	state Exp;
branches;
next	1.83;

1.83
date	2003.08.10.00.03.21;	author miod;	state Exp;
branches;
next	1.82;

1.82
date	2003.06.03.17.31.01;	author drahn;	state Exp;
branches;
next	1.81;

1.81
date	2003.05.11.19.41.08;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2003.05.10.21.11.11;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2002.12.17.23.11.31;	author millert;	state Exp;
branches;
next	1.78;

1.78
date	2002.11.07.04.31.59;	author art;	state Exp;
branches;
next	1.77;

1.77
date	2002.08.24.17.21.44;	author matthieu;	state Exp;
branches;
next	1.76;

1.76
date	2002.07.21.01.09.19;	author art;	state Exp;
branches;
next	1.75;

1.75
date	2002.07.20.19.24.55;	author art;	state Exp;
branches;
next	1.74;

1.74
date	2002.06.08.05.19.12;	author art;	state Exp;
branches;
next	1.73;

1.73
date	2002.06.04.00.09.08;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2002.05.03.00.06.16;	author millert;	state Exp;
branches;
next	1.71;

1.71
date	2002.04.28.20.55.14;	author pvalchev;	state Exp;
branches;
next	1.70;

1.70
date	2002.04.25.00.53.58;	author miod;	state Exp;
branches;
next	1.69;

1.69
date	2002.03.23.13.28.33;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2002.03.14.01.26.26;	author millert;	state Exp;
branches;
next	1.67;

1.67
date	2002.02.17.23.38.16;	author jason;	state Exp;
branches;
next	1.66;

1.66
date	2002.02.17.22.59.52;	author maja;	state Exp;
branches;
next	1.65;

1.65
date	2002.01.23.17.51.52;	author art;	state Exp;
branches;
next	1.64;

1.64
date	2002.01.23.17.35.55;	author art;	state Exp;
branches;
next	1.63;

1.63
date	2002.01.22.21.50.49;	author ericj;	state Exp;
branches;
next	1.62;

1.62
date	2002.01.16.20.50.14;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2001.12.08.02.24.05;	author art;	state Exp;
branches
	1.61.2.1;
next	1.60;

1.60
date	2001.11.28.16.13.27;	author art;	state Exp;
branches;
next	1.59;

1.59
date	2001.11.28.13.47.37;	author art;	state Exp;
branches;
next	1.58;

1.58
date	2001.11.24.17.53.39;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2001.11.07.01.18.00;	author art;	state Exp;
branches;
next	1.56;

1.56
date	2001.11.06.19.53.13;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2001.09.30.13.08.45;	author art;	state Exp;
branches;
next	1.54;

1.54
date	2001.09.19.20.50.55;	author mickey;	state Exp;
branches;
next	1.53;

1.53
date	2001.09.12.14.20.15;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2001.09.12.00.23.33;	author art;	state Exp;
branches;
next	1.51;

1.51
date	2001.08.23.14.01.02;	author art;	state Exp;
branches;
next	1.50;

1.50
date	2001.08.23.12.02.04;	author art;	state Exp;
branches;
next	1.49;

1.49
date	2001.07.05.10.12.03;	author art;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.26.20.25.50;	author art;	state Exp;
branches;
next	1.47;

1.47
date	2001.06.25.00.43.06;	author mickey;	state Exp;
branches;
next	1.46;

1.46
date	2001.05.17.18.41.47;	author provos;	state Exp;
branches;
next	1.45;

1.45
date	2001.05.05.22.33.23;	author art;	state Exp;
branches;
next	1.44;

1.44
date	2001.05.05.20.56.30;	author art;	state Exp;
branches;
next	1.43;

1.43
date	2001.04.30.15.05.34;	author art;	state Exp;
branches;
next	1.42;

1.42
date	2001.02.07.07.22.53;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2001.02.06.17.04.09;	author art;	state Exp;
branches;
next	1.40;

1.40
date	2001.01.24.16.59.12;	author art;	state Exp;
branches;
next	1.39;

1.39
date	2000.12.21.16.54.52;	author aaron;	state Exp;
branches;
next	1.38;

1.38
date	2000.11.19.01.08.08;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2000.11.18.05.26.12;	author ericj;	state Exp;
branches;
next	1.36;

1.36
date	2000.11.16.04.33.46;	author ericj;	state Exp;
branches;
next	1.35;

1.35
date	2000.11.08.19.16.59;	author ericj;	state Exp;
branches;
next	1.34;

1.34
date	2000.11.08.16.01.01;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2000.04.11.02.44.12;	author pjanzen;	state Exp;
branches;
next	1.32;

1.32
date	2000.03.23.09.59.52;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2000.02.22.19.27.40;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2000.02.09.06.01.15;	author itojun;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	99.12.08.06.50.14;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	99.05.24.23.08.55;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	99.05.22.21.22.17;	author weingart;	state Exp;
branches;
next	1.26;

1.26
date	99.03.24.22.56.13;	author alex;	state Exp;
branches;
next	1.25;

1.25
date	99.01.07.23.15.51;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	97.07.31.03.07.55;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	97.07.28.19.32.41;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	97.07.23.06.23.58;	author denny;	state Exp;
branches;
next	1.21;

1.21
date	97.07.08.10.55.54;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	97.07.06.16.25.30;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	97.05.28.22.56.57;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	97.04.14.17.49.58;	author michaels;	state Exp;
branches;
next	1.17;

1.17
date	97.02.03.15.05.02;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.02.03.13.09.14;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.01.24.19.56.37;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	97.01.17.05.53.37;	author kstailey;	state Exp;
branches;
next	1.13;

1.13
date	96.12.08.00.20.18;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	96.11.23.23.19.23;	author kstailey;	state Exp;
branches;
next	1.11;

1.11
date	96.10.30.22.38.14;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	96.07.29.22.57.43;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	96.07.27.11.40.21;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.06.18.09.48.53;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.06.18.09.42.19;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.05.27.07.59.06;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.08.01.26.32;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.01.05.16.17.34;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.26.18.15.10;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.52.40;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.39;	author deraadt;	state Exp;
branches;
next	;

1.30.2.1
date	2000.03.02.07.04.25;	author niklas;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2000.03.24.09.06.54;	author niklas;	state Exp;
branches;
next	1.30.2.3;

1.30.2.3
date	2001.04.18.16.00.22;	author niklas;	state Exp;
branches;
next	1.30.2.4;

1.30.2.4
date	2001.07.04.10.14.21;	author niklas;	state Exp;
branches;
next	1.30.2.5;

1.30.2.5
date	2001.10.31.02.52.44;	author nate;	state Exp;
branches;
next	1.30.2.6;

1.30.2.6
date	2001.11.13.21.00.48;	author niklas;	state Exp;
branches;
next	1.30.2.7;

1.30.2.7
date	2001.12.05.00.39.08;	author niklas;	state Exp;
branches;
next	1.30.2.8;

1.30.2.8
date	2002.03.06.00.47.43;	author niklas;	state Exp;
branches;
next	1.30.2.9;

1.30.2.9
date	2002.03.28.10.06.12;	author niklas;	state Exp;
branches;
next	1.30.2.10;

1.30.2.10
date	2003.03.27.23.18.06;	author niklas;	state Exp;
branches;
next	1.30.2.11;

1.30.2.11
date	2003.05.13.19.41.02;	author ho;	state Exp;
branches;
next	1.30.2.12;

1.30.2.12
date	2003.06.07.11.11.33;	author ho;	state Exp;
branches;
next	1.30.2.13;

1.30.2.13
date	2004.02.19.09.59.33;	author niklas;	state Exp;
branches;
next	1.30.2.14;

1.30.2.14
date	2004.06.05.23.10.42;	author niklas;	state Exp;
branches;
next	1.30.2.15;

1.30.2.15
date	2004.06.08.21.07.17;	author niklas;	state Exp;
branches;
next	;

1.61.2.1
date	2002.01.31.22.55.04;	author niklas;	state Exp;
branches;
next	1.61.2.2;

1.61.2.2
date	2002.06.11.03.33.39;	author art;	state Exp;
branches;
next	1.61.2.3;

1.61.2.3
date	2002.10.29.00.28.00;	author art;	state Exp;
branches;
next	1.61.2.4;

1.61.2.4
date	2003.05.19.21.38.52;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.177
log
@Ansify cpu_sysctl() on alpha, arm, arm64, luna88k and sparc64.

OK mpi@@
@
text
@/* $OpenBSD: machdep.c,v 1.176 2016/10/09 11:25:39 tom Exp $ */
/* $NetBSD: machdep.c,v 1.210 2000/06/01 17:12:38 thorpej Exp $ */

/*-
 * Copyright (c) 1998, 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center and by Chris G. Demetriou.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1994, 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/socket.h>
#include <sys/sched.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/timeout.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/msgbuf.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/user.h>
#include <sys/exec.h>
#include <sys/sysctl.h>
#include <sys/core.h>
#include <sys/kcore.h>

#include <net/if.h>
#include <uvm/uvm.h>

#include <machine/kcore.h>
#ifndef NO_IEEE
#include <machine/fpu.h>
#endif
#include <sys/timetc.h>

#include <sys/mount.h>
#include <sys/syscallargs.h>

#include <dev/cons.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/reg.h>
#include <machine/rpb.h>
#include <machine/prom.h>
#include <machine/cpuconf.h>
#ifndef NO_IEEE
#include <machine/ieeefp.h>
#endif
#ifdef MULTIPROCESSOR
#include <machine/lock.h>
#endif

#include <dev/pci/pcivar.h>

#ifdef DDB
#include <machine/db_machdep.h>
#include <ddb/db_extern.h>
#include <ddb/db_interface.h>
#endif

#include "ioasic.h"

#if NIOASIC > 0
#include <machine/tc_machdep.h>
#include <dev/tc/tcreg.h>
#include <dev/tc/ioasicvar.h>
#endif

int	cpu_dump(void);
int	cpu_dumpsize(void);
u_long	cpu_dump_mempagecnt(void);
void	dumpsys(void);
void	identifycpu(void);
void	regdump(struct trapframe *framep);
void	printregs(struct reg *);

struct uvm_constraint_range  isa_constraint = { 0x0, 0x00ffffffUL };
struct uvm_constraint_range  dma_constraint = { 0x0, (paddr_t)-1 };
struct uvm_constraint_range *uvm_md_constraints[] = {
	&isa_constraint,
	NULL
};

struct vm_map *exec_map = NULL;
struct vm_map *phys_map = NULL;

/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int   safepri = 0;

#ifdef APERTURE
int allowaperture = 0;
#endif

int	totalphysmem;		/* total amount of physical memory in system */
int	physmem;		/* physical mem used by OpenBSD + some rsvd */
int	resvmem;		/* amount of memory reserved for PROM */
int	unusedmem;		/* amount of memory for OS that we don't use */
int	unknownmem;		/* amount of memory with an unknown use */

int	cputype;		/* system type, from the RPB */

int	bootdev_debug = 0;	/* patchable, or from DDB */

/* the following is used externally (sysctl_hw) */
char	machine[] = MACHINE;		/* from <machine/param.h> */
char	cpu_model[128];

struct	user *proc0paddr;

/* Number of machine cycles per microsecond */
u_int64_t	cycles_per_usec;

struct bootinfo_kernel bootinfo;

struct consdev *cn_tab;

/* For built-in TCDS */
#if defined(DEC_3000_300) || defined(DEC_3000_500)
u_int8_t	dec_3000_scsiid[2], dec_3000_scsifast[2];
#endif

struct platform platform;

/* for cpu_sysctl() */
int	alpha_unaligned_print = 1;	/* warn about unaligned accesses */
int	alpha_unaligned_fix = 1;	/* fix up unaligned accesses */
int	alpha_unaligned_sigbus = 1;	/* SIGBUS on fixed-up accesses */
#ifndef NO_IEEE
int	alpha_fp_sync_complete = 0;	/* fp fixup if sync even without /s */
#endif
#if NIOASIC > 0
int	alpha_led_blink = 1;
#endif

/* used by hw_sysctl */
extern char *hw_serial;

/*
 * XXX This should be dynamically sized, but we have the chicken-egg problem!
 * XXX it should also be larger than it is, because not all of the mddt
 * XXX clusters end up being used for VM.
 */
phys_ram_seg_t mem_clusters[VM_PHYSSEG_MAX];	/* low size bits overloaded */
int	mem_cluster_cnt;

void
alpha_init(unused, ptb, bim, bip, biv)
	u_long unused;
	u_long ptb;		/* PFN of current level 1 page table */
	u_long bim;		/* bootinfo magic */
	u_long bip;		/* bootinfo pointer */
	u_long biv;		/* bootinfo version */
{
	extern char kernel_text[], _end[];
	struct mddt *mddtp;
	struct mddt_cluster *memc;
	int i, mddtweird;
	struct vm_physseg *vps;
	vaddr_t kernstart, kernend;
	paddr_t kernstartpfn, kernendpfn, pfn0, pfn1;
	char *p;
	const char *bootinfo_msg;
	const struct cpuinit *c;
	extern caddr_t esym;
	struct cpu_info *ci;
	cpuid_t cpu_id;

	/* NO OUTPUT ALLOWED UNTIL FURTHER NOTICE */

	/*
	 * Turn off interrupts (not mchecks) and floating point.
	 * Make sure the instruction and data streams are consistent.
	 */
	(void)alpha_pal_swpipl(ALPHA_PSL_IPL_HIGH);
	alpha_pal_wrfen(0);
	ALPHA_TBIA();
	alpha_pal_imb();

	/* Initialize the SCB. */
	scb_init();

	cpu_id = cpu_number();

#if defined(MULTIPROCESSOR)
	/*
	 * Set our SysValue to the address of our cpu_info structure.
	 * Secondary processors do this in their spinup trampoline.
	 */
	alpha_pal_wrval((u_long)&cpu_info_primary);
	cpu_info[cpu_id] = &cpu_info_primary;
#endif

	ci = curcpu();
	ci->ci_cpuid = cpu_id;

	/*
	 * Get critical system information (if possible, from the
	 * information provided by the boot program).
	 */
	bootinfo_msg = NULL;
	if (bim == BOOTINFO_MAGIC) {
		if (biv == 0) {		/* backward compat */
			biv = *(u_long *)bip;
			bip += 8;
		}
		switch (biv) {
		case 1: {
			struct bootinfo_v1 *v1p = (struct bootinfo_v1 *)bip;

			bootinfo.ssym = v1p->ssym;
			bootinfo.esym = v1p->esym;
			/* hwrpb may not be provided by boot block in v1 */
			if (v1p->hwrpb != NULL) {
				bootinfo.hwrpb_phys =
				    ((struct rpb *)v1p->hwrpb)->rpb_phys;
				bootinfo.hwrpb_size = v1p->hwrpbsize;
			} else {
				bootinfo.hwrpb_phys =
				    ((struct rpb *)HWRPB_ADDR)->rpb_phys;
				bootinfo.hwrpb_size =
				    ((struct rpb *)HWRPB_ADDR)->rpb_size;
			}
			bcopy(v1p->boot_flags, bootinfo.boot_flags,
			    min(sizeof v1p->boot_flags,
			      sizeof bootinfo.boot_flags));
			bcopy(v1p->booted_kernel, bootinfo.booted_kernel,
			    min(sizeof v1p->booted_kernel,
			      sizeof bootinfo.booted_kernel));
			/* booted dev not provided in bootinfo */
			init_prom_interface((struct rpb *)
			    ALPHA_PHYS_TO_K0SEG(bootinfo.hwrpb_phys));
                	prom_getenv(PROM_E_BOOTED_DEV, bootinfo.booted_dev,
			    sizeof bootinfo.booted_dev);
			break;
		}
		default:
			bootinfo_msg = "unknown bootinfo version";
			goto nobootinfo;
		}
	} else {
		bootinfo_msg = "boot program did not pass bootinfo";
nobootinfo:
		bootinfo.ssym = (u_long)_end;
		bootinfo.esym = (u_long)_end;
		bootinfo.hwrpb_phys = ((struct rpb *)HWRPB_ADDR)->rpb_phys;
		bootinfo.hwrpb_size = ((struct rpb *)HWRPB_ADDR)->rpb_size;
		init_prom_interface((struct rpb *)HWRPB_ADDR);
		prom_getenv(PROM_E_BOOTED_OSFLAGS, bootinfo.boot_flags,
		    sizeof bootinfo.boot_flags);
		prom_getenv(PROM_E_BOOTED_FILE, bootinfo.booted_kernel,
		    sizeof bootinfo.booted_kernel);
		prom_getenv(PROM_E_BOOTED_DEV, bootinfo.booted_dev,
		    sizeof bootinfo.booted_dev);
	}

	esym = (caddr_t)bootinfo.esym;
	/*
	 * Initialize the kernel's mapping of the RPB.  It's needed for
	 * lots of things.
	 */
	hwrpb = (struct rpb *)ALPHA_PHYS_TO_K0SEG(bootinfo.hwrpb_phys);

#if defined(DEC_3000_300) || defined(DEC_3000_500)
	if (hwrpb->rpb_type == ST_DEC_3000_300 ||
	    hwrpb->rpb_type == ST_DEC_3000_500) {
		prom_getenv(PROM_E_SCSIID, dec_3000_scsiid,
		    sizeof(dec_3000_scsiid));
		prom_getenv(PROM_E_SCSIFAST, dec_3000_scsifast,
		    sizeof(dec_3000_scsifast));
	}
#endif

	/*
	 * Remember how many cycles there are per microsecond, 
	 * so that we can use delay().  Round up, for safety.
	 */
	cycles_per_usec = (hwrpb->rpb_cc_freq + 999999) / 1000000;

	/*
	 * Initialize the (temporary) bootstrap console interface, so
	 * we can use printf until the VM system starts being setup.
	 * The real console is initialized before then.
	 */
	init_bootstrap_console();

	/* OUTPUT NOW ALLOWED */

	/* delayed from above */
	if (bootinfo_msg)
		printf("WARNING: %s (0x%lx, 0x%lx, 0x%lx)\n",
		    bootinfo_msg, bim, bip, biv);

	/* Initialize the trap vectors on the primary processor. */
	trap_init();

	/*
	 * Find out what hardware we're on, and do basic initialization.
	 */
	cputype = hwrpb->rpb_type;
	if (cputype < 0) {
		/*
		 * At least some white-box systems have SRM which
		 * reports a systype that's the negative of their
		 * blue-box counterpart.
		 */
		cputype = -cputype;
	}
	c = platform_lookup(cputype);
	if (c == NULL) {
		platform_not_supported();
		/* NOTREACHED */
	}
	(*c->init)();
	strlcpy(cpu_model, platform.model, sizeof cpu_model);

	/*
	 * Initialize the real console, so that the bootstrap console is
	 * no longer necessary.
	 */
	(*platform.cons_init)();

#if 0
	/* Paranoid sanity checking */

	assert(hwrpb->rpb_primary_cpu_id == alpha_pal_whami());

	/*
	 * On single-CPU systypes, the primary should always be CPU 0,
	 * except on Alpha 8200 systems where the CPU id is related
	 * to the VID, which is related to the Turbo Laser node id.
	 */
	if (cputype != ST_DEC_21000)
		assert(hwrpb->rpb_primary_cpu_id == 0);
#endif

	/* NO MORE FIRMWARE ACCESS ALLOWED */
#ifdef _PMAP_MAY_USE_PROM_CONSOLE
	/*
	 * XXX (unless _PMAP_MAY_USE_PROM_CONSOLE is defined and
	 * XXX pmap_uses_prom_console() evaluates to non-zero.)
	 */
#endif

#ifndef SMALL_KERNEL
	/*
	 * If we run on a BWX-capable processor, override cpu_switch
	 * with a faster version.
	 * We do this now because the kernel text might be mapped
	 * read-only eventually (although this is not the case at the moment).
	 */
	if (alpha_implver() >= ALPHA_IMPLVER_EV5) {
		if (~alpha_amask(ALPHA_AMASK_BWX) != 0) {
			extern vaddr_t __bwx_switch0, __bwx_switch1,
			    __bwx_switch2, __bwx_switch3;
			u_int32_t *dst, *src, *end;

			src = (u_int32_t *)&__bwx_switch2;
			end = (u_int32_t *)&__bwx_switch3;
			dst = (u_int32_t *)&__bwx_switch0;
			while (src != end)
				*dst++ = *src++;
			src = (u_int32_t *)&__bwx_switch1;
			end = (u_int32_t *)&__bwx_switch2;
			while (src != end)
				*dst++ = *src++;
		}
	}
#endif

	/*
	 * find out this system's page size
	 */
	if ((uvmexp.pagesize = hwrpb->rpb_page_size) != 8192)
		panic("page size %d != 8192?!", uvmexp.pagesize);

	uvm_setpagesize();

	/*
	 * Find the beginning and end of the kernel (and leave a
	 * bit of space before the beginning for the bootstrap
	 * stack).
	 */
	kernstart = trunc_page((vaddr_t)kernel_text) - 2 * PAGE_SIZE;
	kernend = (vaddr_t)round_page((vaddr_t)bootinfo.esym);

	kernstartpfn = atop(ALPHA_K0SEG_TO_PHYS(kernstart));
	kernendpfn = atop(ALPHA_K0SEG_TO_PHYS(kernend));

	/*
	 * Find out how much memory is available, by looking at
	 * the memory cluster descriptors.  This also tries to do
	 * its best to detect things things that have never been seen
	 * before...
	 */
	mddtp = (struct mddt *)(((caddr_t)hwrpb) + hwrpb->rpb_memdat_off);

	/* MDDT SANITY CHECKING */
	mddtweird = 0;
	if (mddtp->mddt_cluster_cnt < 2) {
		mddtweird = 1;
		printf("WARNING: weird number of mem clusters: %lu\n",
		    (unsigned long)mddtp->mddt_cluster_cnt);
	}

#if 0
	printf("Memory cluster count: %d\n", mddtp->mddt_cluster_cnt);
#endif

	for (i = 0; i < mddtp->mddt_cluster_cnt; i++) {
		memc = &mddtp->mddt_clusters[i];
#if 0
		printf("MEMC %d: pfn 0x%lx cnt 0x%lx usage 0x%lx\n", i,
		    memc->mddt_pfn, memc->mddt_pg_cnt, memc->mddt_usage);
#endif
		totalphysmem += memc->mddt_pg_cnt;
		if (mem_cluster_cnt < VM_PHYSSEG_MAX) {	/* XXX */
			mem_clusters[mem_cluster_cnt].start =
			    ptoa(memc->mddt_pfn);
			mem_clusters[mem_cluster_cnt].size =
			    ptoa(memc->mddt_pg_cnt);
			if (memc->mddt_usage & MDDT_mbz ||
			    memc->mddt_usage & MDDT_NONVOLATILE || /* XXX */
			    memc->mddt_usage & MDDT_PALCODE)
				mem_clusters[mem_cluster_cnt].size |=
				    PROT_READ;
			else
				mem_clusters[mem_cluster_cnt].size |=
				    PROT_READ | PROT_WRITE | PROT_EXEC;
			mem_cluster_cnt++;
		} /* XXX else print something! */

		if (memc->mddt_usage & MDDT_mbz) {
			mddtweird = 1;
			printf("WARNING: mem cluster %d has weird "
			    "usage 0x%lx\n", i, (long)memc->mddt_usage);
			unknownmem += memc->mddt_pg_cnt;
			continue;
		}
		if (memc->mddt_usage & MDDT_NONVOLATILE) {
			/* XXX should handle these... */
			printf("WARNING: skipping non-volatile mem "
			    "cluster %d\n", i);
			unusedmem += memc->mddt_pg_cnt;
			continue;
		}
		if (memc->mddt_usage & MDDT_PALCODE) {
			resvmem += memc->mddt_pg_cnt;
			continue;
		}

		/*
		 * We have a memory cluster available for system
		 * software use.  We must determine if this cluster
		 * holds the kernel.
		 */
#ifdef _PMAP_MAY_USE_PROM_CONSOLE
		/*
		 * XXX If the kernel uses the PROM console, we only use the
		 * XXX memory after the kernel in the first system segment,
		 * XXX to avoid clobbering prom mapping, data, etc.
		 */
	    if (!pmap_uses_prom_console() || physmem == 0) {
#endif /* _PMAP_MAY_USE_PROM_CONSOLE */
		physmem += memc->mddt_pg_cnt;
		pfn0 = memc->mddt_pfn;
		pfn1 = memc->mddt_pfn + memc->mddt_pg_cnt;
		if (pfn0 <= kernstartpfn && kernendpfn <= pfn1) {
			/*
			 * Must compute the location of the kernel
			 * within the segment.
			 */
#if 0
			printf("Cluster %d contains kernel\n", i);
#endif
#ifdef _PMAP_MAY_USE_PROM_CONSOLE
		    if (!pmap_uses_prom_console()) {
#endif /* _PMAP_MAY_USE_PROM_CONSOLE */
			if (pfn0 < kernstartpfn) {
				/*
				 * There is a chunk before the kernel.
				 */
#if 0
				printf("Loading chunk before kernel: "
				    "0x%lx / 0x%lx\n", pfn0, kernstartpfn);
#endif
				uvm_page_physload(pfn0, kernstartpfn,
				    pfn0, kernstartpfn, 0);
			}
#ifdef _PMAP_MAY_USE_PROM_CONSOLE
		    }
#endif /* _PMAP_MAY_USE_PROM_CONSOLE */
			if (kernendpfn < pfn1) {
				/*
				 * There is a chunk after the kernel.
				 */
#if 0
				printf("Loading chunk after kernel: "
				    "0x%lx / 0x%lx\n", kernendpfn, pfn1);
#endif
				uvm_page_physload(kernendpfn, pfn1,
				    kernendpfn, pfn1, 0);
			}
		} else {
			/*
			 * Just load this cluster as one chunk.
			 */
#if 0
			printf("Loading cluster %d: 0x%lx / 0x%lx\n", i,
			    pfn0, pfn1);
#endif
			uvm_page_physload(pfn0, pfn1, pfn0, pfn1, 0);
		}
#ifdef _PMAP_MAY_USE_PROM_CONSOLE
	    }
#endif /* _PMAP_MAY_USE_PROM_CONSOLE */
	}

#ifdef DEBUG
	/*
	 * Dump out the MDDT if it looks odd...
	 */
	if (mddtweird) {
		printf("\n");
		printf("complete memory cluster information:\n");
		for (i = 0; i < mddtp->mddt_cluster_cnt; i++) {
			printf("mddt %d:\n", i);
			printf("\tpfn %lx\n",
			    mddtp->mddt_clusters[i].mddt_pfn);
			printf("\tcnt %lx\n",
			    mddtp->mddt_clusters[i].mddt_pg_cnt);
			printf("\ttest %lx\n",
			    mddtp->mddt_clusters[i].mddt_pg_test);
			printf("\tbva %lx\n",
			    mddtp->mddt_clusters[i].mddt_v_bitaddr);
			printf("\tbpa %lx\n",
			    mddtp->mddt_clusters[i].mddt_p_bitaddr);
			printf("\tbcksum %lx\n",
			    mddtp->mddt_clusters[i].mddt_bit_cksum);
			printf("\tusage %lx\n",
			    mddtp->mddt_clusters[i].mddt_usage);
		}
		printf("\n");
	}
#endif

	if (totalphysmem == 0)
		panic("can't happen: system seems to have no memory!");
#if 0
	printf("totalphysmem = %u\n", totalphysmem);
	printf("physmem = %u\n", physmem);
	printf("resvmem = %d\n", resvmem);
	printf("unusedmem = %d\n", unusedmem);
	printf("unknownmem = %d\n", unknownmem);
#endif

	/*
	 * Initialize error message buffer (at end of core).
	 */
	{
		vsize_t sz = (vsize_t)round_page(MSGBUFSIZE);
		vsize_t reqsz = sz;

		vps = &vm_physmem[vm_nphysseg - 1];

		/* shrink so that it'll fit in the last segment */
		if ((vps->avail_end - vps->avail_start) < atop(sz))
			sz = ptoa(vps->avail_end - vps->avail_start);

		vps->end -= atop(sz);
		vps->avail_end -= atop(sz);
		initmsgbuf((caddr_t) ALPHA_PHYS_TO_K0SEG(ptoa(vps->end)), sz);

		/* Remove the last segment if it now has no pages. */
		if (vps->start == vps->end)
			vm_nphysseg--;

		/* warn if the message buffer had to be shrunk */
		if (sz != reqsz)
			printf("WARNING: %ld bytes not available for msgbuf "
			    "in last cluster (%ld used)\n", reqsz, sz);

	}

	/*
	 * Init mapping for u page(s) for proc 0
	 */
	proc0.p_addr = proc0paddr =
	    (struct user *)pmap_steal_memory(UPAGES * PAGE_SIZE, NULL, NULL);

	/*
	 * Initialize the virtual memory system, and set the
	 * page table base register in proc 0's PCB.
	 */
	pmap_bootstrap(ALPHA_PHYS_TO_K0SEG(ptb << PGSHIFT),
	    hwrpb->rpb_max_asn, hwrpb->rpb_pcs_cnt);

	/*
	 * Initialize the rest of proc 0's PCB, and cache its physical
	 * address.
	 */
	proc0.p_md.md_pcbpaddr =
	    (struct pcb *)ALPHA_K0SEG_TO_PHYS((vaddr_t)&proc0paddr->u_pcb);

	/*
	 * Set the kernel sp, reserving space for an (empty) trapframe,
	 * and make proc0's trapframe pointer point to it for sanity.
	 */
	proc0paddr->u_pcb.pcb_hw.apcb_ksp =
	    (u_int64_t)proc0paddr + USPACE - sizeof(struct trapframe);
	proc0.p_md.md_tf =
	    (struct trapframe *)proc0paddr->u_pcb.pcb_hw.apcb_ksp;

	/*
	 * Initialize the primary CPU's idle PCB to proc0's.  In a
	 * MULTIPROCESSOR configuration, each CPU will later get
	 * its own idle PCB when autoconfiguration runs.
	 */
	ci->ci_idle_pcb = &proc0paddr->u_pcb;
	ci->ci_idle_pcb_paddr = (u_long)proc0.p_md.md_pcbpaddr;

	/*
	 * Look at arguments passed to us and compute boothowto.
	 */

#ifdef KADB
	boothowto |= RB_KDB;
#endif
	for (p = bootinfo.boot_flags; p && *p != '\0'; p++) {
		/*
		 * Note that we'd really like to differentiate case here,
		 * but the Alpha AXP Architecture Reference Manual
		 * says that we shouldn't.
		 */
		switch (*p) {
		case 'a': /* Ignore */
		case 'A':
			break;

		case 'b': /* Enter DDB as soon as the console is initialised */
		case 'B':
			boothowto |= RB_KDB;
			break;

		case 'c': /* enter user kernel configuration */
		case 'C':
			boothowto |= RB_CONFIG;
			break;

#ifdef DEBUG
		case 'd': /* crash dump immediately after autoconfig */
		case 'D':
			boothowto |= RB_DUMP;
			break;
#endif

		case 'h': /* always halt, never reboot */
		case 'H':
			boothowto |= RB_HALT;
			break;


		case 'n': /* askname */
		case 'N':
			boothowto |= RB_ASKNAME;
			break;

		case 's': /* single-user */
		case 'S':
			boothowto |= RB_SINGLE;
			break;

		case '-':
			/*
			 * Just ignore this.  It's not required, but it's
			 * common for it to be passed regardless.
			 */
			break;

		default:
			printf("Unrecognized boot flag '%c'.\n", *p);
			break;
		}
	}


	/*
	 * Figure out the number of cpus in the box, from RPB fields.
	 * Really.  We mean it.
	 */
	for (ncpusfound = 0, i = 0; i < hwrpb->rpb_pcs_cnt; i++) {
		struct pcs *pcsp;

		pcsp = LOCATE_PCS(hwrpb, i);
		if ((pcsp->pcs_flags & PCS_PP) != 0)
			ncpusfound++;
	}

	/*
	 * Initialize debuggers, and break into them if appropriate.
	 */
#ifdef DDB
	db_machine_init();
	ddb_init();

	if (boothowto & RB_KDB)
		Debugger();
#endif
#ifdef KGDB
	if (boothowto & RB_KDB)
		kgdb_connect(0);
#endif
	/*
	 * Figure out our clock frequency, from RPB fields.
	 */
	hz = hwrpb->rpb_intr_freq >> 12;
	if (!(60 <= hz && hz <= 10240)) {
#ifdef DIAGNOSTIC
		printf("WARNING: unbelievable rpb_intr_freq: %lu (%d hz)\n",
			(unsigned long)hwrpb->rpb_intr_freq, hz);
#endif
		hz = 1024;
	}
}

void
consinit()
{

	/*
	 * Everything related to console initialization is done
	 * in alpha_init().
	 */
#if defined(DIAGNOSTIC) && defined(_PMAP_MAY_USE_PROM_CONSOLE)
	printf("consinit: %susing prom console\n",
	    pmap_uses_prom_console() ? "" : "not ");
#endif
}

void
cpu_startup()
{
	vaddr_t minaddr, maxaddr;
#if defined(DEBUG)
	extern int pmapdebug;
	int opmapdebug = pmapdebug;

	pmapdebug = 0;
#endif

	/*
	 * Good {morning,afternoon,evening,night}.
	 */
	printf(version);
	identifycpu();
	printf("real mem = %lu (%luMB)\n", ptoa((psize_t)totalphysmem),
	    ptoa((psize_t)totalphysmem) / 1024 / 1024);
	printf("rsvd mem = %lu (%luMB)\n", ptoa((psize_t)resvmem),
	    ptoa((psize_t)resvmem) / 1024 / 1024);
	if (unusedmem) {
		printf("WARNING: unused memory = %lu (%luMB)\n",
		    ptoa((psize_t)unusedmem),
		    ptoa((psize_t)unusedmem) / 1024 / 1024);
	}
	if (unknownmem) {
		printf("WARNING: %lu (%luMB) of memory with unknown purpose\n",
		    ptoa((psize_t)unknownmem),
		    ptoa((psize_t)unknownmem) / 1024 / 1024);
	}

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	minaddr = vm_map_min(kernel_map);
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    16 * NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);

	/*
	 * Allocate a submap for physio
	 */
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_PHYS_SIZE, 0, FALSE, NULL);

#if defined(DEBUG)
	pmapdebug = opmapdebug;
#endif
	printf("avail mem = %lu (%luMB)\n", ptoa((psize_t)uvmexp.free),
	    ptoa((psize_t)uvmexp.free) / 1024 / 1024);
#if 0
	{
		extern u_long pmap_pages_stolen;

		printf("stolen memory for VM structures = %d\n", pmap_pages_stolen * PAGE_SIZE);
	}
#endif

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();

	/*
	 * Configure the system.
	 */
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}

	/*
	 * Set up the HWPCB so that it's safe to configure secondary
	 * CPUs.
	 */
	hwrpb_primary_init();
}

/*
 * Retrieve the platform name from the DSR.
 */
const char *
alpha_dsr_sysname()
{
	struct dsrdb *dsr;
	const char *sysname;

	/*
	 * DSR does not exist on early HWRPB versions.
	 */
	if (hwrpb->rpb_version < HWRPB_DSRDB_MINVERS)
		return (NULL);

	dsr = (struct dsrdb *)(((caddr_t)hwrpb) + hwrpb->rpb_dsrdb_off);
	sysname = (const char *)((caddr_t)dsr + (dsr->dsr_sysname_off +
	    sizeof(u_int64_t)));
	return (sysname);
}

/*
 * Lookup the system specified system variation in the provided table,
 * returning the model string on match.
 */
const char *
alpha_variation_name(variation, avtp)
	u_int64_t variation;
	const struct alpha_variation_table *avtp;
{
	int i;

	for (i = 0; avtp[i].avt_model != NULL; i++)
		if (avtp[i].avt_variation == variation)
			return (avtp[i].avt_model);
	return (NULL);
}

/*
 * Generate a default platform name based for unknown system variations.
 */
const char *
alpha_unknown_sysname()
{
	static char s[128];		/* safe size */

	snprintf(s, sizeof s, "%s family, unknown model variation 0x%lx",
	    platform.family, (unsigned long)hwrpb->rpb_variation & SV_ST_MASK);
	return ((const char *)s);
}

void
identifycpu()
{
	char *s;
	int slen;

	/*
	 * print out CPU identification information.
	 */
	printf("%s", cpu_model);
	for(s = cpu_model; *s; ++s)
		if(strncasecmp(s, "MHz", 3) == 0)
			goto skipMHz;
	printf(", %luMHz", (unsigned long)hwrpb->rpb_cc_freq / 1000000);
skipMHz:
	/* fill in hw_serial if a serial number is known */
	slen = strlen(hwrpb->rpb_ssn) + 1;
	if (slen > 1) {
		hw_serial = malloc(slen, M_SYSCTL, M_NOWAIT);
		if (hw_serial)
			strlcpy(hw_serial, (char *)hwrpb->rpb_ssn, slen);
	}

	printf("\n");
	printf("%lu byte page size, %d processor%s.\n",
	    (unsigned long)hwrpb->rpb_page_size, ncpusfound,
	    ncpusfound == 1 ? "" : "s");
#if 0
	/* this is not particularly useful! */
	printf("variation: 0x%lx, revision 0x%lx\n",
	    hwrpb->rpb_variation, *(long *)hwrpb->rpb_revision);
#endif
}

int	waittime = -1;
struct pcb dumppcb;

__dead void
boot(int howto)
{
#if defined(MULTIPROCESSOR)
	u_long wait_mask;
	int i;
#endif

	if (cold) {
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
		goto haltsys;
	}

	if ((boothowto & RB_HALT) != 0)
		howto |= RB_HALT;

	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0 && waittime < 0) {
		waittime = 0;
		vfs_shutdown();

		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
	}
	if_downall();

	uvm_shutdown();
	splhigh();
	cold = 1;

#if defined(MULTIPROCESSOR)
	/*
	 * Halt all other CPUs.
	 */
	wait_mask = (1UL << hwrpb->rpb_primary_cpu_id);
	alpha_broadcast_ipi(ALPHA_IPI_HALT);

	/* Ensure any CPUs paused by DDB resume execution so they can halt */
	cpus_paused = 0;

	for (i = 0; i < 10000; i++) {
		alpha_mb();
		if (cpus_running == wait_mask)
			break;
		delay(1000);
	}
	alpha_mb();
	if (cpus_running != wait_mask)
		printf("WARNING: Unable to halt secondary CPUs (0x%lx)\n",
		    cpus_running);
#endif

	if ((howto & RB_DUMP) != 0)
		dumpsys();

haltsys:
	config_suspend_all(DVACT_POWERDOWN);

#ifdef BOOTKEY
	printf("hit any key to %s...\n",
	    (howto & RB_HALT) != 0 ? "halt" : "reboot");
	cnpollc(1);	/* for proper keyboard command handling */
	cngetc();
	cnpollc(0);
	printf("\n");
#endif

	/* Finally, powerdown/halt/reboot the system. */
	if ((howto & RB_POWERDOWN) != 0 &&
	    platform.powerdown != NULL) {
		(*platform.powerdown)();
		printf("WARNING: powerdown failed!\n");
	}
	printf("%s\n\n",
	    (howto & RB_HALT) != 0 ? "halted." : "rebooting...");
	prom_halt((howto & RB_HALT) != 0);
	for (;;)
		continue;
	/* NOTREACHED */
}

/*
 * These variables are needed by /sbin/savecore
 */
u_long	dumpmag = 0x8fca0101;	/* magic number */
int 	dumpsize = 0;		/* pages */
long	dumplo = 0; 		/* blocks */

/*
 * cpu_dumpsize: calculate size of machine-dependent kernel core dump headers.
 */
int
cpu_dumpsize()
{
	int size;

	size = ALIGN(sizeof(kcore_seg_t)) + ALIGN(sizeof(cpu_kcore_hdr_t)) +
	    ALIGN(mem_cluster_cnt * sizeof(phys_ram_seg_t));
	if (roundup(size, dbtob(1)) != dbtob(1))
		return -1;

	return (1);
}

/*
 * cpu_dump_mempagecnt: calculate size of RAM (in pages) to be dumped.
 */
u_long
cpu_dump_mempagecnt()
{
	u_long i, n;

	n = 0;
	for (i = 0; i < mem_cluster_cnt; i++)
		n += atop(mem_clusters[i].size);
	return (n);
}

/*
 * cpu_dump: dump machine-dependent kernel core dump headers.
 */
int
cpu_dump()
{
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
	char buf[dbtob(1)];
	kcore_seg_t *segp;
	cpu_kcore_hdr_t *cpuhdrp;
	phys_ram_seg_t *memsegp;
	int i;

	dump = bdevsw[major(dumpdev)].d_dump;

	bzero(buf, sizeof buf);
	segp = (kcore_seg_t *)buf;
	cpuhdrp = (cpu_kcore_hdr_t *)&buf[ALIGN(sizeof(*segp))];
	memsegp = (phys_ram_seg_t *)&buf[ALIGN(sizeof(*segp)) +
	    ALIGN(sizeof(*cpuhdrp))];

	/*
	 * Generate a segment header.
	 */
	CORE_SETMAGIC(*segp, KCORE_MAGIC, MID_MACHINE, CORE_CPU);
	segp->c_size = dbtob(1) - ALIGN(sizeof(*segp));

	/*
	 * Add the machine-dependent header info.
	 */
	cpuhdrp->lev1map_pa = ALPHA_K0SEG_TO_PHYS((vaddr_t)kernel_lev1map);
	cpuhdrp->page_size = PAGE_SIZE;
	cpuhdrp->nmemsegs = mem_cluster_cnt;

	/*
	 * Fill in the memory segment descriptors.
	 */
	for (i = 0; i < mem_cluster_cnt; i++) {
		memsegp[i].start = mem_clusters[i].start;
		memsegp[i].size = mem_clusters[i].size & ~PAGE_MASK;
	}

	return (dump(dumpdev, dumplo, (caddr_t)buf, dbtob(1)));
}

/*
 * This is called by main to set dumplo and dumpsize.
 * Dumps always skip the first PAGE_SIZE of disk space
 * in case there might be a disk label stored there.
 * If there is extra space, put dump at the end to
 * reduce the chance that swapping trashes it.
 */
void
dumpconf(void)
{
	int nblks, dumpblks;	/* size of dump area */

	if (dumpdev == NODEV ||
	    (nblks = (bdevsw[major(dumpdev)].d_psize)(dumpdev)) == 0)
		return;
	if (nblks <= ctod(1))
		return;

	dumpblks = cpu_dumpsize();
	if (dumpblks < 0)
		return;
	dumpblks += ctod(cpu_dump_mempagecnt());

	/* If dump won't fit (incl. room for possible label), punt. */
	if (dumpblks > (nblks - ctod(1)))
		return;

	/* Put dump at end of partition */
	dumplo = nblks - dumpblks;

	/* dumpsize is in page units, and doesn't include headers. */
	dumpsize = cpu_dump_mempagecnt();
}

/*
 * Dump the kernel's image to the swap partition.
 */
#define	BYTES_PER_DUMP	PAGE_SIZE

void
dumpsys()
{
	u_long totalbytesleft, bytes, i, n, memcl;
	u_long maddr;
	int psize;
	daddr_t blkno;
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
	int error;
	extern int msgbufmapped;

	/* Save registers. */
	savectx(&dumppcb);

	msgbufmapped = 0;	/* don't record dump msgs in msgbuf */
	if (dumpdev == NODEV)
		return;

	/*
	 * For dumps during autoconfiguration,
	 * if dump device has already configured...
	 */
	if (dumpsize == 0)
		dumpconf();
	if (dumplo <= 0) {
		printf("\ndump to dev %u,%u not possible\n", major(dumpdev),
		    minor(dumpdev));
		return;
	}
	printf("\ndumping to dev %u,%u offset %ld\n", major(dumpdev),
	    minor(dumpdev), dumplo);

	psize = (*bdevsw[major(dumpdev)].d_psize)(dumpdev);
	printf("dump ");
	if (psize == -1) {
		printf("area unavailable\n");
		return;
	}

	/* XXX should purge all outstanding keystrokes. */

	if ((error = cpu_dump()) != 0)
		goto err;

	totalbytesleft = ptoa(cpu_dump_mempagecnt());
	blkno = dumplo + cpu_dumpsize();
	dump = bdevsw[major(dumpdev)].d_dump;
	error = 0;

	for (memcl = 0; memcl < mem_cluster_cnt; memcl++) {
		maddr = mem_clusters[memcl].start;
		bytes = mem_clusters[memcl].size & ~PAGE_MASK;

		for (i = 0; i < bytes; i += n, totalbytesleft -= n) {

			/* Print out how many MBs we to go. */
			if ((totalbytesleft % (1024*1024)) == 0)
				printf("%ld ", totalbytesleft / (1024 * 1024));

			/* Limit size for next transfer. */
			n = bytes - i;
			if (n > BYTES_PER_DUMP)
				n =  BYTES_PER_DUMP;
	
			error = (*dump)(dumpdev, blkno,
			    (caddr_t)ALPHA_PHYS_TO_K0SEG(maddr), n);
			if (error)
				goto err;
			maddr += n;
			blkno += btodb(n);			/* XXX? */

			/* XXX should look for keystrokes, to cancel. */
		}
	}

err:
	switch (error) {
#ifdef DEBUG
	case ENXIO:
		printf("device bad\n");
		break;

	case EFAULT:
		printf("device not ready\n");
		break;

	case EINVAL:
		printf("area improper\n");
		break;

	case EIO:
		printf("i/o error\n");
		break;

	case EINTR:
		printf("aborted from console\n");
		break;
#endif /* DEBUG */
	case 0:
		printf("succeeded\n");
		break;

	default:
		printf("error %d\n", error);
		break;
	}
	printf("\n\n");
	delay(1000);
}

void
frametoreg(framep, regp)
	struct trapframe *framep;
	struct reg *regp;
{

	regp->r_regs[R_V0] = framep->tf_regs[FRAME_V0];
	regp->r_regs[R_T0] = framep->tf_regs[FRAME_T0];
	regp->r_regs[R_T1] = framep->tf_regs[FRAME_T1];
	regp->r_regs[R_T2] = framep->tf_regs[FRAME_T2];
	regp->r_regs[R_T3] = framep->tf_regs[FRAME_T3];
	regp->r_regs[R_T4] = framep->tf_regs[FRAME_T4];
	regp->r_regs[R_T5] = framep->tf_regs[FRAME_T5];
	regp->r_regs[R_T6] = framep->tf_regs[FRAME_T6];
	regp->r_regs[R_T7] = framep->tf_regs[FRAME_T7];
	regp->r_regs[R_S0] = framep->tf_regs[FRAME_S0];
	regp->r_regs[R_S1] = framep->tf_regs[FRAME_S1];
	regp->r_regs[R_S2] = framep->tf_regs[FRAME_S2];
	regp->r_regs[R_S3] = framep->tf_regs[FRAME_S3];
	regp->r_regs[R_S4] = framep->tf_regs[FRAME_S4];
	regp->r_regs[R_S5] = framep->tf_regs[FRAME_S5];
	regp->r_regs[R_S6] = framep->tf_regs[FRAME_S6];
	regp->r_regs[R_A0] = framep->tf_regs[FRAME_A0];
	regp->r_regs[R_A1] = framep->tf_regs[FRAME_A1];
	regp->r_regs[R_A2] = framep->tf_regs[FRAME_A2];
	regp->r_regs[R_A3] = framep->tf_regs[FRAME_A3];
	regp->r_regs[R_A4] = framep->tf_regs[FRAME_A4];
	regp->r_regs[R_A5] = framep->tf_regs[FRAME_A5];
	regp->r_regs[R_T8] = framep->tf_regs[FRAME_T8];
	regp->r_regs[R_T9] = framep->tf_regs[FRAME_T9];
	regp->r_regs[R_T10] = framep->tf_regs[FRAME_T10];
	regp->r_regs[R_T11] = framep->tf_regs[FRAME_T11];
	regp->r_regs[R_RA] = framep->tf_regs[FRAME_RA];
	regp->r_regs[R_T12] = framep->tf_regs[FRAME_T12];
	regp->r_regs[R_AT] = framep->tf_regs[FRAME_AT];
	regp->r_regs[R_GP] = framep->tf_regs[FRAME_GP];
	/* regp->r_regs[R_SP] = framep->tf_regs[FRAME_SP]; XXX */
	regp->r_regs[R_ZERO] = 0;
}

void
regtoframe(regp, framep)
	struct reg *regp;
	struct trapframe *framep;
{

	framep->tf_regs[FRAME_V0] = regp->r_regs[R_V0];
	framep->tf_regs[FRAME_T0] = regp->r_regs[R_T0];
	framep->tf_regs[FRAME_T1] = regp->r_regs[R_T1];
	framep->tf_regs[FRAME_T2] = regp->r_regs[R_T2];
	framep->tf_regs[FRAME_T3] = regp->r_regs[R_T3];
	framep->tf_regs[FRAME_T4] = regp->r_regs[R_T4];
	framep->tf_regs[FRAME_T5] = regp->r_regs[R_T5];
	framep->tf_regs[FRAME_T6] = regp->r_regs[R_T6];
	framep->tf_regs[FRAME_T7] = regp->r_regs[R_T7];
	framep->tf_regs[FRAME_S0] = regp->r_regs[R_S0];
	framep->tf_regs[FRAME_S1] = regp->r_regs[R_S1];
	framep->tf_regs[FRAME_S2] = regp->r_regs[R_S2];
	framep->tf_regs[FRAME_S3] = regp->r_regs[R_S3];
	framep->tf_regs[FRAME_S4] = regp->r_regs[R_S4];
	framep->tf_regs[FRAME_S5] = regp->r_regs[R_S5];
	framep->tf_regs[FRAME_S6] = regp->r_regs[R_S6];
	framep->tf_regs[FRAME_A0] = regp->r_regs[R_A0];
	framep->tf_regs[FRAME_A1] = regp->r_regs[R_A1];
	framep->tf_regs[FRAME_A2] = regp->r_regs[R_A2];
	framep->tf_regs[FRAME_A3] = regp->r_regs[R_A3];
	framep->tf_regs[FRAME_A4] = regp->r_regs[R_A4];
	framep->tf_regs[FRAME_A5] = regp->r_regs[R_A5];
	framep->tf_regs[FRAME_T8] = regp->r_regs[R_T8];
	framep->tf_regs[FRAME_T9] = regp->r_regs[R_T9];
	framep->tf_regs[FRAME_T10] = regp->r_regs[R_T10];
	framep->tf_regs[FRAME_T11] = regp->r_regs[R_T11];
	framep->tf_regs[FRAME_RA] = regp->r_regs[R_RA];
	framep->tf_regs[FRAME_T12] = regp->r_regs[R_T12];
	framep->tf_regs[FRAME_AT] = regp->r_regs[R_AT];
	framep->tf_regs[FRAME_GP] = regp->r_regs[R_GP];
	/* framep->tf_regs[FRAME_SP] = regp->r_regs[R_SP]; XXX */
	/* ??? = regp->r_regs[R_ZERO]; */
}

void
printregs(regp)
	struct reg *regp;
{
	int i;

	for (i = 0; i < 32; i++)
		printf("R%d:\t0x%016lx%s", i, regp->r_regs[i],
		   i & 1 ? "\n" : "\t");
}

void
regdump(framep)
	struct trapframe *framep;
{
	struct reg reg;

	frametoreg(framep, &reg);
	reg.r_regs[R_SP] = alpha_pal_rdusp();

	printf("REGISTERS:\n");
	printregs(&reg);
}

#ifdef DEBUG
int sigdebug = 0;
pid_t sigpid = 0;
#define	SDB_FOLLOW	0x01
#define	SDB_KSTACK	0x02
#endif

/*
 * Send an interrupt to process.
 */
void
sendsig(sig_t catcher, int sig, int mask, u_long code, int type,
    union sigval val)
{
	struct proc *p = curproc;
	struct sigcontext ksc, *scp;
	struct fpreg *fpregs = (struct fpreg *)&ksc.sc_fpregs;
	struct trapframe *frame;
	struct sigacts *psp = p->p_p->ps_sigacts;
	unsigned long oldsp;
	int fsize, rndfsize, kscsize;
	siginfo_t *sip, ksi;

	oldsp = alpha_pal_rdusp();
	frame = p->p_md.md_tf;
	fsize = sizeof ksc;
	rndfsize = ((fsize + 15) / 16) * 16;
	kscsize = rndfsize;
	if (psp->ps_siginfo & sigmask(sig)) {
		fsize += sizeof ksi;
		rndfsize = ((fsize + 15) / 16) * 16;
	}

	/*
	 * Allocate space for the signal handler context.
	 */
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 &&
	    !sigonstack(oldsp) && (psp->ps_sigonstack & sigmask(sig)))
		scp = (struct sigcontext *)(p->p_sigstk.ss_sp +
		    p->p_sigstk.ss_size - rndfsize);
	else
		scp = (struct sigcontext *)(oldsp - rndfsize);

	/*
	 * Build the signal context to be used by sigreturn.
	 */
	bzero(&ksc, sizeof(ksc));
	ksc.sc_mask = mask;
	ksc.sc_pc = frame->tf_regs[FRAME_PC];
	ksc.sc_ps = frame->tf_regs[FRAME_PS];

	/* copy the registers. */
	frametoreg(frame, (struct reg *)ksc.sc_regs);
	ksc.sc_regs[R_SP] = oldsp;

	/* save the floating-point state, if necessary, then copy it. */
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 1);
	ksc.sc_ownedfp = p->p_md.md_flags & MDP_FPUSED;
	memcpy(/*ksc.sc_*/fpregs, &p->p_addr->u_pcb.pcb_fp,
	    sizeof(struct fpreg));
#ifndef NO_IEEE
	ksc.sc_fp_control = alpha_read_fp_c(p);
#else
	ksc.sc_fp_control = 0;
#endif
	memset(ksc.sc_reserved, 0, sizeof ksc.sc_reserved);	/* XXX */
	memset(ksc.sc_xxx, 0, sizeof ksc.sc_xxx);		/* XXX */

	if (psp->ps_siginfo & sigmask(sig)) {
		initsiginfo(&ksi, sig, code, type, val);
		sip = (void *)scp + kscsize;
		if (copyout((caddr_t)&ksi, (caddr_t)sip, fsize - kscsize) != 0)
			goto trash;
	} else
		sip = NULL;

	ksc.sc_cookie = (long)scp ^ p->p_p->ps_sigcookie;
	if (copyout((caddr_t)&ksc, (caddr_t)scp, kscsize) != 0) {
trash:
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		sigexit(p, SIGILL);
		/* NOTREACHED */
	}

	/*
	 * Set up the registers to return to sigcode.
	 */
	frame->tf_regs[FRAME_PC] = p->p_p->ps_sigcode;
	frame->tf_regs[FRAME_A0] = sig;
	frame->tf_regs[FRAME_A1] = (u_int64_t)sip;
	frame->tf_regs[FRAME_A2] = (u_int64_t)scp;
	frame->tf_regs[FRAME_T12] = (u_int64_t)catcher;		/* t12 is pv */
	alpha_pal_wrusp((unsigned long)scp);
}

/*
 * System call to cleanup state after a signal
 * has been taken.  Reset signal mask and
 * stack state from context left by sendsig (above).
 * Return to previous pc and psl as specified by
 * context left by sendsig. Check carefully to
 * make sure that the user has not modified the
 * psl to gain improper privileges or to cause
 * a machine fault.
 */
/* ARGSUSED */
int
sys_sigreturn(struct proc *p, void *v, register_t *retval)
{
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	struct sigcontext ksc, *scp = SCARG(uap, sigcntxp);
	struct fpreg *fpregs = (struct fpreg *)&ksc.sc_fpregs;
	int error;

	if (PROC_PC(p) != p->p_p->ps_sigcoderet) {
		sigexit(p, SIGILL);
		return (EPERM);
	}

	if ((error = copyin(scp, &ksc, sizeof(ksc))) != 0)
		return (error);

	if (ksc.sc_cookie != ((long)scp ^ p->p_p->ps_sigcookie)) {
		sigexit(p, SIGILL);
		return (EFAULT);
	}

	/* Prevent reuse of the sigcontext cookie */
	ksc.sc_cookie = 0;
	(void)copyout(&ksc.sc_cookie, (caddr_t)scp +
	    offsetof(struct sigcontext, sc_cookie), sizeof (ksc.sc_cookie));

	/*
	 * Restore the user-supplied information
	 */
	p->p_sigmask = ksc.sc_mask &~ sigcantmask;

	p->p_md.md_tf->tf_regs[FRAME_PC] = ksc.sc_pc;
	p->p_md.md_tf->tf_regs[FRAME_PS] =
	    (ksc.sc_ps | ALPHA_PSL_USERSET) & ~ALPHA_PSL_USERCLR;

	regtoframe((struct reg *)ksc.sc_regs, p->p_md.md_tf);
	alpha_pal_wrusp(ksc.sc_regs[R_SP]);

	/* XXX ksc.sc_ownedfp ? */
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 0);
	memcpy(&p->p_addr->u_pcb.pcb_fp, /*ksc.sc_*/fpregs,
	    sizeof(struct fpreg));
#ifndef NO_IEEE
	p->p_addr->u_pcb.pcb_fp.fpr_cr = ksc.sc_fpcr;
	p->p_md.md_flags = ksc.sc_fp_control & MDP_FP_C;
#endif
	return (EJUSTRETURN);
}

/*
 * machine dependent system variables.
 */
int
cpu_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
	dev_t consdev;
#if NIOASIC > 0
	int oldval, ret;
#endif

	if (name[0] != CPU_CHIPSET && namelen != 1)
		return (ENOTDIR);		/* overloaded */

	switch (name[0]) {
	case CPU_CONSDEV:
		if (cn_tab != NULL)
			consdev = cn_tab->cn_dev;
		else
			consdev = NODEV;
		return (sysctl_rdstruct(oldp, oldlenp, newp, &consdev,
			sizeof consdev));

#ifndef SMALL_KERNEL
	case CPU_UNALIGNED_PRINT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &alpha_unaligned_print));

	case CPU_UNALIGNED_FIX:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &alpha_unaligned_fix));

	case CPU_UNALIGNED_SIGBUS:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &alpha_unaligned_sigbus));

	case CPU_BOOTED_KERNEL:
		return (sysctl_rdstring(oldp, oldlenp, newp,
		    bootinfo.booted_kernel));
	
	case CPU_CHIPSET:
		return (alpha_sysctl_chipset(name + 1, namelen - 1, oldp,
		    oldlenp));
#endif /* SMALL_KERNEL */

#ifndef NO_IEEE
	case CPU_FP_SYNC_COMPLETE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &alpha_fp_sync_complete));
#endif
	case CPU_ALLOWAPERTURE:
#ifdef APERTURE
		if (securelevel > 0)
			return (sysctl_int_lower(oldp, oldlenp, newp, newlen,
			    &allowaperture));
                else
                        return (sysctl_int(oldp, oldlenp, newp, newlen,
                            &allowaperture));
#else
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
#endif
#if NIOASIC > 0
	case CPU_LED_BLINK:
		oldval = alpha_led_blink;
		ret = sysctl_int(oldp, oldlenp, newp, newlen, &alpha_led_blink);
		if (oldval != alpha_led_blink)
			ioasic_led_blink(NULL);
		return (ret);
#endif
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

/*
 * Set registers on exec.
 */
void
setregs(p, pack, stack, retval)
	register struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
{
	struct trapframe *tfp = p->p_md.md_tf;
#ifdef DEBUG
	int i;
#endif

#ifdef DEBUG
	/*
	 * Crash and dump, if the user requested it.
	 */
	if (boothowto & RB_DUMP)
		panic("crash requested by boot flags");
#endif

#ifdef DEBUG
	for (i = 0; i < FRAME_SIZE; i++)
		tfp->tf_regs[i] = 0xbabefacedeadbeef;
	tfp->tf_regs[FRAME_A1] = 0;
#else
	bzero(tfp->tf_regs, FRAME_SIZE * sizeof tfp->tf_regs[0]);
#endif
	bzero(&p->p_addr->u_pcb.pcb_fp, sizeof p->p_addr->u_pcb.pcb_fp);
	alpha_pal_wrusp(stack);
	tfp->tf_regs[FRAME_PS] = ALPHA_PSL_USERSET;
	tfp->tf_regs[FRAME_PC] = pack->ep_entry & ~3;

	tfp->tf_regs[FRAME_A0] = stack;
	/* a1 and a2 already zeroed */
	tfp->tf_regs[FRAME_T12] = tfp->tf_regs[FRAME_PC];	/* a.k.a. PV */

	p->p_md.md_flags &= ~MDP_FPUSED;
#ifndef NO_IEEE
	if (__predict_true((p->p_md.md_flags & IEEE_INHERIT) == 0)) {
		p->p_md.md_flags &= ~MDP_FP_C;
		p->p_addr->u_pcb.pcb_fp.fpr_cr = FPCR_DYN(FP_RN);
	}
#endif
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 0);

	retval[1] = 0;
}

/*
 * Release the FPU.
 */
void
fpusave_cpu(struct cpu_info *ci, int save)
{
	struct proc *p;
#if defined(MULTIPROCESSOR)
	int s;
#endif

	KDASSERT(ci == curcpu());

#if defined(MULTIPROCESSOR)
	/* Need to block IPIs */
	s = splipi();
	atomic_setbits_ulong(&ci->ci_flags, CPUF_FPUSAVE);
#endif

	p = ci->ci_fpcurproc;
	if (p == NULL)
		goto out;

	if (save) {
		alpha_pal_wrfen(1);
		savefpstate(&p->p_addr->u_pcb.pcb_fp);
	}

	alpha_pal_wrfen(0);

	p->p_addr->u_pcb.pcb_fpcpu = NULL;
	ci->ci_fpcurproc = NULL;

out:
#if defined(MULTIPROCESSOR)
	atomic_clearbits_ulong(&ci->ci_flags, CPUF_FPUSAVE);
	alpha_pal_swpipl(s);
#endif
	return;
}

/*
 * Synchronize FP state for this process.
 */
void
fpusave_proc(struct proc *p, int save)
{
	struct cpu_info *ci = curcpu();
	struct cpu_info *oci;
#if defined(MULTIPROCESSOR)
	u_long ipi = save ? ALPHA_IPI_SYNCH_FPU : ALPHA_IPI_DISCARD_FPU;
	int s;
#endif

	KDASSERT(p->p_addr != NULL);

	for (;;) {
#if defined(MULTIPROCESSOR)
		/* Need to block IPIs */
		s = splipi();
#endif

		oci = p->p_addr->u_pcb.pcb_fpcpu;
		if (oci == NULL) {
#if defined(MULTIPROCESSOR)
			alpha_pal_swpipl(s);
#endif
			return;
		}

#if defined(MULTIPROCESSOR)
		if (oci == ci) {
			KASSERT(ci->ci_fpcurproc == p);
			alpha_pal_swpipl(s);
			fpusave_cpu(ci, save);
			return;
		}

		/*
		 * The other cpu may still be running and could have
		 * discarded the fpu context on its own.
		 */
		if (oci->ci_fpcurproc != p) {
			alpha_pal_swpipl(s);
			continue;
		}

		alpha_send_ipi(oci->ci_cpuid, ipi);
		alpha_pal_swpipl(s);

		while (p->p_addr->u_pcb.pcb_fpcpu != NULL)
			SPINLOCK_SPIN_HOOK;
#else
		KASSERT(ci->ci_fpcurproc == p);
		fpusave_cpu(ci, save);
#endif /* MULTIPROCESSOR */

		break;
	}
}

int
spl0()
{

	if (ssir) {
		(void) alpha_pal_swpipl(ALPHA_PSL_IPL_SOFT);
		softintr_dispatch();
	}

	return (alpha_pal_swpipl(ALPHA_PSL_IPL_0));
}

/*
 * Wait "n" microseconds.
 */
void
delay(n)
	unsigned long n;
{
	unsigned long pcc0, pcc1, curcycle, cycles, usec;

	if (n == 0)
		return;

	pcc0 = alpha_rpcc() & 0xffffffffUL;
	cycles = 0;
	usec = 0;

	while (usec <= n) {
		/*
		 * Get the next CPU cycle count - assumes that we can not
		 * have had more than one 32 bit overflow.
		 */
		pcc1 = alpha_rpcc() & 0xffffffffUL;
		if (pcc1 < pcc0)
			curcycle = (pcc1 + 0x100000000UL) - pcc0;
		else
			curcycle = pcc1 - pcc0;

		/*
		 * We now have the number of processor cycles since we
		 * last checked. Add the current cycle count to the
		 * running total. If it's over cycles_per_usec, increment
		 * the usec counter.
		 */
		cycles += curcycle;
		while (cycles >= cycles_per_usec) {
			usec++;
			cycles -= cycles_per_usec;
		}
		pcc0 = pcc1;
	}
}

int
alpha_pa_access(pa)
	u_long pa;
{
	int i;

	for (i = 0; i < mem_cluster_cnt; i++) {
		if (pa < mem_clusters[i].start)
			continue;
		if ((pa - mem_clusters[i].start) >=
		    (mem_clusters[i].size & ~PAGE_MASK))
			continue;
		return (mem_clusters[i].size & PAGE_MASK);	/* prot */
	}

	/*
	 * Address is not a memory address.  If we're secure, disallow
	 * access.  Otherwise, grant read/write.
	 */
	if (securelevel > 0)
		return (PROT_NONE);
	else
		return (PROT_READ | PROT_WRITE);
}

/* XXX XXX BEGIN XXX XXX */
paddr_t alpha_XXX_dmamap_or;					/* XXX */
								/* XXX */
paddr_t								/* XXX */
alpha_XXX_dmamap(v)						/* XXX */
	vaddr_t v;						/* XXX */
{								/* XXX */
								/* XXX */
	return (vtophys(v) | alpha_XXX_dmamap_or);		/* XXX */
}								/* XXX */
/* XXX XXX END XXX XXX */
@


1.176
log
@Apply consistency to forever loops with continue and NOTREACHED

Same thought from kettenis@@, ok krw@@ phessler@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.175 2016/09/18 14:28:04 deraadt Exp $ */
d1556 2
a1557 8
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
@


1.175
log
@option INSECURE is obsolete
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.174 2016/05/21 00:56:41 deraadt Exp $ */
d1050 2
a1051 1
	for (;;) ;
@


1.174
log
@hand-massage sendsig() and sys_sigreturn() to be much more similar.
ok guenther kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.173 2016/05/11 17:59:58 deraadt Exp $ */
a152 3
#ifdef INSECURE
int allowaperture = 1;
#else
a153 1
#endif
@


1.173
log
@Add the sigcontext cookie clearing block, which was missed in the previous
commit.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.172 2016/05/10 18:39:40 deraadt Exp $ */
d1404 2
a1405 6
sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
d1408 1
a1408 1
	struct sigcontext *scp, ksc;
a1434 5
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig(%d): sig %d ssp %p usp %p\n", p->p_pid,
		    sig, &ksc, scp);
#endif
a1445 1
	ksc.sc_regs[R_ZERO] = 0xACEDBADE;		/* magic number */
a1472 5
#ifdef DEBUG
		if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
			printf("sendsig(%d): copyout failed on sig %d\n",
			    p->p_pid, sig);
#endif
a1479 5
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sendsig(%d): sig %d scp %p code %lx\n", p->p_pid, sig,
		    scp, code);
#endif
a1489 9

#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sendsig(%d): pc %lx, catcher %lx\n", p->p_pid,
		    frame->tf_regs[FRAME_PC], frame->tf_regs[FRAME_A3]);
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig(%d): sig %d returns\n",
		    p->p_pid, sig);
#endif
d1504 1
a1504 4
sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1509 1
a1509 1
	struct sigcontext ksc;
a1510 1
	struct sigcontext *scp = SCARG(uap, sigcntxp);
a1512 5
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
	    printf("sigreturn: pid %d, scp %p\n", p->p_pid, scp);
#endif

a1513 2
		printf("%s(%d): sigreturn not from tramp [pc 0x%lx 0x%lx]\n",
		    p->p_comm, p->p_pid, PROC_PC(p), p->p_p->ps_sigcoderet);
a1517 4
	/*
	 * Test and fetch the context structure.
	 * We grab it all at once for speed.
	 */
a1521 3
		printf("%s(%d): cookie %lx should have been %lx\n",
		    p->p_comm, p->p_pid, ksc.sc_cookie,
		    (long)scp ^ p->p_p->ps_sigcookie);
d1529 1
a1529 2
	    offsetof(struct sigcontext, sc_cookie),
	    sizeof (ksc.sc_cookie));
a1530 2
	if (ksc.sc_regs[R_ZERO] != 0xACEDBADE)		/* magic number */
		return (EINVAL);
a1550 5
#endif

#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn(%d): returns\n", p->p_pid);
@


1.172
log
@SROP mitigation.  sendsig() stores a (per-process ^ &sigcontext) cookie
inside the sigcontext.  sigreturn(2) checks syscall entry was from the
exact PC addr in the (per-process ASLR) sigtramp, verifies the cookie,
and clears it to prevent sigcontext reuse.
not yet tested on landisk, sparc, *88k, socppc.
ok kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.171 2015/10/21 07:59:17 mpi Exp $ */
d1572 6
@


1.171
log
@Do not call uvm_swap_finicrypt_all() a second time in dumpsys().

ok tedu@@, deraadt@@, miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.170 2015/07/03 11:36:19 miod Exp $ */
d1480 1
a1480 3
	/*
	 * copy the frame out to userland.
	 */
d1543 1
a1543 3
#ifdef DEBUG
	struct sigcontext *scp;
#endif
d1551 7
d1562 1
a1562 1
	if ((error = copyin(SCARG(uap, sigcntxp), &ksc, sizeof(ksc))) != 0)
d1564 8
@


1.170
log
@Correctly restore ipl in fpusave_proc() when we have to busy loop.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.169 2015/02/11 01:14:16 dlg Exp $ */
a1209 4

#ifdef UVM_SWAP_ENCRYPT
	uvm_swap_finicrypt_all();
#endif
@


1.169
log
@get the SPINLOCK bits from machine/lock.h
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.168 2015/02/09 08:48:23 miod Exp $ */
d1813 2
a1814 1
		if (oci->ci_fpcurproc != p)
d1816 1
@


1.168
log
@Do not even try to call uvm_grow() from sendsig. It will be invoked
automagically if copyout() of the signal frame faults.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.167 2014/12/10 15:29:52 mikeb Exp $ */
d107 3
@


1.167
log
@retire shutdown hooks; ok deraadt, krw
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.166 2014/11/16 12:30:52 deraadt Exp $ */
d1432 1
a1432 5
	 * Allocate and validate space for the signal handler
	 * context. Note that if the stack is in P0 space, the
	 * call to uvm_grow() is a nop, and the useracc() check
	 * will fail if the process has not already allocated
	 * the space with a `brk'.
a1439 2
	if ((u_long)scp <= USRSTACK - ptoa(p->p_vmspace->vm_ssize))
		(void)uvm_grow(p, (u_long)scp);
@


1.166
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.165 2014/09/20 09:28:24 kettenis Exp $ */
a1030 1
	doshutdownhooks();
@


1.165
log
@Use config_suspend_all(9).

ok mpi@@, uebayasi@@, dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.164 2014/07/21 17:25:47 uebayasi Exp $ */
d488 1
a488 1
				    VM_PROT_READ;
d491 1
a491 1
				    VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE;
d1908 1
a1908 1
		return (VM_PROT_NONE);
d1910 1
a1910 1
		return (VM_PROT_READ | VM_PROT_WRITE);
@


1.164
log
@boot(9): Reduce annoying style diffs

- Always use either: ((x & RB_XXX) != 0) or ((x & RB_XXX) == 0) in boolean
  context (mostly if (x), or x ? y : z)
  - prom_halt() in alpha is confirmed to take int as boolean

Converted by coccinelle.  No functional change intended.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a973 1
	struct device *mainbus;
d1032 1
a1032 3
	mainbus = device_mainbus();
	if (mainbus != NULL)
		config_suspend(mainbus, DVACT_POWERDOWN);
@


1.163
log
@RB_MINIROOT is never checked by anything, so stop setting it.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.162 2014/07/13 22:53:38 uebayasi Exp $ */
d1038 2
a1039 1
	printf("hit any key to %s...\n", howto & RB_HALT ? "halt" : "reboot");
d1047 1
a1047 1
	if ((howto & RB_POWERDOWN) == RB_POWERDOWN &&
d1052 3
a1054 2
	printf("%s\n\n", howto & RB_HALT ? "halted." : "rebooting...");
	prom_halt(howto & RB_HALT);
@


1.162
log
@boot(9): Cosmetic changes to improve diff'ability.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a723 6
#if 0
		case 'm': /* mini root present in memory */
		case 'M':
			boothowto |= RB_MINIROOT;
			break;
#endif
@


1.161
log
@Cosmetic changes to reduce diffs.
@
text
@d1034 1
a1034 1
	if (howto & RB_DUMP)
d1059 2
a1060 1
	/*NOTREACHED*/
@


1.160
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.159 2014/07/10 20:15:26 uebayasi Exp $ */
d1009 1
a1009 1
	splhigh();		/* Disable interrupts. */
a1033 1
	/* If rebooting and a dump is requested do it. */
@


1.159
log
@boot(9): Remove comments about RB_*, "cold", and savectx()

Again remove slightly different comments to reduce diffs.  These will be
re-added once boot() become MI and its specification is clearly re-defined.

OK miod@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d1010 1
@


1.158
log
@boot(): Remove comments about RB_TIMEBAD to reduce diffs

RB_TIMEBAD is documented well enough that the comment is not needed.  sparc64
does slightly different and its comment is left with XXX.

OK deraadt@@ miod@@
@
text
@a985 1
	/* If system is cold, just halt. */
a986 1
		/* (Unless the user explicitly asked for reboot.) */
a991 1
	/* If "always halt" was specified as a boot flag, obey. */
@


1.157
log
@boot(): Unify declarations

OK deraadt@@
@
text
@d1002 1
a1002 5
		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now unless
		 * the system has been sitting in ddb.
		 */
@


1.156
log
@Revert previous diff setting cold to 1 on shutdown because it breaks machine
with softraid(4) disks.

softraid(4) is the last real consumer of the doshutdownhooks(9) API and it is
not trivial to convert its hook to a DVACT_POWERDOWN handler since the latter
does not allow to sleep.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.155 2014/05/30 13:46:16 mpi Exp $ */
d977 2
a978 3
void
boot(howto)
	int howto;
@


1.155
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.154 2014/05/25 13:57:48 deraadt Exp $ */
a1017 1
	cold = 1;
@


1.154
log
@Turn on blinky things by default, very useful here
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.153 2014/05/08 20:46:49 miod Exp $ */
d1018 1
@


1.153
log
@Format string fixes for alpha kernels, and remove -Wno-format
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.152 2014/03/26 05:23:42 guenther Exp $ */
d195 1
a195 1
int	alpha_led_blink = 0;
@


1.152
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.151 2014/03/22 06:05:45 guenther Exp $ */
d465 1
a465 1
		    mddtp->mddt_cluster_cnt);
d498 1
a498 1
			    "usage 0x%lx\n", i, memc->mddt_usage);
d787 2
a788 2
		printf("WARNING: unbelievable rpb_intr_freq: %ld (%d hz)\n",
			hwrpb->rpb_intr_freq, hz);
d936 1
a936 1
	    platform.family, hwrpb->rpb_variation & SV_ST_MASK);
d953 1
a953 1
	printf(", %ldMHz", hwrpb->rpb_cc_freq / 1000000);
d964 3
a966 2
	printf("%ld byte page size, %d processor%s.\n",
	    hwrpb->rpb_page_size, ncpusfound, ncpusfound == 1 ? "" : "s");
@


1.151
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.150 2014/03/13 03:52:55 dlg Exp $ */
d1527 1
a1527 1
	frame->tf_regs[FRAME_PC] = p->p_sigcode;
@


1.150
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.149 2014/02/18 19:37:32 miod Exp $ */
d1430 1
a1430 1
	struct sigacts *psp = p->p_sigacts;
@


1.149
log
@sio_intr_shutdown() used to be a shutdown hook, and eventually became an
unconditional call in machdep.c!boot(). Except that the cpp conditional
enabling its use was not in machdep.c's scope, so this function was never
called. Ouch.

Remove it from boot() and grow a ca_activate method to the sio(4/alpha) device,
which will take care of invoking sio_intr_shutdown() if DVACT_POWERDOWN.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.148 2014/02/04 21:52:42 miod Exp $ */
d980 1
d1046 3
a1048 2
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.148
log
@Restore spl (lowering it) with alpha_pal_swpipl() instead of splx() in the
code paths which can be run from ipi handlers, to avoid running soft interrupt
handlers if lowering ipl to 0. Soft interrupts will be processed upon returning
from the ipi interrupt anyway.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.147 2014/02/01 21:25:06 miod Exp $ */
a124 4
#ifdef BROKEN_PROM_CONSOLE
extern void sio_intr_shutdown(void);
#endif

a1046 4

#ifdef BROKEN_PROM_CONSOLE
	sio_intr_shutdown(NULL);
#endif
@


1.147
log
@Use splipi() instead of splhigh() to protect lazy fpu saving code.
In MP kernel, replace a TOCTTOU-vulnerable assert with a ``loop until we have
achieved our goals'' logic.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.146 2014/01/26 17:40:09 miod Exp $ */
d1790 1
a1790 1
	splx(s);
a1810 1

d1819 1
a1819 1
			splx(s);
d1827 1
a1827 1
			splx(s);
d1840 1
a1840 1
		splx(s);
@


1.146
log
@Work in progress work towards SMP, heavily based upon NetBSD. The MP kernel
will boot multiuser, but will deadlock under load, and I can't find my
mistake yet.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.145 2013/12/22 18:52:34 miod Exp $ */
d1769 1
a1769 1
	s = splhigh();
d1805 1
a1805 1
	int s, spincount;
d1810 2
d1813 2
a1814 2
	/* Need to block IPIs */
	s = splhigh();
d1817 2
a1818 2
	oci = p->p_addr->u_pcb.pcb_fpcpu;
	if (oci == NULL) {
d1820 1
a1820 1
		splx(s);
d1822 2
a1823 2
		return;
	}
d1826 20
a1845 1
	if (oci == ci) {
a1846 1
		splx(s);
d1848 1
a1848 2
		return;
	}
d1850 1
a1850 10
	KASSERT(oci->ci_fpcurproc == p);
	alpha_send_ipi(oci->ci_cpuid, ipi);
	splx(s);

	spincount = 0;
	while (p->p_addr->u_pcb.pcb_fpcpu != NULL) {
		spincount++;
		delay(1000);    /* XXX */
		if (spincount > 10000)
			panic("fpsave ipi didn't");
a1851 4
#else
	KASSERT(ci->ci_fpcurproc == p);
	fpusave_cpu(ci, save);
#endif /* MULTIPROCESSOR */
@


1.145
log
@Compute ncpusfound correctly. The logic was there but the count variable was
kept MD.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.144 2013/11/10 19:23:14 guenther Exp $ */
a112 2
#include <ddb/db_access.h>
#include <ddb/db_sym.h>
d114 1
d256 2
a257 1
	alpha_pal_wrval((u_long)&cpu_info[cpu_id]);
d775 1
d985 2
a986 9
#if 0 /* XXX See below. */
	u_long cpu_id;
#endif
#endif

#if defined(MULTIPROCESSOR)
	/* We must be running on the primary CPU. */
	if (alpha_pal_whami() != hwrpb->rpb_primary_cpu_id)
		panic("cpu_reboot: not on primary CPU!");
d1021 22
a1055 12
#if defined(MULTIPROCESSOR)
#if 0 /* XXX doesn't work when called from here?! */
	/* Kill off any secondary CPUs. */
	for (cpu_id = 0; cpu_id < hwrpb->rpb_pcs_cnt; cpu_id++) {
		if (cpu_id == hwrpb->rpb_primary_cpu_id ||
		    cpu_info[cpu_id].ci_softc == NULL)
			continue;
		cpu_halt_secondary(cpu_id);
	}
#endif
#endif

d1761 3
d1768 2
d1790 1
d1805 1
a1805 1
	int spincount;
d1810 5
d1817 3
d1826 1
d1833 1
d1894 1
a1894 1
		while (cycles > cycles_per_usec) {
@


1.144
log
@Make sure we pass a NULL cleanup argument to __start() by initializing
a2 to zero in the kernel and ld.so.  This will let us add the
conditional atexit() call to crt0

ok kettenis@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.143 2013/10/17 08:02:14 deraadt Exp $ */
a168 1
int	alpha_cpus;
d763 1
a763 1
	for (alpha_cpus = 0, i = 0; i < hwrpb->rpb_pcs_cnt; i++) {
d768 1
a768 1
			alpha_cpus++;
d968 1
a968 1
	    hwrpb->rpb_page_size, alpha_cpus, alpha_cpus == 1 ? "" : "s");
@


1.143
log
@Remove support for a.out and ecoff.  We only do elf now.
ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.142 2013/09/28 12:40:28 miod Exp $ */
d1725 1
@


1.142
log
@In boot(), do not iterate over alldevs if it's empty (i.e. halting from ddb
with ddb entered early with boot -d or from UKC).
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.141 2013/06/11 16:42:06 deraadt Exp $ */
a80 1
#include <sys/exec_ecoff.h>
@


1.141
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.140 2012/12/02 07:03:30 guenther Exp $ */
d1035 2
a1036 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.140
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.139 2012/11/01 21:09:17 miod Exp $ */
d1115 1
a1115 1
	int (*dump)(dev_t, daddr64_t, caddr_t, size_t);
d1199 2
a1200 2
	daddr64_t blkno;
	int (*dump)(dev_t, daddr64_t, caddr_t, size_t);
@


1.139
log
@Switch alpha to per-process astpending.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.138 2012/10/20 19:08:38 deraadt Exp $ */
d1434 2
a1435 1
	int oonstack, fsize, rndfsize, kscsize;
d1438 1
a1439 1
	oonstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d1455 2
a1456 2
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 && !oonstack &&
	    (psp->ps_sigonstack & sigmask(sig))) {
d1459 2
a1460 3
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	} else
		scp = (struct sigcontext *)(alpha_pal_rdusp() - rndfsize);
d1466 1
a1466 1
		    sig, &oonstack, scp);
d1472 1
a1472 1
	ksc.sc_onstack = oonstack;
d1480 1
a1480 1
	ksc.sc_regs[R_SP] = alpha_pal_rdusp();
a1590 4
	if (ksc.sc_onstack)
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.138
log
@move sio_intr_shutdown() from being a shutdownhook, and do it directly in
boot() as required.
ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.137 2012/10/08 21:47:45 deraadt Exp $ */
d217 2
a218 2
alpha_init(pfn, ptb, bim, bip, biv)
	u_long pfn;		/* first free PFN number */
a790 1
		hz = 1024;
d795 1
@


1.137
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.137 2012/10/08 21:45:45 deraadt Exp $ */
d127 4
d1036 4
@


1.136
log
@sigpid should be of type pid_t (only visable with DEBUG).

ok miod@@ (who found others to fix as well)
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.135 2011/11/25 05:23:40 miod Exp $ */
a1029 2

	/* run any shutdown hooks */
d1031 1
@


1.135
log
@Compile fixes for gcc4 (-Wbounded)
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.134 2011/07/05 04:48:01 guenther Exp $ */
d1406 1
a1406 1
int sigpid = 0;
@


1.134
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.133 2011/06/26 22:39:58 deraadt Exp $ */
d1424 1
d1479 1
a1479 1
	memcpy((struct fpreg *)ksc.sc_fpregs, &p->p_addr->u_pcb.pcb_fp,
d1561 1
d1600 1
a1600 1
	memcpy(&p->p_addr->u_pcb.pcb_fp, (struct fpreg *)ksc.sc_fpregs,
@


1.133
log
@if_downall() cannot be done MI in sys_reboot() because vfs_shutdown()
might need network (ie. nfs).  Move the call to the MD boot() routines.
This cause for boot hangs diagnosed by kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.132 2011/06/05 19:41:06 deraadt Exp $ */
d1430 1
a1430 1
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d1446 1
a1446 1
	if ((psp->ps_flags & SAS_ALTSTACK) && !oonstack &&
d1448 3
a1450 3
		scp = (struct sigcontext *)(psp->ps_sigstk.ss_sp +
		    psp->ps_sigstk.ss_size - rndfsize);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d1583 1
a1583 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d1585 1
a1585 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.132
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.131 2011/05/30 22:25:20 oga Exp $ */
d66 1
a81 1
#include <uvm/uvm.h>
d85 4
d1020 1
@


1.131
log
@Remove the freelist member from vm_physseg

The new world order of pmemrange makes this data completely redundant
(being dealt with by the pmemrange constraints instead). Remove all code
that messes with the freelist.

While touching every caller of uvm_page_physload() anyway, add the flags
argument to all callers (all but one is 0 and that one already used
PHYSLOAD_DEVICE) and remove the macro magic to allow callers to continue
without it.

Should shrink the code a bit, as well.

matthew@@ pointed out some mistakes i'd made.
``freelist death, I like. Ok.' ariane@@
`I agree with the general direction, go ahead and i'll fix any fallout
shortly'' miod@@ (68k 88k and vax i could not check would build)
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.130 2011/04/18 21:44:55 guenther Exp $ */
a129 14

/*
 * Declare these as initialized data so we can patch them.
 */
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 10
#endif

#ifdef	BUFPAGES
int	bufpages = BUFPAGES;
#else
int	bufpages = 0;
#endif
int	bufcachepercent = BUFCACHEPERCENT;
@


1.130
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.128 2010/11/28 21:00:03 miod Exp $ */
d562 1
a562 1
				    pfn0, kernstartpfn, VM_FREELIST_DEFAULT);
d576 1
a576 1
				    kernendpfn, pfn1, VM_FREELIST_DEFAULT);
d586 1
a586 2
			uvm_page_physload(pfn0, pfn1, pfn0, pfn1,
			    VM_FREELIST_DEFAULT);
@


1.129
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d1440 1
a1440 1
	oonstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d1456 1
a1456 1
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 && !oonstack &&
d1458 3
a1460 3
		scp = (struct sigcontext *)(p->p_sigstk.ss_sp +
		    p->p_sigstk.ss_size - rndfsize);
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d1593 1
a1593 1
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d1595 1
a1595 1
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.128
log
@Get rid of machdep.root_device sysctl and related variables.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.127 2010/06/30 20:38:49 tedu Exp $ */
d1440 1
a1440 1
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d1456 1
a1456 1
	if ((psp->ps_flags & SAS_ALTSTACK) && !oonstack &&
d1458 3
a1460 3
		scp = (struct sigcontext *)(psp->ps_sigstk.ss_sp +
		    psp->ps_sigstk.ss_size - rndfsize);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d1593 1
a1593 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d1595 1
a1595 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.127
log
@remove compat_osf1 support from the kernel
ok deraadt miod
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.126 2010/06/27 13:28:44 miod Exp $ */
a182 1
char	root_device[17];
a1651 3
	case CPU_ROOT_DEVICE:
		return (sysctl_rdstring(oldp, oldlenp, newp,
		    root_device));
@


1.126
log
@If you include <uvm/uvm.h>, you do not need to include any other <uvm/uvm_foo.h>
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.125 2010/06/27 05:06:20 beck Exp $ */
a1498 6
#ifdef COMPAT_OSF1
	/*
	 * XXX Create an OSF/1-style sigcontext and associated goo.
	 */
#endif

a1889 53

#if defined(COMPAT_OSF1)
void	cpu_exec_ecoff_setregs(struct proc *, struct exec_package *,
	    u_long, register_t *);

void
cpu_exec_ecoff_setregs(p, epp, stack, retval)
	struct proc *p;
	struct exec_package *epp;
	u_long stack;
	register_t *retval;
{
	struct ecoff_exechdr *execp = (struct ecoff_exechdr *)epp->ep_hdr;

	setregs(p, epp, stack, retval);
	p->p_md.md_tf->tf_regs[FRAME_GP] = execp->a.gp_value;
}

/*
 * cpu_exec_ecoff_hook():
 *	cpu-dependent ECOFF format hook for execve().
 * 
 * Do any machine-dependent diddling of the exec package when doing ECOFF.
 *
 */
int
cpu_exec_ecoff_hook(p, epp)
	struct proc *p;
	struct exec_package *epp;
{
	struct ecoff_exechdr *execp = (struct ecoff_exechdr *)epp->ep_hdr;
	extern struct emul emul_native;
	int error;
	extern int osf1_exec_ecoff_hook(struct proc *, struct exec_package *);

	switch (execp->f.f_magic) {
#ifdef COMPAT_OSF1
	case ECOFF_MAGIC_ALPHA:
		error = osf1_exec_ecoff_hook(p, epp);
		break;
#endif

	case ECOFF_MAGIC_NATIVE_ALPHA:
		epp->ep_emul = &emul_native;
		error = 0;
		break;

	default:
		error = ENOEXEC;
	}
	return (error);
}
#endif
@


1.125
log
@unbreak alpha kernel build after recent viking pillaging.
ok art@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.124 2010/06/27 03:03:48 thib Exp $ */
a80 2
#include <uvm/uvm_extern.h>
#include <uvm/uvm_swap.h>
@


1.124
log
@uvm constraints. Add two mandatory MD symbols, uvm_md_constraints
which contains the constraints for DMA/memory allocation for each
architecture, and dma_constraints which contains the range of addresses
that are dma accessable by the system.

This is based on ariane@@'s physcontig diff, with lots of bugfixes and
additions the following additions by my self:

Introduce a new function pool_set_constraints() which sets the address
range for which we allocate pages for the pool from, this is now used
for the mbuf/mbuf cluster pools to keep them dma accessible.

The !direct archs no longer stuff pages into the kernel object in
uvm_km_getpage_pla but rather do a pmap_extract() in uvm_km_putpages.

Tested heavily by my self on i386, amd64 and sparc64. Some tests on
alpha and SGI.

"commit it" beck, art, oga, deraadt
"i like the diff" deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.122 2010/06/09 15:44:15 miod Exp $ */
d83 1
@


1.123
log
@Declare safepri at the MD level on each platform, so that the kern_synch.c
does not have to deal with it as a common.  Some platforms may be missed
by this commit... if you spot one, fix it the same way.
ok miod
@
text
@d146 7
@


1.122
log
@Move declaration of cn_tab from dev/cons.c to dev/cninit.c, or appropriate
md files for ports which do not use dev/cninit.c. This gets rid of a common
at kernel link time.
feedback drahn@@ ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.121 2009/11/07 23:01:36 miod Exp $ */
d148 6
@


1.121
log
@Blink leds on the DEC 3000 models (three different led types).
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.120 2009/08/11 19:17:14 miod Exp $ */
d179 2
@


1.120
log
@Do not bother initializing bufpages in the md code if the computation is
exactly the same the mi could will use if bufinit() is invoked with
bufpages == 0.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.119 2009/08/11 18:46:30 miod Exp $ */
d116 8
d194 3
d1629 3
d1685 8
@


1.119
log
@With the SysV memory allocation changes, allocsys() doesn't do anything
anymore. Get rid of it completely.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.118 2009/08/09 10:40:17 blambert Exp $ */
a825 7

	/*
	 * Determine how many buffers to allocate.
	 * We allocate bufcachepercent% of memory for buffer space.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
@


1.118
log
@Rototill system V message queues.

No longer allocate a static amount of memory for messages in MD
boot path; message queues, message metadata, and message data now
all use dynamic memory, which means that runtime sysctls should now
be trivial to implement.

Since I'm going to be around all week to fix any breakage, this should
probably just go in now.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.117 2009/02/04 17:19:16 miod Exp $ */
a119 1
caddr_t allocsys(caddr_t);
a212 1
	vsize_t size;
a213 1
	caddr_t v;
a642 16
	 * Allocate space for system data structures.  These data structures
	 * are allocated here instead of cpu_startup() because physical
	 * memory is directly addressable.  We don't have to map these into
	 * virtual address space.
	 */
	size = (vsize_t)allocsys(NULL);
	v = (caddr_t)pmap_steal_memory(size, NULL, NULL);
	if ((allocsys(v) - v) != size)
		panic("alpha_init: table size inconsistency");

	/*
	 * Clear allocated memory.
	 */
	bzero(v, size);

	/*
a779 19
}

caddr_t
allocsys(v)
	caddr_t v;
{
	/*
	 * Allocate space for system data structures.
	 * The first available kernel virtual address is in "v".
	 * As pages of kernel virtual memory are allocated, "v" is incremented.
	 *
	 * These data structures are allocated here instead of cpu_startup()
	 * because physical memory is directly addressable. We don't have
	 * to map these into virtual address space.
	 */
#define valloc(name, type, num) \
	    (name) = (type *)v; v = (caddr_t)ALIGN((name)+(num))

	return v;
@


1.117
log
@Unify memory size reports a bit more: always report size in MB, and report
reserved memory on alpha and hppa on its own line (as done on sgi).
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.116 2008/06/27 17:22:12 miod Exp $ */
a89 3
#ifdef SYSVMSG
#include <sys/msg.h>
#endif
a815 9

#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif

#undef valloc
@


1.116
log
@Clear swap encryption keys before dumping a kernel image.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.115 2008/06/26 05:42:08 ray Exp $ */
d862 4
a865 4
	printf("total memory = %lu (%luK)\n", ptoa((psize_t)totalphysmem),
	    ptoa((psize_t)totalphysmem) / 1024);
	printf("(%lu reserved for PROM, ", ptoa((psize_t)resvmem));
	printf("%lu used by OpenBSD)\n", ptoa((psize_t)physmem));
d867 3
a869 2
		printf("WARNING: unused memory = %lu (%luK)\n",
		    ptoa((psize_t)unusedmem), ptoa((psize_t)unusedmem) / 1024);
d872 3
a874 2
		printf("WARNING: %lu (%luK) of memory with unknown purpose\n",
		    ptoa((psize_t)unknownmem), ptoa((psize_t)unknownmem) / 1024);
d901 2
a902 2
	printf("avail memory = %lu (%luK)\n", ptoa((psize_t)uvmexp.free),
	    ptoa((psize_t)uvmexp.free) / 1024);
@


1.115
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.114 2008/04/09 16:58:10 deraadt Exp $ */
d82 1
d1258 4
@


1.114
log
@Add new stub uvm_shutdown() and call it from the right place in MD boot()
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.114 2008/04/09 16:50:26 deraadt Exp $ */
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.113
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.112 2007/09/15 10:10:37 martin Exp $ */
d1069 2
a1070 2
	/* Disable interrupts. */
	splhigh();
@


1.112
log
@replace ctob and btoc with ptoa and atop respectively

help and ok miod@@ thib@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.111 2007/08/25 21:49:05 kettenis Exp $ */
a1873 60
}

/*
 * The following primitives manipulate the run queues.  _whichqs tells which
 * of the 32 queues _qs have processes in them.  Setrunqueue puts processes
 * into queues, Remrunqueue removes them from queues.  The running process is
 * on no queue, other processes are on a queue related to p->p_priority,
 * divided by 4 actually to shrink the 0-127 range of priorities into the 32
 * available queues.
 */
/*
 * setrunqueue(p)
 *	proc *p;
 *
 * Call should be made at splclock(), and p->p_stat should be SRUN.
 */

/* XXXART - grmble */
#define sched_qs qs
#define sched_whichqs whichqs

void
setrunqueue(p)
	struct proc *p;
{
	int bit;

	/* firewall: p->p_back must be NULL */
	if (p->p_back != NULL)
		panic("setrunqueue");

	bit = p->p_priority >> 2;
	sched_whichqs |= (1 << bit);
	p->p_forw = (struct proc *)&sched_qs[bit];
	p->p_back = sched_qs[bit].ph_rlink;
	p->p_back->p_forw = p;
	sched_qs[bit].ph_rlink = p;
}

/*
 * remrunqueue(p)
 *
 * Call should be made at splclock().
 */
void
remrunqueue(p)
	struct proc *p;
{
	int bit;

	bit = p->p_priority >> 2;
	if ((sched_whichqs & (1 << bit)) == 0)
		panic("remrunqueue");

	p->p_back->p_forw = p->p_forw;
	p->p_forw->p_back = p->p_back;
	p->p_back = NULL;	/* for firewall checking. */

	if ((struct proc *)&sched_qs[bit] == sched_qs[bit].ph_link)
		sched_whichqs &= ~(1 << bit);
@


1.111
log
@Use ptoa((psize_t)...) and %lu to print memory sizes.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.110 2007/06/06 17:15:11 deraadt Exp $ */
d1496 1
a1496 1
	if ((u_long)scp <= USRSTACK - ctob(p->p_vmspace->vm_ssize))
@


1.110
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.109 2007/05/29 20:36:47 deraadt Exp $ */
d868 4
a871 4
	printf("total memory = %ld (%ldK)\n", ptoa((u_long)totalphysmem),
	    ptoa((u_long)totalphysmem) / 1024);
	printf("(%ld reserved for PROM, ", ptoa((u_long)resvmem));
	printf("%ld used by OpenBSD)\n", ptoa((u_long)physmem));
d873 2
a874 2
		printf("WARNING: unused memory = %ld (%ldK)\n",
		    ptoa((u_long)unusedmem), ptoa((u_long)unusedmem) / 1024);
d877 2
a878 2
		printf("WARNING: %ld (%ldK) of memory with unknown purpose\n",
		    ptoa((u_long)unknownmem), ptoa((u_long)unknownmem) / 1024);
d905 2
a906 2
	printf("avail memory = %ld (%ldK)\n", (long)ptoa(uvmexp.free),
	    (long)ptoa(uvmexp.free) / 1024);
@


1.109
log
@start of dumpconf() unification, which one day we can pray will be MI
(and part of setroot); ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.108 2007/05/26 20:26:50 pedro Exp $ */
d1155 1
a1155 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d1239 2
a1240 2
	daddr_t blkno;
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
@


1.108
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.107 2007/04/23 10:07:43 art Exp $ */
d1202 1
a1202 1
dumpconf()
a1204 1
	int maj;
d1206 3
a1208 8
	if (dumpdev == NODEV)
		goto bad;
	maj = major(dumpdev);
	if (maj < 0 || maj >= nblkdev)
		panic("dumpconf: bad dumpdev=0x%x", dumpdev);
	if (bdevsw[maj].d_psize == NULL)
		goto bad;
	nblks = (*bdevsw[maj].d_psize)(dumpdev);
d1210 1
a1210 1
		goto bad;
d1214 1
a1214 1
		goto bad;
d1219 1
a1219 1
		goto bad;
a1225 5
	return;

bad:
	dumpsize = 0;
	return;
@


1.107
log
@Switch alpha to timecounters.

We use rpcc for the clock. We don't try to get the frequency from the
hwrpb, since from experience we know that it's very unreliable and
can be several % off from the real frequency. Instead we calibrate
the timecounter frequency by using the clock device and count the
number of cycles between two second ticks of the clocks.

This is not perfect, but still much better than what we had before.
We'll have to add an i8254 clock for MP though.

miod@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.106 2007/04/18 16:53:19 martin Exp $ */
a136 6
#ifdef	NBUF
int	nbuf = NBUF;
#else
int	nbuf = 0;
#endif

a169 6
/*
 * XXX We need an address to which we can assign things so that they
 * won't be optimized away because we didn't use the value.
 */
u_int32_t no_optimize;

a832 14
	/*
	 * Determine how many buffers to allocate.
	 * We allocate 10% of memory for buffer space.  Insure a
	 * minimum of 16 buffers.
	 */
	if (bufpages == 0)
		bufpages = (physmem / (100/bufcachepercent));
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}
	valloc(buf, struct buf, nbuf);

a854 2
	register unsigned i;
	int base, residual;
a855 1
	vsize_t size;
d882 5
a886 16
	 * Allocate virtual address space for file I/O buffers.
	 * Note they are different than the array of headers, 'buf',
	 * and usually occupy more virtual memory than physical.
	 */
	size = MAXBSIZE * nbuf;
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(size),
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
				UVM_ADV_NORMAL, 0)))
		panic("startup: cannot allocate VM for buffers");
	base = bufpages / nbuf;
	residual = bufpages % nbuf;
	for (i = 0; i < nbuf; i++) {
		vsize_t curbufsize;
		vaddr_t curbuf;
		struct vm_page *pg;
a887 21
		/*
		 * Each buffer has MAXBSIZE bytes of VM space allocated.  Of
		 * that MAXBSIZE space, we allocate and map (base+1) pages
		 * for the first "residual" buffers, and then we allocate
		 * "base" pages for the rest.
		 */
		curbuf = (vaddr_t) buffers + (i * MAXBSIZE);
		curbufsize = PAGE_SIZE * ((i < residual) ? (base+1) : base);

		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: not enough memory for "
				    "buffer cache");
			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
					VM_PROT_READ|VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
		pmap_update(pmap_kernel());
	}
a913 2
	printf("using %ld buffers containing %ld bytes (%ldK) of memory\n",
	    (long)nbuf, (long)bufpages * PAGE_SIZE, (long)bufpages * (PAGE_SIZE / 1024));
@


1.106
log
@if possible, fill in hw.serialno;
tsunami chipset alphas set this, maybe older ones as well
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.105 2007/04/13 08:31:50 martin Exp $ */
d99 1
a2007 31
}

/*
 * Return the best possible estimate of the time in the timeval
 * to which tvp points.  Unfortunately, we can't read the hardware registers.
 * We guarantee that the time will be greater than the value obtained by a
 * previous call.
 */
void
microtime(tvp)
	register struct timeval *tvp;
{
	int s = splclock();
	static struct timeval lasttime;

	*tvp = time;
#ifdef notdef
	tvp->tv_usec += clkread();
	while (tvp->tv_usec >= 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
#endif
	if (tvp->tv_sec == lasttime.tv_sec &&
	    tvp->tv_usec <= lasttime.tv_usec &&
	    (tvp->tv_usec = lasttime.tv_usec + 1) >= 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
	lasttime = *tvp;
	splx(s);
@


1.105
log
@get alpha SMP into a state where it at least compiles:

- add machine-dependent spinlock operations
- add basic interprocessor interrupt sending and receiving code

from NetBSD; ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.104 2007/02/26 21:30:16 miod Exp $ */
d208 3
d1055 1
d1066 8
d1078 1
a1078 5
	/* this isn't defined for any systems that we run on? */
	printf("serial number 0x%lx 0x%lx\n",
	    ((long *)hwrpb->rpb_ssn)[0], ((long *)hwrpb->rpb_ssn)[1]);

	/* and these aren't particularly useful! */
@


1.104
log
@Zero rval[1] in setregs.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.103 2006/07/12 15:32:57 martin Exp $ */
a1857 3
#if defined(MULTIPROCESSOR)
	int s;
#endif
d1896 1
a1896 1
	int s, spincount;
@


1.103
log
@do not include uvm_extern.h twice
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.102 2006/06/20 14:06:01 deraadt Exp $ */
d501 1
a501 1
		}
d1847 2
@


1.102
log
@fix memory reporting on alphas with 2GB or more; ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.101 2006/06/15 20:08:29 brad Exp $ */
a101 2

#include <uvm/uvm_extern.h>
@


1.101
log
@Rework the interrupt code, shaving some cycles off in the process.
Rather than an "iointr" routine that decomposes a vector into an
IRQ, we maintain a vector table directly, hooking up each "iointr"
routine at the correct vector. This also allows us to hook device
interrupts up to specific vectors.

From thorpej NetBSD

Tested by myself and a number of end-users.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.100 2006/06/07 21:50:52 miod Exp $ */
d623 2
a624 2
	printf("totalphysmem = %d\n", totalphysmem);
	printf("physmem = %d\n", physmem);
d895 4
a898 4
	printf("total memory = %ld (%ldK)\n", (long)ptoa(totalphysmem),
	    (long)ptoa(totalphysmem) / 1024);
	printf("(%ld reserved for PROM, ", (long)ptoa(resvmem));
	printf("%ld used by OpenBSD)\n", (long)ptoa(physmem));
d901 1
a901 1
		    (long)ptoa(unusedmem), (long)ptoa(unusedmem) / 1024);
d905 1
a905 1
		    (long)ptoa(unknownmem), (long)ptoa(unknownmem) / 1024);
@


1.100
log
@One last occurence of an inline sigexit() in sendsig.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.99 2006/04/13 14:41:08 brad Exp $ */
d252 3
@


1.99
log
@Use PAGE_SIZE rather than NBPG.

From NetBSD

ok martin@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.98 2006/03/18 12:03:33 miod Exp $ */
a165 2
int	maxmem;			/* max memory per process */

a618 1
	maxmem = physmem;
d1623 2
a1624 7
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		return;
@


1.98
log
@Switch to a rpcc-based delay() implementation. From NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.97 2006/03/15 21:03:33 deraadt Exp $ */
d933 1
a933 1
		curbufsize = NBPG * ((i < residual) ? (base+1) : base);
d974 1
a974 1
	    (long)nbuf, (long)bufpages * NBPG, (long)bufpages * (NBPG / 1024));
d1252 1
a1252 1
 * Dumps always skip the first NBPG of disk space
d1298 1
a1298 1
#define	BYTES_PER_DUMP	NBPG
@


1.97
log
@use sysctl_int_lower() for the aperture variable.  This lets root close
the aperture without having to reboot, but does not allow re-opening;
ok matthieu
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.96 2006/01/17 20:28:59 miod Exp $ */
d2047 1
a2047 1
	long N = cycles_per_usec * (n);
d2049 17
a2065 3
	/*
	 * XXX Should be written to use RPCC?
	 */
d2067 13
a2079 6
	__asm __volatile(
		"# The 2 corresponds to the insn count\n"
		"1:	subq	%2, %1, %0	\n"
		"	bgt	%0, 1b"
		: "=r" (N)
		: "i" (2), "0" (N));
@


1.96
log
@Do not invoke resettodr() on shutdown if we have been sitting in ddb.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.95 2005/11/23 01:59:02 martin Exp $ */
d1793 2
a1794 2
                        return (sysctl_rdint(oldp, oldlenp, newp,
				 allowaperture));
@


1.95
log
@fix DEBUG build
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.94 2005/11/12 18:39:19 martin Exp $ */
d1115 2
a1116 1
		 * will be out of synch; adjust it now.
d1118 5
a1122 1
		resettodr();
@


1.94
log
@no longer require boot_osflags being set to 'a' in the SRM for going multiuser; setting boot_osflags to 's' explicitly will get us to singleuser as usual; very old SRM versions can only set 'a' or 's', but are still fine because we ignore 'a' now and default to multiuser

idea and ok deraadt@@, jsg@@, testing by many
final ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.93 2005/10/17 18:34:22 miod Exp $ */
d1676 3
@


1.93
log
@Rename ncpus to alpha_ncpus so that MI ncpus matches the number of
attached processors; deraadt@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.92 2005/06/17 21:54:14 miod Exp $ */
a714 1
	boothowto = RB_SINGLE;
d725 1
a725 1
		case 'a': /* autoboot */
a726 1
			boothowto &= ~RB_SINGLE;
d763 1
a763 1
		case 's': /* single-user (default, supported for sanity) */
@


1.92
log
@Override cpu_switch() with a faster version if we can use BWX instructions.
From RusticBSD, ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.91 2005/04/28 17:19:27 deraadt Exp $ */
d175 1
d788 1
a788 1
	for (ncpus = 0, i = 0; i < hwrpb->rpb_pcs_cnt; i++) {
d793 1
a793 1
			ncpus++;
d1068 1
a1068 1
	    hwrpb->rpb_page_size, ncpus, ncpus == 1 ? "" : "s");
@


1.91
log
@shrink extra verbose crud
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.90 2004/11/02 21:20:56 miod Exp $ */
d413 26
@


1.90
log
@Remove __HAVE_NWSCONS and related remnants of pre-wscons days; no functional
change.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.89 2004/07/06 21:53:59 deraadt Exp $ */
d564 1
d590 1
d1347 1
a1347 1

d1367 1
a1367 1

d1730 1
a1730 1

d1750 1
@


1.89
log
@assert is dumb dumb dumb; no objection from miod
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.88 2004/07/04 01:13:05 deraadt Exp $ */
a847 20

#include "pckbc.h"
#include "pckbd.h"
#if (NPCKBC > 0) && (NPCKBD == 0)

#include <dev/ic/pckbcvar.h>

/*
 * This is called by the pckbc driver if no pckbd is configured.
 * On the i386, it is used to glue in the old, deprecated console
 * code.  On the Alpha, it does nothing.
 */
int
pckbc_machdep_cnattach(kbctag, kbcslot)
	pckbc_tag_t kbctag;
	pckbc_slot_t kbcslot;
{
	return (ENXIO);
}
#endif /* NPCKBC > 0 && NPCKBD == 0 */
@


1.88
log
@turn off _KERN_DO_ECOFF unless COMPAT_OSF1 is enabled.  This shrinks the
ramdisks, too.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.87 2004/06/08 18:09:31 marc Exp $ */
d393 1
a393 1
#ifdef DIAGNOSTIC
a395 1
	/* We should always be running on the primary. */
@


1.87
log
@pull ncpus support from smp tree into main branch.
remove alpha specific definition of ncpus.
OK (and tested on alpha) deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.86 2004/03/10 23:02:53 tom Exp $ */
d2046 1
a2046 1
#if defined(COMPAT_OSF1) || 1		/* XXX */
@


1.86
log
@Ensure that we obey a user's ddb> boot reboot command even if the system
is cold (during startup).

This adds RB_USERREQ to sys/reboot.h, uses it in the ddb commands, and
ensures that */*/machdep.c:boot() won't set RB_HALT when cold if this
flag is set.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.85 2004/01/22 17:47:27 miod Exp $ */
a193 3
/* number of cpus in the box.  really! */
int		ncpus;

d760 1
a760 1
	for (i = 0; i < hwrpb->rpb_pcs_cnt; i++) {
@


1.85
log
@dot_conv() is not used.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.84 2003/11/08 06:11:11 nordin Exp $ */
d1096 3
a1098 1
		howto |= RB_HALT;
@


1.84
log
@Avoid a race condition while swapping in a process.
Tested by mickey@@, henning@@, ericj@@, and beck@@.
ok mickey@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.83 2003/08/10 00:03:21 miod Exp $ */
a2135 22

char *
dot_conv(x)
	unsigned long x;
{
	int i;
	char *xc;
	static int next;
	static char space[2][20];

	xc = space[next ^= 1] + sizeof space[0];
	*--xc = '\0';
	for (i = 0;; ++i) {
		if (i && (i & 3) == 0)
			*--xc = '.';
		*--xc = "0123456789abcdef"[x & 0xf];
		x >>= 4;
		if (x == 0)
			break;
	}
	return xc;
}
@


1.83
log
@Do not trust and use uvm_useracc, but rather always check copy{in,out} for
failure and act appropriately.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.82 2003/06/03 17:31:01 drahn Exp $ */
a1893 1
	KDASSERT(p->p_flag & P_INMEM);
@


1.82
log
@Make minaddr sane before calling uvm_km_suballoc()
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.81 2003/05/11 19:41:08 deraadt Exp $ */
a1559 18
	if (uvm_useracc((caddr_t)scp, fsize, B_WRITE) == 0) {
#ifdef DEBUG
		if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
			printf("sendsig(%d): uvm_useracc failed on sig %d\n",
			    p->p_pid, sig);
#endif
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		return;
	}
d1597 2
a1598 1
		(void) copyout((caddr_t)&ksi, (caddr_t)sip, fsize - kscsize);
d1605 19
a1623 1
	(void) copyout((caddr_t)&ksc, (caddr_t)scp, kscsize);
@


1.81
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.80 2003/05/10 21:11:11 deraadt Exp $ */
d948 1
d950 1
a950 1
				   16 * NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);
d956 1
a956 1
				   VM_PHYS_SIZE, 0, FALSE, NULL);
@


1.80
log
@string cleaning; ok beck dhartmei
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.79 2002/12/17 23:11:31 millert Exp $ */
d388 1
a388 1
	strcpy(cpu_model, platform.model);
@


1.79
log
@Make SysV-style shared memory and semaphore limits sysctl'able.
Instead of allocating a static amount of memory for the data
structures via valloc() in allocsys(), allocate things dynamically
using pool(9) when possible and malloc(9) when not.  The various
members of struct seminfo and struct shminfo are in kern.seminfo
and kern.shminfo respectively (not all members of kern.seminfo are
changable).

The data structures used still leave something to be desired but
things are not made worse in that respect by this commit.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.78 2002/11/07 04:31:59 art Exp $ */
d1041 1
a1041 1
	sprintf(s, "%s family, unknown model variation 0x%lx",
@


1.78
log
@Small simplification in sendsig.

In sys_sigreturn - don't uvm_useracc the context address and then copyin
it afterwards. The copyin deals better with finding if the user address is
correct and it's faster.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.77 2002/08/24 17:21:44 matthieu Exp $ */
a98 6
#ifdef SYSVSEM
#include <sys/sem.h>
#endif
#ifdef SYSVSHM
#include <sys/shm.h>
#endif
a812 12
#ifdef SYSVSHM
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
	valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
#endif
#ifdef SYSVSEM
	valloc(sema, struct semid_ds, seminfo.semmni);
	valloc(sem, struct sem, seminfo.semmns);
	/* This is pretty disgusting! */
	valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
#endif
@


1.77
log
@aperture driver for alpha. It works here the same as on i386
to allow access to VGA card's memory by mmapping /dev/xf86.
The macdep.allowaperture does also control /dev/pci access.
Ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.76 2002/07/21 01:09:19 art Exp $ */
d1633 2
a1634 1
	}
d1651 1
a1651 2
	frame->tf_regs[FRAME_A1] = (psp->ps_siginfo & sigmask(sig)) ?
	    (u_int64_t)sip : NULL;
d1686 2
a1687 1
	struct sigcontext *scp, ksc;
a1688 1
	scp = SCARG(uap, sigcntxp);
a1693 3
	if (ALIGN(scp) != (u_int64_t)scp)
		return (EINVAL);

d1698 2
a1699 3
	if (uvm_useracc((caddr_t)scp, sizeof (*scp), B_WRITE) == 0 ||
	    copyin((caddr_t)scp, (caddr_t)&ksc, sizeof ksc))
		return (EINVAL);
@


1.76
log
@remove unsued variables.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.75 2002/07/20 19:24:55 art Exp $ */
d164 8
d1796 11
a1806 1

@


1.75
log
@Instead of copying out the signal trampoline on top of the stack, create
an uvm aobj, copy out the signal trampoline into it and share that page
among all processes for the same emulation.

This also requires us to actually be able to tell signal code where the
trampoline is located, so introduce a new field in struct proc - p_sigcode
that is a pointer to sigcode. This allows us to remove all the ugly
calculations of the signal trampoline address done in every sendsig
function in the tree (that's why so many files are changed).

Tested by various people. ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.74 2002/06/08 05:19:12 art Exp $ */
a1535 1
	extern char sigcode[], esigcode[];
@


1.74
log
@Always keep the symbols, don't hand that memory to the VM system.
In most cases we'll have either DDB or /dev/ksyms and if someone
really needs the memory they'll strip the kernel.
Fixes alpha/2705.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.73 2002/06/04 00:09:08 deraadt Exp $ */
d1641 1
a1641 2
	frame->tf_regs[FRAME_PC] =
	    (u_int64_t)PS_STRINGS - (esigcode - sigcode);
@


1.73
log
@spelling; raj@@cerias.purdue.edu
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.72 2002/05/03 00:06:16 millert Exp $ */
a430 1
#ifdef DDB
a431 3
#else
	kernend = (vaddr_t)round_page((vaddr_t)_end);
#endif
@


1.72
log
@le_ioasic.h is history
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.71 2002/04/28 20:55:14 pvalchev Exp $ */
d1671 1
a1671 1
 * psl to gain improper priviledges or to cause
@


1.71
log
@IEEE 754 floating point completion code, and implementation of the
FP_C (Floating Point Control Quadword).

From ross@@NetBSD.  Added a way to disable it with option NO_IEEE,
which appears on the ramdisks to save space.  This affects only
programs compiled with -mieee, and what it essentially does is
enabling infinities and NaNs, instead of generating SIGFPE on
division by zero, overflow, etc.
ok art, deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.70 2002/04/25 00:53:58 miod Exp $ */
a130 2

#include "le_ioasic.h"			/* for le_iomem creation */
@


1.70
log
@Cast and display memory sizes as long integers, to avoid displaying
negative amounts of memory on >= 2GB machines.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.69 2002/03/23 13:28:33 espie Exp $ */
d93 3
d119 3
d210 3
d1609 2
a1610 6
	if (p == fpcurproc) {
		alpha_pal_wrfen(1);
		savefpstate(&p->p_addr->u_pcb.pcb_fp);
		alpha_pal_wrfen(0);
		fpcurproc = NULL;
	}
d1612 1
a1612 1
	bcopy(&p->p_addr->u_pcb.pcb_fp, (struct fpreg *)ksc.sc_fpregs,
d1614 7
a1620 4
	ksc.sc_fp_control = 0;					/* XXX ? */
	bzero(ksc.sc_reserved, sizeof ksc.sc_reserved);		/* XXX */
	bzero(ksc.sc_xxx, sizeof ksc.sc_xxx);			/* XXX */

d1724 3
a1726 3
	if (p == fpcurproc)
		fpcurproc = NULL;
	bcopy((struct fpreg *)ksc.sc_fpregs, &p->p_addr->u_pcb.pcb_fp,
d1728 4
a1731 1
	/* XXX ksc.sc_fp_control ? */
d1786 1
a1786 1

d1790 7
a1832 2
#define FP_RN 2 /* XXX */
	p->p_addr->u_pcb.pcb_fp.fpr_cr = (long)FP_RN << 58;
d1842 26
a1867 2
	if (fpcurproc == p)
		fpcurproc = NULL;
d1869 63
a1931 1
	retval[0] = retval[1] = 0;
@


1.69
log
@Add variables for config(8) -e time tweak of systemV shared memory
parameters.

Ok millert@@, miod@@, maja@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.68 2002/03/14 01:26:26 millert Exp $ */
d899 4
a902 4
	printf("total memory = %d (%dK)\n", ptoa(totalphysmem),
	    ptoa(totalphysmem) / 1024);
	printf("(%d reserved for PROM, ", ptoa(resvmem));
	printf("%d used by OpenBSD)\n", ptoa(physmem));
d904 2
a905 2
		printf("WARNING: unused memory = %d (%dK)\n", ptoa(unusedmem),
		    ptoa(unusedmem) / 1024);
d908 2
a909 2
		printf("WARNING: %d (%dK) of memory with unknown purpose\n",
		    ptoa(unknownmem), ptoa(unknownmem) / 1024);
d967 2
a968 2
	printf("avail memory = %d (%dK)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free) / 1024);
d976 2
a977 2
	printf("using %ld buffers containing %d bytes (%dK) of memory\n",
	    (long)nbuf, bufpages * NBPG, bufpages * (NBPG / 1024));
@


1.68
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.67 2002/02/17 23:38:16 jason Exp $ */
d809 3
@


1.67
log
@comment typo
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.66 2002/02/17 22:59:52 maja Exp $ */
d128 8
a135 8
int	cpu_dump __P((void));
int	cpu_dumpsize __P((void));
u_long	cpu_dump_mempagecnt __P((void));
void	dumpsys __P((void));
caddr_t allocsys __P((caddr_t));
void	identifycpu __P((void));
void	regdump __P((struct trapframe *framep));
void	printregs __P((struct reg *));
d1204 1
a1204 1
	int (*dump) __P((dev_t, daddr_t, caddr_t, size_t));
d1300 1
a1300 1
	int (*dump) __P((dev_t, daddr_t, caddr_t, size_t));
d1954 2
a1955 2
void	cpu_exec_ecoff_setregs __P((struct proc *, struct exec_package *,
	    u_long, register_t *));
@


1.66
log
@Patch from Daniel Lucq <daniel@@lucq.org>

The patch allows you to change the value of NMBCLUSTERS, BUFCACHEPERCENT
and NKMEMPAGES using the config command, instead of recompiling the kernel.

This is the kernel part of the patch. I have compiled it on i386, sparc64,
alpha and macppc. -moj ok art@@ maja@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.65 2002/01/23 17:51:52 art Exp $ */
d864 1
a864 1
 * This is called by the pbkbc driver if no pckbd is configured.
@


1.65
log
@move mb_map allocation to mbinit()
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.64 2002/01/23 17:35:55 art Exp $ */
d145 5
d155 1
a823 3
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 10
#endif
d830 1
a830 1
		bufpages = (physmem / (100/BUFCACHEPERCENT));
@


1.64
log
@move definition of mb_map from zillions of machdep.c to uipc_mbuf.c
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.63 2002/01/22 21:50:49 ericj Exp $ */
a956 3

	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
			VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
@


1.63
log
@
call osf1_exec_ecoff_hook for osf1 bin's
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.62 2002/01/16 20:50:14 miod Exp $ */
a151 1
struct vm_map *mb_map = NULL;
@


1.62
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.61 2001/12/08 02:24:05 art Exp $ */
a1983 3
#ifdef COMPAT_OSF1
	extern struct emul emul_osf1;
#endif
d1986 1
a1986 2
	extern int osf1_exec_ecoff_hook(struct proc *p,
					struct exec_package *epp);
d1991 1
a1991 1
		epp->ep_emul = &emul_osf1;
@


1.61
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.60 2001/11/28 16:13:27 art Exp $ */
a71 1
#include <sys/map.h>
@


1.61.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.65 2002/01/23 17:51:52 art Exp $ */
d72 1
d153 1
d960 3
d1985 3
d1990 2
a1991 1
	extern int osf1_exec_ecoff_hook(struct proc *, struct exec_package *);
d1996 1
a1996 1
		error = osf1_exec_ecoff_hook(p, epp);
@


1.61.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.61.2.1 2002/01/31 22:55:04 niklas Exp $ */
a92 3
#ifndef NO_IEEE
#include <machine/fpu.h>
#endif
a115 3
#ifndef NO_IEEE
#include <machine/ieeefp.h>
#endif
d126 10
a135 8
int	cpu_dump(void);
int	cpu_dumpsize(void);
u_long	cpu_dump_mempagecnt(void);
void	dumpsys(void);
caddr_t allocsys(caddr_t);
void	identifycpu(void);
void	regdump(struct trapframe *framep);
void	printregs(struct reg *);
a144 5

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 10
#endif

a149 1
int	bufcachepercent = BUFCACHEPERCENT;
a197 3
#ifndef NO_IEEE
int	alpha_fp_sync_complete = 0;	/* fp fixup if sync even without /s */
#endif
d418 1
d420 3
a802 3
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
d818 3
d827 1
a827 1
		bufpages = (physmem / (100/bufcachepercent));
d861 1
a861 1
 * This is called by the pckbc driver if no pckbd is configured.
d893 4
a896 4
	printf("total memory = %ld (%ldK)\n", (long)ptoa(totalphysmem),
	    (long)ptoa(totalphysmem) / 1024);
	printf("(%ld reserved for PROM, ", (long)ptoa(resvmem));
	printf("%ld used by OpenBSD)\n", (long)ptoa(physmem));
d898 2
a899 2
		printf("WARNING: unused memory = %ld (%ldK)\n",
		    (long)ptoa(unusedmem), (long)ptoa(unusedmem) / 1024);
d902 2
a903 2
		printf("WARNING: %ld (%ldK) of memory with unknown purpose\n",
		    (long)ptoa(unknownmem), (long)ptoa(unknownmem) / 1024);
d961 2
a962 2
	printf("avail memory = %ld (%ldK)\n", (long)ptoa(uvmexp.free),
	    (long)ptoa(uvmexp.free) / 1024);
d970 2
a971 2
	printf("using %ld buffers containing %ld bytes (%ldK) of memory\n",
	    (long)nbuf, (long)bufpages * NBPG, (long)bufpages * (NBPG / 1024));
d1201 1
a1201 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d1297 1
a1297 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d1594 6
a1599 2
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 1);
d1601 1
a1601 1
	memcpy((struct fpreg *)ksc.sc_fpregs, &p->p_addr->u_pcb.pcb_fp,
d1603 4
a1606 7
#ifndef NO_IEEE
	ksc.sc_fp_control = alpha_read_fp_c(p);
#else
	ksc.sc_fp_control = 0;
#endif
	memset(ksc.sc_reserved, 0, sizeof ksc.sc_reserved);	/* XXX */
	memset(ksc.sc_xxx, 0, sizeof ksc.sc_xxx);		/* XXX */
d1659 1
a1659 1
 * psl to gain improper privileges or to cause
d1710 3
a1712 3
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 0);
	memcpy(&p->p_addr->u_pcb.pcb_fp, (struct fpreg *)ksc.sc_fpregs,
d1714 1
a1714 4
#ifndef NO_IEEE
	p->p_addr->u_pcb.pcb_fp.fpr_cr = ksc.sc_fpcr;
	p->p_md.md_flags = ksc.sc_fp_control & MDP_FP_C;
#endif
d1769 1
a1769 1
	
a1772 7

#ifndef NO_IEEE
	case CPU_FP_SYNC_COMPLETE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &alpha_fp_sync_complete));
#endif

d1809 2
d1820 2
a1821 47
#ifndef NO_IEEE
	if (__predict_true((p->p_md.md_flags & IEEE_INHERIT) == 0)) {
		p->p_md.md_flags &= ~MDP_FP_C;
		p->p_addr->u_pcb.pcb_fp.fpr_cr = FPCR_DYN(FP_RN);
	}
#endif
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 0);
}

/*
 * Release the FPU.
 */
void
fpusave_cpu(struct cpu_info *ci, int save)
{
	struct proc *p;
#if defined(MULTIPROCESSOR)
	int s;
#endif

	KDASSERT(ci == curcpu());

#if defined(MULTIPROCESSOR)
	atomic_setbits_ulong(&ci->ci_flags, CPUF_FPUSAVE);
#endif

	p = ci->ci_fpcurproc;
	if (p == NULL)
		goto out;

	if (save) {
		alpha_pal_wrfen(1);
		savefpstate(&p->p_addr->u_pcb.pcb_fp);
	}

	alpha_pal_wrfen(0);

	p->p_addr->u_pcb.pcb_fpcpu = NULL;
	ci->ci_fpcurproc = NULL;

out:
#if defined(MULTIPROCESSOR)
	atomic_clearbits_ulong(&ci->ci_flags, CPUF_FPUSAVE);
#endif
	return;
}
d1823 1
a1823 42
/*
 * Synchronize FP state for this process.
 */
void
fpusave_proc(struct proc *p, int save)
{
	struct cpu_info *ci = curcpu();
	struct cpu_info *oci;
#if defined(MULTIPROCESSOR)
	u_long ipi = save ? ALPHA_IPI_SYNCH_FPU : ALPHA_IPI_DISCARD_FPU;
	int s, spincount;
#endif

	KDASSERT(p->p_addr != NULL);
	KDASSERT(p->p_flag & P_INMEM);

	oci = p->p_addr->u_pcb.pcb_fpcpu;
	if (oci == NULL) {
		return;
	}

#if defined(MULTIPROCESSOR)
	if (oci == ci) {
		KASSERT(ci->ci_fpcurproc == p);
		fpusave_cpu(ci, save);
		return;
	}

	KASSERT(oci->ci_fpcurproc == p);
	alpha_send_ipi(oci->ci_cpuid, ipi);

	spincount = 0;
	while (p->p_addr->u_pcb.pcb_fpcpu != NULL) {
		spincount++;
		delay(1000);    /* XXX */
		if (spincount > 10000)
			panic("fpsave ipi didn't");
	}
#else
	KASSERT(ci->ci_fpcurproc == p);
	fpusave_cpu(ci, save);
#endif /* MULTIPROCESSOR */
d1951 2
a1952 2
void	cpu_exec_ecoff_setregs(struct proc *, struct exec_package *,
	    u_long, register_t *);
@


1.61.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.61.2.2 2002/06/11 03:33:39 art Exp $ */
a163 8
#ifdef APERTURE
#ifdef INSECURE
int allowaperture = 1;
#else
int allowaperture = 0;
#endif
#endif

d1536 1
d1641 2
a1642 1
	frame->tf_regs[FRAME_PC] = p->p_sigcode;
d1790 1
a1790 11
	case CPU_ALLOWAPERTURE:
#ifdef APERTURE
		if (securelevel > 0)
                        return (sysctl_rdint(oldp, oldlenp, newp,
				 allowaperture));
                else
                        return (sysctl_int(oldp, oldlenp, newp, newlen,
                            &allowaperture));
#else
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
#endif
@


1.61.2.4
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d99 6
d394 1
a394 1
	strlcpy(cpu_model, platform.model, sizeof cpu_model);
d819 12
d1059 1
a1059 1
	snprintf(s, sizeof s, "%s family, unknown model variation 0x%lx",
d1633 1
a1633 2
	} else
		sip = NULL;
d1650 2
a1651 1
	frame->tf_regs[FRAME_A1] = (u_int64_t)sip;
d1686 1
a1686 2
	struct sigcontext ksc;
	int error;
d1688 1
d1694 3
d1701 3
a1703 2
	if ((error = copyin(SCARG(uap, sigcntxp), &ksc, sizeof(ksc))) != 0)
		return (error);
@


1.60
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.59 2001/11/28 13:47:37 art Exp $ */
d945 1
@


1.59
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.58 2001/11/24 17:53:39 miod Exp $ */
d152 3
a154 3
vm_map_t exec_map = NULL;
vm_map_t mb_map = NULL;
vm_map_t phys_map = NULL;
@


1.58
log
@Harmonize boot() logic across arches:
- ensure RB_DUMP | RB_HALT will cause a dump
- or RB_HALT if (cold)
While there, honor RB_TIMEBAD on sparc64.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.57 2001/11/07 01:18:00 art Exp $ */
d917 1
a917 1
				UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
@


1.57
log
@Add an alignment argument to uvm_map that specifies an alignment hint
for the virtual address.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.56 2001/11/06 19:53:13 miod Exp $ */
a1122 3
#if 0
	if ((howto & (RB_DUMP | RB_HALT)) == RB_DUMP)
#else
a1123 1
#endif
@


1.56
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.55 2001/09/30 13:08:45 art Exp $ */
d915 1
a915 1
		    NULL, UVM_UNKNOWN_OFFSET,
@


1.55
log
@Generic soft interrupts from NetBSD plus some minor cleanups.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.54 2001/09/19 20:50:55 mickey Exp $ */
d89 1
a89 1
#include <vm/vm.h>
@


1.54
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 2
a2 2
/* $OpenBSD: machdep.c,v 1.53 2001/09/12 14:20:15 millert Exp $ */
/* $NetBSD: machdep.c,v 1.206 2000/05/23 05:12:54 thorpej Exp $ */
d74 1
a126 20
#include <net/netisr.h>
#include <net/if.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/ip_var.h>
#endif

#ifdef INET6
# ifndef INET
#  include <netinet/in.h>
# endif
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#endif

#include "ppp.h"
#include "bridge.h"

a131 1
void	do_sir __P((void));
a134 1
void	netintr __P((void));
d166 2
a186 5
#if !defined(MULTIPROCESSOR)
/* A single machine check info structure for single CPU configurations. */
struct mchkinfo mchkinfo_store;
#endif

d227 1
a227 1
	char *bootinfo_msg;
a1833 45
void
netintr()
{
	int n, s;

	s = splhigh();
	n = netisr;
	netisr = 0;
	splx(s);

#define	DONETISR(bit, fn)						\
	do {								\
		if (n & (1 << (bit)))					\
			fn();						\
	} while (0)

#include <net/netisr_dispatch.h>

#undef DONETISR
}

void
do_sir()
{
	u_int64_t n;

	while ((n = atomic_loadlatch_ulong(&ssir, 0)) != 0) {
#define	COUNT_SOFT	uvmexp.softs++

#define	DO_SIR(bit, fn)							\
		do {							\
			if (n & (bit)) {				\
				COUNT_SOFT;				\
				fn;					\
			}						\
		} while (0)

		DO_SIR(SIR_NET, netintr());
		DO_SIR(SIR_CLOCK, softclock());

#undef COUNT_SOFT
#undef DO_SIR
	}
}

d1840 1
a1840 1
		do_sir();
d1861 4
d1876 3
a1878 3
	whichqs |= (1 << bit);
	p->p_forw = (struct proc *)&qs[bit];
	p->p_back = qs[bit].ph_rlink;
d1880 1
a1880 1
	qs[bit].ph_rlink = p;
d1895 1
a1895 1
	if ((whichqs & (1 << bit)) == 0)
d1902 2
a1903 2
	if ((struct proc *)&qs[bit] == qs[bit].ph_link)
		whichqs &= ~(1 << bit);
@


1.53
log
@Print memory numbers in KB as well as bytes like most other platforms.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.52 2001/09/12 00:23:33 art Exp $ */
a105 1
#include <vm/vm_kern.h>
@


1.52
log
@mbutl no more
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.51 2001/08/23 14:01:02 art Exp $ */
d920 2
a921 1
	printf("total memory = %d\n", ptoa(totalphysmem));
d925 2
a926 1
		printf("WARNING: unused memory = %d\n", ptoa(unusedmem));
d929 2
a930 1
		printf("WARNING: %d of memory with unknown purpose\n", ptoa(unknownmem));
d990 2
a991 1
	printf("avail memory = %d\n", ptoa(uvmexp.free));
d999 2
a1000 1
	printf("using %ld buffers containing %d of memory\n", (long)nbuf, bufpages * NBPG);
@


1.51
log
@We can now move timeout_init into main().
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.50 2001/08/23 12:02:04 art Exp $ */
d981 1
a981 1
	mb_map = uvm_km_suballoc(kernel_map, (vaddr_t *)&mbutl, &maxaddr,
@


1.50
log
@Remove even more old timeout tentacles.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.49 2001/07/05 10:12:03 art Exp $ */
a982 5

	/*
	 * Initialize timeouts
	 */
	timeout_init();
@


1.49
log
@Get rid of REAL_CLISTS. It was never implemented and the tentacles are
everywhhere.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.48 2001/06/26 20:25:50 art Exp $ */
a828 1
	valloc(timeouts, struct timeout, ntimeout);
@


1.48
log
@Provide some chipset information to usreland through sysctl.
The chipset support is not here yet, but the skeleton works.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.47 2001/06/25 00:43:06 mickey Exp $ */
a78 3
#ifdef REAL_CLISTS
#include <sys/clist.h>
#endif
a828 3
#ifdef REAL_CLISTS
	valloc(cfree, struct cblock, nclist);
#endif
@


1.47
log
@cold is in systm now
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.46 2001/05/17 18:41:47 provos Exp $ */
d121 2
d1778 1
a1778 2
	/* all sysctl names at this level are terminal */
	if (namelen != 1)
d1810 3
@


1.46
log
@convert mbuf and cluster allocation to pool, mostly from NetBSD
okay art@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.45 2001/05/05 22:33:23 art Exp $ */
a1115 2
	extern int cold;

@


1.45
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.44 2001/05/05 20:56:30 art Exp $ */
a985 7
	/*
	 * Finally, allocate mbuf pool.  Since mclrefcnt is an off-size
	 * we use the more space efficient malloc in place of kmem_alloc.
	 */
	mclrefcnt = (char *)malloc(NMBCLUSTERS+PAGE_SIZE/MCLBYTES,
			M_MBUF, M_NOWAIT);
	bzero(mclrefcnt, NMBCLUSTERS+PAGE_SIZE/MCLBYTES);
@


1.44
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.43 2001/04/30 15:05:34 art Exp $ */
a1034 2

	configure();
@


1.43
log
@Move the hwrpb_primary_init to before configure.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.42 2001/02/07 07:22:53 art Exp $ */
d859 1
a859 1
		bufpages = (physmem / ((100/BUFCACHEPERCENT) / CLSIZE));
d990 1
a990 1
	mclrefcnt = (char *)malloc(NMBCLUSTERS+CLBYTES/MCLBYTES,
d992 1
a992 1
	bzero(mclrefcnt, NMBCLUSTERS+CLBYTES/MCLBYTES);
@


1.42
log
@Now that niklas has fixed ddb to not barf on elf symbols, there
is no need to disable ddb.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.41 2001/02/06 17:04:09 art Exp $ */
a1028 1
	configure();
d1035 2
@


1.41
log
@Don't initialize ddb until I've committed elf support for ddb.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.40 2001/01/24 16:59:12 art Exp $ */
a791 1
#ifdef notyet
a792 1
#endif
@


1.40
log
@Not killing an application when the application does something wrong
encourages not fixing the application.
SIGBUS on unaligned access.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.39 2000/12/21 16:54:52 aaron Exp $ */
d792 1
d794 1
@


1.39
log
@People have difficulty spelling 'initial' and derivatives thereof (too many
"i's" I guess).
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.38 2000/11/19 01:08:08 art Exp $ */
d225 1
a225 1
int	alpha_unaligned_sigbus = 0;	/* don't SIGBUS on fixed-up accesses */
@


1.38
log
@More sane setting of page size.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.37 2000/11/18 05:26:12 ericj Exp $ */
d367 1
a367 1
	 * Initalize the (temporary) bootstrap console interface, so
d404 1
a404 1
	 * Initalize the real console, so that the bootstrap console is
@


1.37
log
@allow this to compile without COMPAT_OSF1
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.36 2000/11/16 04:33:46 ericj Exp $ */
d435 2
a436 3
	PAGE_SIZE = hwrpb->rpb_page_size;
	if (PAGE_SIZE != 8192)
		panic("page size %d != 8192?!", PAGE_SIZE);
a437 3
	/*
	 * Initialize PAGE_SIZE-dependent variables.
	 */
@


1.36
log
@
configure vga, mouse and keyboard's once again. Currently only on eb164.
others soon. Some of this from NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.35 2000/11/08 19:16:59 ericj Exp $ */
d2071 4
a2074 1
	extern struct emul emul_native, emul_osf1;
@


1.35
log
@add tags
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d889 20
@


1.34
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
@


1.33
log
@Check usec for >= 1000000, not just > ; as msaitoh@@NetBSD.org
@
text
@d1 38
a38 2
/*	$OpenBSD: machdep.c,v 1.32 2000/03/23 09:59:52 art Exp $	*/
/*	$NetBSD: machdep.c,v 1.61 1996/12/07 01:54:49 cgd Exp $	*/
d90 1
a107 1
#include <vm/pmap.h>
d109 1
a148 2
vm_map_t buffer_map;

d151 1
d154 1
a162 1
int	nswbuf = 0;
d173 5
a181 2
int	firstusablepage;	/* first usable memory page */
int	lastusablepage;		/* last usable memory page */
d195 1
a195 1
char	machine[] = "alpha";
d197 1
a197 1
const struct cpusw *cpu_fn_switch;		/* function switch */
a203 3
/* some memory areas for device DMA.  "ick." */
caddr_t		le_iomem;		/* XXX iomem for LANCE DMA */

d207 13
a219 2
char boot_flags[64];
char booted_kernel[64];
a221 1
char	root_device[17];
d226 8
d235 1
a235 1
alpha_init(pfn, ptb, symend)
d238 3
a240 1
	char *symend;		/* end of the symbol table */
d242 1
a242 3
	extern char _end[];
	extern char *esym;
	caddr_t start, v;
d244 1
d246 4
d251 6
d258 1
a258 2
	/* Save the symbol table end */
	esym = symend;
d261 1
a261 1
	 * Turn off interrupts and floating point.
d264 1
a264 1
	(void)splhigh();
d269 3
d273 2
a274 2
	 * get address of the restart block, while the bootstrap
	 * mapping is still around.
d276 82
a357 2
	hwrpb = (struct rpb *)ALPHA_PHYS_TO_K0SEG(
	    (vm_offset_t)(*(struct rpb **)HWRPB_ADDR));
d366 3
a368 2
	 * Init the PROM interface, so we can use printf
	 * until PROM mappings go away in consinit.
d370 11
a380 1
	init_prom_interface();
d383 1
a383 1
	 * Point interrupt/exception vectors to our own.
d385 16
a400 6
	alpha_pal_wrent(XentInt, ALPHA_KENTRY_INT);
	alpha_pal_wrent(XentArith, ALPHA_KENTRY_ARITH);
	alpha_pal_wrent(XentMM, ALPHA_KENTRY_MM);
	alpha_pal_wrent(XentIF, ALPHA_KENTRY_IF);
	alpha_pal_wrent(XentUna, ALPHA_KENTRY_UNA);
	alpha_pal_wrent(XentSys, ALPHA_KENTRY_SYS);
d403 2
a404 2
	 * Disable System and Processor Correctable Error reporting.
	 * Clear pending machine checks and error reports, etc.
d406 51
a456 1
	alpha_pal_wrmces(alpha_pal_rdmces() | ALPHA_MCES_DSC | ALPHA_MCES_DPC);
a462 4
	 *
	 * XXX Assumes that the first "system" cluster is the
	 * only one we can use. Is the second (etc.) system cluster
	 * (if one happens to exist) guaranteed to be contiguous?  or...?
d466 1
a466 3
	/*
	 * BEGIN MDDT WEIRDNESS CHECKING
	 */
d468 1
a468 5

#define cnt	 mddtp->mddt_cluster_cnt
#define	usage(n) mddtp->mddt_clusters[(n)].mddt_usage
	if (cnt != 2 && cnt != 3) {
		printf("WARNING: weird number (%ld) of mem clusters\n", cnt);
d470 2
a471 5
	} else if (usage(0) != MDDT_PALCODE ||
		   usage(1) != MDDT_SYSTEM ||
	           (cnt == 3 && usage(2) != MDDT_PALCODE)) {
		mddtweird = 1;
		printf("WARNING: %ld mem clusters, but weird config\n", cnt);
d474 28
a501 4
	for (i = 0; i < cnt; i++) {
		if ((usage(i) & MDDT_mbz) != 0) {
			printf("WARNING: mem cluster %d has weird usage %lx\n",
			    i, usage(i));
d503 4
d508 74
a581 3
		if (mddtp->mddt_clusters[i].mddt_pg_cnt == 0) {
			printf("WARNING: mem cluster %d has pg cnt == 0\n", i);
			mddtweird = 1;
d583 3
a585 1
		/* XXX other things to check? */
a586 2
#undef cnt
#undef usage
d588 3
a612 3
	/*
	 * END MDDT WEIRDNESS CHECKING
	 */
a613 25
	for (i = 0; i < mddtp->mddt_cluster_cnt; i++) {
		totalphysmem += mddtp->mddt_clusters[i].mddt_pg_cnt;
#define	usage(n) mddtp->mddt_clusters[(n)].mddt_usage
#define	pgcnt(n) mddtp->mddt_clusters[(n)].mddt_pg_cnt
		if ((usage(i) & MDDT_mbz) != 0)
			unknownmem += pgcnt(i);
		else if ((usage(i) & ~MDDT_mbz) == MDDT_PALCODE)
			resvmem += pgcnt(i);
		else if ((usage(i) & ~MDDT_mbz) == MDDT_SYSTEM) {
			/*
			 * assumes that the system cluster listed is
			 * one we're in...
			 */
			if (physmem != resvmem) {
				physmem += pgcnt(i);
				firstusablepage =
				    mddtp->mddt_clusters[i].mddt_pfn;
				lastusablepage =
				    firstusablepage + pgcnt(i) - 1;
			} else
				unusedmem += pgcnt(i);
		}
#undef usage
#undef pgcnt
	}
a616 1

a619 2
	printf("firstusablepage = %d\n", firstusablepage);
	printf("lastusablepage = %d\n", lastusablepage);
d626 1
a626 1
	 * find out this CPU's page size
d628 22
a649 3
	PAGE_SIZE = hwrpb->rpb_page_size;
	if (PAGE_SIZE != 8192)
		panic("page size %d != 8192?!", PAGE_SIZE);
d651 1
a651 4
	/*
	 * Init PAGE_SIZE dependent variables in the MI VM system
	 */
	vm_set_page_size();
a652 1
	v = (caddr_t)alpha_round_page(symend ? symend : _end);
d656 2
a657 110
	start = v;
	curproc->p_addr = proc0paddr = (struct user *)v;
	v += UPAGES * NBPG;

	/*
	 * Find out what hardware we're on, and remember its type name.
	 */
	cputype = hwrpb->rpb_type;
	if (cputype < 0 || cputype > ncpusw) {
unknown_cputype:
		printf("\n");
		printf("Unknown system type %d.\n", cputype);
		printf("\n");
		panic("unknown system type");
	}
	cpu_fn_switch = &cpusw[cputype];
	if (cpu_fn_switch->family == NULL)
		goto unknown_cputype;
	if (cpu_fn_switch->option == NULL) {
		printf("\n");
		printf("OpenBSD does not currently support system type %d\n",
		    cputype);
		printf("(%s family).\n", cpu_fn_switch->family);
		printf("\n");
		panic("unsupported system type");
	}
	if (!cpu_fn_switch->present) {
		printf("\n");
		printf("Support for system type %d (%s family) is\n", cputype,
		    cpu_fn_switch->family);
		printf("not present in this kernel.  Build a kernel with "
		    "\"options %s\"\n", cpu_fn_switch->option);
		printf("to include support for this system type.\n");
		printf("\n");
		panic("support for system not present");
	}

	if ((*cpu_fn_switch->model_name)() != NULL)
		strncpy(cpu_model, (*cpu_fn_switch->model_name)(),
		    sizeof cpu_model - 1);
	else {
		strncpy(cpu_model, cpu_fn_switch->family,
		    sizeof cpu_model - 1);
		strcat(cpu_model, " family");		/* XXX */
	}
	cpu_model[sizeof cpu_model - 1] = '\0';

#if NLE_IOASIC > 0
	/*
	 * Grab 128K at the top of physical memory for the lance chip
	 * on machines where it does dma through the I/O ASIC.
	 * It must be physically contiguous and aligned on a 128K boundary.
	 *
	 * Note that since this is conditional on the presence of
	 * IOASIC-attached 'le' units in the kernel config, the
	 * message buffer may move on these systems.  This shouldn't
	 * be a problem, because once people have a kernel config that
	 * they use, they're going to stick with it.
	 */
	if (cputype == ST_DEC_3000_500 ||
	    cputype == ST_DEC_3000_300) {	/* XXX possibly others? */
		lastusablepage -= btoc(128 * 1024);
		le_iomem =
		    (caddr_t)ALPHA_PHYS_TO_K0SEG(ctob(lastusablepage + 1));
	}
#endif /* NLE_IOASIC */

	/*
	 * Initialize error message buffer (at end of core).
	 */
	lastusablepage -= btoc(MSGBUFSIZE);
	printf("%lx %d\n", (caddr_t)ALPHA_PHYS_TO_K0SEG(ctob(lastusablepage + 1)),
	    MSGBUFSIZE);
	initmsgbuf((caddr_t)ALPHA_PHYS_TO_K0SEG(ctob(lastusablepage + 1)),
	    MSGBUFSIZE);
	printf("%lx %d\n", (caddr_t)ALPHA_PHYS_TO_K0SEG(ctob(lastusablepage + 1)),
	    MSGBUFSIZE);

	/*
	 * Allocate space for system data structures.
	 * The first available kernel virtual address is in "v".
	 * As pages of kernel virtual memory are allocated, "v" is incremented.
	 *
	 * These data structures are allocated here instead of cpu_startup()
	 * because physical memory is directly addressable. We don't have
	 * to map these into virtual address space.
	 */
#define valloc(name, type, num) \
	    (name) = (type *)v; v = (caddr_t)ALIGN((name)+(num))
#define valloclim(name, type, num, lim) \
	    (name) = (type *)v; v = (caddr_t)ALIGN((lim) = ((name)+(num)))
#ifdef REAL_CLISTS
	valloc(cfree, struct cblock, nclist);
#endif
	valloc(timeouts, struct timeout, ntimeout);
#ifdef SYSVSHM
	valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
#endif
#ifdef SYSVSEM
	valloc(sema, struct semid_ds, seminfo.semmni);
	valloc(sem, struct sem, seminfo.semmns);
	/* This is pretty disgusting! */
	valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
#endif
#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
d660 9
a668 19
	 * Determine how many buffers to allocate.
	 * We allocate 10% of memory for buffer space.  Insure a
	 * minimum of 16 buffers.  We allocate 1/2 as many swap buffer
	 * headers as file i/o buffers.
	 */
	if (bufpages == 0)
		bufpages = (physmem * 10) / (CLSIZE * 100);
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}
	if (nswbuf == 0) {
		nswbuf = (nbuf / 2) &~ 1;	/* force even */
		if (nswbuf > 256)
			nswbuf = 256;		/* sanity */
	}
	valloc(swbuf, struct buf, nswbuf);
	valloc(buf, struct buf, nbuf);
d673 1
a673 1
	bzero(start, v - start);
d679 2
a680 6
#ifndef NEW_PMAP
	pmap_bootstrap((vm_offset_t)v, ALPHA_PHYS_TO_K0SEG(ptb << PGSHIFT));
#else
	pmap_bootstrap((vm_offset_t)v, ALPHA_PHYS_TO_K0SEG(ptb << PGSHIFT),
	    hwrpb->rpb_max_asn);
#endif
d687 1
a687 1
	    (struct pcb *)ALPHA_K0SEG_TO_PHYS((vm_offset_t)&proc0paddr->u_pcb);
d698 7
a704 3
#ifdef NEW_PMAP
	pmap_activate(kernel_pmap, &proc0paddr->u_pcb.pcb_hw, 0);
#endif
a707 1
	 * Also, get kernel name so it can be used in user-land.
a708 9
	prom_getenv(PROM_E_BOOTED_OSFLAGS, boot_flags, sizeof(boot_flags));
#if 0
	printf("boot flags = \"%s\"\n", boot_flags);
#endif
	prom_getenv(PROM_E_BOOTED_FILE, booted_kernel,
	    sizeof(booted_kernel));
#if 0
	printf("booted kernel = \"%s\"\n", booted_kernel);
#endif
d714 1
a714 1
	for (p = boot_flags; p && *p != '\0'; p++) {
d759 16
d778 1
d786 1
a786 2
		pcsp = (struct pcs *)((char *)hwrpb + hwrpb->rpb_pcs_off +
		    (i * hwrpb->rpb_pcs_size));
d790 83
d878 8
a885 6
	(*cpu_fn_switch->cons_init)();
	pmap_unmap_prom();
#ifdef DDB
	ddb_init();
	if (boothowto & RB_KDB)
		Debugger();
d894 2
a895 2
	vm_offset_t minaddr, maxaddr;
	vm_size_t size;
d908 9
a916 7
	printf("real mem = %d (%d reserved for PROM, %d used by OpenBSD)\n",
	    ctob(totalphysmem), ctob(resvmem), ctob(physmem));
	if (unusedmem)
		printf("WARNING: unused memory = %d bytes\n", ctob(unusedmem));
	if (unknownmem)
		printf("WARNING: %d bytes of memory with unknown purpose\n",
		    ctob(unknownmem));
d924 5
a928 6
	buffer_map = kmem_suballoc(kernel_map, (vm_offset_t *)&buffers,
	    &maxaddr, size, TRUE);
	minaddr = (vm_offset_t)buffers;
	if (vm_map_find(buffer_map, vm_object_allocate(size), (vm_offset_t)0,
			&minaddr, size, FALSE) != KERN_SUCCESS)
		panic("startup: cannot allocate buffers");
d932 3
a934 2
		vm_size_t curbufsize;
		vm_offset_t curbuf;
d937 4
a940 5
		 * First <residual> buffers get (base+1) physical pages
		 * allocated for them.  The rest get (base) physical pages.
		 *
		 * The rest of each buffer occupies virtual space,
		 * but has no physical memory allocated for it.
d942 13
a954 4
		curbuf = (vm_offset_t)buffers + i * MAXBSIZE;
		curbufsize = CLBYTES * (i < residual ? base+1 : base);
		vm_map_pageable(buffer_map, curbuf, curbuf+curbufsize, FALSE);
		vm_map_simplify(buffer_map, curbuf);
d960 2
a961 2
	exec_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
				 16 * NCARGS, TRUE);
d966 2
a967 2
	phys_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
				 VM_PHYS_SIZE, TRUE);
d974 1
a974 1
	    M_MBUF, M_NOWAIT);
d976 3
a978 2
	mb_map = kmem_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
	    VM_MBUF_SIZE, FALSE);
d987 9
a995 3
	printf("avail mem = %ld\n", (long)ptoa(cnt.v_free_count));
	printf("using %ld buffers containing %ld bytes of memory\n",
		(long)nbuf, (long)(bufpages * CLBYTES));
d1015 17
a1031 2
	 * Note that bootstrapping is finished, and set the HWRPB up
	 * to do restarts.
d1033 37
a1069 1
	hwrpb_restart_setup();
d1075 1
d1080 7
a1086 2
	printf("%s, %ldMHz\n", cpu_model,
	    hwrpb->rpb_cc_freq / 1000000);	/* XXX true for 21164? */
d1104 1
a1104 1
boot(howto /* , bootstr */)
a1105 1
	/* char *bootstr; */
d1109 12
a1132 6
		extern struct proc proc0;

		/* protect against curproc->p_stats.foo refs in sync   XXX */
		if (curproc == NULL)
			curproc = &proc0;

d1137 1
a1137 2
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
d1139 1
a1139 5
		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
d1158 12
d1172 1
d1174 1
d1178 6
a1183 1
	/* Finally, halt/reboot the system. */
d1204 2
a1205 1
	size = ALIGN(sizeof(kcore_seg_t)) + ALIGN(sizeof(cpu_kcore_hdr_t));
d1213 14
d1233 5
a1237 3
	long buf[dbtob(1) / sizeof (long)];
	kcore_seg_t	*segp;
	cpu_kcore_hdr_t	*cpuhdrp;
d1239 1
a1239 1
        dump = bdevsw[major(dumpdev)].d_dump;
d1241 1
d1243 3
a1245 2
	cpuhdrp =
	    (cpu_kcore_hdr_t *)&buf[ALIGN(sizeof(*segp)) / sizeof (long)];
d1254 1
a1254 1
	 * Add the machine-dependent header info
d1256 1
a1256 1
	cpuhdrp->lev1map_pa = ALPHA_K0SEG_TO_PHYS((vm_offset_t)Lev1map);
d1258 9
a1266 2
	cpuhdrp->core_seg.start = ctob(firstusablepage);
	cpuhdrp->core_seg.size = ctob(physmem);
d1272 2
a1273 2
 * This is called by configure to set dumplo and dumpsize.
 * Dumps always skip the first CLBYTES of disk space
d1298 1
a1298 1
	dumpblks += ctod(physmem);
d1308 1
a1308 1
	dumpsize = physmem;
d1324 3
a1326 2
	unsigned bytes, i, n;
	int maddr, psize;
d1346 2
a1347 1
		printf("\ndump to dev %x not possible\n", dumpdev);
d1350 2
a1351 1
	printf("\ndumping to dev %x, offset %ld\n", dumpdev, dumplo);
d1365 1
a1365 2
	bytes = ctob(physmem);
	maddr = ctob(firstusablepage);
a1368 1
	for (i = 0; i < bytes; i += n) {
d1370 21
a1390 15
		/* Print out how many MBs we to go. */
		n = bytes - i;
		if (n && (n % (1024*1024)) == 0)
			printf("%d ", n / (1024 * 1024));

		/* Limit size for next transfer. */
		if (n > BYTES_PER_DUMP)
			n =  BYTES_PER_DUMP;

		error = (*dump)(dumpdev, blkno,
		    (caddr_t)ALPHA_PHYS_TO_K0SEG(maddr), n);
		if (error)
			break;
		maddr += n;
		blkno += btodb(n);			/* XXX? */
d1392 2
a1393 1
		/* XXX should look for keystrokes, to cancel. */
a1558 1
	extern struct proc *fpcurproc;
d1574 1
a1574 1
	 * call to grow() is a nop, and the useracc() check
d1586 1
a1586 1
		(void)grow(p, (u_long)scp);
d1592 1
a1592 1
	if (useracc((caddr_t)scp, fsize, B_WRITE) == 0) {
d1595 1
a1595 1
			printf("sendsig(%d): useracc failed on sig %d\n",
a1703 1
	extern struct proc *fpcurproc;
d1718 1
a1718 1
	if (useracc((caddr_t)scp, sizeof (*scp), B_WRITE) == 0 ||
d1783 2
a1784 1
		return (sysctl_rdstring(oldp, oldlenp, newp, root_device));
d1799 2
a1800 1
		return (sysctl_rdstring(oldp, oldlenp, newp, booted_kernel));
a1818 1
	extern struct proc *fpcurproc;
d1868 1
a1868 1
			fn;						\
d1871 1
a1871 28
#ifdef INET
	DONETISR(NETISR_ARP, arpintr());
	DONETISR(NETISR_IP, ipintr());
#endif
#ifdef INET6
	DONETISR(NETISR_IPV6, ip6intr());
#endif
#ifdef NETATALK
	DONETISR(NETISR_ATALK, atintr());
#endif
#ifdef NS
	DONETISR(NETISR_NS, nsintr());
#endif
#ifdef ISO
	DONETISR(NETISR_ISO, clnlintr());
#endif
#ifdef CCITT
	DONETISR(NETISR_CCITT, ccittintr());
#endif
#ifdef NATM
	DONETISR(NETISR_NATM, natmintr());
#endif
#if NPPP > 0
	DONETISR(NETISR_PPP, pppintr());
#endif
#if NBRIDGE > 0
	DONETISR(NETISR_BRIDGE, bridgeintr());
#endif
d1881 3
a1883 6
	do {
		(void)splhigh();
		n = ssir;
		ssir = 0;
		splsoft();		/* don't recurse through spl0() */
	
d1887 1
a1887 1
				cnt.v_soft++;				\
d1895 1
d1897 1
a1897 1
	} while (ssir != 0);
d1904 4
a1907 2
	if (ssir)
		do_sir();		/* it lowers the IPL itself */
d2008 10
a2017 2
	while (N > 0)				/* XXX */
		N -= 3;				/* XXX */
d2050 4
a2053 4
	extern struct emul emul_native;
#ifdef COMPAT_OSF1
	extern struct emul emul_osf1;
#endif
d2064 1
d2068 1
a2068 1
		return ENOEXEC;
d2070 1
a2070 1
	return 0;
d2074 25
d2100 1
a2100 1
vm_offset_t alpha_XXX_dmamap_or;				/* XXX */
d2102 1
a2102 1
vm_offset_t							/* XXX */
d2104 1
a2104 1
	vm_offset_t v;						/* XXX */
d2110 22
@


1.32
log
@New API for timeouts. Replaces the old timeout()/untimeout() API and
makes it the callers responsibility to allocate resources for the
timeouts.

This is a KISS implementation and does _not_ solve the problems of slow
handling of a large number of pending timeouts (this will be solved in
future work) (although hardclock is now guarateed to take constant time
for handling of timeouts).

Old timeout() and untimeout() are implemented as wrappers around the new
API and kept for compatibility. They will be removed as soon as all
subsystems are converted to use the new API.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 2000/02/22 19:27:40 deraadt Exp $	*/
d1621 1
a1621 1
	while (tvp->tv_usec > 1000000) {
d1628 1
a1628 1
	    (tvp->tv_usec = lasttime.tv_usec + 1) > 1000000) {
@


1.31
log
@enlarge msgbuf, somewhat line netbsd did
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.30 2000/02/09 06:01:15 itojun Exp $	*/
d45 1
a45 1
#include <sys/callout.h>
d459 1
a459 1
	valloc(callout, struct callout, ncallout);
d705 1
a705 1
	 * Initialize callouts
d707 1
a707 4
	callfree = callout;
	for (i = 1; i < ncallout; i++)
		callout[i-1].c_next = &callout[i];
	callout[i-1].c_next = NULL;
@


1.30
log
@don't include netinet6/ip6.h
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.29 1999/12/08 06:50:14 itojun Exp $	*/
a136 1
int	msgbufmapped = 0;	/* set when safe to use msgbuf */
d435 7
a441 4
	lastusablepage -= btoc(sizeof (struct msgbuf));
	msgbufp =
	    (struct msgbuf *)ALPHA_PHYS_TO_K0SEG(ctob(lastusablepage + 1));
	msgbufmapped = 1;
d949 1
@


1.30.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d137 1
d436 4
a439 7
	lastusablepage -= btoc(MSGBUFSIZE);
	printf("%lx %d\n", (caddr_t)ALPHA_PHYS_TO_K0SEG(ctob(lastusablepage + 1)),
	    MSGBUFSIZE);
	initmsgbuf((caddr_t)ALPHA_PHYS_TO_K0SEG(ctob(lastusablepage + 1)),
	    MSGBUFSIZE);
	printf("%lx %d\n", (caddr_t)ALPHA_PHYS_TO_K0SEG(ctob(lastusablepage + 1)),
	    MSGBUFSIZE);
a946 1
	extern int msgbufmapped;
@


1.30.2.2
log
@Sync with -current
@
text
@d45 1
a45 1
#include <sys/timeout.h>
d459 1
a459 1
	valloc(timeouts, struct timeout, ntimeout);
d705 1
a705 1
	 * Initialize timeouts
d707 4
a710 1
	timeout_init();
@


1.30.2.3
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 39
/* $OpenBSD: machdep.c,v 1.42 2001/02/07 07:22:53 art Exp $ */
/* $NetBSD: machdep.c,v 1.206 2000/05/23 05:12:54 thorpej Exp $ */

/*-
 * Copyright (c) 1998, 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center and by Chris G. Demetriou.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
a53 1
#include <vm/vm.h>
d71 1
a72 1
#include <uvm/uvm_extern.h>
d112 2
a115 1
u_long	cpu_dump_mempagecnt __P((void));
a117 1
caddr_t allocsys __P((caddr_t));
d126 1
a136 5

vm_map_t exec_map = NULL;
vm_map_t mb_map = NULL;
vm_map_t phys_map = NULL;

d141 2
d156 1
a156 1
char	machine[] = MACHINE;		/* from <machine/param.h> */
d158 1
a158 1
char	root_device[17];
d165 3
d171 2
a172 13
#if !defined(MULTIPROCESSOR)
/* A single machine check info structure for single CPU configurations. */
struct mchkinfo mchkinfo_store;
#endif

struct bootinfo_kernel bootinfo;

/* For built-in TCDS */
#if defined(DEC_3000_300) || defined(DEC_3000_500)
u_int8_t	dec_3000_scsiid[2], dec_3000_scsifast[2];
#endif

struct platform platform;
d175 1
d178 1
a178 9
int	alpha_unaligned_sigbus = 1;	/* SIGBUS on fixed-up accesses */

/*
 * XXX This should be dynamically sized, but we have the chicken-egg problem!
 * XXX it should also be larger than it is, because not all of the mddt
 * XXX clusters end up being used for VM.
 */
phys_ram_seg_t mem_clusters[VM_PHYSSEG_MAX];	/* low size bits overloaded */
int	mem_cluster_cnt;
d181 1
a181 1
alpha_init(pfn, ptb, bim, bip, biv)
d184 1
a184 3
	u_long bim;		/* bootinfo magic */
	u_long bip;		/* bootinfo pointer */
	u_long biv;		/* bootinfo version */
d186 3
a188 1
	extern char kernel_text[], _end[];
a189 1
	struct mddt_cluster *memc;
a190 4
	struct vm_physseg *vps;
	vaddr_t kernstart, kernend;
	paddr_t kernstartpfn, kernendpfn, pfn0, pfn1;
	vsize_t size;
a191 6
	caddr_t v;
	char *bootinfo_msg;
	const struct cpuinit *c;
	extern caddr_t esym;
	struct cpu_info *ci;
	cpuid_t cpu_id;
d193 2
a194 1
	/* NO OUTPUT ALLOWED UNTIL FURTHER NOTICE */
d197 1
a197 1
	 * Turn off interrupts (not mchecks) and floating point.
d200 1
a200 1
	(void)alpha_pal_swpipl(ALPHA_PSL_IPL_HIGH);
a204 3
	cpu_id = cpu_number();

#if defined(MULTIPROCESSOR)
d206 2
a207 2
	 * Set our SysValue to the address of our cpu_info structure.
	 * Secondary processors do this in their spinup trampoline.
d209 2
a210 82
	alpha_pal_wrval((u_long)&cpu_info[cpu_id]);
#endif

	ci = curcpu();
	ci->ci_cpuid = cpu_id;

	/*
	 * Get critical system information (if possible, from the
	 * information provided by the boot program).
	 */
	bootinfo_msg = NULL;
	if (bim == BOOTINFO_MAGIC) {
		if (biv == 0) {		/* backward compat */
			biv = *(u_long *)bip;
			bip += 8;
		}
		switch (biv) {
		case 1: {
			struct bootinfo_v1 *v1p = (struct bootinfo_v1 *)bip;

			bootinfo.ssym = v1p->ssym;
			bootinfo.esym = v1p->esym;
			/* hwrpb may not be provided by boot block in v1 */
			if (v1p->hwrpb != NULL) {
				bootinfo.hwrpb_phys =
				    ((struct rpb *)v1p->hwrpb)->rpb_phys;
				bootinfo.hwrpb_size = v1p->hwrpbsize;
			} else {
				bootinfo.hwrpb_phys =
				    ((struct rpb *)HWRPB_ADDR)->rpb_phys;
				bootinfo.hwrpb_size =
				    ((struct rpb *)HWRPB_ADDR)->rpb_size;
			}
			bcopy(v1p->boot_flags, bootinfo.boot_flags,
			    min(sizeof v1p->boot_flags,
			      sizeof bootinfo.boot_flags));
			bcopy(v1p->booted_kernel, bootinfo.booted_kernel,
			    min(sizeof v1p->booted_kernel,
			      sizeof bootinfo.booted_kernel));
			/* booted dev not provided in bootinfo */
			init_prom_interface((struct rpb *)
			    ALPHA_PHYS_TO_K0SEG(bootinfo.hwrpb_phys));
                	prom_getenv(PROM_E_BOOTED_DEV, bootinfo.booted_dev,
			    sizeof bootinfo.booted_dev);
			break;
		}
		default:
			bootinfo_msg = "unknown bootinfo version";
			goto nobootinfo;
		}
	} else {
		bootinfo_msg = "boot program did not pass bootinfo";
nobootinfo:
		bootinfo.ssym = (u_long)_end;
		bootinfo.esym = (u_long)_end;
		bootinfo.hwrpb_phys = ((struct rpb *)HWRPB_ADDR)->rpb_phys;
		bootinfo.hwrpb_size = ((struct rpb *)HWRPB_ADDR)->rpb_size;
		init_prom_interface((struct rpb *)HWRPB_ADDR);
		prom_getenv(PROM_E_BOOTED_OSFLAGS, bootinfo.boot_flags,
		    sizeof bootinfo.boot_flags);
		prom_getenv(PROM_E_BOOTED_FILE, bootinfo.booted_kernel,
		    sizeof bootinfo.booted_kernel);
		prom_getenv(PROM_E_BOOTED_DEV, bootinfo.booted_dev,
		    sizeof bootinfo.booted_dev);
	}

	esym = (caddr_t)bootinfo.esym;
	/*
	 * Initialize the kernel's mapping of the RPB.  It's needed for
	 * lots of things.
	 */
	hwrpb = (struct rpb *)ALPHA_PHYS_TO_K0SEG(bootinfo.hwrpb_phys);

#if defined(DEC_3000_300) || defined(DEC_3000_500)
	if (hwrpb->rpb_type == ST_DEC_3000_300 ||
	    hwrpb->rpb_type == ST_DEC_3000_500) {
		prom_getenv(PROM_E_SCSIID, dec_3000_scsiid,
		    sizeof(dec_3000_scsiid));
		prom_getenv(PROM_E_SCSIFAST, dec_3000_scsifast,
		    sizeof(dec_3000_scsifast));
	}
#endif
d219 2
a220 3
	 * Initialize the (temporary) bootstrap console interface, so
	 * we can use printf until the VM system starts being setup.
	 * The real console is initialized before then.
d222 1
a222 11
	init_bootstrap_console();

	/* OUTPUT NOW ALLOWED */

	/* delayed from above */
	if (bootinfo_msg)
		printf("WARNING: %s (0x%lx, 0x%lx, 0x%lx)\n",
		    bootinfo_msg, bim, bip, biv);

	/* Initialize the trap vectors on the primary processor. */
	trap_init();
d225 1
a225 1
	 * Find out what hardware we're on, and do basic initialization.
d227 6
a232 16
	cputype = hwrpb->rpb_type;
	if (cputype < 0) {
		/*
		 * At least some white-box systems have SRM which
		 * reports a systype that's the negative of their
		 * blue-box counterpart.
		 */
		cputype = -cputype;
	}
	c = platform_lookup(cputype);
	if (c == NULL) {
		platform_not_supported();
		/* NOTREACHED */
	}
	(*c->init)();
	strcpy(cpu_model, platform.model);
d235 2
a236 2
	 * Initialize the real console, so that the bootstrap console is
	 * no longer necessary.
d238 1
a238 47
	(*platform.cons_init)();

#ifdef DIAGNOSTIC
	/* Paranoid sanity checking */

	/* We should always be running on the primary. */
	assert(hwrpb->rpb_primary_cpu_id == alpha_pal_whami());

	/*
	 * On single-CPU systypes, the primary should always be CPU 0,
	 * except on Alpha 8200 systems where the CPU id is related
	 * to the VID, which is related to the Turbo Laser node id.
	 */
	if (cputype != ST_DEC_21000)
		assert(hwrpb->rpb_primary_cpu_id == 0);
#endif

	/* NO MORE FIRMWARE ACCESS ALLOWED */
#ifdef _PMAP_MAY_USE_PROM_CONSOLE
	/*
	 * XXX (unless _PMAP_MAY_USE_PROM_CONSOLE is defined and
	 * XXX pmap_uses_prom_console() evaluates to non-zero.)
	 */
#endif

	/*
	 * find out this system's page size
	 */
	if ((uvmexp.pagesize = hwrpb->rpb_page_size) != 8192)
		panic("page size %d != 8192?!", uvmexp.pagesize);

	uvm_setpagesize();

	/*
	 * Find the beginning and end of the kernel (and leave a
	 * bit of space before the beginning for the bootstrap
	 * stack).
	 */
	kernstart = trunc_page((vaddr_t)kernel_text) - 2 * PAGE_SIZE;
#ifdef DDB
	kernend = (vaddr_t)round_page((vaddr_t)bootinfo.esym);
#else
	kernend = (vaddr_t)round_page((vaddr_t)_end);
#endif

	kernstartpfn = atop(ALPHA_K0SEG_TO_PHYS(kernstart));
	kernendpfn = atop(ALPHA_K0SEG_TO_PHYS(kernend));
d245 4
d252 3
a254 1
	/* MDDT SANITY CHECKING */
d256 5
a260 1
	if (mddtp->mddt_cluster_cnt < 2) {
d262 5
a266 2
		printf("WARNING: weird number of mem clusters: %lu\n",
		    mddtp->mddt_cluster_cnt);
d269 5
a273 25
#if 0
	printf("Memory cluster count: %d\n", mddtp->mddt_cluster_cnt);
#endif

	for (i = 0; i < mddtp->mddt_cluster_cnt; i++) {
		memc = &mddtp->mddt_clusters[i];
#if 0
		printf("MEMC %d: pfn 0x%lx cnt 0x%lx usage 0x%lx\n", i,
		    memc->mddt_pfn, memc->mddt_pg_cnt, memc->mddt_usage);
#endif
		totalphysmem += memc->mddt_pg_cnt;
		if (mem_cluster_cnt < VM_PHYSSEG_MAX) {	/* XXX */
			mem_clusters[mem_cluster_cnt].start =
			    ptoa(memc->mddt_pfn);
			mem_clusters[mem_cluster_cnt].size =
			    ptoa(memc->mddt_pg_cnt);
			if (memc->mddt_usage & MDDT_mbz ||
			    memc->mddt_usage & MDDT_NONVOLATILE || /* XXX */
			    memc->mddt_usage & MDDT_PALCODE)
				mem_clusters[mem_cluster_cnt].size |=
				    VM_PROT_READ;
			else
				mem_clusters[mem_cluster_cnt].size |=
				    VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE;
			mem_cluster_cnt++;
d275 2
a276 2

		if (memc->mddt_usage & MDDT_mbz) {
a277 15
			printf("WARNING: mem cluster %d has weird "
			    "usage 0x%lx\n", i, memc->mddt_usage);
			unknownmem += memc->mddt_pg_cnt;
			continue;
		}
		if (memc->mddt_usage & MDDT_NONVOLATILE) {
			/* XXX should handle these... */
			printf("WARNING: skipping non-volatile mem "
			    "cluster %d\n", i);
			unusedmem += memc->mddt_pg_cnt;
			continue;
		}
		if (memc->mddt_usage & MDDT_PALCODE) {
			resvmem += memc->mddt_pg_cnt;
			continue;
d279 1
a279 67

		/*
		 * We have a memory cluster available for system
		 * software use.  We must determine if this cluster
		 * holds the kernel.
		 */
#ifdef _PMAP_MAY_USE_PROM_CONSOLE
		/*
		 * XXX If the kernel uses the PROM console, we only use the
		 * XXX memory after the kernel in the first system segment,
		 * XXX to avoid clobbering prom mapping, data, etc.
		 */
	    if (!pmap_uses_prom_console() || physmem == 0) {
#endif /* _PMAP_MAY_USE_PROM_CONSOLE */
		physmem += memc->mddt_pg_cnt;
		pfn0 = memc->mddt_pfn;
		pfn1 = memc->mddt_pfn + memc->mddt_pg_cnt;
		if (pfn0 <= kernstartpfn && kernendpfn <= pfn1) {
			/*
			 * Must compute the location of the kernel
			 * within the segment.
			 */
#if 0
			printf("Cluster %d contains kernel\n", i);
#endif
#ifdef _PMAP_MAY_USE_PROM_CONSOLE
		    if (!pmap_uses_prom_console()) {
#endif /* _PMAP_MAY_USE_PROM_CONSOLE */
			if (pfn0 < kernstartpfn) {
				/*
				 * There is a chunk before the kernel.
				 */
#if 0
				printf("Loading chunk before kernel: "
				    "0x%lx / 0x%lx\n", pfn0, kernstartpfn);
#endif
				uvm_page_physload(pfn0, kernstartpfn,
				    pfn0, kernstartpfn, VM_FREELIST_DEFAULT);
			}
#ifdef _PMAP_MAY_USE_PROM_CONSOLE
		    }
#endif /* _PMAP_MAY_USE_PROM_CONSOLE */
			if (kernendpfn < pfn1) {
				/*
				 * There is a chunk after the kernel.
				 */
#if 0
				printf("Loading chunk after kernel: "
				    "0x%lx / 0x%lx\n", kernendpfn, pfn1);
#endif
				uvm_page_physload(kernendpfn, pfn1,
				    kernendpfn, pfn1, VM_FREELIST_DEFAULT);
			}
		} else {
			/*
			 * Just load this cluster as one chunk.
			 */
#if 0
			printf("Loading cluster %d: 0x%lx / 0x%lx\n", i,
			    pfn0, pfn1);
#endif
			uvm_page_physload(pfn0, pfn1, pfn0, pfn1,
			    VM_FREELIST_DEFAULT);
		}
#ifdef _PMAP_MAY_USE_PROM_CONSOLE
	    }
#endif /* _PMAP_MAY_USE_PROM_CONSOLE */
d281 2
a283 3
	/*
	 * Dump out the MDDT if it looks odd...
	 */
d306 3
d310 25
d338 1
d342 2
d350 21
a370 1
	 * Initialize error message buffer (at end of core).
d372 29
a400 22
	{
		vsize_t sz = (vsize_t)round_page(MSGBUFSIZE);
		vsize_t reqsz = sz;

		vps = &vm_physmem[vm_nphysseg - 1];

		/* shrink so that it'll fit in the last segment */
		if ((vps->avail_end - vps->avail_start) < atop(sz))
			sz = ptoa(vps->avail_end - vps->avail_start);

		vps->end -= atop(sz);
		vps->avail_end -= atop(sz);
		initmsgbuf((caddr_t) ALPHA_PHYS_TO_K0SEG(ptoa(vps->end)), sz);

		/* Remove the last segment if it now has no pages. */
		if (vps->start == vps->end)
			vm_nphysseg--;

		/* warn if the message buffer had to be shrunk */
		if (sz != reqsz)
			printf("WARNING: %ld bytes not available for msgbuf "
			    "in last cluster (%ld used)\n", reqsz, sz);
d402 7
d410 1
d412 1
d414 37
a450 1
	 * Init mapping for u page(s) for proc 0
d452 23
a474 2
	proc0.p_addr = proc0paddr =
	    (struct user *)pmap_steal_memory(UPAGES * PAGE_SIZE, NULL, NULL);
d477 19
a495 9
	 * Allocate space for system data structures.  These data structures
	 * are allocated here instead of cpu_startup() because physical
	 * memory is directly addressable.  We don't have to map these into
	 * virtual address space.
	 */
	size = (vsize_t)allocsys(NULL);
	v = (caddr_t)pmap_steal_memory(size, NULL, NULL);
	if ((allocsys(v) - v) != size)
		panic("alpha_init: table size inconsistency");
d500 1
a500 1
	bzero(v, size);
d506 6
a511 2
	pmap_bootstrap(ALPHA_PHYS_TO_K0SEG(ptb << PGSHIFT),
	    hwrpb->rpb_max_asn, hwrpb->rpb_pcs_cnt);
d518 1
a518 1
	    (struct pcb *)ALPHA_K0SEG_TO_PHYS((vaddr_t)&proc0paddr->u_pcb);
d529 3
a531 7
	/*
	 * Initialize the primary CPU's idle PCB to proc0's.  In a
	 * MULTIPROCESSOR configuration, each CPU will later get
	 * its own idle PCB when autoconfiguration runs.
	 */
	ci->ci_idle_pcb = &proc0paddr->u_pcb;
	ci->ci_idle_pcb_paddr = (u_long)proc0.p_md.md_pcbpaddr;
d535 1
d537 9
d551 1
a551 1
	for (p = bootinfo.boot_flags; p && *p != '\0'; p++) {
a595 16

		case 's': /* single-user (default, supported for sanity) */
		case 'S':
			boothowto |= RB_SINGLE;
			break;

		case '-':
			/*
			 * Just ignore this.  It's not required, but it's
			 * common for it to be passed regardless.
			 */
			break;

		default:
			printf("Unrecognized boot flag '%c'.\n", *p);
			break;
a598 1

d606 2
a607 1
		pcsp = LOCATE_PCS(hwrpb, i);
d611 1
d613 5
a617 3
	/*
	 * Initialize debuggers, and break into them if appropriate.
	 */
a619 1

a622 15
#ifdef KGDB
	if (boothowto & RB_KDB)
		kgdb_connect(0);
#endif
	/*
	 * Figure out our clock frequency, from RPB fields.
	 */
	hz = hwrpb->rpb_intr_freq >> 12;
	if (!(60 <= hz && hz <= 10240)) {
		hz = 1024;
#ifdef DIAGNOSTIC
		printf("WARNING: unbelievable rpb_intr_freq: %ld (%d hz)\n",
			hwrpb->rpb_intr_freq, hz);
#endif
	}
a624 92
caddr_t
allocsys(v)
	caddr_t v;
{
	/*
	 * Allocate space for system data structures.
	 * The first available kernel virtual address is in "v".
	 * As pages of kernel virtual memory are allocated, "v" is incremented.
	 *
	 * These data structures are allocated here instead of cpu_startup()
	 * because physical memory is directly addressable. We don't have
	 * to map these into virtual address space.
	 */
#define valloc(name, type, num) \
	    (name) = (type *)v; v = (caddr_t)ALIGN((name)+(num))

#ifdef REAL_CLISTS
	valloc(cfree, struct cblock, nclist);
#endif
	valloc(timeouts, struct timeout, ntimeout);
#ifdef SYSVSHM
	valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
#endif
#ifdef SYSVSEM
	valloc(sema, struct semid_ds, seminfo.semmni);
	valloc(sem, struct sem, seminfo.semmns);
	/* This is pretty disgusting! */
	valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
#endif
#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 10
#endif
	/*
	 * Determine how many buffers to allocate.
	 * We allocate 10% of memory for buffer space.  Insure a
	 * minimum of 16 buffers.
	 */
	if (bufpages == 0)
		bufpages = (physmem / ((100/BUFCACHEPERCENT) / CLSIZE));
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}
	valloc(buf, struct buf, nbuf);

#undef valloc

	return v;
}

void
consinit()
{

	/*
	 * Everything related to console initialization is done
	 * in alpha_init().
	 */
#if defined(DIAGNOSTIC) && defined(_PMAP_MAY_USE_PROM_CONSOLE)
	printf("consinit: %susing prom console\n",
	    pmap_uses_prom_console() ? "" : "not ");
#endif
}

#include "pckbc.h"
#include "pckbd.h"
#if (NPCKBC > 0) && (NPCKBD == 0)

#include <dev/ic/pckbcvar.h>

/*
 * This is called by the pbkbc driver if no pckbd is configured.
 * On the i386, it is used to glue in the old, deprecated console
 * code.  On the Alpha, it does nothing.
 */
int
pckbc_machdep_cnattach(kbctag, kbcslot)
	pckbc_tag_t kbctag;
	pckbc_slot_t kbcslot;
{
	return (ENXIO);
}
#endif /* NPCKBC > 0 && NPCKBD == 0 */

d630 2
a631 2
	vaddr_t minaddr, maxaddr;
	vsize_t size;
d644 7
a650 9
	printf("total memory = %d\n", ptoa(totalphysmem));
	printf("(%d reserved for PROM, ", ptoa(resvmem));
	printf("%d used by OpenBSD)\n", ptoa(physmem));
	if (unusedmem) {
		printf("WARNING: unused memory = %d\n", ptoa(unusedmem));
	}
	if (unknownmem) {
		printf("WARNING: %d of memory with unknown purpose\n", ptoa(unknownmem));
	}
d658 6
a663 5
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(size),
		    NULL, UVM_UNKNOWN_OFFSET,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
				UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
		panic("startup: cannot allocate VM for buffers");
d667 2
a668 3
		vsize_t curbufsize;
		vaddr_t curbuf;
		struct vm_page *pg;
d671 5
a675 4
		 * Each buffer has MAXBSIZE bytes of VM space allocated.  Of
		 * that MAXBSIZE space, we allocate and map (base+1) pages
		 * for the first "residual" buffers, and then we allocate
		 * "base" pages for the rest.
d677 4
a680 13
		curbuf = (vaddr_t) buffers + (i * MAXBSIZE);
		curbufsize = NBPG * ((i < residual) ? (base+1) : base);

		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: not enough memory for "
				    "buffer cache");
			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
					VM_PROT_READ|VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
d686 2
a687 2
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   16 * NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);
d692 2
a693 2
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   VM_PHYS_SIZE, 0, FALSE, NULL);
d700 1
a700 1
			M_MBUF, M_NOWAIT);
d702 2
a703 3
	mb_map = uvm_km_suballoc(kernel_map, (vaddr_t *)&mbutl, &maxaddr,
			VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);

d712 3
a714 9
	printf("avail memory = %d\n", ptoa(uvmexp.free));
#if 0
	{
		extern u_long pmap_pages_stolen;

		printf("stolen memory for VM structures = %d\n", pmap_pages_stolen * PAGE_SIZE);
	}
#endif
	printf("using %ld buffers containing %d of memory\n", (long)nbuf, bufpages * NBPG);
d734 2
a735 17
	 * Set up the HWPCB so that it's safe to configure secondary
	 * CPUs.
	 */
	hwrpb_primary_init();
}

/*
 * Retrieve the platform name from the DSR.
 */
const char *
alpha_dsr_sysname()
{
	struct dsrdb *dsr;
	const char *sysname;

	/*
	 * DSR does not exist on early HWRPB versions.
d737 1
a737 37
	if (hwrpb->rpb_version < HWRPB_DSRDB_MINVERS)
		return (NULL);

	dsr = (struct dsrdb *)(((caddr_t)hwrpb) + hwrpb->rpb_dsrdb_off);
	sysname = (const char *)((caddr_t)dsr + (dsr->dsr_sysname_off +
	    sizeof(u_int64_t)));
	return (sysname);
}

/*
 * Lookup the system specified system variation in the provided table,
 * returning the model string on match.
 */
const char *
alpha_variation_name(variation, avtp)
	u_int64_t variation;
	const struct alpha_variation_table *avtp;
{
	int i;

	for (i = 0; avtp[i].avt_model != NULL; i++)
		if (avtp[i].avt_variation == variation)
			return (avtp[i].avt_model);
	return (NULL);
}

/*
 * Generate a default platform name based for unknown system variations.
 */
const char *
alpha_unknown_sysname()
{
	static char s[128];		/* safe size */

	sprintf(s, "%s family, unknown model variation 0x%lx",
	    platform.family, hwrpb->rpb_variation & SV_ST_MASK);
	return ((const char *)s);
a742 1
	char *s;
d747 2
a748 7
	printf("%s", cpu_model);
	for(s = cpu_model; *s; ++s)
		if(strncasecmp(s, "MHz", 3) == 0)
			goto skipMHz;
	printf(", %ldMHz", hwrpb->rpb_cc_freq / 1000000);
skipMHz:
	printf("\n");
d766 1
a766 1
boot(howto)
d768 1
a771 12
#if defined(MULTIPROCESSOR)
#if 0 /* XXX See below. */
	u_long cpu_id;
#endif
#endif

#if defined(MULTIPROCESSOR)
	/* We must be running on the primary CPU. */
	if (alpha_pal_whami() != hwrpb->rpb_primary_cpu_id)
		panic("cpu_reboot: not on primary CPU!");
#endif

d784 6
d794 2
a795 1
		 * will be out of synch; adjust it now.
d797 5
a801 1
		resettodr();
a819 12
#if defined(MULTIPROCESSOR)
#if 0 /* XXX doesn't work when called from here?! */
	/* Kill off any secondary CPUs. */
	for (cpu_id = 0; cpu_id < hwrpb->rpb_pcs_cnt; cpu_id++) {
		if (cpu_id == hwrpb->rpb_primary_cpu_id ||
		    cpu_info[cpu_id].ci_softc == NULL)
			continue;
		cpu_halt_secondary(cpu_id);
	}
#endif
#endif

a821 1
	cnpollc(1);	/* for proper keyboard command handling */
a822 1
	cnpollc(0);
d826 1
a826 6
	/* Finally, powerdown/halt/reboot the system. */
	if ((howto & RB_POWERDOWN) == RB_POWERDOWN &&
	    platform.powerdown != NULL) {
		(*platform.powerdown)();
		printf("WARNING: powerdown failed!\n");
	}
d847 1
a847 2
	size = ALIGN(sizeof(kcore_seg_t)) + ALIGN(sizeof(cpu_kcore_hdr_t)) +
	    ALIGN(mem_cluster_cnt * sizeof(phys_ram_seg_t));
a854 14
 * cpu_dump_mempagecnt: calculate size of RAM (in pages) to be dumped.
 */
u_long
cpu_dump_mempagecnt()
{
	u_long i, n;

	n = 0;
	for (i = 0; i < mem_cluster_cnt; i++)
		n += atop(mem_clusters[i].size);
	return (n);
}

/*
d861 3
a863 5
	char buf[dbtob(1)];
	kcore_seg_t *segp;
	cpu_kcore_hdr_t *cpuhdrp;
	phys_ram_seg_t *memsegp;
	int i;
d865 1
a865 1
	dump = bdevsw[major(dumpdev)].d_dump;
a866 1
	bzero(buf, sizeof buf);
d868 2
a869 3
	cpuhdrp = (cpu_kcore_hdr_t *)&buf[ALIGN(sizeof(*segp))];
	memsegp = (phys_ram_seg_t *)&buf[ALIGN(sizeof(*segp)) +
	    ALIGN(sizeof(*cpuhdrp))];
d878 1
a878 1
	 * Add the machine-dependent header info.
d880 1
a880 1
	cpuhdrp->lev1map_pa = ALPHA_K0SEG_TO_PHYS((vaddr_t)kernel_lev1map);
d882 2
a883 9
	cpuhdrp->nmemsegs = mem_cluster_cnt;

	/*
	 * Fill in the memory segment descriptors.
	 */
	for (i = 0; i < mem_cluster_cnt; i++) {
		memsegp[i].start = mem_clusters[i].start;
		memsegp[i].size = mem_clusters[i].size & ~PAGE_MASK;
	}
d889 2
a890 2
 * This is called by main to set dumplo and dumpsize.
 * Dumps always skip the first NBPG of disk space
d915 1
a915 1
	dumpblks += ctod(cpu_dump_mempagecnt());
d925 1
a925 1
	dumpsize = cpu_dump_mempagecnt();
d941 2
a942 3
	u_long totalbytesleft, bytes, i, n, memcl;
	u_long maddr;
	int psize;
d962 1
a962 2
		printf("\ndump to dev %u,%u not possible\n", major(dumpdev),
		    minor(dumpdev));
d965 1
a965 2
	printf("\ndumping to dev %u,%u offset %ld\n", major(dumpdev),
	    minor(dumpdev), dumplo);
d979 2
a980 1
	totalbytesleft = ptoa(cpu_dump_mempagecnt());
d984 1
d986 15
a1000 21
	for (memcl = 0; memcl < mem_cluster_cnt; memcl++) {
		maddr = mem_clusters[memcl].start;
		bytes = mem_clusters[memcl].size & ~PAGE_MASK;

		for (i = 0; i < bytes; i += n, totalbytesleft -= n) {

			/* Print out how many MBs we to go. */
			if ((totalbytesleft % (1024*1024)) == 0)
				printf("%ld ", totalbytesleft / (1024 * 1024));

			/* Limit size for next transfer. */
			n = bytes - i;
			if (n > BYTES_PER_DUMP)
				n =  BYTES_PER_DUMP;
	
			error = (*dump)(dumpdev, blkno,
			    (caddr_t)ALPHA_PHYS_TO_K0SEG(maddr), n);
			if (error)
				goto err;
			maddr += n;
			blkno += btodb(n);			/* XXX? */
d1002 1
a1002 2
			/* XXX should look for keystrokes, to cancel. */
		}
d1168 1
d1184 1
a1184 1
	 * call to uvm_grow() is a nop, and the useracc() check
d1196 1
a1196 1
		(void)uvm_grow(p, (u_long)scp);
d1202 1
a1202 1
	if (uvm_useracc((caddr_t)scp, fsize, B_WRITE) == 0) {
d1205 1
a1205 1
			printf("sendsig(%d): uvm_useracc failed on sig %d\n",
d1314 1
d1329 1
a1329 1
	if (uvm_useracc((caddr_t)scp, sizeof (*scp), B_WRITE) == 0 ||
d1394 1
a1394 2
		return (sysctl_rdstring(oldp, oldlenp, newp,
		    root_device));
d1409 1
a1409 2
		return (sysctl_rdstring(oldp, oldlenp, newp,
		    bootinfo.booted_kernel));
d1428 1
d1478 1
a1478 1
			fn();						\
d1481 28
a1508 1
#include <net/netisr_dispatch.h>
d1518 6
a1523 3
	while ((n = atomic_loadlatch_ulong(&ssir, 0)) != 0) {
#define	COUNT_SOFT	uvmexp.softs++

d1527 1
a1527 1
				COUNT_SOFT;				\
a1534 1
#undef COUNT_SOFT
d1536 1
a1536 1
	}
d1543 2
a1544 4
	if (ssir) {
		(void) alpha_pal_swpipl(ALPHA_PSL_IPL_SOFT);
		do_sir();
	}
d1621 1
a1621 1
	while (tvp->tv_usec >= 1000000) {
d1628 1
a1628 1
	    (tvp->tv_usec = lasttime.tv_usec + 1) >= 1000000) {
d1645 2
a1646 10
	/*
	 * XXX Should be written to use RPCC?
	 */

	__asm __volatile(
		"# The 2 corresponds to the insn count\n"
		"1:	subq	%2, %1, %0	\n"
		"	bgt	%0, 1b"
		: "=r" (N)
		: "i" (2), "0" (N));
d1679 1
a1682 4
	extern struct emul emul_native;
	int error;
	extern int osf1_exec_ecoff_hook(struct proc *p,
					struct exec_package *epp);
a1692 1
		error = 0;
d1696 1
a1696 1
		error = ENOEXEC;
d1698 1
a1698 1
	return (error);
a1701 25
int
alpha_pa_access(pa)
	u_long pa;
{
	int i;

	for (i = 0; i < mem_cluster_cnt; i++) {
		if (pa < mem_clusters[i].start)
			continue;
		if ((pa - mem_clusters[i].start) >=
		    (mem_clusters[i].size & ~PAGE_MASK))
			continue;
		return (mem_clusters[i].size & PAGE_MASK);	/* prot */
	}

	/*
	 * Address is not a memory address.  If we're secure, disallow
	 * access.  Otherwise, grant read/write.
	 */
	if (securelevel > 0)
		return (VM_PROT_NONE);
	else
		return (VM_PROT_READ | VM_PROT_WRITE);
}

d1703 1
a1703 1
paddr_t alpha_XXX_dmamap_or;					/* XXX */
d1705 1
a1705 1
paddr_t								/* XXX */
d1707 1
a1707 1
	vaddr_t v;						/* XXX */
a1712 22

char *
dot_conv(x)
	unsigned long x;
{
	int i;
	char *xc;
	static int next;
	static char space[2][20];

	xc = space[next ^= 1] + sizeof space[0];
	*--xc = '\0';
	for (i = 0;; ++i) {
		if (i && (i & 3) == 0)
			*--xc = '.';
		*--xc = "0123456789abcdef"[x & 0xf];
		x >>= 4;
		if (x == 0)
			break;
	}
	return xc;
}
@


1.30.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.30.2.3 2001/04/18 16:00:22 niklas Exp $ */
a120 2
#include <dev/pci/pcivar.h>

d859 1
a859 1
		bufpages = (physmem / (100/BUFCACHEPERCENT));
d986 7
d1029 1
d1124 2
d1786 2
a1787 1
	if (name[0] != CPU_CHIPSET && namelen != 1)
a1818 3
	case CPU_CHIPSET:
		return (alpha_sysctl_chipset(name + 1, namelen - 1, oldp,
		    oldlenp));
@


1.30.2.5
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/* $OpenBSD: machdep.c,v 1.30.2.4 2001/07/04 10:14:21 niklas Exp $ */
/* $NetBSD: machdep.c,v 1.210 2000/06/01 17:12:38 thorpej Exp $ */
a73 1
#include <sys/sched.h>
d79 3
d109 1
d130 20
d155 1
d159 1
a190 2
int	bootdev_debug = 0;	/* patchable, or from DDB */

d210 5
d255 1
a255 1
	const char *bootinfo_msg;
d832 4
d927 1
a927 2
	printf("total memory = %d (%dK)\n", ptoa(totalphysmem),
	    ptoa(totalphysmem) / 1024);
d931 1
a931 2
		printf("WARNING: unused memory = %d (%dK)\n", ptoa(unusedmem),
		    ptoa(unusedmem) / 1024);
d934 1
a934 2
		printf("WARNING: %d (%dK) of memory with unknown purpose\n",
		    ptoa(unknownmem), ptoa(unknownmem) / 1024);
d988 1
a988 1
	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
d991 5
d999 1
a999 2
	printf("avail memory = %d (%dK)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free) / 1024);
d1007 1
a1007 2
	printf("using %ld buffers containing %d bytes (%dK) of memory\n",
	    (long)nbuf, bufpages * NBPG, bufpages * (NBPG / 1024));
d1866 45
d1917 1
a1917 1
		softintr_dispatch();
a1937 4
/* XXXART - grmble */
#define sched_qs qs
#define sched_whichqs whichqs

d1949 3
a1951 3
	sched_whichqs |= (1 << bit);
	p->p_forw = (struct proc *)&sched_qs[bit];
	p->p_back = sched_qs[bit].ph_rlink;
d1953 1
a1953 1
	sched_qs[bit].ph_rlink = p;
d1968 1
a1968 1
	if ((sched_whichqs & (1 << bit)) == 0)
d1975 2
a1976 2
	if ((struct proc *)&sched_qs[bit] == sched_qs[bit].ph_link)
		sched_whichqs &= ~(1 << bit);
@


1.30.2.6
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d89 1
a89 1
#include <uvm/uvm_extern.h>
d915 1
a915 1
		    NULL, UVM_UNKNOWN_OFFSET, 0,
@


1.30.2.7
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.30.2.6 2001/11/13 21:00:48 niklas Exp $ */
d152 3
a154 3
struct vm_map *exec_map = NULL;
struct vm_map *mb_map = NULL;
struct vm_map *phys_map = NULL;
d917 1
a917 1
				UVM_ADV_NORMAL, 0)))
d1123 3
d1127 1
@


1.30.2.8
log
@Merge in trunk
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d72 1
a145 5

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 10
#endif

a150 1
int	bufcachepercent = BUFCACHEPERCENT;
d153 1
d820 3
d829 1
a829 1
		bufpages = (physmem / (100/bufcachepercent));
d863 1
a863 1
 * This is called by the pckbc driver if no pckbd is configured.
a944 1
		pmap_update(pmap_kernel());
d959 3
d1984 3
d1989 2
a1990 1
	extern int osf1_exec_ecoff_hook(struct proc *, struct exec_package *);
d1995 1
a1995 1
		error = osf1_exec_ecoff_hook(p, epp);
@


1.30.2.9
log
@Merge in -current from about a week ago
@
text
@d128 8
a135 8
int	cpu_dump(void);
int	cpu_dumpsize(void);
u_long	cpu_dump_mempagecnt(void);
void	dumpsys(void);
caddr_t allocsys(caddr_t);
void	identifycpu(void);
void	regdump(struct trapframe *framep);
void	printregs(struct reg *);
d1204 1
a1204 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d1300 1
a1300 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d1954 2
a1955 2
void	cpu_exec_ecoff_setregs(struct proc *, struct exec_package *,
	    u_long, register_t *);
@


1.30.2.10
log
@Sync the SMP branch with 3.3
@
text
@a92 3
#ifndef NO_IEEE
#include <machine/fpu.h>
#endif
d96 6
a115 3
#ifndef NO_IEEE
#include <machine/ieeefp.h>
#endif
d126 2
a159 8
#ifdef APERTURE
#ifdef INSECURE
int allowaperture = 1;
#else
int allowaperture = 0;
#endif
#endif

a203 3
#ifndef NO_IEEE
int	alpha_fp_sync_complete = 0;	/* fp fixup if sync even without /s */
#endif
d424 1
d426 3
d808 9
d896 4
a899 4
	printf("total memory = %ld (%ldK)\n", (long)ptoa(totalphysmem),
	    (long)ptoa(totalphysmem) / 1024);
	printf("(%ld reserved for PROM, ", (long)ptoa(resvmem));
	printf("%ld used by OpenBSD)\n", (long)ptoa(physmem));
d901 2
a902 2
		printf("WARNING: unused memory = %ld (%ldK)\n",
		    (long)ptoa(unusedmem), (long)ptoa(unusedmem) / 1024);
d905 2
a906 2
		printf("WARNING: %ld (%ldK) of memory with unknown purpose\n",
		    (long)ptoa(unknownmem), (long)ptoa(unknownmem) / 1024);
d964 2
a965 2
	printf("avail memory = %ld (%ldK)\n", (long)ptoa(uvmexp.free),
	    (long)ptoa(uvmexp.free) / 1024);
d973 2
a974 2
	printf("using %ld buffers containing %ld bytes (%ldK) of memory\n",
	    (long)nbuf, (long)bufpages * NBPG, (long)bufpages * (NBPG / 1024));
d1530 1
d1597 6
a1602 2
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 1);
d1604 1
a1604 1
	memcpy((struct fpreg *)ksc.sc_fpregs, &p->p_addr->u_pcb.pcb_fp,
d1606 4
a1609 7
#ifndef NO_IEEE
	ksc.sc_fp_control = alpha_read_fp_c(p);
#else
	ksc.sc_fp_control = 0;
#endif
	memset(ksc.sc_reserved, 0, sizeof ksc.sc_reserved);	/* XXX */
	memset(ksc.sc_xxx, 0, sizeof ksc.sc_xxx);		/* XXX */
d1621 1
a1621 2
	} else
		sip = NULL;
d1636 2
a1637 1
	frame->tf_regs[FRAME_PC] = p->p_sigcode;
d1639 2
a1640 1
	frame->tf_regs[FRAME_A1] = (u_int64_t)sip;
d1662 1
a1662 1
 * psl to gain improper privileges or to cause
d1675 1
a1675 2
	struct sigcontext ksc;
	int error;
d1677 1
d1683 3
d1690 3
a1692 2
	if ((error = copyin(SCARG(uap, sigcntxp), &ksc, sizeof(ksc))) != 0)
		return (error);
d1713 3
a1715 3
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 0);
	memcpy(&p->p_addr->u_pcb.pcb_fp, (struct fpreg *)ksc.sc_fpregs,
d1717 1
a1717 4
#ifndef NO_IEEE
	p->p_addr->u_pcb.pcb_fp.fpr_cr = ksc.sc_fpcr;
	p->p_md.md_flags = ksc.sc_fp_control & MDP_FP_C;
#endif
d1772 1
a1772 1
	
a1775 17

#ifndef NO_IEEE
	case CPU_FP_SYNC_COMPLETE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &alpha_fp_sync_complete));
#endif
	case CPU_ALLOWAPERTURE:
#ifdef APERTURE
		if (securelevel > 0)
                        return (sysctl_rdint(oldp, oldlenp, newp,
				 allowaperture));
                else
                        return (sysctl_int(oldp, oldlenp, newp, newlen,
                            &allowaperture));
#else
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
#endif
d1812 2
d1823 2
a1824 30
#ifndef NO_IEEE
	if (__predict_true((p->p_md.md_flags & IEEE_INHERIT) == 0)) {
		p->p_md.md_flags &= ~MDP_FP_C;
		p->p_addr->u_pcb.pcb_fp.fpr_cr = FPCR_DYN(FP_RN);
	}
#endif
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 0);
}

/*
 * Release the FPU.
 */
void
fpusave_cpu(struct cpu_info *ci, int save)
{
	struct proc *p;
#if defined(MULTIPROCESSOR)
	int s;
#endif

	KDASSERT(ci == curcpu());

#if defined(MULTIPROCESSOR)
	atomic_setbits_ulong(&ci->ci_flags, CPUF_FPUSAVE);
#endif

	p = ci->ci_fpcurproc;
	if (p == NULL)
		goto out;
d1826 1
a1826 59
	if (save) {
		alpha_pal_wrfen(1);
		savefpstate(&p->p_addr->u_pcb.pcb_fp);
	}

	alpha_pal_wrfen(0);

	p->p_addr->u_pcb.pcb_fpcpu = NULL;
	ci->ci_fpcurproc = NULL;

out:
#if defined(MULTIPROCESSOR)
	atomic_clearbits_ulong(&ci->ci_flags, CPUF_FPUSAVE);
#endif
	return;
}

/*
 * Synchronize FP state for this process.
 */
void
fpusave_proc(struct proc *p, int save)
{
	struct cpu_info *ci = curcpu();
	struct cpu_info *oci;
#if defined(MULTIPROCESSOR)
	u_long ipi = save ? ALPHA_IPI_SYNCH_FPU : ALPHA_IPI_DISCARD_FPU;
	int s, spincount;
#endif

	KDASSERT(p->p_addr != NULL);
	KDASSERT(p->p_flag & P_INMEM);

	oci = p->p_addr->u_pcb.pcb_fpcpu;
	if (oci == NULL) {
		return;
	}

#if defined(MULTIPROCESSOR)
	if (oci == ci) {
		KASSERT(ci->ci_fpcurproc == p);
		fpusave_cpu(ci, save);
		return;
	}

	KASSERT(oci->ci_fpcurproc == p);
	alpha_send_ipi(oci->ci_cpuid, ipi);

	spincount = 0;
	while (p->p_addr->u_pcb.pcb_fpcpu != NULL) {
		spincount++;
		delay(1000);    /* XXX */
		if (spincount > 10000)
			panic("fpsave ipi didn't");
	}
#else
	KASSERT(ci->ci_fpcurproc == p);
	fpusave_cpu(ci, save);
#endif /* MULTIPROCESSOR */
@


1.30.2.11
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.30.2.10 2003/03/27 23:18:06 niklas Exp $ */
d388 1
a388 1
	strlcpy(cpu_model, platform.model, sizeof cpu_model);
d1041 1
a1041 1
	snprintf(s, sizeof s, "%s family, unknown model variation 0x%lx",
@


1.30.2.12
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.30.2.11 2003/05/13 19:41:02 ho Exp $ */
a947 1
	minaddr = vm_map_min(kernel_map);
d949 1
a949 1
	    16 * NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);
d955 1
a955 1
	    VM_PHYS_SIZE, 0, FALSE, NULL);
@


1.30.2.13
log
@Merge of -current from two weeks ago into the SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d1560 18
d1615 1
a1615 2
		if (copyout((caddr_t)&ksi, (caddr_t)sip, fsize - kscsize) != 0)
			goto trash;
d1622 1
a1622 19
	if (copyout((caddr_t)&ksc, (caddr_t)scp, kscsize) != 0) {
trash:
#ifdef DEBUG
		if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
			printf("sendsig(%d): copyout failed on sig %d\n",
			    p->p_pid, sig);
#endif
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		return;
	}
d1893 1
d2136 22
@


1.30.2.14
log
@Merge with the trunk
@
text
@d1096 1
a1096 3
		/* (Unless the user explicitly asked for reboot.) */
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
@


1.30.2.15
log
@sync to head
@
text
@d194 3
d763 1
a763 1
	for (ncpus = 0, i = 0; i < hwrpb->rpb_pcs_cnt; i++) {
@


1.29
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 1999/05/24 23:08:55 jason Exp $	*/
d103 1
a103 1
#include <netinet6/ip6.h>
@


1.28
log
@Only do basic work in the ethernet interrupt context, and queue packets to
be bridged.  Do the real work in a scheduled netisr.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27 1999/05/22 21:22:17 weingart Exp $	*/
d98 9
d1486 1
a1486 1
	DONETISR(NETISR_IPV6, ipv6intr());
@


1.27
log
@Add new vm_swap code for dynamic swap.  From netbsd, munged some by me, and
others.   syscall commit pending.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.26 1999/03/24 22:56:13 alex Exp $	*/
d99 1
d1496 3
@


1.26
log
@Call vm_set_page_size() during initialization (supresses "MD code did
not set page size" warning at boot time).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.25 1999/01/07 23:15:51 deraadt Exp $	*/
a447 1
	valloc(swapmap, struct map, nswapmap = maxproc * 2);
@


1.25
log
@global decl for *intr() routines, plus add INET6
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 1997/07/31 03:07:55 niklas Exp $	*/
d346 5
@


1.24
log
@grammar
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.23 1997/07/28 19:32:41 deraadt Exp $	*/
a97 18
#ifdef NS
#include <netns/ns_var.h>
#endif
#ifdef ISO
#include <netiso/iso.h>
#include <netiso/clnp.h>
#endif
#ifdef CCITT
#include <netccitt/x25.h>
#include <netccitt/pk.h>
#include <netccitt/pk_extern.h>
#endif
#ifdef NETATALK
#include <netatalk/at_extern.h>
#endif
#ifdef NATM
#include <netnatm/natm.h>
#endif
a98 4
#if NPPP > 0
#include <net/ppp_defs.h>
#include <net/if_ppp.h>
#endif
d1471 3
d1489 1
a1489 1
#if NPPP > 1
@


1.23
log
@for netatalk, pull in netatalk/at_extern.h
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.22 1997/07/23 06:23:58 denny Exp $	*/
d219 1
a219 1
	 * get address of the restart block, while we the bootstrap
@


1.22
log
@Add AppleTalk netisr.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21 1997/07/08 10:55:54 niklas Exp $	*/
d109 3
@


1.21
log
@Recognize that a symbol table may exist, move up proc0paddr if so.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.20 1997/07/06 16:25:30 niklas Exp $	*/
d1489 3
@


1.20
log
@If -b specified as bootflag (-d was taken) enter DDB.  If using a PC keyboard
this does not yet work as the keyboard is not enough setup to work even in
polled mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.19 1997/05/28 22:56:57 niklas Exp $	*/
a122 1
void	alpha_init __P((u_long, u_long));
d191 1
a191 1
alpha_init(pfn, ptb)
d194 1
d197 1
d203 3
d366 1
a366 1
	v = (caddr_t)alpha_round_page(_end);
@


1.19
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.18 1997/04/14 17:49:58 michaels Exp $	*/
d83 7
d562 5
a614 1

d617 5
@


1.18
log
@typo for us.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.17 1997/02/03 15:05:02 deraadt Exp $	*/
d144 1
a144 1
int	physmem;		/* physical memory used by OpenBSD + some rsvd */
d326 2
a327 1
				lastusablepage = firstusablepage + pgcnt(i) - 1;
d389 2
a390 2
		printf("not present in this kernel.  Build a kernel with \"options %s\"\n",
		    cpu_fn_switch->option);
d400 2
a401 1
		strncpy(cpu_model, cpu_fn_switch->family, sizeof cpu_model - 1);
d518 2
a519 1
	proc0.p_md.md_tf = (struct trapframe *)proc0paddr->u_pcb.pcb_hw.apcb_ksp;
d1165 1
@


1.17
log
@More siginfo implementations (alpha and mips might even work)
move "siginfo_t *" to 2nd arg of signal handler as 1003.1b requires.
I really wish I had 1003.1b documentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.16 1997/02/03 13:09:14 deraadt Exp $	*/
d378 1
a378 1
		printf("NetBSD does not currently support system type %d\n",
@


1.16
log
@initial cut at siginfo
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.15 1997/01/24 19:56:37 niklas Exp $	*/
d1148 1
a1148 1
	int oonstack, fsize, rndfsize;
d1151 1
d1157 5
d1236 6
d1245 1
a1245 1
	(void) copyout((caddr_t)&ksc, (caddr_t)scp, fsize);
d1258 2
a1259 1
	frame->tf_regs[FRAME_A1] = code;
@


1.15
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.14 1997/01/17 05:53:37 kstailey Exp $	*/
d1137 1
a1137 1
sendsig(catcher, sig, mask, code)
d1141 2
@


1.14
log
@don't update battery backed up clock if system time is wrong from begin
in ddb.
@
text
@d1 2
a2 2
/*	$OpenBSD: machdep.c,v 1.13 1996/12/08 00:20:18 niklas Exp $	*/
/*	$NetBSD: machdep.c,v 1.52 1996/11/06 20:19:19 cgd Exp $	*/
d81 1
a81 19

#ifdef DEC_3000_500
#include <alpha/alpha/dec_3000_500.h>
#endif
#ifdef DEC_3000_300
#include <alpha/alpha/dec_3000_300.h>
#endif
#ifdef DEC_2100_A50
#include <alpha/alpha/dec_2100_a50.h>
#endif
#ifdef DEC_KN20AA
#include <alpha/alpha/dec_kn20aa.h>
#endif
#ifdef DEC_AXPPCI_33
#include <alpha/alpha/dec_axppci_33.h>
#endif
#ifdef DEC_21000
#include <alpha/alpha/dec_21000.h>
#endif
d98 8
d116 9
a124 7
void dumpsys __P((void));
int cpu_dumpsize __P((void));
int cpu_dump __P((void));
void printregs __P((struct reg *));
void regdump __P((struct trapframe *framep));
void netintr __P((void));
void do_sir __P((void));
d162 1
a162 21
char	*model_names[] = {
	"UNKNOWN (0)",
	"Alpha Demonstration Unit",
	"DEC 4000 (\"Cobra\")",
	"DEC 7000 (\"Ruby\")",
	"DEC 3000/500 (\"Flamingo\") family",
	"UNKNOWN (5)",
	"DEC 2000/300 (\"Jensen\")",
	"DEC 3000/300 (\"Pelican\")",
	"UNKNOWN (8)",
	"DEC 2100/A500 (\"Sable\")",
	"AXPvme 64",
	"AXPpci 33 (\"NoName\")",
	"DEC 21000 (\"TurboLaser\")",
	"DEC 2100/A50 (\"Avanti\") family",
	"Mustang",
	"DEC KN20AA",
	"UNKNOWN (16)",
	"DEC 1000 (\"Mikasa\")",
};
int	nmodel_names = sizeof model_names/sizeof model_names[0];
a171 4
/* Interrupt vectors (in locore) */
extern int XentInt __P((void)), XentArith __P((void)), XentMM __P((void)),
    XentIF __P((void)), XentUna __P((void)), XentSys __P((void));

a174 6
/* various CPU-specific functions. */
char		*(*cpu_modelname) __P((void));
void		(*cpu_consinit) __P((void));
void		(*cpu_device_register) __P((struct device *dev, void *aux));
char		*cpu_iobus;

d176 1
d184 1
a184 4
void	identifycpu __P((void));
int	alpha_init __P((u_long, u_long));

int
d366 28
a393 18
	switch (cputype) {
#ifdef DEC_3000_500				/* and 400, [6-9]00 */
	case ST_DEC_3000_500:
		cpu_modelname = dec_3000_500_modelname;
		cpu_consinit = dec_3000_500_consinit;
		cpu_device_register = dec_3000_500_device_register;
		cpu_iobus = "tcasic";
		break;
#endif

#ifdef DEC_3000_300
	case ST_DEC_3000_300:
		cpu_modelname = dec_3000_300_modelname;
		cpu_consinit = dec_3000_300_consinit;
		cpu_device_register = dec_3000_300_device_register;
		cpu_iobus = "tcasic";
		break;
#endif
d395 6
a400 53
#ifdef DEC_2100_A50
	case ST_DEC_2100_A50:
		cpu_modelname = dec_2100_a50_modelname;
		cpu_consinit = dec_2100_a50_consinit;
		cpu_device_register = dec_2100_a50_device_register;
		cpu_iobus = "apecs";
		break;
#endif

#ifdef DEC_KN20AA
	case ST_DEC_KN20AA:
		cpu_modelname = dec_kn20aa_modelname;
		cpu_consinit = dec_kn20aa_consinit;
		cpu_device_register = dec_kn20aa_device_register;
		cpu_iobus = "cia";
		break;
#endif

#ifdef DEC_AXPPCI_33
	case ST_DEC_AXPPCI_33:
		cpu_modelname = dec_axppci_33_modelname;
		cpu_consinit = dec_axppci_33_consinit;
		cpu_device_register = dec_axppci_33_device_register;
		cpu_iobus = "lca";
		break;
#endif

#ifdef DEC_2000_300
	case ST_DEC_2000_300:
		cpu_modelname = dec_2000_300_modelname;
		cpu_consinit = dec_2000_300_consinit;
		cpu_device_register = dec_2000_300_device_register;
		cpu_iobus = "ibus";
	XXX DEC 2000/300 NOT SUPPORTED
		break;
#endif

#ifdef DEC_21000
	case ST_DEC_21000:
		cpu_modelname = dec_21000_modelname;
		cpu_consinit = dec_21000_consinit;
		cpu_device_register = dec_21000_device_register;
		cpu_iobus = "tlsb";
	XXX DEC 21000 NOT SUPPORTED
		break;
#endif

	default:
		if (cputype > nmodel_names)
			panic("Unknown system type %d", cputype);
		else
			panic("Support for %s system type not in kernel.",
			    model_names[cputype]);
a401 5

	if ((*cpu_modelname)() != NULL)
		strncpy(cpu_model, (*cpu_modelname)(), sizeof cpu_model - 1);
	else
		strncpy(cpu_model, model_names[cputype], sizeof cpu_model - 1);
d524 1
d530 5
a594 2

	return (0);
d601 1
a601 1
	(*cpu_consinit)();
d720 1
a720 1
	hwrbp_restart_setup();
d1374 3
d1394 2
d1397 1
a1397 1
	extern struct proc *fpcurproc;
d1473 15
d1489 5
a1493 10
	if (ssir & SIR_NET) {
		siroff(SIR_NET);
		cnt.v_soft++;
		netintr();
	}
	if (ssir & SIR_CLOCK) {
		siroff(SIR_CLOCK);
		cnt.v_soft++;
		softclock();
	}
d1500 2
a1501 4
	if (ssir) {
		splsoft();
		do_sir();
	}
d1607 3
@


1.13
log
@Merge to NetBSD 961107, i.e. mostly new bus.h
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.12 1996/11/23 23:19:23 kstailey Exp $	*/
d855 2
a856 1
		 * will be out of synch; adjust it now.
d858 5
a862 1
		resettodr();
@


1.12
log
@remrq -> remrunqueue
@
text
@d1 2
a2 2
/*	$OpenBSD: machdep.c,v 1.11 1996/10/30 22:38:14 niklas Exp $	*/
/*	$NetBSD: machdep.c,v 1.49 1996/10/18 20:35:23 cgd Exp $	*/
d1569 4
a1572 4
 * into queues, Remrq removes them from queues.  The running process is on
 * no queue, other processes are on a queue related to p->p_priority, divided
 * by 4 actually to shrink the 0-127 range of priorities into the 32 available
 * queues.
d1600 1
a1600 1
 * Remrunqueue(p)
d1715 12
@


1.11
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.49 1996/10/18 20:35:23 cgd Exp $	*/
d1600 1
a1600 1
 * Remrq(p)
d1605 1
a1605 1
remrq(p)
d1612 1
a1612 1
		panic("remrq");
@


1.10
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: machdep.c,v 1.19.4.5 1996/06/15 03:56:33 cgd Exp $	*/
/*	$NetBSD: machdep.c,v 1.19.4.5 1996/06/15 03:56:33 cgd Exp $	*/
d55 3
d71 1
d76 1
d102 19
a120 1
#include "ether.h"
d127 6
d152 1
a152 1
int	physmem;		/* physical memory used by NetBSD + some rsvd */
d201 2
a202 1
extern int XentInt(), XentArith(), XentMM(), XentIF(), XentUna(), XentSys();
d216 7
a222 1
char		root_device[17];
d240 3
a242 3
	pal_wrfen(0);
	TBIA();
	IMB();
d248 2
a249 1
	hwrpb = (struct rpb *) phystok0seg(*(struct rpb **)HWRPB_ADDR);
d266 12
a277 6
	pal_wrent(XentInt, 0);
	pal_wrent(XentArith, 1);
	pal_wrent(XentMM, 2);
	pal_wrent(XentIF, 3);
	pal_wrent(XentUna, 4);
	pal_wrent(XentSys, 5);
d299 1
a299 1
		printf("WARNING: weird number (%d) of mem clusters\n", cnt);
d305 1
a305 1
		printf("WARNING: %d mem clusters, but weird config\n", cnt);
d501 2
a502 1
		le_iomem = (caddr_t)phystok0seg(ctob(lastusablepage + 1));
d510 2
a511 1
	msgbufp = (struct msgbuf *)phystok0seg(ctob(lastusablepage + 1));
d578 6
a583 1
	pmap_bootstrap((vm_offset_t)v, phystok0seg(ptb << PGSHIFT));
d590 1
a590 1
	    (struct pcb *)k0segtophys(&proc0paddr->u_pcb);
d596 1
a596 1
	proc0paddr->u_pcb.pcb_ksp =
d598 5
a602 1
	proc0.p_md.md_tf = (struct trapframe *)proc0paddr->u_pcb.pcb_ksp;
d628 15
a642 3
		case 'n': /* askname */
		case 'N':
			boothowto |= RB_ASKNAME;
d651 5
a686 1
	register caddr_t v;
d690 1
a690 1
#ifdef DEBUG
d702 1
a702 1
	printf("real mem = %d (%d reserved for PROM, %d used by NetBSD)\n",
d770 1
a770 1
#ifdef DEBUG
d793 6
d801 1
d808 1
a808 1
	printf("%s, %dMHz\n", cpu_model,
d810 1
a810 1
	printf("%d byte page size, %d processor%s.\n",
d827 1
a827 1
boot(howto)
d829 1
d839 4
d845 6
d864 5
a868 2
	if ((howto & (RB_DUMP | RB_HALT)) == RB_DUMP) {
		savectx(&dumppcb, 0);
a869 1
	}
d896 49
d954 1
a954 1
	int nblks;	/* size of dump area */
d958 1
a958 1
		return;
d963 1
a963 1
		return;
d966 13
a978 1
		return;
d980 1
a980 1
	/* XXX XXX XXX STARTING MEMORY LOCATION */
d982 1
d984 3
a986 9
	/* Always skip the first CLBYTES, in case there is a label there. */
	if (dumplo < ctod(1))
		dumplo = ctod(1);

	/* Put dump at end of partition, and make it fit. */
	if (dumpsize > dtoc(nblks - dumplo))
		dumpsize = dtoc(nblks - dumplo);
	if (dumplo < nblks - ctod(dumpsize))
		dumplo = nblks - ctod(dumpsize);
d990 1
a990 3
 * Doadump comes here after turning off memory management and
 * getting on the dump stack, either when called above, or by
 * the auto-restart code.
d992 2
d997 8
d1006 1
a1006 1
	msgbufmapped = 0;
d1009 6
a1014 1
	if (dumpsize == 0) {
d1016 3
a1018 2
		if (dumpsize == 0)
			return;
d1020 1
a1020 1
	printf("\ndumping to dev %x, offset %d\n", dumpdev, dumplo);
d1022 1
d1024 38
a1061 1
	switch ((*bdevsw[major(dumpdev)].d_dump)(dumpdev)) {
d1083 4
d1088 1
a1088 1
		printf("succeeded\n");
d1117 3
a1119 3
	regp->r_regs[R_A0] = framep->tf_a0;
	regp->r_regs[R_A1] = framep->tf_a1;
	regp->r_regs[R_A2] = framep->tf_a2;
d1130 2
a1131 2
	regp->r_regs[R_GP] = framep->tf_gp;
	regp->r_regs[R_SP] = framep->tf_regs[FRAME_SP];
d1157 3
a1159 3
	framep->tf_a0 = regp->r_regs[R_A0];
	framep->tf_a1 = regp->r_regs[R_A1];
	framep->tf_a2 = regp->r_regs[R_A2];
d1170 2
a1171 2
	framep->tf_gp = regp->r_regs[R_GP];
	framep->tf_regs[FRAME_SP] = regp->r_regs[R_SP];
d1193 2
d1240 1
a1240 2
		scp = (struct sigcontext *)(frame->tf_regs[FRAME_SP] -
		    rndfsize);
d1245 1
a1245 1
		printf("sendsig(%d): sig %d ssp %lx usp %lx\n", p->p_pid,
d1272 2
a1273 2
	ksc.sc_pc = frame->tf_pc;
	ksc.sc_ps = frame->tf_ps;
d1278 1
d1282 1
a1282 1
		pal_wrfen(1);
d1284 1
a1284 1
		pal_wrfen(0);
d1307 1
a1307 1
		printf("sendsig(%d): sig %d scp %lx code %lx\n", p->p_pid, sig,
d1314 5
a1318 5
	frame->tf_pc = (u_int64_t)PS_STRINGS - (esigcode - sigcode);
	frame->tf_regs[FRAME_SP] = (u_int64_t)scp;
	frame->tf_a0 = sig;
	frame->tf_a1 = code;
	frame->tf_a2 = (u_int64_t)scp;
d1320 1
d1325 1
a1325 1
		    frame->tf_pc, frame->tf_regs[FRAME_A3]);
d1358 1
a1358 1
	    printf("sigreturn: pid %d, scp %lx\n", p->p_pid, scp);
d1383 3
a1385 2
	p->p_md.md_tf->tf_pc = ksc.sc_pc;
	p->p_md.md_tf->tf_ps = (ksc.sc_ps | PSL_USERSET) & ~PSL_USERCLR;
d1388 1
d1407 1
d1435 12
d1468 9
a1476 1
	for (i = 0; i < FRAME_NSAVEREGS; i++)
a1477 4
	tfp->tf_gp = 0xbabefacedeadbeef;
	tfp->tf_a0 = 0xbabefacedeadbeef;
	tfp->tf_a1 = 0xbabefacedeadbeef;
	tfp->tf_a2 = 0xbabefacedeadbeef;
d1479 1
a1479 5
	bzero(tfp->tf_regs, FRAME_NSAVEREGS * sizeof tfp->tf_regs[0]);
	tfp->tf_gp = 0;
	tfp->tf_a0 = 0;
	tfp->tf_a1 = 0;
	tfp->tf_a2 = 0;
d1484 7
a1490 3
	tfp->tf_regs[FRAME_SP] = stack;	/* restored to usp in trap return */
	tfp->tf_ps = PSL_USERSET;
	tfp->tf_pc = pack->ep_entry & ~3;
d1492 1
a1492 1
	p->p_md.md_flags & ~MDP_FPUSED;
d1502 13
d1516 2
a1517 10
#if NETHER > 0
	if (netisr & (1 << NETISR_ARP)) {
		netisr &= ~(1 << NETISR_ARP);
		arpintr();
	}
#endif
	if (netisr & (1 << NETISR_IP)) {
		netisr &= ~(1 << NETISR_IP);
		ipintr();
	}
d1520 1
a1520 4
	if (netisr & (1 << NETISR_NS)) {
		netisr &= ~(1 << NETISR_NS);
		nsintr();
	}
d1523 1
a1523 4
	if (netisr & (1 << NETISR_ISO)) {
		netisr &= ~(1 << NETISR_ISO);
		clnlintr();
	}
d1526 4
a1529 4
	if (netisr & (1 << NETISR_CCITT)) {
		netisr &= ~(1 << NETISR_CCITT);
		ccittintr();
	}
d1531 2
a1532 5
#ifdef PPP
	if (netisr & (1 << NETISR_PPP)) {
		netisr &= ~(1 << NETISR_PPP);
		pppintr();
	}
d1534 2
d1563 1
a1563 1
	return (pal_swpipl(PSL_IPL_0));
d1656 1
a1656 1
int
d1658 1
a1658 1
	int n;
d1677 1
a1677 1
	p->p_md.md_tf->tf_gp = execp->a.gp_value;
d1705 1
a1705 1
	case ECOFF_MAGIC_NETBSD_ALPHA:
a1714 21

vm_offset_t
vtophys(vaddr)
	vm_offset_t vaddr;
{
	vm_offset_t paddr;

	if (vaddr < K0SEG_BEGIN) {
		printf("vtophys: invalid vaddr 0x%lx", vaddr);
		paddr = vaddr;
	} else if (vaddr < K0SEG_END)
		paddr = k0segtophys(vaddr);
	else
		paddr = vatopa(vaddr);

#if 0
	printf("vtophys(0x%lx) -> %lx\n", vaddr, paddr);
#endif

	return (paddr);
}
@


1.9
log
@handle RB_CONFIG
@
text
@d1 1
@


1.8
log
@merge in rev 1.6; emul_native
@
text
@d714 7
@


1.7
log
@sync to 0616, retaining local diffs
@
text
@d1463 1
a1463 1
	extern struct emul emul_netbsd;
d1476 1
a1476 1
		epp->ep_emul = &emul_netbsd;
@


1.6
log
@native emul is now called "native"
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.14 1996/01/04 22:21:33 jtc Exp $	*/
d4 1
a4 1
 * Copyright (c) 1994, 1995 Carnegie-Mellon University.
d38 1
d98 1
a98 1
#include "le.h"			/* XXX for le_iomem creation */
d139 1
a139 1
char	*cpu_model;
d178 2
a179 2
void		(*cpu_consinit) __P((char *));
dev_t		(*cpu_bootdev) __P((char *));
d182 4
a185 1
char *boot_file, *boot_flags, *boot_console, *boot_dev;
d188 1
a188 1
alpha_init(pfn, ptb, argc, argv, envp)
a190 2
	u_long argc;
	char *argv[], *envp[];
d367 1
a367 1
		cpu_bootdev = dec_3000_500_bootdev;
d376 1
a376 1
		cpu_bootdev = dec_3000_300_bootdev;
d385 1
a385 1
		cpu_bootdev = dec_2100_a50_bootdev;
d394 1
a394 1
		cpu_bootdev = dec_kn20aa_bootdev;
d403 1
a403 1
		cpu_bootdev = dec_axppci_33_bootdev;
d412 1
a412 1
		cpu_bootdev = dec_2000_300_bootdev;
d422 1
a422 1
		cpu_bootdev = dec_21000_bootdev;
d424 1
d436 5
a440 3
	cpu_model = (*cpu_modelname)();
	if (cpu_model == NULL)
		cpu_model = model_names[cputype];
d442 1
a442 1
#if NLE > 0
d447 6
d459 1
a459 1
#endif /* NLE */
d504 1
a504 2
	 * We allocate the BSD standard of 10% of memory for the first
	 * 2 Meg, and 5% of remaining memory for buffer space.  Insure a
d509 1
a509 2
		bufpages = (btoc(2 * 1024 * 1024) + physmem) /
		    (20 * CLSIZE);
d550 1
a550 25
	 * figure out what arguments we have
	 */
	switch (argc) {
	default:
		printf("weird number of arguments from boot: %d\n", argc);
		if (argc < 1)
			break;
		/* FALLTHRU */
	case 4:
		boot_dev = argv[3];
		/* FALLTHRU */
	case 3:
		boot_console = argv[2];
		/* FALLTHRU */
	case 2:
		boot_flags = argv[1];
		/* FALLTHRU */
	case 1:
		boot_file = argv[0];
		/* FALLTHRU */
	}

	/*
	 * Look at arguments and compute bootdev.
	 * XXX NOT HERE.
d552 1
d554 1
a554 4
	{							/* XXX */
		extern dev_t bootdev;				/* XXX */
		bootdev = (*cpu_bootdev)(boot_dev);
	}							/* XXX */
a556 3
	/*
	 * Look at arguments passed to us and compute boothowto.
	 */
a557 3
#ifdef GENERIC
	boothowto |= RB_ASKNAME;
#endif
d562 5
d569 1
a569 1
		case 'A': /* DEC's notion of autoboot */
d573 3
a575 2
		case 'd': /* use compiled in default root */
			boothowto |= RB_DFLTROOT;
d578 1
d580 1
d583 1
a583 7

		case 'n': /* ask for names */
			boothowto |= RB_ASKNAME;
			break;

		case 'N': /* don't ask for names */
			boothowto &= ~RB_ASKNAME;
d603 1
d607 1
a607 1
	(*cpu_consinit)(boot_console);
d611 1
d741 1
a754 6
		extern struct proc proc0;

		/* protect against curproc->p_stats.foo refs in sync   XXX */
		if (curproc == NULL)
			curproc = &proc0;

d1215 4
d1302 1
a1302 1
		netisr &= ~(1 << NETISR_CCITT);
d1423 13
d1438 1
a1438 1
cpu_exec_ecoff_setregs(p, pack, stack, retval)
d1440 1
a1440 1
	struct exec_package *pack;
d1444 1
a1444 3
	struct ecoff_aouthdr *eap;

	setregs(p, pack, stack, retval);
d1446 2
a1447 3
	eap = (struct ecoff_aouthdr *)
	    ((caddr_t)pack->ep_hdr + sizeof(struct ecoff_filehdr));
	p->p_md.md_tf->tf_gp = eap->ea_gp_value;
d1458 1
a1458 1
cpu_exec_ecoff_hook(p, epp, eap)
a1460 1
	struct ecoff_aouthdr *eap;
d1462 2
a1463 2
	struct ecoff_filehdr *efp = epp->ep_hdr;
	extern struct emul emul_native;
d1468 1
a1468 1
	switch (efp->ef_magic) {
d1475 2
a1476 2
	case ECOFF_MAGIC_NATIVE_ALPHA:
		epp->ep_emul = &emul_native;
@


1.5
log
@fix reboot panic.
@
text
@d1474 1
a1474 1
	extern struct emul emul_netbsd;
d1486 2
a1487 2
	case ECOFF_MAGIC_NETBSD_ALPHA:
		epp->ep_emul = &emul_netbsd;
@


1.4
log
@ss_sp is correct, ss_base is not. noticed by agc@@sde.uts.amdahl.com; netbsd pr#1784
@
text
@d773 6
@


1.3
log
@from netbsd:
IO bus for 3000-family boxes is now "tcasic" when then attaches tc.
esp_iomem is unnecessary, has been unnecessary for a while,
apparently.
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.13 1995/12/20 00:19:49 cgd Exp $	*/
d1042 1
a1042 1
		scp = (struct sigcontext *)(psp->ps_sigstk.ss_base +
@


1.2
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.12 1995/11/23 02:34:15 cgd Exp $	*/
a97 1
#include "esp.h"		/* XXX for esp_iomem creation */
a167 1
caddr_t		esp_iomem;		/* XXX iomem for SCSI DMA */
d366 1
a366 1
		cpu_iobus = "tc";
d375 1
a375 1
		cpu_iobus = "tc";
a448 13
#if NESP > 0
	/*
	 * Ditto for the scsi chip. There is probably a way to make esp.c
	 * do dma without these buffers, but it would require major
	 * re-engineering of the esp driver.
	 * They must be 8K in size and page aligned.
	 */
	if (cputype == ST_DEC_3000_500 ||
	    cputype == ST_DEC_3000_300) {	/* XXX possibly others? */
		lastusablepage -= btoc(NESP * 8192);
		esp_iomem = (caddr_t)phystok0seg(ctob(lastusablepage + 1));
	}
#endif /* NESP */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.11 1995/10/07 06:25:19 mycroft Exp $	*/
d84 9
d153 1
a153 1
	"UNKNOWN (12)",
d156 2
d347 2
d390 18
d415 1
d418 7
a424 5
#if defined(ADU) || defined(DEC_4000) || defined(DEC_7000) || \
    defined(DEC_2100_A500) || defined(DEC_AXPVME_64) || \
    defined(DEC_AXPPCI_33) || defined(DEC_MUSTANG) || \
    defined(DEC_1000)
	THIS SYSTEM NOT SUPPORTED
d482 1
a482 1
	    (name) = (type *)v; v = (caddr_t)((name)+(num))
d484 1
a484 1
	    (name) = (type *)v; v = (caddr_t)((lim) = ((name)+(num)))
d642 1
a642 1
	cpu_consinit(boot_console);
d806 2
a810 2
haltsys:

a1498 1
#ifdef DIAGNOSTIC
d1500 1
a1500 2
		panic("cpu_exec_ecoff_hook: can't get here from there.");
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
