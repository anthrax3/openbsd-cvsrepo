head	1.23;
access;
symbols
	OPENBSD_6_2:1.23.0.8
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.23.0.6
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.2
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.22.0.28
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.30
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.22
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.26
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.24
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.20
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.18
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.16
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.14
	OPENBSD_5_0:1.22.0.12
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.10
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.8
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.4
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.6
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.21.0.4
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.19.0.4
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.10
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.8
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.6
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.16
	UBC:1.14.0.6
	UBC_BASE:1.14
	OPENBSD_3_0:1.14.0.4
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_8:1.12.0.14
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.12
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.10
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.8
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.6
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.4
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11;
locks; strict;
comment	@ * @;


1.23
date	2016.04.27.11.03.24;	author mpi;	state Exp;
branches;
next	1.22;
commitid	QLDpQBW1KLbDishX;

1.22
date	2008.10.04.15.34.45;	author martynas;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.05.19.23.22;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.01.11.54.00;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2007.02.14.00.53.47;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2006.02.26.22.26.16;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2003.05.10.21.11.11;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.16.13.01.41;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.26;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.08.19.16.58;	author ericj;	state Exp;
branches
	1.14.6.1;
next	1.13;

1.13
date	2000.11.08.16.00.56;	author art;	state Exp;
branches;
next	1.12;

1.12
date	97.11.06.23.48.53;	author deraadt;	state Exp;
branches
	1.12.10.1;
next	1.11;

1.11
date	97.07.23.23.26.50;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	97.07.19.20.56.53;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.07.09.14.29.03;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.07.09.10.26.39;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.07.09.09.08.03;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.07.09.08.11.39;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.07.09.02.57.28;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.07.08.21.55.39;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	97.07.08.20.34.57;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.07.08.10.56.30;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.07.06.16.31.13;	author niklas;	state Exp;
branches;
next	;

1.12.10.1
date	2001.04.18.16.00.10;	author niklas;	state Exp;
branches;
next	1.12.10.2;

1.12.10.2
date	2002.03.28.10.06.12;	author niklas;	state Exp;
branches;
next	1.12.10.3;

1.12.10.3
date	2003.03.27.22.29.47;	author niklas;	state Exp;
branches;
next	1.12.10.4;

1.12.10.4
date	2003.05.13.19.41.02;	author ho;	state Exp;
branches;
next	;

1.14.6.1
date	2002.06.11.03.33.39;	author art;	state Exp;
branches;
next	1.14.6.2;

1.14.6.2
date	2003.05.19.21.38.52;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Stop using DDB_REGS.

ok dlg@@
@
text
@/* $OpenBSD: db_disasm.c,v 1.22 2008/10/04 15:34:45 martynas Exp $ */
/* $NetBSD: db_disasm.c,v 1.8 2000/05/25 19:57:30 jhawk Exp $ */

/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */

/*
 *	File: db_disasm.c
 * 	Author: Alessandro Forin, Carnegie Mellon University
 *	Date:	11/91
 *
 *	Disassembler for Alpha
 *
 *	Modified for NetBSD/alpha by:
 *
 *	Christopher G. Demetriou, Carnegie Mellon University
 *
 *	Jason R. Thorpe, Numerical Aerospace Simulation Facility,
 *	NASA Ames Research Center
 *
 *	This code was derived exclusively from information available in
 *	"Alpha Architecture Reference Manual", Richard L. Sites ed.
 *	Digital Press, Burlington, MA 01803
 *	ISBN 1-55558-098-X, Order no. EY-L520E-DP
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <machine/db_machdep.h>
#include <alpha/alpha/db_instruction.h>

#include <machine/pal.h>
 
#include <ddb/db_access.h>
#include <ddb/db_sym.h>
#include <ddb/db_output.h>
#include <ddb/db_interface.h>

/*
 * This would belong in a header file, except noone else needs it
 *
 * XXX THESE SHOULD BE CONVERTED TO ra, rb, rc FORMAT.
 */
typedef union {
	/*
	 *	All instructions are 32 bits wide, PAL included
	 */
	unsigned int	bits;

	/*
	 *	Internal processor register access instrs
	 *	specify the IPR index, doubly specify the
	 *	(same) GP register as src/dest, and qualifiers
	 *	for the IPR set involved (abox/ibox/tmp)
	 */
	struct {
		unsigned	index : 5,
				regset : 3, /* a,i,p */
				xxx : 8,
				rs : 5,
				rd : 5,
				opcode : 6;
	} mXpr_format;

	/*
	 *	Load/store instructions have a 12 bit displacement,
	 *	and two register specifiers just as normal ld/st.
	 *	Four bits have special meanings:
	 *		phy: bypass the MMU (physical access)
	 *		alt: use mode in ALT register for checks,
	 *		     or if PHY is also on locked/linked access
	 *		rwc: read-with-write-check (probew)
	 *		qw:  quadword access
	 */
	struct {
		signed int	displacement : 12;
		unsigned	qw : 1,
				qualif : 3,
				rs : 5,
				rd : 5,
				opcode : 6;
	} mem_format;

	/*
	 *	Return from exception or interrupt has
	 *	a branch-like encoding, but only one
	 *	instantiation is actually usable.
	 */
	struct {
		unsigned	xxx : 14,
				zero : 1,	/* branch prediction! */
				one : 1,
				rb : 5,		/* r31 or stall */
				ra : 5,		/* r31 or stall */
				opcode : 6;
	} rei_format;

} pal_instruction;


/*
 * Major opcodes
 */
static char *op_name[64] = {
/* 0 */	"call_pal", "op1", "op2", "op3", "op4",	"op5",	"op6",	"op7",
/* 8 */	"lda",	"ldah",	"ldbu",	"ldq_u","ldwu",	"stw",	"stb",	"stq_u",
/*16 */	"arit",	"logical","bit","mul",	"op20",	"vaxf",	"ieeef","anyf",
/*24 */	"spec",	"hw_mfpr","jump","hw_ld","intmisc","hw_mtpr","hw_rei","hw_st",
/*32 */	"ldf",	"ldg",	"lds",	"ldt",	"stf",	"stg",	"sts",	"stt",
/*40 */	"ldl",	"ldq",	"ldl_l","ldq_l","stl",	"stq",	"stl_c","stq_c",
/*48 */	"br",	"fbeq",	"fblt",	"fble",	"bsr",	"fbne",	"fbge",	"fbgt",
/*56 */	"blbc",	"beq",	"blt",	"ble",	"blbs",	"bne",	"bge",	"bgt"
};

/*
 * The function field is too big (7 or 11 bits), so the sub-tables
 * are addressed in a somewhat complicated manner to save
 * space.  After all, alu operations is what RISCs are good at.
 */

struct tbl {
	const char	*name;
	int		code;
};

static const struct tbl pal_op_tbl[] = {
	/* Common PAL function codes. */
	{ "halt",		PAL_halt },
	{ "cflush",		PAL_cflush },
	{ "draina",		PAL_draina },
	{ "cserve",		PAL_cserve, },
	{ "swppal",		PAL_swppal },
	{ "ipir",		PAL_ipir },
	{ "bpt",		PAL_bpt },
	{ "bugchk",		PAL_bugchk },
	{ "imb",		PAL_imb },
	{ "rdunique",		PAL_rdunique },
	{ "wrunique",		PAL_wrunique },
	{ "gentrap",		PAL_gentrap },

	/* OSF/1 PAL function codes. */
	{ "osf1_rdmces",	PAL_OSF1_rdmces },
	{ "osf1_wrmces",	PAL_OSF1_wrmces },
	{ "osf1_wrfen",		PAL_OSF1_wrfen },
	{ "osf1_wrvptptr",	PAL_OSF1_wrvptptr },
	{ "osf1_swpctx",	PAL_OSF1_swpctx },
	{ "osf1_wrval",		PAL_OSF1_wrval },
	{ "osf1_rdval",		PAL_OSF1_rdval },
	{ "osf1_tbi",		PAL_OSF1_tbi },
	{ "osf1_wrent",		PAL_OSF1_wrent },
	{ "osf1_swpipl",	PAL_OSF1_swpipl },
	{ "osf1_rdps",		PAL_OSF1_rdps },
	{ "osf1_wrkgp",		PAL_OSF1_wrkgp },
	{ "osf1_wrusp",		PAL_OSF1_wrusp },
	{ "osf1_wrperfmon",	PAL_OSF1_wrperfmon },
	{ "osf1_rdusp",		PAL_OSF1_rdusp },
	{ "osf1_whami",		PAL_OSF1_whami },
	{ "osf1_retsys",	PAL_OSF1_retsys },
	{ "osf1_rti",		PAL_OSF1_rti },
	{ "osf1_callsys",	PAL_OSF1_callsys },

	{ NULL,			-1 },
};

static const char *pal_opname(int);

static const char *
pal_opname(op)
	int op;
{
	static char unk[11];
	int i;

	for (i = 0; pal_op_tbl[i].name != NULL; i++) {
		if (pal_op_tbl[i].code == op)
			return (pal_op_tbl[i].name);
	}

	snprintf(unk, sizeof unk, "0x%x", op);
	return (unk);
}

/* HW (PAL) instruction qualifiers, stright tables */
static const char *mXpr_name[8] = {
	"", "/i", "/a", "/ai", "/p", "/pi", "/pa", "/pai"
};
static const char *hwlds_name[8] = {
	"", "/r", "/a", "/ar", "/p", "/p?r", "_l-c", "_l-c/?r"
};

/*
 * For this one we take the low nibble (valid values 0/2/9/b/d)
 * and shift it down one to get the row index.  Within a row
 * we can just take the high nibble deprived of the high bit
 * (valid values 0/1/2/3/4/6).  We could have used a flat 64
 * entry array, but in this way we use just 48 pointers.
 * BUGFIX: the 'cmpbge 0x0f' opcode fits in here too
 */
static const char *arit_c0[8] = {
	"addl", 0, "addq", 0, "addl/v", 0, "addq/v",
};
static const char *arit_c2[8] = {
	"s4addl", "s8addl", "s4addq", "s8addq", 
};
static const char *arit_c9[8] = {
	"subl", 0, "subq", 0, "subl/v", 0, "subq/v", 
};
static const char *arit_cB[8] = {
	"s4subl", "s8subl", "s4subq", "s8subq", 
};
static const char *arit_cD[8] = {
	0, "cmpult", "cmpeq", "cmpule", "cmplt", 0, "cmple",
};
static const char *arit_cF[1] = {
	"cmpbge"
};
static const char **arit_opname[8] = {
	arit_c0, arit_c2, 0, 0, arit_c9, arit_cB, arit_cD, arit_cF
};

static __inline const char *arit_name(int);
static __inline const char *
arit_name(op)
	int op;
{
	static char unk[32];
	const char *name = NULL;

	if (arit_opname[((op)&0xe)>>1])
		name = arit_opname[((op)&0xe)>>1][((op)&0x70)>>4];

	if (name != NULL)
		return (name);

	snprintf(unk, sizeof unk, "?arit 0x%x?", op);
	return (unk);
}

/*
 * Something similar for this one, except there are only
 * 16 entries so the row indexing is done by enumeration
 * of the low nibble (valid values 0/4/6/8).  Then we can
 * just shift the high nibble to index inside the row
 * (valid values are 0/2/4 or 1/2/4/6)
 *
 * There are two functions that don't play by these simple rules,
 * so we special-case them.
 */
static const char *logical_c0[4] = {
	"and", "or", "xor", 0
};
static const char *logical_c4[4] = {
	"cmovlbs", "cmoveq", "cmovlt", "cmovle"
};
static const char *logical_c6[4] = {
	"cmovlbc", "cmovne", "cmovge", "cmovgt"
};
static const char *logical_c8[4] = {
	"andnot", "ornot", "xornot", 0
};

static __inline const char *logical_name(int);
static __inline const char *
logical_name(op)
	int op;
{
	static char unk[32];
	const char *name = NULL;

	if (op == op_amask)
		return ("amask");
	else if (op == op_implver)
		return ("implver");

	switch (op & 0xf) {
	case 0: name = logical_c0[((op)>>5)&3]; break;
	case 4: name = logical_c4[((op)>>5)&3]; break;
	case 6: name = logical_c6[((op)>>5)&3]; break;
	case 8: name = logical_c8[((op)>>5)&3]; break;
	}

	if (name != NULL)
		return (name);

	snprintf(unk, sizeof unk, "?logical 0x%x?", op);
	return (unk);
}

/*
 * This is the messy one. First, we single out the dense
 * case of a 3 in the high nibble (valid values 0/1/2/4/6/9/b/c).
 * Then the case of a 2 in the low nibble (valid values 0/1/2/5/6/7).
 * For the remaining codes (6/7/a/b) we do as above: high
 * nibble has valid values 0/1/2 or 5/6/7.  The low nibble
 * can be used as row index picking bits 0 and 2, for the
 * high one just the lower two bits.
 */
static const char *bitop_c3[8] = {
	"zapnot", "mskql", "srl", "extql", "sll", "insql", "sra", 0
};
static const char *bitop_c2[8] = {
	"mskbl", "mskwl", "mskll", 0/*mskql*/, 0, "mskwh", "msklh", "mskqh"
};
static const char *bitop_c67ab[4][4] = {
/* a */	{ 0, "extwh", "extlh", "extqh"},
/* b */	{ "insbl", "inswl", "insll", 0 },
/* 6 */	{ "extbl", "extwl", "extll", 0 },
/* 7 */	{ 0, "inswh", "inslh", "insqh" },
};

static __inline const char *bitop_name(int);
static __inline const char *
bitop_name(op)
	int op;
{
	static char unk[32];
	const char *name = NULL;

	if ((op & 0x70) == 0x30)
		name = (op == op_zap) ? "zap" : bitop_c3[((op)&0xe)>>1];
	else if ((op & 0xf) == 0x02)
		name = bitop_c2[(op)>>4];
	else
		name =
		    bitop_c67ab[(((op)&1)|(((op)&0x4)>>1))][(((op)&0x30)>>4)];

	if (name != NULL)
		return (name);

	snprintf(unk, sizeof unk, "?bit 0x%x?", op);
	return (unk);
}

/*
 * Only 5 entries in this one
 */
static const char *mul_opname[4] = {
	"mull", "mulq", "mull/v", "mulq/v"
};

static __inline const char *mul_name(int);
static __inline const char *
mul_name(op)
	int op;
{
	static char unk[32];
	const char *name = NULL;

	name = (op == op_umulh) ? "umulh" : mul_opname[((op)>>5)&3];

	if (name != NULL)
		return (name);

	snprintf(unk, sizeof unk, "?mul 0x%x?", op);
	return (unk);
}

/*
 * These are few, the high nibble is usually enough to dispatch.
 * We single out the `f' case to halve the table size, as
 * well as the cases in which the high nibble isn't enough.
 */
static const char *special_opname[8] = {
	"trapb", 0, "mb", 0, "fetch", "fetch_m", "rpcc", "rc"
};

static __inline const char *special_name(int);
static __inline const char *
special_name(op)
	int op;
{
	static char unk[32];
	const char *name;

	switch (op) {
	case op_excb:		name = "excb";		break;
	case op_wmb:		name = "wmb";		break;
	case op_ecb:		name = "ecb";		break;
	case op_rs:		name = "rs";		break;
	case op_wh64:		name = "wh64";		break;
	default:
		name = special_opname[(op)>>13];
	}

	if (name != NULL)
		return (name);

	snprintf(unk, sizeof unk, "?special 0x%x?", op);
	return (unk);
}

/*
 * This is trivial
 */
static const char *jump_opname[4] = {
	"jmp", "jsr", "ret", "jcr"
};
#define jump_name(ix)	jump_opname[ix]

/*
 * For all but 4 of these, we can dispatch on the lower nibble of
 * the "function".
 */
static const char *intmisc_opname_3x[16] = {
	"ctpop", "perr", "ctlz", "cttz", "unpkbw", "unpkbl", "pkwb",
	"pklb", "minsb8", "minsw4", "minub8", "minuw4", "maxub8",
	"maxuw4", "maxsb8", "maxsw4",
};

static __inline const char *intmisc_name(int);
static __inline const char *
intmisc_name(op)
	int op;
{
	static char unk[32];

	if ((op & 0xf0) == 0x30)
		return (intmisc_opname_3x[op & 0x0f]);

	switch (op) {
	case op_sextb: return ("sextb");
	case op_sextw: return ("sextw");
	case op_ftoit: return ("ftoit");
	case op_ftois: return ("ftois");
	}

	snprintf(unk, sizeof unk, "?intmisc 0x%x?", op);
	return (unk);
}

static const char *float_name(const struct tbl[], int, const char *type);

static const char *
float_name(tbl, op, type)
	const struct tbl tbl[];
	int op;
	const char *type;
{
	static char unk[32];
	int i;

	for (i = 0; tbl[i].name != NULL; i++) {
		if (tbl[i].code == op)
			return (tbl[i].name);
	}

	snprintf(unk, sizeof unk, "?%s 0x%x?", type, op);
	return (unk);
}

#define vaxf_name(op)	float_name(vaxf_tbl, op, "vaxfl")
#define ieeef_name(op)	float_name(ieeef_tbl, op, "ieeefl")
#define anyf_name(op)	float_name(anyf_tbl, op, "anyfl")

static const struct tbl anyf_tbl[] = {
	{ "cvtlq",	0x010},
	{ "cpys",	0x020},
	{ "cpysn",	0x021},
	{ "cpyse",	0x022},
	{ "mt_fpcr",	0x024},
	{ "mf_fpcr",	0x025},
	{ "fcmoveq",	0x02a},
	{ "fcmovne",	0x02b},
	{ "fcmovlt",	0x02c},
	{ "fcmovge",	0x02d},
	{ "fcmovle",	0x02e},
	{ "fcmovgt",	0x02f},
	{ "cvtql",	0x030},
	{ "cvtql/v",	0x130},
	{ "cvtql/sv",	0x530},
	{ 0, 0},
};

static const struct tbl ieeef_tbl[] = {
	{ "adds/c",	0x000},
	{ "subs/c",	0x001},
	{ "muls/c",	0x002},
	{ "divs/c",	0x003},
	{ "addt/c",	0x020},
	{ "subt/c",	0x021},
	{ "mult/c",	0x022},
	{ "divt/c",	0x023},
	{ "cvtts/c",	0x02c},
	{ "cvttq/c",	0x02f},
	{ "cvtqs/c",	0x03c},
	{ "cvtqt/c",	0x03e},
	{ "adds/m",	0x040},
	{ "subs/m",	0x041},
	{ "muls/m",	0x042},
	{ "divs/m",	0x043},
	{ "addt/m",	0x060},
	{ "subt/m",	0x061},
	{ "mult/m",	0x062},
	{ "divt/m",	0x063},
	{ "cvtts/m",	0x06c},
	{ "cvtqs/m",	0x07c},
	{ "cvtqt/m",	0x07e},
	{ "adds",	0x080},
	{ "subs",	0x081},
	{ "muls",	0x082},
	{ "divs",	0x083},
	{ "addt",	0x0a0},
	{ "subt",	0x0a1},
	{ "mult",	0x0a2},
	{ "divt",	0x0a3},
	{ "cmptun",	0x0a4},
	{ "cmpteq",	0x0a5},
	{ "cmptlt",	0x0a6},
	{ "cmptle",	0x0a7},
	{ "cvtts",	0x0ac},
	{ "cvttq",	0x0af},
	{ "cvtqs",	0x0bc},
	{ "cvtqt",	0x0be},
	{ "adds/d",	0x0c0},
	{ "subs/d",	0x0c1},
	{ "muls/d",	0x0c2},
	{ "divs/d",	0x0c3},
	{ "addt/d",	0x0e0},
	{ "subt/d",	0x0e1},
	{ "mult/d",	0x0e2},
	{ "divt/d",	0x0e3},
	{ "cvtts/d",	0x0ec},
	{ "cvtqs/d",	0x0fc},
	{ "cvtqt/d",	0x0fe},
	{ "adds/uc",	0x100},
	{ "subs/uc",	0x101},
	{ "muls/uc",	0x102},
	{ "divs/uc",	0x103},
	{ "addt/uc",	0x120},
	{ "subt/uc",	0x121},
	{ "mult/uc",	0x122},
	{ "divt/uc",	0x123},
	{ "cvtts/uc",	0x12c},
	{ "cvttq/vc",	0x12f},
	{ "adds/um",	0x140},
	{ "subs/um",	0x141},
	{ "muls/um",	0x142},
	{ "divs/um",	0x143},
	{ "addt/um",	0x160},
	{ "subt/um",	0x161},
	{ "mult/um",	0x162},
	{ "divt/um",	0x163},
	{ "cvtts/um",	0x16c},
	{ "adds/u",	0x180},
	{ "subs/u",	0x181},
	{ "muls/u",	0x182},
	{ "divs/u",	0x183},
	{ "addt/u",	0x1a0},
	{ "subt/u",	0x1a1},
	{ "mult/u",	0x1a2},
	{ "divt/u",	0x1a3},
	{ "cvtts/u",	0x1ac},
	{ "cvttq/v",	0x1af},
	{ "adds/ud",	0x1c0},
	{ "subs/ud",	0x1c1},
	{ "muls/ud",	0x1c2},
	{ "divs/ud",	0x1c3},
	{ "addt/ud",	0x1e0},
	{ "subt/ud",	0x1e1},
	{ "mult/ud",	0x1e2},
	{ "divt/ud",	0x1e3},
	{ "cvtts/ud",	0x1ec},
	{ "adds/suc",	0x500},
	{ "subs/suc",	0x501},
	{ "muls/suc",	0x502},
	{ "divs/suc",	0x503},
	{ "addt/suc",	0x520},
	{ "subt/suc",	0x521},
	{ "mult/suc",	0x522},
	{ "divt/suc",	0x523},
	{ "cvtts/suc",	0x52c},
	{ "cvttq/svc",	0x52f},
	{ "adds/sum",	0x540},
	{ "subs/sum",	0x541},
	{ "muls/sum",	0x542},
	{ "divs/sum",	0x543},
	{ "addt/sum",	0x560},
	{ "subt/sum",	0x561},
	{ "mult/sum",	0x562},
	{ "divt/sum",	0x563},
	{ "cvtts/sum",	0x56c},
	{ "adds/su",	0x580},
	{ "subs/su",	0x581},
	{ "muls/su",	0x582},
	{ "divs/su",	0x583},
	{ "addt/su",	0x5a0},
	{ "subt/su",	0x5a1},
	{ "mult/su",	0x5a2},
	{ "divt/su",	0x5a3},
	{ "cmptun/su",	0x5a4},
	{ "cmpteq/su",	0x5a5},
	{ "cmptlt/su",	0x5a6},
	{ "cmptle/su",	0x5a7},
	{ "cvtts/su",	0x5ac},
	{ "cvttq/sv",	0x5af},
	{ "adds/sud",	0x5c0},
	{ "subs/sud",	0x5c1},
	{ "muls/sud",	0x5c2},
	{ "divs/sud",	0x5c3},
	{ "addt/sud",	0x5e0},
	{ "subt/sud",	0x5e1},
	{ "mult/sud",	0x5e2},
	{ "divt/sud",	0x5e3},
	{ "cvtts/sud",	0x5ec},
	{ "adds/suic",	0x700},
	{ "subs/suic",	0x701},
	{ "muls/suic",	0x702},
	{ "divs/suic",	0x703},
	{ "addt/suic",	0x720},
	{ "subt/suic",	0x721},
	{ "mult/suic",	0x722},
	{ "divt/suic",	0x723},
	{ "cvtts/suic",	0x72c},
	{ "cvttq/svic",	0x72f},
	{ "cvtqs/suic",	0x73c},
	{ "cvtqt/suic",	0x73e},
	{ "adds/suim",	0x740},
	{ "subs/suim",	0x741},
	{ "muls/suim",	0x742},
	{ "divs/suim",	0x743},
	{ "addt/suim",	0x760},
	{ "subt/suim",	0x761},
	{ "mult/suim",	0x762},
	{ "divt/suim",	0x763},
	{ "cvtts/suim",	0x76c},
	{ "cvtqs/suim",	0x77c},
	{ "cvtqt/suim",	0x77e},
	{ "adds/sui",	0x780},
	{ "subs/sui",	0x781},
	{ "muls/sui",	0x782},
	{ "divs/sui",	0x783},
	{ "addt/sui",	0x7a0},
	{ "subt/sui",	0x7a1},
	{ "mult/sui",	0x7a2},
	{ "divt/sui",	0x7a3},
	{ "cvtts/sui",	0x7ac},
	{ "cvttq/svi",	0x7af},
	{ "cvtqs/sui",	0x7bc},
	{ "cvtqt/sui",	0x7be},
	{ "adds/suid",	0x7c0},
	{ "subs/suid",	0x7c1},
	{ "muls/suid",	0x7c2},
	{ "divs/suid",	0x7c3},
	{ "addt/suid",	0x7e0},
	{ "subt/suid",	0x7e1},
	{ "mult/suid",	0x7e2},
	{ "divt/suid",	0x7e3},
	{ "cvtts/suid",	0x7ec},
	{ "cvtqs/suid",	0x7fc},
	{ "cvtqt/suid",	0x7fe},
	{ 0, 0}
};

static const struct tbl vaxf_tbl[] = {
	{ "addf/c",	0x000},
	{ "subf/c",	0x001},
	{ "mulf/c",	0x002},
	{ "divf/c",	0x003},
	{ "cvtdg/c",	0x01e},
	{ "addg/c",	0x020},
	{ "subg/c",	0x021},
	{ "mulg/c",	0x022},
	{ "divg/c",	0x023},
	{ "cvtgf/c",	0x02c},
	{ "cvtgd/c",	0x02d},
	{ "cvtgq/c",	0x02f},
	{ "cvtqf/c",	0x03c},
	{ "cvtqg/c",	0x03e},
	{ "addf",	0x080},
	{ "subf",	0x081},
	{ "mulf",	0x082},
	{ "divf",	0x083},
	{ "cvtdg",	0x09e},
	{ "addg",	0x0a0},
	{ "subg",	0x0a1},
	{ "mulg",	0x0a2},
	{ "divg",	0x0a3},
	{ "cmpgeq",	0x0a5},
	{ "cmpglt",	0x0a6},
	{ "cmpgle",	0x0a7},
	{ "cvtgf",	0x0ac},
	{ "cvtgd",	0x0ad},
	{ "cvtgq",	0x0af},
	{ "cvtqf",	0x0bc},
	{ "cvtqg",	0x0be},
	{ "addf/uc",	0x100},
	{ "subf/uc",	0x101},
	{ "mulf/uc",	0x102},
	{ "divf/uc",	0x103},
	{ "cvtdg/uc",	0x11e},
	{ "addg/uc",	0x120},
	{ "subg/uc",	0x121},
	{ "mulg/uc",	0x122},
	{ "divg/uc",	0x123},
	{ "cvtgf/uc",	0x12c},
	{ "cvtgd/uc",	0x12d},
	{ "cvtgq/vc",	0x12f},
	{ "addf/u",	0x180},
	{ "subf/u",	0x181},
	{ "mulf/u",	0x182},
	{ "divf/u",	0x183},
	{ "cvtdg/u",	0x19e},
	{ "addg/u",	0x1a0},
	{ "subg/u",	0x1a1},
	{ "mulg/u",	0x1a2},
	{ "divg/u",	0x1a3},
	{ "cvtgf/u",	0x1ac},
	{ "cvtgd/u",	0x1ad},
	{ "cvtgq/v",	0x1af},
	{ "addf/sc",	0x400},
	{ "subf/sc",	0x401},
	{ "mulf/sc",	0x402},
	{ "divf/sc",	0x403},
	{ "cvtdg/sc",	0x41e},
	{ "addg/sc",	0x420},
	{ "subg/sc",	0x421},
	{ "mulg/sc",	0x422},
	{ "divg/sc",	0x423},
	{ "cvtgf/sc",	0x42c},
	{ "cvtgd/sc",	0x42d},
	{ "cvtgq/sc",	0x42f},
	{ "cvtqf/sc",	0x43c},
	{ "cvtqg/sc",	0x43e},
	{ "addf/s",	0x480},
	{ "subf/s",	0x481},
	{ "mulf/s",	0x482},
	{ "divf/s",	0x483},
	{ "cvtdg/s",	0x49e},
	{ "addg/s",	0x4a0},
	{ "subg/s",	0x4a1},
	{ "mulg/s",	0x4a2},
	{ "divg/s",	0x4a3},
	{ "cmpgeq/s",	0x4a5},
	{ "cmpglt/s",	0x4a6},
	{ "cmpgle/s",	0x4a7},
	{ "cvtgf/s",	0x4ac},
	{ "cvtgd/s",	0x4ad},
	{ "cvtgq/s",	0x4af},
	{ "cvtqf/s",	0x4bc},
	{ "cvtqg/s",	0x4be},
	{ "addf/suc",	0x500},
	{ "subf/suc",	0x501},
	{ "mulf/suc",	0x502},
	{ "divf/suc",	0x503},
	{ "cvtdg/suc",	0x51e},
	{ "addg/suc",	0x520},
	{ "subg/suc",	0x521},
	{ "mulg/suc",	0x522},
	{ "divg/suc",	0x523},
	{ "cvtgf/suc",	0x52c},
	{ "cvtgd/suc",	0x52d},
	{ "cvtgq/svc",	0x52f},
	{ "addf/su",	0x580},
	{ "subf/su",	0x581},
	{ "mulf/su",	0x582},
	{ "divf/su",	0x583},
	{ "cvtdg/su",	0x59e},
	{ "addg/su",	0x5a0},
	{ "subg/su",	0x5a1},
	{ "mulg/su",	0x5a2},
	{ "divg/su",	0x5a3},
	{ "cvtgf/su",	0x5ac},
	{ "cvtgd/su",	0x5ad},
	{ "cvtgq/sv",	0x5af},
	{ 0, 0}
};

/*
 * General purpose registers
 */
static const char *name_of_register[32] = {
	"v0",	"t0",	"t1",	"t2",	"t3",	"t4",	"t5",	"t6",
	"t7",	"s0",	"s1",	"s2",	"s3",	"s4",	"s5",	"s6",
	"a0",	"a1",	"a2",	"a3",	"a4",	"a5",	"t8",	"t9",
	"t10",	"t11",	"ra",	"pv",	"at",	"gp",	"sp",	"zero"
};

static int regcount;		/* how many regs used in this inst */
static int regnum[3];		/* which regs used in this inst */

static const char *register_name(int);

static const char *
register_name (ireg)
	int ireg;
{
	int	i;

	for (i = 0; i < regcount; i++)
		if (regnum[i] == ireg)
			break;
	if (i >= regcount)
		regnum[regcount++] = ireg;
	return (name_of_register[ireg]);
}

/*
 * Disassemble instruction at 'loc'.  'altfmt' specifies an
 * (optional) alternate format.  Return address of start of
 * next instruction.
 */
int	alpha_print_instruction(db_addr_t, alpha_instruction, boolean_t);

db_addr_t
db_disasm(loc, altfmt)
	db_addr_t	loc;
	boolean_t	altfmt;
{
	alpha_instruction inst;

	inst.bits = db_get_value(loc, 4, 0);

	loc += alpha_print_instruction(loc, inst, altfmt);
	return (loc);
}

int
alpha_print_instruction(iadr, i, showregs)
	db_addr_t	iadr;
	alpha_instruction i;
	boolean_t	showregs;
{
	const char	*opcode;
	int		ireg;
	long		signed_immediate;
	boolean_t	fstore;
	pal_instruction	p;
	char		tmpfmt[28];

	regcount = 0;
	fstore = FALSE;
	opcode = op_name[i.mem_format.opcode];

	/*
	 *	Dispatch directly on the opcode, save code
	 *	duplication sometimes via "harmless gotos".
	 */
	switch (i.mem_format.opcode) {
	case op_pal:
		/* "call_pal" is a long string; just use a space. */
		db_printf("%s %s", opcode, pal_opname(i.pal_format.function));
		break;
	case op_lda:
	case op_ldah:
	case op_ldbu:
	case op_ldq_u:
	case op_ldwu:
	case op_stw:
	case op_stb:
	case op_stq_u:
		/*
		 * These loadstores are here to make compiling the
		 * switch a bit easier.  Could embellish the output
		 * someday, too.
		 */
		goto loadstore;
		break;
	case op_arit:
		/*
		 * For this and the following three groups we
		 * just need different opcode strings
		 */
		opcode = arit_name(i.operate_lit_format.function);
		goto operate;
		break;
	case op_logical:
		opcode = logical_name(i.operate_lit_format.function);
		goto operate;
		break;
	case op_bit:
		opcode = bitop_name(i.operate_lit_format.function);
		goto operate;
		break;
	case op_mul:
		opcode = mul_name(i.operate_lit_format.function);
operate:
		/*
		 * Nice and uniform, just check for literals
		 */
		db_printf("%s\t%s,", opcode,
		    register_name(i.operate_lit_format.ra));
		if (i.operate_lit_format.one)
			db_printf("#0x%x", i.operate_lit_format.literal);
		else
			db_printf("%s", register_name(i.operate_reg_format.rb));
		db_printf(",%s", register_name(i.operate_lit_format.rc));
		break;
	case op_vax_float:
		/*
		 * The three floating point groups are even simpler
		 */
		opcode = vaxf_name(i.float_format.function);
		goto foperate;
		break;
	case op_ieee_float:
		opcode = ieeef_name(i.float_format.function);
		goto foperate;
		break;
	case op_any_float:
		opcode = anyf_name(i.float_format.function);
foperate:
		db_printf("%s\tf%d,f%d,f%d", opcode,
			i.float_format.fa,
			i.float_format.fb,
			i.float_format.fc);
		break;
	case op_special:
		/*
		 * Miscellaneous.
		 */
		{
			register unsigned int code;

			code = (i.mem_format.displacement)&0xffff;
			opcode = special_name(code);

			switch (code) {
			case op_ecb:
				db_printf("%s\t(%s)", opcode,
					register_name(i.mem_format.rb));
				break;
			case op_fetch:
			case op_fetch_m:
				db_printf("%s\t0(%s)", opcode,
					register_name(i.mem_format.rb));
				break;
			case op_rpcc:
			case op_rc:
			case op_rs:
				db_printf("%s\t%s", opcode,
					register_name(i.mem_format.ra));
				break;
			default:
				db_printf("%s", opcode);
			break;
			}
		}
		break;
	case op_j:
		/*
		 * Jump instructions really are of two sorts,
		 * depending on the use of the hint info.
		 */
		opcode = jump_name(i.jump_format.action);
		switch (i.jump_format.action) {
		case op_jmp:
		case op_jsr:
			db_printf("%s\t%s,(%s),", opcode,
				register_name(i.jump_format.ra),
				register_name(i.jump_format.rb));
			signed_immediate = i.jump_format.hint;
			goto branch_displacement;
			break;
		case op_ret:
		case op_jcr:
			db_printf("%s\t%s,(%s)", opcode,
				register_name(i.jump_format.ra),
				register_name(i.jump_format.rb));
			break;
		}
		break;
	case op_intmisc:
		/*
		 * These are just in "operate" format.
		 */
		opcode = intmisc_name(i.operate_lit_format.function);
		goto operate;
		break;
			/* HW instructions, possibly chip-specific XXXX */
	case op_pal19:	/* "hw_mfpr" */
	case op_pal1d:	/* "hw_mtpr" */
		p.bits = i.bits;
		db_printf("\t%s%s\t%s, %d", opcode,
			mXpr_name[p.mXpr_format.regset],
			register_name(p.mXpr_format.rd),
			p.mXpr_format.index);
		break;
	case op_pal1b:	/* "hw_ld" */
	case op_pal1f:	/* "hw_st" */
		p.bits = i.bits;
		db_printf("\t%s%c%s\t%s,", opcode,
			(p.mem_format.qw) ? 'q' : 'l',
			hwlds_name[p.mem_format.qualif],
			register_name(p.mem_format.rd));
		signed_immediate = (long)p.mem_format.displacement;
		goto loadstore_address;

	case op_pal1e:	/* "hw_rei" */
		db_printf("\t%s", opcode);
		break;

	case op_ldf:
	case op_ldg:
	case op_lds:
	case op_ldt:
	case op_stf:
	case op_stg:
	case op_sts:
	case op_stt:
		fstore = TRUE;
		/* FALLTHROUGH */
	case op_ldl:
	case op_ldq:
	case op_ldl_l:
	case op_ldq_l:
	case op_stl:
	case op_stq:
	case op_stl_c:
	case op_stq_c:
		/*
		 * Memory operations, including floats
		 */
loadstore:
		if (fstore)
		    db_printf("%s\tf%d,", opcode, i.mem_format.ra);
		else
		    db_printf("%s\t%s,", opcode,
		        register_name(i.mem_format.ra));
		signed_immediate = (long)i.mem_format.displacement;
loadstore_address:
		db_printf("%s(%s)", db_format(tmpfmt, sizeof tmpfmt,
		    signed_immediate, DB_FORMAT_Z, 0, 0),
		    register_name(i.mem_format.rb));
		/*
		 * For convenience, do the address computation
		 */
		if (showregs) {
			if (i.mem_format.opcode == op_ldah)
				signed_immediate <<= 16;
			db_printf(" <0x%lx>", signed_immediate +
			    db_register_value(&ddb_regs, i.mem_format.rb));
		}
		break;
	case op_br:
	case op_fbeq:
	case op_fblt:
	case op_fble:
	case op_bsr:
	case op_fbne:
	case op_fbge:
	case op_fbgt:
	case op_blbc:
	case op_beq:
	case op_blt:
	case op_ble:
	case op_blbs:
	case op_bne:
	case op_bge:
	case op_bgt:
		/*
		 * We want to know where we are branching to
		 */
		signed_immediate = (long)i.branch_format.displacement;
		db_printf("%s\t%s,", opcode,
			  register_name(i.branch_format.ra));
branch_displacement:
		db_printsym(iadr + sizeof(alpha_instruction) +
		    (signed_immediate << 2), DB_STGY_PROC, db_printf);
		break;
	default:
		/*
		 * Shouldn't happen
		 */
		db_printf("? 0x%x ?", i.bits);
	}

	/*
	 *	Print out the registers used in this instruction
	 */
	if (showregs && regcount > 0) {
		db_printf("\t<");
		for (ireg = 0; ireg < regcount; ireg++) {
			if (ireg != 0)
				db_printf(",");
			db_printf("%s=0x%lx",
			    name_of_register[regnum[ireg]],
			    db_register_value(&ddb_regs, regnum[ireg]));
		}
		db_printf(">");
	}
	db_printf("\n");
	return (sizeof(alpha_instruction));
}
@


1.22
log
@this is not the cvtql/sv opcode.  ok miod@@, naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: db_disasm.c,v 1.21 2007/11/05 19:23:22 miod Exp $ */
d1055 1
a1055 1
			    db_register_value(DDB_REGS, i.mem_format.rb));
d1101 1
a1101 1
			    db_register_value(DDB_REGS, regnum[ireg]));
@


1.21
log
@temporary ddb buffers need to be a bit larger on 64 bit systems to cope with
some radix configurations.
@
text
@d1 1
a1 1
/* $OpenBSD: db_disasm.c,v 1.20 2007/09/01 11:54:00 miod Exp $ */
d494 1
a494 1
	{ "cvtql/sv",	0x330},
@


1.20
log
@Use db_format() instead of ddb-specific format specifiers; no functional
change inteded.
ok ray@@
@
text
@d1 1
a1 1
/* $OpenBSD: db_disasm.c,v 1.19 2007/02/14 00:53:47 jsg Exp $ */
d852 1
a852 1
	char		tmpfmt[24];
@


1.19
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: db_disasm.c,v 1.18 2006/02/26 22:26:16 miod Exp $ */
d852 1
d1045 3
a1047 2
		db_printf("%lz(%s)", signed_immediate,
			register_name(i.mem_format.rb));
@


1.18
log
@Provide a buffer large enough for its contents in pal_opname(). ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: db_disasm.c,v 1.17 2003/05/10 21:11:11 deraadt Exp $ */
d1024 1
a1024 1
		/* fall through */
@


1.17
log
@string cleaning; ok beck dhartmei
@
text
@d1 1
a1 1
/* $OpenBSD: db_disasm.c,v 1.16 2002/05/16 13:01:41 art Exp $ */
d195 1
a195 1
	static char unk[8];
@


1.16
log
@Add a an argument to db_printsym that specifies the printf function
we'll use for printing the information.
miod@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: db_disasm.c,v 1.15 2002/03/14 01:26:26 millert Exp $ */
d203 1
a203 1
	sprintf(unk, "0x%x", op);
d259 1
a259 1
	sprintf(unk, "?arit 0x%x?", op);
d309 1
a309 1
	sprintf(unk, "?logical 0x%x?", op);
d354 1
a354 1
	sprintf(unk, "?bit 0x%x?", op);
d378 1
a378 1
	sprintf(unk, "?mul 0x%x?", op);
d412 1
a412 1
	sprintf(unk, "?special 0x%x?", op);
d451 1
a451 1
	sprintf(unk, "?intmisc 0x%x?", op);
d471 1
a471 1
	sprintf(unk, "?%s 0x%x?", type, op);
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: db_disasm.c,v 1.14 2000/11/08 19:16:58 ericj Exp $ */
d1080 1
a1080 1
		    (signed_immediate << 2), DB_STGY_PROC);
@


1.14
log
@add tags
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d189 1
a189 1
static const char *pal_opname __P((int));
d245 1
a245 1
static __inline const char *arit_name __P((int));
d286 1
a286 1
static __inline const char *logical_name __P((int));
d335 1
a335 1
static __inline const char *bitop_name __P((int));
d365 1
a365 1
static __inline const char *mul_name __P((int));
d391 1
a391 1
static __inline const char *special_name __P((int));
d434 1
a434 1
static __inline const char *intmisc_name __P((int));
d455 1
a455 1
static const char *float_name __P((const struct tbl[], int, const char *type));
d805 1
a805 1
static const char *register_name __P((int));
d826 1
a826 1
int	alpha_print_instruction __P((db_addr_t, alpha_instruction, boolean_t));
@


1.14.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: db_disasm.c,v 1.14 2000/11/08 19:16:58 ericj Exp $ */
d189 1
a189 1
static const char *pal_opname(int);
d245 1
a245 1
static __inline const char *arit_name(int);
d286 1
a286 1
static __inline const char *logical_name(int);
d335 1
a335 1
static __inline const char *bitop_name(int);
d365 1
a365 1
static __inline const char *mul_name(int);
d391 1
a391 1
static __inline const char *special_name(int);
d434 1
a434 1
static __inline const char *intmisc_name(int);
d455 1
a455 1
static const char *float_name(const struct tbl[], int, const char *type);
d805 1
a805 1
static const char *register_name(int);
d826 1
a826 1
int	alpha_print_instruction(db_addr_t, alpha_instruction, boolean_t);
d1080 1
a1080 1
		    (signed_immediate << 2), DB_STGY_PROC, db_printf);
@


1.14.6.2
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d203 1
a203 1
	snprintf(unk, sizeof unk, "0x%x", op);
d259 1
a259 1
	snprintf(unk, sizeof unk, "?arit 0x%x?", op);
d309 1
a309 1
	snprintf(unk, sizeof unk, "?logical 0x%x?", op);
d354 1
a354 1
	snprintf(unk, sizeof unk, "?bit 0x%x?", op);
d378 1
a378 1
	snprintf(unk, sizeof unk, "?mul 0x%x?", op);
d412 1
a412 1
	snprintf(unk, sizeof unk, "?special 0x%x?", op);
d451 1
a451 1
	snprintf(unk, sizeof unk, "?intmisc 0x%x?", op);
d471 1
a471 1
	snprintf(unk, sizeof unk, "?%s 0x%x?", type, op);
@


1.13
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
@


1.12
log
@param.h, niklas
@
text
@d1 27
a27 1
/*	$OpenBSD: db_disasm.c,v 1.11 1997/07/23 23:26:50 niklas Exp $	*/
d30 5
a34 2
 * Copyright (c) 1997 Niklas Hallqvist.  All rights reserverd.
 * Copyright (c) 1997 Theo de Raadt. All rights reserved.
d36 1
a36 14
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Niklas Hallqvist and
 *	Theo de Raadt.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d38 9
a46 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d51 145
d197 16
a212 1
#include <vm/vm.h>
d214 228
a441 2
#include <machine/db_machdep.h>
#include <machine/frame.h>
d443 6
a448 4
#include <ddb/db_interface.h>
#include <ddb/db_variables.h>
#include <ddb/db_output.h>
#include <ddb/db_sym.h>
d450 2
a451 123
struct opcode opcode[] = {
	{ OPC_PAL, "call_pal", 0 },	/* 00 */
	{ OPC_RES, "opc01", 0 },	/* 01 */
	{ OPC_RES, "opc02", 0 },	/* 02 */
	{ OPC_RES, "opc03", 0 },	/* 03 */
	{ OPC_RES, "opc04", 0 },	/* 04 */
	{ OPC_RES, "opc05", 0 },	/* 05 */
	{ OPC_RES, "opc06", 0 },	/* 06 */
	{ OPC_RES, "opc07", 0 },	/* 07 */
	{ OPC_MEM, "lda", 1 },		/* 08 */
	{ OPC_MEM, "ldah", 1 },		/* 09 */
	{ OPC_RES, "opc0a", 0 },	/* 0A */
	{ OPC_MEM, "ldq_u", 1 },	/* 0B */
	{ OPC_RES, "opc0c", 0 },	/* 0C */
	{ OPC_RES, "opc0d", 0 },	/* 0D */
	{ OPC_RES, "opc0e", 0 },	/* 0E */
	{ OPC_MEM, "stq_u", 1 },	/* 0F */
	{ OPC_OP, "inta", 0 },		/* 10 */
	{ OPC_OP, "intl", 0 },		/* 11 */
	{ OPC_OP, "ints", 0 },		/* 12 */
	{ OPC_OP, "intm", 0 },		/* 13 */
	{ OPC_RES, "opc14", 0 },	/* 14 */
	{ OPC_OP, "fltv", 1 },		/* 15 */
	{ OPC_OP, "flti", 1 },		/* 16 */
	{ OPC_OP, "fltl", 1 },		/* 17 */
	{ OPC_MEM, "misc", 0 },		/* 18 */
	{ OPC_PAL, "pal19", 0 },	/* 19 */
	{ OPC_MEM, "jsr", 0 },		/* 1A */
	{ OPC_PAL, "pal1b", 0 },	/* 1B */
	{ OPC_RES, "opc1c", 0 },	/* 1C */
	{ OPC_PAL, "pal1d", 0 },	/* 1D */
	{ OPC_PAL, "pal1e", 0 },	/* 1E */
	{ OPC_PAL, "pal1f", 0 },	/* 1F */
	{ OPC_MEM, "ldf", 1 },		/* 20 */
	{ OPC_MEM, "ldg", 1 },		/* 21 */
	{ OPC_MEM, "lds", 1 },		/* 22 */
	{ OPC_MEM, "ldt", 1 },		/* 23 */
	{ OPC_MEM, "stf", 1 },		/* 24 */
	{ OPC_MEM, "stg", 1 },		/* 25 */
	{ OPC_MEM, "sts", 1 },		/* 26 */
	{ OPC_MEM, "stt", 1 },		/* 27 */
	{ OPC_MEM, "ldl", 1 },		/* 28 */
	{ OPC_MEM, "ldq", 1 },		/* 29 */
	{ OPC_MEM, "ldl_l", 1 },	/* 2A */
	{ OPC_MEM, "ldq_l", 1 },	/* 2B */
	{ OPC_MEM, "stl", 1 },		/* 2C */
	{ OPC_MEM, "stq", 1 },		/* 2D */
	{ OPC_MEM, "stl_c", 1 },	/* 2E */
	{ OPC_MEM, "stq_c", 1 },	/* 2F */
	{ OPC_BR, "br", 1 },		/* 30 */
	{ OPC_BR, "fbeq", 1 },		/* 31 */
	{ OPC_BR, "fblt", 1 },		/* 32 */
	{ OPC_BR, "fble", 1 },		/* 33 */
	{ OPC_BR, "bsr", 1 },		/* 34 */
	{ OPC_BR, "fbne", 1 },		/* 35 */
	{ OPC_BR, "fbge", 1 },		/* 36 */
	{ OPC_BR, "fbgt", 1 },		/* 37 */
	{ OPC_BR, "blbc", 1 },		/* 38 */
	{ OPC_BR, "beq", 1 },		/* 39 */
	{ OPC_BR, "blt", 1 },		/* 3A */
	{ OPC_BR, "ble", 1 },		/* 3B */
	{ OPC_BR, "blbs", 1 },		/* 3C */
	{ OPC_BR, "bne", 1 },		/* 3D */
	{ OPC_BR, "bge", 1 },		/* 3E */
	{ OPC_BR, "bgt", 1 },		/* 3F */
};

struct opinstr {
	char	*nam;
	u_char	opc;
	u_char	func;
} opinstr[] = {
	{ "addl",0x10,0x00 },	{ "subl",0x10,0x09 },	{ "cmpeq",0x10,0x2d },
	{ "addl/v",0x10,0x40 },	{ "subl/v",0x10,0x49 },	{ "cmplt",0x10,0x4d },
	{ "addq",0x10,0x20 },	{ "subq",0x10,0x29 },	{ "cmple",0x10,0x6d },
	{ "addq/v",0x10,0x60 },	{ "subq/v",0x10,0x69 },	{ "cmpult",0x10,0x1d },
	{ "cmpule",0x10,0x3d },
	{ "cmpbge",0x10,0x0f },

	{ "s4addl",0x10,0x02 },	{ "s4subl",0x10,0x0b },	{ "s8addl",0x10,0x12 },
	    { "s8subl",0x10,0x1b },
	{ "s4addq",0x10,0x22 },	{ "s4subq",0x10,0x2b },	{ "s8addq",0x10,0x32 },
	    { "s8subq",0x10,0x3b },

	{ "and",0x11,0x00 },	{ "bis",0x11,0x20 },	{ "xor",0x11,0x40 },
	{ "bic",0x11,0x08 },	{ "ornot",0x11,0x28 },	{ "eqv",0x11,0x48 },	
	{ "cmovq",0x11,0x24 },	{ "cmovlt",0x11,0x44 },	{ "cmovle",0x11,0x64 },	
	{ "cmovne",0x11,0x26 },	{ "cmovge",0x11,0x46 },	{ "cmovgt",0x11,0x66 },	
	{ "cmovbs",0x11,0x14 },	{ "cmovbc",0x11,0x16 },

	{ "sll",0x12,0x39 },	{ "sra",0x12,0x3c },	{ "srl",0x12,0x34 },
	{ "extbl",0x12,0x06 },	{ "insbl",0x12,0x0b },	{ "mskbl",0x12,0x02 },
	{ "extwl",0x12,0x16 },	{ "inswl",0x12,0x1b },	{ "mskwl",0x12,0x12 },
	{ "extll",0x12,0x26 },	{ "insll",0x12,0x2b },	{ "mskll",0x12,0x22 },
	{ "extql",0x12,0x36 },	{ "insql",0x12,0x3b },	{ "mskql",0x12,0x32 },
	{ "extwh",0x12,0x5a },	{ "inswh",0x12,0x57 },	{ "mskwh",0x12,0x52 },
	{ "extlh",0x12,0x6a },	{ "inslh",0x12,0x67 },	{ "msklh",0x12,0x62 },
	{ "extqh",0x12,0x7a },	{ "insqh",0x12,0x77 },	{ "mskqh",0x12,0x72 },
							{ "zap",0x12,0x30 },
							{ "zapnot",0x12,0x31 },

	{ "mull",0x13,0x00 },	{ "mull/v",0x13,0x40 },	{ "mulq",0x13,0x20 },
	{ "mulq/v",0x13,0x60 },	{ "umulh",0x13,0x30 },
};

char *jsrnam[] = {
	"jmp",
	"jsr",
	"ret",
	"jsr_coroutine"
};

char *regnam __P((int));

char *
regnam(r)
	int r;
{
	extern struct db_variable db_regs[];

	if (r == 31)
		return ("zero");
	return (db_regs[r].name);
d454 9
a462 10
vm_offset_t 
db_disasm(loc, flag)
	vm_offset_t loc;
	boolean_t flag;
{
	char rnam[8];
	u_int32_t ins = *(u_int32_t *)loc;
	int opc = ins >> 26;
	int arg = ins & 0x3ffffff;
	int ra, rb, rc, disp, func, imm;
d465 349
a813 7
	if (opcode[opc].opc_print)
		db_printf("%s\t", opcode[opc].opc_name);
	switch (opcode[opc].opc_fmt) {
	case OPC_PAL:
		switch (arg) {
		case 0x0000000:
			db_printf("halt");
d815 105
a919 10
		case 0x0000080:
			db_printf("bpt");
			break;
		case 0x0000086:
			db_printf("imb");
			break;
		default:
			db_printf("0x%08x", ins);
			break;
		}
d921 7
a927 2
	case OPC_RES:
		db_printf("0x%08x", ins);
d929 14
a942 19
	case OPC_MEM:
		ra = arg >> 21;
		rb = (arg >> 16) & 0x1f;
		disp = arg & 0xffff;
		switch (opc) {
		case 0x18:
			/* Memory fmt with a function code */
			switch (disp) {
			case 0x0000:
				db_printf("trapb");
				break;
			case 0x4000:
				db_printf("mb");
				break;
			case 0x8000:
				db_printf("fetch\t0(%s)", regnam(rb));
				break;
			case 0xa000:
				db_printf("fetch_m\t0($s)", regnam(rb));
d944 4
a947 2
			case 0xc000:
				db_printf("rpcc\t%s", regnam(ra));
d949 5
a953 5
			case 0xe000:
				db_printf("rc\t%s", regnam(ra));
				break;
			case 0xf000:
				db_printf("rs\t%s", regnam(ra));
d956 2
a957 2
				db_printf("0x%08x", ins);
			        break;
d959 16
d976 5
a980 7
		case 0x1a:
			db_printf("%s\t\t%s,(%s),0x%x", jsrnam[disp >> 14],
			    regnam(ra), regnam(rb), disp & 0x3fff);
			break;
		default:
			db_printf("\t%s,0x%x(%s)", regnam(ra), disp,
			    regnam(rb));
d984 69
a1052 40
	case OPC_OP:
		ra = arg >> 21;
		rb = (arg >> 16) & 0x1f;
		func = (arg >> 5) & 0x7f;
		imm = (arg >> 5) & 0x80;
		rc = arg & 0x1f;

		switch (opc) {
		case 0x11:
			if (func == 0x20 && imm == 0 && ra == 31 &&
			    rb == 31 && rc == 31) {
				db_printf("nop");
				break;
			}
			/*FALLTHROUGH*/
		case 0x10:
		case 0x12:
		case 0x13:
			if (imm)	/* literal */
				sprintf(rnam, "0x%x", (arg >> 13) & 0xff);
			else
				sprintf(rnam, "%s", regnam(rb));

			for (i = 0; i < sizeof opinstr/sizeof(opinstr[0]); i++)
				if (opinstr[i].opc == opc &&
				    opinstr[i].func == func)
					break;
			if (i != sizeof opinstr/sizeof(opinstr[0]))
				db_printf("%s\t\t%s,%s,%s",
				    opinstr[i].nam, regnam(ra), rnam,
				    regnam(rc));
			else 
				db_printf("%s\t\t0x%03x,%s,%s,%s",
				    opcode[opc].opc_name, func,
				    regnam(ra), rnam, regnam(rc));
			break;
		default:
			db_printf("0x%03x,%s,%s,%s", func, regnam(ra),
			    regnam(rb), regnam(rc));
			break;
d1055 25
a1079 8
	case OPC_BR:
		ra = arg >> 21;
		disp = arg & 0x1fffff;
		db_printf("\t%s,0x%x [", regnam(ra), disp);
		disp = (disp & 0x100000) ? -((-disp) & 0xfffff) << 2 :
		    (disp & 0xfffff) << 2;
		db_printsym(loc + sizeof (int) + disp, DB_STGY_PROC);
		db_printf("]");
d1081 20
d1103 1
a1103 1
	return (loc + sizeof (int));
@


1.12.10.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 28
/* $OpenBSD: db_disasm.c,v 1.14 2000/11/08 19:16:58 ericj Exp $ */
/* $NetBSD: db_disasm.c,v 1.8 2000/05/25 19:57:30 jhawk Exp $ */

/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
d4 2
a5 5
 *	File: db_disasm.c
 * 	Author: Alessandro Forin, Carnegie Mellon University
 *	Date:	11/91
 *
 *	Disassembler for Alpha
d7 14
a20 1
 *	Modified for NetBSD/alpha by:
d22 10
a31 9
 *	Christopher G. Demetriou, Carnegie Mellon University
 *
 *	Jason R. Thorpe, Numerical Aerospace Simulation Facility,
 *	NASA Ames Research Center
 *
 *	This code was derived exclusively from information available in
 *	"Alpha Architecture Reference Manual", Richard L. Sites ed.
 *	Digital Press, Burlington, MA 01803
 *	ISBN 1-55558-098-X, Order no. EY-L520E-DP
d36 3
a38 1
#include <sys/proc.h>
d40 1
a40 1
#include <alpha/alpha/db_instruction.h>
d42 3
a44 3
#include <machine/pal.h>
 
#include <ddb/db_access.h>
a45 78
#include <ddb/db_output.h>
#include <ddb/db_interface.h>

/*
 * This would belong in a header file, except noone else needs it
 *
 * XXX THESE SHOULD BE CONVERTED TO ra, rb, rc FORMAT.
 */
typedef union {
	/*
	 *	All instructions are 32 bits wide, PAL included
	 */
	unsigned int	bits;

	/*
	 *	Internal processor register access instrs
	 *	specify the IPR index, doubly specify the
	 *	(same) GP register as src/dest, and qualifiers
	 *	for the IPR set involved (abox/ibox/tmp)
	 */
	struct {
		unsigned	index : 5,
				regset : 3, /* a,i,p */
				xxx : 8,
				rs : 5,
				rd : 5,
				opcode : 6;
	} mXpr_format;

	/*
	 *	Load/store instructions have a 12 bit displacement,
	 *	and two register specifiers just as normal ld/st.
	 *	Four bits have special meanings:
	 *		phy: bypass the MMU (physical access)
	 *		alt: use mode in ALT register for checks,
	 *		     or if PHY is also on locked/linked access
	 *		rwc: read-with-write-check (probew)
	 *		qw:  quadword access
	 */
	struct {
		signed int	displacement : 12;
		unsigned	qw : 1,
				qualif : 3,
				rs : 5,
				rd : 5,
				opcode : 6;
	} mem_format;

	/*
	 *	Return from exception or interrupt has
	 *	a branch-like encoding, but only one
	 *	instantiation is actually usable.
	 */
	struct {
		unsigned	xxx : 14,
				zero : 1,	/* branch prediction! */
				one : 1,
				rb : 5,		/* r31 or stall */
				ra : 5,		/* r31 or stall */
				opcode : 6;
	} rei_format;

} pal_instruction;


/*
 * Major opcodes
 */
static char *op_name[64] = {
/* 0 */	"call_pal", "op1", "op2", "op3", "op4",	"op5",	"op6",	"op7",
/* 8 */	"lda",	"ldah",	"ldbu",	"ldq_u","ldwu",	"stw",	"stb",	"stq_u",
/*16 */	"arit",	"logical","bit","mul",	"op20",	"vaxf",	"ieeef","anyf",
/*24 */	"spec",	"hw_mfpr","jump","hw_ld","intmisc","hw_mtpr","hw_rei","hw_st",
/*32 */	"ldf",	"ldg",	"lds",	"ldt",	"stf",	"stg",	"sts",	"stt",
/*40 */	"ldl",	"ldq",	"ldl_l","ldq_l","stl",	"stq",	"stl_c","stq_c",
/*48 */	"br",	"fbeq",	"fblt",	"fble",	"bsr",	"fbne",	"fbge",	"fbgt",
/*56 */	"blbc",	"beq",	"blt",	"ble",	"blbs",	"bne",	"bge",	"bgt"
};
d47 123
a169 66
/*
 * The function field is too big (7 or 11 bits), so the sub-tables
 * are addressed in a somewhat complicated manner to save
 * space.  After all, alu operations is what RISCs are good at.
 */

struct tbl {
	const char	*name;
	int		code;
};

static const struct tbl pal_op_tbl[] = {
	/* Common PAL function codes. */
	{ "halt",		PAL_halt },
	{ "cflush",		PAL_cflush },
	{ "draina",		PAL_draina },
	{ "cserve",		PAL_cserve, },
	{ "swppal",		PAL_swppal },
	{ "ipir",		PAL_ipir },
	{ "bpt",		PAL_bpt },
	{ "bugchk",		PAL_bugchk },
	{ "imb",		PAL_imb },
	{ "rdunique",		PAL_rdunique },
	{ "wrunique",		PAL_wrunique },
	{ "gentrap",		PAL_gentrap },

	/* OSF/1 PAL function codes. */
	{ "osf1_rdmces",	PAL_OSF1_rdmces },
	{ "osf1_wrmces",	PAL_OSF1_wrmces },
	{ "osf1_wrfen",		PAL_OSF1_wrfen },
	{ "osf1_wrvptptr",	PAL_OSF1_wrvptptr },
	{ "osf1_swpctx",	PAL_OSF1_swpctx },
	{ "osf1_wrval",		PAL_OSF1_wrval },
	{ "osf1_rdval",		PAL_OSF1_rdval },
	{ "osf1_tbi",		PAL_OSF1_tbi },
	{ "osf1_wrent",		PAL_OSF1_wrent },
	{ "osf1_swpipl",	PAL_OSF1_swpipl },
	{ "osf1_rdps",		PAL_OSF1_rdps },
	{ "osf1_wrkgp",		PAL_OSF1_wrkgp },
	{ "osf1_wrusp",		PAL_OSF1_wrusp },
	{ "osf1_wrperfmon",	PAL_OSF1_wrperfmon },
	{ "osf1_rdusp",		PAL_OSF1_rdusp },
	{ "osf1_whami",		PAL_OSF1_whami },
	{ "osf1_retsys",	PAL_OSF1_retsys },
	{ "osf1_rti",		PAL_OSF1_rti },
	{ "osf1_callsys",	PAL_OSF1_callsys },

	{ NULL,			-1 },
};

static const char *pal_opname __P((int));

static const char *
pal_opname(op)
	int op;
{
	static char unk[8];
	int i;

	for (i = 0; pal_op_tbl[i].name != NULL; i++) {
		if (pal_op_tbl[i].code == op)
			return (pal_op_tbl[i].name);
	}

	sprintf(unk, "0x%x", op);
	return (unk);
d172 10
a181 257
/* HW (PAL) instruction qualifiers, stright tables */
static const char *mXpr_name[8] = {
	"", "/i", "/a", "/ai", "/p", "/pi", "/pa", "/pai"
};
static const char *hwlds_name[8] = {
	"", "/r", "/a", "/ar", "/p", "/p?r", "_l-c", "_l-c/?r"
};

/*
 * For this one we take the low nibble (valid values 0/2/9/b/d)
 * and shift it down one to get the row index.  Within a row
 * we can just take the high nibble deprived of the high bit
 * (valid values 0/1/2/3/4/6).  We could have used a flat 64
 * entry array, but in this way we use just 48 pointers.
 * BUGFIX: the 'cmpbge 0x0f' opcode fits in here too
 */
static const char *arit_c0[8] = {
	"addl", 0, "addq", 0, "addl/v", 0, "addq/v",
};
static const char *arit_c2[8] = {
	"s4addl", "s8addl", "s4addq", "s8addq", 
};
static const char *arit_c9[8] = {
	"subl", 0, "subq", 0, "subl/v", 0, "subq/v", 
};
static const char *arit_cB[8] = {
	"s4subl", "s8subl", "s4subq", "s8subq", 
};
static const char *arit_cD[8] = {
	0, "cmpult", "cmpeq", "cmpule", "cmplt", 0, "cmple",
};
static const char *arit_cF[1] = {
	"cmpbge"
};
static const char **arit_opname[8] = {
	arit_c0, arit_c2, 0, 0, arit_c9, arit_cB, arit_cD, arit_cF
};

static __inline const char *arit_name __P((int));
static __inline const char *
arit_name(op)
	int op;
{
	static char unk[32];
	const char *name = NULL;

	if (arit_opname[((op)&0xe)>>1])
		name = arit_opname[((op)&0xe)>>1][((op)&0x70)>>4];

	if (name != NULL)
		return (name);

	sprintf(unk, "?arit 0x%x?", op);
	return (unk);
}

/*
 * Something similar for this one, except there are only
 * 16 entries so the row indexing is done by enumeration
 * of the low nibble (valid values 0/4/6/8).  Then we can
 * just shift the high nibble to index inside the row
 * (valid values are 0/2/4 or 1/2/4/6)
 *
 * There are two functions that don't play by these simple rules,
 * so we special-case them.
 */
static const char *logical_c0[4] = {
	"and", "or", "xor", 0
};
static const char *logical_c4[4] = {
	"cmovlbs", "cmoveq", "cmovlt", "cmovle"
};
static const char *logical_c6[4] = {
	"cmovlbc", "cmovne", "cmovge", "cmovgt"
};
static const char *logical_c8[4] = {
	"andnot", "ornot", "xornot", 0
};

static __inline const char *logical_name __P((int));
static __inline const char *
logical_name(op)
	int op;
{
	static char unk[32];
	const char *name = NULL;

	if (op == op_amask)
		return ("amask");
	else if (op == op_implver)
		return ("implver");

	switch (op & 0xf) {
	case 0: name = logical_c0[((op)>>5)&3]; break;
	case 4: name = logical_c4[((op)>>5)&3]; break;
	case 6: name = logical_c6[((op)>>5)&3]; break;
	case 8: name = logical_c8[((op)>>5)&3]; break;
	}

	if (name != NULL)
		return (name);

	sprintf(unk, "?logical 0x%x?", op);
	return (unk);
}

/*
 * This is the messy one. First, we single out the dense
 * case of a 3 in the high nibble (valid values 0/1/2/4/6/9/b/c).
 * Then the case of a 2 in the low nibble (valid values 0/1/2/5/6/7).
 * For the remaining codes (6/7/a/b) we do as above: high
 * nibble has valid values 0/1/2 or 5/6/7.  The low nibble
 * can be used as row index picking bits 0 and 2, for the
 * high one just the lower two bits.
 */
static const char *bitop_c3[8] = {
	"zapnot", "mskql", "srl", "extql", "sll", "insql", "sra", 0
};
static const char *bitop_c2[8] = {
	"mskbl", "mskwl", "mskll", 0/*mskql*/, 0, "mskwh", "msklh", "mskqh"
};
static const char *bitop_c67ab[4][4] = {
/* a */	{ 0, "extwh", "extlh", "extqh"},
/* b */	{ "insbl", "inswl", "insll", 0 },
/* 6 */	{ "extbl", "extwl", "extll", 0 },
/* 7 */	{ 0, "inswh", "inslh", "insqh" },
};

static __inline const char *bitop_name __P((int));
static __inline const char *
bitop_name(op)
	int op;
{
	static char unk[32];
	const char *name = NULL;

	if ((op & 0x70) == 0x30)
		name = (op == op_zap) ? "zap" : bitop_c3[((op)&0xe)>>1];
	else if ((op & 0xf) == 0x02)
		name = bitop_c2[(op)>>4];
	else
		name =
		    bitop_c67ab[(((op)&1)|(((op)&0x4)>>1))][(((op)&0x30)>>4)];

	if (name != NULL)
		return (name);

	sprintf(unk, "?bit 0x%x?", op);
	return (unk);
}

/*
 * Only 5 entries in this one
 */
static const char *mul_opname[4] = {
	"mull", "mulq", "mull/v", "mulq/v"
};

static __inline const char *mul_name __P((int));
static __inline const char *
mul_name(op)
	int op;
{
	static char unk[32];
	const char *name = NULL;

	name = (op == op_umulh) ? "umulh" : mul_opname[((op)>>5)&3];

	if (name != NULL)
		return (name);

	sprintf(unk, "?mul 0x%x?", op);
	return (unk);
}

/*
 * These are few, the high nibble is usually enough to dispatch.
 * We single out the `f' case to halve the table size, as
 * well as the cases in which the high nibble isn't enough.
 */
static const char *special_opname[8] = {
	"trapb", 0, "mb", 0, "fetch", "fetch_m", "rpcc", "rc"
};

static __inline const char *special_name __P((int));
static __inline const char *
special_name(op)
	int op;
{
	static char unk[32];
	const char *name;

	switch (op) {
	case op_excb:		name = "excb";		break;
	case op_wmb:		name = "wmb";		break;
	case op_ecb:		name = "ecb";		break;
	case op_rs:		name = "rs";		break;
	case op_wh64:		name = "wh64";		break;
	default:
		name = special_opname[(op)>>13];
	}

	if (name != NULL)
		return (name);

	sprintf(unk, "?special 0x%x?", op);
	return (unk);
}

/*
 * This is trivial
 */
static const char *jump_opname[4] = {
	"jmp", "jsr", "ret", "jcr"
};
#define jump_name(ix)	jump_opname[ix]

/*
 * For all but 4 of these, we can dispatch on the lower nibble of
 * the "function".
 */
static const char *intmisc_opname_3x[16] = {
	"ctpop", "perr", "ctlz", "cttz", "unpkbw", "unpkbl", "pkwb",
	"pklb", "minsb8", "minsw4", "minub8", "minuw4", "maxub8",
	"maxuw4", "maxsb8", "maxsw4",
};

static __inline const char *intmisc_name __P((int));
static __inline const char *
intmisc_name(op)
	int op;
{
	static char unk[32];

	if ((op & 0xf0) == 0x30)
		return (intmisc_opname_3x[op & 0x0f]);

	switch (op) {
	case op_sextb: return ("sextb");
	case op_sextw: return ("sextw");
	case op_ftoit: return ("ftoit");
	case op_ftois: return ("ftois");
	}

	sprintf(unk, "?intmisc 0x%x?", op);
	return (unk);
}

static const char *float_name __P((const struct tbl[], int, const char *type));

static const char *
float_name(tbl, op, type)
	const struct tbl tbl[];
	int op;
	const char *type;
{
	static char unk[32];
d184 16
a199 349
	for (i = 0; tbl[i].name != NULL; i++) {
		if (tbl[i].code == op)
			return (tbl[i].name);
	}

	sprintf(unk, "?%s 0x%x?", type, op);
	return (unk);
}

#define vaxf_name(op)	float_name(vaxf_tbl, op, "vaxfl")
#define ieeef_name(op)	float_name(ieeef_tbl, op, "ieeefl")
#define anyf_name(op)	float_name(anyf_tbl, op, "anyfl")

static const struct tbl anyf_tbl[] = {
	{ "cvtlq",	0x010},
	{ "cpys",	0x020},
	{ "cpysn",	0x021},
	{ "cpyse",	0x022},
	{ "mt_fpcr",	0x024},
	{ "mf_fpcr",	0x025},
	{ "fcmoveq",	0x02a},
	{ "fcmovne",	0x02b},
	{ "fcmovlt",	0x02c},
	{ "fcmovge",	0x02d},
	{ "fcmovle",	0x02e},
	{ "fcmovgt",	0x02f},
	{ "cvtql",	0x030},
	{ "cvtql/v",	0x130},
	{ "cvtql/sv",	0x330},
	{ 0, 0},
};

static const struct tbl ieeef_tbl[] = {
	{ "adds/c",	0x000},
	{ "subs/c",	0x001},
	{ "muls/c",	0x002},
	{ "divs/c",	0x003},
	{ "addt/c",	0x020},
	{ "subt/c",	0x021},
	{ "mult/c",	0x022},
	{ "divt/c",	0x023},
	{ "cvtts/c",	0x02c},
	{ "cvttq/c",	0x02f},
	{ "cvtqs/c",	0x03c},
	{ "cvtqt/c",	0x03e},
	{ "adds/m",	0x040},
	{ "subs/m",	0x041},
	{ "muls/m",	0x042},
	{ "divs/m",	0x043},
	{ "addt/m",	0x060},
	{ "subt/m",	0x061},
	{ "mult/m",	0x062},
	{ "divt/m",	0x063},
	{ "cvtts/m",	0x06c},
	{ "cvtqs/m",	0x07c},
	{ "cvtqt/m",	0x07e},
	{ "adds",	0x080},
	{ "subs",	0x081},
	{ "muls",	0x082},
	{ "divs",	0x083},
	{ "addt",	0x0a0},
	{ "subt",	0x0a1},
	{ "mult",	0x0a2},
	{ "divt",	0x0a3},
	{ "cmptun",	0x0a4},
	{ "cmpteq",	0x0a5},
	{ "cmptlt",	0x0a6},
	{ "cmptle",	0x0a7},
	{ "cvtts",	0x0ac},
	{ "cvttq",	0x0af},
	{ "cvtqs",	0x0bc},
	{ "cvtqt",	0x0be},
	{ "adds/d",	0x0c0},
	{ "subs/d",	0x0c1},
	{ "muls/d",	0x0c2},
	{ "divs/d",	0x0c3},
	{ "addt/d",	0x0e0},
	{ "subt/d",	0x0e1},
	{ "mult/d",	0x0e2},
	{ "divt/d",	0x0e3},
	{ "cvtts/d",	0x0ec},
	{ "cvtqs/d",	0x0fc},
	{ "cvtqt/d",	0x0fe},
	{ "adds/uc",	0x100},
	{ "subs/uc",	0x101},
	{ "muls/uc",	0x102},
	{ "divs/uc",	0x103},
	{ "addt/uc",	0x120},
	{ "subt/uc",	0x121},
	{ "mult/uc",	0x122},
	{ "divt/uc",	0x123},
	{ "cvtts/uc",	0x12c},
	{ "cvttq/vc",	0x12f},
	{ "adds/um",	0x140},
	{ "subs/um",	0x141},
	{ "muls/um",	0x142},
	{ "divs/um",	0x143},
	{ "addt/um",	0x160},
	{ "subt/um",	0x161},
	{ "mult/um",	0x162},
	{ "divt/um",	0x163},
	{ "cvtts/um",	0x16c},
	{ "adds/u",	0x180},
	{ "subs/u",	0x181},
	{ "muls/u",	0x182},
	{ "divs/u",	0x183},
	{ "addt/u",	0x1a0},
	{ "subt/u",	0x1a1},
	{ "mult/u",	0x1a2},
	{ "divt/u",	0x1a3},
	{ "cvtts/u",	0x1ac},
	{ "cvttq/v",	0x1af},
	{ "adds/ud",	0x1c0},
	{ "subs/ud",	0x1c1},
	{ "muls/ud",	0x1c2},
	{ "divs/ud",	0x1c3},
	{ "addt/ud",	0x1e0},
	{ "subt/ud",	0x1e1},
	{ "mult/ud",	0x1e2},
	{ "divt/ud",	0x1e3},
	{ "cvtts/ud",	0x1ec},
	{ "adds/suc",	0x500},
	{ "subs/suc",	0x501},
	{ "muls/suc",	0x502},
	{ "divs/suc",	0x503},
	{ "addt/suc",	0x520},
	{ "subt/suc",	0x521},
	{ "mult/suc",	0x522},
	{ "divt/suc",	0x523},
	{ "cvtts/suc",	0x52c},
	{ "cvttq/svc",	0x52f},
	{ "adds/sum",	0x540},
	{ "subs/sum",	0x541},
	{ "muls/sum",	0x542},
	{ "divs/sum",	0x543},
	{ "addt/sum",	0x560},
	{ "subt/sum",	0x561},
	{ "mult/sum",	0x562},
	{ "divt/sum",	0x563},
	{ "cvtts/sum",	0x56c},
	{ "adds/su",	0x580},
	{ "subs/su",	0x581},
	{ "muls/su",	0x582},
	{ "divs/su",	0x583},
	{ "addt/su",	0x5a0},
	{ "subt/su",	0x5a1},
	{ "mult/su",	0x5a2},
	{ "divt/su",	0x5a3},
	{ "cmptun/su",	0x5a4},
	{ "cmpteq/su",	0x5a5},
	{ "cmptlt/su",	0x5a6},
	{ "cmptle/su",	0x5a7},
	{ "cvtts/su",	0x5ac},
	{ "cvttq/sv",	0x5af},
	{ "adds/sud",	0x5c0},
	{ "subs/sud",	0x5c1},
	{ "muls/sud",	0x5c2},
	{ "divs/sud",	0x5c3},
	{ "addt/sud",	0x5e0},
	{ "subt/sud",	0x5e1},
	{ "mult/sud",	0x5e2},
	{ "divt/sud",	0x5e3},
	{ "cvtts/sud",	0x5ec},
	{ "adds/suic",	0x700},
	{ "subs/suic",	0x701},
	{ "muls/suic",	0x702},
	{ "divs/suic",	0x703},
	{ "addt/suic",	0x720},
	{ "subt/suic",	0x721},
	{ "mult/suic",	0x722},
	{ "divt/suic",	0x723},
	{ "cvtts/suic",	0x72c},
	{ "cvttq/svic",	0x72f},
	{ "cvtqs/suic",	0x73c},
	{ "cvtqt/suic",	0x73e},
	{ "adds/suim",	0x740},
	{ "subs/suim",	0x741},
	{ "muls/suim",	0x742},
	{ "divs/suim",	0x743},
	{ "addt/suim",	0x760},
	{ "subt/suim",	0x761},
	{ "mult/suim",	0x762},
	{ "divt/suim",	0x763},
	{ "cvtts/suim",	0x76c},
	{ "cvtqs/suim",	0x77c},
	{ "cvtqt/suim",	0x77e},
	{ "adds/sui",	0x780},
	{ "subs/sui",	0x781},
	{ "muls/sui",	0x782},
	{ "divs/sui",	0x783},
	{ "addt/sui",	0x7a0},
	{ "subt/sui",	0x7a1},
	{ "mult/sui",	0x7a2},
	{ "divt/sui",	0x7a3},
	{ "cvtts/sui",	0x7ac},
	{ "cvttq/svi",	0x7af},
	{ "cvtqs/sui",	0x7bc},
	{ "cvtqt/sui",	0x7be},
	{ "adds/suid",	0x7c0},
	{ "subs/suid",	0x7c1},
	{ "muls/suid",	0x7c2},
	{ "divs/suid",	0x7c3},
	{ "addt/suid",	0x7e0},
	{ "subt/suid",	0x7e1},
	{ "mult/suid",	0x7e2},
	{ "divt/suid",	0x7e3},
	{ "cvtts/suid",	0x7ec},
	{ "cvtqs/suid",	0x7fc},
	{ "cvtqt/suid",	0x7fe},
	{ 0, 0}
};

static const struct tbl vaxf_tbl[] = {
	{ "addf/c",	0x000},
	{ "subf/c",	0x001},
	{ "mulf/c",	0x002},
	{ "divf/c",	0x003},
	{ "cvtdg/c",	0x01e},
	{ "addg/c",	0x020},
	{ "subg/c",	0x021},
	{ "mulg/c",	0x022},
	{ "divg/c",	0x023},
	{ "cvtgf/c",	0x02c},
	{ "cvtgd/c",	0x02d},
	{ "cvtgq/c",	0x02f},
	{ "cvtqf/c",	0x03c},
	{ "cvtqg/c",	0x03e},
	{ "addf",	0x080},
	{ "subf",	0x081},
	{ "mulf",	0x082},
	{ "divf",	0x083},
	{ "cvtdg",	0x09e},
	{ "addg",	0x0a0},
	{ "subg",	0x0a1},
	{ "mulg",	0x0a2},
	{ "divg",	0x0a3},
	{ "cmpgeq",	0x0a5},
	{ "cmpglt",	0x0a6},
	{ "cmpgle",	0x0a7},
	{ "cvtgf",	0x0ac},
	{ "cvtgd",	0x0ad},
	{ "cvtgq",	0x0af},
	{ "cvtqf",	0x0bc},
	{ "cvtqg",	0x0be},
	{ "addf/uc",	0x100},
	{ "subf/uc",	0x101},
	{ "mulf/uc",	0x102},
	{ "divf/uc",	0x103},
	{ "cvtdg/uc",	0x11e},
	{ "addg/uc",	0x120},
	{ "subg/uc",	0x121},
	{ "mulg/uc",	0x122},
	{ "divg/uc",	0x123},
	{ "cvtgf/uc",	0x12c},
	{ "cvtgd/uc",	0x12d},
	{ "cvtgq/vc",	0x12f},
	{ "addf/u",	0x180},
	{ "subf/u",	0x181},
	{ "mulf/u",	0x182},
	{ "divf/u",	0x183},
	{ "cvtdg/u",	0x19e},
	{ "addg/u",	0x1a0},
	{ "subg/u",	0x1a1},
	{ "mulg/u",	0x1a2},
	{ "divg/u",	0x1a3},
	{ "cvtgf/u",	0x1ac},
	{ "cvtgd/u",	0x1ad},
	{ "cvtgq/v",	0x1af},
	{ "addf/sc",	0x400},
	{ "subf/sc",	0x401},
	{ "mulf/sc",	0x402},
	{ "divf/sc",	0x403},
	{ "cvtdg/sc",	0x41e},
	{ "addg/sc",	0x420},
	{ "subg/sc",	0x421},
	{ "mulg/sc",	0x422},
	{ "divg/sc",	0x423},
	{ "cvtgf/sc",	0x42c},
	{ "cvtgd/sc",	0x42d},
	{ "cvtgq/sc",	0x42f},
	{ "cvtqf/sc",	0x43c},
	{ "cvtqg/sc",	0x43e},
	{ "addf/s",	0x480},
	{ "subf/s",	0x481},
	{ "mulf/s",	0x482},
	{ "divf/s",	0x483},
	{ "cvtdg/s",	0x49e},
	{ "addg/s",	0x4a0},
	{ "subg/s",	0x4a1},
	{ "mulg/s",	0x4a2},
	{ "divg/s",	0x4a3},
	{ "cmpgeq/s",	0x4a5},
	{ "cmpglt/s",	0x4a6},
	{ "cmpgle/s",	0x4a7},
	{ "cvtgf/s",	0x4ac},
	{ "cvtgd/s",	0x4ad},
	{ "cvtgq/s",	0x4af},
	{ "cvtqf/s",	0x4bc},
	{ "cvtqg/s",	0x4be},
	{ "addf/suc",	0x500},
	{ "subf/suc",	0x501},
	{ "mulf/suc",	0x502},
	{ "divf/suc",	0x503},
	{ "cvtdg/suc",	0x51e},
	{ "addg/suc",	0x520},
	{ "subg/suc",	0x521},
	{ "mulg/suc",	0x522},
	{ "divg/suc",	0x523},
	{ "cvtgf/suc",	0x52c},
	{ "cvtgd/suc",	0x52d},
	{ "cvtgq/svc",	0x52f},
	{ "addf/su",	0x580},
	{ "subf/su",	0x581},
	{ "mulf/su",	0x582},
	{ "divf/su",	0x583},
	{ "cvtdg/su",	0x59e},
	{ "addg/su",	0x5a0},
	{ "subg/su",	0x5a1},
	{ "mulg/su",	0x5a2},
	{ "divg/su",	0x5a3},
	{ "cvtgf/su",	0x5ac},
	{ "cvtgd/su",	0x5ad},
	{ "cvtgq/sv",	0x5af},
	{ 0, 0}
};

/*
 * General purpose registers
 */
static const char *name_of_register[32] = {
	"v0",	"t0",	"t1",	"t2",	"t3",	"t4",	"t5",	"t6",
	"t7",	"s0",	"s1",	"s2",	"s3",	"s4",	"s5",	"s6",
	"a0",	"a1",	"a2",	"a3",	"a4",	"a5",	"t8",	"t9",
	"t10",	"t11",	"ra",	"pv",	"at",	"gp",	"sp",	"zero"
};

static int regcount;		/* how many regs used in this inst */
static int regnum[3];		/* which regs used in this inst */

static const char *register_name __P((int));

static const char *
register_name (ireg)
	int ireg;
{
	int	i;

	for (i = 0; i < regcount; i++)
		if (regnum[i] == ireg)
d201 1
a201 49
	if (i >= regcount)
		regnum[regcount++] = ireg;
	return (name_of_register[ireg]);
}

/*
 * Disassemble instruction at 'loc'.  'altfmt' specifies an
 * (optional) alternate format.  Return address of start of
 * next instruction.
 */
int	alpha_print_instruction __P((db_addr_t, alpha_instruction, boolean_t));

db_addr_t
db_disasm(loc, altfmt)
	db_addr_t	loc;
	boolean_t	altfmt;
{
	alpha_instruction inst;

	inst.bits = db_get_value(loc, 4, 0);

	loc += alpha_print_instruction(loc, inst, altfmt);
	return (loc);
}

int
alpha_print_instruction(iadr, i, showregs)
	db_addr_t	iadr;
	alpha_instruction i;
	boolean_t	showregs;
{
	const char	*opcode;
	int		ireg;
	long		signed_immediate;
	boolean_t	fstore;
	pal_instruction	p;

	regcount = 0;
	fstore = FALSE;
	opcode = op_name[i.mem_format.opcode];

	/*
	 *	Dispatch directly on the opcode, save code
	 *	duplication sometimes via "harmless gotos".
	 */
	switch (i.mem_format.opcode) {
	case op_pal:
		/* "call_pal" is a long string; just use a space. */
		db_printf("%s %s", opcode, pal_opname(i.pal_format.function));
d203 2
a204 14
	case op_lda:
	case op_ldah:
	case op_ldbu:
	case op_ldq_u:
	case op_ldwu:
	case op_stw:
	case op_stb:
	case op_stq_u:
		/*
		 * These loadstores are here to make compiling the
		 * switch a bit easier.  Could embellish the output
		 * someday, too.
		 */
		goto loadstore;
d206 22
a227 63
	case op_arit:
		/*
		 * For this and the following three groups we
		 * just need different opcode strings
		 */
		opcode = arit_name(i.operate_lit_format.function);
		goto operate;
		break;
	case op_logical:
		opcode = logical_name(i.operate_lit_format.function);
		goto operate;
		break;
	case op_bit:
		opcode = bitop_name(i.operate_lit_format.function);
		goto operate;
		break;
	case op_mul:
		opcode = mul_name(i.operate_lit_format.function);
operate:
		/*
		 * Nice and uniform, just check for literals
		 */
		db_printf("%s\t%s,", opcode,
		    register_name(i.operate_lit_format.ra));
		if (i.operate_lit_format.one)
			db_printf("#0x%x", i.operate_lit_format.literal);
		else
			db_printf("%s", register_name(i.operate_reg_format.rb));
		db_printf(",%s", register_name(i.operate_lit_format.rc));
		break;
	case op_vax_float:
		/*
		 * The three floating point groups are even simpler
		 */
		opcode = vaxf_name(i.float_format.function);
		goto foperate;
		break;
	case op_ieee_float:
		opcode = ieeef_name(i.float_format.function);
		goto foperate;
		break;
	case op_any_float:
		opcode = anyf_name(i.float_format.function);
foperate:
		db_printf("%s\tf%d,f%d,f%d", opcode,
			i.float_format.fa,
			i.float_format.fb,
			i.float_format.fc);
		break;
	case op_special:
		/*
		 * Miscellaneous.
		 */
		{
			register unsigned int code;

			code = (i.mem_format.displacement)&0xffff;
			opcode = special_name(code);

			switch (code) {
			case op_ecb:
				db_printf("%s\t(%s)", opcode,
					register_name(i.mem_format.rb));
d229 2
a230 4
			case op_fetch:
			case op_fetch_m:
				db_printf("%s\t0(%s)", opcode,
					register_name(i.mem_format.rb));
d232 2
a233 5
			case op_rpcc:
			case op_rc:
			case op_rs:
				db_printf("%s\t%s", opcode,
					register_name(i.mem_format.ra));
d236 11
a246 1
				db_printf("%s", opcode);
a247 1
			}
d250 35
a284 14
	case op_j:
		/*
		 * Jump instructions really are of two sorts,
		 * depending on the use of the hint info.
		 */
		opcode = jump_name(i.jump_format.action);
		switch (i.jump_format.action) {
		case op_jmp:
		case op_jsr:
			db_printf("%s\t%s,(%s),", opcode,
				register_name(i.jump_format.ra),
				register_name(i.jump_format.rb));
			signed_immediate = i.jump_format.hint;
			goto branch_displacement;
d286 3
a288 5
		case op_ret:
		case op_jcr:
			db_printf("%s\t%s,(%s)", opcode,
				register_name(i.jump_format.ra),
				register_name(i.jump_format.rb));
d292 8
a299 28
	case op_intmisc:
		/*
		 * These are just in "operate" format.
		 */
		opcode = intmisc_name(i.operate_lit_format.function);
		goto operate;
		break;
			/* HW instructions, possibly chip-specific XXXX */
	case op_pal19:	/* "hw_mfpr" */
	case op_pal1d:	/* "hw_mtpr" */
		p.bits = i.bits;
		db_printf("\t%s%s\t%s, %d", opcode,
			mXpr_name[p.mXpr_format.regset],
			register_name(p.mXpr_format.rd),
			p.mXpr_format.index);
		break;
	case op_pal1b:	/* "hw_ld" */
	case op_pal1f:	/* "hw_st" */
		p.bits = i.bits;
		db_printf("\t%s%c%s\t%s,", opcode,
			(p.mem_format.qw) ? 'q' : 'l',
			hwlds_name[p.mem_format.qualif],
			register_name(p.mem_format.rd));
		signed_immediate = (long)p.mem_format.displacement;
		goto loadstore_address;

	case op_pal1e:	/* "hw_rei" */
		db_printf("\t%s", opcode);
a300 88

	case op_ldf:
	case op_ldg:
	case op_lds:
	case op_ldt:
	case op_stf:
	case op_stg:
	case op_sts:
	case op_stt:
		fstore = TRUE;
		/* fall through */
	case op_ldl:
	case op_ldq:
	case op_ldl_l:
	case op_ldq_l:
	case op_stl:
	case op_stq:
	case op_stl_c:
	case op_stq_c:
		/*
		 * Memory operations, including floats
		 */
loadstore:
		if (fstore)
		    db_printf("%s\tf%d,", opcode, i.mem_format.ra);
		else
		    db_printf("%s\t%s,", opcode,
		        register_name(i.mem_format.ra));
		signed_immediate = (long)i.mem_format.displacement;
loadstore_address:
		db_printf("%lz(%s)", signed_immediate,
			register_name(i.mem_format.rb));
		/*
		 * For convenience, do the address computation
		 */
		if (showregs) {
			if (i.mem_format.opcode == op_ldah)
				signed_immediate <<= 16;
			db_printf(" <0x%lx>", signed_immediate +
			    db_register_value(DDB_REGS, i.mem_format.rb));
		}
		break;
	case op_br:
	case op_fbeq:
	case op_fblt:
	case op_fble:
	case op_bsr:
	case op_fbne:
	case op_fbge:
	case op_fbgt:
	case op_blbc:
	case op_beq:
	case op_blt:
	case op_ble:
	case op_blbs:
	case op_bne:
	case op_bge:
	case op_bgt:
		/*
		 * We want to know where we are branching to
		 */
		signed_immediate = (long)i.branch_format.displacement;
		db_printf("%s\t%s,", opcode,
			  register_name(i.branch_format.ra));
branch_displacement:
		db_printsym(iadr + sizeof(alpha_instruction) +
		    (signed_immediate << 2), DB_STGY_PROC);
		break;
	default:
		/*
		 * Shouldn't happen
		 */
		db_printf("? 0x%x ?", i.bits);
	}

	/*
	 *	Print out the registers used in this instruction
	 */
	if (showregs && regcount > 0) {
		db_printf("\t<");
		for (ireg = 0; ireg < regcount; ireg++) {
			if (ireg != 0)
				db_printf(",");
			db_printf("%s=0x%lx",
			    name_of_register[regnum[ireg]],
			    db_register_value(DDB_REGS, regnum[ireg]));
		}
		db_printf(">");
d303 1
a303 1
	return (sizeof(alpha_instruction));
@


1.12.10.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d189 1
a189 1
static const char *pal_opname(int);
d245 1
a245 1
static __inline const char *arit_name(int);
d286 1
a286 1
static __inline const char *logical_name(int);
d335 1
a335 1
static __inline const char *bitop_name(int);
d365 1
a365 1
static __inline const char *mul_name(int);
d391 1
a391 1
static __inline const char *special_name(int);
d434 1
a434 1
static __inline const char *intmisc_name(int);
d455 1
a455 1
static const char *float_name(const struct tbl[], int, const char *type);
d805 1
a805 1
static const char *register_name(int);
d826 1
a826 1
int	alpha_print_instruction(db_addr_t, alpha_instruction, boolean_t);
@


1.12.10.3
log
@Sync the SMP branch with 3.3
@
text
@d1080 1
a1080 1
		    (signed_immediate << 2), DB_STGY_PROC, db_printf);
@


1.12.10.4
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/* $OpenBSD: db_disasm.c,v 1.12.10.3 2003/03/27 22:29:47 niklas Exp $ */
d203 1
a203 1
	snprintf(unk, sizeof unk, "0x%x", op);
d259 1
a259 1
	snprintf(unk, sizeof unk, "?arit 0x%x?", op);
d309 1
a309 1
	snprintf(unk, sizeof unk, "?logical 0x%x?", op);
d354 1
a354 1
	snprintf(unk, sizeof unk, "?bit 0x%x?", op);
d378 1
a378 1
	snprintf(unk, sizeof unk, "?mul 0x%x?", op);
d412 1
a412 1
	snprintf(unk, sizeof unk, "?special 0x%x?", op);
d451 1
a451 1
	snprintf(unk, sizeof unk, "?intmisc 0x%x?", op);
d471 1
a471 1
	snprintf(unk, sizeof unk, "?%s 0x%x?", type, op);
@


1.11
log
@Correct literal extraction.  Provide symbolic targets in branches.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.10 1997/07/19 20:56:53 niklas Exp $	*/
d34 1
a34 1
#include <sys/types.h>
@


1.10
log
@struct opcode is now in db_machdep.h.  Add some other includes needed after
the db_machdep.h rewrite.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.9 1997/07/09 14:29:03 deraadt Exp $	*/
d45 1
d269 1
a269 1
				sprintf(rnam, "0x%x", (arg >> 12) & 0xff);
d295 5
a299 1
		db_printf("\t%s,0x%x", regnam(ra), disp);
d303 1
a303 1
	return (loc + 4);
@


1.9
log
@copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.8 1997/07/09 10:26:39 deraadt Exp $	*/
d37 2
d40 1
d46 1
a46 5
static struct opcode {
	enum opc_fmt { OPC_PAL, OPC_RES, OPC_MEM, OPC_OP, OPC_BR } opc_fmt;
	char *opc_name;
	int opc_print;
} opcode[] = {
@


1.8
log
@do literal mode nicely. ddb now rocks. now we need working traceback
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.7 1997/07/09 09:08:03 deraadt Exp $	*/
d5 1
d17 2
a18 1
 *	This product includes software developed by Niklas Hallqvist.
@


1.7
log
@decode integer instructions, or at least the ones i have documentation for
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.6 1997/07/09 08:11:39 deraadt Exp $	*/
d113 3
a115 2
	char *nam;
	u_int id;
d117 28
a144 42
	{ "addl", 0x1000 },	{ "subl", 0x1009 },	{ "cmpeq", 0x102d },
	{ "addl/v", 0x1040 },	{ "subl/v", 0x1049 },	{ "cmplt", 0x104d },
	{ "addq", 0x1020 }, 	{ "subq", 0x1029 },	{ "cmple", 0x106d },
	{ "addq/v", 0x1060 },	{ "subq/v", 0x1069 },	{ "cmpult", 0x101d },
	{ "cmpule", 0x103d },
	{ "cmpbge", 0x100f },

	{ "s4addl", 0x1002 },	{ "s4subl", 0x100b },	{ "s8addl", 0x1012 },
	    { "s8subl", 0x101b },
	{ "s4addq", 0x1022 },	{ "s4subq", 0x102b },	{ "s8addq", 0x1032 },
	    { "s8subq", 0x103b },

	{ "and", 0x1100 },	{ "bis", 0x1120 },	{ "xor", 0x1140 },
	{ "bic", 0x1108 },	{ "ornot", 0x1128 },	{ "eqv", 0x1148 },	
	{ "cmovq", 0x1124 },	{ "cmovlt", 0x1144 },	{ "cmovle", 0x1164 },	
	{ "cmovne", 0x1126 },	{ "cmovge", 0x1146 },	{ "cmovgt", 0x1166 },	
	{ "cmovbs", 0x1114 },	{ "cmovbc", 0x1116 },

	{ "sll", 0x1239 },	{ "sra", 0x123c },	{ "srl", 0x1234 },
	{ "extbl", 0x1206 },	{ "insbl", 0x120b },	{ "mskbl", 0x1202 },
	{ "extwl", 0x1216 },	{ "inswl", 0x121b },	{ "mskwl", 0x1212 },
	{ "extll", 0x1226 },	{ "insll", 0x122b },	{ "mskll", 0x1222 },
	{ "extql", 0x1236 },	{ "insql", 0x123b },	{ "mskql", 0x1232 },
	{ "extwh", 0x125a },	{ "inswh", 0x1257 },	{ "mskwh", 0x1252 },
	{ "extlh", 0x126a },	{ "inslh", 0x1267 },	{ "msklh", 0x1262 },
	{ "extqh", 0x127a },	{ "insqh", 0x1277 },	{ "mskqh", 0x1272 },
							{ "zap", 0x1230 },
							{ "zapnot", 0x1231 },

	{ "mull", 0x1300 },	{ "mull/v", 0x1340 },	{ "mulq", 0x1320 },
	{ "mulq/v", 0x1360 },	{ "umulh", 0x1330 },

#if 0
	{ "cpys", 0x020 },	{ "cpysn", 0x021 },	{ "cpyse", 0x022 },
	{ "mf_fpcr", 0x025 },	{ "mt_fpcr", 0x024 },	{ "cvtql/sv", 0x530 },
	{ "cvtlq", 0x010 },	{ "cvtql", 0x030 },	{ "cvtql/v", 0x130 },
	{ "fcmoveq", 0x02a },	{ "fcmovlt", 0x02c },	{ "fcmovle", 0x02e },
	{ "fcmovne", 0x02b },	{ "fcmovge", 0x02d },	{ "fcmovgt", 0x02f },

	....

#endif
d146 2
d175 1
d179 1
a179 2
	int ra, rb, rc, disp, func;
	u_int opcfunc;
d197 1
a197 1
			db_printf("%08x", ins);
d234 1
a234 1
				db_printf("%08x", ins);
d251 2
a252 1
		func = (arg >> 5) & 0x7ff;
a253 1
		opcfunc = (opc << 8) | func;
d256 7
a263 1
		case 0x11:
d266 5
d272 2
a273 1
				if (opinstr[i].id == opcfunc)
d275 1
a275 5
			if (i == sizeof opinstr/sizeof(opinstr[0]))
				db_printf("%s\t\t%03x,%s,%s,%s",
				    opcode[opc].opc_name, func,
				    regnam(ra), regnam(rb), regnam(rc), opcfunc);
			else
d277 1
a277 1
				    opinstr[i].nam, regnam(ra), regnam(rb),
d279 4
d285 1
a285 1
			db_printf("%03x,%s,%s,%s", func, regnam(ra),
@


1.6
log
@print registers by name, not number
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.5 1997/07/09 02:57:28 deraadt Exp $	*/
d62 4
a65 4
	{ OPC_OP, "inta", 1 },		/* 10 */
	{ OPC_OP, "intl", 1 },		/* 11 */
	{ OPC_OP, "ints", 1 },		/* 12 */
	{ OPC_OP, "intm", 1 },		/* 13 */
d112 49
d176 2
d190 2
d264 24
a287 2
		db_printf("\t%02x,%s,%s,%s", func, regnam(ra), regnam(rb),
		    regnam(rc));
@


1.5
log
@simplify code
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.4 1997/07/08 21:55:39 niklas Exp $	*/
d38 1
d112 17
a128 1
char *jsr_names[] = { "jmp", "jsr", "ret", "jsr_coroutine" };
d177 1
a177 1
				db_printf("fetch\t0($%d)", rb);
d180 1
a180 1
				db_printf("fetch_m\t0($%d)", rb);
d183 1
a183 1
				db_printf("rpcc\t$%d", ra);
d186 1
a186 1
				db_printf("rc\t$%d", ra);
d189 1
a189 1
				db_printf("rs\t$%d", ra);
d197 2
a198 2
			db_printf("%s\t$%d,($%d),0x%x", jsr_names[disp >> 14],
			    ra, rb, disp & 0x3fff);
d201 2
a202 1
			db_printf("\t$%d,0x%x($%d)", ra, disp, rb);
d211 2
a212 1
		db_printf("\t%03x,$%d,$%d,$%d", func, ra, rb, rc);
d217 1
a217 1
		db_printf("\t$%d,0x%x", ra, disp);
@


1.4
log
@Improved a lot, not so much remains now, mostly the "operate format" stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.3 1997/07/08 20:34:57 niklas Exp $	*/
d111 2
d180 2
a181 18
			switch (disp >> 14) {
			case 0:
				db_printf("jmp\t$%d,($%d),0x%x", ra, rb,
				    disp & 0x3fff);
				break;
			case 1:
				db_printf("jsr\t$%d,($%d),0x%x", ra, rb,
				    disp & 0x3fff);
				break;
			case 2:
				db_printf("ret\t$%d,($%d),0x%x", ra, rb,
				    disp & 0x3fff);
				break;
			case 3:
				db_printf("jsr_coroutine\t$%d,($%d),0x%x", ra,
				    rb, disp & 0x3fff);
				break;
			}
@


1.3
log
@copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.2 1997/07/08 10:56:30 niklas Exp $	*/
d43 1
d45 64
a108 64
	{ OPC_PAL, "call_pal" },	/* 00 */
	{ OPC_RES, "opc01" },		/* 01 */
	{ OPC_RES, "opc02" },		/* 02 */
	{ OPC_RES, "opc03" },		/* 03 */
	{ OPC_RES, "opc04" },		/* 04 */
	{ OPC_RES, "opc05" },		/* 05 */
	{ OPC_RES, "opc06" },		/* 06 */
	{ OPC_RES, "opc07" },		/* 07 */
	{ OPC_MEM, "lda" },		/* 08 */
	{ OPC_MEM, "ldah" },		/* 09 */
	{ OPC_RES, "opc0a" },		/* 0A */
	{ OPC_MEM, "ldq_u" },		/* 0B */
	{ OPC_RES, "opc0c" },		/* 0C */
	{ OPC_RES, "opc0d" },		/* 0D */
	{ OPC_RES, "opc0e" },		/* 0E */
	{ OPC_MEM, "stq_u" },		/* 0F */
	{ OPC_OP, "inta" },		/* 10 */
	{ OPC_OP, "intl" },		/* 11 */
	{ OPC_OP, "ints" },		/* 12 */
	{ OPC_OP, "intm" },		/* 13 */
	{ OPC_RES, "opc14" },		/* 14 */
	{ OPC_OP, "fltv" },		/* 15 */
	{ OPC_OP, "flti" },		/* 16 */
	{ OPC_OP, "fltl" },		/* 17 */
	{ OPC_MEM, "misc" },		/* 18 */
	{ OPC_PAL, "pal19" },		/* 19 */
	{ OPC_MEM, "jsr" },		/* 1A */
	{ OPC_PAL, "pal1b" },		/* 1B */
	{ OPC_RES, "opc1c" },		/* 1C */
	{ OPC_PAL, "pal1d" },		/* 1D */
	{ OPC_PAL, "pal1e" },		/* 1E */
	{ OPC_PAL, "pal1f" },		/* 1F */
	{ OPC_MEM, "ldf" },		/* 20 */
	{ OPC_MEM, "ldg" },		/* 21 */
	{ OPC_MEM, "lds" },		/* 22 */
	{ OPC_MEM, "ldt" },		/* 23 */
	{ OPC_MEM, "stf" },		/* 24 */
	{ OPC_MEM, "stg" },		/* 25 */
	{ OPC_MEM, "sts" },		/* 26 */
	{ OPC_MEM, "stt" },		/* 27 */
	{ OPC_MEM, "ldl" },		/* 28 */
	{ OPC_MEM, "ldq" },		/* 29 */
	{ OPC_MEM, "ldl_l" },		/* 2A */
	{ OPC_MEM, "ldq_l" },		/* 2B */
	{ OPC_MEM, "stl" },		/* 2C */
	{ OPC_MEM, "stq" },		/* 2D */
	{ OPC_MEM, "stl_c" },		/* 2E */
	{ OPC_MEM, "stq_c" },		/* 2F */
	{ OPC_BR, "br" },		/* 30 */
	{ OPC_BR, "fbeq" },		/* 31 */
	{ OPC_BR, "fblt" },		/* 32 */
	{ OPC_BR, "fble" },		/* 33 */
	{ OPC_BR, "bsr" },		/* 34 */
	{ OPC_BR, "fbne" },		/* 35 */
	{ OPC_BR, "fbge" },		/* 36 */
	{ OPC_BR, "fbgt" },		/* 37 */
	{ OPC_BR, "blbc" },		/* 38 */
	{ OPC_BR, "beq" },		/* 39 */
	{ OPC_BR, "blt" },		/* 3A */
	{ OPC_BR, "ble" },		/* 3B */
	{ OPC_BR, "blbs" },		/* 3C */
	{ OPC_BR, "bne" },		/* 3D */
	{ OPC_BR, "bge" },		/* 3E */
	{ OPC_BR, "bgt" },		/* 3F */
d121 2
a122 1
	db_printf("%s\t", opcode[opc].opc_name);
d136 1
a136 1
			db_printf("\t0x%7x", arg);
d141 1
a141 1
		db_printf("\t0x%8x", opc);
d147 54
a200 1
		db_printf("\t$%d,$%d(%4x)", ra, rb, disp);
d207 1
a207 1
		db_printf("\t%3x,$%d,$%d,$%d", func, ra, rb, rc);
d212 1
a212 1
		db_printf("\t$%s,%6x", ra, disp);
d216 1
a216 1
	return (0);
@


1.2
log
@Very rudimentary disassembler, lots are missing.  It is better than nothing though.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.1 1997/07/06 16:31:13 niklas Exp $	*/
d20 10
a29 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
@


1.1
log
@DDB support (much not yet implemented).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d16 3
a18 5
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d39 71
d116 47
a162 2
	 printf("disassembler not implemented yet\n");
	 return (0);
@
