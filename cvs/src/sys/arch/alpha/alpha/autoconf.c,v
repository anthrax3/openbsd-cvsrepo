head	1.36;
access;
symbols
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.36.0.2
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.35.0.16
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.35.0.18
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.10
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.35.0.14
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.35.0.12
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.35.0.8
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.35.0.6
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.4
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.2
	OPENBSD_5_0:1.33.0.4
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.33.0.2
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.32.0.10
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.6
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.8
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.4
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.2
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.31.0.4
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.31.0.2
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.27.0.6
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.4
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.24.0.2
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.22.0.4
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.19.0.6
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.4
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.19
	UBC:1.17.0.2
	UBC_BASE:1.17
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.9.0.8
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.6
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.4
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.36
date	2016.06.08.17.24.44;	author tedu;	state Exp;
branches;
next	1.35;
commitid	oK6mhkiIMNMJ6OsK;

1.35
date	2011.11.25.05.23.40;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2011.11.18.19.24.28;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2010.11.28.21.00.03;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2008.07.21.04.35.53;	author todd;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.01.19.25.09;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.04.19.30.53;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.04.03.44.41;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2007.04.30.17.35.23;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2006.01.26.02.43.28;	author aaron;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.27.18.31.05;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2005.04.21.00.15.42;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2004.12.25.23.02.21;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2004.07.18.02.29.11;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.02.23.27.43;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.05.11.19.41.08;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.10.21.11.11;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.01.26.26;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.22.21.47.38;	author ericj;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.06.04.23.51;	author deraadt;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.12.06.04.22.56;	author ericj;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.05.23.58.41;	author tdeval;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.30.13.08.45;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.19.21.32.13;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.25.00.43.06;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.05.22.33.22;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.08.16.00.54;	author art;	state Exp;
branches;
next	1.9;

1.9
date	99.07.30.19.05.49;	author deraadt;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	98.07.01.02.29.39;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	98.03.17.01.41.26;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	97.01.24.19.56.18;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.11.06.02.01.19;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.10.30.22.37.57;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.07.29.22.57.12;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.18.09.42.03;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.39;	author deraadt;	state Exp;
branches;
next	;

1.9.4.1
date	2001.04.18.16.00.08;	author niklas;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2001.07.04.10.14.18;	author niklas;	state Exp;
branches;
next	1.9.4.3;

1.9.4.3
date	2001.10.31.02.52.43;	author nate;	state Exp;
branches;
next	1.9.4.4;

1.9.4.4
date	2002.03.06.00.24.08;	author niklas;	state Exp;
branches;
next	1.9.4.5;

1.9.4.5
date	2002.03.28.10.06.12;	author niklas;	state Exp;
branches;
next	1.9.4.6;

1.9.4.6
date	2003.05.13.19.41.02;	author ho;	state Exp;
branches;
next	1.9.4.7;

1.9.4.7
date	2003.06.07.11.11.33;	author ho;	state Exp;
branches;
next	;

1.17.2.1
date	2002.01.31.22.55.04;	author niklas;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.06.11.03.33.39;	author art;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2003.05.19.21.38.52;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.36
log
@remove obsolete raid from namtoblk tables. from Artturi Alm
@
text
@/*	$OpenBSD: autoconf.c,v 1.35 2011/11/25 05:23:40 miod Exp $	*/
/*	$NetBSD: autoconf.c,v 1.16 1996/11/13 21:13:04 cgd Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)autoconf.c	8.4 (Berkeley) 10/1/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/disklabel.h>
#include <sys/conf.h>
#include <sys/reboot.h>
#include <sys/device.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/rpb.h>
#include <machine/prom.h>
#include <machine/cpuconf.h>
#include <machine/intr.h>

#include <dev/cons.h>

struct device		*booted_device;
int			booted_partition;
struct bootdev_data	*bootdev_data;
char			boot_dev[128];

void	parse_prom_bootdev(void);
int	atoi(char *);

/*
 * cpu_configure:
 * called at boot time, configure all devices on system
 */
void
cpu_configure()
{
	parse_prom_bootdev();
	softintr_init();

	/*
	 * Disable interrupts during autoconfiguration.  splhigh() won't
	 * work, because it simply _raises_ the IPL, so if machine checks
	 * are disabled, they'll stay disabled.  Machine checks are needed
	 * during autoconfig.
	 */
	(void)alpha_pal_swpipl(ALPHA_PSL_IPL_HIGH);
	if (config_rootfound("mainbus", "mainbus") == NULL)
		panic("no mainbus found");
	(void)spl0();

	hwrpb_restart_setup();
	cold = 0;
}

void
diskconf(void)
{
	struct device *bootdv;
	int bootpartition;

	if (booted_device == NULL)
		printf("WARNING: can't figure what device matches \"%s\"\n",
		    boot_dev);
	bootdv = booted_device;
	bootpartition = booted_partition;

	setroot(bootdv, bootpartition, RB_USERREQ);
	dumpconf();
}

void
parse_prom_bootdev()
{
	static struct bootdev_data bd;
	char *cp, *scp, *boot_fields[8];
	int i, done;

	booted_device = NULL;
	booted_partition = 0;
	bootdev_data = NULL;

	bcopy(bootinfo.booted_dev, boot_dev, sizeof bootinfo.booted_dev);
#if 0
	printf("parse_prom_bootdev: boot dev = \"%s\"\n", boot_dev);
#endif

	i = 0;
	scp = cp = boot_dev;
	for (done = 0; !done; cp++) {
		if (*cp != ' ' && *cp != '\0')
			continue;
		if (*cp == '\0')
			done = 1;

		*cp = '\0';
		boot_fields[i++] = scp;
		scp = cp + 1;
		if (i == 8)
			done = 1;
	}
	if (i != 8)
		return;		/* doesn't look like anything we know! */

#if 0
	printf("i = %d, done = %d\n", i, done);
	for (i--; i >= 0; i--)
		printf("%d = %s\n", i, boot_fields[i]);
#endif

	bd.protocol = boot_fields[0];
	bd.bus = atoi(boot_fields[1]);
	bd.slot = atoi(boot_fields[2]);
	bd.channel = atoi(boot_fields[3]);
	bd.remote_address = boot_fields[4];
	bd.unit = atoi(boot_fields[5]);
	bd.boot_dev_type = atoi(boot_fields[6]);
	bd.ctrl_dev_type = boot_fields[7];

#if 0
	printf("parsed: proto = %s, bus = %d, slot = %d, channel = %d,\n",
	    bd.protocol, bd.bus, bd.slot, bd.channel);
	printf("\tremote = %s, unit = %d, dev_type = %d, ctrl_type = %s\n",
	    bd.remote_address, bd.unit, bd.boot_dev_type, bd.ctrl_dev_type);
#endif

	bootdev_data = &bd;
}

int
atoi(s)
	char *s;
{
	int n, neg;

	n = 0;
	neg = 0;

	while (*s == '-') {
		s++;
		neg = !neg;
	}

	while (*s != '\0') {
		if (*s < '0' || *s > '9')
			break;

		n = (10 * n) + (*s - '0');
		s++;
	}

	return (neg ? -n : n);
}

void
device_register(dev, aux)
	struct device *dev;
	void *aux;
{
	if (bootdev_data == NULL) {
		/*
		 * There is no hope.
		 */
		return;
	}

	if (platform.device_register)
		(*platform.device_register)(dev, aux);
}

struct nam2blk nam2blk[] = {
	{ "st",		2 },
	{ "cd",		3 },
	{ "fd",		4 },
	{ "rd",		6 },
	{ "sd",		8 },
	{ "wd",		0 },
	{ "vnd",	9 },
	{ NULL,		-1 }
};
@


1.35
log
@Compile fixes for gcc4 (-Wbounded)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.34 2011/11/18 19:24:28 miod Exp $	*/
a216 1
	{ "raid",	16 },
@


1.34
log
@Don't bother keeping a local copy of boot_dev in parse_prom_bootdev().
Reminded by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.33 2010/11/28 21:00:03 miod Exp $	*/
d122 1
a122 1
	bcopy(bootinfo.booted_dev, boot_dev, sizeof boot_dev);
@


1.33
log
@Get rid of machdep.root_device sysctl and related variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.32 2008/07/21 04:35:53 todd Exp $	*/
a113 1
	static char hacked_boot_dev[128];
d122 1
a122 1
	bcopy(bootinfo.booted_dev, hacked_boot_dev, sizeof hacked_boot_dev);
d128 1
a128 1
	scp = cp = hacked_boot_dev;
@


1.32
log
@nam2blk[] needs a "vnd" entry for some things (like softraid)
ok marco@@ no objection miod@@ need this for regress djm@@ no objection krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.31 2007/06/01 19:25:09 deraadt Exp $	*/
a60 2

extern char		root_device[17];		/* XXX */
@


1.31
log
@some architectures called setroot() from cpu_configure(), *way* before some
subsystems were enabled.  others used a *md_diskconf -> diskconf() method to
make sure init_main could "do late setroot".  Change all architectures to
have diskconf(), use it directly & late.  tested by todd and myself on most
architectures, ok miod too
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.31 2007/06/01 19:20:46 deraadt Exp $	*/
d221 1
@


1.30
log
@make findblkmajor() and findblkname() MI; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.29 2007/05/04 03:44:41 deraadt Exp $	*/
a78 3
	struct device *bootdv;
	int bootpartition;

d94 8
a110 1
	cold = 0;
@


1.29
log
@setroot() was a ugly mix of MI and MD code, with different bugs on different
machines.  Instead -- build one solid clean MI version, and thenchange all
the architectures to use it.  ok various people, tested on almost all cases.
(it is a 10094 line diff..)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.28 2007/04/30 17:35:23 deraadt Exp $	*/
d209 1
a209 4
static struct {
	char	*name;
	int	maj;
} nam2blk[] = {
d216 2
a217 1
	{ "raid",	16 }
a218 23

int
findblkmajor(struct device *dv)
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (!strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)))
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(int maj)
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	return (NULL);
}
@


1.28
log
@support "exit" as a RB_ASKNAME choice; discussed with miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.27 2006/01/26 02:43:28 aaron Exp $	*/
d52 2
a70 9
void	setroot(void);

static struct device *parsedisk(char *str, int len, int defpart,
				     dev_t *devp);
static struct device *getdisk(char *str, int len, int defpart,
				   dev_t *devp);
int findblkmajor(struct device *dv);
char *findblkname(int);
static int getstr(char *cp, int size);
d79 3
a100 172
	setroot();
	dumpconf();
	cold = 0;
}

struct nam2blk {
	char *name;
	int maj;
} nam2blk[] = {
#include "st.h"
#if NST > 0
	{ "st",		2 },
#endif
#include "cd.h"
#if NCD > 0
	{ "cd",		3 },
#endif
#include "fd.h"
#if NFD > 0
	{ "fd",		4 },
#endif
#include "rd.h"
#if NRD > 0
	{ "rd",		6 },
#endif
	{ "sd",		8 },
	{ "wd",		0 },
#include "raid.h"
#if NRAID > 0
	{ "raid",	16 },
#endif
};

#ifdef RAMDISK_HOOKS
static struct device fakerdrootdev = { DV_DISK, {}, NULL, 0, "rd0", NULL };
#endif

int
findblkmajor(dv)
	struct device *dv;
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name))
		    == 0)
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(maj)
	int maj;
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (maj == nam2blk[i].maj)
			return (nam2blk[i].name);
	return (NULL);
}

static struct device *
getdisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	register struct device *dv;

	if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
		printf("use one of: exit");
#ifdef RAMDISK_HOOKS
		printf(" %s[a-p]", fakerdrootdev.dv_xname);
#endif
		TAILQ_FOREACH(dv, &alldevs, dv_list) {
			if (dv->dv_class == DV_DISK)
				printf(" %s[a-p]", dv->dv_xname);
#ifdef NFSCLIENT
			if (dv->dv_class == DV_IFNET)
				printf(" %s", dv->dv_xname);
#endif
		}
		printf("\n");
	}
	return (dv);
}

static struct device *
parsedisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	register struct device *dv;
	register char *cp, c;
	int majdev, part;

	if (len == 0)
		return (NULL);

	if (len == 4 && !strcmp(str, "exit"))
		boot(RB_USERREQ);

	cp = str + len - 1;
	c = *cp;
	if (c >= 'a' && c <= ('a' + MAXPARTITIONS - 1)) {
		part = c - 'a';
		*cp = '\0';
	} else
		part = defpart;

#ifdef RAMDISK_HOOKS
	if (strcmp(str, fakerdrootdev.dv_xname) == 0) {
		dv = &fakerdrootdev;
		goto gotdisk;
	}
#endif
	TAILQ_FOREACH(dv, &alldevs, dv_list) {
		if (dv->dv_class == DV_DISK &&
		    strcmp(str, dv->dv_xname) == 0) {
#ifdef RAMDISK_HOOKS
gotdisk:
#endif
			majdev = findblkmajor(dv);
			if (majdev < 0)
				panic("parsedisk");
			*devp = MAKEDISKDEV(majdev, dv->dv_unit, part);
			break;
		}
#ifdef NFSCLIENT
		if (dv->dv_class == DV_IFNET &&
		    strcmp(str, dv->dv_xname) == 0) {
			*devp = NODEV;
			break;
		}
#endif
	}

	*cp = c;
	return (dv);
}

/*
 * Attempt to find the device from which we were booted.
 * If we can do so, and not instructed not to do so,
 * change rootdev to correspond to the load device.
 *
 * XXX Actually, swap and root must be on the same type of device,
 * (ie. DV_DISK or DV_IFNET) because of how (*mountroot) is written.
 * That should be fixed.
 */
void
setroot()
{
	struct swdevt *swp;
	struct device *dv;
	int len, majdev, unit, part;
	dev_t nrootdev, nswapdev = NODEV;
	char buf[128], *rootdevname;
	dev_t temp;
	struct device *bootdv, *rootdv, *swapdv;
	int bootpartition;
#if defined(NFSCLIENT)
	extern char *nfsbootdevname;
#endif

#ifdef RAMDISK_HOOKS
	bootdv = &fakerdrootdev;
	bootpartition = 0;
#else
a102 1
#endif
d104 3
a106 239
	/*
	 * (raid) device auto-configuration could have returned
	 * the root device's id in rootdev.  Check this case.
	 */
	if (rootdev != NODEV) {
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);

		len = snprintf(buf, sizeof buf, "%s%d",
		    findblkname(majdev), unit);
		if (len == -1 || len >= sizeof(buf))
			panic("setroot: device name too long");

		bootdv = getdisk(buf, len, part, &rootdev);
	}

	/*
	 * If 'swap generic' and we couldn't determine root device,
	 * ask the user.
	 */
	if (mountroot == NULL && bootdv == NULL)
		boothowto |= RB_ASKNAME;

	if (boothowto & RB_ASKNAME) {
		for (;;) {
			printf("root device");
			if (bootdv != NULL) {
				printf(" (default %s", bootdv->dv_xname);
				if (bootdv->dv_class == DV_DISK)
					printf("%c", bootpartition + 'a');
				printf(")");
			}
			printf(": ");
			len = getstr(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
				len = strlen(buf);
			}
			if (len == 4 && !strcmp(buf, "exit"))
				boot(RB_USERREQ);
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				dv = getdisk(buf, len, 1, &nrootdev);
				if (dv != NULL) {
					rootdv = swapdv = dv;
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			dv = getdisk(buf, len, bootpartition, &nrootdev);
			if (dv != NULL) {
				rootdv = dv;
				break;
			}
		}

		/*
		 * because swap must be on same device type as root, for
		 * network devices this is easy.
		 */
		if (rootdv->dv_class == DV_IFNET) {
			swapdv = NULL;
			goto gotswap;
		}
		for (;;) {
			printf("swap device");
			printf(" (default %s", rootdv->dv_xname);
			if (rootdv->dv_class == DV_DISK)
				printf("b");
			printf(")");
			printf(": ");
			len = getstr(buf, sizeof(buf));
			if (len == 0) {
				switch (rootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
					break;
				default:
					break;
				}
				swapdv = rootdv;
				break;
			}
			if (len == 4 && !strcmp(buf, "exit"))
				boot(RB_USERREQ);
			dv = getdisk(buf, len, 1, &nswapdev);
			if (dv) {
				if (dv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				swapdv = dv;
				break;
			}
		}
gotswap:
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
	} else if (mountroot == NULL) {
		
		/*
		 * "swap generic"
		 */
		majdev = findblkmajor(bootdv);
		if (majdev >= 0) {
			/*
			 * Root and swap are on a disk.
			 */
			rootdv = swapdv = bootdv;
			rootdev = MAKEDISKDEV(majdev, bootdv->dv_unit,
			    bootpartition);
			nswapdev = dumpdev =
			    MAKEDISKDEV(majdev, bootdv->dv_unit, 1);
		} else {
			/*
			 * Root and swap are on a net.
			 */
			rootdv = swapdv = bootdv;
			nswapdev = dumpdev = NODEV;
		}
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
	} else {
		/*
		 * `root DEV swap DEV': honor rootdev/swdevt.
		 * rootdev/swdevt/mountroot already properly set.
		 */

		rootdevname = findblkname(major(rootdev));
		if (rootdevname == NULL) {
			/* Root on NFS or unknown device. */
			strlcpy(root_device, "??", sizeof root_device);
		} else {
			/* Root on known block device. */
			snprintf(root_device, sizeof root_device,
			    "%s%d%c", rootdevname,
			    DISKUNIT(rootdev), DISKPART(rootdev) + 'a');
		}
			
		return;
	}

	switch (rootdv->dv_class) {
#if defined(NFSCLIENT)
	case DV_IFNET:
		strlcpy(root_device, "??", sizeof root_device);
		mountroot = nfs_mountroot;
		nfsbootdevname = rootdv->dv_xname;
		return;
#endif
	case DV_DISK:
		mountroot = dk_mountroot;
		snprintf(root_device, sizeof root_device,
		    "%s%c", rootdv->dv_xname,
		    DISKPART(rootdev) + 'a');
		printf("root on %s", root_device);
		if (nswapdev != NODEV)
			printf(" swap on %s%c", swapdv->dv_xname,
			    DISKPART(nswapdev) + 'a');
		printf("\n");
		break;
	default:
		printf("can't figure root, hope your kernel is right\n");
		return;
	}

	/*
	 * Make the swap partition on the root drive the primary swap.
	 */
	temp = NODEV;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (major(rootdev) == major(swp->sw_dev) &&
		    DISKUNIT(rootdev) == DISKUNIT(swp->sw_dev)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev == NODEV)
		return;

	/*
	 * If dumpdev was the same as the old primary swap device, move
	 * it to the new primary swap device.
	 */
	if (temp == dumpdev)
		dumpdev = swdevt[0].sw_dev;
}

static int
getstr(cp, size)
	register char *cp;
	register int size;
{
	register char *lp;
	register int c;
	register int len;

	lp = cp;
	len = 0;
	for (;;) {
		c = cngetc();
		switch (c) {
		case '\n':
		case '\r':
			printf("\n");
			*lp++ = '\0';
			return (len);
		case '\b':
		case '\177':
		case '#':
			if (len) {
				--len;
				--lp;
				printf("\b \b");
			}
			continue;
		case '@@':
		case 'u'&037:
			len = 0;
			lp = cp;
			printf("\n");
			continue;
		default:
			if (len + 1 >= size || c < ' ') {
				printf("\007");
				continue;
			}
			printf("%c", c);
			++len;
			*lp++ = c;
		}
	}
d207 36
@


1.27
log
@Fix character range check in local atoi() function.  krw@@ "looks correct"
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.26 2005/12/27 18:31:05 miod Exp $	*/
d177 1
a177 1
		printf("use one of:");
d189 1
a189 1
		printf(" halt\n");
d207 2
a208 2
	if (len == 4 && !strcmp(str, "halt"))
		boot(RB_HALT /* , NULL */);
d320 2
d369 2
@


1.26
log
@Remove unused sw_nblks field of struct swdevt. Then, remove swapconf()
which duplicates work done by uvm_swap_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.25 2005/04/21 00:15:42 deraadt Exp $	*/
d592 1
a592 1
		if (*s < '0' && *s > '9')
@


1.25
log
@correct idiom for snprintf failure handling; ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.24 2004/12/25 23:02:21 miod Exp $	*/
a69 1
void	swapconf(void);
d106 1
a106 1
	swapconf();
a107 24
}

/*
 * Configure swap space and related parameters.
 */
void
swapconf()
{
	struct swdevt *swp;
	int nblks, maj;

	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		maj = major(swp->sw_dev);
		if (maj > nblkdev)
			break;
		if (bdevsw[maj].d_psize) {
			nblks = (*bdevsw[maj].d_psize)(swp->sw_dev);
			if (nblks != -1 &&
			    (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
			swp->sw_nblks = ctod(dtoc(swp->sw_nblks));
		}
	}
	dumpconf();
@


1.24
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.23 2004/07/18 02:29:11 deraadt Exp $	*/
d317 1
a317 1
		if (len >= sizeof(buf))
@


1.23
log
@minor space savings
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.22 2003/06/02 23:27:43 millert Exp $	*/
d206 1
a206 2
		for (dv = alldevs.tqh_first; dv != NULL;
		    dv = dv->dv_list.tqe_next) {
d249 1
a249 1
	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
@


1.22
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.21 2003/05/11 19:41:08 deraadt Exp $	*/
d139 2
d142 3
d146 3
d150 3
d154 1
d157 2
d160 1
d387 1
a387 4
				case DV_TAPE:
				case DV_TTY:
				case DV_DULL:
				case DV_CPU:
@


1.21
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.20 2003/05/10 21:11:11 deraadt Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.20
log
@string cleaning; ok beck dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.19 2002/03/14 01:26:26 millert Exp $	*/
d332 1
a332 1
				strcpy(buf, bootdv->dv_xname);
d445 1
a445 1
		strcpy(root_device, "??");
@


1.19
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.18 2002/01/22 21:47:38 ericj Exp $	*/
d305 2
a306 1
		len = sprintf(buf, "%s%d", findblkname(majdev), unit);
d431 1
a431 1
			strcpy(root_device, "??");
d434 2
a435 1
			sprintf(root_device, "%s%d%c", rootdevname,
d452 2
a453 1
		sprintf(root_device, "%s%c", rootdv->dv_xname,
@


1.18
log
@
add fd to nam2blk
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.17 2001/12/06 04:23:51 deraadt Exp $	*/
d71 12
a82 12
void	parse_prom_bootdev __P((void));
int	atoi __P((char *));
void	setroot __P((void));
void	swapconf __P((void));

static struct device *parsedisk __P((char *str, int len, int defpart,
				     dev_t *devp));
static struct device *getdisk __P((char *str, int len, int defpart,
				   dev_t *devp));
int findblkmajor __P((struct device *dv));
char *findblkname __P((int));
static int getstr __P((char *cp, int size));
@


1.17
log
@be more careful with spaces and tabs, guys
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.16 2001/12/06 04:22:56 ericj Exp $	*/
d145 1
a149 3
#if 0
	{ "fd",		XXX },
#endif
a625 1

@


1.17.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.18 2002/01/22 21:47:38 ericj Exp $	*/
a144 1
	{ "fd",		4 },
d149 3
d628 1
@


1.17.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.17.2.1 2002/01/31 22:55:04 niklas Exp $	*/
d71 12
a82 12
void	parse_prom_bootdev(void);
int	atoi(char *);
void	setroot(void);
void	swapconf(void);

static struct device *parsedisk(char *str, int len, int defpart,
				     dev_t *devp);
static struct device *getdisk(char *str, int len, int defpart,
				   dev_t *devp);
int findblkmajor(struct device *dv);
char *findblkname(int);
static int getstr(char *cp, int size);
@


1.17.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d305 1
a305 2
		len = snprintf(buf, sizeof buf, "%s%d",
		    findblkname(majdev), unit);
d331 1
a331 1
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
d430 1
a430 1
			strlcpy(root_device, "??", sizeof root_device);
d433 1
a433 2
			snprintf(root_device, sizeof root_device,
			    "%s%d%c", rootdevname,
d443 1
a443 1
		strlcpy(root_device, "??", sizeof root_device);
d450 1
a450 2
		snprintf(root_device, sizeof root_device,
		    "%s%c", rootdv->dv_xname,
@


1.16
log
@
unbreak alpha kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.15 2001/12/05 23:58:41 tdeval Exp $	*/
d94 7
a100 7
        /*
         * Disable interrupts during autoconfiguration.  splhigh() won't
         * work, because it simply _raises_ the IPL, so if machine checks
         * are disabled, they'll stay disabled.  Machine checks are needed
         * during autoconfig.
         */
        (void)alpha_pal_swpipl(ALPHA_PSL_IPL_HIGH);
d280 1
a280 1
        int len, majdev, unit, part;
d423 1
a423 1
        } else {
@


1.15
log
@Enable rootdev auto-configuration by device drivers during boot.
Add support for "raid" devices (prepare future raidframe changes).

OK deraadt@@, Reviewed by drahn@@, jason@@, mickey@@ and miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.14 2001/09/30 13:08:45 art Exp $	*/
d280 1
a280 1
        int len;
a399 1
		int majdev;
@


1.14
log
@Generic soft interrupts from NetBSD plus some minor cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.13 2001/09/19 21:32:13 miod Exp $	*/
d80 2
a81 2
static int findblkmajor __P((struct device *dv));
static char *findblkname __P((int));
d148 1
d158 1
a158 1
static int
d163 1
a163 1
	register int i;
d166 1
a166 1
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[0].name))
d172 1
a172 1
static char *
d176 1
a176 1
	register int i;
d280 1
a280 1
        register int len;
d297 16
@


1.13
log
@Now is a good time to commit this cosmetic maxpartition-related change...
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.12 2001/06/25 00:43:06 mickey Exp $	*/
d60 1
d92 1
@


1.12
log
@cold is in systm now
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11 2001/05/05 22:33:22 art Exp $	*/
d192 1
a192 1
		printf(" %s[a-h]", fakerdrootdev.dv_xname);
d197 1
a197 1
				printf(" %s[a-h]", dv->dv_xname);
@


1.11
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.10 2000/11/08 16:00:54 art Exp $	*/
a89 2
	extern int cold;

@


1.10
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9 1999/07/30 19:05:49 deraadt Exp $	*/
d84 1
a84 1
 * configure:
d88 1
a88 1
configure()
@


1.9
log
@acd goes away
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.8 1998/07/01 02:29:39 angelos Exp $	*/
d90 1
d105 2
d531 1
a531 2
        prom_getenv(PROM_E_BOOTED_DEV, boot_dev, sizeof(boot_dev));
	bcopy(boot_dev, hacked_boot_dev, sizeof hacked_boot_dev);
a607 2
	extern const struct cpusw *cpu_fn_switch;

d616 2
a617 1
	(*cpu_fn_switch->device_register)(dev, aux);
@


1.9.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.10 2000/11/08 16:00:54 art Exp $	*/
a89 1
	extern int cold;
a103 2
	hwrpb_restart_setup();

d528 2
a529 1
	bcopy(bootinfo.booted_dev, hacked_boot_dev, sizeof hacked_boot_dev);
d606 2
d616 1
a616 2
	if (platform.device_register)
		(*platform.device_register)(dev, aux);
@


1.9.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9.4.1 2001/04/18 16:00:08 niklas Exp $	*/
d84 1
a84 1
 * cpu_configure:
d88 1
a88 1
cpu_configure()
d90 2
@


1.9.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9.4.2 2001/07/04 10:14:18 niklas Exp $	*/
a59 1
#include <machine/intr.h>
a90 1
	softintr_init();
d192 1
a192 1
		printf(" %s[a-p]", fakerdrootdev.dv_xname);
d197 1
a197 1
				printf(" %s[a-p]", dv->dv_xname);
@


1.9.4.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d80 2
a81 2
int findblkmajor __P((struct device *dv));
char *findblkname __P((int));
d94 7
a100 7
	/*
	 * Disable interrupts during autoconfiguration.  splhigh() won't
	 * work, because it simply _raises_ the IPL, so if machine checks
	 * are disabled, they'll stay disabled.  Machine checks are needed
	 * during autoconfig.
	 */
	(void)alpha_pal_swpipl(ALPHA_PSL_IPL_HIGH);
a144 1
	{ "fd",		4 },
d148 3
a150 1
	{ "raid",	16 },
d157 1
a157 1
int
d162 1
a162 1
	int i;
d165 1
a165 1
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name))
d171 1
a171 1
char *
d175 1
a175 1
	int i;
d279 1
a279 1
	int len, majdev, unit, part;
a297 16
	 * (raid) device auto-configuration could have returned
	 * the root device's id in rootdev.  Check this case.
	 */
	if (rootdev != NODEV) {
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);

		len = sprintf(buf, "%s%d", findblkname(majdev), unit);
		if (len >= sizeof(buf))
			panic("setroot: device name too long");

		bootdv = getdisk(buf, len, part, &rootdev);
	}

	/*
d383 1
d407 1
a407 1
	} else {
d612 1
@


1.9.4.5
log
@Merge in -current from about a week ago
@
text
@d71 4
a74 4
void	parse_prom_bootdev(void);
int	atoi(char *);
void	setroot(void);
void	swapconf(void);
d76 7
a82 7
static struct device *parsedisk(char *str, int len, int defpart,
				     dev_t *devp);
static struct device *getdisk(char *str, int len, int defpart,
				   dev_t *devp);
int findblkmajor(struct device *dv);
char *findblkname(int);
static int getstr(char *cp, int size);
@


1.9.4.6
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9.4.5 2002/03/28 10:06:12 niklas Exp $	*/
d305 1
a305 2
		len = snprintf(buf, sizeof buf, "%s%d",
		    findblkname(majdev), unit);
d331 1
a331 1
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
d430 1
a430 1
			strlcpy(root_device, "??", sizeof root_device);
d433 1
a433 2
			snprintf(root_device, sizeof root_device,
			    "%s%d%c", rootdevname,
d443 1
a443 1
		strlcpy(root_device, "??", sizeof root_device);
d450 1
a450 2
		snprintf(root_device, sizeof root_device,
		    "%s%c", rootdv->dv_xname,
@


1.9.4.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9.4.6 2003/05/13 19:41:02 ho Exp $	*/
d25 5
a29 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.8
log
@Do the right thing with interrupts during autoconfiguration; from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.7 1998/03/17 01:41:26 angelos Exp $	*/
a143 1
	{ "acd",	4 },
@


1.7
log
@Allow wd and acd device boot.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.6 1997/01/24 19:56:18 niklas Exp $	*/
d93 7
a99 1
	(void)splhigh();
a139 1
	{ "wd",		0 },
a141 1
	{ "acd",	4 },
d144 2
@


1.6
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.5 1996/11/06 02:01:19 deraadt Exp $	*/
d134 1
d137 1
@


1.5
log
@use dk_mountroot
@
text
@d1 2
a2 2
/*	$OpenBSD: autoconf.c,v 1.4 1996/10/30 22:37:57 niklas Exp $	*/
/*	$NetBSD: autoconf.c,v 1.14 1996/10/13 02:59:23 christos Exp $	*/
d59 1
a89 1
	extern int cold;
d313 1
a313 1
					rootdv = dv;
d599 1
a599 1
	extern void (*cpu_device_register) __P((struct device *dev, void *aux));
d609 1
a609 1
	(*cpu_device_register)(dev, aux);
@


1.4
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.14 1996/10/13 02:59:23 christos Exp $	*/
a271 1
	extern int (*mountroot) __P((void *));
a276 4
	extern int nfs_mountroot __P((void *));
#endif
#if defined(FFS)
	extern int ffs_mountroot __P((void *));
a423 1
#if defined(FFS)
d425 1
a425 1
		mountroot = ffs_mountroot;
a433 1
#endif
@


1.3
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: autoconf.c,v 1.3.4.3 1996/06/14 20:42:41 cgd Exp $	*/
/*	$NetBSD: autoconf.c,v 1.3.4.3 1996/06/14 20:42:41 cgd Exp $	*/
d57 1
d60 2
d71 2
d74 2
a75 1
struct device *parsedisk __P((char *str, int len, int defpart, dev_t *devp));
d109 1
d136 1
d143 4
d183 3
d195 1
a195 1
		printf("\n");
d200 1
a200 1
struct device *
d212 4
d224 6
d233 3
d264 1
d284 4
d290 1
d302 6
a307 5
			if (bootdv != NULL)
				printf(" (default %s%c)",
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK
						? bootpartition + 'a' : ' ');
a313 2
			if (len == 4 && !strcmp(buf, "halt"))
				boot(RB_HALT);
d340 4
a343 2
			printf(" (default %s%c)", rootdv->dv_xname,
			    rootdv->dv_class == DV_DISK?'b':' ');
a363 2
			if (len == 4 && !strcmp(buf, "halt"))
				boot(RB_HALT);
d404 1
a404 1
		 * `root DEV swap DEV': honour rootdev/swdevt.
a580 1
	char c;
@


1.2
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: autoconf.c,v 1.1 1995/02/13 23:06:49 cgd Exp $	*/
d4 2
a5 2
 * Copyright (c) 1994, 1995 Carnegie-Mellon University.
 * All rights reserved.
d7 3
a9 18
 * Authors: Keith Bostic, Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
d11 34
a44 2
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
d56 18
d84 2
d87 1
a87 1
	if (config_rootfound("mainbus", "mainbus") == 0)
d91 3
a93 5
#ifdef GENERIC
	if ((boothowto & RB_ASKNAME) == 0)
		setroot();
	setconf();
#else
a94 1
#endif
d104 2
a105 2
	register struct swdevt *swp;
	register int nblks;
d108 1
a108 2
		int maj = major(swp->sw_dev);

d119 39
d160 7
a166 2
#define	DOSWAP			/* change swdevt and dumpdev */
dev_t	bootdev = 0;		/* should be dev_t, but not until 32 bits */
d168 57
a224 11
static	char devname[][2] = {
	'x','x',	/* 0 = XX */
	'x','x',	/* 1 = XX */
	'x','x',	/* 2 = XX */
	'x','x',	/* 3 = XX */
	'x','x',	/* 4 = XX */
	'x','x',	/* 5 = XX */
	'x','x',	/* 6 = XX */
	'x','x',	/* 7 = XX */
	's','d',	/* 8 = sd */
};
d230 4
a236 2
	int  majdev, mindev, unit, part, adaptor;
	dev_t temp, orootdev;
d238 148
d387 6
a392 3
/*printf("howto %x bootdev %x ", boothowto, bootdev);*/
	if (boothowto & RB_DFLTROOT ||
	    (bootdev & B_MAGICMASK) != (u_long)B_DEVMAGIC)
d394 15
a408 2
	majdev = (bootdev >> B_TYPESHIFT) & B_TYPEMASK;
	if (majdev > sizeof(devname) / sizeof(devname[0]))
d410 2
a411 6
	adaptor = (bootdev >> B_ADAPTORSHIFT) & B_ADAPTORMASK;
	part = (bootdev >> B_PARTITIONSHIFT) & B_PARTITIONMASK;
	unit = (bootdev >> B_UNITSHIFT) & B_UNITMASK;
	mindev = (unit * MAXPARTITIONS) + part;
	orootdev = rootdev;
	rootdev = makedev(majdev, mindev);
d413 1
a413 2
	 * If the original rootdev is the same as the one
	 * just calculated, don't need to adjust the swap configuration.
d415 1
a415 7
	if (rootdev == orootdev)
		return;
	printf("changing root device to %c%c%d%c\n",
		devname[majdev][0], devname[majdev][1],
		unit, part + 'a');

#ifdef DOSWAP
d417 2
a418 3
		if (majdev == major(swp->sw_dev) &&
		    (mindev / MAXPARTITIONS)
		    == (minor(swp->sw_dev) / MAXPARTITIONS)) {
d434 87
d522 62
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

