head	1.46;
access;
symbols
	OPENBSD_6_1:1.46.0.4
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.44.0.2
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.43.0.4
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.41.0.6
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.41.0.4
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.39.0.4
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.39.0.2
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.37.0.16
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.14
	OPENBSD_5_0:1.37.0.12
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.37.0.10
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.37.0.8
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.37.0.4
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.37.0.6
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.37.0.2
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.36.0.4
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.36.0.2
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.32.0.2
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.31.0.2
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.30.0.10
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.30.0.8
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.30.0.6
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.30.0.4
	OPENBSD_3_6_BASE:1.30
	SMP_SYNC_A:1.30
	SMP_SYNC_B:1.30
	OPENBSD_3_5:1.30.0.2
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.28.0.6
	OPENBSD_3_4_BASE:1.28
	UBC_SYNC_A:1.28
	OPENBSD_3_3:1.28.0.4
	OPENBSD_3_3_BASE:1.28
	OPENBSD_3_2:1.28.0.2
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.27.0.4
	OPENBSD_3_1_BASE:1.27
	UBC_SYNC_B:1.28
	UBC:1.27.0.2
	UBC_BASE:1.27
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9:1.20.0.2
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_8:1.15.0.2
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.12.0.6
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.4
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.46
date	2017.02.12.04.55.08;	author guenther;	state Exp;
branches;
next	1.45;
commitid	1rXx7AiXIWFC9gYa;

1.45
date	2016.10.04.05.55.09;	author guenther;	state Exp;
branches;
next	1.44;
commitid	4XP1n5WneE30JLqU;

1.44
date	2016.05.15.23.37.42;	author guenther;	state Exp;
branches;
next	1.43;
commitid	Hg9xYq6uyjPNjU8k;

1.43
date	2015.05.05.02.13.46;	author guenther;	state Exp;
branches;
next	1.42;
commitid	dNPv28CJI5BxtRGW;

1.42
date	2014.11.16.12.30.52;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	yv0ECmCdICvq576h;

1.41
date	2014.02.01.21.19.35;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2014.01.28.20.23.36;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2013.01.16.19.04.43;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2012.11.01.21.01.43;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2009.01.28.08.02.02;	author grange;	state Exp;
branches;
next	1.36;

1.36
date	2007.10.13.07.18.30;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2007.10.10.15.53.51;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2007.09.03.01.24.22;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2007.05.27.20.59.24;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2006.11.29.12.26.11;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2006.04.13.14.41.08;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2003.11.17.10.07.53;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2003.10.18.20.14.40;	author jmc;	state Exp;
branches;
next	1.28;

1.28
date	2002.04.28.20.55.14;	author pvalchev;	state Exp;
branches;
next	1.27;

1.27
date	2001.12.08.02.24.05;	author art;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2001.11.06.19.53.13;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.06.18.41.09;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2001.09.19.20.50.55;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2001.07.25.13.25.31;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.08.08.08.38;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.06.00.45.45;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.04.13.03.07.29;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.21.10.15.05;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.20.20.27.40;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2000.11.08.19.16.59;	author ericj;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.08.16.01.04;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.08.22.25.17;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.08.11.57.21;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.05.11.02.55;	author art;	state Exp;
branches;
next	1.12;

1.12
date	99.09.14.11.41.18;	author kstailey;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	99.09.03.18.00.13;	author art;	state Exp;
branches;
next	1.10;

1.10
date	99.08.17.10.32.16;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	99.01.10.13.34.17;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	98.07.28.00.13.26;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.03.01.16.12.12;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	97.01.24.19.56.47;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.10.30.22.38.30;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.07.29.22.58.08;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.06.18.09.42.34;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.52.48;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.40;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.40;	author deraadt;	state Exp;
branches;
next	;

1.12.4.1
date	2001.04.18.16.00.32;	author niklas;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2001.07.04.10.14.25;	author niklas;	state Exp;
branches;
next	1.12.4.3;

1.12.4.3
date	2001.10.31.02.52.44;	author nate;	state Exp;
branches;
next	1.12.4.4;

1.12.4.4
date	2001.11.13.21.00.49;	author niklas;	state Exp;
branches;
next	1.12.4.5;

1.12.4.5
date	2002.03.06.00.47.43;	author niklas;	state Exp;
branches;
next	1.12.4.6;

1.12.4.6
date	2003.03.27.23.18.06;	author niklas;	state Exp;
branches;
next	1.12.4.7;

1.12.4.7
date	2004.02.19.09.59.33;	author niklas;	state Exp;
branches;
next	;

1.27.2.1
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	;


desc
@@


1.46
log
@Split up fork1():
 - FORK_THREAD handling is a totally separate function, thread_fork(),
   that is only used by sys___tfork() and which loses the flags, func,
   arg, and newprocp parameters and gains tcb parameter to guarantee
   the new thread's TCB is set before the creating thread returns
 - fork1() loses its stack and tidptr parameters
Common bits factor out:
 - struct proc allocation and initialization moves to thread_new()
 - maxthread handling moves to fork_check_maxthread()
 - setting the new thread running moves to fork_thread_start()
The MD cpu_fork() function swaps its unused stacksize parameter for
a tcb parameter.

luna88k testing by aoyama@@, alpha testing by dlg@@
ok mpi@@
@
text
@/* $OpenBSD: vm_machdep.c,v 1.45 2016/10/04 05:55:09 guenther Exp $ */
/* $NetBSD: vm_machdep.c,v 1.55 2000/03/29 03:49:48 simonb Exp $ */

/*
 * Copyright (c) 1994, 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/vnode.h>
#include <sys/user.h>
#include <sys/exec.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/pmap.h>
#include <machine/reg.h>


/*
 * cpu_exit is called as the last action during exit.
 */
void
cpu_exit(p)
	struct proc *p;
{

	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 0);

	/*
	 * Deactivate the exiting address space before the vmspace
	 * is freed.  Note that we will continue to run on this
	 * vmspace's context until the switch to idle in switch_exit().
	 */
	pmap_deactivate(p);
	sched_exit(p);
	/* NOTREACHED */
}

/*
 * Finish a fork operation, with process p2 nearly set up.
 * Copy and update the pcb and trap frame, making the child ready to run.
 * 
 * Rig the child's kernel stack so that it will start out in
 * proc_trampoline() and call 'func' with 'arg' as an argument.
 * For normal processes this is child_return(), which causes the
 * child to go directly to user level with an apparent return value
 * of 0 from fork(), while the parent process returns normally.
 * For kernel threads this will be a function that never return.
 *
 * An alternate user-level stack or TCB can be requested by passing
 * a non-NULL value; these are poked into the PCB so they're in
 * effect at the initial return to userspace.
 */
void
cpu_fork(struct proc *p1, struct proc *p2, void *stack, void *tcb,
    void (*func)(void *), void *arg)
{
	struct user *up = p2->p_addr;

	p2->p_md.md_tf = p1->p_md.md_tf;

#ifndef NO_IEEE
	p2->p_md.md_flags = p1->p_md.md_flags & (MDP_FPUSED | MDP_FP_C);
#else
	p2->p_md.md_flags = p1->p_md.md_flags & MDP_FPUSED;
#endif

	/*
	 * Cache the physical address of the pcb, so we can
	 * swap to it easily.
	 */
	p2->p_md.md_pcbpaddr = (void *)vtophys((vaddr_t)&up->u_pcb);

	/*
	 * Copy floating point state from the FP chip to the PCB
	 * if this process has state stored there.
	 */
	if (p1->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p1, 1);

	/*
	 * Copy pcb and stack from proc p1 to p2.
	 * If specified, give the child a different stack and/or TCB.
	 * We do this as cheaply as possible, copying only the active
	 * part of the stack.  The stack and pcb need to agree;
	 */
	up->u_pcb = p1->p_addr->u_pcb;
	if (stack != NULL)
		up->u_pcb.pcb_hw.apcb_usp = (u_long)stack;
	else
		up->u_pcb.pcb_hw.apcb_usp = alpha_pal_rdusp();
	if (tcb != NULL)
		up->u_pcb.pcb_hw.apcb_unique = (unsigned long)tcb;

	/*
	 * Arrange for a non-local goto when the new process
	 * is started, to resume here, returning nonzero from setjmp.
	 */
#ifdef DIAGNOSTIC
	/*
	 * If p1 != curproc && p1 == &proc0, we are creating a kernel
	 * thread.
	 */
	if (p1 != curproc && p1 != &proc0)
		panic("cpu_fork: curproc");
	if ((up->u_pcb.pcb_hw.apcb_flags & ALPHA_PCB_FLAGS_FEN) != 0)
		printf("DANGER WILL ROBINSON: FEN SET IN cpu_fork!\n");
#endif

	/*
	 * create the child's kernel stack, from scratch.
	 */
	/*
	 * Pick a stack pointer, leaving room for a trapframe;
	 * copy trapframe from parent so return to user mode
	 * will be to right address, with correct registers.
	 */
	p2->p_md.md_tf = (struct trapframe *)((char *)p2->p_addr + USPACE) - 1;
	bcopy(p1->p_md.md_tf, p2->p_md.md_tf, sizeof(struct trapframe));

	/*
	 * Arrange for continuation at child_return(), which
	 * will return to exception_return().  Note that the child
	 * process doesn't stay in the kernel for long!
	 */
	up->u_pcb.pcb_hw.apcb_ksp = (u_int64_t)p2->p_md.md_tf;
	up->u_pcb.pcb_context[0] = (u_int64_t)func;
	up->u_pcb.pcb_context[1] =
	    (u_int64_t)exception_return;	/* s1: ra */
	up->u_pcb.pcb_context[2] = (u_int64_t)arg;
	up->u_pcb.pcb_context[7] =
	    (u_int64_t)switch_trampoline;	/* ra: assembly magic */
#ifdef MULTIPROCESSOR
	/*
	 * MULTIPROCESSOR kernels will reuse the IPL of the parent
	 * process, and will lower to IPL_NONE in proc_trampoline_mp().
	 */
	up->u_pcb.pcb_context[8] = IPL_SCHED;	/* ps: IPL */
#else
	up->u_pcb.pcb_context[8] = IPL_NONE;	/* ps: IPL */
#endif
}

/*
 * Map a user I/O request into kernel virtual address space.
 * Note: the pages are already locked by uvm_vslock(), so we
 * do not need to pass an access_type to pmap_enter().
 */
void
vmapbuf(bp, len)
	struct buf *bp;
	vsize_t len;
{
	vaddr_t faddr, taddr, off;
	paddr_t pa;
	struct proc *p;

	if ((bp->b_flags & B_PHYS) == 0)
		panic("vmapbuf");
	p = bp->b_proc;
	faddr = trunc_page((vaddr_t)(bp->b_saveaddr = bp->b_data));
	off = (vaddr_t)bp->b_data - faddr;
	len = round_page(off + len);
	taddr = uvm_km_valloc_wait(phys_map, len);
	bp->b_data = (caddr_t)(taddr + off);
	len = atop(len);
	while (len--) {
		if (pmap_extract(vm_map_pmap(&p->p_vmspace->vm_map),
		    faddr, &pa) == FALSE)
			panic("vmapbuf: null page frame");
		pmap_enter(vm_map_pmap(phys_map), taddr, trunc_page(pa),
		    PROT_READ | PROT_WRITE, PMAP_WIRED);
		faddr += PAGE_SIZE;
		taddr += PAGE_SIZE;
	}
	pmap_update(vm_map_pmap(phys_map));
}

/*
 * Unmap a previously-mapped user I/O request.
 */
void
vunmapbuf(bp, len)
	struct buf *bp;
	vsize_t len;
{
	vaddr_t addr, off;

	if ((bp->b_flags & B_PHYS) == 0)
		panic("vunmapbuf");
	addr = trunc_page((vaddr_t)bp->b_data);
	off = (vaddr_t)bp->b_data - addr;
	len = round_page(off + len);
	pmap_remove(vm_map_pmap(phys_map), addr, addr + len);
	pmap_update(vm_map_pmap(phys_map));
	uvm_km_free_wakeup(phys_map, addr, len);
	bp->b_data = bp->b_saveaddr;
	bp->b_saveaddr = NULL;
}

void *
tcb_get(struct proc *p)
{
	if (p == curproc)
		return (void *)alpha_pal_rdunique();
	else
		return (void *)p->p_addr->u_pcb.pcb_hw.apcb_unique;
}

void
tcb_set(struct proc *p, void *newtcb)
{
	KASSERT(p == curproc);

	p->p_addr->u_pcb.pcb_hw.apcb_unique = (unsigned long)newtcb;
	alpha_pal_wrunique((unsigned long)newtcb);
}
@


1.45
log
@The new thread's userspace v0, a3, and a4 registers are updated in
child_return() like on other archs, so cpu_fork() doesn't need to
touch them.

ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.44 2016/05/15 23:37:42 guenther Exp $ */
d74 5
a78 4
 * switch_trampoline() and call child_return() with p2 as an
 * argument. This causes the newly-created child process to go
 * directly to user level with an apparent return value of 0 from
 * fork(), while the parent process returns normally.
d80 3
a82 5
 * p1 is the process being forked;
 *
 * If an alternate user-level stack is requested (with non-NULL stack arg),
 * set up the user stack pointer
 * accordingly.
d85 2
a86 6
cpu_fork(p1, p2, stack, stacksize, func, arg)
	struct proc *p1, *p2;
	void *stack;
	size_t stacksize;
	void (*func)(void *);
	void *arg;
d113 1
a113 1
	 * If specified, give the child a different stack.
d119 1
a119 1
		up->u_pcb.pcb_hw.apcb_usp = (u_long)stack + stacksize;
d122 2
@


1.44
log
@Implement TCB_{GET,SET} using PAL_{rd,wr}unique.
Inline asm from NetBSD

testing deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.43 2015/05/05 02:13:46 guenther Exp $ */
d81 2
a82 2
 * If an alternate user-level stack is requested (with non-zero values
 * in both the stack and stacksize args), set up the user stack pointer
d146 20
a165 31
	{
		struct trapframe *p2tf;

		/*
		 * Pick a stack pointer, leaving room for a trapframe;
		 * copy trapframe from parent so return to user mode
		 * will be to right address, with correct registers.
		 */
		p2tf = p2->p_md.md_tf = (struct trapframe *)
		    ((char *)p2->p_addr + USPACE - sizeof(struct trapframe));
		bcopy(p1->p_md.md_tf, p2->p_md.md_tf, sizeof(struct trapframe));

		/*
		 * Set up return-value registers as fork() libc stub expects.
		 */
		p2tf->tf_regs[FRAME_V0] = p1->p_pid;	/* parent's pid */
		p2tf->tf_regs[FRAME_A3] = 0;		/* no error */
		p2tf->tf_regs[FRAME_A4] = 1;		/* is child */

		/*
		 * Arrange for continuation at child_return(), which
		 * will return to exception_return().  Note that the child
		 * process doesn't stay in the kernel for long!
		 */
		up->u_pcb.pcb_hw.apcb_ksp = (u_int64_t)p2tf;	
		up->u_pcb.pcb_context[0] = (u_int64_t)func;
		up->u_pcb.pcb_context[1] =
		    (u_int64_t)exception_return;	/* s1: ra */
		up->u_pcb.pcb_context[2] = (u_int64_t)arg;
		up->u_pcb.pcb_context[7] =
		    (u_int64_t)switch_trampoline;	/* ra: assembly magic */
d167 5
a171 5
		/*
		 * MULTIPROCESSOR kernels will reuse the IPL of the parent
		 * process, and will lower to IPL_NONE in proc_trampoline_mp().
		 */
		up->u_pcb.pcb_context[8] = IPL_SCHED;	/* ps: IPL */
d173 1
a173 1
		up->u_pcb.pcb_context[8] = IPL_NONE;	/* ps: IPL */
a174 1
	}
@


1.43
log
@emul_native is only used for kernel threads which can't dump core, so
delete coredump_trad(), uvm_coredump(), cpu_coredump(), struct md_coredump,
and various #includes that are superfluous.

This leaves compat_linux processes without a coredump callback.  If that
ability is desired, someone should update it to use coredump_elf32() and
verify the results...

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.42 2014/11/16 12:30:52 deraadt Exp $ */
d244 18
@


1.42
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.41 2014/02/01 21:19:35 miod Exp $ */
a38 1
#include <sys/core.h>
a46 47

/*
 * Dump the machine specific header information at the start of a core dump.
 */
int
cpu_coredump(p, vp, cred, chdr)
	struct proc *p;
	struct vnode *vp;
	struct ucred *cred;
	struct core *chdr;
{
	int error;
	struct md_coredump cpustate;
	struct coreseg cseg;

	CORE_SETMAGIC(*chdr, COREMAGIC, MID_ALPHA, 0);
	chdr->c_hdrsize = ALIGN(sizeof(*chdr));
	chdr->c_seghdrsize = ALIGN(sizeof(cseg));
	chdr->c_cpusize = sizeof(cpustate);

	cpustate.md_tf = *p->p_md.md_tf;
	cpustate.md_tf.tf_regs[FRAME_SP] = alpha_pal_rdusp();	/* XXX */
	if (p->p_md.md_flags & MDP_FPUSED) {
		if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
			fpusave_proc(p, 1);
		cpustate.md_fpstate = p->p_addr->u_pcb.pcb_fp;
	} else
		bzero(&cpustate.md_fpstate, sizeof(cpustate.md_fpstate));

	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_ALPHA, CORE_CPU);
	cseg.c_addr = 0;
	cseg.c_size = chdr->c_cpusize;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&cseg, chdr->c_seghdrsize,
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE, IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&cpustate, sizeof(cpustate),
	    (off_t)(chdr->c_hdrsize + chdr->c_seghdrsize), UIO_SYSSPACE,
	    IO_UNIT, cred, NULL, p);

	if (!error)
		chdr->c_nseg++;

	return error;
}
@


1.41
log
@Lower IPL_SCHED to IPL_CLOCK where it belongs.
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.40 2014/01/28 20:23:36 miod Exp $ */
d265 1
a265 1
		    VM_PROT_READ|VM_PROT_WRITE, PMAP_WIRED);
@


1.40
log
@In cpu_fork(), make sure to set the IPL of the new process to IPL_IPI on
MULTIPROCESSOR kernels, instead of IPL_NONE; they need to be ipi-safe until
proc_trampoline_mp() runs, which will also take care of lowering the ipl
to IPL_NONE.
One less race in the MP kernel, unfortunately a few more to go...
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.39 2013/01/16 19:04:43 miod Exp $ */
d226 5
a230 2
		up->u_pcb.pcb_context[8] =
		    ALPHA_PSL_IPL_HIGH;			/* ps: IPL */
d232 1
a232 2
		up->u_pcb.pcb_context[8] =
		    ALPHA_PSL_IPL_0;			/* ps: IPL */
@


1.39
log
@cpu_coredump() also needs to invoke vn_rdwr() without IO_NODELOCKED; only
affects a.out binaries' core dumps.
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.38 2012/11/01 21:01:43 miod Exp $ */
d110 1
a110 1
	 * vmspace's context until the switch to proc0 in switch_exit().
d204 1
a204 2
		bcopy(p1->p_md.md_tf, p2->p_md.md_tf,
		    sizeof(struct trapframe));
d225 7
a231 1
		up->u_pcb.pcb_context[8] = ALPHA_PSL_IPL_0; /* ps: IPL */
@


1.38
log
@In cpu_fork(), correctly set up the stack of the new process if required. This
repairs tfork_thread() operation.
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.37 2009/01/28 08:02:02 grange Exp $ */
d82 1
a82 2
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE,
	    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
d88 1
a88 1
	    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
@


1.37
log
@Add missing braces in trunc_page() call from vmapbuf().

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.36 2007/10/13 07:18:30 miod Exp $ */
d167 1
d171 5
a175 2
	p2->p_addr->u_pcb = p1->p_addr->u_pcb;
	p2->p_addr->u_pcb.pcb_hw.apcb_usp = alpha_pal_rdusp();
a213 6

		/*
		 * If specified, give the child a different stack.
		 */
		if (stack != NULL)
			p2tf->tf_regs[FRAME_SP] = (u_long)stack + stacksize;
@


1.36
log
@Fix cpu_exit() comments to be more closer to reality.
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.35 2007/10/10 15:53:51 art Exp $ */
d250 1
a250 1
	faddr = trunc_page((vaddr_t)bp->b_saveaddr = bp->b_data);
@


1.35
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.34 2007/09/03 01:24:22 krw Exp $ */
a98 3
 * We block interrupts and call switch_exit.  switch_exit switches
 * to proc0's PCB and stack, then jumps into the middle of cpu_switch,
 * as if it were switching from proc0.
@


1.34
log
@Typos from miod. 'specificed' -> 'specified' in some comments and man page.
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.33 2007/05/27 20:59:24 miod Exp $ */
d117 1
a117 3

	(void) splhigh();
	switch_exit(p);
@


1.33
log
@pagemove() is no longer used.
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.32 2006/11/29 12:26:11 miod Exp $ */
d217 1
a217 1
		 * If specificed, give the child a different stack.
@


1.32
log
@Remove cpu_swapin() and cpu_swapout(), they are no longer necessary (except
for cpu_swapin() on hppa* which is kept).
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.31 2006/04/13 14:41:08 brad Exp $ */
a234 42
	}
}

/*
 * Move pages from one kernel virtual address to another.
 * Both addresses are assumed to have valid page table pages.
 *
 * Note that since all kernel page table pages are pre-allocated
 * and mapped in, we can use the Virtual Page Table.
 */
void
pagemove(from, to, size)
	register caddr_t from, to;
	size_t size;
{
	long fidx, tidx;
	ssize_t todo;

#ifdef DIAGNOSTIC
	if ((size & PAGE_MASK) != 0)
		panic("pagemove");
#endif

	todo = size;			/* if testing > 0, need sign... */
	while (todo > 0) {
		fidx = VPT_INDEX(from);
		tidx = VPT_INDEX(to);

		VPT[tidx] = VPT[fidx];
		VPT[fidx] = 0;

		ALPHA_TBIS((vaddr_t)from);
		ALPHA_TBIS((vaddr_t)to);

#if defined(MULTIPROCESSOR) && 0
		pmap_tlb_shootdown(pmap_kernel(), (vaddr_t)from, PG_ASM);
		pmap_tlb_shootdown(pmap_kernel(), (vaddr_t)to, PG_ASM);
#endif

		todo -= PAGE_SIZE;
		from += PAGE_SIZE;
		to += PAGE_SIZE;
@


1.31
log
@Use PAGE_SIZE rather than NBPG.

From NetBSD

ok martin@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.30 2003/11/17 10:07:53 miod Exp $ */
a235 33
}
/*
 * Finish a swapin operation.
 * We needed to update the cached PTEs for the user area in the
 * machine dependent part of the proc structure.
 */
void
cpu_swapin(p)
	register struct proc *p;
{
	struct user *up = p->p_addr;

	/*
	 * Cache the physical address of the pcb, so we can swap to
	 * it easily.
	 */
	p->p_md.md_pcbpaddr = (void *)vtophys((vaddr_t)&up->u_pcb);
}

/*
 * cpu_swapout is called immediately before a process's 'struct user'
 * and kernel stack are unwired, and after the process' P_INMEM flag
 * is cleared).  If the process is the current owner of the floating
 * point unit, the FP state has to be saved, so that it goes out with
 * the pcb, which is in the user area.
 */
void
cpu_swapout(p)
	struct proc *p;
{

	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 1);
@


1.30
log
@Sync cpu_swapout() comments with reality.
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.29 2003/10/18 20:14:40 jmc Exp $ */
d307 3
a309 3
		todo -= NBPG;
		from += NBPG;
		to += NBPG;
@


1.29
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.28 2002/04/28 20:55:14 pvalchev Exp $ */
d257 4
a260 4
 * and kernel stack are unwired (which are in turn done immediately
 * before it's P_INMEM flag is cleared).  If the process is the
 * current owner of the floating point unit, the FP state has to be
 * saved, so that it goes out with the pcb, which is in the user area.
@


1.28
log
@IEEE 754 floating point completion code, and implementation of the
FP_C (Floating Point Control Quadword).

From ross@@NetBSD.  Added a way to disable it with option NO_IEEE,
which appears on the ramdisks to save space.  This affects only
programs compiled with -mieee, and what it essentially does is
enabling infinities and NaNs, instead of generating SIGFPE on
division by zero, overflow, etc.
ok art, deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.27 2001/12/08 02:24:05 art Exp $ */
d239 1
a239 1
 * We neded to update the cached PTEs for the user area in the
@


1.27
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.26 2001/11/06 19:53:13 miod Exp $ */
d71 3
a73 6
		if (p == fpcurproc) {
			alpha_pal_wrfen(1);
			savefpstate(&cpustate.md_fpstate);
			alpha_pal_wrfen(0);
		} else
			cpustate.md_fpstate = p->p_addr->u_pcb.pcb_fp;
d108 2
a109 2
	if (p == fpcurproc)
		fpcurproc = NULL;
d150 4
d155 1
d167 2
a168 5
	if (p1 == fpcurproc) {
		alpha_pal_wrfen(1);
		savefpstate(&fpcurproc->p_addr->u_pcb.pcb_fp);
		alpha_pal_wrfen(0);
	}
d267 2
a268 7
	if (p != fpcurproc)
		return;

	alpha_pal_wrfen(1);
	savefpstate(&fpcurproc->p_addr->u_pcb.pcb_fp);
	alpha_pal_wrfen(0);
	fpcurproc = NULL;
@


1.27.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.27 2001/12/08 02:24:05 art Exp $ */
d71 6
a76 3
		if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
			fpusave_proc(p, 1);
		cpustate.md_fpstate = p->p_addr->u_pcb.pcb_fp;
d111 2
a112 2
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 0);
a152 4

#ifndef NO_IEEE
	p2->p_md.md_flags = p1->p_md.md_flags & (MDP_FPUSED | MDP_FP_C);
#else
a153 1
#endif
d165 5
a169 2
	if (p1->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p1, 1);
d268 7
a274 2
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 1);
@


1.26
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.25 2001/11/06 18:41:09 art Exp $ */
d351 1
d369 2
@


1.25
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.24 2001/09/19 20:50:55 mickey Exp $ */
a41 1
#include <vm/vm.h>
@


1.24
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.23 2001/07/25 13:25:31 art Exp $ */
d137 1
a137 2
 * p1 is the process being forked; if p1 == &proc0, we are creating
 * a kernel thread, and the return path will later be changed in cpu_set_kpc.
d144 2
a145 2
cpu_fork(p1, p2, stack, stacksize)
	register struct proc *p1, *p2;
d148 2
a227 2
		 * 
		 * This is an inlined version of cpu_set_kpc.
d230 1
a230 2
		up->u_pcb.pcb_context[0] =
		    (u_int64_t)child_return;		/* s0: pc */
d233 1
a233 2
		up->u_pcb.pcb_context[2] =
		    (u_int64_t)p2;			/* s2: arg */
a238 30

/*
 * cpu_set_kpc:
 *
 * Arrange for in-kernel execution of a process to continue at the
 * named pc, as if the code at that address were called as a function
 * with argument, the current process's process pointer.
 *
 * Note that it's assumed that when the named process returns,
 * exception_return() should be invoked, to return to user mode.
 *
 * (Note that cpu_fork(), above, uses an open-coded version of this.)
 */
void
cpu_set_kpc(p, pc, arg)
	struct proc *p;
	void (*pc) __P((void *));
	void *arg;
{
	struct pcb *pcbp;

	pcbp = &p->p_addr->u_pcb;
	pcbp->pcb_context[0] = (u_int64_t)pc;	/* s0 - pc to invoke */
	pcbp->pcb_context[1] =
	    (u_int64_t)exception_return;	/* s1 - return address */
	pcbp->pcb_context[2] = (u_int64_t)arg;	/* s2 - arg */
	pcbp->pcb_context[7] =
	    (u_int64_t)switch_trampoline;	/* ra - assembly magic */
}

@


1.23
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.22 2001/06/08 08:08:38 art Exp $ */
a42 2
#include <vm/vm_kern.h>

@


1.22
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.21 2001/05/06 00:45:45 art Exp $ */
d383 1
a383 1
		    VM_PROT_READ|VM_PROT_WRITE, TRUE, 0);
@


1.21
log
@Update some comments wrt. the CLSIZE changes.
And remove that memory price comment from 1981. It is amusing, but also
confusing because the math in there is only correct on vax.
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.20 2001/04/13 03:07:29 art Exp $ */
d379 2
a380 2
		if ((pa = pmap_extract(vm_map_pmap(&p->p_vmspace->vm_map),
		    faddr)) == 0)
@


1.20
log
@In cpu_fork, initialize the ipl of the new process to
run at IPL_0.

From NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.19 2001/03/21 10:15:05 art Exp $ */
d315 1
a315 2
 * Both addresses are assumed to have valid page table pages
 * and size must be a multiple of CLSIZE.
@


1.19
log
@optimize a sanity check and put it behind ifdef DIAGNOSTIC.
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.18 2001/01/20 20:27:40 art Exp $ */
d241 1
@


1.18
log
@No need to include machine/alpha.h here.
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.17 2000/11/08 19:16:59 ericj Exp $ */
d328 2
a329 1
	if (size % NBPG)
d331 1
@


1.17
log
@add tags
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a47 1
#include <machine/alpha.h>
@


1.16
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
@


1.15
log
@Add explicit inclusions of signalvar.h to files actually using syms defined
there but relying on an indirect inclusion
@
text
@d1 1
a1 2
/*	$OpenBSD: vm_machdep.c,v 1.14 2000/06/08 11:57:21 art Exp $	*/
/*	$NetBSD: vm_machdep.c,v 1.21 1996/11/13 21:13:15 cgd Exp $	*/
d41 5
d47 1
a50 5
#include <vm/vm.h>
#include <vm/vm_kern.h>

extern void exception_return __P((void));
extern void child_return __P((struct proc *));
a64 1
	extern struct proc *fpcurproc;
d105 3
a107 4
 * We release the address space of the process, block interrupts,
 * and call switch_exit.  switch_exit switches to proc0's PCB and stack,
 * then jumps into the middle of cpu_switch, as if it were switching
 * from proc0.
a112 1
	extern struct proc *fpcurproc;
d117 7
d131 14
a144 6
 * Copy and update the kernel stack and pcb, making the child
 * ready to run, and marking it so that it can return differently
 * than the parent.  Returns 1 in the child process, 0 in the parent.
 * We currently double-map the user area so that the stack is at the same
 * address in each process; in the future we will probably relocate
 * the frame pointers on the stack after copying.
a152 3
	pt_entry_t *ptep;
	int i;
	extern struct proc *fpcurproc;
d161 1
a161 19
#ifndef NEW_PMAP
	ptep = kvtopte(up);
	p2->p_md.md_pcbpaddr =
	    &((struct user *)(PG_PFNUM(*ptep) << PGSHIFT))->u_pcb;
#else
	p2->p_md.md_pcbpaddr = (void *)vtophys((vm_offset_t)&up->u_pcb);
	printf("process %d pcbpaddr = 0x%lx, pmap = %p\n",
	    p2->p_pid, p2->p_md.md_pcbpaddr,&p2->p_vmspace->vm_map.pmap);
#endif

	/*
	 * Simulate a write to the process's U-area pages,
	 * so that the system doesn't lose badly.
	 * (If this isn't done, the kernel can't read or
	 * write the kernel stack.  "Ouch!")
	 */
	for (i = 0; i < UPAGES; i++)
		pmap_emulate_reference(p2, (vm_offset_t)up + i * PAGE_SIZE,
		    0, 1);
a179 5
#ifndef NEW_PMAP
	PMAP_ACTIVATE(&p2->p_vmspace->vm_pmap, 0);
#else
printf("NEW PROCESS %d USP = %p\n", p2->p_pid, p2->p_addr->u_pcb.pcb_hw.apcb_usp);
#endif
a211 3
#ifdef NEW_PMAP
printf("FORK CHILD: pc = %p, ra = %p\n", p2tf->tf_regs[FRAME_PC], p2tf->tf_regs[FRAME_RA]);
#endif
d249 1
a249 1
 * with argument, the current process' process pointer.
d266 2
a267 2
	pcbp->pcb_context[1] = (u_int64_t)exception_return;
						/* s1 - return address */
a282 2
	pt_entry_t *ptep;
	int i;
d288 1
a288 17
#ifndef NEW_PMAP
	ptep = kvtopte(up);
	p->p_md.md_pcbpaddr =
	    &((struct user *)(PG_PFNUM(*ptep) << PGSHIFT))->u_pcb;
#else
	p->p_md.md_pcbpaddr = (void *)vtophys((vm_offset_t)&up->u_pcb);
#endif

	/*
	 * Simulate a write to the process's U-area pages,
	 * so that the system doesn't lose badly.
	 * (If this isn't done, the kernel can't read or
	 * write the kernel stack.  "Ouch!")
	 */
	for (i = 0; i < UPAGES; i++)
		pmap_emulate_reference(p, (vm_offset_t)up + i * PAGE_SIZE,
		    0, 1);
a301 1
	extern struct proc *fpcurproc;
d314 1
a314 1
 * Both addresses are assumed to reside in the Sysmap,
d316 3
d325 1
a325 1
	register pt_entry_t *fpte, *tpte;
d328 1
a328 1
	if (size % CLBYTES)
d330 1
a330 7
#ifndef NEW_PMAP
	fpte = kvtopte(from);
	tpte = kvtopte(to);
#else
	fpte = pmap_pte(kernel_pmap, (vm_offset_t)from);
	tpte = pmap_pte(kernel_pmap, (vm_offset_t)to);
#endif
d333 14
a346 4
		ALPHA_TBIS((vm_offset_t)from);
		*tpte++ = *fpte;
		*fpte = 0;
		fpte++;
a352 2
extern vm_map_t phys_map;

d354 3
a356 16
 * Map an IO request into kernel virtual address space.  Requests fall into
 * one of five catagories:
 *
 *	B_PHYS|B_UAREA:	User u-area swap.
 *			Address is relative to start of u-area (p_addr).
 *	B_PHYS|B_PAGET:	User page table swap.
 *			Address is a kernel VA in usrpt (Usrptmap).
 *	B_PHYS|B_DIRTY:	Dirty page push.
 *			Address is a VA in proc2's address space.
 *	B_PHYS|B_PGIN:	Kernel pagein of user pages.
 *			Address is VA in user's address space.
 *	B_PHYS:		User "raw" IO request.
 *			Address is VA in user's address space.
 *
 * All requests are (re)mapped into kernel VA space via the useriomap
 * (a name with only slightly more meaning than "kernelmap")
d361 1
a361 1
	vm_size_t len;
d363 2
a364 1
	vm_offset_t faddr, taddr, off, pa;
d370 2
a371 2
	faddr = trunc_page(bp->b_saveaddr = bp->b_data);
	off = (vm_offset_t)bp->b_data - faddr;
d373 1
a373 1
	taddr = kmem_alloc_wait(phys_map, len);
d377 2
a378 2
		pa = pmap_extract(vm_map_pmap(&p->p_vmspace->vm_map), faddr);
		if (pa == 0)
d388 1
a388 2
 * Free the io map PTEs associated with this IO operation.
 * We also invalidate the TLB entries and restore the original b_addr.
d393 1
a393 1
	vm_size_t len;
d395 1
a395 1
	vm_offset_t addr, off;
d399 2
a400 2
	addr = trunc_page(bp->b_data);
	off = (vm_offset_t)bp->b_data - addr;
d402 1
a402 1
	kmem_free_wakeup(phys_map, addr, len);
@


1.14
log
@&vm_pmap -> vm_map.pmap
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.13 2000/06/05 11:02:55 art Exp $	*/
d34 1
@


1.13
log
@Changes to exit handling.

cpu_exit no longer frees the vmspace and u-area. This is now handled by a
separate kernel thread "reaper". This is to avoid sleeping locks in the
critical path of cpu_exit where we're not allowed to sleep.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.12 1999/09/14 11:41:18 kstailey Exp $	*/
d158 1
a158 1
	    p2->p_pid, p2->p_md.md_pcbpaddr, &p2->p_vmspace->vm_pmap);
@


1.12
log
@don't panic when creating kernel threads
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.11 1999/09/03 18:00:13 art Exp $	*/
a117 2

	vmspace_free(p->p_vmspace);
@


1.12.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 2
/* $OpenBSD: vm_machdep.c,v 1.20 2001/04/13 03:07:29 art Exp $ */
/* $NetBSD: vm_machdep.c,v 1.55 2000/03/29 03:49:48 simonb Exp $ */
a33 1
#include <sys/signalvar.h>
a40 5
#include <vm/vm.h>
#include <vm/vm_kern.h>

#include <uvm/uvm_extern.h>

d45 5
d64 1
d105 4
a108 3
 * We block interrupts and call switch_exit.  switch_exit switches
 * to proc0's PCB and stack, then jumps into the middle of cpu_switch,
 * as if it were switching from proc0.
d114 1
d119 1
a119 6
	/*
	 * Deactivate the exiting address space before the vmspace
	 * is freed.  Note that we will continue to run on this
	 * vmspace's context until the switch to proc0 in switch_exit().
	 */
	pmap_deactivate(p);
d128 6
a133 14
 * Copy and update the pcb and trap frame, making the child ready to run.
 * 
 * Rig the child's kernel stack so that it will start out in
 * switch_trampoline() and call child_return() with p2 as an
 * argument. This causes the newly-created child process to go
 * directly to user level with an apparent return value of 0 from
 * fork(), while the parent process returns normally.
 *
 * p1 is the process being forked; if p1 == &proc0, we are creating
 * a kernel thread, and the return path will later be changed in cpu_set_kpc.
 *
 * If an alternate user-level stack is requested (with non-zero values
 * in both the stack and stacksize args), set up the user stack pointer
 * accordingly.
d142 3
d153 19
a171 1
	p2->p_md.md_pcbpaddr = (void *)vtophys((vaddr_t)&up->u_pcb);
d190 5
d227 3
a258 1
		up->u_pcb.pcb_context[8] = ALPHA_PSL_IPL_0; /* ps: IPL */
d267 1
a267 1
 * with argument, the current process's process pointer.
d284 2
a285 2
	pcbp->pcb_context[1] =
	    (u_int64_t)exception_return;	/* s1 - return address */
d301 2
d308 17
a324 1
	p->p_md.md_pcbpaddr = (void *)vtophys((vaddr_t)&up->u_pcb);
d338 1
d351 1
a351 1
 * Both addresses are assumed to have valid page table pages
a352 3
 *
 * Note that since all kernel page table pages are pre-allocated
 * and mapped in, we can use the Virtual Page Table.
d359 1
a359 1
	long fidx, tidx;
d362 1
a362 2
#ifdef DIAGNOSTIC
	if ((size & PAGE_MASK) != 0)
d364 6
a370 1

d373 4
a376 14
		fidx = VPT_INDEX(from);
		tidx = VPT_INDEX(to);

		VPT[tidx] = VPT[fidx];
		VPT[fidx] = 0;

		ALPHA_TBIS((vaddr_t)from);
		ALPHA_TBIS((vaddr_t)to);

#if defined(MULTIPROCESSOR) && 0
		pmap_tlb_shootdown(pmap_kernel(), (vaddr_t)from, PG_ASM);
		pmap_tlb_shootdown(pmap_kernel(), (vaddr_t)to, PG_ASM);
#endif

d383 2
d386 16
a401 3
 * Map a user I/O request into kernel virtual address space.
 * Note: the pages are already locked by uvm_vslock(), so we
 * do not need to pass an access_type to pmap_enter().
d406 1
a406 1
	vsize_t len;
d408 1
a408 2
	vaddr_t faddr, taddr, off;
	paddr_t pa;
d414 2
a415 2
	faddr = trunc_page((vaddr_t)bp->b_saveaddr = bp->b_data);
	off = (vaddr_t)bp->b_data - faddr;
d417 1
a417 1
	taddr = uvm_km_valloc_wait(phys_map, len);
d421 2
a422 2
		if ((pa = pmap_extract(vm_map_pmap(&p->p_vmspace->vm_map),
		    faddr)) == 0)
d432 2
a433 1
 * Unmap a previously-mapped user I/O request.
d438 1
a438 1
	vsize_t len;
d440 1
a440 1
	vaddr_t addr, off;
d444 2
a445 2
	addr = trunc_page((vaddr_t)bp->b_data);
	off = (vaddr_t)bp->b_data - addr;
d447 1
a447 1
	uvm_km_free_wakeup(phys_map, addr, len);
@


1.12.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.12.4.1 2001/04/18 16:00:32 niklas Exp $ */
d315 2
a316 1
 * Both addresses are assumed to have valid page table pages.
d380 2
a381 2
		if (pmap_extract(vm_map_pmap(&p->p_vmspace->vm_map),
		    faddr, &pa) == FALSE)
@


1.12.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: vm_machdep.c,v 1.12.4.2 2001/07/04 10:14:25 niklas Exp $ */
d43 2
d383 1
a383 1
		    VM_PROT_READ|VM_PROT_WRITE, PMAP_WIRED);
@


1.12.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d42 1
d137 2
a138 1
 * p1 is the process being forked;
d145 2
a146 2
cpu_fork(p1, p2, stack, stacksize, func, arg)
	struct proc *p1, *p2;
a148 2
	void (*func)(void *);
	void *arg;
d227 2
d231 2
a232 1
		up->u_pcb.pcb_context[0] = (u_int64_t)func;
d235 2
a236 1
		up->u_pcb.pcb_context[2] = (u_int64_t)arg;
d242 30
@


1.12.4.5
log
@Merge in trunk
@
text
@a350 1
	pmap_update(vm_map_pmap(phys_map));
a367 2
	pmap_remove(vm_map_pmap(phys_map), addr, addr + len);
	pmap_update(vm_map_pmap(phys_map));
@


1.12.4.6
log
@Sync the SMP branch with 3.3
@
text
@d71 6
a76 3
		if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
			fpusave_proc(p, 1);
		cpustate.md_fpstate = p->p_addr->u_pcb.pcb_fp;
d111 2
a112 2
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 0);
a152 4

#ifndef NO_IEEE
	p2->p_md.md_flags = p1->p_md.md_flags & (MDP_FPUSED | MDP_FP_C);
#else
a153 1
#endif
d165 5
a169 2
	if (p1->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p1, 1);
d268 7
a274 2
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 1);
@


1.12.4.7
log
@Merge of -current from two weeks ago into the SMP branch
@
text
@d239 1
a239 1
 * We needed to update the cached PTEs for the user area in the
d257 4
a260 4
 * and kernel stack are unwired, and after the process' P_INMEM flag
 * is cleared).  If the process is the current owner of the floating
 * point unit, the FP state has to be saved, so that it goes out with
 * the pcb, which is in the user area.
@


1.11
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.10 1999/08/17 10:32:16 niklas Exp $	*/
d201 5
a205 1
	if (p1 != curproc)
@


1.10
log
@New cpu_fork API to take a stack in which you point the child's stackpointer
to, at the bottom or the top, depending on your architecture's stack growth
direction.  This is in preparation for Linux' clone(2) emulation.
port maintainers, please check that I did the work right.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.9 1999/01/10 13:34:17 niklas Exp $	*/
d421 1
a421 1
		    VM_PROT_READ|VM_PROT_WRITE, TRUE);
@


1.9
log
@Generalize cpu_set_kpc to take any kind of arg; mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.8 1998/07/28 00:13:26 millert Exp $	*/
d136 1
a136 1
cpu_fork(p1, p2)
d138 2
d232 6
@


1.8
log
@Return EINVAL when msg_iovlen or iovcnt <= 0; Make uio_resid unsigned (size_t) and don't return EINVAL if it is < 0 in sys_{read,write}.  Remove check for uio_resid < 0 uiomove() now that uio_resid is unsigned and brack remaining panics with #ifdef DIAGNOSTIC.  vn_rdwr() must now take a size_t * as its 9th argument so change that and clean up uses of vn_rdwr().  Fixes 549 + more
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.7 1998/03/01 16:12:12 niklas Exp $	*/
d243 2
d255 1
a255 1
 * with argument, the current process's process pointer.
d263 1
a263 1
cpu_set_kpc(p, pc)
d265 2
a266 1
	void (*pc) __P((struct proc *));
d272 3
a274 1
	pcbp->pcb_context[1] = (u_int64_t)exception_return; /* s1 - return address */
@


1.7
log
@GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.6 1997/01/24 19:56:47 niklas Exp $	*/
d89 1
a89 1
	    IO_NODELOCKED|IO_UNIT, cred, (int *)NULL, p);
d95 1
a95 1
	    IO_NODELOCKED|IO_UNIT, cred, (int *)NULL, p);
@


1.6
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.5 1996/10/30 22:38:30 niklas Exp $	*/
d73 1
a73 1
	if (p->p_md.md_flags & MDP_FPUSED)
d80 1
a80 1
	else
@


1.5
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 2
a2 2
/*	$OpenBSD: vm_machdep.c,v 1.20 1996/10/13 02:59:50 christos Exp $	*/
/*	$NetBSD: vm_machdep.c,v 1.20 1996/10/13 02:59:50 christos Exp $	*/
@


1.4
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: vm_machdep.c,v 1.9 1996/04/23 15:26:10 cgd Exp $	*/
/*	$NetBSD: vm_machdep.c,v 1.9 1996/04/23 15:26:10 cgd Exp $	*/
d48 3
d54 1
d62 1
a62 5
	register struct user *up = p->p_addr;
	struct cpustate {
		struct trapframe regs;
		struct fpreg fpstate;
	} cpustate;
d71 2
a72 1
	cpustate.regs = *p->p_md.md_tf;
d75 3
a77 3
			pal_wrfen(1);
			savefpstate(&cpustate.fpstate);
			pal_wrfen(0);
d79 1
a79 1
			cpustate.fpstate = p->p_addr->u_pcb.pcb_fp;
d81 1
a81 1
		bzero(&cpustate.fpstate, sizeof(cpustate.fpstate));
a142 1
	extern void proc_trampoline(), rei(), child_return();
d151 1
d155 5
d176 1
a176 1
		pal_wrfen(1);
d178 1
a178 1
		pal_wrfen(0);
d187 2
d190 3
d201 1
a201 1
	if (up->u_pcb.pcb_fen != 0)
a209 1
		extern void rei();
d221 3
d233 2
a234 2
		 * will return to rei().  Note that the child process
		 * doesn't stay in the kernel for long!
d238 1
a238 1
		up->u_pcb.pcb_ksp = (u_int64_t)p2tf;	
d242 1
a242 1
		    (u_int64_t)rei;			/* s1: ra */
d244 1
a244 1
		    (u_int64_t)proc_trampoline;		/* ra: assembly magic */
d255 2
a256 2
 * Note that it's assumed that when the named process returns, rei()
 * should be invoked, to return to user mode.
a265 2
	extern void proc_trampoline();
	extern void rei();
d269 1
a269 1
	pcbp->pcb_context[1] = (u_int64_t)rei;	/* s1 - return address */
d271 1
a271 1
	    (u_int64_t)proc_trampoline;		/* ra - assembly magic */
d291 1
d295 3
d326 1
a326 1
	pal_wrfen(1);
d328 1
a328 1
	pal_wrfen(0);
d347 1
d350 4
d356 1
a356 1
		TBIS(from);
@


1.3
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.2
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: vm_machdep.c,v 1.6 1995/12/09 04:37:23 mycroft Exp $	*/
d4 1
a4 1
 * Copyright (c) 1994, 1995 Carnegie-Mellon University.
d249 1
a249 1
	u_int64_t pc;
d256 1
a256 1
	pcbp->pcb_context[0] = pc;		/* s0 - pc to invoke */
d321 1
d324 1
a324 1
	int size;
d327 1
d333 2
a334 1
	while (size > 0) {
d339 1
a339 1
		size -= NBPG;
d365 1
d397 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: vm_machdep.c,v 1.4 1995/06/28 02:45:23 cgd Exp $	*/
d133 1
d141 1
d155 10
d218 5
a222 2
		 * Arrange for continuation at rei().  Note that the
		 * child process doesn't stay in the kernel for long!
d224 7
a230 3
		up->u_pcb.pcb_ksp = (u_int64_t)p2tf;
		up->u_pcb.pcb_context[7] = (u_int64_t)rei;
		up->u_pcb.pcb_context[8] = 0;
a231 2

	return (0);
d243 2
d282 10
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

