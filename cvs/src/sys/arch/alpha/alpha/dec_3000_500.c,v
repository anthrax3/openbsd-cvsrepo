head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.14
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.10
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.6
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.8
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.12.0.32
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.28
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.26
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.24
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.22
	OPENBSD_5_0:1.12.0.20
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.18
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.16
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.12
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.14
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.10
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.8
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.6
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.4
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.11.0.18
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.16
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.14
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.12
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.10
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.8
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.6
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.11
	UBC:1.8.0.6
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.5.0.18
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.16
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.14
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.12
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2014.05.08.20.46.49;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.25.21.33.19;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.02.22.56.06;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.26;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.08.21.48.43;	author art;	state Exp;
branches
	1.8.6.1;
next	1.7;

1.7
date	2000.11.08.19.16.58;	author ericj;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.08.16.00.59;	author art;	state Exp;
branches;
next	1.5;

1.5
date	97.01.24.19.56.25;	author niklas;	state Exp;
branches
	1.5.14.1;
next	1.4;

1.4
date	96.10.30.22.38.05;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.07.29.22.57.26;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.18.09.42.09;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.39;	author deraadt;	state Exp;
branches;
next	;

1.5.14.1
date	2001.04.18.16.00.15;	author niklas;	state Exp;
branches;
next	1.5.14.2;

1.5.14.2
date	2002.03.28.10.06.12;	author niklas;	state Exp;
branches;
next	1.5.14.3;

1.5.14.3
date	2003.03.27.23.18.05;	author niklas;	state Exp;
branches;
next	;

1.8.6.1
date	2002.06.11.03.33.39;	author art;	state Exp;
branches;
next	1.8.6.2;

1.8.6.2
date	2002.10.29.00.28.00;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Format string fixes for alpha kernels, and remove -Wno-format
@
text
@/* $OpenBSD: dec_3000_500.c,v 1.12 2006/11/28 16:56:50 dlg Exp $ */
/* $NetBSD: dec_3000_500.c,v 1.29 2000/05/22 20:13:32 thorpej Exp $ */

/*
 * Copyright (c) 1994, 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */
/*
 * Additional Copyright (c) 1997 by Matthew Jacob for NASA/Ames Research Center
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/termios.h>
#include <dev/cons.h>
#include <sys/conf.h>

#include <machine/rpb.h>
#include <machine/autoconf.h>
#include <machine/cpuconf.h>

#include <dev/tc/tcvar.h>
#include <dev/tc/tcdsvar.h>
#include <alpha/tc/tc_3000_500.h>
#ifndef NEW_SCC_DRIVER
#include <alpha/tc/sccvar.h>
#endif

#if 0
#include <machine/z8530var.h>
#include <dev/dec/zskbdvar.h>
#endif

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include "wsdisplay.h"

void dec_3000_500_init(void);
static void dec_3000_500_cons_init(void);
static void dec_3000_500_device_register(struct device *, void *);

static const char dec_3000_500_sp[] = "DEC 3000/400 (\"Sandpiper\")";
static const char dec_3000_500_sf[] = "DEC 3000/500 (\"Flamingo\")";

const struct alpha_variation_table dec_3000_500_variations[] = {
	{ SV_ST_SANDPIPER, dec_3000_500_sp },
	{ SV_ST_FLAMINGO, dec_3000_500_sf },
	{ SV_ST_HOTPINK, "DEC 3000/500X (\"Hot Pink\")" },
	{ SV_ST_FLAMINGOPLUS, "DEC 3000/800 (\"Flamingo+\")" },
	{ SV_ST_SANDPLUS, "DEC 3000/600 (\"Sandpiper+\")" },
	{ SV_ST_SANDPIPER45, "DEC 3000/700 (\"Sandpiper45\")" },
	{ SV_ST_FLAMINGO45, "DEC 3000/900 (\"Flamingo45\")" },
	{ 0, NULL },
};

void
dec_3000_500_init()
{
	u_int64_t variation;

	platform.family = "DEC 3000/500 (\"Flamingo\")";

	if ((platform.model = alpha_dsr_sysname()) == NULL) {
		variation = hwrpb->rpb_variation & SV_ST_MASK;
		if (variation == SV_ST_ULTRA) {
			/* These are really the same. */
			variation = SV_ST_FLAMINGOPLUS;
		}
		if ((platform.model = alpha_variation_name(variation,
		    dec_3000_500_variations)) == NULL) {
			/*
			 * This is how things used to be done.
			 */
			if (variation == SV_ST_RESERVED) {
				if (hwrpb->rpb_variation & SV_GRAPHICS)
					platform.model = dec_3000_500_sf;
				else
					platform.model = dec_3000_500_sp;
			} else
				platform.model = alpha_unknown_sysname();
		}
	}

	platform.iobus = "tcasic";
	platform.cons_init = dec_3000_500_cons_init;
	platform.device_register = dec_3000_500_device_register;
}

static void
dec_3000_500_cons_init()
{
	struct ctb *ctb;

	ctb = (struct ctb *)(((caddr_t)hwrpb) + hwrpb->rpb_ctb_off);

#ifndef NEW_SCC_DRIVER
	switch (ctb->ctb_term_type) {
	case CTB_GRAPHICS:
#ifdef notyet
		alpha_donot_kludge_scc = 1;
#endif
		return;
	case CTB_PRINTERPORT:
		return;
	default:
		goto badconsole;
	}
#else

	switch (ctb->ctb_term_type) {
	case CTB_GRAPHICS:
#if NWSDISPLAY > 0
		/* display console ... */
		if (zs_ioasic_lk201_cnattach(0x1e0000000, 0x00180000, 0) == 0 &&
		    tc_3000_500_fb_cnattach(
		     CTB_TURBOSLOT_SLOT(ctb->ctb_turboslot)) == 0) {
			break;
		}
#endif
		printf("consinit: Unable to init console on keyboard and ");
		printf("TURBOchannel slot 0x%lx.\n", ctb->ctb_turboslot);
		printf("Using serial console.\n");
		/* FALLTHROUGH */

	case CTB_PRINTERPORT:
		/* serial console ... */
		/*
		 * XXX This could stand some cleanup...
		 */
		{
			/*
			 * Delay to allow PROM putchars to complete.
			 * FIFO depth * character time,
			 * character time = (1000000 / (defaultrate / 10))
			 */
			DELAY(160000000 / 9600);	/* XXX */

			/*
			 * Console is channel B of the second SCC.
			 * XXX Should use ctb_line_off to get the
			 * XXX line parameters--these are the defaults.
			 */
			if (zs_ioasic_cnattach(0x1e0000000, 0x00180000, 1,
			    9600, (TTYDEF_CFLAG & ~(CSIZE | PARENB)) | CS8))
				panic("can't init serial console");
			break;
		}
	default:
		goto badconsole;
	}
#endif
	return;
badconsole:
	printf("ctb->ctb_term_type = 0x%lx\n",
	    (unsigned long)ctb->ctb_term_type);
	printf("ctb->ctb_turboslot = 0x%lx\n",
	    (unsigned long)ctb->ctb_turboslot);

	panic("consinit: unknown console type %lu",
	    (unsigned long)ctb->ctb_term_type);
}

static void
dec_3000_500_device_register(dev, aux)
	struct device *dev;
	void *aux;
{
	static int found, initted, scsiboot, netboot;
	static struct device *scsidev;
	static struct device *tcdsdev;
	struct bootdev_data *b = bootdev_data;
	struct device *parent = dev->dv_parent;
	struct cfdata *cf = dev->dv_cfdata;
	struct cfdriver *cd = cf->cf_driver;

	if (found)
		return;

	if (!initted) {
		scsiboot = (strcmp(b->protocol, "SCSI") == 0);
		netboot = (strcmp(b->protocol, "BOOTP") == 0) ||
		    (strcmp(b->protocol, "MOP") == 0);
#if 0
		printf("scsiboot = %d, netboot = %d\n", scsiboot, netboot);
#endif
		initted = 1;
	}

	/*
	 * for scsi boot, we look for "tcds", make sure it has the
	 * right slot number, then find the "asc" on this tcds that
	 * as the right channel.  then we find the actual scsi
	 * device we came from.  note: no SCSI LUN support (yet).
	 */
	if (scsiboot && (strcmp(cd->cd_name, "tcds") == 0)) {
		struct tc_attach_args *tcargs = aux;

		if (b->slot != tcargs->ta_slot)
			return;

		tcdsdev = dev;
#if 0
		printf("\ntcdsdev = %s\n", dev->dv_xname);
#endif
	}
	if (scsiboot && tcdsdev &&
	    (strcmp(cd->cd_name, "asc") == 0)) {
		struct tcdsdev_attach_args *ta = aux;

		if (parent != (struct device *)tcdsdev)
			return;

		if (ta->tcdsda_chip != b->channel)
			return;

		scsidev = dev;
#if 0
		printf("\nscsidev = %s\n", dev->dv_xname);
#endif
	}

	if (scsiboot && scsidev &&
	    (strcmp(cd->cd_name, "sd") == 0 ||
	     strcmp(cd->cd_name, "st") == 0 ||
	     strcmp(cd->cd_name, "cd") == 0)) {
		struct scsi_attach_args *sa = aux;

		if (parent->dv_parent != scsidev)
			return;

		if (b->unit / 100 != sa->sa_sc_link->target)
			return;

		/* XXX LUN! */

		switch (b->boot_dev_type) {
		case 0:
			if (strcmp(cd->cd_name, "sd") &&
			    strcmp(cd->cd_name, "cd"))
				return;
			break;
		case 1:
			if (strcmp(cd->cd_name, "st"))
				return;
			break;
		default:
			return;
		}

		/* we've found it! */
		booted_device = dev;
#if 0
		printf("\nbooted_device = %s\n", booted_device->dv_xname);
#endif
		found = 1;
	}

	if (netboot) {
                if (b->slot == 7 && strcmp(cd->cd_name, "le") == 0 &&
		    strcmp(parent->dv_cfdata->cf_driver->cd_name, "ioasic")
		     == 0) {
			/*
			 * no need to check ioasic_attach_args, since only
			 * one le on ioasic.
			 */

			booted_device = dev;
#if 0
			printf("\nbooted_device = %s\n", booted_device->dv_xname);
#endif
			found = 1;
			return;
		}

		/*
		 * XXX GENERIC SUPPORT FOR TC NETWORK BOARDS
		 */
        }
}
@


1.12
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dec_3000_500.c,v 1.11 2002/06/25 21:33:19 miod Exp $ */
d178 4
a181 2
	printf("ctb->ctb_term_type = 0x%lx\n", ctb->ctb_term_type);
	printf("ctb->ctb_turboslot = 0x%lx\n", ctb->ctb_turboslot);
d184 1
a184 1
	    ctb->ctb_term_type);
@


1.11
log
@No \n at the end of a panic() message... I thought all occurences had been
squashed already.
@
text
@d1 1
a1 1
/* $OpenBSD: dec_3000_500.c,v 1.10 2002/05/02 22:56:06 miod Exp $ */
d248 1
a248 1
		struct scsibus_attach_args *sa = aux;
@


1.10
log
@Big TURBOchannel support catchup from NetBSD, part 1.
A few local changes and tweaks remain.

This bring DEC 3000 machines back in the game, but framebuffers are still
not supported at the moment.

Thanks to ericj@@ and nate@@ for supplying me a DEC 3000 for testing.
@
text
@d1 1
a1 1
/* $OpenBSD: dec_3000_500.c,v 1.9 2002/03/14 01:26:26 millert Exp $ */
d181 1
a181 1
	panic("consinit: unknown console type %lu\n",
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: dec_3000_500.c,v 1.8 2000/11/08 21:48:43 art Exp $ */
d46 1
a46 1
#include <alpha/tc/tcdsvar.h>
d235 1
a235 1
		if (ta->tcdsda_slot != b->channel)
@


1.8
log
@no need to extern booted_device everywhere.
@
text
@d1 1
a1 1
/* $OpenBSD: dec_3000_500.c,v 1.7 2000/11/08 19:16:58 ericj Exp $ */
d62 3
a64 3
void dec_3000_500_init __P((void));
static void dec_3000_500_cons_init __P((void));
static void dec_3000_500_device_register __P((struct device *, void *));
@


1.8.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: dec_3000_500.c,v 1.8 2000/11/08 21:48:43 art Exp $ */
d46 1
a46 1
#include <dev/tc/tcdsvar.h>
d62 3
a64 3
void dec_3000_500_init(void);
static void dec_3000_500_cons_init(void);
static void dec_3000_500_device_register(struct device *, void *);
d235 1
a235 1
		if (ta->tcdsda_chip != b->channel)
@


1.8.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: dec_3000_500.c,v 1.8.6.1 2002/06/11 03:33:39 art Exp $ */
d181 1
a181 1
	panic("consinit: unknown console type %lu",
@


1.7
log
@add tags
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a196 1
	extern struct device *booted_device;
@


1.6
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
@


1.5
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 2
/*	$OpenBSD: dec_3000_500.c,v 1.4 1996/10/30 22:38:05 niklas Exp $	*/
/*	$NetBSD: dec_3000_500.c,v 1.9 1996/11/12 05:14:31 cgd Exp $	*/
d29 3
d36 4
a40 1

d45 5
d51 4
a54 1
#include <alpha/tc/tcdsvar.h>
d59 1
a59 4
char *dec_3000_500_modelname __P((void));
void dec_3000_500_cons_init __P((void));
const char *dec_3000_500_iobus_name __P((void));
void dec_3000_500_device_register __P((struct device *, void *));
d61 17
a77 1
cpu_decl(dec_3000_500);
d79 2
a80 2
const char *
dec_3000_500_model_name()
d82 1
d84 1
a84 30
	switch (hwrpb->rpb_variation & SV_ST_MASK) {
	case SV_ST_SANDPIPER:
systype_sandpiper:
		return "DEC 3000/400 (\"Sandpiper\")";

	case SV_ST_FLAMINGO:
systype_flamingo:
		return "DEC 3000/500 (\"Flamingo\")";

	case SV_ST_HOTPINK:
		return "DEC 3000/500X (\"Hot Pink\")";

	case SV_ST_FLAMINGOPLUS:
	case SV_ST_ULTRA:
		return "DEC 3000/800 (\"Flamingo+\")";

	case SV_ST_SANDPLUS:
		return "DEC 3000/600 (\"Sandpiper+\")";

	case SV_ST_SANDPIPER45:
		return "DEC 3000/700 (\"Sandpiper45\")";

	case SV_ST_FLAMINGO45:
		return "DEC 3000/900 (\"Flamingo45\")";

	case SV_ST_RESERVED: /* this is how things used to be done */
		if (hwrpb->rpb_variation & SV_GRAPHICS)
			goto systype_flamingo;
		else
			goto systype_sandpiper;
d86 19
a104 4
	default:
		printf("unknown system variation %lx\n",
		    hwrpb->rpb_variation & SV_ST_MASK);
		return NULL;
d106 4
d112 1
a112 1
void
d115 64
a178 1
}
d180 2
a181 4
const char *
dec_3000_500_iobus_name()
{
	return ("tcasic");
d184 1
a184 1
void
d191 1
d196 1
d203 2
a204 1
		netboot = (strcmp(b->protocol, "BOOTP") == 0);
d208 19
a226 1
		initted =1;
d228 3
d232 2
a233 5
	if (scsiboot && (strcmp(cd->cd_name, "esp") == 0)) {
		if (b->slot == 6 &&
		    strcmp(parent->dv_cfdata->cf_driver->cd_name, "tcds")
		      == 0) {
			struct tcdsdev_attach_args *tcdsdev = aux;
d235 4
a238 2
			if (tcdsdev->tcdsda_slot == b->channel) {
				scsidev = dev;
d240 1
a240 1
				printf("\nscsidev = %s\n", dev->dv_xname);
a241 2
			}
		}
d244 1
a244 1
	if (scsiboot &&
a248 3

		if (scsidev == NULL)
			return;
@


1.5.14.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 2
/* $OpenBSD: dec_3000_500.c,v 1.8 2000/11/08 21:48:43 art Exp $ */
/* $NetBSD: dec_3000_500.c,v 1.29 2000/05/22 20:13:32 thorpej Exp $ */
a29 3
/*
 * Additional Copyright (c) 1997 by Matthew Jacob for NASA/Ames Research Center
 */
d34 1
a34 3
#include <sys/termios.h>
#include <dev/cons.h>
#include <sys/conf.h>
a35 1
#include <machine/rpb.h>
d40 1
a41 9
#include <alpha/tc/tc_3000_500.h>
#ifndef NEW_SCC_DRIVER
#include <alpha/tc/sccvar.h>
#endif

#if 0
#include <machine/z8530var.h>
#include <dev/dec/zskbdvar.h>
#endif
d46 4
a49 1
#include "wsdisplay.h"
d51 1
a51 17
void dec_3000_500_init __P((void));
static void dec_3000_500_cons_init __P((void));
static void dec_3000_500_device_register __P((struct device *, void *));

static const char dec_3000_500_sp[] = "DEC 3000/400 (\"Sandpiper\")";
static const char dec_3000_500_sf[] = "DEC 3000/500 (\"Flamingo\")";

const struct alpha_variation_table dec_3000_500_variations[] = {
	{ SV_ST_SANDPIPER, dec_3000_500_sp },
	{ SV_ST_FLAMINGO, dec_3000_500_sf },
	{ SV_ST_HOTPINK, "DEC 3000/500X (\"Hot Pink\")" },
	{ SV_ST_FLAMINGOPLUS, "DEC 3000/800 (\"Flamingo+\")" },
	{ SV_ST_SANDPLUS, "DEC 3000/600 (\"Sandpiper+\")" },
	{ SV_ST_SANDPIPER45, "DEC 3000/700 (\"Sandpiper45\")" },
	{ SV_ST_FLAMINGO45, "DEC 3000/900 (\"Flamingo45\")" },
	{ 0, NULL },
};
d53 2
a54 2
void
dec_3000_500_init()
a55 1
	u_int64_t variation;
d57 30
a86 1
	platform.family = "DEC 3000/500 (\"Flamingo\")";
d88 4
a91 19
	if ((platform.model = alpha_dsr_sysname()) == NULL) {
		variation = hwrpb->rpb_variation & SV_ST_MASK;
		if (variation == SV_ST_ULTRA) {
			/* These are really the same. */
			variation = SV_ST_FLAMINGOPLUS;
		}
		if ((platform.model = alpha_variation_name(variation,
		    dec_3000_500_variations)) == NULL) {
			/*
			 * This is how things used to be done.
			 */
			if (variation == SV_ST_RESERVED) {
				if (hwrpb->rpb_variation & SV_GRAPHICS)
					platform.model = dec_3000_500_sf;
				else
					platform.model = dec_3000_500_sp;
			} else
				platform.model = alpha_unknown_sysname();
		}
a92 4

	platform.iobus = "tcasic";
	platform.cons_init = dec_3000_500_cons_init;
	platform.device_register = dec_3000_500_device_register;
d95 1
a95 1
static void
d98 1
a98 1
	struct ctb *ctb;
d100 4
a103 65
	ctb = (struct ctb *)(((caddr_t)hwrpb) + hwrpb->rpb_ctb_off);

#ifndef NEW_SCC_DRIVER
	switch (ctb->ctb_term_type) {
	case CTB_GRAPHICS:
#ifdef notyet
		alpha_donot_kludge_scc = 1;
#endif
		return;
	case CTB_PRINTERPORT:
		return;
	default:
		goto badconsole;
	}
#else

	switch (ctb->ctb_term_type) {
	case CTB_GRAPHICS:
#if NWSDISPLAY > 0
		/* display console ... */
		if (zs_ioasic_lk201_cnattach(0x1e0000000, 0x00180000, 0) == 0 &&
		    tc_3000_500_fb_cnattach(
		     CTB_TURBOSLOT_SLOT(ctb->ctb_turboslot)) == 0) {
			break;
		}
#endif
		printf("consinit: Unable to init console on keyboard and ");
		printf("TURBOchannel slot 0x%lx.\n", ctb->ctb_turboslot);
		printf("Using serial console.\n");
		/* FALLTHROUGH */

	case CTB_PRINTERPORT:
		/* serial console ... */
		/*
		 * XXX This could stand some cleanup...
		 */
		{
			/*
			 * Delay to allow PROM putchars to complete.
			 * FIFO depth * character time,
			 * character time = (1000000 / (defaultrate / 10))
			 */
			DELAY(160000000 / 9600);	/* XXX */

			/*
			 * Console is channel B of the second SCC.
			 * XXX Should use ctb_line_off to get the
			 * XXX line parameters--these are the defaults.
			 */
			if (zs_ioasic_cnattach(0x1e0000000, 0x00180000, 1,
			    9600, (TTYDEF_CFLAG & ~(CSIZE | PARENB)) | CS8))
				panic("can't init serial console");
			break;
		}
	default:
		goto badconsole;
	}
#endif
	return;
badconsole:
	printf("ctb->ctb_term_type = 0x%lx\n", ctb->ctb_term_type);
	printf("ctb->ctb_turboslot = 0x%lx\n", ctb->ctb_turboslot);

	panic("consinit: unknown console type %lu\n",
	    ctb->ctb_term_type);
d106 1
a106 1
static void
a112 1
	static struct device *tcdsdev;
d123 1
a123 2
		netboot = (strcmp(b->protocol, "BOOTP") == 0) ||
		    (strcmp(b->protocol, "MOP") == 0);
d127 1
a127 19
		initted = 1;
	}

	/*
	 * for scsi boot, we look for "tcds", make sure it has the
	 * right slot number, then find the "asc" on this tcds that
	 * as the right channel.  then we find the actual scsi
	 * device we came from.  note: no SCSI LUN support (yet).
	 */
	if (scsiboot && (strcmp(cd->cd_name, "tcds") == 0)) {
		struct tc_attach_args *tcargs = aux;

		if (b->slot != tcargs->ta_slot)
			return;

		tcdsdev = dev;
#if 0
		printf("\ntcdsdev = %s\n", dev->dv_xname);
#endif
a128 3
	if (scsiboot && tcdsdev &&
	    (strcmp(cd->cd_name, "asc") == 0)) {
		struct tcdsdev_attach_args *ta = aux;
d130 5
a134 2
		if (parent != (struct device *)tcdsdev)
			return;
d136 2
a137 4
		if (ta->tcdsda_slot != b->channel)
			return;

		scsidev = dev;
d139 1
a139 1
		printf("\nscsidev = %s\n", dev->dv_xname);
d141 2
d145 1
a145 1
	if (scsiboot && scsidev &&
d150 3
@


1.5.14.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d62 3
a64 3
void dec_3000_500_init(void);
static void dec_3000_500_cons_init(void);
static void dec_3000_500_device_register(struct device *, void *);
@


1.5.14.3
log
@Sync the SMP branch with 3.3
@
text
@d46 1
a46 1
#include <dev/tc/tcdsvar.h>
d181 1
a181 1
	panic("consinit: unknown console type %lu",
d235 1
a235 1
		if (ta->tcdsda_chip != b->channel)
@


1.4
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 2
a2 2
/*	$OpenBSD: dec_3000_500.c,v 1.8 1996/10/13 02:59:31 christos Exp $	*/
/*	$NetBSD: dec_3000_500.c,v 1.8 1996/10/13 02:59:31 christos Exp $	*/
d37 1
d47 2
a48 1
void dec_3000_500_consinit __P((void));
d51 4
a54 2
char *
dec_3000_500_modelname()
d96 6
a101 1
dec_3000_500_consinit()
d103 1
@


1.3
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: dec_3000_500.c,v 1.1.6.2 1996/06/13 18:35:15 cgd Exp $	*/
/*	$NetBSD: dec_3000_500.c,v 1.1.6.2 1996/06/13 18:35:15 cgd Exp $	*/
d45 4
a93 1

d101 1
a101 1
	static int found;
d111 10
a120 1
	if (strcmp(cd->cd_name, "esp") == 0) {
d133 6
a138 3
	} else if (strcmp(cd->cd_name, "sd") == 0 ||
	    strcmp(cd->cd_name, "st") == 0 ||
	    strcmp(cd->cd_name, "cd") == 0) {
d173 22
@


1.2
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: dec_3000_500.c,v 1.1 1995/08/03 00:57:26 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1994, 1995 Carnegie-Mellon University.
d31 2
d35 9
d87 1
a87 2
dec_3000_500_consinit(constype)
	char *constype;
d92 4
a95 3
dev_t
dec_3000_500_bootdev(booted_dev)
	char *booted_dev;
d97 60
a156 2

	panic("gack.");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
