head	1.100;
access;
symbols
	OPENBSD_6_2_BASE:1.100
	OPENBSD_6_1:1.100.0.4
	OPENBSD_6_1_BASE:1.100
	OPENBSD_6_0:1.99.0.4
	OPENBSD_6_0_BASE:1.99
	OPENBSD_5_9:1.99.0.2
	OPENBSD_5_9_BASE:1.99
	OPENBSD_5_8:1.98.0.20
	OPENBSD_5_8_BASE:1.98
	OPENBSD_5_7:1.98.0.12
	OPENBSD_5_7_BASE:1.98
	OPENBSD_5_6:1.98.0.16
	OPENBSD_5_6_BASE:1.98
	OPENBSD_5_5:1.98.0.14
	OPENBSD_5_5_BASE:1.98
	OPENBSD_5_4:1.98.0.10
	OPENBSD_5_4_BASE:1.98
	OPENBSD_5_3:1.98.0.8
	OPENBSD_5_3_BASE:1.98
	OPENBSD_5_2:1.98.0.6
	OPENBSD_5_2_BASE:1.98
	OPENBSD_5_1_BASE:1.98
	OPENBSD_5_1:1.98.0.4
	OPENBSD_5_0:1.98.0.2
	OPENBSD_5_0_BASE:1.98
	OPENBSD_4_9:1.95.0.2
	OPENBSD_4_9_BASE:1.95
	OPENBSD_4_8:1.94.0.4
	OPENBSD_4_8_BASE:1.94
	OPENBSD_4_7:1.94.0.2
	OPENBSD_4_7_BASE:1.94
	OPENBSD_4_6:1.93.0.4
	OPENBSD_4_6_BASE:1.93
	OPENBSD_4_5:1.92.0.4
	OPENBSD_4_5_BASE:1.92
	OPENBSD_4_4:1.92.0.2
	OPENBSD_4_4_BASE:1.92
	OPENBSD_4_3:1.89.0.4
	OPENBSD_4_3_BASE:1.89
	OPENBSD_4_2:1.89.0.2
	OPENBSD_4_2_BASE:1.89
	OPENBSD_4_1:1.67.0.2
	OPENBSD_4_1_BASE:1.67
	OPENBSD_4_0:1.53.0.2
	OPENBSD_4_0_BASE:1.53
	OPENBSD_3_9:1.42.0.2
	OPENBSD_3_9_BASE:1.42
	OPENBSD_3_8:1.40.0.2
	OPENBSD_3_8_BASE:1.40
	OPENBSD_3_7:1.39.0.6
	OPENBSD_3_7_BASE:1.39
	OPENBSD_3_6:1.39.0.4
	OPENBSD_3_6_BASE:1.39
	SMP_SYNC_A:1.39
	SMP_SYNC_B:1.39
	OPENBSD_3_5:1.39.0.2
	OPENBSD_3_5_BASE:1.39
	OPENBSD_3_4:1.37.0.2
	OPENBSD_3_4_BASE:1.37
	UBC_SYNC_A:1.36
	OPENBSD_3_3:1.36.0.2
	OPENBSD_3_3_BASE:1.36
	OPENBSD_3_2:1.35.0.4
	OPENBSD_3_2_BASE:1.35
	OPENBSD_3_1:1.35.0.2
	OPENBSD_3_1_BASE:1.35
	UBC_SYNC_B:1.35
	UBC:1.32.0.6
	UBC_BASE:1.32
	OPENBSD_3_0:1.32.0.4
	OPENBSD_3_0_BASE:1.32
	OPENBSD_2_9:1.32.0.2
	OPENBSD_2_9_BASE:1.32
	OPENBSD_2_8:1.31.0.2
	OPENBSD_2_8_BASE:1.31
	OPENBSD_2_7:1.30.0.2
	OPENBSD_2_7_BASE:1.30
	SMP:1.29.0.4
	SMP_BASE:1.29
	kame_19991208:1.29
	OPENBSD_2_6:1.29.0.2
	OPENBSD_2_6_BASE:1.29
	OPENBSD_2_5:1.27.0.2
	OPENBSD_2_5_BASE:1.27
	OPENBSD_2_4:1.23.0.2
	OPENBSD_2_4_BASE:1.23
	OPENBSD_2_3:1.21.0.2
	OPENBSD_2_3_BASE:1.21
	OPENBSD_2_2:1.15.0.2
	OPENBSD_2_2_BASE:1.15
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.100
date	2017.02.28.10.49.37;	author natano;	state Exp;
branches;
next	1.99;
commitid	9645cvu5lMcc7gZM;

1.99
date	2015.09.28.15.17.08;	author krw;	state Exp;
branches;
next	1.98;
commitid	F5VKEQmoSNbQb8HV;

1.98
date	2011.04.16.03.21.15;	author krw;	state Exp;
branches;
next	1.97;

1.97
date	2011.04.15.14.57.28;	author krw;	state Exp;
branches;
next	1.96;

1.96
date	2011.04.06.13.46.50;	author miod;	state Exp;
branches;
next	1.95;

1.95
date	2011.02.26.13.07.48;	author krw;	state Exp;
branches;
next	1.94;

1.94
date	2009.08.13.15.23.08;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2009.06.04.21.13.00;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2008.06.12.06.58.31;	author deraadt;	state Exp;
branches;
next	1.91;

1.91
date	2008.06.11.12.35.38;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2008.06.10.20.50.22;	author beck;	state Exp;
branches;
next	1.89;

1.89
date	2007.06.20.18.15.45;	author deraadt;	state Exp;
branches;
next	1.88;

1.88
date	2007.06.17.00.27.28;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2007.06.14.03.37.23;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2007.06.14.03.35.29;	author deraadt;	state Exp;
branches;
next	1.85;

1.85
date	2007.06.14.03.29.34;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	2007.06.12.20.57.41;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	2007.06.10.05.42.48;	author krw;	state Exp;
branches;
next	1.82;

1.82
date	2007.06.09.23.06.45;	author krw;	state Exp;
branches;
next	1.81;

1.81
date	2007.06.09.18.05.45;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2007.06.09.18.03.59;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2007.06.09.04.08.39;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2007.06.09.02.03.45;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2007.06.08.05.34.26;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2007.06.07.00.28.16;	author krw;	state Exp;
branches;
next	1.75;

1.75
date	2007.06.06.17.15.11;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2007.06.06.16.42.01;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2007.06.05.00.38.12;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2007.06.02.02.35.26;	author krw;	state Exp;
branches;
next	1.71;

1.71
date	2007.05.31.19.57.43;	author krw;	state Exp;
branches;
next	1.70;

1.70
date	2007.05.31.16.05.50;	author krw;	state Exp;
branches;
next	1.69;

1.69
date	2007.05.29.06.28.14;	author otto;	state Exp;
branches;
next	1.68;

1.68
date	2007.05.29.05.08.19;	author krw;	state Exp;
branches;
next	1.67;

1.67
date	2007.02.18.14.18.28;	author krw;	state Exp;
branches;
next	1.66;

1.66
date	2007.02.18.13.49.22;	author krw;	state Exp;
branches;
next	1.65;

1.65
date	2007.02.03.18.22.33;	author krw;	state Exp;
branches;
next	1.64;

1.64
date	2006.10.28.23.26.05;	author krw;	state Exp;
branches;
next	1.63;

1.63
date	2006.10.21.20.10.39;	author krw;	state Exp;
branches;
next	1.62;

1.62
date	2006.10.21.16.01.53;	author krw;	state Exp;
branches;
next	1.61;

1.61
date	2006.10.21.14.18.36;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2006.10.20.23.47.42;	author krw;	state Exp;
branches;
next	1.59;

1.59
date	2006.10.18.20.09.37;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2006.10.17.23.42.37;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2006.10.10.03.17.45;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2006.10.04.19.01.29;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2006.10.04.03.23.01;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2006.10.04.00.52.55;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2006.09.16.14.56.11;	author krw;	state Exp;
branches;
next	1.52;

1.52
date	2006.08.20.03.14.21;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2006.08.17.19.02.15;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2006.08.17.10.34.14;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2006.08.11.21.32.39;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2006.07.11.00.51.21;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2006.07.09.21.00.17;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2006.07.03.20.00.22;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2006.07.01.16.50.32;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2006.06.11.21.15.35;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.15.20.20.37;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2005.12.22.03.02.48;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2005.09.27.23.56.10;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2005.03.30.07.52.30;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2004.03.17.14.16.00;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2003.10.18.20.14.40;	author jmc;	state Exp;
branches;
next	1.37;

1.37
date	2003.06.02.23.27.43;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2002.12.10.23.31.07;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2002.03.14.03.15.50;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2002.03.14.01.26.26;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2002.02.19.02.46.39;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2001.02.13.16.05.34;	author art;	state Exp;
branches
	1.32.6.1;
next	1.31;

1.31
date	2000.10.18.21.00.32;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2000.04.24.04.53.00;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	99.07.17.23.12.07;	author deraadt;	state Exp;
branches
	1.29.4.1;
next	1.28;

1.28
date	99.05.03.22.33.31;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	99.01.05.04.29.03;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	98.11.23.03.35.56;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	98.11.23.03.33.42;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	98.11.21.20.43.42;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	98.10.03.21.18.54;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	98.05.02.03.33.33;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	98.03.02.20.12.02;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	98.03.01.16.39.59;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	98.02.24.04.22.40;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	98.02.19.20.36.39;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	98.01.11.20.42.03;	author provos;	state Exp;
branches;
next	1.16;

1.16
date	97.11.09.23.10.01;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	97.10.20.07.26.40;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	97.10.02.12.58.08;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	97.10.02.12.55.12;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	97.10.02.11.58.12;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	97.08.08.22.01.08;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	97.07.30.11.39.36;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.06.30.11.50.59;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.04.07.06.21.39;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.04.06.06.03.44;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.01.24.19.56.32;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.10.30.22.38.10;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.07.29.22.57.35;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.06.18.09.42.12;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.12.20.19.48;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.39;	author deraadt;	state Exp;
branches;
next	;

1.29.4.1
date	2001.04.18.16.00.20;	author niklas;	state Exp;
branches;
next	1.29.4.2;

1.29.4.2
date	2002.03.06.00.47.43;	author niklas;	state Exp;
branches;
next	1.29.4.3;

1.29.4.3
date	2002.03.28.10.06.12;	author niklas;	state Exp;
branches;
next	1.29.4.4;

1.29.4.4
date	2003.03.27.23.18.05;	author niklas;	state Exp;
branches;
next	1.29.4.5;

1.29.4.5
date	2003.06.07.11.11.33;	author ho;	state Exp;
branches;
next	1.29.4.6;

1.29.4.6
date	2004.02.19.09.59.33;	author niklas;	state Exp;
branches;
next	1.29.4.7;

1.29.4.7
date	2004.06.05.23.10.42;	author niklas;	state Exp;
branches;
next	;

1.32.6.1
date	2002.06.11.03.33.39;	author art;	state Exp;
branches;
next	1.32.6.2;

1.32.6.2
date	2003.05.19.21.38.52;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.100
log
@Switch geteblks()'s size argument from int to size_t. It's called with
unsigned variables as argument in most places anyway. Decrease the
chance of signedness/range mismatch issues.

ok stefan
@
text
@/*	$OpenBSD: disksubr.c,v 1.99 2015/09/28 15:17:08 krw Exp $	*/
/*	$NetBSD: disksubr.c,v 1.21 1996/05/03 19:42:03 christos Exp $	*/

/*
 * Copyright (c) 1997 Niklas Hallqvist
 * Copyright (c) 1996 Theo de Raadt
 * Copyright (c) 1982, 1986, 1988 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/disklabel.h>
#include <sys/disk.h>

/*
 * Attempt to read a disk label from a device
 * using the indicated strategy routine.
 * The label must be partly set up before this:
 * secpercyl, secsize and anything required for a block i/o read
 * operation in the driver's strategy/start routines
 * must be filled in before calling us.
 */
int
readdisklabel(dev_t dev, void (*strat)(struct buf *),
    struct disklabel *lp, int spoofonly)
{
	struct buf *bp = NULL;
	int error;

	if ((error = initdisklabel(lp)))
		goto done;

	/* get a buffer and initialize it */
	bp = geteblk(lp->d_secsize);
	bp->b_dev = dev;

	if (spoofonly)
		goto doslabel;

	error = readdisksector(bp, strat, lp, DL_BLKTOSEC(lp, LABELSECTOR));
	if (error)
		goto done;

	error = checkdisklabel(bp->b_data + LABELOFFSET, lp, 0,
	    DL_GETDSIZE(lp));
	if (error == 0)
		goto done;

doslabel:
	error = readdoslabel(bp, strat, lp, NULL, spoofonly);
	if (error == 0)
		goto done;

#if defined(CD9660)
	error = iso_disklabelspoof(dev, strat, lp);
	if (error == 0)
		goto done;
#endif
#if defined(UDF)
	error = udf_disklabelspoof(dev, strat, lp);
	if (error == 0)
		goto done;
#endif

done:
	if (bp) {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
	disk_change = 1;
	return (error);
}

/*
 * Write disk label back to device after modification.
 */
int
writedisklabel(dev_t dev, void (*strat)(struct buf *), struct disklabel *lp)
{
	u_int64_t csum = 0, *p;
	struct disklabel *dlp;
	struct buf *bp = NULL;
	int error, i;

	/* get a buffer and initialize it */
	bp = geteblk(lp->d_secsize);
	bp->b_dev = dev;

	error = readdisksector(bp, strat, lp, DL_BLKTOSEC(lp, LABELSECTOR));
	if (error)
		goto done;

	/* Write it in the regular place. */
	dlp = (struct disklabel *)(bp->b_data + LABELOFFSET);
	*dlp = *lp;

	/* Alpha bootblocks require a checksum over the sector */
	for (i = 0, p = (u_int64_t *)bp->b_data; i < 63; i++)
		csum += *p++;
	*p = csum;

	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_WRITE | B_RAW);
	(*strat)(bp);
	error = biowait(bp);

done:
	if (bp) {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
	disk_change = 1;
	return (error);
}
@


1.99
log
@Mechanical changes from manual buf set up to readdisksector().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.98 2011/04/16 03:21:15 krw Exp $	*/
d60 1
a60 1
	bp = geteblk((int)lp->d_secsize);
d112 1
a112 1
	bp = geteblk((int)lp->d_secsize);
@


1.98
log
@Use 'CLR(<buf>->b_flags, B_READ | B_WRITE | B_DONE)' regardless of
what the previous IO was. Less chance of copy and paste errors.
Suggested by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.97 2011/04/15 14:57:28 krw Exp $	*/
d66 2
a67 7
	bp->b_blkno = LABELSECTOR;
	bp->b_bcount = lp->d_secsize;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
	(*strat)(bp);
	if (biowait(bp)) {
		error = bp->b_error;
a68 1
	}
d115 2
a116 6
	bp->b_blkno = LABELSECTOR;
	bp->b_bcount = lp->d_secsize;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
	(*strat)(bp);
	if ((error = biowait(bp)) != 0)
@


1.97
log
@In days of yore one could arbitrarily whack buffer flags. Those days
are past. Use CLR() and SET() to modify necessary flags while leaving
the flags used by the buffer cache in peace.

Should make bufcache code much less confused about the state of the
bufs used in reading/writing disklabels. Other such flag abuses no
doubt await a visit.

Errors in original diff found by miod@@.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.96 2011/04/06 13:46:50 miod Exp $	*/
d68 1
a68 1
	CLR(bp->b_flags, B_WRITE | B_DONE);
d123 1
a123 1
	CLR(bp->b_flags, B_WRITE | B_DONE);
d138 1
a138 1
	CLR(bp->b_flags, B_READ | B_DONE);
@


1.96
log
@The various read*label() have stopped returning error strings for quite
some time, and return errnos instead. Fix or remove out-of-date comments
mentioning the error strings, and make their callers check the return value
against zero, not NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.95 2011/02/26 13:07:48 krw Exp $	*/
d68 2
a69 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d123 2
a124 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d138 2
a139 1
	bp->b_flags = B_BUSY | B_WRITE | B_RAW;
@


1.95
log
@Force the DUID cache used to generate hw.disknames to be updated
after every disklabel read or write. This keeps the DUID cache more
in sync with the physical world. De-syncing noted by drahn@@ while
zapping disklabels with dd.

ok jsing@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.94 2009/08/13 15:23:08 deraadt Exp $	*/
a47 2
 *
 * Returns null on success and an error string on failure.
@


1.94
log
@Replace the error strings that were being passed around with much simpler
errnos.  Note that the error strings are being ignored, since we long ago
decided to not spam the console, and there is no other nice way to use the
errors (without changing the ioctls to pass it back)
The errno is now useful, since we can pass b_error from failing IO up, and
the drive can decide how to use that
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.93 2009/06/04 21:13:00 deraadt Exp $	*/
d103 1
d147 1
@


1.93
log
@Recycle four ancient fields in the disklabel structure, replacing them with
bounds information, ie. the zone of the disk that OpenBSD can use.  Have each
pre-disklabel parser (MBR, DPME, or per-arch MD disklabel parsers) figure out
this area and pass it up to userland.  Then, delete all the same disk parsing
code from disklabel(8) since the kernel passes it up.  Lots and lots of - signs
in the disklabel(8) code.
Tested on as many platforms as possible, the fallout will be repaired as time
goes on.  To test, use disklabel -d <drive> and validate that the bounds do not
overlap any boot blocks.  This same information is used by disklabel -A...
OK for the concept from krw, miod, and drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.92 2008/06/12 06:58:31 deraadt Exp $	*/
d51 1
a51 1
char *
d56 1
a56 1
	char *msg;
d58 1
a58 1
	if ((msg = initdisklabel(lp)))
d73 1
a73 1
		msg = "disk label read error";
d77 3
a79 2
	msg = checkdisklabel(bp->b_data + LABELOFFSET, lp, 0, DL_GETDSIZE(lp));
	if (msg == NULL)
d83 2
a84 2
	msg = readdoslabel(bp, strat, lp, NULL, spoofonly);
	if (msg == NULL)
d88 2
a89 2
	if (iso_disklabelspoof(dev, strat, lp) == 0) {
		msg = NULL;
a90 1
	}
d93 2
a94 2
	if (udf_disklabelspoof(dev, strat, lp) == 0) {
		msg = NULL;
a95 1
	}
d103 1
a103 1
	return (msg);
@


1.92
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.90 2008/06/10 20:50:22 beck Exp $	*/
d77 1
a77 1
	msg = checkdisklabel(bp->b_data + LABELOFFSET, lp);
@


1.91
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.89 2007/06/20 18:15:45 deraadt Exp $	*/
d70 1
a70 1
	bp->b_flags = B_BUSY | B_READ;
d124 1
a124 1
	bp->b_flags = B_BUSY | B_READ;
d138 1
a138 1
	bp->b_flags = B_BUSY | B_WRITE;
@


1.90
log
@Fix buffer cache pending read statistics by ensuring we can identify
biowait() reads that do *not* come from the buffer cache - we use the
B_RAW flag to identify these at art's suggestion - since it makes sense
and the flag was not being used. this just flags all these buffers with
B_RAW - biodone already ignores returned buffers marked B_RAW.
ok art@@
@
text
@d70 1
a70 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d124 1
a124 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d138 1
a138 1
	bp->b_flags = B_BUSY | B_WRITE | B_RAW;
@


1.89
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.88 2007/06/17 00:27:28 deraadt Exp $	*/
d70 1
a70 1
	bp->b_flags = B_BUSY | B_READ;
d124 1
a124 1
	bp->b_flags = B_BUSY | B_READ;
d138 1
a138 1
	bp->b_flags = B_BUSY | B_WRITE;
@


1.88
log
@significantly simplified disklabel infrastructure.  MBR handling becomes MI
to support hotplug media on most architectures.  disklabel setup and
verification done using new helper functions.  Disklabels must *always*
have a correct checksum now.  Same code paths are used to learn on-disk
location disklabels, to avoid new errors sneaking in.  Tested on almost all
cases, testing help from todd, kettenis, krw, otto, dlg, robert, gwk, drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.87 2007/06/14 03:37:23 deraadt Exp $	*/
d53 1
a53 1
    struct disklabel *lp, struct cpu_disklabel *osdep, int spoofonly)
a68 1
	bp->b_cylinder = 0;
d82 1
a82 1
	msg = readdoslabel(bp, strat, lp, osdep, NULL, NULL, spoofonly);
d111 1
a111 2
writedisklabel(dev_t dev, void (*strat)(struct buf *),
    struct disklabel *lp, struct cpu_disklabel *osdep)
a122 1
	bp->b_cylinder = 0;
@


1.87
log
@excessive blank lines making the versions different
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.86 2007/06/14 03:35:29 deraadt Exp $	*/
a32 2
 *
 *	@@(#)ufs_disksubr.c	7.16 (Berkeley) 5/4/91
a37 1
#include <sys/device.h>
a38 1
#include <sys/syslog.h>
a40 62
char   *readbsdlabel(struct buf *, void (*)(struct buf *), int, int,
    int, struct disklabel *, int);
char   *readdoslabel(struct buf *, void (*)(struct buf *),
    struct disklabel *, struct cpu_disklabel *, int *, int *, int);

/*
 * Try to read a standard BSD disklabel at a certain sector.
 */
char *
readbsdlabel(struct buf *bp, void (*strat)(struct buf *),
    int cyl, int sec, int off, struct disklabel *lp, int spoofonly)
{
	struct disklabel *dlp;
	char *msg = NULL;
	u_int16_t cksum;

	/* don't read the on-disk label if we are in spoofed-only mode */
	if (spoofonly)
		return (NULL);

	bp->b_blkno = sec;
	bp->b_cylinder = cyl;
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_BUSY | B_READ;
	(*strat)(bp);

	/* if successful, locate disk label within block and validate */
	if (biowait(bp)) {
		/* XXX we return the faked label built so far */
		msg = "disk label I/O error";
		return (msg);
	}

	/*
	 * If off is negative, search until the end of the sector for
	 * the label, otherwise, just look at the specific location
	 * we're given.
	 */
	dlp = (struct disklabel *)(bp->b_data + (off >= 0 ? off : 0));
	do {
		if (dlp->d_magic != DISKMAGIC || dlp->d_magic2 != DISKMAGIC) {
			if (msg == NULL)
				msg = "no disk label";
		} else {
			cksum = dkcksum(dlp);
			if (dlp->d_npartitions > MAXPARTITIONS || cksum != 0) {
				msg = "disk label corrupted";
			} else {
				DL_SETDSIZE(dlp, DL_GETDSIZE(lp));
				*lp = *dlp;
				msg = NULL;
				break;
			}
		}
		if (off >= 0)
			break;
		dlp = (struct disklabel *)((char *)dlp + sizeof(int32_t));
	} while (dlp <= (struct disklabel *)(bp->b_data + lp->d_secsize -
	    sizeof(*dlp)));
	return (msg);
}

d56 3
a58 11
	char *msg = "no disk label";
	int i;
	struct disklabel minilabel, fallbacklabel;

	/* minimal requirements for archetypal disk label */
	if (lp->d_secsize < DEV_BSIZE)
		lp->d_secsize = DEV_BSIZE;
	if (DL_GETDSIZE(lp) == 0)
		DL_SETDSIZE(lp, MAXDISKSIZE);
	if (lp->d_secpercyl == 0) {
		msg = "invalid geometry";
a59 11
	}
	lp->d_npartitions = RAW_PART + 1;
	for (i = 0; i < RAW_PART; i++) {
		DL_SETPSIZE(&lp->d_partitions[i], 0);
		DL_SETPOFFSET(&lp->d_partitions[i], 0);
	}
	if (DL_GETPSIZE(&lp->d_partitions[RAW_PART]) == 0)
		DL_SETPSIZE(&lp->d_partitions[RAW_PART], DL_GETDSIZE(lp));
	DL_SETPOFFSET(&lp->d_partitions[RAW_PART], 0);
	lp->d_version = 1;
	minilabel = fallbacklabel = *lp;
d65 11
a75 15
	msg = readbsdlabel(bp, strat, 0, LABELSECTOR, LABELOFFSET, lp,
	   spoofonly);
	if (msg)
		*lp = minilabel;
	if (msg) {
		msg = readdoslabel(bp, strat, lp, osdep, 0, 0, spoofonly);
		if (msg) {
			/* Fallback alternative */
			fallbacklabel = *lp;
			*lp = minilabel;
		}
	}
	/* Record metainformation about the disklabel.  */
	if (msg == NULL) {
		osdep->labelsector = bp->b_blkno;
d77 9
d88 1
a88 1
	if (msg && iso_disklabelspoof(dev, strat, lp) == 0)
d90 2
d94 1
a94 1
	if (msg && udf_disklabelspoof(dev, strat, lp) == 0)
d96 2
a99 4
	/* If there was an error, still provide a decent fake one.  */
	if (msg)
		*lp = fallbacklabel;

a104 195
	disklabeltokernlabel(lp);
	return (msg);
}

/*
 * If dos partition table requested, attempt to load it and
 * find disklabel inside a DOS partition. Return buffer
 * for use in signalling errors if requested.
 *
 * We would like to check if each MBR has a valid BOOT_MAGIC, but
 * we cannot because it doesn't always exist. So.. we assume the
 * MBR is valid.
 */
char *
readdoslabel(struct buf *bp, void (*strat)(struct buf *),
    struct disklabel *lp, struct cpu_disklabel *osdep,
    int *partoffp, int *cylp, int spoofonly)
{
	struct dos_partition dp[NDOSPART], *dp2;
	struct partition *pp;
	unsigned long extoff = 0;
	unsigned int fattest;
	daddr64_t part_blkno = DOSBBSECTOR;
	char *msg = NULL;
	int dospartoff, cyl, i, ourpart = -1;
	int wander = 1, n = 0, loop = 0;

	if (lp->d_secpercyl == 0) {
		msg = "invalid label, d_secpercyl == 0";
		return (msg);
	}
	if (lp->d_secsize == 0) {
		msg = "invalid label, d_secsize == 0";
		return (msg);
	}

	/* do dos partitions in the process of getting disklabel? */
	dospartoff = 0;
	cyl = I386_LABELSECTOR / lp->d_secpercyl;

	/*
	 * Read dos partition table, follow extended partitions.
	 * Map the partitions to disklabel entries i-p
	 */
	while (wander && n < 8 && loop < 8) {
		loop++;
		wander = 0;
		if (part_blkno < extoff)
			part_blkno = extoff;

		/* read boot record */
		bp->b_blkno = part_blkno;
		bp->b_bcount = lp->d_secsize;
		bp->b_flags = B_BUSY | B_READ;
		bp->b_cylinder = part_blkno / lp->d_secpercyl;
		(*strat)(bp);

		/* if successful, wander through dos partition table */
		if (biowait(bp)) {
			msg = "dos partition I/O error";
			if (partoffp)
				*partoffp = -1;
			return (msg);
		}
		bcopy(bp->b_data + DOSPARTOFF, dp, sizeof(dp));

		if (ourpart == -1 && part_blkno == DOSBBSECTOR) {
			/* Search for our MBR partition */
			for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
			    i++, dp2++)
				if (letoh32(dp2->dp_size) &&
				    dp2->dp_typ == DOSPTYP_OPENBSD)
					ourpart = i;
			if (ourpart == -1)
				goto donot;
			/*
			 * This is our MBR partition. need sector
			 * address for SCSI/IDE, cylinder for
			 * ESDI/ST506/RLL
			 */
			dp2 = &dp[ourpart];
			dospartoff = letoh32(dp2->dp_start) + part_blkno;
			cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);

			/* XXX build a temporary disklabel */
			DL_SETPSIZE(&lp->d_partitions[0], letoh32(dp2->dp_size));
			DL_SETPOFFSET(&lp->d_partitions[0],
			    letoh32(dp2->dp_start) + part_blkno);
			if (lp->d_ntracks == 0)
				lp->d_ntracks = dp2->dp_ehd + 1;
			if (lp->d_nsectors == 0)
				lp->d_nsectors = DPSECT(dp2->dp_esect);
			if (lp->d_secpercyl == 0)
				lp->d_secpercyl = lp->d_ntracks *
				    lp->d_nsectors;
		}
donot:
		/*
		 * In case the disklabel read below fails, we want to
		 * provide a fake label in i-p.
		 */
		for (dp2=dp, i=0; i < NDOSPART && n < 8; i++, dp2++) {
			pp = &lp->d_partitions[8+n];

			if (dp2->dp_typ == DOSPTYP_OPENBSD)
				continue;
			if (letoh32(dp2->dp_size) > DL_GETDSIZE(lp))
				continue;
			if (letoh32(dp2->dp_start) > DL_GETDSIZE(lp))
				continue;
			if (letoh32(dp2->dp_size) == 0)
				continue;
			if (letoh32(dp2->dp_start))
				DL_SETPOFFSET(pp,
				    letoh32(dp2->dp_start) + part_blkno);

			DL_SETPSIZE(pp, letoh32(dp2->dp_size));

			switch (dp2->dp_typ) {
			case DOSPTYP_UNUSED:
				pp->p_fstype = FS_UNUSED;
				n++;
				break;

			case DOSPTYP_LINUX:
				pp->p_fstype = FS_EXT2FS;
				n++;
				break;

			case DOSPTYP_FAT12:
			case DOSPTYP_FAT16S:
			case DOSPTYP_FAT16B:
			case DOSPTYP_FAT16L:
			case DOSPTYP_FAT32:
			case DOSPTYP_FAT32L:
				pp->p_fstype = FS_MSDOS;
				n++;
				break;
			case DOSPTYP_EXTEND:
			case DOSPTYP_EXTENDL:
				part_blkno = letoh32(dp2->dp_start) + extoff;
				if (!extoff) {
					extoff = letoh32(dp2->dp_start);
					part_blkno = 0;
				}
				wander = 1;
				break;
			default:
				pp->p_fstype = FS_OTHER;
				n++;
				break;
			}
		}
	}
	lp->d_bbsize = 8192;
	lp->d_sbsize = 64*1024;		/* XXX ? */
	lp->d_npartitions = MAXPARTITIONS;

	if (n == 0 && part_blkno == DOSBBSECTOR) {
		/* Check for a short jump instruction. */
		fattest = ((bp->b_data[0] << 8) & 0xff00) | (bp->b_data[2] &
		    0xff);
		if (fattest != 0xeb90 && fattest != 0xe900)
			goto notfat;

		/* Check for a valid bytes per sector value. */
		fattest = ((bp->b_data[12] << 8) & 0xff00) | (bp->b_data[11] &
		    0xff);
		if (fattest < 512 || fattest > 4096 || (fattest % 512 != 0))
			goto notfat;

		/* Check the end of sector marker. */
		fattest = ((bp->b_data[510] << 8) & 0xff00) | (bp->b_data[511] &
		    0xff);
		if (fattest != 0x55aa)
			goto notfat;

		/* Looks like a FAT filesystem. Spoof 'i'. */
		DL_SETPSIZE(&lp->d_partitions['i' - 'a'],
		    DL_GETPSIZE(&lp->d_partitions[RAW_PART]));
		DL_SETPOFFSET(&lp->d_partitions['i' - 'a'], 0);
		lp->d_partitions['i' - 'a'].p_fstype = FS_MSDOS;
	}
notfat:

	/* record the OpenBSD partition's placement for the caller */
	if (partoffp)
		*partoffp = dospartoff;
	if (cylp)
		*cylp = cyl;

	/* next, dig out disk label */
	msg = readbsdlabel(bp, strat, cyl, dospartoff + I386_LABELSECTOR, -1,
	    lp, spoofonly);

d115 2
a116 1
	char *msg = "no disk label";
d118 1
a118 4
	struct disklabel dl;
	struct cpu_disklabel cdl;
	int labeloffset, error, i, partoff = 0, cyl = 0, needcsum = 0;
	u_int64_t csum, *p;
d124 7
a130 28
	/*
	 * I once played with the thought of using osdep->label{tag,sector}
	 * as a cache for knowing where (and what) to write.  However, now I
	 * think it might be useful to reprobe if someone has written
	 * a newer disklabel of another type with disklabel(8) and -r.
	 */
	dl = *lp;
	msg = readbsdlabel(bp, strat, 0, LABELSECTOR, LABELOFFSET, &dl, 0);
	labeloffset = LABELOFFSET;
	if (msg == NULL)
		needcsum = 1;
	if (msg) {
		dl = *lp;
		msg = readdoslabel(bp, strat, &dl, &cdl, &partoff, &cyl, 0);
		labeloffset = I386_LABELOFFSET;
	}
	if (msg) {
		if (partoff == -1) {
			error = EIO;
			goto done;
		}

		/* Write it in the regular place with native byte order. */
		labeloffset = LABELOFFSET;
		bp->b_blkno = partoff + LABELSECTOR;
		bp->b_cylinder = cyl;
		bp->b_bcount = lp->d_secsize;
	}
d132 8
a139 8
	*(struct disklabel *)(bp->b_data + labeloffset) = *lp;

	/* Alpha bootblocks are checksummed. */
	if (needcsum) {
		for (csum = i = 0, p = (u_int64_t *)bp->b_data; i < 63; i++)
			csum += *p++;
		*p = csum;
	}
@


1.86
log
@set the prototype disklabel to version 1
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.85 2007/06/14 03:29:34 deraadt Exp $	*/
a381 2


@


1.85
log
@do not depend on previous loop variable, use a constant instead
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.84 2007/06/12 20:57:41 deraadt Exp $	*/
d143 1
@


1.84
log
@all disksubr.c did their b_flags manipulation differently (and wrong).
correct and unify; ok thib miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.83 2007/06/10 05:42:48 krw Exp $	*/
d140 3
a142 3
	if (DL_GETPSIZE(&lp->d_partitions[i]) == 0)
		DL_SETPSIZE(&lp->d_partitions[i], DL_GETDSIZE(lp));
	DL_SETPOFFSET(&lp->d_partitions[i], 0);
@


1.83
log
@No need for two *LABELSECTOR and *LABELOFFSET defines that mean the
same thing.  Keep LABELSECTOR and LABELOFFSET and nuke
ALPHA_LABELSECTOR and ALPHA_LABELOFFSET.

Kernel still compiles and boots.

Superfluidity pointed out by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.82 2007/06/09 23:06:45 krw Exp $	*/
d392 1
a392 1
	struct buf *bp;
d419 4
a422 2
		if (partoff == -1)
			return EIO;
d444 5
a448 2
	bp->b_flags |= B_INVAL;
	brelse(bp);
@


1.82
log
@The differences in the last non-homogeneous bounds_check_with_label()
routines (alpha, vax) prove to be not worth keeping. Move
bounds_check_with_label() into the MI world. Eliminate unreliable and
almost certainly useless checks for overwriting a disklabel.

After discussion with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.81 2007/06/09 18:05:45 deraadt Exp $	*/
d149 2
a150 2
	msg = readbsdlabel(bp, strat, 0, ALPHA_LABELSECTOR, ALPHA_LABELOFFSET,
	    lp, spoofonly);
d409 2
a410 3
	msg = readbsdlabel(bp, strat, 0, ALPHA_LABELSECTOR, ALPHA_LABELOFFSET,
	    &dl, 0);
	labeloffset = ALPHA_LABELOFFSET;
@


1.81
log
@unify DOSPTYP_FAT* code (some architectures missed a filesystem type or two)
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.79 2007/06/09 04:08:39 deraadt Exp $	*/
a445 56
}

/*
 * Determine the size of the transfer, and make sure it is
 * within the boundaries of the partition. Adjust transfer
 * if needed, and signal errors or early completion.
 */
int
bounds_check_with_label(struct buf *bp, struct disklabel *lp,
    struct cpu_disklabel *osdep, int wlabel)
{
#define blockpersec(count, lp) ((count) * (((lp)->d_secsize) / DEV_BSIZE))
	struct partition *p = lp->d_partitions + DISKPART(bp->b_dev);
	int labelsector = blockpersec(DL_GETPOFFSET(&lp->d_partitions[RAW_PART]), lp) +
	    osdep->labelsector;
	int sz = howmany(bp->b_bcount, DEV_BSIZE);

	/* avoid division by zero */
	if (lp->d_secpercyl == 0) {
		bp->b_error = EINVAL;
		goto bad;
	}

	/* beyond partition? */
	if (bp->b_blkno + sz > blockpersec(DL_GETPSIZE(p), lp)) {
		sz = blockpersec(DL_GETPSIZE(p), lp) - bp->b_blkno;
		if (sz == 0) {
			/* If exactly at end of disk, return EOF. */
			bp->b_resid = bp->b_bcount;
			return (-1);
		}
		if (sz < 0) {
			/* If past end of disk, return EINVAL. */
			bp->b_error = EINVAL;
			goto bad;
		}
		/* Otherwise, truncate request. */
		bp->b_bcount = sz << DEV_BSHIFT;
	}

	/* Overwriting disk label? */
	if (bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) <= labelsector &&
	    bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) + sz > labelsector &&
	    (bp->b_flags & B_READ) == 0 && !wlabel) {
		bp->b_error = EROFS;
		goto bad;
	}

	/* calculate cylinder for disksort to order transfers with */
	bp->b_cylinder = (bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp)) /
	    lp->d_secpercyl;
	return (1);

bad:
	bp->b_flags |= B_ERROR;
	return (-1);
@


1.80
log
@remove a useless comment
@
text
@d316 1
a318 1
			case DOSPTYP_FAT16L:
d324 1
a324 2
				part_blkno =
				    letoh32(dp2->dp_start) + extoff;
@


1.79
log
@by hand i carefully found that all the differences in setdisklabel()
implimentations were simply either missing code, or spacing and such.
setdisklabel() can become MI now.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.78 2007/06/09 02:03:45 deraadt Exp $	*/
a34 6
 */

/*
 * This disksubr.c module started to take its present form on OpenBSD/alpha
 * but it was always thought it should be made completely MI and not need to
 * be in that alpha-specific tree at all.
@


1.78
log
@annoying spacing glitch which makes the diffs bigger
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.77 2007/06/08 05:34:26 deraadt Exp $	*/
a388 60
/*
 * Check new disk label for sensibility
 * before setting it.
 */
int
setdisklabel(struct disklabel *olp, struct disklabel *nlp,
    u_int openmask, struct cpu_disklabel *osdep)
{
	int i;
	struct partition *opp, *npp;

	/* sanity clause */
	if (nlp->d_secpercyl == 0 || nlp->d_secsize == 0 ||
	    (nlp->d_secsize % DEV_BSIZE) != 0)
		return (EINVAL);

	/*
	 * XXX Nice thought, but it doesn't work, if the intention was to
	 * force a reread at the next *readdisklabel call.  That does not
	 * happen.  There's still some use for it though as you can pseudo-
	 * partition the disk.
	 *
	 * Special case to allow disklabel to be invalidated.
	 */
	if (nlp->d_magic == 0xffffffff) {
		*olp = *nlp;
		return (0);
	}

	if (nlp->d_magic != DISKMAGIC || nlp->d_magic2 != DISKMAGIC ||
	    dkcksum(nlp) != 0)
		return (EINVAL);

	/* XXX missing check if other dos partitions will be overwritten */

	while (openmask != 0) {
		i = ffs(openmask) - 1;
		openmask &= ~(1 << i);
		if (nlp->d_npartitions <= i)
			return (EBUSY);
		opp = &olp->d_partitions[i];
		npp = &nlp->d_partitions[i];
		if (DL_GETPOFFSET(npp) != DL_GETPOFFSET(opp) ||
		    DL_GETPSIZE(npp) < DL_GETPSIZE(opp))
			return (EBUSY);
		/*
		 * Copy internally-set partition information
		 * if new label doesn't include it.		XXX
		 */
		if (npp->p_fstype == FS_UNUSED && opp->p_fstype != FS_UNUSED) {
			npp->p_fstype = opp->p_fstype;
			npp->p_fragblock = opp->p_fragblock;
			npp->p_cpg = opp->p_cpg;
		}
	}
	nlp->d_checksum = 0;
	nlp->d_checksum = dkcksum(nlp);
	*olp = *nlp;
	return (0);
}
@


1.77
log
@all disklabels read from the kernel now always contain a total sector
size which is the REAL DISK SIZE.  always.  if a driver fails to set
this right, please fix it.  agreed with otto and krw
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.76 2007/06/07 00:28:16 krw Exp $	*/
d403 1
a403 1
		return(EINVAL);
@


1.76
log
@More bounds_check_with_label homogenization. Fix a couple of typos while
there.

'so go to it!' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.75 2007/06/06 17:15:11 deraadt Exp $	*/
d99 1
@


1.75
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.74 2007/06/06 16:42:01 deraadt Exp $	*/
d541 1
a541 1
			goto done;
a566 1
done:
@


1.74
log
@a fair sprinking of knf, code movement, and sometimes character-by-character
accuracy so that the variious disksubr.c's can be compared easier.
setdisklabel() starts taking an int for openmask.
ok krw, and read by quite a few other people
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.73 2007/06/05 00:38:12 deraadt Exp $	*/
d211 1
a211 1
	daddr_t part_blkno = DOSBBSECTOR;
@


1.73
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.72 2007/06/02 02:35:26 krw Exp $	*/
d60 2
a61 6
readbsdlabel(bp, strat, cyl, sec, off, lp, spoofonly)
	struct buf *bp;
	void (*strat)(struct buf *);
	int cyl, sec, off;
	struct disklabel *lp;
	int spoofonly;
d123 2
a124 6
readdisklabel(dev, strat, lp, osdep, spoofonly)
	dev_t dev;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
	int spoofonly;
d203 3
a205 8
readdoslabel(bp, strat, lp, osdep, partoffp, cylp, spoofonly)
	struct buf *bp;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
	int *partoffp;
	int *cylp;
	int spoofonly;
d393 2
a394 4
setdisklabel(olp, nlp, openmask, osdep)
	struct disklabel *olp, *nlp;
	u_long openmask;
	struct cpu_disklabel *osdep;
d424 1
a424 1
		i = ffs((long)openmask) - 1;
d454 2
a455 5
writedisklabel(dev, strat, lp, osdep)
	dev_t dev;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
@


1.72
log
@Rename cvtdisklabelv1 -> disklabeltokernlabel. It does more than just
convert version 0 to version 1 disklabels.

Suggested by deraadt@@.

ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.71 2007/05/31 19:57:43 krw Exp $	*/
d142 2
a143 2
	if (lp->d_secperunit == 0)
		lp->d_secperunit = 0x1fffffff;
d150 2
a151 2
		lp->d_partitions[i].p_size = 0;
		lp->d_partitions[i].p_offset = 0;
d153 3
a155 3
	if (lp->d_partitions[i].p_size == 0)
		lp->d_partitions[i].p_size = lp->d_secperunit;
	lp->d_partitions[i].p_offset = 0;
d287 3
a289 3
			lp->d_partitions[0].p_size = letoh32(dp2->dp_size);
			lp->d_partitions[0].p_offset =
			    letoh32(dp2->dp_start) + part_blkno;
d308 1
a308 1
			if (letoh32(dp2->dp_size) > lp->d_secperunit)
d310 1
a310 1
			if (letoh32(dp2->dp_start) > lp->d_secperunit)
d315 2
a316 2
				pp->p_offset =
				    letoh32(dp2->dp_start) + part_blkno;
d318 1
a318 1
			pp->p_size = letoh32(dp2->dp_size);
d381 3
a383 3
		lp->d_partitions['i' - 'a'].p_size =
		    lp->d_partitions[RAW_PART].p_size;
		lp->d_partitions['i' - 'a'].p_offset = 0;
d445 2
a446 2
		if (npp->p_offset != opp->p_offset ||
		    npp->p_size < opp->p_size)
d543 1
a543 1
	int labelsector = blockpersec(lp->d_partitions[RAW_PART].p_offset, lp) +
d554 2
a555 2
	if (bp->b_blkno + sz > blockpersec(p->p_size, lp)) {
		sz = blockpersec(p->p_size, lp) - bp->b_blkno;
d571 2
a572 2
	if (bp->b_blkno + blockpersec(p->p_offset, lp) <= labelsector &&
	    bp->b_blkno + blockpersec(p->p_offset, lp) + sz > labelsector &&
d579 1
a579 1
	bp->b_cylinder = (bp->b_blkno + blockpersec(p->p_offset, lp)) /
@


1.71
log
@KNF, whitespace and comment rectification to make all
bounds_check_with_label() routines as identical as possible without
changing any code. Code nits and adjustments to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.70 2007/05/31 16:05:50 krw Exp $	*/
d197 1
a197 1
	cvtdisklabelv1(lp);
@


1.70
log
@Standardize on -1 as the error return value for
bounds_check_with_label. All callers check for <= 0, so no functional
change.

Feedback from miod@@.

ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.69 2007/05/29 06:28:14 otto Exp $	*/
d538 2
a539 5
bounds_check_with_label(bp, lp, osdep, wlabel)
	struct buf *bp;
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
	int wlabel;
d543 2
a544 2
	int labelsector = blockpersec(lp->d_partitions[RAW_PART].p_offset,
	    lp) + osdep->labelsector;
@


1.69
log
@Updated disklabel format to support larger disks and partitions. We
free room in struct partition by packing fragment size and
fragments/block more tighlty and use the resulting space to make
offset and size 48 bits.  For the disk part we use spare fields in
struct disklabel.  Kernel converts in-mem copy of the on-disk
label if needed, disklabel(8) writes new version.
We are careful to only change fields not used by bootloaders.
Conception of basic scheme by deraadt.
ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.68 2007/05/29 05:08:19 krw Exp $	*/
d589 1
a589 1
	return (0);
@


1.68
log
@Refactor readdisklabel() to ensure there is a single point of return, in
preparation for translating all disk labels visible to the kernel to
the soon to arrive V1 format.

ok otto@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.67 2007/02/18 14:18:28 krw Exp $	*/
d197 1
d454 1
a454 2
			npp->p_fsize = opp->p_fsize;
			npp->p_frag = opp->p_frag;
@


1.67
log
@Remove #ifdef/#endif's around MBR checking code. Remove now unused
option DISKLABEL_I386.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.66 2007/02/18 13:49:22 krw Exp $	*/
d144 4
a147 2
	if (lp->d_secpercyl == 0)
		return ("invalid geometry");
d192 1
@


1.66
log
@If no MBR partitions are found when spoofing a disklabel, try looking
for a bare FAT12/16/32 filesystem.  If one is found, spoof it as 'i'.
This enables iPod shuffles and other umass devices that are shipped
with a bare FAT32 filesystem to be used as install media. And
generally makes things easier for the user just trying to mount some
media, e.g.  floppies.

Does not make it safe to write a disklabel or MBR on such a device!
That will still obliterate the FAT filesystem.

Help and suggestions from tom@@ and deraadt@@. Feedback and suggestions
for future enhancements from espie@@ mickey@@ and peter@@.

ok tom@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.65 2007/02/03 18:22:33 krw Exp $	*/
a52 1
#if defined(DISKLABEL_I386)
a54 1
#endif
a163 1
#if defined(DISKLABEL_I386)
a171 1
#endif
a196 1
#if defined(DISKLABEL_I386)
a395 1
#endif
a474 1
#if defined(DISKLABEL_I386)
a475 1
#endif
a494 1
#if defined(DISKLABEL_I386)
a499 1
#endif
@


1.65
log
@Don't spoof an msdosfs partition if it claims to start after the end
of the disk. Fixes the creation of spurious 'i' partitions on new iPod
Shuffle.  And other devices with no MBR, just a FAT32 filesystem.

Pointed out most recently by Stephan A. Rickauer for his sixth
generation, clip-on iPod shuffle.

Fix tested by Stephan.

ok pedro@@ tom@@ miod@@ 'nice' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.64 2006/10/28 23:26:05 krw Exp $	*/
d224 1
d360 28
a387 1
	lp->d_npartitions = n > 0 ? n + 8 : 3;
@


1.64
log
@We don't currently write a disklabel into an OpenBSD ('A6') DOS MBR
extended partition except on alpha, hppa, hppa64 and mips64. So don't
spoof extended partitions as 'a' and try to read a disklabel from
them. Make all archs consistant.

When we can boot from extended partitions we can change to reading and
writing disklabels from them.

This means the first OpenBSD ('A6') extended partition will now be
ignored during spoofing, just as subsequent ones have always been.

Feedback from tom@@, weingart@@ and deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.63 2006/10/21 20:10:39 krw Exp $	*/
d309 2
@


1.63
log
@Don't try to spoof 0 length DOS MBR/EBR partitions. By skipping
partitions with 0 in the length field we don't need to test for
and skip partitions that are all zeros. Eliminating that code
allows elimination of a local pointer.

"0 length partitions are definately dead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.62 2006/10/21 16:01:53 krw Exp $	*/
d268 1
a268 1
		if (ourpart == -1) {
@


1.62
log
@Some KNF cleanup.

De-register. Move declaration to top of function for DOS MBR
processing. Indent nit in macppc.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.61 2006/10/21 14:18:36 krw Exp $	*/
d225 1
a225 1
	char *msg = NULL, *cp;
d310 2
a311 2
			if (letoh32(dp2->dp_size))
				pp->p_size = letoh32(dp2->dp_size);
d316 2
a319 11
				for (cp = (char *)dp2;
				    cp < (char *)(dp2 + 1); cp++)
					if (*cp)
						break;
				/*
				 * Was it all zeroes?  If so, it is
				 * an unused entry that we don't
				 * want to show.
				 */
				if (cp == (char *)(dp2 + 1))
				    continue;
@


1.61
log
@We have a pointer (pp), so use it in the DOSPTYP_UNUSED case rather
than lp->d_partitions[8+n++]. All other cases already use the pointer.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.60 2006/10/20 23:47:42 krw Exp $	*/
d222 1
d304 1
a304 1
			struct partition *pp = &lp->d_partitions[8+n];
@


1.60
log
@Try again with local variable to avoid alignment issues.

"The dosparts member of cpu_disklabel was not used for any persistant
data. Eliminate it, and just use the data being read in while
processing MBR and EBR records.

Should be no functional change.

ok weingart@@ deraadt@@"
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.59 2006/10/18 20:09:37 deraadt Exp $	*/
d328 2
a329 2
				lp->d_partitions[8 + n++].p_fstype =
				    FS_UNUSED;
@


1.59
log
@back out disksubr changes ... since they violate strict alignment on
some architectures (kaboom); that will be fixed in the next iteration
hopefully!
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.57 2006/10/10 03:17:45 krw Exp $	*/
d221 3
a223 1
	struct dos_partition *dp = osdep->u._i386.dosparts, *dp2;
d226 1
a239 4
	if (dp) {
		daddr_t part_blkno = DOSBBSECTOR;
		unsigned long extoff = 0;
		int wander = 1, n = 0, loop = 0;
d241 57
d299 2
a300 2
		 * Read dos partition table, follow extended partitions.
		 * Map the partitions to disklabel entries i-p
d302 12
a313 22
		while (wander && n < 8 && loop < 8) {
			loop++;
			wander = 0;
			if (part_blkno < extoff)
				part_blkno = extoff;

			/* read boot record */
			bp->b_blkno = part_blkno;
			bp->b_bcount = lp->d_secsize;
			bp->b_flags = B_BUSY | B_READ;
			bp->b_cylinder = part_blkno / lp->d_secpercyl;
			(*strat)(bp);
 
			/* if successful, wander through dos partition table */
			if (biowait(bp)) {
				msg = "dos partition I/O error";
				if (partoffp)
					*partoffp = -1;
				return (msg);
			}
			bcopy(bp->b_data + DOSPARTOFF, dp,
			    NDOSPART * sizeof(*dp));
d315 6
a320 9
			if (ourpart == -1) {
				/* Search for our MBR partition */
				for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
				    i++, dp2++)
					if (letoh32(dp2->dp_size) &&
					    dp2->dp_typ == DOSPTYP_OPENBSD)
						ourpart = i;
				if (ourpart == -1)
					goto donot;
d322 3
a324 3
				 * This is our MBR partition. need sector
				 * address for SCSI/IDE, cylinder for
				 * ESDI/ST506/RLL
d326 10
a335 23
				dp2 = &dp[ourpart];
				dospartoff = letoh32(dp2->dp_start) + part_blkno;
				cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);

				/* XXX build a temporary disklabel */
				lp->d_partitions[0].p_size = letoh32(dp2->dp_size);
				lp->d_partitions[0].p_offset =
				    letoh32(dp2->dp_start) + part_blkno;
				if (lp->d_ntracks == 0)
					lp->d_ntracks = dp2->dp_ehd + 1;
				if (lp->d_nsectors == 0)
					lp->d_nsectors = DPSECT(dp2->dp_esect);
				if (lp->d_secpercyl == 0)
					lp->d_secpercyl = lp->d_ntracks *
					    lp->d_nsectors;
			}
donot:
			/*
			 * In case the disklabel read below fails, we want to
			 * provide a fake label in i-p.
			 */
			for (dp2=dp, i=0; i < NDOSPART && n < 8; i++, dp2++) {
				struct partition *pp = &lp->d_partitions[8+n];
d337 16
a352 55
				if (dp2->dp_typ == DOSPTYP_OPENBSD)
					continue;
				if (letoh32(dp2->dp_size) > lp->d_secperunit)
					continue;
				if (letoh32(dp2->dp_size))
					pp->p_size = letoh32(dp2->dp_size);
				if (letoh32(dp2->dp_start))
					pp->p_offset =
					    letoh32(dp2->dp_start) + part_blkno;

				switch (dp2->dp_typ) {
				case DOSPTYP_UNUSED:
					for (cp = (char *)dp2;
					    cp < (char *)(dp2 + 1); cp++)
						if (*cp)
							break;
					/*
					 * Was it all zeroes?  If so, it is
					 * an unused entry that we don't
					 * want to show.
					 */
					if (cp == (char *)(dp2 + 1))
					    continue;
					lp->d_partitions[8 + n++].p_fstype =
					    FS_UNUSED;
					break;

				case DOSPTYP_LINUX:
					pp->p_fstype = FS_EXT2FS;
					n++;
					break;

				case DOSPTYP_FAT12:
				case DOSPTYP_FAT16S:
				case DOSPTYP_FAT16B:
				case DOSPTYP_FAT32:
				case DOSPTYP_FAT32L:
				case DOSPTYP_FAT16L:
					pp->p_fstype = FS_MSDOS;
					n++;
					break;
				case DOSPTYP_EXTEND:
				case DOSPTYP_EXTENDL:
					part_blkno =
					    letoh32(dp2->dp_start) + extoff;
					if (!extoff) {
						extoff = letoh32(dp2->dp_start);
						part_blkno = 0;
					}
					wander = 1;
					break;
				default:
					pp->p_fstype = FS_OTHER;
					n++;
					break;
d354 6
a361 3
		lp->d_bbsize = 8192;
		lp->d_sbsize = 64*1024;		/* XXX ? */
		lp->d_npartitions = n > 0 ? n + 8 : 3;
d363 3
@


1.58
log
@The dosparts member of cpu_disklabel was not used for any persistant
data. Eliminate it, and just use the data being read in while
processing MBR and EBR records.

Should be no functional change.

ok weingart@@ deraadt@@
@
text
@d221 1
a221 3
	struct dos_partition *dp, *dp2;
	unsigned long extoff = 0;
	daddr_t part_blkno = DOSBBSECTOR;
a223 1
	int wander = 1, n = 0, loop = 0;
d237 4
a241 57
	/*
	 * Read dos partition table, follow extended partitions.
	 * Map the partitions to disklabel entries i-p
	 */
	while (wander && n < 8 && loop < 8) {
		loop++;
		wander = 0;
		if (part_blkno < extoff)
			part_blkno = extoff;

		/* read boot record */
		bp->b_blkno = part_blkno;
		bp->b_bcount = lp->d_secsize;
		bp->b_flags = B_BUSY | B_READ;
		bp->b_cylinder = part_blkno / lp->d_secpercyl;
		(*strat)(bp);

		/* if successful, wander through dos partition table */
		if (biowait(bp)) {
			msg = "dos partition I/O error";
			if (partoffp)
				*partoffp = -1;
			return (msg);
		}
		dp = (struct dos_partition *)(bp->b_data + DOSPARTOFF);

		if (ourpart == -1) {
			/* Search for our MBR partition */
			for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
			    i++, dp2++)
				if (letoh32(dp2->dp_size) &&
				    dp2->dp_typ == DOSPTYP_OPENBSD)
					ourpart = i;
			if (ourpart == -1)
				goto donot;
			/*
			 * This is our MBR partition. need sector
			 * address for SCSI/IDE, cylinder for
			 * ESDI/ST506/RLL
			 */
			dp2 = &dp[ourpart];
			dospartoff = letoh32(dp2->dp_start) + part_blkno;
			cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);

			/* XXX build a temporary disklabel */
			lp->d_partitions[0].p_size = letoh32(dp2->dp_size);
			lp->d_partitions[0].p_offset =
			    letoh32(dp2->dp_start) + part_blkno;
			if (lp->d_ntracks == 0)
				lp->d_ntracks = dp2->dp_ehd + 1;
			if (lp->d_nsectors == 0)
				lp->d_nsectors = DPSECT(dp2->dp_esect);
			if (lp->d_secpercyl == 0)
				lp->d_secpercyl = lp->d_ntracks *
				    lp->d_nsectors;
		}
donot:
d243 2
a244 2
		 * In case the disklabel read below fails, we want to
		 * provide a fake label in i-p.
d246 22
a267 2
		for (dp2=dp, i=0; i < NDOSPART && n < 8; i++, dp2++) {
			struct partition *pp = &lp->d_partitions[8+n];
d269 21
a289 8
			if (dp2->dp_typ == DOSPTYP_OPENBSD)
				continue;
			if (letoh32(dp2->dp_size) > lp->d_secperunit)
				continue;
			if (letoh32(dp2->dp_size))
				pp->p_size = letoh32(dp2->dp_size);
			if (letoh32(dp2->dp_start))
				pp->p_offset =
d291 15
d307 55
a361 38
			switch (dp2->dp_typ) {
			case DOSPTYP_UNUSED:
				for (cp = (char *)dp2;
				    cp < (char *)(dp2 + 1); cp++)
					if (*cp)
						break;
				/*
				 * Was it all zeroes?  If so, it is
				 * an unused entry that we don't
				 * want to show.
				 */
				if (cp == (char *)(dp2 + 1))
				    continue;
				lp->d_partitions[8 + n++].p_fstype =
				    FS_UNUSED;
				break;

			case DOSPTYP_LINUX:
				pp->p_fstype = FS_EXT2FS;
				n++;
				break;

			case DOSPTYP_FAT12:
			case DOSPTYP_FAT16S:
			case DOSPTYP_FAT16B:
			case DOSPTYP_FAT32:
			case DOSPTYP_FAT32L:
			case DOSPTYP_FAT16L:
				pp->p_fstype = FS_MSDOS;
				n++;
				break;
			case DOSPTYP_EXTEND:
			case DOSPTYP_EXTENDL:
				part_blkno =
				    letoh32(dp2->dp_start) + extoff;
				if (!extoff) {
					extoff = letoh32(dp2->dp_start);
					part_blkno = 0;
a362 6
				wander = 1;
				break;
			default:
				pp->p_fstype = FS_OTHER;
				n++;
				break;
d365 3
a368 3
	lp->d_bbsize = 8192;
	lp->d_sbsize = 64*1024;		/* XXX ? */
	lp->d_npartitions = n > 0 ? n + 8 : 3;
@


1.57
log
@Don't spoof a Free/NetBSD MBR partition as the 'a' partition in a
disklabel. Fixes 'double spoofing' of these partitions as both 'a' and
something in the 'i' to 'p' range.

OpenBSD changed its MBR partition type to 'A6' eight years ago.  As a
backward compatibility measure NetBSD and FreeBSD MBR partitions were
still spoofed as 'a' partitions when no OpenBSD partition could be
found. This bit of backward compatibility is no longer required.

'we can get rid of it' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.56 2006/10/04 19:01:29 deraadt Exp $	*/
d221 3
a223 1
	struct dos_partition *dp = osdep->u._i386.dosparts, *dp2;
d226 1
a239 4
	if (dp) {
		daddr_t part_blkno = DOSBBSECTOR;
		unsigned long extoff = 0;
		int wander = 1, n = 0, loop = 0;
d241 57
d299 2
a300 2
		 * Read dos partition table, follow extended partitions.
		 * Map the partitions to disklabel entries i-p
d302 12
a313 22
		while (wander && n < 8 && loop < 8) {
			loop++;
			wander = 0;
			if (part_blkno < extoff)
				part_blkno = extoff;

			/* read boot record */
			bp->b_blkno = part_blkno;
			bp->b_bcount = lp->d_secsize;
			bp->b_flags = B_BUSY | B_READ;
			bp->b_cylinder = part_blkno / lp->d_secpercyl;
			(*strat)(bp);
 
			/* if successful, wander through dos partition table */
			if (biowait(bp)) {
				msg = "dos partition I/O error";
				if (partoffp)
					*partoffp = -1;
				return (msg);
			}
			bcopy(bp->b_data + DOSPARTOFF, dp,
			    NDOSPART * sizeof(*dp));
d315 6
a320 9
			if (ourpart == -1) {
				/* Search for our MBR partition */
				for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
				    i++, dp2++)
					if (letoh32(dp2->dp_size) &&
					    dp2->dp_typ == DOSPTYP_OPENBSD)
						ourpart = i;
				if (ourpart == -1)
					goto donot;
d322 3
a324 3
				 * This is our MBR partition. need sector
				 * address for SCSI/IDE, cylinder for
				 * ESDI/ST506/RLL
d326 10
a335 23
				dp2 = &dp[ourpart];
				dospartoff = letoh32(dp2->dp_start) + part_blkno;
				cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);

				/* XXX build a temporary disklabel */
				lp->d_partitions[0].p_size = letoh32(dp2->dp_size);
				lp->d_partitions[0].p_offset =
				    letoh32(dp2->dp_start) + part_blkno;
				if (lp->d_ntracks == 0)
					lp->d_ntracks = dp2->dp_ehd + 1;
				if (lp->d_nsectors == 0)
					lp->d_nsectors = DPSECT(dp2->dp_esect);
				if (lp->d_secpercyl == 0)
					lp->d_secpercyl = lp->d_ntracks *
					    lp->d_nsectors;
			}
donot:
			/*
			 * In case the disklabel read below fails, we want to
			 * provide a fake label in i-p.
			 */
			for (dp2=dp, i=0; i < NDOSPART && n < 8; i++, dp2++) {
				struct partition *pp = &lp->d_partitions[8+n];
d337 16
a352 55
				if (dp2->dp_typ == DOSPTYP_OPENBSD)
					continue;
				if (letoh32(dp2->dp_size) > lp->d_secperunit)
					continue;
				if (letoh32(dp2->dp_size))
					pp->p_size = letoh32(dp2->dp_size);
				if (letoh32(dp2->dp_start))
					pp->p_offset =
					    letoh32(dp2->dp_start) + part_blkno;

				switch (dp2->dp_typ) {
				case DOSPTYP_UNUSED:
					for (cp = (char *)dp2;
					    cp < (char *)(dp2 + 1); cp++)
						if (*cp)
							break;
					/*
					 * Was it all zeroes?  If so, it is
					 * an unused entry that we don't
					 * want to show.
					 */
					if (cp == (char *)(dp2 + 1))
					    continue;
					lp->d_partitions[8 + n++].p_fstype =
					    FS_UNUSED;
					break;

				case DOSPTYP_LINUX:
					pp->p_fstype = FS_EXT2FS;
					n++;
					break;

				case DOSPTYP_FAT12:
				case DOSPTYP_FAT16S:
				case DOSPTYP_FAT16B:
				case DOSPTYP_FAT32:
				case DOSPTYP_FAT32L:
				case DOSPTYP_FAT16L:
					pp->p_fstype = FS_MSDOS;
					n++;
					break;
				case DOSPTYP_EXTEND:
				case DOSPTYP_EXTENDL:
					part_blkno =
					    letoh32(dp2->dp_start) + extoff;
					if (!extoff) {
						extoff = letoh32(dp2->dp_start);
						part_blkno = 0;
					}
					wander = 1;
					break;
				default:
					pp->p_fstype = FS_OTHER;
					n++;
					break;
d354 6
a361 3
		lp->d_bbsize = 8192;
		lp->d_sbsize = 64*1024;		/* XXX ? */
		lp->d_npartitions = n > 0 ? n + 8 : 3;
d363 3
@


1.56
log
@unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.55 2006/10/04 03:23:01 krw Exp $	*/
a274 10
						ourpart = i;
				for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
				    i++, dp2++)
					if (letoh32(dp2->dp_size) &&
					    dp2->dp_typ == DOSPTYP_FREEBSD)
						ourpart = i;
				for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
				    i++, dp2++)
					if (letoh32(dp2->dp_size) &&
					    dp2->dp_typ == DOSPTYP_NETBSD)
@


1.55
log
@More tidying up after bad144. Remove references in comments and
don't include dkbad.h when nothing in it is used. Missed
arm/include/disklabel.h first time around.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.54 2006/10/04 00:52:55 krw Exp $	*/
a223 1
	dev_t dev;
@


1.54
log
@Zap bad144 bad sector info in disklabels. Sparsely used if at all for
a few obsolete and easily replaced disk models. And didn't work anyway
according to Bob, who has tried.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.53 2006/09/16 14:56:11 krw Exp $	*/
d204 1
a204 2
 * find disklabel inside a DOS partition. Also, if bad block
 * table needed, attempt to extract it as well. Return buffer
@


1.53
log
@Revert new check for DOS partitions running past d_secperunit (e.g.
r1.54 of i386/disksubr.c). The check incorrectly handled extended
partitions. Possibly a symptom of a deeper problem with extended
partition offsets that will be addressed post-4.0.

Problem reported/fix tested by A. Velichinsky, cause diagnosed by
otto@@.

ok pedro@@ mickey@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.52 2006/08/20 03:14:21 krw Exp $	*/
a222 1
	struct dkbad *db, *bdp = &DKBAD(osdep);
a390 42
	if (msg)
		return (msg);

	/* obtain bad sector table if requested and present */
	if (bdp && (lp->d_flags & D_BADSECT)) {
		/*
		 * get a new buffer and initialize it as callers trust the
		 * buffer given to us, to point at the disklabel sector.
		 */
		dev = bp->b_dev;
		bp = geteblk((int)lp->d_secsize);
		bp->b_dev = dev;

		i = 0;
		do {
			/* read a bad sector table */
			bp->b_flags = B_BUSY | B_READ;
			bp->b_blkno = lp->d_secperunit - lp->d_nsectors + i;
			if (lp->d_secsize > DEV_BSIZE)
				bp->b_blkno *= lp->d_secsize / DEV_BSIZE;
			else
				bp->b_blkno /= DEV_BSIZE / lp->d_secsize;
			bp->b_bcount = lp->d_secsize;
			bp->b_cylinder = lp->d_ncylinders - 1;
			(*strat)(bp);

			/* if successful, validate, otherwise try another */
			if (biowait(bp))
				msg = "bad sector table I/O error";
			else {
				db = (struct dkbad *)(bp->b_data);
#define DKBAD_MAGIC 0x4321
				if (db->bt_mbz == 0 &&
				    db->bt_flag == DKBAD_MAGIC) {
					msg = NULL;
					*bdp = *db;
					break;
				} else
					msg = "bad sector table corrupted";
			}
		} while ((bp->b_flags & B_ERROR) && (i += 2) < 10 &&
		    i < lp->d_nsectors);
a391 4
		/* Give back the bad block buffer.  */
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
@


1.52
log
@When spoofing an MSDOS disklabel, don't create partitions with a final
block past d_secperunit.

Fixes devices where bogus partitions with a starting offset >
d_secperunit were created. e.g. floppies formatted by Caldera DR-DOS.

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.51 2006/08/17 19:02:15 deraadt Exp $	*/
a318 3
				u_int64_t blkno = (u_int64_t)part_blkno +
				    (u_int64_t)letoh32(dp2->dp_start) +
				    (u_int64_t)letoh32(dp2->dp_size);
d322 1
a322 1
				if (blkno > lp->d_secperunit)
@


1.51
log
@tsk tsk, krw did not test compile this
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.50 2006/08/17 10:34:14 krw Exp $	*/
d319 3
d325 1
a325 1
				if (letoh32(dp2->dp_size) > lp->d_secperunit)
@


1.50
log
@Check d_secpercyl in all readdisklable() functions, and have all of
them return 'invalid geometry' when d_secpercyl == 0. While there move
the check to a consistant location (after the check of d_secperunit)
and use a consistant idiom (i.e. some readdisklabel()'s have no 'done'
label).

prodded by thib@@ after a bad macppc experience. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.49 2006/08/11 21:32:39 krw Exp $	*/
a193 1
done:
@


1.49
log
@Use d_secperunit rather than 0x1fffffff as the default value for
RAW_PART's p_size. Since d_secperunit is initialized to 0x1fffffff if
not specified there should be no need to use the magic number again.
And if d_secperunit was specified then that value should be used
instead of the magic number.

This was already being done for hp300, luna88k, mac68k, mvme68k,
mvme88k.

Should be a no-op.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.48 2006/07/11 00:51:21 krw Exp $	*/
d146 2
a147 4
	if (lp->d_secpercyl == 0) {
		msg = "invalid geometry";
		goto done;
	}
@


1.48
log
@Remove DISKLABEL_ALL, DISKLABEL_ALPHA, leave DISKLABEL_I386 in
GENERIC. Remove now superfluous check for DISKLABEL_ALL.

'whack whack whack!' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.47 2006/07/09 21:00:17 krw Exp $	*/
d156 1
a156 1
		lp->d_partitions[i].p_size = 0x1fffffff;
@


1.47
log
@Remove DLT_* logic from Alpha as well, being careful to keep the
checksumming of the native disklabel.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.46 2006/07/03 20:00:22 krw Exp $	*/
a49 5

/* The native defaults... */
#if defined(DISKLABEL_ALL) && !defined(DISKLABEL_I386)
#define DISKLABEL_I386
#endif
@


1.46
log
@Eliminate most of the #if/#endif maze in alpha, hppa, hppa64, and mips64
disklabel code that was intended to support cross-endian and cross-architecture
use of disklabels. Never actually used except for Alpha<->Amiga moves that now
can't happen anyway.

Leave native and DOS MBR disklabel code. Tested on alpha and hppa.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.45 2006/07/01 16:50:32 krw Exp $	*/
a62 2
static enum disklabel_tag probe_order[] = { LABELPROBES, -1 };

a142 1
	enum disklabel_tag *tp;
d169 4
a172 8
	for (tp = probe_order; msg && *tp != -1; tp++) {
		switch (*tp) {
		case DLT_ALPHA:
			msg = readbsdlabel(bp, strat, 0, ALPHA_LABELSECTOR,
			    ALPHA_LABELOFFSET, lp, spoofonly);
			break;

		case DLT_I386:
d174 6
a179 9
			msg = readdoslabel(bp, strat, lp, osdep, 0, 0, spoofonly);
			if (msg)
				/* Fallback alternative */
				fallbacklabel = *lp;
#endif
			break;

		default:
			panic("unrecognized disklabel tag %d", *tp);
a180 2
		if (msg)
			*lp = minilabel;
d182 1
a182 1

a185 1
		osdep->labeltag = *tp;
a525 1
	enum disklabel_tag *tp;
d532 1
a532 1
	int labeloffset, error, i, partoff = 0, cyl = 0;
d545 8
a552 1
	for (tp = probe_order; msg && *tp != -1; tp++) {
d554 3
a556 12
		switch (*tp) {
		case DLT_ALPHA:
			msg = readbsdlabel(bp, strat, 0, ALPHA_LABELSECTOR,
			    ALPHA_LABELOFFSET, &dl, 0);
			labeloffset = ALPHA_LABELOFFSET;
			break;

		case DLT_I386:
#if defined(DISKLABEL_I386)
			msg = readdoslabel(bp, strat, &dl, &cdl, &partoff,
			    &cyl, 0);
			labeloffset = I386_LABELOFFSET;
a557 7
			break;

		default:
			panic("unrecognized disklabel tag %d", *tp);
		}
	}

d571 2
a572 2
	/* Alpha bootblocks are checksummed.  */
	if (*tp == DLT_ALPHA) {
@


1.45
log
@Eliminate redundant get_le() in favour of letoh32(). Add letoh32()
calls in alpha, hppa, hppa64 and mips63 when accessing the two DOS MBR
u_int32_t fields dp_size and dp_start.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.44 2006/06/11 21:15:35 krw Exp $	*/
a40 3
 *
 * XXX The DOS partitioning code is not endian-independent, only native
 * endian DOS partition tables can be parsed yet.
d52 1
a52 3
#if defined(alpha) && !defined(DISKLABEL_ALPHA)
#define DISKLABEL_ALPHA
#elif (defined(i386) || defined(arc)) && !defined(DISKLABEL_I386)
a55 2
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALPHA) || defined(DISKLABEL_ALL)
void	swapdisklabel(struct disklabel *d);
d57 2
a58 3
    int, int, struct disklabel *, int);
#endif
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALL)
a64 49
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALPHA) || defined(DISKLABEL_ALL)

/*
 * Byteswap all the fields that might be swapped.
 */
void
swapdisklabel(dlp)
	struct disklabel *dlp;
{
	int i;
	struct partition *pp;

	swap32(dlp->d_magic);
	swap16(dlp->d_type);
	swap16(dlp->d_subtype);
	swap32(dlp->d_secsize);
	swap32(dlp->d_nsectors);
	swap32(dlp->d_ntracks);
	swap32(dlp->d_ncylinders);
	swap32(dlp->d_secpercyl);
	swap32(dlp->d_secperunit);
	swap16(dlp->d_sparespertrack);
	swap16(dlp->d_sparespercyl);
	swap32(dlp->d_acylinders);
	swap16(dlp->d_rpm);
	swap16(dlp->d_interleave);
	swap16(dlp->d_trackskew);
	swap16(dlp->d_cylskew);
	swap32(dlp->d_headswitch);
	swap32(dlp->d_trkseek);
	swap32(dlp->d_flags);
	for (i = 0; i < NDDATA; i++)
		swap32(dlp->d_drivedata[i]);
	for (i = 0; i < NSPARE; i++)
		swap32(dlp->d_spare[i]);
	swap32(dlp->d_magic2);
	swap16(dlp->d_checksum);
	swap16(dlp->d_npartitions);
	swap32(dlp->d_bbsize);
	swap32(dlp->d_sbsize);
	for (i = 0; i < MAXPARTITIONS; i++) {
		pp = &dlp->d_partitions[i];
		swap32(pp->p_size);
		swap32(pp->p_offset);
		swap32(pp->p_fsize);
		swap16(pp->p_cpg);
	}
}

d69 1
a69 1
readbsdlabel(bp, strat, cyl, sec, off, endian, lp, spoofonly)
d72 1
a72 1
	int cyl, sec, off, endian;
a78 4
	u_int32_t magic;

	if (endian != LITTLE_ENDIAN && endian != BIG_ENDIAN)
		panic("readbsdlabel: unsupported byteorder %d", endian);
a96 2
	magic = endian == BIG_ENDIAN ? htobe32(DISKMAGIC) : htole32(DISKMAGIC);

d104 1
a104 1
		if (dlp->d_magic != magic || dlp->d_magic2 != magic) {
a108 2
			if (endian != BYTE_ORDER)
				swapdisklabel(dlp);
a110 3
				/* swap back if necessary.  */
				if (off < 0 && endian != BYTE_ORDER)
					swapdisklabel(dlp);
a112 5
				/* Recalc magic on foreign labels */
				if (endian != BYTE_ORDER) {
					lp->d_checksum = 0;
					lp->d_checksum = dkcksum(lp);
				}
a123 1
#endif
a174 1
#if defined(DISKLABEL_ALPHA) || defined(DISKLABEL_ALL)
d176 1
a176 2
			    ALPHA_LABELOFFSET, LITTLE_ENDIAN, lp, spoofonly);
#endif
d180 1
a180 1
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALL)
d222 1
a222 1
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALL)
d412 1
a412 1
	    LITTLE_ENDIAN, lp, spoofonly);
d543 1
a543 1
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALL)
d546 1
a546 1
	int labeloffset, error, i, endian, partoff = 0, cyl = 0;
a562 1
#if defined(DISKLABEL_ALPHA) || defined(DISKLABEL_ALL)
d564 1
a564 1
			    ALPHA_LABELOFFSET, LITTLE_ENDIAN, &dl, 0);
a565 2
			endian = LITTLE_ENDIAN;
#endif
d569 1
a569 1
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALL)
a572 1
			endian = LITTLE_ENDIAN;
a586 1
		endian = BYTE_ORDER;
a589 7
	}

	if (endian != BYTE_ORDER) {
		swapdisklabel(lp);
		/* recalc checksum */
		lp->d_checksum = 0;
		lp->d_checksum = dkcksum(lp);
@


1.44
log
@Amiga is no longer amoung us. Some architectures were too sentimental
to cut all ties when it left for the attic. Eliminate (theoretical)
ability to read Amiga disklabels on those architectures.

mips64 compile tested by miod@@

"whack away" deraadt@@ "my amiga runs 3.2" niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.43 2006/03/15 20:20:37 miod Exp $	*/
d338 1
a338 1
	        daddr_t part_blkno = DOSBBSECTOR;
d347 1
a347 1
		        loop++;
d358 1
a358 1
		     
d371 3
a373 3
				for (dp2=dp, i=0;
				    i < NDOSPART && ourpart == -1; i++, dp2++)
					if (dp2->dp_size &&
d376 3
a378 3
				for (dp2=dp, i=0;
				    i < NDOSPART && ourpart == -1; i++, dp2++)
					if (dp2->dp_size &&
d381 3
a383 3
				for (dp2=dp, i=0;
				    i < NDOSPART && ourpart == -1; i++, dp2++)
					if (dp2->dp_size &&
d394 1
a394 1
				dospartoff = dp2->dp_start + part_blkno;
d398 3
a400 3
				lp->d_partitions[0].p_size = dp2->dp_size;
				lp->d_partitions[0].p_offset = dp2->dp_start +
				    part_blkno;
d419 5
a423 3
				if (dp2->dp_size)
					pp->p_size = dp2->dp_size;
				if (dp2->dp_start)
d425 1
a425 1
					    dp2->dp_start + part_blkno;
d460 6
a465 3
					part_blkno = dp2->dp_start + extoff;
					if (!extoff)
						extoff = dp2->dp_start;
@


1.43
log
@Nuke dk_establish(), no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.42 2005/12/22 03:02:48 krw Exp $	*/
a43 2
 *
 * XXX Amiga RDB partitioning is not understood yet.
a58 2
#elif defined(amiga) && !defined(DISKLABEL_AMIGA)
#define DISKLABEL_AMIGA
d61 1
a61 1
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALPHA) || defined(DISKLABEL_AMIGA) || defined(DISKLABEL_ALL)
a69 4
#if defined(DISKLABEL_AMIGA) || defined(DISKLABEL_ALL)
char   *readamigalabel(struct buf *, void (*)(struct buf *),
    struct disklabel *, struct cpu_disklabel *, int);
#endif
d73 1
a73 1
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALPHA) || defined(DISKLABEL_AMIGA) || defined(DISKLABEL_ALL)
a263 6
		case DLT_AMIGA:
#if defined(DISKLABEL_AMIGA) || defined(DISKLABEL_ALL)
			msg = readamigalabel(bp, strat, lp, osdep, spoofonly);
#endif
			break;

a534 20
#if defined(DISKLABEL_AMIGA) || defined(DISKLABEL_ALL)
/*
 * XXX RDB parsing is missing still.
 */
char *
readamigalabel(bp, strat, lp, osdep, spoofonly)
	struct buf *bp;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
	int spoofonly;
{
	char *msg;

	msg = readbsdlabel(bp, strat, 0, AMIGA_LABELSECTOR, AMIGA_LABELOFFSET,
	    BIG_ENDIAN, lp, spoofonly);
	return (msg);
}
#endif

a647 8
#endif
			break;

		case DLT_AMIGA:
#if defined(DISKLABEL_AMIGA) || defined(DISKLABEL_ALL)
			msg = readamigalabel(bp, strat, &dl, &cdl, 0);
			labeloffset = AMIGA_LABELOFFSET;
			endian = BIG_ENDIAN;
@


1.42
log
@'spoofonly' does not mean what I thought it meant. The whole point is
to read non-OpenBSD label information like MBRs and populate ('spoof')
the OpenBSD disk label appropriately. So avoiding an I/O when doing
'spoofonly' is to miss the whole point.

Backout all Sept. 26 and subsequent changes to disksubr.c files. The
original CD problem with I/O errors on blank media will be addressed
another way.

Should fix the ext3 vs amd64 problems discussed on misc@@. Thanks to
steven@@ for finally putting it terms that I understood.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.41 2005/09/27 23:56:10 krw Exp $	*/
a79 7

void
dk_establish(dk, dev)
	struct disk *dk;
	struct device *dev;
{
}
@


1.41
log
@Don't try to read the DOS label from the device if spoofonly is 1.
This changes the architectures which use code identical to the amd64
disksubr.c.

macppc seems different so it will be separate. The remaining archs
don't try to read a DOS label.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.40 2005/03/30 07:52:30 deraadt Exp $	*/
a371 5

			if (spoofonly) {
				bzero(dp, NDOSPART * sizeof(*dp));
				goto donot;
			}
@


1.40
log
@first approximation:  spoof UDF filesystem disklabels when we see them.
it is likely a slight bug or two will sneak in with this, so everyone
please keep an eye out on your disklabels
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.39 2004/03/17 14:16:00 miod Exp $	*/
d372 5
@


1.39
log
@Make sure disklabels use at least DEV_BSIZE as their sector size.
This allows the kernel to survive reading the disklabel off a 256-bytes/sector
scsi device...

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.38 2003/10/18 20:14:40 jmc Exp $	*/
d300 4
@


1.38
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.37 2003/06/02 23:27:43 millert Exp $	*/
d239 1
a239 1
	if (lp->d_secsize == 0)
@


1.37
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.36 2002/12/10 23:31:07 miod Exp $	*/
d238 1
a238 1
	/* minimal requirements for archtypal disk label */
d594 1
a594 1
	 * partitition the disk.
@


1.36
log
@You would think cleaning your tree every now and then would eventually never
produce typo fixes, but the typo pool is infinite.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.35 2002/03/14 03:15:50 millert Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.35
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.34 2002/03/14 01:26:26 millert Exp $	*/
d42 1
a42 1
 * This disksubr.c module started to take it's present form on OpenBSD/alpha
@


1.34
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.33 2002/02/19 02:46:39 deraadt Exp $	*/
d71 2
a72 2
char   *readbsdlabel __P((struct buf *, void (*)(struct buf *), int, int,
    int, int, struct disklabel *, int));
d75 2
a76 2
char   *readdoslabel __P((struct buf *, void (*)(struct buf *),
    struct disklabel *, struct cpu_disklabel *, int *, int *, int));
d79 2
a80 2
char   *readamigalabel __P((struct buf *, void (*)(struct buf *),
    struct disklabel *, struct cpu_disklabel *, int));
@


1.33
log
@correct extended partition botch; gluk, in PR 1449
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.32 2001/02/13 16:05:34 art Exp $	*/
d70 2
a71 2
void	swapdisklabel __P((struct disklabel *d));
char   *readbsdlabel __P((struct buf *, void (*) __P((struct buf *)), int, int,
d75 1
a75 1
char   *readdoslabel __P((struct buf *, void (*) __P((struct buf *)),
d79 1
a79 1
char   *readamigalabel __P((struct buf *, void (*) __P((struct buf *)),
d147 1
a147 1
	void (*strat) __P((struct buf *));
d231 1
a231 1
	void (*strat) __P((struct buf *));
d333 1
a333 1
	void (*strat) __P((struct buf *));
d563 1
a563 1
	void (*strat) __P((struct buf *));
d647 1
a647 1
	void (*strat) __P((struct buf *));
@


1.32
log
@Cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.31 2000/10/18 21:00:32 mickey Exp $	*/
d370 2
@


1.32.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.32 2001/02/13 16:05:34 art Exp $	*/
d70 3
a72 3
void	swapdisklabel(struct disklabel *d);
char   *readbsdlabel(struct buf *, void (*)(struct buf *), int, int,
    int, int, struct disklabel *, int);
d75 2
a76 2
char   *readdoslabel(struct buf *, void (*)(struct buf *),
    struct disklabel *, struct cpu_disklabel *, int *, int *, int);
d79 2
a80 2
char   *readamigalabel(struct buf *, void (*)(struct buf *),
    struct disklabel *, struct cpu_disklabel *, int);
d147 1
a147 1
	void (*strat)(struct buf *);
d231 1
a231 1
	void (*strat)(struct buf *);
d333 1
a333 1
	void (*strat)(struct buf *);
a369 2
			if (part_blkno < extoff)
				part_blkno = extoff;
d561 1
a561 1
	void (*strat)(struct buf *);
d645 1
a645 1
	void (*strat)(struct buf *);
@


1.32.6.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
 * This disksubr.c module started to take its present form on OpenBSD/alpha
@


1.31
log
@typo in comment; from gluk@@ptci.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.30 2000/04/24 04:53:00 deraadt Exp $	*/
a68 2
#define	b_cylin	b_resid

d165 1
a165 1
	bp->b_cylin = cyl;
d375 1
a375 1
			bp->b_cylin = part_blkno / lp->d_secpercyl;
d526 1
a526 1
			bp->b_cylin = lp->d_ncylinders - 1;
d711 1
a711 1
		bp->b_cylin = cyl;
d790 1
a790 1
	bp->b_cylin = (bp->b_blkno + blockpersec(p->p_offset, lp)) /
@


1.30
log
@support DOSPTYP_EXTENDL like DOSPTYP_EXTEND; scott@@nts.umn.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.29 1999/07/17 23:12:07 deraadt Exp $	*/
d222 1
a222 1
 * using the indicated stategy routine.
@


1.29
log
@do not brelse() badly
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.28 1999/05/03 22:33:31 mickey Exp $	*/
d478 1
@


1.29.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.32 2001/02/13 16:05:34 art Exp $	*/
d69 2
d167 1
a167 1
	bp->b_cylinder = cyl;
d222 1
a222 1
 * using the indicated strategy routine.
d377 1
a377 1
			bp->b_cylinder = part_blkno / lp->d_secpercyl;
a477 1
				case DOSPTYP_EXTENDL:
d527 1
a527 1
			bp->b_cylinder = lp->d_ncylinders - 1;
d712 1
a712 1
		bp->b_cylinder = cyl;
d791 1
a791 1
	bp->b_cylinder = (bp->b_blkno + blockpersec(p->p_offset, lp)) /
@


1.29.4.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a369 2
			if (part_blkno < extoff)
				part_blkno = extoff;
@


1.29.4.3
log
@Merge in -current from about a week ago
@
text
@d70 3
a72 3
void	swapdisklabel(struct disklabel *d);
char   *readbsdlabel(struct buf *, void (*)(struct buf *), int, int,
    int, int, struct disklabel *, int);
d75 2
a76 2
char   *readdoslabel(struct buf *, void (*)(struct buf *),
    struct disklabel *, struct cpu_disklabel *, int *, int *, int);
d79 2
a80 2
char   *readamigalabel(struct buf *, void (*)(struct buf *),
    struct disklabel *, struct cpu_disklabel *, int);
d147 1
a147 1
	void (*strat)(struct buf *);
d231 1
a231 1
	void (*strat)(struct buf *);
d333 1
a333 1
	void (*strat)(struct buf *);
d563 1
a563 1
	void (*strat)(struct buf *);
d647 1
a647 1
	void (*strat)(struct buf *);
@


1.29.4.4
log
@Sync the SMP branch with 3.3
@
text
@d42 1
a42 1
 * This disksubr.c module started to take its present form on OpenBSD/alpha
@


1.29.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.29.4.4 2003/03/27 23:18:05 niklas Exp $	*/
d18 5
a22 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.29.4.6
log
@Merge of -current from two weeks ago into the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d238 1
a238 1
	/* minimal requirements for archetypal disk label */
d594 1
a594 1
	 * partition the disk.
@


1.29.4.7
log
@Merge with the trunk
@
text
@d239 1
a239 1
	if (lp->d_secsize < DEV_BSIZE)
@


1.28
log
@fix some parenthesis nightmare; niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.27 1999/01/05 04:29:03 millert Exp $	*/
d238 1
a238 1
	struct buf *bp;
d314 4
a317 2
	bp->b_flags |= B_INVAL;
	brelse(bp);
@


1.27
log
@be extra careful to not divide by zero; more arches to come
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.26 1998/11/23 03:35:56 millert Exp $	*/
d63 1
a63 1
#elif (defined(i386) || defined(arc))) && !defined(DISKLABEL_I386)
d65 1
a65 1
#elif defined(amiga)) && !defined(DISKLABEL_AMIGA)
@


1.26
log
@pasto in last commit
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.25 1998/11/23 03:33:42 millert Exp $	*/
d346 9
d757 7
@


1.25
log
@add missing done: label so this actually compiles
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.24 1998/11/21 20:43:42 deraadt Exp $	*/
d313 1
a724 1
done:
@


1.24
log
@deal with d_secpercyl insanity
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.23 1998/10/03 21:18:54 millert Exp $	*/
d724 1
@


1.23
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.22 1998/05/02 03:33:33 millert Exp $	*/
d249 4
@


1.22
log
@Fix pasto
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.21 1998/03/02 20:12:02 niklas Exp $	*/
d74 1
a74 1
    int, int, struct disklabel *));
d78 1
a78 1
    struct disklabel *, struct cpu_disklabel *, int *, int *));
d82 1
a82 1
    struct disklabel *, struct cpu_disklabel *));
d147 1
a147 1
readbsdlabel(bp, strat, cyl, sec, off, endian, lp)
d152 1
d162 4
d231 1
a231 1
readdisklabel(dev, strat, lp, osdep)
d236 1
d268 1
a268 1
			    ALPHA_LABELOFFSET, LITTLE_ENDIAN, lp);
d274 1
a274 1
			msg = readdoslabel(bp, strat, lp, osdep, 0, 0);
d283 1
a283 1
			msg = readamigalabel(bp, strat, lp, osdep);
d326 1
a326 1
readdoslabel(bp, strat, lp, osdep, partoffp, cylp)
d333 1
d487 1
a487 1
	    LITTLE_ENDIAN, lp);
d544 1
a544 1
readamigalabel(bp, strat, lp, osdep)
d549 1
d554 1
a554 1
	    BIG_ENDIAN, lp);
d660 1
a660 1
			    ALPHA_LABELOFFSET, LITTLE_ENDIAN, &dl);
d669 1
a669 1
			    &cyl);
d677 1
a677 1
			msg = readamigalabel(bp, strat, &dl, &cdl);
@


1.21
log
@"Whoops" last commit contained stuff not meant to be committed
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.19 1998/02/24 04:22:40 deraadt Exp $	*/
d239 1
a239 1
	if (lp->d_secperunit == 0)
@


1.20
log
@GCC 2.8 -Wall explicit typing
@
text
@d65 1
a65 1
#elif defined(amiga) && !defined(DISKLABEL_AMIGA)
a66 2
#elif defined(sparc) && !defined(DISKLABEL_SUN)
#define DISKLABEL_SUN
d71 1
a71 1
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALPHA) || defined(DISKLABEL_AMIGA) || defined(DISKLABEL_SUN) || defined(DISKLABEL_ALL)
a83 5
#if defined(DISKLABEL_SUN) || defined(DISKLABEL_ALL)
char	*disklabel_sun_to_bsd __P((char *, struct disklabel *));
int	disklabel_bsd_to_sun __P((struct disklabel *, char *));
static __inline u_int32_t sun_extended_sum __P((struct sun_disklabel *));
#endif
a86 1
/* When/if this file gets MI, dk_establish should be moved to an MD file */
d94 1
a94 1
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALPHA) || defined(DISKLABEL_AMIGA) || defined(DISKLABEL_SUN) || defined(DISKLABEL_ALL)
a280 8
		case DLT_SUN:
#if defined(DISKLABEL_SUN) || defined(DISKLABEL_ALL)
			/* XXX We want to grok native Sun labels too */
			msg = readbsdlabel(bp, strat, 0, SUN_LABELSECTOR,
			    SUN_LABELOFFSET, BIG_ENDIAN, lp);
#endif
			break;

d339 1
a339 1
		u_int32_t extoff = 0;
a768 252

#if defined(DISKLABEL_SUN) || defined(DISKLABEL_ALL)
/************************************************************************
 *
 * The rest of this was taken from arch/sparc/scsi/sun_disklabel.c
 * and then substantially rewritten by Gordon W. Ross
 *
 ************************************************************************/

/* What partition types to assume for Sun disklabels: */
static u_int8_t
sun_fstypes[16] = {
	FS_BSDFFS,	/* a */
	FS_SWAP,	/* b */
	FS_UNUSED,	/* c - whole disk */
	FS_BSDFFS,	/* d */
	FS_BSDFFS,	/* e */
	FS_BSDFFS,	/* f */
	FS_BSDFFS,	/* g */
	FS_BSDFFS,	/* h */
	FS_BSDFFS,	/* i */
	FS_BSDFFS,	/* j */
	FS_BSDFFS,	/* k */
	FS_BSDFFS,	/* l */
	FS_BSDFFS,	/* m */
	FS_BSDFFS,	/* n */
	FS_BSDFFS,	/* o */
	FS_BSDFFS	/* p */
};

/*
 * Given a struct sun_disklabel, assume it has an extended partition
 * table and compute the correct value for sl_xpsum.
 */
static __inline u_int32_t
sun_extended_sum(sl)
	struct sun_disklabel *sl;
{
	u_int32_t lsum;
	u_int32_t *xp;
	u_int32_t *ep;

	xp = (u_int32_t *) &sl->sl_xpmag;
	ep = (u_int32_t *) &sl->sl_xxx1[0];

	lsum = 0;
	for (; xp < ep; xp++)
		lsum += *xp;
	return (lsum);
}

/*
 * Given a SunOS disk label, set lp to a BSD disk label.
 * Returns NULL on success, else an error string.
 *
 * The BSD label is cleared out before this is called.
 */
char *
disklabel_sun_to_bsd(cp, lp)
	char *cp;
	struct disklabel *lp;
{
	struct sun_disklabel *sl;
	struct partition *npp;
	struct sun_dkpart *spp;
	int i, secpercyl;
	u_int16_t cksum, *sp1, *sp2;

	sl = (struct sun_disklabel *)cp;

	/* Verify the XOR check. */
	sp1 = (u_int16_t *)sl;
	sp2 = (u_int16_t *)(sl + 1);
	cksum = 0;
	while (sp1 < sp2)
		cksum ^= *sp1++;
	if (cksum != 0)
		return("SunOS disk label, bad checksum");

	/* Format conversion. */
	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	bcopy(sl->sl_text, lp->d_packname, sizeof(lp->d_packname));

	lp->d_secsize = 512;
	lp->d_nsectors   = sl->sl_nsectors;
	lp->d_ntracks    = sl->sl_ntracks;
	lp->d_ncylinders = sl->sl_ncylinders;

	secpercyl = sl->sl_nsectors * sl->sl_ntracks;
	lp->d_secpercyl  = secpercyl;
	lp->d_secperunit = secpercyl * sl->sl_ncylinders;

	lp->d_sparespercyl = sl->sl_sparespercyl;
	lp->d_acylinders   = sl->sl_acylinders;
	lp->d_rpm          = sl->sl_rpm;
	lp->d_interleave   = sl->sl_interleave;

	lp->d_npartitions = MAXPARTITIONS;
	/* These are as defined in <ufs/ffs/fs.h> */
	lp->d_bbsize = 8192;	/* XXX */
	lp->d_sbsize = 8192;	/* XXX */

	for (i = 0; i < 8; i++) {
		spp = &sl->sl_part[i];
		npp = &lp->d_partitions[i];
		npp->p_offset = spp->sdkp_cyloffset * secpercyl;
		npp->p_size = spp->sdkp_nsectors;
		if (npp->p_size == 0) {
			npp->p_fstype = FS_UNUSED;
		} else {
			npp->p_fstype = sun_fstypes[i];
			if (npp->p_fstype == FS_BSDFFS) {
				/*
				 * The sun label does not store the FFS fields,
				 * so just set them with default values here.
				 */
				npp->p_fsize = 1024;
				npp->p_frag = 8;
				npp->p_cpg = 16;
			}
		}
	}

	/* Clear "extended" partition info, tentatively */
	for (i = 0; i < SUNXPART; i++) {
		npp = &lp->d_partitions[i+8];
		npp->p_offset = 0;
		npp->p_size = 0;
		npp->p_fstype = FS_UNUSED;
	}

	/* Check to see if there's an "extended" partition table */
	if (sl->sl_xpmag == SL_XPMAG &&
	    sun_extended_sum(sl) == sl->sl_xpsum) {	/* ...yes! */
		/*
		 * There is.  Copy over the "extended" partitions.
		 * This code parallels the loop for partitions a-h.
		 */
		for (i = 0; i < SUNXPART; i++) {
			spp = &sl->sl_xpart[i];
			npp = &lp->d_partitions[i+8];
			npp->p_offset = spp->sdkp_cyloffset * secpercyl;
			npp->p_size = spp->sdkp_nsectors;
			if (npp->p_size == 0) {
				npp->p_fstype = FS_UNUSED;
				continue;
			}
			npp->p_fstype = sun_fstypes[i+8];
			if (npp->p_fstype == FS_BSDFFS) {
				npp->p_fsize = 1024;
				npp->p_frag = 8;
				npp->p_cpg = 16;
			}
		}
	}

	lp->d_checksum = 0;
	lp->d_checksum = dkcksum(lp);
	return (NULL);
}

/*
 * Given a BSD disk label, update the Sun disklabel
 * pointed to by cp with the new info.  Note that the
 * Sun disklabel may have other info we need to keep.
 * Returns zero or error code.
 */
int
disklabel_bsd_to_sun(lp, cp)
	struct disklabel *lp;
	char *cp;
{
	struct sun_disklabel *sl;
	struct partition *npp;
	struct sun_dkpart *spp;
	int i, secpercyl;
	u_int16_t cksum, *sp1, *sp2;

	if (lp->d_secsize != 512)
		return (EINVAL);

	sl = (struct sun_disklabel *)cp;

	/* Format conversion. */
	bcopy(lp->d_packname, sl->sl_text, sizeof(lp->d_packname));
	sl->sl_rpm = lp->d_rpm;
	sl->sl_pcylinders   = lp->d_ncylinders + lp->d_acylinders; /* XXX */
	sl->sl_sparespercyl = lp->d_sparespercyl;
	sl->sl_interleave   = lp->d_interleave;
	sl->sl_ncylinders   = lp->d_ncylinders;
	sl->sl_acylinders   = lp->d_acylinders;
	sl->sl_ntracks      = lp->d_ntracks;
	sl->sl_nsectors     = lp->d_nsectors;

	secpercyl = sl->sl_nsectors * sl->sl_ntracks;
	for (i = 0; i < 8; i++) {
		spp = &sl->sl_part[i];
		npp = &lp->d_partitions[i];

		if (npp->p_offset % secpercyl)
			return (EINVAL);
		spp->sdkp_cyloffset = npp->p_offset / secpercyl;
		spp->sdkp_nsectors = npp->p_size;
	}
	sl->sl_magic = SUN_DKMAGIC;

	/*
	 * The reason we store the extended table stuff only conditionally
	 * is so that a label that doesn't need it will have NULs there, like
	 * a "traditional" Sun label.  Since Suns seem to ignore everything
	 * between sl_text and sl_rpm, this probably doesn't matter, but it
	 * certainly doesn't hurt anything and it's easy to do.
	 */
	for (i = 0; i < SUNXPART; i++) {
		if (lp->d_partitions[i+8].p_offset ||
		    lp->d_partitions[i+8].p_size)
			break;
	}
	/* We do need to load the extended table? */
	if (i < SUNXPART) {
		sl->sl_xpmag = SL_XPMAG;
		for (i = 0; i < SUNXPART; i++) {
			spp = &sl->sl_xpart[i];
			npp = &lp->d_partitions[i+8];
			if (npp->p_offset % secpercyl)
				return (EINVAL);
			sl->sl_xpart[i].sdkp_cyloffset =
			    npp->p_offset / secpercyl;
			sl->sl_xpart[i].sdkp_nsectors = npp->p_size;
		}
		sl->sl_xpsum = sun_extended_sum(sl);
	} else {
		sl->sl_xpmag = 0;
		for (i = 0; i < SUNXPART; i++) {
			sl->sl_xpart[i].sdkp_cyloffset = 0;
			sl->sl_xpart[i].sdkp_nsectors = 0;
		}
		sl->sl_xpsum = 0;
	}

	/* Correct the XOR check. */
	sp1 = (u_int16_t *)sl;
	sp2 = (u_int16_t *)(sl + 1);
	sl->sl_cksum = cksum = 0;
	while (sp1 < sp2)
		cksum ^= *sp1++;
	sl->sl_cksum = cksum;

	return (0);
}
#endif
@


1.19
log
@rename some DOS MBR partition types
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.18 1998/02/19 20:36:39 deraadt Exp $	*/
d65 1
a65 1
#elif defined(amiga)) && !defined(DISKLABEL_AMIGA)
d67 2
d73 1
a73 1
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALPHA) || defined(DISKLABEL_AMIGA) || defined(DISKLABEL_ALL)
d86 5
d94 1
d102 1
a102 1
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALPHA) || defined(DISKLABEL_AMIGA) || defined(DISKLABEL_ALL)
d289 8
d355 1
a355 1
		unsigned long extoff = 0;
d577 2
a578 2
	register i;
	register struct partition *opp, *npp;
d785 252
@


1.18
log
@add netbsd partition, rename 386BSD one to FreeBSD..
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.17 1998/01/11 20:42:03 provos Exp $	*/
a447 1
				case DOSPTYP_FAT16C:
d449 2
@


1.17
log
@disklabel spoofing for FAT32.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.16 1997/11/09 23:10:01 niklas Exp $	*/
d377 6
a382 1
					    dp2->dp_typ == DOSPTYP_386BSD)
@


1.16
log
@swap definitions superceded by new endian.h
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.15 1997/10/20 07:26:40 niklas Exp $	*/
d444 1
@


1.15
log
@Do not spoof OpenBSD partitions
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.14 1997/10/02 12:58:08 niklas Exp $	*/
a94 8
/* XXX should we not provide generic swapXX functions? */
#if BYTE_ORDER == BIG_ENDIAN
#define swap32(x) ((x) = htole32(x))
#define swap16(x) ((x) = htole16(x))
#else
#define swap32(x) ((x) = htobe32(x))
#define swap16(x) ((x) = htobe16(x))
#endif
@


1.14
log
@label "done" now unused
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.11 1997/08/08 22:01:08 niklas Exp $	*/
d418 2
@


1.13
log
@typos
@
text
@a710 1
done:
@


1.12
log
@no more ESRCH, but maybe EIO instead
@
text
@d686 3
a688 3
		bp->bp_blkno = partoff + LABELSECTOR;
		bp->bp_cylin = cyl;
		bp->bp_bcount = lp->d_secsize;
@


1.11
log
@Use the new bounds_check_with_label API.  Add generic support for reading
both little and big endian BSD disklabels.  Add a specific hook to read such
a big-endian disklabel as it is found on amiga (normally, however, amiga
uses the native RDB format, which still is not supported).
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.10 1997/07/30 11:39:36 niklas Exp $	*/
d78 1
a78 1
    struct disklabel *, struct cpu_disklabel *));
a212 1

d276 1
a276 1
			msg = readdoslabel(bp, strat, lp, osdep);
d328 1
a328 1
readdoslabel(bp, strat, lp, osdep)
d333 2
d368 2
d471 6
d632 1
a632 1
	int labeloffset, error, i, endian;
d659 2
a660 1
			msg = readdoslabel(bp, strat, &dl, &cdl);
d680 9
a688 2
		error = ESRCH;
		goto done;
@


1.10
log
@Simplify ifdefs.  Ensure a MBR-originated fake label will be chosen before the
more minimal label that used to get precedence.  Comment some more.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.9 1997/06/30 11:50:59 niklas Exp $	*/
d41 11
d61 1
a61 1
#ifdef __alpha__
d63 1
a63 1
#elif defined(__i386__) || defined(__arc__)
d65 2
d71 2
a72 4
#define BOOT_MAGIC 0xAA55
#define BOOT_MAGIC_OFF (DOSPARTOFF + NDOSPART * sizeof (struct dos_partition))

#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALPHA) || defined(DISKLABEL_ALL)
d74 1
a74 1
    int, struct disklabel *));
d80 4
d94 57
a150 1
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALPHA) || defined(DISKLABEL_ALL)
d155 1
a155 1
readbsdlabel(bp, strat, cyl, sec, off, lp)
d158 1
a158 1
	int cyl, sec, off;
d163 5
d182 2
d191 1
a191 1
		if (dlp->d_magic != DISKMAGIC || dlp->d_magic2 != DISKMAGIC) {
d194 20
a213 7
		} else if (dlp->d_npartitions > MAXPARTITIONS ||
		    dkcksum(dlp) != 0)
			msg = "disk label corrupted";
		else {
			*lp = *dlp;
			msg = NULL;
			break;
d271 1
a271 3
			    ALPHA_LABELOFFSET, lp);
			if (msg == NULL)
				lp->d_spare[4] = ALPHA_LABELSECTOR; /* XXX */
d278 1
a278 3
			if (msg == NULL)
				lp->d_spare[4] = bp->b_blkno;	/* XXX */
			else
d284 6
d297 6
d335 2
a336 2
	struct dos_partition *dp = osdep->dosparts, *dp2;
	struct dkbad *db, *bdp = &osdep->bad;
d470 1
a470 1
	    lp);
d522 19
a607 1
 * XXX cannot handle OpenBSD partitions in extended partitions!
d623 1
a623 1
	int labeloffset, error, i;
d630 6
d642 1
a642 1
			    ALPHA_LABELOFFSET, &dl);
d644 1
d652 9
d674 7
d706 1
a706 1
bounds_check_with_label(bp, lp, wlabel)
d709 1
d714 2
a715 2
	int labelsector = blockpersec(lp->d_partitions[RAW_PART].p_offset, lp) +
	    lp->d_spare[4];	/* XXX */
@


1.9
log
@Add MBR & i386/disklabel probing in a generic fashion usable for more
disklabel types, and for other architectures if they chose.  Both read/write
supported for both alpha and i386/arc disklabels.  ISO9660 spoofing kept
and tested.  Add "option DISKLABEL_ALL" to your config to use.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.14 1997/05/08 00:14:29 deraadt Exp $	*/
d5 1
d49 7
d59 1
a59 1
#define BOOT_MAGIC_OFF (DOSPARTOFF+NDOSPART*sizeof(struct dos_partition))
d61 1
d64 2
d68 1
d79 1
d131 1
d154 1
a154 1
	struct disklabel savedlabel;
d169 1
a169 1
	savedlabel = *lp;
d178 1
a178 1
#if defined(DISKLABEL_ALPHA) || defined(DISKLABEL_ALL) || defined(__alpha__)
d187 1
a187 1
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALL) || defined(__i386__) || defined(__arc__)
d191 3
d201 1
a201 1
			*lp = savedlabel;
d209 4
d218 1
d366 1
a366 1
		lp->d_npartitions = MAXPARTITIONS;
d421 1
d441 8
a448 2
	/* XXX is this needed at all?  NetBSD/alpha doesn't have it.  */
	/* special case to allow disklabel to be invalidated */
d503 1
a503 1
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALL) || defined(__i386__) || defined(__arc__)
d517 1
a517 1
#if defined(DISKLABEL_ALPHA) || defined(DISKLABEL_ALL) || defined(__alpha__)
d525 1
a525 1
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALL) || defined(__i386__) || defined(__arc__)
@


1.8
log
@16 partitions
@
text
@d1 2
a2 2
/*	$OpenBSD: disksubr.c,v 1.7 1997/04/06 06:03:44 deraadt Exp $	*/
/*	$NetBSD: disksubr.c,v 1.9 1996/11/13 21:13:05 cgd Exp $	*/
d5 2
a6 1
 * Copyright (c) 1994, 1995, 1996 Carnegie-Mellon University.
d9 15
a23 13
 * Authors: Keith Bostic, Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
d25 11
a35 4
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
d37 1
a37 2
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
d41 1
a42 1
#include <sys/ioccom.h>
d45 1
d48 1
a48 2
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
d50 2
a51 2
#include <machine/cpu.h>
#include <machine/autoconf.h>
d53 6
a58 1
extern struct device *bootdv;
a59 1
/* was this the boot device ? */
d65 26
a90 13
#ifdef NOTDEF
	/* XXX: sd -> scsibus -> esp */
	struct bootpath *bp = ((struct esp_softc *)dev->dv_parent->dv_parent)->sc_bp;
	char name[10];

#define CRAZYMAP(v) ((v) == 3 ? 0 : (v) == 0 ? 3 : (v))

	if (bp == NULL) {
		printf("no boot path\n");
	}
	sprintf(name, "%s%d", bp->name, CRAZYMAP(bp->val[0]));
	if (strcmp(name, dev->dv_xname) == 0) {
		bootdv = dev;
d92 25
a116 1
#endif
d123 4
a126 2
 * secpercyl and anything required in the strategy routine
 * (e.g., sector size) must be filled in before calling us.
d130 1
a130 1
readdisklabel(dev, strat, lp, clp)
d134 1
a134 1
	struct cpu_disklabel *clp;
d137 4
a140 2
	struct disklabel *dlp;
	char *msg = NULL;
d144 12
a155 5
		lp->d_secperunit = 0x1fffffff; 
	lp->d_npartitions = 1;
	if (lp->d_partitions[0].p_size == 0)
		lp->d_partitions[0].p_size = 0x1fffffff;
	lp->d_partitions[0].p_offset = 0;
d157 1
a157 1
	/* obtain buffer to probe drive with */
d159 1
d161 10
a170 7
	/* next, dig out disk label */
	bp->b_dev = dev;
	bp->b_blkno = LABELSECTOR;
	bp->b_resid = 0;			/* was b_cylin */
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_BUSY | B_READ;
	(*strat)(bp);  
d172 7
a178 5
	/* if successful, locate disk label within block and validate */
	if (biowait(bp)) {
		msg = "disk label read error";
		goto done;
	}
d180 2
a181 5
	dlp = (struct disklabel *)(bp->b_un.b_addr + LABELOFFSET);
	if (dlp->d_magic == DISKMAGIC) {
		if (dkcksum(dlp)) {
			msg = "OpenBSD disk label corrupted";
			goto done;
d183 2
a184 2
		*lp = *dlp;
		goto done;
d186 1
d188 2
a189 2
	if (iso_disklabelspoof(dev, strat, lp) == 0)
		goto done;
d191 2
a192 3
	msg = "no disk label";
done:
	bp->b_flags = B_INVAL | B_AGE | B_READ;
d198 205
a402 1
 * Check new disk label for sensibility before setting it.
d405 2
a406 2
setdisklabel(olp, nlp, openmask, clp)
	register struct disklabel *olp, *nlp;
d408 1
a408 1
	struct cpu_disklabel *clp;
d418 1
a418 2
#ifdef notdef
	/* XXX WHY WAS THIS HERE?! */
d420 1
a420 1
	if (nlp->d_magic == 0xffffffff) { 
a423 1
#endif
d426 1
a426 1
		dkcksum(nlp) != 0)
d429 4
a432 2
	while ((i = ffs((long)openmask)) != 0) {
		i--;
d438 2
a439 1
		if (npp->p_offset != opp->p_offset || npp->p_size < opp->p_size)
d443 1
a443 1
		 * if new label doesn't include it.             XXX
d455 1
a455 1
	return (0);     
d458 1
d461 1
a461 2
 * this means write out the Rigid disk blocks to represent the 
 * label.  Hope the user was carefull.
d464 1
a464 1
writedisklabel(dev, strat, lp, clp)
d467 2
a468 2
	register struct disklabel *lp;
	struct cpu_disklabel *clp;
d470 31
a500 4
	struct buf *bp; 
	struct disklabel *dlp;
	int labelpart;
	int error = 0;
d502 3
a504 4
	labelpart = DISKPART(dev);
	if (lp->d_partitions[labelpart].p_offset != 0) {
		if (lp->d_partitions[0].p_offset != 0)
			return (EXDEV);		/* not quite right */
d506 3
a508 8
	bp = geteblk((int)lp->d_secsize);
	bp->b_dev = MAKEDISKDEV(major(dev), DISKUNIT(dev), labelpart);
	bp->b_blkno = LABELSECTOR;
	bp->b_resid = 0;			/* was b_cylin */
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_READ;           /* get current label */
	(*strat)(bp);
	if ((error = biowait(bp)) != 0)
d510 1
d512 1
a512 2
	dlp = (struct disklabel *)(bp->b_un.b_addr + LABELOFFSET);
	*dlp = *lp;     /* struct assignment */
d514 5
a518 13
	/*
	 * The Alpha requires that the boot block be checksummed.
	 * The first 63 8-bit quantites are summed into the 64th.
	 */
	{
		int i;
		u_long *dp, sum;

		dp = (u_long *)bp->b_un.b_addr;
		sum = 0;
		for (i = 0; i < 63; i++)
			sum += dp[i];
		dp[63] = sum;
d521 1
a521 1
	bp->b_flags = B_WRITE;
d526 1
d528 1
a528 1
	return (error); 
d531 1
a531 2

/* 
d544 2
a545 2
	int labelsect = blockpersec(lp->d_partitions[0].p_offset, lp) +
	    LABELSECTOR;
a547 9
	/* overwriting disk label ? */
	/* XXX should also protect bootstrap in first 8K */ 
	if (bp->b_blkno + blockpersec(p->p_offset, lp) <= labelsect &&
	    (bp->b_flags & B_READ) == 0 && wlabel == 0) {
		bp->b_error = EROFS;
		goto bad;
	}

	/* beyond partition? */ 
d551 1
a551 1
			/* If exactly at end of disk, return an EOF */
d553 1
a553 1
			return(0);
d556 1
d560 1
a560 1
		/* or truncate if part of it fits */
d562 9
a570 1
	}               
d573 1
a573 1
	bp->b_resid = (bp->b_blkno + blockpersec(p->p_offset, lp)) /
d575 2
a576 1
	return(1);
d579 2
a580 1
	return(-1);
@


1.7
log
@support cd9660 disklabel spoofing; also fix block offset confusion
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.6 1997/01/24 19:56:32 niklas Exp $	*/
d173 3
a175 3
		* Copy internally-set partition information
		* if new label doesn't include it.             XXX
		*/
d203 1
d206 5
d212 1
a212 1
	bp->b_dev = dev;
@


1.6
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.5 1996/10/30 22:38:10 niklas Exp $	*/
d122 4
d254 5
a258 6
#define dkpart(dev) (minor(dev) & 7)

	struct partition *p = lp->d_partitions + dkpart(bp->b_dev);
	int labelsect = lp->d_partitions[0].p_offset;
	int maxsz = p->p_size;
	int sz = (bp->b_bcount + DEV_BSIZE - 1) >> DEV_BSHIFT;
d262 1
a262 1
	if (bp->b_blkno + p->p_offset <= LABELSECTOR + labelsect &&
d269 4
a272 3
	if (bp->b_blkno < 0 || bp->b_blkno + sz > maxsz) {
		/* if exactly at end of disk, return an EOF */
		if (bp->b_blkno == maxsz) {
d276 1
a276 3
		/* or truncate if part of it fits */
		sz = maxsz - bp->b_blkno;
		if (sz <= 0) {
d280 1
d285 2
a286 1
	bp->b_resid = (bp->b_blkno + p->p_offset) / lp->d_secpercyl;
@


1.5
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 2
a2 2
/*	$OpenBSD: disksubr.c,v 1.8 1996/10/13 02:59:35 christos Exp $	*/
/*	$NetBSD: disksubr.c,v 1.8 1996/10/13 02:59:35 christos Exp $	*/
d80 1
a80 1
	void (*strat) __P ((struct buf *));
@


1.4
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: disksubr.c,v 1.6 1996/04/29 16:34:50 cgd Exp $	*/
/*	$NetBSD: disksubr.c,v 1.6 1996/04/29 16:34:50 cgd Exp $	*/
d80 1
a80 1
	void (*strat)();
d116 1
a116 1
			msg = "NetBSD disk label corrupted";
d193 1
a193 1
	void (*strat)();
d199 1
a199 1
	int error = 0, cyl, i;
d208 1
a208 1
	if (error = biowait(bp))
@


1.3
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.2
log
@from netbsd;
New generic disk framework.  Highlights:
New metrics handling.  Metrics are now kept in the new `struct disk'.
Busy time is now stored as a timeval, and transfer count in bytes.
Storage for disklabels is now dynamically allocated, so that the size
of the disk structure is not machine-dependent.
Several new functions for attaching and detaching disks, and handling
metrics calculation.
Old-style instrumentation is still supported in drivers that did it
before.  However, old-style instrumentation is being deprecated, and
will go away once the userland utilities are updated for the new
framework.
For usage and architectural details, see the forthcoming disk(9)
manual page.
@
text
@d1 1
a1 1
/*	$NetBSD: disksubr.c,v 1.4 1996/01/07 22:01:38 thorpej Exp $	*/
d4 1
a4 1
 * Copyright (c) 1994, 1995 Carnegie-Mellon University.
d46 1
a46 1
int
a59 1
		return -1;
a65 1
	return 1;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: disksubr.c,v 1.3 1995/04/22 12:43:22 cgd Exp $	*/
d48 1
a48 1
	struct dkdevice *dk;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

