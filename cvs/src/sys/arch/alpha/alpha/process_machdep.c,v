head	1.13;
access;
symbols
	OPENBSD_6_2:1.13.0.6
	OPENBSD_6_2_BASE:1.13
	OPENBSD_6_1:1.13.0.4
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.12.0.12
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.8
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.10
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.6
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.32
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.30
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.28
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.26
	OPENBSD_5_0:1.11.0.24
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.22
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.20
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.16
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.18
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.14
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.12
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.10
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.8
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.6
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.4
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.9.0.14
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.12
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.10
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.8
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.6
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.9
	UBC:1.5.0.6
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.4.0.18
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.14
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.10.19.08.23.37;	author guenther;	state Exp;
branches;
next	1.12;
commitid	cDua0teqoT9OVlTN;

1.12
date	2014.01.26.17.40.09;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.12.19.44.30;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.11.21.30.27;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.28.20.55.14;	author pvalchev;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.06.04.11;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.00.42.20;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.12.11.58.14;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.08.16.01.03;	author art;	state Exp;
branches
	1.5.6.1;
next	1.4;

1.4
date	96.10.30.22.38.23;	author niklas;	state Exp;
branches
	1.4.14.1;
next	1.3;

1.3
date	96.07.29.22.57.56;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.52.45;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.40;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.40;	author deraadt;	state Exp;
branches;
next	;

1.4.14.1
date	2001.04.18.16.00.29;	author niklas;	state Exp;
branches;
next	1.4.14.2;

1.4.14.2
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	1.4.14.3;

1.4.14.3
date	2003.03.27.23.18.06;	author niklas;	state Exp;
branches;
next	;

1.5.6.1
date	2002.06.11.03.33.39;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@The first argument to process_domem() and its uio_procp should be curproc

ok kettenis@@
@
text
@/*	$OpenBSD: process_machdep.c,v 1.12 2014/01/26 17:40:09 miod Exp $	*/
/*	$NetBSD: process_machdep.c,v 1.7 1996/07/11 20:14:21 cgd Exp $	*/

/*-
 * Copyright (c) 1998 Doug Rabson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * Copyright (c) 1994 Christopher G. Demetriou
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This file may seem a bit stylized, but that so that it's easier to port.
 * Functions to be implemented here are:
 *
 * process_read_regs(proc, regs)
 *	Get the current user-visible register set from the process
 *	and copy it into the regs structure (<machine/reg.h>).
 *	The process is stopped at the time read_regs is called.
 *
 * process_write_regs(proc, regs)
 *	Update the current register set from the passed in regs
 *	structure.  Take care to avoid clobbering special CPU
 *	registers or privileged bits in the PSL.
 *	The process is stopped at the time write_regs is called.
 *
 * process_sstep(proc)
 *	Arrange for the process to trap after executing a single instruction.
 *
 * process_set_pc(proc)
 *	Set the process's program counter.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/vnode.h>
#include <sys/ptrace.h>
#include <machine/reg.h>
#include <machine/frame.h>

#include <alpha/alpha/db_instruction.h>

#define	process_frame(p)	((p)->p_md.md_tf)
#define	process_pcb(p)		(&(p)->p_addr->u_pcb)
#define	process_fpframe(p)	(&(process_pcb(p)->pcb_fp))

int
process_read_regs(p, regs)
	struct proc *p;
	struct reg *regs;
{

	frametoreg(process_frame(p), regs);
	regs->r_regs[R_ZERO] = process_frame(p)->tf_regs[FRAME_PC];
	regs->r_regs[R_SP] = process_pcb(p)->pcb_hw.apcb_usp;
	return (0);
}

int
process_read_fpregs(p, regs)
	struct proc *p;
	struct fpreg *regs;
{

	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 1);

	bcopy(process_fpframe(p), regs, sizeof(struct fpreg));
	return (0);
}

#ifdef PTRACE

int
process_write_regs(p, regs)
	struct proc *p;
	struct reg *regs;
{

	regtoframe(regs, process_frame(p));
	process_frame(p)->tf_regs[FRAME_PC] = regs->r_regs[R_ZERO];
	process_pcb(p)->pcb_hw.apcb_usp = regs->r_regs[R_SP];
	return (0);
}

int
process_set_pc(p, addr)
	struct proc *p;
	caddr_t addr;
{
	struct trapframe *frame = process_frame(p);

	frame->tf_regs[FRAME_PC] = (u_int64_t)addr;
	return (0);
}

int
process_write_fpregs(p, regs)
	struct proc *p;
	struct fpreg *regs;
{

	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 0);

	bcopy(regs, process_fpframe(p), sizeof(struct fpreg));
	return (0);
}

/*
 * Single stepping infrastructure.
 */
int ptrace_set_bpt(struct proc *p, struct mdbpt *bpt);
int ptrace_clear_bpt(struct proc *p, struct mdbpt *bpt);
int ptrace_read_int(struct proc *, vaddr_t, u_int32_t *);
int ptrace_write_int(struct proc *, vaddr_t, u_int32_t);
u_int64_t ptrace_read_register(struct proc *p, int regno);

int
ptrace_read_int(struct proc *p, vaddr_t addr, u_int32_t *v)
{
	struct iovec iov;
	struct uio uio;

	iov.iov_base = (caddr_t) v;
	iov.iov_len = sizeof(u_int32_t);
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = (off_t)addr;
	uio.uio_resid = sizeof(u_int32_t);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = curproc;
	return process_domem(curproc, p->p_p, &uio, PT_READ_I);
}

int
ptrace_write_int(struct proc *p, vaddr_t addr, u_int32_t v)
{
	struct iovec iov;
	struct uio uio;

	iov.iov_base = (caddr_t) &v;
	iov.iov_len = sizeof(u_int32_t);
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = (off_t)addr;
	uio.uio_resid = sizeof(u_int32_t);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_WRITE;
	uio.uio_procp = curproc;
	return process_domem(curproc, p->p_p, &uio, PT_WRITE_I);
}

u_int64_t
ptrace_read_register(struct proc *p, int regno)
{
	static int reg_to_frame[32] = {
		FRAME_V0,
		FRAME_T0,
		FRAME_T1,
		FRAME_T2,
		FRAME_T3,
		FRAME_T4,
		FRAME_T5,
		FRAME_T6,
		FRAME_T7,

		FRAME_S0,
		FRAME_S1,
		FRAME_S2,
		FRAME_S3,
		FRAME_S4,
		FRAME_S5,
		FRAME_S6,

		FRAME_A0,
		FRAME_A1,
		FRAME_A2,
		FRAME_A3,
		FRAME_A4,
		FRAME_A5,

		FRAME_T8,
		FRAME_T9,
		FRAME_T10,
		FRAME_T11,
		FRAME_RA,
		FRAME_T12,
		FRAME_AT,
		FRAME_GP,
		FRAME_SP,
		-1,		/* zero */
	};

	if (regno == R_ZERO)
		return 0;

	return p->p_md.md_tf->tf_regs[reg_to_frame[regno]];
}

int
ptrace_clear_bpt(struct proc *p, struct mdbpt *bpt)
{
	return ptrace_write_int(p, bpt->addr, bpt->contents);
}

int
ptrace_set_bpt(struct proc *p, struct mdbpt *bpt)
{
	int error;
	u_int32_t bpins = 0x00000080;
	error = ptrace_read_int(p, bpt->addr, &bpt->contents);
	if (error)
		return error;
	return ptrace_write_int(p, bpt->addr, bpins);
}

int
process_sstep(struct proc *p, int sstep)
{
	int error;
	vaddr_t pc = p->p_md.md_tf->tf_regs[FRAME_PC];
	alpha_instruction ins;
	vaddr_t addr[2];
	int count = 0;

	if (sstep == 0) {
		/* clearing the breakpoint */
		if (p->p_md.md_flags & MDP_STEP2) {
			ptrace_clear_bpt(p, &p->p_md.md_sstep[1]);
			ptrace_clear_bpt(p, &p->p_md.md_sstep[0]);
			p->p_md.md_flags &= ~MDP_STEP2;
		} else if (p->p_md.md_flags & MDP_STEP1) {
			ptrace_clear_bpt(p, &p->p_md.md_sstep[0]);
			p->p_md.md_flags &= ~MDP_STEP1;
		}
		return (0);
	}
#ifdef DIAGNOSTIC
	if (p->p_md.md_flags & (MDP_STEP1|MDP_STEP2))
		panic("process_sstep: step breakpoints not removed");
#endif
	error = ptrace_read_int(p, pc, &ins.bits);
	if (error)
		return (error);

	switch (ins.branch_format.opcode) {
	case op_j:
		/* Jump: target is register value */
		addr[0] = ptrace_read_register(p, ins.jump_format.rb) & ~3;
		count = 1;
		break;

	case op_br:
	case op_fbeq:
	case op_fblt:
	case op_fble:
	case op_bsr:
	case op_fbne:
	case op_fbge:
	case op_fbgt:
	case op_blbc:
	case op_beq:
	case op_blt:
	case op_ble:
	case op_blbs:
	case op_bne:
	case op_bge:
	case op_bgt:
		/* Branch: target is pc+4+4*displacement */
		addr[0] = pc + 4;
		addr[1] = pc + 4 + 4 * ins.branch_format.displacement;
		count = 2;
		break;

	default:
		addr[0] = pc + 4;
		count = 1;
	}

	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 0);
	p->p_md.md_sstep[0].addr = addr[0];
	error = ptrace_set_bpt(p, &p->p_md.md_sstep[0]);
	if (error)
		return (error);
	if (count == 2) {
		p->p_md.md_sstep[1].addr = addr[1];
		error = ptrace_set_bpt(p, &p->p_md.md_sstep[1]);
		if (error) {
			ptrace_clear_bpt(p, &p->p_md.md_sstep[0]);
			return (error);
		}
		p->p_md.md_flags |= MDP_STEP2;
	} else
		p->p_md.md_flags |= MDP_STEP1;

	return (0);
}

#endif	/* PTRACE */
@


1.12
log
@Work in progress work towards SMP, heavily based upon NetBSD. The MP kernel
will boot multiuser, but will deadlock under load, and I can't find my
mistake yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.11 2005/12/12 19:44:30 miod Exp $	*/
d183 2
a184 2
	uio.uio_procp = p;
	return process_domem(curproc, p, &uio, PT_READ_I);
d201 2
a202 2
	uio.uio_procp = p;
	return process_domem(curproc, p, &uio, PT_WRITE_I);
@


1.11
log
@One procfs.h leftover there, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.10 2005/12/11 21:30:27 miod Exp $	*/
d115 2
a116 5
	if (p == fpcurproc) {
		alpha_pal_wrfen(1);
		savefpstate(process_fpframe(p));
		alpha_pal_wrfen(0);
	}
d154 1
a154 1
		fpusave_proc(p, 1);
@


1.10
log
@Replace procfs_domem() with a similar interface, process_domem(), which lives
out of procfs and gets a ptrace request PT_{READ,WRITE}_{I,D} as argument;
also procfs_checkioperm() becomes process_checkioperm().

From art@@ some time ago; ok kettenis@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.9 2002/04/28 20:55:14 pvalchev Exp $	*/
a91 1
#include <miscfs/procfs/procfs.h>
@


1.9
log
@IEEE 754 floating point completion code, and implementation of the
FP_C (Floating Point Control Quadword).

From ross@@NetBSD.  Added a way to disable it with option NO_IEEE,
which appears on the ramdisks to save space.  This affects only
programs compiled with -mieee, and what it essentially does is
enabling infinities and NaNs, instead of generating SIGFPE on
division by zero, overflow, etc.
ok art, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.8 2002/03/14 06:04:11 mickey Exp $	*/
d188 1
a188 1
	return procfs_domem(curproc, p, NULL, &uio);
d206 1
a206 1
	return procfs_domem(curproc, p, NULL, &uio);
@


1.8
log
@this mod has nothing to do w/ ptrace option addition, did not even compile
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.7 2002/03/14 00:42:20 miod Exp $	*/
d157 2
a158 2
	if (p == fpcurproc)
		fpcurproc = NULL;
d336 2
@


1.7
log
@Turn the ptrace(2) syscall into a kernel compile option, option PTRACE in
your kernel configuration file.
By default, GENERIC will enable this.

When PTRACE is not enabled, several ptrace-like features of the procfs
filesystem will be disabled as well (namely, the ability to read and write
any process' registers, as well as attching, single stepping and detaching
to/from processes).

This should help paranoid people build better sandboxens, and us to build
smaller ramdisks.
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.6 2002/03/12 11:58:14 art Exp $	*/
a136 12
	return (0);
}

int
process_sstep(p, sstep)
	struct proc *p;
	int sstep;
{

	if (sstep)
		return (EINVAL);

@


1.6
log
@Emulate ptrace(PT_STEP in software.
More or less directly from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.5 2000/11/08 16:01:03 art Exp $	*/
d111 18
d141 1
a141 1
process_set_pc(p, addr)
d143 1
a143 1
	caddr_t addr;
a144 1
	struct trapframe *frame = process_frame(p);
d146 3
a148 1
	frame->tf_regs[FRAME_PC] = (u_int64_t)addr;
d153 1
a153 1
process_read_fpregs(p, regs)
d155 1
a155 1
	struct fpreg *regs;
d157 1
d159 1
a159 7
	if (p == fpcurproc) {
		alpha_pal_wrfen(1);
		savefpstate(process_fpframe(p));
		alpha_pal_wrfen(0);
	}

	bcopy(process_fpframe(p), regs, sizeof(struct fpreg));
d365 2
@


1.5
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.4 1996/10/30 22:38:23 niklas Exp $	*/
d4 25
d91 3
a122 12
process_sstep(p, sstep)
	struct proc *p;
	int sstep;
{

	if (sstep)
		return (EINVAL);

	return (0);
}

int
d159 190
@


1.5.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.5 2000/11/08 16:01:03 art Exp $	*/
a3 25
/*-
 * Copyright (c) 1998 Doug Rabson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
a65 3
#include <alpha/alpha/db_instruction.h>
#include <miscfs/procfs/procfs.h>

d83 1
a83 1
process_read_fpregs(p, regs)
d85 1
a85 1
	struct fpreg *regs;
d88 3
a90 7
	if (p == fpcurproc) {
		alpha_pal_wrfen(1);
		savefpstate(process_fpframe(p));
		alpha_pal_wrfen(0);
	}

	bcopy(process_fpframe(p), regs, sizeof(struct fpreg));
a93 2
#ifdef PTRACE

d95 1
a95 1
process_write_regs(p, regs)
d97 1
a97 1
	struct reg *regs;
d100 3
a102 3
	regtoframe(regs, process_frame(p));
	process_frame(p)->tf_regs[FRAME_PC] = regs->r_regs[R_ZERO];
	process_pcb(p)->pcb_hw.apcb_usp = regs->r_regs[R_SP];
d118 1
a118 1
process_write_fpregs(p, regs)
d123 5
a127 2
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 1);
d129 1
a129 1
	bcopy(regs, process_fpframe(p), sizeof(struct fpreg));
a132 9
/*
 * Single stepping infrastructure.
 */
int ptrace_set_bpt(struct proc *p, struct mdbpt *bpt);
int ptrace_clear_bpt(struct proc *p, struct mdbpt *bpt);
int ptrace_read_int(struct proc *, vaddr_t, u_int32_t *);
int ptrace_write_int(struct proc *, vaddr_t, u_int32_t);
u_int64_t ptrace_read_register(struct proc *p, int regno);

d134 3
a136 1
ptrace_read_int(struct proc *p, vaddr_t addr, u_int32_t *v)
a137 2
	struct iovec iov;
	struct uio uio;
d139 2
a140 173
	iov.iov_base = (caddr_t) v;
	iov.iov_len = sizeof(u_int32_t);
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = (off_t)addr;
	uio.uio_resid = sizeof(u_int32_t);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = p;
	return procfs_domem(curproc, p, NULL, &uio);
}

int
ptrace_write_int(struct proc *p, vaddr_t addr, u_int32_t v)
{
	struct iovec iov;
	struct uio uio;

	iov.iov_base = (caddr_t) &v;
	iov.iov_len = sizeof(u_int32_t);
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = (off_t)addr;
	uio.uio_resid = sizeof(u_int32_t);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_WRITE;
	uio.uio_procp = p;
	return procfs_domem(curproc, p, NULL, &uio);
}

u_int64_t
ptrace_read_register(struct proc *p, int regno)
{
	static int reg_to_frame[32] = {
		FRAME_V0,
		FRAME_T0,
		FRAME_T1,
		FRAME_T2,
		FRAME_T3,
		FRAME_T4,
		FRAME_T5,
		FRAME_T6,
		FRAME_T7,

		FRAME_S0,
		FRAME_S1,
		FRAME_S2,
		FRAME_S3,
		FRAME_S4,
		FRAME_S5,
		FRAME_S6,

		FRAME_A0,
		FRAME_A1,
		FRAME_A2,
		FRAME_A3,
		FRAME_A4,
		FRAME_A5,

		FRAME_T8,
		FRAME_T9,
		FRAME_T10,
		FRAME_T11,
		FRAME_RA,
		FRAME_T12,
		FRAME_AT,
		FRAME_GP,
		FRAME_SP,
		-1,		/* zero */
	};

	if (regno == R_ZERO)
		return 0;

	return p->p_md.md_tf->tf_regs[reg_to_frame[regno]];
}

int
ptrace_clear_bpt(struct proc *p, struct mdbpt *bpt)
{
	return ptrace_write_int(p, bpt->addr, bpt->contents);
}

int
ptrace_set_bpt(struct proc *p, struct mdbpt *bpt)
{
	int error;
	u_int32_t bpins = 0x00000080;
	error = ptrace_read_int(p, bpt->addr, &bpt->contents);
	if (error)
		return error;
	return ptrace_write_int(p, bpt->addr, bpins);
}

int
process_sstep(struct proc *p, int sstep)
{
	int error;
	vaddr_t pc = p->p_md.md_tf->tf_regs[FRAME_PC];
	alpha_instruction ins;
	vaddr_t addr[2];
	int count = 0;

	if (sstep == 0) {
		/* clearing the breakpoint */
		if (p->p_md.md_flags & MDP_STEP2) {
			ptrace_clear_bpt(p, &p->p_md.md_sstep[1]);
			ptrace_clear_bpt(p, &p->p_md.md_sstep[0]);
			p->p_md.md_flags &= ~MDP_STEP2;
		} else if (p->p_md.md_flags & MDP_STEP1) {
			ptrace_clear_bpt(p, &p->p_md.md_sstep[0]);
			p->p_md.md_flags &= ~MDP_STEP1;
		}
		return (0);
	}
#ifdef DIAGNOSTIC
	if (p->p_md.md_flags & (MDP_STEP1|MDP_STEP2))
		panic("process_sstep: step breakpoints not removed");
#endif
	error = ptrace_read_int(p, pc, &ins.bits);
	if (error)
		return (error);

	switch (ins.branch_format.opcode) {
	case op_j:
		/* Jump: target is register value */
		addr[0] = ptrace_read_register(p, ins.jump_format.rb) & ~3;
		count = 1;
		break;

	case op_br:
	case op_fbeq:
	case op_fblt:
	case op_fble:
	case op_bsr:
	case op_fbne:
	case op_fbge:
	case op_fbgt:
	case op_blbc:
	case op_beq:
	case op_blt:
	case op_ble:
	case op_blbs:
	case op_bne:
	case op_bge:
	case op_bgt:
		/* Branch: target is pc+4+4*displacement */
		addr[0] = pc + 4;
		addr[1] = pc + 4 + 4 * ins.branch_format.displacement;
		count = 2;
		break;

	default:
		addr[0] = pc + 4;
		count = 1;
	}

	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 0);
	p->p_md.md_sstep[0].addr = addr[0];
	error = ptrace_set_bpt(p, &p->p_md.md_sstep[0]);
	if (error)
		return (error);
	if (count == 2) {
		p->p_md.md_sstep[1].addr = addr[1];
		error = ptrace_set_bpt(p, &p->p_md.md_sstep[1]);
		if (error) {
			ptrace_clear_bpt(p, &p->p_md.md_sstep[0]);
			return (error);
		}
		p->p_md.md_flags |= MDP_STEP2;
	} else
		p->p_md.md_flags |= MDP_STEP1;
d142 1
a144 2

#endif	/* PTRACE */
@


1.4
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.7 1996/07/11 20:14:21 cgd Exp $	*/
a121 1
	extern struct proc *fpcurproc;
a137 1
	extern struct proc *fpcurproc;
@


1.4.14.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.5 2000/11/08 16:01:03 art Exp $	*/
d122 1
d139 1
@


1.4.14.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a3 25
/*-
 * Copyright (c) 1998 Doug Rabson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
a65 3
#include <alpha/alpha/db_instruction.h>
#include <miscfs/procfs/procfs.h>

d83 1
a83 1
process_read_fpregs(p, regs)
d85 1
a85 1
	struct fpreg *regs;
d88 3
a90 7
	if (p == fpcurproc) {
		alpha_pal_wrfen(1);
		savefpstate(process_fpframe(p));
		alpha_pal_wrfen(0);
	}

	bcopy(process_fpframe(p), regs, sizeof(struct fpreg));
a93 2
#ifdef PTRACE

d95 1
a95 1
process_write_regs(p, regs)
d97 1
a97 1
	struct reg *regs;
d100 3
a102 3
	regtoframe(regs, process_frame(p));
	process_frame(p)->tf_regs[FRAME_PC] = regs->r_regs[R_ZERO];
	process_pcb(p)->pcb_hw.apcb_usp = regs->r_regs[R_SP];
d118 1
a118 1
process_write_fpregs(p, regs)
d123 5
a127 2
	if (p == fpcurproc)
		fpcurproc = NULL;
d129 1
a129 1
	bcopy(regs, process_fpframe(p), sizeof(struct fpreg));
a132 9
/*
 * Single stepping infrastructure.
 */
int ptrace_set_bpt(struct proc *p, struct mdbpt *bpt);
int ptrace_clear_bpt(struct proc *p, struct mdbpt *bpt);
int ptrace_read_int(struct proc *, vaddr_t, u_int32_t *);
int ptrace_write_int(struct proc *, vaddr_t, u_int32_t);
u_int64_t ptrace_read_register(struct proc *p, int regno);

d134 3
a136 1
ptrace_read_int(struct proc *p, vaddr_t addr, u_int32_t *v)
a137 2
	struct iovec iov;
	struct uio uio;
d139 2
a140 171
	iov.iov_base = (caddr_t) v;
	iov.iov_len = sizeof(u_int32_t);
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = (off_t)addr;
	uio.uio_resid = sizeof(u_int32_t);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = p;
	return procfs_domem(curproc, p, NULL, &uio);
}

int
ptrace_write_int(struct proc *p, vaddr_t addr, u_int32_t v)
{
	struct iovec iov;
	struct uio uio;

	iov.iov_base = (caddr_t) &v;
	iov.iov_len = sizeof(u_int32_t);
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = (off_t)addr;
	uio.uio_resid = sizeof(u_int32_t);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_WRITE;
	uio.uio_procp = p;
	return procfs_domem(curproc, p, NULL, &uio);
}

u_int64_t
ptrace_read_register(struct proc *p, int regno)
{
	static int reg_to_frame[32] = {
		FRAME_V0,
		FRAME_T0,
		FRAME_T1,
		FRAME_T2,
		FRAME_T3,
		FRAME_T4,
		FRAME_T5,
		FRAME_T6,
		FRAME_T7,

		FRAME_S0,
		FRAME_S1,
		FRAME_S2,
		FRAME_S3,
		FRAME_S4,
		FRAME_S5,
		FRAME_S6,

		FRAME_A0,
		FRAME_A1,
		FRAME_A2,
		FRAME_A3,
		FRAME_A4,
		FRAME_A5,

		FRAME_T8,
		FRAME_T9,
		FRAME_T10,
		FRAME_T11,
		FRAME_RA,
		FRAME_T12,
		FRAME_AT,
		FRAME_GP,
		FRAME_SP,
		-1,		/* zero */
	};

	if (regno == R_ZERO)
		return 0;

	return p->p_md.md_tf->tf_regs[reg_to_frame[regno]];
}

int
ptrace_clear_bpt(struct proc *p, struct mdbpt *bpt)
{
	return ptrace_write_int(p, bpt->addr, bpt->contents);
}

int
ptrace_set_bpt(struct proc *p, struct mdbpt *bpt)
{
	int error;
	u_int32_t bpins = 0x00000080;
	error = ptrace_read_int(p, bpt->addr, &bpt->contents);
	if (error)
		return error;
	return ptrace_write_int(p, bpt->addr, bpins);
}

int
process_sstep(struct proc *p, int sstep)
{
	int error;
	vaddr_t pc = p->p_md.md_tf->tf_regs[FRAME_PC];
	alpha_instruction ins;
	vaddr_t addr[2];
	int count = 0;

	if (sstep == 0) {
		/* clearing the breakpoint */
		if (p->p_md.md_flags & MDP_STEP2) {
			ptrace_clear_bpt(p, &p->p_md.md_sstep[1]);
			ptrace_clear_bpt(p, &p->p_md.md_sstep[0]);
			p->p_md.md_flags &= ~MDP_STEP2;
		} else if (p->p_md.md_flags & MDP_STEP1) {
			ptrace_clear_bpt(p, &p->p_md.md_sstep[0]);
			p->p_md.md_flags &= ~MDP_STEP1;
		}
		return (0);
	}
#ifdef DIAGNOSTIC
	if (p->p_md.md_flags & (MDP_STEP1|MDP_STEP2))
		panic("process_sstep: step breakpoints not removed");
#endif
	error = ptrace_read_int(p, pc, &ins.bits);
	if (error)
		return (error);

	switch (ins.branch_format.opcode) {
	case op_j:
		/* Jump: target is register value */
		addr[0] = ptrace_read_register(p, ins.jump_format.rb) & ~3;
		count = 1;
		break;

	case op_br:
	case op_fbeq:
	case op_fblt:
	case op_fble:
	case op_bsr:
	case op_fbne:
	case op_fbge:
	case op_fbgt:
	case op_blbc:
	case op_beq:
	case op_blt:
	case op_ble:
	case op_blbs:
	case op_bne:
	case op_bge:
	case op_bgt:
		/* Branch: target is pc+4+4*displacement */
		addr[0] = pc + 4;
		addr[1] = pc + 4 + 4 * ins.branch_format.displacement;
		count = 2;
		break;

	default:
		addr[0] = pc + 4;
		count = 1;
	}

	p->p_md.md_sstep[0].addr = addr[0];
	error = ptrace_set_bpt(p, &p->p_md.md_sstep[0]);
	if (error)
		return (error);
	if (count == 2) {
		p->p_md.md_sstep[1].addr = addr[1];
		error = ptrace_set_bpt(p, &p->p_md.md_sstep[1]);
		if (error) {
			ptrace_clear_bpt(p, &p->p_md.md_sstep[0]);
			return (error);
		}
		p->p_md.md_flags |= MDP_STEP2;
	} else
		p->p_md.md_flags |= MDP_STEP1;
d142 1
a144 2

#endif	/* PTRACE */
@


1.4.14.3
log
@Sync the SMP branch with 3.3
@
text
@d157 2
a158 2
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 1);
a335 2
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 0);
@


1.3
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: process_machdep.c,v 1.3 1995/11/23 02:34:29 cgd Exp $	*/
/*	$NetBSD: process_machdep.c,v 1.3 1995/11/23 02:34:29 cgd Exp $	*/
d67 2
a68 1
#define	process_fpframe(p)	(&(p)->p_addr->u_pcb.pcb_fp)
d77 2
a78 1
	regs->r_regs[R_ZERO] = process_frame(p)->tf_pc;
a87 1
	process_frame(p)->tf_pc = regs->r_regs[R_ZERO];
d89 2
d113 1
a113 1
	frame->tf_pc = (u_int64_t)addr;
d125 1
a125 1
		pal_wrfen(1);
d127 1
a127 1
		pal_wrfen(0);
@


1.2
log
@update to netbsd
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: process_machdep.c,v 1.2 1995/03/24 15:07:17 cgd Exp $	*/
a61 1
#include <machine/psl.h>
d65 3
a72 8
	struct trapframe *frame;

	if ((p->p_flag & P_INMEM) == 0)
		return (EIO);

	frame = p->p_md.md_tf;

	frametoreg(frame, regs);
d74 2
a83 8
	struct trapframe *frame;

	if ((p->p_flag & P_INMEM) == 0)
		return (EIO);

	frame = p->p_md.md_tf;

	regtoframe(regs, frame);
d85 2
d107 1
a107 6
	struct trapframe *frame;

	if ((p->p_flag & P_INMEM) == 0)
		return (EIO);

	frame = p->p_md.md_tf;
a109 1

a119 3
	if ((p->p_flag & P_INMEM) == 0)
		return (EIO);

d122 1
a122 1
		savefpstate(&p->p_addr->u_pcb.pcb_fp);
d126 1
a126 2
	bcopy(&p->p_addr->u_pcb.pcb_fp, regs, sizeof(struct fpreg));

a136 3
	if ((p->p_flag & P_INMEM) == 0)
		return (EIO);

d140 1
a140 2
	bcopy(regs, &p->p_addr->u_pcb.pcb_fp, sizeof(struct fpreg));

@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
