head	1.19;
access;
symbols
	OPENBSD_6_0:1.19.0.10
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.6
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.8
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.18.0.16
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.12
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.10
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.8
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.6
	OPENBSD_5_0:1.18.0.4
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.8
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.4
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.2
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.14.0.6
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.4
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.11.0.12
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.10
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.8
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.6
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.11
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.3.0.10
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.8
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.6
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.0.4
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.19
date	2014.05.08.20.46.49;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2010.11.23.04.07.55;	author shadchin;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.26.20.17.26;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2008.08.02.13.48.09;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2008.07.16.20.03.20;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2006.07.16.21.52.05;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.09.21.55.12;	author martin;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.25.21.33.19;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.26;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.14.00.44.59;	author nate;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.12.13.19.13.22;	author nate;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.16.04.33.46;	author ericj;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.08.21.48.44;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.08.19.16.58;	author ericj;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.08.16.00.59;	author art;	state Exp;
branches;
next	1.3;

1.3
date	99.01.11.05.10.59;	author millert;	state Exp;
branches
	1.3.6.1;
next	1.2;

1.2
date	97.11.10.15.46.23;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.01.24.19.56.29;	author niklas;	state Exp;
branches;
next	;

1.3.6.1
date	2001.04.18.16.00.19;	author niklas;	state Exp;
branches;
next	1.3.6.2;

1.3.6.2
date	2002.03.06.00.24.08;	author niklas;	state Exp;
branches;
next	1.3.6.3;

1.3.6.3
date	2002.03.28.10.06.12;	author niklas;	state Exp;
branches;
next	1.3.6.4;

1.3.6.4
date	2003.03.27.23.18.05;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.06.11.03.33.39;	author art;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.10.29.00.28.00;	author art;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Format string fixes for alpha kernels, and remove -Wno-format
@
text
@/* $OpenBSD: dec_eb164.c,v 1.18 2010/11/23 04:07:55 shadchin Exp $ */
/* $NetBSD: dec_eb164.c,v 1.33 2000/05/22 20:13:32 thorpej Exp $ */

/*
 * Copyright (c) 1995, 1996, 1997 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */
/*
 * Additional Copyright (c) 1997 by Matthew Jacob for NASA/Ames Research Center
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/termios.h>
#include <dev/cons.h>
#include <sys/conf.h>

#include <machine/rpb.h>
#include <machine/autoconf.h>
#include <machine/cpuconf.h>
#include <machine/bus.h>

#include <dev/ic/comreg.h>
#include <dev/ic/comvar.h>

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>
#include <dev/ic/i8042reg.h>
#include <dev/ic/pckbcvar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>

#include <alpha/pci/ciareg.h>
#include <alpha/pci/ciavar.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <dev/ata/atavar.h>

#include "pckbd.h"

#ifndef CONSPEED
#define CONSPEED TTYDEF_SPEED
#endif
static int comcnrate = CONSPEED;

#define	DR_VERBOSE(f) while (0)

void dec_eb164_init(void);
static void dec_eb164_cons_init(void);
static void dec_eb164_device_register(struct device *, void *);

void
dec_eb164_init()
{

	platform.family = "EB164";

	if ((platform.model = alpha_dsr_sysname()) == NULL) {
		/* XXX Don't know the system variations, yet. */
		platform.model = alpha_unknown_sysname();
	}

	platform.iobus = "cia";
	platform.cons_init = dec_eb164_cons_init;
	platform.device_register = dec_eb164_device_register;
}

static void
dec_eb164_cons_init()
{
	struct ctb *ctb;
	struct cia_config *ccp;
	extern struct cia_config cia_configuration;

	ccp = &cia_configuration;
	cia_init(ccp, 0);

	ctb = (struct ctb *)(((caddr_t)hwrpb) + hwrpb->rpb_ctb_off);

	switch (ctb->ctb_term_type) {
	case CTB_PRINTERPORT: 
		/* serial console ... */
		/* XXX */
		{
			/*
			 * Delay to allow PROM putchars to complete.
			 * FIFO depth * character time,
			 * character time = (1000000 / (defaultrate / 10))
			 */
			DELAY(160000000 / comcnrate);

			if(comcnattach(&ccp->cc_iot, 0x3f8, comcnrate,
			    COM_FREQ,
			    (TTYDEF_CFLAG & ~(CSIZE | PARENB)) | CS8))
				panic("can't init serial console");

			break;
		}

	case CTB_GRAPHICS:
#if NPCKBD > 0
		/* display console ... */
		/* XXX */
		(void) pckbc_cnattach(&ccp->cc_iot, IO_KBD, KBCMDP, 0);

		/*
		 * On at least LX164, SRM reports an isa video board
		 * as a pci slot with 0xff as the bus and slot numbers.
		 * Since these values are not plausible from a pci point
		 * of view, it is safe to check for them.
		 */
		if (CTB_TURBOSLOT_TYPE(ctb->ctb_turboslot) ==
		    CTB_TURBOSLOT_TYPE_ISA ||
		    (CTB_TURBOSLOT_BUS(ctb->ctb_turboslot) == 0xff &&
		     CTB_TURBOSLOT_SLOT(ctb->ctb_turboslot) == 0xff))
			isa_display_console(&ccp->cc_iot, &ccp->cc_memt);
		else
			pci_display_console(&ccp->cc_iot, &ccp->cc_memt,
			    &ccp->cc_pc, CTB_TURBOSLOT_BUS(ctb->ctb_turboslot),
			    CTB_TURBOSLOT_SLOT(ctb->ctb_turboslot), 0);
#else
		panic("not configured to use display && keyboard console");
#endif
		break;

	default:
		printf("ctb->ctb_term_type = 0x%lx\n",
		    (unsigned long)ctb->ctb_term_type);
		printf("ctb->ctb_turboslot = 0x%lx\n",
		    (unsigned long)ctb->ctb_turboslot);

		panic("consinit: unknown console type %lu",
		    (unsigned long)ctb->ctb_term_type);
	}
}

static void
dec_eb164_device_register(dev, aux)
	struct device *dev;
	void *aux;
{
	static int found, initted, diskboot, netboot;
	static struct device *pcidev, *ctrlrdev;
	struct bootdev_data *b = bootdev_data;
	struct device *parent = dev->dv_parent;
	struct cfdata *cf = dev->dv_cfdata;
	struct cfdriver *cd = cf->cf_driver;

	if (found)
		return;

	if (!initted) {
		diskboot = (strncasecmp(b->protocol, "SCSI", 4) == 0) ||
		    (strncasecmp(b->protocol, "IDE", 3) == 0);
		netboot = (strncasecmp(b->protocol, "BOOTP", 5) == 0) ||
		    (strncasecmp(b->protocol, "MOP", 3) == 0);
		DR_VERBOSE(printf("diskboot = %d, netboot = %d\n", diskboot,
		    netboot));
		initted = 1;
	}

	if (pcidev == NULL) {
		if (strcmp(cd->cd_name, "pci"))
			return;
		else {
			struct pcibus_attach_args *pba = aux;

			if ((b->slot / 1000) != pba->pba_bus)
				return;
	
			pcidev = dev;
			DR_VERBOSE(printf("\npcidev = %s\n", dev->dv_xname));
			return;
		}
	}

	if (ctrlrdev == NULL) {
		if (parent != pcidev)
			return;
		else {
			struct pci_attach_args *pa = aux;
			int slot;

			slot = pa->pa_bus * 1000 + pa->pa_function * 100 +
			    pa->pa_device;
			if (b->slot != slot)
				return;
	
			if (netboot) {
				booted_device = dev;
				DR_VERBOSE(printf("\nbooted_device = %s\n",
				    dev->dv_xname));
				found = 1;
			} else {
				ctrlrdev = dev;
				DR_VERBOSE(printf("\nctrlrdev = %s\n",
				    dev->dv_xname));
			}
			return;
		}
	}

	if (!diskboot)
		return;

	if (!strcmp(cd->cd_name, "sd") || !strcmp(cd->cd_name, "st") ||
	    !strcmp(cd->cd_name, "cd")) {
		struct scsi_attach_args *sa = aux;
		struct scsi_link *periph = sa->sa_sc_link;
		int unit;

		if (parent->dv_parent != ctrlrdev)
			return;

		unit = periph->target * 100 + periph->lun;
		if (b->unit != unit)
			return;

		/* we've found it! */
		booted_device = dev;
		DR_VERBOSE(printf("\nbooted_device = %s\n", dev->dv_xname));
		found = 1;
	}

	/*
	 * Support to boot from IDE drives.
	 */
	if (!strcmp(cd->cd_name, "wd")) {
		struct ata_atapi_attach *aa_link = aux;
		int variation = hwrpb->rpb_variation & SV_ST_MASK;

		if ((strcmp("pciide", parent->dv_cfdata->cf_driver->cd_name) != 0))
			return;
		if (parent != ctrlrdev)
			return;

		DR_VERBOSE(printf("\nAtapi info: drive: %d, channel %d\n",
		    aa_link->aa_drv_data->drive, aa_link->aa_channel));
		DR_VERBOSE(printf("Bootdev info: unit: %d, channel: %d\n",
		    b->unit, b->channel));
		if (b->unit != aa_link->aa_drv_data->drive)
			return;

		/*
		 * On 164SX, the built-in IDE controller appears as
		 * two distinct pciide devices, both with a single
		 * channel.  However SRM will nevertheless pretend
		 * the second channel is channel #1 of the second
		 * device, while it is really channel #0, so just
		 * ignore the channel number in this case.
		 */
		if (variation >= SV_ST_ALPHAPC164SX_400 &&
		   variation <= SV_ST_ALPHAPC164SX_600 &&
		    b->slot == 0 * 1000 + 2 * 100 + 8) {
			/* nothing */
		} else {
			if (b->channel != aa_link->aa_channel)
				return;
		}

		/* we've found it! */
		booted_device = dev;
		DR_VERBOSE(printf("booted_device = %s\n", dev->dv_xname));
		found = 1;
	}
}
@


1.18
log
@removed slot argument of function pckbc_cnattach
because it is always PCKBC_KBD_SLOT

ok krw@@, miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: dec_eb164.c,v 1.17 2009/10/26 20:17:26 deraadt Exp $ */
d151 4
a154 2
		printf("ctb->ctb_term_type = 0x%lx\n", ctb->ctb_term_type);
		printf("ctb->ctb_turboslot = 0x%lx\n", ctb->ctb_turboslot);
d156 2
a157 2
		panic("consinit: unknown console type %ld",
		    ctb->ctb_term_type);
@


1.17
log
@Do not do strncmp comparisons on dv_xname because longer device names which
look similar could arrive in the future.  Instead, compare directly against
dv_cfdata->cf_driver->cd_name
Issue originally spotted by miod
@
text
@d1 1
a1 1
/* $OpenBSD: dec_eb164.c,v 1.16 2008/08/02 13:48:09 miod Exp $ */
d128 1
a128 2
		(void) pckbc_cnattach(&ccp->cc_iot, IO_KBD, KBCMDP,
		    PCKBC_KBD_SLOT, 0);
@


1.16
log
@Ignore the ata channel on 164SX when controller is the built-in one, when
looking for the boot device; PR #5895
@
text
@d1 1
a1 1
/* $OpenBSD: dec_eb164.c,v 1.15 2008/07/16 20:03:20 miod Exp $ */
d255 1
a255 1
		if ((strncmp("pciide", parent->dv_xname, 6) != 0))
@


1.15
log
@Add a new parameter to pckbc_cnattach(): flags to put in the pckbc bowels.
For now, only one such flag is defined, PCKBC_CANT_TRANSLATE. It hints
pckbc that the device does not behave correctly to the ``set translation''
commands.

Set this flag if we are running on a Tadpole Ultrabook machine, which needs it.
This makes the built-in keyboard work correctly on this laptop (with the
help of the software translation pckbd diff).

tested & ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: dec_eb164.c,v 1.14 2006/11/28 16:56:50 dlg Exp $ */
d253 1
d264 1
a264 2
		if (b->unit != aa_link->aa_drv_data->drive ||
		    b->channel != aa_link->aa_channel)
d266 17
@


1.14
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dec_eb164.c,v 1.13 2006/07/16 21:52:05 miod Exp $ */
d129 1
a129 1
		    PCKBC_KBD_SLOT);
@


1.13
log
@On LX164 systems (and maybe others), isa video boards are reported by
the SRM as pci boards with invalid bus and slot number, so check for this
to decide which vga attachment to use.
Found the hard way by robert@@
@
text
@d1 1
a1 1
/* $OpenBSD: dec_eb164.c,v 1.12 2005/05/09 21:55:12 martin Exp $ */
d231 1
a231 1
		struct scsibus_attach_args *sa = aux;
@


1.12
log
@fixes and updates for root device detection from NetBSD:

- remove unneeded checks and variables
- use strncasecmp() to check b->protocol because the case is dependant on the
  firmware revision
- check logical unit numbers
- consistently check PCI function numbers
- on the 6600 models check which PCI hierarchy is looked at
- makes root device detection on DS20 (6600) work

testing by claudio, xsa and miod; ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: dec_eb164.c,v 1.11 2002/06/25 21:33:19 miod Exp $ */
d130 7
d138 3
a140 1
		    CTB_TURBOSLOT_TYPE_ISA)
@


1.11
log
@No \n at the end of a panic() message... I thought all occurences had been
squashed already.
@
text
@d1 1
a1 1
/* $OpenBSD: dec_eb164.c,v 1.10 2002/03/14 01:26:26 millert Exp $ */
d156 2
a157 2
	static int found, initted, scsiboot, ideboot, netboot;
	static struct device *pcidev, *scsidev;
d167 6
a172 11
		scsiboot = (strcmp(b->protocol, "SCSI") == 0);
		netboot = (strcmp(b->protocol, "BOOTP") == 0) ||
		    (strcmp(b->protocol, "MOP") == 0);
		/*
		 * Add an extra check to boot from ide drives:
		 * Newer SRM firmware use the protocol identifier IDE,
		 * older SRM firmware use the protocol identifier SCSI.
		 */
		ideboot = (strcmp(b->protocol, "IDE") == 0);
		DR_VERBOSE(printf("scsiboot = %d, ideboot = %d, netboot = %d\n",
		    scsiboot, ideboot, netboot));
d186 1
a186 2
			DR_VERBOSE(printf("\npcidev = %s\n",
			    pcidev->dv_xname));
d191 1
a191 1
	if ((ideboot || scsiboot) && (scsidev == NULL)) {
d196 1
d198 3
a200 3
			if (b->slot % 1000 / 100 != pa->pa_function)
				return;
			if (b->slot % 100 != pa->pa_device)
d203 10
a212 3
			scsidev = dev;
			DR_VERBOSE(printf("\nscsidev = %s\n",
			    scsidev->dv_xname));
d217 5
a221 4
	if (scsiboot &&
	    (!strcmp(cd->cd_name, "sd") ||
	     !strcmp(cd->cd_name, "st") ||
	     !strcmp(cd->cd_name, "cd"))) {
d223 2
d226 1
a226 1
		if (parent->dv_parent != scsidev)
d229 2
a230 16
		if (b->unit / 100 != sa->sa_sc_link->target)
			return;

		/* XXX LUN! */

		switch (b->boot_dev_type) {
		case 0:
			if (strcmp(cd->cd_name, "sd") &&
			    strcmp(cd->cd_name, "cd"))
				return;
			break;
		case 1:
			if (strcmp(cd->cd_name, "st"))
				return;
			break;
		default:
a231 1
		}
d235 1
a235 2
		DR_VERBOSE(printf("\nbooted_device = %s\n",
		    booted_device->dv_xname));
d242 1
a242 1
	if ((ideboot || scsiboot) && !strcmp(cd->cd_name, "wd")) {
d244 4
a247 1
		if ((strncmp("pciide", parent->dv_xname, 6) != 0)) {
d249 1
a249 4
		} else {
			if (parent != scsidev)
				return;
		}
d260 1
a260 2
		DR_VERBOSE(printf("booted_device = %s\n",
		    booted_device->dv_xname));
a261 19
	}

	if (netboot) {
		if (parent != pcidev)
			return;
		else {
			struct pci_attach_args *pa = aux;

			if ((b->slot % 1000) != pa->pa_device)
				return;

			/* XXX function? */
	
			booted_device = dev;
			DR_VERBOSE(printf("\nbooted_device = %s\n",
			    booted_device->dv_xname));
			found = 1;
			return;
		}
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: dec_eb164.c,v 1.9 2001/12/14 00:44:59 nate Exp $ */
d146 1
a146 1
		panic("consinit: unknown console type %ld\n",
@


1.9
log
@Don't use a single static struct alpha_bus_space since there are machines
that can have more than one system bus attached to mainbus
@
text
@d1 1
a1 1
/* $OpenBSD: dec_eb164.c,v 1.8 2001/12/13 19:13:22 nate Exp $ */
d72 3
a74 3
void dec_eb164_init __P((void));
static void dec_eb164_cons_init __P((void));
static void dec_eb164_device_register __P((struct device *, void *));
@


1.9.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: dec_eb164.c,v 1.9 2001/12/14 00:44:59 nate Exp $ */
d72 3
a74 3
void dec_eb164_init(void);
static void dec_eb164_cons_init(void);
static void dec_eb164_device_register(struct device *, void *);
@


1.9.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: dec_eb164.c,v 1.9.2.1 2002/06/11 03:33:39 art Exp $ */
d146 1
a146 1
		panic("consinit: unknown console type %ld",
@


1.8
log
@Get rid of magic numbers
@
text
@d1 1
a1 1
/* $OpenBSD: dec_eb164.c,v 1.7 2000/11/16 04:33:46 ericj Exp $ */
d116 1
a116 1
			if(comcnattach(ccp->cc_iot, 0x3f8, comcnrate,
d128 1
a128 1
		(void) pckbc_cnattach(ccp->cc_iot, IO_KBD, KBCMDP,
d132 1
a132 1
			isa_display_console(ccp->cc_iot, ccp->cc_memt);
d134 1
a134 1
			pci_display_console(ccp->cc_iot, ccp->cc_memt,
@


1.7
log
@
configure vga, mouse and keyboard's once again. Currently only on eb164.
others soon. Some of this from NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: dec_eb164.c,v 1.6 2000/11/08 21:48:44 art Exp $ */
d105 1
a105 1
	case 2: 
d124 1
a124 1
	case 3:
@


1.6
log
@no need to extern booted_device everywhere.
@
text
@d1 1
a1 1
/* $OpenBSD: dec_eb164.c,v 1.5 2000/11/08 19:16:58 ericj Exp $ */
d51 1
a51 1
#if 0
a52 1
#endif
a62 1
#if 0
a63 1
#endif
d128 2
a129 2
		(void) pckbc_cnattach(&ccp->cc_iot, IO_KBD, PCKBC_KBD_SLOT);

d132 1
a132 1
			isa_display_console(&ccp->cc_iot, &ccp->cc_memt);
d134 1
a134 1
			pci_display_console(&ccp->cc_iot, &ccp->cc_memt,
@


1.5
log
@add tags
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a164 1
	extern struct device *booted_device;
@


1.4
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
@


1.3
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 2
/*	$OpenBSD: dec_eb164.c,v 1.2 1997/11/10 15:46:23 niklas Exp $	*/
/*	$NetBSD: dec_eb164.c,v 1.4 1996/11/25 03:59:21 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
d29 3
d38 1
d43 1
a44 1
#include <dev/isa/isavar.h>
d47 6
d61 12
d74 3
a76 1
cpu_decl(dec_eb164);
d78 2
a79 2
const char *
dec_eb164_model_name()
d82 5
a86 5
	switch (hwrpb->rpb_variation & SV_ST_MASK) {
	default:
		printf("unknown system variation %lx\n",
		    hwrpb->rpb_variation & SV_ST_MASK);
		return NULL;
d88 4
d94 1
a94 1
void
d111 11
a121 5
			static struct consdev comcons = { NULL, NULL,
			    comcngetc, comcnputc, comcnpollc, NODEV, 1 };

			/* Delay to allow PROM putchars to complete */
			DELAY(10000);
a122 11
			comconsaddr = 0x3f8;
			comconsinit = 0;
			comconsiot = ccp->cc_iot;
			if (bus_space_map(comconsiot, comconsaddr, COM_NPORTS,
			    0, &comconsioh))
				panic("can't map serial console I/O ports");
			comconscflag = (TTYDEF_CFLAG & ~(CSIZE | PARENB)) | CS8;
			cominit(comconsiot, comconsioh, comdefaultrate);

			cn_tab = &comcons;
			comcons.cn_dev = makedev(26, 0);	/* XXX */
d127 1
d130 5
a134 2
		if (ctb->ctb_turboslot == 0)
			isa_display_console(ccp->cc_iot, ccp->cc_memt);
d136 6
a141 3
			pci_display_console(ccp->cc_iot, ccp->cc_memt,
			    &ccp->cc_pc, (ctb->ctb_turboslot >> 8) & 0xff,
			    ctb->ctb_turboslot & 0xff, 0);
d148 1
a148 1
		panic("consinit: unknown console type %d",
d153 1
a153 8
const char *
dec_eb164_iobus_name()
{

	return ("cia");
}

void
d158 1
a158 1
	static int found, initted, scsiboot, netboot;
d164 1
d171 11
a181 5
		netboot = (strcmp(b->protocol, "BOOTP") == 0);
#if 0
		printf("scsiboot = %d, netboot = %d\n", scsiboot, netboot);
#endif
		initted =1;
d190 1
a190 1
			if (b->bus != pba->pba_bus)
d194 2
a195 3
#if 0
			printf("\npcidev = %s\n", pcidev->dv_xname);
#endif
d200 1
a200 1
	if (scsiboot && (scsidev == NULL)) {
d206 3
a208 1
			if (b->slot != pa->pa_device)
a209 2

			/* XXX function? */
d212 2
a213 3
#if 0
			printf("\nscsidev = %s\n", scsidev->dv_xname);
#endif
d248 28
a275 3
#if 0
		printf("\nbooted_device = %s\n", booted_device->dv_xname);
#endif
d285 1
a285 1
			if (b->slot != pa->pa_device)
d291 2
a292 3
#if 0
			printf("\nbooted_device = %s\n", booted_device->dv_xname);
#endif
@


1.3.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 2
/* $OpenBSD: dec_eb164.c,v 1.7 2000/11/16 04:33:46 ericj Exp $ */
/* $NetBSD: dec_eb164.c,v 1.33 2000/05/22 20:13:32 thorpej Exp $ */
d5 1
a5 1
 * Copyright (c) 1995, 1996, 1997 Carnegie-Mellon University.
a29 3
/*
 * Additional Copyright (c) 1997 by Matthew Jacob for NASA/Ames Research Center
 */
a35 1
#include <sys/conf.h>
a39 1
#include <machine/bus.h>
d41 1
a43 5

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>
#include <dev/ic/i8042reg.h>
#include <dev/ic/pckbcvar.h>
a51 1
#include <dev/ata/atavar.h>
d53 1
a53 1
#include "pckbd.h"
d55 2
a56 13
#ifndef CONSPEED
#define CONSPEED TTYDEF_SPEED
#endif
static int comcnrate = CONSPEED;

#define	DR_VERBOSE(f) while (0)

void dec_eb164_init __P((void));
static void dec_eb164_cons_init __P((void));
static void dec_eb164_device_register __P((struct device *, void *));

void
dec_eb164_init()
d59 5
a63 5
	platform.family = "EB164";

	if ((platform.model = alpha_dsr_sysname()) == NULL) {
		/* XXX Don't know the system variations, yet. */
		platform.model = alpha_unknown_sysname();
a64 4

	platform.iobus = "cia";
	platform.cons_init = dec_eb164_cons_init;
	platform.device_register = dec_eb164_device_register;
d67 1
a67 1
static void
d84 5
a88 11
			/*
			 * Delay to allow PROM putchars to complete.
			 * FIFO depth * character time,
			 * character time = (1000000 / (defaultrate / 10))
			 */
			DELAY(160000000 / comcnrate);

			if(comcnattach(ccp->cc_iot, 0x3f8, comcnrate,
			    COM_FREQ,
			    (TTYDEF_CFLAG & ~(CSIZE | PARENB)) | CS8))
				panic("can't init serial console");
d90 11
a104 1
#if NPCKBD > 0
d107 1
a107 4
		(void) pckbc_cnattach(ccp->cc_iot, IO_KBD, KBCMDP,
		    PCKBC_KBD_SLOT);
		if (CTB_TURBOSLOT_TYPE(ctb->ctb_turboslot) ==
		    CTB_TURBOSLOT_TYPE_ISA)
d111 2
a112 5
			    &ccp->cc_pc, CTB_TURBOSLOT_BUS(ctb->ctb_turboslot),
			    CTB_TURBOSLOT_SLOT(ctb->ctb_turboslot), 0);
#else
		panic("not configured to use display && keyboard console");
#endif
d119 1
a119 1
		panic("consinit: unknown console type %ld\n",
d124 8
a131 1
static void
d136 1
a136 1
	static int found, initted, scsiboot, ideboot, netboot;
d148 5
a152 11
		netboot = (strcmp(b->protocol, "BOOTP") == 0) ||
		    (strcmp(b->protocol, "MOP") == 0);
		/*
		 * Add an extra check to boot from ide drives:
		 * Newer SRM firmware use the protocol identifier IDE,
		 * older SRM firmware use the protocol identifier SCSI.
		 */
		ideboot = (strcmp(b->protocol, "IDE") == 0);
		DR_VERBOSE(printf("scsiboot = %d, ideboot = %d, netboot = %d\n",
		    scsiboot, ideboot, netboot));
		initted = 1;
d161 1
a161 1
			if ((b->slot / 1000) != pba->pba_bus)
d165 3
a167 2
			DR_VERBOSE(printf("\npcidev = %s\n",
			    pcidev->dv_xname));
d172 1
a172 1
	if ((ideboot || scsiboot) && (scsidev == NULL)) {
d178 1
a178 3
			if (b->slot % 1000 / 100 != pa->pa_function)
				return;
			if (b->slot % 100 != pa->pa_device)
d180 2
d184 3
a186 2
			DR_VERBOSE(printf("\nscsidev = %s\n",
			    scsidev->dv_xname));
d221 3
a223 28
		DR_VERBOSE(printf("\nbooted_device = %s\n",
		    booted_device->dv_xname));
		found = 1;
	}

	/*
	 * Support to boot from IDE drives.
	 */
	if ((ideboot || scsiboot) && !strcmp(cd->cd_name, "wd")) {
		struct ata_atapi_attach *aa_link = aux;
		if ((strncmp("pciide", parent->dv_xname, 6) != 0)) {
			return;
		} else {
			if (parent != scsidev)
				return;
		}
		DR_VERBOSE(printf("\nAtapi info: drive: %d, channel %d\n",
		    aa_link->aa_drv_data->drive, aa_link->aa_channel));
		DR_VERBOSE(printf("Bootdev info: unit: %d, channel: %d\n",
		    b->unit, b->channel));
		if (b->unit != aa_link->aa_drv_data->drive ||
		    b->channel != aa_link->aa_channel)
			return;

		/* we've found it! */
		booted_device = dev;
		DR_VERBOSE(printf("booted_device = %s\n",
		    booted_device->dv_xname));
d233 1
a233 1
			if ((b->slot % 1000) != pa->pa_device)
d239 3
a241 2
			DR_VERBOSE(printf("\nbooted_device = %s\n",
			    booted_device->dv_xname));
@


1.3.6.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d105 1
a105 1
	case CTB_PRINTERPORT: 
d116 1
a116 1
			if(comcnattach(&ccp->cc_iot, 0x3f8, comcnrate,
d124 1
a124 1
	case CTB_GRAPHICS:
d128 1
a128 1
		(void) pckbc_cnattach(&ccp->cc_iot, IO_KBD, KBCMDP,
d132 1
a132 1
			isa_display_console(&ccp->cc_iot, &ccp->cc_memt);
d134 1
a134 1
			pci_display_console(&ccp->cc_iot, &ccp->cc_memt,
@


1.3.6.3
log
@Merge in -current from about a week ago
@
text
@d72 3
a74 3
void dec_eb164_init(void);
static void dec_eb164_cons_init(void);
static void dec_eb164_device_register(struct device *, void *);
@


1.3.6.4
log
@Sync the SMP branch with 3.3
@
text
@d146 1
a146 1
		panic("consinit: unknown console type %ld",
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: dec_eb164.c,v 1.4 1996/11/25 03:59:21 cgd Exp $	*/
d119 1
a119 1
		panic("consinit: unknown console type %d\n",
@


1.1
log
@Sync with NetBSD 961207
@
text
@d1 1
@
