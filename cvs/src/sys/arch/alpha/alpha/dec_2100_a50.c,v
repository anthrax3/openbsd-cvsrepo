head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.16
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.14
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.10
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.6
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.8
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.21.0.16
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.12
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.10
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.8
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.6
	OPENBSD_5_0:1.21.0.4
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.20.0.10
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.6
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.8
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.4
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.18.0.6
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.6
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.4
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.16.0.12
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.10
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.8
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.6
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.16
	UBC:1.14.0.2
	UBC_BASE:1.14
	OPENBSD_3_0:1.12.0.4
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.8.0.10
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.8
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.6
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.4
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.8
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2014.05.08.20.46.49;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2010.11.23.04.07.55;	author shadchin;	state Exp;
branches;
next	1.20;

1.20
date	2008.07.24.16.34.22;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2008.07.16.20.03.20;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.09.21.55.12;	author martin;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.25.21.33.19;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.26;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.14.00.44.59;	author nate;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.12.13.19.13.22;	author nate;	state Exp;
branches;
next	1.12;

1.12
date	2000.11.16.23.32.20;	author ericj;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.08.21.48.42;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.08.19.16.58;	author ericj;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.08.16.00.59;	author art;	state Exp;
branches;
next	1.8;

1.8
date	99.01.11.05.10.58;	author millert;	state Exp;
branches
	1.8.6.1;
next	1.7;

1.7
date	97.01.24.19.56.22;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.12.08.00.20.14;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.10.30.22.38.01;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.07.29.22.57.20;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.06.18.09.42.07;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.52.33;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.39;	author deraadt;	state Exp;
branches;
next	;

1.8.6.1
date	2001.04.18.16.00.13;	author niklas;	state Exp;
branches;
next	1.8.6.2;

1.8.6.2
date	2002.03.06.00.24.08;	author niklas;	state Exp;
branches;
next	1.8.6.3;

1.8.6.3
date	2002.03.28.10.06.12;	author niklas;	state Exp;
branches;
next	1.8.6.4;

1.8.6.4
date	2003.03.27.23.18.05;	author niklas;	state Exp;
branches;
next	;

1.14.2.1
date	2002.06.11.03.33.39;	author art;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2002.10.29.00.28.00;	author art;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Format string fixes for alpha kernels, and remove -Wno-format
@
text
@/* $OpenBSD: dec_2100_a50.c,v 1.21 2010/11/23 04:07:55 shadchin Exp $ */
/* $NetBSD: dec_2100_a50.c,v 1.43 2000/05/22 20:13:31 thorpej Exp $ */

/*
 * Copyright (c) 1995, 1996, 1997 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */
/*
 * Additional Copyright (c) 1997 by Matthew Jacob for NASA/Ames Research Center
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/termios.h>
#include <dev/cons.h>
#include <sys/conf.h>

#include <machine/rpb.h>
#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/cpuconf.h>
#include <machine/logout.h>

#include <dev/ic/comreg.h>
#include <dev/ic/comvar.h>

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>
#include <dev/ic/i8042reg.h>
#include <dev/ic/pckbcvar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>

#include <alpha/pci/apecsreg.h>
#include <alpha/pci/apecsvar.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include "pckbd.h"

#ifndef CONSPEED
#define CONSPEED TTYDEF_SPEED
#endif
static int comcnrate = CONSPEED;

void dec_2100_a50_init(void);
static void dec_2100_a50_cons_init(void);
static void dec_2100_a50_device_register(struct device *, void *);

#ifndef SMALL_KERNEL
static void dec_2100_a50_mcheck_handler(unsigned long, struct trapframe *,
	    unsigned long, unsigned long);
static void dec_2100_a50_mcheck(unsigned long, unsigned long, unsigned long,
	    struct trapframe *);
#endif

const struct alpha_variation_table dec_2100_a50_variations[] = {
	{ SV_ST_AVANTI,	"AlphaStation 400 4/233 (\"Avanti\")" },
	{ SV_ST_MUSTANG2_4_166, "AlphaStation 200 4/166 (\"Mustang II\")" },
	{ SV_ST_MUSTANG2_4_233, "AlphaStation 200 4/233 (\"Mustang II\")" },
	{ SV_ST_AVANTI_4_266, "AlphaStation 250 4/266" },
	{ SV_ST_MUSTANG2_4_100, "AlphaStation 200 4/100 (\"Mustang II\")" },
	{ SV_ST_AVANTI_4_233, "AlphaStation 255/233" },
	{ 0, NULL },
};

void
dec_2100_a50_init()
{
	u_int64_t variation;

	platform.family = "AlphaStation 200/400 (\"Avanti\")";

	if ((platform.model = alpha_dsr_sysname()) == NULL) {
		variation = hwrpb->rpb_variation & SV_ST_MASK;
		if (variation == SV_ST_AVANTI_XXX) {
			/* XXX apparently the same? */
			variation = SV_ST_AVANTI;
		}
		if ((platform.model = alpha_variation_name(variation,
		    dec_2100_a50_variations)) == NULL)
			platform.model = alpha_unknown_sysname();
	}

	platform.iobus = "apecs";
	platform.cons_init = dec_2100_a50_cons_init;
	platform.device_register = dec_2100_a50_device_register;
#ifndef SMALL_KERNEL
	platform.mcheck_handler = dec_2100_a50_mcheck_handler;
#endif
}

static void
dec_2100_a50_cons_init()
{
	struct ctb *ctb;
	struct apecs_config *acp;
	extern struct apecs_config apecs_configuration;

	acp = &apecs_configuration;
	apecs_init(acp, 0);

	ctb = (struct ctb *)(((caddr_t)hwrpb) + hwrpb->rpb_ctb_off);

	switch (ctb->ctb_term_type) {
	case CTB_PRINTERPORT: 
		/* serial console ... */
		/* XXX */
		{
			/*
			 * Delay to allow PROM putchars to complete.
			 * FIFO depth * character time,
			 * character time = (1000000 / (defaultrate / 10))
			 */
			DELAY(160000000 / comcnrate);

			if(comcnattach(&acp->ac_iot, 0x3f8, comcnrate,
			    COM_FREQ,
			    (TTYDEF_CFLAG & ~(CSIZE | PARENB)) | CS8))
				panic("can't init serial console");

			break;
		}

	case CTB_GRAPHICS:
#if NPCKBD > 0
		/* display console ... */
		/* XXX */
		(void) pckbc_cnattach(&acp->ac_iot, IO_KBD, KBCMDP, 0);

		if (CTB_TURBOSLOT_TYPE(ctb->ctb_turboslot) ==
		    CTB_TURBOSLOT_TYPE_ISA)
			isa_display_console(&acp->ac_iot, &acp->ac_memt);
		else
			pci_display_console(&acp->ac_iot, &acp->ac_memt,
			    &acp->ac_pc, CTB_TURBOSLOT_BUS(ctb->ctb_turboslot),
			    CTB_TURBOSLOT_SLOT(ctb->ctb_turboslot), 0);
#else
		panic("not configured to use display && keyboard console");
#endif
		break;

	default:
		printf("ctb->ctb_term_type = 0x%lx\n",
		    (unsigned long)ctb->ctb_term_type);
		printf("ctb->ctb_turboslot = 0x%lx\n",
		    (unsigned long)ctb->ctb_turboslot);

		panic("consinit: unknown console type %lu",
		    (unsigned long)ctb->ctb_term_type);
	}
}

static void
dec_2100_a50_device_register(dev, aux)
	struct device *dev;
	void *aux;
{
	static int found, initted, diskboot, netboot;
	static struct device *pcidev, *ctrlrdev;
	struct bootdev_data *b = bootdev_data;
	struct device *parent = dev->dv_parent;
	struct cfdata *cf = dev->dv_cfdata;
	struct cfdriver *cd = cf->cf_driver;

	if (found)
		return;

	if (!initted) {
		diskboot = (strncasecmp(b->protocol, "SCSI", 4) == 0);
		netboot = (strncasecmp(b->protocol, "BOOTP", 5) == 0) ||
		    (strncasecmp(b->protocol, "MOP", 3) == 0);
#if 0
		printf("diskboot = %d, netboot = %d\n", diskboot, netboot);
#endif
		initted =1;
	}

	if (pcidev == NULL) {
		if (strcmp(cd->cd_name, "pci"))
			return;
		else {
			struct pcibus_attach_args *pba = aux;

			if ((b->slot / 1000) != pba->pba_bus)
				return;
	
			pcidev = dev;
#if 0
			printf("\npcidev = %s\n", dev->dv_xname);
#endif
			return;
		}
	}

	if (ctrlrdev == NULL) {
		if (parent != pcidev)
			return;
		else {
			struct pci_attach_args *pa = aux;
			int slot;

			slot = pa->pa_bus * 1000 + pa->pa_function * 100 +
			    pa->pa_device;
			if (b->slot != slot)
				return;
	
			if (netboot) {
				booted_device = dev;
#if 0
				printf("\nbooted_device = %s\n", dev->dv_xname);
#endif
				found = 1;
			} else {
				ctrlrdev = dev;
#if 0
				printf("\nctrlrdev = %s\n", dev->dv_xname);
#endif
			}
			return;
		}
	}

	if (!diskboot)
		return;

	if (!strcmp(cd->cd_name, "sd") || !strcmp(cd->cd_name, "st") ||
	    !strcmp(cd->cd_name, "cd")) {
		struct scsi_attach_args *sa = aux;
		struct scsi_link *periph = sa->sa_sc_link;
		int unit;

		if (parent->dv_parent != ctrlrdev)
			return;

		unit = periph->target * 100 + periph->lun;
		if (b->unit != unit)
			return;

		/* we've found it! */
		booted_device = dev;
#if 0
		printf("\nbooted_device = %s\n", dev->dv_xname);
#endif
		found = 1;
	}
}

#ifndef SMALL_KERNEL
static void
dec_2100_a50_mcheck(mces, type, logout, framep)
	unsigned long mces;
	unsigned long type;
	unsigned long logout;
	struct trapframe *framep;
{
	struct mchkinfo *mcp;
	static const char *fmt1 = "        %-25s = 0x%016lx\n";
	int i, sysaddr;	
	mc_hdr_avanti *hdr;
	mc_uc_avanti *ptr;

	/*
	 * If we expected a machine check, just go handle it in common code.
	 */
	mcp  = &curcpu()->ci_mcinfo;
	if (mcp->mc_expected) {
		machine_check(mces, framep, type, logout);
		return;
	}

	hdr = (mc_hdr_avanti *) logout;
	ptr = (mc_uc_avanti *) (logout + sizeof (*hdr));

	printf("      Processor Machine Check (%lx), Code 0x%x\n",
		   type, hdr->mcheck_code);
	printf("CPU state:\n");
	/* Print PAL fields */
	for (i = 0; i < 32; i += 2) {
		printf("\tPAL temp[%d-%d]\t\t= 0x%16lx 0x%16lx\n", i, i+1,
		    (unsigned long)ptr->paltemp[i],
		    (unsigned long)ptr->paltemp[i+1]);
	}
	printf(fmt1, "Excepting Instruction Addr", ptr->exc_addr);
	printf(fmt1, "Summary of arithmetic traps", ptr->exc_sum);
	printf(fmt1, "Exception mask", ptr->exc_mask);
	printf(fmt1, "ICCSR", ptr->iccsr);
	printf(fmt1, "Base address for PALcode", ptr->pal_base);
	printf(fmt1, "HIER", ptr->hier);
	printf(fmt1, "HIRR", ptr->hirr);
	printf(fmt1, "MM_CSR", ptr->mm_csr);
	printf(fmt1, "DC_STAT", ptr->dc_stat);
	printf(fmt1, "DC_ADDR", ptr->dc_addr);
	printf(fmt1, "ABOX_CTL", ptr->abox_ctl);
	printf(fmt1, "Bus Interface Unit status", ptr->biu_stat);
	printf(fmt1, "Bus Interface Unit addr", ptr->biu_addr);
	printf(fmt1, "Bus Interface Unit control", ptr->biu_ctl);
	printf(fmt1, "Fill Syndrome", ptr->fill_syndrome);
	printf(fmt1, "Fill Address", ptr->fill_addr);
	printf(fmt1, "Effective VA", ptr->va);
	printf(fmt1, "BC_TAG", ptr->bc_tag);

	printf("\nCache and Memory Controller (21071-CA) state:\n");
	printf(fmt1, "COMA_GCR", ptr->coma_gcr);
	printf(fmt1, "COMA_EDSR", ptr->coma_edsr);
	printf(fmt1, "COMA_TER", ptr->coma_ter);
	printf(fmt1, "COMA_ELAR", ptr->coma_elar);
	printf(fmt1, "COMA_EHAR", ptr->coma_ehar);
	printf(fmt1, "COMA_LDLR", ptr->coma_ldlr);
	printf(fmt1, "COMA_LDHR", ptr->coma_ldhr);
	printf(fmt1, "COMA_BASE0", ptr->coma_base0);
	printf(fmt1, "COMA_BASE1", ptr->coma_base1);
	printf(fmt1, "COMA_BASE2", ptr->coma_base2);
	printf(fmt1, "COMA_CNFG0", ptr->coma_cnfg0);
	printf(fmt1, "COMA_CNFG1", ptr->coma_cnfg1);
	printf(fmt1, "COMA_CNFG2", ptr->coma_cnfg2);

	printf("\nPCI bridge (21071-DA) state:\n");

	printf(fmt1, "EPIC Diag. control/status", ptr->epic_dcsr);
	printf(fmt1, "EPIC_PEAR", ptr->epic_pear);
	printf(fmt1, "EPIC_SEAR", ptr->epic_sear);
	printf(fmt1, "EPIC_TBR1", ptr->epic_tbr1);
	printf(fmt1, "EPIC_TBR2", ptr->epic_tbr2);
	printf(fmt1, "EPIC_PBR1", ptr->epic_pbr1);
	printf(fmt1, "EPIC_PBR2", ptr->epic_pbr2);
	printf(fmt1, "EPIC_PMR1", ptr->epic_pmr1);
	printf(fmt1, "EPIC_PMR2", ptr->epic_pmr2);
	printf(fmt1, "EPIC_HARX1", ptr->epic_harx1);
	printf(fmt1, "EPIC_HARX2", ptr->epic_harx2);
	printf(fmt1, "EPIC_PMLT", ptr->epic_pmlt);
	printf(fmt1, "EPIC_TAG0", ptr->epic_tag0);
	printf(fmt1, "EPIC_TAG1", ptr->epic_tag1);
	printf(fmt1, "EPIC_TAG2", ptr->epic_tag2);
	printf(fmt1, "EPIC_TAG3", ptr->epic_tag3);
	printf(fmt1, "EPIC_TAG4", ptr->epic_tag4);
	printf(fmt1, "EPIC_TAG5", ptr->epic_tag5);
	printf(fmt1, "EPIC_TAG6", ptr->epic_tag6);
	printf(fmt1, "EPIC_TAG7", ptr->epic_tag7);
	printf(fmt1, "EPIC_DATA0", ptr->epic_data0);
	printf(fmt1, "EPIC_DATA1", ptr->epic_data1);
	printf(fmt1, "EPIC_DATA2", ptr->epic_data2);
	printf(fmt1, "EPIC_DATA3", ptr->epic_data3);
	printf(fmt1, "EPIC_DATA4", ptr->epic_data4);
	printf(fmt1, "EPIC_DATA5", ptr->epic_data5);
	printf(fmt1, "EPIC_DATA6", ptr->epic_data6);
	printf(fmt1, "EPIC_DATA7", ptr->epic_data7);

	printf("\n");

	if (type == ALPHA_SYS_MCHECK) {
	  printf("\nPCI bridge fault\n");
	  switch(hdr->mcheck_code) {
	  case AVANTI_RETRY_TIMEOUT:
	    printf("\tRetry timeout error accessing 0x%08lx.\n",
		   (unsigned long)ptr->epic_pear & 0xffffffff);
	    break;

	  case AVANTI_DMA_DATA_PARITY:
	    printf("\tDMA data parity error accessing 0x%08lx.\n",
		   (unsigned long)ptr->epic_pear & 0xffffffff);
	    break;

	  case AVANTI_IO_PARITY:
	    printf("\tI/O parity error at 0x%08lx during PCI cycle 0x%0lx.\n",
		   (unsigned long)ptr->epic_pear & 0xffffffff, 
		   (unsigned long)(ptr->epic_dcsr >> 18) & 0xf);
	    break;

	  case AVANTI_TARGET_ABORT:
	    printf("\tPCI target abort at 0x%08lx during PCI cycle 0x%0lx.\n",
		   (unsigned long)ptr->epic_pear & 0xffffffff, 
		   (unsigned long)(ptr->epic_dcsr >> 18) & 0xf);
	    break;

	  case AVANTI_NO_DEVICE:
	    printf("\tNo device responded at 0x%08lx during PCI cycle 0x%0lx\n.",
		   (unsigned long)ptr->epic_pear & 0xffffffff, 
		   (unsigned long)(ptr->epic_dcsr >> 18) & 0xf);
	    break;

	  case AVANTI_CORRRECTABLE_MEMORY:
	    printf("\tCorrectable memory error reported.\n"
		   "\tWARNING ECC not implemented on this system!\n"
		   "\tError is incorrect.\n");
	    break;

	  case AVANTI_UNCORRECTABLE_PCI_MEMORY:
	    printf("\tUncorrectable memory error at %016lx reported "
		   "during DMA read.\n",
		   (unsigned long)(ptr->epic_sear & 0xfffffff0) << 2);
	    break;

	  case AVANTI_INVALID_PT_LOOKUP:
	    printf("\tInvalid page table lookup during scatter/gather.\n" );
	    if (ptr->epic_dcsr & 0xf20)
	      printf("\tAddress lost.\n");
	    else
	      printf("\tBus address to 0x%08lx, PCI cycle 0x%0lx\n",
		     (unsigned long)ptr->epic_pear & 0xffffffff, 
		     (unsigned long)(ptr->epic_dcsr >> 18) & 0xf);
	    break;

	  case AVANTI_MEMORY:
	    printf("\tMemory error at %016lx, ",
		   (unsigned long)(ptr->epic_sear & 0xfffffff0) << 2);
	    sysaddr = (ptr->epic_sear & 0xffffffff) >> 21;
	    if (sysaddr >= ((ptr->coma_base0 >> 5) & 0x7ff) &&
		sysaddr < (((ptr->coma_base0 >> 5) & 0x7ff) +
			   (1 << (7 - (ptr->coma_cnfg0 >> 1)))))
	      printf("SIMM bank 0\n");
	    else if (sysaddr >= ((ptr->coma_base1 >> 5) & 0x7ff) &&
		     sysaddr < (((ptr->coma_base1 >> 5) & 0x7ff) +
				(1 << (7 - (ptr->coma_cnfg1 >> 1)))))
	      printf("SIMM bank 1\n");
	    else if (sysaddr >= ((ptr->coma_base2 >> 5) & 0x7ff) &&
		     sysaddr < (((ptr->coma_base2 >> 5) & 0x7ff) +
				(1 << (7 - (ptr->coma_cnfg2 >> 1)))))
	      printf("SIMM bank 2\n");
	    else
	      printf("invalid memory bank?\n");
	    break;

	  case AVANTI_BCACHE_TAG_ADDR_PARITY:
	    printf("\tBcache tag address parity error, caused by ");
	    if (ptr->coma_edsr & 0x20)
	      printf("victim write\n");
	    else if (ptr->coma_edsr & 0x10)
	      printf("DMA. ioCmd<2:0> = %0lx\n",
	        (unsigned long)(ptr->coma_edsr >> 6) & 7);
	    else
	      printf("CPU. cpuCReq<2:0> = %0lx\n",
	        (unsigned long)(ptr->coma_edsr >> 6) & 7);
	    break;

	  case AVANTI_BCACHE_TAG_CTRL_PARITY:
	    printf("\tBcache tag control parity error, caused by ");
	    if (ptr->coma_edsr & 0x20)
	      printf("victim write\n");
	    else if (ptr->coma_edsr & 0x10)
	      printf("DMA. ioCmd<2:0> = %0lx\n",
	        (unsigned long)(ptr->coma_edsr >> 6) & 7);
	    else
	      printf("CPU. cpuCReq<2:0> = %0lx\n",
	        (unsigned long)(ptr->coma_edsr >> 6) & 7);
	    break;
	    
	  case AVANTI_NONEXISTENT_MEMORY:
	    printf("\tNonexistent memory error, caused by ");
	    if (ptr->coma_edsr & 0x20)
	      printf("victim write\n");
	    else if (ptr->coma_edsr & 0x10)
	      printf("DMA. ioCmd<2:0> = %0lx\n",
	        (unsigned long)(ptr->coma_edsr >> 6) & 7);
	    else
	      printf("CPU. cpuCReq<2:0> = %0lx\n",
	        (unsigned long)(ptr->coma_edsr >> 6) & 7);
	    break;

	  case AVANTI_IO_BUS:
	    printf("\tI/O bus error at %08lx during PCI cycle %0lx\n",
		   (unsigned long)ptr->epic_pear & 0xffffffff,
		   (unsigned long)(ptr->epic_dcsr >> 18) & 0xf);
	    break;

	  case AVANTI_BCACHE_TAG_PARITY:
	    printf("\tBcache tag address parity error.\n"
		   "\tcReg_h cycle %0lx, address<7:0> 0x%02lx\n",
		   (unsigned long)(ptr->biu_stat >> 4) & 7,
		   (unsigned long)ptr->biu_addr & 0xff);
	    break;

	  case AVANTI_BCACHE_TAG_CTRL_PARITY2:
	    printf("\tBcache tag control parity error.\n"
		   "\tcReg_h cycle %0lx, address<7:0> 0x%02lx\n",
		   (unsigned long)(ptr->biu_stat >> 4) & 7,
		   (unsigned long)ptr->biu_addr & 0xff);
	    break;

	  }
	} else { /* ALPHA_PROC_MCHECK */
	  printf("\nProcessor fault\n");
	  switch(hdr->mcheck_code) {
	  case AVANTI_HARD_ERROR:
	    printf("\tHard error cycle.\n");
	    break;

	  case AVANTI_CORRECTABLE_ECC:
	    printf("\tCorrectable ECC error.\n"
		   "\tWARNING ECC not implemented on this system!\n"
		   "\tError is incorrect.\n");
	    break;

	  case AVANTI_NONCORRECTABLE_ECC:
	    printf("\tNoncorrectable ECC error.\n"
		   "\tWARNING ECC not implemented on this system!\n"
		   "\tError is incorrect.\n");
	    break;

	  case AVANTI_UNKNOWN_ERROR:
	    printf("\tUnknown error.\n");
	    break;

	  case AVANTI_SOFT_ERROR:
	    printf("\tSoft error cycle.\n");
	    break;

	  case AVANTI_BUGCHECK:
	    printf("\tBugcheck.\n");
	    break;

	  case AVANTI_OS_BUGCHECK:
	    printf("\tOS Bugcheck.\n");
	    break;

	  case AVANTI_DCACHE_FILL_PARITY:
	    printf("\tPrimary Dcache data fill parity error.\n"
		   "\tDcache Quadword %lx, address %08lx\n",
		   (unsigned long)(ptr->biu_stat >> 12) & 0x3,
		   (unsigned long)(ptr->fill_addr >> 8) & 0x7f);
	    break;

	  case AVANTI_ICACHE_FILL_PARITY:
	    printf("\tPrimary Icache data fill parity error.\n"
		   "\tDcache Quadword %lx, address %08lx\n",
		   (unsigned long)(ptr->biu_stat >> 12) & 0x3,
		   (unsigned long)(ptr->fill_addr >> 8) & 0x7f);
	    break;
	  }
	}
	  
	/*
	 * Now that we've printed all sorts of useful information
	 * and have decided that we really can't do any more to
	 * respond to the error, go on to the common code for
	 * final disposition. Usually this means that we die.
	 */
	/*
	 * XXX: HANDLE PCI ERRORS HERE?
	 */
	machine_check(mces, framep, type, logout);
}

static void
dec_2100_a50_mcheck_handler(mces, framep, vector, param)
	unsigned long mces;
	struct trapframe *framep;
	unsigned long vector;
	unsigned long param;
{
	switch (vector) {
	case ALPHA_SYS_MCHECK:
	case ALPHA_PROC_MCHECK:
		dec_2100_a50_mcheck(mces, vector, param, framep);
		break;
	default:
		printf("2100_A50_MCHECK: unknown check vector 0x%lx\n", vector);
		machine_check(mces, framep, vector, param);
		break;
	}
}
#endif	/* !SMALL_KERNEL */
@


1.21
log
@removed slot argument of function pckbc_cnattach
because it is always PCKBC_KBD_SLOT

ok krw@@, miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: dec_2100_a50.c,v 1.20 2008/07/24 16:34:22 miod Exp $ */
d168 4
a171 2
		printf("ctb->ctb_term_type = 0x%lx\n", ctb->ctb_term_type);
		printf("ctb->ctb_turboslot = 0x%lx\n", ctb->ctb_turboslot);
d173 2
a174 2
		panic("consinit: unknown console type %ld",
		    ctb->ctb_term_type);
d305 2
a306 1
		    ptr->paltemp[i], ptr->paltemp[i+1]);
d380 1
a380 1
		   ptr->epic_pear & 0xffffffff);
d385 1
a385 1
		   ptr->epic_pear & 0xffffffff);
d390 2
a391 2
		   ptr->epic_pear & 0xffffffff, 
		   (ptr->epic_dcsr >> 18) & 0xf);
d396 2
a397 2
		   ptr->epic_pear & 0xffffffff, 
		   (ptr->epic_dcsr >> 18) & 0xf);
d402 2
a403 2
		   ptr->epic_pear & 0xffffffff, 
		   (ptr->epic_dcsr >> 18) & 0xf);
d415 1
a415 1
		   (ptr->epic_sear & 0xfffffff0) << 2);
d424 2
a425 2
		     ptr->epic_pear & 0xffffffff, 
		     (ptr->epic_dcsr >> 18) & 0xf);
d430 1
a430 1
		   (ptr->epic_sear & 0xfffffff0) << 2);
d453 2
a454 1
	      printf("DMA. ioCmd<2:0> = %0lx\n", (ptr->coma_edsr >> 6) & 7);
d456 2
a457 1
	      printf("CPU. cpuCReq<2:0> = %0lx\n", (ptr->coma_edsr >> 6) & 7);
d465 2
a466 1
	      printf("DMA. ioCmd<2:0> = %0lx\n", (ptr->coma_edsr >> 6) & 7);
d468 2
a469 1
	      printf("CPU. cpuCReq<2:0> = %0lx\n", (ptr->coma_edsr >> 6) & 7);
d477 2
a478 1
	      printf("DMA. ioCmd<2:0> = %0lx\n", (ptr->coma_edsr >> 6) & 7);
d480 2
a481 1
	      printf("CPU. cpuCReq<2:0> = %0lx\n", (ptr->coma_edsr >> 6) & 7);
d486 2
a487 1
		   ptr->epic_pear & 0xffffffff, (ptr->epic_dcsr >> 18) & 0xf);
d493 2
a494 2
		   (ptr->biu_stat >> 4) & 7,
		   ptr->biu_addr & 0xff);
d500 2
a501 2
		   (ptr->biu_stat >> 4) & 7,
		   ptr->biu_addr & 0xff);
d543 2
a544 2
		   (ptr->biu_stat >> 12) & 0x3,
		   (ptr->fill_addr >> 8) & 0x7f);
d550 2
a551 2
		   (ptr->biu_stat >> 12) & 0x3,
		   (ptr->fill_addr >> 8) & 0x7f);
@


1.20
log
@Add code to decode machine checks on Avanti, providing a description of the
problem and lots of register dumps to help the skilled user to fix the hardware.
Not compiled if option SMALL_KERNEL.

From NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: dec_2100_a50.c,v 1.19 2008/07/16 20:03:20 miod Exp $ */
d153 1
a153 2
		(void) pckbc_cnattach(&acp->ac_iot, IO_KBD, KBCMDP,
		    PCKBC_KBD_SLOT, 0);
@


1.19
log
@Add a new parameter to pckbc_cnattach(): flags to put in the pckbc bowels.
For now, only one such flag is defined, PCKBC_CANT_TRANSLATE. It hints
pckbc that the device does not behave correctly to the ``set translation''
commands.

Set this flag if we are running on a Tadpole Ultrabook machine, which needs it.
This makes the built-in keyboard work correctly on this laptop (with the
help of the software translation pckbd diff).

tested & ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: dec_2100_a50.c,v 1.18 2006/11/28 16:56:50 dlg Exp $ */
d45 1
d74 7
d112 3
d271 307
@


1.18
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dec_2100_a50.c,v 1.17 2005/05/09 21:55:12 martin Exp $ */
d143 1
a143 1
		    PCKBC_KBD_SLOT);
@


1.17
log
@fixes and updates for root device detection from NetBSD:

- remove unneeded checks and variables
- use strncasecmp() to check b->protocol because the case is dependant on the
  firmware revision
- check logical unit numbers
- consistently check PCI function numbers
- on the 6600 models check which PCI hierarchy is looked at
- makes root device detection on DS20 (6600) work

testing by claudio, xsa and miod; ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: dec_2100_a50.c,v 1.16 2002/06/25 21:33:19 miod Exp $ */
d241 1
a241 1
		struct scsibus_attach_args *sa = aux;
@


1.16
log
@No \n at the end of a panic() message... I thought all occurences had been
squashed already.
@
text
@d1 1
a1 1
/* $OpenBSD: dec_2100_a50.c,v 1.15 2002/03/14 01:26:26 millert Exp $ */
d171 2
a172 2
	static int found, initted, scsiboot, netboot;
	static struct device *pcidev, *scsidev;
d182 3
a184 3
		scsiboot = (strcmp(b->protocol, "SCSI") == 0);
		netboot = (strcmp(b->protocol, "BOOTP") == 0) ||
		    (strcmp(b->protocol, "MOP") == 0);
d186 1
a186 1
		printf("scsiboot = %d, netboot = %d\n", scsiboot, netboot);
d202 1
a202 1
			printf("\npcidev = %s\n", pcidev->dv_xname);
d208 1
a208 1
	if (scsiboot && (scsidev == NULL)) {
d213 1
d215 3
a217 1
			if ((b->slot % 1000) != pa->pa_device)
a218 2

			/* XXX function? */
d220 8
a227 1
			scsidev = dev;
d229 1
a229 1
			printf("\nscsidev = %s\n", scsidev->dv_xname);
d231 1
d236 5
a240 4
	if (scsiboot &&
	    (!strcmp(cd->cd_name, "sd") ||
	     !strcmp(cd->cd_name, "st") ||
	     !strcmp(cd->cd_name, "cd"))) {
d242 2
d245 1
a245 4
		if (parent->dv_parent != scsidev)
			return;

		if (b->unit / 100 != sa->sa_sc_link->target)
d248 2
a249 13
		/* XXX LUN! */

		switch (b->boot_dev_type) {
		case 0:
			if (strcmp(cd->cd_name, "sd") &&
			    strcmp(cd->cd_name, "cd"))
				return;
			break;
		case 1:
			if (strcmp(cd->cd_name, "st"))
				return;
			break;
		default:
a250 1
		}
d255 1
a255 1
		printf("\nbooted_device = %s\n", booted_device->dv_xname);
a257 20
	}

	if (netboot) {
		if (parent != pcidev)
			return;
		else {
			struct pci_attach_args *pa = aux;

			if ((b->slot % 1000) != pa->pa_device)
				return;

			/* XXX function? */
	
			booted_device = dev;
#if 0
			printf("\nbooted_device = %s\n", booted_device->dv_xname);
#endif
			found = 1;
			return;
		}
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: dec_2100_a50.c,v 1.14 2001/12/14 00:44:59 nate Exp $ */
d161 1
a161 1
		panic("consinit: unknown console type %ld\n",
@


1.14
log
@Don't use a single static struct alpha_bus_space since there are machines
that can have more than one system bus attached to mainbus
@
text
@d1 1
a1 1
/* $OpenBSD: dec_2100_a50.c,v 1.13 2001/12/13 19:13:22 nate Exp $ */
d69 3
a71 3
void dec_2100_a50_init __P((void));
static void dec_2100_a50_cons_init __P((void));
static void dec_2100_a50_device_register __P((struct device *, void *));
@


1.14.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: dec_2100_a50.c,v 1.14 2001/12/14 00:44:59 nate Exp $ */
d69 3
a71 3
void dec_2100_a50_init(void);
static void dec_2100_a50_cons_init(void);
static void dec_2100_a50_device_register(struct device *, void *);
@


1.14.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: dec_2100_a50.c,v 1.14.2.1 2002/06/11 03:33:39 art Exp $ */
d161 1
a161 1
		panic("consinit: unknown console type %ld",
@


1.13
log
@Get rid of magic numbers
@
text
@d1 1
a1 1
/* $OpenBSD: dec_2100_a50.c,v 1.12 2000/11/16 23:32:20 ericj Exp $ */
d130 1
a130 1
			if(comcnattach(acp->ac_iot, 0x3f8, comcnrate,
d142 1
a142 1
		(void) pckbc_cnattach(acp->ac_iot, IO_KBD, KBCMDP,
d147 1
a147 1
			isa_display_console(acp->ac_iot, acp->ac_memt);
d149 1
a149 1
			pci_display_console(acp->ac_iot, acp->ac_memt,
@


1.12
log
@
allow the console to attach on the rest of the alpha's we support.
@
text
@d1 1
a1 1
/* $OpenBSD: dec_2100_a50.c,v 1.11 2000/11/08 21:48:42 art Exp $ */
d119 1
a119 1
	case 2: 
d138 1
a138 1
	case 3:
@


1.11
log
@no need to extern booted_device everywhere.
@
text
@d1 1
a1 1
/* $OpenBSD: dec_2100_a50.c,v 1.10 2000/11/08 19:16:58 ericj Exp $ */
d51 1
a51 1
#ifdef notyet
a52 1
#endif
a61 1
#ifdef notyet
a62 1
#endif
d142 2
a143 1
		(void) pckbc_cnattach(&acp->ac_iot, IO_KBD, PCKBC_KBD_SLOT);
d147 1
a147 1
			isa_display_console(&acp->ac_iot, &acp->ac_memt);
d149 1
a149 1
			pci_display_console(&acp->ac_iot, &acp->ac_memt,
@


1.10
log
@add tags
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a178 1
	extern struct device *booted_device;
@


1.9
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
@


1.8
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 2
/*	$OpenBSD: dec_2100_a50.c,v 1.7 1997/01/24 19:56:22 niklas Exp $	*/
/*	$NetBSD: dec_2100_a50.c,v 1.18 1996/11/25 03:59:19 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
d29 3
d38 1
d42 1
a44 1
#include <dev/isa/isavar.h>
d47 6
d62 3
a64 1
cpu_decl(dec_2100_a50);
d66 4
a69 4
const char *
dec_2100_a50_model_name()
{
	static char s[80];
d71 13
a83 4
	switch (hwrpb->rpb_variation & SV_ST_MASK) {
	case SV_ST_AVANTI:
	case SV_ST_AVANTI_XXX:		/* XXX apparently the same? */
		return "AlphaStation 400 4/233 (\"Avanti\")";
d85 4
a88 2
	case SV_ST_MUSTANG2_4_166:
		return "AlphaStation 200 4/166 (\"Mustang II\")";
d90 1
a90 2
	case SV_ST_MUSTANG2_4_233:
		return "AlphaStation 200 4/233 (\"Mustang II\")";
d92 10
a101 5
	case 0x2000:
		return "AlphaStation 250 4/266";

	case SV_ST_MUSTANG2_4_100:
		return "AlphaStation 200 4/100 (\"Mustang II\")";
d103 3
a105 8
	case 0xa800:
		return "AlphaStation 255/233";

	default:
		sprintf(s, "DEC 2100/A50 (\"Avanti\") family, variation %lx",
		    hwrpb->rpb_variation & SV_ST_MASK);
		return s;
	}
d108 1
a108 1
void
d125 11
a135 2
			static struct consdev comcons = { NULL, NULL,
			    comcngetc, comcnputc, comcnpollc, NODEV, 1 };
a136 14
			/* Delay to allow PROM putchars to complete */
			DELAY(10000);

			comconsaddr = 0x3f8;
			comconsinit = 0;
			comconsiot = acp->ac_iot;
			if (bus_space_map(comconsiot, comconsaddr, COM_NPORTS,
			    0, &comconsioh))
				panic("can't map serial console I/O ports");
			comconscflag = (TTYDEF_CFLAG & ~(CSIZE | PARENB)) | CS8;
			cominit(comconsiot, comconsioh, comdefaultrate);

			cn_tab = &comcons;
			comcons.cn_dev = makedev(26, 0);	/* XXX */
d141 1
d144 5
a148 2
		if (ctb->ctb_turboslot == 0)
			isa_display_console(acp->ac_iot, acp->ac_memt);
d150 6
a155 3
			pci_display_console(acp->ac_iot, acp->ac_memt,
			    &acp->ac_pc, (ctb->ctb_turboslot >> 8) & 0xff,
			    ctb->ctb_turboslot & 0xff, 0);
d162 1
a162 1
		panic("consinit: unknown console type %d",
d167 1
a167 8
const char *
dec_2100_a50_iobus_name()
{

	return ("apecs");
}

void
d178 1
d185 2
a186 1
		netboot = (strcmp(b->protocol, "BOOTP") == 0);
d199 1
a199 1
			if (b->bus != pba->pba_bus)
d216 1
a216 1
			if (b->slot != pa->pa_device)
d271 1
a271 1
			if (b->slot != pa->pa_device)
@


1.8.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 2
/* $OpenBSD: dec_2100_a50.c,v 1.12 2000/11/16 23:32:20 ericj Exp $ */
/* $NetBSD: dec_2100_a50.c,v 1.43 2000/05/22 20:13:31 thorpej Exp $ */
d5 1
a5 1
 * Copyright (c) 1995, 1996, 1997 Carnegie-Mellon University.
a29 3
/*
 * Additional Copyright (c) 1997 by Matthew Jacob for NASA/Ames Research Center
 */
a35 1
#include <sys/conf.h>
a38 1
#include <machine/bus.h>
d41 1
a43 5

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>
#include <dev/ic/i8042reg.h>
#include <dev/ic/pckbcvar.h>
d53 6
a58 1
#include "pckbd.h"
d60 10
a69 4
#ifndef CONSPEED
#define CONSPEED TTYDEF_SPEED
#endif
static int comcnrate = CONSPEED;
d71 2
a72 13
void dec_2100_a50_init __P((void));
static void dec_2100_a50_cons_init __P((void));
static void dec_2100_a50_device_register __P((struct device *, void *));

const struct alpha_variation_table dec_2100_a50_variations[] = {
	{ SV_ST_AVANTI,	"AlphaStation 400 4/233 (\"Avanti\")" },
	{ SV_ST_MUSTANG2_4_166, "AlphaStation 200 4/166 (\"Mustang II\")" },
	{ SV_ST_MUSTANG2_4_233, "AlphaStation 200 4/233 (\"Mustang II\")" },
	{ SV_ST_AVANTI_4_266, "AlphaStation 250 4/266" },
	{ SV_ST_MUSTANG2_4_100, "AlphaStation 200 4/100 (\"Mustang II\")" },
	{ SV_ST_AVANTI_4_233, "AlphaStation 255/233" },
	{ 0, NULL },
};
d74 2
a75 4
void
dec_2100_a50_init()
{
	u_int64_t variation;
d77 2
a78 1
	platform.family = "AlphaStation 200/400 (\"Avanti\")";
d80 4
a83 9
	if ((platform.model = alpha_dsr_sysname()) == NULL) {
		variation = hwrpb->rpb_variation & SV_ST_MASK;
		if (variation == SV_ST_AVANTI_XXX) {
			/* XXX apparently the same? */
			variation = SV_ST_AVANTI;
		}
		if ((platform.model = alpha_variation_name(variation,
		    dec_2100_a50_variations)) == NULL)
			platform.model = alpha_unknown_sysname();
a84 4

	platform.iobus = "apecs";
	platform.cons_init = dec_2100_a50_cons_init;
	platform.device_register = dec_2100_a50_device_register;
d87 1
a87 1
static void
d104 2
a105 11
			/*
			 * Delay to allow PROM putchars to complete.
			 * FIFO depth * character time,
			 * character time = (1000000 / (defaultrate / 10))
			 */
			DELAY(160000000 / comcnrate);

			if(comcnattach(acp->ac_iot, 0x3f8, comcnrate,
			    COM_FREQ,
			    (TTYDEF_CFLAG & ~(CSIZE | PARENB)) | CS8))
				panic("can't init serial console");
d107 14
a124 1
#if NPCKBD > 0
d127 1
a127 5
		(void) pckbc_cnattach(acp->ac_iot, IO_KBD, KBCMDP,
		    PCKBC_KBD_SLOT);

		if (CTB_TURBOSLOT_TYPE(ctb->ctb_turboslot) ==
		    CTB_TURBOSLOT_TYPE_ISA)
d131 2
a132 5
			    &acp->ac_pc, CTB_TURBOSLOT_BUS(ctb->ctb_turboslot),
			    CTB_TURBOSLOT_SLOT(ctb->ctb_turboslot), 0);
#else
		panic("not configured to use display && keyboard console");
#endif
d139 1
a139 1
		panic("consinit: unknown console type %ld\n",
d144 8
a151 1
static void
d168 1
a168 2
		netboot = (strcmp(b->protocol, "BOOTP") == 0) ||
		    (strcmp(b->protocol, "MOP") == 0);
d181 1
a181 1
			if ((b->slot / 1000) != pba->pba_bus)
d198 1
a198 1
			if ((b->slot % 1000) != pa->pa_device)
d253 1
a253 1
			if ((b->slot % 1000) != pa->pa_device)
@


1.8.6.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d119 1
a119 1
	case CTB_PRINTERPORT: 
d130 1
a130 1
			if(comcnattach(&acp->ac_iot, 0x3f8, comcnrate,
d138 1
a138 1
	case CTB_GRAPHICS:
d142 1
a142 1
		(void) pckbc_cnattach(&acp->ac_iot, IO_KBD, KBCMDP,
d147 1
a147 1
			isa_display_console(&acp->ac_iot, &acp->ac_memt);
d149 1
a149 1
			pci_display_console(&acp->ac_iot, &acp->ac_memt,
@


1.8.6.3
log
@Merge in -current from about a week ago
@
text
@d69 3
a71 3
void dec_2100_a50_init(void);
static void dec_2100_a50_cons_init(void);
static void dec_2100_a50_device_register(struct device *, void *);
@


1.8.6.4
log
@Sync the SMP branch with 3.3
@
text
@d161 1
a161 1
		panic("consinit: unknown console type %ld",
@


1.7
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: dec_2100_a50.c,v 1.6 1996/12/08 00:20:14 niklas Exp $	*/
d139 1
a139 1
		panic("consinit: unknown console type %d\n",
@


1.6
log
@Merge to NetBSD 961107, i.e. mostly new bus.h
@
text
@d1 2
a2 2
/*	$OpenBSD: dec_2100_a50.c,v 1.5 1996/10/30 22:38:01 niklas Exp $	*/
/*	$NetBSD: dec_2100_a50.c,v 1.15 1996/10/23 04:12:13 cgd Exp $	*/
d39 1
a49 2
#include <alpha/alpha/dec_2100_a50.h>

d53 4
a56 2
char *
dec_2100_a50_modelname()
d88 1
a88 1
dec_2100_a50_consinit()
d95 1
a95 1
	apecs_init(acp);
d127 6
a132 3
		pci_display_console(acp->ac_iot, acp->ac_memt, &acp->ac_pc,
		    (ctb->ctb_turboslot >> 8) & 0xff,
		    ctb->ctb_turboslot & 0xff, 0);
d142 7
@


1.5
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 2
a2 2
/*	$OpenBSD: dec_2100_a50.c,v 1.14 1996/10/13 02:59:28 christos Exp $	*/
/*	$NetBSD: dec_2100_a50.c,v 1.14 1996/10/13 02:59:28 christos Exp $	*/
d41 2
a42 2
#include <dev/isa/comreg.h>
#include <dev/isa/comvar.h>
a102 5
			extern int comconsinit;	/* set */
			extern int comdefaultrate;
			extern int comcngetc __P((dev_t));
			extern void comcnputc __P((dev_t, int));
			extern void comcnpollc __P((dev_t, int));
d111 3
a113 3
			comconsbc = &acp->ac_bc;
			if (bus_io_map(comconsbc, comconsaddr, COM_NPORTS,
			    &comconsioh))
d116 1
a116 1
			cominit(comconsbc, comconsioh, comdefaultrate);
d126 1
a126 1
		pci_display_console(&acp->ac_bc, &acp->ac_pc,
@


1.4
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: dec_2100_a50.c,v 1.6.4.2 1996/06/14 20:42:23 cgd Exp $	*/
/*	$NetBSD: dec_2100_a50.c,v 1.6.4.2 1996/06/14 20:42:23 cgd Exp $	*/
d32 1
d103 1
a103 3
			extern bus_chipset_tag_t comconsbc;	/* set */
			extern bus_io_handle_t comcomsioh;	/* set */
			extern int comconsaddr, comconsinit;	/* set */
d150 1
a150 1
	static int found;
d160 9
d186 1
a186 1
	if (scsidev == NULL) {
d205 4
a208 3
	if (!strcmp(cd->cd_name, "sd") ||
	    !strcmp(cd->cd_name, "st") ||
	    !strcmp(cd->cd_name, "cd")) {
d239 20
@


1.3
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.2
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: dec_2100_a50.c,v 1.3 1995/11/23 02:33:52 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1995 Carnegie-Mellon University.
d32 1
d36 1
d39 2
d49 3
d55 1
a60 1
		break;
a63 1
		break;
a66 1
		break;
a69 1
		break;
d73 3
a75 1
		break;
d78 1
a78 1
		printf("unknown system variation %lx\n",
d80 1
a80 1
		return NULL;
d85 1
a85 2
dec_2100_a50_consinit(constype)
	char *constype;
a95 4
	printf("constype = %s\n", constype);
	printf("ctb->ctb_term_type = 0x%lx\n", ctb->ctb_term_type);
	printf("ctb->ctb_turboslot = 0x%lx\n", ctb->ctb_turboslot);

d101 4
a104 2
			extern int comdefaultrate, comconsole;
			extern int comconsaddr, comconsinit;
a107 2
			extern __const struct isa_pio_fns *comconsipf;
			extern __const void *comconsipfa;
d111 4
a114 4
			cominit(acp->ac_piofns, acp->ac_pioarg, 0,
			    comdefaultrate);
			comconsole = 0;				/* XXX */
			comconsaddr = 0x3f8;			/* XXX */
d116 6
a121 2
			comconsipf = acp->ac_piofns;
			comconsipfa = acp->ac_pioarg;
d131 3
a133 3
		pci_display_console(acp->ac_conffns, acp->ac_confarg,
		    acp->ac_memfns, acp->ac_memarg, acp->ac_piofns,
		    acp->ac_pioarg, 0, ctb->ctb_turboslot & 0xffff, 0);
d137 3
d145 4
a148 3
dev_t
dec_2100_a50_bootdev(booted_dev)
	char *booted_dev;
d150 45
d196 34
a229 1
	panic("gack.");
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: dec_2100_a50.c,v 1.2 1995/08/03 01:12:15 cgd Exp $	*/
a34 1
#include <machine/pio.h>
d39 5
a43 1
#include <alpha/pci/pci_chipset.h>
d63 4
d83 2
d86 2
a87 1
	apecs_init();
d105 2
d110 2
a111 2

			cominit(0, comdefaultrate);
d115 2
d126 3
a128 1
		pci_display_console(0, ctb->ctb_turboslot & 0xffff, 0);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
