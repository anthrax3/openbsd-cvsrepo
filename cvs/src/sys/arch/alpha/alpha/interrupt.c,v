head	1.40;
access;
symbols
	OPENBSD_6_2:1.40.0.6
	OPENBSD_6_2_BASE:1.40
	OPENBSD_6_1:1.40.0.4
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.38.0.2
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.35.0.4
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.33.0.4
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.31.0.10
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.31.0.8
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.6
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.4
	OPENBSD_5_0:1.31.0.2
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.29.0.6
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.29.0.4
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.25.0.4
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.24.0.4
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.20.0.4
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.18.0.6
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.4
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.6
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.4
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.14
	UBC:1.13.0.2
	UBC_BASE:1.13
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.8.0.8
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.6
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.4
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.8
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.40
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.39;
commitid	CHRb0fCqa8XxUAMH;

1.39
date	2016.10.08.05.49.08;	author guenther;	state Exp;
branches;
next	1.38;
commitid	z63v1DilayzHcfkw;

1.38
date	2016.06.13.01.26.14;	author dlg;	state Exp;
branches;
next	1.37;
commitid	ofg7tRWmBtMrMB35;

1.37
date	2015.09.13.20.37.28;	author kettenis;	state Exp;
branches;
next	1.36;
commitid	l4dcqI5s8IEqvgBi;

1.36
date	2015.09.02.14.07.41;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	cHp48PuRRgzjq4bx;

1.35
date	2015.05.19.20.28.14;	author miod;	state Exp;
branches;
next	1.34;
commitid	YdrkA6WJKqXchmio;

1.34
date	2014.11.18.20.51.00;	author krw;	state Exp;
branches;
next	1.33;
commitid	G35ycnLxaVis5TX9;

1.33
date	2014.07.12.18.44.40;	author tedu;	state Exp;
branches;
next	1.32;
commitid	uKVPYMN2MLxdZxzH;

1.32
date	2014.01.26.17.40.09;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2011.04.15.20.40.03;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2010.12.21.14.56.23;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2009.04.19.19.13.57;	author oga;	state Exp;
branches;
next	1.28;

1.28
date	2009.03.25.21.41.40;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2009.03.15.19.41.33;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2009.03.07.15.31.42;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2008.06.26.05.42.08;	author ray;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.17.10.01.25;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.29.18.10.41;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.05.20.46.34;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2007.04.21.21.37.09;	author martin;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.15.20.08.29;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2006.02.23.20.14.13;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2004.08.16.16.43.52;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.06.21.53.59;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.28.02.28.42;	author aaron;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.06.21.09.34;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.25.21.33.19;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.06.19.53.13;	author miod;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.09.30.13.08.45;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.20.20.29.53;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.08.19.16.59;	author ericj;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.08.16.01.00;	author art;	state Exp;
branches;
next	1.8;

1.8
date	99.09.25.16.23.49;	author pjanzen;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	99.01.11.05.10.59;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.01.24.19.56.34;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.10.30.22.38.12;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.07.29.22.57.39;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.06.18.09.42.15;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.52.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.39;	author deraadt;	state Exp;
branches;
next	;

1.8.4.1
date	2001.04.18.16.00.21;	author niklas;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2001.10.31.02.52.43;	author nate;	state Exp;
branches;
next	1.8.4.3;

1.8.4.3
date	2001.11.13.21.00.48;	author niklas;	state Exp;
branches;
next	1.8.4.4;

1.8.4.4
date	2003.03.27.23.18.05;	author niklas;	state Exp;
branches;
next	1.8.4.5;

1.8.4.5
date	2004.02.19.09.59.33;	author niklas;	state Exp;
branches;
next	;

1.13.2.1
date	2002.10.29.00.28.00;	author art;	state Exp;
branches;
next	;


desc
@@


1.40
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@/* $OpenBSD: interrupt.c,v 1.39 2016/10/08 05:49:08 guenther Exp $ */
/* $NetBSD: interrupt.c,v 1.46 2000/06/03 20:47:36 thorpej Exp $ */

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1994, 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Authors: Keith Bostic, Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */
/*
 * Additional Copyright (c) 1997 by Matthew Jacob for NASA/Ames Research Center.
 * Redistribute and modify at will, leaving only this additional copyright
 * notice.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/vmmeter.h>
#include <sys/sched.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/evcount.h>

#include <uvm/uvm_extern.h>

#include <machine/atomic.h>
#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/reg.h>
#include <machine/rpb.h>
#include <machine/frame.h>
#include <machine/cpuconf.h>

#include "apecs.h"
#include "cia.h"
#include "lca.h"
#include "tcasic.h"

extern struct evcount clk_count;

struct scbvec scb_iovectab[SCB_VECTOIDX(SCB_SIZE - SCB_IOVECBASE)];

void	scb_stray(void *, u_long);

/*
 * True if the system has any non-level interrupts which are shared
 * on the same pin.
 */
int	intr_shared_edge;

void
scb_init(void)
{
	u_long i;

	for (i = 0; i < SCB_NIOVECS; i++) {
		scb_iovectab[i].scb_func = scb_stray;
		scb_iovectab[i].scb_arg = NULL;
	}
}

void
scb_stray(void *arg, u_long vec)
{

	printf("WARNING: stray interrupt, vector 0x%lx\n", vec);
}

void
scb_set(u_long vec, void (*func)(void *, u_long), void *arg)
{
	u_long idx;
	int s;

	s = splhigh();

	if (vec < SCB_IOVECBASE || vec >= SCB_SIZE ||
	    (vec & (SCB_VECSIZE - 1)) != 0)
		panic("scb_set: bad vector 0x%lx", vec);

	idx = SCB_VECTOIDX(vec - SCB_IOVECBASE);

	if (scb_iovectab[idx].scb_func != scb_stray)
		panic("scb_set: vector 0x%lx already occupied", vec);

	scb_iovectab[idx].scb_func = func;
	scb_iovectab[idx].scb_arg = arg;

	splx(s);
}

#ifdef unused
u_long
scb_alloc(void (*func)(void *, u_long), void *arg)
{
	u_long vec, idx;
	int s;

	s = splhigh();

	/*
	 * Allocate "downwards", to avoid bumping into
	 * interrupts which are likely to be at the lower
	 * vector numbers.
	 */
	for (vec = SCB_SIZE - SCB_VECSIZE;
	     vec >= SCB_IOVECBASE; vec -= SCB_VECSIZE) {
		idx = SCB_VECTOIDX(vec - SCB_IOVECBASE);
		if (scb_iovectab[idx].scb_func == scb_stray) {
			scb_iovectab[idx].scb_func = func;
			scb_iovectab[idx].scb_arg = arg;
			splx(s);
			return (vec);
		}
	}

	splx(s);

	return (SCB_ALLOC_FAILED);
}
#endif

void
scb_free(u_long vec)
{
	u_long idx;
	int s;

	s = splhigh();

	if (vec < SCB_IOVECBASE || vec >= SCB_SIZE ||
	    (vec & (SCB_VECSIZE - 1)) != 0)
		panic("scb_free: bad vector 0x%lx", vec);

	idx = SCB_VECTOIDX(vec - SCB_IOVECBASE); 

	if (scb_iovectab[idx].scb_func == scb_stray)
		panic("scb_free: vector 0x%lx is empty", vec);

	scb_iovectab[idx].scb_func = scb_stray;
	scb_iovectab[idx].scb_arg = (void *) vec;

	splx(s);
}

void
interrupt(unsigned long a0, unsigned long a1, unsigned long a2,
    struct trapframe *framep)
{
	struct cpu_info *ci = curcpu();
	extern int schedhz;

	switch (a0) {
	case ALPHA_INTR_XPROC:	/* interprocessor interrupt */
#if defined(MULTIPROCESSOR)
		atomic_add_ulong(&ci->ci_intrdepth, 1);

		alpha_ipi_process(ci, framep);

		/*
		 * Handle inter-console messages if we're the primary
		 * CPU.
		 */
		if (ci->ci_cpuid == hwrpb->rpb_primary_cpu_id &&
		    hwrpb->rpb_txrdy != 0)
			cpu_iccb_receive();

		atomic_sub_ulong(&ci->ci_intrdepth, 1);
#else
		printf("WARNING: received interprocessor interrupt!\n");
#endif /* MULTIPROCESSOR */
		break;
		
	case ALPHA_INTR_CLOCK:	/* clock interrupt */
		atomic_add_int(&uvmexp.intrs, 1);
		if (CPU_IS_PRIMARY(ci))
			clk_count.ec_count++;
		if (platform.clockintr) {
			/*
			 * Call hardclock().  This will also call
			 * statclock(). On the primary CPU, it
			 * will also deal with time-of-day stuff.
			 */
			(*platform.clockintr)((struct clockframe *)framep);

			/*
			 * If it's time to call the scheduler clock,
			 * do so.
			 */
			if ((++ci->ci_schedstate.spc_schedticks & 0x3f) == 0 &&
			    schedhz != 0)
				schedclock(ci->ci_curproc);
		}
		break;

	case ALPHA_INTR_ERROR:	/* Machine Check or Correctable Error */
		atomic_add_ulong(&ci->ci_intrdepth, 1);
		a0 = alpha_pal_rdmces();
		if (platform.mcheck_handler)
			(*platform.mcheck_handler)(a0, framep, a1, a2);
		else
			machine_check(a0, framep, a1, a2);
		atomic_sub_ulong(&ci->ci_intrdepth, 1);
		break;

	case ALPHA_INTR_DEVICE:	/* I/O device interrupt */
	    {
		struct scbvec *scb;

		KDASSERT(a1 >= SCB_IOVECBASE && a1 < SCB_SIZE);

		atomic_add_ulong(&ci->ci_intrdepth, 1);
		atomic_add_int(&uvmexp.intrs, 1);
		scb = &scb_iovectab[SCB_VECTOIDX(a1 - SCB_IOVECBASE)];
		(*scb->scb_func)(scb->scb_arg, a1);
		atomic_sub_ulong(&ci->ci_intrdepth, 1);
		break;
	    }

	case ALPHA_INTR_PERF:	/* performance counter interrupt */
		printf("WARNING: received performance counter interrupt!\n");
		break;

	case ALPHA_INTR_PASSIVE:
#if 0
		printf("WARNING: received passive release interrupt vec "
		    "0x%lx\n", a1);
#endif
		break;

	default:
		printf("unexpected interrupt: type 0x%lx vec 0x%lx "
		    "a2 0x%lx"
#if defined(MULTIPROCESSOR)
		    " cpu %lu"
#endif
		    "\n", a0, a1, a2
#if defined(MULTIPROCESSOR)
		    , ci->ci_cpuid
#endif
		    );
		panic("interrupt");
		/* NOTREACHED */
	}
}

void
machine_check(unsigned long mces, struct trapframe *framep,
    unsigned long vector, unsigned long param)
{
	const char *type;
	struct mchkinfo *mcp;

	mcp = &curcpu()->ci_mcinfo;
	/* Make sure it's an error we know about. */
	if ((mces & (ALPHA_MCES_MIP|ALPHA_MCES_SCE|ALPHA_MCES_PCE)) == 0) {
		type = "fatal machine check or error (unknown type)";
		goto fatal;
	}

	/* Machine checks. */
	if (mces & ALPHA_MCES_MIP) {
		/* If we weren't expecting it, then we punt. */
		if (!mcp->mc_expected) {
			type = "unexpected machine check";
			goto fatal;
		}
		mcp->mc_expected = 0;
		mcp->mc_received = 1;
	}

	/* System correctable errors. */
	if (mces & ALPHA_MCES_SCE)
		printf("Warning: received system correctable error.\n");

	/* Processor correctable errors. */
	if (mces & ALPHA_MCES_PCE)
		printf("Warning: received processor correctable error.\n"); 

	/* Clear pending machine checks and correctable errors */
	alpha_pal_wrmces(mces);
	return;

fatal:
	/* Clear pending machine checks and correctable errors */
	alpha_pal_wrmces(mces);

	printf("\n");
	printf("%s:\n", type);
	printf("\n");
	printf("    mces    = 0x%lx\n", mces);
	printf("    vector  = 0x%lx\n", vector);
	printf("    param   = 0x%lx\n", param);
	printf("    pc      = 0x%lx\n", framep->tf_regs[FRAME_PC]);
	printf("    ra      = 0x%lx\n", framep->tf_regs[FRAME_RA]);
	printf("    curproc = %p\n", curproc);
	if (curproc != NULL)
		printf("        pid = %d, comm = %s\n", curproc->p_p->ps_pid,
		    curproc->p_p->ps_comm);
	printf("\n");
	panic("machine check");
}

#if NAPECS > 0 || NCIA > 0 || NLCA > 0 || NTCASIC > 0

int
badaddr(void *addr, size_t size)
{
	return(badaddr_read(addr, size, NULL));
}

int
badaddr_read(void *addr, size_t size, void *rptr)
{
	struct mchkinfo *mcp = &curcpu()->ci_mcinfo;
	long rcpt;
	int rv;

	/* Get rid of any stale machine checks that have been waiting.  */
	alpha_pal_draina();

	/* Tell the trap code to expect a machine check. */
	mcp->mc_received = 0;
	mcp->mc_expected = 1;

	/* Read from the test address, and make sure the read happens. */
	alpha_mb();
	switch (size) {
	case sizeof (u_int8_t):
		rcpt = *(volatile u_int8_t *)addr;
		break;

	case sizeof (u_int16_t):
		rcpt = *(volatile u_int16_t *)addr;
		break;

	case sizeof (u_int32_t):
		rcpt = *(volatile u_int32_t *)addr;
		break;

	case sizeof (u_int64_t):
		rcpt = *(volatile u_int64_t *)addr;
		break;

	default:
		panic("badaddr: invalid size (%ld)", size);
	}
	alpha_mb();
	alpha_mb();	/* MAGIC ON SOME SYSTEMS */

	/* Make sure we took the machine check, if we caused one. */
	alpha_pal_draina();

	/* disallow further machine checks */
	mcp->mc_expected = 0;

	rv = mcp->mc_received;
	mcp->mc_received = 0;

	/*
	 * And copy back read results (if no fault occurred).
	 */
	if (rptr && rv == 0) {
		switch (size) {
		case sizeof (u_int8_t):
			*(volatile u_int8_t *)rptr = rcpt;
			break;

		case sizeof (u_int16_t):
			*(volatile u_int16_t *)rptr = rcpt;
			break;

		case sizeof (u_int32_t):
			*(volatile u_int32_t *)rptr = rcpt;
			break;

		case sizeof (u_int64_t):
			*(volatile u_int64_t *)rptr = rcpt;
			break;
		}
	}
	/* Return non-zero (i.e. true) if it's a bad address. */
	return (rv);
}

#endif	/* NAPECS > 0 || NCIA > 0 || NLCA > 0 || NTCASIC > 0 */

struct alpha_soft_intr alpha_soft_intrs[SI_NSOFT];

/*
 * softintr_init:
 *
 *	Initialize the software interrupt system.
 */
void
softintr_init()
{
	struct alpha_soft_intr *asi;
	int i;

	for (i = 0; i < SI_NSOFT; i++) {
		asi = &alpha_soft_intrs[i];
		TAILQ_INIT(&asi->softintr_q);
		mtx_init(&asi->softintr_mtx, IPL_HIGH);
		asi->softintr_siq = i;
	}
}

/*
 * softintr_dispatch:
 *
 *	Process pending software interrupts.
 */
void
softintr_dispatch()
{
	struct alpha_soft_intr *asi;
	struct alpha_soft_intrhand *sih;
	u_int64_t n, i;

#if defined(MULTIPROCESSOR)
	__mp_lock(&kernel_lock);
#endif

	while ((n = atomic_loadlatch_ulong(&ssir, 0)) != 0) {
		for (i = 0; i < SI_NSOFT; i++) {
			if ((n & (1 << i)) == 0)
				continue;
	
			asi = &alpha_soft_intrs[i];

			for (;;) {
				mtx_enter(&asi->softintr_mtx);

				sih = TAILQ_FIRST(&asi->softintr_q);
				if (sih == NULL) {
					mtx_leave(&asi->softintr_mtx);
					break;
				}
				TAILQ_REMOVE(&asi->softintr_q, sih, sih_q);
				sih->sih_pending = 0;

				atomic_add_int(&uvmexp.softs, 1);

				mtx_leave(&asi->softintr_mtx);

				(*sih->sih_fn)(sih->sih_arg);
			}
		}
	}

#if defined(MULTIPROCESSOR)
	__mp_unlock(&kernel_lock);
#endif
}

static int
ipl2si(int ipl)
{
	int si;

	switch (ipl) {
	case IPL_TTY:			/* XXX */
	case IPL_SOFTSERIAL:
		si = SI_SOFTSERIAL;
		break;
	case IPL_SOFTNET:
		si = SI_SOFTNET;
		break;
	case IPL_SOFTCLOCK:
		si = SI_SOFTCLOCK;
		break;
	case IPL_SOFT:
		si = SI_SOFT;
		break;
	default:
		panic("ipl2si: %d", ipl);
	}
	return si;
}

/*
 * softintr_establish:		[interface]
 *
 *	Register a software interrupt handler.
 */
void *
softintr_establish(int ipl, void (*func)(void *), void *arg)
{
	struct alpha_soft_intr *asi;
	struct alpha_soft_intrhand *sih;
	int si;

	si = ipl2si(ipl);
	asi = &alpha_soft_intrs[si];

	sih = malloc(sizeof(*sih), M_DEVBUF, M_NOWAIT);
	if (__predict_true(sih != NULL)) {
		sih->sih_intrhead = asi;
		sih->sih_fn = func;
		sih->sih_arg = arg;
		sih->sih_pending = 0;
	}
	return (sih);
}

/*
 * softintr_disestablish:	[interface]
 *
 *	Unregister a software interrupt handler.
 */
void
softintr_disestablish(void *arg)
{
	struct alpha_soft_intrhand *sih = arg;
	struct alpha_soft_intr *asi = sih->sih_intrhead;

	mtx_enter(&asi->softintr_mtx);
	if (sih->sih_pending) {
		TAILQ_REMOVE(&asi->softintr_q, sih, sih_q);
		sih->sih_pending = 0;
	}
	mtx_leave(&asi->softintr_mtx);

	free(sih, M_DEVBUF, sizeof *sih);
}

/*
 * Schedule a software interrupt.
*/
void
softintr_schedule(void *arg)
{
	struct alpha_soft_intrhand *sih = arg;
	struct alpha_soft_intr *si = sih->sih_intrhead;

	mtx_enter(&si->softintr_mtx);
	if (sih->sih_pending == 0) {
		TAILQ_INSERT_TAIL(&si->softintr_q, sih, sih_q);
		sih->sih_pending = 1;
		setsoft(si->softintr_siq);
	}
	mtx_leave(&si->softintr_mtx);
}

void
intr_barrier(void *cookie)
{
	sched_barrier(NULL);
}

int
splraise(int s)
{
	int cur = alpha_pal_rdps() & ALPHA_PSL_IPL_MASK;
	return (s > cur ? alpha_pal_swpipl(s) : cur);
}

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	int curipl = alpha_pal_rdps() & ALPHA_PSL_IPL_MASK;

	/*
	 * Depending on the system, hardware interrupts may occur either
	 * at level 3 or level 4. Avoid false positives in the former case.
	 */
	if (curipl == ALPHA_PSL_IPL_IO - 1)
		curipl = ALPHA_PSL_IPL_IO;

	if (curipl < wantipl) {
		splassert_fail(wantipl, curipl, func);
		/*
		 * If splassert_ctl is set to not panic, raise the ipl
		 * in a feeble attempt to reduce damage.
		 */
		alpha_pal_swpipl(wantipl);
	}
}
#endif
@


1.39
log
@Various printf claim to report the PID, so actually report that and not the TID

Build testing assistance from deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.38 2016/06/13 01:26:14 dlg Exp $ */
d351 1
a351 1
		    curproc->p_comm);
@


1.38
log
@rename _splraise to splraise

gets us a bit closer to an MI splraise api.
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.37 2015/09/13 20:37:28 kettenis Exp $ */
d350 1
a350 1
		printf("        pid = %d, comm = %s\n", curproc->p_pid,
@


1.37
log
@intr_barrier(9) for alpha.
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.36 2015/09/02 14:07:41 deraadt Exp $ */
d605 1
a605 1
_splraise(int s)
@


1.36
log
@sizes for free()
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.35 2015/05/19 20:28:14 miod Exp $ */
d596 6
@


1.35
log
@Move acquisition of the kernel lock deeper in the interrupt path, and make
sure clock interrupts do not attempt to acquire it.
This will also eventually allow for IPL_MPSAFE interrupts on alpha.

Tested by dlg@@ and I.
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.34 2014/11/18 20:51:00 krw Exp $ */
d577 1
a577 1
	free(sih, M_DEVBUF, 0);
@


1.34
log
@Nuke some obvious #include duplications.

ok espie@@ deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.33 2014/07/12 18:44:40 tedu Exp $ */
d144 1
d173 1
a264 9
#if defined(MULTIPROCESSOR)
		/*
		 * XXX Need to support IPL_MPSAFE eventually. Acquiring the
		 * XXX kernel lock could be done deeper, as most of the
		 * XXX scb handlers end up invoking
		 * XXX alpha_shared_intr_dispatch().
		 */
		__mp_lock(&kernel_lock);
#endif
a265 1

a267 3
#if defined(MULTIPROCESSOR)
		__mp_unlock(&kernel_lock);
#endif
@


1.33
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.32 2014/01/26 17:40:09 miod Exp $ */
a70 1
#include <sys/systm.h>
@


1.32
log
@Work in progress work towards SMP, heavily based upon NetBSD. The MP kernel
will boot multiuser, but will deadlock under load, and I can't find my
mistake yet.
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.31 2011/04/15 20:40:03 deraadt Exp $ */
d589 1
a589 1
	free(sih, M_DEVBUF);
@


1.31
log
@More than a decade ago, interrupt handlers on sparc started returning 0
(interrupt was not for me), 1 (positive interrupt was for me), or -1
(i am not sure...).  We have continued with this practice in as many
drivers as possible, throughout the tree.

This makes some of the architectures use that information in their
interrupt handler calling code -- if 1 is returned (and we know
this specific machine does not have edge-shared interrupts), we
finish servicing other possible handlers on the same pin.  If the
interrupt pin remains asserted (from a different device), we will
end up back in the interrupt servicing code of course... but this is
cheaper than calling all the chained interrupts on a pin.

This does of course count on shared level interrupts being properly
sorted by IPL.

There have been some concerns about starvation of drivers which
incorrectly return 1.  Those drivers should be hunted down so that
they return -1.

(other architectures will follow)

ok kettenis drahn dlg miod
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.30 2010/12/21 14:56:23 claudio Exp $ */
a86 4
#if defined(MULTIPROCESSOR)
#include <sys/device.h>
#endif

a91 2
static u_int schedclk2;

a200 1
	struct proc *p;
d207 1
a207 2
	    {
		u_long pending_ipis, bit;
d209 1
a209 16
#if 0
		printf("CPU %lu got IPI\n", cpu_id);
#endif

#ifdef DIAGNOSTIC
		if (ci->ci_dev == NULL) {
			/* XXX panic? */
			printf("WARNING: no device for ID %lu\n", ci->ci_cpuid);
			return;
		}
#endif

		pending_ipis = atomic_loadlatch_ulong(&ci->ci_ipis, 0);
		for (bit = 0; bit < ALPHA_NIPIS; bit++)
			if (pending_ipis & (1UL << bit))
				(*ipifuncs[bit])();
d218 2
a219 1
	    }
d226 3
a228 7
#if defined(MULTIPROCESSOR)
		/* XXX XXX XXX */
		if (CPU_IS_PRIMARY(ci) == 0)
			return;
#endif
		uvmexp.intrs++;
		clk_count.ec_count++;
d241 3
a243 3
			if ((++schedclk2 & 0x3f) == 0 &&
			    (p = ci->ci_curproc) != NULL && schedhz != 0)
				schedclock(p);
d248 1
d254 1
d263 1
d265 7
a271 3
		/* XXX XXX XXX */
		if (CPU_IS_PRIMARY(ci) == 0)
			return;
d273 1
a273 1
		uvmexp.intrs++;
d277 4
d485 4
d507 1
a507 1
				uvmexp.softs++;
d515 4
@


1.30
log
@Convert netisr to a normal soft interrupt instead of hanving MD code
for it. This makes the netisr a real C function which will help further
development. No noticable performance change on i386 and amd64.
With input from kettenis@@ and miod@@ additional OKs mikeb@@ and henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.29 2009/04/19 19:13:57 oga Exp $ */
d103 6
@


1.29
log
@For consistency, make sure that all archs that use the same pattern
always increment uvmexp.softs while inside the lock.

While i'm here, make alpha's dispatch loop look like the rest.

"sure" miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.28 2009/03/25 21:41:40 miod Exp $ */
a90 20
#include <net/netisr.h>
#include <net/if.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/ip_var.h>
#endif

#ifdef INET6
#ifndef INET
#include <netinet/in.h>
#endif
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#endif

#include "ppp.h"
#include "bridge.h"

a101 2
void netintr(void);

a460 22
int netisr;

void
netintr()
{
	int n;

	while ((n = netisr) != 0) {
		atomic_clearbits_int(&netisr, n);

#define	DONETISR(bit, fn)						\
		do {							\
			if (n & (1 << (bit)))				\
				fn();					\
		} while (0)

#include <net/netisr_dispatch.h>

#undef DONETISR
	}
}

a462 3
/* XXX For legacy software interrupts. */
struct alpha_soft_intrhand *softnet_intrhand;

a479 4

	/* XXX Establish legacy software interrupt handlers. */
	softnet_intrhand = softintr_establish(IPL_SOFTNET,
	    (void (*)(void *))netintr, NULL);
@


1.28
log
@Deinline softintr_schedule(). Also fix softintr priorities I got inverted after
adding splsoftassert().
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.27 2009/03/15 19:41:33 miod Exp $ */
d556 3
a558 4
				if (sih != NULL) {
					TAILQ_REMOVE(&asi->softintr_q, sih,
					    sih_q);
					sih->sih_pending = 0;
d560 4
a566 4
				if (sih == NULL)
					break;

				uvmexp.softs++;
@


1.27
log
@Now that we have splsoftassert(), make the soft ipl levels positive and
remove the special casing in splassert().
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.26 2009/03/07 15:31:42 miod Exp $ */
d524 1
a524 1
		simple_lock_init(&asi->softintr_slock);
d553 1
a553 2
				(void) alpha_pal_swpipl(ALPHA_PSL_IPL_HIGH);
				simple_lock(&asi->softintr_slock);
d562 1
a562 2
				simple_unlock(&asi->softintr_slock);
				(void) alpha_pal_swpipl(ALPHA_PSL_IPL_SOFT);
a633 1
	int s;
d635 1
a635 2
	s = splhigh();
	simple_lock(&asi->softintr_slock);
d640 1
a640 2
	simple_unlock(&asi->softintr_slock);
	splx(s);
d643 18
@


1.26
log
@No need to register a soft interrupt for softclock, it's done in MI code.
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.25 2008/06/26 05:42:08 ray Exp $ */
a661 6

	/*
	 * Tell soft interrupts apart from regular levels.
	 */
	if (wantipl < 0)
		wantipl = IPL_SOFTINT;
@


1.25
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.24 2007/06/17 10:01:25 miod Exp $ */
d508 1
a508 1
struct alpha_soft_intrhand *softnet_intrhand, *softclock_intrhand;
a530 2
	softclock_intrhand = softintr_establish(IPL_SOFTCLOCK,
	    (void (*)(void *))softclock, NULL);
@


1.24
log
@Some alpha (or SRM) designs use level 3 for i/o interrupts, instead of the
more commonly encountered level 4. Do not complain in splassert() in this case
(this is similar to the older vsbus vax machines workaround).
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.23 2007/05/29 18:10:41 miod Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.23
log
@Use atomic operations to operate on netisr, instead of clearing it at splhigh.
This changes nothing on legacy architectures, but is a bit faster (and simpler)
on the interesting ones.
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.22 2007/05/05 20:46:34 miod Exp $ */
d677 7
@


1.22
log
@Directly map IPL_xxx in terms of ALPHA_PSL_IPL_xxx values, and implement
splassert. ok art@@ martin@@
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.21 2007/04/21 21:37:09 martin Exp $ */
d495 1
a495 1
	int n, s;
d497 2
a498 4
	s = splhigh();
	n = netisr;
	netisr = 0;
	splx(s);
d501 4
a504 4
	do {								\
		if (n & (1 << (bit)))					\
			fn();						\
	} while (0)
d509 1
@


1.21
log
@fix generic soft interrupts; improve establishing and disestablishing of
soft interrupts

from NetBSD, 'reads good art@@', also tested by robert@@
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.20 2006/06/15 20:08:29 brad Exp $ */
d513 1
a513 1
struct alpha_soft_intr alpha_soft_intrs[IPL_NSOFT];
d529 1
a529 1
	for (i = 0; i < IPL_NSOFT; i++) {
d556 1
a556 1
		for (i = 0; i < IPL_NSOFT; i++) {
d592 1
d666 23
@


1.20
log
@Rework the interrupt code, shaving some cycles off in the process.
Rather than an "iointr" routine that decomposes a vector into an
IRQ, we maintain a vector table directly, hooking up each "iointr"
routine at the correct vector. This also allows us to hook device
interrupts up to specific vectors.

From thorpej NetBSD

Tested by myself and a number of end-users.
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.19 2006/02/23 20:14:13 miod Exp $ */
d531 1
a531 1
		LIST_INIT(&asi->softintr_q);
d533 1
a533 1
		asi->softintr_ipl = i;
d559 1
d562 8
a569 8
			/* Already at splsoft() */
			simple_lock(&asi->softintr_slock);

			for (sih = LIST_FIRST(&asi->softintr_q);
			     sih != NULL;
			     sih = LIST_NEXT(sih, sih_q)) {
				if (sih->sih_pending) {
					uvmexp.softs++;
a570 1
					(*sih->sih_fn)(sih->sih_arg);
d572 9
d582 8
d591 15
a605 2
			simple_unlock(&asi->softintr_slock);
		}
d607 1
d620 1
a620 1
	int s;
d622 2
a623 4
	if (__predict_false(ipl >= IPL_NSOFT || ipl < 0))
		panic("softintr_establish");

	asi = &alpha_soft_intrs[ipl];
a630 5
		s = splsoft();
		simple_lock(&asi->softintr_slock);
		LIST_INSERT_HEAD(&asi->softintr_q, sih, sih_q);
		simple_unlock(&asi->softintr_slock);
		splx(s);
d647 1
a647 3
	(void) asi;	/* XXX Unused if simple locks are noops. */

	s = splsoft();
d649 4
a652 1
	LIST_REMOVE(sih, sih_q);
@


1.19
log
@Only compile badaddr() if we have support for TurboChannel, apecs, cia or lca,
as they are the only users of badaddr(); shrinks RAMDISKB a little more.
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.18 2004/08/16 16:43:52 art Exp $ */
d127 2
d131 95
d305 5
d316 3
a318 2
		if (platform.iointr)
			(*platform.iointr)(framep, a1);
d320 1
a347 10

void
set_iointr(void (*niointr)(void *, unsigned long))
{

	if (platform.iointr)
		panic("set iointr twice");
	platform.iointr = niointr;
}

@


1.18
log
@Uninline splraise to save some time and space.

deraadt@@ ok, tested by many for a long time.
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.17 2004/07/06 21:53:59 deraadt Exp $ */
d118 5
d312 2
d393 2
@


1.17
log
@assert is dumb dumb dumb; no objection from miod
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.16 2004/06/28 02:28:42 aaron Exp $ */
d529 7
@


1.16
log
@Use new event counter API for interrupt counting on alpha.  By me, with some
edits by Theo.  deraadt@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.15 2003/11/06 21:09:34 mickey Exp $ */
a437 3

	assert(softnet_intrhand != NULL);
	assert(softclock_intrhand != NULL);
@


1.15
log
@move netisr definition into md code to allow arch provide suitable allocation; tested on most archs
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.14 2002/06/25 21:33:19 miod Exp $ */
d82 1
a92 1
#include <machine/intrcnt.h>
d120 2
d175 1
a175 1
		intrcnt[INTRCNT_CLOCK]++;
@


1.14
log
@No \n at the end of a panic() message... I thought all occurences had been
squashed already.
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.13 2001/11/06 19:53:13 miod Exp $ */
d384 2
@


1.13
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.12 2001/09/30 13:08:45 art Exp $ */
d345 1
a345 1
		panic("badaddr: invalid size (%ld)\n", size);
@


1.13.2.1
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.13 2001/11/06 19:53:13 miod Exp $ */
d345 1
a345 1
		panic("badaddr: invalid size (%ld)", size);
@


1.12
log
@Generic soft interrupts from NetBSD plus some minor cleanups.
@
text
@d1 1
a1 1
/* $OpenBSD: interrupt.c,v 1.11 2001/01/20 20:29:53 art Exp $ */
a81 2

#include <vm/vm.h>
@


1.11
log
@No need to include machine/alpha.h here.
@
text
@d1 38
a38 2
/* $OpenBSD: interrupt.c,v 1.10 2000/11/08 19:16:59 ericj Exp $ */
/* $NetBSD: interrupt.c,v 1.44 2000/05/23 05:12:53 thorpej Exp $ */
d80 2
d100 20
d122 2
d125 2
a126 3
interrupt(a0, a1, a2, framep)
	unsigned long a0, a1, a2;
	struct trapframe *framep;
d129 1
a129 3
#if defined(MULTIPROCESSOR)
	u_long cpu_id = alpha_pal_whami();
#endif
a135 1
		struct cpu_info *ci = &cpu_info[cpu_id];
d145 1
a145 1
			printf("WARNING: no device for ID %lu\n", cpu_id);
d159 1
a159 1
		if (cpu_id == hwrpb->rpb_primary_cpu_id &&
d171 1
a171 1
		if (cpu_id != hwrpb->rpb_primary_cpu_id)
d177 5
d183 7
a189 3
			if((++schedclk2 & 0x3f) == 0
			&& (p = curproc) != NULL
			&& schedhz)
d205 1
a205 1
		if (cpu_id != hwrpb->rpb_primary_cpu_id)
d232 1
a232 1
		    , cpu_id
d241 1
a241 2
set_iointr(niointr)
	void (*niointr) __P((void *, unsigned long));
d243 1
d251 2
a252 4
machine_check(mces, framep, vector, param)
	unsigned long mces;
	struct trapframe *framep;
	unsigned long vector, param;
d308 1
a308 3
badaddr(addr, size)
	void *addr;
	size_t size;
d314 1
a314 4
badaddr_read(addr, size, rptr)
	void *addr;
	size_t size;
	void *rptr;
d385 145
@


1.10
log
@add tags
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a56 1
#include <machine/alpha.h>
@


1.9
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
@


1.8
log
@alpha-specific part of ross@@netbsd's NetBSD scheduler fix.
@
text
@d1 1
a1 2
/*	$OpenBSD: interrupt.c,v 1.7 1999/01/11 05:10:59 millert Exp $	*/
/*	$NetBSD: interrupt.c,v 1.14 1996/11/13 22:20:54 cgd Exp $	*/
d29 5
d40 3
d44 5
d50 1
d52 1
d54 3
d58 1
a58 1
#ifdef EVCNT_COUNTERS
a59 2
#else
#include <machine/intrcnt.h>
a61 2
extern int schedhz;

a63 20
struct logout {
#define	LOGOUT_RETRY	0x1000000000000000	/* Retry bit. */
#define	LOGOUT_LENGTH	0xffff			/* Length mask. */
	u_int64_t q1;				/* Retry and length */
	/* Unspecified. */
};

void	interrupt __P((u_long, u_long, u_long, struct trapframe *));
void	machine_check __P((struct trapframe *, u_long, u_long));
void	nullintr __P((void *, u_long));
void	real_clockintr __P((void *, u_long));

static void	(*iointr) __P((void *, u_long)) = nullintr;
static void	(*clockintr) __P((void *, u_long)) = nullintr;
static volatile int mc_expected, mc_received;

#ifdef EVCNT_COUNTERS
struct evcnt	clock_intr_evcnt;	/* event counter for clock intrs. */
#endif

d66 1
a66 1
	u_long a0, a1, a2;
d70 28
a98 13
	if (a0 == 1) {			/* clock interrupt */
		cnt.v_intr++;
		(*clockintr)(framep, a1);
		if((++schedclk2 & 0x3f) == 0
		    && (p = curproc) != NULL
		    && schedhz)
			schedclock(p);
	} else if (a0 == 3) {		/* I/O device interrupt */
		cnt.v_intr++;
		(*iointr)(framep, a1);
	} else if (a0 == 2)		/* machine check or correctable error */
		machine_check(framep, a1, a2);
	else {
d100 2
a101 3
		 * Not expected or handled:
		 *	0	Interprocessor interrupt
		 *	4	Performance counter
d103 25
a127 4
		panic("unexpected interrupt: type 0x%lx, vec 0x%lx",
		    a0, a1);
	}
}
d129 7
a135 6
void
nullintr(framep, vec)
	void *framep;
	u_long vec;
{
}
d137 5
a141 10
void
real_clockintr(framep, vec)
	void *framep;
	u_long vec;
{

#ifdef EVCNT_COUNTERS
	clock_intr_evcnt.ev_count++;
#else
	intrcnt[INTRCNT_CLOCK]++;
d143 4
a146 2
	hardclock(framep);
}
d148 3
a150 3
void
set_clockintr()
{
d152 6
a157 2
	if (clockintr != nullintr)
		panic("set clockintr twice");
d159 14
a172 1
	clockintr = real_clockintr;
d177 1
a177 1
	void (*niointr) __P((void *, u_long));
d179 1
a179 2

	if (iointr != nullintr)
d181 2
a183 2
	iointr = niointr;
}
d186 2
a187 1
machine_check(framep, vector, param)
d189 1
a189 1
	u_long vector, param;
a190 1
	u_long mces;
d192 1
d194 3
a196 4
	mces = alpha_pal_rdmces();

	/* If not a machine check, we have no clue ho we got here. */
	if ((mces & ALPHA_MCES_MIP) == 0) {
d201 9
a209 4
	/* If we weren't expecting it, then we punt. */
	if (!mc_expected) {
		type = "unexpected machine check";
		goto fatal;
d212 7
a218 2
	mc_expected = 0;
	mc_received = 1;
d225 3
d249 10
d260 1
d266 2
a267 2
	mc_received = 0;
	mc_expected = 1;
d289 1
a289 1
		panic("badaddr: invalid size (%ld)", size);
d292 1
d298 4
a301 1
	mc_expected = 0;
d303 22
d326 1
a326 1
	return (mc_received);
@


1.8.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 2
/* $OpenBSD: interrupt.c,v 1.11 2001/01/20 20:29:53 art Exp $ */
/* $NetBSD: interrupt.c,v 1.44 2000/05/23 05:12:53 thorpej Exp $ */
a29 5
/*
 * Additional Copyright (c) 1997 by Matthew Jacob for NASA/Ames Research Center.
 * Redistribute and modify at will, leaving only this additional copyright
 * notice.
 */
a35 3
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/device.h>
a36 5
#include <vm/vm.h>

#include <uvm/uvm_extern.h>

#include <machine/atomic.h>
a37 1
#include <machine/cpu.h>
a38 1
#include <machine/rpb.h>
a39 2
#include <machine/cpuconf.h>
#include <machine/intrcnt.h>
d41 1
a41 1
#if defined(MULTIPROCESSOR)
d43 2
d47 2
d51 20
d73 1
a73 1
	unsigned long a0, a1, a2;
a76 4
#if defined(MULTIPROCESSOR)
	u_long cpu_id = alpha_pal_whami();
#endif
	extern int schedhz;
d78 22
a99 6
	switch (a0) {
	case ALPHA_INTR_XPROC:	/* interprocessor interrupt */
#if defined(MULTIPROCESSOR)
	    {
		struct cpu_info *ci = &cpu_info[cpu_id];
		u_long pending_ipis, bit;
d101 6
a106 3
#if 0
		printf("CPU %lu got IPI\n", cpu_id);
#endif
d108 5
a112 12
#ifdef DIAGNOSTIC
		if (ci->ci_dev == NULL) {
			/* XXX panic? */
			printf("WARNING: no device for ID %lu\n", cpu_id);
			return;
		}
#endif

		pending_ipis = atomic_loadlatch_ulong(&ci->ci_ipis, 0);
		for (bit = 0; bit < ALPHA_NIPIS; bit++)
			if (pending_ipis & (1UL << bit))
				(*ipifuncs[bit])();
d114 2
a115 8
		/*
		 * Handle inter-console messages if we're the primary
		 * CPU.
		 */
		if (cpu_id == hwrpb->rpb_primary_cpu_id &&
		    hwrpb->rpb_txrdy != 0)
			cpu_iccb_receive();
	    }
d117 1
a117 9
		printf("WARNING: received interprocessor interrupt!\n");
#endif /* MULTIPROCESSOR */
		break;
		
	case ALPHA_INTR_CLOCK:	/* clock interrupt */
#if defined(MULTIPROCESSOR)
		/* XXX XXX XXX */
		if (cpu_id != hwrpb->rpb_primary_cpu_id)
			return;
d119 2
a120 10
		uvmexp.intrs++;
		intrcnt[INTRCNT_CLOCK]++;
		if (platform.clockintr) {
			(*platform.clockintr)((struct clockframe *)framep);
			if((++schedclk2 & 0x3f) == 0
			&& (p = curproc) != NULL
			&& schedhz)
				schedclock(p);
		}
		break;
d122 3
a124 18
	case ALPHA_INTR_ERROR:	/* Machine Check or Correctable Error */
		a0 = alpha_pal_rdmces();
		if (platform.mcheck_handler)
			(*platform.mcheck_handler)(a0, framep, a1, a2);
		else
			machine_check(a0, framep, a1, a2);
		break;

	case ALPHA_INTR_DEVICE:	/* I/O device interrupt */
#if defined(MULTIPROCESSOR)
		/* XXX XXX XXX */
		if (cpu_id != hwrpb->rpb_primary_cpu_id)
			return;
#endif
		uvmexp.intrs++;
		if (platform.iointr)
			(*platform.iointr)(framep, a1);
		break;
d126 2
a127 3
	case ALPHA_INTR_PERF:	/* performance counter interrupt */
		printf("WARNING: received performance counter interrupt!\n");
		break;
d129 1
a129 21
	case ALPHA_INTR_PASSIVE:
#if 0
		printf("WARNING: received passive release interrupt vec "
		    "0x%lx\n", a1);
#endif
		break;

	default:
		printf("unexpected interrupt: type 0x%lx vec 0x%lx "
		    "a2 0x%lx"
#if defined(MULTIPROCESSOR)
		    " cpu %lu"
#endif
		    "\n", a0, a1, a2
#if defined(MULTIPROCESSOR)
		    , cpu_id
#endif
		    );
		panic("interrupt");
		/* NOTREACHED */
	}
d134 1
a134 1
	void (*niointr) __P((void *, unsigned long));
d136 2
a137 1
	if (platform.iointr)
d139 2
a140 1
	platform.iointr = niointr;
a142 1

d144 1
a144 2
machine_check(mces, framep, vector, param)
	unsigned long mces;
d146 1
a146 1
	unsigned long vector, param;
d148 1
a149 1
	struct mchkinfo *mcp;
d151 4
a154 3
	mcp = &curcpu()->ci_mcinfo;
	/* Make sure it's an error we know about. */
	if ((mces & (ALPHA_MCES_MIP|ALPHA_MCES_SCE|ALPHA_MCES_PCE)) == 0) {
d159 4
a162 9
	/* Machine checks. */
	if (mces & ALPHA_MCES_MIP) {
		/* If we weren't expecting it, then we punt. */
		if (!mcp->mc_expected) {
			type = "unexpected machine check";
			goto fatal;
		}
		mcp->mc_expected = 0;
		mcp->mc_received = 1;
d165 2
a166 7
	/* System correctable errors. */
	if (mces & ALPHA_MCES_SCE)
		printf("Warning: received system correctable error.\n");

	/* Processor correctable errors. */
	if (mces & ALPHA_MCES_PCE)
		printf("Warning: received processor correctable error.\n"); 
a172 3
	/* Clear pending machine checks and correctable errors */
	alpha_pal_wrmces(mces);

a193 10
	return(badaddr_read(addr, size, NULL));
}

int
badaddr_read(addr, size, rptr)
	void *addr;
	size_t size;
	void *rptr;
{
	struct mchkinfo *mcp = &curcpu()->ci_mcinfo;
a194 1
	int rv;
d200 2
a201 2
	mcp->mc_received = 0;
	mcp->mc_expected = 1;
d223 1
a223 1
		panic("badaddr: invalid size (%ld)\n", size);
a225 1
	alpha_mb();	/* MAGIC ON SOME SYSTEMS */
d231 1
a231 4
	mcp->mc_expected = 0;

	rv = mcp->mc_received;
	mcp->mc_received = 0;
a232 22
	/*
	 * And copy back read results (if no fault occurred).
	 */
	if (rptr && rv == 0) {
		switch (size) {
		case sizeof (u_int8_t):
			*(volatile u_int8_t *)rptr = rcpt;
			break;

		case sizeof (u_int16_t):
			*(volatile u_int16_t *)rptr = rcpt;
			break;

		case sizeof (u_int32_t):
			*(volatile u_int32_t *)rptr = rcpt;
			break;

		case sizeof (u_int64_t):
			*(volatile u_int64_t *)rptr = rcpt;
			break;
		}
	}
d234 1
a234 1
	return (rv);
@


1.8.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 38
/* $OpenBSD: interrupt.c,v 1.8.4.1 2001/04/18 16:00:21 niklas Exp $ */
/* $NetBSD: interrupt.c,v 1.46 2000/06/03 20:47:36 thorpej Exp $ */

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
a43 2
#include <sys/mbuf.h>
#include <sys/socket.h>
a61 20
#include <net/netisr.h>
#include <net/if.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/ip_var.h>
#endif

#ifdef INET6
#ifndef INET
#include <netinet/in.h>
#endif
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#endif

#include "ppp.h"
#include "bridge.h"

a63 2
void netintr(void);

d65 3
a67 2
interrupt(unsigned long a0, unsigned long a1, unsigned long a2,
    struct trapframe *framep)
d70 3
a72 1
	struct cpu_info *ci = curcpu();
d79 1
d89 1
a89 1
			printf("WARNING: no device for ID %lu\n", ci->ci_cpuid);
d103 1
a103 1
		if (ci->ci_cpuid == hwrpb->rpb_primary_cpu_id &&
d115 1
a115 1
		if (CPU_IS_PRIMARY(ci) == 0)
a120 5
			/*
			 * Call hardclock().  This will also call
			 * statclock(). On the primary CPU, it
			 * will also deal with time-of-day stuff.
			 */
d122 3
a124 7

			/*
			 * If it's time to call the scheduler clock,
			 * do so.
			 */
			if ((++schedclk2 & 0x3f) == 0 &&
			    (p = ci->ci_curproc) != NULL && schedhz != 0)
d140 1
a140 1
		if (CPU_IS_PRIMARY(ci) == 0)
d167 1
a167 1
		    , ci->ci_cpuid
d176 2
a177 1
set_iointr(void (*niointr)(void *, unsigned long))
a178 1

d186 4
a189 2
machine_check(unsigned long mces, struct trapframe *framep,
    unsigned long vector, unsigned long param)
d245 3
a247 1
badaddr(void *addr, size_t size)
d253 4
a256 1
badaddr_read(void *addr, size_t size, void *rptr)
a326 145
}

void
netintr()
{
	int n, s;

	s = splhigh();
	n = netisr;
	netisr = 0;
	splx(s);

#define	DONETISR(bit, fn)						\
	do {								\
		if (n & (1 << (bit)))					\
			fn();						\
	} while (0)

#include <net/netisr_dispatch.h>

#undef DONETISR
}

struct alpha_soft_intr alpha_soft_intrs[IPL_NSOFT];

/* XXX For legacy software interrupts. */
struct alpha_soft_intrhand *softnet_intrhand, *softclock_intrhand;

/*
 * softintr_init:
 *
 *	Initialize the software interrupt system.
 */
void
softintr_init()
{
	struct alpha_soft_intr *asi;
	int i;

	for (i = 0; i < IPL_NSOFT; i++) {
		asi = &alpha_soft_intrs[i];
		LIST_INIT(&asi->softintr_q);
		simple_lock_init(&asi->softintr_slock);
		asi->softintr_ipl = i;
	}

	/* XXX Establish legacy software interrupt handlers. */
	softnet_intrhand = softintr_establish(IPL_SOFTNET,
	    (void (*)(void *))netintr, NULL);
	softclock_intrhand = softintr_establish(IPL_SOFTCLOCK,
	    (void (*)(void *))softclock, NULL);

	assert(softnet_intrhand != NULL);
	assert(softclock_intrhand != NULL);
}

/*
 * softintr_dispatch:
 *
 *	Process pending software interrupts.
 */
void
softintr_dispatch()
{
	struct alpha_soft_intr *asi;
	struct alpha_soft_intrhand *sih;
	u_int64_t n, i;

	while ((n = atomic_loadlatch_ulong(&ssir, 0)) != 0) {
		for (i = 0; i < IPL_NSOFT; i++) {
			if ((n & (1 << i)) == 0)
				continue;
			asi = &alpha_soft_intrs[i];

			/* Already at splsoft() */
			simple_lock(&asi->softintr_slock);

			for (sih = LIST_FIRST(&asi->softintr_q);
			     sih != NULL;
			     sih = LIST_NEXT(sih, sih_q)) {
				if (sih->sih_pending) {
					uvmexp.softs++;
					sih->sih_pending = 0;
					(*sih->sih_fn)(sih->sih_arg);
				}
			}

			simple_unlock(&asi->softintr_slock);
		}
	}
}

/*
 * softintr_establish:		[interface]
 *
 *	Register a software interrupt handler.
 */
void *
softintr_establish(int ipl, void (*func)(void *), void *arg)
{
	struct alpha_soft_intr *asi;
	struct alpha_soft_intrhand *sih;
	int s;

	if (__predict_false(ipl >= IPL_NSOFT || ipl < 0))
		panic("softintr_establish");

	asi = &alpha_soft_intrs[ipl];

	sih = malloc(sizeof(*sih), M_DEVBUF, M_NOWAIT);
	if (__predict_true(sih != NULL)) {
		sih->sih_intrhead = asi;
		sih->sih_fn = func;
		sih->sih_arg = arg;
		sih->sih_pending = 0;
		s = splsoft();
		simple_lock(&asi->softintr_slock);
		LIST_INSERT_HEAD(&asi->softintr_q, sih, sih_q);
		simple_unlock(&asi->softintr_slock);
		splx(s);
	}
	return (sih);
}

/*
 * softintr_disestablish:	[interface]
 *
 *	Unregister a software interrupt handler.
 */
void
softintr_disestablish(void *arg)
{
	struct alpha_soft_intrhand *sih = arg;
	struct alpha_soft_intr *asi = sih->sih_intrhead;
	int s;

	(void) asi;	/* XXX Unused if simple locks are noops. */

	s = splsoft();
	simple_lock(&asi->softintr_slock);
	LIST_REMOVE(sih, sih_q);
	simple_unlock(&asi->softintr_slock);
	splx(s);

	free(sih, M_DEVBUF);
@


1.8.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d82 2
@


1.8.4.4
log
@Sync the SMP branch with 3.3
@
text
@d345 1
a345 1
		panic("badaddr: invalid size (%ld)", size);
@


1.8.4.5
log
@Merge of -current from two weeks ago into the SMP branch
@
text
@a384 2
int netisr;

@


1.7
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: interrupt.c,v 1.6 1997/01/24 19:56:34 niklas Exp $	*/
d35 1
d47 4
d76 1
d81 4
@


1.6
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: interrupt.c,v 1.5 1996/10/30 22:38:12 niklas Exp $	*/
d86 1
a86 1
		panic("unexpected interrupt: type 0x%lx, vec 0x%lx\n",
d213 1
a213 1
		panic("badaddr: invalid size (%ld)\n", size);
@


1.5
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 2
a2 2
/*	$OpenBSD: interrupt.c,v 1.12 1996/10/13 19:57:49 cgd Exp $	*/
/*	$NetBSD: interrupt.c,v 1.12 1996/10/13 19:57:49 cgd Exp $	*/
d5 1
a5 1
 * Copyright (c) 1994, 1995 Carnegie-Mellon University.
d53 4
a56 4
void		interrupt __P((u_long, u_long, u_long, struct trapframe *));
void		machine_check __P((struct trapframe *, u_long, u_long));
void		real_clockintr __P((void *, u_long));
void		nullintr __P((void *, u_long));
@


1.4
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: interrupt.c,v 1.5 1996/04/23 13:54:32 cgd Exp $	*/
/*	$NetBSD: interrupt.c,v 1.5 1996/04/23 13:54:32 cgd Exp $	*/
d38 1
d53 8
a60 7
void		machine_check __P((struct trapframe *, struct logout *,
		    u_int64_t));
static void	nullintr __P((void *, int));

static void	(*iointr) __P((void *, int)) = nullintr;
static void	(*clockintr) __P((void *, int)) = nullintr;
static int	mc_expected, mc_received;
d67 2
a68 1
interrupt(framep, type, vec, logoutp)
a69 2
	u_int64_t type, vec;
	struct logout *logoutp;
d72 17
a88 9
	if (type == 1)			/* clock interrupt */
		(*clockintr)(framep, vec);
	else if (type == 3)		/* I/O device interrupt */
		(*iointr)(framep, vec);
	else if (type == 2)
		machine_check(framep, logoutp, vec);
	else
		panic("unexpected interrupt: type %ld, vec %ld\n",
		    (long)type, (long)vec);
d91 1
a91 1
static void
d94 1
a94 1
	int vec;
d98 1
a98 1
static void
d101 1
a101 1
	int vec;
d124 1
a124 1
	void (*niointr) __P((void *, int));
d134 1
a134 1
machine_check(framep, logoutp, vec)
d136 1
a136 2
	struct logout *logoutp;
	u_int64_t vec;
d138 2
d141 13
a153 3
	if (!mc_expected)
		panic("machine check: vec 0x%lx, pc = 0x%lx, ra = 0x%lx",
		    vec, framep->tf_pc, framep->tf_regs[FRAME_RA]);
d158 19
a176 2
	logoutp->q1 &= ~LOGOUT_RETRY;		/* XXX: Necessary? */
	pal_mtpr_mces(0x19);			/* XXX: VMS PAL! */
d182 1
a182 1
	u_int64_t size;
d184 4
a187 2
	int rv;
	volatile long rcpt;
d194 1
a194 1
	wbflush();
d197 1
a197 1
		rcpt = *(u_int8_t *)addr;
d201 1
a201 1
		rcpt = *(u_int16_t *)addr;
d205 1
a205 1
		rcpt = *(u_int32_t *)addr;
d209 1
a209 1
		rcpt = *(u_int64_t *)addr;
d215 4
a218 2
	wbflush();
	pal_draina();
@


1.3
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.2
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: interrupt.c,v 1.4 1995/11/23 02:34:08 cgd Exp $	*/
d131 1
a131 1
		panic("machine check: vec %lx, pc = 0x%lx, ra = 0x%lx",
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: interrupt.c,v 1.3 1995/08/03 00:54:28 cgd Exp $	*/
d38 6
d59 4
d88 14
d103 1
a103 2
set_clockintr(nclockintr)
	void (*nclockintr) __P((struct clockframe *));
d109 1
a109 1
	clockintr = (void (*) __P((void *, int)))nclockintr;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
