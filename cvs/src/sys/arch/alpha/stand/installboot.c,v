head	1.19;
access;
symbols
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.10
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.6
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.8
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.17.0.6
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.16.0.8
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.6
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.4
	OPENBSD_5_0:1.16.0.2
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.12
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.8
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.6
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.4
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.13.0.8
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.6
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.12.0.8
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.10.0.22
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.20
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.18
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.10.0.16
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.14
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.12
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.10
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.8
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.6
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.4
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.19
date	2014.07.12.19.01.49;	author tedu;	state Exp;
branches;
next	1.18;
commitid	oZu656PKSRXbpZyM;

1.18
date	2014.07.12.18.44.40;	author tedu;	state Exp;
branches;
next	1.17;
commitid	uKVPYMN2MLxdZxzH;

1.17
date	2013.06.11.16.42.06;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2011.03.13.00.13.51;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.24.08.52.13;	author jasper;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.06.17.15.11;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2005.08.01.05.01.35;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.08.25.23.27.43;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.27;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.10.27.16.52.03;	author millert;	state Exp;
branches
	1.10.12.1
	1.10.22.1;
next	1.9;

1.9
date	97.06.27.02.26.30;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.05.20.05.41.30;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.05.05.06.01.48;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.04.09.05.09.35;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.01.15.23.41.48;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.10.30.22.40.31;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.07.29.23.01.22;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.26.18.15.34;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.14.03.53.49;	author deraadt;	state Exp;
branches;
next	;

1.10.12.1
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	1.10.12.2;

1.10.12.2
date	2004.02.19.09.59.34;	author niklas;	state Exp;
branches;
next	;

1.10.22.1
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	;


desc
@@


1.19
log
@revert bogus free changes in not kernel files. got a little trigger happy.
@
text
@/*	$OpenBSD: installboot.c,v 1.18 2014/07/12 18:44:40 tedu Exp $	*/
/*	$NetBSD: installboot.c,v 1.2 1997/04/06 08:41:12 cgd Exp $	*/

/*
 * Copyright (c) 1997 Christopher G. Demetriou.  All rights reserved.
 * Copyright (c) 1994 Paul Kranenburg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Paul Kranenburg.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/mount.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/sysctl.h>
#include <ufs/ufs/dinode.h>
#include <ufs/ufs/dir.h>
#include <ufs/ffs/fs.h>
#include <sys/disklabel.h>
#include <sys/dkio.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

#include "bbinfo.h"

#ifndef	ISO_DEFAULT_BLOCK_SIZE
#define	ISO_DEFAULT_BLOCK_SIZE	2048
#endif

int	verbose, nowrite, hflag;
char	*boot, *proto, *dev;

struct bbinfoloc *bbinfolocp;
struct bbinfo *bbinfop;
int	max_block_count;


char		*loadprotoblocks(char *, long *);
int		loadblocknums(char *, int, unsigned long);
static void	devread(int, void *, daddr32_t, size_t, char *);
static void	usage(void);
int		main(int, char *[]);

int	isofsblk = 0;
int	isofseblk = 0;

static void
usage(void)
{
	(void)fprintf(stderr,
	    "usage: installboot [-n] [-v] [-s isofsblk -e isofseblk] "
	    "<boot> <proto> <device>\n");
	exit(1);
}

int
main(int argc, char *argv[])
{
	int	c, devfd;
	char	*protostore;
	long	protosize;
	struct stat disksb, bootsb;
	struct disklabel dl;
	daddr_t partoffset;
#define BBPAD   0x1e0
	struct bb {
		char	bb_pad[BBPAD];	/* disklabel lives in here, actually */
		long	bb_secsize;	/* size of secondary boot block */
		long	bb_secstart;	/* start of secondary boot block */
		long	bb_flags;	/* unknown; always zero */
		long	bb_cksum;	/* checksum of the boot block, as longs. */
	} bb;
	long *lp, *ep;

	while ((c = getopt(argc, argv, "vns:e:")) != -1) {
		switch (c) {
		case 'n':
			/* Do not actually write the bootblock to disk */
			nowrite = 1;
			break;
		case 'v':
			/* Chat */
			verbose = 1;
			break;
		case 's':
			isofsblk = atoi(optarg);
			break;
		case 'e':
			isofseblk = atoi(optarg);
			break;
		default:
			usage();
		}
	}

	if (argc - optind < 3)
		usage();

	boot = argv[optind];
	proto = argv[optind + 1];
	dev = argv[optind + 2];

	if (verbose) {
		(void)printf("boot: %s\n", boot);
		(void)printf("proto: %s\n", proto);
		(void)printf("device: %s\n", dev);
	}

	/* Load proto blocks into core */
	if ((protostore = loadprotoblocks(proto, &protosize)) == NULL)
		exit(1);

	/* Open and check raw disk device */
	if ((devfd = opendev(dev, O_RDONLY, OPENDEV_PART, &dev)) < 0)
		err(1, "open: %s", dev);
	if (fstat(devfd, &disksb) == -1)
		err(1, "fstat: %s", dev);
	if (!S_ISCHR(disksb.st_mode))
		errx(1, "%s must be a character device node", dev);
	if ((minor(disksb.st_rdev) % getmaxpartitions()) != getrawpartition())
		errx(1, "%s must be the raw partition", dev);

	/* Extract and load block numbers */
	if (stat(boot, &bootsb) == -1)
		err(1, "stat: %s", boot);
	if (!S_ISREG(bootsb.st_mode))
		errx(1, "%s must be a regular file", boot);
	if ((minor(disksb.st_rdev) / getmaxpartitions()) !=
	    (minor(bootsb.st_dev) / getmaxpartitions()))
		errx(1, "%s must be somewhere on %s", boot, dev);

	/*
	 * Find the offset of the secondary boot block's partition
	 * into the disk.  If disklabels not supported, assume zero.
	 */
	if (ioctl(devfd, DIOCGDINFO, &dl) != -1) {
		partoffset = DL_GETPOFFSET(&dl.d_partitions[minor(bootsb.st_dev) %
		    getmaxpartitions()]);
	} else {
		if (errno != ENOTTY)
			err(1, "read disklabel: %s", dev);
		warnx("couldn't read label from %s, using part offset of 0",
		    dev);
		partoffset = 0;
	}
	if (verbose)
		(void)printf("%s partition offset = 0x%llx\n", boot, partoffset);

	/* Sync filesystems (make sure boot's block numbers are stable) */
	sync();
	sleep(2);
	sync();
	sleep(2);

	if (loadblocknums(boot, devfd, partoffset) != 0)
		exit(1);

	(void)close(devfd);

	if (nowrite)
		return 0;

#if 0
	/* Write patched proto bootblocks into the superblock */
	if (protosize > SBSIZE - DEV_BSIZE)
		errx(1, "proto bootblocks too big");
#endif

	if ((devfd = opendev(dev, O_RDWR, OPENDEV_PART, &dev)) < 0)
		err(1, "open: %s", dev);

	if (lseek(devfd, DEV_BSIZE, SEEK_SET) != DEV_BSIZE)
		err(1, "lseek bootstrap");

	if (write(devfd, protostore, protosize) != protosize)
		err(1, "write bootstrap");

	if (lseek(devfd, 0, SEEK_SET) != 0)
		err(1, "lseek label");

	if (read(devfd, &bb, sizeof (bb)) != sizeof (bb))
		err(1, "read label");

	bb.bb_secsize = 15;
	bb.bb_secstart = 1;
	bb.bb_flags = 0;
	bb.bb_cksum = 0;

	for (lp = (long *)&bb, ep = &bb.bb_cksum; lp < ep; lp++)
		bb.bb_cksum += *lp;

	if (lseek(devfd, 0, SEEK_SET) != 0)
		err(1, "lseek label 2");

	if (write(devfd, &bb, sizeof bb) != sizeof bb)
		err(1, "write label ");

	(void)close(devfd);
	return 0;
}

char *
loadprotoblocks(char *fname, long *size)
{
	int	fd, sz;
	char	*bp;
	struct	stat statbuf;
	u_int64_t *matchp;

	/*
	 * Read the prototype boot block into memory.
	 */
	if ((fd = open(fname, O_RDONLY)) < 0) {
		warn("open: %s", fname);
		return NULL;
	}
	if (fstat(fd, &statbuf) != 0) {
		warn("fstat: %s", fname);
		close(fd);
		return NULL;
	}
	sz = roundup(statbuf.st_size, DEV_BSIZE);
	if ((bp = calloc(sz, 1)) == NULL) {
		warnx("malloc: %s: no memory", fname);
		close(fd);
		return NULL;
	}
	if (read(fd, bp, statbuf.st_size) != statbuf.st_size) {
		warn("read: %s", fname);
		free(bp);
		close(fd);
		return NULL;
	}
	close(fd);

	/*
	 * Find the magic area of the program, and figure out where
	 * the 'blocks' struct is, from that.
	 */
	bbinfolocp = NULL;
	for (matchp = (u_int64_t *)bp; (char *)matchp < bp + sz; matchp++) {
		if (*matchp != 0xbabefacedeadbeef)
			continue;
		bbinfolocp = (struct bbinfoloc *)matchp;
		if (bbinfolocp->magic1 == 0xbabefacedeadbeef &&
		    bbinfolocp->magic2 == 0xdeadbeeffacebabe)
			break;
		bbinfolocp = NULL;
	}

	if (bbinfolocp == NULL) {
		warnx("%s: not a valid boot block?", fname);
		return NULL;
	}

	bbinfop = (struct bbinfo *)(bp + bbinfolocp->end - bbinfolocp->start);
	memset(bbinfop, 0, sz - (bbinfolocp->end - bbinfolocp->start));
	max_block_count =
	    ((char *)bbinfop->blocks - bp) / sizeof (bbinfop->blocks[0]);

	if (verbose) {
		(void)printf("boot block info locator at offset 0x%x\n",
			(char *)bbinfolocp - bp);
		(void)printf("boot block info at offset 0x%x\n",
			(char *)bbinfop - bp);
		(void)printf("max number of blocks: %d\n", max_block_count);
	}

	*size = sz;
	return (bp);
}

static void
devread(int fd, void *buf, daddr32_t blk, size_t size, char *msg)
{
	if (lseek(fd, dbtob(blk), SEEK_SET) != dbtob(blk))
		err(1, "%s: devread: lseek", msg);

	if (read(fd, buf, size) != size)
		err(1, "%s: devread: read", msg);
}

static char sblock[SBSIZE];

int
loadblocknums(char *boot, int devfd, unsigned long partoffset)
{
	int		i, fd, ndb;
	struct	stat	statbuf;
	struct	statfs	statfsbuf;
	struct fs	*fs;
	char		*buf;
	daddr32_t	blk, *ap;
	struct ufs1_dinode	*ip;
	int32_t		cksum;

	/*
	 * Open 2nd-level boot program and record the block numbers
	 * it occupies on the filesystem represented by `devfd'.
	 */
	if ((fd = open(boot, O_RDONLY)) < 0)
		err(1, "open: %s", boot);

	if (fstatfs(fd, &statfsbuf) != 0)
		err(1, "statfs: %s", boot);

	if (isofsblk) {
		bbinfop->bsize = ISO_DEFAULT_BLOCK_SIZE;
		bbinfop->nblocks = isofseblk - isofsblk + 1;
		if (bbinfop->nblocks > max_block_count)
			errx(1, "%s: Too many blocks", boot);
		if (verbose)
			(void)printf("%s: starting block %d (%d total):\n\t",
			    boot, isofsblk, bbinfop->nblocks);
		for (i = 0; i < bbinfop->nblocks; i++) {
			blk = (isofsblk + i) * (bbinfop->bsize / DEV_BSIZE);
			bbinfop->blocks[i] = blk;
			if (verbose)
				(void)printf("%d ", blk);
		}
		if (verbose)
			(void)printf("\n");

		cksum = 0;
		for (i = 0; i < bbinfop->nblocks +
		    (sizeof(*bbinfop) / sizeof(bbinfop->blocks[0])) - 1; i++)
			cksum += ((int32_t *)bbinfop)[i];
		bbinfop->cksum = -cksum;

		return 0;
	}

	if (strncmp(statfsbuf.f_fstypename, MOUNT_FFS, MFSNAMELEN))
		errx(1, "%s: must be on a FFS filesystem", boot);

	if (fsync(fd) != 0)
		err(1, "fsync: %s", boot);

	if (fstat(fd, &statbuf) != 0)
		err(1, "fstat: %s", boot);

	close(fd);

	/* Read superblock */
	devread(devfd, sblock, btodb(SBOFF) + partoffset, SBSIZE,
	    "superblock");
	fs = (struct fs *)sblock;

	/* Read inode */
	if ((buf = malloc(fs->fs_bsize)) == NULL)
		errx(1, "No memory for filesystem block");

	blk = fsbtodb(fs, ino_to_fsba(fs, statbuf.st_ino));
	devread(devfd, buf, blk + partoffset, fs->fs_bsize, "inode");
	ip = (struct ufs1_dinode *)(buf) + ino_to_fsbo(fs, statbuf.st_ino);

	/*
	 * Register filesystem block size.
	 */
	bbinfop->bsize = fs->fs_bsize;

	/*
	 * Get the block numbers; we don't handle fragments
	 */
	ndb = howmany(ip->di_size, fs->fs_bsize);
	if (ndb > max_block_count)
		errx(1, "%s: Too many blocks", boot);

	/*
	 * Register block count.
	 */
	bbinfop->nblocks = ndb;

	if (verbose)
		(void)printf("%s: block numbers: ", boot);
	ap = ip->di_db;
	for (i = 0; i < NDADDR && *ap && ndb; i++, ap++, ndb--) {
		blk = fsbtodb(fs, *ap);
		bbinfop->blocks[i] = blk + partoffset;
		if (verbose)
			(void)printf("%d ", bbinfop->blocks[i]);
	}
	if (verbose)
		(void)printf("\n");

	if (ndb == 0)
		goto checksum;

	/*
	 * Just one level of indirections; there isn't much room
	 * for more in the 1st-level bootblocks anyway.
	 */
	if (verbose)
		(void)printf("%s: block numbers (indirect): ", boot);
	blk = ip->di_ib[0];
	devread(devfd, buf, blk + partoffset, fs->fs_bsize,
	    "indirect block");
	ap = (daddr32_t *)buf;
	for (; i < NINDIR(fs) && *ap && ndb; i++, ap++, ndb--) {
		blk = fsbtodb(fs, *ap);
		bbinfop->blocks[i] = blk + partoffset;
		if (verbose)
			(void)printf("%d ", bbinfop->blocks[i]);
	}
	if (verbose)
		(void)printf("\n");

	if (ndb)
		errx(1, "%s: Too many blocks", boot);

checksum:
	cksum = 0;
	for (i = 0; i < bbinfop->nblocks +
	    (sizeof (*bbinfop) / sizeof (bbinfop->blocks[0])) - 1; i++)
		cksum += ((int32_t *)bbinfop)[i];
	bbinfop->cksum = -cksum;

	return 0;
}
@


1.18
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.17 2013/06/11 16:42:06 deraadt Exp $	*/
d261 1
a261 1
		free(bp, 0);
@


1.17
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.16 2011/03/13 00:13:51 deraadt Exp $	*/
d261 1
a261 1
		free(bp);
@


1.16
log
@Change daddr_t to daddr32_t.  The bootblocks on our architectures only
do 32-bit block spanning.  If later on we get some that can/should do
64-bit, that can be done now using daddr64_t (but of course, we are taking
this step to finalize the daddr_t 64-bit conversion).
ok miod krw
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.15 2009/08/24 08:52:13 jasper Exp $	*/
d95 1
a95 1
	daddr64_t partoffset;
@


1.15
log
@- fix format strings for values that are daddr64_t

ok otto@@, agreed by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.14 2007/06/06 17:15:11 deraadt Exp $	*/
d71 1
a71 1
static void	devread(int, void *, daddr_t, size_t, char *);
d305 1
a305 1
devread(int fd, void *buf, daddr_t blk, size_t size, char *msg)
d324 1
a324 1
	daddr_t		blk, *ap;
d429 1
a429 1
	ap = (daddr_t *)buf;
@


1.14
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.13 2005/08/01 05:01:35 deraadt Exp $	*/
d178 1
a178 1
		(void)printf("%s partition offset = 0x%lx\n", boot, partoffset);
@


1.13
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.12 2003/08/25 23:27:43 tedu Exp $	*/
d95 1
a95 1
	unsigned long partoffset;
d168 2
a169 2
		partoffset = dl.d_partitions[minor(bootsb.st_dev) %
		    getmaxpartitions()].p_offset;
@


1.12
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.11 2002/03/14 01:26:27 millert Exp $	*/
d73 1
a73 1
int 		main(int, char *[]);
d79 1
a79 1
usage()
d82 2
a83 2
		"usage: installboot [-n] [-v] [-s isofsblk -e isofseblk] "
		"<boot> <proto> <device>\n");
d88 1
a88 3
main(argc, argv)
	int argc;
	char *argv[];
d90 1
a90 2
	int	c;
	int	devfd;
d96 9
d155 1
a155 1
	if (stat(boot, &bootsb) == -1)	
d159 1
a159 1
	if ((minor(disksb.st_rdev) / getmaxpartitions()) != 
a208 12
	{

#define BBPAD   0x1e0
	struct bb {
		char    bb_pad[BBPAD];  /* disklabel lives in here, actually */
		long    bb_secsize;     /* size of secondary boot block */
		long    bb_secstart;    /* start of secondary boot block */
		long    bb_flags;       /* unknown; always zero */
		long    bb_cksum;       /* checksum of the boot block, as longs. */
	} bb;
	long *lp, *ep;

d212 1
a212 1
	if (read(devfd, &bb, sizeof (bb)) != sizeof (bb)) 
d215 4
a218 4
        bb.bb_secsize = 15;
        bb.bb_secstart = 1;
        bb.bb_flags = 0;
        bb.bb_cksum = 0;
d220 2
a221 2
        for (lp = (long *)&bb, ep = &bb.bb_cksum; lp < ep; lp++)
                bb.bb_cksum += *lp;
d226 1
a226 1
        if (write(devfd, &bb, sizeof bb) != sizeof bb)
a227 1
	}
d234 1
a234 3
loadprotoblocks(fname, size)
	char *fname;
	long *size;
d287 1
a287 1
	bbinfop = (struct bbinfo *)(bp + bbinfolocp->end - bbinfolocp->start);	
d305 1
a305 6
devread(fd, buf, blk, size, msg)
	int	fd;
	void	*buf;
	daddr_t	blk;
	size_t	size;
	char	*msg;
d317 1
a317 4
loadblocknums(boot, devfd, partoffset)
	char	*boot;
	int	devfd;
	unsigned long partoffset;
d319 1
a319 1
	int		i, fd;
a325 1
	int		ndb;
d445 1
a445 1
	    (sizeof (*bbinfop) / sizeof (bbinfop->blocks[0])) - 1; i++) {
a446 1
	}
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.10 1997/10/27 16:52:03 millert Exp $	*/
d342 1
a342 1
	struct dinode	*ip;
d404 1
a404 1
	ip = (struct dinode *)(buf) + ino_to_fsbo(fs, statbuf.st_ino);
@


1.10
log
@Use opendev()
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.9 1997/06/27 02:26:30 millert Exp $	*/
d69 5
a73 5
char		*loadprotoblocks __P((char *, long *));
int		loadblocknums __P((char *, int, unsigned long));
static void	devread __P((int, void *, daddr_t, size_t, char *));
static void	usage __P((void));
int 		main __P((int, char *[]));
@


1.10.22.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.10 1997/10/27 16:52:03 millert Exp $	*/
d69 5
a73 5
char		*loadprotoblocks(char *, long *);
int		loadblocknums(char *, int, unsigned long);
static void	devread(int, void *, daddr_t, size_t, char *);
static void	usage(void);
int 		main(int, char *[]);
@


1.10.12.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d69 5
a73 5
char		*loadprotoblocks(char *, long *);
int		loadblocknums(char *, int, unsigned long);
static void	devread(int, void *, daddr_t, size_t, char *);
static void	usage(void);
int 		main(int, char *[]);
@


1.10.12.2
log
@Merge of -current from two weeks ago into the SMP branch
@
text
@d342 1
a342 1
	struct ufs1_dinode	*ip;
d404 1
a404 1
	ip = (struct ufs1_dinode *)(buf) + ino_to_fsbo(fs, statbuf.st_ino);
@


1.9
log
@Add a missing space in usage message.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.8 1997/05/20 05:41:30 millert Exp $	*/
d139 1
a139 1
	if ((devfd = open(dev, O_RDONLY, 0)) < 0)
d194 1
a194 1
	if ((devfd = open(dev, O_RDWR, 0)) < 0)
@


1.8
log
@Add -s -e cd9660 hacks for making bootable alpha cd's.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.7 1997/05/05 06:01:48 millert Exp $	*/
d82 1
a82 1
		"usage: installboot [-n] [-v] [-s isofsblk -e isofseblk]"
@


1.7
log
@Updates from NetBSD (cgd):
 - seriously clean up makefiles.  use libsa/libkern/libz as appropriate,
   and don't build the various sources into objs locally by specifying
   them directly in the Makefiles.
 - move the secondary bootstrap down (to 0x20004000), and add a HEAP_LIMIT
   so that we don't exhaust our bootstrap address space (when using the new,
   not yet checked in, memory allocator).
 - clean up installboot, deal with secondary bootstrap programs not on
   'a' partition or 'a' partition not starting at 0.
 - add padding to structures in bbinfo.h for future expansion.  Add a
   netbbinfo structure to allow netboot information to be hard-coded in
   network boot blocks, so that they can be made to work even on systems
   with firmware which doesn't support the new "ethernet address in boot
   device" convention.
 - move the sync() calls to the correct place in installboot.c
 - remove a kludge in disk.c which was breaking multiple opens/closes
   of the disk
 - allow netboot ethernet address to be hard-coded into binary so that
   machines with old firmware which doesn't pass it in the boot device
   can work.  Assume that if the ethernet address isn't passed in, it
   uses the old (dain-bramaged) 'read' interface works on my 3000/300LX.
 - Add setnetbootinfo, a program to hard code an ethernet address into
   a network boot.
 - move an 'int debug;' into boot.c (it was the only diff between boot.c and
   netboot.c), and nuke netboot.c (using boot.c instead for net boot blocks).
 - add cd9660 file system ops to the file system ops table in filesystem.c
 - if a file name is given (i.e. BOOTED_FILE) is set, boot only that file,
   but if not then try to boot "bsd", "bsd.bak", "bsd.old", and
   "obsd" (in that order) until one is found or until the list of names
   is exhausted.
 - add support for reading gzipped kernels.
 - use strerror() to print errors, rather than just printing error numbers
 - if no disk label exists, fake one up
 - slightly relax the block size checks in bootxx.c; they were a bit to paranoid

And local changes:
 - don't build a copy of libsa/libkern/libz for each boot prog,
   just build a single copy and use it for everything.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.6 1997/04/09 05:09:35 deraadt Exp $	*/
d37 1
d57 4
d75 2
d82 2
a83 1
		"usage: installboot [-n] [-v] <boot> <proto> <device>\n");
a95 2
	int	mib[2];
	size_t	size;
d100 1
a100 1
	while ((c = getopt(argc, argv, "vn")) != EOF) {
d110 6
d121 1
a121 1
	if (argc - optind < 3) {
a122 1
	}
a247 2
	struct	exec *hp;
	long	off;
d355 26
@


1.6
log
@the the
@
text
@d1 2
a2 2
/*	$OpenBSD: installboot.c,v 1.5 1997/01/15 23:41:48 millert Exp $ */
/*	$NetBSD: installboot.c,v 1.2 1995/12/20 00:17:49 cgd Exp $ */
d5 1
d43 2
d46 1
d52 1
d65 1
a65 1
int		loadblocknums __P((char *, int));
d74 1
a74 1
	fprintf(stderr,
d90 3
d94 1
a94 1
	while ((c = getopt(argc, argv, "vn")) != -1) {
d118 3
a120 3
		printf("boot: %s\n", boot);
		printf("proto: %s\n", proto);
		printf("device: %s\n", dev);
d130 6
d138 32
a169 1
	if (loadblocknums(boot, devfd) != 0)
a188 4
	/* Sync filesystems (to clean in-memory superblock?) */
	sync();
	sleep(3);

d293 1
a293 1
		printf("boot block info locator at offset 0x%x\n",
d295 1
a295 1
		printf("boot block info at offset 0x%x\n",
d297 1
a297 1
		printf("max number of blocks: %d\n", max_block_count);
d322 4
a325 3
loadblocknums(boot, devfd)
char	*boot;
int	devfd;
d359 2
a360 1
	devread(devfd, sblock, btodb(SBOFF), SBSIZE, "superblock");
d368 1
a368 1
	devread(devfd, buf, blk, fs->fs_bsize, "inode");
d389 1
a389 1
		printf("%s: block numbers: ", boot);
d393 1
a393 1
		bbinfop->blocks[i] = blk;
d395 1
a395 1
			printf("%d ", blk);
d398 1
a398 1
		printf("\n");
d408 1
a408 1
		printf("%s: block numbers (indirect): ", boot);
d410 2
a411 1
	devread(devfd, buf, blk, fs->fs_bsize, "indirect block");
d415 1
a415 1
		bbinfop->blocks[i] = blk;
d417 1
a417 1
			printf("%d ", blk);
d420 1
a420 1
		printf("\n");
@


1.5
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.4 1996/10/30 22:40:31 niklas Exp $ */
d159 1
a159 1
		long    bb_cksum;       /* checksum of the the boot block, as longs. */
@


1.4
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.2 1995/12/20 00:17:49 cgd Exp $ */
d86 1
a86 1
	while ((c = getopt(argc, argv, "vn")) != EOF) {
@


1.3
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@@


1.2
log
@from netbsd; deal with ufs -> ffs transition
@
text
@d1 1
@


1.1
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: installboot.c,v 1.1 1995/11/23 02:39:02 cgd Exp $ */
d304 2
a305 2
	if (strncmp(statfsbuf.f_fstypename, "ufs", MFSNAMELEN))
		errx(1, "%s: must be on a UFS filesystem", boot);
@
