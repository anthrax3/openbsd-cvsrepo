head	1.23;
access;
symbols
	OPENBSD_6_1:1.23.0.14
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.12
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.8
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.10
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.23.0.6
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.20.0.10
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.8
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.6
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.19.0.24
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.22
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.18
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.20
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.16
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.14
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.12
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.10
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.8
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.6
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.4
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.14
	UBC:1.13.0.4
	UBC_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.11.0.14
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.12
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.10
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.8
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.6
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.4
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2014.02.19.22.02.14;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2014.02.19.20.52.57;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2013.12.28.02.51.06;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2011.06.05.21.49.36;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.30.01.41.33;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.30.01.31.12;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.01.20.55.09;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.05.19.59.20;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.23.27.43;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.26.27;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.16.00.38.16;	author deraadt;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2000.11.08.16.01.25;	author art;	state Exp;
branches;
next	1.11;

1.11
date	98.03.05.23.08.17;	author deraadt;	state Exp;
branches
	1.11.10.1;
next	1.10;

1.10
date	97.07.08.10.42.25;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.05.05.06.01.51;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	96.11.27.19.54.52;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.11.27.12.07.55;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.10.30.22.40.39;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.07.31.16.24.11;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.07.29.23.01.33;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.06.18.09.45.05;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.53.57;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.46;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.46;	author deraadt;	state Exp;
branches;
next	;

1.11.10.1
date	2001.04.18.16.01.41;	author niklas;	state Exp;
branches;
next	1.11.10.2;

1.11.10.2
date	2001.07.04.10.14.51;	author niklas;	state Exp;
branches;
next	1.11.10.3;

1.11.10.3
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	1.11.10.4;

1.11.10.4
date	2003.06.07.11.11.33;	author ho;	state Exp;
branches;
next	;

1.13.4.1
date	2002.06.11.03.33.41;	author art;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Don't try to close(-1) if EPERM.
@
text
@/*	$OpenBSD: boot.c,v 1.22 2014/02/19 20:52:57 miod Exp $	*/
/*	$NetBSD: boot.c,v 1.10 1997/01/18 01:58:33 cgd Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)boot.c	8.1 (Berkeley) 6/10/93
 */

#include <lib/libkern/libkern.h>
#include <lib/libsa/stand.h>
#include <lib/libsa/loadfile.h>

#include <sys/param.h>
#include <sys/exec.h>
#include <sys/stat.h>
#define _KERNEL
#include <sys/fcntl.h>
#undef _KERNEL

#include <machine/rpb.h>
#include <machine/prom.h>
#include <machine/autoconf.h>

char boot_file[128];
char boot_flags[128];

extern char bootprog_name[];

struct bootinfo_v1 bootinfo_v1;

paddr_t ptbr_save;

int debug;

char   rnddata[BOOTRANDOM_MAX];

void
loadrandom(char *name, char *buf, size_t buflen)
{
	struct stat sb;
	int fd, i;

	fd = open(name, O_RDONLY);
	if (fd == -1) {
		if (errno != EPERM)
			printf("cannot open %s: %s\n", name, strerror(errno));
		return;
	}
	if (fstat(fd, &sb) == -1 || sb.st_uid != 0 || !S_ISREG(sb.st_mode) ||
	    (sb.st_mode & (S_IWOTH|S_IROTH)))
		goto fail;
	(void) read(fd, buf, buflen);
fail:
	close(fd);
}

int
main()
{
	char *name, **namep;
	u_int64_t entry;
	int rc;
	u_long marks[MARK_MAX];
#ifdef DEBUG
	struct rpb *r;
	struct mddt *mddtp;
	struct mddt_cluster *memc;
	int i;
#endif

	/* Init prom callback vector. */
	init_prom_calls();

	/* print a banner */
	printf("%s\n", bootprog_name);

	/* switch to OSF pal code. */
	OSFpal();

#ifdef DEBUG
	r = (struct rpb *)HWRPB_ADDR;
	mddtp = (struct mddt *)(HWRPB_ADDR + r->rpb_memdat_off);
	printf("%d memory clusters\n", mddtp->mddt_cluster_cnt);
	for (i = 0; i < mddtp->mddt_cluster_cnt; i++) {
		memc = &mddtp->mddt_clusters[i];
		printf("%d: (%d) %lx-%lx\n", i, memc->mddt_usage,
		    memc->mddt_pfn << PAGE_SHIFT,
		    (memc->mddt_pfn + memc->mddt_pg_cnt) << PAGE_SHIFT);
	}
#endif

	loadrandom(BOOTRANDOM, rnddata, sizeof(rnddata));

	prom_getenv(PROM_E_BOOTED_FILE, boot_file, sizeof(boot_file));
	prom_getenv(PROM_E_BOOTED_OSFLAGS, boot_flags, sizeof(boot_flags));

	if (boot_file[0] != '\0') {
		(void)printf("Boot file: %s %s\n", boot_file, boot_flags);
		name = boot_file;
	} else
		name = "bsd";

	(void)printf("Loading %s...\n", name);
	marks[MARK_START] = 0;
	rc = loadfile(name, marks, LOAD_KERNEL | COUNT_KERNEL);
	(void)printf("\n");
	if (rc != 0)
		goto fail;

	/*
	 * Fill in the bootinfo for the kernel.
	 */
	bzero(&bootinfo_v1, sizeof(bootinfo_v1));
	bootinfo_v1.ssym = marks[MARK_SYM];
	bootinfo_v1.esym = marks[MARK_END];
	bcopy(name, bootinfo_v1.booted_kernel,
	    sizeof(bootinfo_v1.booted_kernel));
	bcopy(boot_flags, bootinfo_v1.boot_flags,
	    sizeof(bootinfo_v1.boot_flags));
	bootinfo_v1.hwrpb = (void *)HWRPB_ADDR;
	bootinfo_v1.hwrpbsize = ((struct rpb *)HWRPB_ADDR)->rpb_size;
	bootinfo_v1.cngetc = NULL;
	bootinfo_v1.cnputc = NULL;
	bootinfo_v1.cnpollc = NULL;

	entry = marks[MARK_START];
	(*(void (*)(u_int64_t, u_int64_t, u_int64_t, void *, u_int64_t,
	    u_int64_t))entry)(0, ptbr_save, BOOTINFO_MAGIC, &bootinfo_v1, 1, 0);

fail:
	halt();
}
@


1.22
log
@/etc/random.seed support.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.21 2013/12/28 02:51:06 deraadt Exp $	*/
d74 2
a75 3
		if (errno == EPERM)
			goto fail;
		printf("cannot open %s: %s\n", name, strerror(errno));
@


1.21
log
@Try to load entropy data from disk:/etc/random.seed, and additionally
use a MD-supplied random function.  Then, insert this into the ELF
openbsd.randomdata of the kernel, so that it has entropy right from
the start.  Some help from jsing for the softraid aspects.
Also tested by phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.20 2011/06/05 21:49:36 miod Exp $	*/
d44 4
d64 22
a85 1
char   rnddata[BOOTRANDOM_MAX];		/* XXX dummy */
d121 3
@


1.20
log
@Update alpha bootblocks to use MI loadfile code instead of rolling our own;
also print a meaningful message if the kernel load address conflicts with the
SRM memory areas, so that we can know which kernel load address to use.

Requires `make includes' before attempting to build bootblocks.

Tweaks mk@@, `nice' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.19 2005/05/30 01:41:33 deraadt Exp $	*/
d59 2
@


1.19
log
@even shorter
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.18 2005/05/30 01:31:12 deraadt Exp $	*/
d40 1
a43 1
#include <sys/exec_ecoff.h>
a48 5
#define _KERNEL
#include "include/pte.h"

int loadfile(char *, u_int64_t *);

d56 1
a56 3
extern paddr_t ffp_save, ptbr_save;

extern vaddr_t ssym, esym;
d65 8
a72 1
	int win;
d83 11
d102 6
a107 2
	win = (loadfile(name, &entry) == 0);
	if (!win)
d114 2
a115 2
	bootinfo_v1.ssym = ssym;
	bootinfo_v1.esym = esym;
d126 1
d128 1
a128 2
	    u_int64_t))entry)(ffp_save, ptbr_save, BOOTINFO_MAGIC,
	    &bootinfo_v1, 1, 0);
@


1.18
log
@shrink alpha boot blocks another little bit
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.17 2004/12/01 20:55:09 deraadt Exp $	*/
d86 1
a86 1
	if (boot_file[0] != 0)
a87 2

	if (boot_file[0] != '\0')
d89 1
a89 1
	else
@


1.17
log
@remove excessive chattiness from the bootblocks.  our goal is to shrink
them to < 5*1024, because the floppies are once again tight
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.16 2004/07/05 19:59:20 deraadt Exp $	*/
d57 1
a57 1
extern char bootprog_name[], bootprog_rev[];
d78 1
a78 1
	printf("%s %s\n", bootprog_name, bootprog_rev);
d90 1
a90 1
		win = (loadfile(name = boot_file, &entry) == 0);
d92 2
a93 2
		win = (loadfile(name = "bsd", &entry) == 0);

@


1.16
log
@remove some stuff to make the blocks slightly smaller.  we could go further
still.  tested by matthieu
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.15 2003/06/02 23:27:43 millert Exp $	*/
a112 1
	(void)printf("Entering %s at 0x%lx...\n", name, entry);
a117 1
	(void)printf("Boot failed!  Halting...\n");
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.14 2002/03/14 01:26:27 millert Exp $	*/
d57 1
a57 1
extern char bootprog_name[], bootprog_rev[], bootprog_date[], bootprog_maker[];
a66 8
char *kernelnames[] = {
	"bsd",
	"bsd.bak",
	"bsd.old",
	"obsd",
	NULL
};

d78 1
a78 2
	printf("%s, Revision %s (%s, %s)\n", bootprog_name, bootprog_rev,
	    bootprog_maker, bootprog_date);
a82 2
	printf("\n");

d92 1
a92 3
		for (namep = kernelnames, win = 0; *namep != NULL && !win;
		    namep++)
			win = (loadfile(name = *namep, &entry) == 0);
a93 1
	printf("\n");
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.13 2001/05/16 00:38:16 deraadt Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.13
log
@shrink printf messages
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.12 2000/11/08 16:01:25 art Exp $	*/
d56 1
a56 1
int loadfile __P((char *, u_int64_t *));
@


1.13.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.13 2001/05/16 00:38:16 deraadt Exp $	*/
d56 1
a56 1
int loadfile(char *, u_int64_t *);
@


1.12
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.11 1998/03/05 23:08:17 deraadt Exp $	*/
d90 2
a91 4
	printf("\n");
	printf("%s, Revision %s\n", bootprog_name, bootprog_rev);
	printf("(%s, %s)\n", bootprog_maker, bootprog_date);
	printf("\n");
d102 1
a102 2
		(void)printf("Boot file: %s\n", boot_file);
	(void)printf("Boot flags: %s\n", boot_flags);
d133 2
a134 2
		u_int64_t))entry)(ffp_save, ptbr_save, BOOTINFO_MAGIC,
		&bootinfo_v1, 1, 0);
@


1.11
log
@main returns int
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.10 1997/07/08 10:42:25 niklas Exp $	*/
d51 1
d63 5
a67 1
vm_offset_t ffp_save, ptbr_save, esym;
d115 23
a137 4
	if (win) {
		(void)printf("Entering %s at 0x%lx...\n", name, entry);
		(*(void (*)())entry)(ffp_save, ptbr_save, esym);
	}
d139 1
@


1.11.10.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.12 2000/11/08 16:01:25 art Exp $	*/
a50 1
#include <machine/autoconf.h>
d62 1
a62 5
struct bootinfo_v1 bootinfo_v1;

extern paddr_t ffp_save, ptbr_save;

extern vaddr_t ssym, esym;
d110 4
a113 23
	if (!win)
		goto fail;

	/*
	 * Fill in the bootinfo for the kernel.
	 */
	bzero(&bootinfo_v1, sizeof(bootinfo_v1));
	bootinfo_v1.ssym = ssym;
	bootinfo_v1.esym = esym;
	bcopy(name, bootinfo_v1.booted_kernel,
	    sizeof(bootinfo_v1.booted_kernel));
	bcopy(boot_flags, bootinfo_v1.boot_flags,
	    sizeof(bootinfo_v1.boot_flags));
	bootinfo_v1.hwrpb = (void *)HWRPB_ADDR;
	bootinfo_v1.hwrpbsize = ((struct rpb *)HWRPB_ADDR)->rpb_size;
	bootinfo_v1.cngetc = NULL;
	bootinfo_v1.cnputc = NULL;
	bootinfo_v1.cnpollc = NULL;

	(void)printf("Entering %s at 0x%lx...\n", name, entry);
	(*(void (*)(u_int64_t, u_int64_t, u_int64_t, void *, u_int64_t,
		u_int64_t))entry)(ffp_save, ptbr_save, BOOTINFO_MAGIC,
		&bootinfo_v1, 1, 0);
a114 1
fail:
@


1.11.10.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.11.10.1 2001/04/18 16:01:41 niklas Exp $	*/
d90 4
a93 2
	printf("%s, Revision %s (%s, %s)\n", bootprog_name, bootprog_rev,
	    bootprog_maker, bootprog_date);
d104 2
a105 1
		(void)printf("Boot file: %s %s\n", boot_file, boot_flags);
d136 2
a137 2
	    u_int64_t))entry)(ffp_save, ptbr_save, BOOTINFO_MAGIC,
	    &bootinfo_v1, 1, 0);
@


1.11.10.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 1
a56 1
int loadfile(char *, u_int64_t *);
@


1.11.10.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.11.10.3 2002/03/28 10:06:13 niklas Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.10
log
@Load the kernel symbol table for DDB to use
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.9 1997/05/05 06:01:51 millert Exp $	*/
d74 1
a74 1
void
@


1.9
log
@Updates from NetBSD (cgd):
 - seriously clean up makefiles.  use libsa/libkern/libz as appropriate,
   and don't build the various sources into objs locally by specifying
   them directly in the Makefiles.
 - move the secondary bootstrap down (to 0x20004000), and add a HEAP_LIMIT
   so that we don't exhaust our bootstrap address space (when using the new,
   not yet checked in, memory allocator).
 - clean up installboot, deal with secondary bootstrap programs not on
   'a' partition or 'a' partition not starting at 0.
 - add padding to structures in bbinfo.h for future expansion.  Add a
   netbbinfo structure to allow netboot information to be hard-coded in
   network boot blocks, so that they can be made to work even on systems
   with firmware which doesn't support the new "ethernet address in boot
   device" convention.
 - move the sync() calls to the correct place in installboot.c
 - remove a kludge in disk.c which was breaking multiple opens/closes
   of the disk
 - allow netboot ethernet address to be hard-coded into binary so that
   machines with old firmware which doesn't pass it in the boot device
   can work.  Assume that if the ethernet address isn't passed in, it
   uses the old (dain-bramaged) 'read' interface works on my 3000/300LX.
 - Add setnetbootinfo, a program to hard code an ethernet address into
   a network boot.
 - move an 'int debug;' into boot.c (it was the only diff between boot.c and
   netboot.c), and nuke netboot.c (using boot.c instead for net boot blocks).
 - add cd9660 file system ops to the file system ops table in filesystem.c
 - if a file name is given (i.e. BOOTED_FILE) is set, boot only that file,
   but if not then try to boot "bsd", "bsd.bak", "bsd.old", and
   "obsd" (in that order) until one is found or until the list of names
   is exhausted.
 - add support for reading gzipped kernels.
 - use strerror() to print errors, rather than just printing error numbers
 - if no disk label exists, fake one up
 - slightly relax the block size checks in bootxx.c; they were a bit to paranoid

And local changes:
 - don't build a copy of libsa/libkern/libz for each boot prog,
   just build a single copy and use it for everything.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.8 1996/11/27 19:54:52 niklas Exp $	*/
d62 1
a62 1
vm_offset_t ffp_save, ptbr_save;
d112 1
a112 1
		(*(void (*)())entry)(ffp_save, ptbr_save, 0);
@


1.8
log
@Make compilable in our env.  Involved disabling ELF support,
reordering includes (due to -Wstrict-prototypes) and other -Wall goo
@
text
@d1 2
a2 2
/*	$OpenBSD: boot.c,v 1.7 1996/11/27 12:07:55 mickey Exp $	*/
/*	$NetBSD: boot.c,v 1.8 1996/09/17 22:00:26 cgd Exp $	*/
d64 10
d77 1
d79 1
d98 10
a107 2
	if (boot_file[0] == '\0')
		bcopy("bsd", boot_file, sizeof "bsd");
d109 3
a111 4
	(void)printf("Boot: %s %s\n", boot_file, boot_flags);

	if (!loadfile(boot_file, &entry)) {
		(void)printf("Entering kernel at 0x%lx...\n", entry);
@


1.7
log
@include libkern.h prior to stand.h to not to collide m{in,ax} definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.6 1996/10/30 22:40:39 niklas Exp $	*/
d49 1
@


1.6
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.8 1996/09/17 22:00:26 cgd Exp $	*/
d42 1
a43 1
#include <lib/libkern/libkern.h>
@


1.5
log
@kernel is /bsd, and we are OpenBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: boot.c,v 1.4 1996/07/29 23:01:33 niklas Exp $	*/
/*	$NetBSD: boot.c,v 1.6 1996/05/10 00:15:08 cgd Exp $	*/
d54 1
a54 5
static int aout_exec __P((int, struct exec *, u_int64_t *));
static int coff_exec __P((int, struct ecoff_exechdr *, u_int64_t *));
static int loadfile __P((char *, u_int64_t *));

char line[64] = "/bsd";
a56 1
char boot_dev[128];
a57 1
char boot_console[8];
a60 9
#define	KERNEL_ARGC	4
char *kernel_argv[KERNEL_ARGC+1] = {
	boot_file,
	boot_flags,
	boot_console,
	boot_dev,
	NULL
};

d64 1
a64 4
main(argc, argv, envp)
	int argc;
	char **argv;
	char **envp;
a66 9
	int ask;
	prom_return_t ret;

#ifdef notdef
	{
		extern char *_EDATA, *_end;
		bzero(_EDATA, _end - _EDATA);
	}
#endif
d72 1
a72 1
	printf("\n\n");
a81 1
	prom_getenv(PROM_E_BOOTED_DEV, boot_dev, sizeof(boot_dev));
a83 6
	prom_getenv(PROM_E_TTY_DEV, boot_console, sizeof(boot_console));

	printf("boot_dev = \"%s\"\n", boot_dev);
	printf("boot_file = \"%s\"\n", boot_file);
	printf("boot_flags = \"%s\"\n", boot_flags);
	printf("boot_console = \"%s\"\n", boot_console);
d86 1
a86 143
		bcopy(line, boot_file, strlen(line)+1);

#ifdef JUSTASK
	ask = 1;
#else
	ask = 0;
#endif
	for (;;) {
		if (ask) {
			(void)printf("Boot: ");
			gets(line);
			if (line[0] == '\0')
				continue;
			if (!strcmp(line, "halt"))
				halt();
/* XXX TURN LINE INTO BOOT FILE/FLAGS */
			bcopy(line, boot_file, strlen(line)+1);
		} else
			(void)printf("Boot: %s %s\n", boot_file, boot_flags);

		if (!loadfile(boot_file, &entry)) {

printf("calling %lx with %lx, %lx, %lx, %lx, %lx\n", entry,
ffp_save, ptbr_save, KERNEL_ARGC, kernel_argv, NULL);
			(*(void (*)())entry)(ffp_save, ptbr_save, KERNEL_ARGC,
			    kernel_argv, NULL);
		}

		ask = 1;
	}
	/* NOTREACHED */
}

/*
 * Open 'filename', read in program and return the entry point or -1 if error.
 */
static int
loadfile(fname, entryp)
	char *fname;
	u_int64_t *entryp;
{
	struct devices *dp;
	union {
		struct exec aout;
		struct ecoff_exechdr coff;
	} hdr;
	ssize_t nr;
	int fd, rval;

	/* Open the file. */
	rval = 1;
	if ((fd = open(fname, 0)) < 0) {
		(void)printf("open error: %d\n", errno);
		goto err;
	}

	/* Read the exec header. */
	if ((nr = read(fd, &hdr, sizeof(hdr))) != sizeof(hdr)) {
		(void)printf("read error: %d\n", errno);
		goto err;
	}

	/* Exec a.out or COFF. */
	rval = ECOFF_BADMAG(&hdr.coff) ?	/* XXX check aouthdr */
	    aout_exec(fd, &hdr.aout, entryp) :
	    coff_exec(fd, &hdr.coff, entryp);

err:
#ifndef SMALL
	if (fd >= 0)
		(void)close(fd);
#endif
	if (rval)
		(void)printf("can't boot '%s'\n", fname);
	return (rval);
}

static int
aout_exec(fd, aout, entryp)
	int fd;
	struct exec *aout;
	u_int64_t *entryp;
{
	size_t sz;

	/* Check the magic number. */
	if (N_GETMAGIC(*aout) != OMAGIC) {
		(void)printf("bad magic: %o\n", N_GETMAGIC(*aout));
		return (1);
	}

	/* Read in text, data. */
	(void)printf("%lu+%lu", aout->a_text, aout->a_data);
	if (lseek(fd, (off_t)N_TXTOFF(*aout), SEEK_SET) < 0) {
		(void)printf("lseek: %d\n", errno);
		return (1);
	}
	sz = aout->a_text + aout->a_data;
	if (read(fd, (void *)aout->a_entry, sz) != sz) {
		(void)printf("read text/data: %d\n", errno);
		return (1);
	}

	/* Zero out bss. */
	if (aout->a_bss != 0) {
		(void)printf("+%lu", aout->a_bss);
		bzero(aout->a_entry + sz, aout->a_bss);
	}

	ffp_save = aout->a_entry + aout->a_text + aout->a_data + aout->a_bss;
	ffp_save = k0segtophys((ffp_save + PGOFSET & ~PGOFSET)) >> PGSHIFT;
	ffp_save += 2;		/* XXX OSF/1 does this, no idea why. */

	(void)printf("\n");
	*entryp = aout->a_entry;
	return (0);
}

static int
coff_exec(fd, coff, entryp)
	int fd;
	struct ecoff_exechdr *coff;
	u_int64_t *entryp;
{

	/* Read in text. */
	(void)printf("%lu", coff->a.tsize);
	(void)lseek(fd, ECOFF_TXTOFF(coff), 0);
	if (read(fd, (void *)coff->a.text_start, coff->a.tsize) !=
	    coff->a.tsize) {
		(void)printf("read text: %d\n", errno);
		return (1);
	}

	/* Read in data. */
	if (coff->a.dsize != 0) {
		(void)printf("+%lu", coff->a.dsize);
		if (read(fd, (void *)coff->a.data_start, coff->a.dsize) !=
		    coff->a.dsize) {
			(void)printf("read data: %d\n", errno);
			return (1);
		}
	}
d88 1
d90 3
a92 4
	/* Zero out bss. */
	if (coff->a.bsize != 0) {
		(void)printf("+%lu", coff->a.bsize);
		bzero(coff->a.bss_start, coff->a.bsize);
d95 2
a96 11
	ffp_save = coff->a.text_start + coff->a.tsize;
	if (ffp_save < coff->a.data_start + coff->a.dsize)
		ffp_save = coff->a.data_start + coff->a.dsize;
	if (ffp_save < coff->a.bss_start + coff->a.bsize)
		ffp_save = coff->a.bss_start + coff->a.bsize;
	ffp_save = k0segtophys((ffp_save + PGOFSET & ~PGOFSET)) >> PGSHIFT;
	ffp_save += 2;		/* XXX OSF/1 does this, no idea why. */

	(void)printf("\n");
	*entryp = coff->a.entry;
	return (0);
@


1.4
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.6 1996/05/10 00:15:08 cgd Exp $	*/
d58 1
a58 1
char line[64] = "/netbsd";
@


1.3
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.2
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: boot.c,v 1.4 1995/11/23 02:39:27 cgd Exp $	*/
d46 1
a49 1
#include "include/coff.h"
d54 1
a54 1
static int coff_exec __P((int, struct exechdr *, u_int64_t *));
d163 1
a163 1
		struct exechdr coff;
d182 1
a182 1
	rval = N_COFFBADMAG(hdr.coff.a) ?
d240 1
a240 1
	struct exechdr *coff;
d246 1
a246 1
	(void)lseek(fd, N_COFFTXTOFF(coff->f, coff->a), 0);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: boot.c,v 1.3 1995/06/28 00:58:48 cgd Exp $	*/
d42 1
d49 1
a49 1
#include "../../include/coff.h"
d51 1
a51 1
#include "../../include/pte.h"
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

