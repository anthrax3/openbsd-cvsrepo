head	1.18;
access;
symbols
	OPENBSD_4_9:1.17.0.24
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.22
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.18
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.20
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.16
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.14
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.12
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.10
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.8
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.6
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.4
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.11.0.4
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.7.0.12
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.10
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.8
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.6
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3;
locks; strict;
comment	@ * @;


1.18
date	2011.06.05.21.49.36;	author miod;	state dead;
branches;
next	1.17;

1.17
date	2005.08.10.16.58.42;	author todd;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.01.20.55.07;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.05.19.59.17;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.18.20.14.43;	author jmc;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.23.27.43;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.26.27;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.16.00.38.15;	author deraadt;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2001.01.16.15.34.22;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.14.13.47.47;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.08.16.01.24;	author art;	state Exp;
branches;
next	1.7;

1.7
date	98.09.04.17.03.24;	author millert;	state Exp;
branches
	1.7.8.1;
next	1.6;

1.6
date	97.07.08.20.22.16;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.07.08.18.13.14;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	97.07.08.10.42.24;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	97.05.05.06.01.49;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.11.27.19.54.48;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.10.30.22.40.33;	author niklas;	state Exp;
branches;
next	;

1.7.8.1
date	2001.04.18.16.01.40;	author niklas;	state Exp;
branches;
next	1.7.8.2;

1.7.8.2
date	2001.07.04.10.14.48;	author niklas;	state Exp;
branches;
next	1.7.8.3;

1.7.8.3
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	1.7.8.4;

1.7.8.4
date	2003.06.07.11.11.33;	author ho;	state Exp;
branches;
next	1.7.8.5;

1.7.8.5
date	2004.02.19.09.59.34;	author niklas;	state Exp;
branches;
next	;

1.11.4.1
date	2002.06.11.03.33.41;	author art;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Update alpha bootblocks to use MI loadfile code instead of rolling our own;
also print a meaningful message if the kernel load address conflicts with the
SRM memory areas, so that we can know which kernel load address to use.

Requires `make includes' before attempting to build bootblocks.

Tweaks mk@@, `nice' deraadt@@
@
text
@/*	$OpenBSD: loadfile.c,v 1.17 2005/08/10 16:58:42 todd Exp $	*/
/*	$NetBSD: loadfile.c,v 1.3 1997/04/06 08:40:59 cgd Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)boot.c	8.1 (Berkeley) 6/10/93
 */

#define	ELFSIZE		64

#include <lib/libkern/libkern.h>
#include <lib/libsa/stand.h>

#include <sys/param.h>
#include <sys/exec.h>
#include <sys/exec_ecoff.h>
#include <sys/exec_elf.h>

#include <machine/rpb.h>
#include <machine/prom.h>

#include <ddb/db_aout.h>

#define _KERNEL
#include "include/pte.h"

#ifdef ALPHA_BOOT_ELF
static int elf_exec(int, Elf64_Ehdr *, u_int64_t *);
#endif
int loadfile(char *, u_int64_t *);

paddr_t ffp_save, ptbr_save;
vaddr_t ssym, esym;

#define WARN(...)

/*
 * Open 'filename', read in program and return the entry point or -1 if error.
 */
int
loadfile(fname, entryp)
	char *fname;
	u_int64_t *entryp;
{
	struct devices *dp;
	union {
#ifdef ALPHA_BOOT_ELF
		Elf64_Ehdr elf;
#endif
	} hdr;
	int fd, rval;

	(void)printf("Loading %s...\n", fname);

	/* Open the file. */
	rval = 1;
	if ((fd = open(fname, 0)) < 0) {
		WARN(("open %s: errno %d\n", fname, errno));
		goto err;
	}

	/* Read the exec header. */
	if (read(fd, &hdr, sizeof(hdr)) != sizeof(hdr)) {
		WARN(("read header: %s\n", strerror(errno)));
		goto err;
	}

#ifdef ALPHA_BOOT_ELF
	if (memcmp(ELFMAG, hdr.elf.e_ident, SELFMAG) == 0) {
		rval = elf_exec(fd, &hdr.elf, entryp);
	} else
#endif
	{
		(void)printf("%s: unknown executable format\n", fname);
	}

err:
	if (fd >= 0)
		(void)close(fd);
	return (rval);
}

#ifdef ALPHA_BOOT_ELF
static int
elf_exec(fd, elf, entryp)
	int fd;
	Elf64_Ehdr *elf;
	u_int64_t *entryp;
{
	int i;
	int first = 1, havesyms;
	Elf64_Shdr *shp;
	Elf64_Off off;
	size_t sz;

	for (i = 0; i < elf->e_phnum; i++) {
		Elf64_Phdr phdr;
		(void)lseek(fd, elf->e_phoff + sizeof(phdr) * i, SEEK_SET);
		if (read(fd, (void *)&phdr, sizeof(phdr)) != sizeof(phdr)) {
			WARN(("read phdr: %s\n", strerror(errno)));
			return (1);
		}
		if (phdr.p_type != PT_LOAD ||
		    (phdr.p_flags & (PF_W|PF_X)) == 0)
			continue;

		/* Read in segment. */
		(void)printf("%s%lu", first ? "" : "+", phdr.p_filesz);
		(void)lseek(fd, phdr.p_offset, SEEK_SET);
		if (read(fd, (void *)phdr.p_vaddr, phdr.p_filesz) !=
		    phdr.p_filesz) {
			WARN(("read text: %s\n", strerror(errno)));
			return (1);
		}
		if (first || ffp_save < phdr.p_vaddr + phdr.p_memsz)
			ffp_save = phdr.p_vaddr + phdr.p_memsz;

		/* Zero out bss. */
		if (phdr.p_filesz < phdr.p_memsz) {
			(void)printf("+%lu", phdr.p_memsz - phdr.p_filesz);
			bzero((caddr_t)phdr.p_vaddr + phdr.p_filesz,
			    phdr.p_memsz - phdr.p_filesz);
		}
		first = 0;
	}

	ffp_save = roundup(ffp_save, sizeof(long));

	/*
	 * Retrieve symbols.
	 */
	ssym = ffp_save;
	ffp_save += sizeof(Elf64_Ehdr);

	if (lseek(fd, elf->e_shoff, SEEK_SET) == -1)  {
		WARN(("seek to section headers: %s\n", strerror(errno)));
		return (1);
	}

	sz = elf->e_shnum * sizeof(Elf64_Shdr);
	shp = (Elf64_Shdr *)ffp_save;
	ffp_save += roundup(sz, sizeof(long));

	if (read(fd, shp, sz) != sz) {
		WARN(("read section headers: %d\n", strerror(errno)));
		return (1);
	}

	/*
	 * Now load the symbol sections themselves.  Make sure the
	 * sections are aligned. Don't bother with string tables if
	 * there are no symbol sections.
	 */
	off = roundup((sizeof(Elf64_Ehdr) + sz), sizeof(long));

	for (havesyms = i = 0; i < elf->e_shnum; i++)
		if (shp[i].sh_type == SHT_SYMTAB)
			havesyms = 1;

	if (!havesyms)
		goto no_syms;

	for (first = 1, i = 0; i < elf->e_shnum; i++) {
		if (shp[i].sh_type == SHT_SYMTAB ||
		    shp[i].sh_type == SHT_STRTAB) {
			printf("%s%ld", first ? " [" : "+",
			       (u_long)shp[i].sh_size);
			if (lseek(fd, shp[i].sh_offset, SEEK_SET) == -1) {
				WARN(("lseek symbols: %s\n", strerror(errno)));
				return (1);
			}
			if (read(fd, (void *)ffp_save, shp[i].sh_size) !=
			    shp[i].sh_size) {
				WARN(("read symbols: %s\n", strerror(errno)));
				return (1);
			}
			ffp_save += roundup(shp[i].sh_size, sizeof(long));
			shp[i].sh_offset = off;
			off += roundup(shp[i].sh_size, sizeof(long));
			first = 0;
		}
	}
	if (havesyms && first == 0)
		printf("]");

	elf->e_phoff = 0;
	elf->e_shoff = sizeof(Elf64_Ehdr);
	elf->e_phentsize = 0;
	elf->e_phnum = 0;
	bcopy(elf, (void *)ssym, sizeof(*elf));

no_syms:
	esym = ffp_save;
	ffp_save = ALPHA_K0SEG_TO_PHYS((ffp_save + PGOFSET & ~PGOFSET)) >> PGSHIFT;
	ffp_save += 2;		/* XXX OSF/1 does this, no idea why. */

	(void)printf("\n");
	*entryp = elf->e_entry;
	return (0);
}
#endif /* ALPHA_BOOT_ELF */
@


1.17
log
@suggested by art, go for it deraadt, ok miod@@
remove ECOFF support
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.16 2004/12/01 20:55:07 deraadt Exp $	*/
@


1.16
log
@remove excessive chattiness from the bootblocks.  our goal is to shrink
them to < 5*1024, because the floppies are once again tight
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.15 2004/07/05 19:59:17 deraadt Exp $	*/
a55 3
#ifdef ALPHA_BOOT_ECOFF
static int coff_exec(int, struct ecoff_exechdr *, u_int64_t *);
#endif
a75 3
#ifdef ALPHA_BOOT_ECOFF
		struct ecoff_exechdr coff;
#endif
a96 5
#ifdef ALPHA_BOOT_ECOFF
	if (!ECOFF_BADMAG(&hdr.coff)) {
		rval = coff_exec(fd, &hdr.coff, entryp);
	} else
#endif
a110 110

#ifdef ALPHA_BOOT_ECOFF
static int
coff_exec(fd, coff, entryp)
	int fd;
	struct ecoff_exechdr *coff;
	u_int64_t *entryp;
{
	struct nlist *symtab;
	struct ecoff_symhdr symhdr;
	struct ecoff_extsym sym;
	int symsize, nesyms;

	/* Read in text. */
	(void)printf("%lu", coff->a.tsize);
	if (lseek(fd, ECOFF_TXTOFF(coff), SEEK_SET) == -1) {
		WARN(("seek to text: %s\n", strerror(errno)));
		return (1);
	}
	if (read(fd, (void *)coff->a.text_start, coff->a.tsize) !=
	    coff->a.tsize) {
		WARN(("read text: %s\n", strerror(errno)));
		return (1);
	}

	/* Read in data. */
	if (coff->a.dsize != 0) {
		(void)printf("+%lu", coff->a.dsize);
		if (read(fd, (void *)coff->a.data_start, coff->a.dsize) !=
		    coff->a.dsize) {
			WARN(("read data: %s\n", strerror(errno)));
			return (1);
		}
	}


	/* Zero out bss. */
	if (coff->a.bsize != 0) {
		(void)printf("+%lu", coff->a.bsize);
		bzero((void *)coff->a.bss_start, coff->a.bsize);
	}

	ffp_save = coff->a.text_start + coff->a.tsize;
	if (ffp_save < coff->a.data_start + coff->a.dsize)
		ffp_save = coff->a.data_start + coff->a.dsize;
	if (ffp_save < coff->a.bss_start + coff->a.bsize)
		ffp_save = coff->a.bss_start + coff->a.bsize;

	/* Get symbols if there for DDB's sake.  */
	if (coff->f.f_symptr && coff->f.f_nsyms) {
		if (lseek(fd, coff->f.f_symptr, SEEK_SET) == -1) {
			WARN(("seek to symbol table header: %s\n",
			    strerror(errno)));
			return (1);
		}
		if (read(fd, &symhdr, coff->f.f_nsyms) != coff->f.f_nsyms) {
			WARN(("read symbol table header: %s\n",
			    strerror(errno)));
			return (1);
		}
		*(long *)ffp_save = symsize =
		    symhdr.esymMax * sizeof(struct nlist);
		ffp_save += sizeof(long);
		printf("+[%d", symsize);
		symtab = (struct nlist *)ffp_save;
		bzero(symtab, symsize);
		if (lseek(fd, symhdr.cbExtOffset, SEEK_SET) == -1) {
			WARN(("lseek to symbol table: %s\n", strerror(errno)));
			return (1);
		}
		nesyms = symhdr.esymMax;
		while (nesyms--) {
			if (read(fd, &sym, sizeof(sym)) != sizeof(sym)) {
				WARN(("read symbols: %s\n", strerror(errno)));
				return (1);
			}
			symtab->n_un.n_strx = sym.es_strindex + sizeof(int);
			symtab->n_value = sym.es_value;
			symtab->n_type = N_EXT;
			if (sym.es_class == 1)		/* scText */
				symtab->n_type != N_TEXT;
			symtab++;
		}
		ffp_save += symsize;
		*(int *)ffp_save = symhdr.estrMax + sizeof(int);
		ffp_save += sizeof(int);
		if (lseek(fd, symhdr.cbSsExtOffset, SEEK_SET) == -1) {
			WARN(("seek to string table: %s\n", strerror(errno)));
			return (1);
		}
		if (read(fd, (char *)ffp_save, symhdr.estrMax) !=
		    symhdr.estrMax) {
			WARN(("read string table: %s\n", strerror(errno)));
			return (1);
		}
		ffp_save += symhdr.estrMax;
		printf("+%d]", symhdr.estrMax);
		esym = ((ffp_save + sizeof(int) - 1) & ~(sizeof(int) - 1));
		ssym = (vaddr_t)symtab;
	}

	ffp_save = ALPHA_K0SEG_TO_PHYS((ffp_save + PGOFSET & ~PGOFSET)) >>
	    PGSHIFT;
	ffp_save += 2;		/* XXX OSF/1 does this, no idea why. */

	(void)printf("\n");
	*entryp = coff->a.entry;
	return (0);
}
#endif /* ALPHA_BOOT_ECOFF */
@


1.15
log
@remove some stuff to make the blocks slightly smaller.  we could go further
still.  tested by matthieu
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.14 2003/10/18 20:14:43 jmc Exp $	*/
d67 2
d93 1
a93 1
		(void)printf("open %s: %s\n", fname, strerror(errno));
d99 1
a99 1
		(void)printf("read header: %s\n", strerror(errno));
d138 1
a138 1
		(void)printf("seek to text: %s\n", strerror(errno));
d143 1
a143 1
		(void)printf("read text: %s\n", strerror(errno));
d152 1
a152 1
			(void)printf("read data: %s\n", strerror(errno));
d173 2
a174 2
			printf("seek to symbol table header: %s\n",
			    strerror(errno));
d178 2
a179 2
			printf("read symbol table header: %s\n",
			    strerror(errno));
d189 1
a189 1
			printf("lseek to symbol table: %s\n", strerror(errno));
d195 1
a195 1
				printf("read symbols: %s\n", strerror(errno));
d209 1
a209 1
			printf("seek to string table: %s\n", strerror(errno));
d214 1
a214 1
			printf("read string table: %s\n", strerror(errno));
d250 1
a250 1
			(void)printf("read phdr: %s\n", strerror(errno));
d262 1
a262 1
			(void)printf("read text: %s\n", strerror(errno));
d286 1
a286 1
		printf("seek to section headers: %s\n", strerror(errno));
d295 1
a295 1
		printf("read section headers: %d\n", strerror(errno));
d319 1
a319 1
				printf("lseek symbols: %s\n", strerror(errno));
d324 1
a324 1
				printf("read symbols: %s\n", strerror(errno));
@


1.14
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.13 2003/06/02 23:27:43 millert Exp $	*/
d86 1
a86 1
	(void)printf("\nLoading %s...\n", fname);
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.12 2002/03/14 01:26:27 millert Exp $	*/
d278 1
a278 1
	 * Retreive symbols.
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.11 2001/05/16 00:38:15 deraadt Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.11
log
@shrink printf messages
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.10 2001/01/16 15:34:22 art Exp $	*/
d61 1
a61 1
static int coff_exec __P((int, struct ecoff_exechdr *, u_int64_t *));
d64 1
a64 1
static int elf_exec __P((int, Elf64_Ehdr *, u_int64_t *));
d66 1
a66 1
int loadfile __P((char *, u_int64_t *));
@


1.11.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.11 2001/05/16 00:38:15 deraadt Exp $	*/
d61 1
a61 1
static int coff_exec(int, struct ecoff_exechdr *, u_int64_t *);
d64 1
a64 1
static int elf_exec(int, Elf64_Ehdr *, u_int64_t *);
d66 1
a66 1
int loadfile(char *, u_int64_t *);
@


1.10
log
@First shot at loading elf symbols. Not sure yet if it works correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.9 2000/12/14 13:47:47 art Exp $	*/
d324 2
a325 1
			if (read(fd, (void *)ffp_save, shp[i].sh_size) != shp[i].sh_size) {
@


1.9
log
@First shot at making ELF compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.8 2000/11/08 16:01:24 art Exp $	*/
d243 4
a246 1
	int first = 1;
d279 66
@


1.8
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.7 1998/09/04 17:03:24 millert Exp $	*/
d64 1
a64 1
static int elf_exec __P((int, Elf_Ehdr *, u_int64_t *));
d85 1
a85 1
		Elf_Ehdr elf;
d111 1
a111 1
	if (memcmp(Elf_e_ident, hdr.elf.e_ident, Elf_e_siz) == 0) {
d239 1
a239 1
	Elf_Ehdr *elf;
d246 1
a246 1
		Elf_Phdr phdr;
d252 2
a253 2
		if (phdr.p_type != Elf_pt_load ||
		    (phdr.p_flags & (Elf_pf_w|Elf_pf_x)) == 0)
d270 1
a270 1
			bzero(phdr.p_vaddr + phdr.p_filesz,
@


1.7
log
@ o check lseek return values
 o better error messages on read failure
 o use SEEK_SET, not 0 in lseek
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.6 1997/07/08 20:22:16 niklas Exp $	*/
d68 2
a69 1
vm_offset_t ffp_save, ptbr_save, esym;
d222 1
@


1.7.8.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.10 2001/01/16 15:34:22 art Exp $	*/
d64 1
a64 1
static int elf_exec __P((int, Elf64_Ehdr *, u_int64_t *));
d68 1
a68 2
paddr_t ffp_save, ptbr_save;
vaddr_t ssym, esym;
d84 1
a84 1
		Elf64_Ehdr elf;
d110 1
a110 1
	if (memcmp(ELFMAG, hdr.elf.e_ident, SELFMAG) == 0) {
a220 1
		ssym = (vaddr_t)symtab;
d237 1
a237 1
	Elf64_Ehdr *elf;
d241 1
a241 4
	int first = 1, havesyms;
	Elf64_Shdr *shp;
	Elf64_Off off;
	size_t sz;
d244 1
a244 1
		Elf64_Phdr phdr;
d250 2
a251 2
		if (phdr.p_type != PT_LOAD ||
		    (phdr.p_flags & (PF_W|PF_X)) == 0)
d268 1
a268 1
			bzero((caddr_t)phdr.p_vaddr + phdr.p_filesz,
a273 66
	ffp_save = roundup(ffp_save, sizeof(long));

	/*
	 * Retreive symbols.
	 */
	ssym = ffp_save;
	ffp_save += sizeof(Elf64_Ehdr);

	if (lseek(fd, elf->e_shoff, SEEK_SET) == -1)  {
		printf("seek to section headers: %s\n", strerror(errno));
		return (1);
	}

	sz = elf->e_shnum * sizeof(Elf64_Shdr);
	shp = (Elf64_Shdr *)ffp_save;
	ffp_save += roundup(sz, sizeof(long));

	if (read(fd, shp, sz) != sz) {
		printf("read section headers: %d\n", strerror(errno));
		return (1);
	}

	/*
	 * Now load the symbol sections themselves.  Make sure the
	 * sections are aligned. Don't bother with string tables if
	 * there are no symbol sections.
	 */
	off = roundup((sizeof(Elf64_Ehdr) + sz), sizeof(long));

	for (havesyms = i = 0; i < elf->e_shnum; i++)
		if (shp[i].sh_type == SHT_SYMTAB)
			havesyms = 1;

	if (!havesyms)
		goto no_syms;

	for (first = 1, i = 0; i < elf->e_shnum; i++) {
		if (shp[i].sh_type == SHT_SYMTAB ||
		    shp[i].sh_type == SHT_STRTAB) {
			printf("%s%ld", first ? " [" : "+",
			       (u_long)shp[i].sh_size);
			if (lseek(fd, shp[i].sh_offset, SEEK_SET) == -1) {
				printf("lseek symbols: %s\n", strerror(errno));
				return (1);
			}
			if (read(fd, (void *)ffp_save, shp[i].sh_size) != shp[i].sh_size) {
				printf("read symbols: %s\n", strerror(errno));
				return (1);
			}
			ffp_save += roundup(shp[i].sh_size, sizeof(long));
			shp[i].sh_offset = off;
			off += roundup(shp[i].sh_size, sizeof(long));
			first = 0;
		}
	}
	if (havesyms && first == 0)
		printf("]");

	elf->e_phoff = 0;
	elf->e_shoff = sizeof(Elf64_Ehdr);
	elf->e_phentsize = 0;
	elf->e_phnum = 0;
	bcopy(elf, (void *)ssym, sizeof(*elf));

no_syms:
	esym = ffp_save;
@


1.7.8.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.7.8.1 2001/04/18 16:01:40 niklas Exp $	*/
d324 1
a324 2
			if (read(fd, (void *)ffp_save, shp[i].sh_size) !=
			    shp[i].sh_size) {
@


1.7.8.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d61 1
a61 1
static int coff_exec(int, struct ecoff_exechdr *, u_int64_t *);
d64 1
a64 1
static int elf_exec(int, Elf64_Ehdr *, u_int64_t *);
d66 1
a66 1
int loadfile(char *, u_int64_t *);
@


1.7.8.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.7.8.3 2002/03/28 10:06:13 niklas Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.8.5
log
@Merge of -current from two weeks ago into the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d278 1
a278 1
	 * Retrieve symbols.
@


1.6
log
@The a.out nlist strtab offset needs the strtab size field accounted for
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.4 1997/07/08 10:42:24 niklas Exp $	*/
a86 1
	ssize_t nr;
d99 1
a99 1
	if ((nr = read(fd, &hdr, sizeof(hdr))) != sizeof(hdr)) {
d134 1
a134 1
	int i, symsize;
d138 4
a141 1
	(void)lseek(fd, ECOFF_TXTOFF(coff), 0);
d172 6
a177 2
	if (coff->f.f_symptr) {
		lseek(fd, coff->f.f_symptr, 0);
d179 2
a180 1
			printf("read data: %s\n", strerror(errno));
d189 6
a194 2
		lseek(fd, symhdr.cbExtOffset, 0);
		for (i = 0; i < symhdr.esymMax; i++) {
d196 1
a196 1
				printf("read data: %s\n", strerror(errno));
d209 4
a212 1
		lseek(fd, symhdr.cbSsExtOffset, 0);
d215 1
a215 1
			printf("read data: %s\n", strerror(errno));
d245 1
a245 1
		(void)lseek(fd, elf->e_phoff + sizeof(phdr) * i, 0);
d256 1
a256 1
		(void)lseek(fd, phdr.p_offset, 0);
@


1.5
log
@set N_TEXT when appropriate.  get rid of nlist.h inclusion.
@
text
@d188 1
a188 1
			symtab->n_un.n_strx = sym.es_strindex;
@


1.4
log
@Load the kernel symbol table for DDB to use
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.3 1997/05/05 06:01:49 millert Exp $	*/
d55 1
a55 3
/* XXX this is a userland header!!! must go. */
#define _AOUT_INCLUDE_
#include <nlist.h>
d191 2
@


1.3
log
@Updates from NetBSD (cgd):
 - seriously clean up makefiles.  use libsa/libkern/libz as appropriate,
   and don't build the various sources into objs locally by specifying
   them directly in the Makefiles.
 - move the secondary bootstrap down (to 0x20004000), and add a HEAP_LIMIT
   so that we don't exhaust our bootstrap address space (when using the new,
   not yet checked in, memory allocator).
 - clean up installboot, deal with secondary bootstrap programs not on
   'a' partition or 'a' partition not starting at 0.
 - add padding to structures in bbinfo.h for future expansion.  Add a
   netbbinfo structure to allow netboot information to be hard-coded in
   network boot blocks, so that they can be made to work even on systems
   with firmware which doesn't support the new "ethernet address in boot
   device" convention.
 - move the sync() calls to the correct place in installboot.c
 - remove a kludge in disk.c which was breaking multiple opens/closes
   of the disk
 - allow netboot ethernet address to be hard-coded into binary so that
   machines with old firmware which doesn't pass it in the boot device
   can work.  Assume that if the ethernet address isn't passed in, it
   uses the old (dain-bramaged) 'read' interface works on my 3000/300LX.
 - Add setnetbootinfo, a program to hard code an ethernet address into
   a network boot.
 - move an 'int debug;' into boot.c (it was the only diff between boot.c and
   netboot.c), and nuke netboot.c (using boot.c instead for net boot blocks).
 - add cd9660 file system ops to the file system ops table in filesystem.c
 - if a file name is given (i.e. BOOTED_FILE) is set, boot only that file,
   but if not then try to boot "bsd", "bsd.bak", "bsd.old", and
   "obsd" (in that order) until one is found or until the list of names
   is exhausted.
 - add support for reading gzipped kernels.
 - use strerror() to print errors, rather than just printing error numbers
 - if no disk label exists, fake one up
 - slightly relax the block size checks in bootxx.c; they were a bit to paranoid

And local changes:
 - don't build a copy of libsa/libkern/libz for each boot prog,
   just build a single copy and use it for everything.
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.2 1996/11/27 19:54:48 niklas Exp $	*/
d55 4
d70 1
a70 1
vm_offset_t ffp_save, ptbr_save;
d134 4
d170 41
a210 1
	ffp_save = ALPHA_K0SEG_TO_PHYS((ffp_save + PGOFSET & ~PGOFSET)) >> PGSHIFT;
@


1.2
log
@Make compilable in our env.  Involved disabling ELF support,
reordering includes (due to -Wstrict-prototypes) and other -Wall goo
@
text
@d1 2
a2 2
/*	$OpenBSD: loadfile.c,v 1.1 1996/10/30 22:40:33 niklas Exp $	*/
/*	$NetBSD: loadfile.c,v 1.3 1996/09/23 04:32:44 cgd Exp $	*/
d88 2
d93 1
a93 1
		(void)printf("open %s: error %d\n", fname, errno);
d99 1
a99 1
		(void)printf("read header: error %d\n", errno);
d136 1
a136 1
		(void)printf("read text: %d\n", errno);
d145 1
a145 1
			(void)printf("read data: %d\n", errno);
d185 1
a185 1
			(void)printf("read phdr: %d\n", errno);
d197 1
a197 1
			(void)printf("read text: %d\n", errno);
@


1.1
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: loadfile.c,v 1.3 1996/09/23 04:32:44 cgd Exp $	*/
d44 1
a45 1
#include <lib/libkern/libkern.h>
d52 1
d152 1
a152 1
		bzero(coff->a.bss_start, coff->a.bsize);
@
