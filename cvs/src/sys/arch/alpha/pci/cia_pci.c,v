head	1.13;
access;
symbols
	OPENBSD_6_2:1.13.0.10
	OPENBSD_6_2_BASE:1.13
	OPENBSD_6_1:1.13.0.8
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.22
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.14
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.18
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.16
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.12
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.11.0.18
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.14
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.16
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.12
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.10.0.10
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.8
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.6
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.8
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.8.0.2
	UBC_BASE:1.8
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.5.0.18
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.16
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.14
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.12
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.13
date	2015.10.30.07.51.49;	author miod;	state Exp;
branches;
next	1.12;
commitid	z4wcFsTNnTFyyLXA;

1.12
date	2010.12.04.17.06.31;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.26.20.23.08;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.18.20.14.42;	author jmc;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.27;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.06.19.53.13;	author miod;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.11.08.20.59.25;	author ericj;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.08.16.01.18;	author art;	state Exp;
branches;
next	1.5;

1.5
date	97.01.24.19.57.39;	author niklas;	state Exp;
branches
	1.5.14.1;
next	1.4;

1.4
date	96.10.30.22.39.56;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.07.29.23.00.21;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.18.09.44.09;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.14.03.53.23;	author deraadt;	state Exp;
branches;
next	;

1.5.14.1
date	2001.04.18.16.01.12;	author niklas;	state Exp;
branches;
next	1.5.14.2;

1.5.14.2
date	2001.11.13.21.00.49;	author niklas;	state Exp;
branches;
next	1.5.14.3;

1.5.14.3
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	1.5.14.4;

1.5.14.4
date	2004.02.19.09.59.34;	author niklas;	state Exp;
branches;
next	;

1.8.2.1
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Use NULL instead of 0 for pci_decompose_tag() pointer arguments.
@
text
@/* $OpenBSD: cia_pci.c,v 1.12 2010/12/04 17:06:31 miod Exp $ */
/* $NetBSD: cia_pci.c,v 1.25 2000/06/29 08:58:46 mrg Exp $ */

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>

#include <uvm/uvm_extern.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <alpha/pci/ciareg.h>
#include <alpha/pci/ciavar.h>

void		cia_attach_hook(struct device *, struct device *,
		    struct pcibus_attach_args *);
int		cia_bus_maxdevs(void *, int);
pcitag_t	cia_make_tag(void *, int, int, int);
void		cia_decompose_tag(void *, pcitag_t, int *, int *,
		    int *);
int		cia_conf_size(void *, pcitag_t);
pcireg_t	cia_conf_read(void *, pcitag_t, int);
void		cia_conf_write(void *, pcitag_t, int, pcireg_t);

void
cia_pci_init(pc, v)
	pci_chipset_tag_t pc;
	void *v;
{

	pc->pc_conf_v = v;
	pc->pc_attach_hook = cia_attach_hook;
	pc->pc_bus_maxdevs = cia_bus_maxdevs;
	pc->pc_make_tag = cia_make_tag;
	pc->pc_decompose_tag = cia_decompose_tag;
	pc->pc_conf_size = cia_conf_size;
	pc->pc_conf_read = cia_conf_read;
	pc->pc_conf_write = cia_conf_write;
}

void
cia_attach_hook(parent, self, pba)
	struct device *parent, *self;
	struct pcibus_attach_args *pba;
{
}

int
cia_bus_maxdevs(cpv, busno)
	void *cpv;
	int busno;
{

	return 32;
}

pcitag_t
cia_make_tag(cpv, b, d, f)
	void *cpv;
	int b, d, f;
{

	return (b << 16) | (d << 11) | (f << 8);
}

void
cia_decompose_tag(cpv, tag, bp, dp, fp)
	void *cpv;
	pcitag_t tag;
	int *bp, *dp, *fp;
{

	if (bp != NULL)
		*bp = (tag >> 16) & 0xff;
	if (dp != NULL)
		*dp = (tag >> 11) & 0x1f;
	if (fp != NULL)
		*fp = (tag >> 8) & 0x7;
}

int
cia_conf_size(void *cpv, pcitag_t tag)
{
	return PCI_CONFIG_SPACE_SIZE;
}

pcireg_t
cia_conf_read(cpv, tag, offset)
	void *cpv;
	pcitag_t tag;
	int offset;
{
	struct cia_config *ccp = cpv;
	pcireg_t *datap, data;
	int s, secondary, ba;
	u_int32_t old_cfg, errbits;

#ifdef __GNUC__
	s = 0;					/* XXX gcc -Wuninitialized */
	old_cfg = 0;				/* XXX gcc -Wuninitialized */
#endif

	/*
	 * Some (apparently common) revisions of EB164 and AlphaStation
	 * firmware do the Wrong thing with PCI master and target aborts,
	 * which are caused by accessing the configuration space of devices
	 * that don't exist (for example).
	 *
	 * To work around this, we clear the CIA error register's PCI
	 * master and target abort bits before touching PCI configuration
	 * space and check it afterwards.  If it indicates a master or target
	 * abort, the device wasn't there so we return 0xffffffff.
	 */
	REGVAL(CIA_CSR_CIA_ERR) = CIA_ERR_RCVD_MAS_ABT|CIA_ERR_RCVD_TAR_ABT;
	alpha_mb();
	alpha_pal_draina();	

	/* secondary if bus # != 0 */
	pci_decompose_tag(&ccp->cc_pc, tag, &secondary, NULL, NULL);
	if (secondary) {
		s = splhigh();
		old_cfg = REGVAL(CIA_CSR_CFG);
		alpha_mb();
		REGVAL(CIA_CSR_CFG) = old_cfg | 0x1;
		alpha_mb();
	}

	/*
	 * We just inline the BWX support, since this is the only
	 * difference between BWX and swiz for config space.
	 */
	if (ccp->cc_flags & CCF_PCI_USE_BWX) {
		if (secondary) {
			datap =
			    (pcireg_t *)ALPHA_PHYS_TO_K0SEG(CIA_EV56_BWCONF1 |
				tag | (offset & ~0x03));
		} else {
			datap =
			    (pcireg_t *)ALPHA_PHYS_TO_K0SEG(CIA_EV56_BWCONF0 |
				tag | (offset & ~0x03));
		}
	} else {
		datap = (pcireg_t *)ALPHA_PHYS_TO_K0SEG(CIA_PCI_CONF |
		    tag << 5UL |				/* XXX */
		    (offset & ~0x03) << 5 |			/* XXX */
		    0 << 5 |					/* XXX */
		    0x3 << 3);					/* XXX */
	}
	data = (pcireg_t)-1;
	alpha_mb();
	if (!(ba = badaddr(datap, sizeof *datap)))
		data = *datap;
	alpha_mb();
	alpha_mb();

	if (secondary) {
		alpha_mb();
		REGVAL(CIA_CSR_CFG) = old_cfg;
		alpha_mb();
		splx(s);
	}

	alpha_pal_draina();	
	alpha_mb();
	errbits = REGVAL(CIA_CSR_CIA_ERR);
	if (errbits & (CIA_ERR_RCVD_MAS_ABT|CIA_ERR_RCVD_TAR_ABT)) {
		ba = 1;
		data = 0xffffffff;
	}

	if (errbits) {
		REGVAL(CIA_CSR_CIA_ERR) = errbits;
		alpha_mb();
		alpha_pal_draina();
	}

#if 0
	printf("cia_conf_read: tag 0x%lx, reg 0x%lx -> %x @@ %p%s\n", tag, reg,
	    data, datap, ba ? " (badaddr)" : "");
#endif

	return data;
}

void
cia_conf_write(cpv, tag, offset, data)
	void *cpv;
	pcitag_t tag;
	int offset;
	pcireg_t data;
{
	struct cia_config *ccp = cpv;
	pcireg_t *datap;
	int s, secondary;
	u_int32_t old_cfg;

#ifdef __GNUC__
	s = 0;					/* XXX gcc -Wuninitialized */
	old_cfg = 0;				/* XXX gcc -Wuninitialized */
#endif

	/* secondary if bus # != 0 */
	pci_decompose_tag(&ccp->cc_pc, tag, &secondary, NULL, NULL);
	if (secondary) {
		s = splhigh();
		old_cfg = REGVAL(CIA_CSR_CFG);
		alpha_mb();
		REGVAL(CIA_CSR_CFG) = old_cfg | 0x1;
		alpha_mb();
	}

	/*
	 * We just inline the BWX support, since this is the only
	 * difference between BWX and swiz for config space.
	 */
	if (ccp->cc_flags & CCF_PCI_USE_BWX) {
		if (secondary) {
			datap =
			    (pcireg_t *)ALPHA_PHYS_TO_K0SEG(CIA_EV56_BWCONF1 |
				tag | (offset & ~0x03));
		} else {
			datap =
			    (pcireg_t *)ALPHA_PHYS_TO_K0SEG(CIA_EV56_BWCONF0 |
				tag | (offset & ~0x03));
		}
	} else {
		datap = (pcireg_t *)ALPHA_PHYS_TO_K0SEG(CIA_PCI_CONF |
		    tag << 5UL |				/* XXX */
		    (offset & ~0x03) << 5 |			/* XXX */
		    0 << 5 |					/* XXX */
		    0x3 << 3);					/* XXX */
	}
	alpha_mb();
	*datap = data;
	alpha_mb();
	alpha_mb();

	if (secondary) {
		alpha_mb();
		REGVAL(CIA_CSR_CFG) = old_cfg;
		alpha_mb();
		splx(s);
	}

#if 0
	printf("cia_conf_write: tag 0x%lx, reg 0x%lx -> 0x%x @@ %p\n", tag,
	    reg, data, datap);
#endif
}
@


1.12
log
@Introduce a new pci routine, pci_conf_size(), which returns the size of a
given pcitag_t configuration address space. Currently, all pci controllers
will return the usual 0x100 bytes of PCI configuration space, but this will
eventually change on PCIe-capable controlers.
ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: cia_pci.c,v 1.11 2006/03/26 20:23:08 brad Exp $ */
d147 1
a147 1
	pci_decompose_tag(&ccp->cc_pc, tag, &secondary, 0, 0);
d231 1
a231 1
	pci_decompose_tag(&ccp->cc_pc, tag, &secondary, 0, 0);
@


1.11
log
@Replace usage of alpha_pci_decompose_tag() with pci_decompose_tag() and
remove alpha_pci_decompose_tag().

From NetBSD

ok martin@@
@
text
@d1 1
a1 1
/* $OpenBSD: cia_pci.c,v 1.10 2003/10/18 20:14:42 jmc Exp $ */
d49 1
d64 1
d107 6
@


1.10
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/* $OpenBSD: cia_pci.c,v 1.9 2002/03/14 01:26:27 millert Exp $ */
d139 1
a139 1
	alpha_pci_decompose_tag(&ccp->cc_pc, tag, &secondary, 0, 0);
d223 1
a223 1
	alpha_pci_decompose_tag(&ccp->cc_pc, tag, &secondary, 0, 0);
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: cia_pci.c,v 1.8 2001/11/06 19:53:13 miod Exp $ */
d124 1
a124 1
	 * Some (apparently-common) revisions of EB164 and AlphaStation
d126 1
a126 1
	 * which are caused by accesing the configuration space of devices
@


1.8
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/* $OpenBSD: cia_pci.c,v 1.7 2000/11/08 20:59:25 ericj Exp $ */
d43 8
a50 8
void		cia_attach_hook __P((struct device *, struct device *,
		    struct pcibus_attach_args *));
int		cia_bus_maxdevs __P((void *, int));
pcitag_t	cia_make_tag __P((void *, int, int, int));
void		cia_decompose_tag __P((void *, pcitag_t, int *, int *,
		    int *));
pcireg_t	cia_conf_read __P((void *, pcitag_t, int));
void		cia_conf_write __P((void *, pcitag_t, int, pcireg_t));
@


1.8.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: cia_pci.c,v 1.8 2001/11/06 19:53:13 miod Exp $ */
d43 8
a50 8
void		cia_attach_hook(struct device *, struct device *,
		    struct pcibus_attach_args *);
int		cia_bus_maxdevs(void *, int);
pcitag_t	cia_make_tag(void *, int, int, int);
void		cia_decompose_tag(void *, pcitag_t, int *, int *,
		    int *);
pcireg_t	cia_conf_read(void *, pcitag_t, int);
void		cia_conf_write(void *, pcitag_t, int, pcireg_t);
@


1.7
log
@add tags
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a35 1
#include <vm/vm.h>
@


1.6
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
@


1.5
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 2
/*	$OpenBSD: cia_pci.c,v 1.4 1996/10/30 22:39:56 niklas Exp $	*/
/*	$NetBSD: cia_pci.c,v 1.7 1996/11/23 06:46:50 cgd Exp $	*/
d34 1
d36 1
a36 2

#include <machine/autoconf.h>	/* badaddr proto */
a42 3
#include <machine/rpb.h>	/* XXX for eb164 CIA firmware workarounds. */
#include "dec_eb164.h"		/* XXX for eb164 CIA firmware workarounds. */

d116 1
a116 4
	int32_t old_haxr2;					/* XXX */
#if NDEC_EB164
	extern int cputype;					/* XXX */
#endif
d118 1
a118 1
#ifdef DIAGNOSTIC
d120 1
a120 1
	old_haxr2 = 0;				/* XXX gcc -Wuninitialized */
a122 1
#if NDEC_EB164
d124 4
a127 4
	 * Some (apparently-common) revisions of EB164 firmware do the
	 * Wrong thing with PCI master aborts, which are caused by
	 * accesing the configuration space of devices that don't
	 * exist (for example).
d129 4
a132 4
	 * On EB164's we clear the CIA error register's PCI master
	 * abort bit before touching PCI configuration space and
	 * check it afterwards.  If it indicates a master abort,
	 * the device wasn't there so we return 0xffffffff.
d134 3
a136 7
	if (cputype == ST_EB164) {
		/* clear the PCI master abort bit in CIA error register */
		REGVAL(CIA_CSR_CIA_ERR) = 0x00000080;		/* XXX */
		alpha_mb();
		alpha_pal_draina();	
	}
#endif
d139 1
a139 1
	pci_decompose_tag(&ccp->cc_pc, tag, &secondary, 0, 0);
d142 1
a142 1
		old_haxr2 = REGVAL(CIA_CSRS + 0x480);		/* XXX */
d144 1
a144 1
		REGVAL(CIA_CSRS + 0x480) = old_haxr2 | 0x1;	/* XXX */
d148 21
a168 5
	datap = (pcireg_t *)ALPHA_PHYS_TO_K0SEG(CIA_PCI_CONF |
	    tag << 5UL |					/* XXX */
	    (offset & ~0x03) << 5 |				/* XXX */
	    0 << 5 |						/* XXX */
	    0x3 << 3);						/* XXX */
d170 1
d173 2
d178 1
a178 1
		REGVAL(CIA_CSRS + 0x480) = old_haxr2;		/* XXX */
d183 12
a194 8
#if NDEC_EB164
	if (cputype == ST_EB164) {
		alpha_pal_draina();	
		/* check CIA error register for PCI master abort */
		if (REGVAL(CIA_CSR_CIA_ERR) & 0x00000080) {	/* XXX */
			ba = 1;
			data = 0xffffffff;
		}
a195 1
#endif
d215 1
a215 1
	int32_t old_haxr2;					/* XXX */
d217 1
a217 1
#ifdef DIAGNOSTIC
d219 1
a219 1
	old_haxr2 = 0;				/* XXX gcc -Wuninitialized */
d223 1
a223 1
	pci_decompose_tag(&ccp->cc_pc, tag, &secondary, 0, 0);
d226 1
a226 1
		old_haxr2 = REGVAL(CIA_CSRS + 0x480);		/* XXX */
d228 1
a228 1
		REGVAL(CIA_CSRS + 0x480) = old_haxr2 | 0x1;	/* XXX */
d232 22
a253 5
	datap = (pcireg_t *)ALPHA_PHYS_TO_K0SEG(CIA_PCI_CONF |
	    tag << 5UL |					/* XXX */
	    (offset & ~0x03) << 5 |				/* XXX */
	    0 << 5 |						/* XXX */
	    0x3 << 3);						/* XXX */
d255 2
d260 1
a260 1
		REGVAL(CIA_CSRS + 0x480) = old_haxr2;		/* XXX */
@


1.5.14.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 2
/* $OpenBSD: cia_pci.c,v 1.7 2000/11/08 20:59:25 ericj Exp $ */
/* $NetBSD: cia_pci.c,v 1.25 2000/06/29 08:58:46 mrg Exp $ */
d35 1
d37 1
a37 2
#include <vm/vm.h>
#include <uvm/uvm_extern.h>
d44 3
d120 4
a123 1
	u_int32_t old_cfg, errbits;
d125 1
a125 1
#ifdef __GNUC__
d127 1
a127 1
	old_cfg = 0;				/* XXX gcc -Wuninitialized */
d130 1
d132 4
a135 4
	 * Some (apparently-common) revisions of EB164 and AlphaStation
	 * firmware do the Wrong thing with PCI master and target aborts,
	 * which are caused by accesing the configuration space of devices
	 * that don't exist (for example).
d137 4
a140 4
	 * To work around this, we clear the CIA error register's PCI
	 * master and target abort bits before touching PCI configuration
	 * space and check it afterwards.  If it indicates a master or target
	 * abort, the device wasn't there so we return 0xffffffff.
d142 7
a148 3
	REGVAL(CIA_CSR_CIA_ERR) = CIA_ERR_RCVD_MAS_ABT|CIA_ERR_RCVD_TAR_ABT;
	alpha_mb();
	alpha_pal_draina();	
d151 1
a151 1
	alpha_pci_decompose_tag(&ccp->cc_pc, tag, &secondary, 0, 0);
d154 1
a154 1
		old_cfg = REGVAL(CIA_CSR_CFG);
d156 1
a156 1
		REGVAL(CIA_CSR_CFG) = old_cfg | 0x1;
d160 5
a164 21
	/*
	 * We just inline the BWX support, since this is the only
	 * difference between BWX and swiz for config space.
	 */
	if (ccp->cc_flags & CCF_PCI_USE_BWX) {
		if (secondary) {
			datap =
			    (pcireg_t *)ALPHA_PHYS_TO_K0SEG(CIA_EV56_BWCONF1 |
				tag | (offset & ~0x03));
		} else {
			datap =
			    (pcireg_t *)ALPHA_PHYS_TO_K0SEG(CIA_EV56_BWCONF0 |
				tag | (offset & ~0x03));
		}
	} else {
		datap = (pcireg_t *)ALPHA_PHYS_TO_K0SEG(CIA_PCI_CONF |
		    tag << 5UL |				/* XXX */
		    (offset & ~0x03) << 5 |			/* XXX */
		    0 << 5 |					/* XXX */
		    0x3 << 3);					/* XXX */
	}
a165 1
	alpha_mb();
a167 2
	alpha_mb();
	alpha_mb();
d171 1
a171 1
		REGVAL(CIA_CSR_CFG) = old_cfg;
d176 8
a183 12
	alpha_pal_draina();	
	alpha_mb();
	errbits = REGVAL(CIA_CSR_CIA_ERR);
	if (errbits & (CIA_ERR_RCVD_MAS_ABT|CIA_ERR_RCVD_TAR_ABT)) {
		ba = 1;
		data = 0xffffffff;
	}

	if (errbits) {
		REGVAL(CIA_CSR_CIA_ERR) = errbits;
		alpha_mb();
		alpha_pal_draina();
d185 1
d205 1
a205 1
	u_int32_t old_cfg;
d207 1
a207 1
#ifdef __GNUC__
d209 1
a209 1
	old_cfg = 0;				/* XXX gcc -Wuninitialized */
d213 1
a213 1
	alpha_pci_decompose_tag(&ccp->cc_pc, tag, &secondary, 0, 0);
d216 1
a216 1
		old_cfg = REGVAL(CIA_CSR_CFG);
d218 1
a218 1
		REGVAL(CIA_CSR_CFG) = old_cfg | 0x1;
d222 5
a226 22
	/*
	 * We just inline the BWX support, since this is the only
	 * difference between BWX and swiz for config space.
	 */
	if (ccp->cc_flags & CCF_PCI_USE_BWX) {
		if (secondary) {
			datap =
			    (pcireg_t *)ALPHA_PHYS_TO_K0SEG(CIA_EV56_BWCONF1 |
				tag | (offset & ~0x03));
		} else {
			datap =
			    (pcireg_t *)ALPHA_PHYS_TO_K0SEG(CIA_EV56_BWCONF0 |
				tag | (offset & ~0x03));
		}
	} else {
		datap = (pcireg_t *)ALPHA_PHYS_TO_K0SEG(CIA_PCI_CONF |
		    tag << 5UL |				/* XXX */
		    (offset & ~0x03) << 5 |			/* XXX */
		    0 << 5 |					/* XXX */
		    0x3 << 3);					/* XXX */
	}
	alpha_mb();
a227 2
	alpha_mb();
	alpha_mb();
d231 1
a231 1
		REGVAL(CIA_CSR_CFG) = old_cfg;
@


1.5.14.2
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d36 1
@


1.5.14.3
log
@Merge in -current from about a week ago
@
text
@d43 8
a50 8
void		cia_attach_hook(struct device *, struct device *,
		    struct pcibus_attach_args *);
int		cia_bus_maxdevs(void *, int);
pcitag_t	cia_make_tag(void *, int, int, int);
void		cia_decompose_tag(void *, pcitag_t, int *, int *,
		    int *);
pcireg_t	cia_conf_read(void *, pcitag_t, int);
void		cia_conf_write(void *, pcitag_t, int, pcireg_t);
@


1.5.14.4
log
@Merge of -current from two weeks ago into the SMP branch
@
text
@d124 1
a124 1
	 * Some (apparently common) revisions of EB164 and AlphaStation
d126 1
a126 1
	 * which are caused by accessing the configuration space of devices
@


1.4
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 2
a2 2
/*	$OpenBSD: cia_pci.c,v 1.5 1996/10/13 03:00:04 christos Exp $	*/
/*	$NetBSD: cia_pci.c,v 1.5 1996/10/13 03:00:04 christos Exp $	*/
d44 3
d121 28
d176 11
d206 5
@


1.3
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: cia_pci.c,v 1.2 1996/04/12 23:37:10 cgd Exp $	*/
/*	$NetBSD: cia_pci.c,v 1.2 1996/04/12 23:37:10 cgd Exp $	*/
d37 2
d124 1
a124 1
		wbflush();
d126 1
a126 1
		wbflush();
d129 1
a129 1
	datap = (pcireg_t *)phystok0seg(CIA_PCI_CONF |
d139 1
a139 1
		wbflush();
d141 1
a141 1
		wbflush();
d170 1
a170 1
		wbflush();
d172 1
a172 1
		wbflush();
d175 1
a175 1
	datap = (pcireg_t *)phystok0seg(CIA_PCI_CONF |
d183 1
a183 1
		wbflush();
d185 1
a185 1
		wbflush();
@


1.2
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.1
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: cia_pci.c,v 1.1 1995/11/23 02:37:29 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1995 Carnegie-Mellon University.
d41 8
a48 14
pci_confreg_t	cia_conf_read __P((void *, pci_conftag_t, pci_confoffset_t));
void		cia_conf_write __P((void *, pci_conftag_t,
		    pci_confoffset_t, pci_confreg_t));
int		cia_find_io __P((void *, pci_conftag_t,
		    pci_confoffset_t, pci_iooffset_t *, pci_iosize_t *));
int		cia_find_mem __P((void *, pci_conftag_t,
		    pci_confoffset_t, pci_moffset_t *, pci_msize_t *, int *));

__const struct pci_conf_fns cia_conf_fns = {
	cia_conf_read,
	cia_conf_write,
	cia_find_io,
	cia_find_mem,
};
d50 56
a105 1
pci_confreg_t
d108 2
a109 2
	pci_conftag_t tag;
	pci_confoffset_t offset;
d111 2
a112 2
	struct cia_config *acp = cpv;
	pci_confreg_t *datap, data;
d116 2
a117 1
	secondary = PCI_TAG_BUS(tag) != 0;
d126 1
a126 1
	datap = (pci_confreg_t *)phystok0seg(CIA_PCI_CONF |
d131 1
a131 1
	data = (pci_confreg_t)-1;
d153 3
a155 3
	pci_conftag_t tag;
	pci_confoffset_t offset;
	pci_confreg_t data;
d157 2
a158 2
	struct cia_config *acp = cpv;
	pci_confreg_t *datap;
d162 2
a163 1
	secondary = PCI_TAG_BUS(tag) != 0;
d172 1
a172 1
	datap = (pci_confreg_t *)phystok0seg(CIA_PCI_CONF |
a189 83
}

int
cia_find_io(cpv, tag, reg, iobasep, sizep)
	void *cpv;
	pci_conftag_t tag;
	pci_confoffset_t reg;
	pci_iooffset_t *iobasep;
	pci_iosize_t *sizep;
{
	struct cia_config *acp = cpv;
	pci_confreg_t addrdata, sizedata;
	pci_iooffset_t pci_iobase;

	if (reg < PCI_MAPREG_START || reg >= PCI_MAPREG_END || (reg & 3))
		panic("cia_map_io: bad request");

	addrdata = PCI_CONF_READ(acp->cc_conffns, acp->cc_confarg, tag, reg);

	PCI_CONF_WRITE(acp->cc_conffns, acp->cc_confarg, tag, reg, 0xffffffff);
	sizedata = PCI_CONF_READ(acp->cc_conffns, acp->cc_confarg, tag, reg);
	PCI_CONF_WRITE(acp->cc_conffns, acp->cc_confarg, tag, reg, addrdata);

	if (PCI_MAPREG_TYPE(addrdata) == PCI_MAPREG_TYPE_MEM)
		panic("cia_map_io: attempt to I/O map an memory region");

	if (iobasep != NULL)
		*iobasep = PCI_MAPREG_IO_ADDRESS(addrdata);
	if (sizep != NULL)
		*sizep = ~PCI_MAPREG_IO_ADDRESS(sizedata) + 1;

	return (0);
}

int
cia_find_mem(cpv, tag, reg, paddrp, sizep, cacheablep)
	void *cpv;
	pci_conftag_t tag;
	pci_confoffset_t reg;
	pci_moffset_t *paddrp;
	pci_msize_t *sizep;
	int *cacheablep;
{
	struct cia_config *acp = cpv;
	pci_confreg_t addrdata, sizedata;

	if (reg < PCI_MAPREG_START || reg >= PCI_MAPREG_END || (reg & 3))
		panic("cia_map_mem: bad request");

	/*
	 * The PROM has mapped the device for us.  We take the address
	 * that's been assigned to the register, and figure out what
	 * physical and virtual addresses go with it...
	 */
	addrdata = PCI_CONF_READ(acp->cc_conffns, acp->cc_confarg, tag, reg);

	PCI_CONF_WRITE(acp->cc_conffns, acp->cc_confarg, tag, reg, 0xffffffff);
	sizedata = PCI_CONF_READ(acp->cc_conffns, acp->cc_confarg, tag, reg);
	PCI_CONF_WRITE(acp->cc_conffns, acp->cc_confarg, tag, reg, addrdata);

	if (PCI_MAPREG_TYPE(addrdata) == PCI_MAPREG_TYPE_IO)
		panic("cia_map_mem: attempt to memory map an I/O region");

	switch (PCI_MAPREG_MEM_TYPE(addrdata)) {
	case PCI_MAPREG_MEM_TYPE_32BIT:
	case PCI_MAPREG_MEM_TYPE_32BIT_1M:
		break;
	case PCI_MAPREG_MEM_TYPE_64BIT:
/* XXX */	printf("cia_map_mem: attempt to map 64-bit region\n");
/* XXX */	break;
	default:
		printf("cia_map_mem: reserved mapping type\n");
		return EINVAL;
	}

	if (paddrp != NULL)
		*paddrp = PCI_MAPREG_MEM_ADDRESS(addrdata);	/* PCI addr */
	if (sizep != NULL)
		*sizep = ~PCI_MAPREG_MEM_ADDRESS(sizedata) + 1;
	if (cacheablep != NULL)
		*cacheablep = PCI_MAPREG_MEM_CACHEABLE(addrdata);

	return 0;
@
