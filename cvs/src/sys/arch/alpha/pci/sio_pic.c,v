head	1.38;
access;
symbols
	OPENBSD_6_2:1.38.0.10
	OPENBSD_6_2_BASE:1.38
	OPENBSD_6_1:1.38.0.8
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.37.0.8
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.37.0.4
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.36.0.4
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.35.0.2
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.33.0.2
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.32.0.6
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.4
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.31.0.6
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.4
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.31.0.2
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.29.0.6
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.2
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.26.0.8
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.26.0.6
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.26.0.4
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.24.0.6
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.24.0.4
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.24.0.2
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.22.0.4
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.22
	OPENBSD_3_3:1.21.0.4
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	UBC_SYNC_B:1.21
	UBC:1.19.0.2
	UBC_BASE:1.19
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_8:1.14.0.10
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.8
	OPENBSD_2_7_BASE:1.14
	SMP:1.14.0.6
	SMP_BASE:1.14
	kame_19991208:1.14
	OPENBSD_2_6:1.14.0.4
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.2
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.9.0.4
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.38
date	2015.08.15.20.06.21;	author miod;	state Exp;
branches;
next	1.37;
commitid	jLU9Anin6PCQe7LI;

1.37
date	2014.04.04.20.00.12;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2014.02.18.19.37.33;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2013.03.08.18.29.33;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2013.03.02.22.54.29;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2012.10.20.19.08.39;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2011.04.15.20.40.05;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2009.09.30.20.16.31;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.29;

1.29
date	2008.08.09.16.41.21;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2008.07.29.18.39.45;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2008.06.26.05.42.09;	author ray;	state Exp;
branches;
next	1.26;

1.26
date	2006.06.15.20.08.29;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2006.01.29.10.47.35;	author martin;	state Exp;
branches;
next	1.24;

1.24
date	2004.06.28.02.28.43;	author aaron;	state Exp;
branches;
next	1.23;

1.23
date	2004.06.18.21.33.42;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.05.11.19.41.09;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.25.21.33.21;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.14.01.26.27;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.10.26.01.28.06;	author nate;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.08.17.22.26.58;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2000.11.25.00.39.05;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.25.00.37.28;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2000.11.08.16.01.22;	author art;	state Exp;
branches;
next	1.14;

1.14
date	99.02.08.18.17.21;	author millert;	state Exp;
branches
	1.14.6.1;
next	1.13;

1.13
date	99.01.11.05.11.03;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.07.01.05.32.42;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	98.06.29.05.32.55;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	98.03.18.00.48.29;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	97.01.24.19.57.59;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.12.08.00.20.49;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.11.12.20.29.39;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.10.30.22.40.15;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.07.29.23.00.55;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.06.18.09.44.39;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.27.22.25.38;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.53.36;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.45;	author deraadt;	state Exp;
branches;
next	;

1.14.6.1
date	2001.04.18.16.01.30;	author niklas;	state Exp;
branches;
next	1.14.6.2;

1.14.6.2
date	2001.10.31.02.52.45;	author nate;	state Exp;
branches;
next	1.14.6.3;

1.14.6.3
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	1.14.6.4;

1.14.6.4
date	2003.03.27.23.18.06;	author niklas;	state Exp;
branches;
next	1.14.6.5;

1.14.6.5
date	2003.05.13.19.41.02;	author ho;	state Exp;
branches;
next	;

1.19.2.1
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2002.10.29.00.28.01;	author art;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2003.05.19.21.38.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.38
log
@If the SRM has explicitely set up some ISA interrupts level-triggered,
honour this setting and consider them level-triggered instead of `polarity
decided by the first driver to use it'.

Add explicit code to turn registration of edge-triggered interrupts 3 and 4
into level-triggered, if they were set up a level-triggered by the SRM.

Based upon a NetBSD diff which eventually got reverted in NetBSD. However,
it turns out this is necessary for the kernel to correctly run with serial
console on my Multia.
@
text
@/*	$OpenBSD: sio_pic.c,v 1.37 2014/04/04 20:00:12 miod Exp $	*/
/* $NetBSD: sio_pic.c,v 1.28 2000/06/06 03:10:13 thorpej Exp $ */

/*-
 * Copyright (c) 1998, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/syslog.h>

#include <machine/intr.h>
#include <machine/bus.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/pci/cy82c693reg.h>
#include <dev/pci/cy82c693var.h>

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>
#include <alpha/pci/siovar.h>

#include "sio.h"

/*
 * To add to the long history of wonderful PROM console traits,
 * AlphaStation PROMs don't reset themselves completely on boot!
 * Therefore, if an interrupt was turned on when the kernel was
 * started, we're not going to EVER turn it off...  I don't know
 * what will happen if new interrupts (that the PROM console doesn't
 * want) are turned on.  I'll burn that bridge when I come to it.
 */
#define	BROKEN_PROM_CONSOLE

/*
 * Private functions and variables.
 */

bus_space_tag_t sio_iot;
pci_chipset_tag_t sio_pc;
bus_space_handle_t sio_ioh_icu1, sio_ioh_icu2;

#define	ICU_LEN		16		/* number of ISA IRQs */

static struct alpha_shared_intr *sio_intr;

#ifndef STRAY_MAX
#define	STRAY_MAX	5
#endif

/*
 * If prom console is broken, must remember the initial interrupt
 * settings and enforce them.  WHEE!
 */
u_int8_t initial_ocw1[2];
u_int8_t initial_elcr[2];

#define	INITIALLY_LEVEL_TRIGGERED(irq)	\
	((initial_elcr[(irq) / 8] & (1 << ((irq) % 8))) != 0)

/*
 * Overrides for ELCR settings.
 * These are used on ES40 and similar systems suffering from a PCI USB HCI
 * interrupt being routed through the ISA logic with actual logic to
 * make it behave an edge-triggered interrupt, although PCI interrupts are
 * supposed to be level-triggered.
 */
u_int8_t elcr_override[2] = { 0x00, 0x00 };

void		sio_setirqstat(int, int, int);
int		sio_intr_alloc(void *, int, int, int *);
int		sio_intr_check(void *, int, int);

u_int8_t	(*sio_read_elcr)(int);
void		(*sio_write_elcr)(int, u_int8_t);
static void	specific_eoi(int);

/******************** i82378 SIO ELCR functions ********************/

int		i82378_setup_elcr(void);
u_int8_t	i82378_read_elcr(int);
void		i82378_write_elcr(int, u_int8_t);

bus_space_handle_t sio_ioh_elcr;

int
i82378_setup_elcr()
{
	int device, maxndevs;
	pcitag_t tag;
	pcireg_t id;
	int rv;

	/*
	 * We could probe configuration space to see that there's
	 * actually an SIO present, but we are using this as a
	 * fall-back in case nothing else matches.
	 */

	rv = bus_space_map(sio_iot, 0x4d0, 2, 0, &sio_ioh_elcr);

	if (rv != 0)
		return 0;

	sio_read_elcr = i82378_read_elcr;
	sio_write_elcr = i82378_write_elcr;

	/*
	 * Search PCI configuration space for an ALI M5237 USB controller
	 * on the first bus.
	 */

	maxndevs = pci_bus_maxdevs(sio_pc, 0);

	for (device = 0; device < maxndevs; device++) {
		tag = pci_make_tag(sio_pc, 0, device, 0);
		id = pci_conf_read(sio_pc, tag, PCI_ID_REG);

		if (id == PCI_ID_CODE(PCI_VENDOR_ALI, PCI_PRODUCT_ALI_M5237)) {
			elcr_override[10 / 8] |= 1 << (10 % 8);
			break;
		}
	}

	return (0);
}

u_int8_t
i82378_read_elcr(elcr)
	int elcr;
{

	return (bus_space_read_1(sio_iot, sio_ioh_elcr, elcr));
}

void
i82378_write_elcr(elcr, val)
	int elcr;
	u_int8_t val;
{

	bus_space_write_1(sio_iot, sio_ioh_elcr, elcr, val);
}

/******************** Cypress CY82C693 ELCR functions ********************/

int		cy82c693_setup_elcr(void);
u_int8_t	cy82c693_read_elcr(int);
void		cy82c693_write_elcr(int, u_int8_t);

const struct cy82c693_handle *sio_cy82c693_handle;

int
cy82c693_setup_elcr()
{
	int device, maxndevs;
	pcitag_t tag;
	pcireg_t id;

	/*
	 * Search PCI configuration space for a Cypress CY82C693.
	 *
	 * Note we can make some assumptions about our bus number
	 * here, because:
	 *
	 *	(1) there can be at most one ISA/EISA bridge per PCI bus, and
	 *
	 *	(2) any ISA/EISA bridges must be attached to primary PCI
	 *	    busses (i.e. bus zero).
	 */

	maxndevs = pci_bus_maxdevs(sio_pc, 0);

	for (device = 0; device < maxndevs; device++) {
		tag = pci_make_tag(sio_pc, 0, device, 0);
		id = pci_conf_read(sio_pc, tag, PCI_ID_REG);

		if (id ==
		    PCI_ID_CODE(PCI_VENDOR_CONTAQ, PCI_PRODUCT_CONTAQ_82C693)) {
			sio_cy82c693_handle = cy82c693_init(sio_iot);
			sio_read_elcr = cy82c693_read_elcr;
			sio_write_elcr = cy82c693_write_elcr;
			return (0);
		}
	}

	/*
	 * Didn't find a CY82C693.
	 */
	return (ENODEV);
}

u_int8_t
cy82c693_read_elcr(elcr)
	int elcr;
{

	return (cy82c693_read(sio_cy82c693_handle, CONFIG_ELCR1 + elcr));
}

void
cy82c693_write_elcr(elcr, val)
	int elcr;
	u_int8_t val;
{

	cy82c693_write(sio_cy82c693_handle, CONFIG_ELCR1 + elcr, val);
}

/******************** ELCR access function configuration ********************/

/*
 * Put the Intel SIO at the end, so we fall back on it if we don't
 * find anything else.  If any of the non-Intel functions find a
 * matching device, but are unable to map it for whatever reason,
 * they should panic.
 */

int (*sio_elcr_setup_funcs[])(void) = {
	cy82c693_setup_elcr,
	i82378_setup_elcr,
	NULL,
};

/******************** Shared SIO/Cypress functions ********************/

void
sio_setirqstat(irq, enabled, type)
	int irq, enabled;
	int type;
{
	u_int8_t ocw1[2], elcr[2];
	int icu, bit;

#if 0
	printf("sio_setirqstat: irq %d: %s, %s\n", irq,
	    enabled ? "enabled" : "disabled", isa_intr_typename(type));
#endif

	icu = irq / 8;
	bit = irq % 8;

	ocw1[0] = bus_space_read_1(sio_iot, sio_ioh_icu1, 1);
	ocw1[1] = bus_space_read_1(sio_iot, sio_ioh_icu2, 1);
	elcr[0] = (*sio_read_elcr)(0);				/* XXX */
	elcr[1] = (*sio_read_elcr)(1);				/* XXX */

	/*
	 * interrupt enable: set bit to mask (disable) interrupt.
	 */
	if (enabled)
		ocw1[icu] &= ~(1 << bit);
	else
		ocw1[icu] |= 1 << bit;

	/*
	 * interrupt type select: set bit to get level-triggered...
	 */
	if (type == IST_LEVEL)
		elcr[icu] |= 1 << bit;
	else
		elcr[icu] &= ~(1 << bit);

	/*
	 * ...unless we pretend to know better.
	 */
	elcr[icu] &= ~elcr_override[icu];

#ifdef not_here
	/* see the init function... */
	ocw1[0] &= ~0x04;		/* always enable IRQ2 on first PIC */
	elcr[0] &= ~0x07;		/* IRQ[0-2] must be edge-triggered */
	elcr[1] &= ~0x21;		/* IRQ[13,8] must be edge-triggered */
#endif

	bus_space_write_1(sio_iot, sio_ioh_icu1, 1, ocw1[0]);
	bus_space_write_1(sio_iot, sio_ioh_icu2, 1, ocw1[1]);
	(*sio_write_elcr)(0, elcr[0]);				/* XXX */
	(*sio_write_elcr)(1, elcr[1]);				/* XXX */
}

void
sio_intr_setup(pc, iot)
	pci_chipset_tag_t pc;
	bus_space_tag_t iot;
{
	int i;

	sio_iot = iot;
	sio_pc = pc;

	if (bus_space_map(sio_iot, IO_ICU1, 2, 0, &sio_ioh_icu1) ||
	    bus_space_map(sio_iot, IO_ICU2, 2, 0, &sio_ioh_icu2))
		panic("sio_intr_setup: can't map ICU I/O ports");

	for (i = 0; sio_elcr_setup_funcs[i] != NULL; i++)
		if ((*sio_elcr_setup_funcs[i])() == 0)
			break;
	if (sio_elcr_setup_funcs[i] == NULL)
		panic("sio_intr_setup: can't map ELCR");

	/*
	 * Remember the initial values, so we can restore them later.
	 */
	initial_ocw1[0] = bus_space_read_1(sio_iot, sio_ioh_icu1, 1);
	initial_ocw1[1] = bus_space_read_1(sio_iot, sio_ioh_icu2, 1);
	initial_elcr[0] = (*sio_read_elcr)(0);			/* XXX */
	initial_elcr[1] = (*sio_read_elcr)(1);			/* XXX */

	sio_intr = alpha_shared_intr_alloc(ICU_LEN);

	/*
	 * set up initial values for interrupt enables.
	 */
	for (i = 0; i < ICU_LEN; i++) {
		alpha_shared_intr_set_maxstrays(sio_intr, i, STRAY_MAX);

		switch (i) {
		case 0:
		case 1:
		case 8:
		case 13:
			/*
			 * IRQs 0, 1, 8, and 13 must always be
			 * edge-triggered.
			 */
#ifdef DIAGNOSTIC
			if (INITIALLY_LEVEL_TRIGGERED(i))
				printf("WARNING: PROM set irq %d"
				    " level-triggered\n", i);
#endif
			sio_setirqstat(i, 0, IST_EDGE);
			alpha_shared_intr_set_dfltsharetype(sio_intr, i,
			    IST_EDGE);
			specific_eoi(i);
			break;

		case 2:
			/*
			 * IRQ 2 must be edge-triggered, and should be
			 * enabled (otherwise IRQs 8-15 are ignored).
			 */
			sio_setirqstat(i, 1, IST_EDGE);
			alpha_shared_intr_set_dfltsharetype(sio_intr, i,
			    IST_UNUSABLE);
			break;

		default:
			/*
			 * Otherwise, disable the IRQ and set its
			 * type to (effectively) "unknown", or "level"
			 * if it was set so by the PROM.
			 */
			sio_setirqstat(i, 0, INITIALLY_LEVEL_TRIGGERED(i) ?
			    IST_LEVEL : IST_NONE);
			alpha_shared_intr_set_dfltsharetype(sio_intr, i,
			    INITIALLY_LEVEL_TRIGGERED(i) ?
			      IST_LEVEL : IST_NONE);
			specific_eoi(i);
			break;
		}
	}
}

void
sio_intr_shutdown()
{
#ifdef BROKEN_PROM_CONSOLE
	if (sio_write_elcr == NULL)
		return;

	/*
	 * Restore the initial values, to make the PROM happy.
	 */
	bus_space_write_1(sio_iot, sio_ioh_icu1, 1, initial_ocw1[0]);
	bus_space_write_1(sio_iot, sio_ioh_icu2, 1, initial_ocw1[1]);
	(*sio_write_elcr)(0, initial_elcr[0]);			/* XXX */
	(*sio_write_elcr)(1, initial_elcr[1]);			/* XXX */
#endif
}

const char *
sio_intr_string(v, irq)
	void *v;
	int irq;
{
	static char irqstr[12];		/* 8 + 2 + NUL + sanity */

	if (irq == 0 || irq >= ICU_LEN || irq == 2)
		panic("sio_intr_string: bogus isa irq 0x%x", irq);

	snprintf(irqstr, sizeof irqstr, "isa irq %d", irq);
	return (irqstr);
}

int
sio_intr_line(v, irq)
	void *v;
	int irq;
{
	return (irq);
}

void *
sio_intr_establish(v, irq, type, level, fn, arg, name)
	void *v, *arg;
        int irq;
        int type;
        int level;
        int (*fn)(void *);
	const char *name;
{
	void *cookie;

	if (irq >= ICU_LEN || type == IST_NONE)
		panic("sio_intr_establish: bogus irq or type");

	/*
	 * XXX This is a workaround to let com(4) attach on Multia
	 * XXX where its interrupts are actually level triggered.
	 */
	if (type == IST_EDGE && INITIALLY_LEVEL_TRIGGERED(irq) &&
	    (irq == 3 || irq == 4))
		type = IST_LEVEL;

	cookie = alpha_shared_intr_establish(sio_intr, irq, type, level, fn,
	    arg, name);

	if (cookie != NULL &&
	    alpha_shared_intr_firstactive(sio_intr, irq)) {
		scb_set(0x800 + SCB_IDXTOVEC(irq), sio_iointr, NULL);
		sio_setirqstat(irq, 1,
		    alpha_shared_intr_get_sharetype(sio_intr, irq));
	}

	return (cookie);
}

void
sio_intr_disestablish(v, cookie)
	void *v;
	void *cookie;
{
	struct alpha_shared_intrhand *ih = cookie;
	int s, ist, irq = ih->ih_num;

	s = splhigh();

	/* Remove it from the link. */
	alpha_shared_intr_disestablish(sio_intr, cookie);

	/*
	 * Decide if we should disable the interrupt.  We must ensure
	 * that:
	 *
	 *	- An initially-enabled interrupt is never disabled.
	 *	- An initially-LT interrupt is never untyped.
	 */
	if (alpha_shared_intr_isactive(sio_intr, irq) == 0) {
		/*
		 * IRQs 0, 1, 8, and 13 must always be edge-triggered
		 * (see setup).
		 */
		switch (irq) {
		case 0:
		case 1:
		case 8:
		case 13:
			/*
			 * If the interrupt was initially level-triggered
			 * a warning was printed in setup.
			 */
			ist = IST_EDGE;
			break;

		default:
			ist = INITIALLY_LEVEL_TRIGGERED(irq) ?
			    IST_LEVEL : IST_NONE;
			break;
		}
		sio_setirqstat(irq, 0, ist);
		alpha_shared_intr_set_dfltsharetype(sio_intr, irq, ist);

		/* Release our SCB vector. */
		scb_free(0x800 + SCB_IDXTOVEC(irq));
	}

	splx(s);
}

void
sio_iointr(arg, vec)
	void *arg;
	unsigned long vec;
{
	int irq;

	irq = SCB_VECTOIDX(vec - 0x800);

#ifdef DIAGNOSTIC
	if (irq >= ICU_LEN || irq < 0)
		panic("sio_iointr: irq out of range (%d)", irq);
#endif

	if (!alpha_shared_intr_dispatch(sio_intr, irq))
		alpha_shared_intr_stray(sio_intr, irq, "isa irq");
	else
		alpha_shared_intr_reset_strays(sio_intr, irq);

	/*
	 * Some versions of the machines which use the SIO
	 * (or is it some PALcode revisions on those machines?)
	 * require the non-specific EOI to be fed to the PIC(s)
	 * by the interrupt handler.
	 */
	specific_eoi(irq);
}

#define	LEGAL_IRQ(x)	((x) >= 0 && (x) < ICU_LEN && (x) != 2)

int
sio_intr_alloc(v, mask, type, irq)
	void *v;
	int mask;
	int type;
	int *irq;
{
	int i, tmp, bestirq, count;
	struct alpha_shared_intrhand **p, *q;

	if (type == IST_NONE)
		panic("intr_alloc: bogus type");

	bestirq = -1;
	count = -1;

	/* some interrupts should never be dynamically allocated */
	mask &= 0xffff;
	mask &= ~((1 << 13) | (1 << 8) | (1 << 2) | (1 << 1) | (1 << 0));

	/*
	 * XXX some interrupts will be used later (6 for fdc, 12 for pms).
	 * the right answer is to do "breadth-first" searching of devices.
	 */
	mask &= ~((1 << 12) | (1 << 6));

	for (i = 0; i < ICU_LEN; i++) {
		if (LEGAL_IRQ(i) == 0 || (mask & (1<<i)) == 0)
			continue;

		switch (sio_intr[i].intr_sharetype) {
		case IST_NONE:
			/*
			 * if nothing's using the irq, just return it
			 */
			*irq = i;
			return (0);

		case IST_EDGE:
			intr_shared_edge = 1;
			/* FALLTHROUGH */
		case IST_LEVEL:
			if (type != sio_intr[i].intr_sharetype)
				continue;
			/*
			 * if the irq is shareable, count the number of other
			 * handlers, and if it's smaller than the last irq like
			 * this, remember it
			 *
			 * XXX We should probably also consider the
			 * interrupt level and stick IPL_TTY with other
			 * IPL_TTY, etc.
			 */
			for (p = &TAILQ_FIRST(&sio_intr[i].intr_q), tmp = 0;
			     (q = *p) != NULL; p = &TAILQ_NEXT(q, ih_q), tmp++)
				;
			if ((bestirq == -1) || (count > tmp)) {
				bestirq = i;
				count = tmp;
			}
			break;

		case IST_PULSE:
			/* this just isn't shareable */
			continue;
		}
	}

	if (bestirq == -1)
		return (1);

	*irq = bestirq;

	return (0);
}

/*
 * Just check to see if an IRQ is available/can be shared.
 * 0 = interrupt not available
 * 1 = interrupt shareable
 * 2 = interrupt all to ourself
 */
int
sio_intr_check(void *v, int irq, int type)
{
	if (type == IST_NONE)
		return (0);

	/*
	 * XXX This is a workaround to let com(4) attach on Multia
	 * XXX where its interrupts are actually level triggered.
	 */
	if (type == IST_EDGE && INITIALLY_LEVEL_TRIGGERED(irq) &&
	    (irq == 3 || irq == 4))
		type = IST_LEVEL;

	switch (sio_intr[irq].intr_sharetype) {
	case IST_NONE:
		return (2);
	case IST_EDGE:
	case IST_LEVEL:
		if (type == sio_intr[irq].intr_sharetype)
			return (1);
		/* FALLTHROUGH */
	default:
	case IST_PULSE:
		return (0);
	}
}

static void
specific_eoi(irq)
	int irq;
{
	if (irq > 7) {
		bus_space_write_1(sio_iot,
		    sio_ioh_icu2, 0, 0x60 | (irq & 0x07));	/* XXX */
		irq = 2;
	}
	bus_space_write_1(sio_iot, sio_ioh_icu1, 0, 0x60 | irq);
}
@


1.37
log
@It seems that, when the on-board USB controller is an ALI M5237 USB and its
interrupt is routed through the ISA PIC, the interrupt is edge-triggered
(despite PCI interrupts being level-triggered).

Attempt to recognize this and correctly setup the PIC ELCR register to `edge'.

This allows ES40 systems (and maybe others, but apparently all the other alpha
systems with on-board M5237 correctly route its interrupt as a PCI interrupt)
to reliably boot multiuser without suffering from USB interrupt storms (this is
especially noticeable when using glass console which, unlike serial console,
does not trigger other interrupts to give other devices a chance to run).

However, this is not enough yet to allow for proper USB device usage; your
mileage may vary.

Tested by bluhm@@ and me. Putting it early in the release cycle so that
regressions on other systems, if any, can hopefully get noticed soon enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.36 2014/02/18 19:37:33 miod Exp $	*/
a109 1
#ifdef BROKEN_PROM_CONSOLE
d116 3
a118 1
#endif
a360 1
#ifdef BROKEN_PROM_CONSOLE
a367 1
#endif
d386 5
d410 2
a411 1
			 * type to (effectively) "unknown."
d413 2
a414 1
			sio_setirqstat(i, 0, IST_NONE);
d416 2
a417 1
			    IST_NONE);
d446 1
a446 1
	static char irqstr[12];		/* 8 + 2 + NULL + sanity */
d477 8
d536 2
a537 1
			ist = IST_NONE;
d667 8
@


1.36
log
@sio_intr_shutdown() used to be a shutdown hook, and eventually became an
unconditional call in machdep.c!boot(). Except that the cpp conditional
enabling its use was not in machdep.c's scope, so this function was never
called. Ouch.

Remove it from boot() and grow a ca_activate method to the sio(4/alpha) device,
which will take care of invoking sio_intr_shutdown() if DVACT_POWERDOWN.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.35 2013/03/08 18:29:33 miod Exp $	*/
d119 9
d147 3
d160 21
a180 3
	if (rv == 0) {
		sio_read_elcr = i82378_read_elcr;
		sio_write_elcr = i82378_write_elcr;
d183 1
a183 1
	return (rv);
d236 7
a242 25
		/* Invalid vendor ID value? */
		if (PCI_VENDOR(id) == PCI_VENDOR_INVALID)
			continue;
		/* XXX Not invalid, but we've done this ~forever. */
		if (PCI_VENDOR(id) == 0)
			continue;

		if (PCI_VENDOR(id) != PCI_VENDOR_CONTAQ ||
		    PCI_PRODUCT(id) != PCI_PRODUCT_CONTAQ_82C693)
			continue;

		/*
		 * Found one!
		 */

#if 0
		printf("cy82c693_setup_elcr: found 82C693 at device %d\n",
		    device);
#endif

		sio_cy82c693_handle = cy82c693_init(sio_iot);
		sio_read_elcr = cy82c693_read_elcr;
		sio_write_elcr = cy82c693_write_elcr;

		return (0);
d315 1
a315 1
	 * interrupt type select: set bit to get level-triggered.
d322 5
a344 3
#ifdef notyet
	char *cp;
#endif
@


1.35
log
@Stop defining __NO_ISA_INTR_CHECK and add a real isa_intr_check() function.
Allows pcic to attach and correctly pick a suitable interrupt on Multia.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.34 2013/03/02 22:54:29 miod Exp $	*/
a125 3
#ifdef BROKEN_PROM_CONSOLE
void		sio_intr_shutdown(void *);
#endif
a402 1
#ifdef BROKEN_PROM_CONSOLE
d404 1
a404 2
sio_intr_shutdown(arg)
	void *arg;
d406 1
d417 1
a418 1
#endif
@


1.34
log
@Replace magic numbers with more meaningful (1 << interrupt#) constructs.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.33 2012/10/20 19:08:39 deraadt Exp $	*/
d121 1
d584 1
a584 1
		switch(sio_intr[i].intr_sharetype) {
d628 26
@


1.33
log
@move sio_intr_shutdown() from being a shutdownhook, and do it directly in
boot() as required.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.32 2011/04/15 20:40:05 deraadt Exp $	*/
d570 2
a571 1
	mask &= 0xdef8;
d577 1
a577 1
	mask &= 0xefbf;
@


1.32
log
@More than a decade ago, interrupt handlers on sparc started returning 0
(interrupt was not for me), 1 (positive interrupt was for me), or -1
(i am not sure...).  We have continued with this practice in as many
drivers as possible, throughout the tree.

This makes some of the architectures use that information in their
interrupt handler calling code -- if 1 is returned (and we know
this specific machine does not have edge-shared interrupts), we
finish servicing other possible handlers on the same pin.  If the
interrupt pin remains asserted (from a different device), we will
end up back in the interrupt servicing code of course... but this is
cheaper than calling all the chained interrupts on a pin.

This does of course count on shared level interrupts being properly
sorted by IPL.

There have been some concerns about starvation of drivers which
incorrectly return 1.  Those drivers should be hunted down so that
they return -1.

(other architectures will follow)

ok kettenis drahn dlg miod
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.31 2009/09/30 20:16:31 miod Exp $	*/
a355 1
	shutdownhook_establish(sio_intr_shutdown, 0);
d410 3
@


1.31
log
@Remove unused last argument of alpha_shared_intr_disestablish().
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.30 2009/08/22 02:54:50 mk Exp $	*/
d589 2
@


1.30
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.29 2008/08/09 16:41:21 miod Exp $	*/
d481 1
a481 1
	alpha_shared_intr_disestablish(sio_intr, cookie, "isa irq");
@


1.29
log
@Do not forget to set the ``specific EOI'' bit when sending a... specific EOI;
from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.28 2008/07/29 18:39:45 miod Exp $	*/
d450 1
a450 1
	char *name;
@


1.28
log
@Fix range check in sio_intr_establish().
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.27 2008/06/26 05:42:09 ray Exp $	*/
d628 1
a628 1
	if (irq > 7)
d630 4
a633 2
		    sio_ioh_icu2, 0, 0x20 | (irq & 0x07));	/* XXX */
	bus_space_write_1(sio_iot, sio_ioh_icu1, 0, 0x20 | (irq > 7 ? 2 : irq));
@


1.27
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.26 2006/06/15 20:08:29 brad Exp $	*/
d454 1
a454 1
	if (irq > ICU_LEN || type == IST_NONE)
@


1.26
log
@Rework the interrupt code, shaving some cycles off in the process.
Rather than an "iointr" routine that decomposes a vector into an
IRQ, we maintain a vector table directly, hooking up each "iointr"
routine at the correct vector. This also allows us to hook device
interrupts up to specific vectors.

From thorpej NetBSD

Tested by myself and a number of end-users.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.25 2006/01/29 10:47:35 martin Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.25
log
@Add a alpha_shared_intr_reset_strays() function that resets the stray
interrupt counter for a given shared interrupt descriptor.
When an interrupt is successfully handled, reset the strays counter,
thus preventing a "slow leak" from eventually shutting off the interrupt
vector.

from NetBSD via KUDO Takashi
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.24 2004/06/28 02:28:43 aaron Exp $	*/
d70 1
d467 4
a470 2
	if (cookie)
		sio_setirqstat(irq, alpha_shared_intr_isactive(sio_intr, irq),
d472 1
d520 3
d529 2
a530 2
sio_iointr(framep, vec)
	void *framep;
d535 2
a536 1
	irq = (vec - 0x800) >> 4;
@


1.24
log
@Use new event counter API for interrupt counting on alpha.  By me, with some
edits by Theo.  deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.23 2004/06/18 21:33:42 miod Exp $	*/
d536 2
@


1.23
log
@Correct range validation in sio_iointr().
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.22 2003/05/11 19:41:09 deraadt Exp $	*/
a372 7
#ifdef notyet
		cp = alpha_shared_intr_string(sio_intr, i);
		sprintf(cp, "irq %d", i);
		evcnt_attach_dynamic(alpha_shared_intr_evcnt(sio_intr, i),
		    EVCNT_TYPE_INTR, NULL, "isa", cp);
#endif

a447 14

#ifdef notyet
const struct evcnt *
sio_intr_evcnt(v, irq)
	void *v;
	int irq;
{

	if (irq == 0 || irq >= ICU_LEN || irq == 2)
		panic("sio_intr_evcnt: bogus isa irq 0x%x", irq);

	return (alpha_shared_intr_evcnt(sio_intr, irq));
}
#endif
@


1.22
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.21 2002/06/25 21:33:21 miod Exp $	*/
d551 1
a551 1
	if (irq > ICU_LEN || irq < 0)
@


1.21
log
@No \n at the end of a panic() message... I thought all occurences had been
squashed already.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.20 2002/03/14 01:26:27 millert Exp $	*/
d444 1
a444 1
	sprintf(irqstr, "isa irq %d", irq);
@


1.20
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.19 2001/10/26 01:28:06 nate Exp $	*/
d442 1
a442 1
		panic("sio_intr_string: bogus isa irq 0x%x\n", irq);
d464 1
a464 1
		panic("sio_intr_evcnt: bogus isa irq 0x%x\n", irq);
@


1.19
log
@First cut at a port of isadma and floppy driver.  ok art@@
From NetBSD via jay@@rootaction.net
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.18 2001/08/17 22:26:58 mickey Exp $	*/
d125 2
a126 2
void		sio_setirqstat __P((int, int, int));
int		sio_intr_alloc __P((void *, int, int, int *));
d128 3
a130 3
u_int8_t	(*sio_read_elcr) __P((int));
void		(*sio_write_elcr) __P((int, u_int8_t));
static void	specific_eoi __P((int));
d132 1
a132 1
void		sio_intr_shutdown __P((void *));
d137 3
a139 3
int		i82378_setup_elcr __P((void));
u_int8_t	i82378_read_elcr __P((int));
void		i82378_write_elcr __P((int, u_int8_t));
d183 3
a185 3
int		cy82c693_setup_elcr __P((void));
u_int8_t	cy82c693_read_elcr __P((int));
void		cy82c693_write_elcr __P((int, u_int8_t));
d273 1
a273 1
int (*sio_elcr_setup_funcs[]) __P((void)) = {
@


1.19.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.19 2001/10/26 01:28:06 nate Exp $	*/
d125 2
a126 2
void		sio_setirqstat(int, int, int);
int		sio_intr_alloc(void *, int, int, int *);
d128 3
a130 3
u_int8_t	(*sio_read_elcr)(int);
void		(*sio_write_elcr)(int, u_int8_t);
static void	specific_eoi(int);
d132 1
a132 1
void		sio_intr_shutdown(void *);
d137 3
a139 3
int		i82378_setup_elcr(void);
u_int8_t	i82378_read_elcr(int);
void		i82378_write_elcr(int, u_int8_t);
d183 3
a185 3
int		cy82c693_setup_elcr(void);
u_int8_t	cy82c693_read_elcr(int);
void		cy82c693_write_elcr(int, u_int8_t);
d273 1
a273 1
int (*sio_elcr_setup_funcs[])(void) = {
@


1.19.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.19.2.1 2002/06/11 03:33:40 art Exp $	*/
d442 1
a442 1
		panic("sio_intr_string: bogus isa irq 0x%x", irq);
d464 1
a464 1
		panic("sio_intr_evcnt: bogus isa irq 0x%x", irq);
@


1.19.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d444 1
a444 1
	snprintf(irqstr, sizeof irqstr, "isa irq %d", irq);
@


1.18
log
@provide a way to get the number used for irq line, not only a string
representation, this is needed for devices like cbb which pass
the interrupt line down to the cardbus attachment and not
getting the right line before pci_intr_map() has done it's
dirty deed.
tested on i386 by jason@@, compiles on alpha by art@@.
ppc and mveppc are to be test-compiled, but should work (;
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.17 2000/11/25 00:39:05 art Exp $	*/
d126 1
a568 1
#ifdef notyet
a640 1
#endif
@


1.17
log
@OpenBSD tag
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d445 8
@


1.16
log
@Use the common cy82c693 access functions.
From NetBSD.
Fixes pciide on 164sx.
@
text
@d1 1
@


1.15
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 38
a38 2
/*	$OpenBSD: sio_pic.c,v 1.14 1999/02/08 18:17:21 millert Exp $	*/
/*	$NetBSD: sio_pic.c,v 1.16 1996/11/17 02:05:26 cgd Exp $	*/
d80 3
a86 4
#ifndef EVCNT_COUNTERS
#include <machine/intrcnt.h>
#endif

a96 1
#ifndef SANE_PROM
a97 1
#endif /* SANE_PROM */
d102 1
d105 1
a105 1
bus_space_handle_t sio_ioh_icu1, sio_ioh_icu2, sio_ioh_elcr;
a109 3
#ifdef EVCNT_COUNTERS
struct evcnt sio_intr_evcnt;
#endif
a111 7
#ifdef BROKEN_PROM_CONSOLE
/*
 * If prom console is broken, because initial interrupt settings
 * must be kept, there's no way to escape stray interrupts.
 */
#define	STRAY_MAX	0
#else
a113 1
#endif
a121 7
#define	INITIALLY_ENABLED(irq) \
	    ((initial_ocw1[(irq) / 8] & (1 << ((irq) % 8))) == 0)
#define	INITIALLY_LEVEL_TRIGGERED(irq) \
	    ((initial_elcr[(irq) / 8] & (1 << ((irq) % 8))) != 0)
#else
#define	INITIALLY_ENABLED(irq)		((irq) == 2 ? 1 : 0)
#define	INITIALLY_LEVEL_TRIGGERED(irq)	0
d124 1
a124 3
void sio_setirqstat __P((int, int, int));

void	sio_setirqstat __P((int, int, int));
d128 4
d139 2
d185 2
d191 1
d209 2
a210 2
		id = pci_conf_read(sio_pc, pci_make_tag(sio_pc, 0, device, 0),
				   PCI_ID_REG);
d229 1
a229 1
		       device);
d232 1
a232 6
		/*
		 * The CY82C693's ELCR registers are accessed indirectly
		 * via (IO_ICU1 + 2) (address) and (IO_ICU1 + 3) (data).
		 */
		sio_ioh_elcr = sio_ioh_icu1;

d250 1
a250 2
	bus_space_write_1(sio_iot, sio_ioh_elcr, 0x02, 0x03 + elcr);
	return (bus_space_read_1(sio_iot, sio_ioh_elcr, 0x03));
d259 1
a259 2
	bus_space_write_1(sio_iot, sio_ioh_elcr, 0x02, 0x03 + elcr);
	bus_space_write_1(sio_iot, sio_ioh_elcr, 0x03, val);
d278 1
d297 2
a298 2
        elcr[0] = (*sio_read_elcr)(0);                          /* XXX */
        elcr[1] = (*sio_read_elcr)(1);                          /* XXX */
a322 19
#ifdef BROKEN_PROM_CONSOLE
	/*
	 * make sure that the initially clear bits (unmasked interrupts)
	 * are never set, and that the initially-level-triggered
	 * intrrupts always remain level-triggered, to keep the prom happy.
	 */
	if ((ocw1[0] & ~initial_ocw1[0]) != 0 ||
	    (ocw1[1] & ~initial_ocw1[1]) != 0 ||
	    (elcr[0] & initial_elcr[0]) != initial_elcr[0] ||
	    (elcr[1] & initial_elcr[1]) != initial_elcr[1]) {
		printf("sio_sis: initial: ocw = (%2x,%2x), elcr = (%2x,%2x)\n",
		    initial_ocw1[0], initial_ocw1[1],
		    initial_elcr[0], initial_elcr[1]);
		printf("         current: ocw = (%2x,%2x), elcr = (%2x,%2x)\n",
		    ocw1[0], ocw1[1], elcr[0], elcr[1]);
		panic("sio_setirqstat: hosed");
	}
#endif

d325 2
a326 2
        (*sio_write_elcr)(0, elcr[0]);                          /* XXX */
        (*sio_write_elcr)(1, elcr[1]);                          /* XXX */
d331 1
a331 1
        pci_chipset_tag_t pc;
d334 3
d341 10
a350 10
	
	if (bus_space_map(sio_iot, IO_ICU1, IO_ICUSIZE, 0, &sio_ioh_icu1) ||
	    bus_space_map(sio_iot, IO_ICU2, IO_ICUSIZE, 0, &sio_ioh_icu2))
		panic("sio_intr_setup: can't map I/O ports");

        for (i = 0; sio_elcr_setup_funcs[i] != NULL; i++)
                if ((*sio_elcr_setup_funcs[i])() == 0)
                        break;
        if (sio_elcr_setup_funcs[i] == NULL)
                panic("sio_intr_setup: can't map ELCR");
d354 1
a354 1
	 * Remember the initial values, because the prom is stupid.
d358 3
a360 8
        initial_elcr[0] = (*sio_read_elcr)(0);                  /* XXX */
        initial_elcr[1] = (*sio_read_elcr)(1);                  /* XXX */
#if 0
	printf("initial_ocw1[0] = 0x%x\n", initial_ocw1[0]);
	printf("initial_ocw1[1] = 0x%x\n", initial_ocw1[1]);
	printf("initial_elcr[0] = 0x%x\n", initial_elcr[0]);
	printf("initial_elcr[1] = 0x%x\n", initial_elcr[1]);
#endif
d371 7
d387 1
a387 3
			if (INITIALLY_LEVEL_TRIGGERED(i))
				printf("sio_intr_setup: %d LT!\n", i);
			sio_setirqstat(i, INITIALLY_ENABLED(i), IST_EDGE);
d390 1
a397 4
			if (INITIALLY_LEVEL_TRIGGERED(i))
				printf("sio_intr_setup: %d LT!\n", i);
			if (!INITIALLY_ENABLED(i))
				printf("sio_intr_setup: %d not enabled!\n", i);
d408 1
a408 3
			sio_setirqstat(i, INITIALLY_ENABLED(i),
			    INITIALLY_LEVEL_TRIGGERED(i) ? IST_LEVEL :
				IST_NONE);
d410 2
a411 2
			    INITIALLY_LEVEL_TRIGGERED(i) ? IST_LEVEL :
                                IST_NONE);
d417 15
d440 1
a440 1
		panic("sio_intr_string: bogus isa irq 0x%x", irq);
d446 14
d489 4
d494 2
a495 2
	printf("sio_intr_disestablish(%p)\n", cookie);
	/* XXX */
d497 33
a529 2
	/* XXX NEVER ALLOW AN INITIALLY-ENABLED INTERRUPT TO BE DISABLED */
	/* XXX NEVER ALLOW AN INITIALLY-LT INTERRUPT TO BECOME UNTYPED */
a544 10
#ifdef EVCNT_COUNTERS
	sio_intr_evcnt.ev_count++;
#else
#ifdef DEBUG
	if (ICU_LEN != INTRCNT_ISA_IRQ_LEN)
		panic("sio interrupt counter sizes inconsistent");
#endif
	intrcnt[INTRCNT_ISA_IRQ + irq]++;
#endif

d554 84
d641 1
a641 2
	bus_space_write_1(sio_iot,
	    sio_ioh_icu1, 0, 0x20 | (irq > 7 ? 2 : irq));	/* XXX */
@


1.14
log
@PCI_PRODUCT_CONTAQ_SIO -> PCI_PRODUCT_CONTAQ_82C693
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.13 1999/01/11 05:11:03 millert Exp $	*/
a432 11
}

int
sio_intr_check(v, irq, type)
	void *v;
	int irq, type;
{
      if (irq > ICU_LEN || type == IST_NONE)
		return (0);
 
       return (alpha_shared_intr_check(sio_intr, irq, type));
@


1.14.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 39
/*	$OpenBSD: sio_pic.c,v 1.17 2000/11/25 00:39:05 art Exp $	*/
/* $NetBSD: sio_pic.c,v 1.28 2000/06/06 03:10:13 thorpej Exp $ */

/*-
 * Copyright (c) 1998, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
a43 3
#include <dev/pci/cy82c693reg.h>
#include <dev/pci/cy82c693var.h>

d48 4
d62 1
d64 1
a68 1

d71 1
a71 1
bus_space_handle_t sio_ioh_icu1, sio_ioh_icu2;
d76 3
d81 7
d90 1
d99 7
d108 3
a110 1
void		sio_setirqstat __P((int, int, int));
a113 4
static void	specific_eoi __P((int));
#ifdef BROKEN_PROM_CONSOLE
void		sio_intr_shutdown __P((void *));
#endif
a120 2
bus_space_handle_t sio_ioh_elcr;

a164 2
const struct cy82c693_handle *sio_cy82c693_handle;

a168 1
	pcitag_t tag;
d186 2
a187 2
		tag = pci_make_tag(sio_pc, 0, device, 0);
		id = pci_conf_read(sio_pc, tag, PCI_ID_REG);
d206 1
a206 1
		    device);
d209 6
a214 1
		sio_cy82c693_handle = cy82c693_init(sio_iot);
d232 2
a233 1
	return (cy82c693_read(sio_cy82c693_handle, CONFIG_ELCR1 + elcr));
d242 2
a243 1
	cy82c693_write(sio_cy82c693_handle, CONFIG_ELCR1 + elcr, val);
a261 1

d280 2
a281 2
	elcr[0] = (*sio_read_elcr)(0);				/* XXX */
	elcr[1] = (*sio_read_elcr)(1);				/* XXX */
d306 19
d327 2
a328 2
	(*sio_write_elcr)(0, elcr[0]);				/* XXX */
	(*sio_write_elcr)(1, elcr[1]);				/* XXX */
d333 1
a333 1
	pci_chipset_tag_t pc;
a335 3
#ifdef notyet
	char *cp;
#endif
d340 10
a349 10

	if (bus_space_map(sio_iot, IO_ICU1, 2, 0, &sio_ioh_icu1) ||
	    bus_space_map(sio_iot, IO_ICU2, 2, 0, &sio_ioh_icu2))
		panic("sio_intr_setup: can't map ICU I/O ports");

	for (i = 0; sio_elcr_setup_funcs[i] != NULL; i++)
		if ((*sio_elcr_setup_funcs[i])() == 0)
			break;
	if (sio_elcr_setup_funcs[i] == NULL)
		panic("sio_intr_setup: can't map ELCR");
d353 1
a353 1
	 * Remember the initial values, so we can restore them later.
d357 8
a364 3
	initial_elcr[0] = (*sio_read_elcr)(0);			/* XXX */
	initial_elcr[1] = (*sio_read_elcr)(1);			/* XXX */
	shutdownhook_establish(sio_intr_shutdown, 0);
a374 7
#ifdef notyet
		cp = alpha_shared_intr_string(sio_intr, i);
		sprintf(cp, "irq %d", i);
		evcnt_attach_dynamic(alpha_shared_intr_evcnt(sio_intr, i),
		    EVCNT_TYPE_INTR, NULL, "isa", cp);
#endif

d384 3
a386 1
			sio_setirqstat(i, 0, IST_EDGE);
a388 1
			specific_eoi(i);
d396 4
d410 3
a412 1
			sio_setirqstat(i, 0, IST_NONE);
d414 2
a415 2
			    IST_NONE);
			specific_eoi(i);
a420 15
#ifdef BROKEN_PROM_CONSOLE
void
sio_intr_shutdown(arg)
	void *arg;
{
	/*
	 * Restore the initial values, to make the PROM happy.
	 */
	bus_space_write_1(sio_iot, sio_ioh_icu1, 1, initial_ocw1[0]);
	bus_space_write_1(sio_iot, sio_ioh_icu2, 1, initial_ocw1[1]);
	(*sio_write_elcr)(0, initial_elcr[0]);			/* XXX */
	(*sio_write_elcr)(1, initial_elcr[1]);			/* XXX */
}
#endif

d429 1
a429 1
		panic("sio_intr_string: bogus isa irq 0x%x\n", irq);
d435 2
a436 3
#ifdef notyet
const struct evcnt *
sio_intr_evcnt(v, irq)
d438 1
a438 1
	int irq;
d440 4
a443 5

	if (irq == 0 || irq >= ICU_LEN || irq == 2)
		panic("sio_intr_evcnt: bogus isa irq 0x%x\n", irq);

	return (alpha_shared_intr_evcnt(sio_intr, irq));
a444 1
#endif
a474 2
	struct alpha_shared_intrhand *ih = cookie;
	int s, ist, irq = ih->ih_num;
d476 2
a477 1
	s = splhigh();
d479 2
a480 36
	/* Remove it from the link. */
	alpha_shared_intr_disestablish(sio_intr, cookie, "isa irq");

	/*
	 * Decide if we should disable the interrupt.  We must ensure
	 * that:
	 *
	 *	- An initially-enabled interrupt is never disabled.
	 *	- An initially-LT interrupt is never untyped.
	 */
	if (alpha_shared_intr_isactive(sio_intr, irq) == 0) {
		/*
		 * IRQs 0, 1, 8, and 13 must always be edge-triggered
		 * (see setup).
		 */
		switch (irq) {
		case 0:
		case 1:
		case 8:
		case 13:
			/*
			 * If the interrupt was initially level-triggered
			 * a warning was printed in setup.
			 */
			ist = IST_EDGE;
			break;

		default:
			ist = IST_NONE;
			break;
		}
		sio_setirqstat(irq, 0, ist);
		alpha_shared_intr_set_dfltsharetype(sio_intr, irq, ist);
	}

	splx(s);
d496 10
a514 84
	specific_eoi(irq);
}

#define	LEGAL_IRQ(x)	((x) >= 0 && (x) < ICU_LEN && (x) != 2)

#ifdef notyet
int
sio_intr_alloc(v, mask, type, irq)
	void *v;
	int mask;
	int type;
	int *irq;
{
	int i, tmp, bestirq, count;
	struct alpha_shared_intrhand **p, *q;

	if (type == IST_NONE)
		panic("intr_alloc: bogus type");

	bestirq = -1;
	count = -1;

	/* some interrupts should never be dynamically allocated */
	mask &= 0xdef8;

	/*
	 * XXX some interrupts will be used later (6 for fdc, 12 for pms).
	 * the right answer is to do "breadth-first" searching of devices.
	 */
	mask &= 0xefbf;

	for (i = 0; i < ICU_LEN; i++) {
		if (LEGAL_IRQ(i) == 0 || (mask & (1<<i)) == 0)
			continue;

		switch(sio_intr[i].intr_sharetype) {
		case IST_NONE:
			/*
			 * if nothing's using the irq, just return it
			 */
			*irq = i;
			return (0);

		case IST_EDGE:
		case IST_LEVEL:
			if (type != sio_intr[i].intr_sharetype)
				continue;
			/*
			 * if the irq is shareable, count the number of other
			 * handlers, and if it's smaller than the last irq like
			 * this, remember it
			 *
			 * XXX We should probably also consider the
			 * interrupt level and stick IPL_TTY with other
			 * IPL_TTY, etc.
			 */
			for (p = &TAILQ_FIRST(&sio_intr[i].intr_q), tmp = 0;
			     (q = *p) != NULL; p = &TAILQ_NEXT(q, ih_q), tmp++)
				;
			if ((bestirq == -1) || (count > tmp)) {
				bestirq = i;
				count = tmp;
			}
			break;

		case IST_PULSE:
			/* this just isn't shareable */
			continue;
		}
	}

	if (bestirq == -1)
		return (1);

	*irq = bestirq;

	return (0);
}
#endif

static void
specific_eoi(irq)
	int irq;
{
d518 2
a519 1
	bus_space_write_1(sio_iot, sio_ioh_icu1, 0, 0x20 | (irq > 7 ? 2 : irq));
@


1.14.6.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.14.6.1 2001/04/18 16:01:30 niklas Exp $	*/
a125 1
int		sio_intr_alloc __P((void *, int, int, int *));
a446 8
int
sio_intr_line(v, irq)
	void *v;
	int irq;
{
	return (irq);
}

d560 1
d633 1
@


1.14.6.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d125 2
a126 2
void		sio_setirqstat(int, int, int);
int		sio_intr_alloc(void *, int, int, int *);
d128 3
a130 3
u_int8_t	(*sio_read_elcr)(int);
void		(*sio_write_elcr)(int, u_int8_t);
static void	specific_eoi(int);
d132 1
a132 1
void		sio_intr_shutdown(void *);
d137 3
a139 3
int		i82378_setup_elcr(void);
u_int8_t	i82378_read_elcr(int);
void		i82378_write_elcr(int, u_int8_t);
d183 3
a185 3
int		cy82c693_setup_elcr(void);
u_int8_t	cy82c693_read_elcr(int);
void		cy82c693_write_elcr(int, u_int8_t);
d273 1
a273 1
int (*sio_elcr_setup_funcs[])(void) = {
@


1.14.6.4
log
@Sync the SMP branch with 3.3
@
text
@d442 1
a442 1
		panic("sio_intr_string: bogus isa irq 0x%x", irq);
d464 1
a464 1
		panic("sio_intr_evcnt: bogus isa irq 0x%x", irq);
@


1.14.6.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.14.6.4 2003/03/27 23:18:06 niklas Exp $	*/
d444 1
a444 1
	snprintf(irqstr, sizeof irqstr, "isa irq %d", irq);
@


1.13
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.12 1998/07/01 05:32:42 angelos Exp $	*/
d197 1
a197 1
		    PCI_PRODUCT(id) != PCI_PRODUCT_CONTAQ_SIO)
@


1.12
log
@First shot for EB164SX/LX support; kernels for those should be much
more stable now, but by no means production-strong. A lot of code from
NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.11 1998/06/29 05:32:55 downsj Exp $	*/
d429 1
a429 1
		panic("sio_intr_string: bogus isa irq 0x%x\n", irq);
@


1.11
log
@isa_intr_check(), alpha style.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.10 1998/03/18 00:48:29 angelos Exp $	*/
d40 4
d70 1
d112 150
d280 2
a281 2
	elcr[0] = bus_space_read_1(sio_iot, sio_ioh_elcr, 0);	/* XXX */
	elcr[1] = bus_space_read_1(sio_iot, sio_ioh_elcr, 1);	/* XXX */
d327 2
a328 2
	bus_space_write_1(sio_iot, sio_ioh_elcr, 0, elcr[0]);	/* XXX */
	bus_space_write_1(sio_iot, sio_ioh_elcr, 1, elcr[1]);	/* XXX */
d332 2
a333 1
sio_intr_setup(iot)
d339 2
a340 1

d342 1
a342 2
	    bus_space_map(sio_iot, IO_ICU2, IO_ICUSIZE, 0, &sio_ioh_icu2) ||
	    bus_space_map(sio_iot, 0x4d0, 2, 0, &sio_ioh_elcr))
d345 6
d357 2
a358 2
	initial_elcr[0] = bus_space_read_1(sio_iot, sio_ioh_elcr, 0); /* XXX */
	initial_elcr[1] = bus_space_read_1(sio_iot, sio_ioh_elcr, 1); /* XXX */
d440 1
a440 1
	if (irq > ICU_LEN || type == IST_NONE)
d442 2
a443 2

	return (alpha_shared_intr_check(sio_intr, irq, type));
@


1.10
log
@BROKEN_PROM_CONSOLE is only defined if SANE_PROM is not defined. The
latter can be defined in a kernel config file.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.9 1997/01/24 19:57:59 niklas Exp $	*/
d271 11
@


1.9
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.8 1996/12/08 00:20:49 niklas Exp $	*/
d58 1
d60 1
@


1.8
log
@Merge to NetBSD 961107, i.e. mostly new bus.h
@
text
@d1 2
a2 2
/*	$OpenBSD: sio_pic.c,v 1.7 1996/11/12 20:29:39 niklas Exp $	*/
/*	$NetBSD: sio_pic.c,v 1.14 1996/10/23 04:12:33 cgd Exp $	*/
a62 2
static void	sio_strayintr __P((int));

a65 13
/*
 * Interrupt handler chains.  sio_intr_establish() inserts a handler into
 * the list.  The handler is called with its (single) argument.
 */
struct intrhand {
	int	(*ih_fun) __P((void *));
	void	*ih_arg;
	u_long	ih_count;
	struct	intrhand *ih_next;
	int	ih_level;
	int	ih_irq;
};

d68 1
a68 3
static struct intrhand *sio_intrhand[ICU_LEN];
static int sio_intrsharetype[ICU_LEN];
static u_long sio_strayintrcnt[ICU_LEN];
d103 2
a117 2
	sio_intrsharetype[irq] = type;

d203 2
d209 2
d223 2
d237 2
d249 3
d265 1
a265 1
		panic("sio_intr_string: bogus IRQ 0x%x\n", irq);
d272 2
a273 2
sio_intr_establish(v, irq, type, level, ih_fun, ih_arg, name)
	void *v, *ih_arg;
d277 1
a277 1
        int (*ih_fun)(void *);
d280 1
a280 7
	struct intrhand **p, *c, *ih;
	extern int cold;

	/* no point in sleeping unless someone can free memory. */
	ih = malloc(sizeof *ih, M_DEVBUF, cold ? M_NOWAIT : M_WAITOK);
	if (ih == NULL)
		panic("sio_intr_establish: can't malloc handler info");
d285 2
a286 39
	switch (sio_intrsharetype[irq]) {
	case IST_EDGE:
	case IST_LEVEL:
		if (type == sio_intrsharetype[irq])
			break;
	case IST_PULSE:
		if (type != IST_NONE) {
			if (sio_intrhand[irq] == NULL) {
				printf("sio_intr_establish: irq %d: warning: using %s on %s\n",
				    irq, isa_intr_typename(type),
				    isa_intr_typename(sio_intrsharetype[irq]));
				type = sio_intrsharetype[irq];
			} else {
				panic("sio_intr_establish: irq %d: can't share %s with %s",
				    irq, isa_intr_typename(type),
				    isa_intr_typename(sio_intrsharetype[irq]));
			}
		}
		break;
        }

	/*
	 * Figure out where to put the handler.
	 * This is O(N^2), but we want to preserve the order, and N is
	 * generally small.
	 */
	for (p = &sio_intrhand[irq]; (c = *p) != NULL; p = &c->ih_next)
		;

	/*
	 * Poke the real handler in now.
	 */
	ih->ih_fun = ih_fun;
	ih->ih_arg = ih_arg;
	ih->ih_count = 0;
	ih->ih_next = NULL;
	ih->ih_level = 0;			/* XXX meaningless on alpha */
	ih->ih_irq = irq;
	*p = ih;
d288 3
a290 1
	sio_setirqstat(irq, 1, type);
d292 1
a292 1
	return ih;
d301 1
a301 1
	printf("sio_intr_disestablish(%lx)\n", cookie);
a307 25
/*
 * caught a stray interrupt; notify if not too many seen already.
 */
void
sio_strayintr(irq)
	int irq;
{

        sio_strayintrcnt[irq]++;

#ifdef notyet
        if (sio_strayintrcnt[irq] == STRAY_MAX)
                sio_disable_intr(irq);

        log(LOG_ERR, "stray isa irq %d\n", irq);
        if (sio_strayintrcnt[irq] == STRAY_MAX)
                log(LOG_ERR, "disabling interrupts on isa irq %d\n", irq);
#else
	if (sio_strayintrcnt[irq] <= STRAY_MAX)
		log(LOG_ERR, "stray isa irq %d%s\n", irq,
		    sio_strayintrcnt[irq] >= STRAY_MAX ?
			"; stopped logging" : "");
#endif
}

d313 1
a313 2
	int irq, handled;
	struct intrhand *ih;
d324 1
d327 1
d331 2
a332 25
	/*
	 * We cdr down the intrhand chain, calling each handler with
	 * its appropriate argument;
	 *
	 * The handler returns one of three values:
	 *   0 - This interrupt wasn't for me.
	 *   1 - This interrupt was for me.
	 *  -1 - This interrupt might have been for me, but I don't know.
	 * If there are no handlers, or they all return 0, we flags it as a
	 * `stray' interrupt.  On a system with level-triggered interrupts,
	 * we could terminate immediately when one of them returns 1; but
	 * this is PC-ish!
	 */
	for (ih = sio_intrhand[irq], handled = 0; ih != NULL;
	    ih = ih->ih_next) {
		int rv;

		rv = (*ih->ih_fun)(ih->ih_arg);

		ih->ih_count++;
		handled = handled || (rv != 0);
	}

	if (!handled)
		sio_strayintr(irq);
@


1.7
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 2
a2 2
/*	$OpenBSD: sio_pic.c,v 1.6 1996/10/30 22:40:15 niklas Exp $	*/
/*	$NetBSD: sio_pic.c,v 1.13 1996/10/13 03:00:20 christos Exp $	*/
d38 1
a38 1
#include <machine/bus.old.h>
d65 2
a66 2
bus_chipset_tag_t sio_bc;
bus_io_handle_t sio_ioh_icu1, sio_ioh_icu2, sio_ioh_elcr;
d138 4
a141 4
	ocw1[0] = bus_io_read_1(sio_bc, sio_ioh_icu1, 1);
	ocw1[1] = bus_io_read_1(sio_bc, sio_ioh_icu2, 1);
	elcr[0] = bus_io_read_1(sio_bc, sio_ioh_elcr, 0);	/* XXX */
	elcr[1] = bus_io_read_1(sio_bc, sio_ioh_elcr, 1);	/* XXX */
d185 4
a188 4
	bus_io_write_1(sio_bc, sio_ioh_icu1, 1, ocw1[0]);
	bus_io_write_1(sio_bc, sio_ioh_icu2, 1, ocw1[1]);
	bus_io_write_1(sio_bc, sio_ioh_elcr, 0, elcr[0]);	/* XXX */
	bus_io_write_1(sio_bc, sio_ioh_elcr, 1, elcr[1]);	/* XXX */
d192 2
a193 2
sio_intr_setup(bc)
	bus_chipset_tag_t bc;
d197 1
a197 1
	sio_bc = bc;
d199 3
a201 3
	if (bus_io_map(sio_bc, IO_ICU1, IO_ICUSIZE, &sio_ioh_icu1) ||
	    bus_io_map(sio_bc, IO_ICU2, IO_ICUSIZE, &sio_ioh_icu2) ||
	    bus_io_map(sio_bc, 0x4d0, 2, &sio_ioh_elcr))
d208 4
a211 4
	initial_ocw1[0] = bus_io_read_1(sio_bc, sio_ioh_icu1, 1);
	initial_ocw1[1] = bus_io_read_1(sio_bc, sio_ioh_icu2, 1);
	initial_elcr[0] = bus_io_read_1(sio_bc, sio_ioh_elcr, 0); /* XXX */
	initial_elcr[1] = bus_io_read_1(sio_bc, sio_ioh_elcr, 1); /* XXX */
d435 1
a435 1
		bus_io_write_1(sio_bc,
d437 1
a437 1
	bus_io_write_1(sio_bc,
@


1.6
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_pic.c,v 1.13 1996/10/13 03:00:20 christos Exp $	*/
d38 1
a38 1
#include <machine/bus.h>
@


1.5
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: sio_pic.c,v 1.7.4.3 1996/06/05 22:50:23 cgd Exp $	*/
/*	$NetBSD: sio_pic.c,v 1.7.4.3 1996/06/05 22:50:23 cgd Exp $	*/
d73 1
a73 1
	int	(*ih_fun)();
d118 2
d363 12
a374 2
	if (++sio_strayintrcnt[irq] <= STRAY_MAX)
		log(LOG_ERR, "stray interrupt %d%s\n", irq,
d377 1
d383 1
a383 1
	int vec;
@


1.4
log
@sync to 0616, retaining local diffs
@
text
@d1 1
d276 1
a276 1
sio_intr_establish(v, irq, type, level, ih_fun, ih_arg)
d282 1
@


1.3
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
@
text
@d1 1
a1 1
/*	$NetBSD: sio_pic.c,v 1.3 1995/12/24 02:29:49 mycroft Exp $	*/
d4 1
a4 1
 * Copyright (c) 1995 Carnegie-Mellon University.
d36 3
d62 4
a65 15
static void	*sio_intr_establish __P((void *, isa_irq_t,
		    int, int, int (*)(void *), void *));
static void	sio_intr_disestablish __P((void *, void *));
static void	sio_strayintr __P((isa_irq_t));

static __const struct isa_pio_fns *sio_ipf;		/* XXX */
static void *sio_ipfa;					/* XXX */

void		sio_intr_setup __P((__const struct isa_pio_fns *, void *));
void		sio_iointr __P((void *framep, int vec));

struct	isa_intr_fns sio_isa_intr_fns = {
	sio_intr_establish,
	sio_intr_disestablish,
};
d126 1
a126 1
	printf("sio_setirqstat: irq %d, %s, %s\n", irq,
d135 4
a138 4
	ocw1[0] = INB(sio_ipf, sio_ipfa, IO_ICU1 + 1);
	ocw1[1] = INB(sio_ipf, sio_ipfa, IO_ICU2 + 1);
	elcr[0] = INB(sio_ipf, sio_ipfa, 0x4d0);		/* XXX */
	elcr[1] = INB(sio_ipf, sio_ipfa, 0x4d1);		/* XXX */
d173 1
a173 1
		printf("sio_sis: initial: ocw = (%2x,%2x), elcr = (%2x,%2X)\n",
d176 1
a176 1
		printf("         current: ocw = (%2x,%2x), elcr = (%2x,%2X)\n",
d182 4
a185 4
	OUTB(sio_ipf, sio_ipfa, IO_ICU1 + 1, ocw1[0]);
	OUTB(sio_ipf, sio_ipfa, IO_ICU2 + 1, ocw1[1]);
	OUTB(sio_ipf, sio_ipfa, 0x4d0, elcr[0]);		/* XXX */
	OUTB(sio_ipf, sio_ipfa, 0x4d1, elcr[1]);		/* XXX */
d189 2
a190 3
sio_intr_setup(ipf, ipfa)
	__const struct isa_pio_fns *ipf;
	void *ipfa;
d194 6
a199 2
	sio_ipf = ipf;
	sio_ipfa = ipfa;
d205 4
a208 4
	initial_ocw1[0] = INB(sio_ipf, sio_ipfa, IO_ICU1 + 1);
	initial_ocw1[1] = INB(sio_ipf, sio_ipfa, IO_ICU2 + 1);
	initial_elcr[0] = INB(sio_ipf, sio_ipfa, 0x4d0);	/* XXX */
	initial_elcr[1] = INB(sio_ipf, sio_ipfa, 0x4d1);	/* XXX */
d260 14
d275 3
a277 3
sio_intr_establish(siifa, irq, type, level, ih_fun, ih_arg)
	void *siifa;
        isa_irq_t irq;
a280 1
        void *ih_arg;
d299 12
a310 4
		if (type != IST_NONE)
			panic("intr_establish: can't share %s with %s",
			    isa_intrsharetype_name(sio_intrsharetype[irq]),
			    isa_intrsharetype_name(type));
d339 3
a341 3
sio_intr_disestablish(siifa, handler)
	void *siifa;
	void *handler;
d344 1
a344 1
	printf("sio_intr_disestablish(%lx)\n", handler);
d356 1
a356 1
	isa_irq_t irq;
d420 4
a423 4
		OUTB(sio_ipf, sio_ipfa,
		    IO_ICU2 + 0, 0x20 | (irq & 0x07));		/* XXX */
	OUTB(sio_ipf, sio_ipfa,
	    IO_ICU1 + 0, 0x20 | (irq > 7 ? 2 : irq));		/* XXX */
@


1.2
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: sio_pic.c,v 1.2 1995/11/23 02:38:19 cgd Exp $	*/
d60 1
a60 2
		    isa_intrsharetype_t, isa_intrlevel_t,
		    int (*)(void *), void *));
d91 1
a91 1
static isa_intrsharetype_t sio_intrsharetype[ICU_LEN];
d128 1
a128 1
	isa_intrsharetype_t type;
d159 1
a159 1
	if (type == ISA_IST_LEVEL)
d237 1
a237 1
			sio_setirqstat(i, INITIALLY_ENABLED(i), ISA_IST_EDGE);
d249 1
a249 1
			sio_setirqstat(i, 1, ISA_IST_EDGE);
d258 2
a259 2
			    INITIALLY_LEVEL_TRIGGERED(i) ? ISA_IST_LEVEL :
				ISA_IST_NONE);
d269 2
a270 2
        isa_intrsharetype_t type;
        isa_intrlevel_t level;
d282 1
a282 1
	if (irq > ICU_LEN || type == ISA_IST_NONE)
d286 2
a287 2
	case ISA_IST_EDGE:
	case ISA_IST_LEVEL:
d290 2
a291 2
	case ISA_IST_PULSE:
		if (type != ISA_IST_NONE)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: sio_pic.c,v 1.1 1995/06/28 01:26:13 cgd Exp $	*/
d36 1
d38 5
a42 2
#include <dev/isa/isareg.h>
#include <alpha/isa/isa_intr.h>
d44 1
a44 1
#include <machine/pio.h>
d56 18
a73 9
static void	sio_intr_setup __P((void));
static void	*sio_intr_establish __P((int intr, isa_intrtype type,
		    isa_intrlevel level, int (*ih_fun)(void *), void *ih_arg));
static void	sio_intr_disestablish __P((void *handler));
static void	sio_iointr __P((void *framep, int vec));

struct	isa_intr_fcns sio_intr_fcns = {
	sio_intr_setup, sio_intr_establish,
	sio_intr_disestablish, sio_iointr,
a75 2
static void	sio_strayintr __P((int irq));

d92 1
a92 1
static isa_intrtype sio_intrtype[ICU_LEN];
d94 3
d129 1
a129 1
	isa_intrtype type;
d139 1
a139 1
	sio_intrtype[irq] = type;
d144 4
a147 4
	ocw1[0] = inb(IO_ICU1 + 1);
	ocw1[1] = inb(IO_ICU2 + 1);
	elcr[0] = inb(0x4d0);				/* XXX */
	elcr[1] = inb(0x4d1);				/* XXX */
d191 4
a194 4
	outb(IO_ICU1 + 1, ocw1[0]);
	outb(IO_ICU2 + 1, ocw1[1]);
	outb(0x4d0, elcr[0]);				/* XXX */
	outb(0x4d1, elcr[1]);				/* XXX */
d198 3
a200 1
sio_intr_setup()
d204 3
d211 4
a214 4
	initial_ocw1[0] = inb(IO_ICU1 + 1);
	initial_ocw1[1] = inb(IO_ICU2 + 1);
	initial_elcr[0] = inb(0x4d0);			/* XXX */
	initial_elcr[1] = inb(0x4d1);			/* XXX */
d267 5
a271 4
sio_intr_establish(irq, type, level, ih_fun, ih_arg)
        int irq;
        isa_intrtype type;
        isa_intrlevel level;
d283 1
a283 1
	if (irq < 0 || irq > ICU_LEN || type == ISA_IST_NONE)
d286 1
a286 1
	switch (sio_intrtype[irq]) {
d289 1
a289 1
		if (type == sio_intrtype[irq])
d294 2
a295 2
			    isa_intr_typename(sio_intrtype[irq]),
			    isa_intr_typename(type));
d324 2
a325 1
sio_intr_disestablish(handler)
d341 1
a341 1
	int irq;
d364 8
d405 4
a408 2
		outb(IO_ICU2 + 0, 0x20 | (irq & 0x07));		/* XXX */
	outb(IO_ICU1 + 0, 0x20 | (irq > 7 ? 2 : irq));		/* XXX */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

