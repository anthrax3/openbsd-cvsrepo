head	1.40;
access;
symbols
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.40.0.4
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.38.0.10
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.38.0.2
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.38.0.6
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.38.0.4
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.37.0.2
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.36.0.12
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.36.0.10
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.36
	OPENBSD_5_1:1.36.0.8
	OPENBSD_5_0:1.36.0.6
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.36.0.4
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.36.0.2
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.35.0.6
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.35.0.8
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.35.0.4
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.35.0.2
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.31.0.10
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.31.0.8
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.31.0.6
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.31.0.4
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.30.0.4
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.30.0.2
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.29.0.2
	OPENBSD_3_6_BASE:1.29
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.28.0.2
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.27.0.8
	OPENBSD_3_4_BASE:1.27
	UBC_SYNC_A:1.27
	OPENBSD_3_3:1.27.0.6
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.27.0.4
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.27.0.2
	OPENBSD_3_1_BASE:1.27
	UBC_SYNC_B:1.27
	UBC:1.26.0.2
	UBC_BASE:1.26
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9:1.22.0.2
	OPENBSD_2_9_BASE:1.22
	OPENBSD_2_8:1.15.0.10
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.15.0.8
	OPENBSD_2_7_BASE:1.15
	SMP:1.15.0.6
	SMP_BASE:1.15
	kame_19991208:1.15
	OPENBSD_2_6:1.15.0.4
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.15.0.2
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.14.0.2
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.40
date	2015.08.15.19.26.00;	author miod;	state Exp;
branches;
next	1.39;
commitid	hTgKAyy7Z1S7sARK;

1.39
date	2015.08.15.19.15.18;	author miod;	state Exp;
branches;
next	1.38;
commitid	smtnaO3aYbvHjDlk;

1.38
date	2014.02.18.19.37.33;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2013.03.08.18.29.33;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2010.06.06.11.26.11;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2008.07.29.18.40.23;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2008.07.25.21.11.15;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2008.07.22.20.06.01;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2008.07.19.18.13.06;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2006.01.02.05.21.26;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2004.12.06.19.51.41;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2004.06.28.02.28.43;	author aaron;	state Exp;
branches;
next	1.28;

1.28
date	2004.01.12.19.01.54;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.14.01.26.27;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2001.10.26.11.14.09;	author art;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2001.10.26.01.28.06;	author nate;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.17.22.55.09;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.17.22.26.58;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.07.01.03.51;	author ericj;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.06.19.07.11;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.02.05.17.25.42;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.02.05.17.18.33;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.02.05.17.14.40;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.05.17.10.16;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.08.16.01.21;	author art;	state Exp;
branches;
next	1.15;

1.15
date	99.02.08.18.17.21;	author millert;	state Exp;
branches
	1.15.6.1;
next	1.14;

1.14
date	98.06.29.05.32.54;	author downsj;	state Exp;
branches;
next	1.13;

1.13
date	98.02.24.02.05.20;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.01.07.07.39.58;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	98.01.05.13.35.17;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.07.31.11.03.03;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.01.24.19.57.57;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.12.08.00.20.48;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.11.23.21.44.56;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	96.11.12.20.29.39;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.10.30.22.40.14;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.07.29.23.00.53;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.06.18.09.44.37;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.53.36;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.45;	author deraadt;	state Exp;
branches;
next	;

1.15.6.1
date	2001.04.18.16.01.30;	author niklas;	state Exp;
branches;
next	1.15.6.2;

1.15.6.2
date	2001.10.31.02.52.45;	author nate;	state Exp;
branches;
next	1.15.6.3;

1.15.6.3
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	1.15.6.4;

1.15.6.4
date	2004.02.19.09.59.34;	author niklas;	state Exp;
branches;
next	;

1.26.2.1
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	;


desc
@@


1.40
log
@Store the {e,}isa_chipset_t in the softc, rather than on sio_bridge_callback()'s
stack, for {e,}isa drivers might have a need for them way after autoconf - at
least pcic@@isa does.
@
text
@/*	$OpenBSD: sio.c,v 1.39 2015/08/15 19:15:18 miod Exp $	*/
/*	$NetBSD: sio.c,v 1.15 1996/12/05 01:39:36 cgd Exp $	*/

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>

#include <machine/intr.h>
#include <machine/bus.h>

#include <dev/isa/isavar.h>
#include <dev/eisa/eisavar.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <alpha/pci/siovar.h>

#include "eisa.h"
#include "isadma.h"

struct sio_softc {
	struct device			sc_dv;

	bus_space_tag_t			sc_iot, sc_memt;
	bus_dma_tag_t			sc_dmat;
	int				sc_haseisa;

	struct alpha_eisa_chipset	sc_ec;
	struct alpha_isa_chipset	sc_ic;
};

int	siomatch(struct device *, void *, void *);
void	sioattach(struct device *, struct device *, void *);
int	sioactivate(struct device *, int);

extern int sio_intr_alloc(isa_chipset_tag_t, int, int, int *);
extern int sio_intr_check(isa_chipset_tag_t, int, int);

const struct cfattach sio_ca = {
	.ca_devsize = sizeof(struct sio_softc),
	.ca_match = siomatch,
	.ca_attach = sioattach,
	.ca_activate = sioactivate
};

struct cfdriver sio_cd = {
	NULL, "sio", DV_DULL,
};

int	pcebmatch(struct device *, void *, void *);

struct cfattach pceb_ca = {
	sizeof(struct sio_softc), pcebmatch, sioattach,
};

struct cfdriver pceb_cd = {
	NULL, "pceb", DV_DULL,
};

union sio_attach_args {
	const char *sa_name;			/* XXX should be common */
	struct isabus_attach_args sa_iba;
	struct eisabus_attach_args sa_eba;
};

int	sioprint(void *, const char *pnp);
void	sio_isa_attach_hook(struct device *, struct device *,
	    struct isabus_attach_args *);
void	sio_eisa_attach_hook(struct device *, struct device *,
	    struct eisabus_attach_args *);
int	sio_eisa_intr_map(void *, u_int, eisa_intr_handle_t *);
void	sio_bridge_callback(struct device *);

int
siomatch(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_CONTAQ &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CONTAQ_82C693 &&
	    pa->pa_function == 0)
		return (1);

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INTEL &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_SIO)
		return (1);

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ALI &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ALI_M1533)
		return(1);

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ALI &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ALI_M1543)
		return(1);
	return (0);
}

int
pcebmatch(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INTEL &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_PCEB)
		return (1);

	return (0);
}

void
sioattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct sio_softc *sc = (struct sio_softc *)self;
	struct pci_attach_args *pa = aux;

	printf("\n");

	sc->sc_iot = pa->pa_iot;
	sc->sc_memt = pa->pa_memt;
        sc->sc_dmat = pa->pa_dmat;
	sc->sc_haseisa = (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INTEL &&
		PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_PCEB);

	config_defer(self, sio_bridge_callback);
}

int
sioactivate(struct device *self, int act)
{
	int rv = 0;

	switch (act) {
	case DVACT_POWERDOWN:
		rv = config_activate_children(self, act);
		sio_intr_shutdown();
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

void
sio_bridge_callback(self)
	struct device *self;
{
	struct sio_softc *sc = (struct sio_softc *)self;
	union sio_attach_args sa;

	if (sc->sc_haseisa) {
		sc->sc_ec.ec_v = NULL;
		sc->sc_ec.ec_maxslots = 0; /* will be filled by attach_hook */
		sc->sc_ec.ec_attach_hook = sio_eisa_attach_hook;
		sc->sc_ec.ec_intr_map = sio_eisa_intr_map;
		sc->sc_ec.ec_intr_string = sio_intr_string;
		sc->sc_ec.ec_intr_establish = sio_intr_establish;
		sc->sc_ec.ec_intr_disestablish = sio_intr_disestablish;

		sa.sa_eba.eba_busname = "eisa";
		sa.sa_eba.eba_iot = sc->sc_iot;
		sa.sa_eba.eba_memt = sc->sc_memt;
		sa.sa_eba.eba_dmat =
		    alphabus_dma_get_tag(sc->sc_dmat, ALPHA_BUS_EISA);
		sa.sa_eba.eba_ec = &sc->sc_ec;
		config_found(&sc->sc_dv, &sa.sa_eba, sioprint);
	}

	sc->sc_ic.ic_v = NULL;
	sc->sc_ic.ic_attach_hook = sio_isa_attach_hook;
	sc->sc_ic.ic_intr_establish = sio_intr_establish;
	sc->sc_ic.ic_intr_disestablish = sio_intr_disestablish;
	sc->sc_ic.ic_intr_alloc = sio_intr_alloc;
	sc->sc_ic.ic_intr_check = sio_intr_check;

	sa.sa_iba.iba_busname = "isa";
	sa.sa_iba.iba_iot = sc->sc_iot;
	sa.sa_iba.iba_memt = sc->sc_memt;
#if NISADMA > 0
	sa.sa_iba.iba_dmat =
		alphabus_dma_get_tag(sc->sc_dmat, ALPHA_BUS_ISA);
#endif
	sa.sa_iba.iba_ic = &sc->sc_ic;
	config_found(&sc->sc_dv, &sa.sa_iba, sioprint);
}

int
sioprint(aux, pnp)
	void *aux;
	const char *pnp;
{
        register union sio_attach_args *sa = aux;

        if (pnp)
                printf("%s at %s", sa->sa_name, pnp);
        return (UNCONF);
}

void
sio_isa_attach_hook(parent, self, iba)
	struct device *parent, *self;
	struct isabus_attach_args *iba;
{
	/* Nothing to do. */
}

void
sio_eisa_attach_hook(parent, self, eba)
	struct device *parent, *self;
	struct eisabus_attach_args *eba;
{
#if NEISA > 0
	eisa_init(eba->eba_ec);
#endif
}

int
sio_eisa_intr_map(v, irq, ihp)
	void *v;
	u_int irq;
	eisa_intr_handle_t *ihp;
{

#define	ICU_LEN		16	/* number of ISA IRQs (XXX) */

	if (irq >= ICU_LEN) {
		printf("sio_eisa_intr_map: bad IRQ %d\n", irq);
		*ihp = -1;
		return 1;
	}
	if (irq == 2) {
		printf("sio_eisa_intr_map: changed IRQ 2 to IRQ 9\n");
		irq = 9;
	}

	*ihp = irq;
	return 0;
}
@


1.39
log
@Fix isa_chipset_t ic_intr_{alloc,check} prototype: these take an
isa_chipset_tag_t, not an isa_chipset_tag_t *, as isa_chipset_tag_t is already
a pointer.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.38 2014/02/18 19:37:33 miod Exp $	*/
d52 1
a52 1
	struct device	sc_dv;
d54 6
a59 3
	bus_space_tag_t sc_iot, sc_memt;
	bus_dma_tag_t	sc_dmat;
	int		sc_haseisa;
d69 1
a69 1
struct cfattach sio_ca = {
a186 2
	struct alpha_eisa_chipset ec;
	struct alpha_isa_chipset ic;
d190 7
a196 7
		ec.ec_v = NULL;
		ec.ec_maxslots = 0;	/* will be filled by attach_hook */
		ec.ec_attach_hook = sio_eisa_attach_hook;
		ec.ec_intr_map = sio_eisa_intr_map;
		ec.ec_intr_string = sio_intr_string;
		ec.ec_intr_establish = sio_intr_establish;
		ec.ec_intr_disestablish = sio_intr_disestablish;
d203 1
a203 1
		sa.sa_eba.eba_ec = &ec;
d207 6
a212 6
	ic.ic_v = NULL;
	ic.ic_attach_hook = sio_isa_attach_hook;
	ic.ic_intr_establish = sio_intr_establish;
	ic.ic_intr_disestablish = sio_intr_disestablish;
	ic.ic_intr_alloc = sio_intr_alloc;
	ic.ic_intr_check = sio_intr_check;
d221 1
a221 1
	sa.sa_iba.iba_ic = &ic;
@


1.38
log
@sio_intr_shutdown() used to be a shutdown hook, and eventually became an
unconditional call in machdep.c!boot(). Except that the cpp conditional
enabling its use was not in machdep.c's scope, so this function was never
called. Ouch.

Remove it from boot() and grow a ca_activate method to the sio(4/alpha) device,
which will take care of invoking sio_intr_shutdown() if DVACT_POWERDOWN.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.37 2013/03/08 18:29:33 miod Exp $	*/
d63 2
a64 2
extern int sio_intr_alloc(isa_chipset_tag_t *, int, int, int *);
extern int sio_intr_check(isa_chipset_tag_t *, int, int);
@


1.37
log
@Stop defining __NO_ISA_INTR_CHECK and add a real isa_intr_check() function.
Allows pcic to attach and correctly pick a suitable interrupt on Multia.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.36 2010/06/06 11:26:11 miod Exp $	*/
d61 1
a65 1

d67 4
a70 1
	sizeof(struct sio_softc), siomatch, sioattach,
d160 17
@


1.36
log
@Kill unused sio_intr_count.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.35 2008/07/29 18:40:23 miod Exp $	*/
d63 1
d191 1
@


1.35
log
@Give the eisa device a valid bus_dma_tag_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.34 2008/07/25 21:11:15 miod Exp $	*/
a153 2

	evcount_attach(&sio_intr_count, self->dv_xname, NULL, &evcount_intr);
@


1.34
log
@Improve eisa bus probe by deciding the number of logical eisa slots from
the motherboard eisa id, instead of using a ``one size fits all'' value which
is too large on more than half the eisa-capable alpha designs.

The id -> slot # logic is based on the alpha ECU configuration files, so we
should not perform worse than ECU itself (and see all slots ECU sees too).
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.33 2008/07/22 20:06:01 miod Exp $	*/
d181 2
@


1.33
log
@None of the pceb EISA alpha designs has more than 8 physical slots, so don't
bother trying to probe more.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.32 2008/07/19 18:13:06 miod Exp $	*/
a93 1
int	sio_eisa_maxslots(void *);
d171 1
a172 1
		ec.ec_maxslots = sio_eisa_maxslots;
a229 10
}

int
sio_eisa_maxslots(v)
	void *v;
{
	/*
	 * None of the alpha backplanes has more than 8 physical slots.
	 */
	return 9;
@


1.32
log
@Add code to walk the eisa configuration, from NetBSD. This configuration
is not used yet, but this seems to ``warm up'' the eisa chips so that
accesses to the eisa bus later do not cause machine checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.31 2006/01/02 05:21:26 brad Exp $	*/
d237 4
a240 2

	return 16;		/* as good a number as any.  only 8, maybe? */
@


1.31
log
@remove last traces of __BROKEN_INDIRECT_CONFIG.

Thanks to aanriot@@ and Michael Knudsen for checking that alpha/i386/macppc
kernels still compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.30 2004/12/06 19:51:41 brad Exp $	*/
d48 1
d228 3
a230 2

	/* Nothing to do. */
@


1.30
log
@Use config_defer().

From NetBSD

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.29 2004/06/28 02:28:43 aaron Exp $	*/
a57 1
#ifdef __BROKEN_INDIRECT_CONFIG
a58 3
#else
int	siomatch(struct device *, struct cfdata *, void *);
#endif
a71 1
#ifdef __BROKEN_INDIRECT_CONFIG
a72 3
#else
int	pcebmatch(struct device *, struct cfdata *, void *);
#endif
a99 1
#ifdef __BROKEN_INDIRECT_CONFIG
a100 3
#else
	struct cfdata *match;
#endif
a126 1
#ifdef __BROKEN_INDIRECT_CONFIG
a127 3
#else
	struct cfdata *match;
#endif
@


1.29
log
@Use new event counter API for interrupt counting on alpha.  By me, with some
edits by Theo.  deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.28 2004/01/12 19:01:54 deraadt Exp $	*/
d103 1
a103 1
void	sio_bridge_callback(void *);
d173 1
a173 1
	set_pci_isa_bridge_callback(sio_bridge_callback, sc);
d177 2
a178 2
sio_bridge_callback(v)
	void *v;
d180 1
a180 1
	struct sio_softc *sc = v;
@


1.28
log
@match both ALI ISA bridges (more fallout); ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.27 2002/03/14 01:26:27 millert Exp $	*/
d171 1
a171 3
#ifdef EVCNT_COUNTERS
	evcnt_attach(&sc->sc_dv, "intr", &sio_intr_evcnt);
#endif
@


1.27
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.26 2001/10/26 11:14:09 art Exp $	*/
d125 4
@


1.26
log
@Don't bomb if isadma is not configured.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.25 2001/10/26 01:28:06 nate Exp $	*/
d59 1
a59 1
int	siomatch __P((struct device *, void *, void *));
d61 1
a61 1
int	siomatch __P((struct device *, struct cfdata *, void *));
d63 1
a63 1
void	sioattach __P((struct device *, struct device *, void *));
d65 1
a65 1
extern int sio_intr_alloc __P((isa_chipset_tag_t *, int, int, int *));
d77 1
a77 1
int	pcebmatch __P((struct device *, void *, void *));
d79 1
a79 1
int	pcebmatch __P((struct device *, struct cfdata *, void *));
d96 8
a103 8
int	sioprint __P((void *, const char *pnp));
void	sio_isa_attach_hook __P((struct device *, struct device *,
	    struct isabus_attach_args *));
void	sio_eisa_attach_hook __P((struct device *, struct device *,
	    struct eisabus_attach_args *));
int	sio_eisa_maxslots __P((void *));
int	sio_eisa_intr_map __P((void *, u_int, eisa_intr_handle_t *));
void	sio_bridge_callback __P((void *));
@


1.26.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.26 2001/10/26 11:14:09 art Exp $	*/
d59 1
a59 1
int	siomatch(struct device *, void *, void *);
d61 1
a61 1
int	siomatch(struct device *, struct cfdata *, void *);
d63 1
a63 1
void	sioattach(struct device *, struct device *, void *);
d65 1
a65 1
extern int sio_intr_alloc(isa_chipset_tag_t *, int, int, int *);
d77 1
a77 1
int	pcebmatch(struct device *, void *, void *);
d79 1
a79 1
int	pcebmatch(struct device *, struct cfdata *, void *);
d96 8
a103 8
int	sioprint(void *, const char *pnp);
void	sio_isa_attach_hook(struct device *, struct device *,
	    struct isabus_attach_args *);
void	sio_eisa_attach_hook(struct device *, struct device *,
	    struct eisabus_attach_args *);
int	sio_eisa_maxslots(void *);
int	sio_eisa_intr_map(void *, u_int, eisa_intr_handle_t *);
void	sio_bridge_callback(void *);
@


1.25
log
@First cut at a port of isadma and floppy driver.  ok art@@
From NetBSD via jay@@rootaction.net
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.24 2001/08/17 22:55:09 mickey Exp $	*/
d48 2
d208 1
d211 1
@


1.24
log
@cut and paste typos; from art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.23 2001/08/17 22:26:58 mickey Exp $	*/
d52 1
d63 3
d161 1
d201 1
d206 2
@


1.23
log
@provide a way to get the number used for irq line, not only a string
representation, this is needed for devices like cbb which pass
the interrupt line down to the cardbus attachment and not
getting the right line before pci_intr_map() has done it's
dirty deed.
tested on i386 by jason@@, compiles on alpha by art@@.
ppc and mveppc are to be test-compiled, but should work (;
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.22 2001/03/07 01:03:51 ericj Exp $	*/
a181 1
		ec.ec_intr_line = sio_intr_line;
@


1.22
log
@
DS10 uses Acer M1543 pci<->isa bridge, so match it in siomatch()
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.21 2001/02/06 19:07:11 art Exp $	*/
d182 1
@


1.21
log
@I don't think there is a reason to enable IDE through isa now that
we have pciide.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.20 2001/02/05 17:25:42 art Exp $	*/
d120 3
@


1.20
log
@No, Intel is not a PC_VENDOR. Intel is a PCI_VENDOR.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.19 2001/02/05 17:18:33 art Exp $	*/
a96 2
void	siocfiddle __P((struct isabus_attach_args *iba));

d218 1
a218 1
	siocfiddle(iba);
a258 45
}


/*
 * Look for and gently fondle the 87312 Super I/O chip.
 */

#define SIOC_IDE_ENABLE	0x40
#define	SIOC_NPORTS	2
void
siocfiddle(iba)
	struct isabus_attach_args *iba;
{
	bus_space_tag_t iot = iba->iba_iot;
	bus_space_handle_t ioh;
	extern int cputype;
	int addr;
	u_int8_t reg0;

	/* Decide based on machine type */
	switch (cputype) {
	case 11:			/* DEC AXPpci */
	case 12:			/* DEC 2100 A50 */
		addr = 0x26e;
		break;
	case 26:			/* DEC EB164 */
		addr = 0x398;
		break;
	default:
		return;
	}

	if (bus_space_map(iot, addr, SIOC_NPORTS, 0, &ioh))
		return;

	/* select and read register 0 */
	bus_space_write_1(iot, ioh, 0, 0);
	reg0 = bus_space_read_1(iot, ioh, 1);

	/* write back with IDE enabled flag set, and do it twice!  */
	bus_space_write_1(iot, ioh, 0, 0);
	bus_space_write_1(iot, ioh, 1, reg0 | SIOC_IDE_ENABLE);
	bus_space_write_1(iot, ioh, 1, reg0 | SIOC_IDE_ENABLE);

	bus_space_unmap(iot, ioh, SIOC_NPORTS);
@


1.19
log
@Sigh. Another horrible abuse in this file..
When checking if this is a pci-eisa bridge check the VENDOR too, don't just
assume that no other vendor will do a sia with product id
PCI_PRODUCT_INTEL_PCEB.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.18 2001/02/05 17:14:40 art Exp $	*/
d156 1
a156 1
	sc->sc_haseisa = (PCI_VENDOR(pa->pa_id) == PC_VENDOR_INTEL &&
@


1.18
log
@reverse the logic in pcebmatch to match other match functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.17 2001/02/05 17:10:16 art Exp $	*/
d156 2
a157 1
	sc->sc_haseisa = (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_PCEB);
@


1.17
log
@set the correct size in pceb_ca.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.16 2000/11/08 16:01:21 art Exp $	*/
d137 3
a139 3
	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_INTEL ||
	    PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_INTEL_PCEB)
		return (0);
d141 1
a141 1
	return (1);
@


1.16
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.15 1999/02/08 18:17:21 millert Exp $	*/
d77 1
a77 1
	sizeof(struct device), pcebmatch, sioattach,
@


1.15
log
@PCI_PRODUCT_CONTAQ_SIO -> PCI_PRODUCT_CONTAQ_82C693
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.14 1998/06/29 05:32:54 downsj Exp $	*/
a193 1
	ic.ic_intr_check = sio_intr_check;
@


1.15.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.22 2001/03/07 01:03:51 ericj Exp $	*/
d77 1
a77 1
	sizeof(struct sio_softc), pcebmatch, sioattach,
d97 2
a121 3
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ALI &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ALI_M1543)
		return(1);
d137 3
a139 3
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INTEL &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_PCEB)
		return (1);
d141 1
a141 1
	return (0);
d156 1
a156 2
	sc->sc_haseisa = (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INTEL &&
		PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_PCEB);
d194 1
d220 1
a220 1
	/* Nothing to do. */
d261 45
@


1.15.6.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.15.6.1 2001/04/18 16:01:30 niklas Exp $	*/
a47 2
#include "isadma.h"

a51 1
	bus_dma_tag_t	sc_dmat;
a61 3
extern int sio_intr_alloc __P((isa_chipset_tag_t *, int, int, int *));


a156 1
        sc->sc_dmat = pa->pa_dmat;
a195 1
	ic.ic_intr_alloc = sio_intr_alloc;
a199 4
#if NISADMA > 0
	sa.sa_iba.iba_dmat =
		alphabus_dma_get_tag(sc->sc_dmat, ALPHA_BUS_ISA);
#endif
@


1.15.6.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 1
a59 1
int	siomatch(struct device *, void *, void *);
d61 1
a61 1
int	siomatch(struct device *, struct cfdata *, void *);
d63 1
a63 1
void	sioattach(struct device *, struct device *, void *);
d65 1
a65 1
extern int sio_intr_alloc(isa_chipset_tag_t *, int, int, int *);
d77 1
a77 1
int	pcebmatch(struct device *, void *, void *);
d79 1
a79 1
int	pcebmatch(struct device *, struct cfdata *, void *);
d96 8
a103 8
int	sioprint(void *, const char *pnp);
void	sio_isa_attach_hook(struct device *, struct device *,
	    struct isabus_attach_args *);
void	sio_eisa_attach_hook(struct device *, struct device *,
	    struct eisabus_attach_args *);
int	sio_eisa_maxslots(void *);
int	sio_eisa_intr_map(void *, u_int, eisa_intr_handle_t *);
void	sio_bridge_callback(void *);
@


1.15.6.4
log
@Merge of -current from two weeks ago into the SMP branch
@
text
@a126 4
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ALI_M1533)
		return(1);

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ALI &&
@


1.14
log
@isa_intr_check(), alpha style.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.13 1998/02/24 02:05:20 millert Exp $	*/
d114 1
a114 1
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CONTAQ_SIO &&
@


1.13
log
@Support PCI_PRODUCT_CONTAQ_SIO for 164SX.  Based on patch by ragge@@ludd.luth.se.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.12 1998/01/07 07:39:58 niklas Exp $	*/
d194 1
@


1.12
log
@compile
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.11 1998/01/05 13:35:17 deraadt Exp $	*/
d113 8
a120 3
	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_INTEL ||
	    PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_INTEL_SIO)
		return (0);
d122 1
a122 1
	return (1);
@


1.11
log
@new style pci attach printing
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.10 1997/07/31 11:03:03 deraadt Exp $	*/
a145 1
	char devinfo[256];
@


1.10
log
@use isa hook to enable IDE port on machines where it exists. Niklas
wrote this as a driver, but the change has to be done earlier.
alpha:/usr/obj is now IDE.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.9 1997/01/24 19:57:57 niklas Exp $	*/
d148 1
a148 3
	pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo);
	printf(": %s (rev. 0x%02x)\n", devinfo,
	    PCI_REVISION(pa->pa_class));
@


1.9
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.8 1996/12/08 00:20:48 niklas Exp $	*/
d97 1
d217 1
a217 2

	/* Nothing to do. */
d258 45
@


1.8
log
@Merge to NetBSD 961107, i.e. mostly new bus.h
@
text
@d1 2
a2 2
/*	$OpenBSD: sio.c,v 1.7 1996/11/23 21:44:56 kstailey Exp $	*/
/*	$NetBSD: sio.c,v 1.12 1996/10/23 04:12:33 cgd Exp $	*/
d48 8
d57 3
d63 1
a63 1
	sizeof(struct device), siomatch, sioattach,
d70 1
d72 3
d98 2
d103 6
a108 1
	void *match, *aux;
d122 6
a127 1
	void *match, *aux;
d143 1
a144 4
	struct alpha_isa_chipset ic;
	struct alpha_eisa_chipset ec;
	union sio_attach_args sa;
	int sio, haseisa;
a146 3
	sio = (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_SIO);
	haseisa = (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_PCEB);

d151 3
a153 9
	if (sio) {
		pci_revision_t rev;

		rev = PCI_REVISION(pa->pa_class);
		
		if (rev < 3)
			printf("%s: WARNING: SIO I SUPPORT UNTESTED\n",
			    self->dv_xname);
	}
d156 1
a156 1
	evcnt_attach(self, "intr", &sio_intr_evcnt);
d159 13
a171 1
	if (haseisa) {
d181 2
a182 2
		sa.sa_eba.eba_iot = pa->pa_iot;
		sa.sa_eba.eba_memt = pa->pa_memt;
d184 1
a184 1
		config_found(self, &sa.sa_eba, sioprint);
d193 2
a194 2
	sa.sa_iba.iba_iot = pa->pa_iot;
	sa.sa_iba.iba_memt = pa->pa_memt;
d196 1
a196 1
	config_found(self, &sa.sa_iba, sioprint);
@


1.7
log
@added const to second parameter of cfprint_t routines
@
text
@d1 2
a2 2
/*	$OpenBSD: sio.c,v 1.6 1996/11/12 20:29:39 niklas Exp $	*/
/*	$NetBSD: sio.c,v 1.11 1996/10/13 03:00:18 christos Exp $	*/
d37 1
a37 1
#include <machine/bus.old.h>
d154 2
a155 1
		sa.sa_eba.eba_bc = pa->pa_bc;
d166 2
a167 1
	sa.sa_iba.iba_bc = pa->pa_bc;
@


1.6
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.5 1996/10/30 22:40:14 niklas Exp $	*/
d75 1
a75 1
int	sioprint __P((void *, /* const */ char *pnp));
d173 1
a173 1
	/* const */ char *pnp;
@


1.5
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio.c,v 1.11 1996/10/13 03:00:18 christos Exp $	*/
d37 1
a37 1
#include <machine/bus.h>
@


1.4
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: sio.c,v 1.8 1996/04/13 00:23:34 cgd Exp $	*/
/*	$NetBSD: sio.c,v 1.8 1996/04/13 00:23:34 cgd Exp $	*/
d75 1
a75 1
int	sioprint __P((void *, char *pnp));
a87 1
	struct cfdata *cf = match;
a101 1
	struct cfdata *cf = match;
d173 1
a173 1
	char *pnp;
@


1.3
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.2
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: sio.c,v 1.3 1995/11/23 02:38:16 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1995 Carnegie-Mellon University.
d35 3
d50 6
a55 2
struct cfdriver siocd = {
	NULL, "sio", siomatch, sioattach, DV_DULL, sizeof(struct device)
d60 6
a65 2
struct cfdriver pcebcd = {
	NULL, "pceb", pcebmatch, sioattach, DV_DULL, sizeof(struct device)
d68 13
a80 1
static int	sioprint __P((void *, char *pnp));
d88 1
a88 1
	struct pcidev_attach_args *pda = aux;
d90 2
a91 2
	if (PCI_VENDOR(pda->pda_id) != PCI_VENDOR_INTEL ||
	    PCI_PRODUCT(pda->pda_id) != PCI_PRODUCT_INTEL_SIO)
d103 1
a103 1
	struct pcidev_attach_args *pda = aux;
d105 2
a106 2
	if (PCI_VENDOR(pda->pda_id) != PCI_VENDOR_INTEL ||
	    PCI_PRODUCT(pda->pda_id) != PCI_PRODUCT_INTEL_PCEB)
d117 4
a120 3
	struct pcidev_attach_args *pda = aux;
	struct isa_attach_args ia;
	struct eisa_attach_args ea;
d124 2
a125 2
	sio = (PCI_PRODUCT(pda->pda_id) == PCI_PRODUCT_INTEL_SIO);
	haseisa = (PCI_PRODUCT(pda->pda_id) == PCI_PRODUCT_INTEL_PCEB);
d127 1
a127 1
	pci_devinfo(pda->pda_id, pda->pda_class, 0, devinfo);
d129 1
a129 1
	    PCI_REVISION(pda->pda_class));
d134 1
a134 1
		rev = PCI_REVISION(pda->pda_class);
a144 11
	ia.ia_bus = BUS_ISA;
	ia.ia_dmafns = pda->pda_dmafns;
	ia.ia_dmaarg = pda->pda_dmaarg;
	ia.ia_intrfns = &sio_isa_intr_fns;
	ia.ia_intrarg = NULL;			/* XXX needs nothing */
	ia.ia_memfns = pda->pda_memfns;
	ia.ia_memarg = pda->pda_memarg;
	ia.ia_piofns = pda->pda_piofns;
	ia.ia_pioarg = pda->pda_pioarg;
	config_found(self, &ia, sioprint);

d146 12
a157 10
		ea.ea_bus = BUS_EISA;
		ea.ea_dmafns = pda->pda_dmafns;
		ea.ea_dmaarg = pda->pda_dmaarg;
		ea.ea_intrfns = &sio_isa_intr_fns;
		ea.ea_intrarg = NULL;		/* XXX needs nothing */
		ea.ea_memfns = pda->pda_memfns;
		ea.ea_memarg = pda->pda_memarg;
		ea.ea_piofns = pda->pda_piofns;
		ea.ea_pioarg = pda->pda_pioarg;
		config_found(self, &ea, sioprint);
d159 10
d171 1
a171 1
static int
d176 1
a176 6
        register struct isa_attach_args *ia = aux;

	/*
	 * XXX Assumes that the first fields of 'struct isa_attach_args'
	 * XXX and 'struct eisa_attach_args' are the same.
	 */
d179 1
a179 1
                printf("%s at %s", isa_bustype_name(ia->ia_bus), pnp);
d181 49
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: sio.c,v 1.2 1995/08/03 01:17:25 cgd Exp $	*/
d35 3
d42 1
a42 1
#include <machine/autoconf.h>
d51 6
d65 16
a80 1
	struct pci_attach_args *pa = aux;
d82 2
a83 2
	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_INTEL ||
	    PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_INTEL_SIO)
d94 49
a142 12
	struct pci_attach_args *pa = aux;
	struct confargs nca;
	u_int rev;
	char *type;

	rev = pa->pa_class & 0xff;
	if (rev < 3) {
		type = "I";
		/* XXX PCI IRQ MAPPING FUNCTION */
	} else {
		type = "II";
		/* XXX PCI IRQ MAPPING FUNCTION */
a143 12
	printf(": Saturn %s PCI->ISA bridge (revision 0x%x)\n", type, rev);
	if (rev < 3)
		printf("%s: WARNING: SIO I SUPPORT UNTESTED\n",
		    parent->dv_xname);

	/* attach the ISA bus that hangs off of it... */
	nca.ca_name = "isa";
	nca.ca_slot = 0;
	nca.ca_offset = 0;
	nca.ca_bus = NULL;
	if (!config_found(self, &nca, sioprint))
		panic("sioattach: couldn't attach ISA bus");
d151 6
a156 1
        register struct confargs *ca = aux;
d159 1
a159 1
                printf("%s at %s", ca->ca_name, pnp);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
