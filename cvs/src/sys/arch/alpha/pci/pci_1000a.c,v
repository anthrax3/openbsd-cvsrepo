head	1.13;
access;
symbols
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.6
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.12.0.18
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.22
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.20
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.16
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.14
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.12
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.10
	OPENBSD_5_0:1.12.0.8
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.10.0.8
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.4
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.3.0.2
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.2.0.6
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	OPENBSD_3_5:1.1.0.12
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.10
	OPENBSD_3_4_BASE:1.1
	UBC_SYNC_A:1.1
	SMP:1.1.0.8
	OPENBSD_3_3:1.1.0.6
	OPENBSD_3_3_BASE:1.1
	UBC:1.1.0.4
	UBC_SYNC_B:1.1
	OPENBSD_3_2:1.1.0.2
	OPENBSD_3_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.07.26.05.09.44;	author miod;	state Exp;
branches;
next	1.12;
commitid	5evJqb5U3VOxLlWE;

1.12
date	2009.09.30.20.16.30;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.10;

1.10
date	2008.07.22.18.47.24;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2008.07.22.18.45.50;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2008.07.19.19.25.18;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.26.05.42.09;	author ray;	state Exp;
branches;
next	1.6;

1.6
date	2008.01.09.22.23.00;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.15.20.08.29;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.26.20.23.08;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2006.01.29.10.47.35;	author martin;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.28.02.28.42;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.30.16.24.40;	author miod;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2002.10.29.00.28.01;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Make sure pci_intr_map() will perform proper interrupt swizzling for devices
behind a bridge, if the SRM didn't pick an interrupt line for them.
@
text
@/* $OpenBSD: pci_1000a.c,v 1.12 2009/09/30 20:16:30 miod Exp $ */
/* $NetBSD: pci_1000a.c,v 1.14 2001/07/27 00:25:20 thorpej Exp $ */

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is based on pci_kn20aa.c, written by Chris G. Demetriou at
 * Carnegie-Mellon University. Platform support for Noritake, Pintake, and
 * Corelle by Ross Harvey with copyright assignment by permission of Avalon
 * Computer Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/time.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/device.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/ppbreg.h>

#include <alpha/pci/pci_1000a.h>

#include "sio.h"
#if NSIO > 0 || NPCEB > 0
#include <alpha/pci/siovar.h>
#endif

#define	PCI_NIRQ	32
#define	PCI_STRAY_MAX	5

#define IMR2IRQ(bn) ((bn) - 1)
#define IRQ2IMR(irq) ((irq) + 1)

static bus_space_tag_t mystery_icu_iot;
static bus_space_handle_t mystery_icu_ioh[2];

int	dec_1000a_intr_map(struct pci_attach_args *, pci_intr_handle_t *);
const char *dec_1000a_intr_string(void *, pci_intr_handle_t);
int	dec_1000a_intr_line(void *, pci_intr_handle_t);
void	*dec_1000a_intr_establish(void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, const char *);
void	dec_1000a_intr_disestablish(void *, void *);

struct alpha_shared_intr *dec_1000a_pci_intr;

void dec_1000a_iointr(void *arg, unsigned long vec);
void dec_1000a_enable_intr(int irq);
void dec_1000a_disable_intr(int irq);
void pci_1000a_imi(void);

void
pci_1000a_pickintr(core, iot, memt, pc)
	void *core;
	bus_space_tag_t iot, memt;
	pci_chipset_tag_t pc;
{
	int i;

	mystery_icu_iot = iot;

	if (bus_space_map(iot, 0x54a, 2, 0, mystery_icu_ioh + 0)
	||  bus_space_map(iot, 0x54c, 2, 0, mystery_icu_ioh + 1))
		panic("pci_1000a_pickintr");
        pc->pc_intr_v = core;
        pc->pc_intr_map = dec_1000a_intr_map;
        pc->pc_intr_string = dec_1000a_intr_string;
	pc->pc_intr_line = dec_1000a_intr_line;
        pc->pc_intr_establish = dec_1000a_intr_establish;
        pc->pc_intr_disestablish = dec_1000a_intr_disestablish;

	pc->pc_pciide_compat_intr_establish = NULL;
	pc->pc_pciide_compat_intr_disestablish = NULL;

	dec_1000a_pci_intr = alpha_shared_intr_alloc(PCI_NIRQ);
	for (i = 0; i < PCI_NIRQ; i++) {
		alpha_shared_intr_set_maxstrays(dec_1000a_pci_intr, i,
		    PCI_STRAY_MAX);
	}

	pci_1000a_imi();
#if NSIO > 0 || NPCEB > 0
	sio_intr_setup(pc, iot);
#endif
}

int     
dec_1000a_intr_map(pa, ihp)
	struct pci_attach_args *pa;
        pci_intr_handle_t *ihp;
{
	pcitag_t bustag = pa->pa_intrtag;
	int buspin, line = pa->pa_intrline;
	int imrbit = 0, bus, device;
	/*
	 * Get bit number in mystery ICU imr
	 */
	static const signed char imrmap[][4] = {
#		define	IRQSPLIT(o) { (o), (o)+1, (o)+16, (o)+16+1 }
#		define	IRQNONE		 { 0, 0, 0, 0 }
		/*  0  */ { 1, 0, 0, 0 },	/* Noritake and Pintake */
		/*  1  */ IRQSPLIT(8),
		/*  2  */ IRQSPLIT(10),
		/*  3  */ IRQSPLIT(12),
		/*  4  */ IRQSPLIT(14),
		/*  5  */ { 1, 0, 0, 0 },	/* Corelle */
		/*  6  */ { 10, 0, 0, 0 },	/* Corelle */
		/*  7  */ IRQNONE,
		/*  8  */ IRQNONE,		/* see imrmap2[] below */
		/*  9  */ IRQNONE,
		/* 10  */ IRQNONE,
		/* 11  */ IRQSPLIT(2),
		/* 12  */ IRQSPLIT(4),
		/* 13  */ IRQSPLIT(6),
		/* 14  */ IRQSPLIT(8)		/* Corelle */
	}, imrmap2[][4] = {
		/*  0 */ { 1, 0, 0, 0 },	/* isp */
		/*  1 */  IRQSPLIT(8),
		/*  2 */  IRQSPLIT(10),
		/*  3 */  IRQSPLIT(12),
		/*  4 */  IRQSPLIT(14)
	};

	/*
	 * The console places the interrupt mapping in the "line" value.
	 * We trust it whenever possible.
	 */
	if (line >= 0 && line < PCI_NIRQ) {
		imrbit = line + 1;
	} else {
		if (pa->pa_bridgetag) {
			buspin = pa->pa_rawintrpin;
			bus = pa->pa_bus;
			device = pa->pa_device;
		
			if (bus == 2) {
				/*
				 * Devices behind ppb1 (pci bus #2).
				 * Those use fixed per-slot assignments.
				 */
				if (0 <= device && device <
				    sizeof imrmap2 / sizeof imrmap2[0]) {
					imrbit = imrmap2[device][buspin - 1];
				}
			} else {
				/*
				 * Devices behind further ppb.
				 * Those reuse ppb configured interrupts.
				 */
				buspin = PPB_INTERRUPT_SWIZZLE(buspin, device);
				if (pa->pa_bridgeih[buspin - 1] != 0) {
					imrbit =
					   IRQ2IMR(pa->pa_bridgeih[buspin - 1]);
				}
			}
		} else {
			pci_decompose_tag(pa->pa_pc, bustag, &bus, &device,
			    NULL);
			buspin = pa->pa_intrpin;
			if (0 <= device &&
			    device < sizeof imrmap / sizeof imrmap[0])
				imrbit = imrmap[device][buspin - 1];
		}
	}

	if (imrbit) {
		*ihp = IMR2IRQ(imrbit);
		return 0;
	}

	return 1;
}

const char *
dec_1000a_intr_string(ccv, ih)
	void *ccv;
	pci_intr_handle_t ih;
{
	static const char irqmsg_fmt[] = "dec_1000a irq %ld";
        static char irqstr[sizeof irqmsg_fmt];


        if (ih >= PCI_NIRQ)
                panic("dec_1000a_intr_string: bogus dec_1000a IRQ 0x%lx", ih);

        snprintf(irqstr, sizeof irqstr, irqmsg_fmt, ih);
        return (irqstr);
}

int
dec_1000a_intr_line(ccv, ih)
	void *ccv;
	pci_intr_handle_t ih;
{
#if NSIO > 0
	return sio_intr_line(NULL /*XXX*/, ih);
#else
	return (ih);
#endif
}

void *
dec_1000a_intr_establish(ccv, ih, level, func, arg, name)
        void *ccv;
        pci_intr_handle_t ih;
        int level;
        int (*func)(void *);
	void *arg;
	const char *name;
{           
	void *cookie;

        if (ih >= PCI_NIRQ)
                panic("dec_1000a_intr_establish: IRQ too high, 0x%lx", ih);

	cookie = alpha_shared_intr_establish(dec_1000a_pci_intr, ih, IST_LEVEL,
	    level, func, arg, name);

	if (cookie != NULL &&
	    alpha_shared_intr_firstactive(dec_1000a_pci_intr, ih)) {
		scb_set(0x900 + SCB_IDXTOVEC(ih), dec_1000a_iointr, NULL);
		dec_1000a_enable_intr(ih);

	}
	return (cookie);
}

void    
dec_1000a_intr_disestablish(ccv, cookie)
        void *ccv, *cookie;
{
	struct alpha_shared_intrhand *ih = cookie;
	unsigned int irq = ih->ih_num;
	int s;
 
	s = splhigh();

	alpha_shared_intr_disestablish(dec_1000a_pci_intr, cookie);
	if (alpha_shared_intr_isactive(dec_1000a_pci_intr, irq) == 0) {
		dec_1000a_disable_intr(irq);
		alpha_shared_intr_set_dfltsharetype(dec_1000a_pci_intr, irq,
		    IST_NONE);
		scb_free(0x900 + SCB_IDXTOVEC(irq));
	}
 
	splx(s);
}

void
dec_1000a_iointr(framep, vec)
	void *framep;
	unsigned long vec;
{
	int irq;

	irq = SCB_VECTOIDX(vec - 0x900);

	if (!alpha_shared_intr_dispatch(dec_1000a_pci_intr, irq)) {
		alpha_shared_intr_stray(dec_1000a_pci_intr, irq,
		    "dec_1000a irq");
		if (ALPHA_SHARED_INTR_DISABLE(dec_1000a_pci_intr, irq))
			dec_1000a_disable_intr(irq);
	} else
		alpha_shared_intr_reset_strays(dec_1000a_pci_intr, irq);
}

/*
 * Read and write the mystery ICU IMR registers
 */

#define	IR(h) bus_space_read_2(mystery_icu_iot, mystery_icu_ioh[h], 0)
#define	IW(h, v) bus_space_write_2(mystery_icu_iot, mystery_icu_ioh[h], 0, (v))

/*
 * Enable and disable interrupts at the ICU level
 */

void
dec_1000a_enable_intr(irq)
	int irq;
{
	int imrval = IRQ2IMR(irq);
	int i = imrval >= 16;

	IW(i, IR(i) | 1 << (imrval & 0xf));
}

void
dec_1000a_disable_intr(irq)
	int irq;
{
	int imrval = IRQ2IMR(irq);
	int i = imrval >= 16;

	IW(i, IR(i) & ~(1 << (imrval & 0xf)));
}
/*
 * Initialize mystery ICU
 */
void
pci_1000a_imi()
{
	IW(0, IR(0) & 1);
	IW(1, IR(0) & 3);
}
@


1.12
log
@Remove unused last argument of alpha_shared_intr_disestablish().
@
text
@d1 1
a1 1
/* $OpenBSD: pci_1000a.c,v 1.11 2009/08/22 02:54:50 mk Exp $ */
d149 1
a149 1
	int buspin = pa->pa_intrpin, line = pa->pa_intrline;
a179 7
	if (buspin == 0)	/* No IRQ used. */
		return 1;
	if (!(1 <= buspin && buspin <= 4))
		goto bad;

	pci_decompose_tag(pa->pa_pc, bustag, &bus, &device, NULL);

d213 3
d226 1
a226 1
bad:
@


1.11
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/* $OpenBSD: pci_1000a.c,v 1.10 2008/07/22 18:47:24 miod Exp $ */
d298 1
a298 2
	alpha_shared_intr_disestablish(dec_1000a_pci_intr, cookie,
	    "dec_1000a irq");
@


1.10
log
@Proper interrupt swizzling for devices behind bridges; matches what SRM
configures when it can. ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: pci_1000a.c,v 1.9 2008/07/22 18:45:50 miod Exp $ */
d98 1
a98 1
	    int, int (*func)(void *), void *, char *);
d269 1
a269 1
	char *name;
@


1.9
log
@Modify pci_intr_map() implementation to pass the pci_attach_args to the
per-platform implementation, instead of selected members of it; this allows
us to get rid of some globals, and paves the way for better bridge support
on some models.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_1000a.c,v 1.8 2008/07/19 19:25:18 miod Exp $ */
d150 1
a150 1
	int imrbit = 0, device;
d165 1
a165 1
		/*  8  */ { 1, 0, 0, 0 },	/* isp behind ppb */
d172 6
d185 1
a185 1
	pci_decompose_tag(pa->pa_pc, bustag, NULL, &device, NULL);
d193 31
a223 4
	} else if (0 <= device && device < sizeof imrmap / sizeof imrmap[0]) {
		if (device == 0)
			printf("dec_1000a_intr_map: ?! UNEXPECTED DEV 0\n");
		imrbit = imrmap[device][buspin - 1];
@


1.8
log
@In dec_1000a_intr_map(), use the SRM hint if available. This allows cards
plugged to the bottom 4 PCI slots of AlphaServer 1000A (attaching to pci1
behind a ppb) to get interrupts.
No regressions on AlphaServer 800 (which do not have these extra slots).
@
text
@d1 1
a1 1
/* $OpenBSD: pci_1000a.c,v 1.7 2008/06/26 05:42:09 ray Exp $ */
d76 1
d94 1
a94 2
int	dec_1000a_intr_map(void *, pcitag_t, int, int,
	    pci_intr_handle_t *);
a106 1
static pci_chipset_tag_t pc_tag;
a113 3
#if 0
	char *cp;
#endif
a117 1
	pc_tag = pc;
d144 2
a145 4
dec_1000a_intr_map(ccv, bustag, buspin, line, ihp)
	void *ccv;
	pcitag_t bustag;
	int buspin, line;
d148 2
d179 1
a179 1
	pci_decompose_tag(pc_tag, bustag, NULL, &device, NULL);
@


1.7
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pci_1000a.c,v 1.6 2008/01/09 22:23:00 kettenis Exp $ */
d155 1
a155 1
	int imrbit, device;
d183 1
d185 8
a192 1
	if (0 <= device && device < sizeof imrmap / sizeof imrmap[0]) {
d196 5
a200 4
		if (imrbit) {
			*ihp = IMR2IRQ(imrbit);
			return 0;
		}
@


1.6
log
@Make dec_xxx_intr_map() fail silently; caller will print a message if
appropriate.  Removes unwanted messages that got printed when mapping pins
on PCI-PCI bridges that don't matter.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pci_1000a.c,v 1.5 2006/06/15 20:08:29 brad Exp $ */
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.5
log
@Rework the interrupt code, shaving some cycles off in the process.
Rather than an "iointr" routine that decomposes a vector into an
IRQ, we maintain a vector table directly, hooking up each "iointr"
routine at the correct vector. This also allows us to hook device
interrupts up to specific vectors.

From thorpej NetBSD

Tested by myself and a number of end-users.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_1000a.c,v 1.4 2006/03/26 20:23:08 brad Exp $ */
d200 1
a200 1
bad:	printf("dec_1000a_intr_map: can't map dev %d pin %d\n", device, buspin);
@


1.4
log
@Replace usage of alpha_pci_decompose_tag() with pci_decompose_tag() and
remove alpha_pci_decompose_tag().

From NetBSD

ok martin@@
@
text
@d1 1
a1 1
/* $OpenBSD: pci_1000a.c,v 1.3 2006/01/29 10:47:35 martin Exp $ */
a152 1
	set_iointr(dec_1000a_iointr);
d250 2
a251 1
	    alpha_shared_intr_isactive(dec_1000a_pci_intr, ih)) {
d253 1
d274 1
d287 9
a295 21
	if (vec >= 0x900) {
		if (vec >= 0x900 + (PCI_NIRQ << 4))
			panic("dec_1000_iointr: vec 0x%lx out of range", vec);
		irq = (vec - 0x900) >> 4;

		if (!alpha_shared_intr_dispatch(dec_1000a_pci_intr, irq)) {
			alpha_shared_intr_stray(dec_1000a_pci_intr, irq,
			    "dec_1000a irq");
			if (ALPHA_SHARED_INTR_DISABLE(dec_1000a_pci_intr, irq))
				dec_1000a_disable_intr(irq);
		} else
			alpha_shared_intr_reset_strays(dec_1000a_pci_intr, irq);
		return;
	}
#if NSIO > 0 || NPCEB > 0
	if (vec >= 0x800) {
		sio_iointr(framep, vec);
		return;
	}
#endif
	panic("dec_1000a_intr: weird vec 0x%lx", vec);
@


1.3
log
@Add a alpha_shared_intr_reset_strays() function that resets the stray
interrupt counter for a given shared interrupt descriptor.
When an interrupt is successfully handled, reset the strays counter,
thus preventing a "slow leak" from eventually shutting off the interrupt
vector.

from NetBSD via KUDO Takashi
@
text
@d1 1
a1 1
/* $OpenBSD: pci_1000a.c,v 1.2 2004/06/28 02:28:42 aaron Exp $ */
d191 1
a191 1
	alpha_pci_decompose_tag(pc_tag, bustag, NULL, &device, NULL);
@


1.2
log
@Use new event counter API for interrupt counting on alpha.  By me, with some
edits by Theo.  deraadt@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: pci_1000a.c,v 1.1 2002/06/30 16:24:40 miod Exp $ */
d295 2
a296 1
		}
@


1.1
log
@AlphaServer 800 and 1000 support; from NetBSD. Tested by Tor Houghton.
Added to floppy31 still fits.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a103 3
#if 0
const struct evcnt *dec_1000a_intr_evcnt(void *, pci_intr_handle_t);
#endif
a136 3
#if 0
	pc->pc_intr_evcnt = dec_1000a_intr_evcnt;
#endif
a146 8

#if 0
		cp = alpha_shared_intr_string(dec_1000a_pci_intr, i);
		sprintf(cp, "irq %d", i);
		evcnt_attach_dynamic(alpha_shared_intr_evcnt(
		    dec_1000a_pci_intr, i), EVCNT_TYPE_INTR, NULL,
		    "dec_1000a", cp);
#endif
a231 14

#if 0
const struct evcnt *
dec_1000a_intr_evcnt(ccv, ih)
	void *ccv;
	pci_intr_handle_t ih;
{

	if (ih >= PCI_NIRQ)
		panic("dec_1000a_intr_evcnt: bogus dec_1000a IRQ 0x%lx", ih);

	return (alpha_shared_intr_evcnt(dec_1000a_pci_intr, ih));
}
#endif
@


1.1.4.1
log
@sync to -current
@
text
@@

