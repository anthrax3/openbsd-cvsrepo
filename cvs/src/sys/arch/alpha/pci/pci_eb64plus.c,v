head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.8
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.6
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.4
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.14.0.18
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.22
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.20
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.16
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.14
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.12
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.10
	OPENBSD_5_0:1.14.0.8
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.11.0.8
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.4
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.2
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.6.0.6
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.4
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	SMP:1.1.0.4
	UBC:1.1.0.2
	UBC_SYNC_B:1.4;
locks; strict;
comment	@ * @;


1.15
date	2015.07.26.05.09.44;	author miod;	state Exp;
branches;
next	1.14;
commitid	5evJqb5U3VOxLlWE;

1.14
date	2009.09.30.20.18.06;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2009.09.30.20.16.30;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.11;

1.11
date	2008.07.22.18.45.51;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.26.05.42.09;	author ray;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.15.20.08.29;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.26.20.23.08;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2006.01.29.10.47.35;	author martin;	state Exp;
branches;
next	1.6;

1.6
date	2004.06.28.02.28.43;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.10.21.11.12;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.25.21.33.21;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.03.15.50;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.14.01.26.27;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.23.03.20.41;	author ericj;	state Exp;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.1.2.1
date	2002.01.31.22.55.05;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.10.29.00.28.01;	author art;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.05.19.21.38.53;	author tedu;	state Exp;
branches;
next	;

1.1.4.1
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2003.03.27.23.18.06;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.05.13.19.41.02;	author ho;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Make sure pci_intr_map() will perform proper interrupt swizzling for devices
behind a bridge, if the SRM didn't pick an interrupt line for them.
@
text
@/* $OpenBSD: pci_eb64plus.c,v 1.14 2009/09/30 20:18:06 miod Exp $ */
/* $NetBSD: pci_eb64plus.c,v 1.10 2001/07/27 00:25:20 thorpej Exp $ */

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/time.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/syslog.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/ppbreg.h>

#include <alpha/pci/apecsreg.h>
#include <alpha/pci/apecsvar.h>

#include <alpha/pci/pci_eb64plus.h>

#include "sio.h"
#if NSIO
#include <alpha/pci/siovar.h>
#endif

int	dec_eb64plus_intr_map(struct pci_attach_args *, pci_intr_handle_t *);
const char *dec_eb64plus_intr_string(void *, pci_intr_handle_t);
void	*dec_eb64plus_intr_establish(void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, const char *);
void	dec_eb64plus_intr_disestablish(void *, void *);

#define	EB64PLUS_MAX_IRQ	32
#define	PCI_STRAY_MAX		5

struct alpha_shared_intr *eb64plus_pci_intr;

bus_space_tag_t eb64plus_intrgate_iot;
bus_space_handle_t eb64plus_intrgate_ioh;

void	eb64plus_iointr(void *arg, unsigned long vec);
extern void	eb64plus_intr_enable(int irq);  /* pci_eb64plus_intr.S */
extern void	eb64plus_intr_disable(int irq); /* pci_eb64plus_intr.S */

void
pci_eb64plus_pickintr(acp)
	struct apecs_config *acp;
{
	bus_space_tag_t iot = &acp->ac_iot;
	pci_chipset_tag_t pc = &acp->ac_pc;
	int i;

        pc->pc_intr_v = acp;
        pc->pc_intr_map = dec_eb64plus_intr_map;
        pc->pc_intr_string = dec_eb64plus_intr_string;
        pc->pc_intr_establish = dec_eb64plus_intr_establish;
        pc->pc_intr_disestablish = dec_eb64plus_intr_disestablish;

	/* Not supported on the EB64+. */
	pc->pc_pciide_compat_intr_establish = NULL;

	eb64plus_intrgate_iot = iot;
	if (bus_space_map(eb64plus_intrgate_iot, 0x804, 3, 0,
	    &eb64plus_intrgate_ioh) != 0)
		panic("pci_eb64plus_pickintr: couldn't map interrupt PLD");
	for (i = 0; i < EB64PLUS_MAX_IRQ; i++)
		eb64plus_intr_disable(i);	

	eb64plus_pci_intr = alpha_shared_intr_alloc(EB64PLUS_MAX_IRQ);
	for (i = 0; i < EB64PLUS_MAX_IRQ; i++) {
		alpha_shared_intr_set_maxstrays(eb64plus_pci_intr, i,
			PCI_STRAY_MAX);
	}

#if NSIO > 0
	sio_intr_setup(pc, iot);
#endif
}

int     
dec_eb64plus_intr_map(pa, ihp)
	struct pci_attach_args *pa;
        pci_intr_handle_t *ihp;
{
	int buspin, line = pa->pa_intrline;

	/*
	 * The console places the interrupt mapping in the "line" value.
	 * We trust it whenever possible.
	 */
	if (line >= 0 && line < EB64PLUS_MAX_IRQ) {
		*ihp = line;
		return 0;
	}

	if (pa->pa_bridgetag) {
		buspin = PPB_INTERRUPT_SWIZZLE(pa->pa_rawintrpin,
		    pa->pa_device);
		if (pa->pa_bridgeih[buspin - 1] != 0) {
			*ihp = pa->pa_bridgeih[buspin - 1];
			return 0;
		}
	}

	return 1;
}

const char *
dec_eb64plus_intr_string(acv, ih)
	void *acv;
	pci_intr_handle_t ih;
{
        static char irqstr[15];          /* 11 + 2 + NULL + sanity */

        if (ih >= EB64PLUS_MAX_IRQ)
                panic("dec_eb64plus_intr_string: bogus eb64+ IRQ 0x%lx", ih);
        snprintf(irqstr, sizeof irqstr, "eb64+ irq %ld", ih);
        return (irqstr);
}

void *
dec_eb64plus_intr_establish(acv, ih, level, func, arg, name)
        void *acv;
        pci_intr_handle_t ih;
        int level;
        int (*func)(void *);
	void *arg;
	const char *name;
{
	void *cookie;

	if (ih >= EB64PLUS_MAX_IRQ)
		panic("dec_eb64plus_intr_establish: bogus eb64+ IRQ 0x%lx",
		    ih);

	cookie = alpha_shared_intr_establish(eb64plus_pci_intr, ih, IST_LEVEL,
	    level, func, arg, name);

	if (cookie != NULL &&
	    alpha_shared_intr_firstactive(eb64plus_pci_intr, ih)) {
		scb_set(0x900 + SCB_IDXTOVEC(ih), eb64plus_iointr, NULL);
		eb64plus_intr_enable(ih);
	}
	return (cookie);
}

void
dec_eb64plus_intr_disestablish(acv, cookie)
        void *acv, *cookie;
{
	struct alpha_shared_intrhand *ih = cookie;
	unsigned int irq = ih->ih_num;
	int s;
 
	s = splhigh();

	alpha_shared_intr_disestablish(eb64plus_pci_intr, cookie);
	if (alpha_shared_intr_isactive(eb64plus_pci_intr, irq) == 0) {
		eb64plus_intr_disable(irq);
		alpha_shared_intr_set_dfltsharetype(eb64plus_pci_intr, irq,
		    IST_NONE);
		scb_free(0x900 + SCB_IDXTOVEC(irq));
	}
 
	splx(s);
}

void
eb64plus_iointr(arg, vec)
	void *arg;
	unsigned long vec;
{
	int irq; 

	irq = SCB_VECTOIDX(vec - 0x900);

	if (!alpha_shared_intr_dispatch(eb64plus_pci_intr, irq)) {
		alpha_shared_intr_stray(eb64plus_pci_intr, irq,
		    "eb64+ irq");
		if (ALPHA_SHARED_INTR_DISABLE(eb64plus_pci_intr, irq))
			eb64plus_intr_disable(irq);
	} else
		alpha_shared_intr_reset_strays(eb64plus_pci_intr, irq);
}

#if 0		/* THIS DOES NOT WORK!  see pci_eb64plus_intr.S. */
u_int8_t eb64plus_intr_mask[3] = { 0xff, 0xff, 0xff };

void
eb64plus_intr_enable(irq)
	int irq;
{
	int byte = (irq / 8), bit = (irq % 8);

#if 1
	printf("eb64plus_intr_enable: enabling %d (%d:%d)\n", irq, byte, bit);
#endif
	eb64plus_intr_mask[byte] &= ~(1 << bit);

	bus_space_write_1(eb64plus_intrgate_iot, eb64plus_intrgate_ioh, byte,
	    eb64plus_intr_mask[byte]);
}

void
eb64plus_intr_disable(irq)
	int irq;
{
	int byte = (irq / 8), bit = (irq % 8);

#if 1
	printf("eb64plus_intr_disable: disabling %d (%d:%d)\n", irq, byte, bit);
#endif
	eb64plus_intr_mask[byte] |= (1 << bit);

	bus_space_write_1(eb64plus_intrgate_iot, eb64plus_intrgate_ioh, byte,
	    eb64plus_intr_mask[byte]);
}
#endif
@


1.14
log
@Fix various off-by-ones in irq number validation.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb64plus.c,v 1.13 2009/09/30 20:16:30 miod Exp $ */
d76 1
d136 1
a136 1
#if NSIO
d146 1
a146 15
	pcitag_t bustag = pa->pa_intrtag;
	int buspin = pa->pa_intrpin, line = pa->pa_intrline;
	pci_chipset_tag_t pc = pa->pa_pc;
	int bus, device, function;

	if (buspin == 0) {
		/* No IRQ used. */
		return 1;
	}
	if (buspin > 4) {
		printf("dec_eb64plus_intr_map: bad interrupt pin %d\n", buspin);
		return 1;
	}

	pci_decompose_tag(pc, bustag, &bus, &device, &function);
d150 1
a150 1
	 * A value of (char)-1 indicates there is no mapping.
d152 3
a154 4
	if (line == 0xff) {
		printf("dec_eb64plus_intr_map: no mapping for %d/%d/%d\n",
		    bus, device, function);
		return (1);
d157 8
a164 3
	if (line >= EB64PLUS_MAX_IRQ)
		panic("dec_eb64plus_intr_map: eb64+ irq too large (%d)",
		    line);
d166 1
a166 2
	*ihp = line;
	return (0);
@


1.13
log
@Remove unused last argument of alpha_shared_intr_disestablish().
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb64plus.c,v 1.12 2009/08/22 02:54:50 mk Exp $ */
d186 1
a186 1
        if (ih > EB64PLUS_MAX_IRQ)
d203 1
a203 1
	if (ih > EB64PLUS_MAX_IRQ)
@


1.12
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb64plus.c,v 1.11 2008/07/22 18:45:51 miod Exp $ */
d228 1
a228 2
	alpha_shared_intr_disestablish(eb64plus_pci_intr, cookie,
	    "eb64+ irq");
@


1.11
log
@Modify pci_intr_map() implementation to pass the pci_attach_args to the
per-platform implementation, instead of selected members of it; this allows
us to get rid of some globals, and paves the way for better bridge support
on some models.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb64plus.c,v 1.10 2008/06/26 05:42:09 ray Exp $ */
d90 1
a90 1
	    int, int (*func)(void *), void *, char *);
d199 1
a199 1
	char *name;
@


1.10
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb64plus.c,v 1.9 2006/06/15 20:08:29 brad Exp $ */
d87 1
a87 2
int	dec_eb64plus_intr_map(void *, pcitag_t, int, int,
	    pci_intr_handle_t *);
d141 2
a142 4
dec_eb64plus_intr_map(acv, bustag, buspin, line, ihp)
	void *acv;
	pcitag_t bustag;
	int buspin, line;
d145 3
a147 2
	struct apecs_config *acp = acv;
	pci_chipset_tag_t pc = &acp->ac_pc;
@


1.9
log
@Rework the interrupt code, shaving some cycles off in the process.
Rather than an "iointr" routine that decomposes a vector into an
IRQ, we maintain a vector table directly, hooking up each "iointr"
routine at the correct vector. This also allows us to hook device
interrupts up to specific vectors.

From thorpej NetBSD

Tested by myself and a number of end-users.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb64plus.c,v 1.8 2006/03/26 20:23:08 brad Exp $ */
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.8
log
@Replace usage of alpha_pci_decompose_tag() with pci_decompose_tag() and
remove alpha_pci_decompose_tag().

From NetBSD

ok martin@@
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb64plus.c,v 1.7 2006/01/29 10:47:35 martin Exp $ */
a145 1
	set_iointr(eb64plus_iointr);
d219 3
a221 1
	if (cookie != NULL && alpha_shared_intr_isactive(eb64plus_pci_intr, ih))
d223 1
a223 1

d243 1
d250 2
a251 2
eb64plus_iointr(framep, vec)
	void *framep;
d256 9
a264 21
	if (vec >= 0x900) {
		if (vec >= 0x900 + (EB64PLUS_MAX_IRQ << 4))
			panic("eb64plus_iointr: vec 0x%lx out of range", vec);
		irq = (vec - 0x900) >> 4;

		if (!alpha_shared_intr_dispatch(eb64plus_pci_intr, irq)) {
		    alpha_shared_intr_stray(eb64plus_pci_intr, irq,
			"eb64+ irq");
			if (ALPHA_SHARED_INTR_DISABLE(eb64plus_pci_intr, irq))
				eb64plus_intr_disable(irq);
		} else
			alpha_shared_intr_reset_strays(eb64plus_pci_intr, irq);
		return;
	}
#if NSIO
	if (vec >= 0x800) {
		sio_iointr(framep, vec);
		return;
	}
#endif
	panic("eb64plus_iointr: weird vec 0x%lx", vec);
@


1.7
log
@Add a alpha_shared_intr_reset_strays() function that resets the stray
interrupt counter for a given shared interrupt descriptor.
When an interrupt is successfully handled, reset the strays counter,
thus preventing a "slow leak" from eventually shutting off the interrupt
vector.

from NetBSD via KUDO Takashi
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb64plus.c,v 1.6 2004/06/28 02:28:43 aaron Exp $ */
d169 1
a169 1
	alpha_pci_decompose_tag(pc, bustag, &bus, &device, &function);
@


1.6
log
@Use new event counter API for interrupt counting on alpha.  By me, with some
edits by Theo.  deraadt@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb64plus.c,v 1.5 2003/05/10 21:11:12 deraadt Exp $ */
d264 2
a265 1
		}
@


1.5
log
@string cleaning; ok beck dhartmei
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb64plus.c,v 1.4 2002/06/25 21:33:21 miod Exp $ */
a96 1
const struct evcnt *dec_eb64plus_intr_evcnt(void *, pci_intr_handle_t);
@


1.4
log
@No \n at the end of a panic() message... I thought all occurences had been
squashed already.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb64plus.c,v 1.3 2002/03/14 03:15:50 millert Exp $ */
d199 1
a199 1
        sprintf(irqstr, "eb64+ irq %ld", ih);
@


1.3
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb64plus.c,v 1.2 2002/03/14 01:26:27 millert Exp $ */
d183 1
a183 1
		panic("dec_eb64plus_intr_map: eb64+ irq too large (%d)\n",
d198 1
a198 1
                panic("dec_eb64plus_intr_string: bogus eb64+ IRQ 0x%lx\n", ih);
d215 1
a215 1
		panic("dec_eb64plus_intr_establish: bogus eb64+ IRQ 0x%lx\n",
d257 1
a257 1
			panic("eb64plus_iointr: vec 0x%lx out of range\n", vec);
d274 1
a274 1
	panic("eb64plus_iointr: weird vec 0x%lx\n", vec);
@


1.2
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb64plus.c,v 1.1 2002/01/23 03:20:41 ericj Exp $ */
d98 2
a99 2
void	*dec_eb64plus_intr_establish __P((void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, char *));
@


1.1
log
@
add support for AlphaPC 64.
from NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d94 4
a97 4
int	dec_eb64plus_intr_map __P((void *, pcitag_t, int, int,
	    pci_intr_handle_t *));
const char *dec_eb64plus_intr_string __P((void *, pci_intr_handle_t));
const struct evcnt *dec_eb64plus_intr_evcnt __P((void *, pci_intr_handle_t));
d100 1
a100 1
void	dec_eb64plus_intr_disestablish __P((void *, void *));
d110 3
a112 3
void	eb64plus_iointr __P((void *arg, unsigned long vec));
extern void	eb64plus_intr_enable __P((int irq));  /* pci_eb64plus_intr.S */
extern void	eb64plus_intr_disable __P((int irq)); /* pci_eb64plus_intr.S */
d208 1
a208 1
        int (*func) __P((void *));
@


1.1.4.1
log
@Merge in -current from about a week ago
@
text
@d94 7
a100 7
int	dec_eb64plus_intr_map(void *, pcitag_t, int, int,
	    pci_intr_handle_t *);
const char *dec_eb64plus_intr_string(void *, pci_intr_handle_t);
const struct evcnt *dec_eb64plus_intr_evcnt(void *, pci_intr_handle_t);
void	*dec_eb64plus_intr_establish(void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, char *);
void	dec_eb64plus_intr_disestablish(void *, void *);
d110 3
a112 3
void	eb64plus_iointr(void *arg, unsigned long vec);
extern void	eb64plus_intr_enable(int irq);  /* pci_eb64plus_intr.S */
extern void	eb64plus_intr_disable(int irq); /* pci_eb64plus_intr.S */
d208 1
a208 1
        int (*func)(void *);
@


1.1.4.2
log
@Sync the SMP branch with 3.3
@
text
@d183 1
a183 1
		panic("dec_eb64plus_intr_map: eb64+ irq too large (%d)",
d198 1
a198 1
                panic("dec_eb64plus_intr_string: bogus eb64+ IRQ 0x%lx", ih);
d215 1
a215 1
		panic("dec_eb64plus_intr_establish: bogus eb64+ IRQ 0x%lx",
d257 1
a257 1
			panic("eb64plus_iointr: vec 0x%lx out of range", vec);
d274 1
a274 1
	panic("eb64plus_iointr: weird vec 0x%lx", vec);
@


1.1.4.3
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb64plus.c,v 1.1.4.2 2003/03/27 23:18:06 niklas Exp $ */
d199 1
a199 1
        snprintf(irqstr, sizeof irqstr, "eb64+ irq %ld", ih);
@


1.1.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb64plus.c,v 1.1 2002/01/23 03:20:41 ericj Exp $ */
@


1.1.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb64plus.c,v 1.1.2.1 2002/01/31 22:55:05 niklas Exp $ */
d94 7
a100 7
int	dec_eb64plus_intr_map(void *, pcitag_t, int, int,
	    pci_intr_handle_t *);
const char *dec_eb64plus_intr_string(void *, pci_intr_handle_t);
const struct evcnt *dec_eb64plus_intr_evcnt(void *, pci_intr_handle_t);
void	*dec_eb64plus_intr_establish(void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, char *);
void	dec_eb64plus_intr_disestablish(void *, void *);
d110 3
a112 3
void	eb64plus_iointr(void *arg, unsigned long vec);
extern void	eb64plus_intr_enable(int irq);  /* pci_eb64plus_intr.S */
extern void	eb64plus_intr_disable(int irq); /* pci_eb64plus_intr.S */
d208 1
a208 1
        int (*func)(void *);
@


1.1.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb64plus.c,v 1.1.2.2 2002/06/11 03:33:40 art Exp $ */
d183 1
a183 1
		panic("dec_eb64plus_intr_map: eb64+ irq too large (%d)",
d198 1
a198 1
                panic("dec_eb64plus_intr_string: bogus eb64+ IRQ 0x%lx", ih);
d215 1
a215 1
		panic("dec_eb64plus_intr_establish: bogus eb64+ IRQ 0x%lx",
d257 1
a257 1
			panic("eb64plus_iointr: vec 0x%lx out of range", vec);
d274 1
a274 1
	panic("eb64plus_iointr: weird vec 0x%lx", vec);
@


1.1.2.4
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d199 1
a199 1
        snprintf(irqstr, sizeof irqstr, "eb64+ irq %ld", ih);
@


