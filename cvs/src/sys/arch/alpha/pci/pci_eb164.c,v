head	1.27;
access;
symbols
	OPENBSD_6_1:1.27.0.8
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.6
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.25.0.20
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.16
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.14
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.12
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.10
	OPENBSD_5_0:1.25.0.8
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.6
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.4
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.22.0.8
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.4
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.20.0.4
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.19.0.4
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.16.0.6
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.4
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.14
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.3.0.10
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.8
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.6
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.1.0.6
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.4
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.27
date	2015.07.26.05.09.44;	author miod;	state Exp;
branches;
next	1.26;
commitid	5evJqb5U3VOxLlWE;

1.26
date	2014.04.14.07.36.12;	author mpi;	state Exp;
branches;
next	1.25;

1.25
date	2009.09.30.20.18.06;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2009.09.30.20.16.30;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.22;

1.22
date	2008.07.22.18.45.51;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.26.05.42.09;	author ray;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.02.21.50.14;	author martin;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.15.20.08.29;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.26.20.23.08;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.29.10.47.35;	author martin;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.28.02.28.43;	author aaron;	state Exp;
branches;
next	1.15;

1.15
date	2003.05.10.21.11.12;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.03.15.50;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.27;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.14.00.44.59;	author nate;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.11.06.19.53.13;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.17.22.55.09;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.17.22.26.58;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.25.22.02.08;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.25.21.49.42;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.06.19.28.59;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.06.19.26.39;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.11.19.36.34;	author ericj;	state Exp;
branches;
next	1.3;

1.3
date	99.01.11.05.11.03;	author millert;	state Exp;
branches
	1.3.6.1;
next	1.2;

1.2
date	98.07.01.05.32.40;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	97.01.24.19.57.48;	author niklas;	state Exp;
branches;
next	;

1.3.6.1
date	2001.04.18.16.01.24;	author niklas;	state Exp;
branches;
next	1.3.6.2;

1.3.6.2
date	2001.07.04.10.14.44;	author niklas;	state Exp;
branches;
next	1.3.6.3;

1.3.6.3
date	2001.10.31.02.52.44;	author nate;	state Exp;
branches;
next	1.3.6.4;

1.3.6.4
date	2001.11.13.21.00.49;	author niklas;	state Exp;
branches;
next	1.3.6.5;

1.3.6.5
date	2002.03.06.00.47.44;	author niklas;	state Exp;
branches;
next	1.3.6.6;

1.3.6.6
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	1.3.6.7;

1.3.6.7
date	2003.05.13.19.41.02;	author ho;	state Exp;
branches;
next	;

1.12.2.1
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2003.05.19.21.38.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Make sure pci_intr_map() will perform proper interrupt swizzling for devices
behind a bridge, if the SRM didn't pick an interrupt line for them.
@
text
@/* $OpenBSD: pci_eb164.c,v 1.26 2014/04/14 07:36:12 mpi Exp $ */
/* $NetBSD: pci_eb164.c,v 1.27 2000/06/06 00:50:15 thorpej Exp $ */

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/time.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/syslog.h>

#include <machine/autoconf.h>
#include <machine/rpb.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/ppbreg.h>
#include <dev/pci/pciidereg.h>
#include <dev/pci/pciidevar.h>

#include <alpha/pci/ciareg.h>
#include <alpha/pci/ciavar.h>

#include <alpha/pci/pci_eb164.h>

#include "sio.h"
#if NSIO
#include <alpha/pci/siovar.h>
#endif

int	dec_eb164_intr_map(struct pci_attach_args *, pci_intr_handle_t *);
const char *dec_eb164_intr_string(void *, pci_intr_handle_t);
int	dec_eb164_intr_line(void *, pci_intr_handle_t);
void	*dec_eb164_intr_establish(void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, const char *);
void	dec_eb164_intr_disestablish(void *, void *);

void	*dec_eb164_pciide_compat_intr_establish(void *, struct device *,
	    struct pci_attach_args *, int, int (*)(void *), void *);
void    dec_eb164_pciide_compat_intr_disestablish(void *, void *);

#define	EB164_SIO_IRQ	4  
#define	EB164_MAX_IRQ	24
#define	PCI_STRAY_MAX	5

struct alpha_shared_intr *eb164_pci_intr;

bus_space_tag_t eb164_intrgate_iot;
bus_space_handle_t eb164_intrgate_ioh;

void	eb164_iointr(void *arg, unsigned long vec);
extern void	eb164_intr_enable(int irq);	/* pci_eb164_intr.S */
extern void	eb164_intr_disable(int irq);	/* pci_eb164_intr.S */

void
pci_eb164_pickintr(ccp)
	struct cia_config *ccp;
{
	bus_space_tag_t iot = &ccp->cc_iot;
	pci_chipset_tag_t pc = &ccp->cc_pc;
	int i;

        pc->pc_intr_v = ccp;
        pc->pc_intr_map = dec_eb164_intr_map;
        pc->pc_intr_string = dec_eb164_intr_string;
        pc->pc_intr_line = dec_eb164_intr_line;
        pc->pc_intr_establish = dec_eb164_intr_establish;
        pc->pc_intr_disestablish = dec_eb164_intr_disestablish;

	pc->pc_pciide_compat_intr_establish =
	    dec_eb164_pciide_compat_intr_establish;
	pc->pc_pciide_compat_intr_disestablish =
	    dec_eb164_pciide_compat_intr_disestablish;

	eb164_intrgate_iot = iot;
	if (bus_space_map(eb164_intrgate_iot, 0x804, 3, 0,
	    &eb164_intrgate_ioh) != 0)
		panic("pci_eb164_pickintr: couldn't map interrupt PLD");
	for (i = 0; i < EB164_MAX_IRQ; i++)
		eb164_intr_disable(i);	

	eb164_pci_intr = alpha_shared_intr_alloc(EB164_MAX_IRQ);
	for (i = 0; i < EB164_MAX_IRQ; i++) {
		/*
		 * Systems with a Pyxis seem to have problems with
		 * stray interrupts, so just ignore them.  Sigh,
		 * I hate buggy hardware.
		 */
		alpha_shared_intr_set_maxstrays(eb164_pci_intr, i,
			(ccp->cc_flags & CCF_ISPYXIS) ? 0 : PCI_STRAY_MAX);
	}

#if NSIO
	sio_intr_setup(pc, iot);
	eb164_intr_enable(EB164_SIO_IRQ);
#endif
}

int     
dec_eb164_intr_map(pa, ihp)
	struct pci_attach_args *pa;
        pci_intr_handle_t *ihp;
{
	int buspin, line = pa->pa_intrline;
	u_int64_t variation;

	/*
	 *
	 * The AlphaPC 164 and AlphaPC 164LX have a CMD PCI IDE controller
	 * at bus 0 device 11.  These are wired to compatibility mode,
	 * so do not map their interrupts.
	 *
	 * The AlphaPC 164SX has PCI IDE on functions 1 and 2 of the
	 * Cypress PCI-ISA bridge at bus 0 device 8.  These, too, are
	 * wired to compatibility mode.
	 *
	 * Real EB164s have ISA IDE on the Super I/O chip.
	 */
	variation = hwrpb->rpb_variation & SV_ST_MASK;
	if (pa->pa_bus == 0) {
		if (variation >= SV_ST_ALPHAPC164_366 &&
		    variation <= SV_ST_ALPHAPC164LX_600) {
			if (pa->pa_device == 8)
				panic("dec_eb164_intr_map: SIO device");
			if (pa->pa_device == 11)
				return (1);
		} else if (variation >= SV_ST_ALPHAPC164SX_400 &&
			   variation <= SV_ST_ALPHAPC164SX_600) {
			if (pa->pa_device == 8) {
				if (pa->pa_function == 0)
					panic("dec_eb164_intr_map: SIO device");
				return (1);
			}
		} else {
			if (pa->pa_device == 8)
				panic("dec_eb164_intr_map: SIO device");
		}
	}

	/*
	 * The console places the interrupt mapping in the "line" value.
	 * We trust it whenever possible.
	 */
	if (line >= 0 && line < EB164_MAX_IRQ) {
		*ihp = line;
		return 0;
	}

	if (pa->pa_bridgetag) {
		buspin = PPB_INTERRUPT_SWIZZLE(pa->pa_rawintrpin,
		    pa->pa_device);
		if (pa->pa_bridgeih[buspin - 1] != 0) {
			*ihp = pa->pa_bridgeih[buspin - 1];
			return 0;
		}
	}

	return 1;
}

const char *
dec_eb164_intr_string(ccv, ih)
	void *ccv;
	pci_intr_handle_t ih;
{
#if 0
	struct cia_config *ccp = ccv;
#endif
        static char irqstr[15];          /* 11 + 2 + NULL + sanity */

        if (ih >= EB164_MAX_IRQ)
                panic("dec_eb164_intr_string: bogus eb164 IRQ 0x%lx", ih);
        snprintf(irqstr, sizeof irqstr, "eb164 irq %ld", ih);
        return (irqstr);
}

int
dec_eb164_intr_line(ccv, ih)
	void *ccv;
	pci_intr_handle_t ih;
{
	return (ih);
}

void *
dec_eb164_intr_establish(ccv, ih, level, func, arg, name)
        void *ccv, *arg;
        pci_intr_handle_t ih;
        int level;
        int (*func)(void *);
	const char *name;
{
#if 0
	struct cia_config *ccp = ccv;
#endif
	void *cookie;

	if (ih >= EB164_MAX_IRQ)
		panic("dec_eb164_intr_establish: bogus eb164 IRQ 0x%lx", ih);

	cookie = alpha_shared_intr_establish(eb164_pci_intr, ih, IST_LEVEL,
	    level, func, arg, name);

	if (cookie != NULL &&
	    alpha_shared_intr_firstactive(eb164_pci_intr, ih)) {
		scb_set(0x900 + SCB_IDXTOVEC(ih), eb164_iointr, NULL);
		eb164_intr_enable(ih);
	}
	return (cookie);
}

void
dec_eb164_intr_disestablish(ccv, cookie)
        void *ccv, *cookie;
{
#if 0
	struct cia_config *ccp = ccv;
#endif
	struct alpha_shared_intrhand *ih = cookie;
	unsigned int irq = ih->ih_num;
	int s;
 
	s = splhigh();

	alpha_shared_intr_disestablish(eb164_pci_intr, cookie);
	if (alpha_shared_intr_isactive(eb164_pci_intr, irq) == 0) {
		eb164_intr_disable(irq);
		alpha_shared_intr_set_dfltsharetype(eb164_pci_intr, irq,
		    IST_NONE);
		scb_free(0x900 + SCB_IDXTOVEC(irq));
	}
 
	splx(s);
}

void *
dec_eb164_pciide_compat_intr_establish(v, dev, pa, chan, func, arg)
	void *v;
	struct device *dev;
	struct pci_attach_args *pa;
	int chan;
	int (*func)(void *);
	void *arg;
{
	pci_chipset_tag_t pc = pa->pa_pc;
	void *cookie = NULL;
	int bus, irq;

	pci_decompose_tag(pc, pa->pa_tag, &bus, NULL, NULL);

	/*
	 * If this isn't PCI bus #0, all bets are off.
	 */
	if (bus != 0)
		return (NULL);

	irq = PCIIDE_COMPAT_IRQ(chan);
#if NSIO
	cookie = sio_intr_establish(NULL /*XXX*/, irq, IST_EDGE, IPL_BIO,
	    func, arg, dev->dv_xname);
	if (cookie == NULL)
		return (NULL);
#endif
	return (cookie);
}

void
dec_eb164_pciide_compat_intr_disestablish(void *v, void *cookie)
{
	sio_intr_disestablish(NULL, cookie);
}

void
eb164_iointr(arg, vec)
	void *arg;
	unsigned long vec;
{
	int irq; 

	irq = SCB_VECTOIDX(vec - 0x900);

	if (!alpha_shared_intr_dispatch(eb164_pci_intr, irq)) {
		alpha_shared_intr_stray(eb164_pci_intr, irq,
		    "eb164 irq");
		if (ALPHA_SHARED_INTR_DISABLE(eb164_pci_intr, irq))
			eb164_intr_disable(irq);
	} else
		alpha_shared_intr_reset_strays(eb164_pci_intr, irq);
}

#if 0		/* THIS DOES NOT WORK!  see pci_eb164_intr.S. */
u_int8_t eb164_intr_mask[3] = { 0xff, 0xff, 0xff };

void
eb164_intr_enable(irq)
	int irq;
{
	int byte = (irq / 8), bit = (irq % 8);

#if 1
	printf("eb164_intr_enable: enabling %d (%d:%d)\n", irq, byte, bit);
#endif
	eb164_intr_mask[byte] &= ~(1 << bit);

	bus_space_write_1(eb164_intrgate_iot, eb164_intrgate_ioh, byte,
	    eb164_intr_mask[byte]);
}

void
eb164_intr_disable(irq)
	int irq;
{
	int byte = (irq / 8), bit = (irq % 8);

#if 1
	printf("eb164_intr_disable: disabling %d (%d:%d)\n", irq, byte, bit);
#endif
	eb164_intr_mask[byte] |= (1 << bit);

	bus_space_write_1(eb164_intrgate_iot, eb164_intrgate_ioh, byte,
	    eb164_intr_mask[byte]);
}
#endif
@


1.26
log
@Fewer <uvm/uvm.h>
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.25 2009/09/30 20:18:06 miod Exp $ */
d75 1
d162 1
a162 4
	pcitag_t bustag = pa->pa_intrtag;
	int buspin = pa->pa_intrpin, line = pa->pa_intrline;
	pci_chipset_tag_t pc = pa->pa_pc;
	int bus, device, function;
a164 13
	if (buspin == 0) {
		/* No IRQ used. */
		return 1;
	}
	if (buspin > 4) {
		printf("dec_eb164_intr_map: bad interrupt pin %d\n", buspin);
		return 1;
	}

	pci_decompose_tag(pc, bustag, &bus, &device, &function);

	variation = hwrpb->rpb_variation & SV_ST_MASK;

d177 2
a178 1
	if (bus == 0) {
d181 1
a181 1
			if (device == 8)
d183 1
a183 1
			if (device == 11)
d187 2
a188 2
			if (device == 8) {
				if (function == 0)
d193 1
a193 1
			if (device == 8)
d200 1
a200 1
	 * A value of (char)-1 indicates there is no mapping.
d202 3
a204 4
	if (line == 0xff) {
		printf("dec_eb164_intr_map: no mapping for %d/%d/%d\n",
		    bus, device, function);
		return (1);
d207 8
a214 3
	if (line > EB164_MAX_IRQ)
		panic("dec_eb164_intr_map: eb164 irq too large (%d)",
		    line);
d216 1
a216 2
	*ihp = line;
	return (0);
@


1.25
log
@Fix various off-by-ones in irq number validation.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.24 2009/09/30 20:16:30 miod Exp $ */
a68 2

#include <uvm/uvm.h>
@


1.24
log
@Remove unused last argument of alpha_shared_intr_disestablish().
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.23 2009/08/22 02:54:50 mk Exp $ */
d242 1
a242 1
        if (ih > EB164_MAX_IRQ)
d269 1
a269 1
	if (ih > EB164_MAX_IRQ)
@


1.23
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.22 2008/07/22 18:45:51 miod Exp $ */
d296 1
a296 2
	alpha_shared_intr_disestablish(eb164_pci_intr, cookie,
	    "eb164 irq");
@


1.22
log
@Modify pci_intr_map() implementation to pass the pci_attach_args to the
per-platform implementation, instead of selected members of it; this allows
us to get rid of some globals, and paves the way for better bridge support
on some models.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.21 2008/06/26 05:42:09 ray Exp $ */
d94 1
a94 1
	    int, int (*func)(void *), void *, char *);
d262 1
a262 1
	char *name;
@


1.21
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.20 2007/05/02 21:50:14 martin Exp $ */
d90 1
a90 2
int	dec_eb164_intr_map(void *, pcitag_t, int, int,
	    pci_intr_handle_t *);
d159 2
a160 4
dec_eb164_intr_map(ccv, bustag, buspin, line, ihp)
        void *ccv;
        pcitag_t bustag; 
        int buspin, line;
d163 3
a165 2
	struct cia_config *ccp = ccv;
	pci_chipset_tag_t pc = &ccp->cc_pc;
@


1.20
log
@supply the real devicename to sio_intr_establish() instead a generic
platform interrupt string when establishing pciide interrupts
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.19 2006/06/15 20:08:29 brad Exp $ */
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.19
log
@Rework the interrupt code, shaving some cycles off in the process.
Rather than an "iointr" routine that decomposes a vector into an
IRQ, we maintain a vector table directly, hooking up each "iointr"
routine at the correct vector. This also allows us to hook device
interrupts up to specific vectors.

From thorpej NetBSD

Tested by myself and a number of end-users.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.18 2006/03/26 20:23:08 brad Exp $ */
d341 1
a341 1
	    func, arg, "eb164 irq");
@


1.18
log
@Replace usage of alpha_pci_decompose_tag() with pci_decompose_tag() and
remove alpha_pci_decompose_tag().

From NetBSD

ok martin@@
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.17 2006/01/29 10:47:35 martin Exp $ */
d118 1
a118 1
void	eb164_iointr(void *framep, unsigned long vec);
a163 2

	set_iointr(eb164_iointr);
d284 3
a286 1
	if (cookie != NULL && alpha_shared_intr_isactive(eb164_pci_intr, ih))
d288 1
d311 1
d355 2
a356 2
eb164_iointr(framep, vec)
	void *framep;
d361 9
a369 21
	if (vec >= 0x900) {
		if (vec >= 0x900 + (EB164_MAX_IRQ << 4))
			panic("eb164_iointr: vec 0x%lx out of range", vec);
		irq = (vec - 0x900) >> 4;

		if (!alpha_shared_intr_dispatch(eb164_pci_intr, irq)) {
			alpha_shared_intr_stray(eb164_pci_intr, irq,
			    "eb164 irq");
			if (ALPHA_SHARED_INTR_DISABLE(eb164_pci_intr, irq))
				eb164_intr_disable(irq);
		} else
			alpha_shared_intr_reset_strays(eb164_pci_intr, irq);
		return;
	}
#if NSIO
	if (vec >= 0x800) {
		sio_iointr(framep, vec);
		return;
	}
#endif
	panic("eb164_iointr: weird vec 0x%lx", vec);
@


1.17
log
@Add a alpha_shared_intr_reset_strays() function that resets the stray
interrupt counter for a given shared interrupt descriptor.
When an interrupt is successfully handled, reset the strays counter,
thus preventing a "slow leak" from eventually shutting off the interrupt
vector.

from NetBSD via KUDO Takashi
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.16 2004/06/28 02:28:43 aaron Exp $ */
d189 1
a189 1
	alpha_pci_decompose_tag(pc, bustag, &bus, &device, &function);
d328 1
a328 1
	alpha_pci_decompose_tag(pc, pa->pa_tag, &bus, NULL, NULL);
@


1.16
log
@Use new event counter API for interrupt counting on alpha.  By me, with some
edits by Theo.  deraadt@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.15 2003/05/10 21:11:12 deraadt Exp $ */
d369 2
a370 1
		}
@


1.15
log
@string cleaning; ok beck dhartmei
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.14 2002/03/14 03:15:50 millert Exp $ */
a100 1
const struct evcnt *dec_eb164_intr_evcnt(void *, pci_intr_handle_t);
@


1.14
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.13 2002/03/14 01:26:27 millert Exp $ */
d256 1
a256 1
        sprintf(irqstr, "eb164 irq %ld", ih);
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.12 2001/12/14 00:44:59 nate Exp $ */
d102 2
a103 2
void	*dec_eb164_intr_establish __P((void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, char *));
d106 2
a107 2
void	*dec_eb164_pciide_compat_intr_establish __P((void *, struct device *,
	    struct pci_attach_args *, int, int (*)(void *), void *));
@


1.12
log
@Don't use a single static struct alpha_bus_space since there are machines
that can have more than one system bus attached to mainbus
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.11 2001/11/06 19:53:13 miod Exp $ */
d97 5
a101 5
int	dec_eb164_intr_map __P((void *, pcitag_t, int, int,
	    pci_intr_handle_t *));
const char *dec_eb164_intr_string __P((void *, pci_intr_handle_t));
int	dec_eb164_intr_line __P((void *, pci_intr_handle_t));
const struct evcnt *dec_eb164_intr_evcnt __P((void *, pci_intr_handle_t));
d104 1
a104 1
void	dec_eb164_intr_disestablish __P((void *, void *));
d108 1
a108 1
void    dec_eb164_pciide_compat_intr_disestablish __P((void *, void *));
d119 3
a121 3
void	eb164_iointr __P((void *framep, unsigned long vec));
extern void	eb164_intr_enable __P((int irq));	/* pci_eb164_intr.S */
extern void	eb164_intr_disable __P((int irq));	/* pci_eb164_intr.S */
d273 1
a273 1
        int (*func) __P((void *));
d322 1
a322 1
	int (*func) __P((void *));
@


1.12.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.12 2001/12/14 00:44:59 nate Exp $ */
d97 12
a108 12
int	dec_eb164_intr_map(void *, pcitag_t, int, int,
	    pci_intr_handle_t *);
const char *dec_eb164_intr_string(void *, pci_intr_handle_t);
int	dec_eb164_intr_line(void *, pci_intr_handle_t);
const struct evcnt *dec_eb164_intr_evcnt(void *, pci_intr_handle_t);
void	*dec_eb164_intr_establish(void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, char *);
void	dec_eb164_intr_disestablish(void *, void *);

void	*dec_eb164_pciide_compat_intr_establish(void *, struct device *,
	    struct pci_attach_args *, int, int (*)(void *), void *);
void    dec_eb164_pciide_compat_intr_disestablish(void *, void *);
d119 3
a121 3
void	eb164_iointr(void *framep, unsigned long vec);
extern void	eb164_intr_enable(int irq);	/* pci_eb164_intr.S */
extern void	eb164_intr_disable(int irq);	/* pci_eb164_intr.S */
d273 1
a273 1
        int (*func)(void *);
d322 1
a322 1
	int (*func)(void *);
@


1.12.2.2
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d256 1
a256 1
        snprintf(irqstr, sizeof irqstr, "eb164 irq %ld", ih);
@


1.11
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.10 2001/08/17 22:55:09 mickey Exp $ */
d127 1
a127 1
	bus_space_tag_t iot = ccp->cc_iot;
@


1.10
log
@cut and paste typos; from art@@
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.9 2001/08/17 22:26:58 mickey Exp $ */
a76 1
#include <vm/vm.h>
@


1.9
log
@provide a way to get the number used for irq line, not only a string
representation, this is needed for devices like cbb which pass
the interrupt line down to the cardbus attachment and not
getting the right line before pci_intr_map() has done it's
dirty deed.
tested on i386 by jason@@, compiles on alpha by art@@.
ppc and mveppc are to be test-compiled, but should work (;
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.8 2001/06/25 22:02:08 csapuntz Exp $ */
d262 1
a262 1
dec_eb164_intr_string(ccv, ih)
@


1.8
log
@Fix earlier commit of pciide disestablish
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.7 2001/06/25 21:49:42 csapuntz Exp $ */
d101 1
d135 1
d259 8
@


1.7
log
@

Add disestablish for pciide on Alpha
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.6 2001/02/06 19:28:59 art Exp $ */
d108 1
a108 2
void    dec_eb164_pciide_compat_intr_disestablish __P((void *,
	    pci_chipset_tag_t, void *));
d339 1
a339 2
dec_eb164_pciide_compat_intr_disestablish(void *v, pci_chipset_tag_t pc,
    void *cookie)
@


1.6
log
@Committed by accident.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.4 2000/11/11 19:36:34 ericj Exp $ */
d108 2
d140 2
d337 7
@


1.5
log
@Rename pcs_bus* to pci_swiz_bus* to reduce confusion and match NetBSD.
@
text
@d214 1
a214 2
				if (function == 1 || function == 2)
					return (1);
@


1.4
log
@pci portion of eb164 support. from NetBSD
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d214 2
a215 1
				return (1);
@


1.3
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 39
a39 2
/*	$OpenBSD: pci_eb164.c,v 1.2 1998/07/01 05:32:40 angelos Exp $	*/
/*	$NetBSD: pci_eb164.c,v 1.4 1996/11/25 03:47:05 cgd Exp $	*/
d78 1
d85 2
a92 7
#include <dev/pci/pciidereg.h>
#include <dev/pci/pciidevar.h>

#ifndef EVCNT_COUNTERS
#include <machine/intrcnt.h>
#endif

d101 1
d103 1
a103 1
	    int, int (*)(void *), void *, char *));
d106 3
a108 3
void    *dec_eb164_pciide_compat_intr_establish __P((void *, struct device *,
            struct pci_attach_args *, int, int (*)(void *), void *));
 
a113 3
#ifdef EVCNT_COUNTERS
struct evcnt eb164_intr_evcnt;
#endif
d136 2
a137 2
        pc->pc_pciide_compat_intr_establish =
            dec_eb164_pciide_compat_intr_establish;
d147 6
a152 1
	for (i = 0; i < EB164_MAX_IRQ; i++)
d154 2
a155 1
			PCI_STRAY_MAX);
d177 8
a184 8
        if (buspin == 0) {
                /* No IRQ used. */
                return 1;
        }
        if (buspin > 4) {
                printf("dec_eb164_intr_map: bad interrupt pin %d\n", buspin);
                return 1;
        }
d190 42
a231 42
        /*
         *
         * The AlphaPC 164 and AlphaPC 164LX have a CMD PCI IDE controller
         * at bus 0 device 11.  These are wired to compatibility mode,
         * so do not map their interrupts.
         * 
         * The AlphaPC 164SX has PCI IDE on functions 1 and 2 of the
         * Cypress PCI-ISA bridge at bus 0 device 8.  These, too, are
         * wired to compatibility mode.
         * 
         * Real EB164s have ISA IDE on the Super I/O chip.
         */
        if (bus == 0) {
                if (variation >= SV_ST_ALPHAPC164_366 &&
                    variation <= SV_ST_ALPHAPC164LX_600) {
                        if (device == 8)
                                panic("dec_eb164_intr_map: SIO device");
                        if (device == 11)
                                return (1);
                } else if (variation >= SV_ST_ALPHAPC164SX_400 &&
                           variation <= SV_ST_ALPHAPC164SX_600) {
                        if (device == 8) {
                                if (function == 0)
                                        panic("dec_eb164_intr_map: SIO device");
                                return (1);
                        }
                } else { 
                        if (device == 8)
                                panic("dec_eb164_intr_map: SIO device");
                }
        }

        /*
         * The console places the interrupt mapping in the "line" value.
         * A value of (char)-1 indicates there is no mapping.
         */
        if (line == 0xff) {
                printf("dec_eb164_intr_map: no mapping for %d/%d/%d\n",
                    bus, device, function);
                return (1);
        }
         
d233 1
a233 1
		panic("dec_eb164_map_int: eb164_irq too large (%d)",
d251 2
a252 2
                panic("dec_eb164_intr_string: bogus eb164 IRQ 0x%x", ih);
        sprintf(irqstr, "eb164 irq %d", ih);
d264 3
d270 1
a270 1
		panic("dec_eb164_intr_establish: bogus eb164 IRQ 0x%x", ih);
d287 5
d293 9
a301 1
	panic("dec_eb164_intr_disestablish not implemented"); /* XXX */
d304 1
a304 1
void *      
d306 20
a325 20
        void *v;
        struct device *dev;
        struct pci_attach_args *pa;
        int chan;
        int (*func) __P((void *));
        void *arg;
{       
        pci_chipset_tag_t pc = pa->pa_pc;
        void *cookie = NULL;
        int bus, irq;
            
        alpha_pci_decompose_tag(pc, pa->pa_tag, &bus, NULL, NULL);
        
        /*
         * If this isn't PCI bus #0, all bets are off.
         */
        if (bus != 0)
                return (NULL);
                
        irq = PCIIDE_COMPAT_IRQ(chan);
d327 4
a330 2
        cookie = sio_intr_establish(NULL /*XXX*/, irq, IST_EDGE, IPL_BIO,
            func, arg, "eb164 irq");
d332 1
a332 1
        return (cookie);
d344 1
a344 1
			panic("eb164_iointr: vec 0x%x out of range", vec);
a346 8
#ifdef EVCNT_COUNTERS
		eb164_intr_evcnt.ev_count++;
#else
		if (EB164_MAX_IRQ != INTRCNT_EB164_IRQ_LEN)
			panic("eb164 interrupt counter sizes inconsistent");
		intrcnt[INTRCNT_EB164_IRQ + irq]++;
#endif

d350 1
a350 3
			if (eb164_pci_intr[irq].intr_nstrays ==
			    eb164_pci_intr[irq].intr_maxstrays
			    && TAILQ_FIRST(&eb164_pci_intr[irq].intr_q) == NULL)
d361 1
a361 1
	panic("eb164_iointr: weird vec 0x%x", vec);
@


1.3.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 39
/* $OpenBSD: pci_eb164.c,v 1.6 2001/02/06 19:28:59 art Exp $ */
/* $NetBSD: pci_eb164.c,v 1.27 2000/06/06 00:50:15 thorpej Exp $ */

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
a40 1
#include <uvm/uvm.h>
a46 2
#include <dev/pci/pciidereg.h>
#include <dev/pci/pciidevar.h>
d53 7
a67 1
const struct evcnt *dec_eb164_intr_evcnt __P((void *, pci_intr_handle_t));
d69 1
a69 1
	    int, int (*func)(void *), void *, char *));
d72 3
a74 3
void	*dec_eb164_pciide_compat_intr_establish __P((void *, struct device *,
	    struct pci_attach_args *, int, int (*)(void *), void *));

d80 3
d105 2
a106 2
	pc->pc_pciide_compat_intr_establish =
	    dec_eb164_pciide_compat_intr_establish;
d116 1
a116 6
	for (i = 0; i < EB164_MAX_IRQ; i++) {
		/*
		 * Systems with a Pyxis seem to have problems with
		 * stray interrupts, so just ignore them.  Sigh,
		 * I hate buggy hardware.
		 */
d118 1
a118 2
			(ccp->cc_flags & CCF_ISPYXIS) ? 0 : PCI_STRAY_MAX);
	}
d140 8
a147 8
	if (buspin == 0) {
		/* No IRQ used. */
		return 1;
	}
	if (buspin > 4) {
		printf("dec_eb164_intr_map: bad interrupt pin %d\n", buspin);
		return 1;
	}
d153 42
a194 42
	/*
	 *
	 * The AlphaPC 164 and AlphaPC 164LX have a CMD PCI IDE controller
	 * at bus 0 device 11.  These are wired to compatibility mode,
	 * so do not map their interrupts.
	 *
	 * The AlphaPC 164SX has PCI IDE on functions 1 and 2 of the
	 * Cypress PCI-ISA bridge at bus 0 device 8.  These, too, are
	 * wired to compatibility mode.
	 *
	 * Real EB164s have ISA IDE on the Super I/O chip.
	 */
	if (bus == 0) {
		if (variation >= SV_ST_ALPHAPC164_366 &&
		    variation <= SV_ST_ALPHAPC164LX_600) {
			if (device == 8)
				panic("dec_eb164_intr_map: SIO device");
			if (device == 11)
				return (1);
		} else if (variation >= SV_ST_ALPHAPC164SX_400 &&
			   variation <= SV_ST_ALPHAPC164SX_600) {
			if (device == 8) {
				if (function == 0)
					panic("dec_eb164_intr_map: SIO device");
				return (1);
			}
		} else {
			if (device == 8)
				panic("dec_eb164_intr_map: SIO device");
		}
	}

	/*
	 * The console places the interrupt mapping in the "line" value.
	 * A value of (char)-1 indicates there is no mapping.
	 */
	if (line == 0xff) {
		printf("dec_eb164_intr_map: no mapping for %d/%d/%d\n",
		    bus, device, function);
		return (1);
	}

d196 1
a196 1
		panic("dec_eb164_intr_map: eb164 irq too large (%d)",
d214 2
a215 2
                panic("dec_eb164_intr_string: bogus eb164 IRQ 0x%lx", ih);
        sprintf(irqstr, "eb164 irq %ld", ih);
a226 3
#if 0
	struct cia_config *ccp = ccv;
#endif
d230 1
a230 1
		panic("dec_eb164_intr_establish: bogus eb164 IRQ 0x%lx", ih);
a246 5
	struct alpha_shared_intrhand *ih = cookie;
	unsigned int irq = ih->ih_num;
	int s;
 
	s = splhigh();
d248 1
a248 9
	alpha_shared_intr_disestablish(eb164_pci_intr, cookie,
	    "eb164 irq");
	if (alpha_shared_intr_isactive(eb164_pci_intr, irq) == 0) {
		eb164_intr_disable(irq);
		alpha_shared_intr_set_dfltsharetype(eb164_pci_intr, irq,
		    IST_NONE);
	}
 
	splx(s);
d251 1
a251 1
void *
d253 20
a272 20
	void *v;
	struct device *dev;
	struct pci_attach_args *pa;
	int chan;
	int (*func) __P((void *));
	void *arg;
{
	pci_chipset_tag_t pc = pa->pa_pc;
	void *cookie = NULL;
	int bus, irq;

	alpha_pci_decompose_tag(pc, pa->pa_tag, &bus, NULL, NULL);

	/*
	 * If this isn't PCI bus #0, all bets are off.
	 */
	if (bus != 0)
		return (NULL);

	irq = PCIIDE_COMPAT_IRQ(chan);
d274 2
a275 4
	cookie = sio_intr_establish(NULL /*XXX*/, irq, IST_EDGE, IPL_BIO,
	    func, arg, "eb164 irq");
	if (cookie == NULL)
		return (NULL);
d277 1
a277 1
	return (cookie);
d289 1
a289 1
			panic("eb164_iointr: vec 0x%lx out of range", vec);
d292 8
d303 3
a305 1
			if (ALPHA_SHARED_INTR_DISABLE(eb164_pci_intr, irq))
d316 1
a316 1
	panic("eb164_iointr: weird vec 0x%lx", vec);
@


1.3.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.3.6.1 2001/04/18 16:01:24 niklas Exp $ */
a107 1
void    dec_eb164_pciide_compat_intr_disestablish __P((void *, void *));
a137 2
	pc->pc_pciide_compat_intr_disestablish =
	    dec_eb164_pciide_compat_intr_disestablish;
a332 6
}

void
dec_eb164_pciide_compat_intr_disestablish(void *v, void *cookie)
{
	sio_intr_disestablish(NULL, cookie);
@


1.3.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.3.6.2 2001/07/04 10:14:44 niklas Exp $ */
a100 1
int	dec_eb164_intr_line __P((void *, pci_intr_handle_t));
a133 1
        pc->pc_intr_line = dec_eb164_intr_line;
a256 8
}

int
dec_eb164_intr_line(ccv, ih)
	void *ccv;
	pci_intr_handle_t ih;
{
	return (ih);
@


1.3.6.4
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d77 1
@


1.3.6.5
log
@Merge in trunk
@
text
@d127 1
a127 1
	bus_space_tag_t iot = &ccp->cc_iot;
@


1.3.6.6
log
@Merge in -current from about a week ago
@
text
@d97 12
a108 12
int	dec_eb164_intr_map(void *, pcitag_t, int, int,
	    pci_intr_handle_t *);
const char *dec_eb164_intr_string(void *, pci_intr_handle_t);
int	dec_eb164_intr_line(void *, pci_intr_handle_t);
const struct evcnt *dec_eb164_intr_evcnt(void *, pci_intr_handle_t);
void	*dec_eb164_intr_establish(void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, char *);
void	dec_eb164_intr_disestablish(void *, void *);

void	*dec_eb164_pciide_compat_intr_establish(void *, struct device *,
	    struct pci_attach_args *, int, int (*)(void *), void *);
void    dec_eb164_pciide_compat_intr_disestablish(void *, void *);
d119 3
a121 3
void	eb164_iointr(void *framep, unsigned long vec);
extern void	eb164_intr_enable(int irq);	/* pci_eb164_intr.S */
extern void	eb164_intr_disable(int irq);	/* pci_eb164_intr.S */
d273 1
a273 1
        int (*func)(void *);
d322 1
a322 1
	int (*func)(void *);
@


1.3.6.7
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_eb164.c,v 1.3.6.6 2002/03/28 10:06:13 niklas Exp $ */
d256 1
a256 1
        snprintf(irqstr, sizeof irqstr, "eb164 irq %ld", ih);
@


1.2
log
@First shot for EB164SX/LX support; kernels for those should be much
more stable now, but by no means production-strong. A lot of code from
NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_eb164.c,v 1.1 1997/01/24 19:57:48 niklas Exp $	*/
d196 1
a196 1
		panic("dec_eb164_map_int: eb164_irq too large (%d)\n",
d214 1
a214 1
                panic("dec_eb164_intr_string: bogus eb164 IRQ 0x%x\n", ih);
d230 1
a230 1
		panic("dec_eb164_intr_establish: bogus eb164 IRQ 0x%x\n", ih);
d289 1
a289 1
			panic("eb164_iointr: vec 0x%x out of range\n", vec);
d316 1
a316 1
	panic("eb164_iointr: weird vec 0x%x\n", vec);
@


1.1
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_eb164.c,v 1.4 1996/11/25 03:47:05 cgd Exp $	*/
d43 1
d53 3
d72 3
d105 3
d121 1
a121 1
	sio_intr_setup(iot);
d137 2
a138 2
	int device;
	int eb164_irq, pinbase, pinoff;
d145 1
a145 1
                printf("pci_map_int: bad interrupt pin %d\n", buspin);
d149 35
a183 7
	pci_decompose_tag(pc, bustag, NULL, &device, NULL);
	switch (device) {
#if 0	/* THIS CODE SHOULD NEVER BE CALLED FOR THE SIO */
	case 8: 					/* SIO */
		eb164_irq = 4;
		break;
#endif
d185 13
a197 47
	case 11:
		eb164_irq = 5;				/* IDE */
		break;

	case 5:
	case 6:
	case 7:
	case 9:
		switch (buspin) {
		case 1:
			pinbase = 0;
			break;
		case 2:
		case 3:
		case 4:
			pinbase = (buspin * 4) - 1;
			break;
#ifdef DIAGNOSTIC
		default:
			panic("dec_eb164_intr_map: slot buspin switch");
#endif
		};
		switch (device) {
		case 5:
			pinoff = 2;
			break;

		case 6:
		case 7:
		case 9:
			pinoff = device - 6;
			break;
#ifdef DIAGNOSTIC
		default:
			panic("dec_eb164_intr_map: slot device switch");
#endif
		}
		eb164_irq = pinoff + pinbase;
		break;
	default:
		panic("pci_eb164_map_int: invalid device number %d\n",
		    device);
	}

	if (eb164_irq > EB164_MAX_IRQ)
		panic("pci_eb164_map_int: eb164_irq too large (%d)\n",
		    eb164_irq);
d199 1
a199 1
	*ihp = eb164_irq;
d251 29
d304 2
a305 1
			    eb164_pci_intr[irq].intr_maxstrays)
@

