head	1.23;
access;
symbols
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.6
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.4
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.22.0.16
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.20
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.18
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.14
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.12
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.10
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.8
	OPENBSD_5_0:1.22.0.6
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.4
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.19.0.8
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.4
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.17.0.4
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.16.0.4
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.10
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.23
date	2015.07.26.05.09.44;	author miod;	state Exp;
branches;
next	1.22;
commitid	5evJqb5U3VOxLlWE;

1.22
date	2010.08.07.03.50.01;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2009.09.30.20.16.30;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.19;

1.19
date	2008.07.22.18.45.51;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2008.06.26.05.42.09;	author ray;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.02.21.50.14;	author martin;	state Exp;
branches;
next	1.16;

1.16
date	2006.06.15.20.08.29;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.26.20.23.08;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.29.10.47.35;	author martin;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.24.14.21.29;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.28.02.28.43;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.11.19.41.09;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.25.21.33.21;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.03.15.50;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.27;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.12.14.00.44.59;	author nate;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.11.06.19.53.13;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.17.22.26.58;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.25.22.02.07;	author csapuntz;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.25.21.49.41;	author csapuntz;	state Exp;
branches;
next	1.2;

1.2
date	2000.11.08.20.59.25;	author ericj;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.11.08.16.01.19;	author art;	state Exp;
branches;
next	;

1.2.2.1
date	2001.04.18.16.01.21;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2001.07.04.10.14.42;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2001.10.31.02.52.44;	author nate;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2001.11.13.21.00.49;	author niklas;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2002.03.06.00.47.44;	author niklas;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	1.2.2.7;

1.2.2.7
date	2003.03.27.23.18.06;	author niklas;	state Exp;
branches;
next	1.2.2.8;

1.2.2.8
date	2003.05.13.19.41.02;	author ho;	state Exp;
branches;
next	;

1.7.2.1
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.10.29.00.28.01;	author art;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2003.05.19.21.38.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Make sure pci_intr_map() will perform proper interrupt swizzling for devices
behind a bridge, if the SRM didn't pick an interrupt line for them.
@
text
@/* $OpenBSD: pci_550.c,v 1.22 2010/08/07 03:50:01 krw Exp $ */
/* $NetBSD: pci_550.c,v 1.18 2000/06/29 08:58:48 mrg Exp $ */

/*-
 * Copyright (c) 1998, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center, and by Andrew Gallatin.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/time.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/syslog.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/rpb.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/ppbreg.h>
#include <dev/pci/pciidereg.h>
#include <dev/pci/pciidevar.h>

#include <alpha/pci/ciareg.h>
#include <alpha/pci/ciavar.h>

#include <alpha/pci/pci_550.h>

#include "sio.h"
#if NSIO
#include <alpha/pci/siovar.h>
#endif

int	dec_550_intr_map(struct pci_attach_args *, pci_intr_handle_t *);
const char *dec_550_intr_string(void *, pci_intr_handle_t);
int	dec_550_intr_line(void *, pci_intr_handle_t);
void	*dec_550_intr_establish(void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, const char *);
void	dec_550_intr_disestablish(void *, void *);

void	*dec_550_pciide_compat_intr_establish(void *, struct device *,
	    struct pci_attach_args *, int, int (*)(void *), void *);
void    dec_550_pciide_compat_intr_disestablish(void *, void *);

#define	DEC_550_PCI_IRQ_BEGIN	8
#define	DEC_550_MAX_IRQ		(64 - DEC_550_PCI_IRQ_BEGIN)

/*
 * The Miata has a Pyxis, which seems to have problems with stray
 * interrupts.  Work around this by just ignoring strays.
 */
#define	PCI_STRAY_MAX		0

/*
 * Some Miata models, notably models with a Cypress PCI-ISA bridge, have
 * a PCI device (the OHCI USB controller) with interrupts tied to ISA IRQ
 * lines.  This IRQ is encoded as: line = FLAG | isa_irq. Usually FLAG
 * is 0xe0, however it can be 0xf0.  We don't allow 0xf0 | irq15.
 */
#define	DEC_550_LINE_IS_ISA(line)	((line) >= 0xe0 && (line) <= 0xfe)
#define	DEC_550_LINE_ISA_IRQ(line)	((line) & 0x0f)

struct alpha_shared_intr *dec_550_pci_intr;

void	dec_550_iointr(void *arg, unsigned long vec);
void	dec_550_intr_enable(int irq);
void	dec_550_intr_disable(int irq);

void
pci_550_pickintr(ccp)
	struct cia_config *ccp;
{
	bus_space_tag_t iot = &ccp->cc_iot;
	pci_chipset_tag_t pc = &ccp->cc_pc;
#if 0
	char *cp;
#endif
	int i;

        pc->pc_intr_v = ccp;
        pc->pc_intr_map = dec_550_intr_map;
        pc->pc_intr_string = dec_550_intr_string;
        pc->pc_intr_line = dec_550_intr_line;
        pc->pc_intr_establish = dec_550_intr_establish;
        pc->pc_intr_disestablish = dec_550_intr_disestablish;

	pc->pc_pciide_compat_intr_establish =
	    dec_550_pciide_compat_intr_establish;
	pc->pc_pciide_compat_intr_disestablish =
	    dec_550_pciide_compat_intr_disestablish;

	/*
	 * DEC 550's interrupts are enabled via the Pyxis interrupt
	 * mask register.  Nothing to map.
	 */

	for (i = 0; i < DEC_550_MAX_IRQ; i++)
		dec_550_intr_disable(i);

	dec_550_pci_intr = alpha_shared_intr_alloc(DEC_550_MAX_IRQ);
	for (i = 0; i < DEC_550_MAX_IRQ; i++) {
		alpha_shared_intr_set_maxstrays(dec_550_pci_intr, i,
		    PCI_STRAY_MAX);
		alpha_shared_intr_set_private(dec_550_pci_intr, i, ccp);
	}

#if NSIO
	sio_intr_setup(pc, iot);
#endif
}

int     
dec_550_intr_map(pa, ihp)
	struct pci_attach_args *pa;
        pci_intr_handle_t *ihp;
{
	int buspin, line = pa->pa_intrline;

	/*
	 * There are two main variants of Miata: Miata 1 (Intel SIO)
	 * and Miata {1.5,2} (Cypress).
	 *
	 * The Miata 1 has a CMD PCI IDE wired to compatibility mode at
	 * device 4 of bus 0.  This variant apparently also has the
	 * Pyxis DMA bug.
	 *
	 * On the Miata 1.5 and Miata 2, the Cypress PCI-ISA bridge lives
	 * on device 7 of bus 0.  This device has PCI IDE wired to
	 * compatibility mode on functions 1 and 2.
	 *
	 * There will be no interrupt mapping for these devices, so just
	 * bail out now.
	 */
	if (pa->pa_bus == 0) {
		if ((hwrpb->rpb_variation & SV_ST_MASK) < SV_ST_MIATA_1_5) {
			/* Miata 1 */
			if (pa->pa_device == 7)
				panic("dec_550_intr_map: SIO device");
			else if (pa->pa_device == 4)
				return (1);
		} else {
			/* Miata 1.5 or Miata 2 */
			if (pa->pa_device == 7) {
				if (pa->pa_function == 0)
					panic("dec_550_intr_map: SIO device");
				if (pa->pa_function == 1 ||
				    pa->pa_function == 2)
					return (1);
			}
		}
	}

	/*
	 * The console places the interrupt mapping in the "line" value.
	 * We trust it whenever possible.
	 */
	if (line >= 0 && line < DEC_550_MAX_IRQ) {
		*ihp = line;
		return 0;
	}
	if (DEC_550_LINE_IS_ISA(line)) {
#if NSIO > 0
		*ihp = line;
		return 0;
#else
		printf("dec_550_intr_map: ISA IRQ %d for %d/%d/%d\n",
		    DEC_550_LINE_ISA_IRQ(line),
		    pa->pa_bus, pa->pa_device, pa->pa_function);
		return 1;
#endif
	}

	if (pa->pa_bridgetag) {
		buspin = PPB_INTERRUPT_SWIZZLE(pa->pa_rawintrpin,
		    pa->pa_device);
		if (pa->pa_bridgeih[buspin - 1] != 0) {
			*ihp = pa->pa_bridgeih[buspin - 1];
			return 0;
		}
	}

	return 1;
}

const char *
dec_550_intr_string(ccv, ih)
	void *ccv;
	pci_intr_handle_t ih;
{
#if 0
	struct cia_config *ccp = ccv;
#endif
	static char irqstr[16];		/* 12 + 2 + NULL + sanity */

#if NSIO
	if (DEC_550_LINE_IS_ISA(ih))
		return (sio_intr_string(NULL /*XXX*/,
		    DEC_550_LINE_ISA_IRQ(ih)));
#endif

	if (ih >= DEC_550_MAX_IRQ)
		panic("dec_550_intr_string: bogus 550 IRQ 0x%lx", ih);
	snprintf(irqstr, sizeof irqstr, "dec 550 irq %ld", ih);
	return (irqstr);
}

int
dec_550_intr_line(ccv, ih)
	void *ccv;
	pci_intr_handle_t ih;
{
#if NSIO
	if (DEC_550_LINE_IS_ISA(ih))
		return (sio_intr_line(NULL /*XXX*/, DEC_550_LINE_ISA_IRQ(ih)));
#endif

	return (ih);
}

void *
dec_550_intr_establish(ccv, ih, level, func, arg, name)
	void *ccv, *arg;
	pci_intr_handle_t ih;
	int level;
	int (*func)(void *);
	const char *name;
{
#if 0
	struct cia_config *ccp = ccv;
#endif
	void *cookie;

#if NSIO
	if (DEC_550_LINE_IS_ISA(ih))
		return (sio_intr_establish(NULL /*XXX*/,
		    DEC_550_LINE_ISA_IRQ(ih), IST_LEVEL, level, func, arg,
		    name));
#endif

	if (ih >= DEC_550_MAX_IRQ)
		panic("dec_550_intr_establish: bogus dec 550 IRQ 0x%lx", ih);

	cookie = alpha_shared_intr_establish(dec_550_pci_intr, ih, IST_LEVEL,
	    level, func, arg, name);

	if (cookie != NULL &&
	    alpha_shared_intr_firstactive(dec_550_pci_intr, ih)) {
		scb_set(0x900 + SCB_IDXTOVEC(ih), dec_550_iointr, NULL);
		dec_550_intr_enable(ih);
	}
	return (cookie);
}

void
dec_550_intr_disestablish(ccv, cookie)
        void *ccv, *cookie;
{
	struct cia_config *ccp = ccv;
	struct alpha_shared_intrhand *ih = cookie;
	unsigned int irq = ih->ih_num;
	int s;

#if NSIO
	/*
	 * We have to determine if this is an ISA IRQ or not!  We do this
	 * by checking to see if the intrhand points back to an intrhead
	 * that points to our cia_config.  If not, it's an ISA IRQ.  Pretty
	 * disgusting, eh?
	 */
	if (ih->ih_intrhead->intr_private != ccp) {
		sio_intr_disestablish(NULL /*XXX*/, cookie);
		return;
	}
#endif
 
	s = splhigh();

	alpha_shared_intr_disestablish(dec_550_pci_intr, cookie);
	if (alpha_shared_intr_isactive(dec_550_pci_intr, irq) == 0) {
		dec_550_intr_disable(irq);
		alpha_shared_intr_set_dfltsharetype(dec_550_pci_intr, irq,
		    IST_NONE);
		scb_free(0x900 + SCB_IDXTOVEC(irq));
	}
 
	splx(s);
}

void *
dec_550_pciide_compat_intr_establish(v, dev, pa, chan, func, arg)
	void *v;
	struct device *dev;
	struct pci_attach_args *pa;
	int chan;
	int (*func)(void *);
	void *arg;
{
	pci_chipset_tag_t pc = pa->pa_pc;
	void *cookie = NULL;
	int bus, irq;

	pci_decompose_tag(pc, pa->pa_tag, &bus, NULL, NULL);

	/*
	 * If this isn't PCI bus #0, all bets are off.
	 */
	if (bus != 0)
		return (NULL);

	irq = PCIIDE_COMPAT_IRQ(chan);
#if NSIO
	cookie = sio_intr_establish(NULL /*XXX*/, irq, IST_EDGE, IPL_BIO,
	    func, arg, dev->dv_xname);
#endif
	return (cookie);
}

void
dec_550_pciide_compat_intr_disestablish(v, cookie)
	void *v;
	void *cookie;
{
	sio_intr_disestablish(NULL, cookie);
}

void
dec_550_iointr(arg, vec)
	void *arg;
	unsigned long vec;
{
	int irq; 

	irq = SCB_VECTOIDX(vec - 0x900);

	if (irq >= DEC_550_MAX_IRQ)
		panic("550_iointr: vec 0x%lx out of range", vec);

	if (!alpha_shared_intr_dispatch(dec_550_pci_intr, irq)) {
		alpha_shared_intr_stray(dec_550_pci_intr, irq,
		    "dec 550 irq");
		if (ALPHA_SHARED_INTR_DISABLE(dec_550_pci_intr, irq))
			dec_550_intr_disable(irq);
	} else
		alpha_shared_intr_reset_strays(dec_550_pci_intr, irq);
}

void
dec_550_intr_enable(irq)
	int irq;
{

	cia_pyxis_intr_enable(irq + DEC_550_PCI_IRQ_BEGIN, 1);
}

void
dec_550_intr_disable(irq)
	int irq;
{

	cia_pyxis_intr_enable(irq + DEC_550_PCI_IRQ_BEGIN, 0);
}
@


1.22
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.21 2009/09/30 20:16:30 miod Exp $ */
d77 1
d174 1
a174 15
	pcitag_t bustag = pa->pa_intrtag;
	int buspin = pa->pa_intrpin, line = pa->pa_intrline;
	pci_chipset_tag_t pc = pa->pa_pc;
	int bus, device, function;

	if (buspin == 0) {
		/* No IRQ used. */
		return 1;
	}
	if (buspin > 4) {
		printf("dec_550_intr_map: bad interrupt pin %d\n", buspin);
		return 1;
	}

	pci_decompose_tag(pc, bustag, &bus, &device, &function);
d191 1
a191 1
	if (bus == 0) {
d194 1
a194 1
			if (device == 7)
d196 1
a196 1
			else if (device == 4)
d200 2
a201 2
			if (device == 7) {
				if (function == 0)
d203 2
a204 1
				if (function == 1 || function == 2)
d212 1
a212 1
	 * A value of (char)-1 indicates there is no mapping.
d214 3
a216 4
	if (line == 0xff) {
		printf("dec_550_intr_map: no mapping for %d/%d/%d\n",
		    bus, device, function);
		return (1);
a217 2

#if NSIO == 0
d219 4
d224 4
a227 2
		    DEC_550_LINE_ISA_IRQ(line), bus, device, function);
		return (1);
a228 1
#endif
d230 7
a236 4
	if (DEC_550_LINE_IS_ISA(line) == 0 && line >= DEC_550_MAX_IRQ) {
		printf("dec_550_intr_map: dec 550 irq too large (%d)",
		    line);
		return (1);
d239 1
a239 2
	*ihp = line;
	return (0);
@


1.21
log
@Remove unused last argument of alpha_shared_intr_disestablish().
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.20 2009/08/22 02:54:50 mk Exp $ */
d401 1
a401 1
		panic("550_iointr: vec 0x%lx out of range\n", vec);
@


1.20
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.19 2008/07/22 18:45:51 miod Exp $ */
d343 1
a343 2
	alpha_shared_intr_disestablish(dec_550_pci_intr, cookie,
	    "dec 550 irq");
@


1.19
log
@Modify pci_intr_map() implementation to pass the pci_attach_args to the
per-platform implementation, instead of selected members of it; this allows
us to get rid of some globals, and paves the way for better bridge support
on some models.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.18 2008/06/26 05:42:09 ray Exp $ */
d94 1
a94 1
	    int, int (*func)(void *), void *, char *);
d291 1
a291 1
	char *name;
@


1.18
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.17 2007/05/02 21:50:14 martin Exp $ */
d90 1
a90 2
int	dec_550_intr_map(void *, pcitag_t, int, int,
	    pci_intr_handle_t *);
d169 2
a170 4
dec_550_intr_map(ccv, bustag, buspin, line, ihp)
        void *ccv;
        pcitag_t bustag; 
        int buspin, line;
d173 3
a175 2
	struct cia_config *ccp = ccv;
	pci_chipset_tag_t pc = &ccp->cc_pc;
@


1.17
log
@supply the real devicename to sio_intr_establish() instead a generic
platform interrupt string when establishing pciide interrupts
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.16 2006/06/15 20:08:29 brad Exp $ */
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.16
log
@Rework the interrupt code, shaving some cycles off in the process.
Rather than an "iointr" routine that decomposes a vector into an
IRQ, we maintain a vector table directly, hooking up each "iointr"
routine at the correct vector. This also allows us to hook device
interrupts up to specific vectors.

From thorpej NetBSD

Tested by myself and a number of end-users.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.15 2006/03/26 20:23:08 brad Exp $ */
d388 1
a388 1
	    func, arg, "dec 550 irq");
@


1.15
log
@Replace usage of alpha_pci_decompose_tag() with pci_decompose_tag() and
remove alpha_pci_decompose_tag().

From NetBSD

ok martin@@
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.14 2006/01/29 10:47:35 martin Exp $ */
d129 1
a129 1
void	dec_550_iointr(void *framep, unsigned long vec);
a173 2

	set_iointr(dec_550_iointr);
d320 3
a322 1
	if (cookie != NULL && alpha_shared_intr_isactive(dec_550_pci_intr, ih))
d324 1
d358 1
d402 2
a403 2
dec_550_iointr(framep, vec)
	void *framep;
d408 1
a408 2
	if (vec >= 0x900) {
		irq = ((vec - 0x900) >> 4);
d410 2
a411 2
		if (irq >= DEC_550_MAX_IRQ)
			panic("550_iointr: vec 0x%lx out of range", vec);
d413 7
a419 16
		if (!alpha_shared_intr_dispatch(dec_550_pci_intr, irq)) {
			alpha_shared_intr_stray(dec_550_pci_intr, irq,
			    "dec 550 irq");
			if (ALPHA_SHARED_INTR_DISABLE(dec_550_pci_intr, irq))
				dec_550_intr_disable(irq);
		} else
			alpha_shared_intr_reset_strays(dec_550_pci_intr, irq);
		return;
	}
#if NSIO
	if (vec >= 0x800) {
		sio_iointr(framep, vec);
		return;
	}
#endif
	panic("dec_550_iointr: weird vec 0x%lx", vec);
@


1.14
log
@Add a alpha_shared_intr_reset_strays() function that resets the stray
interrupt counter for a given shared interrupt descriptor.
When an interrupt is successfully handled, reset the strays counter,
thus preventing a "slow leak" from eventually shutting off the interrupt
vector.

from NetBSD via KUDO Takashi
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.13 2005/07/24 14:21:29 miod Exp $ */
d198 1
a198 1
	alpha_pci_decompose_tag(pc, bustag, &bus, &device, &function);
d375 1
a375 1
	alpha_pci_decompose_tag(pc, pa->pa_tag, &bus, NULL, NULL);
@


1.13
log
@Be more permissive when checking the interrupt vector for devices tied to
the ISA interrupts; from NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.12 2004/06/28 02:28:43 aaron Exp $ */
d417 2
a418 1
		}
@


1.12
log
@Use new event counter API for interrupt counting on alpha.  By me, with some
edits by Theo.  deraadt@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.11 2003/05/11 19:41:09 deraadt Exp $ */
d121 2
a122 3
 * lines.  This IRQ is encoded as:
 *
 *	line = 0xe0 | isa_irq;
d124 1
a124 1
#define	DEC_550_LINE_IS_ISA(line)	((line) >= 0xe0 && (line) <= 0xef)
d251 2
a252 2
	if (DEC_550_LINE_IS_ISA(line) == 0 && line >= DEC_550_MAX_IRQ)
		panic("dec_550_intr_map: dec 550 irq too large (%d)",
d254 2
@


1.11
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.10 2002/06/25 21:33:21 miod Exp $ */
a100 1
const struct evcnt *dec_550_intr_evcnt(void *, pci_intr_handle_t);
a148 3
#if 0
	pc->pc_intr_evcnt = dec_550_intr_evcnt;
#endif
a169 7
#if 0		
		cp = alpha_shared_intr_string(dec_550_pci_intr, i);
		sprintf(cp, "irq %d", i);
		evcnt_attach_dynamic(alpha_shared_intr_evcnt(
		    dec_550_pci_intr, i), EVCNT_TYPE_INTR, NULL,
		    "dec_550", cp);
#endif
a293 23

#if 0
const struct evcnt *
dec_550_intr_evcnt(ccv, ih)
	void *ccv;
	pci_intr_handle_t ih;
{
#if 0
	struct cia_config *ccp = ccv;
#endif

#if NSIO
	if (DEC_550_LINE_IS_ISA(ih))
		return (sio_intr_evcnt(NULL /*XXX*/,
		    DEC_550_LINE_ISA_IRQ(ih)));
#endif

	if (ih >= DEC_550_MAX_IRQ)
		panic("dec_550_intr_evcnt: bogus 550 IRQ 0x%lx", ih);

	return (alpha_shared_intr_evcnt(dec_550_pci_intr, ih));
}
#endif
@


1.10
log
@No \n at the end of a panic() message... I thought all occurences had been
squashed already.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.9 2002/03/14 03:15:50 millert Exp $ */
d289 1
a289 1
	sprintf(irqstr, "dec 550 irq %ld", ih);
@


1.9
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.8 2002/03/14 01:26:27 millert Exp $ */
d264 1
a264 1
		panic("dec_550_intr_map: dec 550 irq too large (%d)\n",
d288 1
a288 1
		panic("dec_550_intr_string: bogus 550 IRQ 0x%lx\n", ih);
d323 1
a323 1
		panic("dec_550_intr_evcnt: bogus 550 IRQ 0x%lx\n", ih);
d350 1
a350 1
		panic("dec_550_intr_establish: bogus dec 550 IRQ 0x%lx\n", ih);
d443 1
a443 1
			panic("550_iointr: vec 0x%lx out of range\n", vec);
d459 1
a459 1
	panic("dec_550_iointr: weird vec 0x%lx\n", vec);
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.7 2001/12/14 00:44:59 nate Exp $ */
d102 2
a103 2
void	*dec_550_intr_establish __P((void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, char *));
d106 2
a107 2
void	*dec_550_pciide_compat_intr_establish __P((void *, struct device *,
	    struct pci_attach_args *, int, int (*)(void *), void *));
@


1.7
log
@Don't use a single static struct alpha_bus_space since there are machines
that can have more than one system bus attached to mainbus
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.6 2001/11/06 19:53:13 miod Exp $ */
d97 5
a101 5
int	dec_550_intr_map __P((void *, pcitag_t, int, int,
	    pci_intr_handle_t *));
const char *dec_550_intr_string __P((void *, pci_intr_handle_t));
int	dec_550_intr_line __P((void *, pci_intr_handle_t));
const struct evcnt *dec_550_intr_evcnt __P((void *, pci_intr_handle_t));
d104 1
a104 1
void	dec_550_intr_disestablish __P((void *, void *));
d108 1
a108 1
void    dec_550_pciide_compat_intr_disestablish __P((void *, void *));
d131 3
a133 3
void	dec_550_iointr __P((void *framep, unsigned long vec));
void	dec_550_intr_enable __P((int irq));
void	dec_550_intr_disable __P((int irq));
d334 1
a334 1
	int (*func) __P((void *));
d401 1
a401 1
	int (*func) __P((void *));
@


1.7.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.7 2001/12/14 00:44:59 nate Exp $ */
d97 12
a108 12
int	dec_550_intr_map(void *, pcitag_t, int, int,
	    pci_intr_handle_t *);
const char *dec_550_intr_string(void *, pci_intr_handle_t);
int	dec_550_intr_line(void *, pci_intr_handle_t);
const struct evcnt *dec_550_intr_evcnt(void *, pci_intr_handle_t);
void	*dec_550_intr_establish(void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, char *);
void	dec_550_intr_disestablish(void *, void *);

void	*dec_550_pciide_compat_intr_establish(void *, struct device *,
	    struct pci_attach_args *, int, int (*)(void *), void *);
void    dec_550_pciide_compat_intr_disestablish(void *, void *);
d131 3
a133 3
void	dec_550_iointr(void *framep, unsigned long vec);
void	dec_550_intr_enable(int irq);
void	dec_550_intr_disable(int irq);
d334 1
a334 1
	int (*func)(void *);
d401 1
a401 1
	int (*func)(void *);
@


1.7.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.7.2.1 2002/06/11 03:33:40 art Exp $ */
d264 1
a264 1
		panic("dec_550_intr_map: dec 550 irq too large (%d)",
d288 1
a288 1
		panic("dec_550_intr_string: bogus 550 IRQ 0x%lx", ih);
d323 1
a323 1
		panic("dec_550_intr_evcnt: bogus 550 IRQ 0x%lx", ih);
d350 1
a350 1
		panic("dec_550_intr_establish: bogus dec 550 IRQ 0x%lx", ih);
d443 1
a443 1
			panic("550_iointr: vec 0x%lx out of range", vec);
d459 1
a459 1
	panic("dec_550_iointr: weird vec 0x%lx", vec);
@


1.7.2.3
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d289 1
a289 1
	snprintf(irqstr, sizeof irqstr, "dec 550 irq %ld", ih);
@


1.6
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.5 2001/08/17 22:26:58 mickey Exp $ */
d139 1
a139 1
	bus_space_tag_t iot = ccp->cc_iot;
@


1.5
log
@provide a way to get the number used for irq line, not only a string
representation, this is needed for devices like cbb which pass
the interrupt line down to the cardbus attachment and not
getting the right line before pci_intr_map() has done it's
dirty deed.
tested on i386 by jason@@, compiles on alpha by art@@.
ppc and mveppc are to be test-compiled, but should work (;
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.4 2001/06/25 22:02:07 csapuntz Exp $ */
a76 1
#include <vm/vm.h>
@


1.4
log
@Fix earlier commit of pciide disestablish
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.3 2001/06/25 21:49:41 csapuntz Exp $ */
d101 1
d150 1
d292 13
@


1.3
log
@

Add disestablish for pciide on Alpha
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.2 2000/11/08 20:59:25 ericj Exp $ */
d108 1
a108 2
void    dec_550_pciide_compat_intr_disestablish __P((void *, pci_chipset_tag_t,
	    void *));
d411 1
a411 1
dec_550_pciide_compat_intr_disestablish(v, pc, cookie)
a412 1
	pci_chipset_tag_t pc;
@


1.2
log
@add tags
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d108 2
d158 2
d409 9
@


1.2.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.2 2000/11/08 20:59:25 ericj Exp $ */
@


1.2.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.2.2.1 2001/04/18 16:01:21 niklas Exp $ */
a107 1
void    dec_550_pciide_compat_intr_disestablish __P((void *, void *));
a155 2
	pc->pc_pciide_compat_intr_disestablish =
	    dec_550_pciide_compat_intr_disestablish;
a404 8
}

void
dec_550_pciide_compat_intr_disestablish(v, cookie)
	void *v;
	void *cookie;
{
	sio_intr_disestablish(NULL, cookie);
@


1.2.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.2.2.2 2001/07/04 10:14:42 niklas Exp $ */
a100 1
int	dec_550_intr_line __P((void *, pci_intr_handle_t));
a148 1
        pc->pc_intr_line = dec_550_intr_line;
a289 13
}

int
dec_550_intr_line(ccv, ih)
	void *ccv;
	pci_intr_handle_t ih;
{
#if NSIO
	if (DEC_550_LINE_IS_ISA(ih))
		return (sio_intr_line(NULL /*XXX*/, DEC_550_LINE_ISA_IRQ(ih)));
#endif

	return (ih);
@


1.2.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d77 1
@


1.2.2.5
log
@Merge in trunk
@
text
@d139 1
a139 1
	bus_space_tag_t iot = &ccp->cc_iot;
@


1.2.2.6
log
@Merge in -current from about a week ago
@
text
@d97 12
a108 12
int	dec_550_intr_map(void *, pcitag_t, int, int,
	    pci_intr_handle_t *);
const char *dec_550_intr_string(void *, pci_intr_handle_t);
int	dec_550_intr_line(void *, pci_intr_handle_t);
const struct evcnt *dec_550_intr_evcnt(void *, pci_intr_handle_t);
void	*dec_550_intr_establish(void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, char *);
void	dec_550_intr_disestablish(void *, void *);

void	*dec_550_pciide_compat_intr_establish(void *, struct device *,
	    struct pci_attach_args *, int, int (*)(void *), void *);
void    dec_550_pciide_compat_intr_disestablish(void *, void *);
d131 3
a133 3
void	dec_550_iointr(void *framep, unsigned long vec);
void	dec_550_intr_enable(int irq);
void	dec_550_intr_disable(int irq);
d334 1
a334 1
	int (*func)(void *);
d401 1
a401 1
	int (*func)(void *);
@


1.2.2.7
log
@Sync the SMP branch with 3.3
@
text
@d264 1
a264 1
		panic("dec_550_intr_map: dec 550 irq too large (%d)",
d288 1
a288 1
		panic("dec_550_intr_string: bogus 550 IRQ 0x%lx", ih);
d323 1
a323 1
		panic("dec_550_intr_evcnt: bogus 550 IRQ 0x%lx", ih);
d350 1
a350 1
		panic("dec_550_intr_establish: bogus dec 550 IRQ 0x%lx", ih);
d443 1
a443 1
			panic("550_iointr: vec 0x%lx out of range", vec);
d459 1
a459 1
	panic("dec_550_iointr: weird vec 0x%lx", vec);
@


1.2.2.8
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_550.c,v 1.2.2.7 2003/03/27 23:18:06 niklas Exp $ */
d289 1
a289 1
	snprintf(irqstr, sizeof irqstr, "dec 550 irq %ld", ih);
@


1.1
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
@

