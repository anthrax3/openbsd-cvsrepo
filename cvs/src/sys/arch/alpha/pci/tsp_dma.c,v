head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.10
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.8
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.4
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.8.0.16
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.5.0.10
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.8
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.3.0.18
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.16
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.14
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.12
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.10
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.8
	OPENBSD_3_4_BASE:1.3
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.2.0.2
	UBC_BASE:1.2
	OPENBSD_3_0:1.1.0.6
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9:1.1.0.4
	OPENBSD_2_9_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.12
date	2015.01.03.20.44.23;	author miod;	state Exp;
branches;
next	1.11;
commitid	EiIKk1zMok809r1B;

1.11
date	2014.06.14.23.11.20;	author jmatthew;	state Exp;
branches;
next	1.10;
commitid	bNrqGO9e64n0bceZ;

1.10
date	2014.05.08.20.46.49;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2014.01.06.20.11.40;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.02.18.01.47;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2009.02.01.14.34.00;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2008.10.17.18.30.20;	author okan;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.04.21.20.40;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.20.01.00.58;	author martin;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.27;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.06.19.53.13;	author miod;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.11.16.04.50.18;	author ericj;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.04.18.16.01.34;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.11.13.21.00.49;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	;

1.2.2.1
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Some bowels of the bus_dma code assume it is ok to perform bitwise operations
with the base address of the window, which only works if its size is smaller
than the address it begins at.

Until these assumptions are carefully fixed, revert r1.9, and go back to using
only one direct map window.
@
text
@/* $OpenBSD: tsp_dma.c,v 1.11 2014/06/14 23:11:20 jmatthew Exp $ */
/* $NetBSD: tsp_dma.c,v 1.1 1999/06/29 06:46:47 ross Exp $ */

/*-
 * Copyright (c) 1999 by Ross Harvey.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ross Harvey.
 * 4. The name of Ross Harvey may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY ROSS HARVEY ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURP0SE
 * ARE DISCLAIMED.  IN NO EVENT SHALL ROSS HARVEY BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*-
 * Copyright (c) 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#define _ALPHA_BUS_DMA_PRIVATE

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>

#include <machine/bus.h>
#include <machine/rpb.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <alpha/pci/tsreg.h>
#include <alpha/pci/tsvar.h>

#define tsp_dma() { Generate ctags(1) key. }

#define	EDIFF(a, b) (((a) | WSBA_ENA | WSBA_SG)	!= ((b) | WSBA_ENA | WSBA_SG))

bus_dma_tag_t tsp_dma_get_tag(bus_dma_tag_t, alpha_bus_t);
int	tsp_bus_dmamap_load_sgmap(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);
int	tsp_bus_dmamap_load_mbuf_sgmap(bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int);
int	tsp_bus_dmamap_load_uio_sgmap(bus_dma_tag_t, bus_dmamap_t,
	    struct uio *, int);
int	tsp_bus_dmamap_load_raw_sgmap(bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);
void	tsp_bus_dmamap_unload_sgmap(bus_dma_tag_t, bus_dmamap_t);
void	tsp_tlb_invalidate(struct tsp_config *);

void
tsp_dma_init(struct device *tsp, struct tsp_config *pcp)
{
	int i;
	bus_dma_tag_t t;
	struct ts_pchip *pccsr = pcp->pc_csr;
	bus_addr_t dwbase, dwlen, sgwbase, sgwlen, tbase;
	static const struct map_expected {
		u_int32_t base, mask, physbase, enables;
	} premap[4] = {
		/* 0-8MB at 8MB with S/G DMA (isa space) */
		{ 0x00800000, 0x00700000, 0x00000000, WSBA_ENA | WSBA_SG },
		/* 0-1GB at 2GB direct */
		{ 0x80000000, 0x3ff00000, 0x00000000, WSBA_ENA           },
		{ 0, 0, 0 },
		{ 0, 0, 0 }
	};

	alpha_mb();
	for(i = 0; i < 4; ++i) {
#ifdef DEBUG
		if (EDIFF(pccsr->tsp_wsba[i].tsg_r, premap[i].base) ||
		    EDIFF(pccsr->tsp_wsm[i].tsg_r, premap[i].mask) ||
		    ((premap[i].enables & WSBA_SG) == 0 &&
		      pccsr->tsp_tba[i].tsg_r != premap[i].physbase))
			printf("%s: window %d: %lx/base %lx/mask %lx"
			    " reinitialized\n",
			    tsp->dv_xname, i,
			    pccsr->tsp_wsba[i].tsg_r,
			    pccsr->tsp_wsm[i].tsg_r,
			    pccsr->tsp_tba[i].tsg_r);
#endif
		pccsr->tsp_wsba[i].tsg_r = premap[i].base | premap[i].enables;
		pccsr->tsp_wsm[i].tsg_r = premap[i].mask;
		if ((premap[i].enables & WSBA_SG) == 0)
			pccsr->tsp_tba[i].tsg_r = premap[i].physbase;
	}
	alpha_mb();

	/*
	 * Initialize the DMA tags used for direct-mapped DMA.
	 */
	t = &pcp->pc_dmat_direct;
	t->_cookie = pcp;
	t->_wbase = dwbase = WSBA_ADDR(pccsr->tsp_wsba[1].tsg_r);
	t->_wsize = dwlen = WSM_LEN(pccsr->tsp_wsm[1].tsg_r);
	t->_next_window = &pcp->pc_dmat_sgmap;
	t->_boundary = 0;
	t->_sgmap = NULL;
	t->_get_tag = tsp_dma_get_tag;
	/*
	 * Since we fall back to sgmap if the direct mapping fails,
	 * we need to set up for sgmap in any case.
	 */
	t->_dmamap_create = alpha_sgmap_dmamap_create;
	t->_dmamap_destroy = alpha_sgmap_dmamap_destroy;
	t->_dmamap_load = _bus_dmamap_load_direct;
	t->_dmamap_load_mbuf = _bus_dmamap_load_mbuf_direct;
	t->_dmamap_load_uio = _bus_dmamap_load_uio_direct;
	t->_dmamap_load_raw = _bus_dmamap_load_raw_direct;
	t->_dmamap_unload = _bus_dmamap_unload;
	t->_dmamap_sync = _bus_dmamap_sync;

	t->_dmamem_alloc = _bus_dmamem_alloc;
	t->_dmamem_free = _bus_dmamem_free;
	t->_dmamem_map = _bus_dmamem_map;
	t->_dmamem_unmap = _bus_dmamem_unmap;
	t->_dmamem_mmap = _bus_dmamem_mmap;

	/*
	 * Initialize the DMA tag used for sgmap-mapped DMA.
	 */
	t = &pcp->pc_dmat_sgmap;
	t->_cookie = pcp;
	t->_wbase = sgwbase = WSBA_ADDR(pccsr->tsp_wsba[0].tsg_r);
	t->_wsize = sgwlen = WSM_LEN(pccsr->tsp_wsm[0].tsg_r);
	t->_next_window = NULL;
	t->_boundary = 0;
	t->_sgmap = &pcp->pc_sgmap;
	t->_get_tag = tsp_dma_get_tag;
	t->_dmamap_create = alpha_sgmap_dmamap_create;
	t->_dmamap_destroy = alpha_sgmap_dmamap_destroy;
	t->_dmamap_load = tsp_bus_dmamap_load_sgmap;
	t->_dmamap_load_mbuf = tsp_bus_dmamap_load_mbuf_sgmap;
	t->_dmamap_load_uio = tsp_bus_dmamap_load_uio_sgmap;
	t->_dmamap_load_raw = tsp_bus_dmamap_load_raw_sgmap;
	t->_dmamap_unload = tsp_bus_dmamap_unload_sgmap;
	t->_dmamap_sync = _bus_dmamap_sync;

	t->_dmamem_alloc = _bus_dmamem_alloc;
	t->_dmamem_free = _bus_dmamem_free;
	t->_dmamem_map = _bus_dmamem_map;
	t->_dmamem_unmap = _bus_dmamem_unmap;
	t->_dmamem_mmap = _bus_dmamem_mmap;

	/*
	 * Initialize the SGMAP.  Align page table to 32k in case
	 * window is somewhat larger than expected.
	 */
	alpha_sgmap_init(t, &pcp->pc_sgmap, "tsp_sgmap",
	    sgwbase, 0, sgwlen, sizeof(u_int64_t), NULL, (32*1024));

	/*
	 * Check windows for sanity, especially if we later decide to
	 * use the firmware's initialization in some cases.
	 */
	if ((sgwbase <= dwbase && dwbase < sgwbase + sgwlen) ||
	    (dwbase <= sgwbase && sgwbase < dwbase + dwlen))
		panic("%s: overlap sg 0x%lx len 0x%lx d 0x%lx len 0x%lx",
		    __func__, sgwbase, sgwlen, dwbase, dwlen);

	tbase = pcp->pc_sgmap.aps_ptpa;
	if (tbase & ~0x7fffffc00UL)
		panic("tsp_dma_init: bad page table address");
	alpha_mb();
	pccsr->tsp_tba[0].tsg_r = tbase;
	alpha_mb();

	tsp_tlb_invalidate(pcp);
	alpha_mb();

	/* XXX XXX BEGIN XXX XXX */
	{							/* XXX */
		extern paddr_t alpha_XXX_dmamap_or;		/* XXX */
		alpha_XXX_dmamap_or = dwbase;			/* XXX */
	}							/* XXX */
	/* XXX XXX END XXX XXX */
}

/*
 * Return the bus dma tag to be used for the specified bus type.
 * INTERNAL USE ONLY!
 */
bus_dma_tag_t
tsp_dma_get_tag(t, bustype)
	bus_dma_tag_t t;
	alpha_bus_t bustype;
{
	struct tsp_config *pcp = t->_cookie;

	switch (bustype) {
	case ALPHA_BUS_PCI:
	case ALPHA_BUS_EISA:
		/*
		 * The direct mapped window will work for most systems,
		 * most of the time. When it doesn't, we chain to the sgmap
		 * window automatically.
		 */
		return (&pcp->pc_dmat_direct);

	case ALPHA_BUS_ISA:
		/*
		 * ISA doesn't have enough address bits to use
		 * the direct-mapped DMA window, so we must use
		 * SGMAPs.
		 */
		return (&pcp->pc_dmat_sgmap);

	default:
		panic("tsp_dma_get_tag: shouldn't be here, really...");
	}
}

/*
 * Load a TSP SGMAP-mapped DMA map with a linear buffer.
 */
int
tsp_bus_dmamap_load_sgmap(t, map, buf, buflen, p, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	void *buf;
	bus_size_t buflen;
	struct proc *p;
	int flags;
{
	int error;

	error = pci_sgmap_pte64_load(t, map, buf, buflen, p, flags,
	    t->_sgmap);
	if (error == 0)
		tsp_tlb_invalidate(t->_cookie);

	return (error);
}

/*
 * Load a TSP SGMAP-mapped DMA map with an mbuf chain.
 */
int
tsp_bus_dmamap_load_mbuf_sgmap(t, map, m, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	struct mbuf *m;
	int flags;
{
	int error;

	error = pci_sgmap_pte64_load_mbuf(t, map, m, flags, t->_sgmap);
	if (error == 0)
		tsp_tlb_invalidate(t->_cookie);

	return (error);
}

/*
 * Load a TSP SGMAP-mapped DMA map with a uio.
 */
int
tsp_bus_dmamap_load_uio_sgmap(t, map, uio, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	struct uio *uio;
	int flags;
{
	int error;

	error = pci_sgmap_pte64_load_uio(t, map, uio, flags, t->_sgmap);
	if (error == 0)
		tsp_tlb_invalidate(t->_cookie);

	return (error);
}

/*
 * Load a TSP SGMAP-mapped DMA map with raw memory.
 */
int
tsp_bus_dmamap_load_raw_sgmap(t, map, segs, nsegs, size, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	bus_dma_segment_t *segs;
	int nsegs;
	bus_size_t size;
	int flags;
{
	int error;

	error = pci_sgmap_pte64_load_raw(t, map, segs, nsegs, size, flags,
	    t->_sgmap);
	if (error == 0)
		tsp_tlb_invalidate(t->_cookie);

	return (error);
}

/*
 * Unload a TSP DMA map.
 */
void
tsp_bus_dmamap_unload_sgmap(t, map)
	bus_dma_tag_t t;
	bus_dmamap_t map;
{

	/*
	 * Invalidate any SGMAP page table entries used by this
	 * mapping.
	 */
	pci_sgmap_pte64_unload(t, map, t->_sgmap);
	tsp_tlb_invalidate(t->_cookie);

	/*
	 * Do the generic bits of the unload.
	 */
	_bus_dmamap_unload(t, map);
}

/*
 * Flush the TSP scatter/gather TLB.
 */
void
tsp_tlb_invalidate(pcp)
	struct tsp_config *pcp;
{

	alpha_mb();
	*pcp->pc_tlbia = 0;
	alpha_mb();
}
@


1.11
log
@Preallocate sgmap extent regions for tsp, cia and mcpcia dma maps, which fall
back to sgmap if the direct mapping fails.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: tsp_dma.c,v 1.10 2014/05/08 20:46:49 miod Exp $ */
d115 1
a115 2
		/* 1-2GB at 3GB direct */
		{ 0xC0000000, 0x3ff00000, 0x40000000, WSBA_ENA           },
d146 1
a146 5
	t->_wsize = dwlen = WSM_LEN(pccsr->tsp_wsm[1].tsg_r) +
	    WSM_LEN(pccsr->tsp_wsm[2].tsg_r);
	KDASSERT(WSBA_ADDR(pccsr->tsp_wsba[2].tsg_r) ==
	    WSBA_ADDR(pccsr->tsp_wsba[1].tsg_r) +
	    WSM_LEN(pccsr->tsp_wsm[1].tsg_r));
@


1.10
log
@Format string fixes for alpha kernels, and remove -Wno-format
@
text
@d1 1
a1 1
/* $OpenBSD: tsp_dma.c,v 1.9 2014/01/06 20:11:40 miod Exp $ */
d156 6
a161 2
	t->_dmamap_create = _bus_dmamap_create;
	t->_dmamap_destroy = _bus_dmamap_destroy;
@


1.9
log
@Program window #2 to allow the second GB of low memory to use direct DMA;
adapted from a long gone FreeBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: tsp_dma.c,v 1.8 2009/10/02 18:01:47 miod Exp $ */
d210 2
a211 2
		panic("tsp_dma_init: overlap sg %p len %p d %p len %p",
		    sgwbase, sgwlen, dwbase, dwlen);
@


1.8
log
@Support for DS15/DS25/ES45 (Titan) alpha models (rpb family 38). These systems
are very close to the Tsunami systems (rpb family 34) and share the existing
Tsunami code; the tsc(4) Tsunami controller code is extended to handle the
Titan differences, except for the Titan AGP GART which is left unsupported
for now.

Tested to not cause regressions on DS20 (deraadt@@) and ES40 (miod@@).
Titan support tested by Sergey Prysiazhnyi on DS25, many thanks for your time!
@
text
@d1 1
a1 1
/* $OpenBSD: tsp_dma.c,v 1.7 2009/02/01 14:34:00 miod Exp $ */
d108 2
a109 2
	static struct map_expected {
		u_int32_t base, mask, enables;
d111 6
a116 3
		{ 0x00800000, 0x00700000, WSBA_ENA | WSBA_SG },
		{ 0x80000000, 0x3ff00000, WSBA_ENA           },
		{ 0, 0, 0 },
d122 1
d124 3
a126 1
		    EDIFF(pccsr->tsp_wsm[i].tsg_r, premap[i].mask))
d133 1
d136 2
d142 1
a142 1
	 * Initialize the DMA tag used for direct-mapped DMA.
d147 5
a151 1
	t->_wsize = dwlen = WSM_LEN(pccsr->tsp_wsm[1].tsg_r);
a202 15

	/*
	 * Enable window 0 and enable SG PTE mapping.
	 */
	alpha_mb();
	pccsr->tsp_wsba[0].tsg_r |= WSBA_SG | WSBA_ENA;
	alpha_mb();

	/*
	 * Enable window 1 in direct mode.
	 */
	alpha_mb();
	pccsr->tsp_wsba[1].tsg_r =
	    (pccsr->tsp_wsba[1].tsg_r & ~WSBA_SG) | WSBA_ENA;
	alpha_mb();
@


1.7
log
@Remove unused _pfthresh member from struct alpha_bus_dma_tag.
@
text
@d1 1
a1 1
/* $OpenBSD: tsp_dma.c,v 1.6 2008/10/17 18:30:20 okan Exp $ */
a89 1

a91 1

a93 1

a95 1

a97 1

a98 1

d102 1
a102 2
tsp_dma_init(pcp)
	struct tsp_config *pcp;
d111 4
a114 4
		{ 0x800000, 		   0x700000, WSBA_ENA | WSBA_SG },
		{ 0x80000000 | WSBA_ENA, 0x3ff00000, WSBA_ENA           },
		{ 0, 0 },
		{ 0, 0 }
d121 1
a121 1
			printf("tsp%d: window %d: %lx/base %lx/mask %lx"
d123 1
a123 1
			    pcp->pc_pslot, i,
d199 8
d212 2
a213 1
		panic("tsp_dma_init: overlap");
d380 1
a380 1
	pcp->pc_csr->tsp_tlbia.tsg_r = 0;
@


1.6
log
@Remove clauses 3 and 4 from NetBSD license.

from ray; ok ray, deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: tsp_dma.c,v 1.5 2006/04/04 21:20:40 brad Exp $ */
a106 6
/*
 * XXX Need to figure out what this is, if any.  Initialize it to
 * XXX something that should be safe.
 */
#define	TSP_SGMAP_PFTHRESH	256

a174 1
	t->_pfthresh = TSP_SGMAP_PFTHRESH;
@


1.5
log
@Add a `prefetch threshold' member to the bus_dma_tag_t, so that
eventually we can determine whether or not to allocate a spill
page on a per-mapping basis.

From NetBSD

ok martin@@
@
text
@d1 1
a1 1
/* $OpenBSD: tsp_dma.c,v 1.4 2006/03/20 01:00:58 martin Exp $ */
a50 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.4
log
@factorize SGMAP-mapped DMA map creation and destroy code

ok miod@@, additional testing jsg@@

from NetBSD
@
text
@d1 1
a1 1
/* $OpenBSD: tsp_dma.c,v 1.3 2002/03/14 01:26:27 millert Exp $ */
d114 6
d188 1
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: tsp_dma.c,v 1.2 2001/11/06 19:53:13 miod Exp $ */
a97 5
int	tsp_bus_dmamap_create_sgmap(bus_dma_tag_t, bus_size_t, int,
	    bus_size_t, bus_size_t, int, bus_dmamap_t *);

void	tsp_bus_dmamap_destroy_sgmap(bus_dma_tag_t, bus_dmamap_t);

d183 2
a184 2
	t->_dmamap_create = tsp_bus_dmamap_create_sgmap;
	t->_dmamap_destroy = tsp_bus_dmamap_destroy_sgmap;
a269 49
}

/*
 * Create a TSP SGMAP-mapped DMA map.
 */
int
tsp_bus_dmamap_create_sgmap(t, size, nsegments, maxsegsz, boundary,
    flags, dmamp)
	bus_dma_tag_t t;
	bus_size_t size;  
	int nsegments;
	bus_size_t maxsegsz;
	bus_size_t boundary;
	int flags; 
	bus_dmamap_t *dmamp;
{
	bus_dmamap_t map;
	int error;

	error = _bus_dmamap_create(t, size, nsegments, maxsegsz,
	    boundary, flags, dmamp);
	if (error)
		return (error);

	map = *dmamp;

	if (flags & BUS_DMA_ALLOCNOW) {
		error = alpha_sgmap_alloc(map, round_page(size),
		    t->_sgmap, flags);
		if (error)
			tsp_bus_dmamap_destroy_sgmap(t, map);
	}

	return (error);
}

/*
 * Destroy a TSP SGMAP-mapped DMA map.
 */
void
tsp_bus_dmamap_destroy_sgmap(t, map)
	bus_dma_tag_t t;
	bus_dmamap_t map;
{

	if (map->_dm_flags & DMAMAP_HAS_SGMAP)
		alpha_sgmap_free(map, t->_sgmap);

	_bus_dmamap_destroy(t, map);
@


1.2
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/* $OpenBSD: tsp_dma.c,v 1.1 2000/11/16 04:50:18 ericj Exp $ */
d96 1
a96 1
bus_dma_tag_t tsp_dma_get_tag __P((bus_dma_tag_t, alpha_bus_t));
d98 2
a99 2
int	tsp_bus_dmamap_create_sgmap __P((bus_dma_tag_t, bus_size_t, int,
	    bus_size_t, bus_size_t, int, bus_dmamap_t *));
d101 1
a101 1
void	tsp_bus_dmamap_destroy_sgmap __P((bus_dma_tag_t, bus_dmamap_t));
d103 2
a104 2
int	tsp_bus_dmamap_load_sgmap __P((bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int));
d106 2
a107 2
int	tsp_bus_dmamap_load_mbuf_sgmap __P((bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int));
d109 2
a110 2
int	tsp_bus_dmamap_load_uio_sgmap __P((bus_dma_tag_t, bus_dmamap_t,
	    struct uio *, int));
d112 2
a113 2
int	tsp_bus_dmamap_load_raw_sgmap __P((bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int));
d115 1
a115 1
void	tsp_bus_dmamap_unload_sgmap __P((bus_dma_tag_t, bus_dmamap_t));
d117 1
a117 1
void	tsp_tlb_invalidate __P((struct tsp_config *));
@


1.2.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: tsp_dma.c,v 1.2 2001/11/06 19:53:13 miod Exp $ */
d96 1
a96 1
bus_dma_tag_t tsp_dma_get_tag(bus_dma_tag_t, alpha_bus_t);
d98 2
a99 2
int	tsp_bus_dmamap_create_sgmap(bus_dma_tag_t, bus_size_t, int,
	    bus_size_t, bus_size_t, int, bus_dmamap_t *);
d101 1
a101 1
void	tsp_bus_dmamap_destroy_sgmap(bus_dma_tag_t, bus_dmamap_t);
d103 2
a104 2
int	tsp_bus_dmamap_load_sgmap(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);
d106 2
a107 2
int	tsp_bus_dmamap_load_mbuf_sgmap(bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int);
d109 2
a110 2
int	tsp_bus_dmamap_load_uio_sgmap(bus_dma_tag_t, bus_dmamap_t,
	    struct uio *, int);
d112 2
a113 2
int	tsp_bus_dmamap_load_raw_sgmap(bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);
d115 1
a115 1
void	tsp_bus_dmamap_unload_sgmap(bus_dma_tag_t, bus_dmamap_t);
d117 1
a117 1
void	tsp_tlb_invalidate(struct tsp_config *);
@


1.1
log
@
initial support for 21264 systems.
from NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: tsp_dma.c,v 1.1 1999/06/29 06:46:47 ross Exp $ */
a79 1
#include <vm/vm.h>
@


1.1.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/* $OpenBSD: tsp_dma.c,v 1.1 2000/11/16 04:50:18 ericj Exp $ */
@


1.1.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d80 1
@


1.1.2.3
log
@Merge in -current from about a week ago
@
text
@d96 1
a96 1
bus_dma_tag_t tsp_dma_get_tag(bus_dma_tag_t, alpha_bus_t);
d98 2
a99 2
int	tsp_bus_dmamap_create_sgmap(bus_dma_tag_t, bus_size_t, int,
	    bus_size_t, bus_size_t, int, bus_dmamap_t *);
d101 1
a101 1
void	tsp_bus_dmamap_destroy_sgmap(bus_dma_tag_t, bus_dmamap_t);
d103 2
a104 2
int	tsp_bus_dmamap_load_sgmap(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);
d106 2
a107 2
int	tsp_bus_dmamap_load_mbuf_sgmap(bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int);
d109 2
a110 2
int	tsp_bus_dmamap_load_uio_sgmap(bus_dma_tag_t, bus_dmamap_t,
	    struct uio *, int);
d112 2
a113 2
int	tsp_bus_dmamap_load_raw_sgmap(bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);
d115 1
a115 1
void	tsp_bus_dmamap_unload_sgmap(bus_dma_tag_t, bus_dmamap_t);
d117 1
a117 1
void	tsp_tlb_invalidate(struct tsp_config *);
@


