head	1.21;
access;
symbols
	OPENBSD_6_1:1.21.0.8
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.6
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.20.0.18
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.22
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.20
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.16
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.14
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.12
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.10
	OPENBSD_5_0:1.20.0.8
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.6
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.8
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.4
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.18.0.8
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.6
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.4
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.17.0.18
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.16
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.14
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.12
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.10
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.8
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.6
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.17
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.11.0.12
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.11.0.10
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.8
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.6
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.4
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.6
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.4
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.21
date	2015.07.26.05.09.44;	author miod;	state Exp;
branches;
next	1.20;
commitid	5evJqb5U3VOxLlWE;

1.20
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.19;

1.19
date	2008.07.22.18.45.51;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.15.20.08.29;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.03.15.50;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.26.27;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.14.00.44.59;	author nate;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.11.06.19.53.13;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.17.22.26.58;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.25.21.49.42;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	99.01.11.05.11.03;	author millert;	state Exp;
branches
	1.11.6.1;
next	1.10;

1.10
date	98.07.01.05.32.38;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	97.01.24.19.57.48;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.12.08.00.20.40;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.11.12.20.29.38;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.10.30.22.40.05;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.07.29.23.00.37;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.06.18.09.44.24;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.02.20.04.35.24;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	95.12.27.22.25.32;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.14.03.53.28;	author deraadt;	state Exp;
branches;
next	;

1.11.6.1
date	2001.07.04.10.14.43;	author niklas;	state Exp;
branches;
next	1.11.6.2;

1.11.6.2
date	2001.10.31.02.52.44;	author nate;	state Exp;
branches;
next	1.11.6.3;

1.11.6.3
date	2001.11.13.21.00.49;	author niklas;	state Exp;
branches;
next	1.11.6.4;

1.11.6.4
date	2002.03.06.00.47.44;	author niklas;	state Exp;
branches;
next	1.11.6.5;

1.11.6.5
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Make sure pci_intr_map() will perform proper interrupt swizzling for devices
behind a bridge, if the SRM didn't pick an interrupt line for them.
@
text
@/*	$OpenBSD: pci_axppci_33.c,v 1.20 2009/08/22 02:54:50 mk Exp $	*/
/*	$NetBSD: pci_axppci_33.c,v 1.10 1996/11/13 21:13:29 cgd Exp $	*/

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Authors: Jeffrey Hsu and Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/time.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/isa/isavar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/ppbreg.h>

#include <alpha/pci/lcavar.h>

#include <alpha/pci/pci_axppci_33.h>
#include <alpha/pci/siovar.h>
#include <alpha/pci/sioreg.h>

#include "sio.h"

int     dec_axppci_33_intr_map(struct pci_attach_args *, pci_intr_handle_t *);
const char *dec_axppci_33_intr_string(void *, pci_intr_handle_t);
int	dec_axppci_33_intr_line(void *, pci_intr_handle_t);
void    *dec_axppci_33_intr_establish(void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, const char *);
void    dec_axppci_33_intr_disestablish(void *, void *);

#define	LCA_SIO_DEVICE	7	/* XXX */

void
pci_axppci_33_pickintr(lcp)
	struct lca_config *lcp;
{
	bus_space_tag_t iot = &lcp->lc_iot;
	pci_chipset_tag_t pc = &lcp->lc_pc;
	pcireg_t sioclass;
	int sioII;

	/* XXX MAGIC NUMBER */
	sioclass = pci_conf_read(pc, pci_make_tag(pc, 0, LCA_SIO_DEVICE, 0),
	    PCI_CLASS_REG);
        sioII = (sioclass & 0xff) >= 3;

	if (!sioII)
		printf("WARNING: SIO NOT SIO II... NO BETS...\n");

	pc->pc_intr_v = lcp;
	pc->pc_intr_map = dec_axppci_33_intr_map;
	pc->pc_intr_string = dec_axppci_33_intr_string;
	pc->pc_intr_line = dec_axppci_33_intr_line;
	pc->pc_intr_establish = dec_axppci_33_intr_establish;
	pc->pc_intr_disestablish = dec_axppci_33_intr_disestablish;

        /* Not supported on AXPpci33. */
        pc->pc_pciide_compat_intr_establish = NULL;
        pc->pc_pciide_compat_intr_disestablish = NULL;

#if NSIO > 0
	sio_intr_setup(pc, iot);
#else
	panic("pci_axppci_33_pickintr: no I/O interrupt handler (no sio)");
#endif
}

int
dec_axppci_33_intr_map(pa, ihp)
	struct pci_attach_args *pa;
	pci_intr_handle_t *ihp;
{
	pcitag_t bustag = pa->pa_intrtag;
	pci_chipset_tag_t pc = pa->pa_pc;
	int buspin, device, pirq;
	pcireg_t pirqreg;
	u_int8_t pirqline;

	if (pa->pa_bridgetag) {
		buspin = PPB_INTERRUPT_SWIZZLE(pa->pa_rawintrpin,
		    pa->pa_device);
		if (pa->pa_bridgeih[buspin - 1] != 0) {
			*ihp = pa->pa_bridgeih[buspin - 1];
			return 0;
		}

		return 1;
	}

	buspin = pa->pa_intrpin;
	pci_decompose_tag(pc, bustag, NULL, &device, NULL);

	switch (device) {
	case 6:					/* NCR SCSI */
		pirq = 3;
		break;

	case 11:				/* slot 1 */
		switch (buspin) {
		default:
		case PCI_INTERRUPT_PIN_A:
		case PCI_INTERRUPT_PIN_D:
			pirq = 0;
			break;
		case PCI_INTERRUPT_PIN_B:
			pirq = 2;
			break;
		case PCI_INTERRUPT_PIN_C:
			pirq = 1;
			break;
		};
		break;

	case 12:				/* slot 2 */
		switch (buspin) {
		default:
		case PCI_INTERRUPT_PIN_A:
		case PCI_INTERRUPT_PIN_D:
			pirq = 1;
			break;
		case PCI_INTERRUPT_PIN_B:
			pirq = 0;
			break;
		case PCI_INTERRUPT_PIN_C:
			pirq = 2;
			break;
		};
		break;

	case 8:				/* slot 3 */
		switch (buspin) {
		default:
		case PCI_INTERRUPT_PIN_A:
		case PCI_INTERRUPT_PIN_D:
			pirq = 2;
			break;
		case PCI_INTERRUPT_PIN_B:
			pirq = 1;
			break;
		case PCI_INTERRUPT_PIN_C:
			pirq = 0;
			break;
		};
		break;

	default:
                return 1;
	}

	pirqreg = pci_conf_read(pc, pci_make_tag(pc, 0, LCA_SIO_DEVICE, 0),
	    SIO_PCIREG_PIRQ_RTCTRL);

	pirqline = (pirqreg >> (pirq * 8)) & 0xff;
	if ((pirqline & 0x80) != 0)
		return 1;			/* not routed? */
	pirqline &= 0xf;

	*ihp = pirqline;
	return (0);
}

const char *
dec_axppci_33_intr_string(lcv, ih)
	void *lcv;
	pci_intr_handle_t ih;
{
	return sio_intr_string(NULL /*XXX*/, ih);
}

int
dec_axppci_33_intr_line(lcv, ih)
	void *lcv;
	pci_intr_handle_t ih;
{
	return sio_intr_line(NULL /*XXX*/, ih);
}

void *
dec_axppci_33_intr_establish(lcv, ih, level, func, arg, name)
	void *lcv, *arg;
	pci_intr_handle_t ih;
	int level;
	int (*func)(void *);
	const char *name;
{
	return sio_intr_establish(NULL /*XXX*/, ih, IST_LEVEL, level, func,
	    arg, name);
}

void
dec_axppci_33_intr_disestablish(lcv, cookie)
	void *lcv, *cookie;
{
	sio_intr_disestablish(NULL /*XXX*/, cookie);
}
@


1.20
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_axppci_33.c,v 1.19 2008/07/22 18:45:51 miod Exp $	*/
d46 1
d93 1
a93 1
#if NSIO
a105 1
	int buspin = pa->pa_intrpin;
d107 1
a107 1
	int device, pirq;
d111 10
a120 8
        if (buspin == 0) {
                /* No IRQ used. */
                return 1;
        }
        if (buspin > 4) {
                printf("pci_map_int: bad interrupt pin %d\n", buspin);
                return 1;
        }
d122 1
d132 1
a142 5
#ifdef DIAGNOSTIC
		default:			/* XXX gcc -Wuninitialized */
			panic("dec_axppci_33_intr_map bogus PCI pin %d",
			    buspin);
#endif
d148 1
a158 5
#ifdef DIAGNOSTIC
		default:			/* XXX gcc -Wuninitialized */
			panic("dec_axppci_33_intr_map bogus PCI pin %d",
			    buspin);
#endif
d164 1
a174 5
#ifdef DIAGNOSTIC
		default:			/* XXX gcc -Wuninitialized */
			panic("dec_axppci_33_intr_map bogus PCI pin %d",
			    buspin);
#endif
a178 2
                printf("dec_axppci_33_intr_map: weird device number %d\n",
		    device);
d184 1
a184 4
#if 0
	printf("pci_axppci_33_map_int: device %d pin %c: pirq %d, reg = %x\n",
		device, '@@' + buspin, pirq, pirqreg);
#endif
a188 5

#if 0
	printf("pci_axppci_33_map_int: device %d pin %c: mapped to line %d\n",
	    device, '@@' + buspin, pirqline);
#endif
@


1.19
log
@Modify pci_intr_map() implementation to pass the pci_attach_args to the
per-platform implementation, instead of selected members of it; this allows
us to get rid of some globals, and paves the way for better bridge support
on some models.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_axppci_33.c,v 1.18 2006/06/15 20:08:29 brad Exp $	*/
d59 1
a59 1
	    int, int (*func)(void *), void *, char *);
d235 1
a235 1
	char *name;
@


1.18
log
@Rework the interrupt code, shaving some cycles off in the process.
Rather than an "iointr" routine that decomposes a vector into an
IRQ, we maintain a vector table directly, hooking up each "iointr"
routine at the correct vector. This also allows us to hook device
interrupts up to specific vectors.

From thorpej NetBSD

Tested by myself and a number of end-users.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_axppci_33.c,v 1.17 2002/03/14 03:15:50 millert Exp $	*/
d55 1
a55 2
int     dec_axppci_33_intr_map(void *, pcitag_t, int, int,
	    pci_intr_handle_t *);
d100 2
a101 4
dec_axppci_33_intr_map(lcv, bustag, buspin, line, ihp)
	void *lcv;
	pcitag_t bustag;
	int buspin, line;
d104 3
a106 2
	struct lca_config *lcp = lcv;
	pci_chipset_tag_t pc = &lcp->lc_pc;
@


1.17
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_axppci_33.c,v 1.16 2002/03/14 01:26:27 millert Exp $	*/
a94 1
	set_iointr(&sio_iointr);
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_axppci_33.c,v 1.15 2001/12/14 00:44:59 nate Exp $	*/
d59 2
a60 2
void    *dec_axppci_33_intr_establish __P((void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, char *));
@


1.15
log
@Don't use a single static struct alpha_bus_space since there are machines
that can have more than one system bus attached to mainbus
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_axppci_33.c,v 1.14 2001/11/06 19:53:13 miod Exp $	*/
d55 4
a58 4
int     dec_axppci_33_intr_map __P((void *, pcitag_t, int, int,
	    pci_intr_handle_t *));
const char *dec_axppci_33_intr_string __P((void *, pci_intr_handle_t));
int	dec_axppci_33_intr_line __P((void *, pci_intr_handle_t));
d61 1
a61 1
void    dec_axppci_33_intr_disestablish __P((void *, void *));
d237 1
a237 1
	int (*func) __P((void *));
@


1.15.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_axppci_33.c,v 1.15 2001/12/14 00:44:59 nate Exp $	*/
d55 7
a61 7
int     dec_axppci_33_intr_map(void *, pcitag_t, int, int,
	    pci_intr_handle_t *);
const char *dec_axppci_33_intr_string(void *, pci_intr_handle_t);
int	dec_axppci_33_intr_line(void *, pci_intr_handle_t);
void    *dec_axppci_33_intr_establish(void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, char *);
void    dec_axppci_33_intr_disestablish(void *, void *);
d237 1
a237 1
	int (*func)(void *);
@


1.14
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_axppci_33.c,v 1.13 2001/08/17 22:26:58 mickey Exp $	*/
d69 1
a69 1
	bus_space_tag_t iot = lcp->lc_iot;
@


1.13
log
@provide a way to get the number used for irq line, not only a string
representation, this is needed for devices like cbb which pass
the interrupt line down to the cardbus attachment and not
getting the right line before pci_intr_map() has done it's
dirty deed.
tested on i386 by jason@@, compiles on alpha by art@@.
ppc and mveppc are to be test-compiled, but should work (;
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_axppci_33.c,v 1.12 2001/06/25 21:49:42 csapuntz Exp $	*/
d37 1
a37 1
#include <vm/vm.h>
@


1.12
log
@

Add disestablish for pciide on Alpha
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_axppci_33.c,v 1.11 1999/01/11 05:11:03 millert Exp $	*/
d58 1
d85 1
d222 8
@


1.11
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_axppci_33.c,v 1.10 1998/07/01 05:32:38 angelos Exp $	*/
d89 1
@


1.11.6.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_axppci_33.c,v 1.11 1999/01/11 05:11:03 millert Exp $	*/
a88 1
        pc->pc_pciide_compat_intr_disestablish = NULL;
@


1.11.6.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_axppci_33.c,v 1.11.6.1 2001/07/04 10:14:43 niklas Exp $	*/
a57 1
int	dec_axppci_33_intr_line __P((void *, pci_intr_handle_t));
a83 1
	pc->pc_intr_line = dec_axppci_33_intr_line;
a219 8
}

int
dec_axppci_33_intr_line(lcv, ih)
	void *lcv;
	pci_intr_handle_t ih;
{
	return sio_intr_line(NULL /*XXX*/, ih);
@


1.11.6.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 1
a37 1
#include <uvm/uvm_extern.h>
@


1.11.6.4
log
@Merge in trunk
@
text
@d69 1
a69 1
	bus_space_tag_t iot = &lcp->lc_iot;
@


1.11.6.5
log
@Merge in -current from about a week ago
@
text
@d55 7
a61 7
int     dec_axppci_33_intr_map(void *, pcitag_t, int, int,
	    pci_intr_handle_t *);
const char *dec_axppci_33_intr_string(void *, pci_intr_handle_t);
int	dec_axppci_33_intr_line(void *, pci_intr_handle_t);
void    *dec_axppci_33_intr_establish(void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, char *);
void    dec_axppci_33_intr_disestablish(void *, void *);
d237 1
a237 1
	int (*func)(void *);
@


1.10
log
@First shot for EB164SX/LX support; kernels for those should be much
more stable now, but by no means production-strong. A lot of code from
NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_axppci_33.c,v 1.9 1997/01/24 19:57:48 niklas Exp $	*/
d141 1
a141 1
			panic("dec_axppci_33_intr_map bogus PCI pin %d\n",
d161 1
a161 1
			panic("dec_axppci_33_intr_map bogus PCI pin %d\n",
d181 1
a181 1
			panic("dec_axppci_33_intr_map bogus PCI pin %d\n",
@


1.9
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_axppci_33.c,v 1.8 1996/12/08 00:20:40 niklas Exp $	*/
d87 3
d91 1
a91 1
	sio_intr_setup(iot);
@


1.8
log
@Merge to NetBSD 961107, i.e. mostly new bus.h
@
text
@d1 2
a2 2
/*	$OpenBSD: pci_axppci_33.c,v 1.7 1996/11/12 20:29:38 niklas Exp $	*/
/*	$NetBSD: pci_axppci_33.c,v 1.9 1996/10/23 04:12:27 cgd Exp $	*/
d136 5
d156 5
d176 5
d183 1
d185 3
a187 3
		printf("dec_axppci_33_pci_map_int: unknown device %d\n",
			device);
		panic("dec_axppci_33_pci_map_int: bad device number");
@


1.7
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 2
a2 2
/*	$OpenBSD: pci_axppci_33.c,v 1.6 1996/10/30 22:40:05 niklas Exp $	*/
/*	$NetBSD: pci_axppci_33.c,v 1.8 1996/10/13 03:00:11 christos Exp $	*/
d40 1
a40 1
#include <machine/bus.old.h>
d68 1
a68 1
	bus_chipset_tag_t bc = &lcp->lc_bc;
d88 1
a88 1
	sio_intr_setup(bc);
@


1.6
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_axppci_33.c,v 1.8 1996/10/13 03:00:11 christos Exp $	*/
d40 1
a40 1
#include <machine/bus.h>
@


1.5
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: pci_axppci_33.c,v 1.5 1996/04/23 14:15:28 cgd Exp $	*/
/*	$NetBSD: pci_axppci_33.c,v 1.5 1996/04/23 14:15:28 cgd Exp $	*/
d39 1
a198 2
	struct lca_config *lcp = lcv;

a209 2
	struct lca_config *lcp = lcv;

a217 2
	struct lca_config *lcp = lcv;

@


1.4
log
@sync to 0616, retaining local diffs
@
text
@d1 1
d58 1
a58 1
	    int, int (*func)(void *), void *));
d204 1
a204 1
dec_axppci_33_intr_establish(lcv, ih, level, func, arg)
d209 1
d214 1
a214 1
	    arg);
@


1.3
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d1 1
a1 1
/*	$NetBSD: pci_axppci_33.c,v 1.2 1995/12/24 02:29:43 mycroft Exp $	*/
d4 1
a4 1
 * Copyright (c) 1995 Carnegie-Mellon University.
d7 1
a7 1
 * Author: Jeffrey Hsu
d38 3
a47 1

d49 1
d53 39
a91 9
void    *dec_axppci_33_pci_map_int __P((void *, pci_conftag_t,
	    pci_intr_pin_t, pci_intr_line_t, int,
	    int (*func)(void *), void *, char *));
void    dec_axppci_33_pci_unmap_int __P((void *, void *));

__const struct pci_intr_fns dec_axppci_33_pci_intr_fns = {
        dec_axppci_33_pci_map_int,
        dec_axppci_33_pci_unmap_int,
};
d93 2
a94 2
void *
dec_axppci_33_pci_map_int(lcv, tag, pin, line, level, func, arg, what)
d96 3
a98 7
        pci_conftag_t tag;
	pci_intr_pin_t pin;
	pci_intr_line_t line;
        int level;
        int (*func) __P((void *));
        void *arg;
	char *what;
d101 3
a103 2
	int bus, device, pirq;
	pci_confreg_t irreg, pirqreg;
d106 1
a106 1
        if (pin == 0) {
d108 1
a108 1
                return 0;
d110 3
a112 3
        if (pin > 4) {
                printf("dec_axppci_33_map_int: bad interrupt pin %d\n", pin);
                return NULL;
d115 1
a115 1
	device = PCI_TAG_DEVICE(tag);
d123 1
a123 1
		switch (pin) {
d138 1
a138 1
		switch (pin) {
d153 1
a153 1
		switch (pin) {
d172 2
a173 4
#define LCA_SIO_DEVICE 7		/* XXX */

	pirqreg = PCI_CONF_READ(lcp->lc_conffns, lcp->lc_confarg,
	    PCI_MAKE_TAG(0, LCA_SIO_DEVICE, 0), 0x60); /* XXX */
d175 2
a176 2
	printf("dec_pci_axppci_33_map_int: device %d pin %c: pirq %d, reg = %x\n",
		device, '@@' + pin, pirq, pirqreg);
d180 1
a180 1
		return 0;			/* not routed? */
d184 2
a185 2
	printf("dec_pci_axppci_33_map_int: device %d pin %c: mapped to line %d\n",
	    device, '@@' + pin, pirqline);
d188 2
a189 6
#if NSIO
	return ISA_INTR_ESTABLISH(&sio_isa_intr_fns, NULL,	/* XXX */
	    pirqline, IST_LEVEL, level, func, arg);
#else
	panic("dec_axppci_33_pci_map_int: no sio!");
#endif
d192 4
a195 4
void
dec_axppci_33_pci_unmap_int(pifa, cookie)
	void *pifa;
	void *cookie;
d197 1
d199 1
a199 1
	panic("dec_axppci_33_pci_unmap_int not implemented");	/* XXX */
d202 6
a207 7
void
pci_axppci_33_pickintr(pcf, pcfa, ppf, ppfa, pifp, pifap)
        __const struct pci_conf_fns *pcf;
        __const struct pci_pio_fns *ppf;
        void *pcfa, *ppfa;
        __const struct pci_intr_fns **pifp;
        void **pifap;
d209 1
a209 2
	pci_confreg_t sioclass;
	int sioII;
d211 3
a213 4
	/* XXX MAGIC NUMBER */
	sioclass = PCI_CONF_READ(pcf, pcfa, PCI_MAKE_TAG(0, LCA_SIO_DEVICE, 0),
	    PCI_CLASS_REG);
        sioII = (sioclass & 0xff) >= 3;
d215 5
a219 2
	if (!sioII)
		printf("WARNING: SIO NOT SIO II... NO BETS...\n");
d221 1
a221 8
	*pifp = &dec_axppci_33_pci_intr_fns;
	*pifap = pcfa;			/* XXX assumes apecs_config ptr */
#if NSIO
        sio_intr_setup(ppf, ppfa);
	set_iointr(&sio_iointr);
#else
	panic("pci_axppci_33_pickintr: no I/O interrupt handler (no sio)");
#endif
@


1.2
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
@
text
@d52 1
a52 1
	    int (*func)(void *), void *));
d61 1
a61 1
dec_axppci_33_pci_map_int(lcv, tag, pin, line, level, func, arg)
d69 1
@


1.1
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: pci_axppci_33.c,v 1.1 1995/11/23 02:37:54 cgd Exp $	*/
d51 1
a51 1
	    pci_intr_pin_t, pci_intr_line_t, pci_intrlevel_t,
d66 1
a66 1
        pci_intrlevel_t level;
d161 1
a161 2
	    pirqline, ISA_IST_LEVEL, pci_intrlevel_to_isa(level),
	    func, arg);
@
