head	1.14;
access;
symbols
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	UBC_SYNC_A:1.14
	UBC_SYNC_B:1.14
	OPENBSD_2_7:1.12.0.8
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.6
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.4
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.11.0.4
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2000.07.03.19.35.37;	author mickey;	state dead;
branches;
next	1.13;

1.13
date	2000.07.03.19.30.21;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	98.11.21.18.25.48;	author millert;	state Exp;
branches
	1.12.6.1;
next	1.11;

1.11
date	97.11.06.12.27.04;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	97.07.31.13.40.02;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.01.24.19.58.00;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.12.08.00.20.51;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.11.23.21.44.56;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	96.11.12.20.29.41;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.10.30.22.40.19;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.07.29.23.01.00;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.06.18.09.44.42;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.53.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.45;	author deraadt;	state Exp;
branches;
next	;

1.12.6.1
date	2001.04.18.16.01.31;	author niklas;	state dead;
branches;
next	;


desc
@@


1.14
log
@forgot to cvs rm these
@
text
@@


1.13
log
@closer approximation to an alpha using new wscons.
tga moved to dev/pci.
by request from alpha people.
@
text
@@


1.12
log
@when mmap'ing check for offset >= size, not just > size and disallow negative offsets; mrg@@netbsd.org
@
text
@a0 589
/*	$OpenBSD: tga.c,v 1.11 1997/11/06 12:27:04 niklas Exp $	*/
/*	$NetBSD: tga.c,v 1.13 1996/12/05 01:39:37 cgd Exp $	*/

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/conf.h>
#include <sys/ioctl.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>
#include <machine/tgareg.h>
#include <alpha/pci/tgavar.h>
#include <alpha/pci/bt485reg.h>

#include <dev/rcons/raster.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/wscons/wsconsvar.h>
#include <machine/fbio.h>

#include <machine/autoconf.h>
#include <machine/pte.h>

#ifdef __BROKEN_INDIRECT_CONFIG
int	tgamatch __P((struct device *, void *, void *));
#else
int	tgamatch __P((struct device *, struct cfdata *, void *));
#endif
void	tgaattach __P((struct device *, struct device *, void *));
int	tgaprint __P((void *, const char *));

struct cfattach tga_ca = {
	sizeof(struct tga_softc), tgamatch, tgaattach,
};

struct cfdriver tga_cd = {
	NULL, "tga", DV_DULL,
};

int	tga_identify __P((tga_reg_t *));
const struct tga_conf *tga_getconf __P((int));
void	tga_getdevconfig __P((bus_space_tag_t memt, pci_chipset_tag_t pc,
	    pcitag_t tag, struct tga_devconfig *dc));

struct tga_devconfig tga_console_dc;

struct wscons_emulfuncs tga_emulfuncs = {
	rcons_cursor,			/* could use hardware cursor; punt */
	rcons_putstr,
	rcons_copycols,
	rcons_erasecols,
	rcons_copyrows,
	rcons_eraserows,
	rcons_setattr,
};

int	tgaioctl __P((void *, u_long, caddr_t, int, struct proc *));
int	tgammap __P((void *, off_t, int));

void	tga_blank __P((struct tga_devconfig *));
void	tga_unblank __P((struct tga_devconfig *));

int
tgamatch(parent, match, aux)
	struct device *parent;
#ifdef __BROKEN_INDIRECT_CONFIG
	void *match;
#else
	struct cfdata *match;
#endif
	void *aux;
{
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_DEC ||
	    PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_DEC_21030)
		return (0);

	return (10);
}

void
tga_getdevconfig(memt, pc, tag, dc)
	bus_space_tag_t memt;
	pci_chipset_tag_t pc;
	pcitag_t tag;
	struct tga_devconfig *dc;
{
	const struct tga_conf *tgac;
	const struct tga_ramdac_conf *tgar;
	struct raster *rap;
	struct rcons *rcp;
	bus_size_t pcisize;
	int i, cacheable;

	dc->dc_memt = memt;
	dc->dc_pc = pc;

	dc->dc_pcitag = tag;

	/* XXX MAGIC NUMBER */
	pci_mem_find(pc, tag, 0x10, &dc->dc_pcipaddr, &pcisize,
	    &cacheable);
	if (!cacheable)						/* sanity */
		panic("tga_getdevconfig: memory not cacheable?");

	/* XXX XXX XXX */
	if (bus_space_map(memt, dc->dc_pcipaddr, pcisize, 1, &dc->dc_vaddr))
		return;
	dc->dc_paddr = ALPHA_K0SEG_TO_PHYS(dc->dc_vaddr);	/* XXX */

	dc->dc_regs = (tga_reg_t *)(dc->dc_vaddr + TGA_MEM_CREGS);
	dc->dc_tga_type = tga_identify(dc->dc_regs);
	tgac = dc->dc_tgaconf = tga_getconf(dc->dc_tga_type);
	if (tgac == NULL)
		return;

#if 0
	/* XXX on the Alpha, pcisize = 4 * cspace_size. */
	if (tgac->tgac_cspace_size != pcisize)			/* sanity */
		panic("tga_getdevconfig: memory size mismatch?");
#endif

	tgar = tgac->tgac_ramdac;

	switch (dc->dc_regs[TGA_REG_VHCR] & 0x1ff) {		/* XXX */
	case 0:
		dc->dc_wid = 8192;
		break;

	case 1:
		dc->dc_wid = 8196;
		break;

	default:
		dc->dc_wid = (dc->dc_regs[TGA_REG_VHCR] & 0x1ff) * 4; /* XXX */
		break;
	}

	dc->dc_rowbytes = dc->dc_wid * (dc->dc_tgaconf->tgac_phys_depth / 8);

	if ((dc->dc_regs[TGA_REG_VHCR] & 0x00000001) != 0 &&	/* XXX */
	    (dc->dc_regs[TGA_REG_VHCR] & 0x80000000) != 0) {	/* XXX */
		dc->dc_wid -= 4;
		/*
		 * XXX XXX turning off 'odd' shouldn't be necesssary,
		 * XXX XXX but i can't make X work with the weird size.
		 */
		dc->dc_regs[TGA_REG_VHCR] &= ~0x80000001;
		dc->dc_rowbytes =
		    dc->dc_wid * (dc->dc_tgaconf->tgac_phys_depth / 8);
	}

	dc->dc_ht = (dc->dc_regs[TGA_REG_VVCR] & 0x7ff);	/* XXX */

	/* XXX this seems to be what DEC does */
	dc->dc_regs[TGA_REG_CCBR] = 0;
	dc->dc_regs[TGA_REG_VVBR] = 1;
	dc->dc_videobase = dc->dc_vaddr + tgac->tgac_dbuf[0] +
	    1 * tgac->tgac_vvbr_units;
	dc->dc_blanked = 1;
	tga_unblank(dc);
	
	/*
	 * Set all bits in the pixel mask, to enable writes to all pixels.
	 * It seems that the console firmware clears some of them
	 * under some circumstances, which causes cute vertical stripes.
	 */
	dc->dc_regs[TGA_REG_GPXR_P] = 0xffffffff;

	/* clear the screen */
	for (i = 0; i < dc->dc_ht * dc->dc_rowbytes; i += sizeof(u_int32_t))
		*(u_int32_t *)(dc->dc_videobase + i) = 0;

	/* initialize the raster */
	rap = &dc->dc_raster;
	rap->width = dc->dc_wid;
	rap->height = dc->dc_ht;
	rap->depth = tgac->tgac_phys_depth;
	rap->linelongs = dc->dc_rowbytes / sizeof(u_int32_t);
	rap->pixels = (u_int32_t *)dc->dc_videobase;

	/* initialize the raster console blitter */
	rcp = &dc->dc_rcons;
	rcp->rc_sp = rap;
	rcp->rc_crow = rcp->rc_ccol = -1;
	rcp->rc_crowp = &rcp->rc_crow;
	rcp->rc_ccolp = &rcp->rc_ccol;
	rcons_init(rcp, 34, 80);
}

void
tgaattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct pci_attach_args *pa = aux;
	struct tga_softc *sc = (struct tga_softc *)self;
	struct wscons_attach_args waa;
	struct wscons_odev_spec *wo;
	pci_intr_handle_t intrh;
	const char *intrstr;
	u_int8_t rev;
	int console;

	console = (pa->pa_tag == tga_console_dc.dc_pcitag);
	if (console)
		sc->sc_dc = &tga_console_dc;
	else {
		sc->sc_dc = (struct tga_devconfig *)
		    malloc(sizeof(struct tga_devconfig), M_DEVBUF, M_WAITOK);
		tga_getdevconfig(pa->pa_memt, pa->pa_pc, pa->pa_tag, sc->sc_dc);
	}
	if (sc->sc_dc->dc_vaddr == NULL) {
		printf(": couldn't map memory space; punt!\n");
		return;
	}

	/* XXX say what's going on. */
	intrstr = NULL;
	if (sc->sc_dc->dc_tgaconf->tgac_ramdac->tgar_intr != NULL) {
		if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,
		    pa->pa_intrline, &intrh)) {
			printf(": couldn't map interrupt");
			return;
		}
		intrstr = pci_intr_string(pa->pa_pc, intrh);
		sc->sc_intr = pci_intr_establish(pa->pa_pc, intrh, IPL_TTY,
		    sc->sc_dc->dc_tgaconf->tgac_ramdac->tgar_intr, sc->sc_dc,
		    sc->sc_dev.dv_xname);
		if (sc->sc_intr == NULL) {
			printf(": couldn't establish interrupt");
			if (intrstr != NULL)
				printf("at %s", intrstr);
			printf("\n");
			return;
		}
	}

	/*
	 * Initialize the RAMDAC and allocate any private storage it needs.
	 * Initialization includes disabling cursor, setting a sane
	 * colormap, etc.
	 */
	(*sc->sc_dc->dc_tgaconf->tgac_ramdac->tgar_init)(sc->sc_dc, 1);

	printf(": DC21030 ");
	rev = PCI_REVISION(pa->pa_class);
	switch (rev) {
	case 1: case 2: case 3:
		printf("step %c", 'A' + rev - 1);
		break;

	default:
		printf("unknown stepping (0x%x)", rev);
		break;
	}
	printf(", ");

	if (sc->sc_dc->dc_tgaconf == NULL) {
		printf("unknown board configuration\n");
		return;
	}
	printf("board type %s\n", sc->sc_dc->dc_tgaconf->tgac_name);
	printf("%s: %d x %d, %dbpp, %s RAMDAC\n", sc->sc_dev.dv_xname,
	    sc->sc_dc->dc_wid, sc->sc_dc->dc_ht,
	    sc->sc_dc->dc_tgaconf->tgac_phys_depth,
	    sc->sc_dc->dc_tgaconf->tgac_ramdac->tgar_name);

	if (intrstr != NULL)
		printf("%s: interrupting at %s\n", sc->sc_dev.dv_xname,
		    intrstr);

	waa.waa_isconsole = console;

	wo = &waa.waa_odev_spec;

	wo->wo_emulfuncs = &tga_emulfuncs;
	wo->wo_emulfuncs_cookie = &sc->sc_dc->dc_rcons;

	wo->wo_ioctl = tgaioctl;
	wo->wo_mmap = tgammap;
	wo->wo_miscfuncs_cookie = sc;

	wo->wo_nrows = sc->sc_dc->dc_rcons.rc_maxrow;
	wo->wo_ncols = sc->sc_dc->dc_rcons.rc_maxcol;
	wo->wo_crow = 0;
	wo->wo_ccol = 0;

	config_found(self, &waa, tgaprint);
}

int
tgaprint(aux, pnp)
	void *aux;
	const char *pnp;
{

	if (pnp)
		printf("wscons at %s", pnp);
	return (UNCONF);
}

int
tgaioctl(v, cmd, data, flag, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	struct tga_softc *sc = v;
	struct tga_devconfig *dc = sc->sc_dc;
	const struct tga_ramdac_conf *tgar = dc->dc_tgaconf->tgac_ramdac;

	switch (cmd) {
	case FBIOGTYPE:
#define fbt ((struct fbtype *)data)
		fbt->fb_type = FBTYPE_TGA;
		fbt->fb_height = sc->sc_dc->dc_ht;
		fbt->fb_width = sc->sc_dc->dc_wid;
		fbt->fb_depth = sc->sc_dc->dc_tgaconf->tgac_phys_depth;
		fbt->fb_cmsize = 256;		/* XXX ??? */
		fbt->fb_size = sc->sc_dc->dc_tgaconf->tgac_cspace_size;
#undef fbt
		return (0);

	case FBIOPUTCMAP:
		return (*tgar->tgar_set_cmap)(dc, (struct fbcmap *)data);

	case FBIOGETCMAP:
		return (*tgar->tgar_get_cmap)(dc, (struct fbcmap *)data);

	case FBIOGATTR:
		return (ENOTTY);			/* XXX ? */

	case FBIOSVIDEO:
		if (*(int *)data == FBVIDEO_OFF)
			tga_blank(sc->sc_dc);
		else
			tga_unblank(sc->sc_dc);
		return (0);

	case FBIOGVIDEO:
		*(int *)data = dc->dc_blanked ? FBVIDEO_OFF : FBVIDEO_ON;
		return (0);

	case FBIOSCURSOR:
		return (*tgar->tgar_set_cursor)(dc, (struct fbcursor *)data);

	case FBIOGCURSOR:
		return (*tgar->tgar_get_cursor)(dc, (struct fbcursor *)data);

	case FBIOSCURPOS:
		return (*tgar->tgar_set_curpos)(dc, (struct fbcurpos *)data);

	case FBIOGCURPOS:
		return (*tgar->tgar_get_curpos)(dc, (struct fbcurpos *)data);

	case FBIOGCURMAX:
		return (*tgar->tgar_get_curmax)(dc, (struct fbcurpos *)data);
	}
	return (-1);
}

int
tgammap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
{
	struct tga_softc *sc = v;

	if (offset >= sc->sc_dc->dc_tgaconf->tgac_cspace_size || offset < 0)
		return -1;
	return alpha_btop(sc->sc_dc->dc_paddr + offset);
}

void
tga_console(iot, memt, pc, bus, device, function)
	bus_space_tag_t iot, memt;
	pci_chipset_tag_t pc;
	int bus, device, function;
{
	struct tga_devconfig *dcp = &tga_console_dc;
	struct wscons_odev_spec wo;

	tga_getdevconfig(memt, pc, pci_make_tag(pc, bus, device, function), dcp);

	/* sanity checks */
	if (dcp->dc_vaddr == NULL)
		panic("tga_console(%d, %d): couldn't map memory space",
		    device, function);
	if (dcp->dc_tgaconf == NULL)
		panic("tga_console(%d, %d): unknown board configuration",
		    device, function);

	/*
	 * Initialize the RAMDAC but DO NOT allocate any private storage.
	 * Initialization includes disabling cursor, setting a sane
	 * colormap, etc.  It will be reinitialized in tgaattach().
	 */
	(*dcp->dc_tgaconf->tgac_ramdac->tgar_init)(dcp, 0);

	wo.wo_emulfuncs = &tga_emulfuncs;
	wo.wo_emulfuncs_cookie = &dcp->dc_rcons;

	/* ioctl and mmap are unused until real attachment. */

	wo.wo_nrows = dcp->dc_rcons.rc_maxrow;
	wo.wo_ncols = dcp->dc_rcons.rc_maxcol;
	wo.wo_crow = 0;
	wo.wo_ccol = 0;

	wscons_attach_console(&wo);
}

/*
 * Functions to blank and unblank the display.
 */
void
tga_blank(dc)
	struct tga_devconfig *dc;
{

	if (!dc->dc_blanked) {
		dc->dc_blanked = 1;
		dc->dc_regs[TGA_REG_VVVR] |= 0x02;		/* XXX */
	}
}

void
tga_unblank(dc)
	struct tga_devconfig *dc;
{

	if (dc->dc_blanked) {
		dc->dc_blanked = 0;
		dc->dc_regs[TGA_REG_VVVR] &= ~0x02;		/* XXX */
	}
}

/*
 * Functions to manipulate the built-in cursor handing hardware.
 */
int
tga_builtin_set_cursor(dc, fbc)
	struct tga_devconfig *dc;
	struct fbcursor *fbc;
{
	int v;
#if 0
	int count;
#endif

	v = fbc->set;
#if 0
	if (v & FB_CUR_SETCMAP)			/* XXX should be supported */
		return EINVAL;
	if (v & FB_CUR_SETSHAPE) {
		if ((u_int)fbc->size.x != 64 || (u_int)fbc->size.y > 64)
			return (EINVAL);
		/* The cursor is 2 bits deep, and there is no mask */
		count = (fbc->size.y * 64 * 2) / NBBY;
		if (!useracc(fbc->image, count, B_READ))
			return (EFAULT);
	}
	if (v & FB_CUR_SETHOT)			/* not supported */
		return EINVAL;
#endif

	/* parameters are OK; do it */
	if (v & FB_CUR_SETCUR) {
		if (fbc->enable)
			dc->dc_regs[TGA_REG_VVVR] |= 0x04;	/* XXX */
		else
			dc->dc_regs[TGA_REG_VVVR] &= ~0x04;	/* XXX */
	}
#if 0
	if (v & FB_CUR_SETPOS) {
		dc->dc_regs[TGA_REG_CXYR] =
		    ((fbc->pos.y & 0xfff) << 12) | (fbc->pos.x & 0xfff);
	}
	if (v & FB_CUR_SETCMAP) {
		/* XXX */
	}
	if (v & FB_CUR_SETSHAPE) {
		dc->dc_regs[TGA_REG_CCBR] =
		    (dc->dc_regs[TGA_REG_CCBR] & ~0xfc00) | (fbc->size.y << 10);
		copyin(fbc->image, (char *)(dc->dc_vaddr +
		    (dc->dc_regs[TGA_REG_CCBR] & 0x3ff)),
		    count);				/* can't fail. */
	}
#endif
	return (0);
}

int
tga_builtin_get_cursor(dc, fbc)
	struct tga_devconfig *dc;
	struct fbcursor *fbc;
{
	int count, error;

	fbc->set = FB_CUR_SETALL & ~(FB_CUR_SETHOT | FB_CUR_SETCMAP);
	fbc->enable = (dc->dc_regs[TGA_REG_VVVR] & 0x04) != 0;
	fbc->pos.x = dc->dc_regs[TGA_REG_CXYR] & 0xfff;
	fbc->pos.y = (dc->dc_regs[TGA_REG_CXYR] >> 12) & 0xfff;
	fbc->size.x = 64;
	fbc->size.y = (dc->dc_regs[TGA_REG_CCBR] >> 10) & 0x3f;

	if (fbc->image != NULL) {
		count = (fbc->size.y * 64 * 2) / NBBY;
		error = copyout((char *)(dc->dc_vaddr +
		      (dc->dc_regs[TGA_REG_CCBR] & 0x3ff)),
		    fbc->image, count);
		if (error)
			return (error);
		/* No mask */
	}
	/* XXX No color map */
	return (0);
}

int
tga_builtin_set_curpos(dc, fbp)
	struct tga_devconfig *dc;
	struct fbcurpos *fbp;
{

	dc->dc_regs[TGA_REG_CXYR] =
	    ((fbp->y & 0xfff) << 12) | (fbp->x & 0xfff);
	return (0);
}

int
tga_builtin_get_curpos(dc, fbp)
	struct tga_devconfig *dc;
	struct fbcurpos *fbp;
{

	fbp->x = dc->dc_regs[TGA_REG_CXYR] & 0xfff;
	fbp->y = (dc->dc_regs[TGA_REG_CXYR] >> 12) & 0xfff;
	return (0);
}

int
tga_builtin_get_curmax(dc, fbp)
	struct tga_devconfig *dc;
	struct fbcurpos *fbp;
{

	fbp->x = fbp->y = 64;
	return (0);
}
@


1.12.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: tga.c,v 1.12 1998/11/21 18:25:48 millert Exp $	*/
@


1.11
log
@Add some missing things for the MI vga driver.  Move wscons to an MI place as
well.  $OpenBSD$ tagging
@
text
@d1 1
a1 1
/*	$OpenBSD: tga.c,v 1.10 1997/07/31 13:40:02 kstailey Exp $	*/
d408 1
a408 1
	if (offset > sc->sc_dc->dc_tgaconf->tgac_cspace_size)
@


1.10
log
@text video attributes, tested only on vga, send me E-mail if it breaks something, thx.
@
text
@d1 1
a1 1
/*	$OpenBSD: tga.c,v 1.9 1997/01/24 19:58:00 niklas Exp $	*/
d51 2
a52 2
#include <alpha/wscons/wscons_raster.h>
#include <alpha/wscons/wsconsvar.h>
@


1.9
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: tga.c,v 1.8 1996/12/08 00:20:51 niklas Exp $	*/
d88 1
@


1.8
log
@Merge to NetBSD 961107, i.e. mostly new bus.h
@
text
@d1 2
a2 2
/*	$OpenBSD: tga.c,v 1.7 1996/11/23 21:44:56 kstailey Exp $	*/
/*	$NetBSD: tga.c,v 1.11 1996/10/23 04:12:35 cgd Exp $	*/
d58 1
d60 3
d90 2
a91 2
int	tgaioctl __P((struct device *, u_long, caddr_t, int, struct proc *));
int	tgammap __P((struct device *, off_t, int));
d99 6
a104 1
	void *match, *aux;
d308 1
d310 8
a317 2
	wo->wo_ef = &tga_emulfuncs;
	wo->wo_efa = &sc->sc_dc->dc_rcons;
a321 2
	wo->wo_ioctl = tgaioctl;
	wo->wo_mmap = tgammap;
d338 2
a339 2
tgaioctl(dev, cmd, data, flag, p)
	struct device *dev;
d345 1
a345 1
	struct tga_softc *sc = (struct tga_softc *)dev;
d400 2
a401 2
tgammap(dev, offset, prot)
	struct device *dev;
d405 1
a405 1
	struct tga_softc *sc = (struct tga_softc *)dev;
d438 5
a442 2
	wo.wo_ef = &tga_emulfuncs;
	wo.wo_efa = &dcp->dc_rcons;
a446 1
	/* ioctl and mmap are unused until real attachment. */
@


1.7
log
@added const to second parameter of cfprint_t routines
@
text
@d1 2
a2 2
/*	$OpenBSD: tga.c,v 1.6 1996/11/12 20:29:41 niklas Exp $	*/
/*	$NetBSD: tga.c,v 1.10 1996/10/13 03:00:22 christos Exp $	*/
d40 1
a40 1
#include <machine/bus.old.h>
d72 1
a72 1
void	tga_getdevconfig __P((bus_chipset_tag_t bc, pci_chipset_tag_t pc,
d107 2
a108 2
tga_getdevconfig(bc, pc, tag, dc)
	bus_chipset_tag_t bc;
d117 1
a117 1
	bus_mem_size_t pcisize;
d120 1
a120 1
	dc->dc_bc = bc;
d132 1
a132 1
	if (bus_mem_map(bc, dc->dc_pcipaddr, pcisize, 1, &dc->dc_vaddr))
d236 1
a236 1
		tga_getdevconfig(pa->pa_bc, pa->pa_pc, pa->pa_tag, sc->sc_dc);
d399 2
a400 2
tga_console(bc, pc, bus, device, function)
	bus_chipset_tag_t bc;
d407 1
a407 1
	tga_getdevconfig(bc, pc, pci_make_tag(pc, bus, device, function), dcp);
@


1.6
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$OpenBSD: tga.c,v 1.5 1996/10/30 22:40:19 niklas Exp $	*/
d60 1
a60 1
int	tgaprint __P((void *, /* const */ char *));
d315 1
a315 1
	/* const */ char *pnp;
@


1.5
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: tga.c,v 1.10 1996/10/13 03:00:22 christos Exp $	*/
d40 1
a40 1
#include <machine/bus.h>
@


1.4
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: tga.c,v 1.6 1996/04/12 06:09:08 cgd Exp $	*/
/*	$NetBSD: tga.c,v 1.6 1996/04/12 06:09:08 cgd Exp $	*/
d60 1
a60 1
int	tgaprint __P((void *, char *));
a96 1
	struct cfdata *cf = match;
d134 1
a134 1
	dc->dc_paddr = k0segtophys(dc->dc_vaddr);		/* XXX */
d244 1
d315 1
a315 1
	char *pnp;
d468 4
a471 1
	int v, count;
d550 1
d561 1
d571 1
@


1.3
log
@sync to 0616, retaining local diffs
@
text
@d1 1
d253 2
a254 1
		    sc->sc_dc->dc_tgaconf->tgac_ramdac->tgar_intr, sc->sc_dc);
@


1.2
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: tga.c,v 1.3 1995/11/23 02:38:25 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1995 Carnegie-Mellon University.
d35 1
d37 1
d39 2
a40 3
#include <dev/rcons/raster.h>
#include <dev/pseudo/rcons.h>
#include <dev/pseudo/ansicons.h>
d45 1
a45 1
#include <alpha/pci/tgareg.h>
d48 5
a52 1
#include <alpha/pci/wsconsvar.h>
d59 5
d65 2
a66 2
struct cfdriver tgacd = {
	NULL, "tga", tgamatch, tgaattach, DV_DULL, sizeof(struct tga_softc)
d70 3
a72 6
__const struct tga_conf *tga_getconf __P((int));
void	tga_getdevconfig __P((__const struct pci_conf_fns *, void *,
	    __const struct pci_mem_fns *, void *,
	    pci_conftag_t tag, struct tga_devconfig *dc));

void	tga_bell __P((void *));			/* XXX */
d76 2
a77 8
#if 0
dev_decl(tga, mmap);
dev_decl(tga, ioctl);
#endif

struct ansicons_functions tga_acf = {
	tga_bell,
	rcons_cursor,		/* could use hardware cursor; who cares? */
d85 2
a86 1
#define	TGAUNIT(dev)	minor(dev)
d88 2
a89 102
void	tga_builtin_set_cpos __P((struct tga_devconfig *, int, int));
void	tga_builtin_get_cpos __P((struct tga_devconfig *, int *, int *));

__const struct tga_ramdac_conf tga_ramdac_bt463 = {
	"Bt463",
	tga_builtin_set_cpos,
	tga_builtin_get_cpos,
	/* XXX */
};

void	tga_bt485_wr_reg __P((volatile tga_reg_t *, u_int, u_int8_t));
u_int8_t tga_bt485_rd_reg __P((volatile tga_reg_t *, u_int));

void	tga_bt485_set_cpos __P((struct tga_devconfig *, int, int));
void	tga_bt485_get_cpos __P((struct tga_devconfig *, int *, int *));

__const struct tga_ramdac_conf tga_ramdac_bt485 = {
	"Bt485",
	tga_bt485_set_cpos,
	tga_bt485_get_cpos,
	/* XXX */
};

#undef KB
#define KB		* 1024
#undef MB
#define	MB		* 1024 * 1024

__const struct tga_conf tga_configs[TGA_TYPE_UNKNOWN] = {
	/* TGA_TYPE_T8_01 */
	{
		"T8-01",
		&tga_ramdac_bt485,
		8,
		4 MB,
		2 KB,
		1,	{  2 MB,     0 },	{ 1 MB,    0 },
		0,	{     0,     0 },	{    0,    0 },
	},
	/* TGA_TYPE_T8_02 */
	{
		"T8-02",
		&tga_ramdac_bt485,
		8,
		4 MB,
		4 KB,
		1,	{  2 MB,     0 },	{ 2 MB,    0 },
		0,	{     0,     0 },	{    0,    0 },
	},
	/* TGA_TYPE_T8_22 */
	{
		"T8-22",
		&tga_ramdac_bt485,
		8,
		8 MB,
		4 KB,
		1,	{  4 MB,     0 },	{ 2 MB,    0 },
		1,	{  6 MB,     0 },	{ 2 MB,    0 },
	},
	/* TGA_TYPE_T8_44 */
	{
		"T8-44",
		&tga_ramdac_bt485,
		8,
		16 MB,
		4 KB,
		2,	{  8 MB, 12 MB },	{ 2 MB, 2 MB },
		2,	{ 10 MB, 14 MB },	{ 2 MB, 2 MB },
	},
	/* TGA_TYPE_T32_04 */
	{
		"T32-04",
		&tga_ramdac_bt463,
		32,
		16 MB,
		8 KB,
		1,	{  8 MB,     0 },	{ 4 MB,    0 },
		0,	{     0,     0 },	{    0,    0 },
	},
	/* TGA_TYPE_T32_08 */
	{
		"T32-08",
		&tga_ramdac_bt463,
		32,
		16 MB,
		16 KB,
		1,	{  8 MB,    0 },	{ 8 MB,    0 },
		0,	{     0,    0 },	{    0,    0 },
	},
	/* TGA_TYPE_T32_88 */
	{
		"T32-88",
		&tga_ramdac_bt463,
		32,
		32 MB,
		16 KB,
		1,	{ 16 MB,    0 },	{ 8 MB,    0 },
		1,	{ 24 MB,    0 },	{ 8 MB,    0 },
	},
};
#undef KB
#undef MB
d97 1
a97 1
	struct pcidev_attach_args *pda = aux;
d99 2
a100 2
	if (PCI_VENDOR(pda->pda_id) != PCI_VENDOR_DEC ||
	    PCI_PRODUCT(pda->pda_id) != PCI_PRODUCT_DEC_21030)
d103 1
a103 67
	return (1);
}

int
tga_identify(regs)
	tga_reg_t *regs;
{
	int type;
	int deep, addrmask, wide;

	deep = (regs[TGA_REG_GDER] & 0x1) != 0;		/* XXX */
	addrmask = ((regs[TGA_REG_GDER] >> 2) & 0x7);	/* XXX */
	wide = (regs[TGA_REG_GDER] & 0x200) == 0;	/* XXX */

	type = TGA_TYPE_UNKNOWN;

	if (!deep) {
		/* 8bpp frame buffer */

		if (addrmask == 0x0) {
			/* 4MB core map; T8-01 or T8-02 */

			if (!wide)
				type = TGA_TYPE_T8_01;
			else
				type = TGA_TYPE_T8_02;
		} else if (addrmask == 0x1) {
			/* 8MB core map; T8-22 */

			if (wide)			/* sanity */
				type = TGA_TYPE_T8_22;
		} else if (addrmask == 0x3) {
			/* 16MB core map; T8-44 */

			if (wide)			/* sanity */
				type = TGA_TYPE_T8_44;
		}
	} else {
		/* 32bpp frame buffer */

		if (addrmask == 0x3) {
			/* 16MB core map; T32-04 or T32-08 */

			if (!wide)
				type = TGA_TYPE_T32_04;
			else
				type = TGA_TYPE_T32_08;
		} else if (addrmask == 0x7) {
			/* 32MB core map; T32-88 */

			if (wide)			/* sanity */
				type = TGA_TYPE_T32_88;
		}
	}

	return (type);
}

__const struct tga_conf *
tga_getconf(type)
	int type;
{

	if (type >= 0 && type < TGA_TYPE_UNKNOWN)
		return &tga_configs[type];

	return (NULL);
d107 4
a110 5
tga_getdevconfig(pcf, pcfa, pmf, pmfa, tag, dc)
	__const struct pci_conf_fns *pcf;
	__const struct pci_mem_fns *pmf;
	void *pcfa, *pmfa;
	pci_conftag_t tag;
d113 2
a114 2
	__const struct tga_conf *tgac;
	__const struct tga_ramdac_conf *tgar;
d117 1
a117 1
	pci_msize_t pcisize;
d120 2
a121 4
	dc->dc_pcf = pcf;
	dc->dc_pcfa = pcfa;
	dc->dc_pmf = pmf;
	dc->dc_pmfa = pmfa;
d126 1
a126 1
	PCI_FIND_MEM(pcf, pcfa, tag, 0x10, &dc->dc_pcipaddr, &pcisize,
d131 2
a132 2
	dc->dc_vaddr = PCI_MEM_MAP(pmf, pmfa, dc->dc_pcipaddr, pcisize, 1);
	if (dc->dc_vaddr == 0)
a133 1

d167 1
a167 1
	    (dc->dc_regs[TGA_REG_VHCR] & 0x80000000) != 0)	/* XXX */
d169 8
d181 1
d185 2
a194 9
	/* disable the cursor */
	(*tgar->tgar_set_cpos)(dc, TGA_CURSOR_OFF, 0);

	/* init black and white color map entries to 'sane' values. */
#if 0
	(*tgar->tga_set_cmap)(dc, 0, 0, 0, 0);
	(*tgar->tga_set_cmap)(dc, 255, 0xff, 0xff, 0xff);
#endif

d221 1
a221 1
	struct pcidev_attach_args *pda = aux;
d223 5
a227 1
	pci_revision_t rev;
d230 1
a230 1
	console = (pda->pda_tag == tga_console_dc.dc_pcitag);
d236 1
a236 2
		tga_getdevconfig(pda->pda_conffns, pda->pda_confarg,
		    pda->pda_memfns, pda->pda_memarg, pda->pda_tag, sc->sc_dc);
d243 26
d270 1
a270 1
	rev = PCI_REVISION(pda->pda_class);
d292 23
a314 3
#if 0
	/* XXX intr foo? */
#endif
d316 3
a318 6
	if (!wscattach_output(self, console, &sc->sc_dc->dc_ansicons, &tga_acf,
	    &sc->sc_dc->dc_rcons, sc->sc_dc->dc_rcons.rc_maxrow,
	    sc->sc_dc->dc_rcons.rc_maxcol, 0, 0)) {
		panic("tgaattach: wscattach failed");
		/* NOTREACHED */
	}
a320 1
#if 0
d323 1
a323 1
	dev_t dev;
d329 41
a369 1
	struct tga_softc *sc = tgacd.cd_devs[TGAUNIT(dev)];
d371 10
a380 1
	return (ENOTTY);
d384 4
a387 4
tgammap(dev, offset, nprot)
	dev_t dev;
	int offset;
	int nprot;
d389 1
a389 1
	struct tga_softc *sc = tgacd.cd_devs[TGAUNIT(dev)];
a394 1
#endif
d397 4
a400 2
tga_bell(id)
	void *id;
d402 27
d430 1
a430 2
	/* XXX */
	printf("tga_bell: not implemented\n");
d433 3
d437 1
a437 1
tga_builtin_set_cpos(dc, x, y)
a438 1
	int x, y;
d441 3
a443 5
	if (x == TGA_CURSOR_OFF || y == TGA_CURSOR_OFF) {

		dc->dc_regs[TGA_REG_VVVR] &= ~0x04;		/* XXX */
		wbflush();
		return;
a444 7

	/*
	 * TGA builtin cursor is 0-based, and position is top-left corner.
	 */
	dc->dc_regs[TGA_REG_CXYR] =
	    (x & 0xfff) | ((y & 0xfff) << 12);			/* XXX */
	wbflush();
d448 1
a448 1
tga_builtin_get_cpos(dc, xp, yp)
a449 1
	int *xp, *yp;
a450 1
	tga_reg_t regval;
d452 3
a454 3
	if ((dc->dc_regs[TGA_REG_VVVR] & 0x04) == 0) {		/* XXX */
		*xp = *yp = TGA_CURSOR_OFF;
		return;
a455 4

	regval = dc->dc_regs[TGA_REG_CXYR];
	*xp = regval & 0xfff;					/* XXX */
	*yp = (regval >> 12) & 0xfff;				/* XXX */
d459 1
a459 1
 * Bt485-specific functions.
d461 4
a464 6

void
tga_bt485_wr_reg(tgaregs, btreg, val)
	volatile tga_reg_t *tgaregs;
	u_int btreg;
	u_int8_t val;
d466 1
d468 15
a482 2
	if (btreg > BT485_REG_MAX)
		panic("tga_bt485_wr_reg: reg %d out of range\n", btreg);
d484 24
a507 2
	tgaregs[TGA_REG_EPDR] = (btreg << 9) | (0 << 8 ) | val; /* XXX */
	wbflush();
d510 4
a513 4
u_int8_t
tga_bt485_rd_reg(tgaregs, btreg)
	volatile tga_reg_t *tgaregs;
	u_int btreg;
d515 1
a515 1
	tga_reg_t rdval;
d517 18
a534 8
	if (btreg > BT485_REG_MAX)
		panic("tga_bt485_rd_reg: reg %d out of range\n", btreg);

	tgaregs[TGA_REG_EPSR] = (btreg << 1) | 0x1;		/* XXX */
	wbflush();

	rdval = tgaregs[TGA_REG_EPDR];
	return (rdval >> 16) & 0xff;				/* XXX */
d537 2
a538 2
void
tga_bt485_set_cpos(dc, x, y)
d540 1
a540 1
	int x, y;
d543 2
a544 26
	if (x == TGA_CURSOR_OFF || y == TGA_CURSOR_OFF) {
		u_int8_t regval;

		regval = tga_bt485_rd_reg(dc->dc_regs, BT485_REG_COMMAND_2);
		regval &= ~0x03;				/* XXX */
		regval |= 0x00;					/* XXX */
		tga_bt485_wr_reg(dc->dc_regs, BT485_REG_COMMAND_2, regval);
		return;
	}

	/*
	 * RAMDAC cursors are 1-based, and position is bottom-right
	 * of displayed cursor!
	 */
	x += 64;
	y += 64;

	/* XXX CONSTANTS */
	tga_bt485_rd_reg(dc->dc_regs, BT485_REG_CURSOR_X_LOW/*,
	    x & 0xff*/);
	tga_bt485_rd_reg(dc->dc_regs, BT485_REG_CURSOR_X_HIGH/*,
	    (x >> 8) & 0x0f*/);
	tga_bt485_rd_reg(dc->dc_regs, BT485_REG_CURSOR_Y_LOW/*,
	    y & 0xff*/);
	tga_bt485_rd_reg(dc->dc_regs, BT485_REG_CURSOR_Y_HIGH/*,
	    (y >> 8) & 0x0f*/);
d547 2
a548 2
void
tga_bt485_get_cpos(dc, xp, yp)
d550 1
a550 1
	int *xp, *yp;
a551 1
	u_int8_t regval;
d553 2
a554 22
	regval = tga_bt485_rd_reg(dc->dc_regs, BT485_REG_COMMAND_2);
	if ((regval & 0x03) == 0x00) {			/* XXX */
		*xp = *yp = TGA_CURSOR_OFF;
		return;
	}

	regval = tga_bt485_rd_reg(dc->dc_regs, BT485_REG_CURSOR_X_LOW);
	*xp = regval;
	regval = tga_bt485_rd_reg(dc->dc_regs, BT485_REG_CURSOR_X_HIGH);
	*xp |= regval << 8;				/* XXX */

	regval = tga_bt485_rd_reg(dc->dc_regs, BT485_REG_CURSOR_Y_LOW);
	*yp = regval;
	regval = tga_bt485_rd_reg(dc->dc_regs, BT485_REG_CURSOR_Y_HIGH);
	*yp |= regval << 8;				/* XXX */

	/*
	 * RAMDAC cursors are 1-based, and position is bottom-right
	 * of displayed cursor!
	 */
	(*xp) -= 64;
	(*yp) -= 64;
d557 4
a560 9
void
tga_console(pcf, pcfa, pmf, pmfa, ppf, ppfa, bus, device, function)
	__const struct pci_conf_fns *pcf;
	__const struct pci_mem_fns *pmf;
	__const struct pci_pio_fns *ppf;
	void *pcfa, *pmfa, *ppfa;
	pci_bus_t bus;
	pci_device_t device;
	pci_function_t function;
a561 12
	struct tga_devconfig *dcp = &tga_console_dc;

	tga_getdevconfig(pcf, pcfa, pmf, pmfa,
	    PCI_MAKE_TAG(bus, device, function), dcp);

	/* sanity checks */
	if (dcp->dc_vaddr == NULL)
		panic("tga_console(%d, %d): couldn't map memory space",
		    device, function);
	if (dcp->dc_tgaconf == NULL)
		panic("tga_console(%d, %d): unknown board configuration",
		    device, function);
d563 1
a563 2
	wsc_console(&dcp->dc_ansicons, &tga_acf, &dcp->dc_rcons,
	    dcp->dc_rcons.rc_maxrow, dcp->dc_rcons.rc_maxcol, 0, 0);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: tga.c,v 1.2 1995/08/03 01:17:28 cgd Exp $	*/
d35 1
d37 1
a37 1
#include <dev/pseudo/raster.h>
d47 1
d59 8
d69 4
a72 3
int	tga_identify __P((tga_reg_t *));
struct	tga_conf *tga_getconf __P((int));
void	tga_bell __P((void *));
d86 4
a89 1
struct tga_ramdac_conf tga_ramdac_bt463 = {
d91 2
a92 4
#if 0
	XXX,
	YYY,
#endif
d96 3
d102 1
a102 1
struct tga_ramdac_conf tga_ramdac_bt485 = {
d114 1
a114 1
struct tga_conf tga_configs[TGA_TYPE_UNKNOWN] = {
d195 1
a195 1
	struct pci_attach_args *pa = aux;
d197 2
a198 2
	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_DEC ||
	    PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_DEC_21030)
d259 1
a259 1
struct tga_conf *
d271 5
a275 2
tga_getdevconfig(tag, dc)
	pcitag_t tag;
d278 2
a279 2
	struct tga_conf *tgac;
	struct tga_ramdac_conf *tgar;
d282 7
a288 2
	vm_offset_t pcipa;
	int i;
d292 8
a299 2
	dc->dc_vaddr = 0;
	if (pci_map_mem(tag, 0x10, &dc->dc_vaddr, &pcipa))
d302 1
a302 2
	/* PA filled in by pci_map_mem is the PCI-bus PA, i.e. not shifted */
	dc->dc_paddr = k0segtophys(dc->dc_vaddr);
d309 7
d344 7
d387 1
a387 1
	struct pci_attach_args *pa = aux;
a389 1
	pcireg_t pci_intrdata;
d392 1
a392 1
	console = (pa->pa_tag == tga_console_dc.dc_pcitag);
d398 2
a399 1
		tga_getdevconfig(pa->pa_tag, sc->sc_dc);
d407 1
a407 1
	rev = PCI_REVISION(pa->pa_class);
d426 1
a426 1
	    sc->sc_dc->dc_tgaconf->tgac_phys_depth, 
a427 5
#if 0
	/* not done here; printed by wscons attach. */
	if (console)
		printf("%s: console\n", sc->sc_dev.dv_xname);
#endif
d430 1
a430 8
	pci_intrdata = pci_conf_read(sc->sc_pcitag, PCI_INTERRUPT_REG);
	if (PCI_INTERRUPT_PIN(pci_intrdata) != PCI_INTERRUPT_PIN_NONE) {
		sc->sc_intr = pci_map_int(sc->sc_pcitag, PCI_IPL_TTY,
		    tgaintr, sc);
		if (sc->sc_intr == NULL)
			printf("%s: WARNING: couldn't map interrupt\n",
			    sc->sc_dev.dv_xname);
	}
d441 1
a441 29
int
tgaopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	struct tga_softc *sc;
	int unit = TGAUNIT(dev);

	if (unit >= tgacd.cd_ndevs)
		return ENXIO;
	sc = tgacd.cd_devs[unit];
	if ((sc = tgacd.cd_devs[unit]) == NULL || sc->sc_dc->dc_tgaconf == NULL)
		return ENXIO;

	return (0);
}

int
tgaclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	struct tga_softc *sc = tgacd.cd_devs[TGAUNIT(dev)];

	return (0);
}

d467 1
d478 37
d564 1
d575 8
a582 8
	tga_bt485_rd_reg(dc->dc_regs, BT485_REG_CURSOR_X_LOW,
	    x & 0xff);
	tga_bt485_rd_reg(dc->dc_regs, BT485_REG_CURSOR_X_HIGH,
	    (x >> 8) & 0x0f);
	tga_bt485_rd_reg(dc->dc_regs, BT485_REG_CURSOR_Y_LOW,
	    y & 0xff);
	tga_bt485_rd_reg(dc->dc_regs, BT485_REG_CURSOR_Y_HIGH,
	    (y >> 8) & 0x0f);
d617 8
a624 2
tga_console(bus, device, function)
	int bus, device, function;
d628 2
a629 1
	tga_getdevconfig(pci_make_tag(bus, device, function), dcp);
d633 2
a634 2
		panic("tga_console(%d, %d, %d): couldn't map memory space",
		    bus, device, function);
d636 2
a637 2
		panic("tga_console(%d, %d, %d): unknown board configuration",
		    bus, device, function);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
