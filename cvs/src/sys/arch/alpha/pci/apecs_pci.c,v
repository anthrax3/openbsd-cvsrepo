head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.8
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.4
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.11.0.22
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.14
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.18
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.16
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.12
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.10.0.18
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.14
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.16
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.12
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.18
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.16
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.14
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.12
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.10
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.8
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.8.0.2
	UBC_BASE:1.8
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.6.0.18
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.16
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.14
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.12
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.10
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.8
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.10.30.07.51.49;	author miod;	state Exp;
branches;
next	1.11;
commitid	z4wcFsTNnTFyyLXA;

1.11
date	2010.12.04.17.06.31;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.26.20.23.08;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.27;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.06.19.53.13;	author miod;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.02.16.08.23.39;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	97.01.24.19.57.34;	author niklas;	state Exp;
branches
	1.6.14.1;
next	1.5;

1.5
date	96.10.30.22.39.49;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.07.29.23.00.07;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.06.18.09.44.00;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.53.20;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.45;	author deraadt;	state Exp;
branches;
next	;

1.6.14.1
date	2001.04.18.16.01.07;	author niklas;	state Exp;
branches;
next	1.6.14.2;

1.6.14.2
date	2001.11.13.21.00.49;	author niklas;	state Exp;
branches;
next	1.6.14.3;

1.6.14.3
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	;

1.8.2.1
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Use NULL instead of 0 for pci_decompose_tag() pointer arguments.
@
text
@/*	$OpenBSD: apecs_pci.c,v 1.11 2010/12/04 17:06:31 miod Exp $	*/
/*	$NetBSD: apecs_pci.c,v 1.10 1996/11/13 21:13:25 cgd Exp $	*/

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>	/* badaddr() proto */

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <alpha/pci/apecsreg.h>
#include <alpha/pci/apecsvar.h>

void		apecs_attach_hook(struct device *, struct device *,
		    struct pcibus_attach_args *);
int		apecs_bus_maxdevs(void *, int);
pcitag_t	apecs_make_tag(void *, int, int, int);
void		apecs_decompose_tag(void *, pcitag_t, int *, int *,
		    int *);
int		apecs_conf_size(void *, pcitag_t);
pcireg_t	apecs_conf_read(void *, pcitag_t, int);
void		apecs_conf_write(void *, pcitag_t, int, pcireg_t);

void
apecs_pci_init(pc, v)
	pci_chipset_tag_t pc;
	void *v;
{

	pc->pc_conf_v = v;
	pc->pc_attach_hook = apecs_attach_hook;
	pc->pc_bus_maxdevs = apecs_bus_maxdevs;
	pc->pc_make_tag = apecs_make_tag;
	pc->pc_decompose_tag = apecs_decompose_tag;
	pc->pc_conf_size = apecs_conf_size;
	pc->pc_conf_read = apecs_conf_read;
	pc->pc_conf_write = apecs_conf_write;
}

void
apecs_attach_hook(parent, self, pba)
	struct device *parent, *self;
	struct pcibus_attach_args *pba;
{
}

int
apecs_bus_maxdevs(cpv, busno)
	void *cpv;
	int busno;
{

	return 32;
}

pcitag_t
apecs_make_tag(cpv, b, d, f)
	void *cpv;
	int b, d, f;
{

	return (b << 16) | (d << 11) | (f << 8);
}

void
apecs_decompose_tag(cpv, tag, bp, dp, fp)
	void *cpv;
	pcitag_t tag;
	int *bp, *dp, *fp;
{

	if (bp != NULL)
		*bp = (tag >> 16) & 0xff;
	if (dp != NULL)
		*dp = (tag >> 11) & 0x1f;
	if (fp != NULL)
		*fp = (tag >> 8) & 0x7;
}

int
apecs_conf_size(void *cpv, pcitag_t tag)
{
	return PCI_CONFIG_SPACE_SIZE;
}

pcireg_t
apecs_conf_read(cpv, tag, offset)
	void *cpv;
	pcitag_t tag;
	int offset;
{
	struct apecs_config *acp = cpv;
	pcireg_t *datap, data;
	int s, secondary, ba;
	int32_t old_haxr2;					/* XXX */

	s = 0;					/* XXX gcc -Wuninitialized */
	old_haxr2 = 0;				/* XXX gcc -Wuninitialized */

	/* secondary if bus # != 0 */
	pci_decompose_tag(&acp->ac_pc, tag, &secondary, NULL, NULL);
	if (secondary) {
		s = splhigh();
		old_haxr2 = REGVAL(EPIC_HAXR2);
		alpha_mb();
		REGVAL(EPIC_HAXR2) = old_haxr2 | 0x1;
		alpha_mb();
	}

	datap = (pcireg_t *)ALPHA_PHYS_TO_K0SEG(APECS_PCI_CONF |
	    tag << 5UL |					/* XXX */
	    (offset & ~0x03) << 5 |				/* XXX */
	    0 << 5 |						/* XXX */
	    0x3 << 3);						/* XXX */
	data = (pcireg_t)-1;
	if (!(ba = badaddr(datap, sizeof *datap)))
		data = *datap;

	if (secondary) {
		alpha_mb();
		REGVAL(EPIC_HAXR2) = old_haxr2;
		alpha_mb();
		splx(s);
	}

#if 0
	printf("apecs_conf_read: tag 0x%lx, reg 0x%lx -> %x @@ %p%s\n", tag, reg,
	    data, datap, ba ? " (badaddr)" : "");
#endif

	return data;
}

void
apecs_conf_write(cpv, tag, offset, data)
	void *cpv;
	pcitag_t tag;
	int offset;
	pcireg_t data;
{
	struct apecs_config *acp = cpv;
	pcireg_t *datap;
	int s, secondary;
	int32_t old_haxr2;					/* XXX */

	s = 0;					/* XXX gcc -Wuninitialized */
	old_haxr2 = 0;				/* XXX gcc -Wuninitialized */

	/* secondary if bus # != 0 */
	pci_decompose_tag(&acp->ac_pc, tag, &secondary, NULL, NULL);
	if (secondary) {
		s = splhigh();
		old_haxr2 = REGVAL(EPIC_HAXR2);
		alpha_mb();
		REGVAL(EPIC_HAXR2) = old_haxr2 | 0x1;
		alpha_mb();
	}

	datap = (pcireg_t *)ALPHA_PHYS_TO_K0SEG(APECS_PCI_CONF |
	    tag << 5UL |					/* XXX */
	    (offset & ~0x03) << 5 |				/* XXX */
	    0 << 5 |						/* XXX */
	    0x3 << 3);						/* XXX */

	alpha_mb();
	*datap = data;
	alpha_mb();
	alpha_mb();

	if (secondary) {
		alpha_mb();
		REGVAL(EPIC_HAXR2) = old_haxr2;	
		alpha_mb();
		splx(s);
	}

#if 0
	printf("apecs_conf_write: tag 0x%lx, reg 0x%lx -> 0x%x @@ %p\n", tag,
	    reg, data, datap);
#endif
}
@


1.11
log
@Introduce a new pci routine, pci_conf_size(), which returns the size of a
given pcitag_t configuration address space. Currently, all pci controllers
will return the usual 0x100 bytes of PCI configuration space, but this will
eventually change on PCIe-capable controlers.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apecs_pci.c,v 1.10 2006/03/26 20:23:08 brad Exp $	*/
d132 1
a132 1
	pci_decompose_tag(&acp->ac_pc, tag, &secondary, 0, 0);
d181 1
a181 1
	pci_decompose_tag(&acp->ac_pc, tag, &secondary, 0, 0);
@


1.10
log
@Replace usage of alpha_pci_decompose_tag() with pci_decompose_tag() and
remove alpha_pci_decompose_tag().

From NetBSD

ok martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apecs_pci.c,v 1.9 2002/03/14 01:26:27 millert Exp $	*/
d51 1
d66 1
d109 6
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: apecs_pci.c,v 1.8 2001/11/06 19:53:13 miod Exp $	*/
d124 1
a124 1
	alpha_pci_decompose_tag(&acp->ac_pc, tag, &secondary, 0, 0);
d173 1
a173 1
	alpha_pci_decompose_tag(&acp->ac_pc, tag, &secondary, 0, 0);
@


1.8
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: apecs_pci.c,v 1.7 2001/02/16 08:23:39 jason Exp $	*/
d45 8
a52 8
void		apecs_attach_hook __P((struct device *, struct device *,
		    struct pcibus_attach_args *));
int		apecs_bus_maxdevs __P((void *, int));
pcitag_t	apecs_make_tag __P((void *, int, int, int));
void		apecs_decompose_tag __P((void *, pcitag_t, int *, int *,
		    int *));
pcireg_t	apecs_conf_read __P((void *, pcitag_t, int));
void		apecs_conf_write __P((void *, pcitag_t, int, pcireg_t));
@


1.8.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: apecs_pci.c,v 1.8 2001/11/06 19:53:13 miod Exp $	*/
d45 8
a52 8
void		apecs_attach_hook(struct device *, struct device *,
		    struct pcibus_attach_args *);
int		apecs_bus_maxdevs(void *, int);
pcitag_t	apecs_make_tag(void *, int, int, int);
void		apecs_decompose_tag(void *, pcitag_t, int *, int *,
		    int *);
pcireg_t	apecs_conf_read(void *, pcitag_t, int);
void		apecs_conf_write(void *, pcitag_t, int, pcireg_t);
@


1.7
log
@Bring apecs closer to current netbsd work (updated copyrights, plus
a few bug fixes I missed earlier).
@
text
@d1 1
a1 1
/*	$OpenBSD: apecs_pci.c,v 1.6 1997/01/24 19:57:34 niklas Exp $	*/
d36 1
a36 1
#include <vm/vm.h>
@


1.6
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: apecs_pci.c,v 1.5 1996/10/30 22:39:49 niklas Exp $	*/
d35 1
a119 1
#ifdef DIAGNOSTIC
a121 1
#endif
d124 1
a124 1
	pci_decompose_tag(&acp->ac_pc, tag, &secondary, 0, 0);
a168 1
#ifdef DIAGNOSTIC
a170 1
#endif
d173 1
a173 1
	pci_decompose_tag(&acp->ac_pc, tag, &secondary, 0, 0);
d187 2
d190 2
@


1.6.14.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: apecs_pci.c,v 1.7 2001/02/16 08:23:39 jason Exp $	*/
a34 1

d119 1
d122 1
d125 1
a125 1
	alpha_pci_decompose_tag(&acp->ac_pc, tag, &secondary, 0, 0);
d170 1
d173 1
d176 1
a176 1
	alpha_pci_decompose_tag(&acp->ac_pc, tag, &secondary, 0, 0);
a189 2

	alpha_mb();
a190 2
	alpha_mb();
	alpha_mb();
@


1.6.14.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 1
a36 1
#include <uvm/uvm_extern.h>
@


1.6.14.3
log
@Merge in -current from about a week ago
@
text
@d45 8
a52 8
void		apecs_attach_hook(struct device *, struct device *,
		    struct pcibus_attach_args *);
int		apecs_bus_maxdevs(void *, int);
pcitag_t	apecs_make_tag(void *, int, int, int);
void		apecs_decompose_tag(void *, pcitag_t, int *, int *,
		    int *);
pcireg_t	apecs_conf_read(void *, pcitag_t, int);
void		apecs_conf_write(void *, pcitag_t, int, pcireg_t);
@


1.5
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 2
a2 2
/*	$OpenBSD: apecs_pci.c,v 1.9 1996/10/13 03:00:02 christos Exp $	*/
/*	$NetBSD: apecs_pci.c,v 1.9 1996/10/13 03:00:02 christos Exp $	*/
d119 5
d169 5
@


1.4
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: apecs_pci.c,v 1.6 1996/04/12 06:08:09 cgd Exp $	*/
/*	$NetBSD: apecs_pci.c,v 1.6 1996/04/12 06:08:09 cgd Exp $	*/
d37 2
d124 1
a124 1
		wbflush();
d126 1
a126 1
		wbflush();
d129 1
a129 1
	datap = (pcireg_t *)phystok0seg(APECS_PCI_CONF |
d139 1
a139 1
		wbflush();
d141 1
a141 1
		wbflush();
d170 1
a170 1
		wbflush();
d172 1
a172 1
		wbflush();
d175 1
a175 1
	datap = (pcireg_t *)phystok0seg(APECS_PCI_CONF |
d183 1
a183 1
		wbflush();
d185 1
a185 1
		wbflush();
@


1.3
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.2
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: apecs_pci.c,v 1.4 1995/11/23 02:37:16 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1995 Carnegie-Mellon University.
d41 8
a48 14
pci_confreg_t	apecs_conf_read __P((void *, pci_conftag_t, pci_confoffset_t));
void		apecs_conf_write __P((void *, pci_conftag_t,
		    pci_confoffset_t, pci_confreg_t));
int		apecs_find_io __P((void *, pci_conftag_t,
		    pci_confoffset_t, pci_iooffset_t *, pci_iosize_t *));
int		apecs_find_mem __P((void *, pci_conftag_t,
		    pci_confoffset_t, pci_moffset_t *, pci_msize_t *, int *));

__const struct pci_conf_fns apecs_conf_fns = {
	apecs_conf_read,
	apecs_conf_write,
	apecs_find_io,
	apecs_find_mem,
};
d50 56
a105 1
pci_confreg_t
d108 2
a109 2
	pci_conftag_t tag;
	pci_confoffset_t offset;
d112 1
a112 1
	pci_confreg_t *datap, data;
d116 2
a117 1
	secondary = PCI_TAG_BUS(tag) != 0;
d126 1
a126 1
	datap = (pci_confreg_t *)phystok0seg(APECS_PCI_CONF |
d131 1
a131 1
	data = (pci_confreg_t)-1;
d153 3
a155 3
	pci_conftag_t tag;
	pci_confoffset_t offset;
	pci_confreg_t data;
d158 1
a158 1
	pci_confreg_t *datap;
d162 2
a163 1
	secondary = PCI_TAG_BUS(tag) != 0;
d172 1
a172 1
	datap = (pci_confreg_t *)phystok0seg(APECS_PCI_CONF |
a189 83
}

int
apecs_find_io(cpv, tag, reg, iobasep, sizep)
	void *cpv;
	pci_conftag_t tag;
	pci_confoffset_t reg;
	pci_iooffset_t *iobasep;
	pci_iosize_t *sizep;
{
	struct apecs_config *acp = cpv;
	pci_confreg_t addrdata, sizedata;
	pci_iooffset_t pci_iobase;

	if (reg < PCI_MAPREG_START || reg >= PCI_MAPREG_END || (reg & 3))
		panic("apecs_map_io: bad request");

	addrdata = PCI_CONF_READ(acp->ac_conffns, acp->ac_confarg, tag, reg);

	PCI_CONF_WRITE(acp->ac_conffns, acp->ac_confarg, tag, reg, 0xffffffff);
	sizedata = PCI_CONF_READ(acp->ac_conffns, acp->ac_confarg, tag, reg);
	PCI_CONF_WRITE(acp->ac_conffns, acp->ac_confarg, tag, reg, addrdata);

	if (PCI_MAPREG_TYPE(addrdata) == PCI_MAPREG_TYPE_MEM)
		panic("apecs_map_io: attempt to I/O map an memory region");

	if (iobasep != NULL)
		*iobasep = PCI_MAPREG_IO_ADDRESS(addrdata);
	if (sizep != NULL)
		*sizep = ~PCI_MAPREG_IO_ADDRESS(sizedata) + 1;

	return (0);
}

int
apecs_find_mem(cpv, tag, reg, paddrp, sizep, cacheablep)
	void *cpv;
	pci_conftag_t tag;
	pci_confoffset_t reg;
	pci_moffset_t *paddrp;
	pci_msize_t *sizep;
	int *cacheablep;
{
	struct apecs_config *acp = cpv;
	pci_confreg_t addrdata, sizedata;

	if (reg < PCI_MAPREG_START || reg >= PCI_MAPREG_END || (reg & 3))
		panic("apecs_map_mem: bad request");

	/*
	 * The PROM has mapped the device for us.  We take the address
	 * that's been assigned to the register, and figure out what
	 * physical and virtual addresses go with it...
	 */
	addrdata = PCI_CONF_READ(acp->ac_conffns, acp->ac_confarg, tag, reg);

	PCI_CONF_WRITE(acp->ac_conffns, acp->ac_confarg, tag, reg, 0xffffffff);
	sizedata = PCI_CONF_READ(acp->ac_conffns, acp->ac_confarg, tag, reg);
	PCI_CONF_WRITE(acp->ac_conffns, acp->ac_confarg, tag, reg, addrdata);

	if (PCI_MAPREG_TYPE(addrdata) == PCI_MAPREG_TYPE_IO)
		panic("apecs_map_mem: attempt to memory map an I/O region");

	switch (PCI_MAPREG_MEM_TYPE(addrdata)) {
	case PCI_MAPREG_MEM_TYPE_32BIT:
	case PCI_MAPREG_MEM_TYPE_32BIT_1M:
		break;
	case PCI_MAPREG_MEM_TYPE_64BIT:
/* XXX */	printf("apecs_map_mem: attempt to map 64-bit region\n");
/* XXX */	break;
	default:
		printf("apecs_map_mem: reserved mapping type\n");
		return EINVAL;
	}

	if (paddrp != NULL)
		*paddrp = PCI_MAPREG_MEM_ADDRESS(addrdata);	/* PCI addr */
	if (sizep != NULL)
		*sizep = ~PCI_MAPREG_MEM_ADDRESS(sizedata) + 1;
	if (cacheablep != NULL)
		*cacheablep = PCI_MAPREG_MEM_CACHEABLE(addrdata);

	return 0;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: apecs_pci.c,v 1.3 1995/08/03 01:16:57 cgd Exp $	*/
a35 5
#include <machine/autoconf.h>
#include <machine/pio.h>

#include <dev/isa/isavar.h>

a37 1
#include <alpha/pci/pci_chipset.h>
d39 1
d41 7
a47 19
void	 apecs_setup __P((void));
pcitag_t apecs_make_tag __P((int, int, int));
pcireg_t apecs_conf_read __P((pcitag_t, int));
void	 apecs_conf_write __P((pcitag_t, int, pcireg_t));
int	 apecs_map_io __P((pcitag_t, int, int *));
int	 apecs_map_mem __P((pcitag_t, int, vm_offset_t *, vm_offset_t *));
int	 apecs_pcidma_map __P((caddr_t, vm_size_t, vm_offset_t *));
void	 apecs_pcidma_unmap __P((caddr_t, vm_size_t, int, vm_offset_t *));

struct pci_cs_fcns apecs_p1e_cs_fcns = {	/* XXX WHAT'S DIFFERENT? */
	apecs_setup,
	apecs_make_tag,
	apecs_conf_read,
	apecs_conf_write,
	apecs_map_io,
	apecs_map_mem,
	apecs_pcidma_map,
	apecs_pcidma_unmap,
};
d49 1
a49 3
struct pci_cs_fcns apecs_p2e_cs_fcns = {	/* XXX WHAT'S DIFFERENT? */
	apecs_setup,
	apecs_make_tag,
d52 2
a53 4
	apecs_map_io,
	apecs_map_mem,
	apecs_pcidma_map,
	apecs_pcidma_unmap,
d56 19
a74 1
#define	REGVAL(r)	(*(u_int32_t *)phystok0seg(r))
d76 15
a90 65
void
apecs_setup()
{

	/*
	 * Set up PCI bus mastering DMA windows on the APECS chip.
	 *
	 * What the PROM wants:
	 *	a 1G direct-mapped window that maps the PCI address
	 *	space from 4G -> 5G to memory addresses 0 -> 1G,
	 *	set up in window two.
	 *
	 * What we want:
	 *	a 1G direct-mapped window that maps the PCI address
	 *	space from 0 -> 1G to memory addresses 0 -> 1G.
	 *
	 * Unless we satisfy the PROM, we can't live through a reboot.
	 * If we don't do what we want, I have to write more code.

	 * So:
	 *	Leave window two alone, map window 1 the way I want it.
	 *
	 * XXX verify that windows don't overlap
	 * XXX be trickier
	 * XXX magic numbers
	 */

#if 0 /* should be routine to dump regs */
	printf("old base1  was 0x%x\n", REGVAL(EPIC_PCI_BASE_1));
	printf("old mask1  was 0x%x\n", REGVAL(EPIC_PCI_MASK_1));
	printf("old tbase1 was 0x%x\n", REGVAL(EPIC_TBASE_1));

	printf("old base2  was 0x%x\n", REGVAL(EPIC_PCI_BASE_2));
	printf("old mask2  was 0x%x\n", REGVAL(EPIC_PCI_MASK_2));
	printf("old tbase2 was 0x%x\n", REGVAL(EPIC_TBASE_2));
#endif

#if 0 /* XXX STUPID PROM; MUST LEAVE WINDOW 2 ALONE.  See above */
        /* Turn off DMA window enables in PCI Base Reg 2. */
        REGVAL(EPIC_PCI_BASE_2) = 0;

        /* Set up Translated Base Register 2; translate to sybBus addr 0. */
	REGVAL(EPIC_TBASE_2) = 0;

	/* Set up PCI mask register 2; map 1G space. */
	REGVAL(EPIC_PCI_MASK_2) = 0x3ff00000;

	/* Enable window 2; from PCI address 4G, direct mapped. */
	REGVAL(EPIC_PCI_BASE_2) = 0x40080000;
#endif /* STUPID PROM */

        /* Turn off DMA window enables in PCI Base Reg 1. */
        REGVAL(EPIC_PCI_BASE_1) = 0;

        /* Set up Translated Base Register 1; translate to sybBus addr 0. */
{ /* XXX */
extern struct sgmapent *sgmap;
	REGVAL(EPIC_TBASE_1) = vtophys(sgmap) >> 1;
} /* XXX */

	/* Set up PCI mask register 1; map 8MB space. */
	REGVAL(EPIC_PCI_MASK_1) = 0x00700000;

	/* Enable window 1; from PCI address 8MB, direct mapped. */
	REGVAL(EPIC_PCI_BASE_1) = 0x008c0000;
a91 4
	/*
	 * Should set up HAXR1 and HAXR2...  However, the PROM again
	 * wants them where they're set to be...
	 */
d93 2
a94 3
	printf("old haxr0  was 0x%x\n", REGVAL(EPIC_HAXR0));
	printf("old haxr1  was 0x%x\n", REGVAL(EPIC_HAXR1));
	printf("old haxr2  was 0x%x\n", REGVAL(EPIC_HAXR2));
d97 1
a97 10
#if 0 /* XXX STUPID PROM */
	/* HAXR0 is wired zero; no op. */
	REGVAL(EPIC_HAXR0) = 0;

	/* HAXR1: maps PCI memory space above 16M.  16M -> 2G+16M. */
	REGVAL(EPIC_HAXR1) = 0x80000000;

	/* HAXR2: maps PCI I/O space above 256K.  256K -> 256k. */
	REGVAL(EPIC_HAXR2) = 0;
#endif
d100 19
a118 27
pcitag_t
apecs_make_tag(bus, device, function)
	int bus, device, function;
{
	pcitag_t tag;

	if (bus >= 256 || device >= 32 || function >= 8)
		panic("apecs_make_tag: bad request");

	tag = (bus << 21) | (device << 16) | (function << 13);
#if 0
	printf("apecs_make_tag: bus %d, device %d, function %d -> 0x%lx\n", bus,
	    device, function, tag);
#endif
	return tag;
}

pcireg_t
apecs_conf_read(tag, offset)
	pcitag_t tag;
	int offset;					/* XXX */
{
	pcireg_t *datap, data;
	int reg = offset >> 2;				/* XXX */

	if ((tag & 0x1fe00000) != 0) {
		panic("apecs_conf_read: bus != 0?");
a119 1
	/* XXX FILL IN HAXR2 bits. */
d121 6
a126 11
	datap = (pcireg_t *)
	    phystok0seg(APECS_PCI_CONF | tag | reg << 7 | 0 << 5 | 0x3 << 3);
	if (badaddr(datap, sizeof *datap))
		return ((pcireg_t)-1);
	data = *datap;
#if 0
	printf("apecs_conf_read: tag 0x%lx, reg 0x%lx -> %x @@ %p\n", tag, reg,
	    data, datap);
#endif
	return data;
}
d128 5
a132 11
void
apecs_conf_write(tag, offset, data)
	pcitag_t tag;
	int offset;					/* XXX */
	pcireg_t data;
{
	pcireg_t *datap;
	int reg = offset >> 2;				/* XXX */

	if ((tag & 0x1fe00000) != 0) {
		panic("apecs_conf_read: bus != 0?");
a133 1
	/* XXX FILL IN HAXR2 bits. */
a134 2
	datap = (pcireg_t *)
	    phystok0seg(APECS_PCI_CONF | tag | reg << 7 | 0 << 5 | 0x3 << 3);
a138 1
	*datap = data;
d142 10
a151 7
apecs_map_io(tag, reg, iobasep)
	pcitag_t tag;
	int reg;
	int *iobasep;
{
	pcireg_t data;
	int pci_iobase;
d153 1
a153 1
	if (reg < PCI_MAP_REG_START || reg >= PCI_MAP_REG_END || (reg & 3))
d156 5
a160 1
	data = pci_conf_read(tag, reg);
d162 1
a162 1
	if ((data & PCI_MAP_IO) == 0)
d165 4
a168 2
	/* figure out where it was mapped... */
	pci_iobase = data & PCI_MAP_MEMORY_ADDRESS_MASK; /* PCI I/O addr */
d170 1
a170 1
	return (pci_iobase);
d174 7
a180 4
apecs_map_mem(tag, reg, vap, pap)
	pcitag_t tag;
	int reg;
	vm_offset_t *vap, *pap;
d182 2
a183 2
	pcireg_t data;
	vm_offset_t pci_pa, sb_pa;
d185 1
a185 1
	if (reg < PCI_MAP_REG_START || reg >= PCI_MAP_REG_END || (reg & 3))
d189 3
a191 8
	 * "HERE WE GO AGAIN!!!"
	 *
	 * The PROM has already mapped the device for us.  The PROM is
	 * our friend.  We wouldn't want to make the PROM unhappy.
	 *
	 * So, we take the address that's been assigned (already) to
	 * the register, and figure out what physical and virtual addresses
	 * go with it...
d193 5
a197 6
	/*
	 * Section 6.2.5.1, `Address Maps', says that a device which wants 2^n
	 * bytes of memory will hardwire the bottom n bits of the address to 0.
	 * As recommended, we write all 1s and see what we get back.
	 */
	data = pci_conf_read(tag, reg);
d199 1
a199 1
	if (data & PCI_MAP_IO)
d202 3
a204 2
	switch (data & PCI_MAP_MEMORY_TYPE_MASK) {
	case PCI_MAP_MEMORY_TYPE_32BIT:
d206 3
a208 6
	case PCI_MAP_MEMORY_TYPE_32BIT_1M:
		printf("apecs_map_mem: attempt to map restricted 32-bit region\n");
		return EOPNOTSUPP;
	case PCI_MAP_MEMORY_TYPE_64BIT:
		printf("apecs_map_mem: attempt to map 64-bit region\n");
		return EOPNOTSUPP;
d214 6
a219 20
	/* figure out where it was mapped... */
	pci_pa = data & PCI_MAP_MEMORY_ADDRESS_MASK;	/* PCI bus address */

	/* calcluate sysBus address -- should be a better way to get space */
	if (data & PCI_MAP_MEMORY_CACHABLE) {
		/* Dense space */
		sb_pa = (pci_pa & 0xffffffff) | (3L << 32);	/* XXX */
	} else {
		/* Sparse space */
		sb_pa = ((pci_pa & 0x7ffffff) << 5) | (2L << 32); /* XXX */
	}

	/* and tell the driver. */
	*vap = phystok0seg(sb_pa);
	*pap = pci_pa;

#if 0
	printf("pci_map_mem: memory mapped at 0x%lx\n", *pap);
	printf("pci_map_mem: virtual 0x%lx\n", *vap);
#endif
a221 39
}

int
apecs_pcidma_map(addr, size, mappings)
	caddr_t addr;
	vm_size_t size;
	vm_offset_t *mappings;
{
	vm_offset_t va;
	long todo;
	int i;

	i = 0;
	va = (vm_offset_t)addr;
	todo = size;

	while (todo > 0) {
		mappings[i] = vtophys(va) | 0x40000000;
#if 0
		printf("a_pd_m mapping %d: %lx -> %lx -> %lx\n", i, va,
		    vtophys(va), mappings[i]);
#endif
		i++;
		todo -= PAGE_SIZE - (va - trunc_page(va));
		va += PAGE_SIZE - (va - trunc_page(va));
	}
	return (i);
}

void
apecs_pcidma_unmap(addr, size, nmappings, mappings)
	caddr_t addr;
	vm_size_t size;
	int nmappings;
	vm_offset_t *mappings;
{

	/* maybe XXX if diagnostic, check that mapping happened. */
	printf("apecs_pcidma_unmap: nada\n");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
