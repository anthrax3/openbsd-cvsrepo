head	1.7;
access;
symbols
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.36
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.32
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.28
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.30
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.22
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.26
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.24
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.20
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.18
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.16
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.14
	OPENBSD_5_0:1.7.0.12
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.10
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.8
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.4
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.5.0.8
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.3.0.18
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.16
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.14
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.12
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.10
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.8
	OPENBSD_3_4_BASE:1.3
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.2.0.2
	UBC_BASE:1.2
	OPENBSD_3_0:1.1.0.6
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9:1.1.0.4
	OPENBSD_2_9_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.7
date	2009.02.01.14.34.00;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.26.05.42.08;	author ray;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.04.21.20.40;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.20.01.00.58;	author martin;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.27;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.06.19.53.13;	author miod;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2001.02.16.05.17.31;	author jason;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.04.18.16.01.06;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.11.13.21.00.49;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	;

1.2.2.1
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Remove unused _pfthresh member from struct alpha_bus_dma_tag.
@
text
@/* $OpenBSD: apecs_dma.c,v 1.6 2008/06/26 05:42:08 ray Exp $ */
/* $NetBSD: apecs_dma.c,v 1.13 2000/06/29 08:58:45 mrg Exp $ */

/*-
 * Copyright (c) 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * XXX - We should define this before including bus.h, but since other stuff
 *       pulls in bus.h we must do this here.
 */
#define _ALPHA_BUS_DMA_PRIVATE

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <uvm/uvm_extern.h>

#include <machine/bus.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <alpha/pci/apecsreg.h>
#include <alpha/pci/apecsvar.h>

bus_dma_tag_t apecs_dma_get_tag(bus_dma_tag_t, alpha_bus_t);

int	apecs_bus_dmamap_load_sgmap(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);

int	apecs_bus_dmamap_load_mbuf_sgmap(bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int);

int	apecs_bus_dmamap_load_uio_sgmap(bus_dma_tag_t, bus_dmamap_t,
	    struct uio *, int);

int	apecs_bus_dmamap_load_raw_sgmap(bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);

void	apecs_bus_dmamap_unload_sgmap(bus_dma_tag_t, bus_dmamap_t);

/*
 * Direct-mapped window: 1G at 1G
 */
#define	APECS_DIRECT_MAPPED_BASE (1*1024*1024*1024)
#define	APECS_DIRECT_MAPPED_SIZE (1*1024*1024*1024)

/*
 * SGMAP window: 8M at 8M
 */
#define	APECS_SGMAP_MAPPED_BASE	(8*1024*1024)
#define	APECS_SGMAP_MAPPED_SIZE	(8*1024*1024)

/*
 * Macro to flush APECS scatter/gather TLB.
 */
#define	APECS_TLB_INVALIDATE() \
do { \
	alpha_mb(); \
	REGVAL(EPIC_TBIA) = 0; \
	alpha_mb(); \
} while (0)

void
apecs_dma_init(acp)
	struct apecs_config *acp;
{
	bus_addr_t tbase;
	bus_dma_tag_t t;

	/*
	 * Initialize the DMA tag used for direct-mapped DMA.
	 */
	t = &acp->ac_dmat_direct;
	t->_cookie = acp;
	t->_wbase = APECS_DIRECT_MAPPED_BASE;
	t->_wsize = APECS_DIRECT_MAPPED_SIZE;
	t->_next_window = NULL;
	t->_boundary = 0;
	t->_sgmap = NULL;
	t->_get_tag = apecs_dma_get_tag;
	t->_dmamap_create = _bus_dmamap_create;
	t->_dmamap_destroy = _bus_dmamap_destroy;
	t->_dmamap_load = _bus_dmamap_load_direct;
	t->_dmamap_load_mbuf = _bus_dmamap_load_mbuf_direct;
	t->_dmamap_load_uio = _bus_dmamap_load_uio_direct;
	t->_dmamap_load_raw = _bus_dmamap_load_raw_direct;
	t->_dmamap_unload = _bus_dmamap_unload;
	t->_dmamap_sync = _bus_dmamap_sync;

	t->_dmamem_alloc = _bus_dmamem_alloc;
	t->_dmamem_free = _bus_dmamem_free;
	t->_dmamem_map = _bus_dmamem_map;
	t->_dmamem_unmap = _bus_dmamem_unmap;
	t->_dmamem_mmap = _bus_dmamem_mmap;

	/*
	 * Initialize the DMA tag used for sgmap-mapped DMA.
	 */
	t = &acp->ac_dmat_sgmap;
	t->_cookie = acp;
	t->_wbase = APECS_SGMAP_MAPPED_BASE;
	t->_wsize = APECS_SGMAP_MAPPED_SIZE;
	t->_next_window = NULL;
	t->_boundary = 0;
	t->_sgmap = &acp->ac_sgmap;
	t->_get_tag = apecs_dma_get_tag;
	t->_dmamap_create = alpha_sgmap_dmamap_create;
	t->_dmamap_destroy = alpha_sgmap_dmamap_destroy;
	t->_dmamap_load = apecs_bus_dmamap_load_sgmap;
	t->_dmamap_load_mbuf = apecs_bus_dmamap_load_mbuf_sgmap;
	t->_dmamap_load_uio = apecs_bus_dmamap_load_uio_sgmap;
	t->_dmamap_load_raw = apecs_bus_dmamap_load_raw_sgmap;
	t->_dmamap_unload = apecs_bus_dmamap_unload_sgmap;
	t->_dmamap_sync = _bus_dmamap_sync;

	t->_dmamem_alloc = _bus_dmamem_alloc;
	t->_dmamem_free = _bus_dmamem_free;
	t->_dmamem_map = _bus_dmamem_map;
	t->_dmamem_unmap = _bus_dmamem_unmap;
	t->_dmamem_mmap = _bus_dmamem_mmap;

	/*
	 * The firmware has set up window 2 as a 1G direct-mapped DMA
	 * window beginning at 1G.  We leave it alone.  Disable
	 * window 1.
	 */
	REGVAL(EPIC_PCI_BASE_1) = 0;
	alpha_mb();

	/*
	 * Initialize the SGMAP.
	 */
	alpha_sgmap_init(t, &acp->ac_sgmap, "apecs_sgmap",
	    APECS_SGMAP_MAPPED_BASE, 0, APECS_SGMAP_MAPPED_SIZE,
	    sizeof(u_int64_t), NULL, 0);

	/*
	 * Set up window 1 as an 8MB SGMAP-mapped window
	 * starting at 8MB.
	 */
	REGVAL(EPIC_PCI_BASE_1) = APECS_SGMAP_MAPPED_BASE |
	    EPIC_PCI_BASE_SGEN | EPIC_PCI_BASE_WENB;
	alpha_mb();

	REGVAL(EPIC_PCI_MASK_1) = EPIC_PCI_MASK_8M;
	alpha_mb();

	tbase = acp->ac_sgmap.aps_ptpa >> EPIC_TBASE_SHIFT;
	if ((tbase & EPIC_TBASE_T_BASE) != tbase)
		panic("apecs_dma_init: bad page table address");
	REGVAL(EPIC_TBASE_1) = tbase;
	alpha_mb();

	APECS_TLB_INVALIDATE();

	/* XXX XXX BEGIN XXX XXX */
	{							/* XXX */
		extern paddr_t alpha_XXX_dmamap_or;		/* XXX */
		alpha_XXX_dmamap_or = APECS_DIRECT_MAPPED_BASE;	/* XXX */
	}							/* XXX */
	/* XXX XXX END XXX XXX */
}

/*
 * Return the bus dma tag to be used for the specified bus type.
 * INTERNAL USE ONLY!
 */
bus_dma_tag_t
apecs_dma_get_tag(t, bustype)
	bus_dma_tag_t t;
	alpha_bus_t bustype;
{
	struct apecs_config *acp = t->_cookie;

	switch (bustype) {
	case ALPHA_BUS_PCI:
	case ALPHA_BUS_EISA:
		/*
		 * Systems with an APECS can only support 1G
		 * of memory, so we use the direct-mapped window
		 * on busses that have 32-bit DMA.
		 */
		return (&acp->ac_dmat_direct);

	case ALPHA_BUS_ISA:
		/*
		 * ISA doesn't have enough address bits to use
		 * the direct-mapped DMA window, so we must use
		 * SGMAPs.
		 */
		return (&acp->ac_dmat_sgmap);

	default:
		panic("apecs_dma_get_tag: shouldn't be here, really...");
	}
}

/*
 * Load an APECS SGMAP-mapped DMA map with a linear buffer.
 */
int
apecs_bus_dmamap_load_sgmap(t, map, buf, buflen, p, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	void *buf;
	bus_size_t buflen;
	struct proc *p;
	int flags;
{
	int error;

	error = pci_sgmap_pte64_load(t, map, buf, buflen, p, flags,
	    t->_sgmap);
	if (error == 0)
		APECS_TLB_INVALIDATE();

	return (error);
}

/*
 * Load an APECS SGMAP-mapped DMA map with an mbuf chain.
 */
int
apecs_bus_dmamap_load_mbuf_sgmap(t, map, m, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	struct mbuf *m;
	int flags;
{
	int error;

	error = pci_sgmap_pte64_load_mbuf(t, map, m, flags, t->_sgmap);
	if (error == 0)
		APECS_TLB_INVALIDATE();

	return (error);
}

/*
 * Load an APECS SGMAP-mapped DMA map with a uio.
 */
int
apecs_bus_dmamap_load_uio_sgmap(t, map, uio, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	struct uio *uio;
	int flags;
{
	int error;

	error = pci_sgmap_pte64_load_uio(t, map, uio, flags, t->_sgmap);
	if (error == 0)
		APECS_TLB_INVALIDATE();

	return (error);
}

/*
 * Load an APECS SGMAP-mapped DMA map with raw memory.
 */
int
apecs_bus_dmamap_load_raw_sgmap(t, map, segs, nsegs, size, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	bus_dma_segment_t *segs;
	int nsegs;
	bus_size_t size;
	int flags;
{
	int error;

	error = pci_sgmap_pte64_load_raw(t, map, segs, nsegs, size, flags,
	    t->_sgmap);
	if (error == 0)
		APECS_TLB_INVALIDATE();

	return (error);
}

/*
 * Unload an APECS DMA map.
 */
void
apecs_bus_dmamap_unload_sgmap(t, map)
	bus_dma_tag_t t;
	bus_dmamap_t map;
{

	/*
	 * Invalidate any SGMAP page table entries used by this
	 * mapping.
	 */
	pci_sgmap_pte64_unload(t, map, t->_sgmap);
	APECS_TLB_INVALIDATE();

	/*
	 * Do the generic bits of the unload.
	 */
	_bus_dmamap_unload(t, map);
}
@


1.6
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: apecs_dma.c,v 1.5 2006/04/04 21:20:40 brad Exp $ */
a82 3
/* APECS has a 256-byte out-bound DMA prefetch threshold. */
#define	APECS_SGMAP_PFTHRESH	256

a135 1
	t->_pfthresh = APECS_SGMAP_PFTHRESH;
@


1.5
log
@Add a `prefetch threshold' member to the bus_dma_tag_t, so that
eventually we can determine whether or not to allocate a spill
page on a per-mapping basis.

From NetBSD

ok martin@@
@
text
@d1 1
a1 1
/* $OpenBSD: apecs_dma.c,v 1.4 2006/03/20 01:00:58 martin Exp $ */
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.4
log
@factorize SGMAP-mapped DMA map creation and destroy code

ok miod@@, additional testing jsg@@

from NetBSD
@
text
@d1 1
a1 1
/* $OpenBSD: apecs_dma.c,v 1.3 2002/03/14 01:26:27 millert Exp $ */
d90 3
d146 1
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: apecs_dma.c,v 1.2 2001/11/06 19:53:13 miod Exp $ */
a63 5
int	apecs_bus_dmamap_create_sgmap(bus_dma_tag_t, bus_size_t, int,
	    bus_size_t, bus_size_t, int, bus_dmamap_t *);

void	apecs_bus_dmamap_destroy_sgmap(bus_dma_tag_t, bus_dmamap_t);

d144 2
a145 2
	t->_dmamap_create = apecs_bus_dmamap_create_sgmap;
	t->_dmamap_destroy = apecs_bus_dmamap_destroy_sgmap;
a336 49
}

/*
 * Create a APECS SGMAP-mapped DMA map.
 */
int
apecs_bus_dmamap_create_sgmap(t, size, nsegments, maxsegsz, boundary,
    flags, dmamp)
	bus_dma_tag_t t;
	bus_size_t size;  
	int nsegments;
	bus_size_t maxsegsz;
	bus_size_t boundary;
	int flags; 
	bus_dmamap_t *dmamp;
{
	bus_dmamap_t map;
	int error;

	error = _bus_dmamap_create(t, size, nsegments, maxsegsz,
	    boundary, flags, dmamp);
	if (error)
		return (error);

	map = *dmamp;

	if (flags & BUS_DMA_ALLOCNOW) {
		error = alpha_sgmap_alloc(map, round_page(size),
		    t->_sgmap, flags);
		if (error)
			apecs_bus_dmamap_destroy_sgmap(t, map);
	}

	return (error);
}

/*
 * Destroy a APECS SGMAP-mapped DMA map.
 */
void
apecs_bus_dmamap_destroy_sgmap(t, map)
	bus_dma_tag_t t;
	bus_dmamap_t map;
{

	if (map->_dm_flags & DMAMAP_HAS_SGMAP)
		alpha_sgmap_free(map, t->_sgmap);

	_bus_dmamap_destroy(t, map);
@


1.2
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/* $OpenBSD: apecs_dma.c,v 1.1 2001/02/16 05:17:31 jason Exp $ */
d62 1
a62 1
bus_dma_tag_t apecs_dma_get_tag __P((bus_dma_tag_t, alpha_bus_t));
d64 2
a65 2
int	apecs_bus_dmamap_create_sgmap __P((bus_dma_tag_t, bus_size_t, int,
	    bus_size_t, bus_size_t, int, bus_dmamap_t *));
d67 1
a67 1
void	apecs_bus_dmamap_destroy_sgmap __P((bus_dma_tag_t, bus_dmamap_t));
d69 2
a70 2
int	apecs_bus_dmamap_load_sgmap __P((bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int));
d72 2
a73 2
int	apecs_bus_dmamap_load_mbuf_sgmap __P((bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int));
d75 2
a76 2
int	apecs_bus_dmamap_load_uio_sgmap __P((bus_dma_tag_t, bus_dmamap_t,
	    struct uio *, int));
d78 2
a79 2
int	apecs_bus_dmamap_load_raw_sgmap __P((bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int));
d81 1
a81 1
void	apecs_bus_dmamap_unload_sgmap __P((bus_dma_tag_t, bus_dmamap_t));
@


1.2.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: apecs_dma.c,v 1.2 2001/11/06 19:53:13 miod Exp $ */
d62 1
a62 1
bus_dma_tag_t apecs_dma_get_tag(bus_dma_tag_t, alpha_bus_t);
d64 2
a65 2
int	apecs_bus_dmamap_create_sgmap(bus_dma_tag_t, bus_size_t, int,
	    bus_size_t, bus_size_t, int, bus_dmamap_t *);
d67 1
a67 1
void	apecs_bus_dmamap_destroy_sgmap(bus_dma_tag_t, bus_dmamap_t);
d69 2
a70 2
int	apecs_bus_dmamap_load_sgmap(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);
d72 2
a73 2
int	apecs_bus_dmamap_load_mbuf_sgmap(bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int);
d75 2
a76 2
int	apecs_bus_dmamap_load_uio_sgmap(bus_dma_tag_t, bus_dmamap_t,
	    struct uio *, int);
d78 2
a79 2
int	apecs_bus_dmamap_load_raw_sgmap(bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);
d81 1
a81 1
void	apecs_bus_dmamap_unload_sgmap(bus_dma_tag_t, bus_dmamap_t);
@


1.1
log
@bring in netbsd bus_dma stuff for lca and apecs busses
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a52 1
#include <vm/vm.h>
@


1.1.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/* $OpenBSD: apecs_dma.c,v 1.1 2001/02/16 05:17:31 jason Exp $ */
@


1.1.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d53 1
@


1.1.2.3
log
@Merge in -current from about a week ago
@
text
@d62 1
a62 1
bus_dma_tag_t apecs_dma_get_tag(bus_dma_tag_t, alpha_bus_t);
d64 2
a65 2
int	apecs_bus_dmamap_create_sgmap(bus_dma_tag_t, bus_size_t, int,
	    bus_size_t, bus_size_t, int, bus_dmamap_t *);
d67 1
a67 1
void	apecs_bus_dmamap_destroy_sgmap(bus_dma_tag_t, bus_dmamap_t);
d69 2
a70 2
int	apecs_bus_dmamap_load_sgmap(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);
d72 2
a73 2
int	apecs_bus_dmamap_load_mbuf_sgmap(bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int);
d75 2
a76 2
int	apecs_bus_dmamap_load_uio_sgmap(bus_dma_tag_t, bus_dmamap_t,
	    struct uio *, int);
d78 2
a79 2
int	apecs_bus_dmamap_load_raw_sgmap(bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);
d81 1
a81 1
void	apecs_bus_dmamap_unload_sgmap(bus_dma_tag_t, bus_dmamap_t);
@


