head	1.16;
access;
symbols
	OPENBSD_6_2:1.16.0.10
	OPENBSD_6_2_BASE:1.16
	OPENBSD_6_1:1.16.0.12
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.8
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.4
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.15.0.22
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.20
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.16
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.14
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.12
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.10
	OPENBSD_5_0:1.15.0.8
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.4
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.13.0.10
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.8
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.6
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.4
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.9.0.6
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.6.0.2
	UBC_BASE:1.6
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.16
date	2014.12.24.18.46.14;	author miod;	state Exp;
branches;
next	1.15;
commitid	Tur8zmifqCnJgGsd;

1.15
date	2009.10.02.18.01.47;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2009.03.30.21.43.13;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.14.17.36.12;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.16.22.32.44;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.13.20.10.49;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.13.01.16.11;	author martin;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.18.02.18.26;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.02.17.25.21;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.27;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.12.14.00.44.59;	author nate;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.11.04.23.12.46;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.26.21.13.44;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.26.20.46.18;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.14.22.19.11;	author mjacob;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.11.16.04.50.18;	author ericj;	state Exp;
branches;
next	;

1.2.2.1
date	2001.04.18.16.01.32;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2001.07.04.10.14.47;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2001.11.13.21.00.49;	author niklas;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2002.03.06.00.55.15;	author niklas;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2004.02.19.09.59.34;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	;


desc
@@


1.16
log
@tsciic(4): i2c controller onboard Tsunami and Titan chipsets, gives access to
the fan sensors on systems without RMC. From NetBSD, ok deraadt@@
@
text
@/* $OpenBSD: tsc.c,v 1.15 2009/10/02 18:01:47 miod Exp $ */
/* $NetBSD: tsc.c,v 1.3 2000/06/25 19:17:40 thorpej Exp $ */

/*-
 * Copyright (c) 1999 by Ross Harvey.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ross Harvey.
 * 4. The name of Ross Harvey may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY ROSS HARVEY ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURP0SE
 * ARE DISCLAIMED.  IN NO EVENT SHALL ROSS HARVEY BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <machine/autoconf.h>
#include <machine/rpb.h>

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <alpha/pci/tsreg.h>
#include <alpha/pci/tsvar.h>

#ifdef DEC_6600
#include <alpha/pci/pci_6600.h>
#endif

#define tsc() { Generate ctags(1) key. }

int	tscmatch(struct device *, void *, void *);
void	tscattach(struct device *, struct device *, void *);

struct cfattach tsc_ca = {
	sizeof(struct device), tscmatch, tscattach,
};

struct cfdriver tsc_cd = {
        NULL, "tsc", DV_DULL,
};

struct tsp_config tsp_configuration[4];

static int tscprint(void *, const char *pnp);

int	tspmatch(struct device *, void *, void *);
void	tspattach(struct device *, struct device *, void *);

struct cfattach tsp_ca = {
	sizeof(struct tsp_softc), tspmatch, tspattach,
};

struct cfdriver tsp_cd = {
        NULL, "tsp", DV_DULL,
};


static int tspprint(void *, const char *pnp);

#if	0
static int tsp_bus_get_window(int, int,
	struct alpha_bus_space_translation *);
#endif

/* There can be only one */
static int tscfound;

/* Which hose is the display console connected to? */
int tsp_console_hose;

int
tscmatch(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct mainbus_attach_args *ma = aux;

	switch (cputype) {
	case ST_DEC_6600:
	case ST_DEC_TITAN:
		return strcmp(ma->ma_name, tsc_cd.cd_name) == 0 && !tscfound;
	default:
		return 0;
	}
}

void
tscattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	int i;
	int nbus;
	u_int64_t csc, aar;
	struct tsp_attach_args tsp;
	struct mainbus_attach_args *ma = aux;
	int titan = cputype == ST_DEC_TITAN;

	tscfound = 1;

	csc = LDQP(TS_C_CSC);

	nbus = 1 + (CSC_BC(csc) >= 2);
	printf(": 2127%c Chipset, Cchip rev %d\n"
	       "%s%d: %c Dchips, %d memory bus%s of %d bytes\n",
	    titan ? '4' : '2', (int)MISC_REV(LDQP(TS_C_MISC)),
	    ma->ma_name, ma->ma_slot, "2448"[CSC_BC(csc)],
	    nbus, nbus > 1 ? "es" : "", 16 + 16 * ((csc & CSC_AW) != 0));
	printf("%s%d: arrays present: ", ma->ma_name, ma->ma_slot);
	for(i = 0; i < 4; ++i) {
		aar = LDQP(TS_C_AAR0 + i * TS_STEP);
		printf("%s%dMB%s", i ? ", " : "", (8 << AAR_ASIZ(aar)) & ~0xf,
		    aar & AAR_SPLIT ? " (split)" : "");
	}
	printf(", Dchip 0 rev %d\n", (int)LDQP(TS_D_DREV) & 0xf);

	tsp.tsp_name = "tsp";
	tsp.tsp_slot = 0;
	config_found(self, &tsp, tscprint);
	if (titan) {
		tsp.tsp_slot += 2;
		config_found(self, &tsp, tscprint);
	}

	if (csc & CSC_P1P) {
		tsp.tsp_slot = 1;
		config_found(self, &tsp, tscprint);
		if (titan) {
			tsp.tsp_slot += 2;
			config_found(self, &tsp, tscprint);
		}
	}

	tsp.tsp_name = "tsciic";
	tsp.tsp_slot = -1;
	config_found(self, &tsp, tscprint);
}

static int
tscprint(aux, p)
	void *aux;
	const char *p;
{
	struct tsp_attach_args *tsp = aux;

	if (p)
		printf("%s at %s", tsp->tsp_name, p);
	if (tsp->tsp_slot >= 0)
		printf(" hose %d", tsp->tsp_slot);
	return UNCONF;
}

#define tsp() { Generate ctags(1) key. }

int
tspmatch(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct tsp_attach_args *t = aux;

	switch (cputype) {
	case ST_DEC_6600:
	case ST_DEC_TITAN:
		return strcmp(t->tsp_name, tsp_cd.cd_name) == 0;
	default:
		return 0;
	}
}

void
tspattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct pcibus_attach_args pba;
	struct tsp_attach_args *t = aux;
	struct tsp_config *pcp;

	printf("\n");
	pcp = tsp_init(1, t->tsp_slot);

	tsp_dma_init(self, pcp);
	
	/*
	 * Do PCI memory initialization that needs to be deferred until
	 * malloc is safe.  On the Tsunami, we need to do this after
	 * DMA is initialized, as well.
	 */
	tsp_bus_mem_init2(pcp);

	pci_6600_pickintr(pcp);

	bzero(&pba, sizeof(pba));
	pba.pba_busname = "pci";
	pba.pba_iot = &pcp->pc_iot;
	pba.pba_memt = &pcp->pc_memt;
	pba.pba_dmat =
	    alphabus_dma_get_tag(&pcp->pc_dmat_direct, ALPHA_BUS_PCI);
	pba.pba_pc = &pcp->pc_pc;
	pba.pba_domain = pci_ndomains++;
	pba.pba_bus = 0;
#ifdef	notyet
	pba.pba_flags = PCI_FLAGS_IO_ENABLED | PCI_FLAGS_MEM_ENABLED |
	    PCI_FLAGS_MRL_OKAY | PCI_FLAGS_MRM_OKAY | PCI_FLAGS_MWI_OKAY;
#endif
	config_found(self, &pba, tspprint);
}

struct tsp_config *
tsp_init(mallocsafe, n)
	int mallocsafe;
	int n;	/* hose number */
{
	struct tsp_config *pcp;
	int titan = cputype == ST_DEC_TITAN;

	KASSERT(n >= 0 && n < nitems(tsp_configuration));
	pcp = &tsp_configuration[n];
	pcp->pc_pslot = n;
	pcp->pc_iobase = TS_Pn(n, 0);
	pcp->pc_csr = S_PAGE(TS_Pn(n & 1, P_CSRBASE));
	if (n & 2) {
		/* `A' port of PA Chip */
		pcp->pc_csr++;
	}
	if (titan) {
		/* same address on G and A ports */
		pcp->pc_tlbia = &pcp->pc_csr->port.g.tsp_tlbia.tsg_r;
	} else {
		pcp->pc_tlbia = &pcp->pc_csr->port.p.tsp_tlbia.tsg_r;
	}
	snprintf(pcp->pc_io_ex_name, sizeof pcp->pc_io_ex_name,
	    "tsp%d_bus_io", n);
	snprintf(pcp->pc_mem_ex_name, sizeof pcp->pc_mem_ex_name,
	    "tsp%d_bus_mem", n);
	    
	if (!pcp->pc_initted) {
		tsp_bus_io_init(&pcp->pc_iot, pcp);
		tsp_bus_mem_init(&pcp->pc_memt, pcp);
#if 0
		alpha_bus_window_count[ALPHA_BUS_TYPE_PCI_IO] = 1;
		alpha_bus_window_count[ALPHA_BUS_TYPE_PCI_MEM] = 1;

		alpha_bus_get_window = tsp_bus_get_window;
#endif 
	}
	pcp->pc_mallocsafe = mallocsafe;
	tsp_pci_init(&pcp->pc_pc, pcp);
	alpha_pci_chipset = &pcp->pc_pc;
	if (titan)
		alpha_pci_chipset->pc_name = "titan";
	else
		alpha_pci_chipset->pc_name = "tsunami";
	alpha_pci_chipset->pc_mem = P_PCI_MEM;
	alpha_pci_chipset->pc_ports = P_PCI_IO;
	alpha_pci_chipset->pc_hae_mask = 0;
	alpha_pci_chipset->pc_dense = TS_P0(0);	/* XXX */
	alpha_pci_chipset->pc_bwx = 1;
	pcp->pc_initted = 1;
	return pcp;
}

static int
tspprint(aux, p)
	void *aux;
	const char *p;
{
	register struct pcibus_attach_args *pci = aux;

	if (p)
		printf("%s at %s", pci->pba_busname, p);
	printf(" bus %d", pci->pba_bus);
	return UNCONF;
}

#if 0
static int
tsp_bus_get_window(type, window, abst)
	int type, window;
	struct alpha_bus_space_translation *abst;
{
	struct tsp_config *tsp = &tsp_configuration[tsp_console_hose];
	bus_space_tag_t st;
	int error;

	switch (type) {
	case ALPHA_BUS_TYPE_PCI_IO:
		st = &tsp->pc_iot;
		break;

	case ALPHA_BUS_TYPE_PCI_MEM:
		st = &tsp->pc_memt;
		break;

	default:
		panic("tsp_bus_get_window");
	}

	error = alpha_bus_space_get_window(st, window, abst);
	if (error)
		return (error);

	abst->abst_sys_start = TS_PHYSADDR(abst->abst_sys_start);
	abst->abst_sys_end = TS_PHYSADDR(abst->abst_sys_end);

	return (0);
}
#endif
@


1.15
log
@Support for DS15/DS25/ES45 (Titan) alpha models (rpb family 38). These systems
are very close to the Tsunami systems (rpb family 34) and share the existing
Tsunami code; the tsc(4) Tsunami controller code is extended to handle the
Titan differences, except for the Titan AGP GART which is left unsupported
for now.

Tested to not cause regressions on DS20 (deraadt@@) and ES40 (miod@@).
Titan support tested by Sergey Prysiazhnyi on DS25, many thanks for your time!
@
text
@d1 1
a1 1
/* $OpenBSD: tsc.c,v 1.14 2009/03/30 21:43:13 kettenis Exp $ */
d159 4
d174 2
a175 1
	printf(" hose %d", tsp->tsp_slot);
@


1.14
log
@bzero pci attach args
@
text
@d1 1
a1 1
/* $OpenBSD: tsc.c,v 1.13 2006/12/14 17:36:12 kettenis Exp $ */
d67 1
a67 1
struct tsp_config tsp_configuration[2];
d104 7
a110 3
	return cputype == ST_DEC_6600
	    && strcmp(ma->ma_name, tsc_cd.cd_name) == 0
	    && !tscfound;
d113 2
a114 1
void tscattach(parent, self, aux)
d123 1
d130 5
a134 5
	printf(": 21272 Chipset, Cchip rev %d\n"
		"%s%d: %c Dchips, %d memory bus%s of %d bytes\n",
		(int)MISC_REV(LDQP(TS_C_MISC)),
		ma->ma_name, ma->ma_slot, "2448"[CSC_BC(csc)],
		nbus, nbus > 1 ? "es" : "", 16 + 16 * ((csc & CSC_AW) != 0));
a142 1
	bzero(&tsp, sizeof tsp);
d144 6
a149 1
	config_found(self, &tsp, NULL);
d151 2
a152 2
	if(LDQP(TS_C_CSC) & CSC_P1P) {
		++tsp.tsp_slot;
d154 4
d166 1
a166 1
	register struct tsp_attach_args *tsp = aux;
d168 3
a170 2
	if(p)
		printf("%s%d at %s", tsp->tsp_name, tsp->tsp_slot, p);
d184 7
a190 2
	return  cputype == ST_DEC_6600
	    && strcmp(t->tsp_name, tsp_cd.cd_name) == 0;
d205 1
a205 1
	tsp_dma_init(pcp);
d235 1
a235 1
	int n;	/* Pchip number */
d238 1
d240 1
a240 1
	KASSERT((n | 1) == 1);
d244 11
a254 1
	pcp->pc_csr = S_PAGE(TS_Pn(n, P_CSRBASE));
d273 4
a276 1
	alpha_pci_chipset->pc_name = "tsunami";
d280 1
a280 1
	alpha_pci_chipset->pc_dense = TS_P0(0);
d293 1
a293 1
	if(p)
@


1.13
log
@Make pci subsystem aware of domains.  Each host bridge gets assigned a unique
domain number such that we can distinguish between busses with the same bus
number that are behind different host bridges.  Domains can be accessed by
using different device nodes.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: tsc.c,v 1.12 2006/03/16 22:32:44 miod Exp $ */
d196 1
a204 1
	pba.pba_bridgetag = NULL;
@


1.12
log
@Get rid of specific softc structure for pci host bridges, as it is never
used. No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: tsc.c,v 1.11 2006/03/13 20:10:49 brad Exp $ */
d202 1
@


1.11
log
@* Add "pcitag_t *pba_bridgetag" to pci_attach_args.  This is set to
  NULL for root PCI busses.  For busses behind a bridge, it points to
  a persistent copy of the bridge's pcitag_t.  This can be very useful
  for machine-dependent PCI bus enumeration code.

From NetBSD

ok grange@@ kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: tsc.c,v 1.10 2005/12/13 01:16:11 martin Exp $ */
d60 1
a60 1
	sizeof(struct tsc_softc), tscmatch, tscattach,
@


1.10
log
@Pchip0 PCI memory starts at 0x80000000000, correct and use
P_PCI_MEM accordingly

pointed out by KUDO Takashi in PR 4936

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: tsc.c,v 1.9 2004/07/18 02:18:26 deraadt Exp $ */
d203 1
@


1.9
log
@shrink
@
text
@d1 1
a1 1
/* $OpenBSD: tsc.c,v 1.8 2003/09/02 17:25:21 miod Exp $ */
d241 1
a241 1
	alpha_pci_chipset->pc_mem = TS_P0(0);
@


1.8
log
@Our extent implementation relies on the fact that extents all have distinct
names.

However, the tsp code uses one global extent, which both device instances
want to reinitialize and use for themselves (whether this is a genuine bug
or not is left to the reader).

Solve the problem by putting the extents into the tsp softc, and change the
pci_bwx_bus code to handle variable extent names.

This makes DS20 systems with tsp0 and tsp1 work again.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: tsc.c,v 1.7 2002/03/14 01:26:27 millert Exp $ */
d124 1
a124 1
	printf(": 21272 Core Logic Chipset, Cchip rev %d\n"
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: tsc.c,v 1.6 2001/12/14 00:44:59 nate Exp $ */
d222 5
@


1.6
log
@Don't use a single static struct alpha_bus_space since there are machines
that can have more than one system bus attached to mainbus
@
text
@d1 1
a1 1
/* $OpenBSD: tsc.c,v 1.5 2001/11/04 23:12:46 art Exp $ */
d56 2
a57 2
int	tscmatch __P((struct device *, void *, void *));
void	tscattach __P((struct device *, struct device *, void *));
d69 1
a69 1
static int tscprint __P((void *, const char *pnp));
d71 2
a72 2
int	tspmatch __P((struct device *, void *, void *));
void	tspattach __P((struct device *, struct device *, void *));
d83 1
a83 1
static int tspprint __P((void *, const char *pnp));
d86 2
a87 2
static int tsp_bus_get_window __P((int, int,
	struct alpha_bus_space_translation *));
@


1.6.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: tsc.c,v 1.6 2001/12/14 00:44:59 nate Exp $ */
d56 2
a57 2
int	tscmatch(struct device *, void *, void *);
void	tscattach(struct device *, struct device *, void *);
d69 1
a69 1
static int tscprint(void *, const char *pnp);
d71 2
a72 2
int	tspmatch(struct device *, void *, void *);
void	tspattach(struct device *, struct device *, void *);
d83 1
a83 1
static int tspprint(void *, const char *pnp);
d86 2
a87 2
static int tsp_bus_get_window(int, int,
	struct alpha_bus_space_translation *);
@


1.5
log
@Two new sysctls in the chipset tree.
CPU_CHIPSET_PORTS - address of the I/O ports.
CPU_CHIPSET_HAE_MASK - mask for the HAE register.
@
text
@d1 1
a1 1
/* $OpenBSD: tsc.c,v 1.4 2001/06/26 21:13:44 art Exp $ */
d197 2
a198 2
	pba.pba_iot = pcp->pc_iot;
	pba.pba_memt = pcp->pc_memt;
d223 2
a224 2
		pcp->pc_iot = tsp_bus_io_init(pcp);
		pcp->pc_memt = tsp_bus_mem_init(pcp);
@


1.4
log
@More chipset info needed by X.
@
text
@d1 1
a1 1
/* $OpenBSD: tsc.c,v 1.3 2001/06/26 20:46:18 art Exp $ */
d237 2
@


1.3
log
@Provide chipset configuration to sysctls.
@
text
@d1 1
a1 1
/* $OpenBSD: tsc.c,v 1.2 2001/04/14 22:19:11 mjacob Exp $ */
d237 1
@


1.2
log
@Pick up some more NetBSD-isms (init_mem2 stuff).
@
text
@d1 1
a1 1
/* $OpenBSD: tsc.c,v 1.1 2000/11/16 04:50:18 ericj Exp $ */
d234 4
@


1.2.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/* $OpenBSD: tsc.c,v 1.2 2001/04/14 22:19:11 mjacob Exp $ */
@


1.2.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: tsc.c,v 1.2.2.1 2001/04/18 16:01:32 niklas Exp $ */
a233 5
	alpha_pci_chipset = &pcp->pc_pc;
	alpha_pci_chipset->pc_name = "tsunami";
	alpha_pci_chipset->pc_mem = TS_P0(0);
	alpha_pci_chipset->pc_dense = TS_P0(0);
	alpha_pci_chipset->pc_bwx = 1;
@


1.2.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a236 2
	alpha_pci_chipset->pc_ports = P_PCI_IO;
	alpha_pci_chipset->pc_hae_mask = 0;
@


1.2.2.4
log
@Merge in trunk
@
text
@d197 2
a198 2
	pba.pba_iot = &pcp->pc_iot;
	pba.pba_memt = &pcp->pc_memt;
d223 2
a224 2
		tsp_bus_io_init(&pcp->pc_iot, pcp);
		tsp_bus_mem_init(&pcp->pc_memt, pcp);
@


1.2.2.5
log
@Merge in -current from about a week ago
@
text
@d56 2
a57 2
int	tscmatch(struct device *, void *, void *);
void	tscattach(struct device *, struct device *, void *);
d69 1
a69 1
static int tscprint(void *, const char *pnp);
d71 2
a72 2
int	tspmatch(struct device *, void *, void *);
void	tspattach(struct device *, struct device *, void *);
d83 1
a83 1
static int tspprint(void *, const char *pnp);
d86 2
a87 2
static int tsp_bus_get_window(int, int,
	struct alpha_bus_space_translation *);
@


1.2.2.6
log
@Merge of -current from two weeks ago into the SMP branch
@
text
@a221 5
	snprintf(pcp->pc_io_ex_name, sizeof pcp->pc_io_ex_name,
	    "tsp%d_bus_io", n);
	snprintf(pcp->pc_mem_ex_name, sizeof pcp->pc_mem_ex_name,
	    "tsp%d_bus_mem", n);
	    
@


1.1
log
@
initial support for 21264 systems.
from NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: tsc.c,v 1.3 2000/06/25 19:17:40 thorpej Exp $ */
d85 5
d184 1
d186 8
d195 1
d203 1
a203 1
#if 0
@

