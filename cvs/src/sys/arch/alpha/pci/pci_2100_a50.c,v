head	1.23;
access;
symbols
	OPENBSD_6_1:1.23.0.8
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.6
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.4
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.22.0.18
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.22
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.20
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.16
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.14
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.12
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.10
	OPENBSD_5_0:1.22.0.8
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.6
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.4
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.21.0.8
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.4
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.20.0.8
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.6
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.4
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.19.0.18
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.16
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.14
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.12
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.10
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.8
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.19.0.6
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.4
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.19
	UBC:1.17.0.2
	UBC_BASE:1.17
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9:1.12.0.12
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.12.0.10
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.8
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.6
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.4
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.10.0.6
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.4
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2015.07.26.05.09.44;	author miod;	state Exp;
branches;
next	1.22;
commitid	5evJqb5U3VOxLlWE;

1.22
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.21;

1.21
date	2008.07.22.18.45.50;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.15.20.08.29;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.03.15.50;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.26.27;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.14.00.44.59;	author nate;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.11.06.19.53.13;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.17.22.43.19;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.17.22.26.58;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.25.21.49.40;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	99.01.11.05.11.02;	author millert;	state Exp;
branches
	1.12.6.1;
next	1.11;

1.11
date	98.07.01.05.32.37;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	97.01.24.19.57.47;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	96.12.08.00.20.39;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.11.12.20.29.37;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.10.30.22.40.03;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.07.29.23.00.34;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.06.18.09.44.20;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.02.20.04.35.23;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	95.12.27.22.25.29;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.53.27;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.45;	author deraadt;	state Exp;
branches;
next	;

1.12.6.1
date	2001.07.04.10.14.42;	author niklas;	state Exp;
branches;
next	1.12.6.2;

1.12.6.2
date	2001.10.31.02.52.44;	author nate;	state Exp;
branches;
next	1.12.6.3;

1.12.6.3
date	2001.11.13.21.00.49;	author niklas;	state Exp;
branches;
next	1.12.6.4;

1.12.6.4
date	2002.03.06.00.47.44;	author niklas;	state Exp;
branches;
next	1.12.6.5;

1.12.6.5
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	;

1.17.2.1
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Make sure pci_intr_map() will perform proper interrupt swizzling for devices
behind a bridge, if the SRM didn't pick an interrupt line for them.
@
text
@/*	$OpenBSD: pci_2100_a50.c,v 1.22 2009/08/22 02:54:50 mk Exp $	*/
/*	$NetBSD: pci_2100_a50.c,v 1.12 1996/11/13 21:13:29 cgd Exp $	*/

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/time.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/isa/isavar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/ppbreg.h>

#include <alpha/pci/apecsvar.h>

#include <alpha/pci/pci_2100_a50.h>
#include <alpha/pci/siovar.h>
#include <alpha/pci/sioreg.h>

#include "sio.h"

int	dec_2100_a50_intr_map(struct pci_attach_args *, pci_intr_handle_t *);
const char *dec_2100_a50_intr_string(void *, pci_intr_handle_t);
int	 dec_2100_a50_intr_line(void *, pci_intr_handle_t);
void    *dec_2100_a50_intr_establish(void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, const char *);
void    dec_2100_a50_intr_disestablish(void *, void *);

#define	APECS_SIO_DEVICE	7	/* XXX */

void
pci_2100_a50_pickintr(acp)
	struct apecs_config *acp;
{
	bus_space_tag_t iot = &acp->ac_iot;
	pci_chipset_tag_t pc = &acp->ac_pc;
	pcireg_t sioclass;
	int sioII;

	/* XXX MAGIC NUMBER */
	sioclass = pci_conf_read(pc, pci_make_tag(pc, 0, 7, 0), PCI_CLASS_REG);
        sioII = (sioclass & 0xff) >= 3;

	if (!sioII)
		printf("WARNING: SIO NOT SIO II... NO BETS...\n");

	pc->pc_intr_v = acp;
	pc->pc_intr_map = dec_2100_a50_intr_map;
	pc->pc_intr_string = dec_2100_a50_intr_string;
	pc->pc_intr_line = dec_2100_a50_intr_line;
	pc->pc_intr_establish = dec_2100_a50_intr_establish;
	pc->pc_intr_disestablish = dec_2100_a50_intr_disestablish;

	/* Not supported on 2100 A50. */
	pc->pc_pciide_compat_intr_establish = NULL;
	pc->pc_pciide_compat_intr_disestablish = NULL;

#if NSIO
        sio_intr_setup(pc, iot);
#else
	panic("pci_2100_a50_pickintr: no I/O interrupt handler (no sio)");
#endif
}

int
dec_2100_a50_intr_map(pa, ihp)
	struct pci_attach_args *pa;
	pci_intr_handle_t *ihp;
{
	pcitag_t bustag = pa->pa_intrtag;
	pci_chipset_tag_t pc = pa->pa_pc;
	int buspin, device, pirq;
	pcireg_t pirqreg;
	u_int8_t pirqline;

	if (pa->pa_bridgetag) {
		buspin = PPB_INTERRUPT_SWIZZLE(pa->pa_rawintrpin,
		    pa->pa_device);
		if (pa->pa_bridgeih[buspin - 1] != 0) {
			*ihp = pa->pa_bridgeih[buspin - 1];
			return 0;
		}

		return 1;
	}

	buspin = pa->pa_intrpin;
	pci_decompose_tag(pc, bustag, NULL, &device, NULL);

	switch (device) {
	case 6:					/* NCR SCSI */
		pirq = 3;
		break;

	case 11:				/* slot 1 */
	case 14:				/* slot 3 */
		switch (buspin) {
		default:
		case PCI_INTERRUPT_PIN_A:
		case PCI_INTERRUPT_PIN_D:
			pirq = 0;
			break;
		case PCI_INTERRUPT_PIN_B:
			pirq = 2;
			break;
		case PCI_INTERRUPT_PIN_C:
			pirq = 1;
			break;
		};
			break;

	case 12:				/* slot 2 */
		switch (buspin) {
		default:
		case PCI_INTERRUPT_PIN_A:
		case PCI_INTERRUPT_PIN_D:
			pirq = 1;
			break;
		case PCI_INTERRUPT_PIN_B:
			pirq = 0;
			break;
		case PCI_INTERRUPT_PIN_C:
			pirq = 2;
			break;
	};
	break;

	case 13:				/* slot 3 */
		switch (buspin) {
		default:
		case PCI_INTERRUPT_PIN_A:
		case PCI_INTERRUPT_PIN_D:
			pirq = 2;
			break;
		case PCI_INTERRUPT_PIN_B:
			pirq = 1;
			break;
		case PCI_INTERRUPT_PIN_C:
			pirq = 0;
			break;
		};
		break;

	default:
		printf("dec_2100_a50_intr_map: don't know how to setup %d/%d/%d\n",
		    pa->pa_bus, pa->pa_device, pa->pa_function);
                return 1;
	}

	pirqreg = pci_conf_read(pc, pci_make_tag(pc, 0, APECS_SIO_DEVICE, 0),
	    SIO_PCIREG_PIRQ_RTCTRL);
	pirqline = (pirqreg >> (pirq * 8)) & 0xff;
	if ((pirqline & 0x80) != 0)
		return 1;
	pirqline &= 0xf;

	*ihp = pirqline;
	return 0;
}

const char *
dec_2100_a50_intr_string(acv, ih)
	void *acv;
	pci_intr_handle_t ih;
{
	return sio_intr_string(NULL /*XXX*/, ih);
}

int
dec_2100_a50_intr_line(acv, ih)
	void *acv;
	pci_intr_handle_t ih;
{
	return sio_intr_line(NULL /*XXX*/, ih);
}

void *
dec_2100_a50_intr_establish(acv, ih, level, func, arg, name)
	void *acv, *arg;
	pci_intr_handle_t ih;
	int level;
	int (*func)(void *);
	const char *name;
{
	return sio_intr_establish(NULL /*XXX*/, ih, IST_LEVEL, level, func,
	    arg, name);
}

void
dec_2100_a50_intr_disestablish(acv, cookie)
	void *acv, *cookie;
{
	sio_intr_disestablish(NULL /*XXX*/, cookie);
}
@


1.22
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_2100_a50.c,v 1.21 2008/07/22 18:45:50 miod Exp $	*/
d46 1
a104 1
	int buspin = pa->pa_intrpin;
d106 1
a106 1
	int device, pirq;
d110 10
a119 9
        if (buspin == 0) {
                /* No IRQ used. */
                return 1;
        }
        if (buspin > 4) {
                printf("dec_2100_a50_intr_map: bad interrupt pin %d\n",
		    buspin);
                return 1;
        }
d121 1
d132 1
a142 5
#ifdef DIAGNOSTIC
		default:			/* XXX gcc -Wuninitialized */
			panic("dec_2100_a50_intr_map bogus PCI pin %d",
			    buspin);
#endif
d144 1
a144 1
		break;
d148 1
d159 2
a160 7
#ifdef DIAGNOSTIC
		default:			/* XXX gcc -Wuninitialized */
			panic("dec_2100_a50_intr_map bogus PCI pin %d",
			    buspin);
#endif
		};
		break;
d164 1
a174 5
#ifdef DIAGNOSTIC
		default:			/* XXX gcc -Wuninitialized */
			panic("dec_2100_a50_intr_map bogus PCI pin %d",
			    buspin);
#endif
d179 2
a180 2
                printf("dec_2100_a50_intr_map: weird device number %d\n",
		    device);
a185 4
#if 0
	printf("pci_2100_a50_map_int: device %d pin %c: pirq %d, reg = %x\n",
		device, '@@' + buspin, pirq, pirqreg);
#endif
a190 5
#if 0
	printf("pci_2100_a50_map_int: device %d pin %c: mapped to line %d\n",
	    device, '@@' + buspin, pirqline);
#endif

d192 1
a192 1
	return (0);
@


1.21
log
@Modify pci_intr_map() implementation to pass the pci_attach_args to the
per-platform implementation, instead of selected members of it; this allows
us to get rid of some globals, and paves the way for better bridge support
on some models.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_2100_a50.c,v 1.20 2006/06/15 20:08:29 brad Exp $	*/
d59 1
a59 1
	    int, int (*func)(void *), void *, char *);
d236 1
a236 1
	char *name;
@


1.20
log
@Rework the interrupt code, shaving some cycles off in the process.
Rather than an "iointr" routine that decomposes a vector into an
IRQ, we maintain a vector table directly, hooking up each "iointr"
routine at the correct vector. This also allows us to hook device
interrupts up to specific vectors.

From thorpej NetBSD

Tested by myself and a number of end-users.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_2100_a50.c,v 1.19 2002/03/14 03:15:50 millert Exp $	*/
d55 1
a55 2
int	dec_2100_a50_intr_map(void *, pcitag_t, int, int,
	    pci_intr_handle_t *);
d99 2
a100 4
dec_2100_a50_intr_map(acv, bustag, buspin, line, ihp)
	void *acv;
        pcitag_t bustag;
	int buspin, line;
d103 3
a105 2
	struct apecs_config *acp = acv;
	pci_chipset_tag_t pc = &acp->ac_pc;
@


1.19
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_2100_a50.c,v 1.18 2002/03/14 01:26:27 millert Exp $	*/
a93 1
	set_iointr(&sio_iointr);
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_2100_a50.c,v 1.17 2001/12/14 00:44:59 nate Exp $	*/
d59 2
a60 2
void    *dec_2100_a50_intr_establish __P((void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, char *));
@


1.17
log
@Don't use a single static struct alpha_bus_space since there are machines
that can have more than one system bus attached to mainbus
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_2100_a50.c,v 1.16 2001/11/06 19:53:13 miod Exp $	*/
d55 4
a58 4
int	dec_2100_a50_intr_map __P((void *, pcitag_t, int, int,
	    pci_intr_handle_t *));
const char *dec_2100_a50_intr_string __P((void *, pci_intr_handle_t));
int	 dec_2100_a50_intr_line __P((void *, pci_intr_handle_t));
d61 1
a61 1
void    dec_2100_a50_intr_disestablish __P((void *, void *));
d238 1
a238 1
	int (*func) __P((void *));
@


1.17.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_2100_a50.c,v 1.17 2001/12/14 00:44:59 nate Exp $	*/
d55 7
a61 7
int	dec_2100_a50_intr_map(void *, pcitag_t, int, int,
	    pci_intr_handle_t *);
const char *dec_2100_a50_intr_string(void *, pci_intr_handle_t);
int	 dec_2100_a50_intr_line(void *, pci_intr_handle_t);
void    *dec_2100_a50_intr_establish(void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, char *);
void    dec_2100_a50_intr_disestablish(void *, void *);
d238 1
a238 1
	int (*func)(void *);
@


1.16
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_2100_a50.c,v 1.15 2001/08/17 22:43:19 mickey Exp $	*/
d69 1
a69 1
	bus_space_tag_t iot = acp->ac_iot;
@


1.15
log
@cut and paste typo
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_2100_a50.c,v 1.14 2001/08/17 22:26:58 mickey Exp $	*/
d37 1
a37 1
#include <vm/vm.h>
@


1.14
log
@provide a way to get the number used for irq line, not only a string
representation, this is needed for devices like cbb which pass
the interrupt line down to the cardbus attachment and not
getting the right line before pci_intr_map() has done it's
dirty deed.
tested on i386 by jason@@, compiles on alpha by art@@.
ppc and mveppc are to be test-compiled, but should work (;
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_2100_a50.c,v 1.13 2001/06/25 21:49:40 csapuntz Exp $	*/
d225 1
a225 1
const char *
@


1.13
log
@

Add disestablish for pciide on Alpha
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_2100_a50.c,v 1.12 1999/01/11 05:11:02 millert Exp $	*/
d58 1
d84 1
d223 8
@


1.12
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_2100_a50.c,v 1.11 1998/07/01 05:32:37 angelos Exp $	*/
d88 1
@


1.12.6.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_2100_a50.c,v 1.12 1999/01/11 05:11:02 millert Exp $	*/
a87 1
	pc->pc_pciide_compat_intr_disestablish = NULL;
@


1.12.6.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_2100_a50.c,v 1.12.6.1 2001/07/04 10:14:42 niklas Exp $	*/
a57 1
int	 dec_2100_a50_intr_line __P((void *, pci_intr_handle_t));
a82 1
	pc->pc_intr_line = dec_2100_a50_intr_line;
a220 8
}

int
dec_2100_a50_intr_line(acv, ih)
	void *acv;
	pci_intr_handle_t ih;
{
	return sio_intr_line(NULL /*XXX*/, ih);
@


1.12.6.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 1
a37 1
#include <uvm/uvm_extern.h>
@


1.12.6.4
log
@Merge in trunk
@
text
@d69 1
a69 1
	bus_space_tag_t iot = &acp->ac_iot;
@


1.12.6.5
log
@Merge in -current from about a week ago
@
text
@d55 7
a61 7
int	dec_2100_a50_intr_map(void *, pcitag_t, int, int,
	    pci_intr_handle_t *);
const char *dec_2100_a50_intr_string(void *, pci_intr_handle_t);
int	 dec_2100_a50_intr_line(void *, pci_intr_handle_t);
void    *dec_2100_a50_intr_establish(void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, char *);
void    dec_2100_a50_intr_disestablish(void *, void *);
d238 1
a238 1
	int (*func)(void *);
@


1.11
log
@First shot for EB164SX/LX support; kernels for those should be much
more stable now, but by no means production-strong. A lot of code from
NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_2100_a50.c,v 1.10 1997/01/24 19:57:47 niklas Exp $	*/
d142 1
a142 1
			panic("dec_2100_a50_intr_map bogus PCI pin %d\n",
d162 1
a162 1
			panic("dec_2100_a50_intr_map bogus PCI pin %d\n",
d182 1
a182 1
			panic("dec_2100_a50_intr_map bogus PCI pin %d\n",
@


1.10
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_2100_a50.c,v 1.9 1996/12/08 00:20:39 niklas Exp $	*/
d86 3
d90 1
a90 1
        sio_intr_setup(iot);
@


1.9
log
@Merge to NetBSD 961107, i.e. mostly new bus.h
@
text
@d1 2
a2 2
/*	$OpenBSD: pci_2100_a50.c,v 1.8 1996/11/12 20:29:37 niklas Exp $	*/
/*	$NetBSD: pci_2100_a50.c,v 1.11 1996/10/23 04:12:26 cgd Exp $	*/
d112 2
a113 1
                printf("pci_map_int: bad interrupt pin %d\n", buspin);
d137 5
d157 5
d177 5
d184 5
@


1.8
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 2
a2 2
/*	$OpenBSD: pci_2100_a50.c,v 1.7 1996/10/30 22:40:03 niklas Exp $	*/
/*	$NetBSD: pci_2100_a50.c,v 1.10 1996/10/13 03:00:09 christos Exp $	*/
d40 1
a40 1
#include <machine/bus.old.h>
d68 1
a68 1
	bus_chipset_tag_t bc = &acp->ac_bc;
d87 1
a87 1
        sio_intr_setup(bc);
@


1.7
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_2100_a50.c,v 1.10 1996/10/13 03:00:09 christos Exp $	*/
d40 1
a40 1
#include <machine/bus.h>
@


1.6
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: pci_2100_a50.c,v 1.7 1996/04/23 14:15:55 cgd Exp $	*/
/*	$NetBSD: pci_2100_a50.c,v 1.7 1996/04/23 14:15:55 cgd Exp $	*/
d39 1
a194 2
	struct apecs_config *acp = acv;

a205 2
	struct apecs_config *acp = acv;

a213 2
	struct apecs_config *acp = acv;

@


1.5
log
@sync to 0616, retaining local diffs
@
text
@d1 1
d58 1
a58 1
	    int, int (*func)(void *), void *));
d200 1
a200 1
dec_2100_a50_intr_establish(acv, ih, level, func, arg)
d205 1
d210 1
a210 1
	    arg);
@


1.4
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d1 1
a1 1
/*	$NetBSD: pci_2100_a50.c,v 1.4 1995/12/24 02:29:42 mycroft Exp $	*/
d4 1
a4 1
 * Copyright (c) 1995 Carnegie-Mellon University.
d38 3
d49 1
d53 30
a82 9
void    *dec_2100_a50_pci_map_int __P((void *, pci_conftag_t,
	    pci_intr_pin_t, pci_intr_line_t, int,
	    int (*func)(void *), void *, char *));
void    dec_2100_a50_pci_unmap_int __P((void *, void *));

__const struct pci_intr_fns dec_2100_a50_pci_intr_fns = {
        dec_2100_a50_pci_map_int,
        dec_2100_a50_pci_unmap_int,
};
d84 10
a93 2
void *
dec_2100_a50_pci_map_int(acv, tag, pin, line, level, func, arg, what)
d95 3
a97 7
        pci_conftag_t tag;
	pci_intr_pin_t pin;
	pci_intr_line_t line;
        int level;
        int (*func) __P((void *));
        void *arg;
	char *what;
d100 3
a102 2
	int bus, device, pirq;
	pci_confreg_t irreg, pirqreg;
d105 1
a105 1
        if (pin == 0) {
d107 1
a107 1
                return 0;
d109 3
a111 3
        if (pin > 4) {
                printf("pci_map_int: bad interrupt pin %d\n", pin);
                return NULL;
d114 1
a114 1
	device = PCI_TAG_DEVICE(tag);
d122 2
a123 1
		switch (pin) {
d138 1
a138 1
		switch (pin) {
d153 1
a153 1
		switch (pin) {
d168 2
a169 2
	pirqreg = PCI_CONF_READ(acp->ac_conffns, acp->ac_confarg,
	    PCI_MAKE_TAG(0, 7, 0), 0x60); /* XXX */
d172 1
a172 1
		device, '@@' + pin, pirq, pirqreg);
d176 1
a176 1
		return 0;			/* not routed? */
d181 1
a181 1
	    device, '@@' + pin, pirqline);
d184 2
a185 6
#if NSIO
	return ISA_INTR_ESTABLISH(&sio_isa_intr_fns, NULL,	/* XXX */
	    pirqline, IST_LEVEL, level, func, arg);
#else
	panic("dec_2100_a50_pci_map_int: no sio!");
#endif
d188 4
a191 4
void
dec_2100_a50_pci_unmap_int(pifa, cookie)
	void *pifa;
	void *cookie;
d193 1
d195 1
a195 1
	panic("dec_2100_a50_pci_unmap_int not implemented");	/* XXX */
d198 6
a203 7
void
pci_2100_a50_pickintr(pcf, pcfa, ppf, ppfa, pifp, pifap)
        __const struct pci_conf_fns *pcf;
        __const struct pci_pio_fns *ppf;
        void *pcfa, *ppfa;
        __const struct pci_intr_fns **pifp;
        void **pifap;
d205 1
a205 2
	pci_confreg_t sioclass;
	int sioII;
d207 3
a209 4
	/* XXX MAGIC NUMBER */
	sioclass = PCI_CONF_READ(pcf, pcfa, PCI_MAKE_TAG(0, 7, 0),
	    PCI_CLASS_REG);
        sioII = (sioclass & 0xff) >= 3;
d211 5
a215 2
	if (!sioII)
		printf("WARNING: SIO NOT SIO II... NO BETS...\n");
d217 1
a217 8
	*pifp = &dec_2100_a50_pci_intr_fns;
	*pifap = pcfa;			/* XXX assumes apecs_config ptr */
#if NSIO
        sio_intr_setup(ppf, ppfa);
	set_iointr(&sio_iointr);
#else
	panic("pci_2100_a50_pickintr: no I/O interrupt handler (no sio)");
#endif
@


1.3
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
@
text
@d51 1
a51 1
	    int (*func)(void *), void *));
d60 1
a60 1
dec_2100_a50_pci_map_int(acv, tag, pin, line, level, func, arg)
d68 1
@


1.2
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: pci_2100_a50.c,v 1.3 1995/11/23 02:37:49 cgd Exp $	*/
d50 1
a50 1
	    pci_intr_pin_t, pci_intr_line_t, pci_intrlevel_t,
d65 1
a65 1
        pci_intrlevel_t level;
d154 1
a154 2
	    pirqline, ISA_IST_LEVEL, pci_intrlevel_to_isa(level),
	    func, arg);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: pci_2100_a50.c,v 1.2 1995/08/03 01:17:10 cgd Exp $	*/
a35 1

d39 1
a39 2
#include <alpha/isa/isa_intr.h>

a40 2
#include <dev/pci/pcireg.h>
#include <alpha/pci/pci_chipset.h>
d42 1
a42 3
void	pci_2100_a50_attach __P((struct device *, struct device *, void *));
void	*pci_2100_a50_map_int __P((pcitag_t, pci_intrlevel, int (*) (void *),
	    void *, int));
d44 2
a45 3
struct pci_cfg_fcns pci_2100_a50_sio1_cfg_fcns = {	/* XXX diff? */
	pci_2100_a50_attach, pci_2100_a50_map_int,
};
d47 1
a47 3
struct pci_cfg_fcns pci_2100_a50_sio2_cfg_fcns = {
	pci_2100_a50_attach, pci_2100_a50_map_int,
};
d49 4
a52 6
void
pci_2100_a50_attach(parent, self, aux)
        struct device *parent, *self;
        void *aux;
{
	int bus, device;
d54 4
a57 15
#if 0
	for (bus = 0; bus <= 255; bus++)
#else
	/*
	 * XXX
	 * Some current chipsets do wacky things with bus numbers > 0.
	 * This seems like a violation of protocol, but the PCI BIOS does
	 * allow one to query the maximum bus number, and eventually we
	 * should do so.
	 */
	for (bus = 0; bus <= 0; bus++)
#endif
		for (device = 0; device <= 31; device++)
			pci_attach_subdev(self, bus, device);
}
d60 6
a65 3
pci_2100_a50_map_int(tag, level, func, arg, pin)
        pcitag_t tag;
        pci_intrlevel level;
a67 1
	int pin;
d69 1
d71 2
a72 2
	pcireg_t pirqreg;
	u_int8_t line;
d74 8
a81 2
	bus = (tag >> 21) & 0xff;		/* XXX */
	device = (tag >> 16) & 0x1f;
d83 1
a83 2
	if (bus != 0)				/* XXX */
		return NULL;
d136 2
a137 1
	pirqreg = pci_conf_read(pci_make_tag(0, 7, 0), 0x60);	/* XXX */
d142 2
a143 2
	line = (pirqreg >> (pirq * 8)) & 0xff;
	if ((line & 0x80) != 0)
d145 1
a145 1
	line &= 0xf;
d149 1
a149 1
	    device, '@@' + pin, line);
d152 3
a154 1
	return isa_intr_establish(line, ISA_IST_LEVEL, pcilevel_to_isa(level),
d156 12
d171 6
a176 1
pci_2100_a50_pickintr()
d178 1
a178 1
	pcireg_t sioclass;
d182 2
a183 1
	sioclass = pci_conf_read(pci_make_tag(0, 7, 0), PCI_CLASS_REG);
d185 1
d189 8
a196 8
	if (!sioII)
		pci_cfg_fcns = &pci_2100_a50_sio1_cfg_fcns;
	else
		pci_cfg_fcns = &pci_2100_a50_sio2_cfg_fcns;

	isa_intr_fcns = &sio_intr_fcns;
	(*isa_intr_fcns->isa_intr_setup)();
	set_iointr(isa_intr_fcns->isa_iointr);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
