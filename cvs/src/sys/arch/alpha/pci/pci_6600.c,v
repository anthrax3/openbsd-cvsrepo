head	1.21;
access;
symbols
	OPENBSD_6_2:1.21.0.12
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.21.0.10
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.6
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.19.0.20
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.16
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.14
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.12
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.10
	OPENBSD_5_0:1.19.0.8
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.17.0.8
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.4
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.12.0.6
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.8
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.6
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.10
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.21
date	2015.07.26.05.09.44;	author miod;	state Exp;
branches;
next	1.20;
commitid	5evJqb5U3VOxLlWE;

1.20
date	2014.04.14.07.36.12;	author mpi;	state Exp;
branches;
next	1.19;

1.19
date	2009.09.30.20.16.30;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.17;

1.17
date	2008.07.22.18.45.51;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.02.21.50.14;	author martin;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.15.20.08.29;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.26.20.23.08;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2006.01.29.10.47.35;	author martin;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.28.17.25.05;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.28.02.28.43;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.25.21.33.21;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.03.15.50;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.27;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.12.14.00.44.59;	author nate;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.11.06.19.53.13;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.17.22.26.58;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.25.22.02.08;	author csapuntz;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.25.21.49.42;	author csapuntz;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.20.20.46.46;	author art;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.11.16.04.50.18;	author ericj;	state Exp;
branches;
next	;

1.2.2.1
date	2001.04.18.16.01.22;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2001.07.04.10.14.43;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2001.10.31.02.52.44;	author nate;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2001.11.13.21.00.49;	author niklas;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2002.03.06.00.47.44;	author niklas;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	1.2.2.7;

1.2.2.7
date	2003.03.27.23.18.06;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.10.29.00.28.01;	author art;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Make sure pci_intr_map() will perform proper interrupt swizzling for devices
behind a bridge, if the SRM didn't pick an interrupt line for them.
@
text
@/* $OpenBSD: pci_6600.c,v 1.20 2014/04/14 07:36:12 mpi Exp $ */
/* $NetBSD: pci_6600.c,v 1.5 2000/06/06 00:50:15 thorpej Exp $ */

/*-
 * Copyright (c) 1999 by Ross Harvey.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ross Harvey.
 * 4. The name of Ross Harvey may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY ROSS HARVEY ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURP0SE
 * ARE DISCLAIMED.  IN NO EVENT SHALL ROSS HARVEY BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <machine/autoconf.h>
#define _ALPHA_BUS_DMA_PRIVATE
#include <machine/bus.h>
#include <machine/rpb.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/ppbreg.h>
#include <dev/pci/pciidereg.h>
#include <dev/pci/pciidevar.h>

#include <alpha/pci/tsreg.h>
#include <alpha/pci/tsvar.h>
#include <alpha/pci/pci_6600.h>

#define pci_6600() { Generate ctags(1) key. }

#include "sio.h"
#if NSIO
#include <alpha/pci/siovar.h>
#endif

#define	PCI_NIRQ		64
#define	PCI_STRAY_MAX		5

/*
 * Some Tsunami models have a PCI device (the USB controller) with interrupts
 * tied to ISA IRQ lines.  The IRQ is encoded as:
 *
 *	line = 0xe0 | isa_irq;
 */
#define	DEC_6600_LINE_IS_ISA(line)	((line) >= 0xe0 && (line) <= 0xef)
#define	DEC_6600_LINE_ISA_IRQ(line)	((line) & 0x0f)

static struct tsp_config *sioprimary;

void dec_6600_intr_disestablish(void *, void *);
void *dec_6600_intr_establish(void *, pci_intr_handle_t, int,
    int (*func)(void *), void *, const char *);
const char *dec_6600_intr_string(void *, pci_intr_handle_t);
int dec_6600_intr_line(void *, pci_intr_handle_t);
int dec_6600_intr_map(struct pci_attach_args *, pci_intr_handle_t *);
void *dec_6600_pciide_compat_intr_establish(void *, struct device *,
    struct pci_attach_args *, int, int (*)(void *), void *);
void  dec_6600_pciide_compat_intr_disestablish(void *, void *);

struct alpha_shared_intr *dec_6600_pci_intr;

void dec_6600_iointr(void *arg, unsigned long vec);
extern void dec_6600_intr_enable(int irq);
extern void dec_6600_intr_disable(int irq);

void
pci_6600_pickintr(pcp)
	struct tsp_config *pcp;
{
	bus_space_tag_t iot = &pcp->pc_iot;
	pci_chipset_tag_t pc = &pcp->pc_pc;
#if 0
	char *cp;
#endif
	int i;

        pc->pc_intr_v = pcp;
        pc->pc_intr_map = dec_6600_intr_map;
        pc->pc_intr_string = dec_6600_intr_string;
        pc->pc_intr_line = dec_6600_intr_line;
        pc->pc_intr_establish = dec_6600_intr_establish;
        pc->pc_intr_disestablish = dec_6600_intr_disestablish;
	pc->pc_pciide_compat_intr_establish = NULL;

	/*
	 * System-wide and Pchip-0-only logic...
	 */
	if (dec_6600_pci_intr == NULL) {
		sioprimary = pcp;
		pc->pc_pciide_compat_intr_establish =
		    dec_6600_pciide_compat_intr_establish;
		dec_6600_pci_intr = alpha_shared_intr_alloc(PCI_NIRQ);
		for (i = 0; i < PCI_NIRQ; i++) {
			alpha_shared_intr_set_maxstrays(dec_6600_pci_intr, i,
			    PCI_STRAY_MAX);
			alpha_shared_intr_set_private(dec_6600_pci_intr, i,
			    sioprimary);
		}
#if NSIO
		sio_intr_setup(pc, iot);
		dec_6600_intr_enable(55);	/* irq line for sio */
#endif
	}
}

int     
dec_6600_intr_map(pa, ihp)
	struct pci_attach_args *pa;
        pci_intr_handle_t *ihp;
{
	int buspin, line = pa->pa_intrline;

	/*
	 * The console places the interrupt mapping in the "line" value.
	 * We trust it whenever possible.
	 */
	if (line >= 0 && line < PCI_NIRQ) {
		*ihp = line;
		return 0;
	}
	if (DEC_6600_LINE_IS_ISA(line)) {
#if NSIO > 0
		*ihp = line;
		return 0;
#else
		printf("dec_6600_intr_map: ISA IRQ %d for %d/%d/%d\n",
		    DEC_6600_LINE_ISA_IRQ(line),
		    pa->pa_bus, pa->pa_device, pa->pa_function);
		return 1;
#endif
	}
	
	if (pa->pa_bridgetag) {
		buspin = PPB_INTERRUPT_SWIZZLE(pa->pa_rawintrpin,
		    pa->pa_device);
		if (pa->pa_bridgeih[buspin - 1] != 0) {
			*ihp = pa->pa_bridgeih[buspin - 1];
			return 0;
		}
	}

	return 1;
}

const char *
dec_6600_intr_string(acv, ih)
	void *acv;
	pci_intr_handle_t ih;
{

	static const char irqfmt[] = "dec 6600 irq %ld";
	static char irqstr[sizeof irqfmt];

#if NSIO
	if (DEC_6600_LINE_IS_ISA(ih))
		return (sio_intr_string(NULL /*XXX*/,
		    DEC_6600_LINE_ISA_IRQ(ih)));
#endif

	snprintf(irqstr, sizeof irqstr, irqfmt, ih);
	return (irqstr);
}

int
dec_6600_intr_line(acv, ih)
	void *acv;
	pci_intr_handle_t ih;
{

#if NSIO
	if (DEC_6600_LINE_IS_ISA(ih))
		return (sio_intr_line(NULL /*XXX*/,
		    DEC_6600_LINE_ISA_IRQ(ih)));
#endif

	return (ih);
}

void *
dec_6600_intr_establish(acv, ih, level, func, arg, name)
        void *acv, *arg;
        pci_intr_handle_t ih;
        int level;
        int (*func)(void *);
	const char *name;
{
	void *cookie;

#if NSIO
	if (DEC_6600_LINE_IS_ISA(ih))
		return (sio_intr_establish(NULL /*XXX*/,
		    DEC_6600_LINE_ISA_IRQ(ih), IST_LEVEL, level, func, arg,
	            name));
#endif

	if (ih >= PCI_NIRQ)
		panic("dec_6600_intr_establish: bogus dec 6600 IRQ 0x%lx",
		    ih);

	cookie = alpha_shared_intr_establish(dec_6600_pci_intr, ih, IST_LEVEL,
	    level, func, arg, name);

	if (cookie != NULL &&
	    alpha_shared_intr_firstactive(dec_6600_pci_intr, ih)) {
		scb_set(0x900 + SCB_IDXTOVEC(ih), dec_6600_iointr, NULL);
		dec_6600_intr_enable(ih);
	}
	return (cookie);
}

void
dec_6600_intr_disestablish(acv, cookie)
        void *acv, *cookie;
{
	struct alpha_shared_intrhand *ih = cookie;
	unsigned int irq = ih->ih_num;
	int s;

#if NSIO
	/*
	 * We have to determine if this is an ISA IRQ or not!  We do this
	 * by checking to see if the intrhand points back to an intrhead
	 * that points to the sioprimary TSP.  If not, it's an ISA IRQ.
	 * Pretty disgusting, eh?
	 */
	if (ih->ih_intrhead->intr_private != sioprimary) {
		sio_intr_disestablish(NULL /*XXX*/, cookie);
		return;
	}
#endif
 
	s = splhigh();

	alpha_shared_intr_disestablish(dec_6600_pci_intr, cookie);
	if (alpha_shared_intr_isactive(dec_6600_pci_intr, irq) == 0) {
		dec_6600_intr_disable(irq);
		alpha_shared_intr_set_dfltsharetype(dec_6600_pci_intr, irq,
		    IST_NONE);
		scb_free(0x900 + SCB_IDXTOVEC(irq));
	}
 
	splx(s);
}

void
dec_6600_iointr(arg, vec)
	void *arg;
	unsigned long vec;
{
	int irq; 

	irq = SCB_VECTOIDX(vec - 0x900);

	if (irq >= PCI_NIRQ)
		panic("dec_6600_iointr: irq %d is too high", irq);

	if (!alpha_shared_intr_dispatch(dec_6600_pci_intr, irq)) {
		alpha_shared_intr_stray(dec_6600_pci_intr, irq, "6600 irq");
		if (ALPHA_SHARED_INTR_DISABLE(dec_6600_pci_intr, irq))
			dec_6600_intr_disable(irq);
	} else
		alpha_shared_intr_reset_strays(dec_6600_pci_intr, irq);
}

void
dec_6600_intr_enable(irq)
	int irq;
{
	alpha_mb();
	STQP(TS_C_DIM0) |= 1UL << irq;
	alpha_mb();
}

void
dec_6600_intr_disable(irq)
	int irq;
{
	alpha_mb();
	STQP(TS_C_DIM0) &= ~(1UL << irq);
	alpha_mb();
}

void *
dec_6600_pciide_compat_intr_establish(v, dev, pa, chan, func, arg)
	void *v;
	struct device *dev;
	struct pci_attach_args *pa;
	int chan;
	int (*func)(void *);
	void *arg;
{
	pci_chipset_tag_t pc = pa->pa_pc;
	void *cookie = NULL;
	int bus, irq;

	pci_decompose_tag(pc, pa->pa_tag, &bus, NULL, NULL);

	/*
	 * If this isn't PCI bus #0 on the TSP that holds the PCI-ISA
	 * bridge, all bets are off.
	 */
	if (bus != 0 || pc->pc_intr_v != sioprimary)
		return (NULL);

	irq = PCIIDE_COMPAT_IRQ(chan);
#if NSIO
	cookie = sio_intr_establish(NULL /*XXX*/, irq, IST_EDGE, IPL_BIO,
	    func, arg, dev->dv_xname);

	if (cookie == NULL)
		return (NULL);
#endif
	return (cookie);
}

void
dec_6600_pciide_compat_intr_disestablish(v, cookie)
	void *v;
	void *cookie;
{
	sio_intr_disestablish(NULL, cookie);
}
@


1.20
log
@Fewer <uvm/uvm.h>
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.19 2009/09/30 20:16:30 miod Exp $ */
d48 1
d138 1
a138 15
	pcitag_t bustag = pa->pa_intrtag;
	int buspin = pa->pa_intrpin, line = pa->pa_intrline;
	pci_chipset_tag_t pc = pa->pa_pc;
	int bus, device, function;

	if (buspin == 0) {
		/* No IRQ used. */
		return 1;
	}
	if (buspin > 4) {
		printf("intr_map: bad interrupt pin %d\n", buspin);
		return 1;
	}

	pci_decompose_tag(pc, bustag, &bus, &device, &function);
d142 1
a142 1
	 * A value of (char)-1 indicates there is no mapping.
d144 3
a146 4
	if (line == 0xff) {
		printf("dec_6600_intr_map: no mapping for %d/%d/%d\n",
		    bus, device, function);
		return (1);
a147 2

#if NSIO == 0
d149 4
d154 13
a166 2
		    DEC_6600_LINE_ISA_IRQ(line), bus, device, function);
		return (1);
a167 5
#endif

	if (DEC_6600_LINE_IS_ISA(line) == 0 && line >= PCI_NIRQ)
		panic("dec_6600_intr_map: dec 6600 irq too large (%d)",
		    line);
d169 1
a169 2
	*ihp = line;
	return (0);
d282 1
a282 1
		panic("iointr: irq %d is too high", irq);
@


1.19
log
@Remove unused last argument of alpha_shared_intr_disestablish().
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.18 2009/08/22 02:54:50 mk Exp $ */
a39 2

#include <uvm/uvm.h>
@


1.18
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.17 2008/07/22 18:45:51 miod Exp $ */
a75 1
static char *irqtype = "6600 irq";
d270 1
a270 1
	alpha_shared_intr_disestablish(dec_6600_pci_intr, cookie, irqtype);
d294 1
a294 2
		alpha_shared_intr_stray(dec_6600_pci_intr, irq,
		    irqtype);
@


1.17
log
@Modify pci_intr_map() implementation to pass the pci_attach_args to the
per-platform implementation, instead of selected members of it; this allows
us to get rid of some globals, and paves the way for better bridge support
on some models.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.16 2007/05/02 21:50:14 martin Exp $ */
d81 1
a81 1
    int (*func)(void *), void *, char *);
d222 1
a222 1
	char *name;
@


1.16
log
@supply the real devicename to sio_intr_establish() instead a generic
platform interrupt string when establishing pciide interrupts
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.15 2006/06/15 20:08:29 brad Exp $ */
d84 1
a84 1
int dec_6600_intr_map(void *, pcitag_t, int, int, pci_intr_handle_t *);
d136 2
a137 4
dec_6600_intr_map(acv, bustag, buspin, line, ihp)
        void *acv;
        pcitag_t bustag; 
        int buspin, line;
d140 3
a142 2
	struct tsp_config *pcp = acv;
	pci_chipset_tag_t pc = &pcp->pc_pc;
@


1.15
log
@Rework the interrupt code, shaving some cycles off in the process.
Rather than an "iointr" routine that decomposes a vector into an
IRQ, we maintain a vector table directly, hooking up each "iointr"
routine at the correct vector. This also allows us to hook device
interrupts up to specific vectors.

From thorpej NetBSD

Tested by myself and a number of end-users.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.14 2006/03/26 20:23:08 brad Exp $ */
d347 1
a347 1
	    func, arg, "dec 6600 irq");
@


1.14
log
@Replace usage of alpha_pci_decompose_tag() with pci_decompose_tag() and
remove alpha_pci_decompose_tag().

From NetBSD

ok martin@@
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.13 2006/01/29 10:47:35 martin Exp $ */
d91 1
a91 1
void dec_6600_iointr(void *framep, unsigned long vec);
a131 1
		set_iointr(dec_6600_iointr);
d241 3
a243 1
	if (cookie != NULL && alpha_shared_intr_isactive(dec_6600_pci_intr, ih))
d245 1
d277 1
d284 2
a285 2
dec_6600_iointr(framep, vec)
	void *framep;
d290 1
a290 2
	if (vec >= 0x900) {
		irq = (vec - 0x900) >> 4;
d292 2
a293 2
		if (irq >= PCI_NIRQ)
			panic("iointr: irq %d is too high", irq);
d295 7
a301 16
		if (!alpha_shared_intr_dispatch(dec_6600_pci_intr, irq)) {
			alpha_shared_intr_stray(dec_6600_pci_intr, irq,
			    irqtype);
			if (ALPHA_SHARED_INTR_DISABLE(dec_6600_pci_intr, irq))
				dec_6600_intr_disable(irq);
		} else
			alpha_shared_intr_reset_strays(dec_6600_pci_intr, irq);
		return;
	}
#if NSIO
	if (vec >= 0x800) {
		sio_iointr(framep, vec);
		return;
	}
#endif
	panic("iointr: weird vec 0x%lx", vec);
@


1.13
log
@Add a alpha_shared_intr_reset_strays() function that resets the stray
interrupt counter for a given shared interrupt descriptor.
When an interrupt is successfully handled, reset the strays counter,
thus preventing a "slow leak" from eventually shutting off the interrupt
vector.

from NetBSD via KUDO Takashi
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.12 2004/06/28 17:25:05 deraadt Exp $ */
d156 1
a156 1
	alpha_pci_decompose_tag(pc, bustag, &bus, &device, &function);
d342 1
a342 1
	alpha_pci_decompose_tag(pc, pa->pa_tag, &bus, NULL, NULL);
@


1.12
log
@oops
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.11 2004/06/28 02:28:43 aaron Exp $ */
d298 2
a299 1
		}
@


1.11
log
@Use new event counter API for interrupt counting on alpha.  By me, with some
edits by Theo.  deraadt@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.10 2002/06/25 21:33:21 miod Exp $ */
d190 1
a190 1
	static const char irqfmt[] = "%lddec6600";
@


1.10
log
@No \n at the end of a panic() message... I thought all occurences had been
squashed already.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.9 2002/03/14 03:15:50 millert Exp $ */
a83 1
const struct evcnt *dec_6600_intr_evcnt(void *, pci_intr_handle_t);
a109 3
#if 0
	pc->pc_intr_evcnt = dec_6600_intr_evcnt;
#endif
a126 8

#if 0
			cp = alpha_shared_intr_string(dec_6600_pci_intr);
			sprintf(cp, "irq %d", i);
			evcnt_attach_dynamic(alpha_shared_intr_evcnt(
			    dec_6600_pci_intr, 1), EVCNT_TYPE_INTR, NULL,
			    "dec_6600", cp);
#endif
d190 1
a190 1
	static const char irqfmt[] = "dec 6600 irq %ld";
a216 17

#if 0
const struct evcnt *
dec_6600_intr_evcnt(acv, ih)
	void *acv;
	pci_intr_handle_t ih;
{

#if NSIO
	if (DEC_6600_LINE_IS_ISA(ih))
		return (sio_intr_evcnt(NULL /*XXX*/,
		    DEC_6600_LINE_ISA_IRQ(ih)));
#endif

	return (alpha_shared_intr_evcnt(dec_6600_pci_intr, ih));
}
#endif
@


1.9
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.8 2002/03/14 01:26:27 millert Exp $ */
d189 1
a189 1
		panic("dec_6600_intr_map: dec 6600 irq too large (%d)\n",
d265 1
a265 1
		panic("dec_6600_intr_establish: bogus dec 6600 IRQ 0x%lx\n",
d336 1
a336 1
	panic("iointr: weird vec 0x%lx\n", vec);
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.7 2001/12/14 00:44:59 nate Exp $ */
d80 2
a81 2
void *dec_6600_intr_establish __P((
    void *, pci_intr_handle_t, int, int (*func)(void *), void *, char *));
d86 2
a87 2
void *dec_6600_pciide_compat_intr_establish __P((void *, struct device *,
    struct pci_attach_args *, int, int (*)(void *), void *));
@


1.7
log
@Don't use a single static struct alpha_bus_space since there are machines
that can have more than one system bus attached to mainbus
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.6 2001/11/06 19:53:13 miod Exp $ */
d79 1
a79 1
void dec_6600_intr_disestablish __P((void *, void *));
d82 4
a85 4
const char *dec_6600_intr_string __P((void *, pci_intr_handle_t));
int dec_6600_intr_line __P((void *, pci_intr_handle_t));
const struct evcnt *dec_6600_intr_evcnt __P((void *, pci_intr_handle_t));
int dec_6600_intr_map __P((void *, pcitag_t, int, int, pci_intr_handle_t *));
d88 1
a88 1
void  dec_6600_pciide_compat_intr_disestablish __P((void *, void *));
d92 3
a94 3
void dec_6600_iointr __P((void *framep, unsigned long vec));
extern void dec_6600_intr_enable __P((int irq));
extern void dec_6600_intr_disable __P((int irq));
d252 1
a252 1
        int (*func) __P((void *));
d363 1
a363 1
	int (*func) __P((void *));
@


1.7.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.7 2001/12/14 00:44:59 nate Exp $ */
d79 10
a88 10
void dec_6600_intr_disestablish(void *, void *);
void *dec_6600_intr_establish(void *, pci_intr_handle_t, int,
    int (*func)(void *), void *, char *);
const char *dec_6600_intr_string(void *, pci_intr_handle_t);
int dec_6600_intr_line(void *, pci_intr_handle_t);
const struct evcnt *dec_6600_intr_evcnt(void *, pci_intr_handle_t);
int dec_6600_intr_map(void *, pcitag_t, int, int, pci_intr_handle_t *);
void *dec_6600_pciide_compat_intr_establish(void *, struct device *,
    struct pci_attach_args *, int, int (*)(void *), void *);
void  dec_6600_pciide_compat_intr_disestablish(void *, void *);
d92 3
a94 3
void dec_6600_iointr(void *framep, unsigned long vec);
extern void dec_6600_intr_enable(int irq);
extern void dec_6600_intr_disable(int irq);
d252 1
a252 1
        int (*func)(void *);
d363 1
a363 1
	int (*func)(void *);
@


1.7.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.7.2.1 2002/06/11 03:33:40 art Exp $ */
d189 1
a189 1
		panic("dec_6600_intr_map: dec 6600 irq too large (%d)",
d265 1
a265 1
		panic("dec_6600_intr_establish: bogus dec 6600 IRQ 0x%lx",
d336 1
a336 1
	panic("iointr: weird vec 0x%lx", vec);
@


1.6
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.5 2001/08/17 22:26:58 mickey Exp $ */
d100 1
a100 1
	bus_space_tag_t iot = pcp->pc_iot;
@


1.5
log
@provide a way to get the number used for irq line, not only a string
representation, this is needed for devices like cbb which pass
the interrupt line down to the cardbus attachment and not
getting the right line before pci_intr_map() has done it's
dirty deed.
tested on i386 by jason@@, compiles on alpha by art@@.
ppc and mveppc are to be test-compiled, but should work (;
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.4 2001/06/25 22:02:08 csapuntz Exp $ */
a40 1
#include <vm/vm.h>
@


1.4
log
@Fix earlier commit of pciide disestablish
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.3 2001/06/25 21:49:42 csapuntz Exp $ */
d84 1
d111 1
d214 15
@


1.3
log
@

Add disestablish for pciide on Alpha
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.2 2001/01/20 20:46:46 art Exp $ */
d88 1
a88 2
void  dec_6600_pciide_compat_intr_disestablish __P((void *, pci_chipset_tag_t,
	    void *));
d375 1
a375 1
dec_6600_pciide_compat_intr_disestablish(v, pc, cookie)
a376 1
	pci_chipset_tag_t pc;
@


1.2
log
@No need to include machine/alpha.h
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.1 2000/11/16 04:50:18 ericj Exp $ */
d88 2
d373 9
@


1.2.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.2 2001/01/20 20:46:46 art Exp $ */
@


1.2.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.2.2.1 2001/04/18 16:01:22 niklas Exp $ */
a87 1
void  dec_6600_pciide_compat_intr_disestablish __P((void *, void *));
a370 8
}

void
dec_6600_pciide_compat_intr_disestablish(v, cookie)
	void *v;
	void *cookie;
{
	sio_intr_disestablish(NULL, cookie);
@


1.2.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.2.2.2 2001/07/04 10:14:43 niklas Exp $ */
a83 1
int dec_6600_intr_line __P((void *, pci_intr_handle_t));
a109 1
        pc->pc_intr_line = dec_6600_intr_line;
a211 15
}

int
dec_6600_intr_line(acv, ih)
	void *acv;
	pci_intr_handle_t ih;
{

#if NSIO
	if (DEC_6600_LINE_IS_ISA(ih))
		return (sio_intr_line(NULL /*XXX*/,
		    DEC_6600_LINE_ISA_IRQ(ih)));
#endif

	return (ih);
@


1.2.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d41 1
@


1.2.2.5
log
@Merge in trunk
@
text
@d100 1
a100 1
	bus_space_tag_t iot = &pcp->pc_iot;
@


1.2.2.6
log
@Merge in -current from about a week ago
@
text
@d79 10
a88 10
void dec_6600_intr_disestablish(void *, void *);
void *dec_6600_intr_establish(void *, pci_intr_handle_t, int,
    int (*func)(void *), void *, char *);
const char *dec_6600_intr_string(void *, pci_intr_handle_t);
int dec_6600_intr_line(void *, pci_intr_handle_t);
const struct evcnt *dec_6600_intr_evcnt(void *, pci_intr_handle_t);
int dec_6600_intr_map(void *, pcitag_t, int, int, pci_intr_handle_t *);
void *dec_6600_pciide_compat_intr_establish(void *, struct device *,
    struct pci_attach_args *, int, int (*)(void *), void *);
void  dec_6600_pciide_compat_intr_disestablish(void *, void *);
d92 3
a94 3
void dec_6600_iointr(void *framep, unsigned long vec);
extern void dec_6600_intr_enable(int irq);
extern void dec_6600_intr_disable(int irq);
d252 1
a252 1
        int (*func)(void *);
d363 1
a363 1
	int (*func)(void *);
@


1.2.2.7
log
@Sync the SMP branch with 3.3
@
text
@d189 1
a189 1
		panic("dec_6600_intr_map: dec 6600 irq too large (%d)",
d265 1
a265 1
		panic("dec_6600_intr_establish: bogus dec 6600 IRQ 0x%lx",
d336 1
a336 1
	panic("iointr: weird vec 0x%lx", vec);
@


1.1
log
@
initial support for 21264 systems.
from NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: pci_6600.c,v 1.5 2000/06/06 00:50:15 thorpej Exp $ */
a47 1
#include <machine/alpha.h>
@

