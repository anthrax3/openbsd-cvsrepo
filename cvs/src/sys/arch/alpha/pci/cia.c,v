head	1.25;
access;
symbols
	OPENBSD_6_0:1.25.0.30
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.26
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.28
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.20
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.25.0.24
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.22
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.18
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.16
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.14
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.12
	OPENBSD_5_0:1.25.0.10
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.8
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.6
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.4
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.24.0.4
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.23.0.6
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.4
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.20.0.10
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.8
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.6
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.4
	OPENBSD_3_6_BASE:1.20
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.19.0.6
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.19.0.4
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.19
	UBC:1.17.0.2
	UBC_BASE:1.17
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.8.0.12
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.10
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.8
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.6
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.25
date	2009.03.30.21.43.13;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.26.05.42.08;	author ray;	state Exp;
branches;
next	1.23;

1.23
date	2006.12.14.17.36.12;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.16.22.32.44;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.13.20.10.49;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2003.10.18.20.14.42;	author jmc;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.09.12.52.16;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.26.27;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.14.00.44.59;	author nate;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.11.06.19.53.13;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.04.23.12.46;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.26.21.13.43;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.26.20.46.18;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.06.19.28.59;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.06.19.26.39;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.08.20.59.24;	author ericj;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.08.16.01.16;	author art;	state Exp;
branches;
next	1.8;

1.8
date	98.07.01.05.32.35;	author angelos;	state Exp;
branches
	1.8.8.1;
next	1.7;

1.7
date	97.01.24.19.57.36;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.12.08.00.20.34;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.11.23.21.44.54;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.10.30.22.39.53;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.07.29.23.00.15;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.18.09.44.04;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.14.03.53.22;	author deraadt;	state Exp;
branches;
next	;

1.8.8.1
date	2001.04.18.16.01.09;	author niklas;	state Exp;
branches;
next	1.8.8.2;

1.8.8.2
date	2001.07.04.10.14.40;	author niklas;	state Exp;
branches;
next	1.8.8.3;

1.8.8.3
date	2001.11.13.21.00.49;	author niklas;	state Exp;
branches;
next	1.8.8.4;

1.8.8.4
date	2002.03.06.00.47.44;	author niklas;	state Exp;
branches;
next	1.8.8.5;

1.8.8.5
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	1.8.8.6;

1.8.8.6
date	2003.03.27.23.18.06;	author niklas;	state Exp;
branches;
next	1.8.8.7;

1.8.8.7
date	2004.02.19.09.59.34;	author niklas;	state Exp;
branches;
next	;

1.17.2.1
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.10.29.00.28.00;	author art;	state Exp;
branches;
next	;


desc
@@


1.25
log
@bzero pci attach args
@
text
@/* $OpenBSD: cia.c,v 1.24 2008/06/26 05:42:08 ray Exp $ */
/* $NetBSD: cia.c,v 1.56 2000/06/29 08:58:45 mrg Exp $ */

/*-
 * Copyright (c) 1998, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/rpb.h>

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <alpha/pci/ciareg.h>
#include <alpha/pci/ciavar.h>

#ifdef DEC_KN20AA
#include <alpha/pci/pci_kn20aa.h>
#endif
#ifdef DEC_EB164
#include <alpha/pci/pci_eb164.h>
#endif
#ifdef DEC_550
#include <alpha/pci/pci_550.h>
#endif
#ifdef DEC_1000A
#include <alpha/pci/pci_1000a.h>
#endif
#ifdef DEC_1000
#include <alpha/pci/pci_1000.h>
#endif

int	ciamatch(struct device *, void *, void *);
void	ciaattach(struct device *, struct device *, void *);

struct cfattach cia_ca = {
	sizeof(struct device), ciamatch, ciaattach,
};

struct cfdriver cia_cd = {
	NULL, "cia", DV_DULL,
};

static int	ciaprint(void *, const char *pnp);

/* There can be only one. */
int ciafound;
struct cia_config cia_configuration;

/*
 * This determines if we attempt to use BWX for PCI bus and config space
 * access.  Some systems, notably with Pyxis, don't fare so well unless
 * BWX is used.
 *
 * EXCEPT!  Some devices have a really hard time if BWX is used (WHY?!).
 * So, we decouple the uses for PCI config space and PCI bus space.
 *
 * FURTHERMORE!  The Pyxis, most notably earlier revs, really don't
 * do so well if you don't use BWX for bus access.  So we default to
 * forcing BWX on those chips.
 *
 * Geez.
 */

#ifndef CIA_PCI_USE_BWX
#define	CIA_PCI_USE_BWX	1
#endif

#ifndef	CIA_BUS_USE_BWX
#define	CIA_BUS_USE_BWX	1
#endif

#ifndef CIA_PYXIS_FORCE_BWX
#define	CIA_PYXIS_FORCE_BWX 1
#endif

int	cia_pci_use_bwx = CIA_PCI_USE_BWX;
int	cia_bus_use_bwx = CIA_BUS_USE_BWX;
int	cia_pyxis_force_bwx = CIA_PYXIS_FORCE_BWX;

int
ciamatch(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct mainbus_attach_args *ma = aux;

	/* Make sure that we're looking for a CIA. */
	if (strcmp(ma->ma_name, cia_cd.cd_name) != 0)
		return (0);

	if (ciafound)
		return (0);

	return (1);
}

/*
 * Set up the chipset's function pointers.
 */
void
cia_init(ccp, mallocsafe)
	struct cia_config *ccp;
	int mallocsafe;
{
	int pci_use_bwx = cia_pci_use_bwx;
	int bus_use_bwx = cia_bus_use_bwx;

	ccp->cc_hae_mem = REGVAL(CIA_CSR_HAE_MEM);
	ccp->cc_hae_io = REGVAL(CIA_CSR_HAE_IO);
	ccp->cc_rev = REGVAL(CIA_CSR_REV) & REV_MASK;

	/*
	 * Determine if we have a Pyxis.  Only two systypes can
	 * have this: the EB164 systype (AlphaPC164LX and AlphaPC164SX)
	 * and the DEC_550 systype (Miata).
	 */
	if ((cputype == ST_EB164 &&
	     (hwrpb->rpb_variation & SV_ST_MASK) >= SV_ST_ALPHAPC164LX_400) ||
	    cputype == ST_DEC_550) {
		ccp->cc_flags |= CCF_ISPYXIS;
		if (cia_pyxis_force_bwx)
			pci_use_bwx = bus_use_bwx = 1;
	}

	/*
	 * ALCOR/ALCOR2 Revisions >= 2 and Pyxis have the CNFG register.
	 */
	if (ccp->cc_rev >= 2 || (ccp->cc_flags & CCF_ISPYXIS) != 0)
		ccp->cc_cnfg = REGVAL(CIA_CSR_CNFG);
	else
		ccp->cc_cnfg = 0;

	/*
	 * Use BWX iff:
	 *
	 *	- It hasn't been disabled by the user,
	 *	- it's enabled in CNFG,
	 *	- we're implementation version ev5,
	 *	- BWX is enabled in the CPU's capabilities mask (yes,
	 *	  the bit is really cleared if the capability exists...)
	 */
	if ((pci_use_bwx || bus_use_bwx) &&
	    (ccp->cc_cnfg & CNFG_BWEN) != 0 &&
	    (cpu_amask & ALPHA_AMASK_BWX) != 0) {
		u_int32_t ctrl;

		if (pci_use_bwx)
			ccp->cc_flags |= CCF_PCI_USE_BWX;
		if (bus_use_bwx)
			ccp->cc_flags |= CCF_BUS_USE_BWX;

		/*
		 * For whatever reason, the firmware seems to enable PCI
		 * loopback mode if it also enables BWX.  Make sure it's
		 * enabled if we have an old, buggy firmware rev.
		 */
		alpha_mb();
		ctrl = REGVAL(CIA_CSR_CTRL);
		if ((ctrl & CTRL_PCI_LOOP_EN) == 0) {
			REGVAL(CIA_CSR_CTRL) = ctrl | CTRL_PCI_LOOP_EN;
			alpha_mb();
		}
	}

	if (!ccp->cc_initted) {
		/* don't do these twice since they set up extents */
		if (ccp->cc_flags & CCF_BUS_USE_BWX) {
			cia_bwx_bus_io_init(&ccp->cc_iot, ccp);
			cia_bwx_bus_mem_init(&ccp->cc_memt, ccp);
		} else {
			cia_bus_io_init(&ccp->cc_iot, ccp);
			cia_bus_mem_init(&ccp->cc_memt, ccp);
		}
	}
	ccp->cc_mallocsafe = mallocsafe;

	cia_pci_init(&ccp->cc_pc, ccp);
	alpha_pci_chipset = &ccp->cc_pc;
	alpha_pci_chipset->pc_name = "cia";
	alpha_pci_chipset->pc_dense = CIA_PCI_DENSE;
	alpha_pci_chipset->pc_hae_mask = 7L << 29;
	if (ccp->cc_flags & CCF_BUS_USE_BWX) {
		alpha_pci_chipset->pc_mem = CIA_EV56_BWMEM;
		alpha_pci_chipset->pc_ports = CIA_EV56_BWIO;
		alpha_pci_chipset->pc_bwx = 1;
	} else {
		alpha_pci_chipset->pc_mem = CIA_PCI_SMEM1;
		alpha_pci_chipset->pc_ports = CIA_PCI_SIO1;
		alpha_pci_chipset->pc_bwx = 0;
	}

	ccp->cc_initted = 1;
}

void
ciaattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct cia_config *ccp;
	struct pcibus_attach_args pba;
	const char *name;
	int pass;

	/* note that we've attached the chipset; can't have 2 CIAs. */
	ciafound = 1;

	/*
	 * set up the chipset's info; done once at console init time
	 * (maybe), but we must do it here as well to take care of things
	 * that need to use memory allocation.
	 */
	ccp = &cia_configuration;
	cia_init(ccp, 1);

	if (ccp->cc_flags & CCF_ISPYXIS) {
		name = "Pyxis";
		pass = ccp->cc_rev;
	} else {
		name = "ALCOR/ALCOR2";
		pass = ccp->cc_rev + 1;
	}

	printf(": DECchip 2117x Core Logic Chipset (%s), pass %d\n",
	    name, pass);

	if (ccp->cc_cnfg)
		printf("%s: extended capabilities: %b\n", self->dv_xname,
		    ccp->cc_cnfg, CIA_CSR_CNFG_BITS);

	switch (ccp->cc_flags & (CCF_PCI_USE_BWX|CCF_BUS_USE_BWX)) {
	case CCF_PCI_USE_BWX|CCF_BUS_USE_BWX:
		name = "PCI config and bus";
		break;
	case CCF_PCI_USE_BWX:
		name = "PCI config";
		break;
	case CCF_BUS_USE_BWX:
		name = "bus";
		break;
	default:
		name = NULL;
		break;
	}
	if (name != NULL)
		printf("%s: using BWX for %s access\n", self->dv_xname, name);

#ifdef DEC_550
	if (cputype == ST_DEC_550 &&
	    (hwrpb->rpb_variation & SV_ST_MASK) < SV_ST_MIATA_1_5) {
		/*
		 * Miata 1 systems have a bug: DMA cannot cross
		 * an 8k boundary!  Make sure PCI read prefetching
		 * is disabled on these chips.  Note that secondary
		 * PCI busses don't have this problem, because of
		 * the way PPBs handle PCI read requests.
		 *
		 * In the 21174 Technical Reference Manual, this is
		 * actually documented as "Pyxis Pass 1", but apparently
		 * there are chips that report themselves as "Pass 1"
		 * which do not have the bug!  Miatas with the Cypress
		 * PCI-ISA bridge (i.e. Miata 1.5 and Miata 2) do not
		 * have the bug, so we use this check.
		 *
		 * NOTE: This bug is actually worked around in cia_dma.c,
		 * when direct-mapped DMA maps are created.
		 *
		 * XXX WE NEED TO THINK ABOUT HOW TO HANDLE THIS FOR
		 * XXX SGMAP DMA MAPPINGS!
		 */
		u_int32_t ctrl;

		/* XXX no bets... */
		printf("%s: WARNING: Pyxis pass 1 DMA bug; no bets...\n",
		    self->dv_xname);

		ccp->cc_flags |= CCF_PYXISBUG;

		alpha_mb();
		ctrl = REGVAL(CIA_CSR_CTRL);
		ctrl &= ~(CTRL_RD_TYPE|CTRL_RL_TYPE|CTRL_RM_TYPE);
		REGVAL(CIA_CSR_CTRL) = ctrl;
		alpha_mb();
	}
#endif /* DEC_550 */

	cia_dma_init(ccp);

	switch (cputype) {
#ifdef DEC_KN20AA
	case ST_DEC_KN20AA:
		pci_kn20aa_pickintr(ccp);
		break;
#endif

#ifdef DEC_EB164
	case ST_EB164:
		pci_eb164_pickintr(ccp);
		break;
#endif

#ifdef DEC_550
	case ST_DEC_550:
		pci_550_pickintr(ccp);
		break;
#endif

#ifdef DEC_1000A
	case ST_DEC_1000A:
		pci_1000a_pickintr(ccp, &ccp->cc_iot, &ccp->cc_memt,
			&ccp->cc_pc);
		break;
#endif

#ifdef DEC_1000
	case ST_DEC_1000:
		pci_1000_pickintr(ccp, &ccp->cc_iot, &ccp->cc_memt,
			&ccp->cc_pc);
		break;
#endif

	default:
		panic("ciaattach: shouldn't be here, really...");
	}

	bzero(&pba, sizeof(pba));
	pba.pba_busname = "pci";
	pba.pba_iot = &ccp->cc_iot;
	pba.pba_memt = &ccp->cc_memt;
	pba.pba_dmat = 
	    alphabus_dma_get_tag(&ccp->cc_dmat_direct, ALPHA_BUS_PCI);
	pba.pba_pc = &ccp->cc_pc;
	pba.pba_domain = pci_ndomains++;
	pba.pba_bus = 0;
#ifdef notyet
	pba.pba_flags = PCI_FLAGS_IO_ENABLED | PCI_FLAGS_MEM_ENABLED;
	if ((ccp->cc_flags & CCF_PYXISBUG) == 0)
		pba.pba_flags |= PCI_FLAGS_MRL_OKAY | PCI_FLAGS_MRM_OKAY |
		    PCI_FLAGS_MWI_OKAY;
#endif
	config_found(self, &pba, ciaprint);
}

static int
ciaprint(aux, pnp)
	void *aux;
	const char *pnp;
{
	register struct pcibus_attach_args *pba = aux;

	/* only PCIs can attach to CIAs; easy. */
	if (pnp)
		printf("%s at %s", pba->pba_busname, pnp);
	printf(" bus %d", pba->pba_bus);
	return (UNCONF);
}

void
cia_pyxis_intr_enable(irq, onoff)
	int irq, onoff;
{
	u_int64_t imask;
	int s;

#if 0
	printf("cia_pyxis_intr_enable: %s %d\n",
	    onoff ? "enabling" : "disabling", irq);
#endif

	s = splhigh();
	alpha_mb();
	imask = REGVAL64(PYXIS_INT_MASK);
	if (onoff)
		imask |= (1UL << irq);
	else
		imask &= ~(1UL << irq);
	REGVAL64(PYXIS_INT_MASK) = imask;
	alpha_mb();
	splx(s);
}
@


1.24
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: cia.c,v 1.23 2006/12/14 17:36:12 kettenis Exp $ */
d390 1
a398 2
	pba.pba_bridgetag = NULL;

@


1.23
log
@Make pci subsystem aware of domains.  Each host bridge gets assigned a unique
domain number such that we can distinguish between busses with the same bus
number that are behind different host bridges.  Domains can be accessed by
using different device nodes.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: cia.c,v 1.22 2006/03/16 22:32:44 miod Exp $ */
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.22
log
@Get rid of specific softc structure for pci host bridges, as it is never
used. No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: cia.c,v 1.21 2006/03/13 20:10:49 brad Exp $ */
d403 1
@


1.21
log
@* Add "pcitag_t *pba_bridgetag" to pci_attach_args.  This is set to
  NULL for root PCI busses.  For busses behind a bridge, it points to
  a persistent copy of the bridge's pcitag_t.  This can be very useful
  for machine-dependent PCI bus enumeration code.

From NetBSD

ok grange@@ kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: cia.c,v 1.20 2003/10/18 20:14:42 jmc Exp $ */
d106 1
a106 1
	sizeof(struct cia_softc), ciamatch, ciaattach,
a270 1
	struct cia_softc *sc = (struct cia_softc *)self;
d284 1
a284 1
	ccp = sc->sc_ccp = &cia_configuration;
@


1.20
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/* $OpenBSD: cia.c,v 1.19 2002/07/09 12:52:16 art Exp $ */
d405 1
@


1.19
log
@Use BWX on cia as much as possible.
It doesn't seem to cause problems anymore and it should simplify some things
for X.
@
text
@d1 1
a1 1
/* $OpenBSD: cia.c,v 1.18 2002/03/14 01:26:27 millert Exp $ */
d207 1
a207 1
	 *	- It hasn't been disbled by the user,
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: cia.c,v 1.17 2001/12/14 00:44:59 nate Exp $ */
d139 1
a139 1
#define	CIA_BUS_USE_BWX	0
d143 1
a143 1
#define	CIA_PYXIS_FORCE_BWX 0
@


1.17
log
@Don't use a single static struct alpha_bus_space since there are machines
that can have more than one system bus attached to mainbus
@
text
@d1 1
a1 1
/* $OpenBSD: cia.c,v 1.16 2001/11/06 19:53:13 miod Exp $ */
d102 2
a103 2
int	ciamatch __P((struct device *, void *, void *));
void	ciaattach __P((struct device *, struct device *, void *));
d113 1
a113 1
static int	ciaprint __P((void *, const char *pnp));
@


1.17.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: cia.c,v 1.17 2001/12/14 00:44:59 nate Exp $ */
d102 2
a103 2
int	ciamatch(struct device *, void *, void *);
void	ciaattach(struct device *, struct device *, void *);
d113 1
a113 1
static int	ciaprint(void *, const char *pnp);
@


1.17.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: cia.c,v 1.17.2.1 2002/06/11 03:33:40 art Exp $ */
d139 1
a139 1
#define	CIA_BUS_USE_BWX	1
d143 1
a143 1
#define	CIA_PYXIS_FORCE_BWX 1
@


1.16
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/* $OpenBSD: cia.c,v 1.15 2001/11/04 23:12:46 art Exp $ */
d239 2
a240 2
			ccp->cc_iot = cia_bwx_bus_io_init(ccp);
			ccp->cc_memt = cia_bwx_bus_mem_init(ccp);
d242 2
a243 2
			ccp->cc_iot = cia_bus_io_init(ccp);
			ccp->cc_memt = cia_bus_mem_init(ccp);
d399 2
a400 2
	pba.pba_iot = ccp->cc_iot;
	pba.pba_memt = ccp->cc_memt;
@


1.15
log
@Two new sysctls in the chipset tree.
CPU_CHIPSET_PORTS - address of the I/O ports.
CPU_CHIPSET_HAE_MASK - mask for the HAE register.
@
text
@d1 1
a1 1
/* $OpenBSD: cia.c,v 1.14 2001/06/26 21:13:43 art Exp $ */
d73 1
a73 1
#include <vm/vm.h>
@


1.14
log
@More chipset info needed by X.
@
text
@d1 1
a1 1
/* $OpenBSD: cia.c,v 1.13 2001/06/26 20:46:18 art Exp $ */
d252 1
d255 1
d259 1
@


1.13
log
@Provide chipset configuration to sysctls.
@
text
@d1 1
a1 1
/* $OpenBSD: cia.c,v 1.12 2001/02/06 19:28:59 art Exp $ */
d251 8
a258 2
	alpha_pci_chipset->pc_mem = CIA_EV56_BWMEM;
	alpha_pci_chipset->pc_bwx = pci_use_bwx;
@


1.12
log
@Committed by accident.
@
text
@d1 1
a1 1
/* $OpenBSD: cia.c,v 1.10 2000/11/08 20:59:24 ericj Exp $ */
d249 4
@


1.11
log
@Rename pcs_bus* to pci_swiz_bus* to reduce confusion and match NetBSD.
@
text
@d143 1
a143 1
#define	CIA_PYXIS_FORCE_BWX 1
@


1.10
log
@add tags
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d143 1
a143 1
#define	CIA_PYXIS_FORCE_BWX 0
@


1.9
log
@Merge in big portions of the improvements NetBSD did to their alpha port.
Highlights: UVM, PMAP_NEW, bus_dma (only on some buses for now), new hardware
support, possiblity for ELF, etc, etc. Too much to mention.

This is still work in progress. video consoles might be broken, otherwise
we have basically the same functionality as before plus more.
@
text
@d1 1
@


1.8
log
@First shot for EB164SX/LX support; kernels for those should be much
more stable now, but by no means production-strong. A lot of code from
NetBSD.
@
text
@d1 38
a38 2
/*	$OpenBSD: cia.c,v 1.7 1997/01/24 19:57:36 niklas Exp $	*/
/*	$NetBSD: cia.c,v 1.15 1996/12/05 01:39:35 cgd Exp $	*/
d84 2
a85 1
#if defined(DEC_KN20AA)
d88 1
a88 1
#if defined(DEC_EB164)
d91 9
a100 1
#ifdef __BROKEN_INDIRECT_CONFIG
a101 3
#else
int	ciamatch __P((struct device *, struct cfdata *, void *));
#endif
d112 1
a112 1
int	ciaprint __P((void *, const char *pnp));
d118 31
a151 1
#ifdef __BROKEN_INDIRECT_CONFIG
a152 3
#else
	struct cfdata *match;
#endif
d155 1
a155 1
	struct confargs *ca = aux;
d158 1
a158 1
	if (strcmp(ca->ca_name, cia_cd.cd_name) != 0)
d175 6
d183 3
a185 2
	 * Can't set up SGMAP data here; can be called before malloc().
	 * XXX THIS COMMENT NO LONGER MAKES SENSE.
d187 7
d195 7
a201 2
	ccp->cc_hae_mem = REGVAL(CIA_CSR_HAE_MEM);
	ccp->cc_hae_io = REGVAL(CIA_CSR_HAE_IO);
d203 31
a233 17
        /*
         * Determine if we have a Pyxis.  Only two systypes can
         * have this: the EB164 systype (AlphaPC164LX and AlphaPC164SX)
         * and the DEC_550 systype (Miata).
         */
        if ((hwrpb->rpb_type == ST_EB164 &&
             (hwrpb->rpb_variation & SV_ST_MASK) >= SV_ST_ALPHAPC164LX_400) ||
            hwrpb->rpb_type == ST_DEC_550)
                ccp->cc_flags |= CCF_ISPYXIS;

        /*      
         * ALCOR/ALCOR2 Revisions >= 2 and Pyxis have the CNFG register.
         */
        if (ccp->cc_rev >= 2 || (ccp->cc_flags & CCF_ISPYXIS) != 0)
                ccp->cc_cnfg = REGVAL(CIA_CSR_CNFG);
        else
                ccp->cc_cnfg = 0;
d237 7
a243 2
		ccp->cc_iot = cia_bus_io_init(ccp);
		ccp->cc_memt = cia_bus_mem_init(ccp);
a248 7
	/* XXX XXX BEGIN XXX XXX */
	{							/* XXX */
		extern vm_offset_t alpha_XXX_dmamap_or;		/* XXX */
		alpha_XXX_dmamap_or = 0x40000000;		/* XXX */
	}							/* XXX */
	/* XXX XXX END XXX XXX */

d260 2
d268 2
a269 1
	 * (maybe), but doesn't hurt to do twice.
d274 10
a283 2
	/* XXX print chipset information */
	printf("\n");
d285 64
a348 2
	switch (hwrpb->rpb_type) {
#if defined(DEC_KN20AA)
a350 3
#ifdef EVCNT_COUNTERS
		evcnt_attach(self, "intr", &kn20aa_intr_evcnt);
#endif
d354 1
a354 1
#if defined(DEC_EB164)
d357 1
a357 2
#ifdef EVCNT_COUNTERS
		evcnt_attach(self, "intr", &eb164_intr_evcnt);
d359 18
d387 2
d391 7
d401 1
a401 1
int
d413 24
@


1.8.8.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 39
/* $OpenBSD: cia.c,v 1.12 2001/02/06 19:28:59 art Exp $ */
/* $NetBSD: cia.c,v 1.56 2000/06/29 08:58:45 mrg Exp $ */

/*-
 * Copyright (c) 1998, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
d48 1
a48 2

#ifdef DEC_KN20AA
d51 1
a51 1
#ifdef DEC_EB164
a53 9
#ifdef DEC_550
#include <alpha/pci/pci_550.h>
#endif
#ifdef DEC_1000A
#include <alpha/pci/pci_1000a.h>
#endif
#ifdef DEC_1000
#include <alpha/pci/pci_1000.h>
#endif
d55 1
d57 3
d70 1
a70 1
static int	ciaprint __P((void *, const char *pnp));
a75 31
/*
 * This determines if we attempt to use BWX for PCI bus and config space
 * access.  Some systems, notably with Pyxis, don't fare so well unless
 * BWX is used.
 *
 * EXCEPT!  Some devices have a really hard time if BWX is used (WHY?!).
 * So, we decouple the uses for PCI config space and PCI bus space.
 *
 * FURTHERMORE!  The Pyxis, most notably earlier revs, really don't
 * do so well if you don't use BWX for bus access.  So we default to
 * forcing BWX on those chips.
 *
 * Geez.
 */

#ifndef CIA_PCI_USE_BWX
#define	CIA_PCI_USE_BWX	1
#endif

#ifndef	CIA_BUS_USE_BWX
#define	CIA_BUS_USE_BWX	0
#endif

#ifndef CIA_PYXIS_FORCE_BWX
#define	CIA_PYXIS_FORCE_BWX 0
#endif

int	cia_pci_use_bwx = CIA_PCI_USE_BWX;
int	cia_bus_use_bwx = CIA_BUS_USE_BWX;
int	cia_pyxis_force_bwx = CIA_PYXIS_FORCE_BWX;

d79 1
d81 3
d86 1
a86 1
	struct mainbus_attach_args *ma = aux;
d89 1
a89 1
	if (strcmp(ma->ma_name, cia_cd.cd_name) != 0)
a105 6
	int pci_use_bwx = cia_pci_use_bwx;
	int bus_use_bwx = cia_bus_use_bwx;

	ccp->cc_hae_mem = REGVAL(CIA_CSR_HAE_MEM);
	ccp->cc_hae_io = REGVAL(CIA_CSR_HAE_IO);
	ccp->cc_rev = REGVAL(CIA_CSR_REV) & REV_MASK;
d108 2
a109 3
	 * Determine if we have a Pyxis.  Only two systypes can
	 * have this: the EB164 systype (AlphaPC164LX and AlphaPC164SX)
	 * and the DEC_550 systype (Miata).
a110 7
	if ((cputype == ST_EB164 &&
	     (hwrpb->rpb_variation & SV_ST_MASK) >= SV_ST_ALPHAPC164LX_400) ||
	    cputype == ST_DEC_550) {
		ccp->cc_flags |= CCF_ISPYXIS;
		if (cia_pyxis_force_bwx)
			pci_use_bwx = bus_use_bwx = 1;
	}
d112 2
a113 7
	/*
	 * ALCOR/ALCOR2 Revisions >= 2 and Pyxis have the CNFG register.
	 */
	if (ccp->cc_rev >= 2 || (ccp->cc_flags & CCF_ISPYXIS) != 0)
		ccp->cc_cnfg = REGVAL(CIA_CSR_CNFG);
	else
		ccp->cc_cnfg = 0;
d115 17
a131 31
	/*
	 * Use BWX iff:
	 *
	 *	- It hasn't been disbled by the user,
	 *	- it's enabled in CNFG,
	 *	- we're implementation version ev5,
	 *	- BWX is enabled in the CPU's capabilities mask (yes,
	 *	  the bit is really cleared if the capability exists...)
	 */
	if ((pci_use_bwx || bus_use_bwx) &&
	    (ccp->cc_cnfg & CNFG_BWEN) != 0 &&
	    (cpu_amask & ALPHA_AMASK_BWX) != 0) {
		u_int32_t ctrl;

		if (pci_use_bwx)
			ccp->cc_flags |= CCF_PCI_USE_BWX;
		if (bus_use_bwx)
			ccp->cc_flags |= CCF_BUS_USE_BWX;

		/*
		 * For whatever reason, the firmware seems to enable PCI
		 * loopback mode if it also enables BWX.  Make sure it's
		 * enabled if we have an old, buggy firmware rev.
		 */
		alpha_mb();
		ctrl = REGVAL(CIA_CSR_CTRL);
		if ((ctrl & CTRL_PCI_LOOP_EN) == 0) {
			REGVAL(CIA_CSR_CTRL) = ctrl | CTRL_PCI_LOOP_EN;
			alpha_mb();
		}
	}
d135 2
a136 7
		if (ccp->cc_flags & CCF_BUS_USE_BWX) {
			ccp->cc_iot = cia_bwx_bus_io_init(ccp);
			ccp->cc_memt = cia_bwx_bus_mem_init(ccp);
		} else {
			ccp->cc_iot = cia_bus_io_init(ccp);
			ccp->cc_memt = cia_bus_mem_init(ccp);
		}
d142 7
a159 2
	const char *name;
	int pass;
d166 1
a166 2
	 * (maybe), but we must do it here as well to take care of things
	 * that need to use memory allocation.
d171 2
a172 10
	if (ccp->cc_flags & CCF_ISPYXIS) {
		name = "Pyxis";
		pass = ccp->cc_rev;
	} else {
		name = "ALCOR/ALCOR2";
		pass = ccp->cc_rev + 1;
	}

	printf(": DECchip 2117x Core Logic Chipset (%s), pass %d\n",
	    name, pass);
d174 2
a175 64
	if (ccp->cc_cnfg)
		printf("%s: extended capabilities: %b\n", self->dv_xname,
		    ccp->cc_cnfg, CIA_CSR_CNFG_BITS);

	switch (ccp->cc_flags & (CCF_PCI_USE_BWX|CCF_BUS_USE_BWX)) {
	case CCF_PCI_USE_BWX|CCF_BUS_USE_BWX:
		name = "PCI config and bus";
		break;
	case CCF_PCI_USE_BWX:
		name = "PCI config";
		break;
	case CCF_BUS_USE_BWX:
		name = "bus";
		break;
	default:
		name = NULL;
		break;
	}
	if (name != NULL)
		printf("%s: using BWX for %s access\n", self->dv_xname, name);

#ifdef DEC_550
	if (cputype == ST_DEC_550 &&
	    (hwrpb->rpb_variation & SV_ST_MASK) < SV_ST_MIATA_1_5) {
		/*
		 * Miata 1 systems have a bug: DMA cannot cross
		 * an 8k boundary!  Make sure PCI read prefetching
		 * is disabled on these chips.  Note that secondary
		 * PCI busses don't have this problem, because of
		 * the way PPBs handle PCI read requests.
		 *
		 * In the 21174 Technical Reference Manual, this is
		 * actually documented as "Pyxis Pass 1", but apparently
		 * there are chips that report themselves as "Pass 1"
		 * which do not have the bug!  Miatas with the Cypress
		 * PCI-ISA bridge (i.e. Miata 1.5 and Miata 2) do not
		 * have the bug, so we use this check.
		 *
		 * NOTE: This bug is actually worked around in cia_dma.c,
		 * when direct-mapped DMA maps are created.
		 *
		 * XXX WE NEED TO THINK ABOUT HOW TO HANDLE THIS FOR
		 * XXX SGMAP DMA MAPPINGS!
		 */
		u_int32_t ctrl;

		/* XXX no bets... */
		printf("%s: WARNING: Pyxis pass 1 DMA bug; no bets...\n",
		    self->dv_xname);

		ccp->cc_flags |= CCF_PYXISBUG;

		alpha_mb();
		ctrl = REGVAL(CIA_CSR_CTRL);
		ctrl &= ~(CTRL_RD_TYPE|CTRL_RL_TYPE|CTRL_RM_TYPE);
		REGVAL(CIA_CSR_CTRL) = ctrl;
		alpha_mb();
	}
#endif /* DEC_550 */

	cia_dma_init(ccp);

	switch (cputype) {
#ifdef DEC_KN20AA
d178 3
d184 1
a184 1
#ifdef DEC_EB164
d187 2
a188 1
		break;
a189 18

#ifdef DEC_550
	case ST_DEC_550:
		pci_550_pickintr(ccp);
		break;
#endif

#ifdef DEC_1000A
	case ST_DEC_1000A:
		pci_1000a_pickintr(ccp, &ccp->cc_iot, &ccp->cc_memt,
			&ccp->cc_pc);
		break;
#endif

#ifdef DEC_1000
	case ST_DEC_1000:
		pci_1000_pickintr(ccp, &ccp->cc_iot, &ccp->cc_memt,
			&ccp->cc_pc);
a199 2
	pba.pba_dmat = 
	    alphabus_dma_get_tag(&ccp->cc_dmat_direct, ALPHA_BUS_PCI);
a201 7

#ifdef notyet
	pba.pba_flags = PCI_FLAGS_IO_ENABLED | PCI_FLAGS_MEM_ENABLED;
	if ((ccp->cc_flags & CCF_PYXISBUG) == 0)
		pba.pba_flags |= PCI_FLAGS_MRL_OKAY | PCI_FLAGS_MRM_OKAY |
		    PCI_FLAGS_MWI_OKAY;
#endif
d205 1
a205 1
static int
a216 24
}

void
cia_pyxis_intr_enable(irq, onoff)
	int irq, onoff;
{
	u_int64_t imask;
	int s;

#if 0
	printf("cia_pyxis_intr_enable: %s %d\n",
	    onoff ? "enabling" : "disabling", irq);
#endif

	s = splhigh();
	alpha_mb();
	imask = REGVAL64(PYXIS_INT_MASK);
	if (onoff)
		imask |= (1UL << irq);
	else
		imask &= ~(1UL << irq);
	REGVAL64(PYXIS_INT_MASK) = imask;
	alpha_mb();
	splx(s);
@


1.8.8.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: cia.c,v 1.8.8.1 2001/04/18 16:01:09 niklas Exp $ */
a248 10
	alpha_pci_chipset = &ccp->cc_pc;
	alpha_pci_chipset->pc_name = "cia";
	alpha_pci_chipset->pc_dense = CIA_PCI_DENSE;
	if (ccp->cc_flags & CCF_BUS_USE_BWX) {
		alpha_pci_chipset->pc_mem = CIA_EV56_BWMEM;
		alpha_pci_chipset->pc_bwx = 1;
	} else {
		alpha_pci_chipset->pc_mem = CIA_PCI_SMEM1;
		alpha_pci_chipset->pc_bwx = 0;
	}
@


1.8.8.3
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d73 1
a73 1
#include <uvm/uvm_extern.h>
a251 1
	alpha_pci_chipset->pc_hae_mask = 7L << 29;
a253 1
		alpha_pci_chipset->pc_ports = CIA_EV56_BWIO;
a256 1
		alpha_pci_chipset->pc_ports = CIA_PCI_SIO1;
@


1.8.8.4
log
@Merge in trunk
@
text
@d239 2
a240 2
			cia_bwx_bus_io_init(&ccp->cc_iot, ccp);
			cia_bwx_bus_mem_init(&ccp->cc_memt, ccp);
d242 2
a243 2
			cia_bus_io_init(&ccp->cc_iot, ccp);
			cia_bus_mem_init(&ccp->cc_memt, ccp);
d399 2
a400 2
	pba.pba_iot = &ccp->cc_iot;
	pba.pba_memt = &ccp->cc_memt;
@


1.8.8.5
log
@Merge in -current from about a week ago
@
text
@d102 2
a103 2
int	ciamatch(struct device *, void *, void *);
void	ciaattach(struct device *, struct device *, void *);
d113 1
a113 1
static int	ciaprint(void *, const char *pnp);
@


1.8.8.6
log
@Sync the SMP branch with 3.3
@
text
@d139 1
a139 1
#define	CIA_BUS_USE_BWX	1
d143 1
a143 1
#define	CIA_PYXIS_FORCE_BWX 1
@


1.8.8.7
log
@Merge of -current from two weeks ago into the SMP branch
@
text
@d207 1
a207 1
	 *	- It hasn't been disabled by the user,
@


1.7
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: cia.c,v 1.6 1996/12/08 00:20:34 niklas Exp $	*/
d114 18
@


1.6
log
@Merge to NetBSD 961107, i.e. mostly new bus.h
@
text
@d1 2
a2 2
/*	$OpenBSD: cia.c,v 1.5 1996/11/23 21:44:54 kstailey Exp $	*/
/*	$NetBSD: cia.c,v 1.12 1996/10/23 04:12:24 cgd Exp $	*/
d51 3
d55 1
d57 3
d79 6
a84 1
	void *match, *aux;
d102 1
a102 1
cia_init(ccp)
d104 1
d109 1
a111 4
        ccp->cc_iot = cia_bus_io_init(ccp);
        ccp->cc_memt = cia_bus_mem_init(ccp);
        cia_pci_init(&ccp->cc_pc, ccp);

d115 9
d130 2
d151 1
a151 1
	cia_init(ccp);
d165 10
@


1.5
log
@added const to second parameter of cfprint_t routines
@
text
@d1 2
a2 2
/*	$OpenBSD: cia.c,v 1.4 1996/10/30 22:39:53 niklas Exp $	*/
/*	$NetBSD: cia.c,v 1.11 1996/10/13 03:00:03 christos Exp $	*/
d98 2
a99 2
        cia_bus_io_init(&ccp->cc_bc, ccp);
        cia_bus_mem_init(&ccp->cc_bc, ccp);
d104 7
d149 2
a150 1
	pba.pba_bc = &ccp->cc_bc;
@


1.4
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: cia.c,v 1.11 1996/10/13 03:00:03 christos Exp $	*/
d63 1
a63 1
int	ciaprint __P((void *, /* const */ char *pnp));
d151 1
a151 1
	/* const */ char *pnp;
@


1.3
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: cia.c,v 1.5.4.1 1996/06/10 00:02:39 cgd Exp $	*/
/*	$NetBSD: cia.c,v 1.5.4.1 1996/06/10 00:02:39 cgd Exp $	*/
d63 1
a63 3
static int	ciaprint __P((void *, char *pnp));

#define	REGVAL(r)	(*(int32_t *)phystok0seg(r))
a73 1
	struct cfdata *cf = match;
a110 1
	struct confargs *ca = aux;
d148 1
a148 1
static int
d151 1
a151 1
	char *pnp;
@


1.2
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.1
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: cia.c,v 1.1 1995/11/23 02:37:24 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1995 Carnegie-Mellon University.
d54 6
a59 3
struct cfdriver ciacd = {
	NULL, "cia", ciamatch, ciaattach, DV_DULL,
	    sizeof(struct cia_softc)
d79 1
a79 1
	if (strcmp(ca->ca_name, ciacd.cd_name) != 0)
d100 6
a105 9
	ccp->cc_conffns = &cia_conf_fns;
	ccp->cc_confarg = ccp;
	ccp->cc_dmafns = &cia_dma_fns;
	ccp->cc_dmaarg = ccp;
	/* Interrupt routines set up in 'attach' */
	ccp->cc_memfns = &cia_mem_fns;
	ccp->cc_memarg = ccp;
	ccp->cc_piofns = &cia_pio_fns;
	ccp->cc_pioarg = ccp;
d116 1
a116 1
	struct pci_attach_args pa;
d134 1
a134 3
		pci_kn20aa_pickintr(ccp->cc_conffns, ccp->cc_confarg,
		    ccp->cc_piofns, ccp->cc_pioarg,
		    &ccp->cc_intrfns, &ccp->cc_intrarg);
d144 5
a148 16
	pa.pa_bus = 0;
	pa.pa_maxdev = 32;
	pa.pa_burstlog2 = 8;

	pa.pa_conffns = ccp->cc_conffns;
	pa.pa_confarg = ccp->cc_confarg;
	pa.pa_dmafns = ccp->cc_dmafns;
	pa.pa_dmaarg = ccp->cc_dmaarg;
	pa.pa_intrfns = ccp->cc_intrfns;
	pa.pa_intrarg = ccp->cc_intrarg;
	pa.pa_memfns = ccp->cc_memfns;
	pa.pa_memarg = ccp->cc_memarg;
	pa.pa_piofns = ccp->cc_piofns;
	pa.pa_pioarg = ccp->cc_pioarg;

	config_found(self, &pa, ciaprint);
d156 1
a156 1
	register struct pci_attach_args *pa = aux;
d160 2
a161 2
		printf("pci at %s", pnp);
	printf(" bus %d", pa->pa_bus);
@
