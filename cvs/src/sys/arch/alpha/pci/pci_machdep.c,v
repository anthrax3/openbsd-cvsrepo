head	1.20;
access;
symbols
	OPENBSD_6_1:1.20.0.10
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.6
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.19.0.16
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.20
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.18
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.14
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.12
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.10
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.8
	OPENBSD_5_0:1.19.0.6
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.4
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.17.0.8
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.10
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.6
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.4
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.16.0.24
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.22
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.20
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.18
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.16
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.14
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.12
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.10
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.8
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.16.0.6
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.16
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.10.0.4
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.9.0.12
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.10
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.8
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.6
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2015.07.26.05.09.44;	author miod;	state Exp;
branches;
next	1.19;
commitid	5evJqb5U3VOxLlWE;

1.19
date	2010.04.21.15.00.14;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2010.04.20.23.35.16;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.11.03.10.09.03;	author martin;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.26.27;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.06.19.53.13;	author miod;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.11.04.23.12.46;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.08.15.21.29;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.26.21.13.43;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.26.20.25.51;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.03.19.30.21;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.11.06.12.27.03;	author niklas;	state Exp;
branches
	1.9.10.1;
next	1.8;

1.8
date	97.04.19.21.51.29;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	97.01.24.19.57.52;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.12.08.00.20.42;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.10.30.22.40.08;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.07.29.23.00.43;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.06.18.09.44.29;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.53.32;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.45;	author deraadt;	state Exp;
branches;
next	;

1.9.10.1
date	2001.04.18.16.01.24;	author niklas;	state Exp;
branches;
next	1.9.10.2;

1.9.10.2
date	2001.07.04.10.14.45;	author niklas;	state Exp;
branches;
next	1.9.10.3;

1.9.10.3
date	2001.10.31.02.52.44;	author nate;	state Exp;
branches;
next	1.9.10.4;

1.9.10.4
date	2001.11.13.21.00.49;	author niklas;	state Exp;
branches;
next	1.9.10.5;

1.9.10.5
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Make sure pci_intr_map() will perform proper interrupt swizzling for devices
behind a bridge, if the SRM didn't pick an interrupt line for them.
@
text
@/*	$OpenBSD: pci_machdep.c,v 1.19 2010/04/21 15:00:14 deraadt Exp $	*/
/*	$NetBSD: pci_machdep.c,v 1.7 1996/11/19 04:57:32 cgd Exp $	*/

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 * Machine-specific functions for PCI autoconfiguration.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/time.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/sysctl.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <uvm/uvm_extern.h>
#include <machine/cpu.h>

#include <dev/isa/isavar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>
#include <dev/pci/ppbreg.h>

#include "vga.h"
#if NVGA_PCI
#include <dev/pci/vga_pcivar.h>
#endif

#include "tga.h"
#if NTGA
#include <dev/pci/tgavar.h>
#endif

struct alpha_pci_chipset *alpha_pci_chipset;

void
pci_display_console(iot, memt, pc, bus, device, function)
	bus_space_tag_t iot, memt;
	pci_chipset_tag_t pc;
	int bus, device, function;
{
	pcitag_t tag;
	pcireg_t id, class;
	int match;
#if NVGA_PCI || NTGA
	int nmatch;
#endif
	int (*fn)(bus_space_tag_t, bus_space_tag_t, pci_chipset_tag_t,
	    int, int, int);

	tag = pci_make_tag(pc, bus, device, function);
	id = pci_conf_read(pc, tag, PCI_ID_REG);
	if (id == 0 || id == 0xffffffff)
		panic("pci_display_console: no device at %d/%d/%d",
		    bus, device, function);
	class = pci_conf_read(pc, tag, PCI_CLASS_REG);

	match = 0;
	fn = NULL;

#if NVGA_PCI
	nmatch = DEVICE_IS_VGA_PCI(class);
	if (nmatch > match) {
		match = nmatch;
		fn = vga_pci_cnattach;
	}
#endif
#if NTGA
	nmatch = DEVICE_IS_TGA(class, id);
	if (nmatch > match) {
		match = nmatch;
		fn = tga_cnattach;
	}
#endif

	if (fn != NULL)
		(*fn)(iot, memt, pc, bus, device, function);
	else
		panic("pci_display_console: unconfigured device at %d/%d/%d",
		    bus, device, function);
}

int
alpha_sysctl_chipset(int *name, u_int namelen, char *where, size_t *sizep)
{
	if (namelen != 1)
		return (ENOTDIR);

	if (alpha_pci_chipset == NULL)
		return (EOPNOTSUPP);

	switch (name[0]) {
	case CPU_CHIPSET_TYPE:
		return (sysctl_rdstring(where, sizep, NULL,
		    alpha_pci_chipset->pc_name));
	case CPU_CHIPSET_BWX:
		return (sysctl_rdint(where, sizep, NULL,
		    alpha_pci_chipset->pc_bwx));
	case CPU_CHIPSET_MEM:
		return (sysctl_rdquad(where, sizep, NULL,
		    alpha_pci_chipset->pc_mem));
	case CPU_CHIPSET_DENSE:
		return (sysctl_rdquad(where, sizep, NULL,
		    alpha_pci_chipset->pc_dense));
	case CPU_CHIPSET_PORTS:
		return (sysctl_rdquad(where, sizep, NULL,
		    alpha_pci_chipset->pc_ports));
	case CPU_CHIPSET_HAE_MASK:
		return (sysctl_rdquad(where, sizep, NULL,
		    alpha_pci_chipset->pc_hae_mask));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

int
pci_intr_map(struct pci_attach_args *pa, pci_intr_handle_t *ihp)
{
	if (pa->pa_intrpin == 0)	/* No IRQ used. */
		return 1;

	if (!(1 <= pa->pa_intrpin && pa->pa_intrpin <= 4))
		return 1;

	return (*(pa->pa_pc)->pc_intr_map)(pa, ihp);
}
@


1.19
log
@more proc.h needed
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.18 2010/04/20 23:35:16 deraadt Exp $	*/
d50 1
d143 12
@


1.18
log
@more misuse of user.h and sysctl.h
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.17 2007/11/03 10:09:03 martin Exp $	*/
d39 2
@


1.17
log
@use DEVICE_IS_VGA_PCI in vga_pci_match()

ok brad@@ fgsch@@ also tested by oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.16 2002/03/14 01:26:27 millert Exp $	*/
a42 1
#include <sys/sysctl.h>
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.15 2001/11/06 19:53:13 miod Exp $	*/
d88 1
a88 1
	nmatch = DEVICE_IS_VGA_PCI(class, id);
@


1.15
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.14 2001/11/04 23:12:46 art Exp $	*/
d74 2
a75 2
	int (*fn) __P((bus_space_tag_t, bus_space_tag_t, pci_chipset_tag_t,
	    int, int, int));
@


1.15.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.15 2001/11/06 19:53:13 miod Exp $	*/
d74 2
a75 2
	int (*fn)(bus_space_tag_t, bus_space_tag_t, pci_chipset_tag_t,
	    int, int, int);
@


1.14
log
@Two new sysctls in the chipset tree.
CPU_CHIPSET_PORTS - address of the I/O ports.
CPU_CHIPSET_HAE_MASK - mask for the HAE register.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.13 2001/08/08 15:21:29 millert Exp $	*/
d41 1
a41 1
#include <vm/vm.h>
@


1.13
log
@vga_{isa,pci}.h -> vga.h since the former no longer exists.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.12 2001/06/26 21:13:43 art Exp $	*/
d131 6
@


1.12
log
@More chipset info needed by X.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.11 2001/06/26 20:25:51 art Exp $	*/
d50 1
a50 1
#include "vga_pci.h"
@


1.11
log
@Provide some chipset information to usreland through sysctl.
The chipset support is not here yet, but the skeleton works.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.10 2000/07/03 19:30:21 mickey Exp $	*/
d127 4
a130 1
		    alpha_pci_chipset->pc_bwx));
@


1.10
log
@closer approximation to an alpha using new wscons.
tga moved to dev/pci.
by request from alpha people.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.9 1997/11/06 12:27:03 niklas Exp $	*/
d42 2
d60 2
d107 25
@


1.9
log
@Add some missing things for the MI vga driver.  Move wscons to an MI place as
well.  $OpenBSD$ tagging
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.8 1997/04/19 21:51:29 tholo Exp $	*/
d55 1
a55 1
#include <alpha/pci/tgavar.h>
d70 1
a70 1
	void (*fn) __P((bus_space_tag_t, bus_space_tag_t, pci_chipset_tag_t,
d87 1
a87 1
		fn = vga_pci_console;
d94 1
a94 1
		fn = tga_console;
@


1.9.10.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.10 2000/07/03 19:30:21 mickey Exp $	*/
d55 1
a55 1
#include <dev/pci/tgavar.h>
d70 1
a70 1
	int (*fn) __P((bus_space_tag_t, bus_space_tag_t, pci_chipset_tag_t,
d87 1
a87 1
		fn = vga_pci_cnattach;
d94 1
a94 1
		fn = tga_cnattach;
@


1.9.10.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.9.10.1 2001/04/18 16:01:24 niklas Exp $	*/
a41 2
#include <machine/cpu.h>
#include <sys/sysctl.h>
a57 2
struct alpha_pci_chipset *alpha_pci_chipset;

a102 28
}

int
alpha_sysctl_chipset(int *name, u_int namelen, char *where, size_t *sizep)
{
	if (namelen != 1)
		return (ENOTDIR);

	if (alpha_pci_chipset == NULL)
		return (EOPNOTSUPP);

	switch (name[0]) {
	case CPU_CHIPSET_TYPE:
		return (sysctl_rdstring(where, sizep, NULL,
		    alpha_pci_chipset->pc_name));
	case CPU_CHIPSET_BWX:
		return (sysctl_rdint(where, sizep, NULL,
		    alpha_pci_chipset->pc_bwx));
	case CPU_CHIPSET_MEM:
		return (sysctl_rdquad(where, sizep, NULL,
		    alpha_pci_chipset->pc_mem));
	case CPU_CHIPSET_DENSE:
		return (sysctl_rdquad(where, sizep, NULL,
		    alpha_pci_chipset->pc_dense));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
@


1.9.10.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.9.10.2 2001/07/04 10:14:45 niklas Exp $	*/
d50 1
a50 1
#include "vga.h"
@


1.9.10.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
#include <uvm/uvm_extern.h>
a130 6
	case CPU_CHIPSET_PORTS:
		return (sysctl_rdquad(where, sizep, NULL,
		    alpha_pci_chipset->pc_ports));
	case CPU_CHIPSET_HAE_MASK:
		return (sysctl_rdquad(where, sizep, NULL,
		    alpha_pci_chipset->pc_hae_mask));
@


1.9.10.5
log
@Merge in -current from about a week ago
@
text
@d74 2
a75 2
	int (*fn)(bus_space_tag_t, bus_space_tag_t, pci_chipset_tag_t,
	    int, int, int);
@


1.8
log
@Fix a compile warning
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.7 1997/01/24 19:57:52 niklas Exp $	*/
d50 1
a50 1
#include <alpha/pci/vga_pcivar.h>
@


1.7
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.6 1996/12/08 00:20:42 niklas Exp $	*/
d66 4
a69 1
	int match, nmatch;
@


1.6
log
@Merge to NetBSD 961107, i.e. mostly new bus.h
@
text
@d1 2
a2 2
/*	$OpenBSD: pci_machdep.c,v 1.5 1996/10/30 22:40:08 niklas Exp $	*/
/*	$NetBSD: pci_machdep.c,v 1.6 1996/10/23 04:12:29 cgd Exp $	*/
d48 3
a50 3
#include "pcivga.h"
#if NPCIVGA
#include <alpha/pci/pcivgavar.h>
d80 2
a81 2
#if NPCIVGA
	nmatch = DEVICE_IS_PCIVGA(class, id);
d84 1
a84 1
		fn = pcivga_console;
@


1.5
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 2
a2 2
/*	$OpenBSD: pci_machdep.c,v 1.5 1996/04/12 06:08:49 cgd Exp $	*/
/*	$NetBSD: pci_machdep.c,v 1.5 1996/04/12 06:08:49 cgd Exp $	*/
d59 2
a60 2
pci_display_console(bc, pc, bus, device, function)
	bus_chipset_tag_t bc;
d67 2
a68 1
	void (*fn) __P((bus_chipset_tag_t, pci_chipset_tag_t, int, int, int));
d96 1
a96 1
		(*fn)(bc, pc, bus, device, function);
@


1.4
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@@


1.3
log
@sync to 0616, retaining local diffs
@
text
@d1 1
@


1.2
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: pci_machdep.c,v 1.3 1995/11/23 02:38:07 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1995 Carnegie-Mellon University.
a39 1

d58 4
a61 8
pci_display_console(pcf, pcfa, pmf, pmfa, ppf, ppfa, bus, device, function)
	__const struct pci_conf_fns *pcf;
	__const struct pci_mem_fns *pmf;
	__const struct pci_pio_fns *ppf;
	void *pcfa, *pmfa, *ppfa;
	pci_bus_t bus;
	pci_device_t device;
	pci_function_t function;
d63 4
a66 2
	pci_conftag_t tag;
	pci_confreg_t id, class;
d68 2
a69 2
	tag = PCI_MAKE_TAG(bus, device, function);
	id = PCI_CONF_READ(pcf, pcfa, tag, PCI_ID_REG);
d73 4
a76 1
	class = PCI_CONF_READ(pcf, pcfa, tag, PCI_CLASS_REG);
d79 4
a82 4
	if (DEVICE_IS_PCIVGA(class, id)) {
		pcivga_console(pcf, pcfa, pmf, pmfa, ppf, ppfa, bus,
		    device, function);
		return;
a84 1

d86 4
a89 4
	if (DEVICE_IS_TGA(class, id)) {
		tga_console(pcf, pcfa, pmf, pmfa, ppf, ppfa, bus,
		    device, function);
		return;
d93 4
a96 1
	panic("pci_display_console: unconfigured device at %d/%d/%d",
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: pci_machdep.c,v 1.2 1995/08/03 00:33:58 cgd Exp $	*/
d4 2
a5 1
 * Copyright (c) 1994 Charles Hannum.  All rights reserved.
d7 13
a19 13
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d21 7
a27 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d44 1
a45 1
#include <dev/pci/pcireg.h>
a46 1
#include <alpha/pci/pci_chipset.h>
d49 4
d54 3
a56 44

int pcimatch __P((struct device *, void *, void *));
void pciattach __P((struct device *, struct device *, void *));

struct cfdriver pcicd = {
	NULL, "pci", pcimatch, pciattach, DV_DULL, sizeof(struct device)
};

int
pcimatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{

	return 1;
}

void
pciattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{

	printf("\n");
	(*pci_cs_fcns->cs_setup)();
	(*pci_cfg_fcns->cfg_attach)(parent, self, aux);
}

pcitag_t
pci_make_tag(bus, device, function)
	int bus, device, function;
{

	return (*pci_cs_fcns->cs_make_tag)(bus, device, function);
}

pcireg_t
pci_conf_read(tag, offset)
	pcitag_t tag;
	int offset;					/* XXX */
{

	return (*pci_cs_fcns->cs_conf_read)(tag, offset);
}
d59 8
a66 14
pci_conf_write(tag, offset, data)
	pcitag_t tag;
	int offset;					/* XXX */
	pcireg_t data;
{

	(*pci_cs_fcns->cs_conf_write)(tag, offset, data);
}

int
pci_map_io(tag, reg, iobasep)
	pcitag_t tag;
	int reg;
	int *iobasep;
d68 2
d71 2
a72 98
	return (*pci_cs_fcns->cs_map_io)(tag, reg, iobasep);
}

int
pci_map_mem(tag, reg, vap, pap)
	pcitag_t tag;
	int reg;
	vm_offset_t *vap, *pap;
{

	return (*pci_cs_fcns->cs_map_mem)(tag, reg, vap, pap);
}

int
pcidma_map(addr, size, mappings)
	caddr_t addr;
	vm_size_t size;
	vm_offset_t *mappings;
{

	return (*pci_cs_fcns->cs_pcidma_map)(addr, size, mappings);
}

void
pcidma_unmap(addr, size, nmappings, mappings)
	caddr_t addr;
	vm_size_t size;
	int nmappings;
	vm_offset_t *mappings;
{

	(*pci_cs_fcns->cs_pcidma_unmap)(addr, size, nmappings, mappings);
}

void *
pci_map_int(tag, level, func, arg)
	pcitag_t tag;
	pci_intrlevel level;
	int (*func) __P((void *));
	void *arg;
{
	pcireg_t data;
	int pin;

	data = pci_conf_read(tag, PCI_INTERRUPT_REG);

	pin = PCI_INTERRUPT_PIN(data);

	if (pin == 0) {
		/* No IRQ used. */
		return 0;
	}

	if (pin > 4) {
		printf("pci_map_int: bad interrupt pin %d\n", pin);
		return NULL;
	}

	return (*pci_cfg_fcns->cfg_map_int)(tag, level, func, arg, pin);
}

isa_intrlevel
pcilevel_to_isa(level)
	pci_intrlevel level;
{

	switch (level) {
	case PCI_IPL_NONE:
		return (ISA_IPL_NONE);

	case PCI_IPL_BIO:
		return (ISA_IPL_BIO);

	case PCI_IPL_NET:
		return (ISA_IPL_NET);

	case PCI_IPL_TTY:
		return (ISA_IPL_TTY);

	case PCI_IPL_CLOCK:
		return (ISA_IPL_CLOCK);

	default:
		panic("pcilevel_to_isa: unknown level %d\n", level);
	}
}

void
pci_display_console(bus, device, function)
	int bus, device, function;
{
	pcitag_t tag;
	pcireg_t id, class;

	/* XXX */
	tag = pci_make_tag(bus, device, function);

	id = pci_conf_read(tag, PCI_ID_REG);
d76 1
a76 7
	class = pci_conf_read(tag, PCI_CLASS_REG);

	if (PCI_CLASS(class) != PCI_CLASS_DISPLAY &&
	    !(PCI_CLASS(class) == PCI_CLASS_PREHISTORIC &&
	     PCI_SUBCLASS(class) == PCI_SUBCLASS_PREHISTORIC_VGA))
		panic("pci_display_console: device at %d/%d/%d not a display",
		    bus, device, function);
a77 4
	if ((PCI_CLASS(class) == PCI_CLASS_DISPLAY &&
	     PCI_SUBCLASS(class) == PCI_SUBCLASS_DISPLAY_VGA) ||
	    (PCI_CLASS(class) == PCI_CLASS_PREHISTORIC &&
	     PCI_SUBCLASS(class) == PCI_SUBCLASS_PREHISTORIC_VGA)) {
d79 3
a81 4
		pcivga_console(bus, device, function);
#else
		panic("pci_display_console: pcivga is console, not configured");
#endif
d84 1
a85 2
	if (PCI_VENDOR(id) == PCI_VENDOR_DEC &&
	    PCI_PRODUCT(id) == PCI_PRODUCT_DEC_21030) {
d87 3
a89 4
		tga_console(bus, device, function);
#else
		panic("pci_display_console: tga is console, not configured");
#endif
d92 1
d94 1
a94 1
	panic("pci_display_console: unsupported device at %d/%d/%d",
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
