head	1.29;
access;
symbols
	OPENBSD_6_1:1.28.0.10
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.6
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.4
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.26.0.20
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.16
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.14
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.12
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.10
	OPENBSD_5_0:1.26.0.8
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.6
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.4
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.23.0.8
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.4
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.2
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.22.0.8
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.6
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.4
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.20.0.6
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.4
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.18.0.6
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.4
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.18
	UBC:1.16.0.2
	UBC_BASE:1.16
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.11.0.12
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.11.0.10
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.8
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.6
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.4
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.6
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.4
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6;
locks; strict;
comment	@ * @;


1.29
date	2017.09.08.05.36.51;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	uRv5pa9QDlZaYgwD;

1.28
date	2015.07.26.05.09.44;	author miod;	state Exp;
branches;
next	1.27;
commitid	5evJqb5U3VOxLlWE;

1.27
date	2014.05.08.20.46.49;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2009.09.30.20.18.06;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2009.09.30.20.16.31;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.23;

1.23
date	2008.07.22.18.45.51;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2006.06.15.20.08.29;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2006.01.29.10.47.35;	author martin;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.28.02.28.43;	author aaron;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.10.21.11.12;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.03.15.50;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.26.27;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.14.00.44.59;	author nate;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.11.06.19.53.13;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.29.07.14.35;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.17.22.26.58;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.25.21.49.42;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	99.01.11.05.11.03;	author millert;	state Exp;
branches
	1.11.6.1;
next	1.10;

1.10
date	98.07.01.05.32.41;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	97.01.24.19.57.51;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.12.08.00.20.41;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.10.30.22.40.06;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.10.04.03.06.04;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.07.29.23.00.40;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.06.18.09.44.27;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.02.20.04.35.25;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	95.12.27.22.25.34;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.14.03.53.30;	author deraadt;	state Exp;
branches;
next	;

1.11.6.1
date	2001.07.04.10.14.45;	author niklas;	state Exp;
branches;
next	1.11.6.2;

1.11.6.2
date	2001.10.31.02.52.44;	author nate;	state Exp;
branches;
next	1.11.6.3;

1.11.6.3
date	2001.11.13.21.00.49;	author niklas;	state Exp;
branches;
next	1.11.6.4;

1.11.6.4
date	2002.03.06.00.55.15;	author niklas;	state Exp;
branches;
next	1.11.6.5;

1.11.6.5
date	2002.03.28.10.06.13;	author niklas;	state Exp;
branches;
next	1.11.6.6;

1.11.6.6
date	2003.05.13.19.41.02;	author ho;	state Exp;
branches;
next	;

1.16.2.1
date	2002.06.11.03.33.40;	author art;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2003.05.19.21.38.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.29
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: pci_kn20aa.c,v 1.28 2015/07/26 05:09:44 miod Exp $	*/
/*	$NetBSD: pci_kn20aa.c,v 1.21 1996/11/17 02:05:27 cgd Exp $	*/

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/time.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/syslog.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/ppbreg.h>

#include <alpha/pci/ciareg.h>
#include <alpha/pci/ciavar.h>

#include <alpha/pci/pci_kn20aa.h>

#include "sio.h"
#if NSIO
#include <alpha/pci/siovar.h>
#endif

int	dec_kn20aa_intr_map(struct pci_attach_args *, pci_intr_handle_t *);
const char *dec_kn20aa_intr_string(void *, pci_intr_handle_t);
int	dec_kn20aa_intr_line(void *, pci_intr_handle_t);
void	*dec_kn20aa_intr_establish(void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, const char *);
void	dec_kn20aa_intr_disestablish(void *, void *);

#define	KN20AA_PCEB_IRQ	31
#define	KN20AA_MAX_IRQ	32
#define	PCI_STRAY_MAX	5

struct alpha_shared_intr *kn20aa_pci_intr;
struct evcount kn20aa_intr_count;

void	kn20aa_iointr(void *arg, unsigned long vec);
void	kn20aa_enable_intr(int irq);
void	kn20aa_disable_intr(int irq);

void
pci_kn20aa_pickintr(ccp)
	struct cia_config *ccp;
{
	int i;
	bus_space_tag_t iot = &ccp->cc_iot;
	pci_chipset_tag_t pc = &ccp->cc_pc;

        pc->pc_intr_v = ccp;
        pc->pc_intr_map = dec_kn20aa_intr_map;
        pc->pc_intr_string = dec_kn20aa_intr_string;
        pc->pc_intr_line = dec_kn20aa_intr_line;
        pc->pc_intr_establish = dec_kn20aa_intr_establish;
        pc->pc_intr_disestablish = dec_kn20aa_intr_disestablish;

        /* Not supported on KN20AA. */
        pc->pc_pciide_compat_intr_establish = NULL;
        pc->pc_pciide_compat_intr_disestablish = NULL;

	kn20aa_pci_intr = alpha_shared_intr_alloc(KN20AA_MAX_IRQ);
	for (i = 0; i < KN20AA_MAX_IRQ; i++)
		alpha_shared_intr_set_maxstrays(kn20aa_pci_intr, i,
		    PCI_STRAY_MAX);

#if NSIO
	sio_intr_setup(pc, iot);
	kn20aa_enable_intr(KN20AA_PCEB_IRQ);
#endif
}

int     
dec_kn20aa_intr_map(pa, ihp)
	struct pci_attach_args *pa;
        pci_intr_handle_t *ihp;
{
	pcitag_t bustag = pa->pa_intrtag;
	int buspin = pa->pa_intrpin;
	pci_chipset_tag_t pc = pa->pa_pc;
	int device;
	int kn20aa_irq;

	if (pa->pa_bridgetag) {
		buspin = PPB_INTERRUPT_SWIZZLE(pa->pa_rawintrpin,
		    pa->pa_device);
		if (pa->pa_bridgeih[buspin - 1] != 0) {
			*ihp = pa->pa_bridgeih[buspin - 1];
			return 0;
		}

		return 1;
	}

	/*
	 * Slot->interrupt translation.  Appears to work, though it
	 * may not hold up forever.
	 *
	 * The DEC engineers who did this hardware obviously engaged
	 * in random drug testing.
	 */
	pci_decompose_tag(pc, bustag, NULL, &device, NULL);
	switch (device) {
	case 11:
	case 12:
		kn20aa_irq = ((device - 11) + 0) * 4;
		break;

	case 7:
		kn20aa_irq = 8;
		break;

	case 9:
		kn20aa_irq = 12;
		break;

	case 6:					/* 21040 on AlphaStation 500 */
		kn20aa_irq = 13;
		break;

	case 8:
		kn20aa_irq = 16;
		break;

	default:
		printf("dec_kn20aa_intr_map: don't know how to setup %d/%d/%d\n",
		    pa->pa_bus, pa->pa_device, pa->pa_function);
                return 1;
	}

	if (kn20aa_irq != 13)
		kn20aa_irq += buspin - 1;

	if (kn20aa_irq >= KN20AA_MAX_IRQ) {
		printf("dec_kn20aa_intr_map: kn20aa_irq %d too large for %d/%d/%d\n",
		    kn20aa_irq, pa->pa_bus, pa->pa_device, pa->pa_function);
		return 1;
	}

	*ihp = kn20aa_irq;
	return 0;
}

const char *
dec_kn20aa_intr_string(ccv, ih)
	void *ccv;
	pci_intr_handle_t ih;
{
        static char irqstr[15];          /* 11 + 2 + NULL + sanity */

        if (ih > KN20AA_MAX_IRQ)
		panic("dec_kn20aa_intr_string: bogus kn20aa IRQ 0x%lx", ih);

        snprintf(irqstr, sizeof irqstr, "kn20aa irq %ld", ih);
        return (irqstr);
}

int
dec_kn20aa_intr_line(ccv, ih)
	void *ccv;
	pci_intr_handle_t ih;
{
	return (ih);
}

void *
dec_kn20aa_intr_establish(ccv, ih, level, func, arg, name)
        void *ccv, *arg;
        pci_intr_handle_t ih;
        int level;
        int (*func)(void *);
	const char *name;
{           
	void *cookie;

        if (ih > KN20AA_MAX_IRQ)
                panic("dec_kn20aa_intr_establish: bogus kn20aa IRQ 0x%lx",
		    ih);

	cookie = alpha_shared_intr_establish(kn20aa_pci_intr, ih, IST_LEVEL,
	    level, func, arg, name);

	if (cookie != NULL &&
	    alpha_shared_intr_firstactive(kn20aa_pci_intr, ih)) {
		scb_set(0x900 + SCB_IDXTOVEC(ih), kn20aa_iointr, NULL);
		kn20aa_enable_intr(ih);
	}
	return (cookie);
}

void    
dec_kn20aa_intr_disestablish(ccv, cookie)
        void *ccv, *cookie;
{
	struct alpha_shared_intrhand *ih = cookie;
	unsigned int irq = ih->ih_num;
	int s;

	s = splhigh();

	alpha_shared_intr_disestablish(kn20aa_pci_intr, cookie);
	if (alpha_shared_intr_isactive(kn20aa_pci_intr, irq) == 0) {
		kn20aa_disable_intr(irq);
		alpha_shared_intr_set_dfltsharetype(kn20aa_pci_intr, irq,
		    IST_NONE);
		scb_free(0x900 + SCB_IDXTOVEC(irq));
	}
	splx(s);
}

void
kn20aa_iointr(arg, vec)
	void *arg;
	unsigned long vec;
{
	int irq;

	irq = SCB_VECTOIDX(vec - 0x900);

	if (!alpha_shared_intr_dispatch(kn20aa_pci_intr, irq)) {
		alpha_shared_intr_stray(kn20aa_pci_intr, irq,
		    "kn20aa irq");
		if (ALPHA_SHARED_INTR_DISABLE(kn20aa_pci_intr, irq))
			kn20aa_disable_intr(irq);
	} else
		alpha_shared_intr_reset_strays(kn20aa_pci_intr, irq);
}

void
kn20aa_enable_intr(irq)
	int irq;
{

	/*
	 * From disassembling small bits of the OSF/1 kernel:
	 * the following appears to enable a given interrupt request.
	 * "blech."  I'd give valuable body parts for better docs or
	 * for a good decompiler.
	 */
	alpha_mb();
	REGVAL(0x8780000000L + 0x40L) |= (1 << irq);	/* XXX */
	alpha_mb();
}

void
kn20aa_disable_intr(irq)
	int irq;
{

	alpha_mb();
	REGVAL(0x8780000000L + 0x40L) &= ~(1 << irq);	/* XXX */
	alpha_mb();
}
@


1.28
log
@Make sure pci_intr_map() will perform proper interrupt swizzling for devices
behind a bridge, if the SRM didn't pick an interrupt line for them.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.27 2014/05/08 20:46:49 miod Exp $	*/
a30 1
#include <sys/types.h>
@


1.27
log
@Format string fixes for alpha kernels, and remove -Wno-format
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.26 2009/09/30 20:18:06 miod Exp $	*/
d46 1
d117 10
a126 8
        if (buspin == 0) {
                /* No IRQ used. */
                return 1;
        }
        if (buspin > 4) {
                printf("pci_map_int: bad interrupt pin %d\n", buspin);
                return 1;
        }
d159 2
a160 2
                printf("dec_kn20aa_intr_map: weird device number %d\n",
		    device);
d164 8
a171 4
	kn20aa_irq += buspin - 1;
	if (kn20aa_irq >= KN20AA_MAX_IRQ)
		panic("pci_kn20aa_map_int: kn20aa_irq too large (%d)",
		    kn20aa_irq);
d174 1
a174 1
	return (0);
@


1.26
log
@Fix various off-by-ones in irq number validation.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.25 2009/09/30 20:16:31 miod Exp $	*/
d178 1
a178 1
		panic("dec_kn20aa_intr_string: bogus kn20aa IRQ 0x%x", ih);
d203 1
a203 1
                panic("dec_kn20aa_intr_establish: bogus kn20aa IRQ 0x%x",
@


1.25
log
@Remove unused last argument of alpha_shared_intr_disestablish().
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.24 2009/08/22 02:54:50 mk Exp $	*/
d162 1
a162 1
	if (kn20aa_irq > KN20AA_MAX_IRQ)
@


1.24
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.23 2008/07/22 18:45:51 miod Exp $	*/
d227 1
a227 2
	alpha_shared_intr_disestablish(kn20aa_pci_intr, cookie,
	    "kn20aa irq");
@


1.23
log
@Modify pci_intr_map() implementation to pass the pci_attach_args to the
per-platform implementation, instead of selected members of it; this allows
us to get rid of some globals, and paves the way for better bridge support
on some models.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.22 2006/06/15 20:08:29 brad Exp $	*/
d61 1
a61 1
	    int, int (*func)(void *), void *, char *);
d198 1
a198 1
	char *name;
@


1.22
log
@Rework the interrupt code, shaving some cycles off in the process.
Rather than an "iointr" routine that decomposes a vector into an
IRQ, we maintain a vector table directly, hooking up each "iointr"
routine at the correct vector. This also allows us to hook device
interrupts up to specific vectors.

From thorpej NetBSD

Tested by myself and a number of end-users.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.21 2006/01/29 10:47:35 martin Exp $	*/
d57 1
a57 2
int	dec_kn20aa_intr_map(void *, pcitag_t, int, int,
	    pci_intr_handle_t *);
d106 2
a107 4
dec_kn20aa_intr_map(ccv, bustag, buspin, line, ihp)
        void *ccv;
        pcitag_t bustag; 
        int buspin, line;
d110 3
a112 2
	struct cia_config *ccp = ccv;
	pci_chipset_tag_t pc = &ccp->cc_pc;
@


1.21
log
@Add a alpha_shared_intr_reset_strays() function that resets the stray
interrupt counter for a given shared interrupt descriptor.
When an interrupt is successfully handled, reset the strays counter,
thus preventing a "slow leak" from eventually shutting off the interrupt
vector.

from NetBSD via KUDO Takashi
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.20 2004/06/28 02:28:43 aaron Exp $	*/
d72 1
a72 1
void	kn20aa_iointr(void *framep, unsigned long vec);
a103 2

	set_iointr(kn20aa_iointr);
d212 2
a213 1
	    alpha_shared_intr_isactive(kn20aa_pci_intr, ih))
d215 1
d235 1
a235 1
		/* scb_free(0x900 + SCB_IDXTOVEC(irq)); */
d241 2
a242 2
kn20aa_iointr(framep, vec)
	void *framep;
d247 9
a255 24
	if (vec >= 0x900) {
		if (vec >= 0x900 + (KN20AA_MAX_IRQ << 4))
			panic("kn20aa_iointr: vec 0x%x out of range", vec);
		irq = (vec - 0x900) >> 4;

		kn20aa_intr_count.ec_count++;

		if (!alpha_shared_intr_dispatch(kn20aa_pci_intr, irq)) {
			alpha_shared_intr_stray(kn20aa_pci_intr, irq,
			    "kn20aa irq");
			if (kn20aa_pci_intr[irq].intr_nstrays ==
			    kn20aa_pci_intr[irq].intr_maxstrays)
				kn20aa_disable_intr(irq);
		} else
			alpha_shared_intr_reset_strays(kn20aa_pci_intr, irq);
		return;
	}
#if NSIO
	if (vec >= 0x800) {
		sio_iointr(framep, vec);
		return;
	} 
#endif
	panic("kn20aa_iointr: weird vec 0x%x", vec);
@


1.20
log
@Use new event counter API for interrupt counting on alpha.  By me, with some
edits by Theo.  deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.19 2003/05/10 21:11:12 deraadt Exp $	*/
d260 2
a261 1
		}
@


1.19
log
@string cleaning; ok beck dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.18 2002/03/14 03:15:50 millert Exp $	*/
a51 4
#ifndef EVCNT_COUNTERS
#include <machine/intrcnt.h>
#endif

d70 1
a70 3
#ifdef EVCNT_COUNTERS
struct evcnt kn20aa_intr_evcnt;
#endif
d252 1
a252 7
#ifdef EVCNT_COUNTERS
		kn20aa_intr_evcnt.ev_count++;
#else
		if (KN20AA_MAX_IRQ != INTRCNT_KN20AA_IRQ_LEN)
			panic("kn20aa interrupt counter sizes inconsistent");
		intrcnt[INTRCNT_KN20AA_IRQ + irq]++;
#endif
@


1.18
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.17 2002/03/14 01:26:27 millert Exp $	*/
d190 1
a190 1
        sprintf(irqstr, "kn20aa irq %ld", ih);
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.16 2001/12/14 00:44:59 nate Exp $	*/
d65 2
a66 2
void	*dec_kn20aa_intr_establish __P((void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, char *));
@


1.16
log
@Don't use a single static struct alpha_bus_space since there are machines
that can have more than one system bus attached to mainbus
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.15 2001/11/06 19:53:13 miod Exp $	*/
d61 4
a64 4
int	dec_kn20aa_intr_map __P((void *, pcitag_t, int, int,
	    pci_intr_handle_t *));
const char *dec_kn20aa_intr_string __P((void *, pci_intr_handle_t));
int	dec_kn20aa_intr_line __P((void *, pci_intr_handle_t));
d67 1
a67 1
void	dec_kn20aa_intr_disestablish __P((void *, void *));
d78 3
a80 3
void	kn20aa_iointr __P((void *framep, unsigned long vec));
void	kn20aa_enable_intr __P((int irq));
void	kn20aa_disable_intr __P((int irq));
d207 1
a207 1
        int (*func) __P((void *));
@


1.16.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.16 2001/12/14 00:44:59 nate Exp $	*/
d61 7
a67 7
int	dec_kn20aa_intr_map(void *, pcitag_t, int, int,
	    pci_intr_handle_t *);
const char *dec_kn20aa_intr_string(void *, pci_intr_handle_t);
int	dec_kn20aa_intr_line(void *, pci_intr_handle_t);
void	*dec_kn20aa_intr_establish(void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, char *);
void	dec_kn20aa_intr_disestablish(void *, void *);
d78 3
a80 3
void	kn20aa_iointr(void *framep, unsigned long vec);
void	kn20aa_enable_intr(int irq);
void	kn20aa_disable_intr(int irq);
d207 1
a207 1
        int (*func)(void *);
@


1.16.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d190 1
a190 1
        snprintf(irqstr, sizeof irqstr, "kn20aa irq %ld", ih);
@


1.15
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.14 2001/09/29 07:14:35 mickey Exp $	*/
d87 1
a87 1
	bus_space_tag_t iot = ccp->cc_iot;
@


1.14
log
@dec_kn20aa_intr_disestablish() implementation from netbsd; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.13 2001/08/17 22:26:58 mickey Exp $	*/
d40 1
a40 1
#include <vm/vm.h>
@


1.13
log
@provide a way to get the number used for irq line, not only a string
representation, this is needed for devices like cbb which pass
the interrupt line down to the cardbus attachment and not
getting the right line before pci_intr_map() has done it's
dirty deed.
tested on i386 by jason@@, compiles on alpha by art@@.
ppc and mveppc are to be test-compiled, but should work (;
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.12 2001/06/25 21:49:42 csapuntz Exp $	*/
d229 15
a243 1
	panic("dec_kn20aa_intr_disestablish not implemented"); /* XXX */
@


1.12
log
@

Add disestablish for pciide on Alpha
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.11 1999/01/11 05:11:03 millert Exp $	*/
d64 1
d93 1
d192 8
@


1.11
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.10 1998/07/01 05:32:41 angelos Exp $	*/
d97 1
@


1.11.6.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.11 1999/01/11 05:11:03 millert Exp $	*/
a96 1
        pc->pc_pciide_compat_intr_disestablish = NULL;
@


1.11.6.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.11.6.1 2001/07/04 10:14:45 niklas Exp $	*/
a63 1
int	dec_kn20aa_intr_line __P((void *, pci_intr_handle_t));
a91 1
        pc->pc_intr_line = dec_kn20aa_intr_line;
a191 8
int
dec_kn20aa_intr_line(ccv, ih)
	void *ccv;
	pci_intr_handle_t ih;
{
	return (ih);
}

d219 1
a219 15
	struct alpha_shared_intrhand *ih = cookie;
	unsigned int irq = ih->ih_num;
	int s;

	s = splhigh();

	alpha_shared_intr_disestablish(kn20aa_pci_intr, cookie,
	    "kn20aa irq");
	if (alpha_shared_intr_isactive(kn20aa_pci_intr, irq) == 0) {
		kn20aa_disable_intr(irq);
		alpha_shared_intr_set_dfltsharetype(kn20aa_pci_intr, irq,
		    IST_NONE);
		/* scb_free(0x900 + SCB_IDXTOVEC(irq)); */
	}
	splx(s);
@


1.11.6.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d40 1
a40 1
#include <uvm/uvm_extern.h>
@


1.11.6.4
log
@Merge in trunk
@
text
@d87 1
a87 1
	bus_space_tag_t iot = &ccp->cc_iot;
@


1.11.6.5
log
@Merge in -current from about a week ago
@
text
@d61 7
a67 7
int	dec_kn20aa_intr_map(void *, pcitag_t, int, int,
	    pci_intr_handle_t *);
const char *dec_kn20aa_intr_string(void *, pci_intr_handle_t);
int	dec_kn20aa_intr_line(void *, pci_intr_handle_t);
void	*dec_kn20aa_intr_establish(void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, char *);
void	dec_kn20aa_intr_disestablish(void *, void *);
d78 3
a80 3
void	kn20aa_iointr(void *framep, unsigned long vec);
void	kn20aa_enable_intr(int irq);
void	kn20aa_disable_intr(int irq);
d207 1
a207 1
        int (*func)(void *);
@


1.11.6.6
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.11.6.5 2002/03/28 10:06:13 niklas Exp $	*/
d190 1
a190 1
        snprintf(irqstr, sizeof irqstr, "kn20aa irq %ld", ih);
@


1.10
log
@First shot for EB164SX/LX support; kernels for those should be much
more stable now, but by no means production-strong. A lot of code from
NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.9 1997/01/24 19:57:51 niklas Exp $	*/
d170 1
a170 1
		panic("pci_kn20aa_map_int: kn20aa_irq too large (%d)\n",
d185 1
a185 1
		panic("dec_kn20aa_intr_string: bogus kn20aa IRQ 0x%x\n", ih);
d202 1
a202 1
                panic("dec_kn20aa_intr_establish: bogus kn20aa IRQ 0x%x\n",
d230 1
a230 1
			panic("kn20aa_iointr: vec 0x%x out of range\n", vec);
d256 1
a256 1
	panic("kn20aa_iointr: weird vec 0x%x\n", vec);
@


1.9
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.8 1996/12/08 00:20:41 niklas Exp $	*/
d95 3
d104 1
a104 1
	sio_intr_setup(iot);
@


1.8
log
@Merge to NetBSD 961107, i.e. mostly new bus.h
@
text
@d1 2
a2 2
/*	$OpenBSD: pci_kn20aa.c,v 1.7 1996/10/30 22:40:06 niklas Exp $	*/
/*	$NetBSD: pci_kn20aa.c,v 1.19 1996/10/23 04:12:28 cgd Exp $	*/
d72 1
a72 11
struct kn20aa_intrhand {
	TAILQ_ENTRY(kn20aa_intrhand) ih_q;
        int     (*ih_fun) __P((void *));
        void    *ih_arg;
        u_long  ih_count;
        int     ih_level;
};
TAILQ_HEAD(kn20aa_intrchain, kn20aa_intrhand);

struct kn20aa_intrchain kn20aa_pci_intrs[KN20AA_MAX_IRQ];
int	kn20aa_pci_strayintrcnt[KN20AA_MAX_IRQ];
a76 1
void	kn20aa_pci_strayintr __P((int irq));
a79 2
struct kn20aa_intrhand *kn20aa_attach_intr __P((struct kn20aa_intrchain *,
			    int, int (*) (void *), void *));
a88 3
	for (i = 0; i < KN20AA_MAX_IRQ; i++)
		TAILQ_INIT(&kn20aa_pci_intrs[i]);

d95 5
d102 1
a105 7

#if NSIO
	kn20aa_enable_intr(KN20AA_PCEB_IRQ);
#if 0 /* XXX init PCEB interrupt handler? */
	kn20aa_attach_intr(&kn20aa_pci_intrs[KN20AA_PCEB_IRQ], ???, ???, ???);
#endif
#endif
d160 1
a160 7
#ifdef KN20AA_BOGUS_IRQ_FROB
		*ihp = 0xdeadbeef;
		printf("\n\n BOGUS INTERRUPT MAPPING: dev %d, pin %d\n",
		    device, buspin);
		return (0);
#endif
		panic("pci_kn20aa_map_int: invalid device number %d\n",
d162 1
a180 6
#ifdef KN20AA_BOGUS_IRQ_FROB
	if (ih == 0xdeadbeef) {
		sprintf(irqstr, "BOGUS");
		return (irqstr);
	}
#endif
d182 1
a182 2
                panic("dec_kn20aa_a50_intr_string: bogus kn20aa IRQ 0x%x\n",
		    ih);
d184 1
a184 1
        sprintf(irqstr, "kn20aa irq %d", ih);
a197 16
#ifdef KN20AA_BOGUS_IRQ_FROB
	if (ih == 0xdeadbeef) {
		int i;
		char chars[10];

		printf("dec_kn20aa_intr_establish: BOGUS IRQ\n");
		do {
			printf("IRQ to enable? ");
			getstr(chars, 10);
			i = atoi(chars);
		} while (i < 0 || i > 32);
		printf("ENABLING IRQ %d\n", i);
		kn20aa_enable_intr(i);
		return ((void *)0xbabefacedeadbeef);
	}
#endif
d202 6
a207 2
	cookie = kn20aa_attach_intr(&kn20aa_pci_intrs[ih], level, func, arg);
	kn20aa_enable_intr(ih);
a217 17
/*
 * caught a stray interrupt; notify if not too many seen already.
 */
void
kn20aa_pci_strayintr(irq)
	int irq;
{

	kn20aa_pci_strayintrcnt[irq]++;
	if (kn20aa_pci_strayintrcnt[irq] == PCI_STRAY_MAX)
		kn20aa_disable_intr(irq);

	log(LOG_ERR, "stray kn20aa irq %d\n", irq);
	if (kn20aa_pci_strayintrcnt[irq] == PCI_STRAY_MAX)
		log(LOG_ERR, "disabling interrupts on kn20aa irq %d\n", irq);
}

d223 1
a223 2
	struct kn20aa_intrhand *ih;
	int irq, handled;
d238 6
a243 8
		for (ih = kn20aa_pci_intrs[irq].tqh_first, handled = 0;
		    ih != NULL; ih = ih->ih_q.tqe_next) {
			int rv;

			rv = (*ih->ih_fun)(ih->ih_arg);

			ih->ih_count++;
			handled = handled || (rv != 0);
a244 2
		if (!handled)
			kn20aa_pci_strayintr(irq);
d247 1
a248 1
#if NSIO
a249 1
#endif
d252 1
a279 21
}

struct kn20aa_intrhand *
kn20aa_attach_intr(chain, level, func, arg)
	struct kn20aa_intrchain *chain;
	int level;
	int (*func) __P((void *));
	void *arg;
{
	struct kn20aa_intrhand *nintrhand;

	nintrhand = (struct kn20aa_intrhand *)
	    malloc(sizeof *nintrhand, M_DEVBUF, M_WAITOK);

        nintrhand->ih_fun = func;
        nintrhand->ih_arg = arg;
        nintrhand->ih_count = 0;
        nintrhand->ih_level = level;
	TAILQ_INSERT_TAIL(chain, nintrhand, ih_q);
	
	return (nintrhand);
@


1.7
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 2
a2 2
/*	$OpenBSD: pci_kn20aa.c,v 1.18 1996/10/13 03:00:12 christos Exp $	*/
/*	$NetBSD: pci_kn20aa.c,v 1.18 1996/10/13 03:00:12 christos Exp $	*/
d99 1
a99 1
	bus_chipset_tag_t bc = &ccp->cc_bc;
d112 1
a112 1
	sio_intr_setup(bc);
@


1.6
log
@sync
@
text
@d1 2
a2 2
/*	$OpenBSD: pci_kn20aa.c,v 1.5 1996/07/29 23:00:40 niklas Exp $	*/
/*	$NetBSD: pci_kn20aa.c,v 1.3.4.2 1996/06/13 18:35:31 cgd Exp $	*/
d42 2
d74 1
a74 1
        int     (*ih_fun)();
d88 1
a88 1
void	kn20aa_iointr __P((void *framep, int vec));
a98 1
	struct kn20aa_intrhand *nintrhand;
a135 1
	void *ih;
d177 6
a200 1
	struct cia_config *ccp = ccv;
d203 6
a224 1
        struct cia_config *ccp = ccv;
d227 16
a255 2
	struct cia_config *ccp = ccv;

d279 1
a279 1
	int vec;
d330 1
a330 1
	wbflush();
d332 1
a332 1
	wbflush();
d340 1
a340 1
	wbflush();
d342 1
a342 1
	wbflush();
@


1.5
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_kn20aa.c,v 1.3.4.2 1996/06/13 18:35:31 cgd Exp $	*/
d88 1
d134 1
a134 1
	int kn20aa_slot, kn20aa_irq;
d139 1
a139 1
                return 0;
d143 1
a143 1
                return NULL;
d157 1
a157 1
		kn20aa_slot = (device - 11) + 0;
d161 1
a161 1
		kn20aa_slot = 2;
d164 6
a169 2
	case 8:
		kn20aa_slot = 4;
d172 2
a173 2
	case 9:
		kn20aa_slot = 3;
d181 1
a181 1
	kn20aa_irq = (kn20aa_slot * 4) + buspin - 1;
d187 1
d243 7
a249 4
	if (++kn20aa_pci_strayintrcnt[irq] <= PCI_STRAY_MAX)
		log(LOG_ERR, "stray PCI interrupt %d%s\n", irq,
		    kn20aa_pci_strayintrcnt[irq] >= PCI_STRAY_MAX ?
		    "; stopped logging" : "");
d301 1
a301 1
	 * From disassembling the OSF/1 source code:
d308 10
@


1.4
log
@sync to 0616, retaining local diffs
@
text
@d1 1
d63 1
a63 1
	    int, int (*func)(void *), void *));
d201 1
a201 1
dec_kn20aa_intr_establish(ccv, ih, level, func, arg)
d206 1
@


1.3
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d1 1
a1 1
/*	$NetBSD: pci_kn20aa.c,v 1.2 1995/12/24 02:29:45 mycroft Exp $	*/
d4 1
a4 1
 * Copyright (c) 1995 Carnegie-Mellon University.
d58 6
a63 8
void	*kn20aa_pci_map_int __P((void *, pci_conftag_t, pci_intr_pin_t,
	    pci_intr_line_t, int, int (*func)(void *), void *, char *));
void	kn20aa_pci_unmap_int __P((void *, void *));

__const struct pci_intr_fns kn20aa_pci_intr_fns = {
	kn20aa_pci_map_int,
	kn20aa_pci_unmap_int,
};
d91 2
a92 6
pci_kn20aa_pickintr(pcf, pcfa, ppf, ppfa, pifp, pifap)
	__const struct pci_conf_fns *pcf;
	__const struct pci_pio_fns *ppf;
	void *pcfa, *ppfa;
	__const struct pci_intr_fns **pifp;
	void **pifap;
d96 2
a97 1

d102 5
a106 2
	*pifp = &kn20aa_pci_intr_fns;
	*pifap = NULL;					/* XXX ? */
d109 1
a109 1
	sio_intr_setup(ppf, ppfa);
d122 6
a127 10
void *
kn20aa_pci_map_int(ccv, tag, pin, line, level, func, arg, what)
	void *ccv;
        pci_conftag_t tag;
	pci_intr_pin_t pin;
	pci_intr_line_t line;
        int level;
        int (*func) __P((void *));
        void *arg;
	char *what;
d129 2
d135 1
a135 1
        if (pin == 0) {
d139 2
a140 2
        if (pin > 4) {
                printf("pci_map_int: bad interrupt pin %d\n", pin);
d151 2
a152 1
	switch (device = PCI_TAG_DEVICE(tag)) {
d175 1
a175 1
	kn20aa_irq = (kn20aa_slot * 4) + pin - 1;
d180 14
a193 4
#if 0
	printf("kn20aa_attach_intr: func 0x%lx, arg 0x%lx, level %d, irq %d\n",
	    func, arg, level, kn20aa_irq);
#endif
d195 2
a196 4
	ih = kn20aa_attach_intr(&kn20aa_pci_intrs[kn20aa_irq], level,
	    func, arg);
	kn20aa_enable_intr(kn20aa_irq);
	return (ih);
d199 8
a206 3
void
kn20aa_pci_unmap_int(pifa, cookie)
	void *pifa;
d208 13
d222 1
d224 1
a224 1
	panic("kn20aa_pci_unmap_int not implemented");	/* XXX */
@


1.2
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
@
text
@d59 1
a59 1
	    pci_intr_line_t, int, int (*func)(void *), void *));
d125 1
a125 1
kn20aa_pci_map_int(ccv, tag, pin, line, level, func, arg)
d133 1
@


1.1
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: pci_kn20aa.c,v 1.1 1995/11/23 02:38:00 cgd Exp $	*/
d59 1
a59 1
	    pci_intr_line_t, pci_intrlevel_t, int (*func)(void *), void *));
d90 1
a90 1
			    pci_intrlevel_t, int (*) (void *), void *));
d130 1
a130 1
        pci_intrlevel_t level;
d278 1
a278 1
	pci_intrlevel_t level;
@
