head	1.17;
access;
symbols
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	UBC_SYNC_A:1.17
	UBC_SYNC_B:1.17
	OPENBSD_2_8:1.15.0.10
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.15.0.8
	OPENBSD_2_7_BASE:1.15
	SMP:1.15.0.6
	SMP_BASE:1.15
	kame_19991208:1.15
	OPENBSD_2_6:1.15.0.4
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.15.0.2
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.14.0.4
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.14.0.2
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2001.02.03.12.18.21;	author art;	state dead;
branches;
next	1.16;

1.16
date	2000.11.13.15.53.33;	author aaron;	state Exp;
branches;
next	1.15;

1.15
date	99.01.08.03.16.15;	author niklas;	state Exp;
branches
	1.15.6.1;
next	1.14;

1.14
date	98.02.05.22.57.51;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.02.05.16.47.59;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.11.06.12.27.02;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	97.07.08.11.19.41;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	97.07.06.16.32.57;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.01.24.19.57.26;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.12.08.00.20.28;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.11.12.20.29.32;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.10.30.22.39.40;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.07.29.22.59.49;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.06.18.09.43.47;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.27.22.24.39;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.53.16;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.44;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.44;	author deraadt;	state Exp;
branches;
next	;

1.15.6.1
date	2001.04.18.16.01.02;	author niklas;	state dead;
branches;
next	;


desc
@@


1.17
log
@Remove dead files.
@
text
@/*	$OpenBSD: pckbd.c,v 1.16 2000/11/13 15:53:33 aaron Exp $	*/
/*	$NetBSD: pckbd.c,v 1.14 1996/12/05 01:39:30 cgd Exp $	*/

/*-
 * Copyright (c) 1993, 1994, 1995 Charles Hannum.  All rights reserved.
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz and Don Ahn.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pccons.c	5.11 (Berkeley) 5/21/91
 */

/*
 * code to work keyboard & display for PC-style console
 */

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#ifdef DDB
#include <ddb/db_var.h>
#endif

#include <machine/intr.h>
#include <machine/bus.h>

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>
#include <alpha/isa/pckbdreg.h>
#include <alpha/isa/spkrreg.h>
#include <alpha/isa/timerreg.h>
#include <machine/wsconsio.h>
#include <alpha/isa/pckbcvar.h>

#include <dev/wscons/wsconsvar.h>
#include <dev/wscons/kbd.h>
#include "wscons.h"

static volatile u_char ack, nak;	/* Don't ask. */
static u_char async, kernel, polling;	/* Really, you don't want to know. */
static u_char lock_state = 0x00,	/* all off */
	      old_lock_state = 0xff,
	      typematic_rate = 0xff,	/* don't update until set by user */
	      old_typematic_rate = 0xff;

bus_space_tag_t pckbd_iot;
isa_chipset_tag_t pckbd_ic;

bus_space_handle_t pckbd_ioh;
bus_space_handle_t pckbd_timer_ioh;
bus_space_handle_t pckbd_delay_ioh;

struct pckbd_softc {
        struct  device sc_dev;
        void    *sc_ih;

	int	sc_bellactive;		/* is the bell active? */
	int	sc_bellpitch;		/* last pitch programmed */
};

#ifdef __BROKEN_INDIRECT_CONFIG
int pckbdprobe __P((struct device *, void *, void *));
#else
int pckbdprobe __P((struct device *, struct cfdata *, void *));
#endif
void pckbdattach __P((struct device *, struct device *, void *));
int pckbdintr __P((void *));

struct cfattach pckbd_ca = {
	sizeof(struct pckbd_softc), pckbdprobe, pckbdattach,
};

struct cfdriver pckbd_cd = {
	NULL, "pckbd", DV_DULL,
};

int	pckbd_cngetc __P((struct device *));
void	pckbd_cnpollc __P((struct device *, int));
void	pckbd_bell __P((struct device *, struct wsconsio_bell_data *));
int	pckbd_ioctl __P((void *, u_long, caddr_t, int,
	    struct proc *));
char	*pckbd_translate __P((struct device *dev, int c));

#if NWSCONS
struct wscons_idev_spec pckbd_wscons_idev = {
	pckbd_cngetc,
	pckbd_cnpollc,
	pckbd_bell,
	pckbd_ioctl,
	pckbd_translate,
	0x7f,			/* key data mask */
	0x80,			/* key-up mask */
};
#endif

void	pckbd_bell_stop __P((void *));
static __inline int kbd_wait_output __P((void));
static __inline int kbd_wait_input __P((void));
static __inline void kbd_flush_input __P((void));
u_char	kbc_get8042cmd __P((void));
int	kbc_put8042cmd __P((u_char));
int	kbd_cmd __P((u_char, u_char));
void	do_async_update __P((void *));
void	async_update __P((void));

int kbd_cmd __P((u_char, u_char));
void do_async_update __P((void *));
void async_update __P((void));

/*
 * DANGER WIL ROBINSON -- the values of SCROLL, NUM, CAPS, and ALT are
 * important.
 */
#define	SCROLL		0x0001	/* stop output */
#define	NUM		0x0002	/* numeric shift  cursors vs. numeric */
#define	CAPS		0x0004	/* caps shift -- swaps case of letter */
#define	SHIFT		0x0008	/* keyboard shift */
#define	CTL		0x0010	/* control shift  -- allows ctl function */
#define	ASCII		0x0020	/* ascii code for this key */
#define	ALT		0x0080	/* alternate shift -- alternate chars */
#define	FUNC		0x0100	/* function key */
#define	KP		0x0200	/* Keypad keys */
#define	NONE		0x0400	/* no function */

#define	KBD_DELAY \
	do { \
		bus_space_read_1(pckbd_iot, pckbd_delay_ioh, 0); \
		bus_space_read_1(pckbd_iot, pckbd_delay_ioh, 0); \
		bus_space_read_1(pckbd_iot, pckbd_delay_ioh, 0); \
		bus_space_read_1(pckbd_iot, pckbd_delay_ioh, 0); \
		bus_space_read_1(pckbd_iot, pckbd_delay_ioh, 0); \
		bus_space_read_1(pckbd_iot, pckbd_delay_ioh, 0); \
		bus_space_read_1(pckbd_iot, pckbd_delay_ioh, 0); \
		bus_space_read_1(pckbd_iot, pckbd_delay_ioh, 0); \
	} while(0)

static __inline int
kbd_wait_output()
{
	u_int i;

	for (i = 100000; i; i--)
		if ((bus_space_read_1(pckbd_iot, pckbd_ioh, KBSTATP) & KBS_IBF)
		    == 0) {
			KBD_DELAY;
			return 1;
		}
	return 0;
}

static __inline int
kbd_wait_input()
{
	u_int i;

	for (i = 100000; i; i--)
		if ((bus_space_read_1(pckbd_iot, pckbd_ioh, KBSTATP) & KBS_DIB)
		    != 0) {
			KBD_DELAY;
			return 1;
		}
	return 0;
}

static __inline void
kbd_flush_input()
{
	u_int i;

	for (i = 10; i; i--) {
		if ((bus_space_read_1(pckbd_iot, pckbd_ioh, KBSTATP) & KBS_DIB)
		    == 0)
			return;
		KBD_DELAY;
		(void) bus_space_read_1(pckbd_iot, pckbd_ioh, KBDATAP);
	}
}

#if 1
/*
 * Get the current command byte.
 */
u_char
kbc_get8042cmd()
{

	if (!kbd_wait_output())
		return -1;
	bus_space_write_1(pckbd_iot, pckbd_ioh, KBCMDP, K_RDCMDBYTE);
	if (!kbd_wait_input())
		return -1;
	return bus_space_read_1(pckbd_iot, pckbd_ioh, KBDATAP);
}
#endif

/*
 * Pass command byte to keyboard controller (8042).
 */
int
kbc_put8042cmd(val)
	u_char val;
{

	if (!kbd_wait_output())
		return 0;
	bus_space_write_1(pckbd_iot, pckbd_ioh, KBCMDP, K_LDCMDBYTE);
	if (!kbd_wait_output())
		return 0;
	bus_space_write_1(pckbd_iot, pckbd_ioh, KBOUTP, val);
	return 1;
}

/*
 * Pass command to keyboard itself
 */
int
kbd_cmd(val, polling)
	u_char val;
	u_char polling;
{
	u_int retries = 3;
	register u_int i;

	do {
		if (!kbd_wait_output())
			return 0;
		ack = nak = 0;
		bus_space_write_1(pckbd_iot, pckbd_ioh, KBOUTP, val);
		if (polling)
			for (i = 100000; i; i--) {
				if (bus_space_read_1(pckbd_iot,
				    pckbd_ioh, KBSTATP) & KBS_DIB) {
					register u_char c;

					KBD_DELAY;
					c = bus_space_read_1(pckbd_iot,
					    pckbd_ioh, KBDATAP);
					if (c == KBR_ACK || c == KBR_ECHO) {
						ack = 1;
						return 1;
					}
					if (c == KBR_RESEND) {
						nak = 1;
						break;
					}
#ifdef DIAGNOSTIC
					printf("kbd_cmd: input char %x lost\n",
					    c);
#endif
				}
			}
		else
			for (i = 100000; i; i--) {
				(void) bus_space_read_1(pckbd_iot,
				    pckbd_ioh, KBSTATP);
				if (ack)
					return 1;
				if (nak)
					break;
			}
		if (!nak)
			return 0;
	} while (--retries);
	return 0;
}

/*
 * these are both bad jokes
 */
int
pckbdprobe(parent, match, aux)
	struct device *parent;
#ifdef __BROKEN_INDIRECT_CONFIG
	void *match;
#else
	struct cfdata *match;
#endif
	void *aux;
{
	struct pckbc_attach_args *pa = aux;
	u_int i, rv;

	if (pa->pa_slot != PCKBC_KBD_SLOT)
		return 0;

	rv = 0;

	pckbd_iot = pa->pa_iot;
	pckbd_ic = pa->pa_ic;
	pckbd_ioh = pa->pa_ioh;
	pckbd_timer_ioh = pa->pa_pit_ioh;
	pckbd_delay_ioh = pa->pa_delaybah;

	/* Enable interrupts and keyboard, etc. */
	if (!kbc_put8042cmd(CMDBYTE)) {
		printf("pcprobe: command error\n");
		goto lose;
	}

	rv = 1;			/* from here one out, we let it succeed */
#if 1
	/* Flush any garbage. */
	kbd_flush_input();
	/* Reset the keyboard. */
	if (!kbd_cmd(KBC_RESET, 1)) {
		printf("pcprobe: reset error %d\n", 1);
		goto lose;
	}
	for (i = 600000; i; i--)
		if ((bus_space_read_1(pckbd_iot, pckbd_ioh, KBSTATP) & KBS_DIB)
		    != 0) {
			KBD_DELAY;
			break;
		}
	if (i == 0 || bus_space_read_1(pckbd_iot, pckbd_ioh, KBDATAP)
	    != KBR_RSTDONE) {
		printf("pcprobe: reset error %d\n", 2);
		goto lose;
	}
	/*
	 * Some keyboards seem to leave a second ack byte after the reset.
	 * This is kind of stupid, but we account for them anyway by just
	 * flushing the buffer.
	 */
	kbd_flush_input();
	/* Just to be sure. */
	if (!kbd_cmd(KBC_ENABLE, 1)) {
		printf("pcprobe: reset error %d\n", 3);
		goto lose;
	}

	/*
	 * Some keyboard/8042 combinations do not seem to work if the keyboard
	 * is set to table 1; in fact, it would appear that some keyboards just
	 * ignore the command altogether.  So by default, we use the AT scan
	 * codes and have the 8042 translate them.  Unfortunately, this is
	 * known to not work on some PS/2 machines.  We try desparately to deal
	 * with this by checking the (lack of a) translate bit in the 8042 and
	 * attempting to set the keyboard to XT mode.  If this all fails, well,
	 * tough luck.
	 *
	 * XXX It would perhaps be a better choice to just use AT scan codes
	 * and not bother with this.
	 */
	if (kbc_get8042cmd() & KC8_TRANS) {
		/* The 8042 is translating for us; use AT codes. */
		if (!kbd_cmd(KBC_SETTABLE, 1) || !kbd_cmd(2, 1)) {
			printf("pcprobe: reset error %d\n", 4);
			goto lose;
		}
	} else {
		/* Stupid 8042; set keyboard to XT codes. */
		if (!kbd_cmd(KBC_SETTABLE, 1) || !kbd_cmd(1, 1)) {
			printf("pcprobe: reset error %d\n", 5);
			goto lose;
		}
	}

lose:
	/*
	 * Technically, we should probably fail the probe.  But we'll be nice
	 * and allow keyboard-less machines to boot with the console.
	 */
#endif

	return rv;
}

void
pckbdattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct pckbd_softc *sc = (void *)self;
	struct pckbc_attach_args *pa = aux;

	pckbd_iot = pa->pa_iot;
	pckbd_ic = pa->pa_ic;
	pckbd_ioh = pa->pa_ioh;
	pckbd_timer_ioh = pa->pa_pit_ioh;
	pckbd_delay_ioh = pa->pa_delaybah;

	sc->sc_ih = isa_intr_establish(pckbd_ic, 1, IST_EDGE, IPL_TTY,
	    pckbdintr, sc, sc->sc_dev.dv_xname);

	sc->sc_bellactive = sc->sc_bellpitch = 0;

#if NWSCONS
	printf("\n");
	kbdattach(self, &pckbd_wscons_idev);
#else
	printf(": no wscons driver present; no input possible\n");
#endif
}

/*
 * Got a console receive interrupt -
 * the console processor wants to give us a character.
 * Catch the character, and see who it goes to.
 */
int
pckbdintr(arg)
	void *arg;
{
	u_char data;
	static u_char last;

	if ((bus_space_read_1(pckbd_iot, pckbd_ioh, KBSTATP) & KBS_DIB) == 0)
		return 0;
	if (polling)
		return 1;
	do {
		KBD_DELAY;
		data = bus_space_read_1(pckbd_iot, pckbd_ioh, KBDATAP);

		switch (data) {
		case KBR_ACK:
			ack = 1;
			break;
		case KBR_RESEND:
			nak = 1;
			break;
		default:
			/* Always ignore typematic keys */
			if (data == last)
				break;
			last = data;
#if NWSCONS
			kbd_input(data);
#endif
			break;
		}
	} while (bus_space_read_1(pckbd_iot, pckbd_ioh, KBSTATP) & KBS_DIB);
	return 1;
}

void
do_async_update(v)
	void *v;
{
	u_long poll = (u_long)v;

	async = 0;

	if (lock_state != old_lock_state) {
		old_lock_state = lock_state;
		if (!kbd_cmd(KBC_MODEIND, poll) ||
		    !kbd_cmd(lock_state, poll)) {
			printf("pc: timeout updating leds\n");
			(void) kbd_cmd(KBC_ENABLE, poll);
		}
	}
	if (typematic_rate != old_typematic_rate) {
		old_typematic_rate = typematic_rate;
		if (!kbd_cmd(KBC_TYPEMATIC, poll) ||
		    !kbd_cmd(typematic_rate, poll)) {
			printf("pc: timeout updating typematic rate\n");
			(void) kbd_cmd(KBC_ENABLE, poll);
		}
	}
}

void
async_update()
{
	if (kernel || polling) {
		if (async)
			untimeout(do_async_update, NULL);
		do_async_update((void *)1);
	} else {
		if (async)
			return;
		async = 1;
		timeout(do_async_update, NULL, 1);
	}
}

int
pckbd_ioctl(v, cmd, data, flag, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{

	switch (cmd) {
	case WSCONSIO_KBD_GTYPE:
		*(int *)data = KBD_TYPE_PC;
		return 0;
	}
	return ENOTTY;
}

#if 0
int
pcioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	struct pc_softc *sc = pccd.cd_devs[PCUNIT(dev)];
	int error;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return error;
	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return error;

	switch (cmd) {
	case CONSOLE_X_MODE_ON:
		pc_xmode_on();
		return 0;
	case CONSOLE_X_MODE_OFF:
		pc_xmode_off();
		return 0;
	case CONSOLE_X_BELL:
		/*
		 * If set, data is a pointer to a length 2 array of
		 * integers.  data[0] is the pitch in Hz and data[1]
		 * is the duration in msec.
		 */
		if (data)
			sysbeep(((int*)data)[0],
				(((int*)data)[1] * hz) / 1000);
		else
			sysbeep(BEEP_FREQ, BEEP_TIME);
		return 0;
	case CONSOLE_SET_TYPEMATIC_RATE: {
 		u_char	rate;

 		if (!data)
			return EINVAL;
		rate = *((u_char *)data);
		/*
		 * Check that it isn't too big (which would cause it to be
		 * confused with a command).
		 */
		if (rate & 0x80)
			return EINVAL;
		typematic_rate = rate;
		async_update();
		return 0;
 	}
	default:
		return ENOTTY;
	}

#ifdef DIAGNOSTIC
	panic("pcioctl: impossible");
#endif
}
#endif

#define	CODE_SIZE	4		/* Use a max of 4 for now... */
typedef struct {
	u_short	type;
	char unshift[CODE_SIZE];
	char shift[CODE_SIZE];
	char ctl[CODE_SIZE];
} Scan_def;
static Scan_def	scan_codes[] = {
    {	NONE,	"",		"",		"",	 },	/* 0 unused */
    {	ASCII,	"\033",		"\033",		"\033",	 },	/* 1 ESCape */
    {	ASCII,	"1",		"!",		"!",	 },	/* 2 1 */
    {	ASCII,	"2",		"@@",		"\000",	 },	/* 3 2 */
    {	ASCII,	"3",		"#",		"#",	 },	/* 4 3 */
    {	ASCII,	"4",		"$",		"$",	 },	/* 5 4 */
    {	ASCII,	"5",		"%",		"%",	 },	/* 6 5 */
    {	ASCII,	"6",		"^",		"\036",	 },	/* 7 6 */
    {	ASCII,	"7",		"&",		"&",	 },	/* 8 7 */
    {	ASCII,	"8",		"*",		"\010",	 },	/* 9 8 */
    {	ASCII,	"9",		"(",		"(",	 },	/* 10 9 */
    {	ASCII,	"0",		")",		")",	 },	/* 11 0 */
    {	ASCII,	"-",		"_",		"\037",	 },	/* 12 - */
    {	ASCII,	"=",		"+",		"+",	 },	/* 13 = */
    {	ASCII,	"\177",		"\177",		"\010",	 },	/* 14 backspace */
    {	ASCII,	"\t",		"\177\t",	"\t",	 },	/* 15 tab */
    {	ASCII,	"q",		"Q",		"\021",	 },	/* 16 q */
    {	ASCII,	"w",		"W",		"\027",	 },	/* 17 w */
    {	ASCII,	"e",		"E",		"\005",	 },	/* 18 e */
    {	ASCII,	"r",		"R",		"\022",	 },	/* 19 r */
    {	ASCII,	"t",		"T",		"\024",	 },	/* 20 t */
    {	ASCII,	"y",		"Y",		"\031",	 },	/* 21 y */
    {	ASCII,	"u",		"U",		"\025",	 },	/* 22 u */
    {	ASCII,	"i",		"I",		"\011",	 },	/* 23 i */
    {	ASCII,	"o",		"O",		"\017",	 },	/* 24 o */
    {	ASCII,	"p",		"P",		"\020",	 },	/* 25 p */
    {	ASCII,	"[",		"{",		"\033",	 },	/* 26 [ */
    {	ASCII,	"]",		"}",		"\035",	 },	/* 27 ] */
    {	ASCII,	"\r",		"\r",		"\n",	 },	/* 28 return */
    {	CTL,	"",		"",		"",	 },	/* 29 control */
    {	ASCII,	"a",		"A",		"\001",	 },	/* 30 a */
    {	ASCII,	"s",		"S",		"\023",	 },	/* 31 s */
    {	ASCII,	"d",		"D",		"\004",	 },	/* 32 d */
    {	ASCII,	"f",		"F",		"\006",	 },	/* 33 f */
    {	ASCII,	"g",		"G",		"\007",	 },	/* 34 g */
    {	ASCII,	"h",		"H",		"\010",	 },	/* 35 h */
    {	ASCII,	"j",		"J",		"\n",	 },	/* 36 j */
    {	ASCII,	"k",		"K",		"\013",	 },	/* 37 k */
    {	ASCII,	"l",		"L",		"\014",	 },	/* 38 l */
    {	ASCII,	";",		":",		";",	 },	/* 39 ; */
    {	ASCII,	"'",		"\"",		"'",	 },	/* 40 ' */
    {	ASCII,	"`",		"~",		"`",	 },	/* 41 ` */
    {	SHIFT,	"",		"",		"",	 },	/* 42 shift */
    {	ASCII,	"\\",		"|",		"\034",	 },	/* 43 \ */
    {	ASCII,	"z",		"Z",		"\032",	 },	/* 44 z */
    {	ASCII,	"x",		"X",		"\030",	 },	/* 45 x */
    {	ASCII,	"c",		"C",		"\003",	 },	/* 46 c */
    {	ASCII,	"v",		"V",		"\026",	 },	/* 47 v */
    {	ASCII,	"b",		"B",		"\002",	 },	/* 48 b */
    {	ASCII,	"n",		"N",		"\016",	 },	/* 49 n */
    {	ASCII,	"m",		"M",		"\r",	 },	/* 50 m */
    {	ASCII,	",",		"<",		"<",	 },	/* 51 , */
    {	ASCII,	".",		">",		">",	 },	/* 52 . */
    {	ASCII,	"/",		"?",		"\037",	 },	/* 53 / */
    {	SHIFT,	"",		"",		"",	 },	/* 54 shift */
    {	KP,	"*",		"*",		"*",	 },	/* 55 kp * */
    {	ALT,	"",		"",		"",	 },	/* 56 alt */
    {	ASCII,	" ",		" ",		"\000",	 },	/* 57 space */
    {	CAPS,	"",		"",		"",	 },	/* 58 caps */
    {	FUNC,	"\033[M",	"\033[Y",	"\033[k", },	/* 59 f1 */
    {	FUNC,	"\033[N",	"\033[Z",	"\033[l", },	/* 60 f2 */
    {	FUNC,	"\033[O",	"\033[a",	"\033[m", },	/* 61 f3 */
    {	FUNC,	"\033[P",	"\033[b",	"\033[n", },	/* 62 f4 */
    {	FUNC,	"\033[Q",	"\033[c",	"\033[o", },	/* 63 f5 */
    {	FUNC,	"\033[R",	"\033[d",	"\033[p", },	/* 64 f6 */
    {	FUNC,	"\033[S",	"\033[e",	"\033[q", },	/* 65 f7 */
    {	FUNC,	"\033[T",	"\033[f",	"\033[r", },	/* 66 f8 */
    {	FUNC,	"\033[U",	"\033[g",	"\033[s", },	/* 67 f9 */
    {	FUNC,	"\033[V",	"\033[h",	"\033[t", },	/* 68 f10 */
    {	NUM,	"",		"",		"",	 },	/* 69 num lock */
    {	SCROLL,	"",		"",		"",	 },	/* 70 scroll lock */
    {	KP,	"7",		"\033[H",	"7",	 },	/* 71 kp 7 */
    {	KP,	"8",		"\033[A",	"8",	 },	/* 72 kp 8 */
    {	KP,	"9",		"\033[I",	"9",	 },	/* 73 kp 9 */
    {	KP,	"-",		"-",		"-",	 },	/* 74 kp - */
    {	KP,	"4",		"\033[D",	"4",	 },	/* 75 kp 4 */
    {	KP,	"5",		"\033[E",	"5",	 },	/* 76 kp 5 */
    {	KP,	"6",		"\033[C",	"6",	 },	/* 77 kp 6 */
    {	KP,	"+",		"+",		"+",	 },	/* 78 kp + */
    {	KP,	"1",		"\033[F",	"1",	 },	/* 79 kp 1 */
    {	KP,	"2",		"\033[B",	"2",	 },	/* 80 kp 2 */
    {	KP,	"3",		"\033[G",	"3",	 },	/* 81 kp 3 */
    {	KP,	"0",		"\033[L",	"0",	 },	/* 82 kp 0 */
    {	KP,	".",		"\177",		".",	 },	/* 83 kp . */
    {	NONE,	"",		"",		"",	 },	/* 84 0 */
    {	NONE,	"100",		"",		"",	 },	/* 85 0 */
    {	NONE,	"101",		"",		"",	 },	/* 86 0 */
    {	FUNC,	"\033[W",	"\033[i",	"\033[u", },	/* 87 f11 */
    {	FUNC,	"\033[X",	"\033[j",	"\033[v", },	/* 88 f12 */
    {	NONE,	"102",		"",		"",	 },	/* 89 0 */
    {	NONE,	"103",		"",		"",	 },	/* 90 0 */
    {	NONE,	"",		"",		"",	 },	/* 91 0 */
    {	NONE,	"",		"",		"",	 },	/* 92 0 */
    {	NONE,	"",		"",		"",	 },	/* 93 0 */
    {	NONE,	"",		"",		"",	 },	/* 94 0 */
    {	NONE,	"",		"",		"",	 },	/* 95 0 */
    {	NONE,	"",		"",		"",	 },	/* 96 0 */
    {	NONE,	"",		"",		"",	 },	/* 97 0 */
    {	NONE,	"",		"",		"",	 },	/* 98 0 */
    {	NONE,	"",		"",		"",	 },	/* 99 0 */
    {	NONE,	"",		"",		"",	 },	/* 100 */
    {	NONE,	"",		"",		"",	 },	/* 101 */
    {	NONE,	"",		"",		"",	 },	/* 102 */
    {	NONE,	"",		"",		"",	 },	/* 103 */
    {	NONE,	"",		"",		"",	 },	/* 104 */
    {	NONE,	"",		"",		"",	 },	/* 105 */
    {	NONE,	"",		"",		"",	 },	/* 106 */
    {	NONE,	"",		"",		"",	 },	/* 107 */
    {	NONE,	"",		"",		"",	 },	/* 108 */
    {	NONE,	"",		"",		"",	 },	/* 109 */
    {	NONE,	"",		"",		"",	 },	/* 110 */
    {	NONE,	"",		"",		"",	 },	/* 111 */
    {	NONE,	"",		"",		"",	 },	/* 112 */
    {	NONE,	"",		"",		"",	 },	/* 113 */
    {	NONE,	"",		"",		"",	 },	/* 114 */
    {	NONE,	"",		"",		"",	 },	/* 115 */
    {	NONE,	"",		"",		"",	 },	/* 116 */
    {	NONE,	"",		"",		"",	 },	/* 117 */
    {	NONE,	"",		"",		"",	 },	/* 118 */
    {	NONE,	"",		"",		"",	 },	/* 119 */
    {	NONE,	"",		"",		"",	 },	/* 120 */
    {	NONE,	"",		"",		"",	 },	/* 121 */
    {	NONE,	"",		"",		"",	 },	/* 122 */
    {	NONE,	"",		"",		"",	 },	/* 123 */
    {	NONE,	"",		"",		"",	 },	/* 124 */
    {	NONE,	"",		"",		"",	 },	/* 125 */
    {	NONE,	"",		"",		"",	 },	/* 126 */
    {	NONE,	"",		"",		"",	 },	/* 127 */
};
/*
 * Get characters from the keyboard.  If none are present, return NULL.
 */
char *
pckbd_translate(dev, c)
	struct device *dev;
	int c;
{
	u_char dt = c;
	static u_char extended = 0, shift_state = 0;
	static u_char capchar[2];

	if (dt == KBR_EXTENDED) {
		extended = 1;
		return (NULL);
	}

#ifdef DDB
	/*
	 * Check for cntl-alt-esc.
	 */
	if ((dt == 1) && (shift_state & (CTL | ALT)) == (CTL | ALT)) {
		if (db_console)
			Debugger();
		return (NULL);
	}
#endif

	/*
	 * Check for make/break.
	 */
	if (dt & 0x80) {
		/*
		 * break
		 */
		dt &= 0x7f;
		switch (scan_codes[dt].type) {
		case NUM:
			shift_state &= ~NUM;
			break;
		case CAPS:
			shift_state &= ~CAPS;
			break;
		case SCROLL:
			shift_state &= ~SCROLL;
			break;
		case SHIFT:
			shift_state &= ~SHIFT;
			break;
		case ALT:
			shift_state &= ~ALT;
			break;
		case CTL:
			shift_state &= ~CTL;
			break;
		}
	} else {
		/*
		 * make
		 */
		switch (scan_codes[dt].type) {
		/*
		 * locking keys
		 */
		case NUM:
			if (shift_state & NUM)
				break;
			shift_state |= NUM;
			lock_state ^= NUM;
			async_update();
			break;
		case CAPS:
			if (shift_state & CAPS)
				break;
			shift_state |= CAPS;
			lock_state ^= CAPS;
			async_update();
			break;
		case SCROLL:
			if (shift_state & SCROLL)
				break;
			shift_state |= SCROLL;
			lock_state ^= SCROLL;
			if ((lock_state & SCROLL) == 0)
				wakeup((caddr_t)&lock_state);
			async_update();
			break;
		/*
		 * non-locking keys
		 */
		case SHIFT:
			shift_state |= SHIFT;
			break;
		case ALT:
			shift_state |= ALT;
			break;
		case CTL:
			shift_state |= CTL;
			break;
		case ASCII:
			/* control has highest priority */
			if (shift_state & CTL)
				capchar[0] = scan_codes[dt].ctl[0];
			else if (shift_state & SHIFT)
				capchar[0] = scan_codes[dt].shift[0];
			else
				capchar[0] = scan_codes[dt].unshift[0];
			if ((lock_state & CAPS) && capchar[0] >= 'a' &&
			    capchar[0] <= 'z') {
				capchar[0] -= ('a' - 'A');
			}
			capchar[0] |= (shift_state & ALT);
			extended = 0;
			return capchar;
		case NONE:
			break;
		case FUNC: {
			char *more_chars;
			if (shift_state & SHIFT)
				more_chars = scan_codes[dt].shift;
			else if (shift_state & CTL)
				more_chars = scan_codes[dt].ctl;
			else
				more_chars = scan_codes[dt].unshift;
			extended = 0;
			return more_chars;
		}
		case KP: {
			char *more_chars;
			if (shift_state & (SHIFT | CTL) ||
			    (lock_state & NUM) == 0 || extended)
				more_chars = scan_codes[dt].shift;
			else
				more_chars = scan_codes[dt].unshift;
			extended = 0;
			return more_chars;
		}
		}
	}

	extended = 0;
	return (NULL);
}


/* ARGSUSED */
int
pckbd_cngetc(dev)
	struct device *dev;
{
        register char *cp = NULL;
	u_char data;
	static u_char last;

        do {
		/* wait for byte */
                while ((bus_space_read_1(pckbd_iot, pckbd_ioh, KBSTATP)
		    & KBS_DIB) == 0)
			KBD_DELAY;
		KBD_DELAY;

                data = bus_space_read_1(pckbd_iot, pckbd_ioh, KBDATAP);

                if (data == KBR_ACK) {
                        ack = 1;
                        continue;
		}
                if (data ==  KBR_RESEND) {
                        nak = 1;
                        continue;
		}

		/* Ignore typematic keys */
		if (data == last)
			continue;
		last = data;

		cp = pckbd_translate(NULL, data);
        } while (!cp);
        if (*cp == '\r')
                return '\n';
        return *cp;
}

void
pckbd_cnpollc(dev, on)
	struct device *dev;
        int on;
{
	struct pckbd_softc *sc = (struct pckbd_softc *)dev;

        polling = on;
        if (!on) {
                int s;

                /*
                 * If disabling polling on a device that's been configured,
                 * make sure there are no bytes left in the FIFO, holding up
                 * the interrupt line.  Otherwise we won't get any further
                 * interrupts.
                 */
		if (sc != 0) {
			s = spltty();
			pckbdintr(sc);
			splx(s);
		}
        }
}

void
pckbd_bell(dev, wbd)
	struct device *dev;
	struct wsconsio_bell_data *wbd;
{
	struct pckbd_softc *sc = (struct pckbd_softc *)dev;
	int pitch, period;
	int s;

	pitch = wbd->wbd_pitch;
	period = (wbd->wbd_period * hz) / 1000;
	/* XXX volume ignored */

	s = splhigh();
	if (sc->sc_bellactive)
		untimeout(pckbd_bell_stop, sc);
	splx(s);
	if (pitch == 0 || period == 0) {
		pckbd_bell_stop(sc);
		sc->sc_bellpitch = 0;
		return;
	}
	if (!sc->sc_bellactive || sc->sc_bellpitch != pitch) {
		s = splhigh();
		bus_space_write_1(pckbd_iot, pckbd_timer_ioh, TIMER_MODE,
		    TIMER_SEL2 | TIMER_16BIT | TIMER_SQWAVE);
		bus_space_write_1(pckbd_iot, pckbd_timer_ioh, TIMER_CNTR2,
		    TIMER_DIV(pitch) % 256);
		bus_space_write_1(pckbd_iot, pckbd_timer_ioh, TIMER_CNTR2,
		    TIMER_DIV(pitch) / 256);
		/* enable speaker */
		bus_space_write_1(pckbd_iot, pckbd_ioh, PITAUX_PORT,
	    	    bus_space_read_1(pckbd_iot, pckbd_ioh, PITAUX_PORT) |
		      PIT_SPKR);
		splx(s);
	}
	sc->sc_bellpitch = pitch;
	sc->sc_bellactive = 1;
	timeout(pckbd_bell_stop, sc, period);
}

void
pckbd_bell_stop(arg)
	void *arg;
{
	struct pckbd_softc *sc = arg;
	int s;

	/* disable bell */
	s = splhigh();
	bus_space_write_1(pckbd_iot, pckbd_ioh, PITAUX_PORT,
	    bus_space_read_1(pckbd_iot, pckbd_ioh, PITAUX_PORT) & ~PIT_SPKR);
	sc->sc_bellactive = 0;
	splx(s);
}
@


1.16
log
@Address the i8042 keyboard controller registers as offsets from IO_KBD; from
NetBSD. This will ease the pain when we bring in the pckbc MI keyboard
driver to be used for wscons/i386 and wscons/alpha.
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbd.c,v 1.15 1999/01/08 03:16:15 niklas Exp $	*/
@


1.15
log
@s/pcppi/pckbc/ due to conflict with "real" pcppi and as a step towards
sys/dev/pckbc.  Will probably still not coexist with pcppi but now alpha at
least configs.  I will come back here anyday and improve.
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbd.c,v 1.14 1998/02/05 22:57:51 deraadt Exp $	*/
a72 11

#undef KBDATAP
#undef KBOUTP
#undef KBSTATP
#undef KBCMDP
#undef PITAUX_PORT
#define	KBDATAP		0x0	/* kbd data port (I) */
#define	KBOUTP		0x0	/* kbd data port (O) */
#define	KBSTATP		0x4	/* kbd controller status port (I) */
#define	KBCMDP		0x4	/* kbd controller port (O) */
#define	PITAUX_PORT	0x1	/* port B of PPI */
@


1.15.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbd.c,v 1.15 1999/01/08 03:16:15 niklas Exp $	*/
@


1.14
log
@need db_var.h
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbd.c,v 1.13 1998/02/05 16:47:59 deraadt Exp $	*/
d68 1
a68 1
#include <alpha/isa/pcppivar.h>
d326 1
a326 1
	struct pcppi_attach_args *pa = aux;
d329 1
a329 1
	if (pa->pa_slot != PCPPI_KBD_SLOT)
d421 1
a421 1
	struct pcppi_attach_args *pa = aux;
@


1.13
log
@rename ddb.panic_ddb, and add ddb.console. Now you can stop console ddb entry
with a sysctl. There will be architectures and drivers that lack function,
and I trust the maintainers of those will forget to add the code..
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbd.c,v 1.12 1997/11/06 12:27:02 niklas Exp $	*/
d55 3
@


1.12
log
@Add some missing things for the MI vga driver.  Move wscons to an MI place as
well.  $OpenBSD$ tagging
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbd.c,v 1.11 1997/07/08 11:19:41 niklas Exp $	*/
d760 3
a762 3
	if ((dt == 1)
	    && (shift_state & (CTL | ALT)) == (CTL | ALT)) {
		Debugger();
@


1.11
log
@Prolong the delay, per pccons.c from the i386 port
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbd.c,v 1.10 1997/07/06 16:32:57 niklas Exp $	*/
d67 2
a68 2
#include <alpha/wscons/wsconsvar.h>
#include <alpha/wscons/kbd.h>
@


1.10
log
@Enter DDB via CTL+ALT+ESC + style nits
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbd.c,v 1.9 1997/01/24 19:57:26 niklas Exp $	*/
d170 4
@


1.9
log
@Sync with NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbd.c,v 1.8 1996/12/08 00:20:28 niklas Exp $	*/
d749 1
a749 1
		return NULL;
d752 11
d891 2
a892 2
                while ((bus_space_read_1(pckbd_iot, pckbd_ioh, KBSTATP) & KBS_DIB)
		    == 0)
@


1.8
log
@Merge to NetBSD 961107, i.e. mostly new bus.h
@
text
@d1 2
a2 2
/*	$OpenBSD: pckbd.c,v 1.7 1996/11/12 20:29:32 niklas Exp $	*/
/*	$NetBSD: pckbd.c,v 1.10 1996/10/23 04:12:20 cgd Exp $	*/
d65 1
d71 11
d92 1
a92 4
bus_space_handle_t pckbd_data_ioh;
#define	pckbd_out_ioh	pckbd_data_ioh
bus_space_handle_t pckbd_status_ioh;
#define	pckbd_cmd_ioh	pckbd_status_ioh
a93 1
bus_space_handle_t pckbd_pitaux_ioh;
d104 1
d106 3
d123 1
a123 1
int	pckbd_ioctl __P((struct device *, u_long, caddr_t, int,
a124 1

a139 1

d143 6
a148 2
u_char kbc_get8042cmd __P((void));
int kbc_put8042cmd __P((u_char));
d182 1
a182 1
		if ((bus_space_read_1(pckbd_iot, pckbd_status_ioh, 0) & KBS_IBF)
d196 1
a196 1
		if ((bus_space_read_1(pckbd_iot, pckbd_status_ioh, 0) & KBS_DIB)
d210 1
a210 1
		if ((bus_space_read_1(pckbd_iot, pckbd_status_ioh, 0) & KBS_DIB)
d214 1
a214 1
		(void) bus_space_read_1(pckbd_iot, pckbd_data_ioh, 0);
d228 1
a228 1
	bus_space_write_1(pckbd_iot, pckbd_cmd_ioh, 0, K_RDCMDBYTE);
d231 1
a231 1
	return bus_space_read_1(pckbd_iot, pckbd_data_ioh, 0);
d245 1
a245 1
	bus_space_write_1(pckbd_iot, pckbd_cmd_ioh, 0, K_LDCMDBYTE);
d248 1
a248 1
	bus_space_write_1(pckbd_iot, pckbd_out_ioh, 0, val);
d267 1
a267 1
		bus_space_write_1(pckbd_iot, pckbd_out_ioh, 0, val);
d271 1
a271 1
				    pckbd_status_ioh, 0) & KBS_DIB) {
d276 1
a276 1
					    pckbd_data_ioh, 0);
d294 1
a294 1
				    pckbd_status_ioh, 0);
d312 6
a317 1
	void *match, *aux;
d319 2
a320 2
	struct isa_attach_args *ia = aux;
	u_int i;
d322 2
a323 2
	pckbd_iot = ia->ia_iot;
	pckbd_ic = ia->ia_ic;
d325 1
a325 5
	if (bus_space_map(pckbd_iot, KBDATAP, 1, 0, &pckbd_data_ioh) ||
	    bus_space_map(pckbd_iot, KBSTATP, 1, 0, &pckbd_status_ioh) ||
	    bus_space_map(pckbd_iot, IO_TIMER1, 4, 0, &pckbd_timer_ioh) ||
	    bus_space_map(pckbd_iot, PITAUX_PORT, 1, 0, &pckbd_pitaux_ioh))
		return 0;
d327 5
a331 1
	pckbd_delay_ioh = ia->ia_delaybah;
d336 1
a336 1
		return 0;
d339 1
d349 1
a349 1
		if ((bus_space_read_1(pckbd_iot, pckbd_status_ioh, 0) & KBS_DIB)
d354 1
a354 1
	if (i == 0 || bus_space_read_1(pckbd_iot, pckbd_data_ioh, 0)
d405 1
a405 3
	ia->ia_iobase = 16;
	ia->ia_iosize = 0;
	return 1;
d414 1
a414 4
	struct isa_attach_args *ia = aux;

	pckbd_iot = ia->ia_iot;
	pckbd_ic = ia->ia_ic;
d416 5
a420 5
	if (bus_space_map(pckbd_iot, KBDATAP, 1, 0, &pckbd_data_ioh) ||
	    bus_space_map(pckbd_iot, KBSTATP, 1, 0, &pckbd_status_ioh) ||
	    bus_space_map(pckbd_iot, IO_TIMER1, 4, 0, &pckbd_timer_ioh) ||
	    bus_space_map(pckbd_iot, PITAUX_PORT, 1, 0, &pckbd_pitaux_ioh))
                panic("pckbdattach couldn't map");
d422 2
a423 4
	pckbd_delay_ioh = ia->ia_delaybah;

	sc->sc_ih = isa_intr_establish(pckbd_ic, ia->ia_irq, IST_EDGE,
	    IPL_TTY, pckbdintr, sc, sc->sc_dev.dv_xname);
d447 1
a447 1
	if ((bus_space_read_1(pckbd_iot, pckbd_status_ioh, 0) & KBS_DIB) == 0)
d453 1
a453 1
		data = bus_space_read_1(pckbd_iot, pckbd_data_ioh, 0);
d472 1
a472 1
	} while (bus_space_read_1(pckbd_iot, pckbd_status_ioh, 0) & KBS_DIB);
d477 2
a478 2
do_async_update(vp)
	void *vp;
d480 1
a480 1
	int poll = *(int *)vp;
a504 3
	static int nopoll = 0;
	static int poll = 1;

d507 2
a508 2
			untimeout(do_async_update, &nopoll);
		do_async_update(&poll);
d513 1
a513 1
		timeout(do_async_update, &nopoll, 1);
d518 2
a519 2
pckbd_ioctl(dev, cmd, data, flag, p)
	struct device *dev;
a604 1

d606 128
a733 128
	{ NONE,		"",		"",		"" },		/* 0 unused */
	{ ASCII,	"\033",		"\033",		"\033" },	/* 1 ESCape */
	{ ASCII,	"1",		"!",		"!" },		/* 2 1 */
	{ ASCII,	"2",		"@@",		"\000" },	/* 3 2 */
	{ ASCII,	"3",		"#",		"#" },		/* 4 3 */
	{ ASCII,	"4",		"$",		"$" },		/* 5 4 */
	{ ASCII,	"5",		"%",		"%" },		/* 6 5 */
	{ ASCII,	"6",		"^",		"\036" },	/* 7 6 */
	{ ASCII,	"7",		"&",		"&" },		/* 8 7 */
	{ ASCII,	"8",		"*",		"\010" },	/* 9 8 */
	{ ASCII,	"9",		"(",		"(" },		/* 10 9 */
	{ ASCII,	"0",		")",		")" },		/* 11 0 */
	{ ASCII,	"-",		"_",		"\037" },	/* 12 - */
	{ ASCII,	"=",		"+",		"+" },		/* 13 = */
	{ ASCII,	"\177",		"\177",		"\010" },	/* 14 backspace */
	{ ASCII,	"\t",		"\177\t",	"\t" },		/* 15 tab */
	{ ASCII,	"q",		"Q",		"\021" },	/* 16 q */
	{ ASCII,	"w",		"W",		"\027" },	/* 17 w */
	{ ASCII,	"e",		"E",		"\005" },	/* 18 e */
	{ ASCII,	"r",		"R",		"\022" },	/* 19 r */
	{ ASCII,	"t",		"T",		"\024" },	/* 20 t */
	{ ASCII,	"y",		"Y",		"\031" },	/* 21 y */
	{ ASCII,	"u",		"U",		"\025" },	/* 22 u */
	{ ASCII,	"i",		"I",		"\011" },	/* 23 i */
	{ ASCII,	"o",		"O",		"\017" },	/* 24 o */
	{ ASCII,	"p",		"P",		"\020" },	/* 25 p */
	{ ASCII,	"[",		"{",		"\033" },	/* 26 [ */
	{ ASCII,	"]",		"}",		"\035" },	/* 27 ] */
	{ ASCII,	"\r",		"\r",		"\n" },		/* 28 return */
	{ CTL,		"",		"",		"" },		/* 29 control */
	{ ASCII,	"a",		"A",		"\001" },	/* 30 a */
	{ ASCII,	"s",		"S",		"\023" },	/* 31 s */
	{ ASCII,	"d",		"D",		"\004" },	/* 32 d */
	{ ASCII,	"f",		"F",		"\006" },	/* 33 f */
	{ ASCII,	"g",		"G",		"\007" },	/* 34 g */
	{ ASCII,	"h",		"H",		"\010" },	/* 35 h */
	{ ASCII,	"j",		"J",		"\n" },		/* 36 j */
	{ ASCII,	"k",		"K",		"\013" },	/* 37 k */
	{ ASCII,	"l",		"L",		"\014" },	/* 38 l */
	{ ASCII,	";",		":",		";" },		/* 39 ; */
	{ ASCII,	"'",		"\"",		"'" },		/* 40 ' */
	{ ASCII,	"`",		"~",		"`" },		/* 41 ` */
	{ SHIFT,	"",		"",		"" },		/* 42 shift */
	{ ASCII,	"\\",		"|",		"\034" },	/* 43 \ */
	{ ASCII,	"z",		"Z",		"\032" },	/* 44 z */
	{ ASCII,	"x",		"X",		"\030" },	/* 45 x */
	{ ASCII,	"c",		"C",		"\003" },	/* 46 c */
	{ ASCII,	"v",		"V",		"\026" },	/* 47 v */
	{ ASCII,	"b",		"B",		"\002" },	/* 48 b */
	{ ASCII,	"n",		"N",		"\016" },	/* 49 n */
	{ ASCII,	"m",		"M",		"\r" },		/* 50 m */
	{ ASCII,	",",		"<",		"<" },		/* 51 , */
	{ ASCII,	".",		">",		">" },		/* 52 . */
	{ ASCII,	"/",		"?",		"\037" },	/* 53 / */
	{ SHIFT,	"",		"",		"" },		/* 54 shift */
	{ KP,		"*",		"*",		"*" },		/* 55 kp * */
	{ ALT,		"",		"",		"" },		/* 56 alt */
	{ ASCII,	" ",		" ",		"\000" },	/* 57 space */
	{ CAPS,		"",		"",		"" },		/* 58 caps */
	{ FUNC,		"\033[M",	"\033[Y",	"\033[k" },	/* 59 f1 */
	{ FUNC,		"\033[N",	"\033[Z",	"\033[l" },	/* 60 f2 */
	{ FUNC,		"\033[O",	"\033[a",	"\033[m" },	/* 61 f3 */
	{ FUNC,		"\033[P",	"\033[b",	"\033[n" },	/* 62 f4 */
	{ FUNC,		"\033[Q",	"\033[c",	"\033[o" },	/* 63 f5 */
	{ FUNC,		"\033[R",	"\033[d",	"\033[p" },	/* 64 f6 */
	{ FUNC,		"\033[S",	"\033[e",	"\033[q" },	/* 65 f7 */
	{ FUNC,		"\033[T",	"\033[f",	"\033[r" },	/* 66 f8 */
	{ FUNC,		"\033[U",	"\033[g",	"\033[s" },	/* 67 f9 */
	{ FUNC,		"\033[V",	"\033[h",	"\033[t" },	/* 68 f10 */
	{ NUM,		"",		"",		"" },		/* 69 num lock */
	{ SCROLL,	"",		"",		"" },		/* 70 scroll lock */
	{ KP,		"7",		"\033[H",	"7" },		/* 71 kp 7 */
	{ KP,		"8",		"\033[A",	"8" },		/* 72 kp 8 */
	{ KP,		"9",		"\033[I",	"9" },		/* 73 kp 9 */
	{ KP,		"-",		"-",		"-" },		/* 74 kp - */
	{ KP,		"4",		"\033[D",	"4" },		/* 75 kp 4 */
	{ KP,		"5",		"\033[E",	"5" },		/* 76 kp 5 */
	{ KP,		"6",		"\033[C",	"6" },		/* 77 kp 6 */
	{ KP,		"+",		"+",		"+" },		/* 78 kp + */
	{ KP,		"1",		"\033[F",	"1" },		/* 79 kp 1 */
	{ KP,		"2",		"\033[B",	"2" },		/* 80 kp 2 */
	{ KP,		"3",		"\033[G",	"3" },		/* 81 kp 3 */
	{ KP,		"0",		"\033[L",	"0" },		/* 82 kp 0 */
	{ KP,		".",		"\177",		"." },		/* 83 kp . */
	{ NONE,		"",		"",		"" },		/* 84 0 */
	{ NONE,		"100",		"",		"" },		/* 85 0 */
	{ NONE,		"101",		"",		"" },		/* 86 0 */
	{ FUNC,		"\033[W",	"\033[i",	"\033[u" },	/* 87 f11 */
	{ FUNC,		"\033[X",	"\033[j",	"\033[v" },	/* 88 f12 */
	{ NONE,		"102",		"",		"" },		/* 89 0 */
	{ NONE,		"103",		"",		"" },		/* 90 0 */
	{ NONE,		"",		"",		"" },		/* 91 0 */
	{ NONE,		"",		"",		"" },		/* 92 0 */
	{ NONE,		"",		"",		"" },		/* 93 0 */
	{ NONE,		"",		"",		"" },		/* 94 0 */
	{ NONE,		"",		"",		"" },		/* 95 0 */
	{ NONE,		"",		"",		"" },		/* 96 0 */
	{ NONE,		"",		"",		"" },		/* 97 0 */
	{ NONE,		"",		"",		"" },		/* 98 0 */
	{ NONE,		"",		"",		"" },		/* 99 0 */
	{ NONE,		"",		"",		"" },		/* 100 */
	{ NONE,		"",		"",		"" },		/* 101 */
	{ NONE,		"",		"",		"" },		/* 102 */
	{ NONE,		"",		"",		"" },		/* 103 */
	{ NONE,		"",		"",		"" },		/* 104 */
	{ NONE,		"",		"",		"" },		/* 105 */
	{ NONE,		"",		"",		"" },		/* 106 */
	{ NONE,		"",		"",		"" },		/* 107 */
	{ NONE,		"",		"",		"" },		/* 108 */
	{ NONE,		"",		"",		"" },		/* 109 */
	{ NONE,		"",		"",		"" },		/* 110 */
	{ NONE,		"",		"",		"" },		/* 111 */
	{ NONE,		"",		"",		"" },		/* 112 */
	{ NONE,		"",		"",		"" },		/* 113 */
	{ NONE,		"",		"",		"" },		/* 114 */
	{ NONE,		"",		"",		"" },		/* 115 */
	{ NONE,		"",		"",		"" },		/* 116 */
	{ NONE,		"",		"",		"" },		/* 117 */
	{ NONE,		"",		"",		"" },		/* 118 */
	{ NONE,		"",		"",		"" },		/* 119 */
	{ NONE,		"",		"",		"" },		/* 120 */
	{ NONE,		"",		"",		"" },		/* 121 */
	{ NONE,		"",		"",		"" },		/* 122 */
	{ NONE,		"",		"",		"" },		/* 123 */
	{ NONE,		"",		"",		"" },		/* 124 */
	{ NONE,		"",		"",		"" },		/* 125 */
	{ NONE,		"",		"",		"" },		/* 126 */
	{ NONE,		"",		"",		"" }		/* 127 */
a734 1

d874 1
a874 1
        register char *cp;
d880 1
a880 1
                while ((bus_space_read_1(pckbd_iot, pckbd_status_ioh, 0) & KBS_DIB)
d885 1
a885 1
                data = bus_space_read_1(pckbd_iot, pckbd_data_ioh, 0);
d964 2
a965 2
		bus_space_write_1(pckbd_iot, pckbd_pitaux_ioh, 0,
	    	    bus_space_read_1(pckbd_iot, pckbd_pitaux_ioh, 0) |
d983 2
a984 2
	bus_space_write_1(pckbd_iot, pckbd_pitaux_ioh, 0,
	    bus_space_read_1(pckbd_iot, pckbd_pitaux_ioh, 0) & ~PIT_SPKR);
@


1.7
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 2
a2 2
/*	$OpenBSD: pckbd.c,v 1.6 1996/10/30 22:39:40 niklas Exp $	*/
/*	$NetBSD: pckbd.c,v 1.9 1996/10/13 02:59:56 christos Exp $	*/
d57 1
a57 1
#include <machine/bus.old.h>
d77 1
a77 1
bus_chipset_tag_t pckbd_bc;
d80 1
a80 1
bus_io_handle_t pckbd_data_ioh;
d82 1
a82 1
bus_io_handle_t pckbd_status_ioh;
d84 3
a86 3
bus_io_handle_t pckbd_timer_ioh;
bus_io_handle_t pckbd_pitaux_ioh;
bus_io_handle_t pckbd_delay_ioh;
d156 4
a159 4
		bus_io_read_1(pckbd_bc, pckbd_delay_ioh, 0); \
		bus_io_read_1(pckbd_bc, pckbd_delay_ioh, 0); \
		bus_io_read_1(pckbd_bc, pckbd_delay_ioh, 0); \
		bus_io_read_1(pckbd_bc, pckbd_delay_ioh, 0); \
d168 1
a168 1
		if ((bus_io_read_1(pckbd_bc, pckbd_status_ioh, 0) & KBS_IBF)
d182 1
a182 1
		if ((bus_io_read_1(pckbd_bc, pckbd_status_ioh, 0) & KBS_DIB)
d196 1
a196 1
		if ((bus_io_read_1(pckbd_bc, pckbd_status_ioh, 0) & KBS_DIB)
d200 1
a200 1
		(void) bus_io_read_1(pckbd_bc, pckbd_data_ioh, 0);
d214 1
a214 1
	bus_io_write_1(pckbd_bc, pckbd_cmd_ioh, 0, K_RDCMDBYTE);
d217 1
a217 1
	return bus_io_read_1(pckbd_bc, pckbd_data_ioh, 0);
d231 1
a231 1
	bus_io_write_1(pckbd_bc, pckbd_cmd_ioh, 0, K_LDCMDBYTE);
d234 1
a234 1
	bus_io_write_1(pckbd_bc, pckbd_out_ioh, 0, val);
d253 1
a253 1
		bus_io_write_1(pckbd_bc, pckbd_out_ioh, 0, val);
d256 1
a256 1
				if (bus_io_read_1(pckbd_bc,
d261 1
a261 1
					c = bus_io_read_1(pckbd_bc,
d279 1
a279 1
				(void) bus_io_read_1(pckbd_bc,
d303 1
a303 1
	pckbd_bc = ia->ia_bc;
d306 4
a309 4
	if (bus_io_map(pckbd_bc, KBDATAP, 1, &pckbd_data_ioh) ||
	    bus_io_map(pckbd_bc, KBSTATP, 1, &pckbd_status_ioh) ||
	    bus_io_map(pckbd_bc, IO_TIMER1, 4, &pckbd_timer_ioh) ||
	    bus_io_map(pckbd_bc, PITAUX_PORT, 1, &pckbd_pitaux_ioh))
d312 1
a312 1
	pckbd_delay_ioh = ia->ia_delayioh;
d329 1
a329 1
		if ((bus_io_read_1(pckbd_bc, pckbd_status_ioh, 0) & KBS_DIB)
d334 1
a334 1
	if (i == 0 || bus_io_read_1(pckbd_bc, pckbd_data_ioh, 0)
d398 1
a398 1
	pckbd_bc = ia->ia_bc;
d401 4
a404 4
	if (bus_io_map(pckbd_bc, KBDATAP, 1, &pckbd_data_ioh) ||
	    bus_io_map(pckbd_bc, KBSTATP, 1, &pckbd_status_ioh) ||
	    bus_io_map(pckbd_bc, IO_TIMER1, 4, &pckbd_timer_ioh) ||
	    bus_io_map(pckbd_bc, PITAUX_PORT, 1, &pckbd_pitaux_ioh))
d407 1
a407 1
	pckbd_delay_ioh = ia->ia_delayioh;
d434 1
a434 1
	if ((bus_io_read_1(pckbd_bc, pckbd_status_ioh, 0) & KBS_DIB) == 0)
d440 1
a440 1
		data = bus_io_read_1(pckbd_bc, pckbd_data_ioh, 0);
d459 1
a459 1
	} while (bus_io_read_1(pckbd_bc, pckbd_status_ioh, 0) & KBS_DIB);
d872 1
a872 1
                while ((bus_io_read_1(pckbd_bc, pckbd_status_ioh, 0) & KBS_DIB)
d877 1
a877 1
                data = bus_io_read_1(pckbd_bc, pckbd_data_ioh, 0);
d949 1
a949 1
		bus_io_write_1(pckbd_bc, pckbd_timer_ioh, TIMER_MODE,
d951 1
a951 1
		bus_io_write_1(pckbd_bc, pckbd_timer_ioh, TIMER_CNTR2,
d953 1
a953 1
		bus_io_write_1(pckbd_bc, pckbd_timer_ioh, TIMER_CNTR2,
d956 2
a957 2
		bus_io_write_1(pckbd_bc, pckbd_pitaux_ioh, 0,
	    	    bus_io_read_1(pckbd_bc, pckbd_pitaux_ioh, 0) |
d975 2
a976 2
	bus_io_write_1(pckbd_bc, pckbd_pitaux_ioh, 0,
	    bus_io_read_1(pckbd_bc, pckbd_pitaux_ioh, 0) & ~PIT_SPKR);
@


1.6
log
@Merge to NetBSD 961020.  Retained our kernel APIs where NetBSD has changed.
-Wall -Wstrict-prototypes -Wmissing-prototypes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbd.c,v 1.9 1996/10/13 02:59:56 christos Exp $	*/
d57 1
a57 1
#include <machine/bus.h>
@


1.5
log
@Add OpenBSD tags.  Adapt to OpenBSD *_intr_establish calling convention
@
text
@d1 2
a2 2
/*	$OpenBSD: pckbd.c,v 1.7 1996/05/05 01:41:53 thorpej Exp $	*/
/*	$NetBSD: pckbd.c,v 1.7 1996/05/05 01:41:53 thorpej Exp $	*/
d67 1
d130 9
d155 6
a160 4
	{ u_char x = bus_io_read_1(pckbd_bc, pckbd_delay_ioh, 0); } \
	{ u_char x = bus_io_read_1(pckbd_bc, pckbd_delay_ioh, 0); } \
	{ u_char x = bus_io_read_1(pckbd_bc, pckbd_delay_ioh, 0); } \
	{ u_char x = bus_io_read_1(pckbd_bc, pckbd_delay_ioh, 0); }
d162 1
a162 1
static inline int
d176 1
a176 1
static inline int
d190 1
a190 1
static inline void
d208 1
a208 1
static u_char
d224 1
a224 1
static int
a430 1
	struct pckbd_softc *sc = arg;
d464 2
a465 2
do_async_update(poll)
	u_char poll;
d467 1
a467 2
	int pos;
	static int old_pos = -1;
d492 2
d497 2
a498 2
			untimeout(do_async_update, NULL);
		do_async_update(1);
d503 1
a503 1
		timeout(do_async_update, NULL, 1);
d597 128
a724 128
	NONE,	"",		"",		"",		/* 0 unused */
	ASCII,	"\033",		"\033",		"\033",		/* 1 ESCape */
	ASCII,	"1",		"!",		"!",		/* 2 1 */
	ASCII,	"2",		"@@",		"\000",		/* 3 2 */
	ASCII,	"3",		"#",		"#",		/* 4 3 */
	ASCII,	"4",		"$",		"$",		/* 5 4 */
	ASCII,	"5",		"%",		"%",		/* 6 5 */
	ASCII,	"6",		"^",		"\036",		/* 7 6 */
	ASCII,	"7",		"&",		"&",		/* 8 7 */
	ASCII,	"8",		"*",		"\010",		/* 9 8 */
	ASCII,	"9",		"(",		"(",		/* 10 9 */
	ASCII,	"0",		")",		")",		/* 11 0 */
	ASCII,	"-",		"_",		"\037",		/* 12 - */
	ASCII,	"=",		"+",		"+",		/* 13 = */
	ASCII,	"\177",		"\177",		"\010",		/* 14 backspace */
	ASCII,	"\t",		"\177\t",	"\t",		/* 15 tab */
	ASCII,	"q",		"Q",		"\021",		/* 16 q */
	ASCII,	"w",		"W",		"\027",		/* 17 w */
	ASCII,	"e",		"E",		"\005",		/* 18 e */
	ASCII,	"r",		"R",		"\022",		/* 19 r */
	ASCII,	"t",		"T",		"\024",		/* 20 t */
	ASCII,	"y",		"Y",		"\031",		/* 21 y */
	ASCII,	"u",		"U",		"\025",		/* 22 u */
	ASCII,	"i",		"I",		"\011",		/* 23 i */
	ASCII,	"o",		"O",		"\017",		/* 24 o */
	ASCII,	"p",		"P",		"\020",		/* 25 p */
	ASCII,	"[",		"{",		"\033",		/* 26 [ */
	ASCII,	"]",		"}",		"\035",		/* 27 ] */
	ASCII,	"\r",		"\r",		"\n",		/* 28 return */
	CTL,	"",		"",		"",		/* 29 control */
	ASCII,	"a",		"A",		"\001",		/* 30 a */
	ASCII,	"s",		"S",		"\023",		/* 31 s */
	ASCII,	"d",		"D",		"\004",		/* 32 d */
	ASCII,	"f",		"F",		"\006",		/* 33 f */
	ASCII,	"g",		"G",		"\007",		/* 34 g */
	ASCII,	"h",		"H",		"\010",		/* 35 h */
	ASCII,	"j",		"J",		"\n",		/* 36 j */
	ASCII,	"k",		"K",		"\013",		/* 37 k */
	ASCII,	"l",		"L",		"\014",		/* 38 l */
	ASCII,	";",		":",		";",		/* 39 ; */
	ASCII,	"'",		"\"",		"'",		/* 40 ' */
	ASCII,	"`",		"~",		"`",		/* 41 ` */
	SHIFT,	"",		"",		"",		/* 42 shift */
	ASCII,	"\\",		"|",		"\034",		/* 43 \ */
	ASCII,	"z",		"Z",		"\032",		/* 44 z */
	ASCII,	"x",		"X",		"\030",		/* 45 x */
	ASCII,	"c",		"C",		"\003",		/* 46 c */
	ASCII,	"v",		"V",		"\026",		/* 47 v */
	ASCII,	"b",		"B",		"\002",		/* 48 b */
	ASCII,	"n",		"N",		"\016",		/* 49 n */
	ASCII,	"m",		"M",		"\r",		/* 50 m */
	ASCII,	",",		"<",		"<",		/* 51 , */
	ASCII,	".",		">",		">",		/* 52 . */
	ASCII,	"/",		"?",		"\037",		/* 53 / */
	SHIFT,	"",		"",		"",		/* 54 shift */
	KP,	"*",		"*",		"*",		/* 55 kp * */
	ALT,	"",		"",		"",		/* 56 alt */
	ASCII,	" ",		" ",		"\000",		/* 57 space */
	CAPS,	"",		"",		"",		/* 58 caps */
	FUNC,	"\033[M",	"\033[Y",	"\033[k",	/* 59 f1 */
	FUNC,	"\033[N",	"\033[Z",	"\033[l",	/* 60 f2 */
	FUNC,	"\033[O",	"\033[a",	"\033[m",	/* 61 f3 */
	FUNC,	"\033[P",	"\033[b",	"\033[n",	/* 62 f4 */
	FUNC,	"\033[Q",	"\033[c",	"\033[o",	/* 63 f5 */
	FUNC,	"\033[R",	"\033[d",	"\033[p",	/* 64 f6 */
	FUNC,	"\033[S",	"\033[e",	"\033[q",	/* 65 f7 */
	FUNC,	"\033[T",	"\033[f",	"\033[r",	/* 66 f8 */
	FUNC,	"\033[U",	"\033[g",	"\033[s",	/* 67 f9 */
	FUNC,	"\033[V",	"\033[h",	"\033[t",	/* 68 f10 */
	NUM,	"",		"",		"",		/* 69 num lock */
	SCROLL,	"",		"",		"",		/* 70 scroll lock */
	KP,	"7",		"\033[H",	"7",		/* 71 kp 7 */
	KP,	"8",		"\033[A",	"8",		/* 72 kp 8 */
	KP,	"9",		"\033[I",	"9",		/* 73 kp 9 */
	KP,	"-",		"-",		"-",		/* 74 kp - */
	KP,	"4",		"\033[D",	"4",		/* 75 kp 4 */
	KP,	"5",		"\033[E",	"5",		/* 76 kp 5 */
	KP,	"6",		"\033[C",	"6",		/* 77 kp 6 */
	KP,	"+",		"+",		"+",		/* 78 kp + */
	KP,	"1",		"\033[F",	"1",		/* 79 kp 1 */
	KP,	"2",		"\033[B",	"2",		/* 80 kp 2 */
	KP,	"3",		"\033[G",	"3",		/* 81 kp 3 */
	KP,	"0",		"\033[L",	"0",		/* 82 kp 0 */
	KP,	".",		"\177",		".",		/* 83 kp . */
	NONE,	"",		"",		"",		/* 84 0 */
	NONE,	"100",		"",		"",		/* 85 0 */
	NONE,	"101",		"",		"",		/* 86 0 */
	FUNC,	"\033[W",	"\033[i",	"\033[u",	/* 87 f11 */
	FUNC,	"\033[X",	"\033[j",	"\033[v",	/* 88 f12 */
	NONE,	"102",		"",		"",		/* 89 0 */
	NONE,	"103",		"",		"",		/* 90 0 */
	NONE,	"",		"",		"",		/* 91 0 */
	NONE,	"",		"",		"",		/* 92 0 */
	NONE,	"",		"",		"",		/* 93 0 */
	NONE,	"",		"",		"",		/* 94 0 */
	NONE,	"",		"",		"",		/* 95 0 */
	NONE,	"",		"",		"",		/* 96 0 */
	NONE,	"",		"",		"",		/* 97 0 */
	NONE,	"",		"",		"",		/* 98 0 */
	NONE,	"",		"",		"",		/* 99 0 */
	NONE,	"",		"",		"",		/* 100 */
	NONE,	"",		"",		"",		/* 101 */
	NONE,	"",		"",		"",		/* 102 */
	NONE,	"",		"",		"",		/* 103 */
	NONE,	"",		"",		"",		/* 104 */
	NONE,	"",		"",		"",		/* 105 */
	NONE,	"",		"",		"",		/* 106 */
	NONE,	"",		"",		"",		/* 107 */
	NONE,	"",		"",		"",		/* 108 */
	NONE,	"",		"",		"",		/* 109 */
	NONE,	"",		"",		"",		/* 110 */
	NONE,	"",		"",		"",		/* 111 */
	NONE,	"",		"",		"",		/* 112 */
	NONE,	"",		"",		"",		/* 113 */
	NONE,	"",		"",		"",		/* 114 */
	NONE,	"",		"",		"",		/* 115 */
	NONE,	"",		"",		"",		/* 116 */
	NONE,	"",		"",		"",		/* 117 */
	NONE,	"",		"",		"",		/* 118 */
	NONE,	"",		"",		"",		/* 119 */
	NONE,	"",		"",		"",		/* 120 */
	NONE,	"",		"",		"",		/* 121 */
	NONE,	"",		"",		"",		/* 122 */
	NONE,	"",		"",		"",		/* 123 */
	NONE,	"",		"",		"",		/* 124 */
	NONE,	"",		"",		"",		/* 125 */
	NONE,	"",		"",		"",		/* 126 */
	NONE,	"",		"",		"",		/* 127 */
@


1.4
log
@sync to 0616, retaining local diffs
@
text
@d1 1
d398 1
a398 1
	    IPL_TTY, pckbdintr, sc);
@


1.3
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
@
text
@d1 1
a1 1
/*	$NetBSD: pckbd.c,v 1.3 1995/12/24 02:29:35 mycroft Exp $	*/
d55 2
a56 1
#include <machine/cpu.h>
d61 3
d65 2
a66 4
#include "wsc.h"
#if NWSC
#include <alpha/pci/wsconsvar.h>
#endif
d75 10
a84 4
__const struct isa_intr_fns *pckbd_intr_fns;			/* XXX */
void *pckbd_intr_arg;						/* XXX */
__const struct isa_pio_fns *pckbd_pio_fns;			/* XXX */
void *pckbd_pio_arg;						/* XXX */
d89 3
d98 2
a99 3
struct cfdriver pckbdcd = {
	NULL, "pckbd", pckbdprobe, pckbdattach, DV_DULL,
	    sizeof(struct pckbd_softc)
d102 25
a126 3
char *sget __P((void));
int pccngetc __P((void *));
void pccnpollc __P((void *, int));
d144 4
a147 4
	{ u_char x = INB(pckbd_pio_fns, pckbd_pio_arg, 0x84); } \
	{ u_char x = INB(pckbd_pio_fns, pckbd_pio_arg, 0x84); } \
	{ u_char x = INB(pckbd_pio_fns, pckbd_pio_arg, 0x84); } \
	{ u_char x = INB(pckbd_pio_fns, pckbd_pio_arg, 0x84); }
d155 1
a155 1
		if ((INB(pckbd_pio_fns, pckbd_pio_arg, KBSTATP) & KBS_IBF)
d169 1
a169 1
		if ((INB(pckbd_pio_fns, pckbd_pio_arg, KBSTATP) & KBS_DIB)
d183 1
a183 1
		if ((INB(pckbd_pio_fns, pckbd_pio_arg, KBSTATP) & KBS_DIB)
d187 1
a187 1
		(void) INB(pckbd_pio_fns, pckbd_pio_arg, KBDATAP);
d201 1
a201 1
	OUTB(pckbd_pio_fns, pckbd_pio_arg, KBCMDP, K_RDCMDBYTE);
d204 1
a204 1
	return INB(pckbd_pio_fns, pckbd_pio_arg, KBDATAP);
d218 1
a218 1
	OUTB(pckbd_pio_fns, pckbd_pio_arg, KBCMDP, K_LDCMDBYTE);
d221 1
a221 1
	OUTB(pckbd_pio_fns, pckbd_pio_arg, KBOUTP, val);
d240 1
a240 1
		OUTB(pckbd_pio_fns, pckbd_pio_arg, KBOUTP, val);
d243 2
a244 2
				if (INB(pckbd_pio_fns, pckbd_pio_arg,
				    KBSTATP) & KBS_DIB) {
d248 2
a249 2
					c = INB(pckbd_pio_fns, pckbd_pio_arg,
					    KBDATAP);
d266 2
a267 2
				(void) INB(pckbd_pio_fns, pckbd_pio_arg,
				    KBSTATP);
d287 1
a287 1
	struct isadev_attach_args *ida = aux;
d290 10
a299 2
	pckbd_pio_fns = ida->ida_piofns;			/* XXX */
	pckbd_pio_arg = ida->ida_pioarg;			/* XXX */
d316 1
a316 1
		if ((INB(pckbd_pio_fns, pckbd_pio_arg, KBSTATP) & KBS_DIB)
d321 1
a321 1
	if (i == 0 || INB(pckbd_pio_fns, pckbd_pio_arg, KBDATAP)
d372 2
a373 2
	ida->ida_nports[0] = 16;
	ida->ida_iosiz[0] = 0;
d383 10
a392 1
	struct isadev_attach_args *ida = aux;
d394 8
a401 8
	pckbd_intr_fns = ida->ida_intrfns;			/* XXX */
	pckbd_intr_arg = ida->ida_intrarg;			/* XXX */
	pckbd_pio_fns = ida->ida_piofns;			/* XXX */
	pckbd_pio_arg = ida->ida_pioarg;			/* XXX */
	
	sc->sc_ih = ISA_INTR_ESTABLISH(pckbd_intr_fns, pckbd_intr_arg,
	    ida->ida_irq[0], IST_EDGE, IPL_TTY, pckbdintr, sc);
#if NWSC
d403 1
a403 1
	wscattach_input(self, self, pccngetc, pccnpollc);
d405 1
a405 1
	printf(": no wsc driver; no input possible\n");
d419 2
a420 1
	u_char *cp;
d422 1
a422 1
	if ((INB(pckbd_pio_fns, pckbd_pio_arg, KBSTATP) & KBS_DIB) == 0)
d427 17
a443 4
		cp = sget();
#if NWSC
		if (cp)
			wscons_kbdinput(cp);
d445 3
a447 1
	} while (INB(pckbd_pio_fns, pckbd_pio_arg, KBSTATP) & KBS_DIB);
d494 17
d718 3
a720 1
sget()
d722 1
a722 1
	u_char dt;
d726 1
a726 71
top:
	KBD_DELAY;
	dt = INB(pckbd_pio_fns, pckbd_pio_arg, KBDATAP);

	switch (dt) {
	case KBR_ACK:
		ack = 1;
		goto loop;
	case KBR_RESEND:
		nak = 1;
		goto loop;
	}

#if 0
	if (pc_xmode > 0) {
#if defined(DDB) && defined(XSERVER_DDB)
		/* F12 enters the debugger while in X mode */
		if (dt == 88)
			Debugger();
#endif
		capchar[0] = dt;
		capchar[1] = 0;
		/*
		 * Check for locking keys.
		 *
		 * XXX Setting the LEDs this way is a bit bogus.  What if the
		 * keyboard has been remapped in X?
		 */
		switch (scan_codes[dt & 0x7f].type) {
		case NUM:
			if (dt & 0x80) {
				shift_state &= ~NUM;
				break;
			}
			if (shift_state & NUM)
				break;
			shift_state |= NUM;
			lock_state ^= NUM;
			async_update();
			break;
		case CAPS:
			if (dt & 0x80) {
				shift_state &= ~CAPS;
				break;
			}
			if (shift_state & CAPS)
				break;
			shift_state |= CAPS;
			lock_state ^= CAPS;
			async_update();
			break;
		case SCROLL:
			if (dt & 0x80) {
				shift_state &= ~SCROLL;
				break;
			}
			if (shift_state & SCROLL)
				break;
			shift_state |= SCROLL;
			lock_state ^= SCROLL;
			if ((lock_state & SCROLL) == 0)
				wakeup((caddr_t)&lock_state);
			async_update();
			break;
		}
		return capchar;
	}
#endif /* 0 */

	switch (dt) {
	case KBR_EXTENDED:
d728 1
a728 1
		goto loop;
a730 10
#ifdef DDB
	/*
	 * Check for cntl-alt-esc.
	 */
	if ((dt == 1) && (shift_state & (CTL | ALT)) == (CTL | ALT)) {
		Debugger();
		dt |= 0x80;	/* discard esc (ddb discarded ctl-alt) */
	}
#endif

d844 1
a844 4
loop:
	if ((INB(pckbd_pio_fns, pckbd_pio_arg, KBSTATP) & KBS_DIB) == 0)
		return 0;
	goto top;
d850 2
a851 2
pccngetc(cookie)
        void *cookie;
d854 20
d875 4
a878 4
#if 0
        if (pc_xmode > 0)
                return 0;
#endif
d880 1
a880 6
        do {
                /* wait for byte */
                while ((INB(pckbd_pio_fns, pckbd_pio_arg, KBSTATP) & KBS_DIB)
		    == 0);
                /* see if it's worthwhile */
                cp = sget();
d888 2
a889 2
pccnpollc(cookie, on)
        void *cookie;
d892 1
a892 1
	struct pckbd_softc *sc = cookie;
d910 56
@


1.2
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: pckbd.c,v 1.2 1995/11/23 02:37:06 cgd Exp $	*/
d351 1
a351 1
	    ida->ida_irq[0], ISA_IST_EDGE, ISA_IPL_TTY, pckbdintr, sc);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: pckbd.c,v 1.1 1995/08/03 00:48:25 cgd Exp $	*/
a55 1
#include <machine/pio.h>
d61 5
d73 5
d112 4
a115 4
	{ u_char x = inb(0x84); } \
	{ u_char x = inb(0x84); } \
	{ u_char x = inb(0x84); } \
	{ u_char x = inb(0x84); }
d123 2
a124 1
		if ((inb(KBSTATP) & KBS_IBF) == 0) {
d137 2
a138 1
		if ((inb(KBSTATP) & KBS_DIB) != 0) {
d151 2
a152 1
		if ((inb(KBSTATP) & KBS_DIB) == 0)
d155 1
a155 1
		(void) inb(KBDATAP);
d169 1
a169 1
	outb(KBCMDP, K_RDCMDBYTE);
d172 1
a172 1
	return inb(KBDATAP);
d186 1
a186 1
	outb(KBCMDP, K_LDCMDBYTE);
d189 1
a189 1
	outb(KBOUTP, val);
d208 1
a208 1
		outb(KBOUTP, val);
d211 2
a212 1
				if (inb(KBSTATP) & KBS_DIB) {
d216 2
a217 1
					c = inb(KBDATAP);
d227 2
a228 1
					printf("kbd_cmd: input char %x lost\n", c);
d234 2
a235 1
				(void) inb(KBSTATP);
d255 1
a255 1
	struct isa_attach_args *ia = aux;
d258 3
d276 2
a277 1
		if ((inb(KBSTATP) & KBS_DIB) != 0) {
d281 2
a282 1
	if (i == 0 || inb(KBDATAP) != KBR_RSTDONE) {
d332 2
a333 2
	ia->ia_iosize = 16;
	ia->ia_msize = 0;
d343 1
a343 1
	struct isa_attach_args *ia = aux;
d345 8
a353 2
	sc->sc_ih = isa_intr_establish(ia->ia_irq, ISA_IST_EDGE, ISA_IPL_TTY,
	    pckbdintr, sc);
d355 3
d372 1
a372 1
	if ((inb(KBSTATP) & KBS_DIB) == 0)
d378 1
d381 2
a382 1
	} while (inb(KBSTATP) & KBS_DIB);
d644 1
a644 1
	dt = inb(KBDATAP);
d841 1
a841 1
	if ((inb(KBSTATP) & KBS_DIB) == 0)
d861 2
a862 1
                while ((inb(KBSTATP) & KBS_DIB) == 0);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
